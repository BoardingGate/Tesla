=
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BoardingGate Lanzador</title>
    <link rel="icon" href="https://boardinggate.github.io/Tesla/th.jpeg" type="image/jpeg">
           <script src="//cdn.jsdelivr.net/npm/eruda"></script>
<script>eruda.init();</script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
    <!-- Leaflet-RotatedMarker plugin for rotating the user marker -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.js"></script>
    <!-- OSRM Leaflet Routing Machine -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" />
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
    <!-- Leaflet Geometry Util for snapping -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.geometryutil/0.9.3/leaflet.geometryutil.js"></script>
    
<style>
    body { display: flex; flex-direction: column; min-height: 100vh; background-color: #ABAB99; margin: 0; overflow-x: hidden; }
    body.dark-mode { background-color: #92927E; }
    main { position: relative; margin: 0 auto 0.5rem 60px; margin-top: 76px; background-color: transparent; border-radius: 0.75rem; padding: 16px; min-height: 400px; max-width: 984px; width: 100%; transition: margin-top 0.5s ease-in-out; position: relative; }
    footer { margin: 0.5rem auto; text-align: center; max-width: 984px; width: 100%; display: block; background-color: #ABAB99; margin-left: 145px; transition: margin-top 0.5s ease-in-out; }
    body.dark-mode footer { background-color: #92927E; }
    .footer-content { color: #5C5C47; padding: 0.5rem; margin: 0 auto; max-width: 100%; position: relative; }
    .footer-subtext { font-size: 0.75rem; color: #5C5C47; margin-top: 0.25rem; text-align: center; }
    .footer-link-green { color: #5C5C47; text-decoration: none; transition: color 0.2s ease; }
    .footer-link-green:hover { color: #5C5C47; }
    .footer-line { display: flex; justify-content: center; align-items: center; gap: 0.5rem; flex-wrap: wrap; }
    .hidden { display: none !important; }
    .footer-hidden { display: none !important; }
    .header-container { display: flex; align-items: center; justify-content: center; gap: 0.5rem; background-color: #ABAB99; padding: 0.5rem; }
    body.dark-mode .header-container { background-color: #92927E; }
    .header-logo { width: 100px; height: 70px; transition: filter 0.2s ease; }
    body.dark-mode .header-logo { filter: brightness(85%); }
    .title-container { background-color: #ABAB99; padding: 0.5rem 1rem; border-radius: 0.5rem; display: inline-block; }
    body.dark-mode .title-container { background-color: #92927E; }
    .header-container h1 { color: #5C5C47; }
    .version-text { font-size: 0.75rem; color: #5C5C47; font-weight: normal; }
    #bookmark-grid { display: grid; grid-template-columns: repeat(6, minmax(120px, 1fr)); gap: 15px; background-color: transparent; border-radius: 0.75rem; position: relative; width: 100%; max-width: 984px; margin: 0 auto 0 85px; transition: all 0.3s ease; }
    #bookmark-grid > div { height: auto; aspect-ratio: 16 / 9; transition: all 0.3s ease; }
    .bookmark-item { width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; border-radius: 0.5rem; transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease; box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1); position: relative; cursor: pointer; }
    .bookmark-item:hover:not(.editing-active *):not(.assignment-active *):not(.dragging *):not(.editing-target *):not(.keyword-assignment-active *) { transform: scale(1.05) translateY(-1px); box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.6), -6px -6-12px rgba(255, 255, 255, 0.15); }
    .bookmark-item img { image-rendering: crisp-edges; width: 36px; height: auto; max-width: 40px; border-radius: 0.25rem; }
    .bookmark-name { font-size: clamp(0.85rem, 1.5vw, 1.15rem); font-weight: bold; color: #333; text-align: center; margin-top: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; }
    body.dark-mode .bookmark-item { filter: brightness(60%); }
    .empty-slot { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; border: 1px dashed #ccc; border-radius: 0.5rem; background-color: rgba(200, 200, 200, 0.1); color: #aaa; transition: background-color 0.2s ease, outline 0.2s ease, box-shadow 0.2s ease; cursor: default; }
    .empty-slot span { font-size: 2rem; pointer-events: none; }
    body.dark-mode .empty-slot { border-color: #666; color: #777; background-color: rgba(100, 100, 100, 0.2); }
    .toggle-image, .toggle-sign { width: 135px; height: 74px; margin-bottom: 2px; box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.4); border: 1px solid #7c7c68; left: 10px; z-index: 1000; transition: background-color 0.2s ease, filter 0.2s ease, top 0.3s ease, border 0.2s ease; border-radius: 35px; align-items: center; justify-content: center; cursor: pointer; display: flex; position: fixed; top: 90px; background-color: #ABAB99; }
    .toggle-sign { font-weight: bold; font-size: 1.25rem; color: #000000; text-align: center; }
    .toggle-sign .sign { font-size: 1.5rem; margin-right: 2px; }
    .toggle-sign img, .toggle-image img { max-width: 70%; max-height: 70%; object-fit: contain; }
    .toggle-sign:not(.range-toggle):not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *):hover { background-color: #D9A066; }
    .toggle-sign.range-toggle:not([data-state="hidden"]):not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *):hover { background-color: #D9A066; }
    .toggle-image:hover { filter: brightness(80%); }
    .toggle-sign.range-toggle[data-state="hidden"] { background-color: #ABAB99; color: #7F7F7F; }
    body.dark-mode .toggle-sign.range-toggle[data-state="hidden"] { background-color: #ABAB99; color: #A0A0A0; }
    body.dark-mode .toggle-sign:not(.range-toggle):not(#password-toggle-button), body.dark-mode .toggle-image, body.dark-mode .toggle-sign.range-toggle:not([data-state="hidden"]) { filter: brightness(85%); background-color: #ABAB99; }
    body.dark-mode .toggle-sign:not(.range-toggle):hover:not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *), body.dark-mode .toggle-sign.range-toggle:not([data-state="hidden"]):hover:not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *) { background-color: #ABAB99; }
    .scroll-toggle-button { position: fixed; width: 110px !important; height: clamp(75px, 20vw, 130px) !important; background-color: #ABAB99; border-radius: 60px; display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: clamp(10px, 2vw, 20px); cursor: pointer; box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.4) !important; border: 1px solid #808080 !important; z-index: 1001; transition: background-color 0.2s ease; left: 10px; top: 10px; }
    .scroll-toggle-button:hover { background-color: #668B8B; }
    .scroll-toggle-button svg { width: clamp(24px, 4vw, 32px); height: clamp(24px, 4vw, 32px); stroke: #E6E6DC; }
    .arrow-button { width: clamp(36px, 6vw, 48px); height: clamp(36px, 6vw, 48px); background-color: #668B8B; border-radius: 50%; display: flex; align-items: right; justify-content: center; cursor: pointer; box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3); transition: background-color 0.2s ease; }
    .arrow-button:hover { background-color: #5C5C47; }
    .arrow-button svg { stroke: #E6E6DC; }
    #config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button,
    #password-toggle-button, #versions-button, #info-button {
        width: auto !important;
        height: auto !important;
        background-color: transparent !important;
        border: none !important;
        box-shadow: none !important;
        padding: 5px !important;
        position: absolute !important;
        top: 37px !important;
        z-index: 900 !important;
        cursor: pointer;
        border-radius: 50%;
        transition: transform 0.1s ease, background-color 0.2s ease, box-shadow 0.2s ease, border 0.2s ease;
    }
    #config-button { left: 185px !important; }
    #personal-button { left: 260px !important; }
    #radar-button { left: 330px !important; }
    #home-button { left: 400px !important; }
    #reload-button { left: 470px !important; }
    #keyword-assignment-button { left: 555px !important; }

    #password-toggle-button { left: 1080px !important; top: 25px; }
    #info-button { left: 1027px !important;max-width: 30px !important; max-height: 30px !important; }
    #versions-button { left: 969px !important; max-width: 30px !important; max-height: 30px !important; }

    #config-button img { max-width: 52px !important; max-height: 52px !important; width: 52px; height: 52px; object-fit: contain; display: block; filter: none !important; }
    #personal-button img, #radar-button img, #home-button img, #reload-button img, #keyword-assignment-button img {
        max-width: 46px !important;
        max-height: 46px !important;
        width: 46px;
        height: 46px;
        object-fit: contain;
        display: block;
        filter: none !important;
    }
    #versions-button img, #info-button img, #password-toggle-button img { max-width: 53px !important; max-height: 40px !important; width: 40px; height: 40px; object-fit: contain; display: block; }
    #password-toggle-button img { filter: brightness(85%) !important; top: 25px; }
    #versions-button img { transition: opacity 0.5s ease; }

    #config-button:hover, #personal-button:hover, #radar-button:hover, #home-button:hover, #reload-button:hover, #keyword-assignment-button:hover:not(.active),
    #password-toggle-button:hover, #versions-button:hover:not(.versions-icon-dimmed), #info-button:hover {
        transform: scale(1.1);
        background-color: rgba(255, 255, 255, 0.2);
    }
    #personal-button.editing { border: 3px solid yellow !important; box-shadow: 0 0 10px yellow !important; }
    #personal-button.assigning { border: 3px solid cyan !important; box-shadow: 0 0 10px cyan !important; }

    #keyword-assignment-button.active {
        border: 3px solid yellow !important;
        box-shadow: 0 0 10px yellow !important;
        transform: scale(1.05);
        background-color: transparent !important;
    }
    body.dark-mode #keyword-assignment-button.active {
         border-color: yellow !important;
         box-shadow: 0 0 10px yellow !important;
    }
    .keyword-assignment-active .grid-cell:hover:not(.editing-active *):not(.assignment-active *):not(.dragging *):not(.editing-target *):not(.keyword-assigned-highlight) {
        transform: scale(1.05) translateY(-1px);
        box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.6), -6px -6-12px rgba(255, 255, 255, 0.15);
        outline: 3px dashed #10B981;
        cursor: crosshair;
    }
     .keyword-assignment-active .grid-cell.editing-target {
        outline: 3px solid #10B981 !important;
        outline-offset: 1px;
        box-shadow: 0 0 8px #10B981;
    }
    .keyword-assignment-active .grid-cell.keyword-assigned-highlight {
        outline: 3px solid yellow !important;
        outline-offset: 1px;
        box-shadow: 0 0 8px yellow;
        cursor: crosshair;
    }


    #grid-filter-container { position: absolute; top: 43px; left: 615px; display: flex; align-items: center; z-index: 900; }
    #grid-filter-input { padding: 8px 12px; border: 1px solid #7c7c68; border-radius: 4px; font-size: 1.3rem; font-weight: bold; height: 45px; width: 160px; background-color: #f0f0e0; }
    body.dark-mode #grid-filter-input { background-color: #a0a090; color: #e0e0e0; border-color: #666; }
    #clear-filter-button { background: none; border: none; cursor: pointer; padding: 0 8px; margin-left: -35px; font-size: 1.6rem; color: #555; height: 40px; line-height: 40px; z-index: 901; display: none; }
    body.dark-mode #clear-filter-button { color: #bbb; }
    #user-id-display { position: absolute; top: -25px; right: -69px; font-weight: bold; font-size: 1.1rem; color: #5C5C47; padding: 4px 4px; background-color: rgba(171, 171, 153, 0.7); border-radius: 1px; z-index: 800; white-space: nowrap; text-align: right; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4); }
    body.dark-mode #user-id-display { color: #E6E6DC; background-color: rgba(146, 146, 126, 0.7); opacity: 0.7; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6); }
    .notices-icon-container { display: flex; align-items: center; justify-content: center; width: 100%; max-width: 984px; margin: 0 auto; margin-left: 165px; position: relative; transition: margin-top 0.5s ease-in-out; }
    .notices-container { flex-grow: 1; padding: 0.5rem; border: none; border-radius: 0.5rem; overflow: hidden; display: flex; align-items: center; justify-content: center; gap: 0; margin-left: 2px; height: 3rem; }
    .notice-wrapper { padding: 0.5rem; height: 1.5rem; flex-grow: 1; overflow: hidden; position: relative; display: flex; align-items: center; justify-content: center; }
    .notice { color: #E6E6DC; font-size: 1.3rem; font-weight: bold; white-space: nowrap; text-align: center; opacity: 0; animation: fadeInOut 14s infinite; }
    @keyframes fadeInOut { 0% { opacity: 1; } 10% { opacity: 1; } 90% { opacity: 1; } 100% { opacity: 0; } }
    .notice-off-icon { width: auto; height: clamp(2rem, 5vw, 3rem); margin-right: 10px; align-self: center; cursor: pointer; transition: filter 0.3s ease; }
    body.dark-mode .notice-off-icon { filter: brightness(85%); }
    #reminder-button { display: flex; flex-direction: column; justify-content: center; align-items: center; position: fixed; background-color: #ABAB99; }
    #reminder-button img { object-fit: contain; }
    #reminder-button .reminder-count { position: absolute; top: 6px; left: 8px; background-color: #EF4444; color: #FFFFFF; border-radius: 55%; padding: 4px 10px; font-size: 1.1rem; font-weight: bold; line-height: 1; display: flex; align-items: center; justify-content: center; z-index: 1500; min-width: 1.9rem; max-width: 2.5rem; text-align: center; }
    .reminder-count-globe { position: fixed; top: 10px; left: 10px; background-color: #2563EB; color: white; border-radius: 65%; padding: 10px 15px; font-size: 1.3rem; font-weight: bold; z-index: 1500; transition: margin-top 0.5s ease-in-out; }

    #unified-reminder-window {
        position: fixed;
        top: 35px;
        left: 180px;
        transform: none;
        background-color: #FFFF99;
        border-radius: 1.5rem;
        border: 2px solid #ABAB99;
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        z-index: 7000;
        max-width: 550px;
        width: 95%;
        max-height: 85vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        transition: opacity 0.3s ease-out, transform 0.3s ease-out;
    }

    #unified-reminder-window:not(.visible) {
        opacity: 0;
        transform: scale(0.9);
        pointer-events: none;
    }
    #unified-reminder-window.visible {
        opacity: 1;
        transform: scale(1);
        pointer-events: auto;
    }
    .reminder-count-header {
        padding: 0.8rem 1.5rem;
        text-align: center;
        font-weight: bold;
        color: #0000FF;
        border-bottom: 1px solid #ABAB99;
        flex-shrink: 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 0px 10px;
        position: relative;
    }
     .reminder-title-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex-grow: 1;
    }
    .reminder-title-container > span:first-child { font-size: 1.3rem; }
    .reminder-title-container .swipe-hint { font-size: smaller; }

    #reminder-swiper-container {
        display: flex;
        overflow-x: auto;
        scroll-snap-type: x mandatory;
        -webkit-overflow-scrolling: touch;
        scroll-behavior: smooth;
        flex-grow: 1;
        touch-action: pan-x;
    }
    .reminder-slide {
        flex: 0 0 100%;
        scroll-snap-align: start;
        padding: 1.5rem;
        box-sizing: border-box;
        display: flex;
        flex-direction: row;
        gap: 1rem;
        overflow-y: auto;
        align-items: flex-start;
        max-height: calc(85vh - 60px);
    }

    .reminder-slide-content {
        display: flex;
        flex-direction: column;
        flex-grow: 1;
        min-width: 0;
    }

    .reminder-slide .reminder-content-scrollable {
        max-height: 30vh;
        overflow-y: auto;
        margin-bottom: 1rem;
        word-wrap: break-word;
        overflow-wrap: break-word;
        text-align: left;
        padding-right: 5px;
        flex-grow: 1;
    }
    .reminder-slide .reminder-text { margin: 0 0 0.5rem 0; font-size: 1.6rem; font-weight: bold; color: #0000FF; }
    .reminder-slide .reminder-details { margin: 0.2rem 0; font-size: 1.15rem; font-weight: bold; color: #0000FF; }
    .reminder-slide .button-group {
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: 0.5rem;
        margin-top: auto;
        padding-top: 1rem;
        flex-shrink: 0;
    }
    .reminder-slide button { padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.9rem; width: 100%; }
    .reminder-slide button.cancel { background-color: #EF4444; color: #FFFFFF; font-weight: bold; height:70px; font-size: 1.2rem; order: 1; }
    .reminder-slide button.modify { background-color: #10B981; font-weight: bold; height:60px; font-size: 1.2rem; color: #FFFFFF; order: 5; }
    .reminder-slide button.postpone { background-color: #F59E0B; font-weight: bold; height:60px; font-size: 1.2rem; color: #FFFFFF; order: 3; }
    .reminder-slide button.adjust-time-0001 { background-color: #4F4F4F; color: #FFFFFF; font-weight: bold; height: 60px; font-size: 1.2rem; order: 2; margin-top: 0.5rem; }
    .reminder-slide button.cancel-cyclic { background-color: #8B0000; color: #FFFFFF; font-weight: bold; height: 60px; font-size: 1.2rem; order: 4; margin-top: 0.5rem; }

    .reminder-map-preview-container {
        flex-shrink: 0;
        width: 150px;
        display: flex;
        align-items: center;
        justify-content: center;
        align-self: stretch;
    }

    .reminder-map-preview {
        width: 100%;
        height: 100%;
        min-height: 100px;
        max-height: 25vh;
        border-radius: 0.5rem;
    }

    #hide-all-reminders-button {
        background: none;
        border: none;
        color: #0000FF;
        font-size: 1rem;
        font-weight: bold;
        cursor: pointer;
        padding: 0.2rem 0.5rem;
        position: absolute;
        right: 1rem;
        top: 50%;
        transform: translateY(-50%);
        z-index: 3001;
    }
    #hide-all-reminders-button:hover {
        text-decoration: underline;
    }

    .reminder-modal, .help-modal, .edit-info-modal, .choice-modal, .edit-modal, .reminder-table-modal, .postpone-options, .saved-locations-modal {
       z-index: 2000; background-color: #DAC8A0; padding: 1.0rem; border-radius: 0.3rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
    }
    .postpone-options { background-color: #F5E1A9 !important; z-index: 7500 !important; }

    .versions-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.85);
        display: flex;
        justify-content: center;
        align-items: flex-start;
        z-index: 5000;
        padding-top: 50px;
    }
    .versions-modal-content {
        background-color: #DAC8A0;
        padding: 1.5rem;
        border-radius: 0.5rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
        width: 85%;
        max-width: 900px;
        max-height: 85vh;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
    }
     .versions-modal-content h2 {
         font-size: 1.5rem;
         font-weight: bold;
         margin-bottom: 1rem;
         color: #111827;
         text-align: center;
     }
    .versions-modal-content pre {
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-wrap: break-word;
        font-size: 1rem;
        line-height: 1.4;
        color: #333;
        margin-bottom: 1.5rem;
        padding: 0.8rem;
        background-color: #f0f0e0;
        border-radius: 0.25rem;
        max-height: calc(85vh - 150px);
        overflow-y: auto;
    }
     .versions-modal-content button {
         display: block;
         width: 100%;
         padding: 0.75rem 1rem;
         border-radius: 0.25rem;
         cursor: pointer;
         font-size: 1.1rem;
         text-align: center;
         border: none;
         background-color: #2563EB;
         color: white;
         margin-top: 1rem;
     }
     .versions-modal-content button:hover {
         background-color: #1D4ED8;
     }

    .reminder-modal {
        position: fixed;
        top: 1%;
        left: 50%;
        transform: translate(-50%, 0);
        max-width: 96%;
        width: 95%;
        max-height: 95vh;
        overflow-y: auto;
        font-weight: bold;
        font-size: 1.3rem;
    }

.reminder-table-modal button.visto-prox {
    background-color: #EF4444;
    font-size: 0.9rem;
    color: #FFFFFF;
}

    .help-modal, .edit-info-modal { position: fixed; top: 1%; left: 50%; transform: translate(-50%, 1%); max-width: 910px; width: 98%; max-height: 96vh; overflow-y: auto; font-size: 1.10rem; z-index: 5500; }
    #reminders-map-help-modal-instance { z-index: 7000 !important; }

    .choice-modal { position: fixed; top: 1%; left: 50%; transform: translate(-50%, 1%); max-width: 540px; width: 95%; max-height: 98vh; overflow-y: auto; font-size: 1.10rem; z-index: 5500; }
    .reminder-table-modal { position: fixed; top: 30px; left: 35px; transform: translateY(0); max-width: 99%; width: 1090px; max-height: 90vh; overflow-y: auto; background-color: #E6D6A8; border-radius: 1.5rem; }
    .edit-modal { position: fixed; top: 5%; left: 50%; transform: translate(-50%, 0); width: 75%; max-width: 900px; border: 5px solid #A0522D; background-color: #EADDCA; z-index: 6000; }
    .modal h2, .modal h3 { font-weight: bold; margin-bottom: 1rem; color: #111827; }
    .reminder-modal h2, .help-modal h2, .edit-info-modal h2, .choice-modal h2, .edit-modal h2, .reminder-table-modal h2, .saved-locations-modal h2 { font-size: 1.5rem; }
    .reminder-modal label, .help-modal label, .edit-info-modal label, .choice-modal label, .edit-modal label, .saved-locations-modal label { display: block; margin-bottom: 0.25rem; font-weight: 500; color: #374151; font-size: 1.1rem; }
    .reminder-modal button, .help-modal button, .edit-info-modal button, .choice-modal button, .edit-modal button, .reminder-table-modal button, .versions-modal-content button, .saved-locations-modal button { padding: 0.75rem 1rem; border-radius: 0.25rem; cursor: pointer; font-size: 1.1rem; flex: 1; text-align: center; min-width: 100px; border: none; }
    .edit-info-modal #close-edit-info, .help-modal #close-help, #reminders-map-help-modal-instance #close-reminders-map-help-instance { background-color: #2563EB; color: white; }
    .edit-info-modal #close-edit-info:hover, .help-modal #close-help:hover, #reminders-map-help-modal-instance #close-reminders-map-help-instance:hover { background-color: #1D4ED8; }
    .reminder-modal textarea#reminder-text { width: 100%; padding: 0.5rem; margin-bottom: 0.3rem; border: 1px solid #D1D5DB; border-radius: 0.25rem; font-size: 1.4rem; font-weight: bold; text-transform: uppercase; }

    .reminder-modal input#reminder-time { max-width: 120px; width: auto; }
    .reminder-modal input#reminder-date { max-width: 160px; width: auto; }
    .reminder-modal input#reminder-interval { max-width: 100px; width: auto; }
    .reminder-modal input#reminder-radius { max-width: 120px; width: auto; }
    .reminder-modal input[type="text"], .reminder-modal input[type="number"] {
        padding: 0.5rem;
        margin-bottom: 0.3rem;
        border: 1px solid #D1D5DB;
        border-radius: 0.25rem;
        font-size: 1.5rem;
        text-align: center;
    }

    .reminder-modal .form-grid {
        display: grid;
        grid-template-columns: auto auto auto 1fr;
        gap: 1rem;
        align-items: end;
        margin-bottom: 1rem;
    }

    label[for="reminder-interval"] { line-height: 1.2; }


    .location-controls-group {
        grid-column: 4 / 5;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: flex-start;
        gap: 0.5rem;
        margin-top: 0;
    }
    .location-controls-group label { margin-bottom: 0; }
    .location-controls-group input[type="checkbox"] { margin-right: 0.2rem; }
    .location-controls-group label[for="reminder-radius"] { margin-left: 0; }

    #expand-map-button {
        padding: 0.3rem 0.6rem !important;
        font-size: 1.3rem !important;
        height: auto !important;
        flex-shrink: 0;
        background-color: #668B8B !important;
        color: white !important;
        border: none !important;
        border-radius: 0.25rem !important;
        min-width: unset !important;
        flex: unset !important;
        margin-left: 0.5rem;
    }
    #expand-map-button:hover { background-color: #5C5C47 !important; }

    #location-map-container {
        grid-column: 1 / -1;
        width: 100%;
        border: 1px solid #ccc;
        border-radius: 0.25rem;
        background-color: #eee;
        position: relative;
        margin-top: 0.5rem;
        display: none;
        transition: height 0.3s ease-in-out;
    }

    #location-map-container.preview {
        display: block !important;
        height: 65px;
    }

    #location-map-container.expanded {
        display: block !important;
        height: 360px;
    }


    #reduce-map-button, #locate-me-button {
        position: absolute;
        top: 5px;
        z-index: 1001;
        padding: 0.8rem 1rem;
        font-size: 1rem;
        font-weight: bold;
        background-color: rgba(255, 255, 255, 0.9);
        border: 1px solid #777;
        border-radius: 4px;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0,0,0,0.25);
        transition: background-color 0.2s ease;
    }
    #reduce-map-button:hover, #locate-me-button:hover {
        background-color: rgba(230, 230, 230, 0.95);
    }
    #reduce-map-button {
        right: 5px;
    }
    #locate-me-button {
        right: calc(5px + 135px + 15px);
    }

    .reminder-modal .full-width { grid-column: 1 / -1; }
    .reminder-modal .days-group { display: flex; gap: 1rem; flex-wrap: wrap; grid-column: 1 / -1; margin-top: 1rem; }
    .reminder-modal .days-group label { font-size: 1.1rem; flex: 0 0 auto; }
    .reminder-modal .button-group { display: flex; justify-content: space-between; gap: 1rem; flex-wrap: wrap; margin-top: 1.5rem; margin-bottom: 0.8rem; grid-column: 1 / -1; }

    .reminder-modal button[type="submit"] { background-color: #2563EB; height:70px; font-weight: bold; font-size: 1.5rem; color: #FFFFFF; display: flex; align-items: center; justify-content: center; gap: 0.6rem; }
    .reminder-modal button[type="submit"] span#countdown-save { font-size: 1.6rem; font-weight: bold; justify-content: right; color: #e6e6dc; }
    .reminder-modal button[type="button"] { background-color: #D1D5DB; color: #111827; }
    .speech-button { background-color: #668B8B; color: white; border: none; border-radius: 0.25rem; padding: 0.5rem; cursor: pointer; margin-left: 0.5rem; font-size: 1rem; vertical-align: top; }
    .speech-button:hover { background-color: #5C5C47; }
    .speech-status { font-size: 0.85rem; color: #ABAB99; margin-top: 0.1rem; min-height: 1em; }
    #auto-save-timer { color: #1E40AF; grid-column: 1 / -1; text-align: center; }


    .reminder-table-modal table { width: 100%; border-collapse: collapse; margin-bottom: 1rem; }
    .reminder-table-modal tbody tr { cursor: pointer; transition: background-color: 0.1s ease; }
    .reminder-table-modal tbody tr:hover { background-color: rgba(0, 0, 0, 0.05) !important; }
    .reminder-table-modal th, .reminder-table-modal td { padding: 0.5rem; border: 1px solid #1E3A8A; font-size: 1.1rem; text-align: center; vertical-align: middle; }
    .reminder-table-modal td.text-column { text-align: left; }
    .reminder-table-modal th { background-color: #E5E7EB; font-weight: bold; }
    .reminder-table-modal td.date-column { white-space: nowrap; }
    .reminder-table-modal td:first-child { display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 0.5rem; padding: 0.5rem 0.3rem; border: none; }
    .reminder-table-modal td:first-child button { padding: 0.6rem; font-size: 0.9rem; width: 90%; flex: 0 0 auto; margin: 0; height: 60px; min-height: unset; line-height: 1.2; display: flex; align-items: center; justify-content: center; }
    .reminder-table-modal button.modify { background-color: #10B981; font-size: 1rem; color: #000000; height: 60px; }
    .reminder-table-modal button.delete { background-color: #EF4444; font-size: 0.9rem; color: #FFFFFF; }
    .reminder-table-modal button.postpone { background-color: #F59E0B; font-size: 0.9rem; color: #FFFFFF; }
    .reminder-table-modal button.cancel-cyclic-table { background-color: #8B0000; font-size: 0.9rem; color: #FFFFFF; }
    .reminder-table-modal .button-group { display: flex; margin-top: 1rem; }
    .reminder-table-modal #close-reminders, .reminder-table-modal #close-reminders-top { padding-left: 3rem; padding-right: 3rem; background-color: #2563EB; color: white; padding: 0.75rem 3rem; border-radius: 0.5rem; font-size: 1.25rem; font-weight: bold; border: 2px solid #1E3A8A; cursor: pointer; transition: background-color 0.2s ease; display: inline-flex; align-items: center; }
    .reminder-table-modal #close-reminders:hover, .reminder-table-modal #close-reminders-top:hover { background-color: #1D4ED8; }
    .reminder-table-modal .top-button-container { display: flex; justify-content: flex-end; margin-bottom: 1rem; align-items: center; }
    .reminder-table-modal .top-button-container > div:first-child { margin-right: auto; }
    .button-countdown { margin-left: 8px; font-weight: bold; font-size: 1.1em; opacity: 0.85; }
    .choice-modal .personalization-options { display: flex; flex-direction: column; gap: 1rem; align-items: stretch; margin-bottom: 1.5rem; }
    .choice-modal .personalization-options button { font-weight: bold; width: 100%; }
    .choice-modal button.choice-edit { background-color: #ffc107; color: #333; }
    .choice-modal button.choice-assign { background-color: #17a2b8; color: white; }
    .choice-modal button.choice-help { background-color: #007bff; color: white; }
    .choice-modal button.choice-cancel { background-color: #6c757d; color: white; }
    .choice-modal .footer-buttons { display: flex; justify-content: center; gap: 1rem; margin-top: 1rem; }
    .choice-modal .footer-buttons button { flex: 0 1 auto; min-width: 120px; }
    .edit-modal h2 { font-size: 1.4rem; margin-bottom: 1rem; color: #333; font-weight: bold; text-align: center; }
    .edit-modal label { display: block; margin-bottom: 0.3rem; font-weight: 500; color: #444; font-size: 1rem; }
    .edit-modal input[type="text"], .edit-modal input[type="url"] { width: 100%; padding: 0.6rem; margin-bottom: 0.8rem; border: 1px solid #BDB7AB; border-radius: 0.25rem; font-size: 1rem; }
    .edit-modal .input-with-button { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.8rem; }
    .edit-modal .input-with-button input { flex-grow: 1; margin-bottom: 0; }
    .edit-modal .search-button { padding: 0.4rem 0.6rem; font-size: 0.8rem; background-color: #668B8B; color: white; border: none; border-radius: 0.25rem; cursor: pointer; line-height: 1; height: fit-content; }
    .edit-modal .search-button:hover { background-color: #5C5C47; }
    .edit-modal .button-group { display: flex; justify-content: space-between; gap: 1rem; margin-top: 1.5rem; margin-bottom: 1.2rem; flex-wrap: wrap; height: 40px}
    .edit-modal button { padding: 0.7rem 1rem; font-size: 1.3rem; border-radius: 0.25rem; cursor: pointer; border: none; flex: 1 1 auto; min-width: 90px; }
    .edit-modal button.save { background-color: #28a745; color: white; } .edit-modal button.save:hover { background-color: #218838; }
    .edit-modal button.cancel { background-color: #6c757d; color: white; } .edit-modal button.cancel:hover { background-color: #5a6268; }
    .edit-modal button.reset { background-color: #ffc107; color: #333; } .edit-modal button.reset:hover { background-color: #e0a800; }
    .edit-modal button.empty { background-color: #fd7e14; color: white; } .edit-modal button.empty:hover { background-color: #e66b04; }
    .editing-active .bookmark-item:hover, .editing-active .range-toggle:hover, .editing-active .empty-slot:hover { transform: none; box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1); outline: 3px solid yellow; cursor: crosshair; }
    .editing-active .grid-cell.editing-target, .editing-active .range-toggle.editing-target { outline: 3px solid yellow !important; outline-offset: 1px; box-shadow: 0 0 8px yellow; }
    .editing-active .grid-cell { cursor: grab; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
    .editing-active .grid-cell:active { cursor: grabbing; }
    .grid-cell.dragging { opacity: 0.4; border: 2px dashed #aaa; cursor: grabbing; transform: scale(0.95); z-index: 10; }
    .grid-cell.drag-over { border: 3px solid #3498db !important; background-color: rgba(52, 152, 219, 0.1); box-shadow: inset 0 0 10px rgba(52, 152, 219, 0.3); }
    .empty-slot.drag-over { border: 3px solid #3498db !important; background-color: rgba(52, 152, 219, 0.2); }
    .empty-slot.dragging { opacity: 0.4; border: 2px dashed #aaa !important; cursor: grabbing; }
    .assignment-active .range-toggle.assigning-selected { outline: 4px solid cyan; box-shadow: 0 0 12px cyan; transform: scale(1.03); }
    .assignment-active .range-toggle:not(.assigning-selected) { opacity: 0.7; cursor: pointer; }
    .assignment-active .grid-cell.assigned-to-current { outline: 3px solid cyan; box-shadow: inset 0 0 8px rgba(0, 255, 255, 0.6); background-color: hsla(180, 70%, 80%, 0.3); opacity: 1; }
    .assignment-active .grid-cell:not(.assigned-to-current) { opacity: 0.6; outline: 1px dashed #aaa; }
    .assignment-active .grid-cell { cursor: pointer; }
    body.dark-mode .assignment-active .grid-cell.assigned-to-current { box-shadow: inset 0 0 10px rgba(0, 200, 200, 0.7); background-color: hsla(180, 60%, 30%, 0.4); }
    body.dark-mode .assignment-active .grid-cell:not(.assigned-to-current) { opacity: 0.5; outline-color: #555; }
    #pin-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; justify-content: center; align-items: flex-start; z-index: 9998; }
    #pin-modal-content { background-color: #DAC8A0; padding: 2rem; border-radius: 0.75rem; box-shadow: 0 5px 20px rgba(0,0,0,0.4); text-align: center; border: 1px solid #A0522D; margin-top: 50px; }
    #pin-modal-content h2 { font-size: 1.5rem; font-weight: bold; color: #333; margin-bottom: 1.5rem; }
    #pin-modal-content label { display: block; font-size: 1.1rem; color: #444; margin-bottom: 0.8rem; }
    #pin-input { width: 150px; padding: 0.8rem; font-size: 1.8rem; text-align: center; border: 2px solid #A0522D; border-radius: 0.25rem; margin-bottom: 1.5rem; letter-spacing: 0.5em; background-color: #f0f0e0; }
    #pin-submit-button { padding: 0.8rem 2rem; font-size: 1.2rem; background-color: #28a745; color: white; border: none; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; }
    #pin-submit-button:hover { background-color: #218838; }
    #pin-error-message { color: #dc3545; font-weight: bold; margin-top: 1rem; min-height: 1.2em; }
    #config-modal { position: fixed; top: 15px; left: 50%; transform:translate(-50%, 0); background-color:#ECEFE8; padding:1.5rem; border-radius:.75rem; box-shadow:0 8px 16px rgba(0,0,0,.25); z-index:5000; max-width:1000px; width:95%; max-height:63vh; display:flex; flex-direction:column; }
    .config-tab-content{ max-height:calc(63vh - 120px); }
    .config-tab-button{padding:.7rem 1.2rem;cursor:pointer;border:1px solid #ccc;border-bottom:none;background-color:#e0e0d0;margin-right:.3rem;border-radius:.5rem .5rem 0 0;font-size:1rem;font-weight:500;color:#555;transition:background-color .2s ease,color .2s ease;outline:none;}
    .config-tab-button:hover{background-color:#d8d8c0;}
    .config-tab-button.active{background-color:#ECEFE8;border-color:#ccc;border-bottom:1px solid #ECEFE8;font-weight:bold;color:#2F4F4F;position:relative;top:1px;z-index:2;}
    .tab-buttons{margin-bottom:-1px;flex-shrink:0;border-bottom:1px solid #ccc;padding-left:1rem; display: flex; overflow-x: auto; }
    .tab-contents{flex-grow:1;overflow-y:auto;position:relative;z-index:1;border-top:none;min-height:200px;}
    .config-tab-content{display:none;padding:1.8rem;border:1px solid #ccc;border-top:none;border-radius:0 0 .5rem .5rem;background-color:#ECEFE8; }
    .config-tab-content.active{display:block;}
    #config-modal h2{font-size:1.6rem;margin-bottom:1.5rem;color:#2F4F4F;text-align:center;flex-shrink:0;}
    #config-modal h3{font-size:1.3rem;margin-bottom:.8rem;color:#4682B4;}
    #config-modal p,#config-modal label{font-size:1rem;line-height:1.5;color:#333;}#config-modal em{font-size:.85rem;}
    #config-modal button:not(.config-tab-button){font-size:1.05rem;padding:.8rem 1.5rem;}
    #config-modal textarea{font-size:.9rem;height:110px;width:100%;border:1px solid #ccc;border-radius:.25rem;padding:.5rem;resize:vertical;}
    #config-modal input[type=text],#config-modal input[type=number],#config-modal input[type=password]{font-size:1rem;padding:.6rem;width:100%;border:1px solid #ccc;border-radius:.25rem;}
    #config-modal .status-message{font-size:.9rem;min-height:1.1em;font-weight:500;text-align:center;margin-top:.5rem;}
    .user-data-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:1.2rem 1.8rem;align-items:start;margin-bottom:1rem;}
    .user-data-grid label{margin-bottom:.3rem;display:block;font-weight:500;}
    .user-data-grid .checkbox-container{grid-column:1 / -1;display:flex;align-items:center;gap:.5rem;justify-content:center;margin-top:.5rem;}
    .user-data-grid .checkbox-container input{width:1.2rem;height:1.2rem;}
    .user-data-grid .checkbox-container label{margin-bottom:0;}
    .user-buttons-container{display:flex;justify-content:space-around;gap:1.5rem;margin-top:1.5rem;margin-bottom:1rem;}
    .user-buttons-container button{border:none;border-radius:.25rem;cursor:pointer;flex-grow:1;}
    #config-user-status{min-height:1.2em;}
    .backup-restore-container{display:flex;gap:2.5rem;flex-wrap:wrap;}
    .backup-restore-container>div{flex:1;min-width:250px;}
    .backup-restore-container p{margin-bottom:1.2rem;}
    .backup-restore-container textarea{margin-bottom:1rem;background-color:#f9f9f9;}
    .backup-restore-container button{margin-bottom:1rem;border:none;border-radius:.25rem;cursor:pointer;width:100%;}
    #config-restore-grid-button{background-color:#ff8c00;color:white; margin-top: 10px;}
    .backup-restore-container .status-message{margin-top:.6rem;}
    .borrar-container h3{margin-bottom:.8rem;}
    .borrar-container p{margin-top:.6rem;}
    .borrar-container button{margin-top:1.5rem;border:none;border-radius:.25rem;cursor:pointer;width:100%;}
    .borrar-container button#config-clear-cache {background-color:#EF4444;color:white;}
    #config-close-modal{font-size:1.15rem;padding:.8rem 2.5rem;background-color:#6B7280;color:white;border:none;border-radius:.25rem;cursor:pointer;}
    .pin-config-section { border-top: 1px solid #ccc; margin-top: 2rem; padding-top: 1.5rem; }
    .pin-config-layout { display: grid; grid-template-columns: minmax(200px, 1fr) minmax(200px, 1fr); gap: 1rem 1.5rem; align-items: end; }
    .pin-config-layout .pin-input-group { grid-column: span 1; display: flex; flex-direction: column; }
    .pin-config-layout .pin-input-group label { margin-bottom: 0.3rem; }
    .pin-config-layout .pin-buttons-container { grid-column: 1 / 3; grid-row: 2; display: flex; justify-content: flex-start; gap: 1rem; margin-top: 0.5rem; }
    .pin-config-layout .pin-buttons-container button { flex-grow: 0; min-width: 120px; max-width: 180px; }
    .toast-notification { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 25px; border-radius: 25px; color: white; font-size: 1rem; font-weight: 500; z-index: 9999; opacity: 0; transition: opacity 0.4s ease-in-out, bottom 0.4s ease-in-out; box-shadow: 0 4px 10px rgba(0,0,0,0.2); text-align: center; min-width: 250px; max-width: 80%; }
    .toast-notification.show { opacity: 1; bottom: 40px; }
    .toast-success { background-color: #28a745; }
    .toast-error { background-color: #dc3545; }
    .toast-warning { background-color: #ffc107; color: #333; }
    .toast-info { background-color: #17a2b8; }
    .statcounter-container { display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 0.25rem; }
    .favicon-red { filter: hue-rotate(0deg) saturate(200%) brightness(80%); }
    .favicon-blue { filter: hue-rotate(200deg) saturate(150%) brightness(90%); }

    .leaflet-container {
        cursor: default !important;
    }
    #location-map-container.expanded .leaflet-container,
    #location-picker-map-container.expanded .leaflet-container,
    #locations-view .leaflet-container {
        cursor: crosshair !important;
    }
     #route-planning-view .leaflet-container {
         cursor: crosshair !important;
     }
     #navigation-view .leaflet-container { /* Added for navigation view */
         cursor: grab !important;
     }
    #navigation-view .leaflet-container:active { /* Added for navigation view */
         cursor: grabbing !important;
    }


    #location-map-container.expanded .leaflet-touch .leaflet-container,
    #location-picker-map-container.expanded .leaflet-touch .leaflet-container,
    #locations-view .leaflet-touch .leaflet-container {
        cursor: pointer !important;
    }
    #route-planning-view .leaflet-touch .leaflet-container {
         cursor: pointer !important;
    }
     #navigation-view .leaflet-touch .leaflet-container { /* Added for navigation view */
         cursor: grab !important;
     }


    .leaflet-control-zoom {
        display: block !important;
        margin-bottom: 5px;
    }
    #location-map-container:not(.expanded) .leaflet-control-zoom,
    #location-picker-map-container:not(.expanded) .leaflet-control-zoom {
        display: none !important;
    }
     #locations-view .leaflet-control-zoom {
         display: block !important; /* Ensure zoom controls are shown in the locations view */
     }
     #route-planning-view .leaflet-control-zoom {
          display: block !important; /* Ensure zoom controls are shown in the route planning view */
     }
      #navigation-view .leaflet-control-zoom { /* Added for navigation view */
         display: block !important; /* Ensure zoom controls are shown in the navigation view */
      }


     .leaflet-control-orientation-altitude {
        background-color: rgba(255, 255, 255, 0.65);
        padding: 4px 6px;
        border-radius: 3px;
        box-shadow: 0 1px 4px rgba(0,0,0,0.3);
        text-align: center;
        font-weight: bold;
        clear: both;
        margin-top: 5px;
        margin-left: 5px;
        transform-origin: top left;
        transform: scale(0.8);
     }
    #compass-rose-icon {
        width: 90px;
        height: 90px;
        display: block;
        margin: 0 auto 2px auto;
        transition: transform 0.3s ease-out;
    }
    #orientation-text {
        display: block;
        font-size: 2em;
        color: #333;
        line-height: 1.1;
        margin-bottom: 1px;
    }
    #altitude-display {
        display: block;
        font-size: 2em;
        color: #333;
        line-height: 1.1;
    }


    .saved-locations-modal {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background-color: #E6D6A8;
        padding: 1.5rem; border-radius: 1rem; box-shadow: 0 6px 15px rgba(0,0,0,0.3);
        z-index: 3500;
        max-width: 700px; width: 95%; max-height: 90vh;
        display: flex; flex-direction: column;
    }
    .saved-locations-modal h2 { font-size: 1.5rem; font-weight: bold; text-align: center; margin-bottom: 1rem; color: #333; }
    .saved-locations-modal #saved-locations-list { max-height: calc(90vh - 150px); overflow-y: auto; margin-bottom: 1rem; padding-right: 5px;} /* Adjusted max-height */
    .saved-locations-modal .location-slot { display: flex; align-items: center; margin-bottom: 0.75rem; gap: 0.5rem; }
    .saved-locations-modal .location-slot input[type="text"] { flex-grow: 1; padding: 0.5rem; border: 1px solid #ccc; border-radius: 0.25rem; font-size:1rem; }
    .saved-locations-modal .location-slot button.map-button { padding: 0.5rem 0.75rem; font-size: 0.9rem; background-color: #668B8B; color: white; border: none; border-radius: 0.25rem; cursor: pointer; flex-shrink:0; }
    .saved-locations-modal .location-slot button.map-button:hover { background-color: #5C5C47; }
    .saved-locations-modal .location-slot .coords-display { font-size: 0.8rem; color: #555; min-width: 120px; text-align: right; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .saved-locations-modal .button-group { display: flex; justify-content: space-around; margin-top: 1rem; flex-shrink:0; }
    .saved-locations-modal .button-group button { padding: 0.75rem 1.5rem; font-size: 1.1rem; border-radius: 0.25rem; cursor: pointer; border: none; }
    .saved-locations-modal #save-all-user-locations { background-color: #2563EB; color: white; }
    .saved-locations-modal #close-saved-locations-modal { background-color: #D1D5DB; color: #111827; }
    .saved-locations-modal .location-slot button.select-location-button {
        padding: 0.5rem 0.75rem; font-size: 0.9rem; background-color: #34D399;
        color: white; border: none; border-radius: 0.25rem; cursor: pointer; flex-shrink:0; margin-left: 5px;
    }
    .saved-locations-modal .location-slot button.select-location-button:hover { background-color: #10B981; }


    #location-picker-map-container {
        height: 300px; border: 1px solid #ccc; position: relative; margin-top: 1rem;
        border-radius: 0.25rem; background-color: #eee;
        display: none;
    }
     #location-picker-map-container.expanded {
        display: block !important;
    }
    #location-picker-map-container button {
        padding: 0.5rem 0.8rem; font-size: 0.9rem; font-weight: bold;
        background-color: rgba(255, 255, 255, 0.9); border: 1px solid #777;
        border-radius: 4px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.25);
        position: absolute; z-index:1001;
    }
    #picker-ok-map-button { top:5px; right:5px; }
    #picker-locate-me-button { top:5px; right: calc(5px + 90px + 10px); }

    #location-features-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-color: #E6D6A8;
        z-index: 6500;
        display: flex;
        flex-direction: column;
        padding: 10px;
        box-sizing: border-box;
    }

    #location-features-content-wrapper {
        background-color: #F0EFE4;
        width: 100%;
        height: 100%;
        border-radius: 0.75rem;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    #location-features-header {
        display: flex;
        align-items: center;
        padding: 0.8rem 1.2rem;
        border-bottom: 1px solid #D8CEC1;
        flex-shrink: 0;
        background-color: #EAE7DD;
        justify-content: space-between;
        gap: 10px; /* Space between buttons and title */
        flex-wrap: wrap; /* Allow wrapping on small screens */
    }

    #location-features-header .button-group {
        display: flex;
        gap: 0.8rem;
        flex-wrap: wrap; /* Allow buttons to wrap */
    }

    #location-features-header h2 {
        font-size: 1.3rem;
        font-weight: bold;
        color: #4A4A40;
        margin: 0;
        flex-grow: 1; /* Allow title to take available space */
        text-align: center;
        min-width: 150px; /* Ensure title doesn't collapse too much */
    }

    #locations-view, #route-planning-view, #navigation-view {
        flex-grow: 1;
        background-color: #E0E0E0;
        position: relative; /* Needed for absolute positioning of map divs */
        overflow: hidden; /* Prevent scrollbars */
    }

    #locations-map-div, #navigation-map-div {
         width: 100%;
         height: 100%;
    }

    #location-features-header .location-feature-button-action {
        padding: 0.8rem 1.2rem; /* Reduced padding */
        font-size: 1rem; /* Reduced font size */
        line-height: 1.2; /* Reduced line height */
        min-height: 3.5rem; /* Reduced min height */
        font-weight: bold;
        border-radius: 0.375rem;
        cursor: pointer;
        border: 1px solid transparent;
        color: white;
        transition: background-color 0.2s ease, opacity 0.2s ease;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        flex-shrink: 0; /* Prevent shrinking */
    }
    #location-features-header .location-feature-button-action:hover {
        opacity: 0.88;
    }

    #location-features-header #show-locations-view { background-color: #007bff; border-color: #0069d9; }
    #location-features-header #show-route-planning-view { background-color: #ff8c00; border-color: #cc7000; }
    #location-features-header #close-location-features-modal { background-color: #dc3545; border-color: #bd2130; }
    #location-features-header #add-radar-here { background-color: #F59E0B; border-color: #D97706; }
     #location-features-header #start-navigation-button { background-color: #28a745; border-color: #1e7e34; }
     #location-features-header #stop-navigation-button { background-color: #dc3545; border-color: #bd2130; }


    #locations-view .leaflet-control-container {
        z-index: 800; /* Ensure controls are above map but below header/dashboard */
    }

     #route-planning-controls {
         position: absolute;
         top: 10px;
         right: 10px;
         z-index: 1000;
         background-color: rgba(255, 255, 255, 0.9);
         padding: 10px;
         border-radius: 5px;
         box-shadow: 0 2px 5px rgba(0,0,0,0.2);
         display: flex;
         flex-direction: column;
         gap: 8px;
     }
    #route-planning-controls button {
         padding: 6px 10px;
         font-size: 0.9rem;
         cursor: pointer;
         border-radius: 4px;
         border: 1px solid #ccc;
         background-color: #eee;
         transition: background-color 0.2s ease;
     }
    #route-planning-controls button:hover {
         background-color: #ddd;
     }
    #route-planning-controls button#save-route-button { background-color: #2563EB; color: white; border-color: #1e4ed8; }
    #route-planning-controls button#save-route-button:hover { background-color: #1e4ed8; }
    #route-planning-controls button#load-route-button { background-color: #F59E0B; color: white; border-color: #d97706; }
    #route-planning-controls button#load-route-button:hover { background-color: #d97706; }
    #route-planning-controls button#clear-route-button { background-color: #EF4444; color: white; border-color: #dc2626; }
    #route-planning-controls button#clear-route-button:hover { background-color: #dc2626; }

     #route-points-list {
         position: absolute;
         top: 10px;
         left: 10px;
         z-index: 1000;
         background-color: rgba(255, 255, 255, 0.9);
         padding: 10px;
         border-radius: 5px;
         box-shadow: 0 2px 5px rgba(0,0,0,0.2);
         max-height: calc(100% - 100px); /* Adjust based on header/footer/dashboard */
         overflow-y: auto;
     }
    #route-points-list div {
         margin-bottom: 5px;
         padding: 5px;
         border-bottom: 1px solid #eee;
         display: flex;
         align-items: center;
         gap: 5px;
         cursor: grab;
     }
    #route-points-list div:last-child {
         border-bottom: none;
     }
    #route-points-list div span {
         font-size: 0.9rem;
     }
    #route-points-list .delete-point-button {
         font-size: 0.9rem;
         cursor: pointer;
         color: #dc3545;
         font-weight: bold;
         margin-left: auto;
         padding: 2px 4px;
         border: none;
         background: none;
     }

    /* Route Point Icon Styling */
     .route-point-icon {
         display: flex;
         align-items: center;
         justify-content: center;
         width: 30px; /* MINIMUM 30 PX */
         height: 30px; /* MINIMUM 30 PX */
         border-radius: 50%;
         color: white;
         font-weight: bold;
         font-size: 1rem;
         opacity: 0.5; /* TRANSPARENCIA 50% */
         box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
         line-height: 1;
     }
     .route-point-icon.start { background-color: green; }
     .route-point-icon.waypoint { background-color: orange; }
     .route-point-icon.end { background-color: blue; }
     .route-point-icon .delete-icon {
         position: absolute;
         top: -5px;
         right: -5px;
         width: 18px;
         height: 18px;
         background-color: rgba(255, 0, 0, 0.8);
         color: white;
         border-radius: 50%;
         font-size: 0.9rem;
         font-weight: bold;
         text-align: center;
         line-height: 18px;
         cursor: pointer;
         box-shadow: 1px 1px 3px rgba(0,0,0,0.4);
         display: flex;
         align-items: center;
         justify-content: center;
         z-index: 100; /* Ensure it's above the marker icon */
         opacity: 1; /* Keep delete icon opaque */
     }
    /* Ensure the parent marker div is positioned relative for the delete icon */
     .leaflet-marker-icon.route-point-icon-marker {
         position: relative;
     }


     /* Navigation Dashboard */
     #navigation-dashboard {
         position: absolute;
         bottom: 0;
         left: 0;
         width: 100%;
         background-color: rgba(255, 255, 255, 0.9);
         padding: 10px;
         box-sizing: border-box;
         z-index: 1000;
         display: flex;
         flex-direction: column;
         font-family: sans-serif;
     }

     #navigation-dashboard .instruction-area {
         display: flex;
         align-items: center;
         gap: 15px;
         margin-bottom: 10px;
     }
     #navigation-dashboard .instruction-icon {
         width: 40px;
         height: 40px;
         background-color: #ddd; /* Placeholder */
         border-radius: 5px;
         flex-shrink: 0;
     }
     #navigation-dashboard .instruction-text {
         font-size: 1.2rem;
         font-weight: bold;
         color: #333;
         flex-grow: 1;
     }

     #navigation-dashboard .next-maneuver-area {
         display: flex;
         align-items: center;
         gap: 15px;
         margin-bottom: 10px;
     }
     #navigation-dashboard .next-maneuver-distance {
         font-size: 1.5rem;
         font-weight: bold;
         color: #007bff;
         flex-shrink: 0;
         min-width: 80px;
         text-align: right;
     }
    #navigation-dashboard .next-maneuver-progress {
         flex-grow: 1;
         height: 15px;
         background-color: #e0e0e0;
         border-radius: 7.5px;
         overflow: hidden;
     }
    #navigation-dashboard .next-maneuver-progress-fill {
         height: 100%;
         background-color: #28a745;
         width: 0%;
         transition: width 0.5s linear;
     }


    #navigation-dashboard .overall-progress-area {
         margin-bottom: 10px;
     }
     #navigation-dashboard .overall-progress-bar {
         width: 100%;
         height: 15px;
         background-color: #e0e0e0;
         border-radius: 7.5px;
         overflow: hidden;
         position: relative;
     }
     #navigation-dashboard .overall-progress-fill {
         height: 100%;
         background-color: #17a2b8;
         width: 0%;
         transition: width 0.5s linear;
     }
     #navigation-dashboard .waypoint-marker {
         position: absolute;
         top: 0;
         bottom: 0;
         width: 6px;
         background-color: blue;
         z-index: 1;
         border-radius: 3px;
     }

     #navigation-dashboard .summary-area {
         display: flex;
         justify-content: space-around;
         font-size: 1rem;
         color: #555;
     }
     #navigation-dashboard .summary-item strong {
         font-weight: bold;
         color: #333;
     }

     /* Route Line Styling */
     .leaflet-routing-path {
         stroke: #007bff;
         stroke-opacity: 0.7;
         stroke-width: 5;
     }
     .leaflet-routing-alt {
         stroke: #999;
         stroke-opacity: 0.5;
         stroke-width: 3;
     }


</style>
</head>
<body class="min-h-screen bg-[#ABAB99] flex flex-col items-center p-6">

    <div class="reminder-count-globe" id="reminder-count-globe" style="display: none;"></div>

    <div id="unified-reminder-window" role="alertdialog" aria-labelledby="reminder-window-title" aria-describedby="reminder-window-desc">
        <div class="reminder-count-header" id="reminder-window-title">
            <div class="reminder-title-container">
                <span style="font-size: 1.3rem;" id="reminder-count-text-container">
                    <span id="current-reminder-index">1</span> de <span id="total-reminder-count">X</span> Recordatorios
                </span>
                <span class="swipe-hint" id="reminder-swipe-hint" style="font-size: smaller;">
                    (deslice lateralmente)
                </span>
            </div>
            <button id="hide-all-reminders-button" title="Posponer 1 minuto todos los recordatorios visibles">OCULTAR</button>
        </div>
        <div id="reminder-swiper-container" aria-live="polite">
        </div>
        <span id="reminder-window-desc" class="hidden">Deslice para ver los recordatorios vencidos. Use los botones para gestionar cada recordatorio.</span>
    </div>

    <div id="grid-filter-container">
        <input type="text" id="grid-filter-input" placeholder="Filtrar grid...">
        <button id="clear-filter-button" title="Limpiar filtro">×</button>
    </div>

<main>
    <div id="user-id-display"></div>
    <div id="bookmark-grid">
    </div>
</main>

<div class="notices-icon-container">
    <img src="https://boardinggate.github.io/Tesla/IMG_4194.jpg" alt="Toggle Avisos" class="notice-off-icon" id="notice-toggle-icon">
    <div class="notices-container">
        <div class="notice-wrapper">
            <span class="notice" id="current-notice"></span>
        </div>
    </div>
</div>

<footer>
    <div class="footer-content">
        <div class="header-container">
            <img src="https://boardinggate.github.io/Tesla/LOGOTESLA.jpg" class="header-logo">
            <div class="title-container">
                <h1 class="text-2xl font-bold inline">
                    <span class="text-2xl">BoardingGate</span>
                    <span class="text-base">Lanzador</span>
                    <span id="version" class="version-text"></span>
                </h1>
            </div>
        </div>
        <div class="footer-line">
            <a href="https://x.com/boardinggate?s=21" class="footer-link-green" target="_blank" rel="noopener noreferrer">@BoardingGate</a>
            <span class="text-green-200" style="font-size: 1.5rem;">🤝</span>
            <a href="https://x.com/boardinggate/status/1857325553742721116?s=46" class="footer-link-green" target="_blank" rel="noopener noreferrer">Ahorremos un dinero con mis REFERIDOS</a>
        </div>

        <div class="statcounter-container">
          <div style="display: inline-flex; align-items: center; gap: 10px;">
            <script type="text/javascript">
              var sc_project=13126275;
              var sc_invisible=0;
              var sc_security="0fc568cc";
              var scJsHost = "https://";
              document.write("<sc"+"ript type='text/javascript' src='" +
              scJsHost+
              "statcounter.com/counter/counter.js'>"+"<"+"/script>");
            </script>
            <noscript><div class="statcounter"><a title="Web Analytics"
            href="https://statcounter.com/" target="_blank"><img
            class="statcounter"
            src="https://c.statcounter.com/13126275/0/0fc568cc/0/"
            alt="Web Analytics"
            referrerPolicy="no-referrer-when-downgrade"></a></div></noscript>
            <a href="https://statcounter.com/p13126275/?guest=1" class="footer-subtext">Legionarios de Elon</a>
          </div>
        </div>

        <p class="footer-subtext">La inteligencia tiene ciertos limites. La locura, casi ninguno 🫶 🤟</p>
    </div>
</footer>

<div id="pin-modal-overlay" class="hidden">
    <div id="pin-modal-content">
        <h2>Introducir Clave de Acceso</h2>
        <label for="pin-input">Clave (4 cifras):</label>
        <input type="password" id="pin-input" maxlength="4" pattern="\d{4}" inputmode="numeric" required>
        <br>
        <button id="pin-submit-button">Entrar</button>
        <p id="pin-error-message"></p>
    </div>
</div>

<div id="versions-modal-overlay" class="versions-modal-overlay hidden">
    <div class="versions-modal-content">
        <h2>Histórico de versiones y recomendaciones</h2>
        <pre id="versions-content">Cargando...</pre>
        <button id="close-versions-modal">Salir</button>
    </div>
</div>


<div id="scroll-toggle" class="scroll-toggle-button" title="Ir al inicio o fin">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M19 12l-7 7-7-7"/></svg>
</div>

<!-- Location Features Modal (Radares/Locations Map & Route Planning/Navigation) -->
<div id="location-features-modal" class="hidden">
    <div id="location-features-content-wrapper">
        <div id="location-features-header">
            <div class="button-group">
                 <button id="close-location-features-modal" class="location-feature-button-action" title="Cerrar mapa">SALIR</button>
                 <button id="show-locations-view" class="location-feature-button-action" title="Ver mapa con recordatorios de ubicación">VER UBICACIONES</button>
                 <button id="show-route-planning-view" class="location-feature-button-action" title="Planificar y navegar una ruta">PLANIFICAR RUTA</button>
            </div>
            <h2></h2> <!-- Title will be updated by JS -->
        </div>
        <div id="locations-view" class="hidden">
             <div id="locations-map-div"></div>
             <!-- Other location-specific controls like Add Radar Here button -->
             <button id="add-radar-here" class="location-feature-button-action" title="Crear RADAR en mi posición actual (radio 1000m)" style="position: absolute; bottom: 10px; right: 10px; z-index: 1000;">AQUÍ HAY UN RADAR</button>
             <button id="reminders-map-help-button" class="location-feature-button-action" title="Ayuda del mapa de radares" style="position: absolute; bottom: 10px; left: 10px; z-index: 1000;">AYUDA</button>
        </div>
        <div id="route-planning-view" class="hidden">
             <div id="navigation-map-div"></div>
             <div id="route-planning-controls">
                  <button id="add-start-point-button">Añadir Salida (GPS)</button>
                  <button id="save-route-button">Guardar Ruta</button>
                  <button id="load-route-button">Cargar Ruta</button>
                  <button id="clear-route-button">Limpiar Ruta</button>
             </div>
             <button id="start-navigation-button" class="location-feature-button-action hidden" style="position: absolute; bottom: 10px; right: 10px; z-index: 1000;">INICIAR NAVEGACIÓN</button>
        </div>
         <div id="navigation-view" class="hidden">
             <div id="navigation-map-div-active"></div> <!-- Using a different ID/structure if needed, or reuse navigation-map-div -->
             <div id="navigation-dashboard">
                 <div class="instruction-area">
                     <div class="instruction-icon"></div>
                     <div class="instruction-text"></div>
                 </div>
                 <div class="next-maneuver-area">
                     <div class="next-maneuver-distance"></div>
                     <div class="next-maneuver-progress"><div class="next-maneuver-progress-fill"></div></div>
                 </div>
                 <div class="overall-progress-area">
                     <div class="overall-progress-bar"><div class="overall-progress-fill"></div></div>
                 </div>
                 <div class="summary-area">
                     <div class="summary-item">Distancia Total: <strong><span id="total-distance">--</span> km</strong></div>
                     <div class="summary-item">Tiempo Total: <strong><span id="total-time">--</span></strong></div>                    
                    <div class="summary-item">Llegada Estimada: <strong><span id="eta">--:--</span></strong></div>
                      <div class="summary-item">Próxima Etapa: <strong><span id="next-waypoint-eta">--:--</span></strong></div>
                 </div>
             </div>
             <button id="stop-navigation-button" class="location-feature-button-action" style="position: absolute; top: 10px; right: 10px; z-index: 1000;">DEJAR DE SEGUIR</button>
         </div>
    </div>
</div>

<!-- Saved Routes Modal -->
<div id="saved-routes-modal" class="saved-locations-modal hidden">
    <h2>Cargar Ruta Guardada</h2>
    <div id="saved-routes-list" style="max-height: calc(90vh - 150px); overflow-y: auto; margin-bottom: 1rem; padding-rht: 5px;">
        <!-- Saved routes will be listed here -->
    </div>
    <div class="button-group">
        <button id="close-saved-routes-modal">Cerrar</button>
    </div>
</div>

<script>

/* //
console.log("Script started"); // Log 1: Script start

// Block 1: Global variables and initial setup
const originalBookmarks = [{
    name: "YouTube",
    url: "https://www.youtube.com"
}, {
    name: "Google",
    url: "https://www.google.com"
}, {
    name: "GDrive",
    url: "https://drive.google.com",
    favicon: "./IMG_4172.png"
}, {
    name: "GMail",
    url: "https://mail.google.com/mail/mu/mp/603/#tl/Recibidos",
    favicon: "./IMG_4171.png"
}, {
    name: "Google Fotos",
    url: "https://photos.google.com"
}, {
    name: "iCloud",
    url: "https://www.icloud.com/",
    favicon: "https://www.google.com/s2/favicons?domain=icloud.com&sz=64"
}, {
    name: "ABRP",
    url: "https://abetterrouteplanner.com"
}, {
    name: "ElectroMaps",
    url: "https://map.electromaps.com/es/",
    favicon: "https://www.google.com/s2/favicons?domain=electromaps.com&sz=64"
}, {
    name: "REVE PdR España",
    url: "https://www.mapareve.es/mapa-puntos-recarga",
    favicon: "https://www.google.com/s2/favicons?domain=mapareve.es&sz=64"
}, {
    name: "PdR,s",
    url: "https://www.google.com/maps/search/puntos+recarga+veh%C3%ADculos+el%C3%A9ctricos",
    favicon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 18h8v2h-8v-2z'/><path d='M12 14h8v2h-8v-2z'/><path d='M12 10h8v2h-8V10z'/><path d='M12 6h8v2h-8V6z'/><path d='M4 18h4v-2H4v2zM4 14h4v-2H4v2zM4 10h4v-2H4v2zM4 6h4V4H4v2z'/></svg>"
}, {
    name: "Google Maps",
    url: "https://maps.google.com"
}, {
    name: "WhatsApp",
    url: "https://web.whatsapp.com/"
}, {
    name: "TESSIE",
    url: "https://dash.tessie.com/signin",
    favicon: "https://www.google.com/s2/favicons?domain=tessie.com&sz=64"
}, {
    name: "Mis Updates",
    url: "https://dash.tessie.com/software",
    favicon: "https://cdn-icons-png.flaticon.com/512/148/148767.png"
}, {
    name: "Olas Updates",
    url: "https://es.stats.tessie.com/",
    favicon: "https://es.stats.tessie.com/favicon-32x32.png?v=b6cf0b0d24", // Updated favicon source
}, {
    name: "NotaTeslaApp",
    url: "https://www.notateslaapp.com/software-updates/"
}, {
    name: "ENHAUTO",
    url: "https://www.enhauto.com"
}, {
    name: "MAREAS",
    url: "https://www.meteogalicia.gal/web/predicion/mareas-e-luas"
}, {
    name: "ELECTROVERSE",
    url: "https://electroverse.com/es/map",
    favicon: "https://www.google.com/s2/favicons?domain=electroverse.com&sz=64"
}, {
    name: "ACCIONA",
    url: "https://www.google.com/maps/search/recarga+Acciona",
    favicon: "https://www.google.com/s2/favicons?domain=acciona.com&sz=64"
}, {
    name: "IBERDROLA",
    url: "https://www.google.com/maps/search/recarga+IBERDROLA",
    favicon: "https://www.google.com/s2/favicons?domain=iberdrola.com&sz=64"
}, {
    name: "WAYLET Repsol",
    url: "https://www.google.com/maps/search/recarga+REPSOL+Waylet",
    favicon: "https://www.google.com/s2/favicons?domain=repsol.com&sz=64"
}, {
    name: "ENDESA xWay",
    url: "https://www.google.com/maps/search/recarga+ENDESA+XWAY",
    favicon: "https://www.google.com/s2/favicons?domain=endesa.com&sz=64"
}, {
    name: "ZUNDER",
    url: "https://www.google.com/maps/search/recarga+ZUNDER",
    favicon: "https://www.google.com/s2/favicons?domain=zunder.com&sz=64"
}, {
    name: "IONITY",
    url: "https://www.google.com/maps/search/recarga+IONITY",
    favicon: "https://www.google.com/s2/favicons?domain=ionity.eu&sz=64"
}, {
    name: "WENEA",
    url: "https://www.google.com/maps/search/recarga+WENEA",
    favicon: "https://www.google.com/s2/favicons?domain=wenea.com&sz=64"
}, {
    name: "T.ENERGIES",
    url: "https://www.google.com/maps/search/recarga+TOTAL+ENERGIES",
    favicon: "https://www.google.com/s2/favicons?domain=totalenergies.com&sz=64"
}, {
    name: "GALP",
    url: "https://www.google.com/maps/search/recarga+GALP",
    favicon: "https://www.google.com/s2/favicons?domain=galp.com&sz=64"
}, {
    name: "MIIO",
    url: "https://miio.com",
    favicon: "https://www.google.com/s2/favicons?domain=miio.com&sz=64"
}, {
    name: "EVDC",
    url: "https://evdc.network",
    favicon: "https://www.google.com/s2/favicons?domain=evdc.network&sz=64"
}, {
    name: "GROK",
    url: "https://grok.com/?referrer=website"
}, {
    name: "CHATGPT",
    url: "https://chat.openai.com"
}, {
    name: "CLAUDE",
    url: "https://claude.ai/new"
}, {
    name: "GEMINI",
    url: "https://gemini.google.com"
}, {
    name: "NOTEBOOKLM",
    url: "https://notebooklm.google.com"
}, {
    name: "Batería",
    url: "https://docs.google.com/spreadsheets/d/1bLZmgVGTBqg2bS2E45JpORjs9eK2nb05AWXYLLDY-RI/edit?gid=1398548891#gid=1398548891",
    favicon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='10'/><polyline points='12 6 12 12 16 14'/></svg>"
}, {
    name: "TeslaParaTodos",
    url: "https://teslaparatodos.com/cine/"
}, {
    name: "BetterTheater",
    url: "https://abettertheater.com",
    favicon: "https://www.google.com/s2/favicons?domain=abettertheater.com&sz=64"
}, {
    name: "Filmin",
    url: "https://www.filmin.es/catalogo/peliculas"
}, {
    name: "Octopus",
    url: "https://octopusenergy.es/login"
}, {
    name: "App MCE",
    url: "https://www.oscarabilleira.com/app-mi-coche-electrico/#ayuda"
}, {
    name: "Patrón Luz",
    url: "https://docs.google.com/spreadsheets/d/1R7UUZ9i4BAYWAGAX6PQT1WGd12GEZ4Ja/edit?usp=sharing&ouid=108345701896498198132&rtpof=true&sd=true"
}, {
    name: "TradingView",
    url: "https://es.tradingview.com/chart/t5g9UFG0/"
}, {
    name: "Telegram",
    url: "https://web.telegram.org/a/"
}, {
    name: "Twitter",
    url: "https://x.com"
}, {
    name: "Maesal Detailer",
    url: "https://www.maesaldetailer.es/"
}, {
    name: "Superchargers",
    url: "https://www.tesla.com/es_es/findus?bounds=45.41107111786193%2C19.27853056943938%2C29.703668286784747%2C-16.64676239931062"
}, {
    name: "TESLA web",
    url: "https://www.tesla.com/es_es"
}, {
    name: "Manual M3",
    url: "https://www.tesla.com/ownersmanual/model3/es_es/"
}, {
    name: "de Servicio",
    url: "https://service.tesla.com/docs/Model3/ServiceManual/2024/es-es/"
}, {
    name: "de Despiece",
    url: "https://epc.tesla.com/es-MX/catalogs/e0e07c3d-272f-4d06-b8b6-9e92f857e5f3"
}, {
    name: "de Usted Mismo",
    url: "https://www.tesla.com/es_es/support/do-it-yourself-guides"
}, {
    name: "de Filtro Cabina",
    url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-DB0A1E3C-926E-498C-A2FD-A27B8421A471.html"
}, {
    name: "de Móvil remoto",
    url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-53651B16-A2E3-4118-933E-B5F41C74D433.html"
}, {
    name: "Waze (consultas)",
    url: "https://www.waze.com/es/live-map/",
    favicon: "https://www.google.com/s2/favicons?domain=waze.com&sz=64"
}, {
    name: "AMAZON",
    url: "https://www.amazon.es"
}, {
    name: "BIP&DRIVE",
    url: "https://areaprivada.bipdrive.com/login"
}, {
    name: "ITV Cita",
    url: "https://www.sycitv.com/es/cita-previa-particulares/",
    favicon: "https://boardinggate.github.io/Tesla/itv.png"
}, {
    name: "Deportes",
    url: "https://www.sofascore.com/es/tenis"
}, null, {
    name: "Jaime Odena",
    url: "https://www.youtube.com/@JOdena",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "Eduardo Arcos",
    url: "https://www.youtube.com/@earcos",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "AutoIngenium",
    url: "https://www.youtube.com/@AutoIngenium",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "Gallego en Munich",
    url: "https://www.youtube.com/@ungallegoenmunich",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "Electromiaumiau",
    url: "https://www.youtube.com/@electromiaumiau",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "Manuel Martos",
    url: "https://www.youtube.com/@Manuel_Martos",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "Todos Electricos",
    url: "https://www.youtube.com/@TodosElectricos",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "Juan Vidal Haces",
    url: "https://www.youtube.com/@JuanVidalHaces",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "Ruedana",
    url: "https://www.youtube.com/@ruedana",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "STR-600",
    url: "https://www.youtube.com/@STR-600",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "Juanjo T. Aventuras",
    url: "https://www.youtube.com/@juanjoteslaventuras",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "Carlos Cuezva",
    url: "https://www.youtube.com/@CarlosCuezva",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "Javi Manzanoo",
    url: "https://www.youtube.com/@javimanzanoo",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "Crifedi",
    url: "https://www.youtube.com/@Crifedi",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "Tescno Tesla",
    url: "https://www.youtube.com/@TecnoTesla",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "Full Electric Mex",
    url: "https://www.youtube.com/@FullElectricMexico",
    favicon: "https://www.youtube.com/favicon.ico"
}, null, null, {
    name: "La iA Jon",
    url: "https://www.youtube.com/@la_inteligencia_artificial",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "JF Ccalero",
    url: "https://www.youtube.com/@jfcalero",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "Visual Politik",
    url: "https://www.youtube.com/@VisualPolitik",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "Fabian Barrio",
    url: "https://www.youtube.com/@fabiancbarrio",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "Loquetudigas",
    url: "https://www.youtube.com/@Loquetudigas",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "David Antunes",
    url: "https://www.youtube.com/@davidantunesmusic",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "TheWildProject",
    url: "https://www.youtube.com/@TheWildProject",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "Estas Tonne",
    url: "https://www.youtube.com/@Estastonne",
    favicon: "https://www.youtube.com/favicon.ico"
}, {
    name: "BBC6 Music",
    url: "https://www.youtube.com/@BBC6Music",
    favicon: "https://www.google.com/s2/favicons?domain=bbc.co.uk&sz=64"
}, null, null];
const originalToggleRanges = [{
    start: 18,
    end: 29,
    name: "ELECTROVERSE",
    label: "PdR,s"
}, {
    start: 30,
    end: 41,
    name: "GROK",
    label: "iAs"
}, {
    start: 42,
    end: 59,
    name: "TradingView",
    label: "Útil"
}, {
    start: 60,
    end: 95,
    name: "JOdena",
    label: "Varios"
}];

const sectionColors = {
    18: '#F0E0D3',
    30: '#D8D4E0',
    42: '#D9E5DB',
    60: '#F2ECD0',
    unassigned: '#C5C8B8',
    off: '#ABAB99'
};
const darkModeGenericButtonColor = '#ABAB99';

const TOTAL_CELLS = 96;
const COLS = 6;
const grid = document.getElementById('bookmark-grid');
let isDarkMode = false;
let pressStartTime = null;
let reminderPressStartTime = null;
let isActive = true;
let isFooterVisible = true;
let notices = [];
let currentNoticeIndex = 0;
let fromReminderModal = false;
let isEditMode = false;
let isAssignmentMode = false;
let isKeywordAssignmentMode = false;
let currentlyAssigningToggleStart = null;
let customData = {
    bookmarks: {},
    toggles: {}
};
let cellElements = [];
let toggleButtonElements = {};
let currentBookmarks = [];
let currentToggleRanges = [];
let onOffToggle, weatherButton, reminderButton, zoomButton, darkModeToggle, versionsButton, infoButton;
let radarButton;

let firstPersonalizationSession = !sessionStorage.getItem('personalizationHelpShown');
let editingTargetElement = null;
let draggedItem = null;
let draggedItemIndex = null;
let dragOverIndex = null;
let touchStartX = 0;
let touchStartY = 0;
let currentTouchTarget = null;
let isPasswordActive = false;
let storedPin = null;
let reminderCheckIntervalId = null;
let currentCheckIntervalDuration = 60000; // Default check interval (1 minute)
let lastUpdatesCheckDate = localStorage.getItem('lastUpdatesCheckDate');
let currentNotificationSlideIndex = 0;
let isUnifiedWindowVisibleByLogic = false;
let reminderModalMap = null; // Map instance for the reminder modal
let reminderMarker = null; // Marker for the reminder location in the modal map
let reminderCircle = null; // Circle for the reminder radius in the modal map
let previewMaps = {}; // Object to hold map instances for unified reminder window previews

const MAX_SAVED_LOCATIONS = 15;
const SAVED_LOCATIONS_KEY = 'boardinggate_saved_locations';
const SHOW_EXCLUDED_REMINDERS_KEY = 'boardinggate_showExcludedRemindersInTable';

let locationPickerMap = null; // Map instance for the saved locations picker modal
let locationPickerMarker = null; // Marker for picking location in the picker modal
let currentEditingLocationSlotIndex = -1; // Index of the saved location slot being edited
let tempSavedLocations = []; // Temporary array for saved locations while modal is open

let allLocationsMapInstance = null; // Map instance for the 'VER UBICACIONES' view
let initialUserLocationMarker = null; // User marker in the 'VER UBICACIONES' map
let initialUserLocationCircle = null; // User accuracy circle in the 'VER UBICACIONES' map
let initialUserLocationMarkerLat = null; // Last known user lat in Locations view
let initialUserLocationMarkerLng = null; // Last known user lng in Locations view

let locationWatchId = null; // Global watch ID for geolocation updates (used by Locations and Navigation)
let shouldCenterOnUserInAllLocationsMap = false; // State for user tracking in 'VER UBICACIONES'
let orientationAltitudeControl = null; // Control for compass and altitude in Locations view
let isLocationFeaturesModalActive = false; // Tracks if the main map modal is open
let currentLocationFeatureView = 'locations'; // Tracks the currently active view within the map modal ('locations', 'route-planning', 'navigation')

// Navigation specific variables
let navigationMap = null; // Map instance for the 'PLANIFICAR RUTA' and 'NAVEGACIÓN' views
let routePoints = []; // Array of { lat, lng, name? } objects representing user-defined route points
let routePointMarkers = []; // Array of Leaflet marker objects for routePoints
let routeLine = null; // Leaflet polyline for the calculated route
let currentRouteData = null; // OSRM route object (includes geometry, duration, distance, steps)
let isNavigating = false; // True when active navigation is running
let currentUserMarker = null; // User marker in navigationMap (rotates)
let currentUserCircle = null; // User accuracy circle in navigationMap
let currentRouteStepIndex = 0; // Index of the current step in OSRM steps
let metersToNextManeuver = 0; // Distance remaining to the next maneuver
let totalRouteDistance = 0; // Total distance of the calculated route
let totalRouteDuration = 0; // Total estimated duration of the calculated route
let distanceTravelledOnRoute = 0; // Distance travelled along the *calculated* route so far
let timeElapsedOnRoute = 0; // Time elapsed since navigation started
let routeRecalculateDebounce = null; // Debounce timer for route recalculation
let lastPositionTime = null; // Timestamp of the last valid position update for calculating speed/distance moved

// Saved Routes variables
const SAVED_ROUTES_KEY = 'boardinggate_saved_routes'; // localStorage key for saved routes

// Navigation UI elements (will be populated when navigation-view is created/shown)
let navInstructionIconEl = null;
let navInstructionTextEl = null;
let navNextManeuverDistanceEl = null;
let navNextManeuverProgressFillEl = null;
let navOverallProgressFillEl = null;
let navTotalDistanceEl = null;
let navTotalTimeEl = null;
let navEtaEl = null;
let navNextWaypointEtaEl = null;
let navProgressBarEl = null; // Reference to the overall progress bar container


async function loadNotices() { try { const r = await fetch('https://boardinggate.github.io/Tesla/avisos.txt', { cache: 'no-cache' }); if (!r.ok) throw new Error('Fetch failed'); const txt = await r.text(); notices = txt.split('\n').map(l => l.trim()).filter(l => l.length > 0); if (notices.length === 0) notices = ['No hay avisos.']; } catch (e) { notices = ['Error carga avisos.']; console.error("Error loading notices:", e); } updateNotice(); }

function updateNotice() { const noticeElement = document.getElementById('current-notice'); if (!noticeElement || notices.length === 0) { return; } if (!isActive) { noticeElement.textContent = ''; noticeElement.style.animation = 'none'; return; } noticeElement.textContent = notices[currentNoticeIndex]; noticeElement.style.animation = 'none'; void noticeElement.offsetWidth; noticeElement.style.animation = 'fadeInOut 14s infinite'; currentNoticeIndex = (currentNoticeIndex + 1) % notices.length; }

function toggleNotices() { isActive = !isActive; const nC = document.querySelector('.notices-container'); if (nC) nC.style.display = isActive ? 'flex' : 'none'; const fC = document.querySelector('footer'); if (fC) fC.classList.toggle('footer-hidden', !isActive); isFooterVisible = isActive; const nE = document.getElementById('current-notice'); if (nE) { if (!isActive) { nE.textContent = ''; nE.style.animation = 'none'; } else { currentNoticeIndex = 0; updateNotice(); } } saveSettings(); }

function startNoticeRotation() { if (notices.length === 0) return; if (isActive) updateNotice(); setInterval(updateNotice, 14000); }

function adjustButtonPositions() { const scrollToggle = document.getElementById('scroll-toggle'); if (!scrollToggle) { return; } const scrollToggleHeight = scrollToggle.offsetHeight; const buttonHeight = 74; const buttonSpacing = 10; const startTop = scrollToggleHeight + 20; const fixedButtons = [ document.getElementById('on-off-toggle'), ...document.querySelectorAll('.range-toggle'), document.getElementById('weather-button'), document.getElementById('reminder-button'), document.getElementById('zoom-button'), document.getElementById('dark-mode-toggle') ].filter(button => button !== null).sort((a, b) => { const startA = parseInt(a.dataset.rangeStart) || Infinity; const startB = parseInt(b.dataset.rangeStart) || Infinity; if (a.id === 'on-off-toggle') return -1; if (b.id === 'on-off-toggle') return 1; if (isFinite(startA) && isFinite(startB)) return startA - startB; if (isFinite(startA)) return -1; if (isFinite(startB)) return 1; const order = ['weather-button', 'reminder-button', 'zoom-button', 'dark-mode-toggle']; return order.indexOf(a.id) - order.indexOf(b.id); }); if (fixedButtons.length < 6) { return; } let currentTop = startTop; fixedButtons.forEach((button) => { button.style.position = 'fixed'; button.style.top = `${currentTop}px`; button.style.left = '10px'; currentTop += buttonHeight + buttonSpacing; }); }

function saveSettings() { localStorage.setItem('darkMode', JSON.stringify(isDarkMode)); const tS = {}; document.querySelectorAll('.range-toggle').forEach(t => { const start = t.dataset.rangeStart; if(start) tS[start] = t.dataset.state; }); localStorage.setItem('toggleStates', JSON.stringify(tS)); const zoomBtn = document.getElementById('zoom-button'); if (zoomBtn) localStorage.setItem('zoomState', zoomBtn.dataset.zoomState); const onOffBtn = document.getElementById('on-off-toggle'); if (onOffBtn) localStorage.setItem('onOffState', onOffBtn.dataset.state); localStorage.setItem('noticesActive', JSON.stringify(isActive)); localStorage.setItem('footerVisible', JSON.stringify(isFooterVisible)); localStorage.setItem('password_active', JSON.stringify(isPasswordActive)); localStorage.setItem('lastUpdatesCheckDate', lastUpdatesCheckDate);
}

function saveCustomData() { try { console.log("Saving custom data..."); if (customData.bookmarks) { Object.keys(customData.bookmarks).forEach(indexKey => { const index = parseInt(indexKey); const custom = customData.bookmarks[index]; const original = index < originalBookmarks.length ? originalBookmarks[index] : null; const bookmarksAreEqual = (b1, b2) => { if (b1 === null && b2 === null) return true; if (b1 === null || b2 === null) return false; return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null); }; if (bookmarksAreEqual(custom, original)) { delete customData.bookmarks[index]; } }); if (Object.keys(customData.bookmarks).length === 0) { delete customData.bookmarks; } } if (customData.toggles) { Object.keys(customData.toggles).forEach(startKey => { const customToggle = customData.toggles[startKey]; const originalRange = originalToggleRanges.find(r => r.start == startKey); if (customToggle && customToggle.assignedIndexes && originalRange) { const originalIndexes = Array.from({ length: originalRange.end - originalRange.start + 1 }, (_, i) => originalRange.start + i); if (customToggle.assignedIndexes.length === originalIndexes.length && customToggle.assignedIndexes.every((val, index) => val === originalIndexes[index])) { delete customToggle.assignedIndexes; } } if (customToggle && originalRange && customToggle.label === originalRange.label) { delete customToggle.label; } if (customData.toggles[startKey] && Object.keys(customData.toggles[startKey]).length === 0) { delete customData.toggles[startKey]; } }); if (Object.keys(customData.toggles).length === 0) { delete customData.toggles; } } localStorage.setItem('customGridData', JSON.stringify(customData)); console.log("Custom data saved:", customData); } catch (e) { showToast("Error al guardar personalización", "error"); console.error("Error in saveCustomData:", e); } }

function loadCustomData() { console.log("Loading custom data..."); const savedData = localStorage.getItem('customGridData'); currentBookmarks = []; currentToggleRanges = []; customData = { bookmarks: {}, toggles: {} }; if (savedData) { try { customData = JSON.parse(savedData) || { bookmarks: {}, toggles: {} }; console.log("Parsed custom data:", customData); } catch (e) { customData = { bookmarks: {}, toggles: {} }; console.error("Error parsing custom data:", e); } } if (!customData.bookmarks) customData.bookmarks = {}; if (!customData.toggles) customData.toggles = {}; currentBookmarks = Array.from({ length: TOTAL_CELLS }).map((_, index) => { if (customData.bookmarks.hasOwnProperty(index)) { return customData.bookmarks[index] ? { ...customData.bookmarks[index] } : null; } else { const original = index < originalBookmarks.length ? originalBookmarks[index] : null; return original ? { ...original } : null; } }); currentToggleRanges = originalToggleRanges.map(originalRange => { const customToggle = customData.toggles[originalRange.start]; const rangeCopy = { ...originalRange }; if (customToggle) { if (typeof customToggle.label === 'string') rangeCopy.label = customToggle.label; if (Array.isArray(customToggle.assignedIndexes)) rangeCopy.assignedIndexes = [...customToggle.assignedIndexes]; } if (!rangeCopy.assignedIndexes) rangeCopy.assignedIndexes = Array.from({ length: rangeCopy.end - originalRange.start + 1 }, (_, i) => rangeCopy.start + i); return rangeCopy; }); console.log("Custom data loaded. Current bookmarks length:", currentBookmarks.length, "Current toggles length:", currentToggleRanges.length); }

function loadSavedSettings() {
    console.log("Loading saved settings...");
    const savedDarkMode = localStorage.getItem('darkMode');
    isDarkMode = savedDarkMode ? JSON.parse(savedDarkMode) : false;
    if (isDarkMode) document.body.classList.add('dark-mode');
    console.log("Loaded isDarkMode:", isDarkMode);

    const savedZoomState = localStorage.getItem('zoomState');
    const zoomButton = document.getElementById('zoom-button');
    if (savedZoomState && zoomButton) { zoomButton.dataset.zoomState = savedZoomState; applyZoom(savedZoomState); console.log("Loaded zoomState:", savedZoomState); } else if (zoomButton) { zoomButton.dataset.zoomState = 'off'; applyZoom('off'); console.log("Default zoomState: off"); }

    const savedPasswordActive = localStorage.getItem('password_active');
    isPasswordActive = savedPasswordActive ? JSON.parse(savedPasswordActive) : false;
    storedPin = localStorage.getItem('password_pin');
    updatePasswordToggleIcon();
    console.log("Loaded isPasswordActive:", isPasswordActive, "storedPin exists:", !!storedPin);

    lastUpdatesCheckDate = localStorage.getItem('lastUpdatesCheckDate');
    console.log("Loaded lastUpdatesCheckDate:", lastUpdatesCheckDate);

    const savedNoticesActive = localStorage.getItem('noticesActive');
    const savedFooterVisible = localStorage.getItem('footerVisible');
    const savedToggleStates = localStorage.getItem('toggleStates');
    const savedOnOffState = localStorage.getItem('onOffState');
    const onOffToggle = document.getElementById('on-off-toggle');
    if (savedOnOffState && onOffToggle) onOffToggle.dataset.state = savedOnOffState;
    else if (onOffToggle) onOffToggle.dataset.state = 'on';
    console.log("Loaded onOffState:", onOffToggle ? onOffToggle.dataset.state : 'N/A');

    if (cellElements.length === 0) {
        console.log("Rendering grid from loadSavedSettings (cellElements empty)...");
        renderGrid(); // This should happen after loadCustomData
    }

    const toggleStates = savedToggleStates ? JSON.parse(savedToggleStates) : {};
    console.log("Loaded toggleStates:", toggleStates);
    document.querySelectorAll('.range-toggle').forEach(toggle => {
        const start = parseInt(toggle.dataset.rangeStart);
        const range = currentToggleRanges.find(r => r.start === start);
        if (!range) return;
        const savedState = toggleStates[start] || 'visible';
        toggle.dataset.state = savedState;
        toggle.innerHTML = `<span class="sign">${savedState === 'visible' ? '-' : '+'}</span>${range.label}`;
    });

    isActive = savedNoticesActive ? JSON.parse(savedNoticesActive) : true;
    const nC = document.querySelector('.notices-container');
    if (nC) nC.style.display = isActive ? 'flex' : 'none';
    const fC = document.querySelector('footer');
    if (fC) fC.classList.toggle('footer-hidden', !isActive);
    isFooterVisible = savedFooterVisible ? JSON.parse(savedFooterVisible) : true;
    const footer = document.querySelector('footer');
    if (footer) footer.classList.toggle('footer-hidden', !isFooterVisible);
    console.log("Loaded noticesActive:", isActive, "footerVisible:", isFooterVisible);


    const filterInput = document.getElementById('grid-filter-input');
    if (filterInput) {
        const savedFilter = localStorage.getItem('gridFilterValue');
        if (savedFilter !== null) {
            filterInput.value = savedFilter;
            console.log("Loaded gridFilterValue:", savedFilter);
        } else {
            filterInput.value = '';
            console.log("No saved gridFilterValue.");
        }
    }

    updateButtonStyles();
    loadReminders(); // Calls updateReminderCount
    updateUserIdDisplay();
    filterGridItems();
    console.log("Finished loading saved settings.");
}

function loadReminders() { console.log("Loading reminders and updating count..."); updateReminderCount(); }

function updateUserIdDisplay() { const userIdDisplay = document.getElementById('user-id-display'); const userId = localStorage.getItem('userData_userId'); if (userIdDisplay) { if (userId) { userIdDisplay.textContent = userId.trim(); userIdDisplay.style.display = 'block'; } else { userIdDisplay.textContent = ''; userIdDisplay.style.display = 'none'; } console.log("User ID display updated. userId:", userId); } }

function applyZoom(state) { console.log("Applying zoom state:", state); const originalWidth = 984; const adjustedWidth = 935; const originalCols = 6; const zoomedCols = 4; const gap = 15; const zoomButton = document.getElementById('zoom-button'); if (state === 'on') { grid.style.gridTemplateColumns = `repeat(${zoomedCols}, 1fr)`; grid.style.gap = `${gap}px`; grid.style.maxWidth = `${adjustedWidth}px`; document.querySelectorAll('.bookmark-item img').forEach(i => { i.style.width = '48px'; i.style.maxWidth = '56px'; }); document.querySelectorAll('.bookmark-name').forEach(n => { n.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)'; }); document.querySelectorAll('.small-bookmark img').forEach(i => { i.style.width = '48px'; i.style.maxWidth = '56px'; }); document.querySelectorAll('.small-bookmark .bookmark-name').forEach(n => { n.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)'; }); if (zoomButton) zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/zoon+.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; } else { grid.style.gridTemplateColumns = `repeat(${originalCols}, minmax(120px, 1fr))`; grid.style.gap = `${gap}px`; grid.style.maxWidth = `${originalWidth}px`; document.querySelectorAll('.bookmark-item img').forEach(i => { i.style.width = '36px'; i.style.maxWidth = '40px'; }); document.querySelectorAll('.bookmark-name').forEach(n => { n.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)'; }); document.querySelectorAll('.small-bookmark img').forEach(i => { i.style.width = '24px'; i.style.maxWidth = '28px'; }); document.querySelectorAll('.small-bookmark .bookmark-name').forEach(n => { n.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)'; }); if (zoomButton) zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; } }

function getSectionForIndex(index) { return currentToggleRanges.find(range => range.assignedIndexes.includes(index)); }

function getColorForSection(sectionStart, state = 'visible') { if (state === 'hidden') { return sectionColors.off; } if (isDarkMode) { return darkModeGenericButtonColor; } else { return sectionColors[sectionStart] || sectionColors.unassigned; } }

function updateButtonStyles() { console.log("Updating button styles. Dark mode:", isDarkMode); const darkModeToggle = document.getElementById('dark-mode-toggle'); const onOffToggle = document.getElementById('on-off-toggle'); const rangeToggleButtons = document.querySelectorAll('.toggle-sign.range-toggle'); const reminderButton = document.getElementById('reminder-button'); if (onOffToggle) { onOffToggle.src = `https://boardinggate.github.io/Tesla/${onOffToggle.dataset.state === 'on' ? 'IMG_4192.jpg' : 'IMG_4191.jpg'}`; onOffToggle.alt = `Toggle ${onOffToggle.dataset.state === 'on' ? 'On' : 'Off'}`; } if (darkModeToggle) { darkModeToggle.src = `https://boardinggate.github.io/Tesla/${isDarkMode ? 'oscuro2.png' : 'claro2.png'}`; darkModeToggle.alt = `Toggle ${isDarkMode ? 'Oscuro' : 'Claro'}`; }

    let reminders = [];
    try { reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); } catch (e) { console.error("Error reading reminders from localStorage:", e); reminders = []; }
    const showExcludedInTable = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
    let remindersForButtonStyleCount = reminders;
    if (!showExcludedInTable) {
        remindersForButtonStyleCount = reminders.filter(r => !r.excludeFromList);
    }
    const pendingCount = remindersForButtonStyleCount.length;
    console.log("Pending reminders count for button:", pendingCount);

    if (reminderButton) { reminderButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4197.jpg" alt="Recordatorio" style="max-width: 70%; max-height: 70%; object-fit: contain;">${pendingCount > 0 ? `<span class="reminder-count">${pendingCount}</span>` : ''}`; reminderButton.style.backgroundColor = sectionColors.off; reminderButton.style.filter = isDarkMode ? 'brightness(85%)' : ''; } rangeToggleButtons.forEach(toggle => { const start = parseInt(toggle.dataset.rangeStart); const state = toggle.dataset.state || 'visible'; toggle.style.backgroundColor = getColorForSection(start, state); if (isDarkMode && state === 'visible') { toggle.style.filter = 'brightness(85%)'; } else { toggle.style.filter = ''; } }); updatePasswordToggleIcon(); checkVersionsIconOpacity();
    if (cellElements && cellElements.length > 0) { cellElements.forEach((cell, index) => { const bookmarkItem = cell.querySelector('.bookmark-item'); const emptySlot = cell.classList.contains('empty-slot'); const section = getSectionForIndex(index); const color = sectionColors[section ? section.start : null] || sectionColors.unassigned; if (bookmarkItem) { bookmarkItem.style.backgroundColor = color; } else if (emptySlot) { cell.style.backgroundColor = color; } }); }
}

function formatVersionDate(date) { const y = date.getUTCFullYear().toString().slice(-2); const m = String(date.getUTCMonth() + 1).padStart(2, '0'); const d = String(date.getUTCDate()).padStart(2, '0'); const h = String(date.getUTCHours()).padStart(2, '0'); return `${y}.${m}.${d}${h}`; }

async function getLastModifiedDate() { const k = 'teslaHtmlLastModified'; const tk = 'teslaHtmlLastModifiedTimestamp'; const dur = 86400000; const cd = localStorage.getItem(k); const ct = localStorage.getItem(tk); const now = Date.now(); if (cd && ct && now - ct < dur) { console.log("Using cached last modified date."); return new Date(cd); } try { console.log("Fetching last modified date from version.txt..."); const r = await fetch('https://boardinggate.github.io/Tesla/version.txt', { cache: 'no-cache' }); if (!r.ok) throw new Error(`HTTP ${r.status}`); const txt = await r.text(); const lmd = new Date(txt.trim()); if (isNaN(lmd.getTime())) throw new Error('Invalid date format'); localStorage.setItem(k, lmd.toISOString()); localStorage.setItem(tk, now.toString()); console.log("Fetched and cached last modified date:", lmd); return lmd; } catch (e) { console.error("Error fetching last modified date:", e); if (cd) { console.log("Using old cached last modified date due to fetch error."); return new Date(cd); } console.log("Using default last modified date."); return new Date('2024-01-01T00:00:00Z'); } }

async function updateVersion() { try { const lmd = await getLastModifiedDate(); const v = formatVersionDate(lmd); const el = document.getElementById('version'); if (el) el.textContent = `versión: ${v}`; console.log("Version updated to:", v); } catch (e) { const el = document.getElementById('version'); if (el) el.textContent = 'versión: error'; console.error("Error in updateVersion:", e); } }

const getFaviconUrl = (bookmarkData) => { try { const urlToParse = bookmarkData?.url || ''; const customFavicon = bookmarkData?.favicon; if (customFavicon && (customFavicon.startsWith('data:image') || customFavicon.startsWith('http') || customFavicon.startsWith('./'))) return customFavicon; if (urlToParse) { const domain = new URL(urlToParse).hostname; return `https://www.google.com/s2/favicons?domain=${domain}&sz=64`; } } catch (e) { console.warn("Error getting favicon URL for", bookmarkData?.url, ":", e); } return 'https://via.placeholder.com/64'; };

function renderGrid() { console.log("Rendering grid..."); grid.innerHTML = ''; cellElements = []; Array.from({ length: TOTAL_CELLS }).forEach((_, index) => { const cellContainer = document.createElement('div'); cellContainer.classList.add('grid-cell'); cellContainer.dataset.index = index; const bookmarkData = currentBookmarks[index]; const section = getSectionForIndex(index); const bgColor = sectionColors[section ? section.start : null] || sectionColors.unassigned; if (bookmarkData) { const link = document.createElement('a'); link.className = 'bookmark-item'; link.title = bookmarkData.name; link.style.backgroundColor = bgColor; link.href = bookmarkData.url || "#"; link.dataset.index = index;
    if (isKeywordAssignmentMode || (bookmarkData.name && bookmarkData.name === "Inicio Tesla") || !bookmarkData.url || bookmarkData.url === '#') {
    } else {
         link.target = "_blank";
         link.rel = "noopener noreferrer";
    }
    const img = document.createElement('img'); img.src = getFaviconUrl(bookmarkData); img.alt = `Favicon ${bookmarkData.name}`; img.loading = "lazy"; img.onerror = function() { console.warn("Failed to load favicon for", bookmarkData?.name, ". Using placeholder."); this.src = 'https://via.placeholder.com/64'; this.onerror = null; }; if (bookmarkData.name === "Mis Updates") img.classList.add('favicon-red'); else if (bookmarkData.name === "Olas Updates") img.classList.add('favicon-blue'); const nameSpan = document.createElement('span'); nameSpan.className = 'bookmark-name'; nameSpan.textContent = bookmarkData.name; link.appendChild(img); link.appendChild(nameSpan); cellContainer.appendChild(link); } else { cellContainer.classList.add('empty-slot'); const addIcon = document.createElement('span'); addIcon.textContent = '+'; cellContainer.appendChild(addIcon); cellContainer.style.backgroundColor = bgColor; }
    cellContainer.addEventListener('click', handleGridCellClick);

    if (isEditMode) {
         cellContainer.draggable = true;
         cellContainer.addEventListener('dragstart', handleDragStart);
         cellContainer.addEventListener('dragover', handleDragOver);
         cellContainer.addEventListener('dragleave', handleDragLeave);
         cellContainer.addEventListener('drop', handleDrop);
         cellContainer.addEventListener('dragend', handleDragEnd);
         cellContainer.addEventListener('touchstart', handleTouchStart, {
             passive: false
         });
         cellContainer.addEventListener('touchmove', handleTouchMove, {
             passive: false
         });
         cellContainer.addEventListener('touchend', handleTouchEnd);
         cellContainer.addEventListener('touchcancel', handleTouchCancel);
         cellContainer.classList.add('editable');
    } else {
         cellContainer.draggable = false;
         cellContainer.removeEventListener('dragstart', handleDragStart);
         cellContainer.removeEventListener('dragover', handleDragOver);
         cellContainer.removeEventListener('dragleave', handleDragLeave);
         cellContainer.removeEventListener('drop', handleDrop);
         cellContainer.removeEventListener('dragend', handleDragEnd);
         cellContainer.removeEventListener('touchstart', handleTouchStart);
         cellContainer.removeEventListener('touchmove', handleTouchMove);
         cellContainer.removeEventListener('touchend', handleTouchEnd);
         cellContainer.removeEventListener('touchcancel', handleTouchCancel);
         cellContainer.classList.remove('editable');
    }
    grid.appendChild(cellContainer);
    cellElements.push(cellContainer);
    console.log("Grid rendered with", cellElements.length, "cells.");
});}

function renderToggleButtons() { console.log("Rendering toggle buttons..."); document.querySelectorAll('.range-toggle').forEach(btn => btn.remove()); toggleButtonElements = {}; currentToggleRanges.forEach((range) => { const toggle = document.createElement('span'); toggle.className = 'toggle-sign range-toggle'; toggle.dataset.rangeStart = range.start; toggle.dataset.rangeEnd = range.end; toggle.style.position = 'fixed'; toggle.style.top = '100px'; toggle.style.left = '10px'; const initialState = 'visible'; toggle.innerHTML = `<span class="sign">${initialState === 'visible' ? '-' : '+'}</span>${range.label}`; toggle.dataset.state = initialState; toggle.addEventListener('click', handleToggleClick); document.body.appendChild(toggle); toggleButtonElements[range.start] = toggle; }); console.log("Toggle buttons rendered:", Object.keys(toggleButtonElements).length); adjustButtonPositions(); }

function createOtherButtons() {
    console.log("Creating other fixed buttons...");
    if (!document.getElementById('on-off-toggle')) { onOffToggle = document.createElement('img'); onOffToggle.className = 'toggle-image'; onOffToggle.id = 'on-off-toggle'; onOffToggle.dataset.state = 'on'; document.body.appendChild(onOffToggle); onOffToggle.addEventListener('mousedown', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) pressStartTime = Date.now(); }); onOffToggle.addEventListener('mouseup', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) handleOnOffAction(); }); onOffToggle.addEventListener('mouseleave', () => { pressStartTime = null; }); onOffToggle.addEventListener('touchstart', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); pressStartTime = Date.now(); } }); onOffToggle.addEventListener('touchend', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); handleOnOffAction(); } }); console.log("On/Off Toggle created."); }
    if (!document.getElementById('weather-button')) { weatherButton = document.createElement('span'); weatherButton.className = 'toggle-sign'; weatherButton.id = 'weather-button'; weatherButton.innerHTML = `<img src="https://www.google.com/s2/favicons?domain=accuweather.com&sz=64" alt="Tiempo" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; document.body.appendChild(weatherButton); weatherButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; window.open('https://www.ventusky.com/?p=40.2;-4.7;5&l=rain-3h', '_blank'); }); console.log("Weather Button created."); }
    if (!document.getElementById('reminder-button')) { reminderButton = document.createElement('span'); reminderButton.className = 'toggle-sign'; reminderButton.id = 'reminder-button'; document.body.appendChild(reminderButton); reminderButton.addEventListener('mousedown', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) reminderPressStartTime = Date.now(); }); reminderButton.addEventListener('mouseup', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) handleReminderLongPress(); }); reminderButton.addEventListener('mouseleave', () => { reminderPressStartTime = null; }); reminderButton.addEventListener('touchstart', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); reminderPressStartTime = Date.now(); } }); reminderButton.addEventListener('touchend', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); handleReminderLongPress(); } }); console.log("Reminder Button created.");}
    if (!document.getElementById('zoom-button')) { zoomButton = document.createElement('span'); zoomButton.className = 'toggle-sign'; zoomButton.id = 'zoom-button'; zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; zoomButton.dataset.zoomState = 'off'; document.body.appendChild(zoomButton); zoomButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const cS = zoomButton.dataset.zoomState; const nS = cS === 'off' ? 'on' : 'off'; applyZoom(nS); zoomButton.dataset.zoomState = nS; updateButtonStyles(); saveSettings(); adjustButtonPositions(); }); console.log("Zoom Button created."); }
    if (!document.getElementById('dark-mode-toggle')) { darkModeToggle = document.createElement('img'); darkModeToggle.className = 'toggle-image'; darkModeToggle.id = 'dark-mode-toggle'; document.body.appendChild(darkModeToggle); darkModeToggle.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; isDarkMode = !isDarkMode; document.body.classList.toggle('dark-mode', isDarkMode); updateButtonStyles(); saveSettings(); }); console.log("Dark Mode Toggle created."); }
    if (!document.getElementById('config-button')) { const configButton = document.createElement('span'); configButton.id = 'config-button'; configButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/config.jpg" alt="Configuración">`; document.body.appendChild(configButton); configButton.addEventListener('click', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) showConfigModal(); }); console.log("Config Button created."); }
    if (!document.getElementById('personal-button')) { const personalButton = document.createElement('span'); personalButton.id = 'personal-button'; personalButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/personal.png" alt="Personal">`; document.body.appendChild(personalButton); personalButton.addEventListener('click', handlePersonalizationClick); console.log("Personal Button created."); }

    if (!document.getElementById('radar-button')) {
        radarButton = document.createElement('span');
        radarButton.id = 'radar-button';
        radarButton.innerHTML = `<img src="RADAR.PNG" alt="Radar/Ubicaciones">`;
        document.body.appendChild(radarButton);
        radarButton.addEventListener('click', () => {
            console.log("Radar Button clicked. Showing Location Features Modal (locations view).");
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
            showLocationFeaturesModal('locations'); // Show the Location Features modal, starting in Locations view
        });
        console.log("Radar Button created.");
    }

    if (!document.getElementById('home-button')) { const homeButton = document.createElement('span'); homeButton.id = 'home-button'; homeButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/home.webp" alt="Inicio">`; document.body.appendChild(homeButton); homeButton.addEventListener('click', (e) => { console.log("Home Button clicked."); if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) { e.preventDefault(); return; } window.history.back(); }); console.log("Home Button created."); }
    if (!document.getElementById('reload-button')) { const reloadButton = document.createElement('span'); reloadButton.id = 'reload-button'; reloadButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/reload.webp" alt="Recargar">`; document.body.appendChild(reloadButton); reloadButton.addEventListener('click', () => { console.log("Reload Button clicked."); if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; location.reload(); }); console.log("Reload Button created."); }

    if (!document.getElementById('keyword-assignment-button')) {
        const keywordButton = document.createElement('span');
        keywordButton.id = 'keyword-assignment-button';
        keywordButton.title = "Asignar/Quitar palabra clave filtro";
        keywordButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4314.PNG" alt="Asignar Keyword">`;
        document.body.appendChild(keywordButton);
        keywordButton.addEventListener('click', () => {
            console.log("Keyword Assignment Button clicked.");
            toggleKeywordAssignmentMode(!isKeywordAssignmentMode);
        });
        console.log("Keyword Assignment Button created.");
    }

    if (!document.getElementById('password-toggle-button')) { const passwordButton = document.createElement('span'); passwordButton.id = 'password-toggle-button'; passwordButton.innerHTML = `<img src="" alt="Clave">`; document.body.appendChild(passwordButton); passwordButton.addEventListener('click', handlePasswordToggleClick); updatePasswordToggleIcon(); console.log("Password Toggle Button created."); }

    if (!document.getElementById('versions-button')) {
        versionsButton = document.createElement('span');
        versionsButton.id = 'versions-button';
        versionsButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4309.PNG" alt="Versiones">`;
        document.body.appendChild(versionsButton);
        versionsButton.addEventListener('click', () => {
            console.log("Versions Button clicked. Showing versions modal.");
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
            showVersionsModal();
        });
        console.log("Versions Button created.");
    }

    if (!document.getElementById('info-button')) {
        infoButton = document.createElement('span');
        infoButton.id = 'info-button';
        infoButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4326.PNG" alt="Info">`;
        document.body.appendChild(infoButton);
        infoButton.addEventListener('click', () => {
            console.log("Info Button clicked. Opening manual.");
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
            window.open('https://boardinggate.github.io/Tesla/manual.html', '_blank');
        });
        console.log("Info Button created.");
    }
    console.log("Finished creating other fixed buttons.");
}

function handleGridCellClick(event) {
    const cellContainer = event.currentTarget;
    const index = parseInt(cellContainer.dataset.index);
    console.log("Grid cell clicked. Index:", index, "isEditMode:", isEditMode, "isAssignmentMode:", isAssignmentMode, "isKeywordAssignmentMode:", isKeywordAssignmentMode);

    if (isEditMode) {
        const link = cellContainer.querySelector('a.bookmark-item');
        if (link) event.preventDefault();
        showEditModal(index, false);
    } else if (isAssignmentMode) {
        event.preventDefault();
        handleGridCellClickForAssignment(index);
    } else if (isKeywordAssignmentMode) {
        event.preventDefault();
        handleKeywordAssignmentClick(index);
    } else {
        const link = cellContainer.querySelector('a.bookmark-item');
        const bookmarkData = currentBookmarks[index];
        if (!link || !link.href || link.href === '#') {
            console.log("Link has no href or is #. Preventing default.");
            event.preventDefault();
        } else {
            if (!link.target && bookmarkData && bookmarkData.name !== "Inicio Tesla") {
                console.log("Link will open in new tab.");
                link.target = "_blank";
                link.rel = "noopener noreferrer";
            }
        }
    }
}

function handleToggleClick(event) { const toggle = event.currentTarget; console.log("Toggle button clicked:", toggle.id, toggle.dataset.rangeStart, "isEditMode:", isEditMode, "isAssignmentMode:", isAssignmentMode, "isKeywordAssignmentMode:", isKeywordAssignmentMode); if (isEditMode) { event.preventDefault(); const start = parseInt(toggle.dataset.rangeStart); showEditModal(start, true); } else if (isAssignmentMode) { event.preventDefault(); handleToggleClickForAssignment(toggle); } else if (isKeywordAssignmentMode) { event.preventDefault(); } else { updateToggleState(toggle); } }

function updateToggleState(toggle) { if (!toggle || isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
    console.log("Updating toggle state for:", toggle.dataset.rangeStart);
    const start = parseInt(toggle.dataset.rangeStart);
    if (isNaN(start)) return;
    const rangeConfig = currentToggleRanges.find(r => r.start === start);
    if (!rangeConfig) {
        console.warn("Range config not found for toggle start:", start);
        return;
    }
    const currentState = toggle.dataset.state;
    const newState = currentState === 'visible' ? 'hidden' : 'visible';
    const label = rangeConfig.label;
    toggle.dataset.state = newState;
    toggle.innerHTML = `<span class="sign">${newState === 'visible' ? '-' : '+'}</span>${label}`;
    const savedStates = JSON.parse(localStorage.getItem('toggleStates') || '{}');
    savedStates[start] = newState;
    localStorage.setItem('toggleStates', JSON.stringify(savedStates));
    console.log("Toggle state saved. New state:", newState);
    updateButtonStyles();
    filterGridItems();
}

function updateAllToggles(newState) { console.log("Updating all toggles state to:", newState); const onOffToggle = document.getElementById('on-off-toggle'); if (!onOffToggle) return; onOffToggle.dataset.state = newState; updateButtonStyles(); saveSettings(); filterGridItems(); }

const scrollToggle = document.getElementById('scroll-toggle');
if (scrollToggle) scrollToggle.addEventListener('click', () => { console.log("Scroll Toggle clicked."); if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const sP = window.scrollY; const mS = document.body.scrollHeight - window.innerHeight; window.scrollTo({ top: sP < 100 ? mS : 0, behavior: 'smooth' }); });

function handleOnOffAction() { if (pressStartTime !== null) { const t = document.getElementById('on-off-toggle'); if (t) { console.log("On/Off toggle action triggered."); const nS = t.dataset.state === 'on' ? 'off' : 'on'; updateAllToggles(nS); } } pressStartTime = null; }

function handleReminderLongPress() { if (reminderPressStartTime === null) return; const dur = Date.now() - reminderPressStartTime; console.log("Reminder button press duration:", dur); if (dur >= 2000) showAllReminders(); else showReminderModal(); reminderPressStartTime = null; }

function handlePersonalizationClick() {
    console.log("Personalization button clicked. Current modes: Edit=", isEditMode, "Assign=", isAssignmentMode, "Keyword=", isKeywordAssignmentMode);
    const personalButton = document.getElementById('personal-button');
    const wasEditing = isEditMode;
    const wasAssigning = isAssignmentMode;
    const wasKeywordAssigning = isKeywordAssignmentMode;

    if (wasKeywordAssigning) {
        toggleKeywordAssignmentMode(false);
    }

    if (editingTargetElement) {
        editingTargetElement.classList.remove('editing-target');
        editingTargetElement = null;
    }

    if (wasEditing) {
        toggleEditMode(false);
    } else if (wasAssigning) {
        toggleAssignmentMode(false);
    } else if (!wasKeywordAssigning) {
        showPersonalizationChoice();
    }
}


function showPersonalizationChoice() { console.log("Showing personalization choice modal."); const existingModal = document.querySelector('.choice-modal'); if (existingModal) existingModal.remove(); const modal = document.createElement('div'); modal.className = 'choice-modal'; modal.setAttribute('aria-label', 'Elegir tipo de personalización'); modal.innerHTML = ` <h2>¿Qué quieres personalizar?</h2> <p class="mb-6">Elige una opción:</p> <div class="personalization-options"> <button class="choice-edit">URLs / Etiquetas / Reordenar</button> <button class="choice-assign">Asignar Botones Ocultación</button> <button class="choice-help">Ver Ayuda</button> <button class="choice-cancel">Cancelar</button> </div> `; modal.querySelector('.choice-edit').addEventListener('click', () => { console.log("Edit choice selected."); modal.remove(); toggleEditMode(true); }); modal.querySelector('.choice-assign').addEventListener('click', () => { console.log("Assign choice selected."); modal.remove(); toggleAssignmentMode(true); }); modal.querySelector('.choice-help').addEventListener('click', () => { console.log("Help choice selected."); modal.remove(); showEditInfoModal(); }); modal.querySelector('.choice-cancel').addEventListener('click', () => { console.log("Cancel choice selected."); modal.remove(); }); document.body.appendChild(modal); }

function toggleEditMode(activate) {
    console.log("Toggling Edit Mode:", activate);
    const personalButton = document.getElementById('personal-button');
    isEditMode = activate;
    personalButton.classList.toggle('editing', isEditMode);
    document.body.classList.toggle('editing-active', isEditMode);

    if (isEditMode) {
        if (isAssignmentMode) toggleAssignmentMode(false);
        if (isKeywordAssignmentMode) toggleKeywordAssignmentMode(false);
        if (firstPersonalizationSession) { showEditInfoModal(); firstPersonalizationSession = false; sessionStorage.setItem('personalizationHelpShown', 'true'); }
        showToast("Modo Edición (URLs/Etiquetas/Arrastrar) Activado", "info", 4000);
    } else {
        showToast("Modo Edición Desactivado", "info", 2000);
        cellElements.forEach(cell => cell.classList.remove('dragging', 'drag-over'));
        draggedItem = null;
        draggedItemIndex = null;
        currentTouchTarget = null;
        dragOverIndex = null;
        if (editingTargetElement) {
            editingTargetElement.classList.remove('editing-target');
            editingTargetElement = null;
        }
    }

    renderGrid();
    renderToggleButtons();
    loadSavedSettings();
    document.querySelectorAll('.range-toggle').forEach(el => { el.classList.toggle('editable', isEditMode); });
    filterGridItems();
}

function toggleAssignmentMode(activate) {
    console.log("Toggling Assignment Mode:", activate);
    const personalButton = document.getElementById('personal-button');
    isAssignmentMode = activate;
    personalButton.classList.toggle('assigning', isAssignmentMode);
    document.body.classList.toggle('assignment-active', isAssignmentMode);

    if (isAssignmentMode) {
        if (isEditMode) toggleEditMode(false);
        if (isKeywordAssignmentMode) toggleKeywordAssignmentMode(false);
        if (firstPersonalizationSession) { showEditInfoModal(); firstPersonalizationSession = false; sessionStorage.setItem('personalizationHelpShown', 'true'); }
        showToast("Modo Asignación Botones Activado", "info", 4000);
        const firstToggle = document.querySelector('.range-toggle');
        if (firstToggle) { handleToggleClickForAssignment(firstToggle); } else { currentlyAssigningToggleStart = null; updateGridAssignmentVisuals(); }
    } else {
        showToast("Modo Asignación Botones Desactivado", "info", 2000);
        saveCustomData();
        document.querySelectorAll('.range-toggle.assigning-selected').forEach(t => t.classList.remove('assigning-selected'));
        document.querySelectorAll('.grid-cell.assigned-to-current').forEach(c => c.classList.remove('assigned-to-current'));
        document.querySelectorAll('.grid-cell').forEach(c => { c.style.opacity = ''; c.style.outline = ''; c.style.boxShadow = ''; c.style.backgroundColor = ''; });
        document.querySelectorAll('.range-toggle').forEach(t => t.style.opacity = '');
        currentlyAssigningToggleStart = null;
    }

    renderGrid();
    renderToggleButtons();
    loadSavedSettings();
    filterGridItems();
}

function toggleKeywordAssignmentMode(activate) {
    console.log("Toggling Keyword Assignment Mode:", activate);
    const keywordButton = document.getElementById('keyword-assignment-button');
    const filterInput = document.getElementById('grid-filter-input');
    isKeywordAssignmentMode = activate;

    if (keywordButton) {
        keywordButton.classList.toggle('active', isKeywordAssignmentMode);
    }
    document.body.classList.toggle('keyword-assignment-active', isKeywordAssignmentMode);

    if (isKeywordAssignmentMode) {
        if (isEditMode) toggleEditMode(false);
        if (isAssignmentMode) toggleAssignmentMode(false);

        const toastMessage = "Modo activo: Escribe palabra(s) en el campo filtro grid (separadas por espacio si son varias). Pulsa ICONO FILTRO para añadir/quitar esa(s) palabra(s) al nombre del botón(es) que vaya seleccionando. Pulsa el icono para salir de este modo.";
        showToast(toastMessage, "info", 15000);

        filterGridItems(); // Show all items in this mode
        applyInitialKeywordHighlights(); // Highlight items with the current filter word

    } else {
        showToast("Modo Asignación de Palabras Clave Desactivado", "info", 2000);
        cellElements.forEach(cell => cell.classList.remove('keyword-assigned-highlight'));
        filterGridItems(); // Re-apply normal filtering
    }
}

function applyInitialKeywordHighlights() {
    console.log("Applying initial keyword highlights...");
    const filterInput = document.getElementById('grid-filter-input');
    const keyword = filterInput.value.trim().replace(/\s+/g, '').toUpperCase();
    console.log("Highlight keyword:", keyword);

    if (!keyword) return;

    const keywordTag = `[${keyword}]`;

    cellElements.forEach((cell, index) => {
        const bookmark = currentBookmarks[index];
        if (bookmark && bookmark.name && bookmark.name.toUpperCase().includes(keywordTag)) { // Case-insensitive check
            cell.classList.add('keyword-assigned-highlight');
            console.log(`Highlighting cell ${index} with keyword "${keyword}"`);
        } else {
            cell.classList.remove('keyword-assigned-highlight');
        }
    });
}

function handleKeywordAssignmentClick(index) {
    console.log("Keyword Assignment click on index:", index);
    const filterInput = document.getElementById('grid-filter-input');
    const keyword = filterInput.value.trim().replace(/\s+/g, '').toUpperCase();

    if (!keyword) {
        showToast("Escribe una palabra en el campo filtro primero.", "warning");
        console.warn("No keyword entered for assignment.");
        return;
    }

    const bookmark = currentBookmarks[index];
    const cellElement = cellElements[index];

    if (!bookmark || !cellElement) {
        showToast(`No hay un marcador en la posición ${index + 1}.`, "warning");
        console.warn("No bookmark found at index:", index, "for keyword assignment.");
        return;
    }

    const keywordTag = `[${keyword}]`;
    const currentName = bookmark.name || "";
    const nameSpan = cellElement.querySelector('.bookmark-name');

    let newName = currentName;
    let actionTaken = '';

    // Check if the tag already exists (case-insensitive check on the name)
    if (currentName.toUpperCase().includes(keywordTag)) {
        // Remove the tag (case-sensitive removal based on the generated tag)
        // Use a regex to handle potential multiple spaces around the tag
        newName = currentName.replace(new RegExp(escapeRegExp(keywordTag), 'gi'), '').replace(/\s{2,}/g, ' ').trim();
        cellElement.classList.remove('keyword-assigned-highlight');
        actionTaken = 'removed';
        console.log(`Keyword "${keyword}" removed from cell ${index}. New name: "${newName}"`);

    } else {
        // Add the tag
        newName = currentName.trim();
        const lastBracketIndex = newName.lastIndexOf(']');
        const endsWithBracket = lastBracketIndex !== -1 && lastBracketIndex === newName.length - 1;

        // Add some spaces to separate tags, append at the end
        newName += '          ' + keywordTag;

        cellElement.classList.add('keyword-assigned-highlight');
        actionTaken = 'added';
        console.log(`Keyword "${keyword}" added to cell ${index}. New name: "${newName}"`);
    }

    bookmark.name = newName;
    currentBookmarks[index] = { ...bookmark };
    if (!customData.bookmarks) customData.bookmarks = {};
    customData.bookmarks[index] = { ...bookmark };
    saveCustomData();

    if (nameSpan) {
        nameSpan.textContent = newName;
    }

    if (actionTaken === 'added') {
        showToast(`"${keyword}" añadido. Nombre: ${newName}`, "success", 2500);
    } else if (actionTaken === 'removed') {
        showToast(`"${keyword}" quitado. Nombre: ${newName}`, "info", 2500);
    }
}

function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}


function handleToggleClickForAssignment(toggleElement) { const start = parseInt(toggleElement.dataset.rangeStart); if (isNaN(start)) return; console.log("Assignment mode: Toggle clicked:", toggleElement.textContent); currentlyAssigningToggleStart = start; document.querySelectorAll('.range-toggle').forEach(t => { t.classList.toggle('assigning-selected', t === toggleElement); t.style.opacity = t === toggleElement ? '' : '0.7'; }); updateGridAssignmentVisuals(); showToast(`Asignando botones para: ${toggleElement.textContent.substring(1)}`, "info", 2500); }

function handleGridCellClickForAssignment(cellIndex) {
    console.log("Assignment mode: Grid cell clicked:", cellIndex);
    if (currentlyAssigningToggleStart === null) { showToast("Selecciona primero un botón lateral (PdR,s, iAs, etc.)", "warning"); console.warn("No toggle selected for assignment."); return; }
    const startKey = currentlyAssigningToggleStart.toString();
    if (!customData.toggles[startKey]) { const currentRange = currentToggleRanges.find(r => r.start == startKey); customData.toggles[startKey] = { label: currentRange ? currentRange.label : `Rango ${startKey}`, assignedIndexes: currentRange ? [...currentRange.assignedIndexes] : [] }; console.log("Created new custom toggle data for key:", startKey);}
    else if (!customData.toggles[startKey].assignedIndexes) { const currentRange = currentToggleRanges.find(r => r.start == startKey); customData.toggles[startKey].assignedIndexes = currentRange ? [...currentRange.assignedIndexes] : []; console.log("Initialized assignedIndexes for existing custom toggle data:", startKey);}
    const assigned = customData.toggles[startKey].assignedIndexes;
    const indexInArray = assigned.indexOf(cellIndex);
    if (indexInArray > -1) {
        assigned.splice(indexInArray, 1);
        console.log("Removed cell", cellIndex, "from assignment for", startKey);
    } else {
        assigned.push(cellIndex);
        assigned.sort((a, b) => a - b);
        console.log("Added cell", cellIndex, "to assignment for", startKey);
    }
    const currentRangeIndex = currentToggleRanges.findIndex(r => r.start == startKey);
    if (currentRangeIndex > -1) { currentToggleRanges[currentRangeIndex].assignedIndexes = [...assigned]; }
    updateGridAssignmentVisuals();
    saveCustomData();
    showToast('Asignación guardada', 'success', 500);
}

function updateGridAssignmentVisuals() { console.log("Updating grid assignment visuals..."); if (!isAssignmentMode || currentlyAssigningToggleStart === null) { console.log("Not in assignment mode or no toggle selected. Removing assignment visuals."); cellElements.forEach(cell => { cell.classList.remove('assigned-to-current'); cell.style.opacity = ''; cell.style.outline=''; cell.style.boxShadow=''; cell.style.backgroundColor = ''; }); return; } const startKey = currentlyAssigningToggleStart.toString(); let assignedIndexesForCurrentToggle = []; if (customData.toggles[startKey] && customData.toggles[startKey].assignedIndexes) { assignedIndexesForCurrentToggle = customData.toggles[startKey].assignedIndexes; } else { const currentRange = currentToggleRanges.find(r => r.start == startKey); if (currentRange?.assignedIndexes) { assignedIndexesForCurrentToggle = currentRange.assignedIndexes; } } console.log("Assigned indexes for current toggle", startKey, ":", assignedIndexesForCurrentToggle); cellElements.forEach((cell, index) => { const isAssigned = assignedIndexesForCurrentToggle.includes(index); cell.classList.toggle('assigned-to-current', isAssigned); if (isAssigned) { cell.style.opacity = ''; cell.style.outline = '3px solid cyan'; cell.style.boxShadow = document.body.classList.contains('dark-mode') ? 'inset 0 0 10px rgba(0, 200, 200, 0.7)' : 'inset 0 0 8px rgba(0, 255, 255, 0.6)'; } else { cell.style.opacity = document.body.classList.contains('dark-mode') ? '0.5' : '0.6'; cell.style.outline = `1px dashed ${document.body.classList.contains('dark-mode') ? '#555' : '#aaa'}`; cell.style.boxShadow = ''; } }); console.log("Finished updating grid assignment visuals."); }

function showEditInfoModal() { console.log("Showing edit info modal."); const existingModal = document.querySelector('.edit-info-modal'); if (existingModal) existingModal.remove(); const modal = document.createElement('div'); modal.className = 'edit-info-modal'; modal.setAttribute('aria-label', 'Ayuda Personalización'); modal.innerHTML = ` <h2 class="text-xl font-bold mb-4">Ayuda de Personalización</h2> <p class="mb-3">Al pulsar el botón <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (personalizar) o el icono <img src="https://boardinggate.github.io/Tesla/IMG_4314.PNG" alt="Key" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (llave) puedes elegir entre varios modos:</p> <div class="mb-4 p-3 bg-yellow-100 border border-yellow-300 rounded"> <h3 class="font-semibold text-lg mb-2">1. Editar URLs / Etiquetas / Reordenar (Botón Personalizar Amarillo)</h3> <ul class="list-disc pl-5 space-y-1 text-sm"> <li><strong>Activar:</strong> Elige "URLs / Etiquetas / Reordenar" en el menú inicial. El botón <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> se pondrá amarillo.</li> <li><strong>Editar Marcador:</strong> Haz clic (o tap simple) en un marcador existente o un espacio vacío (+). Se abrirá un editor y el marcador se resaltará en amarillo.</li> <li><strong>Editar Etiqueta Sección:</strong> Haz clic (o tap simple) en un botón lateral (PdR,s, iAs, etc.). Se abrirá un editor y el botón se resaltará.</li> <li><strong>Guardar/Cancelar Edición:</strong> Usa los botones del editor. "Vaciar" elimina el marcador. "Resetear" vuelve al valor original. El resaltado amarillo desaparecerá al cerrar el editor.</li> <li><strong><span style="color:blue;">Reordenar Marcadores (Arrastrar y Soltar):</span></strong> <br>• <strong>PC:</strong> Haz clic sobre un marcador y, sin soltar, arrástralo a otra posición (incluso a un hueco vacío). Suelta el botón para fijar la nueva posición. <br>• <strong>Táctil:</strong> Mantén pulsado un marcador durante un instante y luego arrástralo a otra posición. Levanta el dedo para fijar la nueva posición. <br>• <strong>Funcionamiento:</strong> El marcador arrastrado se insertará en la posición donde lo sueltes, desplazando los marcadores siguientes. Los cambios se guardan automáticamente al soltar. </li> </ul> </div> <div class="mb-4 p-3 bg-cyan-100 border border-cyan-300 rounded"> <h3 class="font-semibold text-lg mb-2">2. Asignar Botones Ocultación (Botón Personalizar Cian)</h3> <ul class="list-disc pl-5 space-y-1 text-sm"> <li><strong>Activar:</strong> Elige "Asignar Botones Ocultación" en el menú inicial. El botón <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> se pondrá cian.</li> <li><strong>Seleccionar Botón Lateral:</strong> Haz clic en el botón lateral (PdR,s, iAs, etc.) cuyos marcadores quieres definir. Se resaltará.</li> <li><strong>Asignar/Desasignar Marcadores:</strong> Haz clic en cualquier marcador de la rejilla. Si estaba asignado, se desasignará (atenuado). Si no lo estaba, se asignará (resaltado). <strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li> <li><strong>Cambiar Botón Lateral:</strong> Haz clic en otro botón lateral para asignar sus marcadores.</li> <li><strong>Guardar:</strong> Los cambios se guardan automáticamente al salir de este modo (pulsando el botón <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> cian).</li> <li><strong>Visibilidad por defecto:</strong> Marcadores no asignados a <i>ningún</i> botón lateral siempre serán visibles (salvo que el botón general <img src="https://boardinggate.github.io/Tesla/IMG_4191.jpg" alt="OFF" style="width:20px; height:11px; display:inline; vertical-align:middle;"> esté desactivado).</li> </ul> </div> <div class="mb-4 p-3 bg-green-100 border border-green-300 rounded"> <h3 class="font-semibold text-lg mb-2">3. Asignar Palabra Clave Filtro (Icono Llave Verde)</h3> <ul class="list-disc pl-5 space-y-1 text-sm"> <li><strong>Activar:</strong> Pulsa el icono de la llave <img src="https://boardinggate.github.io/Tesla/IMG_4314.PNG" alt="Key" style="width:16px; height:16px; display:inline; vertical-align:middle;"> junto al campo de filtro. El icono se pondrá verde. Si vuelves a pulsar, se desactivará.</li> <li><strong>Escribe la Palabra:</strong> Escribe la palabra que quieres añadir al nombre de los botones en el campo de filtro. Se eliminarán los espacios automáticamente.</li> <li><strong>Asignar:</strong> Haz clic en el botón del grid al que quieres añadir la palabra clave. La palabra (en corchetes) se añadirá a su nombre (si no existe ya).</li> <li><strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li> <li><strong>Guardar:</strong> Los cambios se guardan automáticamente cada vez que asignas una palabra clave a un botón.</li> <li><strong>Mostrar Todo:</strong> Al activar este modo, se limpiará el filtro y se mostrarán todos los botones para facilitar la asignación.</li> </ul> </div> <p class="mb-4"><strong>Salir de Personalización:</strong> Pulsa el botón activo <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (amarillo o cian) o el icono de la llave <img src="https://boardinggate.github.io/Tesla/IMG_4314.PNG" alt="Key" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (verde) para desactivar el modo actual y volver al uso normal.</p> <div class="flex justify-end mt-5"> <button type="button" id="close-edit-info" class="px-6 py-2">Entendido</button> </div>`; document.body.appendChild(modal);
        const closeEditInfoButton = modal.querySelector('#close-edit-info');
        const closeHandler = () => {
            clearModalAutoCloseTimer(modal, closeEditInfoButton, 'edit-info-modal');
            if (modal.parentNode) modal.parentNode.removeChild(modal);
        };
        closeEditInfoButton.addEventListener('click', closeHandler);
        addModalAutoCloseTimer(modal, closeEditInfoButton, 'edit-info-modal');
    }

function showEditModal(targetIndexOrStart, isToggle = false) { console.log("Showing edit modal. Target:", targetIndexOrStart, "isToggle:", isToggle); if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); } const existingModal = document.querySelector('.edit-modal'); if (existingModal) existingModal.remove(); const modal = document.createElement('div'); modal.className = 'edit-modal'; if (isToggle) { editingTargetElement = toggleButtonElements[targetIndexOrStart]; } else { editingTargetElement = cellElements[targetIndexOrStart]; } if (editingTargetElement) { editingTargetElement.classList.add('editing-target'); } else { console.warn("Editing target element not found for index/start:", targetIndexOrStart); } let currentItemData = {}; let originalItemData = {}; let title = ''; let isNewBookmark = false; const targetIndex = isToggle ? -1 : targetIndexOrStart; if (isToggle) { const targetStart = targetIndexOrStart; const currentRange = currentToggleRanges.find(r => r.start === targetStart); const originalRange = originalToggleRanges.find(r => r.start === targetStart); const currentLabel = customData.toggles[targetStart]?.label ?? currentRange?.label ?? ''; currentItemData = { label: currentLabel }; originalItemData = { label: originalRange?.label || '' }; title = `Editar Etiqueta Sección`; modal.innerHTML = ` <h2>${title}</h2> <div><label for="edit-label">Etiqueta (máx 7):</label><input type="text" id="edit-label" value="${currentItemData.label}" maxlength="7"></div> <div class="button-group" style="margin-bottom: 1.2rem;"><button class="save">Guardar</button><button class="reset">Resetear</button><button class="cancel">Cancelar</button></div>`; } else { const currentBookmark = currentBookmarks[targetIndex]; const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null; currentItemData = currentBookmark ? { ...currentBookmark } : { name: '', url: '', favicon: '' }; originalItemData = originalBookmark ? { ...originalBookmark } : { name: '', url: '', favicon: '' }; isNewBookmark = !currentBookmark; title = currentBookmark ? `Editar Marcador: ${currentItemData?.name || `Índice ${targetIndex}`}` : `Añadir Marcador (Posición ${targetIndex + 1})`; modal.innerHTML = ` <h2>${title}</h2> <div><label for="edit-name">Nombre:</label><input type="text" id="edit-name" value="${currentItemData.name || ''}"></div> <div><label for="edit-url">URL:</label><div class="input-with-button"><input type="url" id="edit-url" value="${currentItemData.url || ''}" placeholder="https://ejemplo.com"><button class="search-button" id="search-url-button" title="Buscar URL en Google (basado en URL/Nombre)">🔍</button></div></div> <div><label for="edit-favicon">URL Favicon (Opcional):</label><div class="input-with-button"><input type="text" id="edit-favicon" value="${currentItemData.favicon || ''}" placeholder="Dejar vacío para auto"><button class="search-button" id="search-favicon-button" title="Buscar Favicon en Google Images (basado en Favicon/Nombre)">🖼️</button></div></div> <div class="button-group" style="margin-bottom: 1.2rem;"><button class="save">Guardar</button><button class="reset">Resetear</button><button class="empty">Vaciar</button><button class="cancel">Cancelar</button></div>`; } document.body.appendChild(modal); const cleanupEditModal = () => { console.log("Cleaning up edit modal."); if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; } if (modal.parentNode) modal.parentNode.removeChild(modal); }; modal.querySelector('.save').addEventListener('click', () => { console.log("Edit modal: Save clicked."); let dataChanged = false; if (isToggle) { const targetStart = targetIndexOrStart; const newLabel = modal.querySelector('#edit-label').value.trim(); if (!newLabel) { showToast("La etiqueta no puede estar vacía.", "warning"); return; } if (newLabel.length > 7) { showToast("La etiqueta no puede exceder 7 caracteres.", "warning"); return; } const originalLabel = originalToggleRanges.find(r => r.start === targetStart)?.label || ''; if (newLabel !== originalLabel) { if (!customData.toggles[targetStart]) customData.toggles[targetStart] = {}; customData.toggles[targetStart].label = newLabel; dataChanged = true; } else { if (customData.toggles[targetStart] && customData.toggles[targetStart].hasOwnProperty('label')) { delete customData.toggles[targetStart].label; if (Object.keys(customData.toggles[targetStart]).length === 0) delete customData.toggles[targetStart]; dataChanged = true; } } const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetStart); if (rangeIdx > -1) currentToggleRanges[rangeIdx].label = newLabel; console.log("Toggle label updated. Data changed:", dataChanged); } else { const nameInput = modal.querySelector('#edit-name'); const urlInput = modal.querySelector('#edit-url'); const faviconInput = modal.querySelector('#edit-favicon'); const newName = nameInput.value.trim(); const newUrl = urlInput.value.trim(); const newFavicon = faviconInput.value.trim() || null; const isEmpty = !newName && !newUrl && !newFavicon; const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null; if (isEmpty) { console.log("Bookmark is empty."); if (originalBookmark !== null && originalBookmark !== undefined) { console.log("Original was not empty. Marking as null."); if (!customData.bookmarks) customData.bookmarks = {}; customData.bookmarks[targetIndex] = null; dataChanged = true; } else { console.log("Original was already empty. Checking custom data."); if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) { console.log("Deleting from custom data."); delete customData.bookmarks[targetIndex]; dataChanged = true; } } currentBookmarks[targetIndex] = null; } else { if (!newName || !newUrl) { showToast("Nombre y URL son obligatorios.", "warning"); return; } try { new URL(newUrl); } catch (_) { showToast("URL inválida.", "warning"); return; } const bookmarkUpdate = { name: newName, url: newUrl, favicon: newFavicon }; const originalData = originalBookmark ? { name: originalBookmark.name, url: originalBookmark.url, favicon: originalBookmark.favicon || null } : null; const bookmarksAreEqual = (b1, b2) => { if (b1 === null && b2 === null) return true; if (b1 === null || b2 === null) return false; return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null); }; console.log("Bookmark update data:", bookmarkUpdate, "Original data:", originalData); if (!bookmarksAreEqual(bookmarkUpdate, originalData)) { console.log("Bookmark data changed. Saving to custom data."); if (!customData.bookmarks) customData.bookmarks = {}; customData.bookmarks[targetIndex] = bookmarkUpdate; dataChanged = true; } else { console.log("Bookmark data is same as original. Checking custom data."); if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) { delete customData.bookmarks[targetIndex]; dataChanged = true; } } currentBookmarks[targetIndex] = bookmarkUpdate; } console.log("Bookmark updated. Data changed:", dataChanged); } if (dataChanged) { saveCustomData(); showToast("Cambios guardados", "success"); } else { showToast("No se detectaron cambios", "info"); } updateGridItemUI(targetIndexOrStart, isToggle); cleanupEditModal(); }); modal.querySelector('.reset').addEventListener('click', () => { console.log("Edit modal: Reset clicked."); let dataChanged = false; if (isToggle) { const targetStart = targetIndexOrStart; const originalRange = originalToggleRanges.find(r => r.start === targetStart); const originalLabel = originalRange?.label || ''; modal.querySelector('#edit-label').value = originalLabel; if (customData.toggles && customData.toggles[targetStart] && customData.toggles[targetStart].hasOwnProperty('label')) { delete customData.toggles[targetStart].label; if (Object.keys(customData.toggles[targetStart]).length === 0) delete customData.toggles[targetStart]; dataChanged = true; } const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetStart); if (rangeIdx > -1) currentToggleRanges[rangeIdx].label = originalLabel; console.log("Toggle label reset. Data changed:", dataChanged); } else { const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null; modal.querySelector('#edit-name').value = originalBookmark?.name || ''; modal.querySelector('#edit-url').value = originalBookmark?.url || ''; modal.querySelector('#edit-favicon').value = originalBookmark?.favicon || ''; if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) { delete customData.bookmarks[targetIndex]; dataChanged = true; } currentBookmarks[targetIndex] = originalBookmark ? { ...originalBookmark } : null; console.log("Bookmark reset. Data changed:", dataChanged); } if (dataChanged) { saveCustomData(); showToast("Valores reseteados al original y guardados", "info"); } else { showToast("Ya estaba con los valores originales", "info"); } updateGridItemUI(targetIndexOrStart, isToggle); cleanupEditModal(); }); modal.querySelector('.cancel').addEventListener('click', () => { console.log("Edit modal: Cancel clicked."); cleanupEditModal(); }); if (!isToggle) { const emptyBtn = modal.querySelector('.empty'); if (emptyBtn) { emptyBtn.addEventListener('click', () => { console.log("Edit modal: Empty clicked."); modal.querySelector('#edit-name').value = ''; modal.querySelector('#edit-url').value = ''; modal.querySelector('#edit-favicon').value = ''; const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null; let dataChanged = false; if (originalBookmark !== null && originalBookmark !== undefined) { console.log("Original was not empty. Marking as null."); if (!customData.bookmarks) customData.bookmarks = {}; customData.bookmarks[targetIndex] = null; dataChanged = true; } else { console.log("Original was already empty. Checking custom data."); if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) { console.log("Deleting from custom data."); delete customData.bookmarks[targetIndex]; dataChanged = true; } } currentBookmarks[targetIndex] = null; if(dataChanged) { saveCustomData(); showToast("Marcador vaciado y guardado.", "success"); } else { showToast("Marcador ya estaba vacío.", "info"); } updateGridItemUI(targetIndex, false); cleanupEditModal(); }); } const searchUrlBtn = modal.querySelector('#search-url-button'); const searchFaviconBtn = modal.querySelector('#search-favicon-button'); const nameInput = modal.querySelector('#edit-name'); const urlInput = modal.querySelector('#edit-url'); const faviconInput = modal.querySelector('#edit-favicon'); if (searchUrlBtn) { searchUrlBtn.addEventListener('click', () => { console.log("Search URL clicked."); const urlValue = urlInput.value.trim(); const nameValue = nameInput.value.trim(); const query = urlValue || nameValue; if (query) { console.log("Searching Google for URL/Name:", query); window.open(`https://www.google.com/search?q=${encodeURIComponent(query)}`, '_blank'); } else { showToast("Escribe un Nombre o URL para buscar.", "warning"); } }); } if (searchFaviconBtn) { searchFaviconBtn.addEventListener('click', () => { console.log("Search Favicon clicked."); const faviconValue = faviconInput.value.trim(); const nameValue = nameInput.value.trim(); const query = faviconValue || nameValue; if (query) { console.log("Searching Google Images for favicon:", query); window.open(`https://www.google.com/search?tbm=isch&q=${encodeURIComponent(`"${query}" favicon logo icon`)}`, '_blank'); } else { showToast("Escribe un Nombre o URL de Favicon para buscar.", "warning"); } }); } } }

function updateGridItemUI(indexOrStart, isToggle = false) {
    console.log("Updating grid item UI. Index/Start:", indexOrStart, "isToggle:", isToggle);
    renderGrid();
    renderToggleButtons();
    loadSavedSettings(); // This calls updateButtonStyles internally

    if (isAssignmentMode) {
        updateGridAssignmentVisuals();
        if (currentlyAssigningToggleStart !== null && toggleButtonElements[currentlyAssigningToggleStart]) {
            toggleButtonElements[currentlyAssigningToggleStart].classList.add('assigning-selected');
            toggleButtonElements[currentlyAssigningToggleStart].style.opacity = '';
        }
    } else if (isKeywordAssignmentMode) {
        applyInitialKeywordHighlights();
    }
}

function performInsertAndSave(sourceIndex, targetIndex) { console.log("Performing drag-and-drop insert. Source:", sourceIndex, "Target:", targetIndex); if (sourceIndex === targetIndex || sourceIndex === null || targetIndex === null) { console.log("Source equals target or is null. Aborting."); return false; } const draggedData = currentBookmarks.splice(sourceIndex, 1)[0]; currentBookmarks.splice(targetIndex, 0, draggedData); console.log("Bookmarks array updated."); if (!customData.bookmarks) customData.bookmarks = {}; if (!customData.toggles) customData.toggles = {}; const minIdx = Math.min(sourceIndex, targetIndex); const maxIdx = Math.max(sourceIndex, targetIndex); currentToggleRanges.forEach(range => { if (range.assignedIndexes) { const oldAssigned = [...range.assignedIndexes]; range.assignedIndexes = range.assignedIndexes.map(idx => { if (idx === sourceIndex) return targetIndex; else if (idx > sourceIndex && idx <= targetIndex) return idx - 1; else if (idx < sourceIndex && idx >= targetIndex) return idx + 1; else return idx; }).sort((a, b) => a - b); const startKey = range.start.toString(); // Only update customData if the assigned indexes actually changed const assignedArraysEqual = (arr1, arr2) => arr1.length === arr2.length && arr1.every((val, index) => val === arr2[index]); if (!assignedArraysEqual(oldAssigned, range.assignedIndexes)) { if (!customData.toggles[startKey]) customData.toggles[startKey] = {}; customData.toggles[startKey].assignedIndexes = [...range.assignedIndexes]; } console.log(`Toggle range ${startKey}: Assigned indexes updated from ${oldAssigned} to ${range.assignedIndexes}`); } }); // Update customData.bookmarks for all affected indices between min and max index for (let i = minIdx; i <= maxIdx; i++) { const currentItem = currentBookmarks[i]; const originalItem = i < originalBookmarks.length ? originalBookmarks[i] : null; const bookmarksAreEqual = (b1, b2) => { if (b1 === null && b2 === null) return true; if (b1 === null || b2 === null) return false; return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null); }; if (!bookmarksAreEqual(currentItem, originalItem)) { customData.bookmarks[i] = currentItem ? { ...currentItem } : null; console.log(`Index ${i}: Bookmark changed from original. Saving to custom data.`); } else if (customData.bookmarks && customData.bookmarks.hasOwnProperty(i)) { delete customData.bookmarks[i]; console.log(`Index ${i}: Bookmark is back to original. Removing from custom data.`); } } // Clean up empty custom toggle entries after updating assignedIndexes Object.keys(customData.toggles).forEach(startKey => { if (customData.toggles[startKey] && Object.keys(customData.toggles[startKey]).length === 0) { delete customData.toggles[startKey]; console.log(`Custom toggle entry for ${startKey} is empty. Deleting.`); } }); // Clean up empty custom bookmarks entries if any were explicitly set to null and now removed? (Should be handled by the loop) saveCustomData(); console.log("Drag and drop successful."); showToast(`Movido de ${sourceIndex + 1} a ${targetIndex + 1}`, "success", 1500); renderGrid(); loadSavedSettings(); return true; }

function handleDragStart(e) { if (!isEditMode) return; console.log("Drag start."); draggedItem = e.currentTarget; draggedItemIndex = parseInt(draggedItem.dataset.index); e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', draggedItemIndex); setTimeout(() => { if (draggedItem) draggedItem.classList.add('dragging'); }, 0); }

function handleDragOver(e) { if (!isEditMode || !draggedItem) return; e.preventDefault(); e.dataTransfer.dropEffect = 'move'; const targetCell = e.target.closest('.grid-cell'); const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetCell && targetIndex !== dragOverIndex) { if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } if (targetIndex !== draggedItemIndex) { targetCell.classList.add('drag-over'); dragOverIndex = targetIndex; } else { dragOverIndex = null; } console.log("Drag over index:", dragOverIndex);} else if (!targetCell && dragOverIndex !== null) { if (cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } dragOverIndex = null; console.log("Drag left grid. Drag over index:", dragOverIndex); } }

function handleDragLeave(e) { if (!isEditMode || !draggedItem) return; const targetCell = e.target.closest('.grid-cell'); if (targetCell && !targetCell.contains(e.relatedTarget)) { if (parseInt(targetCell.dataset.index) === dragOverIndex) { targetCell.classList.remove('drag-over'); dragOverIndex = null; console.log("Drag leave target cell. Drag over index:", dragOverIndex); } } }

function handleDrop(e) { if (!isEditMode || !draggedItem) return; e.preventDefault(); console.log("Drop event."); const targetCell = e.target.closest('.grid-cell'); const sourceIndex = draggedItemIndex; const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetIndex !== null && sourceIndex !== targetIndex) { console.log("Valid drop target. Performing insert."); performInsertAndSave(sourceIndex, targetIndex); } else { console.log("Invalid drop target or drop on self."); if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } } handleDragEndCleanup(); }

function handleDragEnd(e) { console.log("Drag end."); if (!isEditMode) return; handleDragEndCleanup(); }

function handleDragEndCleanup() { console.log("Cleaning up drag end."); if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } draggedItem = null; draggedItemIndex = null; dragOverIndex = null; }

function handleTouchStart(e) { if (!isEditMode || e.touches.length !== 1) return; console.log("Touch start."); draggedItem = e.currentTarget; draggedItemIndex = parseInt(draggedItem.dataset.index); const touch = e.touches[0]; touchStartX = touch.clientX; touchStartY = touch.clientY; draggedItem.classList.add('dragging'); currentTouchTarget = draggedItem; e.preventDefault(); // Prevent default scroll/zoom }

function handleTouchMove(e) { if (!isEditMode || !draggedItem || e.touches.length !== 1) return; e.preventDefault(); const touch = e.touches[0]; const elementOver = document.elementFromPoint(touch.clientX, touch.clientY); const targetCell = elementOver?.closest('.grid-cell'); const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetCell && targetIndex !== dragOverIndex) { if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } if (targetIndex !== draggedItemIndex) { targetCell.classList.add('drag-over'); dragOverIndex = targetIndex; currentTouchTarget = targetCell; } else { dragOverIndex = null; currentTouchTarget = draggedItem; } console.log("Touch move over index:", dragOverIndex); } else if (!targetCell && dragOverIndex !== null) { if (cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } dragOverIndex = null; currentTouchTarget = null; console.log("Touch move left grid. Drag over index:", dragOverIndex); } }

function handleTouchEnd(e) { if (!isEditMode || !draggedItem) return; console.log("Touch end."); // Prevent default click behavior if it was a drag/long press e.preventDefault(); if (dragOverIndex !== null && dragOverIndex !== draggedItemIndex) { console.log("Valid touch drop target. Performing insert."); performInsertAndSave(draggedItemIndex, dragOverIndex); } else { console.log("Invalid touch drop target or drop on self."); if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } } handleTouchEndCleanup(); }

function handleTouchCancel(e) { console.log("Touch cancel."); if (!isEditMode) return; handleTouchEndCleanup(); }

function handleTouchEndCleanup() { console.log("Cleaning up touch end."); if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } draggedItem = null; draggedItemIndex = null; dragOverIndex = null; currentTouchTarget = null; touchStartX = 0; touchStartY = 0; }

function normalizeText(text) { if (!text) return ''; return text.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, ''); }

function filterGridItems() {
    console.log("Filtering grid items.");
    const filterInput = document.getElementById('grid-filter-input');
    const clearButton = document.getElementById('clear-filter-button');
    if (!filterInput || !clearButton || !cellElements || cellElements.length === 0) { console.warn("Filter elements or cells not found."); return; }

    if (isKeywordAssignmentMode) {
        console.log("Keyword Assignment mode active. Showing all items.");
        cellElements.forEach(cellContainer => {
            cellContainer.classList.remove('hidden');
        });
        clearButton.style.display = filterInput.value.trim() ? 'inline-block' : 'none';
        return;
    }

    const rawFilterText = filterInput.value.trim();
    clearButton.style.display = rawFilterText ? 'inline-block' : 'none';

    const filterWords = rawFilterText.split(/\s+/).filter(word => word.length > 0).map(word => normalizeText(word));
    const masterState = document.getElementById('on-off-toggle')?.dataset.state || 'on';
    console.log("Filter words:", filterWords, "Master state:", masterState);


    cellElements.forEach((cellContainer, index) => {
        const isMasterOff = masterState === 'off';
        if (isMasterOff) {
            cellContainer.classList.add('hidden');
            return;
        }

        const bookmark = currentBookmarks[index];
        const bookmarkName = bookmark ? normalizeText(bookmark.name) : '';
        const isEmptySlot = !bookmark;

        let matchesFilter = true;
        if (filterWords.length > 0) {
            if (isEmptySlot) {
                matchesFilter = false;
            } else {
                matchesFilter = filterWords.some(word => bookmarkName.includes(word));
            }
        }

        const shouldBeHiddenByFilter = filterWords.length > 0 && !matchesFilter;

        let shouldBeHiddenByToggles = false;
        const containingRange = getSectionForIndex(index);
        if (containingRange) {
            const toggleButton = toggleButtonElements[containingRange.start];
            const toggleState = toggleButton?.dataset.state || 'visible';
            shouldBeHiddenByToggles = toggleState === 'hidden';
        } else {
            shouldBeHiddenByToggles = false;
        }

        const shouldBeHidden = shouldBeHiddenByToggles || shouldBeHiddenByFilter;
        cellContainer.classList.toggle('hidden', shouldBeHidden);
        // if (shouldBeHidden) { console.log(`Cell ${index} hidden. By filter: ${shouldBeHiddenByFilter}, By toggle: ${shouldBeHiddenByToggles}`); } else { console.log(`Cell ${index} visible.`); }
    });
    console.log("Finished filtering grid items.");
}


function promptForPin() { console.log("Prompting for PIN."); const pinModal = document.getElementById('pin-modal-overlay'); const pinInput = document.getElementById('pin-input'); const pinSubmit = document.getElementById('pin-submit-button'); const pinError = document.getElementById('pin-error-message'); if(pinModal) pinModal.classList.remove('hidden'); if(pinInput) pinInput.value = ''; if(pinError) pinError.textContent = ''; if(pinInput) pinInput.focus(); // Re-add listener to prevent duplicates if modal was previously opened const newPinSubmit = pinSubmit.cloneNode(true); pinSubmit.parentNode.replaceChild(newPinSubmit, pinSubmit); newPinSubmit.addEventListener('click', checkPin); if(pinInput) pinInput.addEventListener('keyup', (event) => { if (event.key === 'Enter') { checkPin(); } }); }

function checkPin() { console.log("Checking PIN."); const pinModal = document.getElementById('pin-modal-overlay'); const pinInput = document.getElementById('pin-input'); const pinError = document.getElementById('pin-error-message'); const enteredPin = pinInput ? pinInput.value : ''; console.log("Entered PIN:", enteredPin, "Stored PIN exists:", !!storedPin); if (enteredPin === storedPin) { console.log("PIN correct. Initializing app."); if(pinModal) pinModal.classList.add('hidden'); initializeApp(); } else { console.warn("PIN incorrect."); if(pinError) pinError.textContent = 'Clave incorrecta.'; if(pinInput) pinInput.value = ''; if(pinInput) pinInput.focus(); if (navigator.vibrate) navigator.vibrate(100); } }

function handlePasswordToggleClick() { console.log("Password toggle clicked. Current active state:", isPasswordActive); if (!storedPin) { showToast('Primero establece una clave en Configuración -> Usuario.', 'warning'); console.warn("No stored PIN."); return; } isPasswordActive = !isPasswordActive; updatePasswordToggleIcon(); saveSettings(); showToast(`Solicitar clave al inicio: ${isPasswordActive ? 'Activado' : 'Desactivado'}`, 'info'); }

function updatePasswordToggleIcon() { const passwordButton = document.getElementById('password-toggle-button'); if (passwordButton) { const img = passwordButton.querySelector('img'); if(img) { const iconPath = isPasswordActive ? 'IMG_4281.png' : 'IMG_4280.png'; img.src = `https://boardinggate.github.io/Tesla/${iconPath}`;
    img.alt = isPasswordActive ? 'Clave Activada' : 'Clave Desactivada'; passwordButton.title = `Clave al inicio: ${isPasswordActive ? 'Activada' : 'Desactivada'}`; console.log("Password icon updated. Active state:", isPasswordActive); } else { console.warn("Password button img not found."); } } else { console.warn("Password button not found."); } }

function savePinSettings() { console.log("Saving PIN settings."); const pinSetInput = document.getElementById('config-pin-set'); const pinConfirmInput = document.getElementById('config-pin-confirm'); const pinStatus = document.getElementById('config-pin-status'); const newPin = pinSetInput ? pinSetInput.value : ''; const confirmPin = pinConfirmInput ? pinConfirmInput.value : ''; if(pinStatus) pinStatus.textContent = ''; if (!/^\d{4}$/.test(newPin)) { if(pinStatus) { pinStatus.textContent = 'La clave debe tener exactamente 4 cifras.'; pinStatus.style.color = '#EF4444'; } showToast("La clave debe tener exactamente 4 cifras.", "warning"); console.warn("Invalid PIN format."); return; } if (newPin !== confirmPin) { if(pinStatus) { pinStatus.textContent = 'Las claves no coinciden.'; pinStatus.style.color = '#EF4444'; } showToast("Las claves no coinciden.", "warning"); console.warn("PINs do not match."); return; } try { localStorage.setItem('password_pin', newPin); storedPin = newPin; // Also update the runtime variable if (!localStorage.getItem('password_active') || isPasswordActive) { isPasswordActive = true; localStorage.setItem('password_active', 'true'); } if(pinStatus) { pinStatus.textContent = 'Clave guardada correctamente.'; pinStatus.style.color = '#28a745'; } if(pinSetInput) pinSetInput.value = ''; if(pinConfirmInput) pinConfirmInput.value = ''; updatePasswordToggleIcon(); saveSettings(); showToast('Clave guardada.', 'success'); console.log("PIN saved successfully."); } catch (e) { if(pinStatus) { pinStatus.textContent = 'Error al guardar la clave.'; pinStatus.style.color = '#EF4444'; } showToast('Error al guardar la clave.', 'error'); console.error("Error saving PIN:", e); } }

function removePinSettings() { console.log("Attempting to remove PIN settings."); const pinStatus = document.getElementById('config-pin-status'); if (confirm('¿Estás seguro de que deseas eliminar la clave de acceso? Ya no se solicitará al inicio.')) { try { localStorage.removeItem('password_pin'); localStorage.setItem('password_active', 'false'); storedPin = null; isPasswordActive = false; if(pinStatus) { pinStatus.textContent = 'Clave eliminada.'; pinStatus.style.color = '#17a2b8'; } if(document.getElementById('config-pin-set')) document.getElementById('config-pin-set').value = ''; if(document.getElementById('config-pin-confirm')) document.getElementById('config-pin-confirm').value = ''; updatePasswordToggleIcon(); saveSettings(); showToast('Clave eliminada.', 'info'); console.log("PIN removed successfully."); } catch (e) { if(pinStatus) { pinStatus.textContent = 'Error al eliminar la clave.'; pinStatus.style.color = '#EF4444'; } showToast('Error al eliminar la clave.', 'error'); console.error("Error removing PIN:", e); } } else { console.log("PIN removal cancelled by user."); } }

async function getRemoteUpdatesDate() {
    console.log("Fetching remote updates date...");
    try {
        const response = await fetch('https://boardinggate.github.io/Tesla/updates.txt', {
            cache: 'no-cache'
        });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const text = await response.text();
        const firstLine = text.split('\n')[0].trim();
        const dateMatch = firstLine.match(/^\d{4}-\d{2}-\d{2}/);
        if (dateMatch) {
            const [year, month, day] = dateMatch[0].split('-').map(Number);
            const remoteDate = new Date(Date.UTC(year, month - 1, day));
            if (!isNaN(remoteDate.getTime())) {
                console.log("Successfully fetched remote date:", dateMatch[0]);
                return dateMatch[0];
            }
        }
        console.warn("Remote updates file did not contain a valid date string on the first line.");
        return null;
    } catch (e) {
        console.error("Error fetching remote updates date:", e);
        return null;
    }
}

function isRemoteDateNewer(remoteDateStr, cachedDateStr) {
    console.log("Comparing remote date", remoteDateStr, "with cached date", cachedDateStr);
    if (!remoteDateStr) return false;
    if (!cachedDateStr) return true;
    try {
        return remoteDateStr > cachedDateStr;
    } catch (e) {
        console.error("Error comparing dates:", e);
        return false;
    }
}

async function checkVersionsIconOpacity() {
    console.log("Checking versions icon opacity based on updates...");
    const versionsIcon = document.getElementById('versions-button');
    const versionsImg = versionsIcon ? versionsIcon.querySelector('img') : null;
    if (!versionsImg) { console.warn("Versions icon image not found."); return; }

    let showAsNew = false;
    const remoteDateStr = await getRemoteUpdatesDate();

    if (remoteDateStr) {
        showAsNew = isRemoteDateNewer(remoteDateStr, lastUpdatesCheckDate);
    }
    versionsImg.style.opacity = showAsNew ? '1.0' : '0.1';
    console.log("Versions icon opacity set. Show as new:", showAsNew);
}


async function showVersionsModal() {
    console.log("Showing versions modal.");
    const versionsModalOverlay = document.getElementById('versions-modal-overlay');
    const versionsContent = document.getElementById('versions-content');
    const closeButton = document.getElementById('close-versions-modal');
    if (!versionsModalOverlay || !versionsContent || !closeButton) { console.error("Versions modal elements not found."); return; }

    // Remove existing listener and re-add to prevent multiple handlers
    const newCloseButton = closeButton.cloneNode(true);
    closeButton.parentNode.replaceChild(newCloseButton, closeButton);

    const closeHandler = () => {
        console.log("Closing versions modal.");
        versionsModalOverlay.classList.add('hidden');
        clearModalAutoCloseTimer(versionsModalOverlay, newCloseButton, 'versions-modal');
    };
    newCloseButton.addEventListener('click', closeHandler);

    versionsContent.textContent = 'Cargando histórico...';
    versionsModalOverlay.classList.remove('hidden');
    addModalAutoCloseTimer(versionsModalOverlay, newCloseButton, 'versions-modal');


    try {
        console.log("Fetching updates.txt content...");
        const response = await fetch('https://boardinggate.github.io/Tesla/updates.txt', {
            cache: 'no-cache'
        });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const text = await response.text();
        versionsContent.textContent = text;
        console.log("Updates.txt content loaded.");

        const firstLine = text.split('\n')[0].trim();
        const dateMatch = firstLine.match(/^\d{4}-\d{2}-\d{2}/);
        let dateToStore = null;
        if (dateMatch) {
            const [year, month, day] = dateMatch[0].split('-').map(Number);
            const checkDate = new Date(Date.UTC(year, month - 1, day));
            if (!isNaN(checkDate.getTime())) {
                dateToStore = dateMatch[0];
            }
        }

        if (dateToStore) {
            lastUpdatesCheckDate = dateToStore;
            console.log("Last updates check date updated to:", lastUpdatesCheckDate);
        } else {
            const today = new Date();
            lastUpdatesCheckDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
            console.warn("Could not parse date from updates.txt. Setting last check date to today:", lastUpdatesCheckDate);
        }

        saveSettings(); // Save the updated lastUpdatesCheckDate
        checkVersionsIconOpacity(); // Update opacity immediately


    } catch (e) {
        versionsContent.textContent = `Error al cargar el histórico:\n${e.message}`;
        console.error("Error loading updates.txt:", e);
    }
}

function getCurrentLocation(callback, errorCallback) {
    console.log("Attempting to get current location...");
    if ('geolocation' in navigator) {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                console.log("Geolocation success:", position.coords);
                callback({
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy,
                    altitude: position.coords.altitude,
                    heading: position.coords.heading
                });
            },
            (error) => {
                let message = "No se pudo obtener la ubicación.";
                switch (error.code) {
                    case error.PERMISSION_DENIED:
                        message = "Permiso de ubicación denegado.";
                        break;
                    case error.POSITION_UNAVAILABLE:
                        message = "Información de ubicación no disponible.";
                        break;
                    case error.TIMEOUT:
                        message = "Timeout obteniendo ubicación.";
                        break;
                    default:
                        message = `Error (${error.code}).`;
                        break;
                }
                console.error("Geolocation error:", error);
                if (errorCallback) errorCallback(message);
                else showToast(message, "error");
            }, {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 0
            } // High accuracy, 10s timeout, no cache
        );
    } else {
        const message = "Geolocalización no soportada por este navegador.";
        console.error(message);
        if (errorCallback) errorCallback(message);
        else showToast(message, "error");
    }
}

function calculateDistance(lat1, lon1, lat2, lon2) {
    // Haversine formula for distance between two points on a sphere
    const R = 6371e3; // metres
    const φ1 = lat1 * Math.PI / 180; // φ, λ in radians
    const φ2 = lat2 * Math.PI / 180;
    const Δφ = (lat2 - lat1) * Math.PI / 180;
    const Δλ = (lon2 - lon1) * Math.PI / 180;

    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
        Math.cos(φ1) * Math.cos(φ2) *
        Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c; // In metres
}


function parseReminderText(text, elementsToUpdate = null) {
    console.log("Parsing reminder text:", text);
    const result = {
        text: `<b>${text.trim().toUpperCase()}</b>`,
        time: null,
        date: null,
        repeatDays: [],
        intervalDays: null,
        type: null,
        isLocationEnabled: false,
        locationCoordinates: null,
        radiusMeters: 1000,
        excludeFromList: false
    };
    let norm = text.toUpperCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');

    // Time parsing
    const numW = {
        'UNA': 1,
        'UNO': 1,
        'DOS': 2,
        'TRES': 3,
        'CUATRO': 4,
        'CINCO': 5,
        'SEIS': 6,
        'SIETE': 7,
        'OCHO': 8,
        'NUEVE': 9,
        'DIEZ': 10,
        'ONCE': 11,
        'DOCE': 12,
        'TRECE': 13,
        'CATORCE': 14,
        'QUINCE': 15,
        'DIECISEIS': 16,
        'DIECISIETE': 17,
        'DIECIOCHO': 18,
        'DIECINUEVE': 19,
        'VEINTE': 20,
        'VEINTIUNO': 21,
        'VEINTIDOS': 22,
        'VEINTITRES': 23,
        'VEINTICUATRO': 24,
        'VEINTICINCO': 25,
        'VEINTISEIS': 26,
        'VEINTISIETE': 27,
        'VEINTIOCHO': 28,
        'VEINTINUEVE': 29,
        'TREINTA': 30,
        'TREINTAYUNO': 31
    };
    const tRgx = /\b(\d{1,2}):(\d{2})\b/; // HH:MM format
    const ttRgx = /.*\bA\s*LAS?\s*(\d+|\w+)\s*(?:Y\s*(CUARTO|MEDIA|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA)|MENOS\s*(CUARTO|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA))?\s*(DE\s*LA\s*(MANANA|TARDE|NOCHE))?/i; // "a las cinco y media tarde"
    const tM = norm.match(tRgx);
    if (tM) {
        let h = parseInt(tM[1]);
        let m = parseInt(tM[2]);
        if (h >= 0 && h <= 23 && m >= 0 && m <= 59) result.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
    } else {
        const ttM = norm.match(ttRgx);
        if (ttM) {
            let h = numW[ttM[1].toUpperCase()] || parseInt(ttM[1]);
            if (!isNaN(h)) {
                const minTxt = ttM[2]?.toUpperCase() || '';
                const minus = ttM[3]?.toUpperCase() || '';
                const period = ttM[5]?.toUpperCase() || null;
                let m = 0;
                if (minTxt) m = minTxt === 'CUARTO' ? 15 : minTxt === 'MEDIA' ? 30 : numW[minTxt] || parseInt(minTxt) || 0;
                else if (minus) { m = minus === 'CUARTO' ? 15 : numW[minus] || parseInt(minus) || 0; h = (h - 1 + 24) % 24; m = (60 - m + 60) % 60; }
                if (period) { if (period === 'TARDE' && h >= 1 && h <= 11) h += 12; if (period === 'NOCHE' && h >= 1 && h <= 11) h += 12; if (period === 'MANANA' && h === 12) h = 0; if (period === 'TARDE' && h === 12) h = 12; if (period === 'NOCHE' && h === 12) h = 0; } else if (h >= 1 && h <= 5) h += 12; // Assume afternoon if no period specified for 1-5
                if (h >= 0 && h <= 23 && m >= 0 && m <= 59) result.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
            }
        }
    }
    console.log("Parsed time:", result.time);

    // Date parsing
    const now = new Date();
    const manDRgx = /(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{2}|\d{4})\b/; // DD/MM/YYYY or DD.MM.YY etc.
    const manDM = norm.match(manDRgx);
    if (manDM && !result.date) {
        let d = parseInt(manDM[1]);
        let m = parseInt(manDM[2]);
        let y = parseInt(manDM[3]);
        if (y >= 0 && y <= 99) y += 2000; // Assume 21st century for 2-digit years
        // Basic validation for day/month/year range
        if (d >= 1 && d <= 31 && m >= 1 && m <= 12 && y >= 2000 && y <= 2099) {
            // Validate if the date is actually valid (e.g., no 31/02)
            const tD = new Date(Date.UTC(y, m - 1, d)); // Use UTC to avoid timezone issues with parsing
            if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() + 1 === m && tD.getUTCFullYear() === y) {
                result.date = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`;
            }
        }
    }

    const todayRgx = /\bHOY\b/;
    const tomRgx = /\bMANANA\b/;
    const dayAftRgx = /\bPASADO\s*MANANA\b/;
    if (!result.date) {
        if (norm.match(todayRgx)) {
            result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
        } else if (norm.match(dayAftRgx)) {
            const tD = new Date(now);
            tD.setDate(now.getDate() + 2);
            result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`;
        } else if (norm.match(tomRgx)) {
            const tD = new Date(now);
            tD.setDate(now.getDate() + 1);
            result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`;
        }
    }

    const daysMap = { 'LUNES': 1, 'MARTES': 2, 'MIERCOLES': 3, 'MIÉRCOLES': 3, 'JUEVES': 4, 'VIERNES': 5, 'SABADO': 6, 'SÁBADO': 6, 'DOMINGO': 0 };
    const dndRgx = /(?:EL\s*(PROXIMO)?\s*)?(LUNES|MARTES|MIERCOLES|MIÉRCOLES|JUEVES|VIERNES|SABADO|SÁBADO|DOMINGO)/i; // "el lunes", "el proximo sabado"
    const dndM = norm.match(dndRgx);
    if (dndM && !result.date) {
        const tDN = dndM[2].toUpperCase();
        const tD = daysMap[tDN];
        if (tD !== undefined) {
            const curD = now.getDay(); // 0 for Sunday, 6 for Saturday
            let dU = (tD - curD + 7) % 7;
            if (dU === 0) dU = 7; // If today is the target day, the "next" one is 7 days from now
            if (dndM[1]?.toUpperCase() === 'PROXIMO') dU += 7; // "proximo" means 7 days after the *next* occurrence

            const target = new Date(now);
            target.setDate(now.getDate() + dU);
            result.date = `${target.getFullYear()}-${(target.getMonth() + 1).toString().padStart(2, '0')}-${target.getDate().toString().padStart(2, '0')}`;
        }
    }

    const didRgx = /DENTRO\s*DE\s*(\d+)\s*DIAS?/; // "dentro de 3 dias"
    const didM = norm.match(didRgx);
    if (didM && !result.date) {
        const d = parseInt(didM[1]);
        if (!isNaN(d) && d > 0) {
            const tD = new Date(now);
            tD.setDate(now.getDate() + d);
            result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`;
        }
    }

    const dsdRgx = /\bEL\s*DIA\s*(\d{1,2})\b/; // "el dia 22"
    const dsdM = norm.match(dsdRgx);
    if (dsdM && !result.date) {
        const d = parseInt(dsdM[1]);
        if (!isNaN(d) && d >= 1 && d <= 31) {
            let tM = now.getMonth();
            let tY = now.getFullYear();
            // If the target day has already passed this month, assume next month
            if (d < now.getDate()) {
                tM++;
                if (tM > 11) { tM = 0; tY++; }
            }
            const tD = new Date(Date.UTC(tY, tM, d));
            // Validate if the date is valid for the chosen month/year
            if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() === tM) {
                result.date = `${tY}-${(tM + 1).toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`;
            } else {
                // If invalid date (e.g. 31/02), try adding a month if the day is invalid in the selected month but passed today
                const tempDate = new Date(Date.UTC(tY, tM, 1)); // Start of potential month
                if (d >= 1 && d <= 31) { // Day is in valid range 1-31
                    if (tempDate.getUTCMonth() === tM) { // Check if month is still the same (means day was valid)
                        // This case is already handled above.
                    } else { // Month changed, meaning original day was invalid for that month
                        // Let's just ignore this pattern if the day is invalid for the month.
                    }
                }
            }
        }
    }

    console.log("Parsed date:", result.date);


    // Repetition days parsing (weekly)
    const daysMapShort = { 'LUN': 1, 'MAR': 2, 'MIE': 3, 'JUE': 4, 'VIE': 5, 'SAB': 6, 'DOM': 0 };
    const daysMapLong = { 'LUNES': 1, 'MARTES': 2, 'MIERCOLES': 3, 'MIÉRCOLES': 3, 'JUEVES': 4, 'VIERNES': 5, 'SABADO': 6, 'SÁBADO': 6, 'DOMINGO': 0 };
    const dayNamesRegex = /(LUNES|MARTES|MIERCOLES|MIÉRCOLES|JUEVES|VIERNES|SABADO|SÁBADO|DOMINGO|LUN|MAR|MIE|JUE|VIE|SAB|DOM)/g;
    let wM;
    // Need to reset regex lastIndex if using global flag repeatedly
    dayNamesRegex.lastIndex = 0;
    while ((wM = dayNamesRegex.exec(norm)) !== null) {
        const dayMatch = wM[1].toUpperCase();
        const day = daysMapLong[dayMatch] !== undefined ? daysMapLong[dayMatch] : daysMapShort[dayMatch];
        if (day !== undefined && !result.repeatDays.includes(day)) result.repeatDays.push(day);
    }
    console.log("Parsed repeatDays:", result.repeatDays);


    // Interval parsing
    const intRgx = /CADA\s*(\d+)\s*DIAS?/;
    const intM = norm.match(intRgx);
    if (intM) {
        result.intervalDays = parseInt(intM[1]);
        if (!result.date) {
            // If interval is specified but no date, default to today
            result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
        }
    }
    console.log("Parsed intervalDays:", result.intervalDays);


    // Timer/Alarm parsing (overrides other time/date if successful)
    // Looks for words like ALARMA, AVISO, RECORDAR, TIMER followed by a number and unit (MINUTOS, HORAS)
    const timRgx = /(ALARMA|AVISO|AVISAR|AVISARME|TEMPORIZADOR|TIMER|RECORDAR|RECORDARME)\b.*?\b(\d+|\w+)\s*(MINUTOS?|HORAS?|MINS?|HRS?)/i;
    const timM = norm.match(timRgx);
    if (timM) {
        const valStr = timM[2];
        const unit = timM[3]?.toUpperCase();
        let val = numW[valStr.toUpperCase()] || parseInt(valStr); // Try parsing word number or digit
        if (!isNaN(val) && val > 0 && unit) {
            let tmc = 0; // time in minutes
            if (unit.startsWith('HORA') || unit.startsWith('HR')) { tmc = val * 60; } else if (unit.startsWith('MINUTO') || unit.startsWith('MIN')) { tmc = val; }

            if (tmc > 0) {
                const endTime = new Date(Date.now() + tmc * 60000);
                result.date = `${endTime.getFullYear()}-${(endTime.getMonth() + 1).toString().padStart(2, '0')}-${endTime.getDate().toString().padStart(2, '0')}`;
                result.time = `${endTime.getHours().toString().padStart(2, '0')}:${endTime.getMinutes().toString().padStart(2, '0')}`;
                result.repeatDays = []; // Timers are not recurring
                result.intervalDays = null; // Timers are not recurring
                result.type = 'simple'; // Timers are simple one-time reminders
                console.log("Parsed timer:", tmc, "minutes. End time:", result.date, result.time);
            }
        }
    }


    // Location phrases parsing
    const locationPhrases = ["EN EL LUGAR", "EN EL SITIO", "EN LA UBICACION", "EN LA LOCALIZACION"];
    if (locationPhrases.some(phrase => norm.includes(phrase))) {
        result.isLocationEnabled = true;
        console.log("Location enabled by phrase.");
    }

    // Radius parsing
    const radiusRgx = /(?:RADIO|MARGEN)\s*DE\s*(\d+)\s*METROS?/i;
    const radiusMatch = norm.match(radiusRgx);
    if (radiusMatch && radiusMatch[1]) {
        const parsedRadius = parseInt(radiusMatch[1]);
        if (!isNaN(parsedRadius) && parsedRadius > 0) {
            result.radiusMeters = parsedRadius;
            result.isLocationEnabled = true; // Enabling location if radius specified
            console.log("Radius parsed:", result.radiusMeters, "Location enabled by radius.");
        }
    }

    // Exclude from list parsing (for radars etc)
    const excludePhrases = ["NO LISTAR", "NO MOSTRAR EN LISTA", "EXCLUIR LISTA", "OCULTAR LISTA", "RADAR"];
    if (excludePhrases.some(phrase => norm.includes(phrase))) {
        result.excludeFromList = true;
        console.log("Exclude from list enabled by phrase.");
    }


    // Determine reminder type if not already set by timer
    if (result.type === null) {
        if (result.intervalDays !== null && result.date) {
            result.type = 'interval';
        } else if (result.repeatDays.length > 0 && result.time) {
            result.type = 'weekly';
        } else if (result.date && result.time) {
            result.type = 'daily';
        } else if (result.time) {
            // If only time is specified, assume daily for today
            result.type = 'daily';
            if (!result.date) result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
        } else if (result.date) {
            // If only date is specified, assume daily at 00:01
            result.type = 'daily';
            if (!result.time) result.time = '00:01';
        } else if (result.isLocationEnabled) {
            // If only location is enabled, assume simple for now/today
            result.type = 'simple';
            if (!result.date) result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
            if (!result.time) result.time = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
        } else {
            // Default to simple (now/today) if no time, date, interval, repeat days, or location phrases found
            result.type = 'simple';
            if (!result.date) result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
            if (!result.time) result.time = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
        }
    }

    // Ensure time is set for cyclic reminders if not parsed
    if (!result.time && (result.type === 'daily' || result.type === 'weekly' || result.type === 'interval')) {
        result.time = '00:01';
    }


    // Update UI elements if provided
    if (elementsToUpdate) {
        console.log("Updating UI elements based on parse result.");
        if (elementsToUpdate.locationCheckbox) {
            const shouldBeChecked = result.isLocationEnabled;
            // Only update checkbox checked state automatically if the map wasn't manually expanded
            // or if the location wasn't manually enabled before parsing.
            // This prevents text parsing from disabling a manually enabled location.
            // Simplified: Always update checkbox state based on parsing for now.
            // A better approach would track manual checkbox change vs text parsing.
            elementsToUpdate.locationCheckbox.checked = shouldBeChecked;
            elementsToUpdate.radiusInput.disabled = !shouldBeChecked;

        }
        if (elementsToUpdate.radiusInput) {
            elementsToUpdate.radiusInput.value = result.radiusMeters;
        }
        // Update time/date inputs ONLY if they were not manually changed since the last parse
        // (This requires tracking manual input, handled by manualTimeInput flag)
        if (!elementsToUpdate.manualTimeInput && elementsToUpdate.timeInput && result.time) {
            elementsToUpdate.timeInput.value = result.time;
        } else if (elementsToUpdate.timeInput && !elementsToUpdate.manualTimeInput && !result.time) {
            elementsToUpdate.timeInput.value = ''; // Clear if text parsing removed time
        }

        if (elementsToUpdate.dateInput && result.date) {
            const dateParts = result.date.split('-');
            if (dateParts.length === 3) {
                elementsToUpdate.dateInput.value = `${dateParts[2]}/${dateParts[1]}/${dateParts[0]}`;
            } else {
                elementsToUpdate.dateInput.value = ''; // Clear if date format is unexpected
            }
        } else if (elementsToUpdate.dateInput && !result.date) {
            elementsToUpdate.dateInput.value = ''; // Clear if text parsing removed date
        }

        if (elementsToUpdate.intervalInput) {
            elementsToUpdate.intervalInput.value = result.intervalDays || '';
        }
        if (elementsToUpdate.repeatCheckboxes) {
            elementsToUpdate.repeatCheckboxes.forEach(input => {
                input.checked = result.repeatDays.includes(parseInt(input.value));
            });
        }

        if (elementsToUpdate.excludeFromListCheckbox) {
            elementsToUpdate.excludeFromListCheckbox.checked = result.excludeFromList;
        }
    }
    console.log("Parsed result:", result);
    return result;
}

function showHelpModal() {
    console.log("Showing help modal.");
    const modal = document.createElement('div');
    modal.className = 'help-modal';
    modal.setAttribute('aria-label', 'Ayuda recordatorios');
    modal.innerHTML = `
            <h2 class="text-2xl font-bold">Ayuda Recordatorios</h2>
            <p class="mb-4">Ejemplos:</p>
            <ul class="list-disc pl-6 mb-4">
                <li><strong>Texto:</strong> "Recordar cita", "Llamar mamá"</li>
                <li><strong>Hora:</strong> "A LAS DIEZ Y CUARTO" → 10:15, "A LAS CINCO Y MEDIA TARDE" → 17:30</li>
                <li><strong>Fecha:</strong> "HOY", "MAÑANA", "DENTRO DE 15 DÍAS", "EL DÍA 22", "PRÓXIMO LUNES", "25/05/2025"</li>
                <li><strong>Repetición:</strong> "CADA LUNES", "TODOS LOS VIERNES Y SÁBADOS"</li>
                <li><strong>Intervalo:</strong> "CADA 7 DÍAS"</li>
                <li><strong>Alarma:</strong> "ALARMA EN 30 MINUTOS", "RECORDAR EN 2 HORAS". Crea recordatorio para fecha/hora exacta.</li>
                <li><strong>Excluir de Lista/Radar:</strong> Añadir "NO LISTAR", "EXCLUIR LISTA" o "RADAR" para ocultarlo de la lista general y que aparezca con chincheta morada en el mapa de ubicaciones.</li>
            </ul>
            <p class="mb-4">Formatos fecha: DD/MM/YYYY, DD-MM-YY, etc.</p>
            <p class="mb-4">Nota: Combina hora, fecha, días, intervalo. Palabra Alarma/Aviso/sar/Recordar/torio/dame,Timer crean alarmas.</p>

            <h3 class="text-xl font-bold mt-6 mb-2">Recordatorios por Ubicación</h3>
            <ul class="list-disc pl-6 mb-4">
                <li><strong>Activar:</strong>
                    <ul>
                        <li>Marca la casilla "Ubicación".</li>
                        <li>O escribe frases como: "EN EL LUGAR", "EN EL SITIO", "EN LA UBICACIÓN", "EN LA LOCALIZACIÓN".</li>
                    </ul>
                </li>
                <li><strong>Ver/Ampliar Mapa (Formulario):</strong>
                    <ul>
                        <li>Pulsa el botón "Ampliar Mapa" que aparece junto al check "Ubicación".</li>
                        <li>Si la ubicación está activa y fijada, verás un pequeño mapa de previsualización debajo.</li>
                    </ul>
                </li>
                <li><strong>Fijar Punto (Formulario):</strong>
                    <ul>
                        <li>Una vez ampliado el mapa, pulsa en él para fijar la ubicación deseada.</li>
                        <li>El mapa ampliado mostrará tu ubicación actual por defecto si concedes permiso y está disponible.</li>
                        <li>Usa el botón <strong style="color:green;">"ESTÁS AQUÍ"</strong> (en el mapa ampliado del formulario) para centrar rápidamente en tu posición actual y <strong>fijar esa posición como la del recordatorio</strong>. Si pulsas de nuevo vuelves a la anterior.</li>
                    </ul>
                </li>
                <li><strong>Radio de Acción:</strong>
                    <ul>
                        <li>Indica el radio en metros (por defecto 1000) en el campo correspondiente.</li>
                        <li>Puedes escribir "RADIO DE 200 METROS" o "MARGEN DE 500 METROS" en el texto para ajustarlo automáticamente.</li>
                    </ul>
                </li>
                <li><strong>Funcionamiento:</strong> El recordatorio solo saltará si, además de cumplirse la hora/fecha, te encuentras DENTRO del radio de la ubicación guardada.</li>
                 <li><strong>Reducir Mapa (Formulario):</strong> Pulsa el botón "REDUCIR MAPA" (visible en el mapa ampliado del formulario) para volver a la vista pequeña de previsualización.</li>
                 <li><strong>Ubicaciones Guardadas:</strong> Puedes guardar hasta 15 ubicaciones frecuentes desde el botón "Ubicaciones" en este formulario. Luego, para usarlas, ve a "Ubicaciones", busca la deseada y pulsa "Seleccionar".</li>
            </ul>

             <h3 class="text-xl font-bold mt-6 mb-2">Mapas y Navegación (Opción <img src="RADAR.PNG" alt="Radar Icon" style="width:1em; height:1em; vertical-align:middle; display:inline;">)</h3>
             <ul class="list-disc pl-6 mb-4 text-sm">
                <li><strong>VER UBICACIONES:</strong> Muestra un mapa con todos tus recordatorios que tienen ubicación (chinchetas azules o moradas para "RADAR") y tu posición actual (<img src="Coche.PNG" alt="Icono Coche" style="width:1.5em; height:1.5em; vertical-align:middle; display:inline;">). La rosa de los vientos y la altitud se muestran a la izquierda.</li>
                <li><strong>PLANIFICAR RUTA:</strong> Permite añadir puntos de ruta pulsando en el mapa. El primer punto es "S", el último "F", los intermedios son números. Puedes arrastrarlos y borrarlos. Usa el botón "Añadir Salida (GPS)" para que tu ubicación actual sea el primer punto. La ruta se recalcula automáticamente. Puedes guardar y cargar rutas.</li>
                <li><strong>INICIAR NAVEGACIÓN:</strong> Se activa si tienes al menos 2 puntos en Planificar Ruta. Inicia la navegación GPS en tiempo real con indicaciones y seguimiento.</li>
                <li><strong>DEJAR DE SEGUIR:</strong> (En Navegación) Detiene la navegación, borra la ruta y vuelve a la vista de Planificar Ruta. (En VER UBICACIONES) Activa/desactiva el centrado automático en tu posición.</li>
                <li><strong>AQUÍ HAY UN RADAR:</strong> (En VER UBICACIONES) Crea un recordatorio "RADAR" en tu posición actual.</li>
                <li><strong>Clic en mapa (VER UBICACIONES):</strong> Crea un recordatorio "RADAR" en el punto pulsado.</li>
                <li><strong>Recalculo Ruta (Navegación):</strong> Si te sales de la ruta, intentará recalcularla automáticamente desde tu posición.</li>
            </ul>

            <p class="mb-4">Usa micrófono para voz.</p>
            <div class="flex justify-end"><button type="button" id="close-help">Cerrar</button></div>`;
    document.body.appendChild(modal);
    const closeHelpButton = modal.querySelector('#close-help');
    const closeHandler = () => {
        clearModalAutoCloseTimer(modal, closeHelpButton, 'help-modal');
        if (modal.parentNode) modal.parentNode.removeChild(modal);
    };
    closeHelpButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(modal, closeHelpButton, 'help-modal');
}


function showRemindersMapHelpModal() {
    console.log("Showing reminders map help modal.");
    const existingHelpModal = document.getElementById('reminders-map-help-modal-instance');
    if (existingHelpModal) {
        clearModalAutoCloseTimer(existingHelpModal, existingHelpModal.querySelector('#close-reminders-map-help-instance'), 'reminders-map-help-modal-instance');
        existingHelpModal.remove();
    }

    const helpModal = document.createElement('div');
    helpModal.id = 'reminders-map-help-modal-instance';
    helpModal.className = 'help-modal';
    helpModal.setAttribute('aria-label', 'Ayuda Mapa de Ubicaciones/Radares');
    helpModal.innerHTML = `
            <h2 class="text-xl font-bold mb-4">Ayuda del Mapa de Ubicaciones</h2>
            <p class="mb-2">Este mapa muestra todos tus recordatorios que tienen una ubicación geográfica asociada.</p>
            <ul class="list-disc pl-5 space-y-1 mb-4 text-sm">
                <li><strong>Ver Detalles:</strong> Pulsa sobre un marcador (chincheta) para ver los detalles del recordatorio y un botón para modificarlo.</li>
                <li><strong>Iconos de Marcadores:</strong>
                    <ul>
                        <li><img src="${defaultLocationMarkerIconBlue.options.iconUrl}" alt="Chincheta Azul" style="width:12px; height:20px; vertical-align:middle; display:inline;"> Recordatorio normal.</li>
                        <li><img src="${radarMarkerIcon.options.iconUrl}" alt="Chincheta Morada" style="width:12px; height:20px; vertical-align:middle; display:inline;"> Recordatorio con "RADAR" en el texto o excluido de lista.</li>
                        <li><img src="Coche.PNG" alt="Icono Coche" style="width:1.5em; height:1.5em; vertical-align:middle; display:inline;"> Tu posición actual. El icono <strong>no rota</strong> según tu orientación. El círculo que lo rodea tiene un radio variable de 3m (cerca) a 150m (lejos) según el zoom.</li>
                        <li>El botón <strong style="color:green;">"ESTÁS AQUÍ"</strong> (<img src="https://boardinggate.github.io/Tesla/home.webp" alt="Locate Icon" style="width:1em; height:1em; vertical-align:middle; display:inline;">) en este mapa te centra y marca tu posición con el icono del coche. Al pulsarlo de nuevo ("DEJAR DE SEGUIR"), el mapa deja de centrarse automáticamente pero la posición del coche sigue actualizándose.</li>
                    </ul>
                </li>
                <li><strong>"AQUÍ HAY UN RADAR":</strong> Crea automáticamente un recordatorio con el texto "RADAR", tu ubicación GPS actual, radio de 1000 metros y lo marca para no incluir en la lista general. El nuevo radar se añade al mapa.</li>
                 <li><strong>Actualización Posición:</strong> La posición de tu coche (<img src="Coche.PNG" alt="Icono Coche" style="width:1.5em; height:1.5em; vertical-align:middle; display:inline;">) se actualiza en tiempo real.</li>
                 <li><strong>Orientación y Altitud:</strong> A la izquierda del mapa, verás un icono de ROSA.PNG (de 90x90px) que sí rota según tu rumbo, la orientación cardinal abreviada (ej: NE) y tu altitud (ej: 123 m) si están disponibles, en letra más grande. Los botones de zoom (+/-) están a la derecha.</li>
            </ul>
            <h3 class="font-semibold text-lg mt-4 mb-2">Crear Recordatorio "RADAR" Manualmente</h3>
            <p class="mb-2">También puedes añadir un recordatorio "RADAR" directamente desde este mapa haciendo clic o tap en cualquier punto del mapa. Esto es útil para marcar ubicaciones específicas sin necesidad de estar allí.</p>
            <ul class="list-disc pl-5 space-y-1 text-sm">
                <li><strong>PC:</strong> Haz clic derecho en cualquier punto del mapa.</li>
                <li><strong>Móvil/Táctil:</strong> Un tap/click simple en un punto del mapa (para facilitar en pantallas táctiles).</li>
            </ul>
            <p class="mb-2">Al hacerlo, se abrirá la ventana de creación de recordatorios con los siguientes datos pre-rellenados:</p>
            <ul class="list-disc pl-5 space-y-1 text-sm">
                <li><strong>Texto:</strong> "RADAR"</li>
                <li><strong>Ubicación:</strong> Las coordenadas GPS del punto que pulsaste.</li>
                <li><strong>Radio:</strong> 1000 metros (puedes ajustarlo en el formulario).</li>
                <li><strong>Opción "NO INCLUIRLO EN LA LISTA":</strong> Marcada por defecto.</li>
            </ul>
            <div class="flex justify-end mt-6">
                <button type="button" id="close-reminders-map-help-instance">Entendido</button>
            </div>
        `;
    document.body.appendChild(helpModal);
    const closeButtonHelp = helpModal.querySelector('#close-reminders-map-help-instance');
    const closeHandlerHelp = () => {
        clearModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance');
        if (helpModal.parentNode) helpModal.parentNode.removeChild(helpModal);
    };
    closeButtonHelp.addEventListener('click', closeHandlerHelp);
    addModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance');
}


function showConfigModal() {
    console.log("Showing config modal.");
    const mapWasOpenBeforeConfig = isLocationFeaturesModalActive;

    hideUnifiedReminderWindow();
    const otherModals = document.querySelectorAll('.choice-modal, .edit-modal, .edit-info-modal, .help-modal, .reminder-modal, .reminder-table-modal, #postpone-options-modal, .versions-modal-overlay, .saved-locations-modal, #location-features-modal, #reminders-map-help-modal-instance, #saved-routes-modal');
    otherModals.forEach(m => m.remove());

    const GAS_URL = 'AKfycbxrM-2kTU4irtHs-8wNEPteYpU7Jy7JWn2p92p8b1UQk-3P0e2bAAt0Z1qkHW025AF6qg';

    const modal = document.createElement('div');
    modal.id = 'config-modal';
    modal.setAttribute('aria-label', 'Configuración');

    const managedKeys = ['reminders', 'darkMode', 'toggleStates', 'zoomState', 'onOffState', 'noticesActive', 'footerVisible', 'teslaHtmlLastModified', 'teslaHtmlLastModifiedTimestamp', 'userData_userId', 'userData_teslaModel', 'userData_teslaYear', 'userData_teslaProvince', 'userData_allowDMs', 'customGridData', 'personalizationHelpShown', 'gridFilterValue', 'password_pin', 'password_active', 'lastUpdatesCheckDate', SAVED_LOCATIONS_KEY, SHOW_EXCLUDED_REMINDERS_KEY, SAVED_ROUTES_KEY ];
    const managedDesc = managedKeys.map(k => {
        switch (k) {
            case 'reminders':
                return 'Recordatorios';
            case 'darkMode':
                return 'Modo Oscuro';
            case 'toggleStates':
                return 'Visibilidad Secc.';
            case 'zoomState':
                return 'Zoom Grid';
            case 'onOffState':
                return 'On/Off Gral';
            case 'noticesActive':
                return 'Avisos/Footer';
            case 'footerVisible':
                return 'Vis. Footer';
            case 'teslaHtmlLastModified':
                return 'Cache Versión';
            case 'teslaHtmlLastModifiedTimestamp':
                return 'TS Cache';
            case 'userData_userId':
                return 'ID Usuario';
            case 'userData_teslaModel':
                return 'Modelo';
            case 'userData_teslaYear':
                return 'Año';
            case 'userData_teslaProvince':
                return 'Provincia';
            case 'userData_allowDMs':
                return 'Permitir DMs';
            case 'customGridData':
                return 'Grid Pers.';
            case 'personalizationHelpShown':
                return 'Ayuda Pers. Vista';
            case 'gridFilterValue':
                return 'Filtro Grid';
            case 'password_pin':
                return 'PIN Acceso';
            case 'password_active':
                return 'PIN Activo';
            case 'lastUpdatesCheckDate':
                return 'Cache Fecha Updates';
            case SAVED_LOCATIONS_KEY:
                return 'Ubicaciones Guardadas';
            case SHOW_EXCLUDED_REMINDERS_KEY:
                return 'Mostrar Excluidos Tabla';
            case SAVED_ROUTES_KEY:
                return 'Rutas Guardadas';
            default:
                return k;
        }
    }).join(', ');

    modal.innerHTML = `
        <h2 style="flex-shrink:0;">Configuración y Datos</h2>
        <div class="tab-buttons" style="flex-shrink:0;">
            <button class="config-tab-button active" data-tab-target="#tab-content-usuario">Usuario</button>
            <button class="config-tab-button" data-tab-target="#tab-content-pin">Clave Acceso</button>
            <button class="config-tab-button" data-tab-target="#tab-content-radares">RADARES</button>
            <button class="config-tab-button" data-tab-target="#tab-content-backup-restore">Backup/Restore</button>
            <button class="config-tab-button" data-tab-target="#tab-content-borrar">Borrar Datos</button>
        </div>
        <div class="tab-contents">
            <div id="tab-content-usuario" class="config-tab-content active">
                <h3>Datos Compartidos (Opcional)</h3>
                <p style="font-size:.9rem;color:#555;margin-bottom:1.5rem;text-align:center;">Guardados en <a href="https://docs.google.com/spreadsheets/d/1-DiwTDrxpUrfYpa_yahHHqeOMYK0ny-KPdoLrDU3uYw/edit?usp=sharing" target="_blank" rel="noopener noreferrer" style="color:#1E40AF;">Hoja Cálculo</a>.</p>
                <div class="user-data-grid">
                    <div><label for="user-id">* ID Usuario (Apodo):</label><input type="text" id="user-id" name="userId" required></div>
                    <div><label for="tesla-model">Modelo Tesla:</label><input type="text" id="tesla-model" name="teslaModel"></div>
                    <div><label for="tesla-year">Año Modelo:</label><input type="number" id="tesla-year" name="teslaYear" min="2012" max="2099"></div>
                    <div><label for="tesla-province">Provincia:</label><input type="text" id="tesla-province" name="teslaProvince"></div>
                    <div class="checkbox-container"><input type="checkbox" id="allow-dms" name="allowDMs"><label for="allow-dms">Permitir MDs (vía admin)</label></div>
                </div>
                <div class="user-buttons-container">
                    <button id="config-save-user" style="background-color:#16A34A;color:white;">Guardar Datos</button>
                    <button id="config-reset-user" style="background-color:#D97706;color:white;">Resetear Reg.</button>
                </div>
                <p id="config-user-status" class="status-message"></p>
            </div>
             <div id="tab-content-pin" class="config-tab-content">
                 <h3>Clave de Acceso (Local)</h3>
                 <p style="font-size: 0.9rem; color: #555; margin-bottom: 1rem;">Establece una clave de 4 cifras para proteger el acceso inicial a la página. Se guarda sólo en tu navegador.</p>
                 <div class="pin-config-layout">
                     <div class="pin-input-group">
                         <label for="config-pin-set">Establecer/Cambiar Clave:</label>
                         <input type="password" id="config-pin-set" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="4 cifras">
                     </div>
                     <div class="pin-input-group">
                         <label for="config-pin-confirm">Confirmar Clave:</label>
                         <input type="password" id="config-pin-confirm" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="Repetir 4 cifras">
                     </div>
                     <div class="pin-buttons-container">
                         <button id="config-save-pin" style="background-color:#2563EB;color:white;">Guardar Clave</button>
                         <button id="config-remove-pin" style="background-color:#dc3545;color:white;">Quitar Clave</button>
                     </div>
                 </div>
                 <p id="config-pin-status" class="status-message"></p>
             </div>

             <div id="tab-content-radares" class="config-tab-content">
                <h3>Importar / Borrar Radares y Otros POIs</h3>
                <p style="font-size:0.85rem; color:#444; margin-bottom:0.5rem;">
                    Para <strong>importar</strong>, el filtro de "Palabras Clave" buscará coincidencias en el nombre del POI (ej: provincia, población, tipo).
                    Los filtros de Lat/Lon pueden ser un valor único (aprox.) o un rango (ej: "<code>40.1 40.5</code>" para buscar entre esas latitudes).
                </p>
                <p style="font-size:0.85rem; color:#444; margin-bottom:1rem;">
                    Los POIs importados (RADARES) se guardarán con un radio de <strong>400 metros</strong>.
                </p>
                <p style="font-size:0.85rem; color:#444; margin-bottom:1.5rem;">
                    Para <strong>borrar</strong>, se eliminarán los recordatorios de ubicación que cumplan TODOS los filtros activos (Lat, Lon, Palabras). Si un filtro está vacío, se ignora.
                </p>
                <div class="radar-filter-group">
                    <div>
                        <label for="radar-filter-lat">Latitud (valor o "min max"):</label>
                        <input type="text" id="radar-filter-lat" placeholder="Ej: 40.123 o 40.0 40.5">
                    </div>
                    <div>
                        <label for="radar-filter-lon">Longitud (valor o "min max"):</label>
                        <input type="text" id="radar-filter-lon" placeholder="Ej: -3.567 o -4.0 -3.0">
                    </div>
                    <div style="grid-column: span 2;">
                        <label for="radar-filter-keywords">Palabras Clave (en nombre POI, separadas por espacio):</label>
                        <input type="text" id="radar-filter-keywords" placeholder="Ej: FIJO CAMUFLADO MADRID">
                    </div>
                </div>
                <div class="radar-import-options">
                    <input type="checkbox" id="import-extra-radars-checkbox">
                    <label for="import-extra-radars-checkbox">Importar también radares móviles, semáforo, etc (sino, solo radares fijos y de tramo)</label>
                </div>
                <div class="radar-action-buttons">
                    <button id="import-radars-button">IMPORTAR RADARES y otros</button>
                    <button id="delete-filtered-radars-button">BORRAR CACHÉ (según filtro)</button>
                </div>
                <div id="radar-import-progress-container" style="display:none;">
                    <progress id="radar-import-progress-bar" value="0" max="100"></progress>
                    <p id="radar-import-status" class="status-message"></p>
                </div>
             </div>

            <div id="tab-content-backup-restore" class="config-tab-content">
                 <div style="background-color:#f7f9f7;padding:.8rem 1rem;border-radius:.25rem;margin-bottom:1.5rem;border:1px solid #ccc;">
                 <p style="font-size:.9rem;color:#555;margin:0;line-height:1.4;"><strong>Datos Incluidos:</strong> ${managedDesc}.<em style="font-size:.8rem;display:block;margin-top:.3rem;">(Backup TODO, Restore sólo compatibles).</em></p>
                </div>
                <div class="backup-restore-container">
                    <div>
                        <h3>Crear Backup</h3>
                        <p>Genera código. <strong style="color:#006400;">Guárdalo.</strong></p>
                        <button id="config-generate-backup" style="background-color:#2563EB;color:white;">Generar Backup</button>
                        <textarea id="config-backup-display" readonly style="display:none;"></textarea>
                        <p id="config-backup-status" class="status-message"></p>
                    </div>
                    <div>
                        <h3>Restaurar Copia</h3>
                        <p>Pega código. <strong style="color:blue;">Solo restaura compatibles</strong>.</p>
                        <textarea id="config-restore-input" placeholder="Pega aquí..."></textarea>
                        <button id="config-restore-backup" style="background-color:#10B981;color:white;">Restaurar</button>
                        <p id="config-restore-status" class="status-message"></p>
                    </div>
                </div>
            </div>
            <div id="tab-content-borrar" class="config-tab-content borrar-container">
                <h3>Borrar Datos Locales</h3>
                 <button id="config-restore-grid-button">RESTAURAR EL GRID ORIGINAL DE BOTONES</button>
                 <p id="config-restore-grid-status" class="status-message" style="margin-bottom: 1.5rem;"></p>

                <h3 style="border-top: 1px solid #ccc; padding-top: 1.5rem; margin-top:1.5rem;">Acción Irreversible</h3>
                <p>Elimina TODOS los datos locales.</p>
                <button id="config-clear-cache">Borrar TODO</button>
                <p><strong style="color:red;">¡Sin deshacer!</strong> Ten backup.</p>
            </div>
        </div>
        <div style="text-align:center;margin-top:1rem;flex-shrink:0;"><button id="config-close-modal">Cerrar</button></div>`;

    document.body.appendChild(modal);

    const tabBtns = modal.querySelectorAll('.config-tab-button');
    const tabConts = modal.querySelectorAll('.config-tab-content');
    const userIdI = modal.querySelector('#user-id');
    const modelI = modal.querySelector('#tesla-model');
    const yearI = modal.querySelector('#tesla-year');
    const provinceI = modal.querySelector('#tesla-province');
    const dmsChk = modal.querySelector('#allow-dms');
    const saveBtn = modal.querySelector('#config-save-user');
    const resetBtn = modal.querySelector('#config-reset-user');
    const userStat = modal.querySelector('#config-user-status');
    const genBkupBtn = modal.querySelector('#config-generate-backup');
    const bkupDisp = modal.querySelector('#config-backup-display');
    const restInp = modal.querySelector('#config-restore-input');
    const restBtn = modal.querySelector('#config-restore-backup');
    const clearBtn = modal.querySelector('#config-clear-cache');
    const closeBtn = modal.querySelector('#config-close-modal');
    const restoreGridBtn = modal.querySelector('#config-restore-grid-button');
    const restoreGridStatus = modal.querySelector('#config-restore-grid-status');
    const savePinBtn = modal.querySelector('#config-save-pin');
    const removePinBtn = modal.querySelector('#config-remove-pin');
    const pinSetInput = modal.querySelector('#config-pin-set');
    const pinConfirmInput = modal.querySelector('#config-pin-confirm');
    const pinStatus = modal.querySelector('#config-pin-status');

    const importRadarsButton = modal.querySelector('#import-radars-button');
    const deleteFilteredRadarsButton = modal.querySelector('#delete-filtered-radars-button');
    if (importRadarsButton) importRadarsButton.addEventListener('click', handleImportRadars);
    if (deleteFilteredRadarsButton) deleteFilteredRadarsButton.addEventListener('click', handleDeleteFilteredRadars);


    tabBtns.forEach(button => {
        button.addEventListener('click', () => {
            const tabTarget = button.dataset.tabTarget;
            tabBtns.forEach(btn => btn.classList.remove('active'));
            tabConts.forEach(content => content.classList.remove('active'));
            button.classList.add('active');
            modal.querySelector(tabTarget).classList.add('active');
        });
    });

    const loadUData = () => {
        userIdI.value = localStorage.getItem('userData_userId') || '';
        modelI.value = localStorage.getItem('userData_teslaModel') || '';
        yearI.value = localStorage.getItem('userData_teslaYear') || '';
        provinceI.value = localStorage.getItem('userData_teslaProvince') || '';
        dmsChk.checked = localStorage.getItem('userData_allowDMs') === 'true';
    };

    const callGAS = async (action, data = {}) => {
        if (!GAS_URL || GAS_URL === 'URL_DE_TU_GOOGLE_APPS_SCRIPT_WEB_APP') {
            return {
                status: 'error',
                message: 'URL API no conf.'
            };
        }
        if (userStat) userStat.textContent = '';
        setUserDataLoading(true);
        try {
            const resp = await fetch(GAS_URL, {
                method: 'POST',
                mode: 'cors',
                cache: 'no-cache',
                headers: {
                    'Content-Type': 'application/json'
                },
                redirect: 'follow',
                body: JSON.stringify({
                    action,
                    ...data
                }),
            });
            let res;
            const ct = resp.headers.get("content-type");
            if (ct?.includes("application/json")) {
                res = await resp.json();
            } else {
                const txt = await resp.text();
                try { res = JSON.parse(txt); } catch (e) {
                    if (!resp.ok) throw new Error(`Server error (${resp.status}): ${txt.substring(0,200)}`);
                    res = {
                        status: 'success',
                        message: 'OK (non-JSON).'
                    };
                }
            }
            if (!resp.ok && res.status !== 'exists' && res.status !== 'not_found') {
                throw new Error(res.message || `Server error (${resp.status})`);
            }
            return res;
        } catch (e) {
            return {
                status: 'error',
                message: e.message || 'API Conn Error.'
            };
        } finally {
            setUserDataLoading(false);
        }
    };

    const setUserDataLoading = (isLoading) => {
        [userIdI, modelI, yearI, provinceI, dmsChk, saveBtn, resetBtn, pinSetInput, pinConfirmInput, savePinBtn, removePinBtn].forEach(el => { if (el) el.disabled = isLoading; });
        if (saveBtn) saveBtn.style.opacity = isLoading ? 0.6 : 1;
        if (resetBtn) resetBtn.style.opacity = isLoading ? 0.6 : 1;
        if (savePinBtn) savePinBtn.style.opacity = isLoading ? 0.6 : 1;
        if (removePinBtn) removePinBtn.style.opacity = isLoading ? 0.6 : 1;
        if (isLoading && userStat) {
            userStat.textContent = 'Procesando...';
            userStat.style.color = '#1E40AF';
        } else if (userStat && userStat.textContent === 'Procesando...') {
            userStat.textContent = '';
        }
    };

    saveBtn.addEventListener('click', async () => {
        const userId = userIdI.value.trim();
        const model = modelI.value.trim();
        const year = yearI.value.trim();
        const province = provinceI.value.trim();
        const allowDMs = dmsChk.checked;

        if (!userId) {
            showToast('ID Usuario (Apodo) obligatorio.', 'warning', 4000);
            if (userStat) { userStat.textContent = 'ID de Usuario es obligatorio.'; userStat.style.color = '#EF4444'; }
            return;
        }

        const storedUserId = localStorage.getItem('userData_userId');
        let syncAttempted = false;
        let syncSuccess = false;
        let syncMessage = '';

        try {
            localStorage.setItem('userData_userId', userId);
            localStorage.setItem('userData_teslaModel', model);
            localStorage.setItem('userData_teslaYear', year);
            localStorage.setItem('userData_teslaProvince', province);
            localStorage.setItem('userData_allowDMs', allowDMs.toString());
            updateUserIdDisplay();
        } catch (e) {
            showToast(`Error local: ${e.message}`, 'error', 5000);
            if (userStat) { userStat.textContent = `Error local: ${e.message.substring(0, 100)}`; userStat.style.color = '#EF4444'; }
            return;
        }

        let proceedRemoteSave = false;
        if (userStat) userStat.textContent = 'Sincronizando con servidor...';
        try {
            if (!storedUserId || userId !== storedUserId) {
                if (userStat) userStat.textContent = 'Validando ID en servidor...';
                const chk = await callGAS('checkUserIdExists', {
                    usuario: userId
                });
                syncAttempted = true;
                if (chk.status === 'exists') {
                    syncMessage = `El ID "${userId}" ya existe. No se guardó remotamente.`;
                    showToast(syncMessage, 'error', 6000);
                    if (userStat) { userStat.textContent = syncMessage; userStat.style.color = '#EF4444'; }
                    return;
                } else if (chk.status === 'not_found' || chk.status === 'success') {
                    if (storedUserId && userId !== storedUserId) {
                        if (userStat) userStat.textContent = 'Eliminando registro antiguo...';
                        const delOld = await callGAS('deleteUserRow', {
                            userId: storedUserId
                        });
                        if (delOld.status !== 'success' && delOld.status !== 'not_found') {
                            console.warn("Fallo al eliminar registro antiguo:", delOld.message);
                        }
                    }
                    proceedRemoteSave = true;
                } else {
                    throw new Error(chk.message || "Error al validar ID.");
                }
            } else {
                proceedRemoteSave = true;
            }

            if (proceedRemoteSave) {
                if (userStat) userStat.textContent = 'Guardando datos en servidor...';
                const uData = {
                    usuario: userId,
                    modelo: model,
                    anio: year,
                    provincia: province,
                    rss: allowDMs ? 'SI' : 'NO'
                };
                const sav = await callGAS('addUserData', {
                    userData: uData
                });
                syncAttempted = true;
                if (sav.status === 'success') {
                    syncSuccess = true;
                    syncMessage = 'Datos guardados local y remotamente.';
                    if (userStat) { userStat.textContent = 'Sincronización OK.'; userStat.style.color = '#28a745'; }
                } else {
                    throw new Error(sav.message || "Error al guardar datos.");
                }
            }
        } catch (e) {
            syncSuccess = false;
            syncMessage = `Guardado local. Error sync: ${e.message}`;
            if (userStat) { userStat.textContent = `Sync error: ${e.message.substring(0, 100)}`; userStat.style.color = '#ffc107'; }
        } finally {
            if (syncAttempted) {
                showToast(syncMessage, syncSuccess ? 'success' : (syncAttempted && !syncSuccess ? 'error' : 'warning'), syncSuccess ? 3000 : 6000);
            } else {
                showToast('Datos guardados localmente.', 'success', 3000);
            }
            if (userStat && (userStat.textContent === 'Procesando...' || userStat.textContent === 'Sincronizando con servidor...' || userStat.textContent === 'Validando ID en servidor...' || userStat.textContent === 'Eliminando registro antiguo...')) {
                if (!syncAttempted || syncSuccess) {
                    userStat.textContent = 'Guardado local OK.';
                    userStat.style.color = '#28a745';
                }
            }
            setUserDataLoading(false);
        }
    });

    resetBtn.addEventListener('click', async () => {
        const storedUserId = localStorage.getItem('userData_userId');
        if (!storedUserId) {
            showToast('No hay registro local para resetear.', 'info', 3000);
            if (userStat) { userStat.textContent = 'No hay registro local.'; userStat.style.color = '#17a2b8'; }
            return;
        }
        if (!confirm(`¿Seguro resetear registro "${storedUserId}"?\nBorrará datos compartidos y locales.`)) {
            showToast('Reseteo cancelado.', 'info', 2000);
            if (userStat) { userStat.textContent = 'Reseteo cancelado.'; userStat.style.color = '#17a2b8'; }
            return;
        }

        let remoteDeletionAttempted = false;
        let remoteDeletionSuccess = false;
        let remoteMessage = '';
        setUserDataLoading(true);

        if (userStat) userStat.textContent = `Eliminando remoto "${storedUserId}"...`;
        try {
            const delRes = await callGAS('deleteUserRow', {
                userId: storedUserId
            });
            remoteDeletionAttempted = true;
            if (delRes.status === 'success') {
                remoteDeletionSuccess = true;
                remoteMessage = 'Registro remoto eliminado. ';
                if (userStat) { userStat.textContent = 'Registro remoto eliminado.'; userStat.style.color = '#28a745'; }
            } else if (delRes.status === 'not_found') {
                remoteDeletionSuccess = true;
                remoteMessage = 'Registro remoto no encontrado. ';
                if (userStat) { userStat.textContent = 'Registro remoto no encontrado.'; userStat.style.color = '#ffc107'; }
            } else {
                remoteMessage = `Error eliminar remoto (${delRes.message || '?'}). `;
                if (userStat) { userStat.textContent = `Error remoto: ${delRes.message.substring(0, 100)}`; userStat.style.color = '#EF4444'; }
            }
        } catch (e) {
            remoteMessage = `Error conexión eliminar remoto (${e.message}). `;
            if (userStat) { userStat.textContent = `Error conexión: ${e.message.substring(0, 100)}`; userStat.style.color = '#EF4444'; }
        } finally {
            if (!remoteDeletionAttempted && userStat) { userStat.textContent = ''; }
        }

        try {
            localStorage.removeItem('userData_userId');
            localStorage.removeItem('userData_teslaModel');
            localStorage.removeItem('userData_teslaYear');
            localStorage.removeItem('userData_teslaProvince');
            localStorage.removeItem('userData_allowDMs');
            userIdI.value = '';
            modelI.value = '';
            yearI.value = '';
            provinceI.value = '';
            dmsChk.checked = false;
            updateUserIdDisplay();
            showToast(`${remoteMessage}Datos locales reseteados.`, remoteDeletionSuccess ? 'success' : (remoteDeletionAttempted ? 'warning' : 'success'), 4000);
            if (userStat && userStat.style.color !== '#EF4444') {
                userStat.textContent = `Datos locales reseteados.`;
                userStat.style.color = '#28a745';
            }
        } catch (e) {
            showToast(`${remoteMessage}Error al limpiar datos locales.`, 'error', 5000);
            if (userStat) { userStat.textContent = `Error limpiar local: ${e.message.substring(0, 100)}`; userStat.style.color = '#EF4444'; }
        } finally {
            setUserDataLoading(false);
        }
    });

    clearBtn.addEventListener('click', () => {
        console.log("Clear Cache button clicked.");
        if (confirm('¿Estás MUY SEGURO de borrar TODO el caché local?\n\n¡ACCIÓN IRREVERSIBLE!\nEliminará: Recordatorios, Ajustes UI, Datos Usuario, Grid Personalizado, PIN, Ubicaciones Guardadas, Rutas Guardadas.\n\nAsegúrate de tener Backup.')) {
            const storedUserId = localStorage.getItem('userData_userId');
            if (storedUserId) {
                console.log("Attempting to delete remote user data on clear all.");
                callGAS('deleteUserRow', {
                    userId: storedUserId
                })
                .then(r => console.log("Remote deletion result (on clear all):", r))
                .catch(e => console.warn("Error remote deletion (on clear all):", e));
            }
            console.log("Clearing localStorage and sessionStorage...");
            localStorage.clear();
            sessionStorage.clear();
            console.log("Storage cleared. Closing modal and reloading.");
            clearModalAutoCloseTimer(modal, closeBtn, 'config-modal');
            if (modal.parentNode) modal.parentNode.removeChild(modal);
            showToast('Datos borrados. Recargando...', 'info', 2000);
            setTimeout(() => {
                location.reload();
            }, 500);
        } else {
            console.log("Clear cache cancelled by user.");
            showToast('Borrado de caché cancelado.', 'info', 2000);
        }
    });

    restoreGridBtn.addEventListener('click', () => {
        console.log("Restore Grid button clicked.");
        if (restoreGridStatus) restoreGridStatus.textContent = '';
        if (confirm('¿Seguro restaurar grid original de botones?\nEliminará personalización de marcadores y asignación de botones.\nNO afecta recordatorios ni otros ajustes.')) {
            try {
                localStorage.removeItem('customGridData');
                customData = {
                    bookmarks: {},
                    toggles: {}
                };
                console.log("customGridData removed. Custom data reset.");
                if (restoreGridStatus) {
                    restoreGridStatus.textContent = 'Grid original restaurado. Recargando...';
                    restoreGridStatus.style.color = '#28a745';
                }
                showToast('Grid original restaurado. Recargando...', 'success', 2500);
                clearModalAutoCloseTimer(modal, closeBtn, 'config-modal');
                setTimeout(() => {
                    location.reload();
                }, 1500);
            } catch (e) {
                if (restoreGridStatus) {
                    restoreGridStatus.textContent = 'Error al restaurar.';
                    restoreGridStatus.style.color = '#EF4444';
                }
                showToast('Error al restaurar grid.', 'error', 4000);
                console.error("Error restoring grid:", e);
            }
        } else {
            console.log("Restore grid cancelled by user.");
            if (restoreGridStatus) {
                restoreGridStatus.textContent = 'Restauración grid cancelada.';
                restoreGridStatus.style.color = '#17a2b8';
            }
            showToast('Restauración grid cancelada.', 'info', 2000);
        }
    });

    genBkupBtn.addEventListener('click', () => {
        console.log("Generate Backup clicked.");
        bkupDisp.value = '';
        bkupDisp.style.display = 'none';
        const backupData = {};
        let keysCount = 0;
        let skippedKeys = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key !== null) {
                if (managedKeys.includes(key)) {
                    try {
                        backupData[key] = localStorage.getItem(key);
                        keysCount++;
                        console.log(`Backed up key: ${key}`);
                    } catch (e) {
                        skippedKeys.push(`${key}(err)`);
                        console.warn(`Error backing up key ${key}: ${e.message}`);
                    }
                } else {
                    skippedKeys.push(key);
                    console.log(`Skipped key (not managed): ${key}`);
                }
            }
        }
        if (keysCount === 0) {
            showToast('No hay datos locales para crear backup.', 'warning', 4000);
            if (userStat) { userStat.textContent = 'No hay datos para backup.'; userStat.style.color = '#ffc107'; }
            console.warn("No managed keys found for backup.");
            return;
        }
        try {
            const jsonString = JSON.stringify(backupData, null, 2);
            bkupDisp.value = jsonString;
            bkupDisp.style.display = 'block';
            bkupDisp.select();
            let message = `Backup (${keysCount} claves) generado. Cópialo.`;
            if (skippedKeys.length > 0) { message += ` (Ignoradas: ${skippedKeys.length})`; }
            showToast(message, 'success', 5000);
            if (userStat) { userStat.textContent = 'Backup generado OK.'; userStat.style.color = '#28a745'; }
            console.log("Backup generated successfully. Keys:", keysCount, "Skipped:", skippedKeys.length);
        } catch (e) {
            bkupDisp.value = `Error:\n${e.message}`;
            bkupDisp.style.display = 'block';
            showToast('Error al generar backup.', 'error', 5000);
            if (userStat) { userStat.textContent = `Error backup: ${e.message.substring(0, 100)}`; userStat.style.color = '#EF4444'; }
            console.error("Error generating backup JSON:", e);
        }
    });

    restBtn.addEventListener('click', () => {
        console.log("Restore Backup clicked.");
        const jsonString = restInp.value.trim();
        if (!jsonString) {
            showToast('Pega el código de backup.', 'warning', 4000);
            if (userStat) { userStat.textContent = 'Pega el código.'; userStat.style.color = '#ffc107'; }
            console.warn("Restore input is empty.");
            return;
        }
        try {
            const restoredData = JSON.parse(jsonString);
            if (typeof restoredData !== 'object' || restoredData === null || Array.isArray(restoredData)) {
                throw new Error("Formato inválido.");
            }
            if (!confirm('¿Seguro restaurar datos?\nBorrará datos locales actuales y los reemplazará con los compatibles del backup.')) {
                showToast('Restauración cancelada.', 'info', 2000);
                if (userStat) { userStat.textContent = 'Restauración cancelada.'; userStat.style.color = '#17a2b8'; }
                console.log("Restore cancelled by user.");
                return;
            }

            console.log("Starting restore process. Clearing relevant storage keys...");
            // Clear relevant session storage
            Object.keys(sessionStorage).forEach(key => {
                if (key.startsWith('reminder_managed_') || key === 'personalizationHelpShown' || key === 'boardinggate_current_route_points') {
                    sessionStorage.removeItem(key);
                    console.log(`Cleared sessionStorage key: ${key}`);
                }
            });

            let restoredCount = 0;
            let skippedKeys = [];
            for (const key in restoredData) {
                if (Object.hasOwnProperty.call(restoredData, key)) {
                    if (managedKeys.includes(key)) {
                        try {
                            // Special handling for complex objects like customGridData, reminders, saved locations, saved routes
                            if (key === 'customGridData' || key === 'reminders' || key === SAVED_LOCATIONS_KEY || key === SAVED_ROUTES_KEY) {
                                // Attempt to parse JSON string, if successful, store it back as string
                                try {
                                    JSON.parse(restoredData[key]); // Just check if it's valid JSON
                                    localStorage.setItem(key, restoredData[key]);
                                    restoredCount++;
                                    console.log(`Restored and validated JSON key: ${key}`);
                                } catch (e) {
                                    skippedKeys.push(`${key}(invalid_json)`);
                                    console.warn(`Skipped restoring key ${key}: Invalid JSON format.`, e);
                                }
                            } else {
                                // For simple strings, numbers, booleans - restore directly
                                localStorage.setItem(key, restoredData[key]);
                                restoredCount++;
                                console.log(`Restored simple key: ${key}`);
                            }
                        } catch (e) {
                            skippedKeys.push(`${key}(storage_err)`);
                            console.warn(`Error restoring key ${key} to localStorage: ${e.message}`);
                        }
                    } else {
                        skippedKeys.push(key);
                        console.log(`Skipped restoring key (not managed): ${key}`);
                    }
                }
            }

            let message = '';
            let toastType = 'info';
            if (restoredCount > 0) {
                message = `Restauradas ${restoredCount} claves.`;
                if (skippedKeys.length > 0) { message += ` Ignoradas ${skippedKeys.length}.`; }
                message += ' Recargando...';
                toastType = 'success';
                console.log("Restore successful. Restored keys:", restoredCount, "Skipped:", skippedKeys.length, "Reloading...");
                clearModalAutoCloseTimer(modal, closeBtn, 'config-modal');
                if (modal.parentNode) modal.parentNode.removeChild(modal);
                showToast(message, toastType, 3000);
                // Set a flag to reopen the locations map if it was open before config
                if (mapWasOpenBeforeConfig) {
                    sessionStorage.setItem('boardinggate_map_should_reopen_after_config', currentLocationFeatureView); // Reopen to the same view
                    console.log("Flagged to reopen map modal to view:", currentLocationFeatureView);
                }
                setTimeout(() => {
                    location.reload();
                }, 1800);
            } else {
                message = 'No se encontraron datos compatibles.';
                if (skippedKeys.length > 0) { message += ` Ignoradas ${skippedKeys.length}.`; }
                toastType = 'warning';
                showToast(message, toastType, 5000);
                if (userStat) { userStat.textContent = message.substring(0, 100); userStat.style.color = '#ffc107'; }
                console.warn("Restore completed, but no compatible keys found. Skipped:", skippedKeys.length);
            }

        } catch (e) {
            showToast(`Error restaurar: ${e.message}`, 'error', 5000);
            if (userStat) { userStat.textContent = `Error restaurar: ${e.message.substring(0, 100)}`; userStat.style.color = '#EF4444'; }
            console.error("Error during restore process:", e);
        }
    });

    if (savePinBtn) savePinBtn.addEventListener('click', savePinSettings);
    if (removePinBtn) removePinBtn.addEventListener('click', removePinSettings);

    const closeConfigHandler = () => {
        console.log("Closing config modal.");
        clearModalAutoCloseTimer(modal, closeBtn, 'config-modal');
        if (modal.parentNode) document.body.removeChild(modal);

        // Check if the location features modal needs to be reopened
        const viewToReopen = sessionStorage.getItem('boardinggate_map_should_reopen_after_config');
        sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');
        if (viewToReopen) {
            console.log("Reopening map modal to view:", viewToReopen);
            showLocationFeaturesModal(viewToReopen);
        } else if (mapWasOpenBeforeConfig) {
            // If map was open but no specific view flagged, default to locations view
            console.log("Map was open before config, defaulting to locations view.");
            showLocationFeaturesModal('locations');
        } else {
            console.log("Map was not open before config. Not reopening.");
        }
    };
    closeBtn.addEventListener('click', closeConfigHandler);
    // Increased duration for config modal as it's used for more complex tasks
    addModalAutoCloseTimer(modal, closeBtn, 'config-modal', 300000); // 5 minutes

    loadUData();
    const firstTabButton = modal.querySelector('.config-tab-button');
    if (firstTabButton) { firstTabButton.click(); } // Activate the first tab by default
}

function parseCoordinateFilter(inputValue) {
    console.log("Parsing coordinate filter input:", inputValue);
    const cleanedValue = inputValue.trim();
    if (!cleanedValue) { console.log("Filter input is empty."); return { type: 'empty' }; }

    const parts = cleanedValue.split(/\s+/).map(p => parseFloat(p));

    if (parts.some(isNaN)) { console.warn("Filter input contains non-numeric values."); return { type: 'error', message: 'Contiene valores no numéricos.' }; }

    if (parts.length === 1) {
        console.log("Parsed as single value:", parts[0]);
        return {
            type: 'single',
            value: parts[0]
        };
    } else if (parts.length === 2) {
        console.log("Parsed as range:", parts[0], parts[1]);
        return {
            type: 'range',
            min: Math.min(parts[0], parts[1]),
            max: Math.max(parts[0], parts[1])
        };
    } else {
        console.warn("Filter input has too many values.");
        return {
            type: 'error',
            message: 'Demasiados valores. Usar 1 o 2.'
        };
    }
}

async function handleImportRadars() {
    console.log("Import Radars button clicked.");
    const importExtraCheckbox = document.getElementById('import-extra-radars-checkbox');
    const KML_FILES_LIST_STANDARD = './KLM/KLMFILES.TXT';
    const KML_FILES_LIST_EXTRA = './KLM/KLMFILES2.TXT';
    const KML_FILES_LIST_PATH = importExtraCheckbox ? (importExtraCheckbox.checked ? KML_FILES_LIST_EXTRA : KML_FILES_LIST_STANDARD) : KML_FILES_LIST_STANDARD;
    console.log("Using KML list path:", KML_FILES_LIST_PATH);

    const KML_BASE_PATH = './KLM/';
    const COORD_EPSILON = 0.000001;

    const filterLatInput = document.getElementById('radar-filter-lat');
    const filterLonInput = document.getElementById('radar-filter-lon');
    const filterKeywordsInput = document.getElementById('radar-filter-keywords');
    const progressContainer = document.getElementById('radar-import-progress-container');
    const progressBar = document.getElementById('radar-import-progress-bar');
    const progressStatus = document.getElementById('radar-import-status');
    const isMobile = window.innerWidth < 768;

    const latFilterParsed = filterLatInput ? parseCoordinateFilter(filterLatInput.value) : {
        type: 'empty'
    };
    const lonFilterParsed = filterLonInput ? parseCoordinateFilter(filterLonInput.value) : {
        type: 'empty'
    };

    if (latFilterParsed.type === 'error') {
        if (!isMobile) showToast(`Error en filtro Latitud: ${latFilterParsed.message}`, "error");
        if (progressStatus) progressStatus.textContent = `Error en filtro Latitud: ${latFilterParsed.message}`;
        console.error("Lat filter error:", latFilterParsed.message);
        return;
    }
    if (lonFilterParsed.type === 'error') {
        if (!isMobile) showToast(`Error en filtro Longitud: ${lonFilterParsed.message}`, "error");
        if (progressStatus) progressStatus.textContent = `Error en filtro Longitud: ${lonFilterParsed.message}`;
        console.error("Lon filter error:", lonFilterParsed.message);
        return;
    }

    const filterKeywordsRaw = filterKeywordsInput ? filterKeywordsInput.value.trim() : '';
    const filterKeywords = filterKeywordsRaw ? filterKeywordsRaw.toUpperCase().split(/\s+/).filter(k => k) : [];
    console.log("Parsed filters - Lat:", latFilterParsed, "Lon:", lonFilterParsed, "Keywords:", filterKeywords);

    if (progressContainer) progressContainer.style.display = 'block';
    if (progressBar) { progressBar.value = 0; progressBar.max = 1; }
    if (progressStatus) progressStatus.textContent = 'Iniciando importación...';
    console.log("Import process started.");

    try {
        console.log("Fetching KML file list:", KML_FILES_LIST_PATH);
        const response = await fetch(KML_FILES_LIST_PATH, {
            cache: 'no-cache'
        });
        if (!response.ok) {
            throw new Error(`No se pudo cargar ${KML_FILES_LIST_PATH}: ${response.statusText}`);
        }
        const fileListText = await response.text();
        const kmlFiles = fileListText.split('\n').map(f => f.trim()).filter(f => f && !f.startsWith('#'));
        console.log("Found KML files:", kmlFiles);

        if (kmlFiles.length === 0) {
            const msg = `No hay ficheros KML para importar en ${KML_FILES_LIST_PATH.split('/').pop()}.`;
            if (progressStatus) progressStatus.textContent = msg;
            if (!isMobile) showToast(msg, 'info');
            console.warn(msg);
            return;
        }

        if (progressBar) progressBar.max = kmlFiles.length;
        let totalImportedCount = 0;
        let existingReminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        console.log("Loaded", existingReminders.length, "existing reminders.");

        for (let i = 0; i < kmlFiles.length; i++) {
            const kmlFileName = kmlFiles[i];
            if (progressStatus) progressStatus.textContent = `Procesando fichero ${i + 1} de ${kmlFiles.length}: ${kmlFileName}...`;
            if (progressBar) progressBar.value = i + 1;
            await new Promise(resolve => setTimeout(resolve, 50)); // Small delay for UI update

            try {
                console.log("Fetching KML file:", KML_BASE_PATH + kmlFileName);
                const kmlResponse = await fetch(KML_BASE_PATH + kmlFileName, {
                    cache: 'no-cache'
                });
                if (!kmlResponse.ok) {
                    const errorMsg = `(Error carga: ${kmlResponse.statusText})`;
                    if (progressStatus) progressStatus.textContent += errorMsg;
                    console.warn(`Failed to fetch ${kmlFileName}: ${kmlResponse.statusText}`);
                    await sleep(1000);
                    continue;
                }
                const kmlString = await kmlResponse.text();
                const parser = new DOMParser();
                const kmlDoc = parser.parseFromString(kmlString, "application/xml");
                console.log(`Parsed KML for ${kmlFileName}`);

                const placemarks = kmlDoc.getElementsByTagName('Placemark');
                let fileRecordsFound = placemarks.length;
                let fileImportedCount = 0;
                console.log(`Found ${fileRecordsFound} placemarks in ${kmlFileName}.`);

                for (let j = 0; j < placemarks.length; j++) {
                    const placemark = placemarks[j];
                    const nameElement = placemark.getElementsByTagName('name')[0];
                    const coordinatesElement = placemark.getElementsByTagName('coordinates')[0];

                    if (!nameElement || !coordinatesElement) { console.warn(`Placemark ${j} in ${kmlFileName} missing name or coordinates.`); continue; }

                    const name = nameElement.textContent.trim();
                    const coordsString = coordinatesElement.textContent.trim();
                    const coordsParts = coordsString.split(',');
                    if (coordsParts.length < 2) { console.warn(`Placemark ${j} in ${kmlFileName} has invalid coordinates string: "${coordsString}".`); continue; }
                    const lon = parseFloat(coordsParts[0]);
                    const lat = parseFloat(coordsParts[1]);
                    if (isNaN(lat) || isNaN(lon)) { console.warn(`Placemark ${j} in ${kmlFileName} has invalid lat/lon: ${lat}, ${lon}.`); continue; }

                    // Apply filters
                    let passesLatFilter = true;
                    if (latFilterParsed.type === 'single') {
                        passesLatFilter = Math.abs(lat - latFilterParsed.value) < 0.0001;
                    } else if (latFilterParsed.type === 'range') {
                        passesLatFilter = lat >= latFilterParsed.min && lat <= latFilterParsed.max;
                    }
                    if (!passesLatFilter) continue;

                    let passesLonFilter = true;
                    if (lonFilterParsed.type === 'single') {
                        passesLonFilter = Math.abs(lon - lonFilterParsed.value) < 0.0001;
                    } else if (lonFilterParsed.type === 'range') {
                        passesLonFilter = lon >= lonFilterParsed.min && lon <= lonFilterParsed.max;
                    }
                    if (!passesLonFilter) continue;

                    if (filterKeywords.length > 0) {
                        const nameUpper = name.toUpperCase();
                        if (!filterKeywords.some(kw => nameUpper.includes(kw))) {
                            continue; // Skip if name doesn't contain any keyword
                        }
                    }

                    // Check for duplicates based on coordinates
                    const alreadyExists = existingReminders.some(r =>
                        r.isLocationEnabled && r.locationCoordinates &&
                        Math.abs(r.locationCoordinates.latitude - lat) < COORD_EPSILON &&
                        Math.abs(r.locationCoordinates.longitude - lon) < COORD_EPSILON
                    );
                    if (alreadyExists) continue; // Skip if duplicate

                    // Create and add new reminder
                    const now = new Date();
                    const newRadarReminder = {
                        id: Date.now() + i * 10000 + j, // Unique enough ID for import batch
                        text: `<b>RADAR: ${name.toUpperCase()}</b>`, // Use RADAR prefix
                        type: 'simple', // Treat as simple location reminder
                        time: '00:01', // Default time
                        date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`, // Default date (today)
                        createdAt: now.toISOString(),
                        managedByUser: false, // Not manually created by user in modal
                        isLocationEnabled: true, // Location is enabled
                        locationCoordinates: {
                            latitude: lat,
                            longitude: lon
                        },
                        radiusMeters: 400, // Default radius for imported POIs
                        excludeFromList: true // Exclude from general list, mark as radar
                    };
                    existingReminders.push(newRadarReminder);
                    fileImportedCount++;
                    totalImportedCount++;
                    console.log(`Imported new radar: ${name} at ${lat}, ${lon}`);
                }
                const fileStatusMsg = `${kmlFileName}: Encontrados ${fileRecordsFound}. Importados ${fileImportedCount} nuevos.`;
                if (progressStatus) {
                    progressStatus.textContent = fileStatusMsg;
                    if (progressBar) progressBar.value = i + 1;
                }
                if (fileImportedCount > 0 && !isMobile) showToast(`${kmlFileName}: ${fileImportedCount} nuevos radares importados.`, 'success');
                await sleep(isMobile ? 500 : 200); // Small delay after each file

            } catch (fileError) {
                const errorMsg = `Error en ${kmlFileName}: ${fileError.message.substring(0,50)}`;
                if (progressStatus) progressStatus.textContent = errorMsg;
                console.error(`Error processing KML file ${kmlFileName}:`, fileError);
                await sleep(1000); // Longer delay on error
            }
        }
        // Save all reminders back to local storage after processing all files
        localStorage.setItem('reminders', JSON.stringify(existingReminders));
        console.log("All KML files processed. Final number of reminders:", existingReminders.length);
        if (progressBar) progressBar.value = kmlFiles.length; // Ensure progress bar is full
        if (progressStatus) progressStatus.textContent = `Importación completada. Total importados: ${totalImportedCount} nuevos radares.`;
        if (!isMobile) showToast(`Proceso finalizado. ${totalImportedCount} radares nuevos añadidos.`, 'info');
        updateReminderCount(); // Update counts on buttons/globe
        updateButtonStyles(); // Refresh button styles (might not be necessary here)
        checkReminders(); // Re-trigger check to update unified window if any imported are overdue/nearby

    } catch (error) {
        const errorMsg = `Error: ${error.message}`;
        if (progressStatus) progressStatus.textContent = errorMsg;
        if (!isMobile) showToast(`Error en importación: ${error.message}`, 'error');
        console.error("Import process failed:", error);
    }
}

async function handleDeleteFilteredRadars() {
    console.log("Delete Filtered Radars button clicked.");
    const filterLatInput = document.getElementById('radar-filter-lat');
    const filterLonInput = document.getElementById('radar-filter-lon');
    const filterKeywordsInput = document.getElementById('radar-filter-keywords');
    const progressStatus = document.getElementById('radar-import-status'); // Reuse status area
    const isMobile = window.innerWidth < 768;

    const latFilterParsed = filterLatInput ? parseCoordinateFilter(filterLatInput.value) : {
        type: 'empty'
    };
    const lonFilterParsed = filterLonInput ? parseCoordinateFilter(filterLonInput.value) : {
        type: 'empty'
    };

    if (latFilterParsed.type === 'error') {
        if (!isMobile) showToast(`Error en filtro Latitud: ${latFilterParsed.message}`, "error");
        if (progressStatus) progressStatus.textContent = `Error en filtro Latitud: ${latFilterParsed.message}`;
        console.error("Lat filter error:", latFilterParsed.message);
        return;
    }
    if (lonFilterParsed.type === 'error') {
        if (!isMobile) showToast(`Error en filtro Longitud: ${lonFilterParsed.message}`, "error");
        if (progressStatus) progressStatus.textContent = `Error en filtro Longitud: ${lonFilterParsed.message}`;
        console.error("Lon filter error:", lonFilterParsed.message);
        return;
    }

    const filterKeywordsRaw = filterKeywordsInput ? filterKeywordsInput.value.trim() : '';
    const filterKeywords = filterKeywordsRaw ? filterKeywordsRaw.toUpperCase().split(/\s+/).filter(k => k) : [];
    console.log("Parsed filters for deletion - Lat:", latFilterParsed, "Lon:", lonFilterParsed, "Keywords:", filterKeywords);


    const isAnyFilterActive = latFilterParsed.type !== 'empty' || lonFilterParsed.type !== 'empty' || filterKeywords.length > 0;

    if (!isAnyFilterActive) {
        const msg = "Define al menos un filtro para borrar.";
        if (!isMobile) showToast(msg, "warning");
        if (progressStatus) progressStatus.textContent = msg;
        console.warn(msg);
        return;
    }

    if (!confirm("¿Seguro que quieres borrar los recordatorios de ubicación que coincidan con los filtros activos? Esta acción no se puede deshacer.")) {
        const msg = "Borrado cancelado.";
        if (!isMobile) showToast(msg, "info");
        if (progressStatus) progressStatus.textContent = msg;
        console.log(msg);
        return;
    }

    if (progressStatus) progressStatus.textContent = "Buscando y borrando recordatorios...";
    console.log("Starting deletion process with filters...");

    let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    let initialCount = reminders.length;
    let deletedCount = 0;

    const remindersToKeep = reminders.filter(reminder => {
        // Keep the reminder if it does NOT have location enabled OR if it does BUT it doesn't match ALL filters
        if (!reminder.isLocationEnabled || !reminder.locationCoordinates) {
            return true; // Keep non-location reminders
        }

        let matchesLat = latFilterParsed.type === 'empty'; // If filter is empty, it's considered a match
        if (latFilterParsed.type === 'single') {
            matchesLat = Math.abs(reminder.locationCoordinates.latitude - latFilterParsed.value) < 0.0001;
        } else if (latFilterParsed.type === 'range') {
            matchesLat = reminder.locationCoordinates.latitude >= latFilterParsed.min && reminder.locationCoordinates.latitude <= latFilterParsed.max;
        }

        let matchesLon = lonFilterParsed.type === 'empty'; // If filter is empty, it's considered a match
        if (lonFilterParsed.type === 'single') {
            matchesLon = Math.abs(reminder.locationCoordinates.longitude - lonFilterParsed.value) < 0.0001;
        } else if (lonFilterParsed.type === 'range') {
            matchesLon = reminder.locationCoordinates.longitude >= lonFilterParsed.min && reminder.locationCoordinates.longitude <= lonFilterParsed.max;
        }

        let matchesKeywords = filterKeywords.length === 0; // If no keywords, it's considered a match
        if (filterKeywords.length > 0) {
            const reminderTextUpper = reminder.text.toUpperCase().replace(/<b>|<\/b>/gi, '');
            // Must match *all* keywords? Or *any* keyword? The prompt says "cumplan TODOS los filtros activos (Lat, Lon, Palabras)".
            // Let's assume it means matching *all* provided keywords if keywords are active.
            matchesKeywords = filterKeywords.every(kw => reminderTextUpper.includes(kw));
            // If it meant *any*: matchesKeywords = filterKeywords.some(kw => reminderTextUpper.includes(kw));
        }

        // Delete the reminder if it matches ALL active filters (location, lat, lon, keywords)
        if (matchesLat && matchesLon && matchesKeywords) {
            deletedCount++;
            // console.log("Deleting reminder:", reminder.text, reminder.locationCoordinates);
            return false; // Filter this reminder OUT (delete it)
        }
        return true; // Keep this reminder
    });

    if (deletedCount > 0) {
        localStorage.setItem('reminders', JSON.stringify(remindersToKeep));
        const msg = `${deletedCount} recordatorios borrados.`;
        if (!isMobile) showToast(msg, 'success');
        if (progressStatus) progressStatus.textContent = msg;
        console.log(msg);
        updateReminderCount(); // Update counts on buttons/globe
        updateButtonStyles(); // Refresh button styles
        checkReminders(); // Re-trigger check to update unified window and maps
    } else {
        const msg = "No se encontraron recordatorios que coincidan con los filtros.";
        if (!isMobile) showToast(msg, 'info');
        if (progressStatus) progressStatus.textContent = msg;
        console.log(msg);
    }
}

const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

function showToast(message, type = 'info', duration = 3000) {
    console.log(`Showing toast: [${type}] ${message}`);
    const existingToast = document.getElementById('toast-notification-element');
    if (existingToast) { existingToast.remove(); }

    const toast = document.createElement('div');
    toast.id = 'toast-notification-element';
    toast.className = `toast-notification toast-${type}`;
    toast.textContent = message;
    document.body.appendChild(toast);

    // Use requestAnimationFrame for smoother display
    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            toast.classList.add('show');
        });
    });

    // Hide and remove after duration
    setTimeout(() => {
        toast.classList.remove('show');
        // Remove the element after the transition ends
        toast.addEventListener('transitionend', () => {
            if (toast.parentNode) { toast.parentNode.removeChild(toast); }
        }, {
            once: true
        }); // Ensure the listener runs only once
    }, duration);
}


function formatDateToDDMMMYY(dateString) {
    // dateString format: YYYY-MM-DD
    if (!dateString) return '-';
    try {
        const [year, month, day] = dateString.split('-').map(Number);
        // Create Date object in UTC to avoid timezone conversions affecting the date parts
        const date = new Date(Date.UTC(year, month - 1, day));

        if (isNaN(date.getTime())) return '-'; // Invalid date

        const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
        const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
        const monthName = monthNames[date.getUTCMonth()];
        const yearShort = String(date.getUTCFullYear()).slice(-2); // Last 2 digits of year

        return `${dayOfMonth} ${monthName} ${yearShort}`;
    } catch (e) {
        console.error("Error formatting date to DD MMM YY:", dateString, e);
        return '-'; // Return hyphen on error
    }
}

function formatDateDetailed(dateString) {
    // dateString format: YYYY-MM-DD
    if (!dateString || !dateString.match(/^\d{4}-\d{2}-\d{2}$/)) return '-';
    try {
        const [year, month, day] = dateString.split('-').map(Number);
        // Create Date object in UTC to avoid timezone conversions affecting the date parts
        const date = new Date(Date.UTC(year, month - 1, day));
        if (isNaN(date.getTime())) return dateString; // Return original string if invalid but format matches

        const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
        const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
        const monthName = monthNames[date.getUTCMonth()];
        const fullYear = date.getUTCFullYear();

        return `${dayOfMonth}-${monthName}-${fullYear}`;
    } catch (e) {
        console.error("Error formatting date detailed:", dateString, e);
        return dateString; // Return original string or hyphen on error
    }
}

function formatTimeWithPeriod(timeString) {
    // timeString format: HH:MM
    if (!timeString || !timeString.match(/^\d{2}:\d{2}$/)) return '-';
    try {
        const [hourStr, minuteStr] = timeString.split(':');
        const hour = parseInt(hourStr);
        const minute = parseInt(minuteStr);
        if (isNaN(hour) || isNaN(minute) || hour < 0 || hour > 23 || minute < 0 || minute > 59) {
            console.warn("Invalid time string format or values:", timeString);
            return timeString; // Return original string if values are out of range
        }
        let period = '';
        if (hour >= 22 || hour < 5) { period = 'de la Noche'; } else if (hour >= 5 && hour < 12) { period = 'de la Mañana'; } else if (hour >= 12 && hour < 14) { period = 'del Mediodía'; } else { period = 'de la Tarde'; }

        return `${hourStr}:${minuteStr} (${period})`;
    } catch (e) {
        console.error("Error formatting time with period:", timeString, e);
        return timeString; // Return original string on error
    }
}

let globalModalTimers = {};

function addModalAutoCloseTimer(modalElement, closeButtonElement, modalId, duration = 60000) {
    if (!modalElement || !closeButtonElement || !modalId) {
        console.warn("Missing elements for addModalAutoCloseTimer.");
        return;
    }
    modalElement.dataset.modalTimerId = modalId;
    console.log(`Adding auto-close timer for modal "${modalId}" (${duration / 1000}s).`);

    // Clear any existing timer for this modal
    clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId);

    let countdown = duration / 1000;
    // Find or create the countdown span
    let countdownSpan = closeButtonElement.querySelector(`.button-countdown-timer`);

    if (!countdownSpan) {
        countdownSpan = document.createElement('span');
        countdownSpan.className = 'button-countdown-timer';
        countdownSpan.style.marginLeft = '5px';
        countdownSpan.style.fontWeight = 'normal';
        closeButtonElement.appendChild(countdownSpan);
    }
    countdownSpan.textContent = ` (${countdown})`;

    const intervalId = setInterval(() => {
        countdown--;
        if (countdownSpan && document.body.contains(countdownSpan)) {
            countdownSpan.textContent = ` (${countdown})`;
        }
        if (countdown <= 0) {
            console.log(`Modal "${modalId}" auto-closing.`);
            // Clear the interval and the global timer reference
            if (globalModalTimers[modalId]) {
                clearInterval(globalModalTimers[modalId].intervalId);
                delete globalModalTimers[modalId];
            }
            // Trigger the close action
            if (closeButtonElement && document.body.contains(closeButtonElement)) {
                closeButtonElement.click();
            } else if (modalElement && modalElement.parentNode) {
                // Fallback: just remove the modal if button isn't available/valid
                modalElement.parentNode.removeChild(modalElement);
            }
        }
    }, 1000); // Update every second

    // Handler to reset the timer on user interaction
    const resetTimerHandler = () => {
        // console.log(`User interaction detected on modal "${modalId}". Resetting timer.`);
        if (!globalModalTimers[modalId] || !globalModalTimers[modalId].intervalId) {
            // console.warn(`Timer for "${modalId}" not found or invalid during reset.`);
            return; // Timer is not active or already cleared
        }
        clearInterval(globalModalTimers[modalId].intervalId); // Clear the old interval
        countdown = duration / 1000; // Reset countdown
        if (countdownSpan && document.body.contains(countdownSpan)) {
            countdownSpan.textContent = ` (${countdown})`; // Update UI immediately
        }
        // Start a new interval with the reset countdown
        const newIntervalId = setInterval(() => {
            countdown--;
            if (countdownSpan && document.body.contains(countdownSpan)) {
                countdownSpan.textContent = ` (${countdown})`;
            }
            if (countdown <= 0) {
                console.log(`Modal "${modalId}" auto-closing after reset.`);
                if (globalModalTimers[modalId]) {
                    clearInterval(globalModalTimers[modalId].intervalId);
                    delete globalModalTimers[modalId];
                }
                if (closeButtonElement && document.body.contains(closeButtonElement)) {
                    closeButtonElement.click();
                } else if (modalElement && modalElement.parentNode) {
                    modalElement.parentNode.removeChild(modalElement);
                }
            }
        }, 1000);
        globalModalTimers[modalId].intervalId = newIntervalId; // Store the new interval ID
    };

    // Add event listeners to reset the timer
    modalElement.addEventListener('click', resetTimerHandler);
    modalElement.addEventListener('touchstart', resetTimerHandler, {
        passive: true
    }); // Use passive for touch
    modalElement.addEventListener('input', resetTimerHandler);
    modalElement.addEventListener('scroll', resetTimerHandler, {
        passive: true
    }); // Use passive for scroll

    // Store timer information globally
    globalModalTimers[modalId] = {
        intervalId: intervalId,
        resetHandler: resetTimerHandler, // Store handler to remove it later
        modalElement: modalElement, // Store element to remove listeners later
        closeButtonElement: closeButtonElement, // Store button to update span
        countdownSpan: countdownSpan // Store span to update text
    };
    console.log(`Timer for "${modalId}" started with interval ID ${intervalId}.`);
}

function clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId) {
    console.log(`Attempting to clear auto-close timer for modal "${modalId || (modalElement ? modalElement.dataset.modalTimerId : 'N/A')}".`);
    // Get the modal ID from the function argument or the element's data attribute
    const timerIdToClear = modalId || (modalElement ? modalElement.dataset.modalTimerId : null);

    if (timerIdToClear && globalModalTimers[timerIdToClear]) {
        console.log(`Timer "${timerIdToClear}" found. Clearing interval ${globalModalTimers[timerIdToClear].intervalId}.`);
        clearInterval(globalModalTimers[timerIdToClear].intervalId);
        const timerData = globalModalTimers[timerIdToClear];
        // Remove event listeners
        if (timerData.modalElement && timerData.resetHandler) {
            timerData.modalElement.removeEventListener('click', timerData.resetHandler);
            timerData.modalElement.removeEventListener('touchstart', timerData.resetHandler);
            timerData.modalElement.removeEventListener('input', timerData.resetHandler);
            timerData.modalElement.removeEventListener('scroll', timerData.resetHandler);
            console.log("Removed event listeners for timer.");
        }
        // Remove the countdown span from the button
        if (timerData.countdownSpan && timerData.countdownSpan.parentNode) {
            timerData.countdownSpan.remove();
            console.log("Removed countdown span from button.");
        }
        // Delete the global reference
        delete globalModalTimers[timerIdToClear];
        console.log(`Timer "${timerIdToClear}" cleared.`);
    } else {
        // console.log(`No active timer found for "${timerIdToClear || 'N/A'}".`);
    }
    // Also ensure the data attribute is removed from the modal element
    if (modalElement && modalElement.dataset.modalTimerId) {
        delete modalElement.dataset.modalTimerId;
        // console.log("Removed modalTimerId data attribute.");
    }
}

async function initializeApp() {
    console.log("Initializing application..."); // Log 3: initializeApp start

    isLocationFeaturesModalActive = false; // Ensure this is false initially
    isNavigating = false; // Ensure this is false initially
    routePoints = []; // Clear any previous route points on startup
    sessionStorage.removeItem('boardinggate_current_route_points'); // Clear cached route points on startup


    renderGrid();
    createOtherButtons();
    renderToggleButtons();
    try { await updateVersion(); } catch (e) { console.error("Error updating version:", e); }
    loadSavedSettings();
    try { await loadNotices(); startNoticeRotation(); } catch (e) { console.error("Error loading notices:", e); }

    // Ensure previous reminder check interval is cleared before starting a new one
    if (reminderCheckIntervalId) {
        clearInterval(reminderCheckIntervalId);
        reminderCheckIntervalId = null;
        console.log("Cleared existing reminder check interval.");
    }
    checkReminders(); // Perform an initial check immediately
    console.log("Starting reminder check interval (initial duration:", currentCheckIntervalDuration, "ms)");
    reminderCheckIntervalId = setInterval(checkReminders, currentCheckIntervalDuration);


    const noticeToggleIcon = document.getElementById('notice-toggle-icon');
    if (noticeToggleIcon) noticeToggleIcon.addEventListener('click', toggleNotices);

    const countEl = document.getElementById('reminder-count-globe');
    if (countEl) {
        const openTable = (e) => {
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
            e.preventDefault();
            e.stopPropagation();
            showAllReminders();
        };
        // Remove existing listener before adding a new one, just in case
        countEl.removeEventListener('click', openTable);
        countEl.addEventListener('click', openTable);
        countEl.style.cursor = 'pointer';
    }

    const filterInput = document.getElementById('grid-filter-input');
    const clearButton = document.getElementById('clear-filter-button');
    if (filterInput) {
        filterInput.addEventListener('input', () => {
            localStorage.setItem('gridFilterValue', filterInput.value);
            filterGridItems();
            if (isKeywordAssignmentMode) applyInitialKeywordHighlights();
        });
    }
    if (clearButton) {
        clearButton.addEventListener('click', () => {
            if (filterInput) filterInput.value = '';
            localStorage.removeItem('gridFilterValue');
            filterGridItems();
            if (isKeywordAssignmentMode) applyInitialKeywordHighlights();
        });
    }

    adjustButtonPositions();
    // Remove existing resize listener before adding a new one
    window.removeEventListener('resize', adjustButtonPositions);
    window.addEventListener('resize', adjustButtonPositions);
    checkVersionsIconOpacity();

    // Check if we need to reopen the map modal after a config restore
    const viewToReopen = sessionStorage.getItem('boardinggate_map_should_reopen_after_config');
    if (viewToReopen) {
        console.log("Reopening map modal after config restore to view:", viewToReopen);
        sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');
        showLocationFeaturesModal(viewToReopen);
    } else {
        console.log("No specific map view flagged to reopen after config.");
        // If no specific view to reopen, ensure the main content area is displayed if needed
        // (In case it was hidden by a modal that didn't handle its cleanup properly)
        const mainElement = document.querySelector('main');
        if (mainElement) {
            // Assuming the main content is visible by default and hidden only when modals are shown fullscreen
            // No specific action needed here unless a modal is sticky on startup
        }
    }
    console.log("Application initialization complete."); // Log 3: initializeApp end
}


document.addEventListener('DOMContentLoaded', async () => {
    loadCustomData(); 
    storedPin = localStorage.getItem('password_pin');
    const savedPasswordActive = localStorage.getItem('password_active');
    isPasswordActive = savedPasswordActive ? JSON.parse(savedPasswordActive) : false;


  */ //

    console.log("Initial password check. isPasswordActive:", isPasswordActive, "storedPin exists:", !!storedPin); 
    if (isPasswordActive && storedPin) {
        promptForPin(); 
    } else {
        await initializeApp();
    }
    window.addEventListener('beforeunload', () => {
        console.log("Window beforeunload event triggered. Performing cleanup.");
        if (reminderCheckIntervalId) {
            clearInterval(reminderCheckIntervalId);
            reminderCheckIntervalId = null;
        }
        
        
        
        if (locationWatchId !== null) {
            navigator.geolocation.clearWatch(locationWatchId);
            locationWatchId = null;
            console.log("Cleared location watch ID:", locationWatchId);
        }
        if (navigationLocationWatchId !== null) {
            navigator.geolocation.clearWatch(navigationLocationWatchId);
            navigationLocationWatchId = null;
            console.log("Cleared navigation location watch ID:", navigationLocationWatchId);
        }
        if (navigationUpdateInterval) {
            clearInterval(navigationUpdateInterval);
            navigationUpdateInterval = null;
            console.log("Cleared navigation UI update interval.");
        }
        Object.keys(globalModalTimers).forEach(modalId => {
            const timerData = globalModalTimers[modalId];
            if (timerData) {
                clearModalAutoCloseTimer(timerData.modalElement, timerData.closeButtonElement, modalId);
            }
        });
        globalModalTimers = {};
        const openModals = document.querySelectorAll('.reminder-modal, .reminder-table-modal, #postpone-options-modal, .saved-locations-modal, #location-features-modal, #reminders-map-help-modal-instance, #saved-routes-modal, .versions-modal-overlay, #pin-modal-overlay');
        openModals.forEach(modal => {
            if (modal.autoCloseInterval) clearInterval(modal.autoCloseInterval);
            if (modal.autoPostponeInterval) clearInterval(modal.autoPostponeInterval);
            if (modal.id === 'location-features-modal') {
                if (allLocationsMapInstance) {
                    if (orientationAltitudeControl && typeof allLocationsMapInstance.hasControl === 'function' && allLocationsMapInstance.hasControl(orientationAltitudeControl)) {
                        allLocationsMapInstance.removeControl(orientationAltitudeControl);
                    }
                    try { allLocationsMapInstance.remove(); } catch (e) { console.warn("Error removing allLocationsMapInstance on unload:", e); }
                    allLocationsMapInstance = null;
                    initialUserLocationMarker = null;
                    initialUserLocationCircle = null;
                    orientationAltitudeControl = null;
                }
                if (navigationMap) { try { navigationMap.remove(); } catch (e) { console.warn("Error removing navigationMap on unload:", e); } navigationMap = null; currentUserMarker = null; currentUserCircle = null; }
            }
            if (modal.id === 'location-map-container' && reminderModalMap) { 
                try { reminderModalMap.remove(); } catch (e) { console.warn("Error removing reminderModalMap on unload:", e); }
                reminderModalMap = null;
                reminderMarker = null;
                reminderCircle = null;
            }
            if (modal.id === 'location-picker-map-container' && locationPickerMap) {
                try { locationPickerMap.remove(); } catch (e) { console.warn("Error removing locationPickerMap on unload:", e); }
                locationPickerMap = null;
                locationPickerMarker = null;
            }
            if (modal.parentNode) modal.parentNode.removeChild(modal);
        });
        Object.values(previewMaps).forEach(map => {
            try { map?.remove(); } catch (e) { console.warn("Error removing preview map on unload:", e); }
        });
        previewMaps = {}; 
        if (isAssignmentMode || isEditMode || isKeywordAssignmentMode) {
            console.log("Saving custom data before unload.");
            saveCustomData();
        } else {
        }
        saveRoutePointsToCache();
        const filterInput = document.getElementById('grid-filter-input');
        if (filterInput && filterInput.value.trim()) {
            localStorage.setItem('gridFilterValue', filterInput.value);
            console.log("Saved grid filter value:", filterInput.value);
        } else {
            localStorage.removeItem('gridFilterValue');
            console.log("Cleared saved grid filter value.");
        }
        saveSettings(); 
    });
</script>
</body>
</html>    
lllll