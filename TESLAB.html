
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BoardingGate</title>
    <link rel="icon" href="https://boardinggate.github.io/Tesla/th.jpeg" type="image/jpeg">
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module"> import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js"; import { getFirestore, doc, setDoc, getDoc, getDocs, deleteDoc, collection } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js"; console.log("Firebase Init Script: STARTING initialization."); const firebaseConfig = {apiKey: "AIzaSyCEAWL1Pj1OMBrGnXLOS79W3iDjMkmTQGw",authDomain: "boardinggate-1df74.firebaseapp.com",databaseURL: "https://boardinggate-1df74-default-rtdb.europe-west1.firebaseio.com",projectId: "boardinggate-1df74",storageBucket: "boardinggate-1df74.appspot.com", messagingSenderId: "771541345352",appId: "1:771541345352:web:0447d72b3383875ac5a47d" };try {  const app = initializeApp(firebaseConfig); window.db = getFirestore(app); window.doc = doc; window.setDoc = setDoc; window.getDoc = getDoc; window.collection = collection; window.getDocs = getDocs; window.deleteDoc = deleteDoc; console.log("Firebase Init Script: SUCCESS Firestore initialized and functions exposed globally. window.db is:", window.db); } catch (e) { console.error("Firebase Init Script: ERROR during initialization!", e); } console.log("Firebase Init Script: END of initialization block."); </script>  
   <script src="//cdn.jsdelivr.net/npm/eruda"></script>
    <script>eruda.init();</script>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script src="https://unpkg.com/leaflet-geometryutil@0.10.3/src/leaflet.geometryutil.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>

<style>
 body {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    background-color: #ABAB99;
    margin: 0;
    overflow-x: hidden;
}
body.dark-mode {
    background-color: #92927E;
}
main {
    position: relative;
    margin: 0 auto 0.5rem 60px;
    margin-top: 76px;
    background-color: transparent;
    border-radius: 0.75rem;
    padding: 16px;
    min-height: 400px;
    max-width: 984px;
    width: 100%;
    transition: margin-top 0.5s ease-in-out;
}
footer {
    margin: 0.5rem auto;
    text-align: center;
    max-width: 984px;
    width: 100%;
    display: block;
    background-color: #ABAB99;
    margin-left: 145px;
    transition: margin-top 0.5s ease-in-out;
}
body.dark-mode footer {
    background-color: #92927E;
}
.footer-content {
    color: #5C5C47;
    padding: 0.5rem;
    margin: 0 auto;
    max-width: 100%;
    position: relative;
}
.footer-subtext {
    font-size: 0.75rem;
    color: #5C5C47;
    margin-top: 0.25rem;
    text-align: center;
}
.footer-link-green {
    color: #5C5C47;
    text-decoration: none;
    transition: color 0.2s ease;
}
.footer-link-green:hover {
    color: #5C5C47;
}
.footer-line {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
}
.hidden {
    display: none !important;
}
.footer-hidden {
    display: none !important;
}
.header-container {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    background-color: #ABAB99;
    padding: 0.5rem;
}
body.dark-mode .header-container {
    background-color: #92927E;
}
.header-logo {
    width: 100px;
    height: 70px;
    transition: filter 0.2s ease;
}
body.dark-mode .header-logo {
    filter: brightness(85%);
}
.title-container {
    background-color: #ABAB99;
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    display: inline-block;
}
body.dark-mode .title-container {
    background-color: #92927E;
}
.header-container h1 {
    color: #5C5C47;
}
.version-text {
    font-size: 0.75rem;
    color: #5C5C47;
    font-weight: normal;
}
#bookmark-grid {
    display: grid;
    grid-template-columns: repeat(6, minmax(120px, 1fr));
    gap: 15px;
    background-color: transparent;
    border-radius: 0.75rem;
    position: relative;
    width: 100%;
    max-width: 984px;
    margin: 0 auto 0 85px;
    transition: all 0.3s ease;
}
#bookmark-grid > div {
    height: auto;
    aspect-ratio: 16 / 9;
    transition: all 0.3s ease;
}
.bookmark-item {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border-radius: 0.5rem;
    transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease;
    box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1);
    position: relative;
    cursor: pointer;
}
.bookmark-item:hover:not(.editing-active *):not(.assignment-active *):not(.dragging *):not(.editing-target *):not(.keyword-assignment-active *) {
    transform: scale(1.05) translateY(-1px);
    box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.6), -6px -6-12px rgba(255, 255, 255, 0.15);
}
.bookmark-item img {
    image-rendering: crisp-edges;
    width: 36px;
    height: auto;
    max-width: 40px;
    border-radius: 0.25rem;
}
.bookmark-name {
    font-size: clamp(0.85rem, 1.5vw, 1.15rem);
    font-weight: bold;
    color: #333;
    text-align: center;
    margin-top: 4px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
}
body.dark-mode .bookmark-item {
    filter: brightness(60%);
}
.empty-slot {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    border: 1px dashed #ccc;
    border-radius: 0.5rem;
    background-color: rgba(200, 200, 200, 0.1);
    color: #aaa;
    transition: background-color 0.2s ease, outline 0.2s ease, box-shadow 0.2s ease;
    cursor: default;
}
.empty-slot span {
    font-size: 2rem;
    pointer-events: none;
}
body.dark-mode .empty-slot {
    border-color: #666;
    color: #777;
    background-color: rgba(100, 100, 100, 0.2);
}
.toggle-image, .toggle-sign {
    width: 135px;
    height: 74px;
    margin-bottom: 2px;
    box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.4);
    border: 1px solid #7c7c68;
    left: 10px;
    z-index: 1000;
    transition: background-color 0.2s ease, filter 0.2s ease, top 0.3s ease, border 0.2s ease;
    border-radius: 35px;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    display: flex;
    position: fixed;
    top: 90px;
    background-color: #ABAB99;
}
.toggle-sign {
    font-weight: bold;
    font-size: 1.25rem;
    color: #000000;
    text-align: center;
}
.toggle-sign .sign {
    font-size: 1.5rem;
    margin-right: 2px;
}
.toggle-sign img, .toggle-image img {
    max-width: 70%;
    max-height: 70%;
    object-fit: contain;
}
.toggle-sign:not(.range-toggle):not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *):hover {
    background-color: #D9A066;
}
.toggle-sign.range-toggle:not([data-state="hidden"]):not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *):hover {
    background-color: #D9A066;
}
.toggle-image:hover {
    filter: brightness(80%);
}
.toggle-sign.range-toggle[data-state="hidden"] {
    background-color: #ABAB99;
    color: #7F7F7F;
}
body.dark-mode .toggle-sign.range-toggle[data-state="hidden"] {
    background-color: #ABAB99;
    color: #A0A0A0;
}
body.dark-mode .toggle-sign:not(.range-toggle):not(#password-toggle-button), body.dark-mode .toggle-image, body.dark-mode .toggle-sign.range-toggle:not([data-state="hidden"]) {
    filter: brightness(85%);
    background-color: #ABAB99;
}
body.dark-mode .toggle-sign:not(.range-toggle):hover:not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *), body.dark-mode .toggle-sign.range-toggle:not([data-state="hidden"]):hover:not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *) {
    background-color: #ABAB99;
}
.scroll-toggle-button {
    position: fixed;
    width: 110px !important;
    height: clamp(75px, 20vw, 130px) !important;
    background-color: #ABAB99;
    border-radius: 60px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    padding: clamp(10px, 2vw, 20px);
    cursor: pointer;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.4) !important;
    border: 1px solid #808080 !important;
    z-index: 1001;
    transition: background-color 0.2s ease;
    left: 10px;
    top: 10px;
}
.scroll-toggle-button:hover {
    background-color: #668B8B;
}
.scroll-toggle-button svg {
    width: clamp(24px, 4vw, 32px);
    height: clamp(24px, 4vw, 32px);
    stroke: #E6E6DC;
}
.arrow-button {
    width: clamp(36px, 6vw, 48px);
    height: clamp(36px, 6vw, 48px);
    background-color: #668B8B;
    border-radius: 50%;
    display: flex;
    align-items: right;
    justify-content: center;
    cursor: pointer;
    box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    transition: background-color 0.2s ease;
}
.arrow-button:hover {
    background-color: #5C5C47;
}
.arrow-button svg {
    stroke: #E6E6DC;
}
#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button {
    width: auto !important;
    height: auto !important;
    background-color: transparent !important;
    border: none !important;
    box-shadow: none !important;
    padding: 5px !important;
    position: absolute !important;
    top: 37px !important;
    z-index: 900 !important;
    cursor: pointer;
    border-radius: 50%;
    transition: transform 0.1s ease, background-color 0.2s ease, box-shadow 0.2s ease, border 0.2s ease;
}
#config-button {
    left: 185px !important;
}
#personal-button {
    left: 260px !important;
}
#radar-button {
    left: 330px !important;
}
#home-button {
    left: 400px !important;
}
#reload-button {
    left: 470px !important;
}
#keyword-assignment-button {
    left: 555px !important;
}
#password-toggle-button {
    left: 1080px !important;
    top: 25px;
}
#info-button {
    left: 1027px !important;
    max-width: 30px !important;
    max-height: 30px !important;
}
#versions-button {
    left: 969px !important;
    max-width: 30px !important;
    max-height: 30px !important;
}
#config-button img {
    max-width: 52px !important;
    max-height: 52px !important;
    width: 52px;
    height: 52px;
    object-fit: contain;
    display: block;
    filter: none !important;
}
#personal-button img, #radar-button img, #home-button img, #reload-button img, #keyword-assignment-button img {
    max-width: 46px !important;
    max-height: 46px !important;
    width: 46px;
    height: 46px;
    object-fit: contain;
    display: block;
    filter: none !important;
}
#versions-button img, #info-button img, #password-toggle-button img {
    max-width: 53px !important;
    max-height: 37px !important;
    width: 40px;
    height: 37px;
    object-fit: contain;
    display: block;
}
#password-toggle-button img {
    filter: brightness(85%) !important;
    top: 25px;
}
#versions-button img {
    transition: opacity 0.5s ease;
}
#config-button:hover, #personal-button:hover, #radar-button:hover, #home-button:hover, #reload-button:hover, #keyword-assignment-button:hover:not(.active), #password-toggle-button:hover, #versions-button:hover:not(.versions-icon-dimmed), #info-button:hover {
    transform: scale(1.1);
    background-color: rgba(255, 255, 255, 0.2);
}
#personal-button.editing {
    border: 3px solid yellow !important;
    box-shadow: 0 0 10px yellow !important;
}
#personal-button.assigning {
    border: 3px solid cyan !important;
    box-shadow: 0 0 10px cyan !important;
}
#keyword-assignment-button.active {
    border: 3px solid yellow !important;
    box-shadow: 0 0 10px yellow !important;
    transform: scale(1.05);
    background-color: transparent !important;
}
body.dark-mode #keyword-assignment-button.active {
    border-color: yellow !important;
    box-shadow: 0 0 10px yellow !important;
}
.keyword-assignment-active .grid-cell:hover:not(.editing-active *):not(.assignment-active *):not(.dragging *):not(.editing-target *):not(.keyword-assigned-highlight) {
    transform: scale(1.05) translateY(-1px);
    box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.6), -6px -6-12px rgba(255, 255, 255, 0.15);
    outline: 3px dashed #10B981;
    cursor: crosshair;
}
.keyword-assignment-active .grid-cell.editing-target {
    outline: 3px solid #10B981 !important;
    outline-offset: 1px;
    box-shadow: 0 0 8px #10B981;
}
.keyword-assignment-active .grid-cell.keyword-assigned-highlight {
    outline: 3px solid yellow !important;
    outline-offset: 1px;
    box-shadow: 0 0 8px yellow;
    cursor: crosshair;
}
#grid-filter-container {
    position: absolute;
    top: 43px;
    left: 615px;
    display: flex;
    align-items: center;
    z-index: 900;
}
#grid-filter-input {
    padding: 8px 12px;
    border: 1px solid #7c7c68;
    border-radius: 4px;
    font-size: 1.3rem;
    font-weight: bold;
    height: 45px;
    width: 160px;
    background-color: #f0f0e0;
}
body.dark-mode #grid-filter-input {
    background-color: #a0a090;
    color: #e0e0e0;
    border-color: #666;
}
#clear-filter-button {
    background: none;
    border: none;
    cursor: pointer;
    padding: 0 8px;
    margin-left: -35px;
    font-size: 1.6rem;
    color: #555;
    height: 40px;
    line-height: 40px;
    z-index: 901;
    display: none;
}
body.dark-mode #clear-filter-button {
    color: #bbb;
}
#user-id-display {
    position: absolute;
    top: -25px;
    right: -69px;
    font-weight: bold;
    font-size: 1.1rem;
    color: #5C5C47;
    padding: 4px 4px;
    background-color: rgba(171, 171, 153, 0.7);
    border-radius: 1px;
    z-index: 800;
    white-space: nowrap;
    text-align: right;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4);
}
body.dark-mode #user-id-display {
    color: #E6E6DC;
    background-color: rgba(146, 146, 126, 0.7);
    opacity: 0.7;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6);
}
.notices-icon-container {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    max-width: 984px;
    margin: 0 auto;
    margin-left: 165px;
    position: relative;
    transition: margin-top 0.5s ease-in-out;
}
.notices-container {
    flex-grow: 1;
    padding: 0.5rem;
    border: none;
    border-radius: 0.5rem;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0;
    margin-left: 2px;
    height: 3rem;
}
.notice-wrapper {
    padding: 0.5rem;
    height: 1.5rem;
    flex-grow: 1;
    overflow: hidden;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
}
.notice {
    color: #E6E6DC;
    font-size: 1.3rem;
    font-weight: bold;
    white-space: nowrap;
    text-align: center;
    opacity: 0;
    animation: fadeInOut 14s infinite;
}
@keyframes fadeInOut {
    0% {
        opacity: 1;
    }
    10% {
        opacity: 1;
    }
    90% {
        opacity: 1;
    }
    100% {
        opacity: 0;
    }
}
.notice-off-icon {
    width: auto;
    height: clamp(2rem, 5vw, 3rem);
    margin-right: 10px;
    align-self: center;
    cursor: pointer;
    transition: filter 0.3s ease;
}
body.dark-mode .notice-off-icon {
    filter: brightness(85%);
}
#reminder-button {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: fixed;
    background-color: #ABAB99;
}
#reminder-button img {
    object-fit: contain;
}
#reminder-button .reminder-count {
    position: absolute;
    top: 6px;
    left: 8px;
    background-color: #EF4444;
    color: #FFFFFF;
    border-radius: 55%;
    padding: 4px 10px;
    font-size: 1.1rem;
    font-weight: bold;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1500;
    min-width: 1.9rem;
    max-width: 2.5rem;
    text-align: center;
}
.reminder-count-globe {
    position: fixed;
    top: 10px;
    left: 10px;
    background-color: #2563EB;
    color: white;
    border-radius: 65%;
    padding: 10px 15px;
    font-size: 1.3rem;
    font-weight: bold;
    z-index: 1500;
    transition: margin-top 0.5s ease-in-out;
}
#unified-reminder-window {
    position: fixed;
    top: 35px;
    left: 180px;
    transform: none;
    background-color: #FFFF99;
    border-radius: 1.5rem;
    border: 2px solid #ABAB99;
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
    z-index: 7000;
    max-width: 550px;
    width: 95%;
    max-height: 85vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    transition: opacity 0.3s ease-out, transform 0.3s ease-out;
}
#unified-reminder-window:not(.visible) {
    opacity: 0;
    transform: scale(0.9);
    pointer-events: none;
}
#unified-reminder-window.visible {
    opacity: 1;
    transform: scale(1);
    pointer-events: auto;
}
.reminder-count-header {
    padding: 0.8rem 1.5rem;
    text-align: center;
    font-weight: bold;
    color: #0000FF;
    border-bottom: 1px solid #ABAB99;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 0px 10px;
    position: relative;
}
.reminder-title-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    flex-grow: 1;
}
.reminder-title-container > span:first-child {
    font-size: 1.3rem;
}
.reminder-title-container .swipe-hint {
    font-size: smaller;
}
#reminder-swiper-container {
    display: flex;
    overflow-x: auto;
    scroll-snap-type: x mandatory;
    -webkit-overflow-scrolling: touch;
    scroll-behavior: smooth;
    flex-grow: 1;
    touch-action: pan-x;
}
.reminder-slide {
    flex: 0 0 100%;
    scroll-snap-align: start;
    padding: 1.5rem;
    box-sizing: border-box;
    display: flex;
    flex-direction: row;
    gap: 1rem;
    overflow-y: auto;
    align-items: flex-start;
    max-height: calc(85vh - 60px);
}
.reminder-slide-content {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    min-width: 0;
}
.reminder-slide .reminder-content-scrollable {
    max-height: 30vh;
    overflow-y: auto;
    margin-bottom: 1rem;
    word-wrap: break-word;
    overflow-wrap: break-word;
    text-align: left;
    padding-right: 5px;
    flex-grow: 1;
}
.reminder-slide .reminder-text {
    margin: 0 0 0.5rem 0;
    font-size: 1.6rem;
    font-weight: bold;
    color: #0000FF;
}
.reminder-slide .reminder-details {
    margin: 0.2rem 0;
    font-size: 1.15rem;
    font-weight: bold;
    color: #0000FF;
}
.reminder-slide .button-group {
    display: flex;
    flex-direction: column;
    justify-content: center;
    gap: 0.5rem;
    margin-top: auto;
    padding-top: 1rem;
    flex-shrink: 0;
}
.reminder-slide button {
    padding: 0.5rem 1rem;
    border-radius: 0.25rem;
    cursor: pointer;
    font-size: 0.9rem;
    width: 100%;
    background-color: #D1D5DB;
}
.reminder-slide button.cancel {
    background-color: #EF4444;
    color: #FFFFFF;
    font-weight: bold;
    height: 70px;
    font-size: 1.2rem;
    order: 1;
}
.reminder-slide button.modify {
    background-color: #10B981;
    font-weight: bold;
    height: 60px;
    font-size: 1.2rem;
    color: #FFFFFF;
    order: 5;
}
.reminder-slide button.postpone {
    background-color: #F59E0B;
    font-weight: bold;
    height: 60px;
    font-size: 1.2rem;
    color: #FFFFFF;
    order: 3;
}
.reminder-slide button.adjust-time-0001 {
    background-color: #4F4F4F;
    color: #FFFFFF;
    font-weight: bold;
    height: 60px;
    font-size: 1.2rem;
    order: 2;
    margin-top: 0.5rem;
}
.reminder-slide button.cancel-cyclic {
    background-color: #8B0000;
    color: #FFFFFF;
    font-weight: bold;
    height: 60px;
    font-size: 1.2rem;
    order: 4;
    margin-top: 0.5rem;
}
.reminder-map-preview-container {
    flex-shrink: 0;
    width: 150px;
    display: flex;
    align-items: center;
    justify-content: center;
    align-self: stretch;
}
.reminder-map-preview {
    width: 100%;
    height: 100%;
    min-height: 100px;
    max-height: 25vh;
    border-radius: 0.5rem;
}
#hide-all-reminders-button {
    background: none;
    border: none;
    color: #0000FF;
    font-size: 1rem;
    font-weight: bold;
    cursor: pointer;
    padding: 0.2rem 0.5rem;
    position: absolute;
    right: 1rem;
    top: 50%;
    transform: translateY(-50%);
    z-index: 3001;
}
#hide-all-reminders-button:hover {
    text-decoration: underline;
}
.modal-top-buttons {
    display: flex;
    justify-content: space-between;
    gap: 1rem;
    margin-bottom: 1.5rem;
    flex-wrap: wrap;
}
.modal-top-buttons button {
    flex: 1 1 auto;
    min-width: 100px;
    background-color: #D1D5DB;
}
.reminder-modal, .help-modal, .edit-info-modal, .choice-modal, .edit-modal, .reminder-table-modal, .postpone-options, .saved-locations-modal, #reorder-stages-modal, #simulation-modal, #locations-preview-modal, #deviation-modal, #arrival-stats-modal, #simulation-speed-modal {
    z-index: 2000;
    background-color: #DAC8A0;
    padding: 1.0rem;
    border-radius: 0.3rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
}
#arrival-stats-modal {
    top: 5px;
    transform: translateX(-50%);
    z-index: 12000;
}
#arrival-stats-modal .eta-deviation {
    font-size: 2.1em;
    font-weight: bold;
    margin-left: 8px;
    vertical-align: middle;
}
#arrival-stats-modal .eta-deviation.positive {
    color: #EF4444;
}
#arrival-stats-modal .eta-deviation.negative {
    color: #013220;
}
#deviation-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #E6D6A8;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 0 15px rgba(0,0,0,0.5);
    z-index: 9000;
    text-align: center;
    max-width: 450px;
    width: 90%;
}
#deviation-modal p#deviation-modal-message {
    margin-bottom: 15px;
    font-size: 1.1rem;
    color: #333;
}
#deviation-modal button {
    padding: 10px 15px;
    margin: 0 5px;
    border-radius: 5px;
    font-size: 1rem;
    font-weight: bold;
    cursor: pointer;
    border: none;
}
#deviation-modal button#deviation-accept {
    background-color: #28a745;
    color: white;
}
#deviation-modal button#deviation-delete-stage {
    background-color: #EF4444;
    color: white;
}
#address-suggestions-modal {
    position: fixed;
    left: 5%;
    width: 90%;
    transform: none;
    background-color: #E6D6A8;
    padding: 1rem;
    border-radius: 0.5rem;
    box-shadow: 0 4px 10px rgba(0,0,0,0.25);
    z-index: 9000;
    display: flex;
    flex-direction: column;
    border: 1px solid #C0B080;
}
#address-suggestions-modal h2 {
    font-size: 1.1rem;
    font-weight: bold;
    text-align: center;
    margin-bottom: 0.75rem;
    color: #333;
}
#address-suggestions-list {
    list-style: none;
    padding: 0;
    margin: 0 0 0.75rem 0;
    overflow-y: auto;
    border: 1px solid #B0A898;
    border-radius: 4px;
    background-color: #D8CEC0;
}
#address-suggestions-list li {
    padding: 8px 12px;
    border-bottom: 1px solid #C8B890;
    cursor: pointer;
    font-size: 1.1rem;
    font-weight: bold;
    color: #F5F5DC;
    background-color: #5C5C47;
}
#address-suggestions-list li:last-child {
    border-bottom: none;
}
#address-suggestions-list li:hover {
    background-color: #6B6B56;
}
#locations-preview-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90vw;
    height: 90vh;
    max-width: none;
    max-height: none;
    display: flex;
    flex-direction: column;
    z-index: 7000;
}
#locations-preview-map-container {
    flex-grow: 1;
    border: 1px solid #ccc;
    border-radius: 0.5rem;
    margin-bottom: 1rem;
}
#locations-preview-modal h2 {
    font-size: 1.3rem;
    font-weight: bold;
    text-align: center;
    margin-bottom: 1rem;
    color: #333;
}
#close-locations-preview {
    padding: 0.7rem 1rem;
    font-size: 1.1rem;
    background-color: #4A5568;
    color: white;
    border: 1px solid #2D3748;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
}
#close-locations-preview:hover {
    background-color: #2D3748;
}
#address-suggestions-modal .modal-top-buttons button#close-address-suggestions-modal {
    background-color: #4A5568 !important;
    color: white !important;
    border: 1px solid #2D3748 !important;
    font-weight: bold !important;
}
#address-suggestions-modal .modal-top-buttons button#close-address-suggestions-modal:hover {
    background-color: #2D3748 !important;
}
#reorder-stages-modal {
    position: fixed !important;
    top: 30px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    width: 80vw !important;
    height: 90vh !important;
    max-width: none !important;
    max-height: none !important;
    z-index: 8600 !important;
    display: flex;
    flex-direction: column;
    background-color: #DAC8A0;
}
#saved-routes-modal, #save-route-prompt-modal {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    width: 90%;
    z-index: 8600;
    max-height: calc(100vh - 20px);
    overflow-y: auto;
}
#simulation-modal {
    position: fixed;
    top: 10px;
    right: 40px;
    left: auto;
    transform: none;
    background-color: #E6D6A8;
    padding: 1.5rem;
    border-radius: 1rem;
    box-shadow: 0 6px 15px rgba(0,0,0,0.3);
    z-index: 8800;
    max-width: 450px;
    width: calc(100% - 80px);
    max-height: calc(100vh - 20px);
    display: flex;
    flex-direction: column;
}
#simulation-speed-modal {
    position: fixed;
    top: 50px;
    left: 50%;
    transform: translateX(-50%);
    width: 90%;
    max-width: 400px;
    z-index: 9100;
    background-color: #F5E1A9;
    padding: 1.5rem;
    border-radius: 1rem;
    box-shadow: 0 6px 15px rgba(0,0,0,0.3);
    text-align: center;
}
#simulation-speed-modal h2 {
    font-size: 1.2rem;
    font-weight: bold;
    margin-bottom: 1rem;
    color: #333;
}
#simulation-speed-modal input {
    width: 100px;
    padding: 0.5rem;
    margin-bottom: 1rem;
    font-size: 1.2rem;
    text-align: center;
    border: 1px solid #ccc;
    border-radius: 4px;
}
#reorder-stages-modal button {
    background-color: #D1D5DB;
}
#reorder-stages-modal #confirm-reorder-stages {
    background-color: #28a745;
    color: white;
}
#reorder-stages-modal #cancel-reorder-stages {
    background-color: #6c757d;
    color: white;
}
#saved-routes-modal {
    max-width: 500px;
    z-index: 8000;
}
#save-route-prompt-modal {
    max-width: 800px;
    z-index: 8500;
}
#simulation-modal #close-simulation-modal {
    background-color: #2563EB;
    color: white;
    position: absolute;
    top: 10px;
    left: 10px;
    height: 35px;
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
    min-height: unset;
    min-width: unset;
    width: auto;
    line-height: 1;
}
.postpone-options {
    background-color: #F5E1A9 !important;
    z-index: 7500 !important;
    top: 10px !important;
    transform: translateX(-50%) !important;
}
.versions-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    display: flex;
    justify-content: center;
    align-items: flex-start;
    z-index: 5000;
    padding-top: 50px;
}
.versions-modal-content {
    background-color: #DAC8A0;
    padding: 1.5rem;
    border-radius: 0.5rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
    width: 85%;
    max-width: 900px;
    max-height: 85vh;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
}
.versions-modal-content h2 {
    font-size: 1.5rem;
    font-weight: bold;
    margin-bottom: 1rem;
    color: #111827;
    text-align: center;
}
.versions-modal-content .modal-top-buttons {
    margin-bottom: 1rem;
}
.versions-modal-content pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow-wrap: break-word;
    font-size: 1rem;
    line-height: 1.4;
    color: #333;
    margin-bottom: 1.5rem;
    padding: 0.8rem;
    background-color: #f0f0e0;
    border-radius: 0.25rem;
    max-height: calc(85vh - 150px);
    overflow-y: auto;
}
.versions-modal-content button {
    display: block;
    width: 100%;
    padding: 0.75rem 1rem;
    border-radius: 0.25rem;
    cursor: pointer;
    font-size: 1.1rem;
    text-align: center;
    border: none;
    background-color: #2563EB;
    color: white;
}
.versions-modal-content button:hover {
    background-color: #1D4ED8;
}
.reminder-modal {
    position: fixed;
    top: 1%;
    left: 50%;
    transform: translate(-50%, 0);
    max-width: 96%;
    width: 95%;
    max-height: 95vh;
    overflow-y: auto;
    font-weight: bold;
    font-size: 1.3rem;
}
.reminder-table-modal button.visto-prox {
    background-color: #EF4444;
    font-size: 0.9rem;
    color: #FFFFFF;
    border: 1px solid #A00000;
    font-weight: bold;
}
.reminder-table-modal button.visto-prox:hover {
    background-color: #D00000;
}
.help-modal, .edit-info-modal {
    position: fixed;
    top: 1%;
    left: 50%;
    transform: translate(-50%, 1%);
    max-width: 910px;
    width: 98%;
    max-height: 96vh;
    overflow-y: auto;
    font-size: 1.10rem;
    z-index: 5500;
}
#reminders-map-help-modal-instance {
    z-index: 7000 !important;
    top: 10px !important;
    transform: translateX(-50%) !important;
}
.choice-modal {
    position: fixed;
    top: 1%;
    left: 50%;
    transform: translate(-50%, 1%);
    max-width: 540px;
    width: 95%;
    max-height: 98vh;
    overflow-y: auto;
    font-size: 1.10rem;
    z-index: 5500;
}
.reminder-table-modal {
    position: fixed;
    top: 30px;
    left: 35px;
    transform: translateY(0);
    max-width: 99%;
    width: 1090px;
    max-height: 90vh;
    overflow-y: auto;
    background-color: #E6D6A8;
    border-radius: 1.5rem;
}
.reminder-table-modal h2 {
    font-size: 1.8rem !important;
    font-weight: bold !important;
}
.reminder-table-modal #view-all-locations-map {
    white-space: nowrap !important;
}
.edit-modal {
    position: fixed;
    top: 5%;
    left: 50%;
    transform: translate(-50%, 0);
    width: 75%;
    max-width: 900px;
    border: 5px solid #A0522D;
    background-color: #EADDCA;
    z-index: 6000;
}
.modal h2, .modal h3 {
    font-weight: bold;
    margin-bottom: 1rem;
    color: #111827;
}
.reminder-modal h2, .help-modal h2, .edit-info-modal h2, .choice-modal h2, .edit-modal h2, .saved-locations-modal h2, #reorder-stages-modal h2, #simulation-modal h2, #deviation-modal h2, #arrival-stats-modal h2, #simulation-speed-modal h2 {
    font-size: 1.5rem;
}
.reminder-modal label, .help-modal label, .edit-info-modal label, .choice-modal label, .edit-modal label, .saved-locations-modal label {
    display: block;
    margin-bottom: 0.25rem;
    font-weight: 500;
    color: #374151;
    font-size: 1.1rem;
}
.reminder-modal button, .help-modal button, .edit-info-modal button, .choice-modal button, .edit-modal button, .reminder-table-modal button, .versions-modal-content button, .saved-locations-modal button, #reorder-stages-modal button, #simulation-modal button, #address-suggestions-modal button, #deviation-modal button, #arrival-stats-modal button, #simulation-speed-modal button {
    padding: 0.75rem 1rem;
    border-radius: 0.25rem;
    cursor: pointer;
    font-size: 1.1rem;
    flex: 1;
    text-align: center;
    min-width: 100px;
    border: none;
    background-color: #D1D5DB;
    min-height: 60px;
}
.reminder-modal .modal-top-buttons button {
    height: 70px;
    min-height: 70px;
}
.edit-info-modal #close-edit-info, .help-modal #close-help, #reminders-map-help-modal-instance #close-reminders-map-help-instance, #simulation-modal #close-simulation-modal {
    background-color: #2563EB;
    color: white;
}
.edit-info-modal #close-edit-info:hover, .help-modal #close-help:hover, #reminders-map-help-modal-instance #close-reminders-map-help-instance:hover, #simulation-modal #close-simulation-modal:hover {
    background-color: #1D4ED8;
}
.reminder-modal textarea#reminder-text {
    width: 100%;
    padding: 0.5rem;
    margin-bottom: 0.3rem;
    border: 1px solid #D1D5DB;
    border-radius: 0.25rem;
    font-size: 1.4rem;
    font-weight: bold;
    text-transform: uppercase;
}
.reminder-modal input#reminder-time {
    max-width: 120px;
    width: auto;
}
.reminder-modal input#reminder-date {
    max-width: 160px;
    width: auto;
}
.reminder-modal input#reminder-interval {
    max-width: 100px;
    width: auto;
}
.reminder-modal input#reminder-radius {
    max-width: 120px;
    width: auto;
}
.reminder-modal input[type="text"], .reminder-modal input[type="number"] {
    padding: 0.5rem;
    margin-bottom: 0.3rem;
    border: 1px solid #D1D5DB;
    border-radius: 0.25rem;
    font-size: 1.5rem;
    text-align: center;
}
.reminder-modal .form-grid {
    display: grid;
    grid-template-columns: auto auto auto 1fr;
    gap: 1rem;
    align-items: end;
    margin-bottom: 1rem;
}
label[for="reminder-interval"] {
    line-height: 1.2;
}
.location-controls-group {
    grid-column: 4 / 5;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: flex-start;
    gap: 0.5rem;
    margin-top: 0;
}
.location-controls-group label {
    margin-bottom: 0;
}
.location-controls-group input[type="checkbox"] {
    margin-right: 0.2rem;
}
.location-controls-group label[for="reminder-radius"] {
    margin-left: 0;
}
#expand-map-button {
    padding: 0.3rem 0.6rem !important;
    font-size: 1.3rem !important;
    height: auto !important;
    flex-shrink: 0;
    background-color: #668B8B !important;
    color: white !important;
    border: none !important;
    border-radius: 0.25rem !important;
    min-width: unset !important;
    flex: unset !important;
    margin-left: 0.5rem;
}
#expand-map-button:hover {
    background-color: #5C5C47 !important;
}
#location-map-container {
    grid-column: 1 / -1;
    width: 100%;
    border: 1px solid #ccc;
    border-radius: 0.25rem;
    background-color: #eee;
    position: relative;
    margin-top: 0.5rem;
    display: none;
    transition: height 0.3s ease-in-out;
}
#location-map-container.preview {
    display: block !important;
    height: 65px;
}
#location-map-container.expanded {
    display: block !important;
    height: 360px;
}
#reduce-map-button, #locate-me-button {
    position: absolute;
    top: 5px;
    z-index: 1001;
    padding: 0.8rem 1rem;
    font-size: 1rem;
    font-weight: bold;
    background-color: rgba(255, 255, 255, 0.9);
    border: 1px solid #777;
    border-radius: 4px;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0,0,0,0.25);
    transition: background-color 0.2s ease;
}
#reduce-map-button:hover, #locate-me-button:hover {
    background-color: rgba(230, 230, 230, 0.95);
}
#reduce-map-button {
    right: 5px;
}
#locate-me-button {
    right: calc(5px + 135px + 15px);
}
.reminder-modal .full-width {
    grid-column: 1 / -1;
}
.reminder-modal .days-group {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
    grid-column: 1 / -1;
    margin-top: 1rem;
}
.reminder-modal .days-group label {
    font-size: 1.1rem;
    flex: 0 0 auto;
}
.reminder-modal button[type="submit"] {
    background-color: #2563EB;
    color: #FFFFFF;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.6rem;
}
.reminder-modal button[type="submit"] span#countdown-save {
    font-size: 1.6rem;
    font-weight: bold;
    justify-content: right;
    color: #e6e6dc;
}
.reminder-modal button[type="button"] {
    background-color: #D1D5DB;
    color: #111827;
}
#saved-routes-modal #close-saved-routes-modal, #config-modal #config-close-modal, #save-route-prompt-modal #cancel-save-route, #simulation-speed-modal #cancel-simulation-speed, .postpone-options #cancel-postpone {
    background-color: blue !important;
    color: white !important;
    border: 1px solid #2D3748 !important;
    font-weight: bold !important;
}
#saved-routes-modal #close-saved-routes-modal:hover, #config-modal #config-close-modal:hover, #save-route-prompt-modal #cancel-save-route:hover, #simulation-speed-modal #cancel-simulation-speed:hover, .postpone-options #cancel-postpone:hover {
    background-color: #2D3748 !important;
}
#simulation-speed-modal #confirm-simulation-speed {
    background-color: #28a745 !important;
    color: white !important;
}
.speech-button {
    background-color: #668B8B;
    color: white;
    border: none;
    border-radius: 0.25rem;
    padding: 0.5rem;
    cursor: pointer;
    margin-left: 0.5rem;
    font-size: 1rem;
    vertical-align: top;
}
.speech-button:hover {
    background-color: #5C5C47;
}
.speech-status {
    font-size: 0.85rem;
    color: #ABAB99;
    margin-top: 0.1rem;
    min-height: 1em;
}
#auto-save-timer {
    color: #1E40AF;
    grid-column: 1 / -1;
    text-align: center;
}
.reminder-table-modal table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 1rem;
}
.reminder-table-modal tbody tr {
    cursor: pointer;
    transition: background-color: 0.1s ease;
}
.reminder-table-modal tbody tr:hover {
    background-color: rgba(0, 0, 0, 0.05) !important;
}
.reminder-table-modal th, .reminder-table-modal td {
    padding: 0.5rem;
    border: 1px solid #1E3A8A;
    font-size: 1.1rem;
    text-align: center;
    vertical-align: middle;
}
.reminder-table-modal td.text-column {
    text-align: left;
}
.reminder-table-modal th {
    background-color: #E5E7EB;
    font-weight: bold;
}
.reminder-table-modal td.date-column {
    white-space: nowrap;
}
.reminder-table-modal td:first-child {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.3rem;
    border: none;
}
.reminder-table-modal td:first-child button {
    padding: 0.6rem;
    font-size: 0.9rem;
    width: 90%;
    flex: 0 0 auto;
    margin: 0;
    height: 60px;
    min-height: unset;
    line-height: 1.2;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #D1D5DB;
    border: 1px solid #4A5568;
}
.reminder-table-modal button.modify {
    background-color: #10B981;
    font-size: 1rem;
    color: #FFFFFF;
    height: 60px;
    border: 1px solid #008000;
    font-weight: bold;
}
.reminder-table-modal button.modify:hover {
    background-color: #008000;
}
.reminder-table-modal button.delete {
    background-color: #EF4444;
    font-size: 0.9rem;
    color: #FFFFFF;
    border: 1px solid #A00000;
    font-weight: bold;
}
.reminder-table-modal button.delete:hover {
    background-color: #D00000;
}
.reminder-table-modal button.postpone {
    background-color: #F59E0B;
    font-size: 0.9rem;
    color: #FFFFFF;
    border: 1px solid #D97706;
    font-weight: bold;
}
.reminder-table-modal button.postpone:hover {
    background-color: #D97706;
}
.reminder-table-modal button.cancel-cyclic-table {
    background-color: #8B0000;
    font-size: 0.9rem;
    color: #FFFFFF;
    border: 1px solid #580000;
    font-weight: bold;
}
.reminder-table-modal button.cancel-cyclic-table:hover {
    background-color: #580000;
}
.reminder-table-modal #close-reminders-bottom, .reminder-table-modal #close-reminders-top {
    padding-left: 3rem;
    padding-right: 3rem;
    background-color: #2563EB;
    color: white;
    padding: 0.75rem 3rem;
    border-radius: 0.5rem;
    font-size: 1.25rem;
    font-weight: bold;
    border: 2px solid #1E3A8A;
    cursor: pointer;
    transition: background-color 0.2s ease;
    display: inline-flex;
    align-items: center;
}
.reminder-table-modal #close-reminders-bottom:hover, .reminder-table-modal #close-reminders-top:hover {
    background-color: #1D4ED8;
}
.reminder-table-modal .bottom-button-container {
    display: flex;
    justify-content: flex-end;
    margin-top: 1rem;
}
.choice-modal .personalization-options {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    align-items: stretch;
    margin-bottom: 1.5rem;
}
.choice-modal .personalization-options button {
    font-weight: bold;
    width: 100%;
    background-color: #D1D5DB;
}
.choice-modal button.choice-edit {
    background-color: #ffc107;
    color: #333;
}
.choice-modal button.choice-assign {
    background-color: #17a2b8;
    color: white;
}
.choice-modal button.choice-help {
    background-color: #007bff;
    color: white;
}
.choice-modal button.choice-cancel {
    background-color: #6c757d;
    color: white;
}
.choice-modal .footer-buttons {
    display: flex;
    justify-content: center;
    gap: 1rem;
    margin-top: 1rem;
}
.choice-modal .footer-buttons button {
    flex: 0 1 auto;
    min-width: 120px;
    background-color: #D1D5DB;
}
.edit-modal h2 {
    font-size: 1.4rem;
    margin-bottom: 1rem;
    color: #333;
    font-weight: bold;
    text-align: center;
}
.edit-modal .modal-top-buttons {
    margin-bottom: 1.2rem;
}
.edit-modal label {
    display: block;
    margin-bottom: 0.3rem;
    font-weight: 500;
    color: #444;
    font-size: 1rem;
}
.edit-modal input[type="text"], .edit-modal input[type="url"] {
    width: 100%;
    padding: 0.6rem;
    margin-bottom: 0.8rem;
    border: 1px solid #BDB7AB;
    border-radius: 0.25rem;
    font-size: 1rem;
}
.edit-modal .input-with-button {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.8rem;
}
.edit-modal .input-with-button input {
    flex-grow: 1;
    margin-bottom: 0;
}
.edit-modal .search-button {
    padding: 0.4rem 0.6rem;
    font-size: 0.8rem;
    background-color: #668B8B;
    color: white;
    border: none;
    border-radius: 0.25rem;
    cursor: pointer;
    line-height: 1;
    height: fit-content;
}
.edit-modal .search-button:hover {
    background-color: #5C5C47;
}
.edit-modal button {
    padding: 0.7rem 1rem;
    font-size: 1.3rem;
    border-radius: 0.25rem;
    cursor: pointer;
    border: none;
    flex: 1 1 auto;
    min-width: 90px;
    background-color: #D1D5DB;
}
.edit-modal button.save {
    background-color: #28a745;
    color: white;
}
.edit-modal button.save:hover {
    background-color: #218838;
}
.edit-modal button.cancel {
    background-color: #6c757d;
    color: white;
}
.edit-modal button.cancel:hover {
    background-color: #5a6268;
}
.edit-modal button.reset {
    background-color: #ffc107;
    color: #333;
}
.edit-modal button.reset:hover {
    background-color: #e0a800;
}
.edit-modal button.empty {
    background-color: #fd7e14;
    color: white;
}
.edit-modal button.empty:hover {
    background-color: #e66b04;
}
.editing-active .bookmark-item:hover, .editing-active .range-toggle:hover, .editing-active .empty-slot:hover {
    transform: none;
    box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1);
    outline: 3px solid yellow;
    cursor: crosshair;
}
.editing-active .grid-cell.editing-target, .editing-active .range-toggle.editing-target {
    outline: 3px solid yellow !important;
    outline-offset: 1px;
    box-shadow: 0 0 8px yellow;
}
.editing-active .grid-cell {
    cursor: grab;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}
.editing-active .grid-cell:active {
    cursor: grabbing;
}
.grid-cell.dragging {
    opacity: 0.4;
    border: 2px dashed #aaa;
    cursor: grabbing;
    transform: scale(0.95);
    z-index: 10;
}
.grid-cell.drag-over {
    border: 3px solid #3498db !important;
    background-color: rgba(52, 152, 219, 0.1);
    box-shadow: inset 0 0 10px rgba(52, 152, 219, 0.3);
}
.empty-slot.drag-over {
    border: 3px solid #3498db !important;
    background-color: rgba(52, 152, 219, 0.2);
}
.empty-slot.dragging {
    opacity: 0.4;
    border: 2px dashed #aaa !important;
    cursor: grabbing;
}
.assignment-active .range-toggle.assigning-selected {
    outline: 4px solid cyan;
    box-shadow: 0 0 12px cyan;
    transform: scale(1.03);
}
.assignment-active .range-toggle:not(.assigning-selected) {
    opacity: 0.7;
    cursor: pointer;
}
.assignment-active .grid-cell.assigned-to-current {
    outline: 3px solid cyan;
    box-shadow: inset 0 0 8px rgba(0, 255, 255, 0.6);
    background-color: hsla(180, 70%, 80%, 0.3);
    opacity: 1;
}
.assignment-active .grid-cell:not(.assigned-to-current) {
    opacity: 0.6;
    outline: 1px dashed #aaa;
}
.assignment-active .grid-cell {
    cursor: pointer;
}
body.dark-mode .assignment-active .grid-cell.assigned-to-current {
    box-shadow: inset 0 0 10px rgba(0, 200, 200, 0.7);
    background-color: hsla(180, 60%, 30%, 0.4);
}
body.dark-mode .assignment-active .grid-cell:not(.assigned-to-current) {
    opacity: 0.5;
    outline-color: #555;
}
#pin-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    display: flex;
    justify-content: center;
    align-items: flex-start;
    z-index: 9998;
}
#pin-modal-content {
    background-color: #DAC8A0;
    padding: 2rem;
    border-radius: 0.75rem;
    box-shadow: 0 5px 20px rgba(0,0,0,0.4);
    text-align: center;
    border: 1px solid #A0522D;
    margin-top: 50px;
}
#pin-modal-content h2 {
    font-size: 1.5rem;
    font-weight: bold;
    color: #333;
    margin-bottom: 1rem;
}
#pin-modal-content .modal-top-buttons {
    margin-bottom: 1.5rem;
}
#pin-modal-content label {
    display: block;
    font-size: 1.1rem;
    color: #444;
    margin-bottom: 0.8rem;
}
#pin-input {
    width: 150px;
    padding: 0.8rem;
    font-size: 1.8rem;
    text-align: center;
    border: 2px solid #A0522D;
    border-radius: 0.25rem;
    margin-bottom: 1.5rem;
    letter-spacing: 0.5em;
    background-color: #f0f0e0;
}
#pin-submit-button {
    padding: 0.8rem 2rem;
    font-size: 1.2rem;
    background-color: #28a745;
    color: white;
    border: none;
    border-radius: 0.25rem;
    cursor: pointer;
    transition: background-color 0.2s;
}
#pin-submit-button:hover {
    background-color: #218838;
}
#pin-error-message {
    color: #dc3545;
    font-weight: bold;
    margin-top: 1rem;
    min-height: 1.2em;
}
#config-modal {
    position: fixed;
    top: 15px;
    left: 50%;
    transform: translate(-50%, 0);
    background-color: #ECEFE8;
    padding: 1.5rem;
    border-radius: .75rem;
    box-shadow: 0 8px 16px rgba(0,0,0,.25);
    z-index: 5000;
    max-width: 1000px;
    width: 95%;
    max-height: calc(83vh + 190px);
    display: flex;
    flex-direction: column;
}
#config-modal .modal-top-buttons {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
}
#config-modal .modal-top-buttons h2 {
    margin-bottom: 0;
}
.config-tab-content {
    max-height: calc(83vh + 130px - 190px);
}
.config-tab-button {
    padding: .7rem 1.2rem;
    cursor: pointer;
    border: 1px solid #ccc;
    border-bottom: none;
    background-color: #e0e0d0;
    margin-right: .3rem;
    border-radius: .5rem .5rem 0 0;
    font-size: 1rem;
    font-weight: 500;
    color: #555;
    transition: background-color .2s ease,color .2s ease;
    outline: none;
}
.config-tab-button:hover {
    background-color: #d8d8c0;
}
.config-tab-button.active {
    background-color: #ECEFE8;
    border-color: #ccc;
    border-bottom: 1px solid #ECEFE8;
    font-weight: bold;
    color: #2F4F4F;
    position: relative;
    top: 1px;
    z-index: 2;
}
.tab-buttons {
    margin-bottom: -1px;
    flex-shrink: 0;
    border-bottom: 1px solid #ccc;
    padding-left: 1rem;
    display: flex;
    overflow-x: auto;
}
.tab-contents {
    flex-grow: 1;
    overflow-y: auto;
    position: relative;
    z-index: 1;
    border-top: none;
    min-height: 200px;
}
.config-tab-content {
    display: none;
    padding: 1.8rem;
    border: 1px solid #ccc;
    border-top: none;
    border-radius: 0 0 .5rem .5rem;
    background-color: #ECEFE8;
}
.config-tab-content.active {
    display: block;
}
#config-modal h2 {
    font-size: 1.6rem;
    margin-bottom: 0;
    color: #2F4F4F;
    text-align: center;
    flex-shrink: 0;
}
#config-modal h3 {
    font-size: 1.3rem;
    margin-bottom: .8rem;
    color: #4682B4;
}
#config-modal p, #config-modal label {
    font-size: 1rem;
    line-height: 1.5;
    color: #333;
}
#config-modal em {
    font-size: .85rem;
}
#config-modal button:not(.config-tab-button) {
    font-size: 1.05rem;
    padding: .8rem 1.5rem;
    background-color: #D1D5DB;
}
#config-modal textarea {
    font-size: .9rem;
    height: 110px;
    width: 100%;
    border: 1px solid #ccc;
    border-radius: .25rem;
    padding: .5rem;
    resize: vertical;
}
#config-modal input[type=text], #config-modal input[type=number], #config-modal input[type=password] {
    font-size: 1rem;
    padding: .6rem;
    width: 100%;
    border: 1px solid #ccc;
    border-radius: .25rem;
}
#config-modal .status-message {
    font-size: .9rem;
    min-height: 1.1em;
    font-weight: 500;
    text-align: center;
    margin-top: .5rem;
}
.user-data-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit,minmax(180px,1fr));
    gap: 1.2rem 1.8rem;
    align-items: start;
    margin-bottom: 1rem;
}
.user-data-grid label {
    margin-bottom: .3rem;
    display: block;
    font-weight: 500;
}
.user-data-grid .checkbox-container {
    grid-column: 1 / -1;
    display: flex;
    align-items: center;
    gap: .5rem;
    justify-content: center;
    margin-top: .5rem;
}
.user-data-grid .checkbox-container input {
    width: 1.2rem;
    height: 1.2rem;
}
.user-data-grid .checkbox-container label {
    margin-bottom: 0;
}
.user-buttons-container {
    display: flex;
    justify-content: space-around;
    gap: 1.5rem;
    margin-top: 1.5rem;
    margin-bottom: 1rem;
}
.user-buttons-container button {
    border: none;
    border-radius: .25rem;
    cursor: pointer;
    flex-grow: 1;
}
#config-user-status {
    min-height: 1.2em;
}
.backup-restore-container {
    display: flex;
    gap: 2.5rem;
    flex-wrap: wrap;
}
.backup-restore-container > div {
    flex: 1;
    min-width: 250px;
}
.backup-restore-container p {
    margin-bottom: 1.2rem;
}
.backup-restore-container textarea {
    margin-bottom: 1rem;
    background-color: #f9f9f9;
}
.backup-restore-container button {
    margin-bottom: 1rem;
    border: none;
    border-radius: .25rem;
    cursor: pointer;
    width: 100%;
}
#config-restore-grid-button {
    background-color: #E65100;
    color: black;
    margin-top: 10px;
}
#config-restore-grid-button:hover {
    background-color: #D84315;
}
.backup-restore-container .status-message {
    margin-top: .6rem;
}
.borrar-container h3 {
    margin-bottom: .8rem;
}
.borrar-container p {
    margin-top: .6rem;
}
.borrar-container button {
    margin-top: 1.5rem;
    border: none;
    border-radius: .25rem;
    cursor: pointer;
    width: 100%;
}
.borrar-container button#config-clear-cache {
    background-color: #EF4444;
    color: white;
}
#config-close-modal-container {
    text-align: center;
    margin-top: 1rem;
    flex-shrink: 0;
}
#config-close-modal {
    font-size: 1.15rem;
    padding: .8rem 2.5rem;
    background-color: #4A5568;
    color: white;
    border: 1px solid #2D3748;
    font-weight: bold;
}
#config-close-modal:hover {
    background-color: #2D3748;
}
.pin-config-section {
    border-top: 1px solid #ccc;
    margin-top: 2rem;
    padding-top: 1.5rem;
}
.pin-config-layout {
    display: grid;
    grid-template-columns: minmax(200px, 1fr) minmax(200px, 1fr);
    gap: 1rem 1.5rem;
    align-items: end;
}
.pin-config-layout .pin-input-group {
    grid-column: span 1;
    display: flex;
    flex-direction: column;
}
.pin-config-layout .pin-input-group label {
    margin-bottom: 0.3rem;
}
.pin-config-layout .pin-buttons-container {
    grid-column: 1 / 3;
    grid-row: 2;
    display: flex;
    justify-content: flex-start;
    gap: 1rem;
    margin-top: 0.5rem;
}
.pin-config-layout .pin-buttons-container button {
    flex-grow: 0;
    min-width: 120px;
    max-width: 180px;
}
#tab-content-pin .checkbox-container {
    grid-column: 1 / -1;
    display: flex;
    align-items: center;
    gap: .5rem;
    justify-content: flex-start;
    margin-top: 1.5rem;
    border-top: 1px solid #ccc;
    padding-top: 1rem;
}
#tab-content-pin .checkbox-container input {
    width: 1.2rem;
    height: 1.2rem;
}
#tab-content-pin .checkbox-container label {
    margin-bottom: 0;
}
.toast-notification {
    position: fixed;
    top: 180px;
    right: 15px;
    transform: none;
    padding: 15px 30px;
    border-radius: 8px;
    color: white;
    font-size: 1rem;
    font-weight: bold;
    z-index: 9999;
    opacity: 0;
    transition: opacity 0.4s ease-in-out, top 0.4s ease-in-out;
    box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    text-align: center;
    min-width: 250px;
    max-width: 70%;
}
.toast-notification.show {
    opacity: 1;
}
.toast-success {
    background-color: #28a745;
}
.toast-error {
    background-color: #dc3545;
}
.toast-warning {
    background-color: #ffc107;
    color: #333;
}
.toast-info {
    background-color: #17a2b8;
}
.toast-debug {
    background-color: #663399;
    color: white;
    font-size: 0.9rem;
    text-align: left;
    max-width: 90%;
    white-space: pre-wrap;
    max-height: 80vh;
    overflow-y: auto;
    line-height: 1.3;
}
.toast-debug button {
    display: block;
    margin-top: 10px;
    padding: 5px 10px;
    background-color: rgba(255,255,255,0.2);
    color: white;
    border: 1px solid white;
    border-radius: 3px;
    cursor: pointer;
}
.toast-error.not-found {
    background-color: #a02020;
    border: 2px solid #ffdddd;
    font-size: 1.3rem;
    box-shadow: 0 8px 16px rgba(0,0,0,0.4);
}
.leaflet-container {
    cursor: default !important;
}
#location-map-container.expanded .leaflet-container, #location-picker-map-container.expanded .leaflet-container, #reminders-location-map-div #leaflet-map-actual-container .leaflet-container {
    cursor: crosshair !important;
}
#reminders-location-map-div.simulating-gps-click-mode #leaflet-map-actual-container .leaflet-container {
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="%23FF0000" stroke="white" stroke-width="1"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>') 14 28, crosshair !important;
}
#reminders-location-map-div.navigating #leaflet-map-actual-container .leaflet-container {
    cursor: default !important;
}
#reminders-location-map-div.add-reminder-mode #leaflet-map-actual-container .leaflet-container {
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="%23008000" stroke="white" stroke-width="1"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle><line x1="12" y1="7" x2="12" y2="13"></line><line x1="9" y1="10" x2="15" y2="10"></line></svg>') 14 28, crosshair !important;
}
#location-map-container.expanded .leaflet-touch .leaflet-container, #location-picker-map-container.expanded .leaflet-touch .leaflet-container, #reminders-location-map-div #leaflet-map-actual-container .leaflet-touch .leaflet-container {
    cursor: pointer !important;
}
#reminders-location-map-div.navigating #leaflet-map-actual-container .leaflet-touch .leaflet-container {
    cursor: default !important;
}
#reminders-location-map-div.add-reminder-mode #leaflet-map-actual-container .leaflet-touch .leaflet-container {
    cursor: pointer !important;
}
.leaflet-top.leaflet-right .leaflet-control-layers {
    margin-top: 10px;
    margin-right: 10px;
}
.leaflet-control-layers {
    border-radius: 4px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.65);
    background-color: rgba(0,0,0,0.6) !important;
    color: white !important;
}
.leaflet-control-layers-expanded {
    max-height: 200px;
    overflow-y: auto;
    background-color: rgba(0,0,0,0.509) !important;
}
.leaflet-control-layers-selector {
    color: white !important;
}
.leaflet-control-layers-selector:hover {
    background-color: rgba(255,255,255,0.2) !important;
}
#average-speed-display {
    color: #CBDDB5 !important;
}
#max-speed-display {
    color: #FFA420 !important;
}
#compass-rose-icon {
    width: 57px;
    height: 59px;
    display: block;
    margin: 0 auto 2px auto;
    transition: transform 0.3s ease-out;
}
#orientation-text {
    display: block;
    font-size: 1.4em;
    font-weight: bold;
    line-height: 1.2;
    margin-bottom: 2px;
}
#altitude-display {
    display: block;
    font-size: 1.2em;
    line-height: 1.1;
}
#current-speed-display, #average-speed-display, #max-speed-display {
    display: block;
    font-size: 1.2em;
    line-height: 1.2;
    margin-top: 2px;
}
#navigation-graph-card.enlarged {
    position: fixed;
    background-color: rgba(0, 0, 0, 0.85);
    z-index: 2000;
    border: 1px solid #888;
}
#navigation-graph-card.enlarged #navigation-graph-container {
    flex-grow: 1;
}
#enlarge-graph-button {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 28px;
    height: 28px;
    cursor: pointer;
    z-index: 5;
    opacity: 0.7;
    transition: opacity 0.2s;
}
#enlarge-graph-button:hover {
    opacity: 1;
}
#navigation-graph-title {
    font-size: 1.1em;
    font-weight: bold;
    padding: 1px 5px;
    color: #cb9a01;
    flex-shrink: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}
#navigation-graph-container {
    width: 100%;
    flex-grow: 1;
    position: relative;
    min-height: 0;
}
#navigation-chart {
    display: block;
    width: 100%;
    height: 100%;
}
#reminders-location-map-div {
    position: relative;
    overflow: hidden;
}
#leaflet-map-actual-container {
    width: 100%;
    height: 100%;
    position: relative;
}
#location-map-container:not(.expanded) .leaflet-control-zoom, #location-picker-map-container:not(.expanded) .leaflet-control-zoom {
    display: none !important;
}
.saved-locations-modal {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #E6D6A8;
    padding: 1.5rem;
    border-radius: 1rem;
    box-shadow: 0 6px 15px rgba(0,0,0,0.3);
    z-index: 3500;
    max-width: 700px;
    width: 95%;
    max-height: calc(100vh - 20px);
    display: flex;
    flex-direction: column;
}
.saved-locations-modal h2 {
    font-size: 1.5rem;
    font-weight: bold;
    text-align: center;
    margin-bottom: 1rem;
    color: #333;
}
.saved-locations-modal .modal-top-buttons {
    margin-bottom: 1rem;
}
.saved-locations-modal #saved-locations-list {
    max-height: calc(90vh - 200px - 50px);
    overflow-y: auto;
    margin-bottom: 1rem;
    padding-right: 5px;
}
.saved-locations-modal .location-slot {
    display: flex;
    align-items: center;
    margin-bottom: 0.75rem;
    gap: 0.5rem;
}
.saved-locations-modal .location-slot input[type="text"] {
    flex-grow: 1;
    padding: 0.5rem;
    border: 1px solid #ccc;
    border-radius: 0.25rem;
    font-size: 1rem;
}
.saved-locations-modal .location-slot button.map-button {
    padding: 0.5rem 0.75rem;
    font-size: 0.9rem;
    background-color: #668B8B;
    color: white;
    border: none;
    border-radius: 0.25rem;
    cursor: pointer;
    flex-shrink: 0;
}
.saved-locations-modal .location-slot button.map-button:hover {
    background-color: #5C5C47;
}
.saved-locations-modal .location-slot .coords-display {
    font-size: 0.8rem;
    color: #555;
    min-width: 120px;
    text-align: right;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.saved-locations-modal #save-all-user-locations {
    background-color: #2563EB;
    color: white;
}
.saved-locations-modal #close-saved-locations-modal {
    background-color: #D1D5DB;
    color: #111827;
}
.saved-locations-modal .location-slot button.select-location-button {
    padding: 0.5rem 0.75rem;
    font-size: 0.9rem;
    background-color: #34D399;
    color: white;
    border: none;
    border-radius: 0.25rem;
    cursor: pointer;
    flex-shrink: 0;
    margin-left: 5px;
}
.saved-locations-modal .location-slot button.select-location-button:hover {
    background-color: #10B981;
}
#location-picker-map-container {
    height: 300px;
    border: 1px solid #ccc;
    position: relative;
    margin-top: 1rem;
    border-radius: 0.25rem;
    background-color: #eee;
    display: none;
}
#location-picker-map-container.expanded {
    display: block !important;
}
#location-picker-map-container button {
    padding: 0.5rem 0.8rem;
    font-size: 0.9rem;
    font-weight: bold;
    background-color: rgba(255, 255, 255, 0.9);
    border: 1px solid #777;
    border-radius: 4px;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0,0,0,0.25);
    position: absolute;
    z-index: 1001;
}
#picker-ok-map-button {
    top: 5px;
    right: 5px;
}
#picker-locate-me-button {
    top: 5px;
    right: calc(5px + 90px + 10px);
}
#reminders-location-map-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: #D8D8D0;
    z-index: 6500;
    display: flex;
    flex-direction: column;
    padding: 2px;
    box-sizing: border-box;
}
#reminders-location-map-content-wrapper {
    background-color: #F0EFE4;
    width: 100%;
    height: 100%;
    border-radius: 0.75rem;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}
#reminders-location-map-header {
    display: flex;
    flex-direction: column;
    padding: 2px 0rem;
    border-bottom: 0px solid #D8D8D0;
    flex-shrink: 0;
    background-color: #D8D8D0;
}
#search-row-map-header .reminders-map-button-action {
    height: 57px;
}
#search-row-map-header > #reorder-route-stages-button, #search-row-map-header > #map-location-search-button, #search-row-map-header > #clear-map-search-input-button, #search-row-map-header > #map-location-search-input, #search-row-map-header > #filter-input, #search-row-map-header > #navigation-map-help-button {
    height: 57px !important;
}
#reminders-location-map-header .button-row.hidden-map-header {
    opacity: 0;
    visibility: hidden;
    max-height: 0 !important;
    min-height: 0 !important;
    overflow: hidden !important;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    margin-bottom: 0 !important;
    border-bottom: none !important;
}
#reminders-location-map-header .button-row:first-child {
    margin-bottom: 10px;
}
#reminders-location-map-header h2 {
    display: none;
}
#reminders-location-map-header .reminders-map-button-action img, #reminders-location-map-header .reminders-map-button-action svg {
    width: 100%;
    height: 100%;
    object-fit: contain;
}
#reminders-location-map-header .reminders-map-button-action:hover {
    opacity: 0.88;
}
#toggle-map-header-buttons-panel {
    position: fixed;
    left: 15px;
    top: 50%;
    transform: translateY(-50%);
    width: calc(100px);
    height: calc(100px);
    background-color: rgba(100, 100, 100, 0.45);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 1010;
    box-shadow: 1px 1px 3px rgba(0,0,0,0.45);
    touch-action: none;
}
#toggle-map-header-buttons-panel img {
    width: 60%;
    height: 60%;
    object-fit: contain;
}
#load-route-button, #save-route-button {
    background-color: #0000CD !important;
}
#navigation-map-help-button {
    margin-right: 10px;
    margin-left: 10px;
    background-color: #4A5568 !important;
    box-shadow: 2px 2px 5px rgba(0,0,0,0.50);
}
#add-reminder-at-location-button {
    background-color: #FFA500 !important;
    width: 60px;
    height: 60px;
    padding: 5px;
    gap: 0;
}
#add-reminder-at-location-button.active-reminder-mode {
    background-color: #EF4444 !important;
}
#add-reminder-at-location-button svg {
    width: 100%;
    height: 100%;
    object-fit: contain;
}
.radares-ruta-control {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.3rem 0.6rem;
    background-color: rgba(200,200,180,0.7);
    border-radius: 5px;
    height: 60px;
    min-width: 70px;
    box-sizing: border-box;
    gap: 4px;
}
#radares-ruta-checkbox {
    margin-right: 0px;
    margin-bottom: 0px;
    transform: scale(1.1);
}
.radares-ruta-label-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}
#radares-ruta-checkbox + .radares-ruta-label-container > label {
    font-weight: bold;
    font-size: 0.85rem;
    color: #333;
    cursor: pointer;
    text-align: center;
    line-height: 1.1;
    margin-bottom: 1px;
}
#radares-ruta-count {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
    background-color: #6600a1;
    color: white;
    border-radius: 50%;
    font-size: 0.75rem;
    font-weight: bold;
    line-height: 1;
    margin-top: 2px;
}
.tareas-ruta-control {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.3rem 0.6rem;
    background-color: rgba(200,200,180,0.7);
    border-radius: 5px;
    height: 60px;
    min-width: 70px;
    box-sizing: border-box;
    gap: 4px;
}
#tareas-ruta-checkbox {
    margin-right: 0px;
    margin-bottom: 0px;
    transform: scale(1.1);
}
.tareas-ruta-label-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}
#tareas-ruta-checkbox + .tareas-ruta-label-container > label {
    font-weight: bold;
    font-size: 0.85rem;
    color: #333;
    cursor: pointer;
    text-align: center;
    line-height: 1.1;
    margin-bottom: 1px;
}
#tareas-ruta-count {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
    background-color: #008f39;
    color: white;
    border-radius: 50%;
    font-size: 0.75rem;
    font-weight: bold;
    line-height: 1;
    margin-top: 2px;
}
#reorder-route-stages-button {
    height: 60px;
    width: 60px;
    border: 1px solid #777;
    box-shadow: 2px 3px 5px rgba(0,0,0,0.70);
    padding: 2px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 0.9rem;
    font-weight: bold;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    flex-shrink: 0;
    white-space: nowrap;
    background-color: white !important;
    margin-right: 4px;
}
#reorder-route-stages-button img {
    max-height: 90%;
    max-width: 90%;
    object-fit: contain;
}
#map-location-search-button {
    height: 60px;
    width: 60px;
    border: 1px solid #777;
    box-shadow: 2px 3px 5px rgba(0,0,0,0.70);
    padding: 3px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 0.9rem;
    font-weight: bold;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    flex-shrink: 0;
    white-space: nowrap;
    background-color: white !important;
    margin-left: 2px;
}
#map-location-search-button img {
    max-height: 80%;
    max-width: 90%;
    object-fit: contain;
}
#map-location-search-input::placeholder {
    color: #CDCDCD;
    opacity: 1;
}
#::placeholder {
    color: #CDCDCD;
    opacity: 1;
}
#map-location-search-input::-webkit-input-placeholder {
    color: #CDCDCD;
}
#map-location-search-input::-moz-placeholder {
    color: #CDCDCD;
    opacity: 1;
}
#map-location-search-input:-ms-input-placeholder {
    color: #CDCDCD;
}
#map-location-search-input::-ms-input-placeholder {
    color: #CDCDCD;
}
body.dark-mode #map-location-search-input {
    background-color: #a0a090;
    color: #e0e0e0;
    border-color: #666;
}
body.dark-mode #map-location-search-input::placeholder {
    color: #A0A0A0;
}
#clear-map-search-input-button {
    height: 60px !important;
    width: 50px !important;
    background-color: #e0e0e0;
    border: 1px solid #ccc;
    box-shadow: 2px 3px 5px rgba(0,0,0,0.70);
    border-radius: 4px;
    cursor: pointer;
    flex-shrink: 0;
    padding: 0;
    z-index: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-left: 2px;
}
#clear-map-search-input-button svg {
    width: 60%;
    height: 60%;
    stroke: red;
    stroke-width: 3;
}
body.dark-mode #clear-map-search-input-button {
    background-color: #555;
    border-color: #444;
}
body.dark-mode #clear-map-search-input-button svg {
    stroke: #ff6666;
}
#toggle-simulate-gps-button {
    background-color: #DAA520 !important;
    width: 60px;
    height: 60px;
    padding: 5px !important;
}
#toggle-simulate-gps-button.active-simulate-gps-mode {
    background-color: #B22222 !important;
    box-shadow: 0 0 8px #FF4500;
}
#toggle-simulate-gps-button img {
    width: 100%;
    height: 100%;
    object-fit: contain;
}
#simulate-route-button {
    padding: 5px;
}
#simulate-route-button img {
    width: 100%;
    height: 100%;
    object-fit: contain;
}
#view-all-locations-map {
    padding: 0.75rem 1.2rem;
    font-size: 1.1rem;
    font-weight: bold;
    border-radius: 0.5rem;
    cursor: pointer;
    border: 2px solid #506C6C;
    color: white;
    background-color: #668B8B;
    margin-left: 10px;
    transition: background-color 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    height: auto;
    min-height: 46px;
    white-space: nowrap;
}
#view-all-locations-map:hover {
    background-color: #5C7A7A;
}
#reminders-location-map-div {
    flex-grow: 1;
    background-color: #E0E0E0;
    position: relative;
    overflow: hidden;
}
#map-info-overlay {
    position: absolute;
    top: 10px;
    right: 90px;
    left: auto;
    transform: none;
    z-index: 1002;
    background: rgba(0,0,0,0.1);
    color: white;
    padding: 8px 15px;
    border-radius: 8px;
    font-size: 0.8em;
    font-weight: bold;
    text-align: right;
    display: none;
    max-width: 55%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    line-height: 1.3;
}
#map-info-overlay span {
}
#tab-content-radares .radar-filter-group {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-bottom: 1rem;
    align-items: end;
}
#tab-content-radares .radar-filter-group label {
    margin-bottom: 0.25rem;
    font-weight: 500;
    font-size: 0.9rem;
}
#tab-content-radares .radar-filter-group input {
    padding: 0.5rem;
    font-size: 1rem;
    border: 1px solid #ccc;
    border-radius: 0.25rem;
}
#tab-content-radares .radar-import-options {
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}
#tab-content-radares .radar-import-options input[type=checkbox] {
    width: 1.1rem;
    height: 1.1rem;
}
#tab-content-radares .radar-import-options label {
    margin-bottom: 0;
    font-size: 0.9rem;
}
#tab-content-radares .radar-action-buttons {
    display: flex;
    justify-content: space-around;
    gap: 1rem;
    margin-top: 1rem;
    margin-bottom: 1.5rem;
}
#tab-content-radares .radar-action-buttons button {
    flex: 1;
    padding: 0.8rem 1rem;
    font-size: 1.1rem;
    border-radius: 0.3rem;
    background-color: #D1D5DB;
}
#import-radars-button, #delete-filtered-radars-button {
    background-color: #F59E0B !important;
    color: white !important;
    border: 1px solid #D97706 !important;
}
#import-radars-button:hover, #delete-filtered-radars-button:hover {
    background-color: #D97706 !important;
}
#radar-import-progress-container {
    margin-top: 1rem;
    padding: 0.8rem;
    border: 1px solid #ccc;
    border-radius: 0.25rem;
    background-color: #f9f9f9;
}
#radar-import-progress-bar {
    width: 100%;
    height: 20px;
    margin-bottom: 0.5rem;
}
#radar-import-status {
    font-size: 0.9rem;
    color: #333;
    min-height: 1.2em;
    text-align: center;
}
.navigation-waypoint-marker {
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    color: white;
    font-weight: bold;
    text-align: center;
    box-shadow: 0 0 3px rgba(0,0,0,0.5);
    opacity: 0.85;
    position: relative;
}
.navigation-waypoint-marker.start-point {
    background-color: rgba(0, 128, 0, 0.80);
}
.navigation-waypoint-marker.finish-point {
    background-color: rgba(0, 0, 255, 0.80);
}
.navigation-waypoint-marker.intermediate-point {
    background-color: rgba(230, 140, 0, 0.80);
}
.waypoint-delete-button {
    position: absolute;
    background-color: rgba(255, 0, 0, 0.85);
    color: white;
    border-radius: 50%;
    text-align: center;
    cursor: pointer;
    border: 1px solid white;
    z-index: 10;
}
#navigation-bottom-progress-bar {
    position: absolute;
    top: 10px;
    left: 10px;
    transform: none;
    width: auto;
    max-width: 500px;
    min-width: 480px;
    background-color: rgba(0, 0, 0, 0.6);
    padding: 8px;
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    z-index: 1001;
    color: white;
    display: none;
}
#navigation-top-info-bar {
    margin-bottom: 8px;
    font-size: 1.2em;
    display: flex;
    align-items: center;
    position: relative;
    cursor: pointer;
}
#navigation-bottom-progress-bar hr {
    border: none;
    border-top: 1px solid rgba(229, 209, 193, 0.5);
    margin: 10px 0;
}
#navigation-top-info-bar .turn-icon-display img {
    width: 95% !important;
    height: 95% !important;
    background-size: contain;
    background-position: center;
    display: block;
    margin: auto;
    object-fit: contain;
}


#turn-icon-container-styled {
    position: relative;
    background-color: white;
    padding: 2px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 60px;
    height: 60px;
    box-sizing: border-box;
    z-index: 1;
    flex-shrink: 0;
    margin-right: 8px;
    overflow: hidden; 
}

#navigation-top-info-bar .turn-icon-display .leaflet-routing-icon {
    width: 100%;
    height: 100%;
    background-image: url('https://cdnjs.cloudflare.com/ajax/libs/leaflet-routing-machine/3.2.12/leaflet.routing.icons.png');
    background-repeat: no-repeat;
    image-rendering: pixelated; /* Mantiene la nitidez al escalar */
  }

#simulation-modal .turn-icon-sim .leaflet-routing-icon {
    width: 24px !important;
    height: 24px !important;
    transform: none !important;
    display: block;
    object-fit: contain;
    background-image: url('https://cdnjs.cloudflare.com/ajax/libs/leaflet-routing-machine/3.2.12/leaflet.routing.icons.png');
    background-repeat: no-repeat;
   }

    
#navigation-top-info-bar .maneuver-text-container {
    flex-grow: 1;
    text-align: center;
    max-width: calc(100% - 60px);
}
#navigation-top-info-bar .maneuver-text, #navigation-top-info-bar .street-name {
    font-weight: bold;
    font-size: 1.33em
    color: white;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    white-space: normal;
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.2;
}
#navigation-top-info-bar .maneuver-text {
    font-size: 1.2em;
    margin-right: 8px;
    display: inline;
}
#navigation-top-info-bar .street-name {
    font-size: 0.8em;
    display: inline;
}
#distance-to-turn-formatted {
    text-align: center;
    font-weight: bold;
    font-size: 1.5em;
    margin-top: 4px;
}
#distance-progress-bar-to-turn-container {
    width: 100%;
    height: 7px;
    background-color: #e0e0e0;
    border-radius: 4px;
    margin-top: 5px;
    overflow: hidden;
}
#distance-progress-bar-to-turn {
    width: 100%;
    height: 100%;
    background: linear-gradient(to right, #680000 0%, #FF0000 50%, #FA8072 97%);
    border-radius: 4px;
    transition: width 0.3s linear;
}
#route-overall-progress-container {
    width: 100%;
    height: 18px;
    background-color: #e0e0e0;
    border-radius: 9px;
    margin-bottom: 9px;
    position: relative;
    overflow: visible;
}
#route-overall-progress {
    width: 0%;
    height: 100%;
    z-index: 3;
    background-color: #4CAF50;
    background: linear-gradient(to right, #006600 30%, #258D19 92%, #b4ff9a 99%);
    border-radius: 9px;
    transition: width 0.5s linear;
    position: relative;
}
.radar-marker-on-progress-bar {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 0;
    height: 0;
    z-index: 1;
    border-left: 11px solid transparent;
    border-right: 11px solid transparent;
    border-bottom: 14px solid white;
}
.radar-marker-on-progress-bar::after {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    z-index: 2;
    border-left: 9px solid transparent;
    border-right: 9px solid transparent;
    border-bottom: 12px solid #8A36D2;
    top: 1px;
    left: -9px;
}
.task-marker-on-progress-bar {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 0;
    height: 0;
    z-index: 1;
    border-left: 11px solid transparent;
    border-right: 11px solid transparent;
    border-bottom: 14px solid white;
}
.task-marker-on-progress-bar::after {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    z-index: 2;
    border-left: 9px solid transparent;
    border-right: 9px solid transparent;
    border-bottom: 12px solid #608414;
    top: 1px;
    left: -9px;
}
#route-progress-icon {
    position: absolute;
    height: 100%;
    width: auto;
    max-height: 18px;
    left: 100%;
    top: 50%;
    transform: translate(-50%, -50%);
    z-index: 4;
    display: none;
}
#route-progress-text {
    position: absolute;
    text-align: left;
    top: 50%;
    left: 10px;
    transform: translateY(-50%);
    font-family: 'Arial', 'Helvetica Neue', Helvetica, sans-serif;
    font-weight: bold;
    color: yellow;
    -webkit-text-stroke-width: 2px;
    -webkit-text-stroke-color: #006400;
    paint-order: stroke fill;
    font-size: clamp(0.8em, 3vw, 0.9em);
    line-height: 1;
    pointer-events: none;
    z-index: 3;
    background-color: transparent;
    padding: 2px;
    white-space: nowrap;
}
.waypoint-dot-on-progress-bar {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 13px;
    height: 13px;
    background-color: #3498db;
    border-radius: 50%;
    border: 1px solid white;
    z-index: 2;
}
#navigation-eta-info {
    display: flex;
    justify-content: space-between;
    margin-top: 6px;
    font-size: 1em;
}
#navigation-eta-info.single-destination {
    justify-content: center;
}
#navigation-eta-info > div {
    flex-basis: 48%;
    text-align: center;
}
#final-destination-info.single-destination-layout {
    text-align: center;
    flex-basis: auto !important;
}
#final-destination-info.single-destination-layout strong {
    font-size: 0.7em !important;
}
#final-destination-info.single-destination-layout span {
    font-size: 1.1em !important;
}
#navigation-eta-info strong {
    display: block;
    font-size: 0.7em;
    margin-bottom: 2px;
}
#navigation-eta-info span {
    font-size: 1.1em;
    font-weight: bold;
}
#next-stage-info {
    display: block;
}
#navigation-eta-info #next-stage-distance, #navigation-eta-info #final-destination-distance {
    margin-right: 3px;
}
#navigation-eta-info #next-stage-time, #navigation-eta-info #final-destination-time {
    margin-left: 3px;
    margin-right: 3px;
}
#navigation-eta-info #next-stage-eta, #navigation-eta-info #final-destination-eta {
    margin-left: 3px;
}
.eta-deviation {
    font-size: 0.9em !important;
    font-weight: bold;
    margin-left: 6px !important;
}
.eta-deviation.positive {
    color: #FF7C39;
}
.eta-deviation.negative {
    color: #10B981;
}
#next-stage-info .eta-deviation {
    font-size: 0.9em !important;
    font-weight: bold;
    margin-left: 6px;
}
#final-destination-info .eta-deviation {
    font-size: 0.9em !important;
    font-weight: bold;
    margin-left: 6px;
}
#simulation-modal .modal-top-buttons {
    margin-bottom: 1rem;
}
#simulation-content-area {
    overflow-y: auto;
    margin-bottom: 1rem;
    padding: 0.5rem;
    background-color: #fff;
    border: 1px solid #ccc;
    border-radius: 0.5rem;
    min-height: 150px;
    font-size: 0.9rem;
    line-height: 1.4;
    flex-grow: 1;
}
#simulation-content-area ul {
    list-style-type: none;
    padding-left: 0;
}
#simulation-content-area li {
    padding: 0.3rem 0;
    border-bottom: 1px solid #eee;
    display: flex;
    align-items: center;
}
#simulation-content-area li:last-child {
    border-bottom: none;
}
#simulation-modal .turn-icon-sim {
    margin-right: 8px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    flex-shrink: 0;
    vertical-align: middle;
}
#simulation-modal .turn-icon-sim img {
    width: 24px !important;
    height: 24px !important;
    object-fit: contain;
}
#saved-routes-modal {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #E6D6A8;
    padding: 1.5rem;
    border-radius: 1rem;
    box-shadow: 0 6px 15px rgba(0,0,0,0.3);
    z-index: 8000;
    max-width: 750px;
    width: 95%;
    max-height: calc(100vh - 10px);
    display: flex;
    flex-direction: column;
}
#saved-routes-modal h2 {
    font-size: 1.3rem;
    font-weight: bold;
    text-align: center;
    margin-bottom: 1rem;
    color: #333;
}
#saved-routes-modal .modal-top-buttons {
    margin-bottom: 1rem;
    display: flex;
    justify-content: flex-start;
    align-items: center;
}
#saved-routes-modal #close-saved-routes-modal {
    background-color: #C0392B !important;
    color: white !important;
    border: 1px solid #A93226 !important;
    padding: 0.9rem 1.8rem !important;
    font-size: 1.15rem !important;
    font-weight: bold !important;
    border-radius: 0.3rem;
    min-width: 130px;
    flex-grow: 0;
    flex-shrink: 0;
    flex-basis: flex-start;
}
#saved-routes-modal #close-saved-routes-modal:hover {
    background-color: #A93226 !important;
}
#saved-routes-modal .filter-container {
    display: flex;
    margin-bottom: 1rem;
    gap: 5px;
}
#saved-routes-modal input#filter-saved-routes {
    flex-grow: 1;
    padding: 8px 12px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 1.5rem;
    font-weight: bold !important;
    text-transform: uppercase !important;
}
#saved-routes-modal button#clear-filter-saved-routes {
    padding: 8px 12px;
    background-color: #e0e0e0;
    border: 1px solid #ccc;
    border-radius: 4px;
    cursor: pointer;
    color: #EF4444;
    font-weight: bold;
    font-size: 1.5rem;
    line-height: 1;
}
#saved-routes-list {
    list-style: none;
    padding: 0;
    margin: 0 0 1rem 0;
    max-height: calc(60vh - 80px - 50px);
    overflow-y: auto;
    border: 1px solid #A9A18C;
    border-radius: 5px;
    background-color: #D3CBB8;
}
#saved-routes-list li {
    padding: 10px 15px;
    border-bottom: 1px solid #ddd;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 1.1rem;
    font-weight: bold;
    background-color: #F5F5DC;
}
#saved-routes-list li:last-child {
    border-bottom: none;
}
#saved-routes-list li:hover {
    background-color: #FFD700;
}
#saved-routes-list .delete-route-btn {
    background-color: #ef4444;
    color: white;
    border: none;
    border-radius: 3px;
    padding: 3px 7px;
    font-size: 0.8rem;
    cursor: pointer;
}
#save-route-prompt-modal {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #E6D6A8;
    padding: 1.5rem;
    border-radius: 1rem;
    box-shadow: 0 6px 15px rgba(0,0,0,0.3);
    z-index: 8500;
    max-width: 800px;
    width: 90%;
    display: flex;
    flex-direction: column;
    max-height: calc(100vh - 20px);
}
#save-route-prompt-modal h2 {
    font-size: 1.3rem;
    font-weight: bold;
    text-align: center;
    margin-bottom: 1rem;
    color: #333;
}
#save-route-prompt-modal .modal-top-buttons {
    margin-bottom: 1rem;
}
#save-route-prompt-modal label {
    margin-bottom: 0.5rem;
    font-weight: 500;
    display: block;
}
#save-route-prompt-modal input[type="text"]#route-name-input {
    padding: 0.5rem;
    border: 1px solid #ccc;
    border-radius: 0.25rem;
    margin-bottom: 1rem;
    width: 100%;
    font-weight: bold !important;
    text-transform: uppercase !important;
    font-size: 1.3rem !important;
}
#save-route-prompt-modal button {
    padding: 0.7rem 1rem;
    font-size: 1.1rem;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    flex: 1;
    background-color: #D1D5DB;
}
#save-route-prompt-modal #confirm-save-route {
    background-color: #2563EB;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
}
#save-route-prompt-modal #cancel-save-route {
    background-color: #4A5568;
    color: white;
    border: 1px solid #2D3748;
    font-weight: bold;
}
#save-route-prompt-modal #cancel-save-route:hover {
    background-color: #2D3748;
}
.leaflet-control-attribution {
    opacity: 0.2;
    background-color: rgba(255, 255, 255, 0.3) !important;
}
.leaflet-routing-icon {
    background-image: url('https://cdnjs.cloudflare.com/ajax/libs/leaflet-routing-machine/3.2.12/leaflet.routing.icons.png');
    background-repeat: no-repeat;
    display: inline-block;
    width: 24px;
    height: 24px;
    vertical-align: middle;
    background-size: 288px 24px;
    overflow: visible;
}
.leaflet-routing-icon-continue {
    --bg-pos-x: 0;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-sharp-right {
    --bg-pos-x: -24px;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-turn-right {
    --bg-pos-x: -48px;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-bear-right {
    --bg-pos-x: -72px;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-sharp-left {
    --bg-pos-x: -96px;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-turn-left {
    --bg-pos-x: -120px;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-bear-left {
    --bg-pos-x: -144px;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-u-turn {
    --bg-pos-x: -168px;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-depart {
    --bg-pos-x: -192px;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-arrive {
    --bg-pos-x: -216px;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-roundabout {
    --bg-pos-x: -24px;
    --bg-pos-y: -24px;
}
.favicon-red {
    filter: hue-rotate(0deg) saturate(200%) brightness(80%);
}
.favicon-blue {
    filter: hue-rotate(200deg) saturate(150%) brightness(90%);
}
.button-countdown-timer {
    margin-left: 5px;
    font-weight: normal;
    font-size: 1em;
    opacity: 0.9;
}
#sortable-stages-list {
    max-height: calc(100% - 130px);
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    touch-action: pan-y;
    padding: 0;
    margin: 0;
    list-style-type: none;
    background-color: #C8BBA0;
}
#sortable-stages-list li {
    padding: 15px;
    min-height: 60px;
    border-bottom: 1px solid #ddd;
    transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    cursor: grab;
    user-select: none;
    display: flex;
    align-items: center;
    gap: 12px;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    margin-bottom: 10px;
    color: #333;
}
#sortable-stages-list li:hover:not(.dragging) {
    background-color: #f0e6c8;
    color: #FFFF00;
    box-shadow: 0 3px 7px rgba(0,0,0,0.15);
}
.drag-handle {
    cursor: grab;
    padding: 0 10px;
    align-self: stretch;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 8px;
    touch-action: none;
}
.drag-handle:hover {
}
.drag-handle img {
    width: 24px;
    height: 24px;
    object-fit: contain;
}
#sortable-stages-list li.dragging .drag-handle, .drag-handle:active {
    cursor: grabbing;
}
#sortable-stages-list li:hover:not(.dragging) {
    background-color: #E0D8C8;
    color: #FFFF00;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}
#sortable-stages-list li:hover:not(.dragging) .drag-handle {
}
#sortable-stages-list li:hover:not(.dragging) .stage-label-badge {
    color: white;
}
#sortable-stages-list li:hover:not(.dragging) .delete-stage-button {
    color: #EF4444;
}
#sortable-stages-list li:hover:not(.dragging) .delete-stage-button:hover {
    color: #B91C1C;
}
#sortable-stages-list li:hover:not(.dragging) .stage-name-text {
    color: #FFFF00;
}
#sortable-stages-list li:last-child {
    border-bottom: none;
    margin-bottom: 0;
}
#sortable-stages-list li.dragging {
    opacity: 0.7;
    background-color: #4a4a3b;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}
.stage-label-badge {
    background-color: #555;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.85rem;
    min-width: 25px;
    text-align: center;
    flex-shrink: 0;
    font-weight: bold;
}
.stage-name-text {
    flex-grow: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    font-size: 1rem;
    color: #333;
}
.delete-stage-button {
    cursor: pointer;
    margin-left: auto;
    padding: 0 10px;
    font-size: 1.8rem;
    color: #EF4444;
    font-weight: bold;
    line-height: 1;
    flex-shrink: 0;
}
.delete-stage-button:hover {
    color: #B91C1C;
}
#vehicle-icon-wrapper {
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    transform-origin: center center;
    position: relative;
}
#vehicle-icon-wrapper img {
    width: 100%;
    height: 100%;
    display: block;
    object-fit: contain;
    position: absolute;
    top: 0px;
    left: 0px;
}
.vehicle-icon-minimap {
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    transform-origin: center center;
    position: relative;
}
.vehicle-icon-minimap img {
    width: 100%;
    height: 100%;
    display: block;
    object-fit: contain;
    position: absolute;
    top: 0px;
    left: 0px;
}
#intersection-preview-map-container {
    width: 100%;
    height: 100%;
}
#reminders-location-map-modal.immersive-mode-active #reminders-location-map-header, #reminders-location-map-modal.immersive-mode-active #navigation-bottom-progress-bar, #reminders-location-map-modal.immersive-mode-active .leaflet-control-custom-map-controls, #reminders-location-map-modal.immersive-mode-active #map-info-overlay {
    display: none !important;
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
}
#search-row-map-header {
    height: 70px;
    min-height: 70px;
    max-height: 70px;
    margin-bottom: 2px;
}

.leaflet-bottom.leaflet-left {
    display: flex;
    align-items: flex-start;
    left: 5px;
    bottom: 5px;
}
#reminders-location-map-header .reminders-map-button-action {
    padding: 5px;
    font-size: 0.9rem;
    height: 60px;
    min-height: 60px;
    font-weight: bold;
    border-radius: 0.375rem;
    cursor: pointer;
    border: 1px solid #777;
    color: white;
    transition: background-color 0.2s ease, opacity 0.2s ease;
    box-shadow: 2px 5px 4px rgba(0,0,0,0.65);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    flex-shrink: 0;
    white-space: nowrap;
    background-color: white !important;
    min-width: 60px;
    width: 60px;
    margin-bottom: 5px;
}
.leaflet-control-custom-map-controls {
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap !important;
    align-items: flex-end;
    gap: 7px;
    z-index: 1001;
    min-width: 0;
}
    
.leaflet-control-custom-map-controls > * {
    flex-shrink: 0 !important;
    min-width: 0 !important;
}
    
.leaflet-control-orientation-altitude {
    transform: none !important;
    background-color: rgba(0,0,0,0.5);
    color: white;
    padding: 8px;
    border-radius: 3px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.40);
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
    box-sizing: border-box;
    cursor: pointer;
    width: 125px;
    min-width: 125px;
    flex-shrink: 0;
    height: 160px;
}
    
#navigation-graph-card {
    width: 395px;
    height: 160px;
    background-color: rgba(0, 0, 0, 0.50);
    color: white;
    border-radius: 5px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.45);
    z-index: auto;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    padding: 5px;
    position: relative;
    transition: all 0.4s ease-in-out;
}
    
#reminders-location-map-header .button-row {
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap !important;
    align-items: center;
    width: 100%;
    height: 65px;
    min-height: 65px;
    padding-bottom: 5px;
    box-sizing: content-box;
    overflow-x: auto;
    overflow-y: hidden;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    transition: opacity 0.3s ease, visibility 0.3s ease, max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
}
#reminders-location-map-header .button-row::-webkit-scrollbar {
    display: none;
}
#reminders-location-map-header .button-row > *:not(:last-child) {
    margin-right: 10px;
}
#intersection-preview-map-window {
    position: absolute;
    background-color: rgba(0, 0, 0, 0.75);
    border: 6px solid #bf875d;
    border-radius: 7px;
    z-index: 7000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    overflow: hidden;
}
@media (min-width: 768px) {
    #intersection-preview-map-window {
        height: 480px;
    }
}
body.mobile-view #intersection-preview-map-window {
    width: 90vw;
    height: 50vh;
    max-width: 500px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
body.mobile-view #reminders-location-map-modal {
    display: flex;
    flex-direction: column;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100dvh;
    padding: 0;
    border: none;
    border-radius: 0;
    box-sizing: border-box;
    z-index: 10000;
}
body.mobile-view #reminders-location-map-content-wrapper {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
    border-radius: 0;
    overflow: hidden;
}
body.mobile-view #reminders-location-map-header {
    flex-shrink: 0;
    padding: 5px;
    background-color: #C8C8C0;
}
body.mobile-view #reminders-location-map-header .button-row {
    height: auto;
    min-height: 0;
    flex-wrap: wrap;
    justify-content: center;
    gap: 5px;
    padding: 5px 0;
}
body.mobile-view #reminders-location-map-header .reminders-map-button-action,
body.mobile-view #reminders-location-map-header #reorder-route-stages-button {
    height: 48px;
    min-height: 48px;
    width: 48px;
    min-width: 48px;
    max-width: 60px;
    padding: 2px;
    font-size: 0.7rem;
}
body.mobile-view #reminders-location-map-header #map-location-search-input {
    font-size: 1.1rem;
    height: 48px;
    flex-grow: 1;
    min-width: 150px;
}
body.mobile-view #reminders-location-map-header #filter-input {
    height: 48px;
    width: 100px;
    font-size: 0.9rem;
}
body.mobile-view #reminders-location-map-div {
    flex-grow: 1;
    position: relative;
}
body.mobile-view #leaflet-map-actual-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
body.mobile-view #toggle-map-header-buttons-panel {
    width: 60px;
    height: 60px;
    left: 10px;
}
body.mobile-view #map-info-overlay {
    max-width: 80%;
    top: 10px;
    right: 10px;
    font-size: 0.9em;
}
body.mobile-view .leaflet-control-custom-map-controls {
    flex-direction: column;
    align-items: flex-start;
    gap: 5px;
}
body.mobile-view .reminder-modal,
body.mobile-view .help-modal,
body.mobile-view .edit-info-modal,
body.mobile-view .choice-modal,
body.mobile-view .edit-modal,
body.mobile-view .reminder-table-modal,
body.mobile-view .postpone-options,
body.mobile-view .saved-locations-modal,
body.mobile-view #reorder-stages-modal,
body.mobile-view #simulation-modal,
body.mobile-view #locations-preview-modal,
body.mobile-view #deviation-modal,
body.mobile-view #arrival-stats-modal,
body.mobile-view #simulation-speed-modal,
body.mobile-view #saved-routes-modal,
body.mobile-view #save-route-prompt-modal,
body.mobile-view #address-suggestions-modal,
body.mobile-view #pin-modal-overlay,
body.mobile-view #versions-modal-overlay
body.mobile-view #reminders-map-help-modal-instance,
body.mobile-view #intersection-preview-map-window {
    z-index: 10001 !important;
}
#reminders-map-help-modal-instance {
    z-index: 10002 !important;
}
#map-location-search-input {
    flex-grow: 1;
    padding: 8px 12px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background-color: #fff;
    min-width: 300px;
    height: 60px;
    font-weight: bold;
    text-transform: uppercase;
    font-size: 1rem;
    box-sizing: border-box;
    margin-right: 0 !important;
    margin-left: 5px;
}
#filter-input {
    max-width: 200px;
    font-size: 0.9rem;
    padding: 8px 5px;
    margin-left: 2PX;
    border: 1px solid #7c7c68;
    border-radius: 4px;
    font-weight: bold;
    height: 60px;
    background-color: #f0f0e0;
    box-sizing: border-box;
}
#nav-map-zoomtoggle-button {
    width: 60px !important;
    min-width: 60px !important;
    height: 60px !important;
    padding: 5px;
}
#reminders-location-map-header .button-row {
    display: flex;
    margin-left: 5px;
    flex-direction: row;
    flex-wrap: nowrap !important;
    align-items: center;
    width: 100%;
    height: 70px;
    min-height: 70px;
    padding-bottom: 5px;
    box-sizing: content-box;
    overflow-x: auto;
    overflow-y: hidden;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    transition: opacity 0.3s ease, visibility 0.3s ease, max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
}  




.direction-warning-card {
    position: absolute;
    /* Aplicamos la transparencia y el fondo al contenedor principal */
    background-color: rgba(100, 100, 100, 0.70);
    color: white;
    font-weight: bold;
    font-size: 1.1rem;
    padding: 8px 12px;
    border-radius: 5px;
    z-index: 1005;
    display: none; /* Se mostrar con JavaScript */
    /* El text-shadow se aplica al texto dentro de la tarjeta */
    text-shadow: 1px 1px 2px rgba(0,0,0,0.45);
    /* Aadimos flexbox para alinear texto e icono */
    display: flex;
    align-items: center;
    gap: 8px; /* Espacio entre icono y texto */
}

/* Nueva regla para estilizar los iconos dentro de las tarjetas */
.direction-card-icon {
    width: 28px;
    height: 28px;
    display: inline-block;
    vertical-align: middle;
    /* La magia est aqu: aplicamos un filtro para que el icono se vea integrado */
    filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.45));
}



    


/* ======================================= */
/* === INICIO: CDIGO CSS PARA ALERTAS === */
/* ======================================= */

#alert-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.75);
    z-index: 8000;
    /* Quitamos flex para posicionar el contenido de forma absoluta */
}

#alert-modal-content {
    position: fixed; /* Posicionamiento fijo */
    top: 25px;       /* A 25px del borde superior */
    left: 25px;      /* A 25px del borde izquierdo */
    background-color: #E6D6A8;
    padding: 1rem;
    border-radius: 1rem;
    box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    border: 2px solid #C0B080;
}

#alert-columns-container {
    display: flex;
    gap: 1rem; /* Espacio entre las columnas */
}

.alert-column {
    display: flex;
    flex-direction: column;
    gap: 0.8rem; /* Espacio entre los botones de una misma columna */
}

.alert-option, #alert-cancel-button {
    display: flex;
    align-items: center;
    padding: 0.75rem 1.25rem;
    background-color: #F5F5DC;
    border: 1px solid #A9A18C;
    border-radius: 0.5rem;
    cursor: pointer;
    transition: background-color 0.2s ease, transform 0.1s ease;
    width: 100%; /* Para que ocupen el ancho de la columna */
}

.alert-option:hover {
    background-color: #FFD700;
    transform: translateY(-2px);
}

.alert-option img {
    width: 80px;
    height: 50px;
    margin-right: 1rem;
    object-fit: contain;
}

.alert-option span {
    font-size: 1.4rem ; color: white;
    font-weight: bold;
    color: #333;
}


#alert-cancel-button {
    background-color: #2563EB;
    justify-content: center;
    margin-top: auto;
}

#alert-cancel-button:hover {
    background-color: #1D4ED8;
}

#alert-cancel-button span {
    color: white !important;
    font-weight: bold !important;
}


    
    
#accident-alert-button-map {
    background-color: white !important; /* Estilo para el botn en el mapa */
}

#proximity-alert-modal {
    position: fixed;
    top: 25px; 
    left: 25px; 
    background-color: white;
    border: 2px solid black; border-radius: 0.75rem;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4); z-index: 8500;
    padding: 0.8rem; display: flex; align-items: center;
    gap: 0.8rem; max-width: 450px; 
}
#proximity-alert-modal img {
    width: 110px; 
    height: 85px;
    object-fit: contain;
}
#proximity-alert-modal .content {
    display: flex; flex-direction: column; gap: 0.5rem;
}
#proximity-alert-modal .alert-text {
    font-size: 1.3rem; 
    font-weight: bold; color: #111827;
}
#proximity-alert-modal button {
    padding: 0.6rem 1.2rem; font-size: 1rem;
    background-color: #2563EB;
    color: white; font-weight: bold; 
    border: none; border-radius: 0.25rem; cursor: pointer;
    align-self: flex-start; min-width: 120px; 
}

#flashing-border-overlay {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    box-sizing: border-box; pointer-events: none; z-index: 8499;
    border: 15px solid transparent; animation: flash-yellow-border 1s infinite;
}
@keyframes flash-yellow-border {
    0%, 100% { border-color: transparent; }
    50% { border-color: #FFFF00; }
}


/* ================================================= */
/* === INICIO: CSS PARA ICONOS DE ALERTA EN MAPA === */
/* ================================================= */
.traffic-alert-icon-container {
    width: 55px;  
    height: 55px;
    border-radius: 50%;
    background-color: white;
    border: 3px solid red;
    box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden; 
    transition: width 0.2s ease, height 0.2s ease; /* Transicin suave */
}

.traffic-alert-icon-container.small {
    width: 27px; 
    height: 27px;
    border-width: 2px; 
}

.traffic-alert-icon-container img {
    width: 85%;
    height: 85%;
    object-fit: contain;
}

/* =========================================================== */
/* === FIN: CSS PARA ICONOS DE ALERTA EN MAPA (CORREGIDO) === */
/* =========================================================== */

.reminder-slide .radar-icon {
    display: block;
    margin: 0 auto 0.5rem auto; 
    width: 90px;
    height: 70px;
    object-fit: contain;
}    

/* ============================================================ */
/* === INICIO: NUEVOS ESTILOS PARA PUNTOS DE RECARGA (OCM) === */
/* ============================================================ */
.filter-modal-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: 9000;
    display: flex;
    justify-content: flex-start; 
    align-items: flex-start;    
    padding-top: 10px;          
    padding-left: 10px;         
}

.filter-modal-content {
    background-color: #E6D6A8;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    width: 90%;
    max-width: 500px;
    text-align: center;
}

.filter-modal-content h2 {
    font-size: 1.5rem;
    font-weight: bold;
    color: #333;
    margin-bottom: 20px;
}

.filter-group {
    margin-bottom: 25px;
}

.filter-group label {
    display: block;
    font-weight: bold;
    margin-bottom: 15px;
    font-size: 1.1rem;
}

.slider-container {
    position: relative;
    width: 90%;
    margin: 0 auto;
    height: 30px;
}

.slider-track, .slider-range {
    position: absolute;
    height: 5px;
    border-radius: 3px;
    top: 12.5px;
    width: 100%;
}

.slider-track {
    background-color: #ccc;
    z-index: 1;
}

.slider-range {
    background-color: #2563EB;
    z-index: 2;
}

.slider-thumb {
    position: absolute;
    width: 25px;
    height: 25px;
    background-color: white;
    border: 2px solid #2563EB;
    border-radius: 50%;
    top: 2.5px;
    z-index: 3;
    cursor: pointer;
    box-shadow: 0 0 5px rgba(0,0,0,0.2);
}
  

.slider-thumb.left {
    left: 0%;
    transform: translateX(-50%);
}
.slider-thumb.right {
    right: 0%;
    transform: translateX(50%);
}

.filter-modal-content button#accept-filters-btn {
    background-color: #2563EB;
    color: white;
    font-weight: bold;
    padding: 10px 30px;
    border-radius: 5px;
    border: none;
    font-size: 1.1rem;
    cursor: pointer;
    transition: background-color 0.2s;
}

.filter-modal-content button#accept-filters-btn:hover {
    background-color: #1D4ED8;
}

.single-slider-container .slider-range {
    left: 0;
}

.single-slider-container .slider-thumb {
    transform: translateX(-50%);
}


/* ============================================================ */
/* === INICIO: NUEVOS ESTILOS PARA PUNTOS DE RECARGA (OCM) === */
/* ============================================================ */

.charging-point-card {
    background-color: rgb(30, 144, 255);
    color: white;
    border: 1px solid white;
    border-radius: 6px;
    padding: 4px 8px;
    font-family: sans-serif;
    text-align: center;
    box-shadow: 0 1px 4px rgba(0,0,0,0.5);
    width: 160px; 
    max-height: 70px; /* Altura mxima */
    height: 70px;     /* Altura fija */
    cursor: pointer;
    line-height: 1.3; /* Espaciado entre lneas */
    display: flex;
    flex-direction: column;
    justify-content: center;
    overflow: hidden; /* Oculta lo que no quepa */
}
.charging-point-card p {
    margin: 2px 0; /* Un poco ms de espacio vertical */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 0.8rem; 
}
.charging-point-card p.operator {
    font-weight: bold;
    font-size: 0.85rem; /* Letra un poco ms grande para el operador */
}
.charging-point-card p.power {
    font-weight: bold;
    font-size: 0.9rem;
    color: #ffd700; /* Destacamos potencia y precio */
}
.charging-point-card p.availability {
    font-size: 0.8rem;
}
    
.charging-point-popup .leaflet-popup-content-wrapper {
    background-color: #E6D6A8;
    color: #333;
    border-radius: 8px;
    border: 1px solid #C0B080;
}
.charging-point-popup .leaflet-popup-content {
    font-family: sans-serif;
    font-size: 0.9rem;
    line-height: 1.4;
    padding: 10px;
    width: 300px !important;
}
.charging-point-popup h3 {
    font-size: 1.1rem;
    font-weight: bold;
    margin-bottom: 8px;
    color: #1E3A8A;
}
.charging-point-popup h4 {
    font-size: 1rem;
    font-weight: bold;
    margin-top: 10px;
    margin-bottom: 5px;
    border-top: 1px solid #ccc;
    padding-top: 8px;
}
.charging-point-popup p {
    margin: 4px 0;
}
.charging-point-popup .ocm-connection-list {
    list-style: none;
    padding: 0;
    margin: 0;
}
.charging-point-popup .ocm-connection-list li {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
    border-bottom: 1px solid #D8CEC0;
}
.charging-point-popup .ocm-connection-list li:last-child {
    border-bottom: none;
}
.charging-point-popup .conn-type {
    font-weight: 500;
    flex-basis: 45%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.charging-point-popup .conn-power {
    flex-basis: 20%;
    text-align: center;
}
.charging-point-popup .conn-status {
    flex-basis: 35%;
    text-align: center;
    color: white;
    padding: 2px 5px;
    border-radius: 3px;
    font-size: 0.8rem;
    font-weight: bold;
}
.charging-point-popup .popup-buttons {
    display: flex;
    justify-content: space-around;
    margin-top: 12px;
}
.charging-point-popup button {
    padding: 6px 12px;
    font-size: 0.9rem;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
}
.charging-point-popup .add-to-route-btn {
    background-color: #28a745;
    color: white;
}
.charging-point-popup .cancel-btn {
    background-color: #6c757d;
    color: white;
}
/* ========================================================== */
/* === FIN: NUEVOS ESTILOS PARA PUNTOS DE RECARGA (OCM) === */
/* ========================================================== */

    
</style>

    
</head>
<body class="min-h-screen bg-[#ABAB99] flex flex-col items-center p-6">

    <div class="reminder-count-globe" id="reminder-count-globe" style="display: none;"></div>

    <div id="unified-reminder-window" role="alertdialog" aria-labelledby="reminder-window-title" aria-describedby="reminder-window-desc">
        <div class="reminder-count-header" id="reminder-window-title">
            <div class="reminder-title-container">
                <span style="font-size: 1.3rem;" id="reminder-count-text-container">
                    <span id="current-reminder-index">1</span> de <span id="total-reminder-count">X</span> Recordatorios
                </span>
                <span class="swipe-hint" id="reminder-swipe-hint" style="font-size: smaller;">
                    (deslice lateralmente)
              </span>
            </div>
            <button id="hide-all-reminders-button" title="Posponer 1 minuto todos los recordatorios visibles">OCULTAR</button>
        </div>
        <div id="reminder-swiper-container" aria-live="polite">
        </div>
        <span id="reminder-window-desc" class="hidden">Deslice para ver los recordatorios vencidos. Use los botones para gestionar cada recordatorio.</span>
    </div>

    <div id="grid-filter-container">
        <input type="text" id="grid-filter-input" placeholder="Filtrar grid...">
        <button id="clear-filter-button" title="Limpiar filtro"></button>
    </div>

<main>
    <div id="user-id-display"></div>
    <div id="bookmark-grid">
    </div>
</main>

<div class="notices-icon-container">
    <img src="https://boardinggate.github.io/Tesla/IMG_4194.jpg" alt="Toggle Avisos" class="notice-off-icon" id="notice-toggle-icon">
    <div class="notices-container">
        <div class="notice-wrapper">
            <span class="notice" id="current-notice"></span>
        </div>
    </div>
</div>

<footer>
    <div class="footer-content">
        <div class="header-container">
            <img src="https://boardinggate.github.io/Tesla/LOGOTESLA.jpg" class="header-logo">
            <div class="title-container">
                <h1 class="text-2xl font-bold inline">
                    <span class="text-2xl">BoardingGate</span>
                    <span class="text-base">Lanzador</span>
                    <span id="version" class="version-text"></span>
                </h1>
            </div>
        </div>
        <div class="footer-line">
          <a href="https://x.com/boardinggate/status/1857325553742721116?s=46" class="footer-link-green" target="_blank" rel="noopener noreferrer">Ahorremos un dinero con mis REFERIDOS</a>
        </div>

        <div class="statcounter-container">
          <div style="display: inline-flex; align-items: center; gap: 10px;">
            <script type="text/javascript">
              var sc_project=13126275;
              var sc_invisible=0;
              var sc_security="0fc568cc";
              var scJsHost = "https://";
              document.write("<sc"+"ript type='text/javascript' src='" +
              scJsHost+
              "statcounter.com/counter/counter.js'>"+"<"+"/script>");
            </script>
            <noscript><div class="statcounter"><a title="Web Analytics"
            href="https://statcounter.com/" target="_blank"><img
            class="statcounter"
            src="https://c.statcounter.com/13126275/0/0fc568cc/0/"
            alt="Web Analytics"
            referrerPolicy="no-referrer-when-downgrade"></a></div></noscript>
            <a href="https://statcounter.com/p13126275/?guest=1" class="footer-subtext">Legionarios de Elon</a>
          </div>
        </div>

        <p class="footer-subtext">La inteligencia tiene ciertos limites. La locura, casi ninguno  </p>
    </div>
</footer>

<div id="pin-modal-overlay" class="hidden">
    <div id="pin-modal-content">
        <h2>Introducir Clave de Acceso</h2>
        <div class="modal-top-buttons" style="justify-content: center;">
            <button id="pin-submit-button">Entrar</button>
        </div>
        <label for="pin-input">Clave (4 cifras):</label>
        <input type="password" id="pin-input" maxlength="4" pattern="\d{4}" inputmode="numeric" required>
        <p id="pin-error-message"></p>
    </div>
</div>

<div id="versions-modal-overlay" class="versions-modal-overlay hidden">
    <div class="versions-modal-content">
        <h2>Histrico de versiones y recomendaciones</h2>
        <div class="modal-top-buttons" style="justify-content: flex-end;">
             <button id="close-versions-modal" style="flex: 0 1 auto; min-width: 120px;">Salir</button>
        </div>
        <pre id="versions-content">Cargando...</pre>
    </div>
</div>

<div id="reorder-stages-modal" class="hidden">
    <h2>Ordenar Etapas de Ruta</h2>
    <div class="modal-top-buttons">
        <button id="confirm-reorder-stages">Aceptar <span class="button-countdown-timer"></span></button>
        <button id="cancel-reorder-stages">Cancelar</button>
    </div>
    <p style="font-size: 0.9rem; color: #555; margin-bottom: 1rem;">Arrastra y suelta las etapas para cambiar su orden. Pulsa el aspa (X) para eliminar una etapa.</p>
    <ul id="sortable-stages-list">
    </ul>
</div>

<div id="scroll-toggle" class="scroll-toggle-button" title="Ir al inicio o fin">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M19 12l-7 7-7-7"/></svg>
</div>

<div id="config-modal" class="hidden">
    <div class="modal-top-buttons">
        <h2>Configuracin y Datos</h2>
        <button id="config-close-modal" style="padding: 0.5rem 1rem; font-size:1rem;">Cerrar</button>
    </div>
    <div class="tab-buttons">
        <button class="config-tab-button active" data-tab-target="#tab-content-usuario">Usuario</button>
        <button class="config-tab-button" data-tab-target="#tab-content-pin">Clave Acceso</button>
        <button class="config-tab-button" data-tab-target="#tab-content-radares">RADARES</button>
        <button class="config-tab-button" data-tab-target="#tab-content-backup-restore">Backup/Restore</button>
        <button class="config-tab-button" data-tab-target="#tab-content-borrar">Borrar Datos</button>
    </div>
    <div class="tab-contents">
        <div id="tab-content-usuario" class="config-tab-content active">
            <h3>Datos de Usuario y Sincronizacin</h3>
            <p style="font-size:.9rem;color:#555;margin-bottom:1.5rem;text-align:center;">
                Introduce un nombre de usuario nico para guardar y recuperar tus datos en la nube.
            </p>
            <p style="font-size: .95rem; color: #005A9C; margin-bottom: 1.5rem; text-align: left; background-color: #e6f7ff; padding: 10px; border-radius: 5px; border-left: 5px solid #007bff;">
                <strong>Modo Compaero (Mvil):</strong> Para sincronizar datos desde tu mvil, usa tu nombre de usuario seguido de <strong>@MOVIL o MVIL</strong> (ej: `MI_USUARIO@MOVIL`).
                Al iniciar sesin, se cargarn los LTIMOS DATOS que el coche haya GUARDADO EN LA NUBE. Cada cambio que hagas en el mvil (crear rutas, etc.) se guardar automticamente en la nube para que est disponible en el coche al RECARGAR. 
                 -----IMPORTANTE!!!!---- SI QUIERES ENVIAR DATOS DESDE EL MVIL RECUERDA ANTES FORZAR UNA RECARGA DE LA PGINA EN EL COCHE (debes tener el check activo de copias automticas) O REALIZAR MANUALMENTE UN BACKUP</p>
            <div class="user-data-grid">
                <div><label for="user-id">* ID Usuario (nico, no se puede cambiar):</label><input type="text" id="user-id" name="userId" required></div>
                <div><label for="tesla-model">Modelo Tesla:</label><input type="text" id="tesla-model" name="teslaModel"></div>
                <div><label for="tesla-year">Ao Modelo:</label><input type="number" id="tesla-year" name="teslaYear" min="2012" max="2099"></div>
                <div><label for="tesla-province">Provincia:</label><input type="text" id="tesla-province" name="teslaProvince"></div>
                <div class="checkbox-container">
                    <input type="checkbox" id="allow-dms" name="allowDMs"><label for="allow-dms">Permitir MDs (va admin)</label>
                </div>
                <div class="checkbox-container" style="border-top: 1px solid #ccc; padding-top: 1rem; margin-top: 1rem;">
                    <input type="checkbox" id="config-auto-backup-on-load" name="autoBackup">
                    <label for="config-auto-backup-on-load">Sincronizar/Hacer copia de seguridad automtica al cargar la pgina (en el coche)</label>
                </div>
            </div>
            <div class="user-buttons-container" style="margin-top:1.5rem;">
                <button id="config-save-user-firebase" style="background-color:#16A34A;color:white;">Validar usuario y/o Sincronizar/Guardar en la nube</button>
            </div>
            <p id="config-user-status" class="status-message"></p>
            </div>
         <div id="tab-content-pin" class="config-tab-content">
             <h3>Clave de Acceso (Local)</h3>
             <div class="pin-buttons-container" style="margin-bottom: 1rem;">
                 <button id="config-save-pin" style="background-color:#2563EB;color:white;">Guardar Clave y Preferencias</button>
                 <button id="config-remove-pin" style="background-color:#dc3545;color:white;">Quitar Clave</button>
             </div>
             <p style="font-size: 0.9rem; color: #555; margin-bottom: 1rem;">Establece una clave de 4 cifras para proteger el acceso inicial a la pgina</p>
             <div class="pin-config-layout">
                 <div class="pin-input-group">
                     <label for="config-pin-set">Establecer/Cambiar Clave:</label>
                     <input type="password" id="config-pin-set" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="4 cifras">
                 </div>
                 <div class="pin-input-group">
                     <label for="config-pin-confirm">Confirmar Clave:</label>
                     <input type="password" id="config-pin-confirm" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="Repetir 4 cifras">
                 </div>
             </div>
             <div class="checkbox-container" style="margin-top: 1.5rem; border-top: 1px solid #ccc; padding-top: 1rem;">
                <input type="checkbox" id="config-direct-to-nav" name="directToNav">
                <label for="config-direct-to-nav">Entrar directamente al Navegador de rutas</label>
            </div>
             <p id="config-pin-status" class="status-message"></p>
         </div>
         <div id="tab-content-radares" class="config-tab-content">
            <h3>Importar / Borrar Radares y Otros POIs</h3>
            <div class="radar-action-buttons" style="margin-bottom: 1rem;">
                <button id="import-radars-button">IMPORTAR RADARES y otros</button>
                <button id="delete-filtered-radars-button">BORRAR CACH (segn filtro)</button>
            </div>
            <p style="font-size:0.85rem; color:#444; margin-bottom:0.5rem;">
                Para <strong>importar</strong>, el filtro de "Palabras Clave" buscar coincidencias (OR) en el nombre del POI (ej: provincia, poblacin, tipo).
                Los filtros de Lat/Lon pueden ser un valor nico (aprox.) o un rango (ej: "<code>40.1 40.5</code>" para buscar entre esas latitudes). Si un filtro est vaco, no se aplica.
            </p>
             <p style="font-size:0.85rem; color:#444; margin-bottom:1rem;">
                 Los POIs importados (RADARES) se guardarn con un radio de <strong>400 metros</strong> y excluidos de la lista por defecto.
             </p>
            <p style="font-size:0.85rem; color:#444; margin-bottom:1.5rem;">
                Para <strong>borrar</strong>: Si NO se especifica NINGN filtro, se borrarn TODOS los recordatorios de tipo "RADAR:" o excluidos de lista. Si se especifica algn filtro, se borrarn los que cumplan TODAS las condiciones activas (Palabras Clave OR, Latitud Y Longitud).
            </p>
            <div class="radar-filter-group">
                <div>
                    <label for="radar-filter-lat">Latitud (valor o "min max"):</label>
                    <input type="text" id="radar-filter-lat" placeholder="Ej: 40.123 o 40.0 40.5">
                </div>
                <div>
                    <label for="radar-filter-lon">Longitud (valor o "min max"):</label>
                    <input type="text" id="radar-filter-lon" placeholder="Ej: -3.567 o -4.0 -3.0">
                </div>
                <div style="grid-column: span 2;">
                    <label for="radar-filter-keywords">Palabras Clave (en nombre POI, separadas por espacio, condicin OR):</label>
                    <input type="text" id="radar-filter-keywords" placeholder="Ej: FIJO CAMUFLADO MADRID">
                </div>
            </div>
            <div class="radar-import-options">
                <input type="checkbox" id="import-extra-radars-checkbox">
                <label for="import-extra-radars-checkbox">Importar tambin radares mviles, semforo, etc (usa ficheros KLM adicionales)</label>
            </div>
             <div id="radar-import-progress-container" style="display:none;">
                 <progress id="radar-import-progress-bar" value="0" max="100"></progress>
                 <p id="radar-import-status" class="status-message"></p>
             </div>
         </div>
        <div id="tab-content-backup-restore" class="config-tab-content">
            <h3>Recuperar Backup / Hacer Copia en la Nube</h3>
            <p style="margin-bottom:1.2rem;">
                Para <strong>Recuperar</strong>, introduce tu ID de usuario y pulsa el botn naranja.<br>
                Para <strong>Hacer una Copia de Seguridad</strong>, asegrate de que tu ID est introducido en la pestaa "Usuario" y pulsa el botn verde.
            </p>
            
            <div class="user-data-grid" style="grid-template-columns: 1fr auto; align-items: end; gap: 1rem;">
                <div style="grid-column: 1 / 2;">
                    <label for="restore-user-id">ID Usuario a recuperar:</label>
                    <input type="text" id="restore-user-id" placeholder="Tu apodo nico (el que est en la pestaa usuario)...">
                </div>
                <div style="grid-column: 2 / 3; display: flex; flex-direction: column; gap: 0.5rem;">
                    <button id="config-restore-backup-firebase" style="background-color:#E65100;color:white;width:100%;padding: 0.6rem 1rem;">Recuperar Backup de la nube</button>
                    <button id="config-save-user-firebase-from-backup-tab" style="background-color:#16A34A;color:white;width:100%;padding: 0.6rem 1rem;">Hacer la copia de seguridad en la nube</button>
                </div>
            </div>
            <p id="config-restore-status" class="status-message"></p>
            <hr style="margin: 2rem 0;">
            <h3>Backup/Restore Local (Manual)</h3>
            <p style="font-size:.85rem; color:#555;">Esto es para copias manuales de texto. No interacta con la nube</p>
            <div class="backup-restore-container" style="margin-top:1rem;">
                 <div>
                    <h4>Crear Backup Local</h4>
                     <button id="config-generate-backup" style="background-color:#2563EB;color:white; margin-bottom: 1rem;">Generar Cdigo</button>
                    <textarea id="config-backup-display" readonly style="display:none;"></textarea>
                    <p id="config-backup-status" class="status-message"></p>
                </div>
                <div>
                    <h4>Restaurar Copia Local</h4>
                    <button id="config-restore-backup" style="background-color:#10B981;color:white; margin-bottom: 1rem;">Restaurar</button>
                    <textarea id="config-restore-input" placeholder="Pega el cdigo de backup local aqu..."></textarea>
                </div>
            </div>
        </div>
        
        <div id="tab-content-borrar" class="config-tab-content borrar-container">
            <h3>Borrar Datos Locales</h3>
             <button id="config-restore-grid-button">RESTAURAR EL GRID ORIGINAL DE BOTONES</button>
             <p id="config-restore-grid-status" class="status-message" style="margin-bottom: 1.5rem;"></p>
            <h3 style="border-top: 1px solid #ccc; padding-top: 1.5rem; margin-top:1.5rem;">Accin Irreversible</h3>
            <button id="config-clear-cache" style="margin-bottom: 0.5rem;">Borrar TODO</button>
            <p>Elimina TODOS los datos locales.</p>
            <p><strong style="color:red;">Sin deshacer!</strong> Ten backup.</p>
        </div>
    </div>
</div>
<div id="simulation-modal" class="hidden">
</div>

<div id="simulation-speed-modal" class="hidden">
</div>

<div id="locations-preview-modal" class="hidden">
    <h2 id="locations-preview-title">Ubicaciones (filtrado segn tabla)</h2>
    <div id="locations-preview-map-container" style="height: calc(100% - 100px); width: 100%;"></div>
    <div class="modal-top-buttons" style="justify-content: center; margin-top: 1rem;">
        <button id="close-locations-preview">Salir</button>
    </div>
</div>

<div id="address-suggestions-modal" class="hidden">
    <h2 id="address-suggestions-title">Sugerencias de Direccin</h2>
    <ul id="address-suggestions-list"></ul>
    <div class="modal-top-buttons" style="justify-content: flex-end; margin-top: 1rem;">
        <button id="close-address-suggestions-modal" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
    </div>
</div>

<div id="deviation-modal" class="hidden">
</div>

<div id="arrival-stats-modal" class="hidden">
</div>

<div id="intersection-preview-map-window" class="hidden">
    <div id="intersection-preview-map-container"></div>
</div>

<div id="alert-modal-overlay" class="hidden">
    <div id="alert-modal-content">
        <!-- Las opciones se generarn dinmicamente con JavaScript -->
    </div>
</div>

<div id="proximity-alert-modal" class="hidden">
    <!-- El contenido se generar dinmicamente con JavaScript -->
</div>

<div id="flashing-border-overlay" class="hidden"></div>
    
<script>
    const originalToFixed = Number.prototype.toFixed;
    Number.prototype.toFixed = function(digits) {
        if (this === undefined || this === null || isNaN(this)) {
            try {
                throw new Error("Debug toFixed Call");
            } catch (e) {
            }
            return "NaN";
        }
        return originalToFixed.call(this, digits);
    };

   const OCM_API_KEY = "be9a78f7-0f5e-4f28-b742-4b7ab4b7eb5a";
    
   let chargingPointsLayer = null;
   let currentChargingPointsOnRoute = [];
 
    let trafficAlertsCache = [];
    let trafficAlertsLayer = null;
    let lastAlertCheckTimestamp = 0;
    const ALERT_CHECK_INTERVAL = 15 * 60 * 1000;
    let currentlyDisplayedProximityAlerts = new Set();
    let alertModalTimer = null;
    let proximityAlertTimer = null;

    let tripStartLocationForStats = null; // Guardar la ubicacin al pulsar "Iniciar Navegacin"
    
    let stageScrollTimeout;
    let locationsPreviewMap = null;
    let globalModalTimers = {};
    const originalBookmarks = [ { name: "YouTube", url: "https://www.youtube.com" }, { name: "Google", url: "https://www.google.com" }, { name: "GDrive", url: "https://drive.google.com", favicon: "./IMG_4172.png" }, { name: "GMail", url: "https://mail.google.com/mail/mu/mp/603/#tl/Recibidos", favicon: "./IMG_4171.png"}, { name: "Google Fotos", url: "https://photos.google.com" }, { name: "iCloud", url: "https://www.icloud.com/", favicon: "https://www.google.com/s2/favicons?domain=icloud.com&sz=64t" }, { name: "ABRP", url: "https://abetterrouteplanner.com" }, { name: "ElectroMaps", url: "https://map.electromaps.com/es/", favicon: "https://www.google.com/s2/favicons?domain=electromaps.com&sz=64" }, { name: "REVE PdR Espaa", url: "https://www.mapareve.es/mapa-puntos-recarga", favicon: "https://www.google.com/s2/favicons?domain=mapareve.es&sz=64" }, { name: "Ver ubicaciones", url: "map-action:openRemindersMapWithNoRadars", favicon: "https://www.google.com/s2/favicons?domain=google.com/maps&sz=64" }, { name: "Google Maps", url: "https://maps.google.com" }, { name: "WhatsApp", url: "https://web.whatsapp.com/" }, { name: "TESSIE", url: "https://dash.tessie.com/signin", favicon: "https://www.google.com/s2/favicons?domain=tessie.com&sz=64" }, { name: "Mis Updates", url: "https://dash.tessie.com/software", favicon: "https://cdn-icons-png.flaticon.com/512/148/148767.png" }, { name: "Olas Updates", url: "https://es.stats.tessie.com/", favicon: "https://cdn-icons-png.flaticon.com/512/5815/5815902.png" }, { name: "NotaTeslaApp", url: "https://www.notateslaapp.com/software-updates/" }, { name: "ENHAUTO", url: "https://www.enhauto.com" }, { name: "MAREAS", url: "https://www.meteogalicia.gal/web/predicion/mareas-e-luas" }, { name: "ELECTROVERSE", url: "https://electroverse.com/es/map", favicon: "https://www.google.com/s2/favicons?domain=electroverse.com&sz=64" }, { name: "ACCIONA", url: "https://www.google.com/maps/search/recarga+Acciona", favicon: "https://www.google.com/s2/favicons?domain=acciona.com&sz=64" }, { name: "IBERDROLA", url: "https://www.google.com/maps/search/recarga+IBERDROLA", favicon: "https://www.google.com/s2/favicons?domain=iberdrola.com&sz=64" }, { name: "WAYLET Repsol", url: "https://www.google.com/maps/search/recarga+REPSOL+Waylet", favicon: "https://www.google.com/s2/favicons?domain=repsol.com&sz=64" }, { name: "ENDESA xWay", url: "https://www.google.com/maps/search/recarga+ENDESA+XWAY", favicon: "https://www.google.com/s2/favicons?domain=endesa.com&sz=64" }, { name: "ZUNDER", url: "https://www.google.com/maps/search/recarga+ZUNDER", favicon: "https://www.google.com/s2/favicons?domain=zunder.com&sz=64" }, { name: "IONITY", url: "https://www.google.com/maps/search/recarga+IONITY", favicon: "https://www.google.com/s2/favicons?domain=ionity.eu&sz=64" }, { name: "WENEA", url: "https://www.google.com/maps/search/recarga+WENEA", favicon: "https://www.google.com/s2/favicons?domain=wenea.com&sz=64" }, { name: "T.ENERGIES", url: "https://www.google.com/maps/search/recarga+TOTAL+ENERGIES", favicon: "https://www.google.com/s2/favicons?domain=totalenergies.com&sz=64" }, { name: "GALP", url: "https://www.google.com/maps/search/recarga+GALP", favicon: "https://www.google.com/s2/favicons?domain=galp.com&sz=64" }, { name: "MIIO", url: "https://miio.com", favicon: "https://www.google.com/s2/favicons?domain=miio.com&sz=64" }, { name: "EVDC", url: "https://evdc.network", favicon: "https://www.google.com/s2/favicons?domain=evdc.network&sz=64" }, { name: "GROK", url: "https://grok.com/?referrer=website" }, { name: "CHATGPT", url: "https://chat.openai.com" }, { name: "CLAUDE", url: "https://claude.ai/new" }, { name: "GEMINI", url: "https://gemini.google.com" }, { name: "NOTEBOOKLM", url: "https://notebooklm.google.com" }, { name: "Batera", url: "https://docs.google.com/spreadsheets/d/1bLZmgVGTBqg2bS2E45JpORjs9eK2nb05AWXYLLDY-RI/edit?gid=1398548891#gid=1398548891", favicon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='10'/><polyline points='12 6 12 12 16 14'/></svg>" }, { name: "TeslaParaTodos", url: "https://teslaparatodos.com/cine/" }, { name: "BetterTheater", url: "https://abettertheater.com", favicon: "https://www.google.com/s2/favicons?domain=abettertheater.com&sz=64" }, { name: "Filmin", url: "https://www.filmin.es/catalogo/peliculas" }, { name: "Octopus", url: "https://octopusenergy.es/login" }, { name: "App MCE", url: "https://www.oscarabilleira.com/app-mi-coche-electrico/#ayuda" }, { name: "Patrn Luz", url: "https://docs.google.com/spreadsheets/d/1R7UUZ9i4BAYWAGAX6PQT1WGd12GEZ4Ja/edit?usp=sharing&ouid=108345701896498198132&rtpof=true&sd=true" }, { name: "TradingView", url: "https://es.tradingview.com/chart/t5g9UFG0/" }, { name: "Telegram", url: "https://web.telegram.org/a/" }, { name: "Twitter", url: "https://x.com" }, { name: "Maesal Detailer", url: "https://www.maesaldetailer.es/" }, { name: "Superchargers", url: "https://www.tesla.com/es_es/findus?bounds=45.41107111786193%2C19.27853056943938%2C29.703668286784747%2C-16.64676239931062" }, { name: "TESLA web", url: "https://www.tesla.com/es_es" }, { name: "Manual M3", url: "https://www.tesla.com/ownersmanual/model3/es_es/" }, { name: "de Servicio", url: "https://service.tesla.com/docs/Model3/ServiceManual/2024/es-es/" }, { name: "de Despiece", url: "https://epc.tesla.com/es-MX/catalogs/e0e07c3d-272f-4d06-b8b6-9e92f857e5f3" }, { name: "de Usted Mismo", url: "https://www.tesla.com/es_es/support/do-it-yourself-guides" }, { name: "de Filtro Cabina", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-DB0A1E3C-926E-498C-A2FD-A27B8421A471.html" }, { name: "de Mvil remoto", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-53651B16-A2E3-4118-933E-B5F41C74D433.html" }, { name: "Waze (consultas)", url: "https://www.waze.com/es/live-map/", favicon: "https://www.google.com/s2/favicons?domain=waze.com&sz=64" }, { name: "AMAZON", url: "https://www.amazon.es" }, { name: "BIP&DRIVE", url: "https://areaprivada.bipdrive.com/login" }, { name: "ITV Cita", url: "https://www.sycitv.com/es/cita-previa-particulares/", favicon: "https://boardinggate.github.io/Tesla/itv.png" }, { name: "Deportes", url: "https://www.sofascore.com/es/tenis" }, null, { name: "Jaime Odena", url: "https://www.youtube.com/@Jaimeodena", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Eduardo Arcos", url: "https://www.youtube.com/@earcos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "AutoIngenium", url: "https://www.youtube.com/@AutoIngenium", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Gallego en Munich", url: "https://www.youtube.com/@ungallegoenmunich", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Electromiaumiau", url: "https://www.youtube.com/@electromiaumiau", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Manuel Martos", url: "https://www.youtube.com/@Manuel_Martos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Todos Electricos", url: "https://www.youtube.com/@TodosElectricos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Juan Vidal Haces", url: "https://www.youtube.com/@JuanVidalHaces", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Ruedana", url: "https://www.youtube.com/@ruedana", favicon: "https://www.youtube.com/favicon.ico" }, { name: "STR-600", url: "https://www.youtube.com/@STR-600", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Juanjo T. Aventuras", url: "https://www.youtube.com/@juanjoteslaventuras", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Carlos Cuezva", url: "https://www.youtube.com/@CarlosCuezva", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Javi Manzanoo", url: "https://www.youtube.com/@javimanzanoo", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Crifedi", url: "https://www.youtube.com/@Crifedi", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Tescno Tesla", url: "https://www.youtube.com/@TecnoTesla", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Full Electric Mex", url: "https://www.youtube.com/@FullElectricMexico", favicon: "https://www.youtube.com/favicon.ico" }, null, null, { name: "La iA Jon", url: "https://www.youtube.com/@la_inteligencia_artificial", favicon: "https://www.youtube.com/favicon.ico" }, { name: "JF Ccalero", url: "https://www.youtube.com/@jfcalero", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Visual Politik", url: "https://www.youtube.com/@VisualPolitik", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Fabian Barrio", url: "https://www.youtube.com/@fabiancbarrio", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Loquetudigas", url: "https://www.youtube.com/@Loquetudigas", favicon: "https://www.youtube.com/favicon.ico" }, { name: "David Antunes", url: "https://www.youtube.com/@davidantunesmusic", favicon: "https://www.youtube.com/favicon.ico" }, { name: "TheWildProject", url: "https://www.youtube.com/@TheWildProject", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Estas Tonne", url: "https://www.youtube.com/@Estastonne", favicon: "https://www.youtube.com/favicon.ico" }, { name: "BBC6 Music", url: "https://www.youtube.com/@BBC6Music", favicon: "https://www.youtube.com/favicon.ico" }, null, null ];
    const originalToggleRanges = [ { start: 18, end: 29, name: "ELECTROVERSE", label: "PdR,s" }, { start: 30, end: 41, name: "GROK", label: "iAs" }, { start: 42, end: 59, name: "TradingView", label: "til" }, { start: 60, end: 95, name: "Jaimeodena", label: "Varios" } ];
    const sectionColors = { 18: '#F0E0D3', 30: '#D8D4E0', 42: '#D9E5DB', 60: '#F2ECD0', unassigned: '#C5C8B8', off: '#ABAB99' };
    const darkModeGenericButtonColor = '#ABAB99';
    const DEFAULT_LOCATION_RADIUS = 450;
    let snoozedRouteRadars = new Map();
    const MAP_SEARCH_INPUT_KEY = 'boardinggate_map_search_value';
    let gpsRetryTimeoutId = null;
    let gpsRetryAttempt = 0;
    const MAX_GPS_RETRIES = 10;
    const GPS_RETRY_DELAY_MS = 5000;
    let isMapImmersiveModeActive = false;
    let isArrivalSequenceStarted = false;
    let maxSpeedCoordinates = null;
    let progressiveZoomState = 'none';
    let mapPreviousZoomLevelForProgressive = null;
    let lastProcessedStepIdentifier = null;
    const PROGRESSIVE_ZOOM_START_DISTANCE = 180;
    const PROGRESSIVE_ZOOM_PEAK_DISTANCE = 50;
    const PROGRESSIVE_ZOOM_EXIT_START_DISTANCE = 60;
    const PROGRESSIVE_ZOOM_EXIT_END_DISTANCE = 150;
    let isZoomedForManeuver = false;
    let isFlying = false;
    let navigationTargetZoom = null;
    let currentSmoothedMapCenter = null;
    let lastMobileSyncTimestamp = 0;
    const TOTAL_CELLS = 96; const COLS = 6; const grid = document.getElementById('bookmark-grid');
    let isDarkMode = false; let pressStartTime = null; let reminderPressStartTime = null; let isActive = true; let isFooterVisible = true; let notices = []; let currentNoticeIndex = 0; let fromReminderModal = false;
    let isEditMode = false; let isAssignmentMode = false;
    let isKeywordAssignmentMode = false;
    let currentlyAssigningToggleStart = null;
    let customData = { bookmarks: {}, toggles: {} };
    let cellElements = []; let toggleButtonElements = {}; let currentBookmarks = []; let currentToggleRanges = [];
    let onOffToggle, weatherButton, reminderButton, zoomButton, darkModeToggle, versionsButton, infoButton;
    let radarButton;
    let initialUserLocationCircle = null;
    let firstPersonalizationSession = !sessionStorage.getItem('personalizationHelpShown');
    let editingTargetElement = null; let draggedItem = null; let draggedItemIndex = null; let dragOverIndex = null;
    let touchStartX = 0; let touchStartY = 0; let currentTouchTarget = null;
    let isPasswordActive = false; let storedPin = null;
    let reminderCheckIntervalId = null;
    let currentCheckIntervalDuration = 3000;
    let lastUpdatesCheckDate = localStorage.getItem('lastUpdatesCheckDate');
    let currentNotificationSlideIndex = 0;
    let isUnifiedWindowVisibleByLogic = false;
    let reminderModalMap = null;
    let reminderMarker = null;
    let reminderCircle = null;
    let previewMaps = {};
    const MAX_SAVED_LOCATIONS = 15;
    const SAVED_LOCATIONS_KEY = 'boardinggate_saved_locations';
    const SHOW_EXCLUDED_REMINDERS_KEY = 'boardinggate_showExcludedRemindersInTable';
    const RADARES_RUTA_CHECKED_KEY = 'boardinggate_radaresRutaCheckboxChecked';
    const TAREAS_RUTA_CHECKED_KEY = 'boardinggate_tareasRutaCheckboxChecked';
    const ACTIVE_MAP_LAYER_KEY = 'boardinggate_activeMapLayer';
    const DIRECT_TO_NAVIGATION_KEY = 'boardinggate_directToNavigation';
    const MAP_ENTRY_OVERRIDE_KEY = 'boardinggate_map_entry_override';
    const TEMP_PREVENT_DIRECT_NAV_KEY = 'tempPreventDirectNavAfterMapExit';
    const GRAPH_STATE_KEY = 'boardinggate_graphState';
    let locationPickerMap = null;
    let locationPickerMarker = null;
    let currentEditingLocationSlotIndex = -1;
    let tempSavedLocations = [];
    let navigationMapInstance = null;
    let isNavigationMapActive = false;
    let completedRouteSegmentsLayer = null;
    let initialUserLocationMarker = null;
    let initialUserLocationMarkerLat = null;
    let initialUserLocationMarkerLng = null;
    let navigationCurrentLocation = null;
    let locationWatchId = null;
    let shouldCenterOnUser = false;
    let navigationFollowUser = false;
    let mapPreviousZoomLevel = null;
    const MIN_MANEUVER_ZOOM_LEVEL = 17;
    let currentMapBearing = 0;
    let currentMapRotationAngle = 0;
    let currentMapCenterOffset = { x: 0, y: 0 };
    let targetMapCenterOffset = { x: 0, y: 0 };
    let mapOffsetAnimationId = null;
    let miniMapOffsetActive = { x: 0, y: 0 };
    let lastHeadingForTilt = 0;
    let compassAndModeControl = null;
    let navigationWaypoints = [];
    let navigationRouteLayer = null;
    let navigationCurrentRouteData = null;
    let isNavigating = false;
    let routeStartTime = null;
    let navigationStartTimeForStats = null;
    let totalDistanceTravelledForStats = 0;
    let accumulatedDistanceBeforeCurrentSegment = 0;
    let lastPositionForStats = null;
    let maxDistanceReachedOnRoute = 0; 
    let maxSpeedDuringTrip = 0;
    let maxAltitudeDuringTrip = -Infinity;
    let minAltitudeDuringTrip = Infinity;
    window.lastPositionForSpeedCalc = null;
    window.currentSpeedKmh = 0;
    window.averageSpeedKmh = 0;
    let isSimulatingGpsLocation = false;
    let simulatedGpsLocation = null;
    let automatedSimulationIntervalId = null;
    let simulatedDistanceAlongRoute = 0;
    let simulationSpeedKmph = 85;
    let currentSimulationSpeedKmph = 85; 
    const SIMULATION_TICK_INTERVAL_MS = 300;
    let maxSpeedMarkerLayer = null; 
    let speedMilestoneLayer = null;
    let lastSpeedMilestone = 0;
    const SPEED_MILESTONES = [50, 60, 80, 100, 110, 120, 130, 150];
    const OSRM_SERVICE_URL = 'https://router.project-osrm.org/route/v1';
    const SAVED_ROUTES_KEY = 'boardinggate_saved_routes';
    const MAX_SAVED_ROUTES = 100;
    let currentRouteNameForSaving = null;
    let navigationMapClickHandler = null;
    let draggedStageLi = null;
    const DEVIATION_THRESHOLD_METERS = 100;
    const DEVIATION_MIN_TIME_SECONDS = 5;
    let deviationStartTime = 0;
    let isRecalculatingRoute = false;
    let deviationModalTimerId = null;
    let isDeviationModalActive = false;
    const WAYPOINT_VISITED_THRESHOLD_METERS = 100;
    let currentLegIndexNav = 0;
    let currentStepIndexNav = 0;
    let lastCarDistanceAlongRouteForNavLogic = 0;
    let lastValidCarDistanceForDisplay = 0;
    let lastProcessedStepManeuverLocation = null;
    let recalculationRetryTimeoutId = null;
    let recalculationAttempts = 0;
    let isAddReminderAtLocationModeActive = false;
    let addReminderAtLocationButton = null;
    let simulationModalTimer = null;
    let autoStartNavTimer = null;
    let mapLayersControl = null;
    let searchToastShown = false;
    let pendingPositionToProcess = null;
    const KML_FILES_LIST_STANDARD = './KLM/KLMFILES.TXT';
    const KML_FILES_LIST_EXTRA = './KLM/KLMFILES2.TXT';
    const KML_BASE_PATH = './KLM/';
    const COORD_EPSILON = 0.00001;
    const RUTA_RADAR_PROXIMITY_THRESHOLD = 75;
    let reminderMapObjects = [];
    let radaresEnRutaActual = [];
    let tareasEnRutaActual = [];
    const STATIC_MODAL_IDS = ['config-modal', 'versions-modal-overlay', 'pin-modal-overlay', 'reorder-stages-modal', 'simulation-modal', 'locations-preview-modal', 'address-suggestions-modal', 'deviation-modal', 'arrival-stats-modal', 'simulation-speed-modal'];
    let activeToasts = [];
    let intersectionPreviewMap = null;
    let intersectionPreviewRouteLayer = null;
    let intersectionPreviewManeuverMarker = null;
    let intersectionPreviewCarMarker = null;
    let intersectionPreviewTimer = null;
    let lastAutoShownManeuverId = null;
    let directToNavOnLoad = false;
    let mapLayersControlReminder = null;
    let mapLayersControlLocationsPreview = null;
    let directionCardDerecha = null;
    let directionCardIzquierda = null;
    let navigationChart = null;
    let currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviacin Ruta';
    let graphPlotState = { lastPlotTime: null, lastPlotCoords: null };
    let graphIntervalDuration = 0; 
    let graphIntervalTimer = null;
    let graphDataPoints = { speed: [], altitude: [] };
    let graphLabels = [];
    let graphExpectedAvgSpeed = 0;
    let isCarStoppedForGraph = false; 
    const GRAPH_PIXELS_PER_DATAPOINT = 2; 
    const GRAPH_BUFFER_PERCENTAGE = 0.15;
    const managedKeys = [ 'reminders','darkMode','toggleStates','zoomState','onOffState','noticesActive', 'footerVisible','teslaHtmlLastModified','teslaHtmlLastModifiedTimestamp', 'userData_userId','userData_teslaModel','userData_teslaYear','userData_teslaProvince', 'userData_allowDMs', 'customGridData', 'personalizationHelpShown', 'gridFilterValue',  'password_pin', 'password_active', 'lastUpdatesCheckDate', SAVED_LOCATIONS_KEY,  SHOW_EXCLUDED_REMINDERS_KEY, SAVED_ROUTES_KEY, RADARES_RUTA_CHECKED_KEY,  TAREAS_RUTA_CHECKED_KEY, ACTIVE_MAP_LAYER_KEY, DIRECT_TO_NAVIGATION_KEY, GRAPH_STATE_KEY, 'boardinggate_autoBackupOnLoad', 'userData_backupPassword', MAP_SEARCH_INPUT_KEY ];
    const MAP_FILTER_INPUT_KEY = 'boardinggate_map_filter_value';
    const managedDesc = managedKeys.map(k => {
            switch(k){
                case 'reminders':return 'Recordatorios'; case 'darkMode':return 'Modo Oscuro'; case 'toggleStates':return 'Visibilidad Secc.';
                case 'zoomState':return 'Zoom Grid'; case 'onOffState':return 'On/Off Gral'; case 'noticesActive':return 'Avisos/Footer';
                case 'footerVisible':return 'Vis. Footer'; case 'teslaHtmlLastModified':return 'Cache Versin'; case 'teslaHtmlLastModifiedTimestamp':return 'TS Cache';
                case 'userData_userId':return 'ID Usuario'; case 'userData_teslaModel':return 'Modelo'; case 'userData_teslaYear':return 'Ao';
                case 'userData_teslaProvince':return 'Provincia'; case 'userData_allowDMs':return 'Permitir DMs'; case 'customGridData': return 'Grid Pers.';
                case 'personalizationHelpShown': return 'Ayuda Pers. Vista'; case 'gridFilterValue': return 'Filtro Grid';
                case 'password_pin': return 'PIN Acceso'; case 'password_active': return 'PIN Activo'; case 'lastUpdatesCheckDate': return 'Cache Fecha Updates';
                case SAVED_LOCATIONS_KEY: return 'Ubicaciones Guardadas';
                case SHOW_EXCLUDED_REMINDERS_KEY: return 'Mostrar Excluidos Tabla';
                case SAVED_ROUTES_KEY: return 'Rutas Guardadas';
                case RADARES_RUTA_CHECKED_KEY: return 'Check Radares Ruta';
                case TAREAS_RUTA_CHECKED_KEY: return 'Check Tareas Ruta';
                case ACTIVE_MAP_LAYER_KEY: return 'Capa de Mapa Activa';
                case DIRECT_TO_NAVIGATION_KEY: return 'Directo a Navegacin';
                case GRAPH_STATE_KEY: return 'Estado Grfica';
                case MAP_SEARCH_INPUT_KEY: return 'Buscador Mapa (Principal)';
                case MAP_FILTER_INPUT_KEY: return 'Buscador Mapa (Filtro)';
                default:return k;
            }
        }).join(', ');
    const vehicleIcon = L.divIcon({
        html: `<div id="vehicle-icon-wrapper"><img src="AVANCE.PNG" alt="Coche"></div>`,
        className: 'vehicle-icon-leaflet-container',
        iconSize: [48, 48],
        iconAnchor: [24, 24]
    });
    const vehicleIconMiniMap = L.divIcon({
        html: `<div class="vehicle-icon-minimap"><img src="AVANCE.PNG" alt="Coche Mini"></div>`,
        className: 'vehicle-icon-minimap-leaflet-container',
        iconSize: [24, 24],
        iconAnchor: [12, 12]
    });
    const smallRadarMarkerIcon = L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-violet.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [13, 21], iconAnchor: [6, 21], popupAnchor: [1, -18], shadowSize: [21, 21]
    });
    const largeGreenLocationMarkerIcon = L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [17, 28], iconAnchor: [8, 28], popupAnchor: [1, -24], shadowSize: [28, 28]
    });
    const defaultLocationMarkerIconBlue = L.icon({ iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png', shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png', iconSize: [15, 25], iconAnchor: [7, 25], popupAnchor: [1, -20], shadowSize: [25, 25] });
    const maneuverTexts = { 'turn-sharp right': 'Giro brusco a la derecha', 'turn-right': 'Gira a la derecha', 'bear-right': 'Mantente a la derecha', 'turn-sharp left': 'Giro brusco a la izquierda', 'turn-left': 'Gira a la izquierda', 'bear-left': 'Mantente a la izquierda', 'turn-': 'Gira', 'straight-straight': 'Sigue recto', 'straight-': 'Sigue recto', 'roundabout-': 'Entra en la rotonda', 'roundabout turn-': 'Toma la salida de la rotonda', 'rotary-': 'Entra en la glorieta', 'roundabout turn-left': 'En la rotonda, toma la salida hacia la izquierda', 'roundabout turn-right': 'En la rotonda, toma la salida hacia la derecha', 'roundabout turn-straight': 'En la rotonda, sigue recto', 'destination-left': 'Has llegado a tu destino  (a la izquierda)', 'destination-right': 'Has llegado a tu destino (a la derecha)', 'destination-': ' tu destino ', 'depart-': 'Inicia la ruta', 'arrive-left': 'Has llegado a tu destino (a la izquierda)', 'arrive-right': 'Has llegado a tu destino  (a la derecha)', 'arrive-': 'Has llegado a tu destino', 'continue-straight': 'Contina recto', 'continue-': 'Contina', 'new name-': 'Contina por', 'fork-right': 'En la bifurcacin, mantente a la derecha', 'fork-left': 'En la bifurcacin, mantente a la izquierda', 'fork-': 'En la bifurcacin', 'merge-left': 'Incorprate por la izquierda', 'merge-right': 'Incorprate por la derecha', 'merge-straight': 'Incorprate', 'merge-': 'Incorprate', 'end of road-left': 'Al final de la va, gira a la izquierda', 'end of road-right': 'Al final de la va, gira a la derecha', 'end of road-': 'Fin de la va', 'u turn-left': 'Haz un cambio de sentido (hacia la izquierda)', 'u turn-right': 'Haz un cambio de sentido (hacia la derecha)', 'u turn-': 'Haz un cambio de sentido', 'use lane-': 'Usa el carril indicado', 'notification-': 'Atencin', 'exit roundabout-': 'Sal de la rotonda', 'exit rotary-': 'Sal de la glorieta', 'off ramp-': 'Va de salida', 'on ramp-': 'Incorporate a la va de Entrada',};
    const SMOOTH_ZOOM_DURATION = 5.0;

    let lastPreciseRecalcTime = 0;
    const PRECISE_RECALC_INTERVAL = 120000;
    let distanceToNextManeuverOSRM = Infinity;
 
    let mapHeaderButtonsVisible = true;
    let mapHeaderToggleDragStartPos = null;
    let mapHeaderToggleIsDragging = false;
   
    





// ===================================================================
// NOMBRE: showPDRsFilterModal
// RESUMEN: Muestra el modal para filtrar los puntos de recarga (con atribucin a OCM y corregido para aparecer sobre el mapa).
// ===================================================================
function showPDRsFilterModal() {
    if (!navigationRouteLayer) {
        showToast("Primero debe calcular una ruta para buscar puntos de carga.", "warning");
        return;
    }

    const mapContainer = document.getElementById('reminders-location-map-modal');
    if (!mapContainer) {
        showToast("El mapa de navegacin debe estar abierto para usar los filtros.", "error");
        return;
    }

    const existingModal = document.getElementById('pdrs-filter-modal-overlay');
    if (existingModal) existingModal.remove();

    const modalOverlay = document.createElement('div');
    modalOverlay.id = 'pdrs-filter-modal-overlay';
    modalOverlay.className = 'filter-modal-overlay';
    modalOverlay.innerHTML = `
        <div class="filter-modal-content">
            <h2>FILTRO PUNTOS DE CARGA</h2>
            
            <div class="filter-group">
                <label id="power-range-label">Potencia: 30 kW - 600 kW</label>
                <div class="slider-container">
                    <div class="slider-track"></div>
                    <div class="slider-range" id="power-slider-range"></div>
                    <div class="slider-thumb left" id="power-thumb-min"></div>
                    <div class="slider-thumb right" id="power-thumb-max"></div>
                </div>
            </div>

            <div class="filter-group">
                <label id="distance-range-label">Distancia Mxima a la Ruta: 20 km</label>
                <div class="slider-container">
                    <div class="slider-track"></div>
                    <div class="slider-range" id="distance-slider-range"></div>
                    <div class="slider-thumb left" id="distance-thumb-max"></div>
                </div>
            </div>
            
            <button id="accept-filters-btn">Aceptar</button>
            <p style="font-size:0.9rem; color:#444; margin-top:20px; font-weight: bold; border-top: 1px solid #ccc; padding-top: 10px;">
                Datos proporcionados por <a href="https://openchargemap.org" target="_blank" style="color:#0056b3; text-decoration:underline;">Open Charge Map</a>
            </p>
        </div>
    `;

    mapContainer.appendChild(modalOverlay);

    const setupSlider = (idPrefix, minVal, maxVal, defaultMin, defaultMax, unit, isRange = true) => {
        const container = document.querySelector(`#${idPrefix}-thumb-max`).parentElement;
        const range = document.getElementById(`${idPrefix}-slider-range`);
        const thumbMax = document.getElementById(`${idPrefix}-thumb-max`);
        const label = document.getElementById(`${idPrefix}-range-label`);
        const thumbMin = isRange ? document.getElementById(`${idPrefix}-thumb-min`) : null;

        let currentMin = defaultMin;
        let currentMax = defaultMax;

        const updateVisuals = () => {
            const minPercent = isRange ? ((currentMin - minVal) / (maxVal - minVal)) * 100 : 0;
            const maxPercent = ((currentMax - minVal) / (maxVal - minVal)) * 100;
            
            if (isRange && thumbMin) thumbMin.style.left = `${minPercent}%`;
            thumbMax.style.left = `${maxPercent}%`;
            range.style.left = `${minPercent}%`;
            range.style.width = `${maxPercent - minPercent}%`;
            
            if(isRange){
                label.textContent = `Potencia: ${Math.round(currentMin)} ${unit} - ${Math.round(currentMax)} ${unit}`;
            } else {
                label.textContent = `Distancia Mxima a la Ruta: ${Math.round(currentMax)} ${unit}`;
            }
        };

        const onDrag = (e, thumb) => {
            const rect = container.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let percent = ((clientX - rect.left) / rect.width) * 100;
            percent = Math.max(0, Math.min(100, percent));
            
            let value = minVal + (percent / 100) * (maxVal - minVal);
            
            if (isRange && thumb === thumbMin) {
                currentMin = Math.min(value, currentMax);
            } else {
                currentMax = isRange ? Math.max(value, currentMin) : value;
            }
            updateVisuals();
        };

        const thumbsToSetup = isRange ? [thumbMin, thumbMax] : [thumbMax];
        thumbsToSetup.forEach(thumb => {
            const startDrag = (e) => {
                const moveHandler = (moveEvent) => onDrag(moveEvent, thumb);
                const endDrag = () => {
                    document.removeEventListener('mousemove', moveHandler);
                    document.removeEventListener('mouseup', endDrag);
                    document.removeEventListener('touchmove', moveHandler);
                    document.removeEventListener('touchend', endDrag);
                };
                document.addEventListener('mousemove', moveHandler);
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchmove', moveHandler);
                document.addEventListener('touchend', endDrag);
            };
            thumb.addEventListener('mousedown', startDrag);
            thumb.addEventListener('touchstart', startDrag);
        });
        
        updateVisuals();
        return () => ({ min: isRange ? currentMin : 0, max: currentMax });
    };

    const getPowerValues = setupSlider('power', 7, 600, 30, 600, 'kW', true);
    const getDistanceValues = setupSlider('distance', 0, 50, 0, 20, 'km', false);

    document.getElementById('accept-filters-btn').addEventListener('click', () => {
        const powerFilters = getPowerValues();
        const distanceFilters = getDistanceValues();
        modalOverlay.remove();
        findChargingPointsOnRoute(powerFilters, distanceFilters);
    });
}



    



        


// ===================================================================
// NOMBRE: openAlertModal
// RESUMEN: Abre el modal para que el usuario seleccione una incidencia de trfico.
// ===================================================================
function openAlertModal() {
    const alertModalOverlay = document.getElementById('alert-modal-overlay');
    const alertModalContent = document.getElementById('alert-modal-content');
    if (!alertModalOverlay || !alertModalContent) return;

    // --- INICIO DE LA CORRECCIN ---
    // Se han intercambiado los cdigos 8 y 9 para que coincidan con la lgica de procesamiento.
    // "YA NO HAY NADA" debe tener el cdigo 9 para que funcione la eliminacin de alertas.
    const alertOptions = [
        { code: 1, text: 'ACCIDENTE TRFICO', icon: 'AACCIDENTE.png' },
        { code: 2, text: 'COCHE AVERIADO', icon: 'AAVERIADO.png' },
        { code: 3, text: 'CONTROL TRFICO / RADAR', icon: 'AGUARDIA.png' },
        { code: 4, text: 'ATASCO', icon: 'AATASCO.png' },
        { code: 5, text: 'PELIGRO INDETERMINADO', icon: 'APELIGRO.png' },
        { code: 6, text: 'CARRETERA MAL ESTADO', icon: 'ARESVALAR.png' },
        { code: 7, text: 'OBRAS', icon: 'AOBRAS.png' },
        { code: 8, text: 'VA / CARRETERA CERRADA', icon: 'ACERRADA.png' }, // <-- CDIGO CORREGIDO A 8
        { code: 9, text: 'YA NO HAY NADA', icon: 'AANULAR.png' }           // <-- CDIGO CORREGIDO A 9
    ];
    // --- FIN DE LA CORRECCIN ---

    alertModalContent.innerHTML = '<div id="alert-columns-container"></div>';
    const columnsContainer = document.getElementById('alert-columns-container');

    const column1 = document.createElement('div');
    column1.className = 'alert-column';
    const column2 = document.createElement('div');
    column2.className = 'alert-column';

    alertOptions.forEach((option, index) => {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'alert-option';
        optionDiv.onclick = () => sendTrafficAlert(option.code, option.text);
        optionDiv.innerHTML = `<img src="${option.icon}" alt="${option.text}"><span>${option.text}</span>`;

        if (index < 5) {
            column1.appendChild(optionDiv);
        } else {
            column2.appendChild(optionDiv);
        }
    });

    const cancelButton = document.createElement('div');
    cancelButton.id = 'alert-cancel-button';
    cancelButton.innerHTML = '<span>CANCELAR <span id="alert-timer">(10)</span></span>';
    cancelButton.onclick = closeAlertModal;
    column2.appendChild(cancelButton); // Aadimos el botn cancelar a la segunda columna

    columnsContainer.appendChild(column1);
    columnsContainer.appendChild(column2);

    alertModalOverlay.classList.remove('hidden');

    let countdown = 10;
    const timerSpan = document.getElementById('alert-timer');
    if (alertModalTimer) clearInterval(alertModalTimer);
    alertModalTimer = setInterval(() => {
        countdown--;
        if (timerSpan) timerSpan.textContent = `(${countdown})`;
        if (countdown <= 0) {
            closeAlertModal();
        }
    }, 1000);
}



// ===================================================================
// NOMBRE: formatOCMPoint
// RESUMEN: Convierte un punto de recarga del formato OCM a un formato interno estandarizado.
// ===================================================================
function formatOCMPoint(point) {
    if (!point || !point.AddressInfo) {
        return null;
    }

    let maxPower = 0;
    if (point.Connections && Array.isArray(point.Connections)) {
        point.Connections.forEach(conn => {
            if (conn.PowerKW && conn.PowerKW > maxPower) {
                maxPower = conn.PowerKW;
            }
        });
    }

    const totalPoints = point.NumberOfPoints || (point.Connections ? point.Connections.length : 0);
    const displayName = (point.OperatorInfo ? point.OperatorInfo.Title : point.AddressInfo.Title) || 'Desconocido';

    let priceText = ' (precio no disp.)';
    if (point.UsageCost) {
        const priceMatch = point.UsageCost.match(/(\d[\d,.]*)/);
        if (priceMatch && priceMatch[1]) {
            let priceNum = parseFloat(priceMatch[1].replace(',', '.'));
            if (!isNaN(priceNum) && priceNum > 0) {
                 priceText = ` | ~${priceNum.toFixed(2)}/kWh`;
            }
        }
    }

    return {
        lat: point.AddressInfo.Latitude,
        lon: point.AddressInfo.Longitude,
        address: point.AddressInfo.Title || 'Direccin no disponible',
        numPoints: totalPoints > 0 ? totalPoints : '?',
        priceForCard: priceText,
        fullPriceInfo: point.UsageCost || 'Consultar',
        power: maxPower > 0 ? maxPower.toFixed(0) : 'N/A',
        displayName: displayName,
        operator: point.OperatorInfo ? point.OperatorInfo.Title : 'No especificado',
        connections: point.Connections || []
    };
}
    




// ===================================================================
// NOMBRE: findChargingPointsOnRoute
// RESUMEN: Busca PDRs de OCM en la zona de la ruta y los filtra segn los criterios.
// ===================================================================
async function findChargingPointsOnRoute(powerFilters, distanceFilters) {
    showToast("Buscando puntos de recarga en ruta (OCM)...", "info", 0, false, "pdrs-search");
    clearChargingPoints();

    if (!navigationRouteLayer) {
        showToast("Primero debe calcular una ruta.", "warning");
        return;
    }

    try {
        const bounds = navigationRouteLayer.getBounds();
        const northWest = bounds.getNorthWest();
        const southEast = bounds.getSouthEast();

        const apiUrl = `https://api.openchargemap.io/v3/poi/?output=json&key=${OCM_API_KEY}&countrycode=ES&boundingbox=(${northWest.lat},${northWest.lng}),(${southEast.lat},${southEast.lng})&maxresults=1500&compact=true&verbose=false`;

        const response = await fetch(apiUrl);
        if (!response.ok) {
            throw new Error(`Error de red de OCM: ${response.statusText}`);
        }

        const data = await response.json();
        if (!data || !Array.isArray(data)) {
            throw new Error("Respuesta de OCM no vlida.");
        }

        const routeLine = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));

        data.forEach(point => {
            try {
                const formattedPoint = formatOCMPoint(point);
                if (!formattedPoint) return;

                const pointTurf = turf.point([formattedPoint.lon, formattedPoint.lat]);
                const distanceKm = turf.pointToLineDistance(pointTurf, routeLine, { units: 'kilometers' });

                if (distanceKm > distanceFilters.max) return;
                
                const power = parseFloat(formattedPoint.power);
                if (isNaN(power) || power < powerFilters.min || power > powerFilters.max) return;

                currentChargingPointsOnRoute.push(formattedPoint);
            } catch (e) {
                // Ignorar puntos individuales que fallen en el procesamiento
            }
        });

        const existingToast = document.getElementById("pdrs-search");
        if (existingToast) existingToast.remove();
        showToast(`${currentChargingPointsOnRoute.length} puntos de recarga encontrados con los filtros aplicados.`, "success");
        displayChargingPointsOnMap();

    } catch (error) {
        const existingToast = document.getElementById("pdrs-search");
        if (existingToast) existingToast.remove();
        showToast(`Error al buscar PDRs: ${error.message}`, "error");
    }
}





    
    



// ===================================================================
// NOMBRE: closeAlertModal
// RESUMEN: Cierra el modal de seleccin de incidencias y limpia su temporizador.
// ===================================================================
function closeAlertModal() {
    const alertModalOverlay = document.getElementById('alert-modal-overlay');
    if (alertModalOverlay) {
        alertModalOverlay.classList.add('hidden');
    }
    if (alertModalTimer) {
        clearInterval(alertModalTimer);
        alertModalTimer = null;
    }
}

// ===================================================================
// NOMBRE: sendTrafficAlert
// RESUMEN: Enva una alerta de trfico a Firebase usando la ubicacin real o simulada.
// ===================================================================
function sendTrafficAlert(alertCode, alertName) {
    const userId = localStorage.getItem('userData_userId');
    if (!userId) {
        showToast("Debes configurar un ID de Usuario para enviar alertas.", "warning");
        closeAlertModal();
        return;
    }

    closeAlertModal();

    // --- MODIFICACIN CLAVE: Lgica para usar coordenadas simuladas ---
    const sendData = async (coords) => {
        if (!window.db || !window.doc || !window.setDoc || !window.collection) {
            showToast("Error: Firebase no est inicializado.", "error");
            return;
        }
        const alertData = {
            user: userId,
            code: alertCode,
            latitude: coords.latitude,
            longitude: coords.longitude,
            timestamp: new Date().toISOString()
        };

        try {
            const alertsCollectionRef = window.collection(window.db, "users", "ALERTAS", "events");
            const docId = `${Date.now()}_${userId.replace(/[^a-zA-Z0-9]/g, '_')}`;
            const newAlertRef = window.doc(alertsCollectionRef, docId);
            await window.setDoc(newAlertRef, alertData);
            showToast(`Alerta "${alertName}" enviada correctamente.`, "success");
            forceProcessTrafficAlerts();
        } catch (error) {
            showToast(`Error al enviar alerta a Firebase: ${error.message}`, "error");
        }
    };

    if (isSimulatingGpsLocation && simulatedGpsLocation) {
        // Si estamos en modo simulacin y hay una ubicacin simulada, la usamos.
        showToast("Enviando alerta desde ubicacin simulada...", "info");
        sendData(simulatedGpsLocation);
    } else {
        // Si no, usamos el GPS real como antes.
        showToast("Obteniendo ubicacin para la alerta...", "info");
        getCurrentLocation(
            (realCoords) => {
                sendData(realCoords);
            },
            (errorMsg) => {
                showToast(`No se pudo obtener la ubicacin: ${errorMsg}`, "error");
            }
        );
    }
  }
    

// ===================================================================
// NOMBRE: processTrafficAlerts
// RESUMEN: Lgica principal que lee, limpia y actualiza las alertas desde Firebase.
// ===================================================================
async function processTrafficAlerts() {
    if (!window.db || !window.getDocs || !window.deleteDoc || !window.collection) {
        return;
    }
    
    try {
        const alertsCollectionRef = window.collection(window.db, "users", "ALERTAS", "events");
        const querySnapshot = await window.getDocs(alertsCollectionRef);
        
        let allAlerts = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        const now = new Date();
        const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
        
        const removals = allAlerts.filter(alert => alert.code === 9);
        let activeAlerts = allAlerts.filter(alert => alert.code !== 9);

        for (const removal of removals) {
            const removalCoords = { lat: removal.latitude, lon: removal.longitude };
            const alertsToDelete = new Set();
            
            activeAlerts.forEach(alert => {
                if(alert.latitude && alert.longitude){
                    const alertCoords = { lat: alert.latitude, lon: alert.longitude };
                    if (calculateDistance(removalCoords.lat, removalCoords.lon, alertCoords.lat, alertCoords.lon) <= 800) {
                        alertsToDelete.add(alert.id);
                    }
                }
            });

            for (const idToDelete of alertsToDelete) {
                const docRef = window.doc(window.db, "users", "ALERTAS", "events", idToDelete);
                await window.deleteDoc(docRef);
            }
            
            const removalDocRef = window.doc(window.db, "users", "ALERTAS", "events", removal.id);
            await window.deleteDoc(removalDocRef);
        }

        activeAlerts = activeAlerts.filter(alert => {
            if (!alert.timestamp || new Date(alert.timestamp) < twentyFourHoursAgo) {
                const docRef = window.doc(window.db, "users", "ALERTAS", "events", alert.id);
                window.deleteDoc(docRef);
                return false;
            }
            return true;
        });
        
        trafficAlertsCache = activeAlerts.filter(alert => alert.latitude && alert.longitude).map(alert => ({
            id: alert.id,
            code: alert.code,
            coordinates: { lat: alert.latitude, lon: alert.longitude }
        }));
        
        // --- LNEA CORREGIDA ---
        // Aseguramos que la llamada es a la funcin correcta "displayAlertsOnMap"
        displayAlertsOnMap(); 
        checkAlertsProximity();
        // -----------------------

    } catch (error) {
        console.error("Error procesando alertas de trfico: ", error);
    }
}








// ===================================================================
// NOMBRE: closeNavigationMap
// RESUMEN: Cierra el mapa de navegacin y limpia todos sus componentes y estados.
// ===================================================================
function closeNavigationMap(force = false) {
    lastAutoShownManeuverId = null;
    const wasInDirectToMapModeSession = sessionStorage.getItem('isInDirectToMapMode') === 'true';
    const userPrefersDirectToNav = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
    if (wasInDirectToMapModeSession && userPrefersDirectToNav && !force) {
        sessionStorage.removeItem('isInDirectToMapMode');
        sessionStorage.setItem(TEMP_PREVENT_DIRECT_NAV_KEY, 'true');
        location.reload();
        return;
    }
    directToNavOnLoad = false;
    sessionStorage.removeItem('isInDirectToMapMode');
    isNavigationMapActive = false;
    sessionStorage.removeItem('mapContext');
    if (locationWatchId !== null && navigator.geolocation) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
    if (gpsRetryTimeoutId) {
        clearTimeout(gpsRetryTimeoutId);
        gpsRetryTimeoutId = null;
    }
    gpsRetryAttempt = 0;
    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresRutaCheckbox) {
        localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked));
        if (radaresRutaCheckbox.checked) {
             eliminarRadaresDeRuta();
        }
    }
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasRutaCheckbox) {
        localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
        if (tareasRutaCheckbox.checked) {
            eliminarTareasDeBarraProgreso();
        }
    }
    actualizarContadorRadares(0);
    actualizarContadorTareas(0);
    clearChargingPoints();
    if (isAddReminderAtLocationModeActive) { toggleAddReminderAtLocationMode(); }
    if (isSimulatingGpsLocation) { stopAutomatedRouteSimulation(); isSimulatingGpsLocation = false; }
    clearAllWaypointMarkersFromMap();
    navigationWaypoints = [];
    if (navigationMapInstance) {
        const toggleMapHeaderButton = document.getElementById('toggle-map-header-buttons-panel');
        if (toggleMapHeaderButton && toggleMapHeaderButton.parentNode) {
            toggleMapHeaderButton.parentNode.removeChild(toggleMapHeaderButton);
        }
        if (compassAndModeControl && navigationMapInstance._controlContainer && navigationMapInstance._controlContainer.contains(compassAndModeControl.getContainer())) { try { navigationMapInstance.removeControl(compassAndModeControl); } catch(e) {} }
        if (mapLayersControl && navigationMapInstance._controlContainer && navigationMapInstance._controlContainer.contains(mapLayersControl.getContainer())) {
             try {mapLayersControl.remove();} catch(e){}
             mapLayersControl = null;
        }
        if (navigationMapClickHandler) { navigationMapInstance.off('click', navigationMapClickHandler); navigationMapClickHandler = null; }
        if (completedRouteSegmentsLayer) { completedRouteSegmentsLayer.clearLayers(); completedRouteSegmentsLayer.remove(); completedRouteSegmentsLayer = null; }
        if (maxSpeedMarkerLayer) { maxSpeedMarkerLayer.clearLayers(); maxSpeedMarkerLayer.remove(); maxSpeedMarkerLayer = null; }
        if (speedMilestoneLayer) { speedMilestoneLayer.clearLayers(); speedMilestoneLayer.remove(); speedMilestoneLayer = null; }
        if (navigationRouteLayer) { try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch(e){} navigationRouteLayer = null; }
        try { navigationMapInstance.remove(); } catch (e) {} navigationMapInstance = null;
    }
    navigationCurrentRouteData = null; isNavigating = false; navigationFollowUser = false;
    routeStartTime = null; navigationStartTimeForStats = null; totalDistanceTravelledForStats = 0; lastPositionForStats = null;
    tripInitialOverallEtaTime = null; currentStageInitialExpectedEtaTime = null; accumulatedDeviationMs = 0;
    currentMapRotationAngle = 0; lastValidCarDistanceForDisplay = 0;
    accumulatedDistanceBeforeCurrentSegment = 0;
    initialUserLocationMarker = null; initialUserLocationMarkerLat = null; initialUserLocationMarkerLng = null;
    if (initialUserLocationCircle) { try {initialUserLocationCircle.remove();} catch(e){} initialUserLocationCircle = null; }
    navigationCurrentLocation = null; compassAndModeControl = null;
    maxSpeedDuringTrip = 0;
    maxSpeedCoordinates = null;
    lastSpeedMilestone = 0;
    maxAltitudeDuringTrip = -Infinity; 
    minAltitudeDuringTrip = Infinity; 
    if (window.compassAndModeControl) { 
        window.compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip); 
    }
    const mapModalElement = document.getElementById('reminders-location-map-modal'); if (mapModalElement) { mapModalElement.remove(); }
    const helpModalInstance = document.getElementById('reminders-map-help-modal-instance'); if (helpModalInstance) { const helpCloseButton = helpModalInstance.querySelector('#close-reminders-map-help-instance'); if(helpCloseButton) clearModalAutoCloseTimer(helpModalInstance, helpCloseButton, 'reminders-map-help-modal-instance'); helpModalInstance.remove(); }
    const savedRoutesModal = document.getElementById('saved-routes-modal'); if (savedRoutesModal) { const closeBtnSRM = savedRoutesModal.querySelector('#close-saved-routes-modal'); if(closeBtnSRM) clearModalAutoCloseTimer(savedRoutesModal, closeBtnSRM, 'saved-routes-modal'); savedRoutesModal.remove(); }
    const saveRoutePromptModal = document.getElementById('save-route-prompt-modal'); if (saveRoutePromptModal) { const closeBtnSRPM = saveRoutePromptModal.querySelector('#cancel-save-route'); if(closeBtnSRPM) clearModalAutoCloseTimer(saveRoutePromptModal, closeBtnSRPM, 'save-route-prompt-modal'); saveRoutePromptModal.remove(); }
    const reorderStagesModalElement = document.getElementById('reorder-stages-modal'); if (reorderStagesModalElement && !reorderStagesModalElement.classList.contains('hidden')) {
        const cancelBtnReorder = reorderStagesModalElement.querySelector('#cancel-reorder-stages');
        if(cancelBtnReorder) clearModalAutoCloseTimer(reorderStagesModalElement, cancelBtnReorder, 'reorder-stages-modal');
        reorderStagesModalElement.classList.add('hidden');
    }
    const simModal = document.getElementById('simulation-modal');
    if (simModal && !simModal.classList.contains('hidden')) {
        if (simulationModalTimer) clearTimeout(simulationModalTimer);
        const simCloseBtn = simModal.querySelector('#close-simulation-modal');
        if (simCloseBtn) clearModalAutoCloseTimer(simModal, simCloseBtn, 'simulation-modal');
        simModal.classList.add('hidden');
        hideIntersectionPreviewMap();
    }
    hideMapInfoOverlay();
    sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
    sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
    sessionStorage.removeItem('boardinggate_map_was_open_before_table');
    sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');
    hideUnifiedReminderWindow();
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    checkReminders();
    const generalTopButtonsPanel = document.getElementById('toggle-top-buttons-panel-general');
    if (generalTopButtonsPanel) generalTopButtonsPanel.classList.remove('hidden');

    if (!directToNavOnLoad) {
        const mainContent = document.querySelector('main');
        if (mainContent) mainContent.style.display = 'block';
        const footer = document.querySelector('footer');
        if (footer) footer.style.display = 'block';
        const noticesContainer = document.querySelector('.notices-icon-container');
        if (noticesContainer) noticesContainer.style.display = 'flex';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button');
        sideControls.forEach(el => el.style.display = 'flex');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'block');
        const gridFilter = document.getElementById('grid-filter-container');
        if (gridFilter) gridFilter.style.display = 'flex';
        renderGrid();
        renderToggleButtons();
        updateButtonStyles();
        filterGridItems();
        setTimeout(adjustButtonPositions, 100);
    }

    hideIntersectionPreviewMap();
    updateDirectionWarningCardsVisibility();
    
    clearNavigationGraph();
}






    



    

    

// ===================================================================
// NOMBRE: displayAlertsOnMap
// RESUMEN: Dibuja los iconos de las alertas de trfico en el mapa, con tamao dinmico segn el zoom.
// ===================================================================
function displayAlertsOnMap() {
    if (!navigationMapInstance || !navigationMapInstance.getPane) {
        return;
    }
    
    const currentZoom = navigationMapInstance.getZoom();
    const ZOOM_THRESHOLD = 16; // Nivel de zoom a partir del cual el icono se hace grande
    const isSmall = currentZoom < ZOOM_THRESHOLD;

    // Estos tamaos deben coincidir con tu CSS para que el anclaje sea correcto
    const largeIconTotalSize = 55; // 55px del .traffic-alert-icon-container
    const smallIconTotalSize = 27; // 27px del .traffic-alert-icon-container.small

    const iconSize = isSmall ? smallIconTotalSize : largeIconTotalSize;
    const iconAnchor = iconSize / 2;

    if (trafficAlertsLayer && navigationMapInstance.hasLayer(trafficAlertsLayer)) {
        trafficAlertsLayer.clearLayers();
    } else {
        trafficAlertsLayer = L.layerGroup().addTo(navigationMapInstance);
    }
    
    const alertIcons = {
        1: 'AACCIDENTE.png', 2: 'AAVERIADO.png', 3: 'AGUARDIA.png',
        4: 'AATASCO.png', 5: 'APELIGRO.png', 6: 'ARESVALAR.png',
        7: 'AOBRAS.png', 8: 'ACERRADA.png', 9: 'AANULAR.png'
    };

    trafficAlertsCache.forEach(alert => {
        if (alertIcons[alert.code]) {
            const extraClass = isSmall ? ' small' : '';
            const iconHtml = `<div class="traffic-alert-icon-container${extraClass}"><img src="${alertIcons[alert.code]}" alt="Alerta"></div>`;

            const divIcon = L.divIcon({
                html: iconHtml,
                className: '', // La clase principal ya est en el HTML
                iconSize: [iconSize, iconSize],
                iconAnchor: [iconAnchor, iconAnchor]
            });
            
            L.marker([alert.coordinates.lat, alert.coordinates.lon], { icon: divIcon, zIndexOffset: 950 }).addTo(trafficAlertsLayer);
        }
    });
}


    
// ===================================================================
// NOMBRE: checkAlertsProximity
// RESUMEN: Comprueba la proximidad del vehculo a las alertas y muestra un aviso si es necesario.
// ===================================================================
function checkAlertsProximity() {
    if (!navigationCurrentLocation || trafficAlertsCache.length === 0) {
        return;
    }

    const carLat = navigationCurrentLocation.latitude;
    const carLon = navigationCurrentLocation.longitude;

    trafficAlertsCache.forEach(alert => {
        const distance = calculateDistance(carLat, carLon, alert.coordinates.lat, alert.coordinates.lon);
        if (distance <= 500 && !currentlyDisplayedProximityAlerts.has(alert.id)) {
            showProximityAlert(alert);
            currentlyDisplayedProximityAlerts.add(alert.id);
        }
    });
}

    
// ===================================================================
// NOMBRE: hideProximityAlert
// RESUMEN: Oculta el modal de aviso de proximidad.
// ===================================================================
function hideProximityAlert(alertId) {
    const proximityModal = document.getElementById('proximity-alert-modal');
    if (proximityModal) proximityModal.classList.add('hidden');
    document.getElementById('flashing-border-overlay').classList.add('hidden');
    
    if (proximityAlertTimer) {
        clearInterval(proximityAlertTimer);
        proximityAlertTimer = null;
    }
}


// ===================================================================
// NOMBRE: forceProcessTrafficAlerts
// RESUMEN: Lanza el proceso de actualizacin de alertas inmediatamente.
// ===================================================================
function forceProcessTrafficAlerts() {
    console.log("-> Forzando actualizacin inmediata de alertas de trfico...");
    // Reseteamos el timestamp para que el prximo ciclo de 15 min empiece a contar desde ahora
    lastAlertCheckTimestamp = Date.now();
    processTrafficAlerts();
}    


// ===================================================================
// NOMBRE: showProximityAlert
// RESUMEN: Muestra el modal de aviso de proximidad a una alerta de trfico.
// ===================================================================
function showProximityAlert(alert) {
    const proximityModal = document.getElementById('proximity-alert-modal');
    if (!proximityModal) return;

    const alertDetails = [
        null, 
        { text: 'ACCIDENTE TRFICO', icon: 'AACCIDENTE.png' },
        { text: 'COCHE AVERIADO', icon: 'AAVERIADO.png' },
        { text: 'CONTROL TRFICO / RADAR', icon: 'AGUARDIA.png' },
        { text: 'ATASCO', icon: 'AATASCO.png' },
        { text: 'PELIGRO INDETERMINADO', icon: 'APELIGRO.png' },
        { text: 'CARRETERA MAL ESTADO', icon: 'ARESVALAR.png' },
        { text: 'OBRAS', icon: 'AOBRAS.png' },
        null, // Espacio para el cdigo 8 que no se muestra aqu
        { text: 'VA / CARRETERA CERRADA', icon: 'ACERRADA.png' } // <-- NUEVA OPCIN AADIDA
    ][alert.code];

    if (!alertDetails) return;

    proximityModal.innerHTML = `
        <img src="${alertDetails.icon}" alt="${alertDetails.text}">
        <div class="content">
            <span class="alert-text">${alertDetails.text}</span>
            <button id="proximity-ok-button">ENTERADO <span id="proximity-timer">(10)</span></button>
        </div>
    `;

    document.getElementById('flashing-border-overlay').classList.remove('hidden');
    proximityModal.classList.remove('hidden');

    const okButton = document.getElementById('proximity-ok-button');
    const timerSpan = document.getElementById('proximity-timer');
    let countdown = 15;
    
    if (proximityAlertTimer) clearInterval(proximityAlertTimer);
    proximityAlertTimer = setInterval(() => {
        countdown--;
        if (timerSpan) timerSpan.textContent = `(${countdown})`;
        if (countdown <= 0) {
            hideProximityAlert(alert.id);
        }
    }, 1000);
    
    okButton.onclick = () => hideProximityAlert(alert.id);
}
    



    







// ===================================================================
// NOMBRE: loadRouteByName
// RESUMEN: Carga una ruta guardada por su nombre y la dibuja en el mapa.
// ===================================================================
function loadRouteByName(routeName, autoStartNavigation = false) {
    const savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
    const routeToLoad = savedRoutes.find(r => r.name.toUpperCase() === routeName.toUpperCase());
    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (!routeToLoad) {
        showToast(`No se pudo cargar la ruta "${routeName}". No encontrada`, "error");
        if (radaresRutaCheckbox) {
           localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked));
        }
        if (tareasRutaCheckbox) {
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
        }
        return;
    }
    clearAllWaypointMarkersFromMap();
    if (navigationMapInstance) {
        if (navigationRouteLayer) {
            try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch(e) {}
        }
        if (completedRouteSegmentsLayer) {
            completedRouteSegmentsLayer.clearLayers();
        }
    }
    navigationWaypoints = [];
    navigationRouteLayer = null;
    navigationCurrentRouteData = null;
    isNavigating = false;
    routeStartTime = null; 
    navigationStartTimeForStats = null; 
    totalDistanceTravelledForStats = 0; 
    lastPositionForStats = null;
    tripInitialOverallEtaTime = null; 
    currentStageInitialExpectedEtaTime = null; 
    accumulatedDeviationMs = 0;
    lastValidCarDistanceForDisplay = 0;
    accumulatedDistanceBeforeCurrentSegment = 0;
    maxSpeedDuringTrip = 0; 
    maxAltitudeDuringTrip = -Infinity; 
    minAltitudeDuringTrip = Infinity;
    if (compassAndModeControl) { 
        compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip); 
    }
    eliminarRadaresDeRuta();
    actualizarContadorRadares(0);
    eliminarTareasDeBarraProgreso();
    actualizarContadorTareas(0);
    clearChargingPoints();
    clearNavigationGraph();
    currentRouteNameForSaving = routeToLoad.name;
    const isSavedLocationRoute = routeToLoad.name.startsWith("UBICACIN: ");
    if (isSavedLocationRoute && routeToLoad.waypoints.length === 1 && navigationCurrentLocation) {
        const startPoint = {
            id: Date.now() -1,
            lat: navigationCurrentLocation.latitude,
            lng: navigationCurrentLocation.longitude,
            type: 'S',
            marker: null,
            label: 'S',
            address: 'Posicin Actual (GPS)',
            visited: true,
            isCriticalForRecalc: true,
            isRecalculatedStart: false
        };
        navigationWaypoints.push(startPoint);
    }
    routeToLoad.waypoints.forEach(wpData => {
        if (wpData) {
            navigationWaypoints.push({
                id: wpData.id || Date.now() + Math.random(),
                lat: wpData.lat,
                lng: wpData.lng,
                type: wpData.type,
                label: wpData.label,
                marker: null,
                address: wpData.address || '',
                visited: wpData.visited || false,
                isCriticalForRecalc: wpData.isCriticalForRecalc !== false,
                isRecalculatedStart: false
            });
        }
    });
    if (navigationCurrentLocation && navigationWaypoints.length > 0) {
        const firstWp = navigationWaypoints[0];
        const distanceToFirstWp = calculateDistance(
            navigationCurrentLocation.latitude, navigationCurrentLocation.longitude,
            firstWp.lat, firstWp.lng
        );
        if (distanceToFirstWp < 15000) {
            if (firstWp.type === 'S') {
                navigationWaypoints.shift();
            }
            const newStartPoint = {
                id: Date.now() -1,
                lat: navigationCurrentLocation.latitude,
                lng: navigationCurrentLocation.longitude,
                type: 'S', marker: null, label: 'S',
                address: 'Posicin Actual (GPS)',
                visited: true, isCriticalForRecalc: true,
                isRecalculatedStart: false
            };
            navigationWaypoints.unshift(newStartPoint);
        } else {
             const newStartPoint = {
                id: Date.now() -1,
                lat: navigationCurrentLocation.latitude,
                lng: navigationCurrentLocation.longitude,
                type: 'S', marker: null, label: 'S',
                address: 'Posicin Actual (GPS)',
                visited: true, isCriticalForRecalc: true,
                isRecalculatedStart: false
            };
            navigationWaypoints.unshift(newStartPoint);
        }
    }
    updateWaypointTypesAndLabels();
    renderWaypointMarkers();
    if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2) {
        recalculateAndDrawRoute(false).then(() => {
            showToast(`Ruta "${routeToLoad.name}" cargada y recalculada`, "success");
            if (navigationMapInstance && navigationRouteLayer) {
                navigationMapInstance.fitBounds(navigationRouteLayer.getBounds().pad(0.1));
            }
             if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
                let carDistAlongRouteLoad = 0;
                const currentCarPosForLoad = navigationCurrentLocation;
                 if (currentCarPosForLoad && navigationMapInstance && navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
                    try {
                        const carPointTurf = turf.point([currentCarPosForLoad.longitude, currentCarPosForLoad.latitude]);
                        const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                        const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                        const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                        carDistAlongRouteLoad = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                    } catch (e) {  }
                 }
                updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], carDistAlongRouteLoad);
                updateTurnByTurnDisplay(navigationCurrentRouteData.routes[0], carDistAlongRouteLoad);
                showNavigationUIElementsForPlanning();
                if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                    toggleRadaresRuta(true);
                }
                 if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                    toggleTareasRuta(true);
                }
                if (autoStartNavigation) {
                    if (autoStartNavTimer) clearTimeout(autoStartNavTimer);
                    let countdown = 3;
                    const startNavToastId = `start-nav-toast-${Date.now()}`;
                    const updateNavToast = () => {
                        showToast(`Iniciando navegacin automtica en ${countdown} segundos... <button onclick="cancelAutoStartNav('${startNavToastId}')" style="background:rgba(255,255,255,0.2);border:1px solid white;padding:2px 5px;margin-left:10px;border-radius:3px;">Cancelar</button>`, 'info', countdown * 1000 + 500, false, startNavToastId);
                    };
                    updateNavToast();
                    autoStartNavTimer = setInterval(() => {
                        countdown--;
                        if (countdown > 0) {
                            updateNavToast();
                        } else {
                            clearInterval(autoStartNavTimer);
                            autoStartNavTimer = null;
                            const existingToast = document.getElementById(startNavToastId);
                            if (existingToast) existingToast.remove();
                            if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2 && !isNavigating) {
                                toggleNavigationState();
                            }
                        }
                    }, 1000);
                }
            }
        }).catch(error => {
            showToast(`Error al recalcular la ruta "${routeToLoad.name}": ${error.message}`, "error");
        });
    } else {
        showToast(`Ruta "${routeToLoad.name}" cargada (solo waypoints, no hay suficientes para una ruta)`, "info");
        hideNavigationUI();
         if (radaresRutaCheckbox) {
           localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked));
        }
         if (tareasRutaCheckbox) {
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
        }
    }
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    actualizarContadorRadares(radaresEnRutaActual.length);
    actualizarContadorTareas(tareasEnRutaActual.length);
}

















    
    


// ===================================================================
// NOMBRE: handleStageSelectionFromDeviationModal
// RESUMEN: Gestiona la seleccin de una etapa especfica desde el modal de desvo.
// ===================================================================
function handleStageSelectionFromDeviationModal(selectedWaypointId) {
const selectedIndex = navigationWaypoints.findIndex(wp => wp.id === selectedWaypointId);
if (selectedIndex === -1) {
showToast("Error: No se encontr la etapa seleccionada.", "error");
closeModalAndProceed();
return;
}
for (let i = 0; i < selectedIndex; i++) {
const wp = navigationWaypoints[i];
if (wp && !wp.isInternal && wp.type !== 'S' && wp.type !== 'S_Recalc') {
wp.visited = true;
}
}
navigationWaypoints[selectedIndex].visited = false;
closeModalAndProceed();
recalculateAndDrawRoute(true);
renderWaypointMarkers();
}


    


    



// ===================================================================
// NOMBRE: showArrivalStatsModal
// RESUMEN: Muestra un modal con las estadsticas del viaje al llegar al destino.
// ===================================================================
function showArrivalStatsModal() {
    closeOtherModals('arrival-stats-modal');
    let modal = document.getElementById('arrival-stats-modal');
    if (modal) {
        clearModalAutoCloseTimer(modal, modal.querySelector('#arrival-stats-accept-button'), 'arrival-stats-modal');
        modal.remove();
    }
    modal = document.createElement('div');
    modal.id = 'arrival-stats-modal';
    modal.style.cssText = `
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background-color: #E6D6A8; padding: 25px; border-radius: 10px;
        box-shadow: 0 0 20px rgba(0,0,0,0.5); z-index: 10000; text-align: center;
        max-width: 550px; width: 90%;
    `;
    const destinationWp = navigationWaypoints[navigationWaypoints.length - 1];
    const destinationName = destinationWp?.address || "";
    const startTime = navigationStartTimeForStats ? new Date(navigationStartTimeForStats) : new Date();
    const arrivalTime = new Date();
    const durationMs = arrivalTime - startTime;
    const durationHours = Math.floor(durationMs / (1000 * 60 * 60));
    const durationMinutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
    const durationSeconds = Math.floor((durationMs % (1000 * 60)) / 1000);
    let kmRealizados;
    if (isSimulatingGpsLocation && automatedSimulationIntervalId) {
        kmRealizados = (simulatedDistanceAlongRoute / 1000).toFixed(2);
    } else {
        kmRealizados = (totalDistanceTravelledForStats / 1000).toFixed(2);
    }
    const velocidadMedia = window.averageSpeedKmh.toFixed(1);
    const velocidadMaxima = maxSpeedDuringTrip.toFixed(1);
    const altitudMaxima = maxAltitudeDuringTrip !== -Infinity ? maxAltitudeDuringTrip.toFixed(0) + ' m' : 'N/D';
    const altitudMinima = minAltitudeDuringTrip !== Infinity ? minAltitudeDuringTrip.toFixed(0) + ' m' : 'N/D';
    let altitudMediaHtml = '';
    if (graphDataPoints && graphDataPoints.altitude && graphDataPoints.altitude.length > 0) {
        const sum = graphDataPoints.altitude.reduce((a, b) => a + b, 0);
        const avg = sum / graphDataPoints.altitude.length;
        altitudMediaHtml = `
            <div style="text-align: center;">
                <span style="font-size: 1.1rem; color: black; font-weight: bold;">(Media:</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;"> ${avg.toFixed(0)} m)</span>
            </div>
        `;
    }
    let deviationHtml = "";
    let finalDeviationMs = 0;
    if (tripInitialOverallEtaTime) {
        finalDeviationMs = arrivalTime.getTime() - tripInitialOverallEtaTime.getTime();
        deviationHtml = formatDeviation(finalDeviationMs);
    }
    let initialEtaDetailsHtml = '';
    const initialRoute = navigationCurrentRouteData?.routes?.[0];
    if (initialRoute && tripInitialOverallEtaTime && Math.abs(finalDeviationMs) < 5000) { 
        const realEtaTime = arrivalTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const realDurationTotalMinutes = Math.round(durationMs / (1000 * 60));
        const realDurationHours = Math.floor(realDurationTotalMinutes / 60);
        const realDurationMins = realDurationTotalMinutes % 60;
        const realDurationFormatted = `${String(realDurationHours).padStart(2,'0')}:${String(realDurationMins).padStart(2,'0')}`;
        const realAvgSpeed = velocidadMedia;
        initialEtaDetailsHtml = `
        <div id="initial-eta-details" style="font-size: 0.9rem; color: #333; margin-top: 8px; padding-top: 8px; border-top: 1px solid #ccc; text-align: center; font-weight: bold; line-height: 1.4;">
            <strong>Previsin (coincide con real):</strong><br>
            Hora llegada: ${realEtaTime} | Tiempo: ${realDurationFormatted} h. | Vel. media: ${realAvgSpeed} Km/h
        </div>
        `;
    } else if (initialRoute && tripInitialOverallEtaTime) {
        const initialEtaTime = tripInitialOverallEtaTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const initialDurationTotalMinutes = Math.round(initialRoute.duration / 60);
        const initialDurationHours = Math.floor(initialDurationTotalMinutes / 60);
        const initialDurationMins = initialDurationTotalMinutes % 60;
        const initialDurationFormatted = `${String(initialDurationHours).padStart(2,'0')}:${String(initialDurationMins).padStart(2,'0')}`;
        const initialAvgSpeed = ((initialRoute.distance / initialRoute.duration) * 3.6).toFixed(1);
        initialEtaDetailsHtml = `
        <div id="initial-eta-details" style="font-size: 0.9rem; color: #555; margin-top: 8px; padding-top: 8px; border-top: 1px solid #ccc; text-align: center; font-weight: bold; line-height: 1.4;">
            <strong>Previsin inicial:</strong><br>
            Hora llegada: ${initialEtaTime} | Tiempo: ${initialDurationFormatted} h. | Vel. media: ${initialAvgSpeed} Km/h
        </div>
        `;
    }
    modal.innerHTML = `
        <h2 style="font-size: 1.6rem; color: #006400; font-weight: bold; margin-bottom: 15px; display: flex; align-items: center; justify-content: center;">
            <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path></svg>
            HA LLEGADO A !
        </h2>
        <div style="font-size: 1.1rem; color: #006400; font-weight: bold; text-align: center; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #ccc; display: flex; align-items: center; justify-content: center;">
             <img src="arrive.png" alt="Destino" style="width: 5em; height: 5em; margin-right: 5px; vertical-align: middle;">
             <span style="font-size: 1.5em; vertical-align: middle;">${destinationName}</span>
        </div>
        <div style="display: flex; justify-content: space-around; align-items: center; margin-bottom: 15px; font-size: 1.1rem;">
            <div style="text-align: center;">
                <span style="font-size: 1.1rem; color: black; font-weight: bold; display: block;">Hora Salida</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;">${startTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
            </div>
            <div style="font-size: 4rem; color: black;"></div>
            <div style="text-align: center;">
                <span style="font-size: 1.1rem; color: black; font-weight: bold; display: block;">Hora Llegada</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;">${arrivalTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
            </div>
        </div>
        <div style="text-align: center; margin-bottom: 20px;">
            <span style="font-size: 1.1rem; color: black; font-weight: bold; display: block;">Tiempo Viaje</span>
            <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;">${String(durationHours).padStart(2,'0')}:${String(durationMinutes).padStart(2,'0')}:${String(durationSeconds).padStart(2,'0')}</span>
         </div>
          <div style="text-align: center; margin-bottom: 10px;">
            <span style="font-size: 1.1rem; color: blue; font-weight: bold;">Desviacin ETA: ${deviationHtml}</span>
            ${initialEtaDetailsHtml}
         </div>
        </div>
        <div style="display: flex; justify-content: space-around; margin-bottom: 10px; font-size: 1.1rem; border-top: 1px solid #ccc; padding-top: 10px; margin-top:10px;">
            <div>
                <span style="font-size: 1.1rem; color: black; font-weight: bold;">Km realizados:</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;"> ${kmRealizados} km</span>
            </div>
            <div>
                <span style="font-size: 1.1rem; color: black; font-weight: bold;">Vel. media:</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;"> ${velocidadMedia} km/h</span>
            </div>
        </div>
        <div style="display: flex; justify-content: center; align-items: center; gap: 10px; margin-bottom: 20px; font-size: 1.1rem;">
            <div>
                <span style="font-size: 1.1rem; color: black; font-weight: bold;">Vel. mxima:</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;"> ${velocidadMaxima} km/h</span>
            </div>
            <button id="show-max-speed-location-button" style="padding: 0; font-size: 1rem; background-color: #f59e0b; color: white; border: 1px solid #d97706; border-radius: 4px; cursor: pointer; max-width: 12px; max-height: 8px;">Dnde?</button>
        </div>
        <div style="display: flex; justify-content: space-around; align-items: center; margin-bottom: 20px; font-size: 1.1rem; border-top: 1px solid #ccc; padding-top: 15px; margin-top:15px;">
            <div>
                <span style="font-size: 1.1rem; color: black; font-weight: bold;">Altitud Mx:</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;"> ${altitudMaxima}</span>
            </div>
            ${altitudMediaHtml}
            <div>
                <span style="font-size: 1.1rem; color: black; font-weight: bold;">Altitud Mn:</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;"> ${altitudMinima}</span>
            </div>
        </div>
        <button id="arrival-stats-accept-button" style="background-color: #007bff; color: white; padding: 12px 25px; font-size: 1.2rem; border-radius: 5px; border: none; cursor: pointer;">ACEPTAR</button>
    `;
    document.body.appendChild(modal);
    const coordsAreValid = maxSpeedCoordinates &&
                            typeof maxSpeedCoordinates.lat === 'number' && !isNaN(maxSpeedCoordinates.lat) &&
                            typeof maxSpeedCoordinates.lng === 'number' && !isNaN(maxSpeedCoordinates.lng);
    if (coordsAreValid && navigationMapInstance) {
        const maxSpeedIcon = L.divIcon({
            className: 'max-speed-marker-icon',
            html: `<div style="background-color: red; color: white; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; border: 2px solid white; box-shadow: 0 0 5px black;">${Math.round(velocidadMaxima)}</div>`,
            iconSize: [44, 44],
            iconAnchor: [22, 22]
        });
        const markerPosition = [maxSpeedCoordinates.lat, maxSpeedCoordinates.lng];
        if (!maxSpeedMarkerLayer) {
            maxSpeedMarkerLayer = L.layerGroup().addTo(navigationMapInstance);
        } else {
            maxSpeedMarkerLayer.clearLayers();
        }
        L.marker(markerPosition, { 
            icon: maxSpeedIcon,
            zIndexOffset: 2000
        }).addTo(maxSpeedMarkerLayer);
    }
    const acceptButton = modal.querySelector('#arrival-stats-accept-button');
    acceptButton.addEventListener('click', () => {
        clearModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal');
        if (modal.parentNode) modal.remove();
        if (isNavigating) {
            toggleNavigationState(); 
        } else {
            mapHeaderButtonsVisible = true;
            toggleMapHeaderRowsVisibility(true);
        }
        showMapInfoOverlay("HA LLEGADO AL : " + destinationName);
    });
    const showLocationButton = modal.querySelector('#show-max-speed-location-button');
    showLocationButton.addEventListener('click', () => {
        const coordsAreValid = maxSpeedCoordinates &&
                              typeof maxSpeedCoordinates.lat === 'number' && !isNaN(maxSpeedCoordinates.lat) &&
                              typeof maxSpeedCoordinates.lng === 'number' && !isNaN(maxSpeedCoordinates.lng);
        if (!coordsAreValid || !navigationMapInstance) {
            showToast("No se han registrado coordenadas vlidas para la velocidad mxima.", "warning");
            return;
        }
        clearModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal');
        if (modal.parentNode) modal.remove();
        const markerPosition = [maxSpeedCoordinates.lat, maxSpeedCoordinates.lng];
        navigationMapInstance.setView(markerPosition, 16);
        showToast("Mapa centrado en el punto de velocidad mxima.", "info");
        mapHeaderButtonsVisible = true;
        toggleMapHeaderRowsVisibility(true);
    });
    addModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal', 60000);
}













    


// ===================================================================
// NOMBRE: saveCurrentRoute
// RESUMEN: Muestra el modal para guardar la ruta actualmente planificada en el mapa.
// ===================================================================
async function saveCurrentRoute() {
    if (navigationWaypoints.length < 2) {
        showToast("No hay ruta activa para guardar (se necesitan al menos 2 puntos)", "warning");
        return;
    }
    const isMultiStage = navigationWaypoints.length > 2;
    const lastWp = navigationWaypoints[navigationWaypoints.length - 1];
    let defaultRouteName = await getSuggestedRouteName(lastWp.lat, lastWp.lng, isMultiStage, navigationWaypoints.length);
    currentRouteNameForSaving = null;
    const existingModal = document.getElementById('save-route-prompt-modal');
    if (existingModal) existingModal.remove();
    const modal = document.createElement('div');
    modal.id = 'save-route-prompt-modal';
    modal.innerHTML = `
        <h2>Guardar Ruta</h2>
        <div class="modal-top-buttons">
            <button id="confirm-save-route">Guardar <span class="button-countdown-timer"></span></button>
            <button id="cancel-save-route">Cancelar</button>
        </div>
        <label for="route-name-input">Nombre de la Ruta:</label>
        <input type="text" id="route-name-input" value="${defaultRouteName.toUpperCase()}">
    `;
    document.body.appendChild(modal);
    const nameInput = modal.querySelector('#route-name-input');
    nameInput.style.textTransform = 'uppercase';
    const confirmButton = modal.querySelector('#confirm-save-route');
    const cancelButton = modal.querySelector('#cancel-save-route');
    nameInput.focus();
    const textLength = nameInput.value.length;
    nameInput.setSelectionRange(textLength, textLength);
    const closePrompt = () => {
        clearModalAutoCloseTimer(modal, confirmButton, 'save-route-prompt-modal');
        if (modal.parentNode) modal.remove();
    };
    const saveAction = () => {
        let routeName = nameInput.value.trim().toUpperCase();
        if (!routeName) {
            showToast("El nombre de la ruta no puede estar vaco", "warning");
            addModalAutoCloseTimer(modal, confirmButton, 'save-route-prompt-modal', 15000);
            return;
        }
        currentRouteNameForSaving = routeName;
        let waypointsToSave = navigationWaypoints.map(wp => (wp ? { id: wp.id, lat: wp.lat, lng: wp.lng, label:wp.label, type:wp.type, address: wp.address || '', visited: wp.visited || false, isCriticalForRecalc: wp.isCriticalForRecalc !== false, isInternal: wp.isInternal || false, isRecalculatedStart: wp.isRecalculatedStart || false } : null)).filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
       if (waypointsToSave.length === 2 && !isMultiStage) {
            const startPoint = waypointsToSave.find(wp => wp.type === 'S');
            const endPoint = waypointsToSave.find(wp => wp.type === 'F');
            if (startPoint && endPoint) {
                 waypointsToSave = [endPoint];
            }
        }
        const routeToSave = {
            name: routeName,
            waypoints: waypointsToSave,
            createdAt: new Date().toISOString()
        };
        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        const existingRouteIndex = savedRoutes.findIndex(r => r.name === routeName);
        if (existingRouteIndex !== -1) {
            if (!confirm(`Ya existe una ruta llamada "${routeName}". Sobreescribir?`)) {
                showToast("Guardado cancelado", "info");
                addModalAutoCloseTimer(modal, confirmButton, 'save-route-prompt-modal', 15000);
                return;
            }
            savedRoutes[existingRouteIndex] = routeToSave;
        } else {
            savedRoutes.push(routeToSave);
        }
        if (savedRoutes.length > MAX_SAVED_ROUTES) {
            savedRoutes.sort((a,b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
            savedRoutes = savedRoutes.slice(0, MAX_SAVED_ROUTES);
        }
        localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes));
        localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
        markCacheAsDirty(); 
        showToast(`Ruta "${routeName}" guardada`, "success");
        closePrompt();
    };
    confirmButton.addEventListener('click', saveAction);
    cancelButton.addEventListener('click', () => {
        closePrompt();
    });
    addModalAutoCloseTimer(modal, confirmButton, 'save-route-prompt-modal', 15000);
}






    

// ===================================================================
// NOMBRE: generateBackup
// RESUMEN: Genera un cdigo de backup con todos los datos locales y lo copia al portapapeles.
// ===================================================================
function generateBackup() {
    const backupData = {};
    managedKeys.forEach(key => {
        const value = localStorage.getItem(key);
        if (value !== null) {
            backupData[key] = value;
        }
    });
    const backupString = JSON.stringify(backupData);
    const backupDisplay = document.getElementById('config-backup-display');
    backupDisplay.value = btoa(unescape(encodeURIComponent(backupString)));
    backupDisplay.style.display = 'block';
    backupDisplay.select();
    try {
        document.execCommand('copy');
        showToast('Backup copiado al portapapeles', 'success');
         document.getElementById('config-backup-status').textContent = 'Copiado! Guarda este cdigo en un lugar seguro.';
         document.getElementById('config-backup-status').style.color = '#28a745';
    } catch (err) {
        showToast('Error al copiar. Por favor, copia manualmente', 'warning');
        document.getElementById('config-backup-status').textContent = 'Copia este cdigo manualmente y gurdalo.';
        document.getElementById('config-backup-status').style.color = '#ffc107';
    }
}






    






    


 // ===================================================================
// NOMBRE: updateStartNavigationButtonState
// RESUMEN: Actualiza la visibilidad y estado de los botones de navegacin segn si hay una ruta activa.
// ===================================================================
function updateStartNavigationButtonState() {
    const startNavButton = document.getElementById('start-navigation-button');
    const saveRouteButton = document.getElementById('save-route-button');
    const reorderBtn = document.getElementById('reorder-route-stages-button');
    const startNavImg = startNavButton ? startNavButton.querySelector('img') : null;
    const simulateBtn = document.getElementById('simulate-route-button');
    const deleteRouteBtn = document.getElementById('delete-current-route-button');
    const loadRouteBtn = document.getElementById('load-saved-route-button'); 
    const toggleSimulateGpsBtn = document.getElementById('toggle-simulate-gps-button');
    const graphCard = document.getElementById('navigation-graph-card');
    if (!startNavButton || !saveRouteButton || !reorderBtn || !simulateBtn || !loadRouteBtn || !deleteRouteBtn || !toggleSimulateGpsBtn || !graphCard) return;
    const hasEnoughWaypointsForRoute = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2;
    const hasRouteData = navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0];
    const canDisplayRoute = hasEnoughWaypointsForRoute && hasRouteData;
    const hasAtLeastOneWaypoint = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 1;
    startNavButton.classList.toggle('hidden', !(hasEnoughWaypointsForRoute || isNavigating));
    saveRouteButton.classList.toggle('hidden', !(!isNavigating && canDisplayRoute));
    if (reorderBtn) reorderBtn.style.display = (!isNavigating && canDisplayRoute) ? 'inline-flex' : 'none';
    const canSimulate = (canDisplayRoute || (isNavigating && hasRouteData));
    if(simulateBtn) simulateBtn.style.display = canSimulate ? 'inline-flex' : 'none';
    if(toggleSimulateGpsBtn) toggleSimulateGpsBtn.style.display = hasAtLeastOneWaypoint ? 'inline-flex' : 'none';
    if (deleteRouteBtn) {
        deleteRouteBtn.classList.remove('hidden');
    }
    if (loadRouteBtn) {
        loadRouteBtn.classList.remove('hidden');
    }
    const hasGraphData = graphDataPoints && (graphDataPoints.speed.length > 0 || graphDataPoints.altitude.length > 0);
    graphCard.classList.toggle('hidden', !hasGraphData || currentGraphMode === 'Grfica off');
    if (isNavigating) {
        if(reorderBtn) reorderBtn.style.display = 'none';
        if(startNavImg) startNavImg.src = "TERMINARNAVEGACION.PNG";
    } else {
        if (hasEnoughWaypointsForRoute) {
            if(startNavImg) startNavImg.src = "INICIARNAVEGACION.PNG";
        } else {
            if (navigationRouteLayer && navigationMapInstance) { try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch(e){} navigationRouteLayer = null; }
            if (completedRouteSegmentsLayer && navigationMapInstance) completedRouteSegmentsLayer.clearLayers();
            navigationCurrentRouteData = null;
            hideNavigationUI();
            hideMapInfoOverlay();
        }
    }
    updateNavigationGraphVisibilityAndMode();
}





// ===================================================================
// NOMBRE: restoreOriginalGrid
// RESUMEN: Restaura el grid de marcadores a su estado original de fbrica.
// ===================================================================
function restoreOriginalGrid() {
    if (confirm('Restaurar el grid de botones a su estado original? Perders tu personalizacin del grid (URLs, nombres, orden).')) {
        localStorage.removeItem('customGridData');
        localStorage.removeItem('gridFilterValue');
        loadCustomData();
        renderGrid();
        renderToggleButtons();
        loadSavedSettings();
        updateButtonStyles();
        filterGridItems();
        document.getElementById('config-restore-grid-status').textContent = 'Grid restaurado al original. Recargando...';
        document.getElementById('config-restore-grid-status').style.color = '#28a745';
        showToast('Grid restaurado. Recargando...', 'success');
        setTimeout(() => location.reload(), 1500);
    }
}











 





    





// ===================================================================
// NOMBRE: getManeuverIconFilename
// RESUMEN: Devuelve el nombre del fichero de imagen para una maniobra.
// ===================================================================
function getManeuverIconFilename(maneuver) {
    if (!maneuver) return 'continue.png';
    const type = maneuver.type || '';
    const modifier = maneuver.modifier || '';

    // Salidas de rotonda especficas
    if (type.includes('roundabout') && maneuver.exit && maneuver.exit >= 1 && maneuver.exit <= 5 && getManeuverInstructionText(maneuver).toLowerCase().includes("salida")) {
        return `S${maneuver.exit}.PNG`;
    }
    
    // Casos nicos
    if (type === 'depart') return 'depart.png';
    if (type === 'arrive') return 'arrive.png';
    if (type.includes('roundabout') || type.includes('rotary')) return 'roundabout.png';
    
    // Casos con modificador (ordenados de ms especfico a ms general)
    if (modifier.includes('uturn')) return 'u-turn.png';
    if (modifier.includes('sharp right')) return 'sharp-right.png';
    if (modifier.includes('sharp left')) return 'sharp-left.png';
    if (modifier.includes('slight right') || modifier.includes('bear right')) return 'bear-right.png';
    if (modifier.includes('slight left') || modifier.includes('bear left')) return 'bear-left.png';
    if (modifier.includes('right')) return 'turn-right.png';
    if (modifier.includes('left')) return 'turn-left.png';
    
    return 'continue.png'; 
}






    


  // ===================================================================
// NOMBRE: getSuggestedRouteName
// RESUMEN: Sugiere un nombre de ruta por defecto basado en la ubicacin final.
// ===================================================================
async function getSuggestedRouteName(lat, lng, isMultiStage = false, totalWaypoints = 0) {
    let baseName = `RUTA: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
    try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=1&accept-language=es`);
        if (response.ok) {
            const data = await response.json();
            if (data.address) {
                const road = data.address.road;
                const city = data.address.city || data.address.town || data.address.village || data.address.hamlet;
                if (road && city) baseName = `${road}, ${city}`;
                else if (city) baseName = city;
                else if (road) baseName = road;
            }
        }
    } catch (e) {
    }
    if (isMultiStage) {
        const numStages = Math.max(0, totalWaypoints - 1);
        return `${numStages} ETAPAS: ${baseName}`;
    } else {
        return `  ${baseName}`;
    }
}
    









    
    






    

    


// ===================================================================
// NOMBRE: initializeConfigModalListeners
// RESUMEN: Asigna los listeners a todos los elementos interactivos del modal de configuracin.
// ===================================================================
function initializeConfigModalListeners() {
    document.getElementById('config-save-user-firebase')?.addEventListener('click', validateAndSaveUserToFirebase);
    document.getElementById('config-save-user-firebase-from-backup-tab')?.addEventListener('click', validateAndSaveUserToFirebase);
    document.getElementById('config-restore-backup-firebase')?.addEventListener('click', restoreBackupFromFirebase);
    document.getElementById('config-save-pin')?.addEventListener('click', savePinSettings);
    document.getElementById('config-remove-pin')?.addEventListener('click', removePinSettings);
    document.getElementById('config-generate-backup')?.addEventListener('click', generateBackup);
    document.getElementById('config-restore-backup')?.addEventListener('click', restoreBackup);
    document.getElementById('config-restore-grid-button')?.addEventListener('click', restoreOriginalGrid);
    document.getElementById('config-clear-cache')?.addEventListener('click', clearAllLocalData);
    const importBtn = document.getElementById('import-radars-button');
    if (importBtn && !importBtn.dataset.listenerAttached) {
        importBtn.addEventListener('click', importRadars);
        importBtn.style.backgroundColor = '#FFA500';
        importBtn.style.border = '1px solid #D97706';
        importBtn.dataset.listenerAttached = "true";
    }
    const deleteBtn = document.getElementById('delete-filtered-radars-button');
    if (deleteBtn && !deleteBtn.dataset.listenerAttached) {
        deleteBtn.addEventListener('click', deleteFilteredRadars);
        deleteBtn.style.backgroundColor = '#FFA500';
        deleteBtn.style.border = '1px solid #D97706';
        deleteBtn.dataset.listenerAttached = "true";
    }
    const configCloseBtn = document.getElementById('config-close-modal');
    if (configCloseBtn) {
        configCloseBtn.style.backgroundColor = '#4A5568';
        configCloseBtn.style.color = 'white';
        configCloseBtn.style.border = '1px solid #2D3748';
        configCloseBtn.style.fontWeight = 'bold';
        configCloseBtn.onmouseover = () => configCloseBtn.style.backgroundColor = '#2D3748';
        configCloseBtn.onmouseout = () => configCloseBtn.style.backgroundColor = '#4A5568';
    }
    const directToNavCheckbox = document.getElementById('config-direct-to-nav');
    if (directToNavCheckbox && !directToNavCheckbox.dataset.listenerAttached) {
        directToNavCheckbox.addEventListener('change', () => {
            localStorage.setItem(DIRECT_TO_NAVIGATION_KEY, JSON.stringify(directToNavCheckbox.checked));
            showToast('Preferencia de inicio directo al mapa guardada.', 'success', 2000);
        });
        directToNavCheckbox.dataset.listenerAttached = "true";
    }
    const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
    if (autoBackupCheckbox && !autoBackupCheckbox.dataset.listenerAttached) {
        autoBackupCheckbox.addEventListener('change', () => {
            const isEnabled = autoBackupCheckbox.checked;
            localStorage.setItem('boardinggate_autoBackupOnLoad', JSON.stringify(isEnabled));
            showToast(`Copia de seguridad automtica al inicio: ${isEnabled ? 'Activada' : 'Desactivada'}`, 'info', 3000);
        });
        autoBackupCheckbox.dataset.listenerAttached = "true";
    }
}






    
    // ===================================================================
// NOMBRE: startGpsWatching
// RESUMEN: Inicia el seguimiento GPS del dispositivo y gestiona los reintentos.
// ===================================================================
function startGpsWatching() {
    if (gpsRetryTimeoutId) {
        clearTimeout(gpsRetryTimeoutId);
        gpsRetryTimeoutId = null;
    }
    if (locationWatchId !== null) {
        return;
    }
    if (!('geolocation' in navigator) || !('watchPosition' in navigator.geolocation)) {
        showToast("Geolocalizacin no soportada por este navegador.", "error", 5000);
        return;
    }
    if (gpsRetryAttempt >= MAX_GPS_RETRIES) {
        showToast("Error persistente: No se pudo conectar al GPS. Revisa la configuracin del dispositivo.", "error", 0, false, "gps-persistent-error");
        return;
    }
    gpsRetryAttempt++;
    showToast(`Intentando conectar al GPS (Intento ${gpsRetryAttempt}/${MAX_GPS_RETRIES})...`, "info", GPS_RETRY_DELAY_MS, false, "gps-attempt-toast");
    locationWatchId = navigator.geolocation.watchPosition(
        (position) => {
            if (isSimulatingGpsLocation) return;
            const attemptToast = document.getElementById("gps-attempt-toast");
            if (attemptToast) attemptToast.remove();
            activeToasts = activeToasts.filter(t => t.id !== "gps-attempt-toast");
            gpsRetryAttempt = 0;
            const persistentErrorToast = document.getElementById("gps-persistent-error");
            if (persistentErrorToast) persistentErrorToast.remove();
            const coordsForUpdate = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                heading: position.coords.heading,
                speed: position.coords.speed,
                altitude: position.coords.altitude
            };
            navigationCurrentLocation = coordsForUpdate;

            // <-- LNEA CORREGIDA: AQU ESTABA EL ERROR! -->
            // Se llama a la funcin que actualiza el icono y la vista del mapa.
            // ANTES (INCORRECTO): (coordsForUpdate, navigationMapInstance);
            updateInitialUserPosition(coordsForUpdate, navigationMapInstance);

            if (isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0] && coordsForUpdate) {
                const routeForDistCalc = navigationCurrentRouteData.routes[0];
                let carDistTurf = 0;
                if (navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
                    try {
                        const carPointTurf = turf.point([coordsForUpdate.longitude, coordsForUpdate.latitude]);
                        const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                        const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                        const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                        carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                    } catch (e) { }
                }
                const totalRouteLength = routeForDistCalc.distance;
                if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                    if (carDistTurf > lastCarDistanceAlongRouteForNavLogic - 100) {
                         lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                    }
                } else if (carDistTurf > totalRouteLength + 500) {
                    lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
                }

                let cumulativeDistance = 0;
                navigationWaypoints.forEach((wp, index) => {
                    if (wp) {
                        const isStartPoint = wp.type === 'S' || wp.isRecalculatedStart;
                        const isIntermediate = wp.type === 'intermediate';
                        const isFinal = wp.type === 'F';

                        if (isStartPoint) {
                            wp.visited = true;
                        } else if (isIntermediate && routeForDistCalc.legs && (index - 1) < routeForDistCalc.legs.length) {
                            const leg = routeForDistCalc.legs[index - 1];
                            if (leg) {
                                cumulativeDistance += (leg.distance || 0);
                                if (carDistTurf >= cumulativeDistance - WAYPOINT_VISITED_THRESHOLD_METERS) {
                                    wp.visited = true;
                                }
                            }
                        } else if (isFinal) {
                            if (carDistTurf >= routeForDistCalc.distance - WAYPOINT_VISITED_THRESHOLD_METERS) {
                                wp.visited = true;
                            }
                        }
                    }
                });
                renderWaypointMarkers();
                
                updateTurnByTurnDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                updateNavigationProgressDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
            }
        },
        (error) => {
            showToast(`Error GPS: ${error.message}`, "warning");
            if (locationWatchId !== null) {
                navigator.geolocation.clearWatch(locationWatchId);
                locationWatchId = null;
            }
            gpsRetryTimeoutId = setTimeout(startGpsWatching, GPS_RETRY_DELAY_MS);
        },
        { enableHighAccuracy: true, timeout: 15000, maximumAge: 2000, distanceFilter: 3 }
    );
}

    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: parseUserId
    // RESUMEN: Analiza el ID de usuario para detectar si es un usuario mvil y extrae el ID principal.
    // ===================================================================
    function parseUserId(rawUserId) {
        if (!rawUserId) {
            return { primaryId: null, isMobile: false, originalId: null };
        }
        const mobileRegex = /^(.*?)@(MVIL|MOVIL)$/i;
        const match = rawUserId.trim().match(mobileRegex);
        if (match && match[1]) {
            return {
                primaryId: match[1].trim(),
                isMobile: true,
                originalId: rawUserId.trim()
            };
        } else {
            return {
                primaryId: rawUserId.trim(),
                isMobile: false,
                originalId: rawUserId.trim()
            };
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: markCacheAsDirty
    // RESUMEN: Actualiza un timestamp para marcar que la cach local ha sido modificada.
    // ===================================================================
    function markCacheAsDirty() {
        localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: promptForBackupPassword
    // RESUMEN: Muestra un modal para que el usuario introduzca un PIN de seguridad para backups.
    // ===================================================================
    function promptForBackupPassword(message, onConfirm, onCancel, isSettingPassword = false) {
        const existingModal = document.getElementById('backup-password-modal-overlay');
        if (existingModal) existingModal.remove();
        const modalOverlay = document.createElement('div');
        modalOverlay.id = 'backup-password-modal-overlay';
        modalOverlay.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85); display: flex; justify-content: center;
            align-items: center; z-index: 9999;
        `;
        const modalContent = document.createElement('div');
        modalContent.id = 'backup-password-modal-content';
        modalContent.style.cssText = `
            background-color: #DAC8A0; padding: 2rem; border-radius: 0.75rem;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4); text-align: center; border: 1px solid #A0522D;
            margin-top: -50px;
            max-width: 350px; width: 90%;
        `;
        modalContent.innerHTML = `
            <h2 style="font-size: 1.5rem; font-weight: bold; color: #333; margin-bottom: 1rem;">${message}</h2>
            <input type="password" id="backup-password-input" maxlength="6" pattern="\\d{6}" inputmode="numeric" style="
                width: 150px; padding: 0.8rem; font-size: 1.8rem; text-align: center;
                border: 2px solid #A0522D; border-radius: 0.25rem; margin-bottom: 1.5rem;
                letter-spacing: 0.5em; background-color: #f0f0e0;
            " required>
            ${isSettingPassword ? `
                <label for="backup-password-confirm" style="display: block; font-size: 1.1rem; color: #444; margin-bottom: 0.8rem;">Confirmar PIN:</label>
                <input type="password" id="backup-password-confirm" maxlength="6" pattern="\\d{6}" inputmode="numeric" style="
                    width: 150px; padding: 0.8rem; font-size: 1.8rem; text-align: center;
                    border: 2px solid #A0522D; border-radius: 0.25rem; margin-bottom: 1.5rem;
                    letter-spacing: 0.5em; background-color: #f0f0e0;
                " required>
            ` : ''}
            <p id="backup-password-error" style="color: #dc3545; font-weight: bold; margin-top: -0.5rem; margin-bottom: 1rem; min-height: 1.2em;"></p>
            <div style="display:flex; justify-content: space-around; gap:1rem;">
                <button id="backup-password-submit" style="padding: 0.8rem 1.5rem; font-size: 1.2rem; background-color: #28a745; color: white; border: none; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; flex: 1;">Aceptar</button>
                <button id="backup-password-cancel" style="padding: 0.8rem 1.5rem; font-size: 1.2rem; background-color: #6c757d; color: white; border: none; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; flex: 1;">Cancelar</button>
            </div>
        `;
        document.body.appendChild(modalOverlay);
        modalOverlay.appendChild(modalContent);
        const pinInput = document.getElementById('backup-password-input');
        const pinConfirmInput = document.getElementById('backup-password-confirm');
        const errorEl = document.getElementById('backup-password-error');
        const submitBtn = document.getElementById('backup-password-submit');
        const cancelBtn = document.getElementById('backup-password-cancel');
        pinInput.focus();
        const validateAndSubmit = () => {
            errorEl.textContent = '';
            const pin = pinInput.value;
            if (!/^\d{6}$/.test(pin)) {
                errorEl.textContent = 'El PIN debe ser de 6 dgitos numricos.';
                if (navigator.vibrate) navigator.vibrate(100);
                return;
            }
            if (isSettingPassword) {
                const confirmPin = pinConfirmInput.value;
                if (pin !== confirmPin) {
                    errorEl.textContent = 'Los PINs no coinciden.';
                    if (navigator.vibrate) navigator.vibrate(100);
                    return;
                }
            }
            modalOverlay.remove();
            onConfirm(pin);
        };
        submitBtn.addEventListener('click', validateAndSubmit);
        cancelBtn.addEventListener('click', () => {
            modalOverlay.remove();
            onCancel();
        });
        pinInput.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                if (isSettingPassword && pinConfirmInput) {
                    pinConfirmInput.focus();
                } else {
                    validateAndSubmit();
                }
            }
        });
        if (isSettingPassword && pinConfirmInput) {
            pinConfirmInput.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') {
                    validateAndSubmit();
                }
            });
        }
        addModalAutoCloseTimer(modalOverlay, submitBtn, 'backup-password-modal', isSettingPassword ? 90000 : 30000);
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: callFirebase
    // RESUMEN: Encapsula las llamadas a Firebase Firestore para guardar, obtener o verificar datos de usuario.
    // ===================================================================
    async function callFirebase(action, data) {
        if (!window.db || !window.doc || !window.setDoc || !window.getDoc || !window.collection) {
            console.error("Firebase Firestore SDK functions no estn expuestas globalmente.");
            return { status: "error", message: "Error interno: Funciones de Firebase no estn disponibles." };
        }
        const userId = data.userId;
        if (!userId) {
            return { status: "error", message: "ID de Usuario es obligatorio para las operaciones de Firebase." };
        }
        try {
            const userDocRef = window.doc(window.db, "user_data", userId);
            if (action === 'saveUser') {
                const documentData = {
                    usuario: data.usuario,
                    modelo: data.modelo || '',
                    anio: data.anio || '',
                    provincia: data.provincia || '',
                    rss: data.rss || false,
                    contenidoCacheCompleto: JSON.stringify(data.datosCache),
                    fechaBackup: new Date().toISOString(),
                    backupPassword: data.backupPassword || null
                };
                await window.setDoc(userDocRef, documentData);
                return { status: "success", message: "Datos guardados en Firebase." };
            } else if (action === 'getUserData') {
                const docSnap = await window.getDoc(userDocRef);
                if (docSnap.exists()) {
                    const firebaseData = docSnap.data();
                    try {
                        firebaseData.contenidoCacheCompleto = JSON.parse(firebaseData.contenidoCacheCompleto);
                    } catch (e) {
                        console.error("Error al parsear contenidoCacheCompleto de Firebase:", e);
                    }
                    return { status: "success", message: "Datos recuperados de Firebase.", data: firebaseData };
                } else {
                    return { status: "not_found", message: "No se encontr ningn backup para ese ID de Usuario." };
                }
            } else if (action === 'checkUserExists') {
                 const docSnap = await window.getDoc(userDocRef);
                 return { status: "success", exists: docSnap.exists() };
            } else {
                return { status: "error", message: "Accin de Firebase no reconocida." };
            }
        } catch (error) {
            console.error("Error en la operacin de Firebase:", error);
            return { status: "error", message: `Error de Firebase: ${error.message}` };
        }
    }
    
    
    
    
    
    
    
    
    // ===================================================================
// NOMBRE: validateAndSaveUserToFirebase
// RESUMEN: Valida el usuario, pide PIN si es necesario y guarda los datos locales en Firebase.
// ===================================================================
async function validateAndSaveUserToFirebase() {
    const statusEl = document.getElementById('config-user-status');
    const userIdInput = document.getElementById('user-id');
    const { primaryId, isMobile, originalId } = parseUserId(userIdInput.value);

    // <-- AADIDO: Comprobacin para proteger el usuario 'ALERTAS' -->
    if (primaryId && primaryId.toUpperCase() === 'ALERTAS') {
        statusEl.textContent = 'El nombre de usuario "ALERTAS" est reservado para el sistema. Por favor, elige otro.';
        statusEl.style.color = '#EF4444';
        showToast('Nombre de usuario no permitido', 'error');
        return; // Detiene la ejecucin de la funcin
    }
    // <-- FIN DE LA MODIFICACIN -->

    if (!primaryId) {
        statusEl.textContent = 'El ID de Usuario es obligatorio.';
        statusEl.style.color = '#EF4444';
        return;
    }
    statusEl.textContent = 'Validando y preparando guardado...';
    statusEl.style.color = '#17a2b8';
    const toastId = "firebase-save-toast";
    showToast('Validando en la nube...', 'info', 0, false, toastId);
    const currentLocalUserId = localStorage.getItem('userData_userId');
    const localBackupPassword = localStorage.getItem('userData_backupPassword');
    const hasChangedUser = originalId.toLowerCase() !== (currentLocalUserId || '').toLowerCase();
    const completeSaveProcess = async (finalBackupPin) => {
        localStorage.setItem('userData_userId', originalId);
        localStorage.setItem('userData_teslaModel', document.getElementById('tesla-model').value.trim());
        localStorage.setItem('userData_teslaYear', document.getElementById('tesla-year').value.trim());
        localStorage.setItem('userData_teslaProvince', document.getElementById('tesla-province').value.trim());
        localStorage.setItem('userData_allowDMs', JSON.stringify(document.getElementById('allow-dms').checked));
        localStorage.setItem('boardinggate_autoBackupOnLoad', JSON.stringify(document.getElementById('config-auto-backup-on-load').checked));
        localStorage.setItem('userData_backupPassword', finalBackupPin);
        updateUserIdDisplay();
        const cacheData = {};
        managedKeys.forEach(key => {
            const value = localStorage.getItem(key);
            if (value !== null) cacheData[key] = value;
        });
        const saveData = {
            userId: primaryId,
            usuario: primaryId,
            modelo: localStorage.getItem('userData_teslaModel') || '',
            anio: localStorage.getItem('userData_teslaYear') || '',
            provincia: localStorage.getItem('userData_teslaProvince') || '',
            rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
            datosCache: cacheData,
            backupPassword: finalBackupPin,
            fechaBackup: new Date().toISOString()
        };
        const saveResult = await callFirebase('saveUser', saveData);
        const existingToast = document.getElementById(toastId);
        if (existingToast) existingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== toastId);
        if (saveResult.status === 'success') {
            const successMsg = isMobile ?
                `Datos sincronizados con el usuario "${primaryId}".` :
                "Datos guardados en la nube y localmente.";
            statusEl.textContent = successMsg;
            statusEl.style.color = '#28a745';
            showToast(successMsg, 'success');
            localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
        } else {
            statusEl.textContent = `Error al guardar: ${saveResult.message}. (Datos guardados localmente).`;
            statusEl.style.color = '#EF4444';
            showToast(`Error al guardar: ${saveResult.message}`, 'error');
        }
    };
    if (!hasChangedUser && localBackupPassword) {
        await completeSaveProcess(localBackupPassword);
    } else {
        const checkResult = await callFirebase('checkUserExists', { userId: primaryId });
        if (checkResult.status === 'error') {
            statusEl.textContent = `Error al verificar usuario en la nube: ${checkResult.message}.`;
            statusEl.style.color = '#EF4444';
            return;
        }
        if (checkResult.exists) {
            promptForBackupPassword(
                `Introduce el PIN para "${primaryId}":`,
                async (enteredPin) => {
                    const retrieveResult = await callFirebase('getUserData', { userId: primaryId });
                    if (retrieveResult.status === 'success' && retrieveResult.data && retrieveResult.data.backupPassword === enteredPin) {
                        await completeSaveProcess(enteredPin);
                    } else {
                        statusEl.textContent = 'PIN incorrecto. Guardado cancelado.';
                        statusEl.style.color = '#EF4444';
                        showToast('PIN incorrecto. Acceso denegado.', 'error');
                    }
                },
                () => { }
            );
        } else {
            if(isMobile) {
                statusEl.textContent = `El usuario primario "${primaryId}" no existe. No se puede sincronizar.`;
                statusEl.style.color = '#EF4444';
                return;
            }
            promptForBackupPassword(
                'Nuevo usuario. Establece un PIN de 6 dgitos:',
                (pin) => completeSaveProcess(pin),
                () => { },
                true
            );
        }
    }
}


    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: autoSaveFromMobile
    // RESUMEN: Realiza un guardado automtico en Firebase, llamado por checkReminders para usuarios mviles.
    // ===================================================================
    async function autoSaveFromMobile(primaryId, backupPassword) {
        showToast(`Sincronizando cambios con "${primaryId}"...`, 'info', 0, false, 'mobile-autosave');
        const cacheData = {};
        managedKeys.forEach(key => {
            const value = localStorage.getItem(key);
            if (value !== null) cacheData[key] = value;
        });
        const saveData = {
            userId: primaryId,
            usuario: primaryId,
            modelo: localStorage.getItem('userData_teslaModel') || '',
            anio: localStorage.getItem('userData_teslaYear') || '',
            provincia: localStorage.getItem('userData_teslaProvince') || '',
            rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
            datosCache: cacheData,
            backupPassword: backupPassword,
            fechaBackup: new Date().toISOString()
        };
        const saveResult = await callFirebase('saveUser', saveData);
        const toast = document.getElementById('mobile-autosave');
        if(toast) toast.remove();
        if (saveResult.status === 'success') {
            showToast('Cambios sincronizados con la nube.', 'success');
            lastMobileSyncTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');
        } else {
            showToast(`Error al sincronizar: ${saveResult.message}`, 'error');
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: syncDataOnLoad
    // RESUMEN: Sincroniza datos al cargar, descargando o subiendo a Firebase segn timestamps.
    // ===================================================================
    async function syncDataOnLoad() {
        const autoSyncEnabled = JSON.parse(localStorage.getItem('boardinggate_autoBackupOnLoad') || 'false');
        const { primaryId, isMobile } = parseUserId(localStorage.getItem('userData_userId'));
        const backupPassword = localStorage.getItem('userData_backupPassword');
        if (!autoSyncEnabled || !primaryId || isMobile || !backupPassword) {
            return;
        }
        showToast(`Sincronizando datos del coche para ${primaryId}...`, 'info', 4000, false, "auto-sync-toast");
        const result = await callFirebase('getUserData', { userId: primaryId });
        const existingToast = document.getElementById("auto-sync-toast");
        if (existingToast) existingToast.remove();
        if (result.status === 'success' && result.data) {
            const cloudTimestamp = new Date(result.data.fechaBackup || 0).getTime();
            const localTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');
            if (cloudTimestamp > localTimestamp + 10000) {
                showToast(`Nuevos datos encontrados en la nube. Aplicando...`, 'info', 5000);
                const backupCacheData = result.data.contenidoCacheCompleto;
                if (backupCacheData) {
                    const currentUserIdentity = localStorage.getItem('userData_userId');
                    for (const key in backupCacheData) {
                        if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                            localStorage.setItem(key, backupCacheData[key]);
                        }
                    }
                    if (currentUserIdentity) {
                        localStorage.setItem('userData_userId', currentUserIdentity);
                    }
                    localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
                    showToast('Datos sincronizados desde la nube. La pgina se recargar.', 'success', 3000);
                    setTimeout(() => location.reload(), 2500);
                } else {
                    showToast('Los datos en la nube estn corruptos.', 'error');
                }
            }
            else if (localTimestamp > cloudTimestamp + 10000) {
                showToast('Realizando copia de seguridad automtica...', 'info', 3000);
                const cacheData = {};
                managedKeys.forEach(key => {
                    const value = localStorage.getItem(key);
                    if (value !== null) cacheData[key] = value;
                });
                const requestData = {
                    userId: primaryId, usuario: primaryId,
                    modelo: localStorage.getItem('userData_teslaModel') || '',
                    anio: localStorage.getItem('userData_teslaYear') || '',
                    provincia: localStorage.getItem('userData_teslaProvince') || '',
                    rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
                    datosCache: cacheData,
                    backupPassword: backupPassword,
                    fechaBackup: new Date().toISOString()
                };
                await callFirebase('saveUser', requestData);
            }
        } else if (result.status === 'not_found') {
            showToast(`Creando primera copia de seguridad para ${primaryId}...`, 'info', 3000);
            const cacheData = {};
            managedKeys.forEach(key => {
                const value = localStorage.getItem(key);
                if (value !== null) cacheData[key] = value;
            });
            const requestData = {
                userId: primaryId, usuario: primaryId,
                modelo: localStorage.getItem('userData_teslaModel') || '',
                anio: localStorage.getItem('userData_teslaYear') || '',
                provincia: localStorage.getItem('userData_teslaProvince') || '',
                rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
                datosCache: cacheData,
                backupPassword: backupPassword,
                fechaBackup: new Date().toISOString()
            };
            await callFirebase('saveUser', requestData);
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: restoreBackupFromFirebase
    // RESUMEN: Recupera y aplica un backup de datos desde Firebase, pidiendo PIN para confirmar.
    // ===================================================================
    async function restoreBackupFromFirebase(isAutoLoad = false) {
        const statusEl = document.getElementById('config-restore-status');
        const { primaryId, isMobile, originalId } = parseUserId(document.getElementById('restore-user-id').value || localStorage.getItem('userData_userId'));
        if (!primaryId) {
            if (!isAutoLoad) statusEl.textContent = 'Introduce un ID de Usuario para recuperar.';
            if (!isAutoLoad) statusEl.style.color = '#EF4444';
            return;
        }
        if (!isAutoLoad) {
            statusEl.textContent = `Buscando backup para "${primaryId}"...`;
            statusEl.style.color = '#17a2b8';
            showToast(`Recuperando backup de "${primaryId}"...`, 'info', 0, false, "firebase-restore-toast");
        }
        const result = await callFirebase('getUserData', { userId: primaryId });
        if (!isAutoLoad) {
            const existingToast = document.getElementById("firebase-restore-toast");
            if (existingToast) existingToast.remove();
            activeToasts = activeToasts.filter(t => t.id !== "firebase-restore-toast");
        }
        if (result.status === 'success' && result.data) {
            const firebaseData = result.data;
            const backupCacheData = firebaseData.contenidoCacheCompleto;
            if (!backupCacheData) {
                if (!isAutoLoad) {
                    statusEl.textContent = `El backup para "${primaryId}" no contiene datos de cach.`;
                    statusEl.style.color = '#EF4444';
                    showToast('Backup incompleto.', 'error');
                }
                return;
            }
            const applyChanges = () => {
                const currentUserIdentity = localStorage.getItem('userData_userId') || originalId;
                for (const key in backupCacheData) {
                    if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                        localStorage.setItem(key, backupCacheData[key]);
                    }
                }
                localStorage.setItem('userData_userId', currentUserIdentity);
                const newTimestamp = Date.now().toString();
                localStorage.setItem('lastCacheUpdateTimestamp', newTimestamp);
                if (isMobile) {
                    lastMobileSyncTimestamp = parseInt(newTimestamp);
                }
                showToast('Restauracin completada. Recargando...', 'success', 3000);
                setTimeout(() => location.reload(), 2500);
            };
            if (isAutoLoad) {
                applyChanges();
            } else {
                 promptForBackupPassword(
                    `Introduce el PIN para "${primaryId}":`,
                    (enteredPin) => {
                        if (enteredPin === firebaseData.backupPassword) {
                            if (confirm(`Se encontr un backup para "${primaryId}". Ests seguro de que quieres restaurar estos datos?`)) {
                                applyChanges();
                            } else {
                                statusEl.textContent = 'Restauracin cancelada.';
                                statusEl.style.color = '#6c757d';
                            }
                        } else {
                            statusEl.textContent = 'PIN incorrecto. Restauracin cancelada.';
                            statusEl.style.color = '#EF4444';
                            showToast('PIN incorrecto.', 'error');
                        }
                    },
                    () => {
                        statusEl.textContent = 'Restauracin cancelada.';
                        statusEl.style.color = '#6c757d';
                    }
                );
            }
        } else if (result.status === 'not_found' && !isAutoLoad) {
            statusEl.textContent = `No se encontr backup para "${primaryId}".`;
            statusEl.style.color = '#EF4444';
            showToast('Backup no encontrado.', 'error not-found');
        } else if (!isAutoLoad) {
            statusEl.textContent = `Error al recuperar: ${result.message}`;
            statusEl.style.color = '#EF4444';
            showToast(`Error de recuperacin: ${result.message}`, 'error');
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getRandomSpeedMultiplierForManeuver
    // RESUMEN: Devuelve un multiplicador aleatorio de velocidad para simular variaciones en las maniobras.
    // ===================================================================
    function getRandomSpeedMultiplierForManeuver(maneuver) {
        const type = maneuver.type || '';
        const modifier = maneuver.modifier || '';
        let min, max;
        if (type === 'roundabout' || type === 'rotary' || modifier.includes('sharp') || modifier.includes('uturn')) {
            min = -0.30;
            max = 0.10;
        } else if (type === 'turn' || type === 'fork' || type === 'merge' || type === 'end of road') {
            min = -0.20;
            max = 0.20;
        } else {
            min = -0.05;
            max = 0.25;
        }
        return Math.random() * (max - min) + min;
    }
    
    
    
    





// ===================================================================
// NOMBRE: hideIntersectionPreviewMap
// RESUMEN: Oculta el minimapa de previsualizacin de la interseccin.
// ===================================================================
function hideIntersectionPreviewMap() {
    const card = document.getElementById('intersection-preview-map-window');
    if (card) {
        card.classList.add('hidden');
        const rotator = card.querySelector('#intersection-rotator');
        if (rotator) {
            rotator.style.transform = 'rotate(0deg)';
        }
        miniMapOffsetActive.x = 0;
        targetMapCenterOffset.x -= miniMapOffsetActive.x;
    }
    if (intersectionPreviewTimer) {
        clearTimeout(intersectionPreviewTimer);
        intersectionPreviewTimer = null;
    }
}



    
    




// ===================================================================
// NOMBRE: checkReminders
// RESUMEN: Comprueba peridicamente los recordatorios y las alertas de trfico.
// ===================================================================
function checkReminders() {
    // Control de tiempo para las alertas de trfico
    if (Date.now() - lastAlertCheckTimestamp >= ALERT_CHECK_INTERVAL) {
        lastAlertCheckTimestamp = Date.now();
        processTrafficAlerts();
    }
    
    // El resto de tu lgica de recordatorios...
    if (isRecalculatingRoute && recalculationAttempts > 0) {
        return;
    }
    let currentReminders = []; try { currentReminders = JSON.parse(localStorage.getItem('reminders') || '[]'); } catch (e) { localStorage.setItem('reminders_backup_error', localStorage.getItem('reminders') || '[]'); localStorage.removeItem('reminders'); showToast("Error al cargar recordatorios. Backup intentado.", "error", 5000); return; }
    const now = new Date(); let overdueReminders = []; const validRemindersForStorage = []; let storageNeedsUpdate = false; const processedIds = new Set(); let newOverdueFound = false; let isAnyReminderNearby = false;
    new Promise((resolve) => {
        if (isSimulatingGpsLocation && simulatedGpsLocation) {
            resolve(simulatedGpsLocation);
        } else if (navigationCurrentLocation) {
            resolve(navigationCurrentLocation);
        } else if ('geolocation' in navigator) {
             getCurrentLocation( (coordsParam) => resolve(coordsParam), (errorMsg) => { resolve(null); } );
        } else {
            resolve(null);
        }
    }).then(async coords => {
        let allRemindersToCheck = [...currentReminders];
        const radaresRutaActivos = document.getElementById('radares-ruta-checkbox')?.checked;
        if (isNavigating && radaresRutaActivos && reminderMapObjects && reminderMapObjects.length > 0) {
            reminderMapObjects.forEach(mapObj => {
                if (mapObj.isFromRuta) {
                    const tempReminderFromMap = {
                        id: mapObj.reminderId, text: mapObj.marker.options.title || "RADAR RUTA", type: 'simple',
                        time: '00:00', date: new Date().toISOString().split('T')[0], createdAt: new Date().toISOString(),
                        managedByUser: false, isLocationEnabled: true,
                        locationCoordinates: { latitude: mapObj.marker.getLatLng().lat, longitude: mapObj.marker.getLatLng().lng },
                        radiusMeters: mapObj.circle ? mapObj.circle.getRadius() : 600,
                        excludeFromList: true, isFromRuta: true
                    };
                    allRemindersToCheck.push(tempReminderFromMap);
                }
            });
        }
        allRemindersToCheck.forEach(reminder => {
            if (!reminder || typeof reminder.id !== 'number' || typeof reminder.managedByUser === 'undefined' || !reminder.type || !reminder.time || !reminder.date || !reminder.createdAt) {
                if (!reminder.isFromRuta) storageNeedsUpdate = true;
                return;
            }
            if (processedIds.has(reminder.id)) {
                if (!reminder.isFromRuta) storageNeedsUpdate = true;
                return;
            }
            processedIds.add(reminder.id);
            if (reminder.isFromRuta && snoozedRouteRadars.has(reminder.id)) {
                const snoozeEndTime = snoozedRouteRadars.get(reminder.id);
                if (Date.now() < snoozeEndTime) { return; } else { snoozedRouteRadars.delete(reminder.id); }
            }
            const isManagedByUser = reminder.managedByUser === true; let keepInStorage = true; let isOverdue = false; let locationConditionMet = true;
            if (!isManagedByUser) {
                let reminderLocalDueTime = null; try { const [year, month, day] = reminder.date.split('-').map(Number); const [hour, minute] = reminder.time.split(':').map(Number); reminderLocalDueTime = new Date(year, month - 1, day, hour, minute);
                    if (isNaN(reminderLocalDueTime.getTime())) { throw new Error("Invalid date/time components"); }
                    if (reminderLocalDueTime <= now) {
                        isOverdue = true;
                        if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                            if (coords) {
                                const distance = calculateDistance( coords.latitude, coords.longitude, reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude );
                                locationConditionMet = distance <= (reminder.radiusMeters || DEFAULT_LOCATION_RADIUS);
                                if (locationConditionMet && distance < 1500) { isAnyReminderNearby = true; }
                            } else { locationConditionMet = false; }
                        }
                    } else if (reminder.isLocationEnabled && reminder.locationCoordinates && coords) {
                        const distance = calculateDistance( coords.latitude, coords.longitude, reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude );
                        if (distance < 1500) { isAnyReminderNearby = true; }
                    }
                } catch (error) {
                    if (!reminder.isFromRuta) storageNeedsUpdate = true;
                    keepInStorage = false; isOverdue = false; locationConditionMet = false;
                }
            }
             if (isOverdue && locationConditionMet) {
                overdueReminders.push(reminder);
                if (!isUnifiedWindowVisibleByLogic || !document.querySelector(`#unified-reminder-window .reminder-slide[data-id="${reminder.id}"]`)) {
                    newOverdueFound = true;
                }
            }
            if (keepInStorage && !reminder.isFromRuta) { validRemindersForStorage.push(reminder); }
        });
        if (storageNeedsUpdate) { try { const oldStorageString = localStorage.getItem('reminders') || '[]'; const newStorageString = JSON.stringify(validRemindersForStorage); if (oldStorageString !== newStorageString) { localStorage.setItem('reminders', newStorageString); } } catch (e) { showToast("Error al actualizar recordatorios tras limpieza.", "error", 5000); } }
        let shouldDisplayWindow = false;
        if (overdueReminders.length > 0) {
            if (!isUnifiedWindowVisibleByLogic || newOverdueFound) {
                shouldDisplayWindow = true;
                currentNotificationSlideIndex = 0;
                if (newOverdueFound) showYellowBorder();
            } else {
                const currentDisplayedIds = Array.from(document.querySelectorAll('#unified-reminder-window .reminder-slide')).map(el => parseInt(el.dataset.id));
                const newOverdueIds = overdueReminders.map(r => r.id);
                if (currentDisplayedIds.length !== newOverdueIds.length || !currentDisplayedIds.every(id => newOverdueIds.includes(id))) {
                    shouldDisplayWindow = true;
                }
            }
        }
        if (shouldDisplayWindow) {
             displayUnifiedReminderWindow(overdueReminders);
        } else if (overdueReminders.length === 0 && isUnifiedWindowVisibleByLogic) {
             hideUnifiedReminderWindow();
             currentNotificationSlideIndex = 0;
        }
        if (isNavigating && navigationCurrentLocation && !isRecalculatingRoute && !isDeviationModalActive && !isAddReminderAtLocationModeActive) {
            const currentCoords = navigationCurrentLocation;
            if (navigationMapInstance && navigationRouteLayer && navigationRouteLayer.getLatLngs().length > 0 && typeof L.GeometryUtil !== 'undefined' && L.GeometryUtil.closestLayerSnap) {
                const closestPointInfo = L.GeometryUtil.closestLayerSnap(navigationMapInstance, [navigationRouteLayer], L.latLng(currentCoords.latitude, currentCoords.longitude), DEVIATION_THRESHOLD_METERS * 2 , false);
                if (closestPointInfo) {
                    const distanceToRoute = closestPointInfo.distance;
                    if (distanceToRoute > DEVIATION_THRESHOLD_METERS) {
                        if (deviationStartTime === 0) {
                            deviationStartTime = Date.now();
                        } else if ((Date.now() - deviationStartTime) / 1000 > DEVIATION_MIN_TIME_SECONDS) {
                            showDeviationModal();
                            deviationStartTime = 0;
                        }
                    } else { deviationStartTime = 0; }
                } else {
                    if (deviationStartTime === 0) {
                         deviationStartTime = Date.now();
                    } else if ((Date.now() - deviationStartTime) / 1000 > DEVIATION_MIN_TIME_SECONDS) {
                         showDeviationModal();
                         deviationStartTime = 0;
                    }
                }
            }
        } else {
            deviationStartTime = 0;
        }
        updateReminderCount(); updateButtonStyles();
        let newInterval = isNavigating ? 1000 : 3000;
        if (isNavigating) {
            const distToNextManeuver = distanceToNextManeuverOSRM || Infinity;
             if (distToNextManeuver < 500 && distToNextManeuver > 0) {
                newInterval = 1000;
            } else if (distToNextManeuver < 1000 && distToNextManeuver > 0) {
                newInterval = 1500;
            } else {
                newInterval = 3000;
            }
        } else if (isAnyReminderNearby) {
             newInterval = 5000;
        }
        const unifiedWindowCurrentlyVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible');
        if (unifiedWindowCurrentlyVisible && (isNavigationMapActive)) {
            newInterval = Math.min(newInterval, 5000);
        }
        if (newInterval !== currentCheckIntervalDuration) {
            currentCheckIntervalDuration = newInterval;
            if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
            reminderCheckIntervalId = setInterval(checkReminders, currentCheckIntervalDuration);
        }
        const swiperContainer = document.getElementById('reminder-swiper-container');
        const windowElement = document.getElementById('unified-reminder-window');
        if (swiperContainer && overdueReminders.length > 0 && windowElement.classList.contains('visible') && newInterval !== 1000 && newInterval !== 5000) {
            const totalSlides = overdueReminders.length; let nextSlideIndex = currentNotificationSlideIndex;
            if (totalSlides > 1) { nextSlideIndex = (currentNotificationSlideIndex + 1) % totalSlides; } else { nextSlideIndex = 0; }
            if (totalSlides === 1 || nextSlideIndex !== currentNotificationSlideIndex) { currentNotificationSlideIndex = nextSlideIndex; const targetScrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth; swiperContainer.scrollTo({ left: targetScrollLeft, behavior: 'smooth' }); setTimeout(updateReminderIndexDisplay, 400); }
        }
        const { isMobile, primaryId } = parseUserId(localStorage.getItem('userData_userId'));
        if (isMobile) {
            const localTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');
            const backupPassword = localStorage.getItem('userData_backupPassword');
            if (backupPassword && localTimestamp > lastMobileSyncTimestamp) {
                autoSaveFromMobile(primaryId, backupPassword);
            }
        }
    });
}




    

    
    
// ===================================================================
// NOMBRE: showDeviationModal
// RESUMEN: Muestra un modal cuando se detecta un desvo de la ruta.
// ===================================================================
function showDeviationModal() {
    closeOtherModals('deviation-modal');
    isDeviationModalActive = true;
    let modal = document.getElementById('deviation-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'deviation-modal';
        document.body.appendChild(modal);
    }

    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    const unvisitedSelectableStages = actualWaypoints.filter(wp => !wp.visited && wp.type !== 'S' && wp.type !== 'S_Recalc' && wp.type !== 'F');

    const iconHtml = `<img src="APELIGRO.png" alt="Icono de Peligro" style="width: 115px; height: 70px; margin: 0 auto 10px auto; display: block;">`;

    if (unvisitedSelectableStages.length === 0 && actualWaypoints.length <= 2) {
        modal.innerHTML = `
            <style>
                #deviation-modal {
                    position: fixed; top: 10px; left: 10px; transform: none; max-width: 480px; width: calc(100% - 20px);
                    background-color: #E6D6A8; padding: 20px; border-radius: 10px; box-shadow: 0 0 15px rgba(0,0,0,0.5); z-index: 9000; text-align: center;
                    display: flex;
                    flex-direction: column;
                    max-height: 85vh;
                }
                #deviation-modal h2 { font-size: 1.5rem; margin-bottom: 10px; color: #333; flex-shrink: 0; }
                #deviation-modal p { font-size: 1.1rem; line-height: 1.4; margin-bottom: 15px; flex-shrink: 0; font-weight: bold; } /* Texto en negrita */
                #deviation-modal button { 
                    padding: 12px 15px; border: none; border-radius: 5px; font-size: 1.1rem; font-weight: bold; cursor: pointer; transition: background-color 0.2s ease;
                    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
                    flex-shrink: 0;
                }
                #deviation-modal #deviation-accept-simple { background-color: #28a745; color: white; }
            </style>
            <h2>Desvo Detectado</h2>
            ${iconHtml}
            <p id="deviation-modal-message">Se ha detectado un desvo de ruta.</p>
            <div class="modal-top-buttons" style="justify-content: center;">
                <button id="deviation-accept-simple">Aceptar <span class="button-countdown-timer"></span></button>
            </div>
        `;
        modal.classList.remove('hidden');
        const acceptButton = modal.querySelector('#deviation-accept-simple');
        acceptButton.addEventListener('click', (e) => {
            e.stopPropagation();
            closeModalAndProceed();
        });
        addModalAutoCloseTimer(modal, acceptButton, 'deviation-modal', 3000);
        recalculateAndDrawRoute(true);
        return;
    }

    const finalDestination = actualWaypoints[actualWaypoints.length - 1];
    const stageButtonsHtml = unvisitedSelectableStages.map(wp => {
        const addressSummary = wp.address ? (wp.address.split(',')[0].trim()) : `Etapa ${wp.label}`;
        return `<button class="deviation-stage-button" data-waypoint-id="${wp.id}">ETAPA ${wp.label}: ${addressSummary}</button>`;
    }).join('');

    modal.innerHTML = `
        <style>
            #deviation-modal {
                position: fixed; top: 10px; left: 10px; transform: none; max-width: 480px; width: calc(100% - 20px);
                background-color: #E6D6A8; padding: 20px; border-radius: 10px; box-shadow: 0 0 15px rgba(0,0,0,0.5); z-index: 9000; text-align: center;
                display: flex;
                flex-direction: column;
                max-height: 85vh;
            }
            #deviation-modal h2 { font-size: 1.5rem; margin-bottom: 10px; color: #333; flex-shrink: 0; }
            #deviation-modal p { font-size: 1rem; line-height: 1.4; margin-bottom: 15px; flex-shrink: 0; font-weight: bold; } /* Texto en negrita */
            #deviation-modal .deviation-options-container {
                display: flex;
                flex-direction: column;
                flex-grow: 1;
                overflow: hidden;
            }
            #deviation-modal .stage-list-scroll-container {
                overflow-y: auto;
                display: flex;
                flex-direction: column;
                gap: 10px;
                padding: 10px;
                margin: 5px 0;
                border-top: 2px solid #C0B080;
                border-bottom: 2px solid #C0B080;
                background-color: black;
                border-radius: 6px;
            }
            #deviation-modal #scroll-hint-text {
                font-size: 0.85rem;
                font-style: italic;
                color: #555;
                margin-top: 5px;
                margin-bottom: -5px;
                display: none;
            }
            #deviation-modal button { 
                padding: 12px 15px; border: none; border-radius: 5px; font-size: 1.1rem; font-weight: bold; cursor: pointer; transition: background-color 0.2s ease;
                white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
                flex-shrink: 0;
            }
            #deviation-modal #deviation-go-to-final { background-color: #28a745; color: white; margin-bottom: 5px; }
            #deviation-modal .deviation-stage-button { background-color: #007bff; color: white; }
            #deviation-modal #deviation-cancel { background-color: #6c757d; color: white; margin-top: 5px; }
        </style>
        <h2>Desvo Detectado</h2>
        ${iconHtml}
        <p>Elige tu prximo destino. <strong>Nota:</strong> Al seleccionar una etapa, las anteriores se marcarn como visitadas y se omitirn.</p>
        <div class="deviation-options-container">
            <button id="deviation-go-to-final">Ir a Destino Final (${finalDestination.address.split(',')[0].trim()})</button>
            <p id="scroll-hint-text"></p>
            <div class="stage-list-scroll-container">
                ${stageButtonsHtml}
            </div>
            <button id="deviation-cancel">Cancelar (Seguir Desviado)</button>
        </div>
    `;
    modal.classList.remove('hidden');
    const scrollContainer = modal.querySelector('.stage-list-scroll-container');
    const scrollHint = modal.querySelector('#scroll-hint-text');
    if (scrollContainer && scrollHint) {
        requestAnimationFrame(() => {
            if (scrollContainer.scrollHeight > scrollContainer.clientHeight) {
                const stageCount = scrollContainer.querySelectorAll('.deviation-stage-button').length;
                scrollHint.textContent = `Hay ${stageCount} etapas sin visitar (deslice para verlas todas y seleccione)`;
                scrollHint.style.display = 'block';
            }
        });
    }
    document.getElementById('deviation-go-to-final').addEventListener('click', (e) => {
        e.stopPropagation();
        handleFinalDestinationSelection();
    });
    document.querySelectorAll('.deviation-stage-button').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const waypointId = parseInt(e.currentTarget.dataset.waypointId);
            handleStageSelectionFromDeviationModal(waypointId);
        });
    });
    document.getElementById('deviation-cancel').addEventListener('click', (e) => {
        e.stopPropagation();
        isDeviationModalActive = false;
        deviationStartTime = 0;
        modal.classList.add('hidden');
    });
    addModalAutoCloseTimer(modal, document.getElementById('deviation-go-to-final'), 'deviation-modal', 30000);
}    
    
    
    
    





    


    


    

    
    
    

// ===================================================================
// NOMBRE: showLoadRouteModal
// RESUMEN: Muestra el modal para cargar o borrar rutas guardadas.
// ===================================================================
function showLoadRouteModal() {
    clearAllWaypointMarkersFromMap();
    if (navigationMapInstance) {
        if (navigationRouteLayer) navigationMapInstance.removeLayer(navigationRouteLayer);
        if (completedRouteSegmentsLayer) completedRouteSegmentsLayer.clearLayers();
    }
    navigationWaypoints = [];
    navigationRouteLayer = null;
    navigationCurrentRouteData = null;
    isNavigating = false;
    lastValidCarDistanceForDisplay = 0;
    tripInitialOverallEtaTime = null; currentStageInitialExpectedEtaTime = null; accumulatedDeviationMs = 0;
    accumulatedDistanceBeforeCurrentSegment = 0;
    totalDistanceTravelledForStats = 0;
    maxSpeedDuringTrip = 0; maxAltitudeDuringTrip = -Infinity; minAltitudeDuringTrip = Infinity;


    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    hideNavigationUI();
    hideMapInfoOverlay();

    eliminarRadaresDeRuta();
    actualizarContadorRadares(0);
    eliminarTareasDeBarraProgreso();
    actualizarContadorTareas(0);


    const existingModal = document.getElementById('saved-routes-modal');
    if (existingModal) existingModal.remove();

    const modal = document.createElement('div');
    modal.id = 'saved-routes-modal';
    modal.innerHTML = `
        <h2>Cargar/Borrar Rutas Guardadas (Mx. ${MAX_SAVED_ROUTES})</h2>
        <div class="modal-top-buttons" style="justify-content: flex-end;">
             <button id="close-saved-routes-modal" style="flex: 0 1 auto; min-width: 120px;">Cerrar</button>
        </div>
        <div class="filter-container">
            <input type="text" id="filter-saved-routes" placeholder="FILTRAR RUTAS...">
            <button id="clear-filter-saved-routes" title="Limpiar filtro">X</button>
        </div>
        <ul id="saved-routes-list"></ul>
    `;
    document.body.appendChild(modal);

    const listElement = modal.querySelector('#saved-routes-list');
    const closeButton = modal.querySelector('#close-saved-routes-modal');
    const filterInput = modal.querySelector('#filter-saved-routes');
    const clearFilterButton = modal.querySelector('#clear-filter-saved-routes');

    if(closeButton){
        closeButton.style.backgroundColor = '#4A5568';
        closeButton.style.color = 'white';
        closeButton.style.border = '1px solid #2D3748';
        closeButton.style.fontWeight = 'bold';
        closeButton.onmouseover = () => closeButton.style.backgroundColor = '#2D3748';
        closeButton.onmouseout = () => closeButton.style.backgroundColor = '#4A5568';
    }


    let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
    savedRoutes.sort((a,b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

    function displayRoutes(routesToDisplay) {
        listElement.innerHTML = '';
        if (routesToDisplay.length === 0) {
            listElement.innerHTML = '<li>No hay rutas que coincidan con el filtro.</li>';
        } else {
            routesToDisplay.forEach(route => {
                const li = document.createElement('li');
                li.textContent = route.name;
                li.dataset.routeName = route.name;

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Borrar';
                deleteBtn.className = 'delete-route-btn';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    let currentSavedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
                    currentSavedRoutes = currentSavedRoutes.filter(r => r.name !== route.name);
                    localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(currentSavedRoutes));
                    savedRoutes = currentSavedRoutes;
                    filterRoutes();
                    markCacheAsDirty()
                    showToast(`Ruta "${route.name}" borrada`, "info");
                };
                li.appendChild(deleteBtn);

                li.addEventListener('click', () => {
                    loadRouteByName(route.name, true);
                    clearModalAutoCloseTimer(modal, closeButton, 'saved-routes-modal');
                    if (modal.parentNode) modal.remove();
                });
                listElement.appendChild(li);
            });
        }
    }

    function filterRoutes() {
        const filterText = filterInput.value.toUpperCase().trim();
        if (!filterText) {
            displayRoutes(savedRoutes);
            clearFilterButton.style.display = 'none';
            return;
        }
        clearFilterButton.style.display = 'inline-block';
        const filtered = savedRoutes.filter(route => route.name.toUpperCase().includes(filterText));
        displayRoutes(filtered);
    }

    filterInput.addEventListener('input', filterRoutes);
    clearFilterButton.addEventListener('click', () => {
        filterInput.value = '';
        filterRoutes();
    });
    filterRoutes();

    const closeHandler = () => {
        clearModalAutoCloseTimer(modal, closeButton, 'saved-routes-modal');
        if (modal.parentNode) modal.remove();
    };
    closeButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(modal, closeButton, 'saved-routes-modal', 30000);
}


    

    
    
    
    


// ===================================================================
// NOMBRE: toggleNavigationState (MODIFICADA)
// RESUMEN: Inicia o detiene el modo de navegacin, implementando la lgica de "inicio de viaje diferido".
// ===================================================================
function toggleNavigationState(isRecalculationStop = false) {
    const startNavButton = document.getElementById('start-navigation-button');
    const startNavImg = startNavButton ? startNavButton.querySelector('img') : null;
    const mapContainer = document.getElementById('reminders-location-map-div');

    if (isNavigating) {
        // --- Lgica para DETENER la navegacin ---
        isNavigating = false;
        navigationFollowUser = false;
        tripStartLocationForStats = null; // Limpiar la ubicacin de inicio
        if(startNavImg) startNavImg.src = "INICIARNAVEGACION.PNG";
        if(startNavButton) startNavButton.classList.remove('navigating');
        if (mapContainer) mapContainer.classList.remove('navigating');
        setNavigationMapClickHandler();
        navigationWaypoints.forEach(wp => { if (wp && wp.marker && wp.marker.dragging) wp.marker.dragging.enable(); });
        showToast("Navegacin finalizada", "info", 3000);
        if (!isRecalculationStop && !isArrivalSequenceStarted) {
            if (!document.getElementById('arrival-stats-modal') || document.getElementById('arrival-stats-modal').classList.contains('hidden')) {
                showArrivalStatsModal();
            }
        }
        mapHeaderButtonsVisible = true; 
        toggleMapHeaderRowsVisibility(true); 
        if (locationWatchId !== null) {
            navigator.geolocation.clearWatch(locationWatchId);
            locationWatchId = null;
        }
        if (gpsRetryTimeoutId) {
            clearTimeout(gpsRetryTimeoutId);
            gpsRetryTimeoutId = null;
        }
        gpsRetryAttempt = 0;
    } else {
        // --- Lgica para INICIAR la navegacin ---
        if (!navigationCurrentRouteData || !navigationCurrentRouteData.routes || navigationCurrentRouteData.routes.length === 0 || navigationWaypoints.filter(wp => !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
            showToast("No hay ruta calculada para iniciar la navegacin", "warning");
            return;
        }
        clearNavigationGraph();
        if(startNavImg) startNavImg.src = "TERMINARNAVEGACION.PNG";
        showToast("Iniciando GPS para comenzar navegacin...", "info", 0, false, "gps-init-toast");
        navigationWaypoints.forEach(wp => {
            if(wp) {
                if (wp.type === 'S' || wp.type === 'S_Recalc') {
                    wp.visited = true; 
                } else {
                    wp.visited = false; 
                }
                if (wp.marker && wp.marker.dragging) wp.marker.dragging.disable();
            }
        });
        renderWaypointMarkers();
        getCurrentLocation(
            (initialCoords) => {
                navigationCurrentLocation = initialCoords;
                updateInitialUserPosition(initialCoords, navigationMapInstance);
            },
            (errorMsg) => {
                showToast(`No se pudo obtener tu ubicacin inicial: ${errorMsg}. El mapa se centrar cuando el GPS est listo.`, "warning", 5000);
            }
        );
        startGpsWatching();
        const loadingToast = document.getElementById("gps-init-toast");
        if (loadingToast) loadingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== "gps-init-toast");
        isNavigating = true;
        shouldCenterOnUser = true; 
        navigationFollowUser = true; 
        const locateMeButton = document.getElementById('locate-me-on-reminders-map');
        const locateMeImg = locateMeButton ? locateMeButton.querySelector('img') : null;
        if(locateMeImg) locateMeImg.src = "DEJARSEGUIR.PNG";
        if(locateMeButton) locateMeButton.title = "Dejar de centrar el mapa automticamente en mi posicin";
        if (navigationMapInstance && navigationCurrentLocation) {
            const mapSize = navigationMapInstance.getSize();
            const progressBar = document.getElementById('navigation-bottom-progress-bar');
            let progressBarHeight = 0;
            if (progressBar && progressBar.offsetParent !== null && progressBar.style.display !== 'none') {
                progressBarHeight = progressBar.offsetHeight;
            }
            const offsetFactor = 0.25; 
            const minMapDimension = Math.min(mapSize.x, mapSize.y);
            const offsetDistance = minMapDimension * offsetFactor;
            const effectiveHeading = (navigationCurrentLocation && typeof navigationCurrentLocation.heading === 'number' && navigationCurrentLocation.heading !== null) ? navigationCurrentLocation.heading : (currentMapBearing || 0);
            const headingRad = (effectiveHeading % 360) * Math.PI / 180;
            let calculatedInitialMapCenterOffset = { x: 0, y: 0 };
            calculatedInitialMapCenterOffset.x = -offsetDistance * Math.sin(headingRad);
            calculatedInitialMapCenterOffset.y = offsetDistance * Math.cos(headingRad);
            const isGoingNorth = (effectiveHeading <= 60 || effectiveHeading >= 300);
            const isGoingSouth = effectiveHeading > 120 && effectiveHeading < 240;
            if (progressBarHeight > 0) { 
                if (isGoingNorth) {
                    calculatedInitialMapCenterOffset.y -= progressBarHeight * 1.4; 
                } else if (isGoingSouth) {
                    calculatedInitialMapCenterOffset.y += progressBarHeight * 1.3; 
                }
            }
            const vehicleLatLng = L.latLng(navigationCurrentLocation.latitude, navigationCurrentLocation.longitude);
            const vehicleScreenPos = navigationMapInstance.project(vehicleLatLng);
            const idealInitialMapCenterScreenPos = L.point(
                vehicleScreenPos.x - calculatedInitialMapCenterOffset.x,
                vehicleScreenPos.y - calculatedInitialMapCenterOffset.y
            );
            const idealInitialMapCenterLatLng = navigationMapInstance.unproject(idealInitialMapCenterScreenPos);
            const targetZoom = Math.min(navigationMapInstance.getMaxZoom() || 19, 17); 
            navigationMapInstance.setView(idealInitialMapCenterLatLng, targetZoom, {
                animate: true,
                duration: 0.8,
                easeLinearity: 0.75
            });
            targetMapCenterOffset = { ...calculatedInitialMapCenterOffset };
        }
        mapHeaderButtonsVisible = false;
        toggleMapHeaderRowsVisibility(false);
        if(startNavButton) startNavButton.classList.add('navigating');
        if (mapContainer) mapContainer.classList.add('navigating');
        setNavigationMapClickHandler();

        // --- LGICA DE INICIO DIFERIDO ---
        // 1. Guardamos la ubicacin de inicio, pero no la hora.
        tripStartLocationForStats = { ...navigationCurrentLocation };
        navigationStartTimeForStats = null; // Se pone a null para indicar que el viaje "real" no ha empezado.
        
        // 2. Reseteamos las dems estadsticas.
        totalDistanceTravelledForStats = 0;
        maxDistanceReachedOnRoute = 0; 
        maxSpeedDuringTrip = 0; 
        maxSpeedCoordinates = null; 
        maxAltitudeDuringTrip = -Infinity; 
        minAltitudeDuringTrip = Infinity; 
        lastPositionForStats = {...navigationCurrentLocation};
        tripInitialOverallEtaTime = null; 
        currentStageInitialExpectedEtaTime = null;
        accumulatedDeviationMs = 0;

        if (speedMilestoneLayer) speedMilestoneLayer.clearLayers();
        lastSpeedMilestone = 0;
        if (compassAndModeControl) {
            compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip); 
        }
        
        // El resto de la inicializacin de la navegacin
        navigationWaypoints.forEach(wp => { if (wp && wp.marker && wp.marker.dragging) wp.marker.dragging.disable(); });
        showToast("Navegacin iniciada. Esperando movimiento...", "success");
        currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviacin ETA';
        initializeNavigationGraph();
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        updateDirectionWarningCardsVisibility();
    } 
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    actualizarContadorRadares(radaresEnRutaActual.length);
    actualizarContadorTareas(tareasEnRutaActual.length);
    updateDirectionWarningCardsVisibility();
}

// ===================================================================
// NOMBRE: updateInitialUserPosition (MODIFICADA)
// RESUMEN: Actualiza el icono del coche y gestiona el auto-inicio y el inicio "real" del viaje.
// ===================================================================
function updateInitialUserPosition(coords, mapInstanceToUse) {
    if (!mapInstanceToUse || !coords || typeof coords.latitude !== 'number' || typeof coords.longitude !== 'number') {
        return;
    }
    const latLng = L.latLng(coords.latitude, coords.longitude);
    initialUserLocationMarkerLat = coords.latitude; initialUserLocationMarkerLng = coords.longitude;
    if (!initialUserLocationMarker) {
        initialUserLocationMarker = L.marker(latLng, { icon: vehicleIcon, zIndexOffset: 1000, interactive: false });
        if (mapInstanceToUse && mapInstanceToUse.getPane) { try { initialUserLocationMarker.addTo(mapInstanceToUse); } catch (e) { return; } } else { return; }
    } else { initialUserLocationMarker.setLatLng(latLng); }
    const currentHeading = (coords && typeof coords.heading === 'number' && coords.heading !== null) ? coords.heading : (currentMapBearing || 0);
    const vehicleWrapper = initialUserLocationMarker.getElement()?.querySelector('#vehicle-icon-wrapper');
    if (vehicleWrapper) { let iconRotationAngle = currentHeading - 90; vehicleWrapper.style.transform = `rotate(${iconRotationAngle}deg)`; }
    if (compassAndModeControl) {
        compassAndModeControl.updateOrientation(currentHeading); compassAndModeControl.updateAltitude(coords.altitude);
        if (window.lastPositionForSpeedCalc && typeof coords.latitude === 'number' && typeof coords.longitude === 'number' && typeof coords.speed === 'number' && coords.speed !== null) { const distM = calculateDistance(window.lastPositionForSpeedCalc.latitude, window.lastPositionForSpeedCalc.longitude, coords.latitude, coords.longitude); const timeS = (Date.now() - window.lastPositionForSpeedCalc.time) / 1000; if (timeS > 0 && distM >= 0) { let speedMs = coords.speed; if (typeof speedMs !== 'number' || speedMs === null || speedMs < 0) { speedMs = distM / timeS; } window.currentSpeedKmh = speedMs * 3.6; } else { window.currentSpeedKmh = 0; } } else { if (typeof coords.speed === 'number' && coords.speed !== null && coords.speed >= 0) { window.currentSpeedKmh = coords.speed * 3.6; } else { window.currentSpeedKmh = 0; } }
        window.lastPositionForSpeedCalc = { latitude: coords.latitude, longitude: coords.longitude, time: Date.now() };
        if (isNavigating || (isSimulatingGpsLocation && automatedSimulationIntervalId)) { if (window.currentSpeedKmh > maxSpeedDuringTrip) { maxSpeedDuringTrip = window.currentSpeedKmh; if (coords) { maxSpeedCoordinates = { lat: coords.latitude, lng: coords.longitude }; } } const currentSpeed = window.currentSpeedKmh; for (const milestone of SPEED_MILESTONES) { if (currentSpeed >= milestone && lastSpeedMilestone < milestone) { const milestoneIcon = L.divIcon({ className: 'speed-milestone-icon', html: `<div style="background-color: #007bff; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; border: 2px solid white; box-shadow: 0 0 4px black;">${milestone}</div>`, iconSize: [36, 36], iconAnchor: [18, 18] }); if (speedMilestoneLayer) { L.marker([coords.latitude, coords.longitude], { icon: milestoneIcon }).addTo(speedMilestoneLayer); } lastSpeedMilestone = milestone; break; } } if (currentSpeed < lastSpeedMilestone) { let newMilestone = 0; for (let i = SPEED_MILESTONES.length - 1; i >= 0; i--) { if (currentSpeed >= SPEED_MILESTONES[i]) { newMilestone = SPEED_MILESTONES[i]; break; } } lastSpeedMilestone = newMilestone; } if (coords.altitude !== null && !isNaN(coords.altitude)) { maxAltitudeDuringTrip = Math.max(maxAltitudeDuringTrip, coords.altitude); minAltitudeDuringTrip = Math.min(minAltitudeDuringTrip, coords.altitude); } }
        
        // --- LGICA DE VELOCIDAD MEDIA ---
        if (isNavigating && navigationStartTimeForStats && typeof totalDistanceTravelledForStats === 'number') {
            if (lastPositionForStats && coords) {
                const distanceIncrement = calculateDistance(lastPositionForStats.latitude, lastPositionForStats.longitude, coords.latitude, coords.longitude);
                if (distanceIncrement > 0 && distanceIncrement < 5000) {
                    totalDistanceTravelledForStats += distanceIncrement;
                }
            }
            lastPositionForStats = { ...coords };
            if (totalDistanceTravelledForStats > 300) {
                const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000;
                if (timeElapsedS > 0) {
                    const avgSpeedMs = totalDistanceTravelledForStats / timeElapsedS;
                    window.averageSpeedKmh = avgSpeedMs * 3.6;
                } else {
                    window.averageSpeedKmh = 0;
                }
            } else {
                 window.averageSpeedKmh = 0;
            }
        } else if (isSimulatingGpsLocation && automatedSimulationIntervalId && navigationStartTimeForStats && typeof simulatedDistanceAlongRoute === 'number') {
            const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000;
            if (timeElapsedS > 0 && simulatedDistanceAlongRoute > 50) { 
                const avgSpeedMs = simulatedDistanceAlongRoute / timeElapsedS;
                window.averageSpeedKmh = avgSpeedMs * 3.6;
            } else {
                window.averageSpeedKmh = 0;
            }
        } else {
            window.averageSpeedKmh = 0;
        }

        compassAndModeControl.updateCurrentSpeed(window.currentSpeedKmh);
        compassAndModeControl.updateAverageSpeed(window.averageSpeedKmh);
        compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip);
    }

    // --- LGICA DE AUTO-INICIO DE NAVEGACIN ---
    if (!isNavigating && navigationWaypoints.length >= 2) {
        const startWp = navigationWaypoints.find(wp => wp.type === 'S');
        const finalWp = navigationWaypoints.find(wp => wp.type === 'F');
        if (startWp && finalWp && !finalWp.visited) {
            const distanceFromStart = calculateDistance(coords.latitude, coords.longitude, startWp.lat, startWp.lng);
            if (distanceFromStart > 50) {
                showToast("Movimiento detectado. Iniciando navegacin...", "info", 3000);
                toggleNavigationState(); 
            }
        }
    }

    // --- LGICA DE INICIO DE VIAJE "REAL" ---
    if (isNavigating && !navigationStartTimeForStats && tripStartLocationForStats) {
        const distanceFromTripStart = calculateDistance(
            coords.latitude, coords.longitude,
            tripStartLocationForStats.latitude, tripStartLocationForStats.longitude
        );
        if (distanceFromTripStart > 50) {
            navigationStartTimeForStats = new Date(); // El viaje "real" empieza AHORA!
            totalDistanceTravelledForStats = 0; // Reiniciamos el contador de distancia
            lastPositionForStats = { ...coords };
            
            // Recalculamos los ETAs desde este punto
            const route = navigationCurrentRouteData.routes[0];
            const remainingDistance = Math.max(0, route.distance - lastCarDistanceAlongRouteForNavLogic);
            const remainingDuration = route.distance > 0 ? route.duration * (remainingDistance / route.distance) : 0;
            tripInitialOverallEtaTime = new Date(Date.now() + remainingDuration * 1000);

            if (route.legs && route.legs.length > 0) {
                const leg = route.legs[currentLegIndexNav];
                if (leg) {
                    const distanceIntoCurrentLeg = Math.max(0, lastCarDistanceAlongRouteForNavLogic - calculateDistanceToEndOfStep(route, currentLegIndexNav - 1, -1));
                    const remainingDistanceThisLeg = Math.max(0, leg.distance - distanceIntoCurrentLeg);
                    const remainingDurationThisLeg = leg.distance > 0 ? leg.duration * (remainingDistanceThisLeg / leg.distance) : 0;
                    currentStageInitialExpectedEtaTime = new Date(Date.now() + remainingDurationThisLeg * 1000);
                }
            }
            showToast("Viaje iniciado! Calculando ETA...", "success", 3000);
        }
    }
    
    // El resto de la funcin (lgica de seguimiento del mapa) no cambia
    const shouldFollow = shouldCenterOnUser || navigationFollowUser;
    if (shouldFollow && navigationMapInstance && !isFlying) {
        const finalZoom = navigationTargetZoom !== null ? navigationTargetZoom : navigationMapInstance.getZoom();
        const effectiveHeading = (coords && typeof coords.heading === 'number' && coords.heading !== null) ? coords.heading : (currentMapBearing || 0);
        const mapSize = mapInstanceToUse.getSize();
        const offsetFactor = 0.25;
        const minMapDimension = Math.min(mapSize.x, mapSize.y);
        const offsetDistance = minMapDimension * offsetFactor;
        const headingRad = (effectiveHeading % 360) * Math.PI / 180;
        targetMapCenterOffset = { x: -offsetDistance * Math.sin(headingRad), y: offsetDistance * Math.cos(headingRad) };
        const vehicleLatLng = L.latLng(coords.latitude, coords.longitude);
        const vehicleScreenPos = navigationMapInstance.project(vehicleLatLng);
        const idealMapCenterScreenPos = L.point(vehicleScreenPos.x - targetMapCenterOffset.x, vehicleScreenPos.y - targetMapCenterOffset.y);
        const idealMapCenterLatLng = navigationMapInstance.unproject(idealMapCenterScreenPos);
        if (currentSmoothedMapCenter === null) {
            currentSmoothedMapCenter = idealMapCenterLatLng;
        }
        const lerpFactor = 0.1;
        currentSmoothedMapCenter = L.latLng(
            currentSmoothedMapCenter.lat + (idealMapCenterLatLng.lat - currentSmoothedMapCenter.lat) * lerpFactor,
            currentSmoothedMapCenter.lng + (idealMapCenterLatLng.lng - currentSmoothedMapCenter.lng) * lerpFactor
        );
        const currentZoom = navigationMapInstance.getZoom();
        const zoomDifference = Math.abs(currentZoom - finalZoom);
        if (zoomDifference > 0.05 || currentSmoothedMapCenter.distanceTo(navigationMapInstance.getCenter()) > 1) {
            isFlying = true;
            navigationMapInstance.flyTo(currentSmoothedMapCenter, finalZoom, {
                animate: true,
                duration: 1.0,
                easeLinearity: 0.5
            });
            setTimeout(() => { isFlying = false; }, 1050);
        }
    } else {
        currentSmoothedMapCenter = null;
    }
    navigationTargetZoom = null;
    updateDirectionWarningCardsVisibility();
}



    

    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: smoothZoomAnimation
    // RESUMEN: Realiza una animacin de zoom suave usando requestAnimationFrame.
    // ===================================================================
    function smoothZoomAnimation(startZoom, endZoom, duration = 1200) {
        if (isAnimatingZoom || !navigationMapInstance) return;
        isAnimatingZoom = true;
        const startTime = performance.now();
        function animate(currentTime) {
            const elapsedTime = currentTime - startTime;
            const progress = Math.min(elapsedTime / duration, 1);
            const currentZoom = startZoom + (endZoom - startZoom) * progress;
            let targetCenter = navigationMapInstance.getCenter();
            if (navigationCurrentLocation) {
                const vehicleLatLng = L.latLng(navigationCurrentLocation.latitude, navigationCurrentLocation.longitude);
                const vehicleScreenPos = navigationMapInstance.project(vehicleLatLng);
                const idealMapCenterScreenPos = L.point(
                    vehicleScreenPos.x - targetMapCenterOffset.x,
                    vehicleScreenPos.y - targetMapCenterOffset.y
                );
                targetCenter = navigationMapInstance.unproject(idealMapCenterScreenPos);
            }
            navigationMapInstance.setView(targetCenter, currentZoom, { animate: false });
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                isAnimatingZoom = false;
            }
        }
        requestAnimationFrame(animate);
    }
    
    
    
    





// ===================================================================
// NOMBRE: addModalAutoCloseTimer
// RESUMEN: Aade un temporizador de autocierre a un modal.
// ===================================================================
function addModalAutoCloseTimer(modalElement, closeButtonElement, modalId, duration = 60000) {
    if (!modalElement || !closeButtonElement || !modalId) {
        return;
    }
    modalElement.dataset.modalTimerId = modalId;
    clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId);
    let countdown = duration / 1000;
    const originalButtonText = closeButtonElement.textContent.split(' (')[0];
    const countdownSpanId = `modal-countdown-${modalId}`;
    let countdownSpan = closeButtonElement.querySelector(`.button-countdown-timer`);
    if (!countdownSpan) {
        countdownSpan = document.createElement('span');
        countdownSpan.className = 'button-countdown-timer';
        countdownSpan.style.marginLeft = '5px';
        countdownSpan.style.fontWeight = 'normal';
        closeButtonElement.appendChild(countdownSpan);
    }
    countdownSpan.textContent = ` (${countdown})`;
    const intervalId = setInterval(() => {
        countdown--;
        if (countdownSpan && document.body.contains(countdownSpan)) {
          countdownSpan.textContent = ` (${countdown})`;
        }
        if (countdown <= 0) {
            if (globalModalTimers[modalId]) {
                clearInterval(globalModalTimers[modalId].intervalId);
                delete globalModalTimers[modalId];
            }
            if (closeButtonElement && document.body.contains(closeButtonElement)) {
                closeButtonElement.click();
            } else if (modalElement && modalElement.parentNode) {
                 if (!STATIC_MODAL_IDS.includes(modalElement.id)) {
                    modalElement.parentNode.removeChild(modalElement);
                 } else {
                    modalElement.classList.add('hidden');
                 }
            }
        }
    }, 1000);
    const resetTimerHandler = () => {
        if (!globalModalTimers[modalId] || !globalModalTimers[modalId].intervalId) return;
        clearInterval(globalModalTimers[modalId].intervalId);
        countdown = duration / 1000;
        if (countdownSpan && document.body.contains(countdownSpan)) {
           countdownSpan.textContent = ` (${countdown})`;
        }
        const newIntervalId = setInterval(() => {
            countdown--;
            if (countdownSpan && document.body.contains(countdownSpan)) {
                countdownSpan.textContent = ` (${countdown})`;
            }
            if (countdown <= 0) {
                if (globalModalTimers[modalId]) {
                    clearInterval(globalModalTimers[modalId].intervalId);
                    delete globalModalTimers[modalId];
                }
                if (closeButtonElement && document.body.contains(closeButtonElement)) {
                    closeButtonElement.click();
                } else if (modalElement && modalElement.parentNode) {
                    if (!STATIC_MODAL_IDS.includes(modalElement.id)) {
                       modalElement.parentNode.removeChild(modalElement);
                    } else {
                       modalElement.classList.add('hidden');
                    }
                }
            }
        }, 1000);
        globalModalTimers[modalId].intervalId = newIntervalId;
    };
    modalElement.addEventListener('click', resetTimerHandler);
    modalElement.addEventListener('touchstart', resetTimerHandler, { passive: true });
    modalElement.addEventListener('input', resetTimerHandler);
    modalElement.addEventListener('scroll', resetTimerHandler, { passive: true });
    globalModalTimers[modalId] = {
        intervalId: intervalId,
        resetHandler: resetTimerHandler,
        modalElement: modalElement,
        closeButtonElement: closeButtonElement,
        countdownSpan: countdownSpan
    };
}


    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: proceedWithRecalculation
    // RESUMEN: Gestiona la lgica de reclculo de ruta segn la accin del usuario.
    // ===================================================================
    async function proceedWithRecalculation(action) {
        if (!isNavigating || !navigationCurrentLocation) {
            showToast("No se puede recalcular: no se est navegando o la ubicacin es desconocida.", "error");
            return;
        }
        if (action === 'skip_one') {
            const nextUnvisitedStageIndex = navigationWaypoints.findIndex(wp => wp && !wp.isInternal && !wp.isRecalculatedStart && !wp.visited && wp.type !== 'S' && wp.type !== 'S_Recalc');
            if (nextUnvisitedStageIndex !== -1) {
                navigationWaypoints[nextUnvisitedStageIndex].visited = true;
                showToast(`Omitiendo etapa: ${navigationWaypoints[nextUnvisitedStageIndex].address || 'Siguiente' }`, "info");
            } else {
                showToast("No hay prximas etapas para omitir. Recalculando a destino.", "info");
            }
        } else if (action === 'skip_multiple') {
            const stagesToSkip = [];
            const currentHeading = navigationCurrentLocation.heading;
            navigationWaypoints.forEach(wp => {
                if (wp.visited || wp.type === 'S' || wp.type === 'S_Recalc') return;
                const bearingToWp = turf.bearing(
                    turf.point([navigationCurrentLocation.longitude, navigationCurrentLocation.latitude]),
                    turf.point([wp.lng, wp.lat])
                );
                let angleDiff = Math.abs(currentHeading - (bearingToWp < 0 ? bearingToWp + 360 : bearingToWp));
                if (angleDiff > 180) angleDiff = 360 - angleDiff;
                if (angleDiff > 110) {
                    stagesToSkip.push(wp.id);
                }
            });
            if (stagesToSkip.length > 0) {
                navigationWaypoints.forEach(wp => {
                    if (stagesToSkip.includes(wp.id)) wp.visited = true;
                });
                showToast(`Saltando ${stagesToSkip.length} etapas que han quedado atrs.`, "info");
            }
        }
        await recalculateAndDrawRoute(true);
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: closeModalAndProceed
    // RESUMEN: Cierra el modal de desvo y ejecuta la accin de reclculo seleccionada.
    // ===================================================================
    function closeModalAndProceed(action) {
        if (deviationModalTimerId) {
            clearInterval(deviationModalTimerId);
            deviationModalTimerId = null;
        }
        const modal = document.getElementById('deviation-modal');
        if (modal) {
            const primaryButton = modal.querySelector('#deviation-primary') || modal.querySelector('button');
            clearModalAutoCloseTimer(modal, primaryButton, 'deviation-modal');
            modal.classList.add('hidden');
        }
        isDeviationModalActive = false;
        deviationStartTime = 0;
        proceedWithRecalculation(action);
    }
    
    
    
    



// ===================================================================
// NOMBRE: restoreBackup
// RESUMEN: Restaura los datos locales desde un cdigo de backup manual.
// ===================================================================
function restoreBackup() {
    const restoreInput = document.getElementById('config-restore-input');
    const backupStringBase64 = restoreInput.value.trim();
    const statusEl = document.getElementById('config-restore-status');
    statusEl.textContent = '';
    if (!backupStringBase64) {
        statusEl.textContent = 'Pega el cdigo de backup primero.';
        statusEl.style.color = '#EF4444';
        return;
    }
    try {
        const backupString = decodeURIComponent(escape(atob(backupStringBase64)));
        const backupData = JSON.parse(backupString);
        let restoredCount = 0;
        let incompatibleCount = 0;
        if (confirm('Esto sobreescribir tus datos actuales con los del backup. Ests seguro?')) {
            Object.keys(backupData).forEach(key => {
                if (managedKeys.includes(key)) {
                    localStorage.setItem(key, backupData[key]);
                    restoredCount++;
                } else {
                    incompatibleCount++;
                }
            });
            loadCustomData();
            loadSavedSettings();
            updateUserIdDisplay();
            checkReminders();
            statusEl.textContent = `Restauracin completada. ${restoredCount} claves restauradas. ${incompatibleCount} claves ignoradas (incompatibles). La pgina se recargar.`;
            statusEl.style.color = '#28a745';
            showToast('Restauracin completada. Recargando...', 'success');
            setTimeout(() => location.reload(), 2500);
        } else {
             statusEl.textContent = 'Restauracin cancelada.';
             statusEl.style.color = '#6c757d';
        }
    } catch (e) {
        statusEl.textContent = 'Error: Cdigo de backup invlido o corrupto.';
        statusEl.style.color = '#EF4444';
        showToast('Error en el cdigo de backup', 'error');
    }
}





    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: clearNavigationGraph
    // RESUMEN: Limpia y oculta la grfica de navegacin.
    // ===================================================================
    function clearNavigationGraph() {
        if (graphIntervalTimer) {
            clearInterval(graphIntervalTimer);
            graphIntervalTimer = null;
        }
        if (navigationChart) {
            navigationChart.destroy();
            navigationChart = null;
        }
        const graphCard = document.getElementById('navigation-graph-card');
        if (graphCard) {
            graphCard.classList.add('hidden');
        }
        graphDataPoints = { speed: [], altitude: [] };
        graphLabels = [];
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: hideNavigationUI
    // RESUMEN: Oculta los elementos de la interfaz de usuario de navegacin.
    // ===================================================================
    function hideNavigationUI() {
        const topInfoBar = document.getElementById('navigation-top-info-bar');
        const bottomProgressBar = document.getElementById('navigation-bottom-progress-bar');
        const startNavButton = document.getElementById('start-navigation-button');
        const saveRouteButton = document.getElementById('save-route-button');
        const reorderBtn = document.getElementById('reorder-route-stages-button');
        const simulateBtn = document.getElementById('simulate-route-button');
        const toggleSimulateGpsBtn = document.getElementById('toggle-simulate-gps-button');
        const graphCard = document.getElementById('navigation-graph-card');
        if (topInfoBar) topInfoBar.style.display = 'none';
        if (bottomProgressBar) bottomProgressBar.style.display = 'none';
        if (startNavButton) startNavButton.classList.add('hidden');
        if (saveRouteButton) saveRouteButton.classList.add('hidden');
        if (reorderBtn) reorderBtn.style.display = 'none';
        if (simulateBtn) simulateBtn.style.display = 'none';
        if (graphCard) graphCard.classList.add('hidden');
        if (toggleSimulateGpsBtn && isSimulatingGpsLocation) {
        } else if (toggleSimulateGpsBtn) {
            toggleSimulateGpsBtn.style.display = 'none';
        }
        hideIntersectionPreviewMap();
        updateDirectionWarningCardsVisibility();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showNavigationUIElementsForPlanning
    // RESUMEN: Muestra los elementos de la UI para la planificacin de rutas.
    // ===================================================================
    function showNavigationUIElementsForPlanning() {
        const topInfoBar = document.getElementById('navigation-top-info-bar');
        const bottomProgressBar = document.getElementById('navigation-bottom-progress-bar');
        if (!navigationCurrentRouteData || !navigationCurrentRouteData.routes || navigationCurrentRouteData.routes.length === 0 || navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
            if (topInfoBar) topInfoBar.style.display = 'none';
            if (bottomProgressBar) bottomProgressBar.style.display = 'none';
            hideMapInfoOverlay();
            hideIntersectionPreviewMap();
        } else {
            if (topInfoBar) topInfoBar.style.display = 'flex';
            if (bottomProgressBar) bottomProgressBar.style.display = 'flex';
            let carDistAlongRoutePlan = 0;
            const currentCarPosForShowUI = navigationCurrentLocation;
            if (currentCarPosForShowUI && navigationMapInstance && navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
                try {
                    const carPointTurf = turf.point([currentCarPosForShowUI.longitude, currentCarPosForShowUI.latitude]);
                    const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                    const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                    const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                    carDistAlongRoutePlan = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                } catch(e){  }
             }
            updateTurnByTurnDisplay(navigationCurrentRouteData.routes[0], carDistAlongRoutePlan);
            showDestinationName();
        }
        updateDirectionWarningCardsVisibility();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getManeuverInstructionText
    // RESUMEN: Convierte una maniobra de OSRM en un texto legible.
    // ===================================================================
    function getManeuverInstructionText(maneuver) {
        if (!maneuver) return '';
        const type = maneuver.type || '';
        const modifier = maneuver.modifier || '';
        let exit = maneuver.exit;
        let key = `${type}-${modifier}`;
        let text = maneuverTexts[key];
        if (!text) {
            key = `${type}-`;
            text = maneuverTexts[key];
        }
        if (!text && type === 'turn' && !modifier) {
            text = maneuverTexts['turn-'] || type.replace(/-/g, ' ');
        } else if (!text) {
            text = type.replace(/-/g, ' ');
        }
        const roundaboutExitTypes = ['roundabout turn', 'exit roundabout', 'rotary', 'roundabout'];
        if (roundaboutExitTypes.includes(type) && typeof exit === 'number' && exit > 0) {
             const ordinals = ["", "primera", "segunda", "tercera", "cuarta", "quinta"];
             const ordinalText = (exit >= 1 && exit <= 5) ? ordinals[exit] : `${exit}`;
             text = `Sal en la rotonda en la ${ordinalText} salida`;
        }
        let baseText = text.charAt(0).toUpperCase() + text.slice(1);
        return baseText;
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: formatDeviation
    // RESUMEN: Formatea la desviacin de tiempo ETA con signo y color.
    // ===================================================================
    function formatDeviation(milliseconds) {
        if (typeof milliseconds !== 'number' || isNaN(milliseconds)) {
            return '';
        }
        const totalSeconds = Math.round(Math.abs(milliseconds) / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const sign = milliseconds >= 0 ? '+' : '-';
        const colorClass = milliseconds >= 0 ? 'positive' : 'negative';
        const formattedTime = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        return `<span class="eta-deviation ${colorClass}">[${sign}${formattedTime}]</span>`;
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateRouteAndCarIconStyle
    // RESUMEN: Ajusta el estilo de la lnea de ruta segn la capa de mapa activa.
    // ===================================================================
    function updateRouteAndCarIconStyle() {
        if (!navigationMapInstance) return;
        let activeLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "satlite + calles";
        activeLayerName = activeLayerName.toLowerCase();
        if (!localStorage.getItem(ACTIVE_MAP_LAYER_KEY) && mapLayersControl && mapLayersControl._map && mapLayersControl._map._layers) {
            const layersArray = Object.values(mapLayersControl._map._layers);
            const baseLayerMapObject = layersArray.find(l => l._map && l.options && !l.options.pane && l.options.attribution);
            if (baseLayerMapObject) {
                const activeLayerEntry = mapLayersControl._layers.find(l => l.layer === baseLayerMapObject);
                 if (activeLayerEntry && activeLayerEntry.name) {
                    activeLayerName = activeLayerEntry.name.toLowerCase();
                }
            }
        }
        if (navigationRouteLayer) {
            const isSatelliteViewForRoute = activeLayerName.includes('satlite') || activeLayerName.includes('satellite');
            if (isSatelliteViewForRoute) {
                navigationRouteLayer.setStyle({ 
                    color: 'yellow', 
                    weight: 10,
                    opacity: 1.0 
                });
            } else {
                navigationRouteLayer.setStyle({ 
                    color: 'blue', 
                    weight: 10,
                    opacity: 0.5
                });
            }
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: parseCoordinateFilter
    // RESUMEN: Parsea y aplica un filtro de coordenadas (valor nico o rango).
    // ===================================================================
    function parseCoordinateFilter(filterValue, coordinate) {
        if (!filterValue) return true;
        const parts = filterValue.trim().split(/\s+/).map(s => parseFloat(s.replace(',','.'))).filter(n => !isNaN(n));
        if (parts.length === 1) {
            return Math.abs(coordinate - parts[0]) < COORD_EPSILON;
        } else if (parts.length === 2) {
            const minVal = Math.min(parts[0], parts[1]);
            const maxVal = Math.max(parts[0], parts[1]);
            return coordinate >= minVal && coordinate <= maxVal;
        } else if (parts.length === 0 && filterValue.trim() !== "") {
            return false;
        }
        return true;
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: closeOtherModals
    // RESUMEN: Cierra todos los modales abiertos, excepto el especificado.
    // ===================================================================
    function closeOtherModals(modalToKeepOpenId = null) {
        STATIC_MODAL_IDS.forEach(id => {
            if (id === modalToKeepOpenId) return;
            const modal = document.getElementById(id);
            if (modal && !modal.classList.contains('hidden')) {
                if (id === 'reorder-stages-modal') {
                    const listElement = modal.querySelector('#sortable-stages-list');
                    if (listElement) {
                        listElement.removeEventListener('dragstart', handleDragStartReorder);
                        listElement.removeEventListener('dragend', handleDragEndReorder);
                        listElement.removeEventListener('dragover', handleDragOverReorder);
                        listElement.removeEventListener('touchstart', handleStageTouchStart);
                        listElement.removeEventListener('touchmove', handleStageTouchMove);
                        listElement.removeEventListener('touchend', handleStageTouchEnd);
                        listElement.removeEventListener('touchcancel', handleStageTouchEnd);
                    }
                    if (draggedStageLi) {
                        draggedStageLi.classList.remove('dragging');
                        draggedStageLi = null;
                    }
                    clearTimeout(stageScrollTimeout);
                    document.body.style.overflow = '';
                }
                 if (id === 'deviation-modal') {
                    if (deviationModalTimerId) clearInterval(deviationModalTimerId);
                    deviationModalTimerId = null;
                    isDeviationModalActive = false;
                }
                 if (id === 'arrival-stats-modal') {
                    const acceptButton = modal.querySelector('#arrival-stats-accept-button');
                    if (acceptButton) clearModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal');
                 }
                 if (id === 'simulation-speed-modal') {
                    const confirmBtn = modal.querySelector('#confirm-simulation-speed');
                    if(confirmBtn) clearModalAutoCloseTimer(modal, confirmBtn, 'simulation-speed-modal');
                 }
                modal.classList.add('hidden');
                const closeBtn = modal.querySelector('button[id^="close-"], button[id*="-close"], #cancel-postpone, #close-saved-routes-modal, #cancel-reorder-stages, #config-close-modal, #close-versions-modal, #pin-submit-button, #close-simulation-modal, #close-locations-preview, #close-address-suggestions-modal, #deviation-accept, #arrival-stats-accept-button, #cancel-simulation-speed');
                if (closeBtn) clearModalAutoCloseTimer(modal, closeBtn, id.replace(/-/g, '_') || `modal_timer_${Date.now()}`);
                 if (id === 'simulation-modal') {
                     if (simulationModalTimer) {
                         clearTimeout(simulationModalTimer);
                         simulationModalTimer = null;
                     }
                     hideIntersectionPreviewMap();
                 }
            }
        });
        document.querySelectorAll(
            '.choice-modal, .edit-modal, .edit-info-modal, .help-modal, .reminder-modal, .reminder-table-modal, #postpone-options-modal, .saved-locations-modal, #reminders-map-help-modal-instance'
        ).forEach(m => {
            if (m.id === modalToKeepOpenId) return;
            if (m.parentNode) {
                 const closeBtn = m.querySelector('button[id^="close-"], button[id*="-close"], #cancel-postpone');
                 if(closeBtn) clearModalAutoCloseTimer(m, closeBtn, m.id.replace(/-/g, '_') || `modal_timer_${Date.now()}`);
                 m.remove();
            }
        });
         if (modalToKeepOpenId !== 'unified-reminder-window') {
            hideUnifiedReminderWindow();
         }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showConfigModal
    // RESUMEN: Muestra el modal de configuracin principal, reseteando sus campos.
    // ===================================================================
    function showConfigModal() {
        closeOtherModals('config-modal');
        const modal = document.getElementById('config-modal');
        if (modal) {
            const firstTabButton = modal.querySelector('.config-tab-button[data-tab-target="#tab-content-usuario"]');
            const firstTabContent = modal.querySelector('#tab-content-usuario');
            if (firstTabButton && firstTabContent) {
                modal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                modal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                firstTabButton.classList.add('active');
                firstTabContent.classList.add('active');
            }
            const statusMessages = modal.querySelectorAll('.status-message');
            statusMessages.forEach(msg => msg.textContent = '');
            modal.querySelectorAll('input[type="text"], input[type="number"], textarea').forEach(input => {
                if (input.id !== 'user-id' && input.id !== 'config-pin-set' && input.id !== 'config-pin-confirm') {
                    input.value = '';
                }
            });
            modal.querySelector('#config-pin-set').value = '';
            modal.querySelector('#config-pin-confirm').value = '';
            modal.querySelector('#config-backup-display').value = '';
            modal.querySelector('#config-restore-input').value = '';
            if(modal.querySelector('#config-backup-display')) modal.querySelector('#config-backup-display').style.display = 'none';
            const userIdInput = modal.querySelector('#user-id');
            const storedUserId = localStorage.getItem('userData_userId');
            if (userIdInput && storedUserId) {
                userIdInput.value = storedUserId;
            } else if (userIdInput) {
                userIdInput.value = '';
            }
             const teslaModelInput = modal.querySelector('#tesla-model');
             if (teslaModelInput) teslaModelInput.value = localStorage.getItem('userData_teslaModel') || '';
             const teslaYearInput = modal.querySelector('#tesla-year');
             if (teslaYearInput) teslaYearInput.value = localStorage.getItem('userData_teslaYear') || '';
             const teslaProvinceInput = modal.querySelector('#tesla-province');
             if (teslaProvinceInput) teslaProvinceInput.value = localStorage.getItem('userData_teslaProvince') || '';
             const allowDmsCheckbox = modal.querySelector('#allow-dms');
             if (allowDmsCheckbox) allowDmsCheckbox.checked = JSON.parse(localStorage.getItem('userData_allowDMs')) || false;
            const directToNavCheckbox = document.getElementById('config-direct-to-nav');
            if (directToNavCheckbox) {
                directToNavCheckbox.checked = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
            }
            const backupDescSpan = modal.querySelector('#backup-data-description');
            if(backupDescSpan) backupDescSpan.textContent = managedDesc || 'No se pudo cargar descripcin.';
            const importRadarsButton = modal.querySelector('#import-radars-button');
            const deleteFilteredRadarsButton = modal.querySelector('#delete-filtered-radars-button');
            if (importRadarsButton && !importRadarsButton.dataset.listenerAttached) {
                importRadarsButton.addEventListener('click', importRadars);
                importRadarsButton.dataset.listenerAttached = "true";
            }
            if (deleteFilteredRadarsButton && !deleteFilteredRadarsButton.dataset.listenerAttached) {
                deleteFilteredRadarsButton.addEventListener('click', deleteFilteredRadars);
                deleteFilteredRadarsButton.dataset.listenerAttached = "true";
            }
            modal.classList.remove('hidden');
            const closeButtonConfig = modal.querySelector('#config-close-modal');
            addModalAutoCloseTimer(modal, closeButtonConfig, 'config-modal', 120000);
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: loadNotices
    // RESUMEN: Carga los avisos desde un archivo de texto externo.
    // ===================================================================
    async function loadNotices() { try { const r = await fetch('https://boardinggate.github.io/Tesla/avisos.txt', { cache: 'no-cache' }); if (!r.ok) throw new Error('Fetch failed'); const txt = await r.text(); notices = txt.split('\n').map(l => l.trim()).filter(l => l.length > 0); if (notices.length === 0) notices = ['No hay avisos.']; } catch (e) { notices = ['Error carga avisos.']; } updateNotice(); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateNotice
    // RESUMEN: Actualiza el texto del aviso visible en la pantalla.
    // ===================================================================
    function updateNotice() { const noticeElement = document.getElementById('current-notice'); if (!noticeElement || notices.length === 0) { return; } if (!isActive) { noticeElement.textContent = ''; noticeElement.style.animation = 'none'; return; } noticeElement.textContent = notices[currentNoticeIndex]; noticeElement.style.animation = 'none'; void noticeElement.offsetWidth; noticeElement.style.animation = 'fadeInOut 14s infinite'; currentNoticeIndex = (currentNoticeIndex + 1) % notices.length; }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleNotices
    // RESUMEN: Activa o desactiva la visualizacin de los avisos y el pie de pgina.
    // ===================================================================
    function toggleNotices() { isActive = !isActive; const nC = document.querySelector('.notices-container'); if (nC) nC.style.display = isActive ? 'flex' : 'none'; const fC = document.querySelector('footer'); if (fC) fC.classList.toggle('footer-hidden', !isActive); isFooterVisible = isActive; const nE = document.getElementById('current-notice'); if (nE) { if (!isActive) { nE.textContent = ''; nE.style.animation = 'none'; } else { currentNoticeIndex = 0; updateNotice(); } } saveSettings(); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: startNoticeRotation
    // RESUMEN: Inicia la rotacin peridica de los avisos.
    // ===================================================================
    function startNoticeRotation() { if (notices.length === 0) return; if (isActive) updateNotice(); setInterval(updateNotice, 14000); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: adjustButtonPositions
    // RESUMEN: Ajusta dinmicamente la posicin de los botones laterales fijos.
    // ===================================================================
    function adjustButtonPositions() { const scrollToggle = document.getElementById('scroll-toggle'); if (!scrollToggle) { return; }
    const scrollToggleHeight = scrollToggle.offsetHeight; const buttonHeight = 74; const buttonSpacing = 10; const startTop = scrollToggleHeight + 20; const fixedButtons = [ document.getElementById('on-off-toggle'), ...document.querySelectorAll('.range-toggle'), document.getElementById('weather-button'), document.getElementById('reminder-button'), document.getElementById('zoom-button'), document.getElementById('dark-mode-toggle') ].filter(button => button !== null).sort((a, b) => { const startA = parseInt(a.dataset.rangeStart) || Infinity; const startB = parseInt(b.dataset.rangeStart) || Infinity; if (a.id === 'on-off-toggle') return -1; if (b.id === 'on-off-toggle') return 1; if (isFinite(startA) && isFinite(startB)) return startA - startB; if (isFinite(startA)) return -1; if (isFinite(startB)) return 1; const order = ['weather-button', 'reminder-button', 'zoom-button', 'dark-mode-toggle']; return order.indexOf(a.id) - order.indexOf(b.id); }); if (fixedButtons.length < 6) { return; } let currentTop = startTop; fixedButtons.forEach((button) => { button.style.position = 'fixed'; button.style.top = `${currentTop}px`; button.style.left = '10px'; currentTop += buttonHeight + buttonSpacing; }); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: saveSettings
    // RESUMEN: Guarda la configuracin actual de la UI en localStorage.
    // ===================================================================
    function saveSettings() {
        localStorage.setItem('darkMode', JSON.stringify(isDarkMode));
        const tS = {};
        document.querySelectorAll('.range-toggle').forEach(t => {
            const start = t.dataset.rangeStart;
            if (start) tS[start] = t.dataset.state;
        });
        localStorage.setItem('toggleStates', JSON.stringify(tS));
        const zoomButton = document.getElementById('zoom-button');
        if (zoomButton) localStorage.setItem('zoomState', zoomButton.dataset.zoomState);
        const onOffBtn = document.getElementById('on-off-toggle');
        if (onOffBtn) localStorage.setItem('onOffState', onOffBtn.dataset.state);
        localStorage.setItem('noticesActive', JSON.stringify(isActive));
        localStorage.setItem('footerVisible', JSON.stringify(isFooterVisible));
        localStorage.setItem('password_active', JSON.stringify(isPasswordActive));
        localStorage.setItem('lastUpdatesCheckDate', lastUpdatesCheckDate);
        localStorage.setItem(GRAPH_STATE_KEY, currentGraphMode);
        const radaresCheckboxElement = document.getElementById('radares-ruta-checkbox');
        if (radaresCheckboxElement) {
            localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckboxElement.checked));
        }
        const tareasCheckboxElement = document.getElementById('tareas-ruta-checkbox');
        if (tareasCheckboxElement) { 
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckboxElement.checked));
        }
        const mainSearchInputGrid = document.getElementById('main-search-input'); 
        if (mainSearchInputGrid) {
            localStorage.setItem('gridFilterValue', mainSearchInputGrid.value);
        }
        const mapFilterInput = document.getElementById('filter-input'); 
        if (mapFilterInput) {
            localStorage.setItem(MAP_FILTER_INPUT_KEY, mapFilterInput.value);
        }
        if (mapLayersControl && mapLayersControl._map && mapLayersControl._map._layers) {
            const layersArray = Object.values(mapLayersControl._map._layers);
            const baseLayerMapObject = layersArray.find(l => l._map && l.options && !l.options.pane && l.options.attribution);
            if (baseLayerMapObject) {
                const activeLayerEntry = mapLayersControl._layers.find(l => l.layer === baseLayerMapObject);
                if (activeLayerEntry && activeLayerEntry.name) {
                    localStorage.setItem(ACTIVE_MAP_LAYER_KEY, activeLayerEntry.name);
                }
            }
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: saveCustomData
    // RESUMEN: Guarda la personalizacin del grid y los toggles en localStorage, optimizando el espacio.
    // ===================================================================
    function saveCustomData() {
        try {
            if (customData.bookmarks) {
                Object.keys(customData.bookmarks).forEach(indexKey => {
                    const index = parseInt(indexKey);
                    const custom = customData.bookmarks[index];
                    const original = index < originalBookmarks.length ? originalBookmarks[index] : null;
                    const bookmarksAreEqual = (b1, b2) => {
                        if (b1 === null && b2 === null) return true;
                        if (b1 === null || b2 === null) return false;
                        return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null);
                    };
                    if (bookmarksAreEqual(custom, original)) {
                        delete customData.bookmarks[index];
                    }
                });
                if (Object.keys(customData.bookmarks).length === 0) {
                    delete customData.bookmarks;
                }
            }
            if (customData.toggles) {
                Object.keys(customData.toggles).forEach(startKey => {
                    const customToggle = customData.toggles[startKey];
                    const originalRange = originalToggleRanges.find(r => r.start == startKey);
                    if (customToggle && customToggle.assignedIndexes && originalRange) {
                        const originalDefaultIndexes = [];
                        for (let i = originalRange.start; i <= originalRange.end; i++) {
                            originalDefaultIndexes.push(i);
                        }
                        if (customToggle.assignedIndexes.length === originalDefaultIndexes.length &&
                            customToggle.assignedIndexes.every((val, idx) => val === originalDefaultIndexes[idx])) {
                            delete customToggle.assignedIndexes;
                        }
                    }
                    if (customToggle && originalRange && customToggle.label === originalRange.label) {
                        delete customToggle.label;
                    }
                    if (customData.toggles[startKey] && Object.keys(customData.toggles[startKey]).length === 0) {
                        delete customData.toggles[startKey];
                    }
                });
                if (Object.keys(customData.toggles).length === 0) {
                    delete customData.toggles;
                }
            }
            localStorage.setItem('customGridData', JSON.stringify(customData));
            markCacheAsDirty();
        } catch (e) {
            showToast("Error al guardar personalizacin", "error");
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: loadCustomData
    // RESUMEN: Carga los datos de personalizacin del grid desde localStorage.
    // ===================================================================
    function loadCustomData() { const savedData = localStorage.getItem('customGridData'); currentBookmarks = []; currentToggleRanges = []; customData = { bookmarks: {}, toggles: {} }; if (savedData) { try { customData = JSON.parse(savedData) || { bookmarks: {}, toggles: {} }; } catch (e) { customData = { bookmarks: {}, toggles: {} }; } } if (!customData.bookmarks) customData.bookmarks = {}; if (!customData.toggles) customData.toggles = {}; currentBookmarks = Array.from({ length: TOTAL_CELLS }).map((_, index) => { if (customData.bookmarks.hasOwnProperty(index)) { return customData.bookmarks[index] ? { ...customData.bookmarks[index] } : null; } else { const original = index < originalBookmarks.length ? originalBookmarks[index] : null; return original ? { ...original } : null; } }); currentToggleRanges = originalToggleRanges.map(originalRange => { const customToggle = customData.toggles[originalRange.start]; const rangeCopy = { ...originalRange }; if (customToggle) { if (typeof customToggle.label === 'string') rangeCopy.label = customToggle.label; if (Array.isArray(customToggle.assignedIndexes)) rangeCopy.assignedIndexes = [...customToggle.assignedIndexes]; } if (!rangeCopy.assignedIndexes) rangeCopy.assignedIndexes = Array.from({ length: rangeCopy.end - originalRange.start + 1 }, (_, i) => originalRange.start + i); return rangeCopy; }); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: loadSavedSettings
    // RESUMEN: Carga toda la configuracin guardada desde localStorage.
    // ===================================================================
    function loadSavedSettings() {
        const savedDarkMode = localStorage.getItem('darkMode');
        isDarkMode = savedDarkMode ? JSON.parse(savedDarkMode) : false;
        if (isDarkMode) document.body.classList.add('dark-mode');
        const savedZoomState = localStorage.getItem('zoomState');
        const zoomButtonElem = document.getElementById('zoom-button');
        if (zoomButtonElem) {
            zoomButtonElem.dataset.zoomState = savedZoomState || 'off';
            applyZoom(zoomButtonElem.dataset.zoomState);
        }
        const savedPasswordActive = localStorage.getItem('password_active');
        isPasswordActive = savedPasswordActive ? JSON.parse(savedPasswordActive) : false;
        storedPin = localStorage.getItem('password_pin');
        lastUpdatesCheckDate = localStorage.getItem('lastUpdatesCheckDate');
        const savedNoticesActive = localStorage.getItem('noticesActive');
        const savedFooterVisible = localStorage.getItem('footerVisible');
        isActive = savedNoticesActive ? JSON.parse(savedNoticesActive) : true;
        isFooterVisible = savedFooterVisible ? JSON.parse(savedFooterVisible) : true;
        const noticeContainer = document.querySelector('.notices-container');
        if (noticeContainer) noticeContainer.style.display = isActive ? 'flex' : 'none';
        const footerElement = document.querySelector('footer');
        if (footerElement) footerElement.classList.toggle('footer-hidden', !isFooterVisible);
        const onOffBtn = document.getElementById('on-off-toggle');
        if (onOffBtn) {
            const savedOnOffState = localStorage.getItem('onOffState');
            onOffBtn.dataset.state = savedOnOffState ? savedOnOffState : 'on';
        }
        const toggleStatesFromCache = JSON.parse(localStorage.getItem('toggleStates') || '{}');
        document.querySelectorAll('.range-toggle').forEach(toggle => {
            const start = parseInt(toggle.dataset.rangeStart);
            const savedState = toggleStatesFromCache[start] || 'visible';
            toggle.dataset.state = savedState;
        });
        const mainSearchInputGrid = document.getElementById('main-search-input'); 
        if (mainSearchInputGrid) {
            const savedMainFilter = localStorage.getItem('gridFilterValue');
            if (savedMainFilter !== null) {
                mainSearchInputGrid.value = savedMainFilter;
            } else {
                mainSearchInputGrid.value = '';
            }
        }
        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox) {
            const savedCheckState = localStorage.getItem(RADARES_RUTA_CHECKED_KEY);
            radaresRutaCheckbox.checked = savedCheckState === 'true';
        }
        const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasRutaCheckbox) {
            const savedTareasCheckState = localStorage.getItem(TAREAS_RUTA_CHECKED_KEY);
            tareasRutaCheckbox.checked = savedTareasCheckState === 'true';
        }
        currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviacin ETA';
        const userIdInput = document.getElementById('user-id');
        const modelInput = document.getElementById('tesla-model');
        const yearInput = document.getElementById('tesla-year');
        const provinceInput = document.getElementById('tesla-province');
        const dmsCheckbox = document.getElementById('allow-dms');
        const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
        if (userIdInput) userIdInput.value = localStorage.getItem('userData_userId') || '';
        if (modelInput) modelInput.value = localStorage.getItem('userData_teslaModel') || '';
        if (yearInput) yearInput.value = localStorage.getItem('userData_teslaYear') || '';
        if (provinceInput) provinceInput.value = localStorage.getItem('userData_teslaProvince') || '';
        if (dmsCheckbox) dmsCheckbox.checked = JSON.parse(localStorage.getItem('userData_allowDMs') || 'false');
        if (autoBackupCheckbox) {
            const savedAutoBackup = localStorage.getItem('boardinggate_autoBackupOnLoad');
            autoBackupCheckbox.checked = savedAutoBackup === null ? true : JSON.parse(savedAutoBackup);
        }
        actualizarContadorRadares(0);
        actualizarContadorTareas(0);
        updateUserIdDisplay();
        updateReminderCount();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: loadReminders
    // RESUMEN: Carga los recordatorios y actualiza el contador.
    // ===================================================================
    function loadReminders() { updateReminderCount(); }
    
    
    
    




// ===================================================================
// NOMBRE: actualizarContadorRadares
// RESUMEN: Actualiza el contador numrico de radares en la UI del mapa.
// ===================================================================
function actualizarContadorRadares(count) {
    const contadorElement = document.getElementById('radares-ruta-count');
    if (contadorElement) {
        contadorElement.textContent = count;
        const checkbox = document.getElementById('radares-ruta-checkbox');
        contadorElement.classList.toggle('hidden', count === 0 && (!checkbox || !checkbox.checked));
    }
}
    



// ===================================================================
// NOMBRE: actualizarContadorTareas
// RESUMEN: Actualiza el contador numrico de tareas en la UI del mapa.
// ===================================================================
function actualizarContadorTareas(count) {
    const contadorElement = document.getElementById('tareas-ruta-count');
    if (contadorElement) {
        contadorElement.textContent = count;
        const checkbox = document.getElementById('tareas-ruta-checkbox');
        contadorElement.classList.toggle('hidden', count === 0 && (!checkbox || !checkbox.checked));
    }
}    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateUserIdDisplay
    // RESUMEN: Muestra el ID de usuario en la pantalla si existe.
    // ===================================================================
    function updateUserIdDisplay() { const userIdDisplay = document.getElementById('user-id-display'); const userId = localStorage.getItem('userData_userId'); if (userIdDisplay) { if (userId) { userIdDisplay.textContent = userId.trim(); userIdDisplay.style.display = 'block'; } else { userIdDisplay.textContent = ''; userIdDisplay.style.display = 'none'; } } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: applyZoom
    // RESUMEN: Aplica el estado de zoom (acercado o alejado) al grid de marcadores.
    // ===================================================================
    function applyZoom(state) { const originalWidth = 984; const adjustedWidth = 935; const originalCols = 6; const zoomedCols = 4; const gap = 15; const zoomButton = document.getElementById('zoom-button'); if (state === 'on') { grid.style.gridTemplateColumns = `repeat(${zoomedCols}, 1fr)`; grid.style.gap = `${gap}px`; grid.style.maxWidth = `${adjustedWidth}px`; document.querySelectorAll('.bookmark-item img').forEach(i => { i.style.width = '48px'; i.style.maxWidth = '56px'; }); document.querySelectorAll('.bookmark-name').forEach(n => { n.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)'; }); document.querySelectorAll('.small-bookmark img').forEach(i => { i.style.width = '48px'; i.style.maxWidth = '56px'; }); document.querySelectorAll('.small-bookmark .bookmark-name').forEach(n => { n.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)'; }); if (zoomButton) zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/zoon+.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; } else { grid.style.gridTemplateColumns = `repeat(${originalCols}, minmax(120px, 1fr))`; grid.style.gap = `${gap}px`; grid.style.maxWidth = `${originalWidth}px`; document.querySelectorAll('.bookmark-item img').forEach(i => { i.style.width = '36px'; i.style.maxWidth = '40px'; }); document.querySelectorAll('.bookmark-name').forEach(n => { n.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)'; }); document.querySelectorAll('.small-bookmark img').forEach(i => { i.style.width = '24px'; i.style.maxWidth = '28px'; }); document.querySelectorAll('.small-bookmark .bookmark-name').forEach(n => { n.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)'; }); if (zoomButton) zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getSectionForIndex
    // RESUMEN: Devuelve la configuracin de la seccin a la que pertenece un ndice del grid.
    // ===================================================================
    function getSectionForIndex(index) { return currentToggleRanges.find(range => range.assignedIndexes.includes(index)); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getColorForSection
    // RESUMEN: Obtiene el color de fondo para una seccin, considerando el modo oscuro.
    // ===================================================================
    function getColorForSection(sectionStart, state = 'visible') { if (state === 'hidden') { return sectionColors.off; } if (isDarkMode) { return darkModeGenericButtonColor; } else { return sectionColors[sectionStart] || sectionColors.unassigned; } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateButtonStyles
    // RESUMEN: Actualiza los estilos visuales de todos los botones de la UI.
    // ===================================================================
    function updateButtonStyles() {
        const darkModeToggleElem = document.getElementById('dark-mode-toggle');
        const onOffToggleElem = document.getElementById('on-off-toggle');
        const rangeToggleButtonsElems = document.querySelectorAll('.toggle-sign.range-toggle');
        const reminderButtonElem = document.getElementById('reminder-button');
        if (onOffToggleElem) {
            onOffToggleElem.src = `https://boardinggate.github.io/Tesla/${onOffToggleElem.dataset.state === 'on' ? 'IMG_4192.jpg' : 'IMG_4191.jpg'}`;
            onOffToggleElem.alt = `Toggle ${onOffToggleElem.dataset.state === 'on' ? 'On' : 'Off'}`;
            onOffToggleElem.style.backgroundColor = sectionColors.off;
            if (isDarkMode) {
                onOffToggleElem.style.filter = 'brightness(85%)';
                 if (onOffToggleElem.dataset.state === 'on') {
                    onOffToggleElem.style.backgroundColor = darkModeGenericButtonColor;
                 }
            } else {
                onOffToggleElem.style.filter = '';
            }
        }
        if (darkModeToggleElem) {
            darkModeToggleElem.src = `https://boardinggate.github.io/Tesla/${isDarkMode ? 'oscuro2.png' : 'claro2.png'}`;
            darkModeToggleElem.alt = `Toggle ${isDarkMode ? 'Oscuro' : 'Claro'}`;
            darkModeToggleElem.style.backgroundColor = sectionColors.off;
            if (isDarkMode) darkModeToggleElem.style.filter = 'brightness(85%)'; else darkModeToggleElem.style.filter = '';
        }
        let reminders = [];
        try {
            reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        } catch(e) {
            reminders = [];
        }
        const showExcludedInTable = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
        let remindersForButtonStyleCount = reminders;
        if (!showExcludedInTable) {
            remindersForButtonStyleCount = reminders.filter(r => !r.excludeFromList);
        }
        const totalPendingCount = remindersForButtonStyleCount.length;
        if (reminderButtonElem) {
            reminderButtonElem.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4197.jpg" alt="Recordatorio" style="max-width: 70%; max-height: 70%; object-fit: contain;">${totalPendingCount > 0 ? `<span class="reminder-count">${totalPendingCount}</span>` : ''}`;
            reminderButtonElem.style.backgroundColor = sectionColors.off;
            if (isDarkMode) reminderButtonElem.style.filter = 'brightness(85%)'; else reminderButtonElem.style.filter = '';
        }
        rangeToggleButtonsElems.forEach(toggle => {
            const start = parseInt(toggle.dataset.rangeStart);
            const state = toggle.dataset.state || 'visible';
            const rangeConfig = currentToggleRanges.find(r => r.start === start);
            if (rangeConfig) {
                toggle.innerHTML = `<span class="sign">${state === 'visible' ? '-' : '+'}</span>${rangeConfig.label}`;
            }
            toggle.style.backgroundColor = getColorForSection(start, state);
            if (isDarkMode && state === 'visible') {
                toggle.style.filter = 'brightness(85%)';
            } else {
                toggle.style.filter = '';
            }
        });
        updatePasswordToggleIcon();
        const zoomButtonElem = document.getElementById('zoom-button');
        if (zoomButtonElem && zoomButtonElem.dataset.zoomState) {
            applyZoom(zoomButtonElem.dataset.zoomState);
        }
        if (cellElements && cellElements.length > 0) {
            cellElements.forEach((cell, index) => {
                const bookmarkItem = cell.querySelector('.bookmark-item');
                const emptySlot = cell.classList.contains('empty-slot');
                const section = getSectionForIndex(index);
                const color = sectionColors[section ? section.start : null] || sectionColors.unassigned;
                if (bookmarkItem) {
                    bookmarkItem.style.backgroundColor = color;
                } else if (emptySlot) {
                    cell.style.backgroundColor = color;
                }
            });
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: formatVersionDate
    // RESUMEN: Formatea una fecha a un formato de versin especfico (YY.MM.DDHH).
    // ===================================================================
    function formatVersionDate(date) { const y = date.getUTCFullYear().toString().slice(-2); const m = String(date.getUTCMonth() + 1).padStart(2, '0'); const d = String(date.getUTCDate()).padStart(2, '0'); const h = String(date.getUTCHours()).padStart(2, '0'); return `${y}.${m}.${d}${h}`; }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getLastModifiedDate
    // RESUMEN: Obtiene la fecha de la ltima modificacin desde un archivo remoto, con cach local.
    // ===================================================================
    async function getLastModifiedDate() {
        const k = 'teslaHtmlLastModified';
        const tk = 'teslaHtmlLastModifiedTimestamp';
        const dur = 86400000;
        const cd = localStorage.getItem(k);
        const ct = localStorage.getItem(tk);
        const now = Date.now();
        if (cd && ct && (now - parseInt(ct)) < dur) {
            return new Date(cd);
        }
        try {
            const r = await fetch('https://boardinggate.github.io/Tesla/version.txt', { cache: 'no-cache' });
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const txt = await r.text();
            const lmd = new Date(txt.trim());
            if (isNaN(lmd.getTime())) throw new Error('Invalid date format');
            localStorage.setItem(k, lmd.toISOString());
            localStorage.setItem(tk, now.toString());
            return lmd;
        } catch (e) {
            if (cd) return new Date(cd);
            return new Date('2024-01-01T00:00:00Z');
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateVersion
    // RESUMEN: Actualiza el texto de la versin en la UI.
    // ===================================================================
    async function updateVersion() { try { const lmd = await getLastModifiedDate(); const v = formatVersionDate(lmd); const el = document.getElementById('version'); if (el) el.textContent = `versin: ${v}`; } catch (e) { const el = document.getElementById('version'); if (el) el.textContent = 'versin: error'; } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getFaviconUrl
    // RESUMEN: Obtiene la URL del favicon para un marcador, usando un servicio externo como fallback.
    // ===================================================================
    const getFaviconUrl = (bookmarkData) => { try { const urlToParse = bookmarkData?.url || ''; const customFavicon = bookmarkData?.favicon; if (customFavicon && (customFavicon.startsWith('data:image') || customFavicon.startsWith('http') || customFavicon.startsWith('./'))) return customFavicon; if (urlToParse) { const domain = new URL(urlToParse).hostname; return `https://www.google.com/s2/favicons?domain=${domain}&sz=64`; } } catch (e) { } return 'https://via.placeholder.com/64'; };
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: renderGrid
    // RESUMEN: Dibuja o redibuja el grid completo de marcadores.
    // ===================================================================
    function renderGrid() { grid.innerHTML = ''; cellElements = []; Array.from({ length: TOTAL_CELLS }).forEach((_, index) => { const cellContainer = document.createElement('div'); cellContainer.classList.add('grid-cell'); cellContainer.dataset.index = index; const bookmarkData = currentBookmarks[index]; const section = getSectionForIndex(index); const bgColor = sectionColors[section ? section.start : null] || sectionColors.unassigned; if (bookmarkData) { const link = document.createElement('a'); link.className = 'bookmark-item'; link.title = bookmarkData.name; link.style.backgroundColor = bgColor; link.href = bookmarkData.url || "#"; link.dataset.index = index;
        if (isKeywordAssignmentMode || (bookmarkData.name && bookmarkData.name === "Inicio Tesla") || !bookmarkData.url || bookmarkData.url === '#') { } else { link.target = "_blank"; link.rel = "noopener noreferrer"; }
        const img = document.createElement('img'); img.src = getFaviconUrl(bookmarkData); img.alt = `Favicon ${bookmarkData.name}`; img.loading = "lazy"; img.onerror = function() { this.src = 'https://via.placeholder.com/64'; this.onerror = null; }; if (bookmarkData.name === "Mis Updates") img.classList.add('favicon-red'); else if (bookmarkData.name === "Olas Updates") img.classList.add('favicon-blue'); const nameSpan = document.createElement('span'); nameSpan.className = 'bookmark-name'; nameSpan.textContent = bookmarkData.name; link.appendChild(img); link.appendChild(nameSpan); cellContainer.appendChild(link); } else { cellContainer.classList.add('empty-slot'); const addIcon = document.createElement('span'); addIcon.textContent = '+'; cellContainer.appendChild(addIcon); cellContainer.style.backgroundColor = bgColor; }
        cellContainer.addEventListener('click', handleGridCellClick);
        if (isEditMode) {
             cellContainer.draggable = true;
             cellContainer.addEventListener('dragstart', handleDragStart); cellContainer.addEventListener('dragover', handleDragOver);
             cellContainer.addEventListener('dragleave', handleDragLeave);
             cellContainer.addEventListener('drop', handleDrop);
             cellContainer.addEventListener('dragend', handleDragEnd);
             cellContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
             cellContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
             cellContainer.addEventListener('touchend', handleTouchEnd);
             cellContainer.addEventListener('touchcancel', handleTouchCancel);
             cellContainer.classList.add('editable');
        } else {
             cellContainer.draggable = false;
             cellContainer.removeEventListener('dragstart', handleDragStart);
             cellContainer.removeEventListener('dragover', handleDragOver);
             cellContainer.removeEventListener('dragleave', handleDragLeave);
             cellContainer.removeEventListener('drop', handleDrop);
             cellContainer.removeEventListener('dragend', handleDragEnd);
             cellContainer.removeEventListener('touchstart', handleTouchStart);
             cellContainer.removeEventListener('touchmove', handleTouchMove);
             cellContainer.removeEventListener('touchend', handleTouchEnd);
             cellContainer.removeEventListener('touchcancel', handleTouchCancel);
             cellContainer.classList.remove('editable');
        }
        grid.appendChild(cellContainer); cellElements.push(cellContainer); }); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: renderToggleButtons
    // RESUMEN: Dibuja los botones laterales para ocultar/mostrar secciones del grid.
    // ===================================================================
    function renderToggleButtons() {
        document.querySelectorAll('.range-toggle').forEach(btn => btn.remove());
        toggleButtonElements = {};
        const toggleStatesFromCache = JSON.parse(localStorage.getItem('toggleStates') || '{}');
        currentToggleRanges.forEach((range) => {
            const toggle = document.createElement('span');
            toggle.className = 'toggle-sign range-toggle';
            toggle.dataset.rangeStart = range.start;
            toggle.dataset.rangeEnd = range.end;
            toggle.style.position = 'fixed';
            toggle.style.top = '100px';
            toggle.style.left = '10px';
            const initialState = toggleStatesFromCache[range.start] || 'visible';
            toggle.dataset.state = initialState;
            toggle.addEventListener('click', handleToggleClick);
            document.body.appendChild(toggle);
            toggleButtonElements[range.start] = toggle;
        });
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: createOtherButtons
    // RESUMEN: Crea y aade a la UI los botones de accin fijos.
    // ===================================================================
    function createOtherButtons() {
        if (!document.getElementById('on-off-toggle')) {
            onOffToggle = document.createElement('img');
            onOffToggle.className = 'toggle-image';
            onOffToggle.id = 'on-off-toggle';
            const savedOnOffState = localStorage.getItem('onOffState');
            onOffToggle.dataset.state = savedOnOffState ? savedOnOffState : 'on';
            document.body.appendChild(onOffToggle);
            onOffToggle.addEventListener('mousedown', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) pressStartTime = Date.now(); });
            onOffToggle.addEventListener('mouseup', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) handleOnOffAction(); });
            onOffToggle.addEventListener('mouseleave', () => { pressStartTime = null; });
            onOffToggle.addEventListener('touchstart', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); pressStartTime = Date.now(); } });
            onOffToggle.addEventListener('touchend', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); handleOnOffAction(); } });
        }
        if (!document.getElementById('weather-button')) { weatherButton = document.createElement('span'); weatherButton.className = 'toggle-sign'; weatherButton.id = 'weather-button'; weatherButton.innerHTML = `<img src="https://www.google.com/s2/favicons?domain=accuweather.com&sz=64" alt="Tiempo" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; document.body.appendChild(weatherButton); weatherButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; window.open('https://www.ventusky.com/?p=40.2;-4.7;5&l=rain-3h', '_blank'); }); }
        if (!document.getElementById('reminder-button')) { reminderButton = document.createElement('span'); reminderButton.className = 'toggle-sign'; reminderButton.id = 'reminder-button'; document.body.appendChild(reminderButton); reminderButton.addEventListener('mousedown', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) reminderPressStartTime = Date.now(); }); reminderButton.addEventListener('mouseup', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) handleReminderLongPress(); }); reminderButton.addEventListener('mouseleave', () => { reminderPressStartTime = null; }); reminderButton.addEventListener('touchstart', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); reminderPressStartTime = Date.now(); } }); reminderButton.addEventListener('touchend', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); handleReminderLongPress(); } }); }
        if (!document.getElementById('zoom-button')) { zoomButton = document.createElement('span'); zoomButton.className = 'toggle-sign'; zoomButton.id = 'zoom-button'; zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; zoomButton.dataset.zoomState = localStorage.getItem('zoomState') || 'off'; document.body.appendChild(zoomButton); zoomButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const cS = zoomButton.dataset.zoomState; const nS = cS === 'off' ? 'on' : 'off'; applyZoom(nS); zoomButton.dataset.zoomState = nS; updateButtonStyles(); saveSettings(); adjustButtonPositions(); }); }
        if (!document.getElementById('dark-mode-toggle')) { darkModeToggle = document.createElement('img'); darkModeToggle.className = 'toggle-image'; darkModeToggle.id = 'dark-mode-toggle'; document.body.appendChild(darkModeToggle); darkModeToggle.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; isDarkMode = !isDarkMode; document.body.classList.toggle('dark-mode', isDarkMode); updateButtonStyles(); saveSettings(); }); }
        if (!document.getElementById('config-button')) {
            const configButton = document.createElement('span');
            configButton.id = 'config-button';
            configButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/config.jpg" alt="Configuracin">`;
            document.body.appendChild(configButton);
            configButton.addEventListener('click', () => {
                if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) {
                    const mapIsCurrentlyOpen = isNavigationMapActive;
                    const currentMapContext = sessionStorage.getItem('mapContext');
                    if (mapIsCurrentlyOpen && currentMapContext) {
                        sessionStorage.setItem('boardinggate_map_should_reopen_after_config', 'true');
                        sessionStorage.setItem('mapContextToReopenAfterConfig', currentMapContext);
                        closeNavigationMap(true);
                    }
                    showConfigModal();
                }
            });
        }
        if (!document.getElementById('personal-button')) {
            const personalButton = document.createElement('span');
            personalButton.id = 'personal-button';
            personalButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/personal.png" alt="Personal">`;
            document.body.appendChild(personalButton);
            personalButton.addEventListener('click', handlePersonalizationClick);
        }
        if (!document.getElementById('radar-button')) {
            radarButton = document.createElement('span');
            radarButton.id = 'radar-button';
            radarButton.innerHTML = `<img src="RADAR.PNG" alt="Radar/Ubicaciones/Navegacin">`;
            document.body.appendChild(radarButton);
            radarButton.addEventListener('click', () => {
                if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
                openNavigationMap();
            });
        }
        if (!document.getElementById('home-button')) {
            const homeButton = document.createElement('span');
            homeButton.id = 'home-button';
            homeButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/home.webp" alt="Inicio">`;
            document.body.appendChild(homeButton);
            homeButton.addEventListener('click', (e) => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) { e.preventDefault(); return; } window.history.back(); });
        }
        if (!document.getElementById('reload-button')) {
            const reloadButton = document.createElement('span');
            reloadButton.id = 'reload-button';
            reloadButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/reload.webp" alt="Recargar">`;
            document.body.appendChild(reloadButton);
            reloadButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; location.reload(); });
        }
        if (!document.getElementById('keyword-assignment-button')) {
             const keywordButton = document.createElement('span');
             keywordButton.id = 'keyword-assignment-button';
             keywordButton.title = "Asignar/Quitar palabra clave filtro";
             keywordButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4314.PNG" alt="Asignar Keyword">`;
             document.body.appendChild(keywordButton);
             keywordButton.addEventListener('click', () => { toggleKeywordAssignmentMode(!isKeywordAssignmentMode); });
        }
        if (!document.getElementById('password-toggle-button')) {
            const passwordButton = document.createElement('span');
            passwordButton.id = 'password-toggle-button';
            passwordButton.innerHTML = `<img src="" alt="Clave">`;
            document.body.appendChild(passwordButton);
            passwordButton.addEventListener('click', handlePasswordToggleClick);
        }
        if (!document.getElementById('versions-button')) {
             versionsButton = document.createElement('span');
             versionsButton.id = 'versions-button';
             versionsButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4309.PNG" alt="Versiones">`;
             document.body.appendChild(versionsButton);
             versionsButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; showVersionsModal(); });
        }
        if (!document.getElementById('info-button')) {
             infoButton = document.createElement('span');
             infoButton.id = 'info-button';
             infoButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4326.PNG" alt="Info">`;
             document.body.appendChild(infoButton);
             infoButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; window.open('https://boardinggate.github.io/Tesla/manual.html', '_blank'); });
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleGridCellClick
    // RESUMEN: Gestiona los clics en las celdas del grid, segn el modo activo.
    // ===================================================================
    function handleGridCellClick(event) {
        const cellContainer = event.currentTarget; const index = parseInt(cellContainer.dataset.index);
        if (isEditMode) { const link = cellContainer.querySelector('a.bookmark-item'); if (link) event.preventDefault(); showEditModal(index, false); }
        else if (isAssignmentMode) { event.preventDefault(); handleGridCellClickForAssignment(index); }
        else if (isKeywordAssignmentMode) { event.preventDefault(); handleKeywordAssignmentClick(index); }
        else { const link = cellContainer.querySelector('a.bookmark-item'); const bookmarkData = currentBookmarks[index];
            if (!link || !link.href || link.href === '#') {
                event.preventDefault();
                if (bookmarkData && bookmarkData.url && bookmarkData.url.startsWith("map-action:")) {
                    const action = bookmarkData.url.split(":")[1];
                    if (action === "openRemindersMapWithNoRadars") {
                        openLocationsPreviewMap();
                    } else if (action === "openRemindersMap") {
                        openNavigationMap();
                    }
                }
            } else {
                if (!link.target && bookmarkData && bookmarkData.name !== "Inicio Tesla") {
                    link.target = "_blank"; link.rel = "noopener noreferrer";
                }
            }
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleToggleClick
    // RESUMEN: Gestiona los clics en los botones laterales de seccin, segn el modo activo.
    // ===================================================================
    function handleToggleClick(event) { const toggle = event.currentTarget; if (isEditMode) { event.preventDefault(); const start = parseInt(toggle.dataset.rangeStart); showEditModal(start, true); } else if (isAssignmentMode) { event.preventDefault(); handleToggleClickForAssignment(toggle); } else if (isKeywordAssignmentMode) { event.preventDefault(); } else { updateToggleState(toggle); } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateToggleState
    // RESUMEN: Cambia el estado (visible/oculto) de un botn de seccin.
    // ===================================================================
    function updateToggleState(toggle) { if (!toggle || isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const start = parseInt(toggle.dataset.rangeStart); if (isNaN(start)) return; const rangeConfig = currentToggleRanges.find(r => r.start === start); if (!rangeConfig) return; const currentState = toggle.dataset.state; const newState = currentState === 'visible' ? 'hidden' : 'visible'; toggle.dataset.state = newState; const savedStates = JSON.parse(localStorage.getItem('toggleStates') || '{}'); savedStates[start] = newState; localStorage.setItem('toggleStates', JSON.stringify(savedStates)); updateButtonStyles(); filterGridItems(); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateAllToggles
    // RESUMEN: Cambia el estado de todos los toggles a la vez (on/off general).
    // ===================================================================
    function updateAllToggles(newState) { const onOffToggleElem = document.getElementById('on-off-toggle'); if (!onOffToggleElem) return; onOffToggleElem.dataset.state = newState; localStorage.setItem('onOffState', newState); updateButtonStyles(); filterGridItems(); saveSettings(); }
    const scrollToggle = document.getElementById('scroll-toggle'); if (scrollToggle) scrollToggle.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const sP = window.scrollY; const mS = document.body.scrollHeight - window.innerHeight; window.scrollTo({ top: sP < 100 ? mS : 0, behavior: 'smooth' }); });
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleOnOffAction
    // RESUMEN: Maneja la accin del botn de on/off general.
    // ===================================================================
    function handleOnOffAction() { if (pressStartTime !== null) { const t = document.getElementById('on-off-toggle'); if (t) { const nS = t.dataset.state === 'on' ? 'off' : 'on'; updateAllToggles(nS); } } pressStartTime = null; }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleReminderLongPress
    // RESUMEN: Maneja el clic corto/largo en el botn de recordatorios.
    // ===================================================================
    function handleReminderLongPress() { if (reminderPressStartTime === null) return; const dur = Date.now() - reminderPressStartTime; if (dur >= 2000) showAllReminders(); else showReminderModal(); reminderPressStartTime = null; }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handlePersonalizationClick
    // RESUMEN: Gestiona el clic en el botn de personalizacin, mostrando el men de opciones.
    // ===================================================================
    function handlePersonalizationClick() {
        const personalButton = document.getElementById('personal-button'); const wasEditing = isEditMode; const wasAssigning = isAssignmentMode; const wasKeywordAssigning = isKeywordAssignmentMode;
        if (wasKeywordAssigning) { toggleKeywordAssignmentMode(false); }
        if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
        if (wasEditing) { toggleEditMode(false); } else if (wasAssigning) { toggleAssignmentMode(false); } else if (!wasKeywordAssigning) { showPersonalizationChoice(); }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showPersonalizationChoice
    // RESUMEN: Muestra el modal para elegir el tipo de personalizacin.
    // ===================================================================
    function showPersonalizationChoice() {
        const existingModal = document.querySelector('.choice-modal'); if (existingModal) existingModal.remove();
        const modal = document.createElement('div'); modal.className = 'choice-modal'; modal.setAttribute('aria-label', 'Elegir tipo de personalizacin');
        modal.innerHTML = `
            <h2>Qu quieres personalizar?</h2>
            <div class="modal-top-buttons">
                <button class="choice-cancel">Cancelar</button>
            </div>
            <p class="mb-6">Elige una opcin:</p>
            <div class="personalization-options">
                <button class="choice-edit">URLs / Etiquetas / Reordenar</button>
                <button class="choice-assign">Asignar Botones Ocultacin</button>
                <button class="choice-help">Ver Ayuda</button>
            </div>
        `;
        modal.querySelector('.choice-edit').addEventListener('click', () => { modal.remove(); toggleEditMode(true); });
        modal.querySelector('.choice-assign').addEventListener('click', () => { modal.remove(); toggleAssignmentMode(true); });
        modal.querySelector('.choice-help').addEventListener('click', () => { modal.remove(); showEditInfoModal(); });
        modal.querySelector('.choice-cancel').addEventListener('click', () => { modal.remove(); });
        document.body.appendChild(modal);
        addModalAutoCloseTimer(modal, modal.querySelector('.choice-cancel'), 'choice-modal', 30000);
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleEditMode
    // RESUMEN: Activa o desactiva el modo de edicin (URLs, etiquetas, arrastrar).
    // ===================================================================
    function toggleEditMode(activate) {
        const personalButton = document.getElementById('personal-button'); isEditMode = activate; personalButton.classList.toggle('editing', isEditMode); document.body.classList.toggle('editing-active', isEditMode);
        if (isEditMode) {
            if (isAssignmentMode) toggleAssignmentMode(false); if (isKeywordAssignmentMode) toggleKeywordAssignmentMode(false);
            if (firstPersonalizationSession) { showEditInfoModal(); firstPersonalizationSession = false; sessionStorage.setItem('personalizationHelpShown', 'true'); }
            showToast("Modo Edicin (URLs/Etiquetas/Arrastrar) Activado", "info", 4000);
        } else {
            showToast("Modo Edicin Desactivado", "info", 2000);
            cellElements.forEach(cell => cell.classList.remove('dragging', 'drag-over')); draggedItem = null; draggedItemIndex = null; currentTouchTarget = null; dragOverIndex = null;
            if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
        } renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles(); adjustButtonPositions();
        document.querySelectorAll('.range-toggle').forEach(el => { el.classList.toggle('editable', isEditMode); }); filterGridItems();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleAssignmentMode
    // RESUMEN: Activa o desactiva el modo de asignacin de botones a secciones.
    // ===================================================================
    function toggleAssignmentMode(activate) {
        const personalButton = document.getElementById('personal-button'); isAssignmentMode = activate; personalButton.classList.toggle('assigning', isAssignmentMode); document.body.classList.toggle('assignment-active', isAssignmentMode);
        if (isAssignmentMode) {
            if (isEditMode) toggleEditMode(false); if (isKeywordAssignmentMode) toggleKeywordAssignmentMode(false);
            if (firstPersonalizationSession) { showEditInfoModal(); firstPersonalizationSession = false; sessionStorage.setItem('personalizationHelpShown', 'true'); }
            showToast("Modo Asignacin Botones Activado", "info", 4000);
            const firstToggle = document.querySelector('.range-toggle');
            if (firstToggle) { handleToggleClickForAssignment(firstToggle); } else { currentlyAssigningToggleStart = null; updateGridAssignmentVisuals(); }
        } else {
            showToast("Modo Asignacin Botones Desactivado", "info", 2000); saveCustomData();
            document.querySelectorAll('.range-toggle.assigning-selected').forEach(t => t.classList.remove('assigning-selected'));
            document.querySelectorAll('.grid-cell.assigned-to-current').forEach(c => { c.classList.remove('assigned-to-current'); c.style.opacity = ''; c.style.outline=''; c.style.boxShadow=''; c.style.backgroundColor = ''; });
            document.querySelectorAll('.range-toggle').forEach(t => t.style.opacity = '');
            currentlyAssigningToggleStart = null;
        } renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles(); adjustButtonPositions(); filterGridItems(); 
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleKeywordAssignmentMode
    // RESUMEN: Activa o desactiva el modo de asignacin de palabras clave a los nombres de los marcadores.
    // ===================================================================
    function toggleKeywordAssignmentMode(activate) {
         const keywordButton = document.getElementById('keyword-assignment-button'); const filterInput = document.getElementById('grid-filter-input'); isKeywordAssignmentMode = activate;
         if (keywordButton) { keywordButton.classList.toggle('active', isKeywordAssignmentMode); }
        document.body.classList.toggle('keyword-assignment-active', isKeywordAssignmentMode);
         if (isKeywordAssignmentMode) {
              if (isEditMode) toggleEditMode(false); if (isAssignmentMode) toggleAssignmentMode(false);
              const toastMessage = "Modo activo: Escribe palabra(s) en el campo filtro grid (separadas por espacio si son varias). Pulsa ICONO FILTRO para aadir/quitar esa(s) palabra(s) al nombre del botn(es) que vaya seleccionando. Pulsa el icono para salir de este modo.";
              showToast(toastMessage, "info", 15000); filterGridItems(); applyInitialKeywordHighlights();
         } else {
              showToast("Modo Asignacin de Palabras Clave Desactivado", "info", 2000); cellElements.forEach(cell => cell.classList.remove('keyword-assigned-highlight')); filterGridItems();
         }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: applyInitialKeywordHighlights
    // RESUMEN: Resalta los marcadores que ya contienen la palabra clave del filtro al activar el modo.
    // ===================================================================
    function applyInitialKeywordHighlights() { const filterInput = document.getElementById('grid-filter-input'); const keyword = filterInput.value.trim().replace(/\s+/g, '').toUpperCase(); if (!keyword) return; const keywordTag = `[${keyword}]`; cellElements.forEach((cell, index) => { const bookmark = currentBookmarks[index]; if (bookmark && bookmark.name && bookmark.name.includes(keywordTag)) { cell.classList.add('keyword-assigned-highlight'); } else { cell.classList.remove('keyword-assigned-highlight'); } }); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleKeywordAssignmentClick
    // RESUMEN: Aade o quita la palabra clave del filtro al nombre de un marcador.
    // ===================================================================
    function handleKeywordAssignmentClick(index) {
        const filterInput = document.getElementById('grid-filter-input'); const keyword = filterInput.value.trim().replace(/\s+/g, '').toUpperCase();
        if (!keyword) { showToast("Escribe una palabra en el campo filtro primero.", "warning"); return; }
        const bookmark = currentBookmarks[index]; const cellElement = cellElements[index];
        if (!bookmark || !cellElement) { showToast(`No hay un marcador en la posicin ${index + 1}.`, "warning"); return; }
        const keywordTag = `[${keyword}]`; const currentName = bookmark.name || ""; const nameSpan = cellElement.querySelector('.bookmark-name');
        let newName = currentName; let actionTaken = '';
        if (currentName.includes(keywordTag)) { newName = currentName.replace(keywordTag, '').replace(/\s{2,}/g, ' ').trim(); cellElement.classList.remove('keyword-assigned-highlight'); actionTaken = 'removed'; }
        else { newName = currentName.trim(); const lastBracketIndex = newName.lastIndexOf(']'); const endsWithBracket = lastBracketIndex !== -1 && lastBracketIndex === newName.length - 1;
            if (endsWithBracket) { newName += '  ' + keywordTag; } else { newName += '          ' + keywordTag; } cellElement.classList.add('keyword-assigned-highlight'); actionTaken = 'added'; }
        bookmark.name = newName; currentBookmarks[index] = { ...bookmark }; if (!customData.bookmarks) customData.bookmarks = {}; customData.bookmarks[index] = { ...bookmark }; saveCustomData();
        if (nameSpan) { nameSpan.textContent = newName; }
        if (actionTaken === 'added') { showToast(`"${keyword}" aadido. Nombre: ${newName}`, "success", 2500); } else if (actionTaken === 'removed') { showToast(`"${keyword}" quitado. Nombre: ${newName}`, "info", 2500); }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleToggleClickForAssignment
    // RESUMEN: Selecciona un botn de seccin para empezar a asignarle marcadores.
    // ===================================================================
    function handleToggleClickForAssignment(toggleElement) { const start = parseInt(toggleElement.dataset.rangeStart); if (isNaN(start)) return; currentlyAssigningToggleStart = start; document.querySelectorAll('.range-toggle').forEach(t => { t.classList.toggle('assigning-selected', t === toggleElement); t.style.opacity = t === toggleElement ? '' : '0.7'; }); updateGridAssignmentVisuals(); showToast(`Asignando botones para: ${toggleElement.textContent.substring(1)}`, "info", 2500); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleGridCellClickForAssignment
    // RESUMEN: Asigna o desasigna un marcador a la seccin actualmente seleccionada.
    // ===================================================================
    function handleGridCellClickForAssignment(cellIndex) {
        if (currentlyAssigningToggleStart === null) { showToast("Selecciona primero un botn lateral (PdR,s, iAs, etc.)", "warning"); return; }
        const startKey = currentlyAssigningToggleStart.toString(); if (!customData.toggles[startKey]) { const currentRange = currentToggleRanges.find(r => r.start == startKey); customData.toggles[startKey] = { label: currentRange ? currentRange.label : `Rango ${startKey}`, assignedIndexes: currentRange ? [...currentRange.assignedIndexes] : [] }; }
        else if (!customData.toggles[startKey].assignedIndexes) { const currentRange = currentToggleRanges.find(r => r.start == startKey); customData.toggles[startKey].assignedIndexes = currentRange ? [...currentRange.assignedIndexes] : []; }
        const assigned = customData.toggles[startKey].assignedIndexes; const indexInArray = assigned.indexOf(cellIndex);
        if (indexInArray > -1) { assigned.splice(indexInArray, 1); } else { assigned.push(cellIndex); assigned.sort((a, b) => a - b); }
        const currentRangeIndex = currentToggleRanges.findIndex(r => r.start == startKey); if (currentRangeIndex > -1) { currentToggleRanges[currentRangeIndex].assignedIndexes = [...assigned]; }
        updateGridAssignmentVisuals(); saveCustomData(); showToast('Asignacin guardada', 'success', 500);
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateGridAssignmentVisuals
    // RESUMEN: Actualiza la apariencia visual del grid durante el modo de asignacin.
    // ===================================================================
    function updateGridAssignmentVisuals() { if (!isAssignmentMode || currentlyAssigningToggleStart === null) { cellElements.forEach(cell => { cell.classList.remove('assigned-to-current'); cell.style.opacity = ''; cell.style.outline = ''; cell.style.boxShadow = ''; }); return; } const startKey = currentlyAssigningToggleStart.toString(); let assignedIndexesForCurrentToggle = []; if (customData.toggles[startKey] && customData.toggles[startKey].assignedIndexes) { assignedIndexesForCurrentToggle = customData.toggles[startKey].assignedIndexes; } else { const currentRange = currentToggleRanges.find(r => r.start == startKey); if (currentRange?.assignedIndexes) { assignedIndexesForCurrentToggle = currentRange.assignedIndexes; } } cellElements.forEach((cell, index) => { const isAssigned = assignedIndexesForCurrentToggle.includes(index); cell.classList.toggle('assigned-to-current', isAssigned); if (isAssigned) { cell.style.opacity = ''; cell.style.outline = '3px solid cyan'; cell.style.boxShadow = document.body.classList.contains('dark-mode') ? 'inset 0 0 10px rgba(0, 200, 200, 0.7)' : 'inset 0 0 8px rgba(0, 255, 255, 0.6)'; } else { cell.style.opacity = document.body.classList.contains('dark-mode') ? '0.5' : '0.6'; cell.style.outline = `1px dashed ${document.body.classList.contains('dark-mode') ? '#555' : '#aaa'}`; cell.style.boxShadow = ''; } }); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showEditInfoModal
    // RESUMEN: Muestra el modal con la ayuda sobre los modos de personalizacin.
    // ===================================================================
    function showEditInfoModal() {
        const existingModal = document.querySelector('.edit-info-modal'); if (existingModal) existingModal.remove();
        const modal = document.createElement('div'); modal.className = 'edit-info-modal'; modal.setAttribute('aria-label', 'Ayuda Personalizacin');
        modal.innerHTML = `
            <h2 class="text-xl font-bold mb-4">Ayuda de Personalizacin</h2>
            <div class="modal-top-buttons" style="justify-content: flex-end;">
                <button type="button" id="close-edit-info" class="px-6 py-2" style="flex: 0 1 auto; min-width: 120px;">Entendido</button>
            </div>
            <p class="mb-3">Al pulsar el botn <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (personalizar) o el icono <img src="https://boardinggate.github.io/Tesla/IMG_4314.PNG" alt="Key" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (llave) puedes elegir entre varios modos:</p>
            <div class="mb-4 p-3 bg-yellow-100 border border-yellow-300 rounded">
                 <h3 class="font-semibold text-lg mb-2">1. Editar URLs / Etiquetas / Reordenar (Botn Personalizar Amarillo)</h3>
                 <ul class="list-disc pl-5 space-y-1 text-sm">
                    <li><strong>Activar:</strong> Elige "URLs / Etiquetas / Reordenar" en el men inicial. El botn <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> se pondr amarillo.</li>
                    <li><strong>Editar Marcador/Botn Lateral:</strong> Haz clic en un marcador del grid o en un botn lateral (PdR,s, iAs, etc.). Se abrir una ventana para editar su nombre, URL (si es marcador) o etiqueta (si es botn lateral). <strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                    <li><strong>Arrastrar y Soltar:</strong> Mantn pulsado un marcador del grid y arrstralo a otra posicin (incluso vaca) para reordenarlos.</li>
                    <li><strong>Guardar Cambios:</strong> Los cambios en nombre/URL/etiqueta se guardan al pulsar "Guardar" en la ventana de edicin. El reordenamiento se guarda automticamente al soltar.</li>
                    <li><strong>Vaciar Casilla:</strong> En la ventana de edicin de un marcador, pulsa "Vaciar" para eliminarlo.</li>
                    <li><strong>Resetear:</strong> En la ventana de edicin, pulsa "Resetear" para volver a los valores originales (si los tena).</li>
                 </ul>
            </div>
            <div class="mb-4 p-3 bg-cyan-100 border border-cyan-300 rounded">
                <h3 class="font-semibold text-lg mb-2">2. Asignar Botones Ocultacin (Botn Personalizar Cian)</h3>
                <ul class="list-disc pl-5 space-y-1 text-sm">
                    <li><strong>Activar:</strong> Elige "Asignar Botones Ocultacin" en el men inicial. El botn <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> se pondr cian.</li>
                    <li><strong>Seleccionar Botn Lateral:</strong> Haz clic en el botn lateral (PdR,s, iAs, etc.) cuyos marcadores quieres definir. Se resaltar.</li>
                    <li><strong>Asignar/Desasignar Marcadores:</strong> Haz clic en cualquier marcador de la rejilla. Si estaba asignado, se desasignar (atenuado). Si no lo estaba, se asignar (resaltado). <strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                    <li><strong>Cambiar Botn Lateral:</strong> Haz clic en otro botn lateral para asignar sus marcadores.</li>
                    <li><strong>Guardar:</strong> Los cambios se guardan automticamente al salir de este modo (pulsando el botn <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> cian).</li>
                    <li><strong>Visibilidad por defecto:</strong> Marcadores no asignados a <i>ningn</i> botn lateral siempre sern visibles (salvo que el botn general <img src="https://boardinggate.github.io/Tesla/IMG_4191.jpg" alt="OFF" style="width:20px; height:11px; display:inline; vertical-align:middle;"> est desactivado).</li>
                </ul>
            </div>
            <div class="mb-4 p-3 bg-green-100 border border-green-300 rounded">
            <h3 class="font-semibold text-lg mb-2">3. Asignar Palabra Clave Filtro (Icono Llave Verde)</h3>
            <ul class="list-disc pl-5 space-y-1 text-sm">
                <li><strong>Activar:</strong> Pulsa el icono de la llave <img src="https://boardinggate.github.io/Tesla/IMG_4314.PNG" alt="Key" style="width:16px; height:16px; display:inline; vertical-align:middle;"> junto al campo de filtro. El icono se pondr verde. Si vuelves a pulsar, se desactivar.</li>
                <li><strong>Escribe la Palabra:</strong> Escribe la palabra que quieres aadir al nombre de los botones en el campo de filtro. Se eliminarn los espacios automticamente.</li>
                <li><strong>Asignar:</strong> Haz clic en el botn del grid al que quieres aadir la palabra clave. La palabra (en corchetes) se aadir a su nombre (si no existe ya).</li>
                <li><strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                <li><strong>Guardar:</strong> Los cambios se guardan automticamente cada vez que asignas una palabra clave a un botn.</li>
                <li><strong>Mostrar Todo:</strong> Al activar este modo, se limpiar el filtro y se mostrarn todos los botones para facilitar la asignacin.</li>
            </ul>
            </div>
            <p class="mb-4"><strong>Salir de Personalizacin:</strong> Pulsa el botn activo <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (amarillo o cian) o el icono de la llave <img src="https://boardinggate.github.io/Tesla/IMG_4314.PNG" alt="Key" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (verde) para desactivar el modo actual y volver al uso normal.</p>
        `;
        document.body.appendChild(modal);
        const closeEditInfoButton = modal.querySelector('#close-edit-info');
        const closeHandler = () => { clearModalAutoCloseTimer(modal, closeEditInfoButton, 'edit-info-modal'); if (modal.parentNode) modal.parentNode.removeChild(modal); };
        closeEditInfoButton.addEventListener('click', closeHandler); addModalAutoCloseTimer(modal, closeEditInfoButton, 'edit-info-modal');
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showEditModal
    // RESUMEN: Muestra el modal para editar los detalles de un marcador o de un botn de seccin.
    // ===================================================================
    function showEditModal(targetIndexOrStart, isToggle = false) { if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); } const existingModal = document.querySelector('.edit-modal'); if (existingModal) existingModal.remove(); const modal = document.createElement('div'); modal.className = 'edit-modal'; if (isToggle) { editingTargetElement = toggleButtonElements[targetIndexOrStart]; } else { editingTargetElement = cellElements[targetIndexOrStart]; } if (editingTargetElement) { editingTargetElement.classList.add('editing-target'); } else { } let currentItemData = {}; let originalItemData = {}; let title = ''; let isNewBookmark = false; const targetIndex = isToggle ? -1 : targetIndexOrStart; if (isToggle) { const targetStart = targetIndexOrStart; const currentRange = currentToggleRanges.find(r => r.start === targetStart); const originalRange = originalToggleRanges.find(r => r.start === targetStart); const currentLabel = customData.toggles[targetStart]?.label ?? currentRange?.label ?? ''; currentItemData = { label: currentLabel }; originalItemData = { label: originalRange?.label || '' }; title = `Editar Etiqueta Seccin`;
        modal.innerHTML = `
            <h2>${title}</h2>
            <div class="modal-top-buttons" style="margin-bottom: 1.2rem;">
                <button class="save">Guardar</button>
                <button class="reset">Resetear</button>
                <button class="cancel">Cancelar</button>
            </div>
            <div><label for="edit-label">Etiqueta (mx 7):</label><input type="text" id="edit-label" value="${currentItemData.label}" maxlength="7"></div>
        `;
    } else { const currentBookmark = currentBookmarks[targetIndex]; const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null; currentItemData = currentBookmark ? { ...currentBookmark } : { name: '', url: '', favicon: '' }; originalItemData = originalBookmark ? { ...originalBookmark } : { name: '', url: '', favicon: '' }; isNewBookmark = !currentBookmark; title = currentBookmark ? `Editar Marcador: ${currentItemData?.name || `ndice ${targetIndex}`}` : `Aadir Marcador (Posicin ${targetIndex + 1})`;
        modal.innerHTML = `
            <h2>${title}</h2>
            <div class="modal-top-buttons" style="margin-bottom: 1.2rem;">
                <button class="save">Guardar</button>
                <button class="reset">Resetear</button>
                <button class="empty">Vaciar</button>
                <button class="cancel">Cancelar</button>
            </div>
            <div><label for="edit-name">Nombre:</label><input type="text" id="edit-name" value="${currentItemData.name || ''}"></div>
            <div><label for="edit-url">URL:</label><div class="input-with-button"><input type="url" id="edit-url" value="${currentItemData.url || ''}" placeholder="https://ejemplo.com"><button class="search-button" id="search-url-button" title="Buscar URL en Google (basado en URL/Nombre)"></button></div></div>
            <div><label for="edit-favicon">URL Favicon (Opcional):</label><div class="input-with-button"><input type="text" id="edit-favicon" value="${currentItemData.favicon || ''}" placeholder="Dejar vaco para auto"><button class="search-button" id="search-favicon-button" title="Buscar Favicon en Google Images (basado en Favicon/Nombre)"></button></div></div>
        `;
    } document.body.appendChild(modal); const cleanupEditModal = () => { if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; } if (modal.parentNode) modal.parentNode.removeChild(modal); }; modal.querySelector('.save').addEventListener('click', () => { let dataChanged = false; if (isToggle) { const targetStart = targetIndexOrStart; const newLabel = modal.querySelector('#edit-label').value.trim(); if (!newLabel) { showToast("La etiqueta no puede estar vaca.", "warning"); return; } if (newLabel.length > 7) { showToast("La etiqueta no puede exceder 7 caracteres.", "warning"); return; } const originalLabel = originalToggleRanges.find(r => r.start === targetStart)?.label || ''; if (newLabel !== originalLabel) { if (!customData.toggles[targetStart]) customData.toggles[targetStart] = {}; customData.toggles[targetStart].label = newLabel; dataChanged = true; } else { if (customData.toggles[targetStart] && customData.toggles[targetStart].hasOwnProperty('label')) { delete customData.toggles[targetStart].label; if (Object.keys(customData.toggles[targetStart]).length === 0) delete customData.toggles[targetStart]; dataChanged = true; } } const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetStart); if (rangeIdx > -1) currentToggleRanges[rangeIdx].label = newLabel; } else { const nameInput = modal.querySelector('#edit-name'); const urlInput = modal.querySelector('#edit-url'); const faviconInput = modal.querySelector('#edit-favicon');
                const newName = nameInput.value.trim();
                const newUrl = urlInput.value.trim();
                const newFavicon = faviconInput.value.trim() || null;
                const isEmpty = !newName && !newUrl && !newFavicon;
                const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                if (isEmpty) {
                    if (originalBookmark !== null && originalBookmark !== undefined) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = null;
                        dataChanged = true;
                    } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = null;
                } else {
                    if (!newName || !newUrl) {
                        showToast("Nombre y URL son obligatorios.", "warning");
                        return;
                    }
                    try { new URL(newUrl); } catch (_) {
                        showToast("URL invlida.", "warning");
                        return;
                    }
                    const bookmarkUpdate = { name: newName, url: newUrl, favicon: newFavicon };
                    const originalData = originalBookmark ? { name: originalBookmark.name, url: originalBookmark.url, favicon: originalBookmark.favicon || null } : null;
                    const bookmarksAreEqual = (b1, b2) => { if (b1 === null && b2 === null) return true; if (b1 === null || b2 === null) return false; return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null); };
                    if (!bookmarksAreEqual(bookmarkUpdate, originalData)) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = bookmarkUpdate;
                        dataChanged = true;
                   } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = bookmarkUpdate;
                }
            }
            if (dataChanged) {
                saveCustomData();
                showToast("Cambios guardados", "success");
            } else {
                showToast("No se detectaron cambios", "info");
            }
            updateGridItemUI(targetIndexOrStart, isToggle);
            cleanupEditModal();
        });
        modal.querySelector('.reset').addEventListener('click', () => {
            let dataChanged = false;
            if (isToggle) {
                const targetStart = targetIndexOrStart;
                const originalRange = originalToggleRanges.find(r => r.start === targetStart);
                const originalLabel = originalRange?.label || '';
                modal.querySelector('#edit-label').value = originalLabel;
                if (customData.toggles && customData.toggles[targetStart] && customData.toggles[targetStart].hasOwnProperty('label')) {
                    delete customData.toggles[targetStart].label;
                    if (Object.keys(customData.toggles[targetStart]).length === 0) delete customData.toggles[targetStart];
                    dataChanged = true;
                }
                const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetStart);
                if (rangeIdx > -1) currentToggleRanges[rangeIdx].label = originalLabel;
            } else {
                const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                modal.querySelector('#edit-name').value = originalBookmark?.name || '';
                modal.querySelector('#edit-url').value = originalBookmark?.url || '';
                modal.querySelector('#edit-favicon').value = originalBookmark?.favicon || '';
                if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                    delete customData.bookmarks[targetIndex];
                    dataChanged = true;
                }
                currentBookmarks[targetIndex] = originalBookmark ? { ...originalBookmark } : null;
            }
            if (dataChanged) {
                saveCustomData();
                showToast("Valores reseteados al original y guardados", "info");
            } else {
                showToast("Ya estaba con los valores originales", "info");
            }
            updateGridItemUI(targetIndexOrStart, isToggle);
            cleanupEditModal();
        });
        modal.querySelector('.cancel').addEventListener('click', cleanupEditModal);
        if (!isToggle) {
            const emptyBtn = modal.querySelector('.empty');
            if (emptyBtn) {
                emptyBtn.addEventListener('click', () => {
                    modal.querySelector('#edit-name').value = '';
                    modal.querySelector('#edit-url').value = '';
                    modal.querySelector('#edit-favicon').value = '';
                    const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                    let dataChanged = false;
                    if (originalBookmark !== null && originalBookmark !== undefined) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = null;
                        dataChanged = true;
                    } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = null;
                    if(dataChanged) {
                        saveCustomData();
                        showToast("Marcador vaciado y guardado.", "success");
                    } else {
                        showToast("Marcador ya estaba vaco.", "info");
                    }
                    updateGridItemUI(targetIndex, false);
                    cleanupEditModal();
                });
            }
            const searchUrlBtn = modal.querySelector('#search-url-button');
            const searchFaviconBtn = modal.querySelector('#search-favicon-button');
            const nameInput = modal.querySelector('#edit-name');
            const urlInputSearch = modal.querySelector('#edit-url');
            const faviconInputSearch = modal.querySelector('#edit-favicon');
            if (searchUrlBtn) {
                searchUrlBtn.addEventListener('click', () => {
                    const urlValue = urlInputSearch.value.trim();
                    const nameValue = nameInput.value.trim();
                    const query = urlValue || nameValue;
                    if (query) { window.open(`https://www.google.com/search?q=${encodeURIComponent(query)}`, '_blank'); }
                    else { showToast("Escribe un Nombre o URL para buscar.", "warning"); }
                });
            }
            if (searchFaviconBtn) {
                searchFaviconBtn.addEventListener('click', () => {
                    const faviconValue = faviconInputSearch.value.trim();
                    const nameValue = nameInput.value.trim();
                    const query = faviconValue || nameValue;
                    if (query) { window.open(`https://www.google.com/search?tbm=isch&q=${encodeURIComponent(`"${query}" favicon logo icon`)}`, '_blank'); }
                    else { showToast("Escribe un Nombre o URL de Favicon para buscar.", "warning"); }
                });
            }
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateGridItemUI
    // RESUMEN: Redibuja el grid y los botones para reflejar los cambios realizados en la edicin.
    // ===================================================================
    function updateGridItemUI(indexOrStart, isToggle = false) {
        renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles();adjustButtonPositions();
        if (isAssignmentMode) {
            updateGridAssignmentVisuals();
            if (currentlyAssigningToggleStart !== null && toggleButtonElements[currentlyAssigningToggleStart]) {
                toggleButtonElements[currentlyAssigningToggleStart].classList.add('assigning-selected');
                toggleButtonElements[currentlyAssigningToggleStart].style.opacity = '';
            }
        } else if (isKeywordAssignmentMode) { applyInitialKeywordHighlights(); }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: performInsertAndSave
    // RESUMEN: Realiza la lgica de mover un marcador en el grid y guarda los cambios.
    // ===================================================================
    function performInsertAndSave(sourceIndex, targetIndex) { if (sourceIndex === targetIndex || sourceIndex === null || targetIndex === null) { return false; } const draggedData = currentBookmarks.splice(sourceIndex, 1)[0]; currentBookmarks.splice(targetIndex, 0, draggedData); if (!customData.bookmarks) customData.bookmarks = {}; if (!customData.toggles) customData.toggles = {}; const minIdx = Math.min(sourceIndex, targetIndex); const maxIdx = Math.max(sourceIndex, targetIndex); currentToggleRanges.forEach(range => { if (range.assignedIndexes) {
        range.assignedIndexes = range.assignedIndexes.map(idx => { if (idx === sourceIndex) return targetIndex; else if (idx > sourceIndex && idx <= targetIndex) return idx - 1; else if (idx < sourceIndex && idx >= targetIndex) return idx + 1; else return idx; }).sort((a, b) => a - b); const startKey = range.start.toString(); if (customData.toggles[startKey] && customData.toggles[startKey].hasOwnProperty('assignedIndexes')) { customData.toggles[startKey].assignedIndexes = [...range.assignedIndexes]; } } }); for (let i = minIdx; i <= maxIdx; i++) { const currentItem = currentBookmarks[i]; const originalItem = i < originalBookmarks.length ? originalBookmarks[i] : null; const bookmarksAreEqual = (b1, b2) => { if (b1 === null && b2 === null) return true; if (b1 === null || b2 === null) return false; return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null); }; if (!bookmarksAreEqual(currentItem, originalItem)) { customData.bookmarks[i] = currentItem ? { ...currentItem } : null; } else if (customData.bookmarks.hasOwnProperty(i)) { delete customData.bookmarks[i]; } } saveCustomData(); renderGrid(); loadSavedSettings(); updateButtonStyles(); showToast(`Movido de ${sourceIndex + 1} a ${targetIndex + 1}`, "success", 1500); return true; }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleDragStart
    // RESUMEN: Maneja el inicio del arrastre de un elemento del grid.
    // ===================================================================
    function handleDragStart(e) { if (!isEditMode) return; draggedItem = e.currentTarget; draggedItemIndex = parseInt(draggedItem.dataset.index); e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', draggedItemIndex); setTimeout(() => { if (draggedItem) draggedItem.classList.add('dragging'); }, 0); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleDragOver
    // RESUMEN: Maneja el evento cuando un elemento arrastrado pasa sobre otro.
    // ===================================================================
    function handleDragOver(e) { if (!isEditMode || !draggedItem) return; e.preventDefault(); e.dataTransfer.dropEffect = 'move'; const targetCell = e.target.closest('.grid-cell'); const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetCell && targetIndex !== dragOverIndex) { if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } if (targetIndex !== draggedItemIndex) { targetCell.classList.add('drag-over'); dragOverIndex = targetIndex; } else { dragOverIndex = null; } } else if (!targetCell && dragOverIndex !== null) { if (cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } dragOverIndex = null; } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleDragLeave
    // RESUMEN: Maneja el evento cuando un elemento arrastrado sale de una celda destino.
    // ===================================================================
    function handleDragLeave(e) { if (!isEditMode || !draggedItem) return; const targetCell = e.target.closest('.grid-cell'); if (targetCell && !targetCell.contains(e.relatedTarget)) { if (parseInt(targetCell.dataset.index) === dragOverIndex) { targetCell.classList.remove('drag-over'); dragOverIndex = null; } } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleDrop
    // RESUMEN: Maneja el evento de soltar un elemento arrastrado.
    // ===================================================================
    function handleDrop(e) { if (!isEditMode || !draggedItem) return; e.preventDefault(); const targetCell = e.target.closest('.grid-cell'); const sourceIndex = draggedItemIndex; const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetIndex !== null && sourceIndex !== targetIndex) { performInsertAndSave(sourceIndex, targetIndex); } else { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } } handleDragEndCleanup(); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleDragEnd
    // RESUMEN: Maneja la finalizacin de una operacin de arrastre.
    // ===================================================================
    function handleDragEnd(e) { if (!isEditMode) return; handleDragEndCleanup(); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleDragEndCleanup
    // RESUMEN: Limpia las variables y estilos de la operacin de arrastre.
    // ===================================================================
    function handleDragEndCleanup() { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } draggedItem = null; draggedItemIndex = null; dragOverIndex = null; }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleTouchStart
    // RESUMEN: Maneja el inicio de un toque para el arrastre en dispositivos tctiles.
    // ===================================================================
    function handleTouchStart(e) { if (!isEditMode || e.touches.length !== 1) return; draggedItem = e.currentTarget; draggedItemIndex = parseInt(draggedItem.dataset.index); const touch = e.touches[0]; touchStartX = touch.clientX; touchStartY = touch.clientY; draggedItem.classList.add('dragging'); currentTouchTarget = draggedItem; }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleTouchMove
    // RESUMEN: Maneja el movimiento del dedo durante el arrastre tctil.
    // ===================================================================
    function handleTouchMove(e) { if (!isEditMode || !draggedItem || e.touches.length !== 1) return; e.preventDefault(); const touch = e.touches[0]; const elementOver = document.elementFromPoint(touch.clientX, touch.clientY); const targetCell = elementOver?.closest('.grid-cell'); const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetCell && targetIndex !== dragOverIndex) { if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } if (targetIndex !== draggedItemIndex) { targetCell.classList.add('drag-over'); dragOverIndex = targetIndex; currentTouchTarget = targetCell; } else { dragOverIndex = null; currentTouchTarget = draggedItem; } } else if (!targetCell && dragOverIndex !== null) { if (cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } dragOverIndex = null; currentTouchTarget = null; } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleTouchEnd
    // RESUMEN: Maneja la finalizacin de un arrastre tctil.
    // ===================================================================
    function handleTouchEnd(e) { if (!isEditMode || !draggedItem) return; if (dragOverIndex !== null && dragOverIndex !== draggedItemIndex) { performInsertAndSave(draggedItemIndex, dragOverIndex); e.preventDefault(); } else { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } } handleTouchEndCleanup(); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleTouchCancel
    // RESUMEN: Maneja la cancelacin de un arrastre tctil.
    // ===================================================================
    function handleTouchCancel(e) { if (!isEditMode) return; handleTouchEndCleanup(); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleTouchEndCleanup
    // RESUMEN: Limpia las variables y estilos de la operacin de arrastre tctil.
    // ===================================================================
    function handleTouchEndCleanup() { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } draggedItem = null; draggedItemIndex = null; dragOverIndex = null; currentTouchTarget = null; touchStartX = 0; touchStartY = 0; }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: normalizeText
    // RESUMEN: Normaliza un texto (minsculas, sin acentos) para facilitar comparaciones.
    // ===================================================================
    function normalizeText(text) { if (!text) return ''; return text.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, ''); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: filterGridItems
    // RESUMEN: Filtra los elementos del grid segn el texto del filtro y los toggles de seccin.
    // ===================================================================
    function filterGridItems() {
        const filterInput = document.getElementById('grid-filter-input');
        const clearButton = document.getElementById('clear-filter-button');
        if (!filterInput || !clearButton || !cellElements || cellElements.length === 0) { return; }
        if (isKeywordAssignmentMode) {
            cellElements.forEach(cellContainer => { cellContainer.classList.remove('hidden'); });
            clearButton.style.display = filterInput.value.trim() ? 'inline-block' : 'none';
            return;
        }
        const rawFilterText = filterInput.value.trim();
        clearButton.style.display = rawFilterText ? 'inline-block' : 'none';
        const filterWords = rawFilterText.split(/\s+/).filter(word => word.length > 0).map(word => normalizeText(word));
        const onOffToggleElem = document.getElementById('on-off-toggle');
        const masterState = onOffToggleElem ? (onOffToggleElem.dataset.state || 'on') : 'on';
        cellElements.forEach((cellContainer, index) => {
            const isMasterOff = masterState === 'off';
            if (isMasterOff) {
                cellContainer.classList.add('hidden');
                return;
            }
            const bookmark = currentBookmarks[index];
            const bookmarkName = bookmark ? normalizeText(bookmark.name) : '';
            const isEmptySlot = !bookmark;
            let matchesFilter = true;
            if (filterWords.length > 0) {
                if (isEmptySlot) {
                    matchesFilter = false;
                } else {
                    matchesFilter = filterWords.every(word => bookmarkName.includes(word));
                }
            }
            const shouldBeHiddenByFilter = filterWords.length > 0 && !matchesFilter;
            let shouldBeHiddenByToggles = false;
            const containingRange = getSectionForIndex(index);
            if (containingRange) {
                const toggleButton = toggleButtonElements[containingRange.start] || document.querySelector(`.range-toggle[data-range-start="${containingRange.start}"]`);
                if (toggleButton) {
                    const toggleState = toggleButton.dataset.state || 'visible';
                    shouldBeHiddenByToggles = toggleState === 'hidden';
                }
            } else {
                shouldBeHiddenByToggles = false;
            }
            const shouldBeHidden = shouldBeHiddenByToggles || shouldBeHiddenByFilter;
            cellContainer.classList.toggle('hidden', shouldBeHidden);
        });
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: promptForPin
    // RESUMEN: Muestra el modal para introducir el PIN de acceso.
    // ===================================================================
    function promptForPin() { const pinModal = document.getElementById('pin-modal-overlay'); const pinInput = document.getElementById('pin-input'); const pinSubmit = document.getElementById('pin-submit-button'); const pinError = document.getElementById('pin-error-message'); pinModal.classList.remove('hidden');
        pinInput.value = ''; pinError.textContent = ''; pinInput.focus(); const newPinSubmit = pinSubmit.cloneNode(true); pinSubmit.parentNode.replaceChild(newPinSubmit, pinSubmit); newPinSubmit.addEventListener('click', checkPin); pinInput.addEventListener('keyup', (event) => { if (event.key === 'Enter') { checkPin(); } }); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: checkPin
    // RESUMEN: Verifica el PIN introducido por el usuario.
    // ===================================================================
    function checkPin() { const pinModal = document.getElementById('pin-modal-overlay'); const pinInput = document.getElementById('pin-input'); const pinError = document.getElementById('pin-error-message'); const enteredPin = pinInput.value; if (enteredPin === storedPin) { pinModal.classList.add('hidden'); initializeApp(); } else { pinError.textContent = 'Clave incorrecta.'; pinInput.value = ''; pinInput.focus(); if (navigator.vibrate) navigator.vibrate(100); } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handlePasswordToggleClick
    // RESUMEN: Activa o desactiva la solicitud de PIN al inicio.
    // ===================================================================
    function handlePasswordToggleClick() { if (!storedPin) { showToast('Primero establece una clave en Configuracin -> Usuario.', 'warning'); return; } isPasswordActive = !isPasswordActive; updatePasswordToggleIcon(); saveSettings(); showToast(`Solicitar clave al inicio: ${isPasswordActive ? 'Activado' : 'Desactivado'}`, 'info'); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updatePasswordToggleIcon
    // RESUMEN: Actualiza el icono del candado segn si el PIN est activo o no.
    // ===================================================================
    function updatePasswordToggleIcon() { const passwordButton = document.getElementById('password-toggle-button'); if (passwordButton) { const img = passwordButton.querySelector('img'); if(img) { const iconPath = isPasswordActive ? 'IMG_4281.png' : 'IMG_4280.png'; img.src = `https://boardinggate.github.io/Tesla/${iconPath}`;
        img.alt = isPasswordActive ? 'Clave Activada' : 'Clave Desactivada'; passwordButton.title = `Clave al inicio: ${isPasswordActive ? 'Activada' : 'Desactivada'}`; } } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: savePinSettings
    // RESUMEN: Guarda las nuevas configuraciones de PIN y preferencias de inicio.
    // ===================================================================
    function savePinSettings() {
        const pinSetInput = document.getElementById('config-pin-set');
        const pinConfirmInput = document.getElementById('config-pin-confirm');
        const pinStatus = document.getElementById('config-pin-status');
        const directToNavCheckbox = document.getElementById('config-direct-to-nav');
        const newPin = pinSetInput.value;
        const confirmPin = pinConfirmInput.value;
        pinStatus.textContent = '';
        let keySaved = false;
        let prefSaved = false;
        if (newPin || confirmPin) {
            if (!/^\d{4}$/.test(newPin)) {
                pinStatus.textContent = 'La clave debe tener exactamente 4 cifras.';
                pinStatus.style.color = '#EF4444';
                return;
            }
            if (newPin !== confirmPin) {
                pinStatus.textContent = 'Las claves no coinciden.';
                pinStatus.style.color = '#EF4444';
                return;
            }
            try {
                localStorage.setItem('password_pin', newPin);
                storedPin = newPin;
                if (!localStorage.getItem('password_active') || isPasswordActive) {
                    isPasswordActive = true;
                    localStorage.setItem('password_active', 'true');
                }
                pinStatus.textContent = 'Clave guardada. ';
                pinStatus.style.color = '#28a745';
                pinSetInput.value = '';
                pinConfirmInput.value = '';
                updatePasswordToggleIcon();
                keySaved = true;
            } catch (e) {
                pinStatus.textContent ='Error al guardar la clave.';
                pinStatus.style.color = '#EF4444';
                showToast('Error al guardar la clave.', 'error');
            }
        }
        const directToNavChecked = directToNavCheckbox.checked;
        localStorage.setItem(DIRECT_TO_NAVIGATION_KEY, JSON.stringify(directToNavChecked));
        prefSaved = true;
        if (keySaved && prefSaved) {
            showToast('Clave y preferencia de inicio guardadas.', 'success');
            pinStatus.textContent += (pinStatus.textContent ? "Y " : "") + "Preferencia de inicio guardada.";
             pinStatus.style.color = '#28a745';
        } else if (keySaved) {
            showToast('Clave guardada. Preferencia de inicio tambin actualizada.', 'success');
             pinStatus.textContent += (pinStatus.textContent ? " " : "") + "Preferencia de inicio guardada.";
             pinStatus.style.color = '#28a745';
        } else if (prefSaved) {
            showToast('Preferencia de inicio guardada.', 'success');
            pinStatus.textContent = "Preferencia de inicio guardada.";
            pinStatus.style.color = '#28a745';
        } else if (!newPin && !confirmPin) {
             pinStatus.textContent = "No se realizaron cambios en la clave. Preferencia de inicio no cambi.";
             pinStatus.style.color = '#17a2b8';
        }
        saveSettings();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: removePinSettings
    // RESUMEN: Elimina la configuracin de PIN de acceso.
    // ===================================================================
    function removePinSettings() { const pinStatus = document.getElementById('config-pin-status'); if (confirm('Ests seguro de que deseas eliminar la clave de acceso? Ya no se solicitar al inicio.')) { try { localStorage.removeItem('password_pin'); localStorage.setItem('password_active', 'false'); storedPin = null; isPasswordActive = false; pinStatus.textContent = 'Clave eliminada.'; pinStatus.style.color = '#17a2b8'; document.getElementById('config-pin-set').value = ''; document.getElementById('config-pin-confirm').value = ''; updatePasswordToggleIcon(); saveSettings(); showToast('Clave eliminada.', 'info'); } catch (e) { pinStatus.textContent = 'Error al eliminar la clave.'; pinStatus.style.color = '#EF4444'; showToast('Error al eliminar la clave.', 'error'); } } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getRemoteUpdatesDate
    // RESUMEN: Obtiene la fecha de la ltima actualizacin de un archivo remoto.
    // ===================================================================
    async function getRemoteUpdatesDate() { try { const response = await fetch('https://boardinggate.github.io/Tesla/updates.txt', { cache: 'no-cache' }); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const text = await response.text(); const firstLine = text.split('\n')[0].trim(); const dateMatch = firstLine.match(/^\d{4}-\d{2}-\d{2}/); if (dateMatch) { const [year, month, day] = dateMatch[0].split('-').map(Number); const remoteDate = new Date(Date.UTC(year, month - 1, day)); if (!isNaN(remoteDate.getTime())) { return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`; } } return null; } catch (e) { return null; } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: isRemoteDateNewer
    // RESUMEN: Compara si una fecha remota es ms reciente que una fecha en cach.
    // ===================================================================
    function isRemoteDateNewer(remoteDateStr, cachedDateStr) { if (!remoteDateStr) return false; if (!cachedDateStr) return true; try { return remoteDateStr > cachedDateStr; } catch (e) { return false; } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: checkVersionsIconOpacity
    // RESUMEN: Ajusta la opacidad del icono de versiones si hay actualizaciones nuevas.
    // ===================================================================
    async function checkVersionsIconOpacity() { const versionsIcon = document.getElementById('versions-button'); const versionsImg = versionsIcon ? versionsIcon.querySelector('img') : null; if (!versionsImg) return;
        let showAsNew = false; const remoteDateStr = await getRemoteUpdatesDate();
        if (remoteDateStr) { showAsNew = isRemoteDateNewer(remoteDateStr, lastUpdatesCheckDate); } versionsImg.style.opacity = showAsNew ? '1.0' : '0.1';
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showVersionsModal
    // RESUMEN: Muestra el modal con el historial de versiones.
    // ===================================================================
    async function showVersionsModal() {
        const versionsModalOverlay = document.getElementById('versions-modal-overlay');
        const versionsContent = document.getElementById('versions-content');
        const closeButton = document.getElementById('close-versions-modal');
        if (!versionsModalOverlay || !versionsContent || !closeButton) return;
        const newCloseButton = closeButton.cloneNode(true);
        closeButton.parentNode.replaceChild(newCloseButton, closeButton);
        const closeHandler = () => {
            versionsModalOverlay.classList.add('hidden');
            clearModalAutoCloseTimer(versionsModalOverlay, newCloseButton, 'versions-modal');
        };
        newCloseButton.addEventListener('click', closeHandler);
        versionsContent.textContent = 'Cargando histrico...';
        versionsModalOverlay.classList.remove('hidden');
        addModalAutoCloseTimer(versionsModalOverlay, newCloseButton, 'versions-modal');
        try {
            const response = await fetch('https://boardinggate.github.io/Tesla/updates.txt', { cache: 'no-cache' });
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const text = await response.text();
            versionsContent.textContent = text;
            const firstLine = text.split('\n')[0].trim();
            const dateMatch = firstLine.match(/^\d{4}-\d{2}-\d{2}/);
            let dateToStore = null;
            if (dateMatch) {
                const [year, month, day] = dateMatch[0].split('-').map(Number);
                const checkDate = new Date(Date.UTC(year, month - 1, day));
                if (!isNaN(checkDate.getTime())) {
                    dateToStore = dateMatch[0];
                }
            }
            if (dateToStore) {
                lastUpdatesCheckDate = dateToStore;
            } else {
                const today = new Date();
                lastUpdatesCheckDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
            }
            saveSettings();
            await checkVersionsIconOpacity();
        } catch (e) {
            versionsContent.textContent = `Error al cargar el histrico:\n${e.message}`;
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getCurrentLocation
    // RESUMEN: Obtiene la ubicacin actual del dispositivo a travs de la API de Geolocalizacin.
    // ===================================================================
    function getCurrentLocation(callback, errorCallback) {
        if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    callback({
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy,
                        altitude: position.coords.altitude,
                        heading: position.coords.heading,
                        speed: position.coords.speed
                    });
                },
                (error) => {
                    let message = "No se pudo obtener la ubicacin.";
                    switch (error.code) {
                        case error.PERMISSION_DENIED:
                            message = "Permiso de ubicacin denegado.";
                            break;
                        case error.POSITION_UNAVAILABLE:
                            message = "Informacin de ubicacin no disponible.";
                            break;
                        case error.TIMEOUT:
                            message = "Timeout obteniendo ubicacin.";
                            break;
                    }
                    if (errorCallback) errorCallback(message);
                    else showToast(message, "error");
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        } else {
            const message = "Geolocalizacin no soportada por este navegador.";
            if (errorCallback) errorCallback(message);
            else showToast(message, "error");
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: calculateDistance
    // RESUMEN: Calcula la distancia en metros entre dos coordenadas geogrficas.
    // ===================================================================
    function calculateDistance(lat1, lon1, lat2, lon2) {
        if (typeof lat1 !== 'number' || typeof lon1 !== 'number' || typeof lat2 !== 'number' || typeof lon2 !== 'number' || isNaN(lat1) || isNaN(lon1) || isNaN(lat2) || isNaN(lon2)) {
             return Infinity;
        }
        const R = 6371e3; const 1 = lat1 * Math.PI / 180; const 2 = lat2 * Math.PI / 180; const  = (lat2 - lat1) * Math.PI / 180; const  = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin( / 2) * Math.sin( / 2) + Math.cos(1) * Math.cos(2) * Math.sin( / 2) * Math.sin( / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return R * c;
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: parseReminderText
    // RESUMEN: Parsea el texto de un recordatorio para extraer fecha, hora, repeticin, etc.
    // ===================================================================
    function parseReminderText(text, elementsToUpdate = null) {
        const result = { text: `<b>${text.trim().toUpperCase()}</b>`, time: null, date: null, repeatDays: [], intervalDays: null, type: null, isLocationEnabled: false, locationCoordinates: null, radiusMeters: 350, excludeFromList: false };
        let norm = text.toUpperCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        const numW = { 'UNA': 1, 'UNO': 1, 'DOS': 2, 'TRES': 3, 'CUATRO': 4, 'CINCO': 5, 'SEIS': 6, 'SIETE': 7, 'OCHO': 8, 'NUEVE': 9, 'DIEZ': 10, 'ONCE': 11, 'DOCE': 12, 'TRECE': 13, 'CATORCE': 14, 'QUINCE': 15, 'DIECISEIS': 16, 'DIECISIETE': 17, 'DIECIOCHO': 18, 'DIECINUEVE': 19, 'VEINTE': 20, 'VEINTIUNO': 21, 'VEINTIDOS': 22, 'VEINTITRES': 23, 'VEINTICUATRO': 24, 'VEINTICINCO': 25, 'VEINTISEIS': 26, 'VEINTISIETE': 27, 'VEINTIOCHO': 28, 'VEINTINUEVE': 29, 'TREINTA': 30, 'TREINTAYUNO': 31 }; const tRgx = /\b(\d{1,2}):(\d{2})\b/; const ttRgx = /.*\bA\s*LAS?\s*(\d+|\w+)\s*(?:Y\s*(CUARTO|MEDIA|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA)|MENOS\s*(CUARTO|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA))?\s*(DE\s*LA\s*(MANANA|TARDE|NOCHE))?/i; const tM = norm.match(tRgx); if (tM) { let h = parseInt(tM[1]); let m = parseInt(tM[2]); if (h >= 0 && h <= 23 && m >= 0 && m <= 59) result.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`; } else { const ttM = norm.match(ttRgx); if (ttM) { let h = numW[ttM[1].toUpperCase()] || parseInt(ttM[1]); if (!isNaN(h)) { const minTxt = ttM[2]?.toUpperCase() || ''; const minus = ttM[3]?.toUpperCase() || ''; const period = ttM[5]?.toUpperCase() || null; let m = 0; if (minTxt) m = minTxt === 'CUARTO' ? 15 : minTxt === 'MEDIA' ? 30 : numW[minTxt] || parseInt(minTxt) || 0; else if (minus) { m = minus === 'CUARTO' ? 15 : numW[minus] || parseInt(minus) || 0; h = (h - 1 + 24) % 24; m = (60 - m + 60) % 60; } if (period) { if (period === 'TARDE' && h >= 1 && h <= 11) h += 12; if (period === 'NOCHE' && h >= 1 && h <= 11) h += 12; if (period === 'MANANA' && h === 12) h = 0; if (period === 'TARDE' && h === 12) h = 12; if (period === 'NOCHE' && h === 12) h = 0; } else if (h >= 1 && h <= 5) h += 12; if (h >= 0 && h <= 23 && m >= 0 && m <= 59) result.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`; } } } const daysMap = { 'LUNES': 1, 'MARTES': 2, 'MIERCOLES': 3, 'MIRCOLES': 3, 'JUEVES': 4, 'VIERNES': 5, 'SABADO': 6, 'SBADO': 6, 'DOMINGO': 0 }; const wRgx = /(TODOS\s+LOS|LOS|CADA)?\s*(LUNES|MARTES|MIERCOLES|MIRCOLES|JUEVES|VIERNES|SABADO|SBADO|DOMINGO)/g; let wM; while ((wM = wRgx.exec(norm)) !== null) { const day = daysMap[wM[2]]; if (day !== undefined && !result.repeatDays.includes(day)) result.repeatDays.push(day); }
        const now = new Date(); const manDRgx = /(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{2}|\d{4})\b/; const manDM = norm.match(manDRgx);
        if (manDM && !result.date) { let d = parseInt(manDM[1]); let m = parseInt(manDM[2]); let y = parseInt(manDM[3]); if (y >= 0 && y <= 99) y += 2000; if (d >= 1 && d <= 31 && m >= 1 && m <= 12 && y >= 2000 && y <= 2099) { const tD = new Date(Date.UTC(y, m - 1, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() + 1 === m && tD.getUTCFullYear() === y) { result.date = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } } }
        const todayRgx = /\bHOY\b/; const tomRgx = /\bMANANA\b/; const dayAftRgx = /\bPASADO\s*MANANA\b/;
        if (!result.date) { if (norm.match(todayRgx)) { result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (norm.match(dayAftRgx)) { const tD = new Date(now); tD.setDate(now.getDate() + 2); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } else if (norm.match(tomRgx)) { const tD = new Date(now); tD.setDate(now.getDate() + 1); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } }
        const dndRgx = /(?:EL\s*(PROXIMO)?\s*)?(LUNES|MARTES|MIERCOLES|MIRCOLES|JUEVES|VIERNES|SABADO|SBADO|DOMINGO)/i; const dndM = norm.match(dndRgx);
        if (dndM && !result.date) { const tDN = dndM[2].toUpperCase(); const tD = daysMap[tDN]; if (tD !== undefined) { const curD = now.getDay(); let dU = (tD - curD + 7) % 7; if (dU === 0) dU = 7; if (dndM[1]?.toUpperCase() === 'PROXIMO') dU += 7; const target = new Date(now); target.setDate(now.getDate() + dU); result.date = `${target.getFullYear()}-${(target.getMonth() + 1).toString().padStart(2, '0')}-${target.getDate().toString().padStart(2, '0')}`; } }
        const didRgx = /DENTRO\s*DE\s*(\d+)\s*DIAS?/; const didM = norm.match(didRgx);
        if (didM && !result.date) { const d = parseInt(didM[1]); if (!isNaN(d) && d > 0) { const tD = new Date(now); tD.setDate(now.getDate() + d); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } }
        const dsdRgx = /\bEL\s*DIA\s*(\d{1,2})\b/; const dsdM = norm.match(dsdRgx);
        if (dsdM && !result.date) { const d = parseInt(dsdM[1]); if (!isNaN(d) && d >= 1 && d <= 31) { let tM = now.getMonth(); let tY = now.getFullYear(); if (d < now.getDate()) { tM++; if (tM > 11) { tM = 0; tY++; } } const tD = new Date(Date.UTC(tY, tM, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() === tM) { result.date = `${tY}-${(tM + 1).toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } } }
        const intRgx = /CADA\s*(\d+)\s*DIAS?/; const intM = norm.match(intRgx);
        if (intM) { result.intervalDays = parseInt(intM[1]); if (!result.date) { result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } }
        const timRgx = /(ALARMA|AVISO|AVISAR|AVISARME|AVSAME|TEMPORIZADOR|TIMER|RECORDAR|RECORDARME|RECURDAME)\b.*?\b(\d+|\w+)\s*(MINUTOS?|HORAS?|MINS?|HRS?)/i; const timM = norm.match(timRgx);
        if (timM) { const valStr = timM[2]; const unit = timM[3]?.toUpperCase(); let val = numW[valStr.toUpperCase()] || parseInt(valStr); if (!isNaN(val) && val > 0 && unit) { let tmc = 0; if (unit.startsWith('HORA') || unit.startsWith('HR')) { tmc = val * 60; } else if (unit.startsWith('MINUTO') || unit.startsWith('MIN')) { tmc = val; }
                if (tmc > 0) { const endT = new Date(Date.now() + tmc * 60000); result.date = `${endT.getFullYear()}-${(endT.getMonth() + 1).toString().padStart(2, '0')}-${endT.getDate().toString().padStart(2, '0')}`; result.time = `${endT.getHours().toString().padStart(2, '0')}:${endT.getMinutes().toString().padStart(2, '0')}`; result.repeatDays = []; result.intervalDays = null; result.type = 'simple'; } } }
        const locationPhrases = ["EN EL LUGAR", "EN EL SITIO", "EN LA UBICACION", "EN LA LOCALIZACION"]; if (locationPhrases.some(phrase => norm.includes(phrase))) { result.isLocationEnabled = true; }
        const radiusRgx = /(?:RADIO|MARGEN)\s*DE\s*(\d+)\s*METROS?/i; const radiusMatch = norm.match(radiusRgx);
        if (radiusMatch && radiusMatch[1]) { const parsedRadius = parseInt(radiusMatch[1]); if (!isNaN(parsedRadius) && parsedRadius > 0) { result.radiusMeters = parsedRadius; result.isLocationEnabled = true; } }
        const excludePhrases = ["NO LISTAR", "NO MOSTRAR EN LISTA", "EXCLUIR LISTA", "OCULTAR LISTA", "RADAR"]; if (excludePhrases.some(phrase => norm.includes(phrase))) { result.excludeFromList = true; }
        if (norm.toUpperCase().startsWith("<b>RADAR:") && result.radiusMeters === 350 && !radiusMatch) {
            result.radiusMeters = 350;
        } else if (result.radiusMeters === 350 && !norm.toUpperCase().startsWith("<b>RADAR:") && !radiusMatch && !excludePhrases.some(phrase => norm.includes(phrase))) {
            result.radiusMeters = 350;
        }
        if (result.type === null) {
            if (result.intervalDays !== null && result.date) { result.type = 'interval'; } else if (result.repeatDays.length > 0 && result.time) { result.type = 'weekly'; } else if (result.date && result.time) { result.type = 'daily'; } else if (result.time) { result.type = 'daily'; if (!result.date) result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (result.date) { result.type = 'daily'; } else { result.type = 'simple'; } }
        if (!result.time && (result.type === 'daily' || result.type === 'weekly' || result.type === 'interval' )) { result.time = '00:01'; }
        if (elementsToUpdate) {
             if (elementsToUpdate.locationCheckbox) { const shouldBeChecked = result.isLocationEnabled; if (elementsToUpdate.locationCheckbox.checked !== shouldBeChecked && !elementsToUpdate.mapExpandedManually) { elementsToUpdate.locationCheckbox.checked = shouldBeChecked; } }
             if (elementsToUpdate.radiusInput) { elementsToUpdate.radiusInput.value = result.radiusMeters; }
             if (!elementsToUpdate.manualTimeInput && elementsToUpdate.timeInput && result.time) { elementsToUpdate.timeInput.value = result.time; }
             if (elementsToUpdate.dateInput && result.date) { const dateParts = result.date.split('-');
             if(dateParts.length === 3) { elementsToUpdate.dateInput.value = `${dateParts[2]}/${dateParts[1]}/${dateParts[0]}`; } else { elementsToUpdate.dateInput.value = ''; } } else if (elementsToUpdate.dateInput) { elementsToUpdate.dateInput.value = ''; }
             if (elementsToUpdate.intervalInput) { elementsToUpdate.intervalInput.value = result.intervalDays || ''; }
             if (elementsToUpdate.repeatCheckboxes && result.repeatDays && result.repeatDays.length > 0) { elementsToUpdate.repeatCheckboxes.forEach(input => { input.checked = result.repeatDays.includes(parseInt(input.value)); }); } else if (elementsToUpdate.repeatCheckboxes) { elementsToUpdate.repeatCheckboxes.forEach(input => { input.checked = false; }); }
             if (elementsToUpdate.excludeFromListCheckbox) { elementsToUpdate.excludeFromListCheckbox.checked = result.excludeFromList; }
        } return result;
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showHelpModal
    // RESUMEN: Muestra el modal de ayuda con ejemplos de uso para crear recordatorios.
    // ===================================================================
    function showHelpModal(options = {}) {
        const modal = document.createElement('div'); modal.className = 'help-modal'; modal.setAttribute('aria-label', 'Ayuda recordatorios');
        modal.innerHTML = `
            <h2 class="text-2xl font-bold">Ayuda Recordatorios</h2>
            <div class="modal-top-buttons" style="justify-content: flex-end;">
                <button type="button" id="close-help" style="flex: 0 1 auto; min-width: 120px;">Cerrar</button>
            </div>
            <p class="mb-4">Ejemplos:</p>
            <ul class="list-disc pl-6 mb-4">
                <li><strong>Texto:</strong> "Recordar cita", "Llamar mam"</li>
                <li><strong>Hora:</strong> "A LAS DIEZ Y CUARTO"  10:15, "A LAS CINCO Y MEDIA TARDE"  17:30</li>
                <li><strong>Fecha:</strong> "HOY", "MAANA", "DENTRO DE 15 DAS", "EL DA 22", "PRXIMO LUNES", "25/05/2025"</li>
                <li><strong>Repeticin:</strong> "CADA LUNES", "TODOS LOS VIERNES Y SBADOS"</li>
                <li><strong>Intervalo:</strong> "CADA 7 DAS"</li>
                <li><strong>Alarma:</strong> "ALARMA EN 30 MINUTOS", "RECORDAR EN 2 HORAS". Crea recordatorio para fecha/hora exacta.</li>
                <li><strong>Excluir de Lista/Radar:</strong> Aadir "NO LISTAR", "EXCLUIR LISTA" o "RADAR" para ocultarlo de la lista general y que aparezca con chincheta morada en el mapa de ubicaciones.</li>
            </ul>
            <p class="mb-4">Formatos fecha: DD/MM/YYYY, DD-MM-YY, etc.</p>
            <p class="mb-4">Nota: Combina hora, fecha, das, intervalo. Palabra Alarma/Aviso/sar/Recordar/torio/dame,Timer crean alarmas.</p>
            <h3 class="text-xl font-bold mt-6 mb-2">Recordatorios por Ubicacin</h3>
            <ul class="list-disc pl-6 mb-4">
                <li><strong>Activar:</strong>
                    <ul>
                        <li>Marca la casilla "Ubicacin".</li>
                        <li>O escribe frases como: "EN EL LUGAR", "EN EL SITIO", "EN LA UBICACION", "EN LA LOCALIZACION".</li>
                    </ul>
                </li>
                <li><strong>Ver/Ampliar Mapa (Formulario):</strong>
                    <ul>
                        <li>Pulsa el botn "Ampliar Mapa" que aparece junto al check "Ubicacin".</li>
                        <li>Si la ubicacin est activa y fijada, vers un pequeo mapa de previsualizacin debajo.</li>
                    </ul>
                </li>
                <li><strong>Fijar Punto (Formulario):</strong>
                    <ul>
                        <li>Una vez ampliado el mapa, pulsa en l para fijar la ubicacin deseada.</li>
                        <li>El mapa ampliado mostrar tu ubicacin actual por defecto si concedes permiso y est disponible.</li>
                        <li>Usa el botn <strong style="color:green;">ESTS AQU</strong> (en el mapa ampliado del formulario) para centrar rpidamente en tu posicin actual y <strong>fijar esa posicin como la del recordatorio</strong>. Si pulsas de nuevo vuelves a la anterior.</li>
                    </ul>
                </li>
                <li><strong>Radio de Accin:</strong>
                    <ul>
                        <li>Indica el radio en metros (por defecto ${DEFAULT_LOCATION_RADIUS}m para normales, 350m para "RADAR:") en el campo correspondiente.</li>
                        <li>Puedes escribir "RADIO DE 200 METROS" o "MARGEN DE 500 METROS" en el texto para ajustarlo automticamente.</li>
                    </ul>
                </li>
                <li><strong>Funcionamiento:</strong> El recordatorio solo saltar si, adems de cumplirse la hora/fecha, te encuentras DENTRO del radio de la ubicacin guardada.</li>
                <li><strong>Reducir Mapa (Formulario):</strong> Pulsa el botn "REDUCIR MAPA" (visible en el mapa ampliado del formulario) para volver a la vista pequea de previsualizacin.</li>
                <li><strong>Ubicaciones Guardadas:</strong> Puedes guardar hasta ${MAX_SAVED_LOCATIONS} ubicaciones frecuentes desde el botn "Ubicaciones" en este formulario. Luego, para usarlas, ve a "Ubicaciones", busca la deseada y pulsa "Seleccionar".</li>
                <li><strong>Mapa General de Ubicaciones/Navegacin:</strong>
                    <ul>
                        <li>Accede a l pulsando el icono <img src="RADAR.PNG" alt="Radar Icon" style="width:1em; height:1em; vertical-align:middle; display:inline;"> en la barra superior.</li>
                        <li>Desde aqu puedes gestionar recordatorios con ubicacin (como antes) o planificar y seguir rutas GPS.</li>
                        <li>Al entrar, el mapa est en modo "Planificacin de Ruta". Pulsa en el mapa para aadir puntos.
                            Si quieres aadir un punto buscando por direccin, usa el campo de bsqueda <img src="./IMG_4400.png" alt="Campo bsqueda" style="height:1.2em; display:inline; vertical-align:middle;">.
                            El botn de aadir punto de ruta <img src="./ANADIRPUNTO.PNG" alt="Aadir punto" style="height:1.2em; display:inline; vertical-align:middle;"> estar visible si hay texto en el campo de bsqueda y est antes pegado a l.
                            El botn de ordenar etapas <img src="./MOVER.PNG" alt="Ordenar etapas" style="height:1.2em; display:inline; vertical-align:middle;"> est a la izquierda del de aadir punto de ruta.
                        </li>
                        <li>Consulta la ayuda especfica del "Mapa de Navegacin" (botn AYUDA <img src="./IMG_4326.PNG" alt="Ayuda" style="height:1.2em; display:inline; vertical-align:middle;"> en ese mapa) para ms detalles sobre la planificacin de rutas y navegacin.</li>
                         <li>En la barra de progreso de la navegacin, pulsa el icono de la maniobra para mostrar una vista de minimapa detallada de la prxima interseccin.</li>
                    </ul>
                </li>
            </ul>
            <p class="mb-4">Usa micrfono para voz.</p>
        `;
        const parent = options.parentContainer || document.body;
        parent.appendChild(modal);
        const closeHelpButton = modal.querySelector('#close-help');
        const closeHandler = () => { clearModalAutoCloseTimer(modal, closeHelpButton, 'help-modal'); if (modal.parentNode) modal.parentNode.removeChild(modal); };
        closeHelpButton.addEventListener('click', closeHandler); addModalAutoCloseTimer(modal, closeHelpButton, 'help-modal');
    }
    
    
    
    
    
    
    








    



    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: markReminderAsManaged
    // RESUMEN: Marca un recordatorio como "gestionado" por el usuario para ocultarlo temporalmente.
    // ===================================================================
    function markReminderAsManaged(reminderId, managedState = true) {
         if (typeof reminderId !== 'number') { return; } try { let reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); const index = reminders.findIndex(r => r.id === reminderId); if (index !== -1) { if (reminders[index].managedByUser !== managedState) { reminders[index].managedByUser = managedState; localStorage.setItem('reminders', JSON.stringify(reminders)); markCacheAsDirty(); } } } catch (e) { }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: addSlideButtonListeners
    // RESUMEN: Aade los listeners a los botones de un slide de recordatorio en la ventana unificada.
    // ===================================================================
    function addSlideButtonListeners(slideElement, reminder) {
        const reminderId = reminder.id;
        const cancelButton = slideElement.querySelector('.cancel');
        const adjustTimeButton = slideElement.querySelector('.adjust-time-0001');
        const cancelCyclicButton = slideElement.querySelector('.cancel-cyclic');
        const modifyButton = slideElement.querySelector('.modify');
        const postponeButton = slideElement.querySelector('.postpone');
        const routeRadarVistoButton = slideElement.querySelector('.route-radar-seen');
        const handleInteraction = (actionFn) => {
            markReminderAsManaged(reminderId, true);
            actionFn();
            updateUnifiedWindowUI(processedReminderId);
        };
        let processedReminderId = reminderId;
        if (routeRadarVistoButton) {
            routeRadarVistoButton.addEventListener('click', () => {
                const minutesToSnooze = 5;
                const snoozeEndTime = Date.now() + minutesToSnooze * 60 * 1000;
                snoozedRouteRadars.set(reminderId, snoozeEndTime);
                markReminderAsManaged(reminderId, true);
                showToast(`Radar pospuesto ${minutesToSnooze} minutos`, 'info');
                updateUnifiedWindowUI(reminderId);
            });
        }
        if (cancelButton) {
            cancelButton.addEventListener('click', () => { 
                if (reminder.isFromRuta === true) { 
                    showToast(`Radar en ruta "${reminder.text.replace(/<[^>]*>/g, '')}" marcado como visto para esta alerta.`, 'info');
                    updateUnifiedWindowUI(reminder.id); 
                    markReminderAsManaged(reminder.id, true); 
                } else { 
                    handleInteraction(() => { 
                        let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                        const index = rems.findIndex(r => r.id === processedReminderId); 
                        if (index === -1) {
                            showToast("Error: No se encontr el recordatorio en localStorage para actualizar.", "error");
                            return;
                        }
                        const currentReminder = rems[index];
                        let needsSave = false;
                        const isRadarTypeStored = currentReminder.text.toUpperCase().includes("RADAR:") || currentReminder.excludeFromList;
                        if (isRadarTypeStored) { 
                           const minutesToPostponeRadar = 15;
                           const { newDateISO, newTime } = calculatePostponedDateTime(minutesToPostponeRadar);
                           rems[index].date = newDateISO;
                           rems[index].time = newTime;
                           rems[index].managedByUser = false;
                           needsSave = true;
                           showToast(`Radar guardado pospuesto ${minutesToPostponeRadar} minutos`, 'info');
                        } else if (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval')) {
                           const minutesToPostponeLocation = 15; 
                           const { newDateISO, newTime } = calculatePostponedDateTime(minutesToPostponeLocation);
                           rems[index].date = newDateISO;
                           rems[index].time = newTime;
                           rems[index].managedByUser = false;
                           needsSave = true;
                           showToast(`Recordatorio de ubicacin pospuesto ${minutesToPostponeLocation} minutos`, 'info');
                        } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                            let referenceDateForNext = new Date();
                            try {
                                const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                                const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                                const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                                if (!isNaN(reminderDateTime.getTime())) {
                                    referenceDateForNext = new Date(reminderDateTime.getTime() + 60000); 
                                }
                            } catch(er) {  }
                            const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                            if (nextOcc) {
                                rems[index].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                                rems[index].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                                rems[index].managedByUser = false;
                                needsSave = true;
                                showToast('Recordatorio actualizado al prximo ciclo', 'info');
                            } else {
                                rems.splice(index, 1); needsSave = true;
                                showToast('Error calculando siguiente ciclo. Recordatorio eliminado.', 'error');
                            }
                        } else {
                           rems.splice(index, 1);
                           needsSave = true;
                           showToast('Recordatorio inmediato marcado como visto y eliminado.', 'info');
                        }
                        if (needsSave) localStorage.setItem('reminders', JSON.stringify(rems)); 
                    }); 
                } 
            });
        }
        if (adjustTimeButton) {
            adjustTimeButton.addEventListener('click', () => handleInteraction(() => {
                let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                const index = rems.findIndex(r => r.id === processedReminderId);
                if (index === -1) return;
                const currentReminder = rems[index];
                let needsSave = false;
                if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                     let referenceDateForNext = new Date();
                     try {
                         const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                         const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, 0, 1)); 
                         if (!isNaN(reminderDateTime.getTime())) {
                             referenceDateForNext = new Date(reminderDateTime.getTime() + 60000); 
                         }
                     } catch(e) {  }
                    const reminderForCalc = { ...currentReminder, time: '00:01' };
                    const nextOcc = calculateNextOccurrence(reminderForCalc, referenceDateForNext);
                    if (nextOcc) {
                        rems[index].date= `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                        rems[index].time = '00:01';
                        rems[index].managedByUser = false;
                        needsSave = true;
                        showToast('Recordatorio ajustado a 00:01 y actualizado', 'info');
                    } else {
                        rems.splice(index, 1); needsSave = true;
                        showToast('Error calculando siguiente ciclo (ajuste 00:01). Eliminado.', 'error');
                    }
                } else { 
                    rems.splice(index, 1); needsSave = true;
                    showToast('Recordatorio no cclico eliminado (accin "Ajustar 00:01")', 'info');
                }
                if (needsSave) localStorage.setItem('reminders', JSON.stringify(rems)); 
            }));
        }
        if (cancelCyclicButton) {
            cancelCyclicButton.addEventListener('click', () => handleInteraction(() => {
                if (confirm('Ests seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE?')) {
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const initialLength = rems.length;
                    rems = rems.filter(r => r.id !== processedReminderId);
                    if (rems.length < initialLength) {
                       localStorage.setItem('reminders', JSON.stringify(rems)); 
                       showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                    } else {
                        showToast('Error: No se encontr el ciclo para anular.', 'warning');
                    }
                } else {
                    markReminderAsManaged(processedReminderId, false); 
                }
            }));
        }
        if (modifyButton) {
            modifyButton.addEventListener('click', () => {
                markReminderAsManaged(reminder.id, true);
                let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                let reminderToModify = remindersFromStorage.find(r => r.id === reminder.id);
                if (!reminderToModify && reminder.isFromRuta) {
                   reminderToModify = { ...reminder };
                   reminderToModify.isFromRuta = false;
                }
                const mapIsVisible = document.getElementById('reminders-location-map-modal') && !document.getElementById('reminders-location-map-modal').classList.contains('hidden');
                const mapShouldReopenWhenUnifiedCloses = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                const mapContextBeforeUnified = sessionStorage.getItem('mapContext');
                hideUnifiedReminderWindow();
                if (reminderToModify) {
                    if (mapShouldReopenWhenUnifiedCloses) {
                         sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                         if (mapContextBeforeUnified) {
                           sessionStorage.setItem('mapContext', mapContextBeforeUnified);
                         }
                    }
                    showReminderModal(reminderToModify, { onTopOfMap: mapIsVisible });
                }
                else {
                    showToast("Error: no se pudo encontrar el recordatorio para modificar.", "error");
                    updateUnifiedWindowUI(reminder.id);
                    if (mapShouldReopenWhenUnifiedCloses &&
                        sessionStorage.getItem('boardinggate_map_should_reopen_after_form') !== 'true' &&
                        !document.getElementById('reminders-location-map-modal')
                       ) {
                        if (mapContextBeforeUnified === 'navigation') openNavigationMap();
                         sessionStorage.removeItem('mapContext');
                    }
                }
                sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
            });
        }
        if (postponeButton) {
            postponeButton.addEventListener('click', () => {
                markReminderAsManaged(processedReminderId, true); 
                let reminderToPostpone;
                if (reminder.isFromRuta) {
                    showToast(`Radar en ruta "${reminder.text.replace(/<[^>]*>/g, '')}" marcado como visto (accin Posponer).`, 'info');
                    updateUnifiedWindowUI(reminder.id);
                    return; 
                } else {
                    let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                    reminderToPostpone = remindersFromStorage.find(r => r.id === processedReminderId);
                }
                if (reminderToPostpone) {
                    showPostponeOptionsModal(reminderToPostpone, 'unified');
                }
                else {
                    showToast("Error: no se pudo encontrar el recordatorio para posponer", "error");
                    updateUnifiedWindowUI(processedReminderId); 
                }
            });
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: restoreCacheForMobile
    // RESUMEN: Descarga silenciosamente la cach de Firebase al iniciar en mvil.
    // ===================================================================
    async function restoreCacheForMobile() {
        const { primaryId } = parseUserId(localStorage.getItem('userData_userId'));
        if (!primaryId) return;
        const result = await callFirebase('getUserData', { userId: primaryId });
        if (result.status === 'success' && result.data) {
            const backupCacheData = result.data.contenidoCacheCompleto;
            if (backupCacheData) {
                showToast('Sincronizando datos desde la nube...', 'info', 2000);
                const currentUserIdentity = localStorage.getItem('userData_userId');
                for (const key in backupCacheData) {
                    if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                        localStorage.setItem(key, backupCacheData[key]);
                    }
                }
                if (currentUserIdentity) {
                    localStorage.setItem('userData_userId', currentUserIdentity);
                }
                loadCustomData();
                loadSavedSettings();
                updateUserIdDisplay();
                checkReminders();
            }
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: hideUnifiedReminderWindow
    // RESUMEN: Oculta la ventana unificada de recordatorios y limpia sus elementos.
    // ===================================================================
    function hideUnifiedReminderWindow() {
        const windowElement = document.getElementById('unified-reminder-window');
        if (windowElement && windowElement.classList.contains('visible')) {
            windowElement.classList.remove('visible');
            isUnifiedWindowVisibleByLogic = false;
            const swiperContainer = document.getElementById('reminder-swiper-container');
            Object.values(previewMaps).forEach(map => {
                if (map && typeof map.remove === 'function') {
                    map.remove();
                }
            });
            previewMaps = {};
            if (swiperContainer) {
                swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay);
                setTimeout(() => {
                    if (swiperContainer && !windowElement.classList.contains('visible')) {
                        swiperContainer.innerHTML = '';
                    }
                }, 600);
            }
            const hideAllButton = document.getElementById('hide-all-reminders-button');
            if (hideAllButton) { const newHideAllButton = hideAllButton.cloneNode(true); hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton); }
            const mapShouldReopen = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
            const mapContextToReopen = sessionStorage.getItem('mapContext');
            sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
            if (mapShouldReopen &&
                !document.querySelector('.reminder-modal') &&
                !document.querySelector('.reminder-table-modal') &&
                !document.getElementById('reminders-location-map-modal')
               ) {
                 if (mapContextToReopen === 'navigation') openNavigationMap();
                  sessionStorage.removeItem('mapContext');
            }
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: postponeAllVisibleReminders
    // RESUMEN: Pospone todos los recordatorios actualmente visibles en la ventana unificada.
    // ===================================================================
    function postponeAllVisibleReminders() {
        const swiperContainer = document.getElementById('reminder-swiper-container'); if (!swiperContainer) return;
        const visibleSlides = swiperContainer.querySelectorAll('.reminder-slide'); if (visibleSlides.length === 0) return;
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        let updated = false;
        const idsToUpdate = [];
        visibleSlides.forEach(slide => {
            const reminderId = parseInt(slide.dataset.id);
            if (isNaN(reminderId)) return;
            idsToUpdate.push(reminderId);
            const index = reminders.findIndex(r => r.id === reminderId);
            if (index !== -1) {
                const { newDateISO, newTime } = calculatePostponedDateTime(1);
                reminders[index].date = newDateISO;
                reminders[index].time = newTime;
                reminders[index].managedByUser = false;
                updated = true;
            }
        });
        if (updated) {
            localStorage.setItem('reminders', JSON.stringify(reminders));
            showToast(`${idsToUpdate.length} recordatorio(s) pospuesto(s) 1 minuto`, 'info');
            idsToUpdate.forEach(id => updateUnifiedWindowUI(id));
            updateReminderCount();
            updateButtonStyles();
        }
        if (idsToUpdate.length > 0 && document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
           hideUnifiedReminderWindow();
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateReminderIndexDisplay
    // RESUMEN: Actualiza el contador de ndice del slide actual en la ventana unificada.
    // ===================================================================
    function updateReminderIndexDisplay() {
        const swiperContainer = document.getElementById('reminder-swiper-container');
        const currentIndexSpan = document.getElementById('current-reminder-index');
        if (!swiperContainer || !currentIndexSpan) return;
        const totalSlides = swiperContainer.querySelectorAll('.reminder-slide').length;
        if (totalSlides === 0) {
            currentIndexSpan.textContent = '0';
            return;
        }
        const containerWidth = swiperContainer.offsetWidth;
        if (containerWidth <= 0) {
           return;
        }
        const currentScroll = swiperContainer.scrollLeft;
        const currentIndex = Math.round(currentScroll / containerWidth);
        currentNotificationSlideIndex = currentIndex;
        const displayIndex = Math.max(1, Math.min(currentIndex + 1, totalSlides));
        currentIndexSpan.textContent = displayIndex;
         const currentSlideElement = swiperContainer.querySelectorAll('.reminder-slide')[currentIndex];
         if (currentSlideElement && !isNavigationMapActive) {
            const mapId = currentSlideElement.querySelector('.reminder-map-preview')?.id;
            if (mapId) {
                 const reminderId = parseInt(mapId.replace('map-preview-', ''));
                 if (previewMaps[reminderId]) {
                     setTimeout(() => { if(previewMaps[reminderId]) previewMaps[reminderId].invalidateSize(); }, 50);
                 }
            }
         }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateUnifiedWindowUI
    // RESUMEN: Actualiza la UI de la ventana unificada despus de que un recordatorio es gestionado.
    // ===================================================================
    function updateUnifiedWindowUI(processedReminderId) {
        const windowElement = document.getElementById('unified-reminder-window');
        const swiperContainer = document.getElementById('reminder-swiper-container');
        const slideToRemove = swiperContainer ? swiperContainer.querySelector(`.reminder-slide[data-id="${processedReminderId}"]`) : null;
        if (previewMaps[processedReminderId]) {
           if (typeof previewMaps[processedReminderId].remove === 'function') {
               previewMaps[processedReminderId].remove();
           }
           delete previewMaps[processedReminderId];
        }
        if (slideToRemove && slideToRemove.parentNode === swiperContainer) {
            swiperContainer.removeChild(slideToRemove);
        }
        const remainingSlides = swiperContainer ? swiperContainer.querySelectorAll('.reminder-slide') : [];
        const remainingCount = remainingSlides.length;
        if (remainingCount === 0) {
            hideUnifiedReminderWindow();
        }
        else {
            const countHeader = windowElement.querySelector('.reminder-count-header');
            const countSpan = document.getElementById('total-reminder-count');
            const countTextContainer = document.getElementById('reminder-count-text-container');
            const swipeHint = document.getElementById('reminder-swipe-hint');
            countSpan.textContent = remainingCount;
            updateReminderIndexDisplay();
            if (remainingCount > 1) {
                countTextContainer.style.display = 'inline';
                swipeHint.style.display = 'block';
                document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = 'calc(85vh - 60px)');
            } else {
                countTextContainer.style.display = 'none';
                swipeHint.style.display = 'none';
                document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = '85vh');
            }
            const maxScrollIndex = remainingCount - 1;
            if (currentNotificationSlideIndex > maxScrollIndex) {
                 currentNotificationSlideIndex = maxScrollIndex;
                 swiperContainer.scrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
                 updateReminderIndexDisplay();
            }
        }
        updateReminderCount();
        updateButtonStyles();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: setupReminderTableListeners
    // RESUMEN: Aade los listeners a los botones de la tabla de recordatorios.
    // ===================================================================
    function setupReminderTableListeners(modalTable) {
        modalTable.querySelectorAll('.visto-prox').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#EF4444';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #B91C1C';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true);
                let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderIndex = rems.findIndex(r => r.id === id);
                let needsSave = false;
                const row = newButton.closest('tr');
                if (reminderIndex > -1 && row) {
                     const currentReminder = rems[reminderIndex];
                     if (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval')) {
                        const { newDateISO, newTime } = calculatePostponedDateTime(15);
                        rems[reminderIndex].date = newDateISO;
                        rems[reminderIndex].time = newTime;
                        rems[reminderIndex].managedByUser = false;
                        needsSave = true;
                        const dateCell = row.cells[3]; const timeCell = row.cells[2];
                        if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date);
                        if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                        showToast('Recordatorio con ubicacin pospuesto 15 min', 'info');
                    } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                         let referenceDateForNext = new Date();
                         try {
                             const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                             const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                             const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                             if (!isNaN(reminderDateTime.getTime())) {
                                 referenceDateForNext = new Date(reminderDateTime.getTime() + 60000);
                             }
                         } catch(er) { }
                        const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                        if (nextOcc) {
                            rems[reminderIndex].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                            rems[reminderIndex].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                            rems[reminderIndex].managedByUser = false;
                            needsSave = true;
                            const dateCell = row.cells[3]; const timeCell = row.cells[2];
                            if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date);
                            if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                            showToast('Actualizado al prximo periodo', 'info');
                        } else {
                            rems.splice(reminderIndex, 1); needsSave = true;
                            row.remove(); showToast('Error calculando siguiente ciclo. Eliminado.', 'error');
                        }
                    } else {
                        rems.splice(reminderIndex, 1); needsSave = true;
                        row.remove(); showToast('Recordatorio borrado', 'info');
                    }
                    if (needsSave) localStorage.setItem('reminders', JSON.stringify(rems)); 
                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios.</td></tr>`;
                    }
                } else {
                    showToast('Error: Recordatorio no encontrado para actualizar/borrar.', 'error');
                    if(row) row.remove();
                }
                updateReminderCount(); updateButtonStyles(); checkReminders();
            });
        });
        modalTable.querySelectorAll('.postpone').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#F59E0B';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #B45309';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true);
                const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderToPostpone = reminders.find(r => r.id === id);
                if (reminderToPostpone) {
                    if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                    modalTable.remove();
                    showPostponeOptionsModal(reminderToPostpone, 'table');
                } else {
                    showToast('Error: Recordatorio no encontrado para posponer.', 'error');
                    markReminderAsManaged(id, false);
                }
            });
        });
        modalTable.querySelectorAll('.cancel-cyclic-table').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#8B0000';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #580000';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                if (confirm('Ests seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE?')) {
                    markReminderAsManaged(id, true);
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const initialLength = rems.length;
                    rems = rems.filter(r => r.id !== id);
                    if (rems.length < initialLength) {
                        localStorage.setItem('reminders', JSON.stringify(rems)); 
                        showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                    } else {
                        showToast('Error: No se encontr el ciclo para anular', 'warning');
                    }
                    const row = newButton.closest('tr');
                    if (row) row.remove();
                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios.</td></tr>`;
                    }
                    updateReminderCount(); updateButtonStyles(); checkReminders();
                }
            });
        });
        const tableBody = modalTable.querySelector('#reminder-table-body');
        if (tableBody) {
            const newTableBody = tableBody.cloneNode(false);
            while(tableBody.firstChild) newTableBody.appendChild(tableBody.firstChild);
            tableBody.parentNode.replaceChild(newTableBody, tableBody);
            newTableBody.addEventListener('click', (e) => {
                if (e.target.closest('td:first-child button')) return;
               const row = e.target.closest('tr[data-id]');
                if (row?.dataset.id) {
                    const id = parseInt(row.dataset.id); if (isNaN(id)) return;
                    markReminderAsManaged(id, true);
                    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const reminderToModify = reminders.find(r => r.id === id);
                    if (reminderToModify) {
                        const mapWasOpenBeforeTable = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                        const mapContextBeforeTable = sessionStorage.getItem('mapContext');
                        if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                        modalTable.remove();
                        if (mapWasOpenBeforeTable) {
                            sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                            if (mapContextBeforeTable) {
                                sessionStorage.setItem('mapContext', mapContextBeforeTable);
                            }
                        }
                        sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                        showReminderModal(reminderToModify);
                    } else {
                        showToast('Error: Recordatorio no encontrado para modificar', 'error');
                        markReminderAsManaged(id, false);
                    }
                }
            });
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showAllReminders
    // RESUMEN: Muestra una tabla con todos los recordatorios.
    // ===================================================================
    function showAllReminders(options = {}) {
         const mapWasOpenBeforeThisTable = isNavigationMapActive;
         if (mapWasOpenBeforeThisTable) {
             sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
             sessionStorage.setItem('mapContext', 'navigation');
         } else {
             sessionStorage.removeItem('boardinggate_map_was_open_before_table');
             sessionStorage.removeItem('mapContext');
         }
         closeOtherModals();
         let allReminders = []; try { allReminders = JSON.parse(localStorage.getItem('reminders') || '[]').map(r => ({ ...r })); } catch(e) { showToast("Error al cargar lista de recordatorios.", "error"); return; }
         const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false; let remindersToDisplay = allReminders;
         if (!showExcluded) { remindersToDisplay = allReminders.filter(r => !r.excludeFromList); }
         remindersToDisplay.sort((a, b) => {
             const nowForSort = new Date(); const nextA = calculateNextOccurrence(a, nowForSort); const nextB = calculateNextOccurrence(b, nowForSort);
             if (nextA && nextB) { const timeDiff = nextA.getTime() - nextB.getTime(); if (timeDiff !== 0) return timeDiff; } else if (nextA) { return -1; } else if (nextB) { return 1; }
             const typeOrder = { 'simple': 1, 'hourly': 2, 'daily': 3, 'weekly': 4, 'interval': 5 }; const typeDiff = (typeOrder[a.type] ?? 99) - (typeOrder[b.type] ?? 99); if (typeDiff !== 0) return typeDiff;
             const createdAtA = a.createdAt ? new Date(a.createdAt).getTime() : 0; const createdAtB = b.createdAt ? new Date(b.createdAt).getTime() : 0; return createdAtA - createdAtB;
         });
         const existingModal = document.querySelector('.reminder-table-modal');
         if (existingModal) { if (existingModal.autoCloseInterval) clearInterval(existingModal.autoCloseInterval); if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal); }
         const modalTable = document.createElement('div');
         modalTable.className = 'reminder-table-modal';
         modalTable.setAttribute('aria-label', 'Tabla recordatorios');
         modalTable.innerHTML = `
            <div class="modal-top-buttons" style="justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <div style="display: flex; align-items: center;">
                    <input type="checkbox" id="show-excluded-reminders" ${showExcluded ? 'checked' : ''} style="transform: scale(1.3);">
                    <label for="show-excluded-reminders" style="margin-left: 0.5rem; font-size: 1.1rem;">MOSTRAR RADARES u OTROS</label>
                </div>
                <h2 style="text-align:center; font-size:1.8rem;color:#333; flex-grow:1; font-weight:bold;">Recordatorios</h2>
                <div style="display: flex; align-items: center;">
                    <button type="button" id="view-all-locations-map" style="white-space: nowrap;">VER UBICACIONES</button>
                    <button type="button" id="close-reminders-top" style="margin-left:10px;">SALIR <span class="button-countdown"></span></button>
                </div>
            </div>
            <table>
                <thead>
                    <tr>
                        <th style="width:12%;">Acciones</th> <th>Texto</th> <th style="width:8%;">Hora</th>
                        <th style="width:10%;">Fecha Prox.</th> <th style="width:15%;">Das Rep.</th>
                        <th style="width:8%;">Cada x das</th> <th style="width:8%;">Geoloc.</th>
                        <th style="width:10%;">Creado</th>
                    </tr>
                </thead>
                <tbody id="reminder-table-body">
                    ${remindersToDisplay.length === 0 ? `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios ${showExcluded ? ' (incluyendo excluidos)' : ''}.</td></tr>` : remindersToDisplay.map(r => { const isCyclic = r.type === 'weekly' || r.type === 'interval'; const rowBackgroundColor = isCyclic ? (r.excludeFromList ? '#C0D8C0' : '#D9E5DB') : (r.excludeFromList ? '#D8BFBF' : '#EAD9D9'); const nextOccurrenceDate = calculateNextOccurrence(r, new Date()); const formattedNextDate = nextOccurrenceDate ? formatDateToDDMMMYY(nextOccurrenceDate.toISOString().split('T')[0]) : formatDateToDDMMMYY(r.date); const timeDisplay = r.time ? r.time : '-'; const geoIndicator = r.isLocationEnabled ? '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#008000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>' : '-'; return `<tr data-id="${r.id}" style="background-color: ${rowBackgroundColor};"> <td> <button class="visto-prox" data-id="${r.id}" title="${isCyclic ? 'Marcar Visto y Avanzar al Prximo Ciclo' : 'Marcar Visto y Borrar'}">Visto/Prox</button> <button class="postpone" data-id="${r.id}" title="Posponer">Posponer</button> ${isCyclic ? `<button class="cancel-cyclic-table" data-id="${r.id}" title="Anular Ciclo Permanente">Anular Ciclo</button>` : ''} </td> <td class="text-column" title="Modificar">${r.text}</td> <td class="time-column">${timeDisplay}</td> <td class="date-column">${formattedNextDate}</td> <td>${r.type === 'weekly' && r.repeatDays?.length > 0 ? r.repeatDays.map(d => ['Dom','Lun','Mar','Mi','Jue','Vie','Sb'][d]).join(', ') : '-'}</td> <td>${r.type === 'interval' ? r.intervalDays || '-' : '-'}</td> <td>${geoIndicator}</td> <td class="date-column">${r.createdAt ? formatDateToDDMMMYY(r.createdAt.split('T')[0]) : '-'}</td> </tr>`; }).join('')}
                </tbody>
            </table>
             <div class="bottom-button-container" style="margin-top: 1rem; display:flex; justify-content:flex-end;">
                <button type="button" id="close-reminders-bottom">SALIR <span class="button-countdown"></span></button>
            </div>
        `;
         const parent = options.parentContainer || document.body;
         parent.appendChild(modalTable);
         const showExcludedCheckbox = modalTable.querySelector('#show-excluded-reminders');
         if (showExcludedCheckbox) { 
             showExcludedCheckbox.addEventListener('change', () => { 
                 localStorage.setItem(SHOW_EXCLUDED_REMINDERS_KEY, JSON.stringify(showExcludedCheckbox.checked)); 
                 markCacheAsDirty();
                 if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval); 
                 modalTable.remove(); 
                 showAllReminders(); 
            }); 
        }
         const viewLocationsMapButton = modalTable.querySelector('#view-all-locations-map');
         if (viewLocationsMapButton) {
            viewLocationsMapButton.addEventListener('click', () => {
                if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                if (modalTable.parentNode) modalTable.remove();
                setTimeout(() => {
                    openLocationsPreviewMap();
                }, 50);
            });
        }
         let count = 60; const countdownSpans = modalTable.querySelectorAll('.button-countdown'); countdownSpans.forEach(span => span.textContent = `(${count})`);
         const closeClean = () => { clearInterval(modalTable.autoCloseInterval); modalTable.autoCloseInterval = null; if (modalTable.parentNode) modalTable.parentNode.removeChild(modalTable);
             const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true'; sessionStorage.removeItem('boardinggate_map_was_open_before_table');
             const mapContext = sessionStorage.getItem('mapContext'); sessionStorage.removeItem('mapContext');
             if (fromReminderModal) { fromReminderModal = false; if (mapShouldReopen) { sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true'); sessionStorage.setItem('mapContext', mapContext); } showReminderModal(); }
             else if (mapShouldReopen) { if (mapContext === 'navigation') openNavigationMap(); }
         };
         modalTable.autoCloseInterval = setInterval(() => { count--; countdownSpans.forEach(span => span.textContent = `(${count})`); if (count <= 0) { closeClean(); } }, 1000);
         const resetTimer = () => { if (!modalTable.autoCloseInterval) return; clearInterval(modalTable.autoCloseInterval); count = 60; countdownSpans.forEach(span => span.textContent = `(${count})`); modalTable.autoCloseInterval = setInterval(() => { count--; countdownSpans.forEach(span => span.textContent = `(${count})`); if (count <= 0) { closeClean(); } }, 1000); };
         modalTable.addEventListener('click', resetTimer); modalTable.addEventListener('touchstart', resetTimer, { passive: true }); modalTable.addEventListener('input', resetTimer);
         modalTable.querySelector('#close-reminders-top').addEventListener('click', closeClean);
         modalTable.querySelector('#close-reminders-bottom').addEventListener('click', closeClean);
         setupReminderTableListeners(modalTable);
     }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateReminderCount
    // RESUMEN: Actualiza los contadores de recordatorios en la UI.
    // ===================================================================
    function updateReminderCount() {
         let reminders = []; try { reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); } catch (e) { reminders = []; }
         const showExcludedInTable = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false; let remindersForCount = reminders;
         if (!showExcludedInTable) { remindersForCount = reminders.filter(r => !r.excludeFromList); }
         const totalCount = remindersForCount.length; const nonCyclicReminders = remindersForCount.filter(r => r.type !== 'weekly' && r.type !== 'interval'); const nonCyclicCount = nonCyclicReminders.length;
         const countElGlobe = document.getElementById('reminder-count-globe'); if (countElGlobe) { countElGlobe.textContent = nonCyclicCount > 0 ? nonCyclicCount : ''; countElGlobe.style.display = nonCyclicCount > 0 ? 'flex' : 'none'; }
         const reminderButtonElem = document.getElementById('reminder-button'); if (reminderButtonElem) { let countSpanSide = reminderButtonElem.querySelector('.reminder-count'); if (totalCount > 0) { if (!countSpanSide) { countSpanSide = document.createElement('span'); countSpanSide.className = 'reminder-count'; reminderButtonElem.appendChild(countSpanSide); } countSpanSide.textContent = totalCount; } else { if (countSpanSide) { countSpanSide.remove(); } } }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: calculateNextOccurrence
    // RESUMEN: Calcula la prxima fecha de vencimiento de un recordatorio cclico.
    // ===================================================================
    function calculateNextOccurrence(reminder, referenceDate) {
          if (!reminder || !reminder.type || !reminder.time || !reminder.date) { return null; } try {
              let [year, month, day] = reminder.date.split('-').map(Number); let [hour, minute] = reminder.time.split(':').map(Number);
              let baseDate = new Date(Date.UTC(year, month - 1, day, hour, minute)); if (isNaN(baseDate.getTime())) { return null; }
              const refDateUTC = new Date(referenceDate.getTime()); if (baseDate > refDateUTC) return baseDate;
              if (reminder.type === 'simple') { return null; }
              if (reminder.type === 'daily' || reminder.type === 'hourly') { let next = new Date(baseDate); while (next <= refDateUTC) { next.setUTCDate(next.getUTCDate() + 1); } return next; }
              if (reminder.type === 'weekly' && reminder.repeatDays && reminder.repeatDays.length > 0) {
                  let next = new Date(refDateUTC); next.setUTCHours(hour, minute, 0, 0);
                  if (next <= refDateUTC || !reminder.repeatDays.includes(next.getUTCDay())) { next.setUTCDate(next.getUTCDate() + 1); }
                  for (let i = 0; i < 7; i++) { if (reminder.repeatDays.includes(next.getUTCDay())) { return next; } next.setUTCDate(next.getUTCDate() + 1); } return null;
              }
              if (reminder.type === 'interval' && reminder.intervalDays && reminder.intervalDays > 0) { let next = new Date(baseDate); while (next <= refDateUTC) { next.setUTCDate(next.getUTCDate() + reminder.intervalDays); } return next; }
              return null; } catch (e) { return null; }
     }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: calculatePostponedDateTime
    // RESUMEN: Calcula la fecha y hora para posponer un recordatorio.
    // ===================================================================
    function calculatePostponedDateTime(mins) {
          const now = new Date(); const postponedDate = new Date(now.getTime() + mins * 60000);
          const newDateISO = `${postponedDate.getFullYear()}-${(postponedDate.getMonth() + 1).toString().padStart(2, '0')}-${postponedDate.getDate().toString().padStart(2, '0')}`;
          const newTime = `${postponedDate.getHours().toString().padStart(2, '0')}:${postponedDate.getMinutes().toString().padStart(2, '0')}`; return { newDateISO, newTime };
     }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showPostponeOptionsModal
    // RESUMEN: Muestra un modal con opciones para posponer un recordatorio.
    // ===================================================================
    function showPostponeOptionsModal(reminder, source = 'unified') {
         const existingModal = document.getElementById('postpone-options-modal'); if (existingModal) { if (existingModal.autoPostponeInterval) clearInterval(existingModal.autoPostponeInterval); if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal); }
         const modal = document.createElement('div'); modal.id = 'postpone-options-modal'; modal.className = 'postpone-options';
         modal.style.cssText = `position:fixed; top:10px; left:50%; transform:translateX(-50%); width:90%; max-width:480px; max-height:calc(100vh - 20px); overflow-y:auto; background-color:#F5E1A9; padding:1.5rem; border-radius:1rem; box-shadow:0 10px 25px rgba(0,0,0,0.2); z-index:7500; `;
         modal.setAttribute('aria-label', 'Posponer recordatorio');
         let countdown = 10; const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval'; const defaultMinutes = 15;
         let buttonHtml = ` <button data-minutes="15" class="postpone-option">15 Minutos</button> <button data-minutes="60" class="postpone-option">1 Hora</button> <button data-minutes="180" class="postpone-option">3 Horas</button> `;
         if (!isCyclic) { buttonHtml += ` <button data-minutes="1440" class="postpone-option">1 Da</button> <button data-minutes="4320" class="postpone-option">3 Das</button> `; }
         modal.innerHTML = `
            <style>
                .postpone-options .reminder-text { color:#333; font-size:1.2rem; margin-bottom:.5rem; word-wrap:break-word; }
                .postpone-options .reminder-details { color:#555; font-size:1rem; margin-bottom:1.5rem; }
                .postpone-options .button-group { display:flex; flex-direction:column; gap:1rem; align-items:stretch; }
                .postpone-options button.postpone-option { font-size:1.3rem; font-weight:bold; padding:.8rem 1rem; background-color:#F59E0B; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                .postpone-options button.postpone-option:hover { background-color:#D97706; }
                #postpone-countdown { text-align:center; margin-top:1.8rem; font-size:1.1rem; font-weight:500; color:#444; }
                #postpone-timer-value { font-weight:bold; font-size:1.2rem; }
                #cancel-postpone { margin-top:1.2rem; width:100%; padding:.7rem 1rem; font-size:1.1rem; background-color:#EF4444; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                #cancel-postpone:hover { background-color:#DC2626; }
            </style>
            <div class="modal-top-buttons" style="justify-content: flex-end; margin-bottom: 1rem;">
                 <button id="cancel-postpone" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
            </div>
            <p class="reminder-text">Posponer: ${reminder.text.replace(/<[^>]*>/g, '')}</p>
            <p class="reminder-details">Selecciona tiempo:</p>
            <div class="button-group">
                ${buttonHtml}
            </div>
            <p id="postpone-countdown">Autom&aacute;tico en <span id="postpone-timer-value">${countdown}</span>s (${defaultMinutes} min)</p>
         `;
         document.body.appendChild(modal);
         const countdownDisplay = modal.querySelector('#postpone-timer-value');
         const handlePostpone = (minutes) => {
             if (modal.autoPostponeInterval) clearInterval(modal.autoPostponeInterval); modal.autoPostponeInterval = null;
             updateUnifiedWindowUI(reminder.id);
             let reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); const index = reminders.findIndex(r => r.id === reminder.id);
             if (index === -1) { showToast("Error: Recordatorio no encontrado", "error"); checkReminders(); if (modal.parentNode) document.body.removeChild(modal); return; }
             const { newDateISO, newTime } = calculatePostponedDateTime(minutes); reminders[index].date = newDateISO; reminders[index].time = newTime; reminders[index].managedByUser = false;
             if (!isCyclic) { reminders[index].type = 'daily'; reminders[index].repeatDays = []; reminders[index].intervalDays = null; }
             localStorage.setItem('reminders', JSON.stringify(reminders)); updateReminderCount(); updateButtonStyles(); 
             const durationText = minutes >= 1440 ? `${minutes / 1440} da(s)` : (minutes >= 60 ? `${minutes / 60} hora(s)` : `${minutes} minutos`);
             showToast(`Pospuesto ${durationText}`, 'info');
             if (modal.parentNode) document.body.removeChild(modal);
             if (source === 'table') { setTimeout(showAllReminders, 100); }
             else { const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                 const mapContextToReopen = sessionStorage.getItem('mapContext');
                 if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) { sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); if (!document.getElementById('reminders-location-map-modal')) { if (mapContextToReopen === 'navigation') openNavigationMap(); sessionStorage.removeItem('mapContext');} } } };
         modal.autoPostponeInterval = setInterval(() => { countdown--; if (countdownDisplay) countdownDisplay.textContent = countdown; if (countdown <= 0) { handlePostpone(defaultMinutes); } }, 1000);
         modal.querySelectorAll('.postpone-option').forEach(button => { button.addEventListener('click', () => { const minutes = parseInt(button.dataset.minutes); if (!isNaN(minutes)) { handlePostpone(minutes); } }); });
         modal.querySelector('#cancel-postpone').addEventListener('click', () => {
             clearInterval(modal.autoPostponeInterval); modal.autoPostponeInterval = null; markReminderAsManaged(reminder.id, false); if (modal.parentNode) document.body.removeChild(modal);
             if (source === 'table') { setTimeout(showAllReminders, 100); }
             else { const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                  const mapContextToReopen = sessionStorage.getItem('mapContext');
                 if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) { sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); if (!document.getElementById('reminders-location-map-modal')) { if (mapContextToReopen === 'navigation') openNavigationMap(); sessionStorage.removeItem('mapContext');} } } showToast('Posposicin cancelada', 'info'); });
     }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showYellowBorder
    // RESUMEN: Muestra un borde amarillo intermitente en toda la pantalla como alerta visual.
    // ===================================================================
    function showYellowBorder() {
        const borderDiv = document.createElement('div'); borderDiv.style.position = 'fixed'; borderDiv.style.top = '0'; borderDiv.style.left = '0'; borderDiv.style.width = '100vw'; borderDiv.style.height = '100vh'; borderDiv.style.boxSizing = 'border-box'; borderDiv.style.border = '25px solid #FFFF00'; borderDiv.style.zIndex = '99999'; borderDiv.style.pointerEvents = 'none'; borderDiv.style.opacity = '1'; borderDiv.style.transition = 'opacity 0.5s ease-out'; document.body.appendChild(borderDiv);
        setTimeout(() => { borderDiv.style.opacity = '0'; setTimeout(() => { if (borderDiv.parentNode) { borderDiv.parentNode.removeChild(borderDiv); } }, 500); }, 3500);
    }
    
    
    
    

// ===================================================================
// NOMBRE: formatTimeWithPeriod
// RESUMEN: Formatea una hora (HH:MM) para aadir un perodo del da (Maana, Tarde, etc.).
// ===================================================================
function formatTimeWithPeriod(timeString) {
     if (!timeString || !timeString.match(/^\d{2}:\d{2}$/)) return '-';
     try {
         const [hourStr, minuteStr] = timeString.split(':');
         const hour = parseInt(hourStr);
         const minute = parseInt(minuteStr);
         if (isNaN(hour) || isNaN(minute) || hour < 0 || hour > 23 || minute < 0 || minute > 59) {
             return timeString;
         }
         let period = '';
         if (hour >= 22 || hour < 5) { period = 'de la Noche'; }
         else if (hour >= 5 && hour < 12) { period = 'de la Maana'; }
         else if (hour >= 12 && hour < 14) { period = 'del Medioda'; }
         else { period = 'de la Tarde'; }
         return `${hourStr}:${minuteStr} (${period})`;
     } catch (e) {
         return timeString;
     }
}











// ===================================================================
// NOMBRE: formatDateDetailed
// RESUMEN: Formatea una fecha (YYYY-MM-DD) a un formato ms legible (DD-Mes-YYYY).
// ===================================================================
function formatDateDetailed(dateString) {
    if (!dateString || !dateString.match(/^\d{4}-\d{2}-\d{2}$/)) return '-';
    try {
        const [year, month, day] = dateString.split('-').map(Number);
        const date = new Date(Date.UTC(year, month - 1, day));
        if (isNaN(date.getTime())) return dateString;
        const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
        const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
        const monthName = monthNames[date.getUTCMonth()];
        const fullYear = date.getUTCFullYear();
        return `${dayOfMonth}-${monthName}-${fullYear}`;
    } catch (e) {
        return dateString;
    }
}

    
    
    
    
    
    
    
// ===================================================================
// NOMBRE: displayUnifiedReminderWindow
// RESUMEN: Muestra y rellena la ventana unificada de recordatorios con los que estn vencidos.
// ===================================================================
function displayUnifiedReminderWindow(overdueReminders) {
    const windowElement = document.getElementById('unified-reminder-window');
    const swiperContainer = document.getElementById('reminder-swiper-container');
    const countHeader = windowElement.querySelector('.reminder-count-header');
    const countSpan = document.getElementById('total-reminder-count');
    const currentIndexSpan = document.getElementById('current-reminder-index');
    const countTextContainer = document.getElementById('reminder-count-text-container');
    const swipeHint = document.getElementById('reminder-swipe-hint');
    const hideAllButton = document.getElementById('hide-all-reminders-button');
     Object.values(previewMaps).forEach(map => {
       if (map && typeof map.remove === 'function') {
           map.remove();
       }
     });
     previewMaps = {};
    if (!windowElement || !swiperContainer || !countHeader || !countSpan || !currentIndexSpan || !countTextContainer || !swipeHint || !hideAllButton) {
        return;
    }
    swiperContainer.innerHTML = '';
    overdueReminders.sort((a, b) => { try { const dateA = new Date(`${a.date}T${a.time}:00Z`); const dateB = new Date(`${b.date}T${b.time}:00Z`); return dateA - dateB; } catch (e) { return 0; } });
    if (!isUnifiedWindowVisibleByLogic) {
        currentNotificationSlideIndex = 0;
    }
    overdueReminders.forEach((reminder, index) => {
        const slide = document.createElement('div');
        slide.className = 'reminder-slide';
        slide.dataset.id = reminder.id;
        slide.setAttribute('role', 'group');
        slide.setAttribute('aria-label', `Recordatorio: ${reminder.text.replace(/<[^>]*>/g, '')}`);
        
        let slideContentHtml = '';
        const isRadarAlert = reminder.text.toUpperCase().includes("RADAR");

        if (isRadarAlert) {
            slideContentHtml = `
                <div class="reminder-slide-content">
                    <img src="https://boardinggate.github.io/Tesla/AGUARDIA.png" alt="Icono Radar" class="radar-icon">
                    <div class="reminder-content-scrollable">
                        <p class="reminder-text" style="text-align: center;">${reminder.text}</p>
                    </div>
                    <div class="button-group">
                        <button class="route-radar-seen" style="background-color: #2563EB; color: white; font-weight: bold; height: 70px; font-size: 1.2rem;">VISTO (Posponer 5 min)</button>
                        <button class="modify">Modificar</button>
                    </div>
                </div>
            `;
        } else {
            let detailsHtml = '';
            if (reminder.time) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Hora: ${formatTimeWithPeriod(reminder.time)}</p>`;
            if (reminder.date) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Fecha: ${formatDateDetailed(reminder.date)}</p>`;
            if (reminder.type === 'weekly' && reminder.repeatDays?.length > 0) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Repite: ${reminder.repeatDays.map(d => ['Dom', 'Lun', 'Mar', 'Mi', 'Jue', 'Vie', 'Sb'][d]).join(', ')}</p>`;
            if (reminder.type === 'interval' && reminder.intervalDays) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Cada: ${reminder.intervalDays} das</p>`;
            if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Ubicacin: Activada (Radio ${reminder.radiusMeters || DEFAULT_LOCATION_RADIUS}m)</p>`;
            }
            const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval';
            const showAdjustButton = isCyclic && reminder.time !== '00:01';
            const adjustButtonHtml = showAdjustButton ? `<button class="adjust-time-0001">Ajustar Hora 00:01 y Visto</button>` : '';
            const cyclicCancelButtonHtml = isCyclic ? `<button class="cancel-cyclic">Anular Ciclo</button>` : '';
            
            const buttonsHtml = `
                <div class="button-group">
                    <button class="cancel">Visto / Prximo</button>
                    <button class="postpone">Posponer</button>
                    <button class="modify">Modificar</button>
                    ${adjustButtonHtml}
                    ${cyclicCancelButtonHtml}
                </div>`;

            const mapPreviewHtml = (reminder.isLocationEnabled && reminder.locationCoordinates && !isNavigationMapActive) ? `
                <div class="reminder-map-preview-container">
                    <div id="map-preview-${reminder.id}" class="reminder-map-preview"></div>
                </div>
            ` : '';

            slideContentHtml = `
                <div class="reminder-slide-content">
                    <div class="reminder-content-scrollable">
                        <p class="reminder-text">${reminder.text}</p>
                        ${detailsHtml}
                    </div>
                    ${buttonsHtml} 
                </div>
                ${mapPreviewHtml}
            `;
        }
        
        slide.innerHTML = slideContentHtml;
        // --- FIN DE LA MODIFICACIN ---

        addSlideButtonListeners(slide, reminder);
        swiperContainer.appendChild(slide);

        if (reminder.isLocationEnabled && reminder.locationCoordinates && !isNavigationMapActive && !isRadarAlert) {
             const mapPreviewElement = slide.querySelector(`#map-preview-${reminder.id}`);
             if (mapPreviewElement) {
                setTimeout(() => {
                    try {
                        if (!document.getElementById(mapPreviewElement.id)) return;
                        if (previewMaps[reminder.id] && typeof previewMaps[reminder.id].remove === 'function') {
                           previewMaps[reminder.id].remove();
                        }
                        const isRadarType = reminder.text.toUpperCase().includes("RADAR:") || reminder.excludeFromList;
                        const circleColor = isRadarType ? 'rgba(255, 165, 0, 0.2)' : 'blue';
                        const circleFillColor = isRadarType ? 'rgba(255, 165, 0, 0.2)' : '#ADD8E6';
                        const circleFillOpacity = isRadarType ? 0.2 : 0.05;
                        const circleWeight = 1;
                        const map = L.map(mapPreviewElement, {
                            dragging: false, touchZoom: false, scrollWheelZoom: false, doubleClickZoom: false,
                            boxZoom: false, keyboard: false, tap: false, zoomControl: false
                        }).setView([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude], 14);
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        }).addTo(map);
                        L.marker([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude]).addTo(map);
                        L.circle([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude], {
                            color: circleColor, fillColor: circleFillColor, weight: circleWeight, fillOpacity: circleFillOpacity, radius: reminder.radiusMeters || DEFAULT_LOCATION_RADIUS
                        }).addTo(map);
                        map.invalidateSize();
                        previewMaps[reminder.id] = map;
                    } catch (mapError) {
                         if (mapPreviewElement) mapPreviewElement.innerHTML = `<p style="font-size:0.8rem; color: red; text-align: center; padding: 5px;">Error al cargar mapa</p>`;
                    }
                }, 100);
             }
        }
    });
    const count = overdueReminders.length;
    countSpan.textContent = count;
    if (count > 0) {
         if (currentNotificationSlideIndex >= count) {
             currentNotificationSlideIndex = 0;
         }
         swiperContainer.scrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
         updateReminderIndexDisplay();
         countHeader.classList.remove('hidden');
         if (count > 1) {
            countTextContainer.style.display = 'inline';
            swipeHint.style.display = 'block';
            document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = 'calc(85vh - 60px)');
         } else {
            countTextContainer.style.display = 'none';
            swipeHint.style.display = 'none';
            document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = '85vh');
         }
          hideAllButton.classList.remove('hidden');
          const newHideAllButton = hideAllButton.cloneNode(true);
          hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton);
          newHideAllButton.addEventListener('click', postponeAllVisibleReminders);
    } else {
        countHeader.classList.add('hidden');
        hideAllButton.classList.add('hidden');
        currentNotificationSlideIndex = 0;
    }
    windowElement.classList.add('visible');
    isUnifiedWindowVisibleByLogic = true;
    swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay);
    swiperContainer.addEventListener('scroll', updateReminderIndexDisplay);
}    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getSavedLocations
    // RESUMEN: Obtiene las ubicaciones guardadas desde localStorage.
    // ===================================================================
    function getSavedLocations() { try { const locations = localStorage.getItem(SAVED_LOCATIONS_KEY); return locations ? JSON.parse(locations) : Array(MAX_SAVED_LOCATIONS).fill(null); } catch (e) { return Array(MAX_SAVED_LOCATIONS).fill(null); } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: saveLocationsToCache
    // RESUMEN: Guarda el array de ubicaciones en localStorage.
    // ===================================================================
    function saveLocationsToCache(locationsArray) { try { localStorage.setItem(SAVED_LOCATIONS_KEY, JSON.stringify(locationsArray));} catch (e) { showToast("Error al guardar ubicaciones.", "error"); } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showSavedLocationsModal
    // RESUMEN: Muestra el modal para gestionar las ubicaciones guardadas.
    // ===================================================================
    function showSavedLocationsModal(callbackOnClose, callbackOnSelectLocation, options = {}) {
        const existingModal = document.querySelector('.saved-locations-modal');
        if (existingModal) { if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; } clearModalAutoCloseTimer(existingModal, existingModal.querySelector('#close-saved-locations-modal'), 'saved-locations-modal'); existingModal.remove(); }
        tempSavedLocations = getSavedLocations().map(loc => loc ? {...loc} : null);
        const modal = document.createElement('div'); modal.className = 'saved-locations-modal';
        modal.innerHTML = `
            <h2>Gestionar Ubicaciones Guardadas (Mx. ${MAX_SAVED_LOCATIONS})</h2>
            <div class="modal-top-buttons">
                <button id="save-all-user-locations">Guardar Cambios</button>
                <button id="close-saved-locations-modal">Cerrar</button>
            </div>
            <div id="saved-locations-list"> </div>
            <div id="location-picker-map-container">
                <button id="picker-ok-map-button" title="Confirmar esta posicin">OK</button>
                <button id="picker-locate-me-button" title="Ir a mi posicin actual">Mi Ubic.</button>
            </div>
        `;
        const parent = options.parentContainer || document.body;
        parent.appendChild(modal);
        const listElement = modal.querySelector('#saved-locations-list'); const mapPickerContainer = modal.querySelector('#location-picker-map-container');
        const okMapBtn = modal.querySelector('#picker-ok-map-button'); const locateMeMapBtn = modal.querySelector('#picker-locate-me-button');
        const saveAllButton = modal.querySelector('#save-all-user-locations'); const closeButton = modal.querySelector('#close-saved-locations-modal');
        function loadAndDisplaySlots() {
            listElement.innerHTML = '';
            for (let i = 0; i < MAX_SAVED_LOCATIONS; i++) {
                const location = tempSavedLocations[i]; const slotDiv = document.createElement('div'); slotDiv.className = 'location-slot';
                slotDiv.innerHTML = ` <span style="width: 25px; text-align: right; font-weight: bold;">${i + 1}.</span> <input type="text" placeholder="Nombre Ubicacin" value="${location?.name || ''}" data-index="${i}"> <button class="map-button" data-index="${i}" title="Fijar en Mapa"> Mapa</button> <button class="select-location-button" data-index="${i}" title="Seleccionar esta ubicacin para el recordatorio actual">Seleccionar</button> <span class="coords-display">${location?.lat && location?.lng ? `${parseFloat(location.lat).toFixed(4)}, ${parseFloat(location.lng).toFixed(4)}` : 'No fijada'}</span> `;
                listElement.appendChild(slotDiv);
                slotDiv.querySelector('input[type="text"]').addEventListener('input', (e) => { if (!tempSavedLocations[i]) tempSavedLocations[i] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS }; tempSavedLocations[i].name = e.target.value; });
                slotDiv.querySelector('.map-button').addEventListener('click', () => {
                    currentEditingLocationSlotIndex = i; mapPickerContainer.classList.add('expanded'); initializeLocationPickerMap('location-picker-map-container', i);
                    const currentSlotLocation = tempSavedLocations[i]; const initialCoords = currentSlotLocation?.lat && currentSlotLocation?.lng ? { latitude: currentSlotLocation.lat, longitude: currentSlotLocation.lng } : null;
                    if (locationPickerMap && initialCoords) { locationPickerMap.setView([initialCoords.latitude, initialCoords.longitude], 15); if (locationPickerMarker) locationPickerMarker.setLatLng([initialCoords.latitude, initialCoords.longitude]); }
                    else if (locationPickerMap) { getCurrentLocation( (coords) => { locationPickerMap.setView([coords.latitude, coords.longitude], 15); if(locationPickerMarker) locationPickerMarker.setLatLng([coords.latitude, coords.longitude]); else { locationPickerMarker = L.marker([coords.latitude, coords.longitude], {draggable: true}).addTo(locationPickerMap); locationPickerMarker.on('dragend', (event) => { const pos = event.target.getLatLng(); if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS }; tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat; tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng; }); } }, () => { } ); } });
                const selectButton = slotDiv.querySelector('.select-location-button');
                selectButton.addEventListener('click', () => { const selectedIndex = parseInt(selectButton.dataset.index); const selectedLocData = tempSavedLocations[selectedIndex];
                    if (selectedLocData && selectedLocData.lat && selectedLocData.lng) {
                        if (callbackOnSelectLocation && typeof callbackOnSelectLocation === 'function') { callbackOnSelectLocation({ name: selectedLocData.name, lat: selectedLocData.lat, lng: selectedLocData.lng, radius: selectedLocData.radius || DEFAULT_LOCATION_RADIUS }); }
                        if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; } clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal'); modal.remove();
                    } else { showToast("Ubicacin no fijada. Fjala en el mapa primero", "warning"); } }); } }
        loadAndDisplaySlots();
        okMapBtn.addEventListener('click', () => { if (locationPickerMarker && currentEditingLocationSlotIndex !== -1) { const pos = locationPickerMarker.getLatLng(); if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS }; tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat; tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng;
                const slotInput = listElement.querySelector(`.location-slot input[dataindex="${currentEditingLocationSlotIndex}"]`); if (slotInput) { const coordsDisplay = slotInput.closest('.location-slot').querySelector('.coords-display'); if (coordsDisplay) { coordsDisplay.textContent = `${pos.lat.toFixed(4)}, ${pos.lng.toFixed(4)}`; } } }
            mapPickerContainer.classList.remove('expanded'); if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; } currentEditingLocationSlotIndex = -1; });
        locateMeMapBtn.addEventListener('click', () => { if (locationPickerMap) { locateMeMapBtn.disabled = true; locateMeMapBtn.textContent = 'Buscando...';
                getCurrentLocation( (coords) => { locationPickerMap.setView([coords.latitude, coords.longitude], 16); if (locationPickerMarker) locationPickerMarker.setLatLng([coords.latitude, coords.longitude]); if (currentEditingLocationSlotIndex !== -1) { if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS }; tempSavedLocations[currentEditingLocationSlotIndex].lat = coords.latitude; tempSavedLocations[currentEditingLocationSlotIndex].lng = coords.longitude; } locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.'; }, (errorMsg) => { showToast(`Error localizacin: ${errorMsg}`, 'error'); locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.'; } ); } });
        saveAllButton.addEventListener('click', () => {
            const locationsToSave = tempSavedLocations.map(loc => { if (loc && (!loc.name || loc.name.trim() === '') && (loc.lat === null || loc.lng === null)) { return null; } if (loc && (loc.lat !== null && loc.lng !== null) && typeof loc.radius !== 'number') { loc.radius = DEFAULT_LOCATION_RADIUS; } return loc; });
            saveLocationsToCache(locationsToSave);
            let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
            savedRoutes = savedRoutes.filter(r => !r.name.startsWith("UBICACIN: "));
            locationsToSave.forEach(loc => {
                if (loc && loc.name && loc.lat && loc.lng) {
                    const routeName = `UBICACIN: ${loc.name.toUpperCase()}`;
                    const routeWaypoint = {
                        id: Date.now() + Math.random(),
                        lat: loc.lat,
                        lng: loc.lng,
                        type: 'F',
                        label: 'F',
                        address: loc.name,
                        visited: false,
                        isCriticalForRecalc: true
                    };
                    const existingRouteIndex = savedRoutes.findIndex(r => r.name === routeName);
                    const routeToSave = {
                        name: routeName,
                        waypoints: [routeWaypoint],
                        createdAt: new Date().toISOString()
                    };
                    if (existingRouteIndex !== -1) {
                        savedRoutes[existingRouteIndex] = routeToSave;
                    } else {
                        savedRoutes.push(routeToSave);
                    }
                }
            });
            if (savedRoutes.length > MAX_SAVED_ROUTES) {
                 savedRoutes.sort((a,b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
                 savedRoutes = savedRoutes.slice(0, MAX_SAVED_ROUTES);
            }
            localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes)); 
            showToast("Ubicaciones guardadas y sincronizadas como s.", "success");
            if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose();
            if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; } clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal'); modal.remove(); });
        const closeHandler = () => { clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal'); if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; } if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose(); modal.remove(); };
        closeButton.addEventListener('click', closeHandler); addModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleEnlargedGraph
    // RESUMEN: Ampla o reduce la grfica de navegacin.
    // ===================================================================
    function toggleEnlargedGraph() {
        const graphCard = document.getElementById('navigation-graph-card');
        const enlargeButton = document.getElementById('enlarge-graph-button');
        const compassControlContainer = document.querySelector('.leaflet-control-orientation-altitude');
        const mapModal = document.getElementById('reminders-location-map-modal');
        if (!graphCard || !enlargeButton || !compassControlContainer || !mapModal) return;
        const isCurrentlyEnlarged = graphCard.classList.contains('enlarged');
        if (!isCurrentlyEnlarged) {
            graphCard.classList.add('enlarged');
            const compassRect = compassControlContainer.getBoundingClientRect();
            const fixedWidth = 995; 
            const fixedHeight = 600; 
            const newLeft = compassRect.left;
            const distanceFromBottom = window.innerHeight - compassRect.bottom;
            const newBottom = distanceFromBottom;
            graphCard.style.left = `${newLeft}px`;
            graphCard.style.bottom = `${newBottom}px`;
            graphCard.style.width = `${fixedWidth}px`;
            graphCard.style.height = `${fixedHeight}px`;
            enlargeButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    <line x1="8" y1="11" x2="14" y2="11"></line>
                </svg>
            `;
            enlargeButton.title = 'Reducir grfica';
        } else {
            graphCard.classList.remove('enlarged');
            graphCard.style.left = '';
            graphCard.style.bottom = '';
            graphCard.style.width = '';
            graphCard.style.height = '';
            graphCard.style.top = '';
            graphCard.style.right = '';
            graphCard.style.transform = '';
            enlargeButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    <line x1="11" y1="8" x2="11" y2="14"></line>
                    <line x1="8" y1="11" x2="14" y2="11"></line>
                </svg>
            `;
            enlargeButton.title = 'Ampliar grfica';
        }
        if (navigationChart) {
            updateChartData(); 
            setTimeout(() => {
                navigationChart.resize();
            }, 200);
        }
        updateNavigationGraphVisibilityAndMode();
    }
    
    
    
    






// ===================================================================
// NOMBRE: updateNavigationGraphVisibilityAndMode
// RESUMEN: Actualiza la visibilidad y modo de la grfica de navegacin.
// ===================================================================
function updateNavigationGraphVisibilityAndMode() {
    const graphCard = document.getElementById('navigation-graph-card');
    const graphContainer = document.getElementById('navigation-graph-container');
    const graphTitleElement = document.getElementById('navigation-graph-title');
    const compassControl = document.querySelector('.leaflet-control-orientation-altitude');
    if (!graphCard || !graphContainer || !graphTitleElement) {
        return;
    }
    if (compassControl && compassControl._updateGraphTitle) {
        compassControl._updateGraphTitle();
    }
    const isEnlarged = graphCard.classList.contains('enlarged');
    if (navigationCurrentRouteData && currentGraphMode !== 'Grfica off') {
        graphCard.classList.remove('hidden');
        if (!isEnlarged) {
            const compassHeight = compassControl ? compassControl.offsetHeight : 0;
            graphCard.style.height = compassHeight > 0 ? `${compassHeight}px` : '157px';
        }
        if (navigationChart) {
            updateChartData(); 
        } else if (isNavigating) {
            ; 
        }
    } else {
        graphCard.classList.add('hidden');
    }
}





    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: initializeLocationPickerMap
    // RESUMEN: Inicializa el mapa selector de ubicaciones en el modal correspondiente.
    // ===================================================================
    function initializeLocationPickerMap(mapContainerId, slotIndex) {
        if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
        const mapDiv = document.createElement('div'); mapDiv.style.width = '100%'; mapDiv.style.height = '100%';
        const container = document.getElementById(mapContainerId); while (container.firstChild && container.firstChild.id !== 'picker-ok-map-button' && container.firstChild.id !== 'picker-locate-me-button') { container.removeChild(container.firstChild); } container.insertBefore(mapDiv, container.firstChild);
        const initialLocation = tempSavedLocations[slotIndex] || {}; const centerLat = initialLocation.lat || 40.416775; const centerLng = initialLocation.lng || -3.703790; const initialZoom = (initialLocation.lat && initialLocation.lng) ? 15 : 6;
        locationPickerMap = L.map(mapDiv, { zoomControl: false }).setView([centerLat, centerLng], initialZoom);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: ' OpenStreetMap contributors' }).addTo(locationPickerMap);
        locationPickerMarker = L.marker([centerLat, centerLng], { draggable: true }).addTo(locationPickerMap);
        locationPickerMarker.on('dragend', (event) => { const pos = event.target.getLatLng(); if (!tempSavedLocations[slotIndex]) tempSavedLocations[slotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS }; tempSavedLocations[slotIndex].lat = pos.lat; tempSavedLocations[slotIndex].lng = pos.lng; });
        locationPickerMap.on('click', (e) => handlePickerMapClick(e, slotIndex));
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                if (locationPickerMap) {
                     try { locationPickerMap.invalidateSize(); } catch(e){}
                }
            });
        });
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handlePickerMapClick
    // RESUMEN: Maneja el clic en el mapa selector de ubicaciones para fijar coordenadas.
    // ===================================================================
    function handlePickerMapClick(e, slotIndex) {
        const latlng = e.latlng; if (locationPickerMarker) { locationPickerMarker.setLatLng(latlng); }
        if (!tempSavedLocations[slotIndex]) tempSavedLocations[slotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
        tempSavedLocations[slotIndex].lat = latlng.lat; tempSavedLocations[slotIndex].lng = latlng.lng;
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleMapHeaderRowsVisibility
    // RESUMEN: Muestra u oculta las filas de botones en la cabecera del mapa.
    // ===================================================================
    function toggleMapHeaderRowsVisibility(show) {
        const header = document.getElementById('reminders-location-map-header');
        if (!header) return;
        mapHeaderButtonsVisible = show;
        header.querySelectorAll('.button-row').forEach(row => {
            row.classList.toggle('hidden-map-header', !show);
        });
        if (navigationMapInstance) {
            setTimeout(() => {
                if (navigationMapInstance) {
                    try {
                        navigationMapInstance.invalidateSize();
                    } catch(e) {
                        console.error("Error al invalidar el tamao del mapa:", e);
                    }
                }
            }, 350);
        }
    }
    
    
    
    
    
    
    
    
    
    
    
    
    













    
// ===================================================================
// NOMBRE: showToast
// RESUMEN: Muestra una notificacin temporal (toast) en la pantalla.
// ===================================================================
function showToast(message, type = 'info', duration = 3000, isErrorNotFound = false, toastId = null) {
    const uniqueToastId = toastId || 'toast-notification-element' + (type === 'debug' ? '-debug' : '') + `-${Date.now()}`;
    let currentTopOffset = 180;
    const toastSpacing = 10;
    activeToasts.forEach(activeToast => {
        const toastElement = document.getElementById(activeToast.id);
        if (toastElement) {
             currentTopOffset += toastElement.offsetHeight + toastSpacing;
        }
    });
    const existingToast = document.getElementById(uniqueToastId);
    if (existingToast && !toastId) {
        existingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
    } else if (existingToast && toastId) {
         existingToast.remove();
         activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
         currentTopOffset = 180;
         activeToasts.forEach(activeToast => {
            const toastElement = document.getElementById(activeToast.id);
            if (toastElement) {
                currentTopOffset += toastElement.offsetHeight + toastSpacing;
            }
         });
    }
    const toast = document.createElement('div');
    toast.id = uniqueToastId;
    toast.className = `toast-notification toast-${type}`;
    if (isErrorNotFound && type === 'error') {
        toast.classList.add('not-found');
    }
    const messageSpan = document.createElement('span');
    messageSpan.innerHTML = message.replace(/\n/g, '<br>');
    toast.appendChild(messageSpan);
    if (type === 'debug') {
        toast.style.top = 'auto';
        toast.style.bottom = '20px';
        toast.style.right = '20px';
        toast.style.left = 'auto';
        toast.style.transform = 'none';
        toast.style.maxWidth = 'calc(100% - 40px)';
        const closeButtonToast = document.createElement('button');
        closeButtonToast.textContent = 'Cerrar Info Debug';
        closeButtonToast.style.cssText = "display: block; margin-top: 10px; padding: 5px 10px; background-color: rgba(255,255,255,0.2); color: white; border: 1px solid white; border-radius: 3px; cursor: pointer;";
        closeButtonToast.onclick = () => {
            if (toast.parentNode) toast.parentNode.removeChild(toast);
             activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
        };
        toast.appendChild(closeButtonToast);
    }
    toast.style.top = `${currentTopOffset}px`;
    document.body.appendChild(toast);
    activeToasts.push({ id: uniqueToastId, element: toast });
    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            toast.classList.add('show');
        });
    });
    if (duration > 0 && type !== 'debug') {
        setTimeout(() => {
            if (toast.classList.contains('show')) {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => {
                     if (toast.parentNode) { toast.parentNode.removeChild(toast); }
                     activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
                }, { once: true });
            } else {
                 if (toast.parentNode) { toast.parentNode.removeChild(toast); }
                 activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
            }
        }, duration);
    }
}







    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleMapImmersiveMode
    // RESUMEN: Activa o desactiva el modo inmersivo del mapa para ocultar los controles.
    // ===================================================================
    function toggleMapImmersiveMode() {
        isMapImmersiveModeActive = !isMapImmersiveModeActive;
        const mapModal = document.getElementById('reminders-location-map-modal');
        if (mapModal) {
            mapModal.classList.toggle('immersive-mode-active', isMapImmersiveModeActive);
            showToast(isMapImmersiveModeActive ? 'Modo Inmersivo Activado' : 'Modo Inmersivo Desactivado', 'info');
            if (navigationMapInstance) {
                setTimeout(() => {
                    try {
                        navigationMapInstance.invalidateSize();
                    } catch(e) { console.error("Error al invalidar tamao de mapa en modo inmersivo:", e); }
                }, 350);
            }
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateNavigationButtonColor
    // RESUMEN: Actualiza el color del botn de inicio de navegacin segn el estado.
    // ===================================================================
    function updateNavigationButtonColor() {
        const startNavButton = document.getElementById('start-navigation-button');
        if (startNavButton) {
            if (isNavigating) {
                startNavButton.style.setProperty('background-color', '#000000', 'important');
            } else {
                startNavButton.style.backgroundColor = 'white';
                startNavButton.style.boxShadow = '2px 3px 5px rgba(0,0,0,0.60)';
            }
        }
    }
    
    
    



    
    
// ===================================================================
// NOMBRE: initDirectionWarningCards (MODIFICADA CON ICONOS)
// RESUMEN: Inicializa y aade al DOM las tarjetas de advertencia de direccin, incluyendo iconos.
// ===================================================================
function initDirectionWarningCards() {
    const mapContainer = document.getElementById('leaflet-map-actual-container');
    if (!mapContainer) return;

    // --- Tarjeta de la DERECHA ---
    if (!directionCardDerecha) {
        directionCardDerecha = document.createElement('div');
        directionCardDerecha.id = 'direction-card-derecha';
        directionCardDerecha.className = 'direction-warning-card';
        directionCardDerecha.innerHTML = `
            <span style="vertical-align: middle;"> DERECHA</span>
            <img src="https://boardinggate.github.io/Tesla/turn-right.png" alt="Giro derecha" class="direction-card-icon">
        `;
        directionCardDerecha.style.left = '170px';
        directionCardDerecha.style.bottom = '200px';
        mapContainer.appendChild(directionCardDerecha);
    }

    // --- Tarjeta de la IZQUIERDA ---
    if (!directionCardIzquierda) {
        directionCardIzquierda = document.createElement('div');
        directionCardIzquierda.id = 'direction-card-izquierda';
        directionCardIzquierda.className = 'direction-warning-card';
        directionCardIzquierda.innerHTML = `
            <img src="https://boardinggate.github.io/Tesla/turn-left.png" alt="Giro izquierda" class="direction-card-icon">
            <span style="vertical-align: middle;">IZQUIERDA </span>
        `;
        directionCardIzquierda.style.right = '170px';
        directionCardIzquierda.style.bottom = '200px';
        mapContainer.appendChild(directionCardIzquierda);
    }
}
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateDirectionWarningCardsVisibility
    // RESUMEN: Muestra u oculta las tarjetas de advertencia segn el rumbo y el modo.
    // ===================================================================
    function updateDirectionWarningCardsVisibility() {
        if (!directionCardDerecha || !directionCardIzquierda) {
            return;
        }
        const heading = navigationCurrentLocation?.heading;
        const isStrictlySouth = (heading >= 145 && heading <= 215);
        const showCards = isStrictlySouth && navigationFollowUser && isZoomedForManeuver;
        directionCardDerecha.style.display = showCards ? 'block' : 'none';
        directionCardIzquierda.style.display = showCards ? 'block' : 'none';
    }
    
    
    
    
    
    
    
    
    
    
    L.Control.CompassAndMode = L.Control.extend({
        options: {
            position: 'bottomleft'
        },
        onAdd: function(map) {
            const container = L.DomUtil.create('div', 'leaflet-control-custom-map-controls leaflet-bar');
            const compassContainer = L.DomUtil.create('div', 'leaflet-control-orientation-altitude', container);
            compassContainer.innerHTML = `
                <img id="compass-rose-icon" src="ROSA.PNG" alt="Orientacin">
                <span id="orientation-text">---</span>
                <span id="altitude-display">--- m</span>
                <span id="current-speed-display">--- km/h</span>
                <span id="average-speed-display" class="speed-stats-text">Med: --- km/h</span>
                <span id="max-speed-display" class="speed-stats-text">Mx: --- km/h</span>
            `;
            L.DomEvent.disableClickPropagation(compassContainer);
            L.DomEvent.on(compassContainer, 'click', this._toggleGraphMode, this);
            const graphCard = L.DomUtil.create('div', 'hidden', container);
            graphCard.id = 'navigation-graph-card';
            graphCard.style.position = 'relative'; 
            graphCard.style.cursor = 'pointer';
            L.DomEvent.on(graphCard, 'click', toggleEnlargedGraph, this);
            const graphTitle = L.DomUtil.create('div', '', graphCard);
            graphTitle.id = 'navigation-graph-title';
            const enlargeButton = L.DomUtil.create('div', '', graphCard);
            enlargeButton.id = 'enlarge-graph-button';
            enlargeButton.title = 'Ampliar/Reducir grfica';
            enlargeButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    <line x1="11" y1="8" x2="11" y2="14"></line>
                    <line x1="8" y1="11" x2="14" y2="11"></line>
                </svg>
            `;
            L.DomEvent.disableClickPropagation(enlargeButton);
            L.DomEvent.on(enlargeButton, 'click', (e) => {
                e.stopPropagation(); 
                toggleEnlargedGraph();
            });
            const graphCanvasContainer = L.DomUtil.create('div', '', graphCard);
            graphCanvasContainer.id = 'navigation-graph-container';
            graphCanvasContainer.style.width = '100%';
            graphCanvasContainer.style.height = '100%';
            const canvas = L.DomUtil.create('canvas', '', graphCanvasContainer);
            canvas.id = 'navigation-chart';
            L.DomEvent.disableClickPropagation(graphCard);
            this._updateGraphTitle();
            return container;
        },
        _toggleGraphMode: function(e) {
            if (e) L.DomEvent.stopPropagation(e);
            if (!navigationCurrentRouteData) {
                showToast("La grfica estar disponible cuando se calcule una ruta.", "info");
                return;
            }
            const modes = ['Desviacin ETA', 'Altitud', 'Grfica off'];
            let currentIndex = modes.indexOf(currentGraphMode);
            currentIndex = (currentIndex + 1) % modes.length;
            currentGraphMode = modes[currentIndex];
            localStorage.setItem(GRAPH_STATE_KEY, currentGraphMode); 
            updateNavigationGraphVisibilityAndMode();
            if (currentGraphMode !== 'Grfica off') {
                showToast(`Grfica cambiada a: ${currentGraphMode}`, 'info');
            } else {
                showToast(`Grfica desactivada`, 'info');
            }
        },
        _updateGraphTitle: function() {
            const graphTitleElement = document.getElementById('navigation-graph-title');
            if (graphTitleElement) {
                if (currentGraphMode === 'Desviacin ETA') {
                    graphTitleElement.textContent = 'Desviacin ETA';
                } else if (currentGraphMode === 'Altitud') {
                    graphTitleElement.textContent = 'Desnivel Ruta';
                } else {
                    graphTitleElement.textContent = ''; 
                }
            }
        },
        onRemove: function(map) { },
        updateOrientation: function(heading) {
            const compassRoseIcon = document.getElementById('compass-rose-icon');
            const orientationText = document.getElementById('orientation-text');
            if (compassRoseIcon && orientationText) {
                if (heading !== null && !isNaN(heading) && heading >= 0 && heading <= 360) {
                    compassRoseIcon.style.transform = `rotate(${heading}deg)`;
                    currentMapBearing = heading;
                    const directions = ["N", "NE", "E", "SE", "S", "SO", "O", "NO", "N"];
                    const index = Math.round(heading / 45) % 8;
                    orientationText.textContent = `${directions[index]}`;
                } else {
                    compassRoseIcon.style.transform = 'rotate(0deg)';
                    orientationText.textContent = '---';
                    currentMapBearing = 0;
                }
            }
        },
        updateAltitude: function(altitude) {
            const altitudeDisplay = document.getElementById('altitude-display');
            if (altitudeDisplay) {
                let displayText = '--- m';
                if (altitude !== null && !isNaN(altitude)) {
                    displayText = `${altitude.toFixed(0)} m`;
                    if (maxAltitudeDuringTrip !== -Infinity && isNavigating) {
                        displayText += ` \u2261 ${maxAltitudeDuringTrip.toFixed(0)} m`;
                    }
                } else if (isNavigating && maxAltitudeDuringTrip !== -Infinity) {
                     displayText = `-- m \u2261 ${maxAltitudeDuringTrip.toFixed(0)} m`;
                }
                altitudeDisplay.textContent = displayText;
            }
        },
        updateCurrentSpeed: function(speedKmh) {
            const speedDisplay = document.getElementById('current-speed-display');
            if (speedDisplay) {
                if (speedKmh !== null && !isNaN(speedKmh)) {
                    speedDisplay.textContent = `${speedKmh.toFixed(1)} km/h`;
                } else {
                    speedDisplay.textContent = '--- km/h';
                }
            }
        },
        updateAverageSpeed: function(avgSpeedKmh) {
            const avgSpeedDisplay = document.getElementById('average-speed-display');
            if (avgSpeedDisplay) {
                let displayText = 'Med: --- km/h';
                if (avgSpeedKmh !== null && !isNaN(avgSpeedKmh) && (isNavigating || (isSimulatingGpsLocation && automatedSimulationIntervalId))) {
                     displayText = `Med: ${avgSpeedKmh.toFixed(1)} km/h`;
                }
                avgSpeedDisplay.textContent = displayText;
            }
        },
        updateMaxSpeed: function(currentSpeedKmh, currentCoords) {
            if (typeof currentSpeedKmh === 'number' && currentSpeedKmh > maxSpeedDuringTrip) {
                maxSpeedDuringTrip = currentSpeedKmh;
                if (currentCoords) {
                    maxSpeedCoordinates = { lat: currentCoords.latitude, lng: currentCoords.longitude };
                }
            }
            const maxSpeedDisplay = document.getElementById('max-speed-display');
            if (maxSpeedDisplay) {
                let displayText = 'Mx: --- km/h'; 
                if (typeof maxSpeedDuringTrip === 'number' && !isNaN(maxSpeedDuringTrip)) {
                    if (maxSpeedDuringTrip > 0) {
                        displayText = `Mx: ${maxSpeedDuringTrip.toFixed(1)} km/h`;
                    } else if ((isNavigating || (isSimulatingGpsLocation && automatedSimulationIntervalId)) && maxSpeedDuringTrip === 0) {
                        displayText = `Mx: 0.0 km/h`;
                    }
                }
                maxSpeedDisplay.textContent = displayText;
            }
        }
    });
    L.control.compassAndMode = function(opts) {
        return new L.Control.CompassAndMode(opts);
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleMapTilt
    // RESUMEN: Activa/desactiva la inclinacin del mapa (no implementado).
    // ===================================================================
    function toggleMapTilt(activate) {
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateMapTiltBasedOnHeading
    // RESUMEN: Actualiza la inclinacin del mapa segn el rumbo (no implementado).
    // ===================================================================
    function updateMapTiltBasedOnHeading(heading) {
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleMapHeaderRowsVisibility
    // RESUMEN: Muestra u oculta las filas de botones en la cabecera del mapa.
    // ===================================================================
    function toggleMapHeaderRowsVisibility(show) {
        const header = document.getElementById('reminders-location-map-header');
        if (!header) return;
        mapHeaderButtonsVisible = show;
        header.querySelectorAll('.button-row').forEach(row => {
            row.classList.toggle('hidden-map-header', !show);
        });
        if (navigationMapInstance) {
            setTimeout(() => {
                if (navigationMapInstance) {
                    try {
                        navigationMapInstance.invalidateSize();
                    } catch(e) {
                        console.error("Error al invalidar el tamao del mapa:", e);
                    }
                }
            }, 350);
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleLocateMeClick
    // RESUMEN: Maneja el clic en el botn de "Ests Aqu" para centrar o dejar de seguir al usuario.
    // ===================================================================
    function handleLocateMeClick(locateMeButton) {
        if (!navigationMapInstance || !locateMeButton) return;
        const locateMeImg = locateMeButton.querySelector('img');
        const isSatelliteWithLabelsLayer = (localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "").toLowerCase().includes("satlite + calles");
        const targetZoom = isSatelliteWithLabelsLayer ? 17 : 19;
        if (locateMeButton.title.includes("Mostrar mi posicin")) {
            shouldCenterOnUser = true; navigationFollowUser = true;
            if(locateMeImg) locateMeImg.src = "DEJARSEGUIR.PNG";
            locateMeButton.title = "Dejar de centrar el mapa en mi posicin";
            if (navigationCurrentLocation) {
                navigationMapInstance.setView([navigationCurrentLocation.latitude, navigationCurrentLocation.longitude], targetZoom);
            } else {
                getCurrentLocation(coords => {
                    if (navigationMapInstance) navigationMapInstance.setView([coords.latitude, coords.longitude], targetZoom);
                    updateInitialUserPosition(coords, navigationMapInstance);
                }, () => showToast("No se pudo obtener tu ubicacin.", "warning"));
            }
        } else {
            shouldCenterOnUser = false; navigationFollowUser = false;
            if(locateMeImg) locateMeImg.src = "ESTASAQUI.PNG";
            locateMeButton.title = "Mostrar mi posicin actual y activar seguimiento";
            targetMapCenterOffset = { x: 0, y: 0 };
            if (navigationMapInstance) navigationMapInstance.panTo(navigationMapInstance.getCenter(), { animate: false });
        }
        updateStartNavigationButtonState(); updateNavigationButtonColor(); updateDirectionWarningCardsVisibility();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleZoomToggleButtonClick
    // RESUMEN: Alterna el zoom del mapa entre la vista completa de la ruta y la vista del coche.
    // ===================================================================
    function handleZoomToggleButtonClick(zoomButton) {
        if (!navigationMapInstance || !zoomButton) return;
        const currentState = zoomButton.dataset.zoomState;
        const img = zoomButton.querySelector('img');
        if (!img) return;
        if (currentState === 'waypoints' || currentState === 'no_route_zoom_out') {
            if (navigationCurrentLocation) {
                const targetZoom = (navigationMapInstance.getMaxZoom() || 19) - 1;
                zoomButton.dataset.zoomState = 'car';
                img.src = 'ZOOM-.PNG';
                zoomButton.title = "Zoom para ver la ruta completa";
                navigationMapInstance.setView([navigationCurrentLocation.latitude, navigationCurrentLocation.longitude], targetZoom, { animate: true, duration: 0.5 });
            }
        } else {
            if (navigationRouteLayer?.getBounds().isValid()) {
                navigationMapInstance.fitBounds(navigationRouteLayer.getBounds().pad(0.15), { animate: true, duration: 0.5 });
                zoomButton.dataset.zoomState = 'waypoints';
            } else {
                navigationMapInstance.setView(navigationMapInstance.getCenter(), 10, { animate: true, duration: 0.5 });
                zoomButton.dataset.zoomState = 'no_route_zoom_out';
            }
            img.src = 'ZOOM+.PNG';
            zoomButton.title = "Zoom a la ubicacin del coche";
        }
    }
    
    
    
    
    
    
    


// ===================================================================
// NOMBRE: handleLoadOrDeleteRouteClick
// RESUMEN: Borra la ruta actual del mapa.
// ===================================================================
function handleLoadOrDeleteRouteClick(button) {
    lastAutoShownManeuverId = null;
    if (isNavigating) {
        toggleNavigationState();
    }
    if (isSimulatingGpsLocation) {
        stopAutomatedRouteSimulation();
    }
    clearNavigationGraph();
    clearAllWaypointMarkersFromMap();
    navigationWaypoints = [];
    if (navigationRouteLayer) { 
        try { 
            navigationMapInstance.removeLayer(navigationRouteLayer); 
        } catch (e) {} 
        navigationRouteLayer = null; 
    }
    if (completedRouteSegmentsLayer) completedRouteSegmentsLayer.clearLayers();
    if (maxSpeedMarkerLayer) maxSpeedMarkerLayer.clearLayers();
    if (speedMilestoneLayer) speedMilestoneLayer.clearLayers();
    navigationCurrentRouteData = null;
    hideNavigationUI();
    hideMapInfoOverlay();
    eliminarRadaresDeRuta();
    eliminarTareasDeBarraProgreso();
    clearChargingPoints();
    actualizarContadorRadares(0);
    actualizarContadorTareas(0);
    showToast("Ruta actual borrada del mapa", "info");
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}
    
    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleAddRadarHereClick
    // RESUMEN: Crea un recordatorio de tipo RADAR en la ubicacin actual del usuario.
    // ===================================================================
    function handleAddRadarHereClick(button) {
        button.disabled = true;
        const radarImg = button.querySelector('img');
        if (radarImg) radarImg.src = "MARCANDO.PNG";
        getCurrentLocation(
            (coords) => {
                const now = new Date();
                const newRadarReminder = {
                    id: Date.now(),
                    text: '<b>RADAR: EN ESTA UBICACION (Aadido manualmente)</b>',
                    type: 'simple',
                    time: `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`,
                    date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                    createdAt: now.toISOString(),
                    managedByUser: false,
                    isLocationEnabled: true,
                    locationCoordinates: { latitude: coords.latitude, longitude: coords.longitude },
                    radiusMeters: 350,
                    excludeFromList: true
                };
                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                reminders.push(newRadarReminder);
                localStorage.setItem('reminders', JSON.stringify(reminders));
                showToast("Recordatorio RADAR creado en tu ubicacin (radio 350m)", "success");
                updateReminderCount();
                updateButtonStyles();
                if (navigationMapInstance) {
                    plotSingleReminderOnMap(newRadarReminder, navigationMapInstance);
                    navigationMapInstance.setView([coords.latitude, coords.longitude], 15);
                }
                button.disabled = false;
                if (radarImg) radarImg.src = "RADARAQUI.PNG";
            },
            (errorMsg) => {
                showToast(`Error al obtener ubicacin para RADAR: ${errorMsg}`, "error");
                button.disabled = false;
                if (radarImg) radarImg.src = "RADARAQUI.PNG";
            }
        );
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleSimulateGpsPositionClick
    // RESUMEN: Maneja el clic en el mapa durante la simulacin GPS manual.
    // ===================================================================
    function handleSimulateGpsPositionClick(e, forceExactPosition = false) {
        if (!isSimulatingGpsLocation || !navigationMapInstance) return;
        if (automatedSimulationIntervalId) {
            stopAutomatedRouteSimulationInternal();
            showToast("Simulacin automtica detenida. Posicin GPS fijada manualmente.", "info");
        }
        let latLngToUse = e.latlng;
        if (!forceExactPosition && navigationRouteLayer && navigationRouteLayer.getLatLngs().length > 0 && typeof L.GeometryUtil !== 'undefined' && L.GeometryUtil.closest) {
            const closestPointOnRoute = L.GeometryUtil.closest(navigationMapInstance, navigationRouteLayer, e.latlng);
            if (closestPointOnRoute && closestPointOnRoute.distance < 50) { 
                latLngToUse = L.latLng(closestPointOnRoute.lat, closestPointOnRoute.lng);
            }
        }
        simulatedGpsLocation = {
            latitude: latLngToUse.lat,
            longitude: latLngToUse.lng,
            accuracy: 10,
            heading: navigationCurrentLocation ? navigationCurrentLocation.heading : 0,
            altitude: navigationCurrentLocation ? navigationCurrentLocation.altitude : 0,
            speed: 0
        };
        processSimulatedGpsPosition(true); 
        setNavigationMapClickHandler(); 
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: stopAutomatedRouteSimulationInternal
    // RESUMEN: Detiene la simulacin automtica de ruta sin cambiar el estado general.
    // ===================================================================
    function stopAutomatedRouteSimulationInternal() {
        if (automatedSimulationIntervalId) {
            clearInterval(automatedSimulationIntervalId);
            automatedSimulationIntervalId = null;
        }
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) {
        }
        setNavigationMapClickHandler();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleGpsSimulationToggle
    // RESUMEN: Activa/desactiva el modo de simulacin GPS.
    // ===================================================================
    function handleGpsSimulationToggle() {
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        const mapDiv = document.getElementById('reminders-location-map-div');
        if (isSimulatingGpsLocation) { 
            stopAutomatedRouteSimulationInternal(); 
            isSimulatingGpsLocation = false;
            reactivateRealGpsAfterSimulation();
            if (mapDiv) mapDiv.classList.remove('simulating-gps-click-mode');
            if (simulateGpsButton) {
                simulateGpsButton.classList.remove('active-simulate-gps-mode'); 
                simulateGpsButton.title = "Activar Simulacin GPS (recorrido automtico o clic manual)";
            }
            showToast("Modo simulacin GPS desactivado. Volviendo a GPS real.", "info");
        } else { 
            isSimulatingGpsLocation = true;
            if (locationWatchId !== null && navigator.geolocation) {
                navigator.geolocation.clearWatch(locationWatchId);
                locationWatchId = null;
            }
            if (simulateGpsButton) {
                simulateGpsButton.classList.add('active-simulate-gps-mode'); 
                simulateGpsButton.title = "Desactivar Simulacin GPS (Volver a GPS Real)";
            }
            if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0] && navigationWaypoints.length >= 2) {
                showSimulationSpeedModal(simulationSpeedKmph, (newSpeed) => {
                    simulationSpeedKmph = newSpeed;
                    startAutomatedRouteSimulation(simulationSpeedKmph); 
                    if (mapDiv) mapDiv.classList.remove('simulating-gps-click-mode'); 
                });
            } else {
                if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode'); 
                showToast("Modo simulacin GPS por clic ACTIVADO. Carga una ruta para recorrido automtico o toca el mapa.", "info", 6000);
            }
        }
        setNavigationMapClickHandler();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: startAutomatedRouteSimulation
    // RESUMEN: Inicia la simulacin automtica de una ruta a una velocidad determinada.
    // ===================================================================
    function startAutomatedRouteSimulation(speedKmph) {
        if (!isSimulatingGpsLocation) {
            showToast("Error: El modo de simulacin GPS no est activo.", "error");
            return;
        }
        if (!navigationRouteLayer || !navigationCurrentRouteData || !navigationCurrentRouteData.routes[0] || navigationWaypoints.length < 2) {
            showToast("No hay ruta vlida para simular.", "warning");
            stopAutomatedRouteSimulationInternal();
            if (isSimulatingGpsLocation) { 
                const mapDiv = document.getElementById('reminders-location-map-div');
                if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode');
                setNavigationMapClickHandler();
            }
            return;
        }
        if (automatedSimulationIntervalId) clearInterval(automatedSimulationIntervalId);
        if (!isNavigating) {
            toggleNavigationState(); 
        }
        simulationSpeedKmph = speedKmph;
        currentSimulationSpeedKmph = speedKmph;
        const routeLine = navigationRouteLayer.getLatLngs();
        const route = navigationCurrentRouteData.routes[0];
        const startWaypoint = navigationWaypoints.find(wp => wp.type === 'S' || wp.isRecalculatedStart) || navigationWaypoints[0];
        let initialHeading = 0;
        if (routeLine.length >= 2) {
            const firstPoint = turf.point([routeLine[0].lng, routeLine[0].lat]);
            const secondPoint = turf.point([routeLine[1].lng, routeLine[1].lat]);
            initialHeading = turf.bearing(firstPoint, secondPoint);
            if (initialHeading < 0) initialHeading += 360;
        }
        simulatedGpsLocation = {
            latitude: startWaypoint.lat,
            longitude: startWaypoint.lng,
            accuracy: 5,
            heading: initialHeading,
            altitude: (navigationCurrentLocation?.altitude) ?? 0,
            speed: 0
        };
        simulatedDistanceAlongRoute = 0;
        lastCarDistanceAlongRouteForNavLogic = 0;
        lastValidCarDistanceForDisplay = 0;
        totalDistanceTravelledForStats = 0;
        if (!navigationStartTimeForStats || !isNavigating) {
            navigationStartTimeForStats = new Date();
        }
        maxSpeedDuringTrip = 0;
        maxSpeedCoordinates = { lat: startWaypoint.lat, lng: startWaypoint.lng };
        processSimulatedGpsPosition(true); 
        const totalRouteDistance = route.distance;
        showToast(`Simulacin automtica de ruta iniciada a ${speedKmph.toFixed(0)} km/h (velocidad variable).`, "info");
        setNavigationMapClickHandler(); 
        let simulationStepIndex = 0;
        let simulationLegIndex = 0;
        let distanceToEndOfCurrentStep = calculateDistanceToEndOfStep(route, 0, 0);
        automatedSimulationIntervalId = setInterval(() => {
            const speedMps = (currentSimulationSpeedKmph * 1000) / 3600;
            const distanceIncrement = speedMps * (SIMULATION_TICK_INTERVAL_MS / 1000);
            simulatedDistanceAlongRoute += distanceIncrement;
            totalDistanceTravelledForStats = simulatedDistanceAlongRoute;
            if (simulatedDistanceAlongRoute > distanceToEndOfCurrentStep) {
                simulationStepIndex++;
                if (simulationStepIndex >= route.legs[simulationLegIndex].steps.length) {
                    simulationStepIndex = 0;
                    simulationLegIndex++;
                }
                if (simulationLegIndex < route.legs.length) {
                    const currentStep = route.legs[simulationLegIndex].steps[simulationStepIndex];
                    const multiplier = getRandomSpeedMultiplierForManeuver(currentStep.maneuver);
                    let newSpeed = simulationSpeedKmph * (1 + multiplier);
                    currentSimulationSpeedKmph = Math.max(20, Math.min(160, newSpeed));
                    distanceToEndOfCurrentStep = calculateDistanceToEndOfStep(route, simulationLegIndex, simulationStepIndex);
                }
            }
            if (simulatedDistanceAlongRoute >= totalRouteDistance) {
                stopAutomatedRouteSimulationInternal();
                const endPointCoords = routeLine[routeLine.length - 1];
                simulatedGpsLocation = {
                    ...simulatedGpsLocation,
                    latitude: endPointCoords.lat,
                    longitude: endPointCoords.lng,
                    speed: 0
                };
                processSimulatedGpsPosition(true);
                showToast("Simulacin de ruta completada. Modo simulacin por clic activo.", "success");
                const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
                const mapDiv = document.getElementById('reminders-location-map-div');
                if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode'); 
                if (isNavigating || (!isNavigating && navigationWaypoints.length > 0)) {
                     showArrivalStatsModal();
                }
                setNavigationMapClickHandler();
                return;
            }
            const turfLine = turf.lineString(routeLine.map(p => [p.lng, p.lat]));
            const pointOnLine = turf.along(turfLine, simulatedDistanceAlongRoute / 1000, { units: 'kilometers' });
            if (pointOnLine && pointOnLine.geometry && pointOnLine.geometry.coordinates) {
                const [lng, lat] = pointOnLine.geometry.coordinates;
                let headingSim = 0;
                const lookAheadDistance = Math.min(distanceIncrement * 2, totalRouteDistance - simulatedDistanceAlongRoute);
                if (simulatedDistanceAlongRoute + lookAheadDistance <= totalRouteDistance && lookAheadDistance > 0) {
                    const nextPointOnLine = turf.along(turfLine, (simulatedDistanceAlongRoute + lookAheadDistance) / 1000, { units: 'kilometers' });
                    if (nextPointOnLine && nextPointOnLine.geometry && nextPointOnLine.geometry.coordinates) {
                        headingSim = turf.bearing(pointOnLine, nextPointOnLine);
                        if (headingSim < 0) headingSim += 360;
                    }
                } else {
                    if (simulatedGpsLocation && typeof simulatedGpsLocation.heading === 'number' && simulatedGpsLocation.heading !== null) {
                        headingSim = simulatedGpsLocation.heading;
                    }
                }
                simulatedGpsLocation = {
                    latitude: lat,
                    longitude: lng,
                    accuracy: 5,
                    heading: headingSim,
                    altitude: (navigationCurrentLocation?.altitude) ?? 0,
                    speed: speedMps
                };
                processSimulatedGpsPosition(false);
            }
        }, SIMULATION_TICK_INTERVAL_MS);
    }
    
    
    
    
    
    
    



// ===================================================================
// NOMBRE: processSimulatedGpsPosition
// RESUMEN: Procesa la posicin GPS simulada y actualiza el estado de la navegacin.
// ===================================================================
function processSimulatedGpsPosition(forceExactPosition = false) {
    if (!isSimulatingGpsLocation || !simulatedGpsLocation) return;
    navigationCurrentLocation = { ...simulatedGpsLocation };
    updateInitialUserPosition(navigationCurrentLocation, navigationMapInstance);
    if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
        const route = navigationCurrentRouteData.routes[0];
        let carDistTurf = 0;
        if (navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
            try {
                const carPointTurf = turf.point([simulatedGpsLocation.longitude, simulatedGpsLocation.latitude]);
                const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                let nearestPointOnLineTurf;
                if (forceExactPosition) {
                     nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                } else {
                    nearestPointOnLineTurf = carPointTurf;
                }
                const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
            } catch (turfError) {
            }
         }
        
        // ----- INICIO DE LA CORRECCIN -----
        // Se asegura que una etapa marcada como 'visitada' no pueda volver a 'no visitada'.
        let cumulativeDistance = 0;
        navigationWaypoints.forEach((wp, index) => {
            if (wp && !wp.visited) { // Solo se evalan las etapas que NO han sido visitadas.
                const isStartPoint = wp.type === 'S' || wp.isRecalculatedStart;
                const isIntermediate = wp.type === 'intermediate';
                const isFinal = wp.type === 'F';
        
                if (isStartPoint) {
                    wp.visited = true;
                } else if (isIntermediate && route.legs && (index - 1) < route.legs.length) {
                    const leg = route.legs[index - 1];
                    if (leg) {
                        cumulativeDistance += (leg.distance || 0);
                        if (carDistTurf >= cumulativeDistance - WAYPOINT_VISITED_THRESHOLD_METERS) {
                            wp.visited = true;
                        }
                    }
                } else if (isFinal) {
                    if (carDistTurf >= route.distance - WAYPOINT_VISITED_THRESHOLD_METERS) {
                        wp.visited = true;
                    }
                }
            } else if (wp && wp.visited && wp.type === 'intermediate') {
                // Si ya est visitada, solo actualizamos la distancia acumulada para los siguientes clculos
                if (route.legs && (index - 1) < route.legs.length) {
                    const leg = route.legs[index - 1];
                    if (leg) {
                        cumulativeDistance += (leg.distance || 0);
                    }
                }
            }
        });
        renderWaypointMarkers();
        // ----- FIN DE LA CORRECCIN -----

        lastCarDistanceAlongRouteForNavLogic = carDistTurf;
        updateTurnByTurnDisplay(route, carDistTurf);
        updateNavigationProgressDisplay(route, carDistTurf);
    }
    if (!automatedSimulationIntervalId) { 
        showToast(`Posicin GPS simulada: ${simulatedGpsLocation.latitude.toFixed(4)}, ${simulatedGpsLocation.longitude.toFixed(4)}`, "info");
    }
}


    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: setNavigationMapClickHandler
    // RESUMEN: Asigna el manejador de clics correcto al mapa segn el modo actual.
    // ===================================================================
    function setNavigationMapClickHandler() {
        if (!navigationMapInstance) return;
        if (navigationMapClickHandler) {
            navigationMapInstance.off('click', navigationMapClickHandler);
            navigationMapClickHandler = null;
        }
        const mapDiv = document.getElementById('reminders-location-map-div');
        if (mapDiv) {
            mapDiv.classList.remove('add-reminder-mode', 'simulating-gps-click-mode', 'navigating');
        }
        if (isAddReminderAtLocationModeActive) {
            navigationMapClickHandler = handleMapClickToAddReminder;
            if (mapDiv) mapDiv.classList.add('add-reminder-mode');
        } else if (isSimulatingGpsLocation) {
            navigationMapClickHandler = (e) => {
                if (automatedSimulationIntervalId) {
                    stopAutomatedRouteSimulationInternal();
                    showToast("Simulacin automtica detenida. Posicin GPS fijada manualmente.", "info");
                }
                handleSimulateGpsPositionClick(e, true);
            };
            if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode');
        } else if (!isNavigating) {
            navigationMapClickHandler = (e) => addWaypoint(e.latlng);
        } else {
            if (mapDiv) mapDiv.classList.add('navigating');
            navigationMapClickHandler = null;
        }
        if (navigationMapClickHandler) {
            navigationMapInstance.on('click', navigationMapClickHandler);
        }
    }
    
    
    
    
    
    
    
    
// ===================================================================
// NOMBRE: showSimulationSpeedModal
// RESUMEN: Muestra un modal para que el usuario introduzca la velocidad de simulacin.
// ===================================================================
function showSimulationSpeedModal(defaultSpeed, callback) {
    closeOtherModals('simulation-speed-modal');
    let modal = document.getElementById('simulation-speed-modal');
    if (modal) modal.remove();
    modal = document.createElement('div');
    modal.id = 'simulation-speed-modal';
    // --- HTML del modal actualizado con el slider ---
    modal.innerHTML = `
        <h2>Velocidad de Simulacin</h2>
        <div class="filter-group" style="margin-bottom: 20px;">
            <label id="speed-range-label">Velocidad: ${defaultSpeed} km/h</label>
            <div class="slider-container single-slider-container" style="height: 25px;">
                <div class="slider-track"></div>
                <div class="slider-range" id="speed-slider-range"></div>
                <div class="slider-thumb" id="speed-thumb" style="left: 0%;"></div>
            </div>
        </div>
        <div class="modal-top-buttons">
            <button id="confirm-simulation-speed">Aceptar <span class="button-countdown-timer"></span></button>
            <button id="cancel-simulation-speed">Cancelar</button>
        </div>
    `;
    document.body.appendChild(modal);

    // --- LGICA DEL SLIDER DE VELOCIDAD ---
    const speedSliderContainer = modal.querySelector('#speed-thumb').parentElement;
    const speedThumb = modal.querySelector('#speed-thumb');
    const speedRange = modal.querySelector('#speed-slider-range');
    const speedLabel = modal.querySelector('#speed-range-label');
    const minSpeed = 1;
    const maxSpeed = 5000;
    let currentSpeed = defaultSpeed || 90;

    const updateSpeedVisuals = () => {
        const minLog = Math.log(minSpeed);
        const maxLog = Math.log(maxSpeed);
        const percent = (Math.log(currentSpeed) - minLog) / (maxLog - minLog);
        
        speedThumb.style.left = `${percent * 100}%`;
        speedRange.style.width = `${percent * 100}%`;
        speedLabel.textContent = `Velocidad: ${Math.round(currentSpeed)} km/h`;
    };

    const onSpeedDrag = (e) => {
        const rect = speedSliderContainer.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        let percent = (clientX - rect.left) / rect.width;
        percent = Math.max(0, Math.min(1, percent));
        
        const minLog = Math.log(minSpeed);
        const maxLog = Math.log(maxSpeed);
        currentSpeed = Math.exp(minLog + percent * (maxLog - minLog));
        
        updateSpeedVisuals();
    };

    const startSpeedDrag = (e) => {
        const moveHandler = (moveEvent) => onSpeedDrag(moveEvent);
        const endDrag = () => {
            document.removeEventListener('mousemove', moveHandler);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchmove', moveHandler);
            document.removeEventListener('touchend', endDrag);
        };
        document.addEventListener('mousemove', moveHandler);
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchmove', moveHandler);
        document.addEventListener('touchend', endDrag);
    };
    
    speedThumb.addEventListener('mousedown', startSpeedDrag);
    speedThumb.addEventListener('touchstart', startSpeedDrag);
    updateSpeedVisuals();
    
    // --- Lgica de los botones ---
    const confirmBtn = modal.querySelector('#confirm-simulation-speed');
    const cancelBtn = modal.querySelector('#cancel-simulation-speed');
    const closeHandler = () => {
        clearModalAutoCloseTimer(modal, confirmBtn, 'simulation-speed-modal');
        if (modal.parentNode) modal.remove();
    };

    confirmBtn.addEventListener('click', () => {
        callback(Math.round(currentSpeed));
        closeHandler();
    });

    cancelBtn.addEventListener('click', () => {
        showToast("Inicio de simulacin cancelado", "info");
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) simulateGpsButton.classList.remove('active-simulate-gps-mode');
        isSimulatingGpsLocation = false;
        reactivateRealGpsAfterSimulation();
        setNavigationMapClickHandler();
        closeHandler();
    });

    addModalAutoCloseTimer(modal, confirmBtn, 'simulation-speed-modal', 30000);
}


    
    
    
    
    




// ===================================================================
// NOMBRE: showReminderModal
// RESUMEN: Muestra el modal para crear o modificar un recordatorio.
// ===================================================================
function showReminderModal(reminder = null, options = {}) {
    const mapShouldReopenAfterForm = sessionStorage.getItem('boardinggate_map_should_reopen_after_form') === 'true';
    const mapContextBeforeThisModal = sessionStorage.getItem('mapContext');
    closeOtherModals();
    let autoSaveInterval = null; let parseTimeout = null; let restartTimeout = null; let focusTimeout = null; let countdownSave = 25; let manualTimeInput = false; let lastInputWasSpeech = false;
    let currentReminderLocation = null;
    let locationEnabledByUser = false;
    let mapExpandedManually = false;
    let mapMoveDebounceTimer = null;
    function cleanUpModalTimers(clearAll = true) {
        if (autoSaveInterval) { clearInterval(autoSaveInterval); autoSaveInterval = null; }
        if (clearAll) {
            if (parseTimeout) clearTimeout(parseTimeout);
            if (restartTimeout) clearTimeout(restartTimeout);
            if (focusTimeout) clearTimeout(focusTimeout);
            parseTimeout = null; restartTimeout = null; focusTimeout = null;
        }
    }
    const existingModal = document.querySelector('.reminder-modal');
    if (existingModal && typeof existingModal.cleanUpModalTimers === 'function') {
        existingModal.cleanUpModalTimers(true);
        if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal);
    }
    let isNew = true;
    let parsed = {
         id: null, text: '', time: null, date: null, repeatDays: [], intervalDays: null, type: 'simple',
         createdAt: new Date().toISOString(), managedByUser: false,
         isLocationEnabled: false, locationCoordinates: null, radiusMeters: DEFAULT_LOCATION_RADIUS,
         excludeFromList: false
    };
    if (reminder && typeof reminder.id === 'number' && reminder.id !== null) {
        const remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
        const foundReminder = remindersFromStorage.find(r => r.id === reminder.id);
        if (foundReminder) {
            parsed = { ...foundReminder };
            isNew = false;
        } else {
            parsed = { ...reminder, id: null, createdAt: new Date().toISOString(), managedByUser: false };
            isNew = true;
            if(reminder.text && reminder.text.toUpperCase().includes("RADAR RUTA:")) {
                 parsed.text = reminder.text.replace("RADAR RUTA:", "RADAR:");
                 parsed.excludeFromList = true;
                 parsed.radiusMeters = 350;
            }
        }
    } else if (reminder) {
        parsed = { ...reminder, id: null, createdAt: new Date().toISOString(), managedByUser: false };
        isNew = true;
         if(reminder.text && reminder.text.toUpperCase().includes("RADAR RUTA:")) {
            parsed.text = reminder.text.replace("RADAR RUTA:", "RADAR:");
            parsed.excludeFromList = true;
            parsed.radiusMeters = 350;
        }
    }
    if (parsed.text && parsed.text.toUpperCase().startsWith("<b>RADAR:") && (parsed.radiusMeters === DEFAULT_LOCATION_RADIUS || !parsed.radiusMeters)) {
        parsed.radiusMeters = 350;
    }
    if (!isNew && !parsed.createdAt) { parsed.createdAt = new Date(0).toISOString(); }
    locationEnabledByUser = parsed.isLocationEnabled;
    currentReminderLocation = parsed.locationCoordinates;
    let fmtDate = '';
    if (parsed.date?.match(/^\d{4}-\d{2}-\d{2}$/)) {
        try {
            const [y,m,d] = parsed.date.split('-');
            const dt=new Date(Date.UTC(y,m-1,d));
            if(!isNaN(dt.getTime())&&dt.getUTCDate()==d&&dt.getUTCMonth()==m-1) {
                fmtDate=`${d.toString().padStart(2,'0')}/${m.toString().padStart(2,'0')}/${y}`;
            }
        } catch(e){}
    }
    const modal = document.createElement('div');
    modal.className = 'reminder-modal';
    modal.setAttribute('aria-label','Formulario recordatorio');
    const titleHtml = `
        <div style="display: flex; align-items: center; justify-content: space-between; width: 100%; flex-wrap: wrap;">
            <span class="font-bold" style="font-size: 1.5rem; margin-right: auto;">${isNew ? 'NUEVO RECORDATORIO' : 'MODIFICAR RECORDATORIO'}</span>
            <div style="display: flex; align-items: center; margin-left: 35px; white-space: nowrap;">
                <input type="checkbox" id="reminder-exclude-from-list" ${parsed.excludeFromList ? 'checked' : ''} style="transform: scale(1.1); margin-right: 5px;">
                <label for="reminder-exclude-from-list" style="font-size: 0.9rem; font-weight: normal; color: #555;">NO INCLUIRLO EN LA LISTA (radares, etc)</label>
            </div>
        </div>`;
    modal.innerHTML = `
         <h2 style="display: flex; align-items: center; justify-content: center; text-align: center;">${titleHtml}</h2>
         <div class="modal-top-buttons full-width" style="margin-top: 1rem; margin-bottom: 0.8rem;">
            <button type="submit" id="save-reminder">Aceptar <span id="countdown-save">25</span></button>
            <button type="button" id="cancel-reminder">Cancelar</button>
            <button type="button" id="delete-reminder" title="Borrar este recordatorio permanentemente">Borrar</button>
            <button type="button" id="view-reminders">Ver Recordatorios</button>
            <button type="button" id="manage-saved-locations">Ubicaciones</button>
            <button type="button" id="help-reminder">Ayuda</button>
         </div>
         <p id="parse-status" class="text-sm mt-1"></p>
         <form id="reminder-form">
             <div class="full-width">
                <div style="display:flex;align-items:center;gap:.5rem;">
                    <button type="button" id="clear-fields" class="speech-button" title="Limpiar" style="background-color:#D1D5DB;color:#111827;flex-shrink:0;">Limpiar</button>
                    <textarea id="reminder-text" rows="4" required style="flex-grow:1;">${parsed.text.replace(/<b>|<\/b>/gi,'')}</textarea>
                    <button type="button" id="start-speech" class="speech-button" title="Voz" style="flex-shrink:0;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                    </button>
                </div>
                <p id="speech-status" class="speech-status"></p>
             </div>
             <div class="form-grid">
                 <div>
                     <label for="reminder-time">Hora:</label>
                     <input type="text" id="reminder-time" placeholder="HH:MM" pattern="\\d{2}:\\d{2}" value="${parsed.time||''}">
                 </div>
                 <div>
                     <label for="reminder-date">Fecha:</label>
                     <input type="text" id="reminder-date" placeholder="DD/MM/AAAA" pattern="\\d{2}/\\d{2}/\\d{4}" value="${fmtDate}">
                 </div>
                 <div style="display: flex; flex-direction: column; align-items: flex-start;">
                     <label for="reminder-interval" style="margin-bottom: 0.25rem; line-height: 1.2;">Intervalo<br>(das):</label>
                     <div style="display: flex; align-items: center; gap: 0.5rem;">
                         <input type="number" id="reminder-interval" min="1" max="9999" value="${parsed.intervalDays||''}" style="width: 90px;">
                         <input type="checkbox" id="location-enabled" ${parsed.isLocationEnabled ? 'checked' : ''} style="margin-left: 8px; transform: scale(1.2); margin-right: 0.2rem;">
                         <label for="location-enabled" style="font-weight: bold; white-space: nowrap; font-size: 1.1rem; color: #374151;">Ubicacin</label>
                     </div>
                 </div>
                 <div class="location-controls-group" style="justify-content: flex-start; margin-top: 0; align-items: center;">
                    <button type="button" id="expand-map-button">Ampliar Mapa</button>
                 </div>
             </div>
             
             <div id="radius-slider-group" class="filter-group" style="grid-column: 1 / -1; margin-bottom: 10px; margin-top: 10px;">
                 <label id="radius-range-label">RADIO ACCIN (si marca ubicacin): ${parsed.radiusMeters || 350} metros</label>
                 <div class="slider-container single-slider-container" style="height: 25px; width: 100%;">
                     <div class="slider-track"></div>
                     <div class="slider-range" id="radius-slider-range"></div>
                     <div class="slider-thumb" id="radius-thumb" style="left: 0%;"></div>
                 </div>
             </div>
    
             <div id="location-map-container" class="full-width">
                 <button type="button" id="reduce-map-button" class="hidden">REDUCIR MAPA</button>
                 <button type="button" id="locate-me-button" class="hidden">ESTS AQU</button>
             </div>
             <div class="days-group full-width">
                 <label>Das repeticin:</label>
                 ${['Lun ','Mar ','Mi ','Jue ','Vie ','Sb ','Dom '].map((d,i)=>`<label style="flex:0 0 auto;"><input type="checkbox" name="repeat" value="${(i+1)%7}" ${parsed.repeatDays?.includes((i+1)%7)?'checked':''}> ${d}</label>`).join('')}
             </div>
             <p id="auto-save-timer" class="text-sm text-gray-600 mt-2 full-width"></p>
         </form>`;
    if (options.onTopOfMap) {
        const mapContainerEl = document.getElementById('reminders-location-map-modal');
        if (mapContainerEl) {
            mapContainerEl.appendChild(modal);
        } else {
            document.body.appendChild(modal);
        }
    } else {
        document.body.appendChild(modal);
    }
    modal.cleanUpModalTimers = cleanUpModalTimers;
    const parseStatus = modal.querySelector('#parse-status');
    const speechStatus = modal.querySelector('#speech-status');
    const autoSaveTimerLabel = modal.querySelector('#auto-save-timer');
    let countdownSaveElement = modal.querySelector('#countdown-save');
    const textInput = modal.querySelector('#reminder-text');
    const timeInput = modal.querySelector('#reminder-time');
    const dateInput = modal.querySelector('#reminder-date');
    const intervalInput = modal.querySelector('#reminder-interval');
    const speechButton = modal.querySelector('#start-speech');
    const saveButton = modal.querySelector('#save-reminder');
    const clearButton = modal.querySelector('#clear-fields');
    const locationCheckbox = modal.querySelector('#location-enabled');
    const mapContainer = modal.querySelector('#location-map-container');
    const expandMapButton = modal.querySelector('#expand-map-button');
    const reduceMapButton = modal.querySelector('#reduce-map-button');
    const locateMeButton = modal.querySelector('#locate-me-button');
    const manageLocationsBtn = modal.querySelector('#manage-saved-locations');
    const excludeFromListCheckbox = modal.querySelector('#reminder-exclude-from-list');
    const deleteButton = modal.querySelector('#delete-reminder');
    
    // --- INICIO DE LA MODIFICACIN ---
    // 2. Se selecciona el contenedor del slider y se aade la lgica de visibilidad.
    const radiusSliderGroup = modal.querySelector('#radius-slider-group');

    function toggleRadiusVisibility() {
        if (radiusSliderGroup) {
            radiusSliderGroup.style.display = locationCheckbox.checked ? 'block' : 'none';
        }
    }
    
    // Se aade el listener al checkbox para ejecutar la funcin cuando cambie
    locationCheckbox.addEventListener('change', toggleRadiusVisibility);
    
    // Se ejecuta una vez al inicio para establecer el estado inicial correcto
    toggleRadiusVisibility();
    // --- FIN DE LA MODIFICACIN ---

    // --- LGICA PARA EL SLIDER DE RADIO ---
    const radiusSliderContainer = modal.querySelector('#radius-thumb')?.parentElement;
    const radiusThumb = modal.querySelector('#radius-thumb');
    const radiusRange = modal.querySelector('#radius-slider-range');
    const radiusLabel = modal.querySelector('#radius-range-label');
    const minRadius = 1;
    const maxRadius = 5000;
    let currentRadius = parsed.radiusMeters || 350;

    const updateRadiusVisuals = () => {
        if (!radiusThumb || !radiusRange || !radiusLabel) return;
        const minLog = Math.log(minRadius);
        const maxLog = Math.log(maxRadius);
        const percent = (Math.log(currentRadius) - minLog) / (maxLog - minLog);
        
        radiusThumb.style.left = `${percent * 100}%`;
        radiusRange.style.width = `${percent * 100}%`;
        radiusLabel.textContent = `Radio (si es por ubicacin): ${Math.round(currentRadius)} metros`;
    };

    if (radiusSliderContainer && radiusThumb) {
        const onRadiusDrag = (e) => {
            const rect = radiusSliderContainer.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let percent = (clientX - rect.left) / rect.width;
            percent = Math.max(0, Math.min(1, percent));
            
            const minLog = Math.log(minRadius);
            const maxLog = Math.log(maxRadius);
            currentRadius = Math.exp(minLog + percent * (maxLog - minLog));
            currentRadius = Math.max(minRadius, Math.min(maxRadius, currentRadius));
            
            updateRadiusVisuals();
            resetAndStartCountdown();
        };

        const startRadiusDrag = (e) => {
            const moveHandler = (moveEvent) => onRadiusDrag(moveEvent);
            const endDrag = () => {
                document.removeEventListener('mousemove', moveHandler);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchmove', moveHandler);
                document.removeEventListener('touchend', endDrag);
            };
            document.addEventListener('mousemove', moveHandler);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchmove', moveHandler);
            document.addEventListener('touchend', endDrag);
        };
        
        radiusThumb.addEventListener('mousedown', startRadiusDrag);
        radiusThumb.addEventListener('touchstart', startRadiusDrag);
        updateRadiusVisuals();
    }

    function initializeOrUpdateMap(centerCoords, radius, isInteractive = false) {
        const mapDivId = 'reminder-modal-map-div';
        let mapDiv = document.getElementById(mapDivId);
        const effectiveLocationEnabled = locationCheckbox.checked;
        const showMap = effectiveLocationEnabled || isInteractive;

        if (!showMap) {
            destroyMap();
            return;
        }

        mapContainer.style.display = 'block';
        mapContainer.classList.toggle('preview', !isInteractive && effectiveLocationEnabled && centerCoords);
        mapContainer.classList.toggle('expanded', isInteractive && effectiveLocationEnabled);

        const effectiveCoords = centerCoords || { latitude: 40.416775, longitude: -3.703790 };
        const effectiveRadius = parseInt(radius) || DEFAULT_LOCATION_RADIUS;

        if (!isInteractive && !centerCoords && effectiveLocationEnabled) {
             destroyMap();
             return;
        }

        const zoomLevel = isInteractive ? 13 : 11;

        const setupMapInteractions = (mapInstance) => {
            mapInstance.off('click', handleMapClick);
            mapInstance.off('movestart', handleMapMoveStart);
            mapInstance.off('moveend', handleMapMoveEnd);

            if (isInteractive && effectiveLocationEnabled) {
                mapInstance.dragging.enable(); mapInstance.touchZoom.enable(); mapInstance.scrollWheelZoom.enable();
                mapInstance.doubleClickZoom.enable(); mapInstance.tap?.enable();
                mapInstance.on('click', handleMapClick);
                mapInstance.on('movestart', handleMapMoveStart);
                mapInstance.on('moveend', handleMapMoveEnd);
            } else {
                mapInstance.dragging.disable(); mapInstance.touchZoom.disable(); mapInstance.scrollWheelZoom.disable();
                mapInstance.doubleClickZoom.disable(); mapInstance.tap?.disable();
            }
        };

        const activeLayerKeyReminder = 'boardinggate_activeMapLayer_reminderModal';

        if (!reminderModalMap) {
            if (!mapDiv) {
                mapDiv = document.createElement('div');
                mapDiv.id = mapDivId;
                mapDiv.style.width = '100%'; mapDiv.style.height = '100%';
                mapContainer.insertBefore(mapDiv, reduceMapButton);
            }

            reminderModalMap = L.map(mapDivId, {
                 scrollWheelZoom: (isInteractive && effectiveLocationEnabled),
                 doubleClickZoom: (isInteractive && effectiveLocationEnabled),
                 touchZoom: (isInteractive && effectiveLocationEnabled),
                 dragging: (isInteractive && effectiveLocationEnabled),
                 tap: (isInteractive && effectiveLocationEnabled),
                 zoomControl: isInteractive && effectiveLocationEnabled
            }).setView([effectiveCoords.latitude, effectiveCoords.longitude], zoomLevel);

            const osmLayerRem = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: (isInteractive && effectiveLocationEnabled) ? ' <a href="https://www.openstreetmap.org/copyright">OSM</a>' : null });
            const satelliteLayerRem = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles  Esri' });
            const satelliteWithLabelsRem = L.layerGroup([
                L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles  Esri' }),
                L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', { attribution: ' OSM  CARTO', pane: 'labels_reminder' })
            ]);

            if (!reminderModalMap.getPane('labels_reminder')) {
                reminderModalMap.createPane('labels_reminder');
                reminderModalMap.getPane('labels_reminder').style.zIndex = 650;
                reminderModalMap.getPane('labels_reminder').style.pointerEvents = 'none';
            }

            const baseMapsRem = { "Mapa Normal": osmLayerRem, "Satlite Puro": satelliteLayerRem, "Satlite + Calles": satelliteWithLabelsRem };
            const savedLayerNameRem = localStorage.getItem(activeLayerKeyReminder) || "Satlite + Calles";
            let initialLayerRem = baseMapsRem[savedLayerNameRem] || satelliteWithLabelsRem;
            initialLayerRem.addTo(reminderModalMap);

            if (mapLayersControlReminder) mapLayersControlReminder.remove();
            mapLayersControlReminder = L.control.layers(baseMapsRem, null, { position: 'topright', collapsed: true });
            if (isInteractive && effectiveLocationEnabled) {
               mapLayersControlReminder.addTo(reminderModalMap);
            }

            reminderModalMap.on('baselayerchange', function(e) {
                localStorage.setItem(activeLayerKeyReminder, e.name);
                markCacheAsDirty();
            });

            setupMapInteractions(reminderModalMap);
            updateMarkerAndCircle(effectiveCoords, effectiveRadius);

        } else {
             reminderModalMap.setView([effectiveCoords.latitude, effectiveCoords.longitude], zoomLevel);
             updateMarkerAndCircle(effectiveCoords, effectiveRadius);
             setupMapInteractions(reminderModalMap);
             if (mapLayersControlReminder && reminderModalMap) { 
                 if (isInteractive && effectiveLocationEnabled && !reminderModalMap.hasControl(mapLayersControlReminder)) {
                     mapLayersControlReminder.addTo(reminderModalMap);
                 } else if ((!isInteractive || !effectiveLocationEnabled) && reminderModalMap.hasControl(mapLayersControlReminder)) {
                    mapLayersControlReminder.remove();
                 }
             }
             if (reminderModalMap.zoomControl) {
                if (isInteractive && effectiveLocationEnabled) reminderModalMap.zoomControl.addTo(reminderModalMap);
                else reminderModalMap.zoomControl.remove();
             }
        }
        if (reduceMapButton) reduceMapButton.classList.toggle('hidden', !(isInteractive && effectiveLocationEnabled));
        if (locateMeButton) locateMeButton.classList.toggle('hidden', !(isInteractive && effectiveLocationEnabled));
        if (mapContainer.classList.contains('expanded') || mapContainer.classList.contains('preview')) {
             requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    if (reminderModalMap && mapContainer.offsetHeight > 0) {
                        try {
                            reminderModalMap.invalidateSize();
                        } catch (e) {}
                    }
                });
            });
        }
    }
    
    function handleMapClick(e) {
         const latlng = e.latlng;
         currentReminderLocation = { latitude: latlng.lat, longitude: latlng.lng };
         updateMarkerAndCircle(currentReminderLocation, Math.round(currentRadius));
         resetAndStartCountdown();
    }
 
    function updateMarkerAndCircle(coords, radius) {
        if (!reminderModalMap || !coords) return;
        const latlng = L.latLng(coords.latitude, coords.longitude);
        const radiusMeters = parseInt(radius) || DEFAULT_LOCATION_RADIUS;
        const isDraggable = mapContainer.classList.contains('expanded') && locationCheckbox.checked;
        const currentCarIcon = vehicleIcon;
        if (!reminderMarker) {
            reminderMarker = L.marker(latlng, { icon: currentCarIcon, draggable: isDraggable }).addTo(reminderModalMap);
            if (isDraggable) reminderMarker.on('dragend', handleMarkerDragEnd);
        } else {
            reminderMarker.setLatLng(latlng);
            reminderMarker.setIcon(vehicleIcon);
            reminderMarker.options.draggable = isDraggable;
            reminderMarker.off('dragend', handleMarkerDragEnd);
            if (isDraggable) reminderMarker.on('dragend', handleMarkerDragEnd);
        }
        const markerElementContainer = reminderMarker.getElement();
        if(markerElementContainer) {
             const vehicleWrapper = markerElementContainer.querySelector('#vehicle-icon-wrapper');
             if (vehicleWrapper) {
                const currentHeading = (navigationCurrentLocation && typeof navigationCurrentLocation.heading === 'number') ? navigationCurrentLocation.heading : (currentMapBearing || 0);
                const rotationAngle = currentHeading - 90;
                vehicleWrapper.style.transform = `rotate(${rotationAngle}deg)`;
             }
        }
        const isRadar = textInput.value.toUpperCase().includes("RADAR:");
        const circleColor = isRadar ? 'rgba(255, 165, 0, 0.2)' : 'blue';
        const circleFillColor = isRadar ? 'rgba(255, 165, 0, 0.2)' : '#ADD8E6';
        const circleFillOpacity = isRadar ? 0.2 : 0.05;
        const circleWeight = isRadar ? 1 : 1;
        if (!reminderCircle) {
            reminderCircle = L.circle(latlng, { color: circleColor, fillColor: circleFillColor, weight: circleWeight, fillOpacity: circleFillOpacity, radius: radiusMeters }).addTo(reminderModalMap);
        } else {
            reminderCircle.setLatLng(latlng);
            reminderCircle.setRadius(radiusMeters);
             reminderCircle.setStyle({ color: circleColor, fillColor: circleFillColor, weight: circleWeight, fillOpacity: circleFillOpacity });
            if (!mapContainer.classList.contains('expanded') || (mapMoveDebounceTimer === null)) {
                 reminderCircle.setStyle({ stroke: true });
            }
        }
    }
    
    function handleMarkerDragEnd(event) {
         const marker = event.target;
         const position = marker.getLatLng();
         currentReminderLocation = { latitude: position.lat, longitude: position.lng };
         updateMarkerAndCircle(currentReminderLocation, Math.round(currentRadius));
         resetAndStartCountdown();
    }
    
    function destroyMap() {
        if (reminderModalMap) {
             reminderModalMap.off('click', handleMapClick);
             reminderModalMap.off('movestart', handleMapMoveStart);
             reminderModalMap.off('moveend', handleMapMoveEnd);
             if (reminderMarker) reminderMarker.off('dragend', handleMarkerDragEnd);
             if (mapLayersControlReminder) mapLayersControlReminder.remove();
             mapLayersControlReminder = null;
             try { reminderModalMap.remove(); } catch(e) { }
             reminderModalMap = null; reminderMarker = null; reminderCircle = null;
        }
        mapContainer.style.display = 'none';
        mapContainer.classList.remove('preview', 'expanded');
        if (reduceMapButton) reduceMapButton.classList.add('hidden');
        if (locateMeButton) locateMeButton.classList.add('hidden');
        const mapDiv = document.getElementById('reminder-modal-map-div');
        if(mapDiv && mapDiv.parentNode === mapContainer) {
             mapContainer.removeChild(mapDiv);
        }
    }
    
    function handleLocationCheckboxChange() {
        const wasEnabled = locationEnabledByUser;
        locationEnabledByUser = locationCheckbox.checked;
        if (locationEnabledByUser) {
            if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && currentReminderLocation) {
                initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false);
            } else if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && !currentReminderLocation) {
                destroyMap();
            }
             if (!currentReminderLocation && !wasEnabled) {
                getCurrentLocation(
                    (coords) => {
                        currentReminderLocation = coords;
                        if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && currentReminderLocation) {
                            initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false);
                        }
                    }
                );
            }
        } else {
            destroyMap();
        }
        resetAndStartCountdown();
    }
    
    if (deleteButton) {
        deleteButton.style.backgroundColor = '#8B0000';
        deleteButton.style.color = '#FFFFFF';
        deleteButton.style.fontWeight = 'bold';
        deleteButton.style.fontSize = '1.2rem';
        deleteButton.style.border = '1px solid #580000';
        deleteButton.style.height = '70px';
        deleteButton.addEventListener('click', () => {
            cleanUpModalTimers(true);
            const mapShouldReopen = mapShouldReopenAfterForm;
            const mapContextToReopen = mapContextBeforeThisModal;

            if (isNew) {
                destroyMap();
                if (modal.parentNode) modal.parentNode.removeChild(modal);
                showToast('Creacin de recordatorio cancelada', 'info');

                if (mapShouldReopen && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
                    if (mapContextToReopen === 'navigation') openNavigationMap();
                } else if (mapShouldReopen) {
                    sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
                    if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen);
                }
                 sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
                return;
            }

            let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
            const initialLength = reminders.length;
            reminders = reminders.filter(r => r.id !== parsed.id);

            if (reminders.length < initialLength) {
                localStorage.setItem('reminders', JSON.stringify(reminders));
                markCacheAsDirty();
                showToast('Recordatorio borrado.', 'success');
            } else {
                showToast('Recordatorio no encontrado para borrar', 'warning');
            }

            destroyMap();
            if (modal.parentNode) modal.parentNode.removeChild(modal);
            updateReminderCount();
            updateButtonStyles();
            checkReminders();

             if (mapShouldReopen && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
                if (mapContextToReopen === 'navigation') openNavigationMap();
            } else if (mapShouldReopen) {
                 sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
                 if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen);
            }
            sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
        });
    }

    modal.querySelectorAll('.modal-top-buttons button').forEach(btn => {
        if (btn.id !== 'save-reminder' && btn.id !== 'delete-reminder') {
            btn.style.height = '70px';
        }

        const defaultBgColor = window.getComputedStyle(btn).backgroundColor;
        const defaultTextColor = window.getComputedStyle(btn).color;
    
        if ((defaultTextColor === 'rgb(255, 255, 255)' || defaultTextColor.toLowerCase() === '#ffffff') &&
            (defaultBgColor === 'rgb(209, 213, 219)' || defaultBgColor.toLowerCase() === '#d1d5db') &&
             btn.id !== 'save-reminder' &&
             btn.id !== 'delete-reminder' &&
             !btn.style.backgroundColor.includes('rgb(37, 99, 235)') &&
             !btn.style.backgroundColor.includes('rgb(139, 0, 0)') ) {

            btn.style.backgroundColor = '#4A5568';
            btn.style.border = '1px solid #2D3748';
            btn.style.fontWeight = 'bold';
             btn.onmouseover = () => btn.style.backgroundColor = '#2D3748';
             btn.onmouseout = () => btn.style.backgroundColor = '#4A5568';
        }
    });

    if (manageLocationsBtn) {
        manageLocationsBtn.addEventListener('click', () => {
            showSavedLocationsModal(
                () => { },
                (selectedLocationData) => {
                    if (selectedLocationData && typeof selectedLocationData.lat === 'number' && typeof selectedLocationData.lng === 'number') {
                        currentReminderLocation = { latitude: selectedLocationData.lat, longitude: selectedLocationData.lng };
                        locationCheckbox.checked = true;
                        locationEnabledByUser = true;

                        currentRadius = typeof selectedLocationData.radius === 'number' && selectedLocationData.radius > 0 ? selectedLocationData.radius : DEFAULT_LOCATION_RADIUS;
                        updateRadiusVisuals();

                        if (mapContainer.classList.contains('expanded')) {
                            initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), true);
                        } else {
                            initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false);
                        }
                        showToast(`Ubicacin "${selectedLocationData.name || 'Seleccionada'}" aplicada.`, "success");
                        resetAndStartCountdown();
                    } else {
                        showToast("Error: Datos de ubicacin seleccionada no vlidos.", "error");
                    }
                },
                { parentContainer: modal } 
            );
        });
    }

    const handleMapMoveStart = () => {
        if (reminderCircle && mapContainer.classList.contains('expanded')) {
            clearTimeout(mapMoveDebounceTimer);
            reminderCircle.setStyle({ stroke: false, fill: false });
        }
    };

    const handleMapMoveEnd = () => {
        clearTimeout(mapMoveDebounceTimer);
        mapMoveDebounceTimer = setTimeout(() => {
            if (reminderCircle && mapContainer.classList.contains('expanded')) {
                const effectiveRadius = Math.round(currentRadius) || DEFAULT_LOCATION_RADIUS;
                const isRadar = textInput.value.toUpperCase().includes("RADAR:");
                const circleColor = isRadar ? 'rgba(255, 165, 0, 0.2)' : 'blue';
                const circleFillColor = isRadar ? 'rgba(255, 165, 0, 0.2)' : '#ADD8E6';
                const circleFillOpacity = isRadar ? 0.2 : 0.05;
                const circleWeight = isRadar ? 1 : 1;
                reminderCircle.setStyle({ stroke: true, color: circleColor, fill: true, fillColor: circleFillColor, fillOpacity: circleFillOpacity, weight: circleWeight });
            }
        }, 200);
    };   

    locationCheckbox.addEventListener('change', handleLocationCheckboxChange);

    if (parsed.isLocationEnabled && parsed.locationCoordinates) {
        initializeOrUpdateMap(parsed.locationCoordinates, parsed.radiusMeters, false);
    } else if (parsed.isLocationEnabled && !parsed.locationCoordinates) {
        destroyMap();
    } else {
        destroyMap();
    }

    if (expandMapButton) {
        expandMapButton.addEventListener('click', () => {
            if (!locationCheckbox.checked) {
                locationCheckbox.checked = true;
                toggleRadiusVisibility(); // Asegurarse de que el slider aparezca
            }
            locationEnabledByUser = true;
            mapExpandedManually = true;

            if (!currentReminderLocation) {
                locateMeButton.disabled = true;
                locateMeButton.textContent = 'Buscando...';
                getCurrentLocation(
                    (gpsCoords) => {
                        currentReminderLocation = { latitude: gpsCoords.latitude, longitude: gpsCoords.longitude };
                        initializeOrUpdateMap(gpsCoords, Math.round(currentRadius), true);
                        if (reminderModalMap) {
                             reminderModalMap.setZoom(16);
                        }
                        showToast("Mapa centrado en tu ubicacin GPS. Pulsa en el mapa para ajustar si es necesario", "info");
                        locateMeButton.disabled = false; locateMeButton.textContent = 'ESTS AQU';
                    },
                    (errorMsg) => {
                        initializeOrUpdateMap(null, Math.round(currentRadius), true);
                        if (reminderModalMap) {
                            reminderModalMap.setZoom(6);
                        }
                        showToast(`Error GPS: ${errorMsg}. Mapa centrado por defecto`, "warning", 3000);
                        locateMeButton.disabled = false; locateMeButton.textContent = 'ESTS AQU';
                    }
                );
            } else {
                initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), true);
            }

            resetAndStartCountdown();
            setTimeout(() => { mapExpandedManually = false; }, 100);
        });
    }

    if (reduceMapButton) {
        reduceMapButton.addEventListener('click', () => {
             if (locationEnabledByUser && currentReminderLocation) {
                 initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false);
             } else {
                 destroyMap();
             }
             resetAndStartCountdown();
        });
    }

    if (locateMeButton) {
        locateMeButton.addEventListener('click', () => {
             if (!reminderModalMap || !mapContainer.classList.contains('expanded')) return;
             resetAndStartCountdown();
             locateMeButton.disabled = true; locateMeButton.textContent = 'Buscando...';
             getCurrentLocation(
                 (coords) => {
                     currentReminderLocation = { latitude: coords.latitude, longitude: coords.longitude };
                     if (reminderModalMap) {
                        reminderModalMap.setView([coords.latitude, coords.longitude], 16);
                        updateMarkerAndCircle(coords, Math.round(currentRadius));
                     }
                     showToast('Ubicacin actual fijada para el recordatorio', 'success');
                     locateMeButton.disabled = false; locateMeButton.textContent = 'ESTS AQU';
                 },
                 (errorMsg) => {
                     showToast(`Error al localizar: ${errorMsg}`, 'error');
                     locateMeButton.disabled = false; locateMeButton.textContent = 'ESTS AQU';
                 }
             );
        });
    }

    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = new SpeechRecognition();
        recognition.continuous = false;
        recognition.interimResults = false;
        recognition.lang = 'es-ES';
        speechButton.addEventListener('click', () => {
            cleanUpModalTimers(false);
            try {
                recognition.start();
            } catch (e) {
                speechStatus.textContent = `Error inicio: ${e.message}`;
                speechStatus.style.color = '#EF4444';
                resetAndStartCountdown();
            }
        });
        recognition.onstart = () => {
            speechStatus.textContent = 'Escuchando...';
            speechStatus.style.color = '#10B981';
        };
        recognition.onresult = (event) => {
            const transcript = event.results[event.results.length - 1][0].transcript.trim();
            textInput.value = textInput.value + transcript;
            speechStatus.textContent = '';
            lastInputWasSpeech = true;
            const inputEvent = new Event('input', { bubbles: true });
            textInput.dispatchEvent(inputEvent);
            textInput.focus();
            textInput.selectionStart = textInput.selectionEnd = textInput.value.length;
        };
        recognition.onerror = (event) => {
            speechStatus.textContent = `Error voz: ${event.error}`;
            speechStatus.style.color = '#EF4444';
            resetAndStartCountdown();
        };
        recognition.onend = () => {
            if (speechStatus.textContent === 'Escuchando...') {
                setTimeout(() => {
                    if (speechStatus.textContent === 'Escuchando...') speechStatus.textContent = '';
                }, 1500);
            }
            if (!lastInputWasSpeech) {
                resetAndStartCountdown();
            }
        };
    } else {
        speechStatus.textContent = 'Voz no soportada.';
        speechStatus.style.color = '#EF4444';
        speechButton.disabled = true;
        speechButton.style.opacity = 0.5;
    }

    function startCountdown() {
        autoSaveInterval = setInterval(() => {
            if (!document.body.contains(modal)) {
                clearInterval(autoSaveInterval);
                autoSaveInterval = null;
                return;
            }
            countdownSave--;
            if (countdownSaveElement) countdownSaveElement.textContent = countdownSave;
            if (countdownSave === 23) {
                if (document.activeElement === textInput) {
                    textInput.value += ' ';
                    textInput.selectionStart = textInput.selectionEnd = textInput.value.length;
                }
            }
            if (countdownSave <= 0) {
                clearInterval(autoSaveInterval);
                autoSaveInterval = null;
                if (saveButton) saveButton.click();
            }
        }, 1000);
    }

    function resetAndStartCountdown() {
        countdownSave = 25;
        if (countdownSaveElement) countdownSaveElement.textContent = countdownSave;
        if (autoSaveInterval) {
            clearInterval(autoSaveInterval);
            autoSaveInterval = null;
        }
        startCountdown();
    }

    timeInput.addEventListener('input', (e) => {
        manualTimeInput = true;
        let v = e.target.value.replace(/\D/g, '');
        let fV = '';
        if (v.length >= 2) fV = v.slice(0, 2);
        if (v.length > 2) fV += ':' + v.slice(2, 4);
        else if (v.length < 2) fV = v;
        e.target.value = fV;
        if (fV.match(/^\d{2}:\d{2}$/)) {
            const [h, m] = fV.split(':').map(Number);
            parseStatus.textContent = (h > 23 || m > 59) ? 'Hora invlida' : '';
            parseStatus.classList.toggle('text-red-600', h > 23 || m > 59);
            parseStatus.classList.remove('text-green-600');
        } else if (fV.length > 0) {
            parseStatus.textContent = 'Formato HH:MM';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        } else {
            parseStatus.textContent = '';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        }
        resetAndStartCountdown();
    });

    dateInput.addEventListener('input', (e) => {
        let v = e.target.value.replace(/\D/g, '');
        let fV = '';
        if (v.length >= 2) fV = v.slice(0, 2);
        if (v.length > 2) fV += '/' + v.slice(2, 4);
        if (v.length > 4) fV += '/' + v.slice(4, 8);
        else if (v.length < 2) fV = v;
        e.target.value = fV;
        if (fV.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
            const [d, m, y] = fV.split('/').map(Number);
            const dt = new Date(Date.UTC(y, m - 1, d));
            const ok = !isNaN(dt.getTime()) && dt.getUTCDate() === d && dt.getUTCMonth() + 1 === m && y >= 2000 && y <= 2099;
            parseStatus.textContent = ok ? '' : 'Fecha invlida';
            parseStatus.classList.toggle('text-red-600', !ok);
            parseStatus.classList.remove('text-green-600');
        } else if (fV.length > 0) {
            parseStatus.textContent = 'Formato DD/MM/AAAA';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        } else {
            parseStatus.textContent = '';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        }
        resetAndStartCountdown();
    });

    intervalInput.addEventListener('input', resetAndStartCountdown);
    modal.querySelectorAll('input[name="repeat"]').forEach(chk => chk.addEventListener('change', resetAndStartCountdown));
    autoSaveTimerLabel.style.display = 'block';
    if (countdownSaveElement) countdownSaveElement.textContent = countdownSave;

    function startFocusCheck() {
        if (restartTimeout) clearTimeout(restartTimeout);
        restartTimeout = setTimeout(() => {
            if (document.activeElement !== textInput && document.activeElement !== timeInput && document.activeElement !== dateInput && document.activeElement !== intervalInput && !Array.from(modal.querySelectorAll('input[name="repeat"]')).includes(document.activeElement) && document.activeElement !== speechButton && document.activeElement !== saveButton && document.activeElement !== modal.querySelector('#cancel-reminder') && document.activeElement !== modal.querySelector('#help-reminder') && document.activeElement !== clearButton && document.activeElement !== modal.querySelector('#view-reminders') && document.activeElement !== locationCheckbox && document.activeElement !== radiusThumb && document.activeElement !== expandMapButton && document.activeElement !== reduceMapButton && document.activeElement !== locateMeButton && !(reminderModalMap && reminderModalMap.getContainer().contains(document.activeElement))) {
                resetAndStartCountdown();
                restartTimeout = null;
            } else {
                restartTimeout = null;
            }
        }, 500);
    }

    resetAndStartCountdown();
    startFocusCheck();
    modal.addEventListener('input', resetAndStartCountdown);
    modal.addEventListener('click', resetAndStartCountdown);
    modal.addEventListener('touchstart', resetAndStartCountdown, { passive: true });
    modal.addEventListener('focusin', () => {
        resetAndStartCountdown();
        if (focusTimeout) clearTimeout(focusTimeout);
        focusTimeout = null;
    });
    modal.addEventListener('focusout', () => {
        if (!focusTimeout) {
            startFocusCheck();
        }
    });

    textInput.addEventListener('input', (e) => {
        lastInputWasSpeech = false;
        const txt = e.target.value || '';
        parseStatus.textContent = 'Parseando...';
        parseStatus.classList.remove('text-green-600', 'text-red-600');
        if (parseTimeout) clearTimeout(parseTimeout);
        parseTimeout = setTimeout(() => {
            if (!document.body.contains(modal)) return;
            try {
                const uiElements = {
                    timeInput: timeInput,
                    dateInput: dateInput,
                    intervalInput: intervalInput,
                    repeatCheckboxes: modal.querySelectorAll('input[name="repeat"]'),
                    locationCheckbox: locationCheckbox,
                    radiusInput: null, // Ya no usamos el input de radio
                    manualTimeInput: manualTimeInput,
                    mapExpandedManually: mapExpandedManually,
                    excludeFromListCheckbox: excludeFromListCheckbox
                };
                if (!manualTimeInput) uiElements.timeInput.value = '';
                uiElements.dateInput.value = '';
                uiElements.intervalInput.value = '';
                uiElements.repeatCheckboxes.forEach(chk => chk.checked = false);
                const pD = parseReminderText(txt, uiElements);
                
                // Actualizamos el slider con el radio parseado
                if(pD.radiusMeters) {
                    currentRadius = pD.radiusMeters;
                    updateRadiusVisuals();
                }

                if (isNew && (pD.type === 'weekly' || pD.type === 'interval')) {
                    const tempReminderForCalc = { type: pD.type, time: pD.time, date: pD.date, repeatDays: pD.repeatDays, intervalDays: pD.intervalDays };
                    const nowForCalc = new Date();
                    if (!tempReminderForCalc.date) tempReminderForCalc.date = `${nowForCalc.getFullYear()}-${(nowForCalc.getMonth() + 1).toString().padStart(2, '0')}-${nowForCalc.getDate().toString().padStart(2, '0')}`;
                    if (!tempReminderForCalc.time) tempReminderForCalc.time = '00:01';
                    const firstOcc = calculateNextOccurrence(tempReminderForCalc, new Date());
                    if (firstOcc) {
                        const firstOccISO = `${firstOcc.getUTCFullYear()}-${(firstOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOcc.getUTCDate().toString().padStart(2, '0')}`;
                        const firstOccTime = `${firstOcc.getUTCHours().toString().padStart(2, '0')}:${firstOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                        pD.date = firstOccISO;
                        pD.time = firstOccTime;
                        const datePartsCalc = pD.date.split('-');
                        if (datePartsCalc.length === 3) dateInput.value = `${datePartsCalc[2]}/${datePartsCalc[1]}/${datePartsCalc[0]}`;
                        if (!manualTimeInput) timeInput.value = pD.time;
                    } else {
                        if (!pD.date) { const today = new Date(); pD.date = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}-${today.getDate().toString().padStart(2, '0')}`; }
                        if (!pD.time) pD.time = '00:01';
                        const datePartsFb = pD.date.split('-');
                        if (datePartsFb.length === 3) dateInput.value = `${datePartsFb[2]}/${datePartsFb[1]}/${datePartsFb[0]}`;
                        if (!manualTimeInput) timeInput.value = pD.time;
                    }
                }
                parseStatus.textContent = 'Parseado OK';
                parseStatus.classList.add('text-green-600');
                parseStatus.classList.remove('text-red-600');
                handleLocationCheckboxChange();
            } catch (error) {
                parseStatus.textContent = `Error parse: ${error.message.substring(0, 100)}`;
                parseStatus.classList.add('text-red-600');
                parseStatus.classList.remove('text-green-600');
            }
            parseTimeout = null;
        }, 1000);
        resetAndStartCountdown();
    });

    saveButton.addEventListener('click', (e) => {
        e.preventDefault();
        const form = modal.querySelector('#reminder-form');
        if (form.checkValidity && !form.checkValidity()) {
            form.reportValidity();
            return;
        }
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        const mapContextToReopen = mapContextBeforeThisModal;
        const text = textInput.value.trim();
        if (!text) {
            parseStatus.textContent = 'Texto obligatorio.';
            parseStatus.classList.add('text-red-600');
            resetAndStartCountdown();
            return;
        }
        let time = timeInput.value.trim();
        let dateStr = dateInput.value.trim();
        const repeatDays = Array.from(modal.querySelectorAll('input[name="repeat"]:checked')).map(input => parseInt(input.value));
        const intervalDays = parseInt(intervalInput.value) || null;
        const isLocationChecked = locationCheckbox.checked;
        const radius = Math.round(currentRadius);
        const locationCoords = currentReminderLocation;
        const excludeFromListVal = excludeFromListCheckbox.checked;
        if (isLocationChecked && !locationCoords) {
            parseStatus.textContent = 'Ubicacin activada pero no fijada en el mapa.';
            parseStatus.classList.add('text-red-600');
            resetAndStartCountdown();
            return;
        }
        let dateISO = null;
        let finalTime = time;
        let reminderType = 'simple';
        if (dateStr) {
            if (dateStr.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                const [d, m, y] = dateStr.split('/').map(Number);
                const tD = new Date(Date.UTC(y, m - 1, d));
                if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() + 1 === m && y >= 2000 && y <= 2099) {
                    dateISO = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`;
                } else {
                    parseStatus.textContent = 'Fecha invlida'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return;
                }
            } else {
                parseStatus.textContent = 'Formato DD/MM/AAAA'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return;
            }
        }
        if (finalTime && !finalTime.match(/^\d{2}:\d{2}$/)) {
            parseStatus.textContent = 'Formato HH:MM'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return;
        } else if (finalTime) {
            const [h, m] = finalTime.split(':').map(Number);
            if (h > 23 || m > 59) {
                parseStatus.textContent = 'Hora invlida'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return;
            }
        }
        if (intervalDays !== null && intervalDays > 0) {
            reminderType = 'interval';
            if (!dateISO) { const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; }
            if (!finalTime) finalTime = '00:01';
        } else if (repeatDays.length > 0) {
            reminderType = 'weekly';
            if (!dateISO) {
                const tempCalc = { type: 'weekly', time: finalTime || '00:01', date: null, repeatDays: repeatDays, intervalDays: null };
                const firstOcc = calculateNextOccurrence(tempCalc, new Date());
                if (firstOcc) {
                    dateISO = `${firstOcc.getUTCFullYear()}-${(firstOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOcc.getUTCDate().toString().padStart(2, '0')}`;
                    finalTime = finalTime || `${firstOcc.getUTCHours().toString().padStart(2, '0')}:${firstOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                } else {
                    const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
                    if (!finalTime) finalTime = '00:01';
                }
            } else { if (!finalTime) finalTime = '00:01'; }
        } else if (dateISO && finalTime) {
            reminderType = 'daily';
        } else if (finalTime) {
            reminderType = 'daily';
            const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
        } else if (dateISO) {
            reminderType = 'daily';
            finalTime = '00:01';
        } else {
            reminderType = 'simple';
            const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
            finalTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
        }
        const now = new Date();
        const finalCreatedAt = isNew ? now.toISOString() : (parsed.createdAt || now.toISOString());
        let finalDateISO = dateISO;
        if (isNew && (reminderType === 'weekly' || reminderType === 'interval')) {
            let needsRecalc = false;
            if (!dateInput.value.trim()) { needsRecalc = true; } 
            else { try { const [d, m, y] = dateStr.split('/').map(Number); const inputDate = new Date(Date.UTC(y, m - 1, d)); const todayForCompare = new Date(now.getFullYear(), now.getMonth(), now.getDate()); if (inputDate < todayForCompare) { needsRecalc = true; } } catch (e) { needsRecalc = true; } }
            if (needsRecalc) {
                const tempCalcForNewCyclic = { type: reminderType, time: finalTime || '00:01', date: null, repeatDays: reminderType === 'weekly' ? repeatDays : [], intervalDays: reminderType === 'interval' ? intervalDays : null };
                const firstOccurrence = calculateNextOccurrence(tempCalcForNewCyclic, new Date());
                if (firstOccurrence) { finalDateISO = `${firstOccurrence.getUTCFullYear()}-${(firstOccurrence.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOccurrence.getUTCDate().toString().padStart(2, '0')}`; } 
                else { if (!finalDateISO) { finalDateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } }
            }
        }
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        const newReminder = {
            id: isNew ? Date.now() : parsed.id,
            text: `<b>${text.toUpperCase()}</b>`,
            type: reminderType,
            time: finalTime || null,
            date: finalDateISO,
            repeatDays: reminderType === 'weekly' ? repeatDays : [],
            intervalDays: reminderType === 'interval' ? intervalDays : null,
            createdAt: finalCreatedAt,
            managedByUser: false,
            isLocationEnabled: isLocationChecked,
            locationCoordinates: isLocationChecked ? locationCoords : null,
            radiusMeters: isLocationChecked ? radius : (parsed.radiusMeters || (text.toUpperCase().startsWith("RADAR:") ? 350 : DEFAULT_LOCATION_RADIUS)),
            excludeFromList: excludeFromListVal,
            isFromRuta: parsed.isFromRuta || false
        };
        if (!newReminder.date || !newReminder.time || !newReminder.createdAt) { showToast("Error GRAVE: Fechas/Hora invlidas al guardar", "error"); resetAndStartCountdown(); return; }
        if (!isNew) {
            const index = reminders.findIndex(r => r.id === parsed.id);
            if (index !== -1) { reminders[index] = newReminder; } 
            else { newReminder.id = Date.now() + Math.random(); reminders.push(newReminder); }
        } else { reminders.push(newReminder); }
        localStorage.setItem('reminders', JSON.stringify(reminders));
        markCacheAsDirty();
        showToast('Recordatorio guardado', 'success');
        destroyMap();
        if (modal.parentNode) modal.parentNode.removeChild(modal);
        updateReminderCount();
        updateButtonStyles();
        checkReminders();
        const unifiedWindowIsVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible');
        if (mapShouldReopen && !unifiedWindowIsVisible) {
            if (mapContextToReopen === 'navigation') openNavigationMap();
        } else if (mapShouldReopen && unifiedWindowIsVisible) {
             sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
             if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen);
        }
        sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
        sessionStorage.removeItem('mapContext');
    });

    modal.querySelector('#cancel-reminder').addEventListener('click', () => {
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        const mapContextToReopen = mapContextBeforeThisModal;
        destroyMap();
        if (modal.parentNode) modal.parentNode.removeChild(modal);
        if (mapShouldReopen) {
             if (mapContextToReopen === 'navigation') openNavigationMap();
        }
        sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
        sessionStorage.removeItem('mapContext');
    });

    modal.querySelector('#help-reminder').addEventListener('click', () => {
        showHelpModal({ parentContainer: modal }); 
    });

    clearButton.addEventListener('click', () => {
        textInput.value=''; timeInput.value=''; dateInput.value='';
        modal.querySelectorAll('input[name="repeat"]').forEach(i=>i.checked=false);
        intervalInput.value='';
        locationCheckbox.checked = false;
        // --- INICIO DE LA MODIFICACIN ---
        toggleRadiusVisibility(); // Asegurarse de que el slider se oculta al limpiar
        // --- FIN DE LA MODIFICACIN ---
        currentRadius = parsed.radiusMeters || DEFAULT_LOCATION_RADIUS;
        updateRadiusVisuals();
        currentReminderLocation = null;
        destroyMap();
        excludeFromListCheckbox.checked = false;
        parseStatus.textContent='';
        speechStatus.textContent='';
        manualTimeInput=false;
        resetAndStartCountdown();
        textInput.focus();
    });

    modal.querySelector('#view-reminders').addEventListener('click', () => {
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        const mapContextToReopen = mapContextBeforeThisModal;
        destroyMap();
        if (modal.parentNode) document.body.removeChild(modal);
        fromReminderModal = true;
        if (mapShouldReopen) {
            sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
            if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen);
        }
        showAllReminders({ parentContainer: document.getElementById('reminders-location-map-modal') }); 
    });
    
    textInput.focus();
}


    







    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: stopAutomatedRouteSimulation
    // RESUMEN: Detiene completamente el modo de simulacin y vuelve al GPS real.
    // ===================================================================
    function stopAutomatedRouteSimulation() {
        stopAutomatedRouteSimulationInternal();
        isSimulatingGpsLocation = false;
        const mapDiv = document.getElementById('reminders-location-map-div');
        if (mapDiv) {
            mapDiv.classList.remove('simulating-gps-click-mode');
        }
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) {
            simulateGpsButton.classList.remove('active-simulate-gps-mode');
            simulateGpsButton.title = "Activar Simulacin GPS (recorrido automtico o clic manual)";
        }
        startGpsWatching();
        setNavigationMapClickHandler();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: reactivateRealGpsAfterSimulation
    // RESUMEN: Reactiva el seguimiento del GPS real despus de una simulacin.
    // ===================================================================
    function reactivateRealGpsAfterSimulation() {
        if (locationWatchId === null && 'geolocation' in navigator && 'watchPosition' in navigator.geolocation) {
            locationWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    if (isSimulatingGpsLocation) return;
                    const coordsForUpdate = {
                         latitude: position.coords.latitude, longitude: position.coords.longitude,
                         accuracy: position.coords.accuracy, heading: position.coords.heading,
                         altitude: position.coords.altitude, speed: position.coords.speed
                    };
                    navigationCurrentLocation = coordsForUpdate;
                    updateInitialUserPosition(coordsForUpdate, navigationMapInstance);
                     if(isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
                        const routeForDistCalc = navigationCurrentRouteData.routes[0];
                        let carDistTurf = 0;
                        if (navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
                            try {
                                const carPointTurf = turf.point([coordsForUpdate.longitude, coordsForUpdate.latitude]);
                                const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                                const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                                const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                                carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                            } catch(e){
                            }
                        }
                        const totalRouteLength = routeForDistCalc.distance;
                         if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                            if (carDistTurf < lastCarDistanceAlongRouteForNavLogic - 100 && lastCarDistanceAlongRouteForNavLogic > 100) {
                            } else {
                                lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                            }
                        } else if (carDistTurf > totalRouteLength + 500) {
                            lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
                        }
                        updateTurnByTurnDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                        updateNavigationProgressDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                        console.log('Turf Log (reactivateRealGpsAfterSimulation):', {
                            lat: coordsForUpdate.latitude.toFixed(4),
                            lng: coordsForUpdate.longitude.toFixed(4),
                            speed: coordsForUpdate.speed ? coordsForUpdate.speed.toFixed(1) : 'N/A',
                            distanceAlongRoute: carDistTurf.toFixed(2)
                        });
                    }
                },
                (error) => {
                    showToast(`Error al reactivar GPS: ${error.message}`, "warning");
                },
                { enableHighAccuracy: true, timeout: 15000, maximumAge: 3000, distanceFilter: 3 }
            );
            getCurrentLocation(coords => {
                if (!isSimulatingGpsLocation) {
                    navigationCurrentLocation = coords;
                    updateInitialUserPosition(coords, navigationMapInstance);
                    if (isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
                        const routeForDistCalc = navigationCurrentRouteData.routes[0];
                        let carDistTurf = 0;
                         if (navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
                            try {
                                const carPointTurf = turf.point([coords.longitude, coords.latitude]);
                                const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                                const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                                const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                                carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                            } catch(e){
                            }
                         }
                        const totalRouteLength = routeForDistCalc.distance;
                         if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                            if (carDistTurf < lastCarDistanceAlongRouteForNavLogic - 100 && lastCarDistanceAlongRouteForNavLogic > 100) {
                            }
                            lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                        } else if (carDistTurf > totalRouteLength + 500) {
                            lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
                        }
                        updateTurnByTurnDisplay(routeForDistCalc, carDistTurf);
                        updateNavigationProgressDisplay(routeForDistCalc, carDistTurf);
                    }
                }
            });
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleAddReminderAtLocationMode
    // RESUMEN: Activa/desactiva el modo para aadir un recordatorio haciendo clic en el mapa.
    // ===================================================================
    function toggleAddReminderAtLocationMode() {
        isAddReminderAtLocationModeActive = !isAddReminderAtLocationModeActive;
        const mapDiv = document.getElementById('reminders-location-map-div');
        const button = document.getElementById('add-reminder-at-location-button');
        if (button) {
            if (isAddReminderAtLocationModeActive) {
                button.classList.add('active-reminder-mode');
                if (mapDiv) mapDiv.classList.add('add-reminder-mode');
                showToast("Modo 'Aadir Recordatorio en Mapa' ACTIVADO. Pulsa en el mapa para crear un recordatorio.", "info", 5000);
            } else {
                button.classList.remove('active-reminder-mode');
                if (mapDiv) mapDiv.classList.remove('add-reminder-mode');
                showToast("Modo 'Aadir Recordatorio en Mapa' DESACTIVADO.", "info");
            }
        }
        setNavigationMapClickHandler();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleMapClickToAddReminder
    // RESUMEN: Maneja el clic para aadir un recordatorio en el mapa.
    // ===================================================================
    function handleMapClickToAddReminder(e) {
        if (!isAddReminderAtLocationModeActive || !navigationMapInstance) return;
        const latlng = e.latlng;
        toggleAddReminderAtLocationMode(); 
        const mapContextBeforeModal = sessionStorage.getItem('mapContext');
        closeNavigationMap(true); 
        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
        if (mapContextBeforeModal) {
          sessionStorage.setItem('mapContext', mapContextBeforeModal);
        }
        showReminderModal({
            isLocationEnabled: true,
            locationCoordinates: { latitude: latlng.lat, longitude: latlng.lng },
            radiusMeters: DEFAULT_LOCATION_RADIUS,
            text: 'Recordatorio en mapa: ',
            excludeFromList: false
        });
    }
    
    
    
    
    
    



// ===================================================================
// NOMBRE: openNavigationMap
// RESUMEN: Abre y inicializa el mapa principal de navegacin.
// ===================================================================
function openNavigationMap() {
    const mainContent = document.querySelector('main');
    if (mainContent) mainContent.style.display = 'none';
    const footer = document.querySelector('footer');
    if (footer) footer.style.display = 'none';
    const noticesContainer = document.querySelector('.notices-icon-container');
    if (noticesContainer) noticesContainer.style.display = 'none';
    const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button');
    sideControls.forEach(el => el.style.display = 'none');
    document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button, #accident-alert-button').forEach(el => el.style.display = 'none');
    const gridFilter = document.getElementById('grid-filter-container');
    if (gridFilter) gridFilter.style.display = 'none';

    isNavigationMapActive = true;
    sessionStorage.setItem('mapContext', 'navigation');

    closeOtherModals('reminders-location-map-modal');
    
    const mapModal = document.createElement('div');
    mapModal.id = 'reminders-location-map-modal';
    mapModal.innerHTML = `
        <div id="toggle-map-header-buttons-panel">
             <img src="Coche_Sat.PNG" alt="Toggle Panel Mapa">
        </div>
        <div id="reminders-location-map-content-wrapper">
            <div id="reminders-location-map-header">
                 <div class="button-row">
                    <button id="close-reminders-location-map" class="reminders-map-button-action" title="Cerrar mapa y navegacin"><img src="SALIR.PNG" alt="Salir"></button>
                    <button id="locate-me-on-reminders-map" class="reminders-map-button-action" title="Mostrar mi posicin actual y activar seguimiento"><img src="ESTASAQUI.PNG" alt="Ests Aqu"></button>
                    <button id="nav-map-zoomtoggle-button" class="reminders-map-button-action" style="background-color: white;" data-zoom-state="waypoints" title="Alternar zoom entre vista de ruta y coche"><img src="ZOOM+.PNG" alt="Zoom" style="width:30px; height:30px;"></button>
                    <button id="start-navigation-button" class="reminders-map-button-action hidden" title="Iniciar/Terminar Navegacin"><img src="INICIARNAVEGACION.PNG" alt="Iniciar Navegacin"></button>
                    <button id="save-route-button" class="reminders-map-button-action hidden" title="Guardar Ruta Actual"><img src="GUARDARRUTA.PNG" alt="Guardar Ruta"></button>
                    <button id="load-saved-route-button" class="reminders-map-button-action" title="Cargar Ruta Guardada"><img src="CARGARRUTA.PNG" alt="Cargar Ruta"></button>
                    <button id="delete-current-route-button" class="reminders-map-button-action hidden" title="Borrar Ruta Actual del Mapa"><img src="BORRARRUTA.PNG" alt="Borrar Ruta"></button>
                    <button id="add-radar-here" class="reminders-map-button-action" title="Crear RADAR en mi posicin actual (radio 350m)"><img src="RADARAQUI.PNG" alt="Radar Aqu"></button>
                    <button id="accident-alert-button-map" class="reminders-map-button-action" title="Informar de una incidencia de trfico"><img src="https://boardinggate.github.io/Tesla/AACCIDENTE.png" alt="Informar Incidencia"></button>
                    <button id="pdrs-ruta-button" class="reminders-map-button-action" title="Buscar Puntos de Recarga en Ruta"><img src="pdrs.png" alt="PDRs"></button>
                     <div class="radares-ruta-control">
                        <input type="checkbox" id="radares-ruta-checkbox">
                        <div class="radares-ruta-label-container">
                            <label for="radares-ruta-checkbox">Radares<br>Ruta</label>
                            <span id="radares-ruta-count" class="hidden">0</span>
                        </div>
                    </div>
                    <div class="tareas-ruta-control">
                        <input type="checkbox" id="tareas-ruta-checkbox">
                        <div class="tareas-ruta-label-container">
                            <label for="tareas-ruta-checkbox">Tareas<br>Ruta</label>
                            <span id="tareas-ruta-count" class="hidden">0</span>
                        </div>
                    </div>
                    <button id="add-reminder-at-location-button" class="reminders-map-button-action" title="Aadir recordatorio en punto del mapa">
                        <img src="https://boardinggate.github.io/Tesla/IMG_4197.jpg" alt="Aadir Recordatorio">
                    </button>
                     <button id="toggle-simulate-gps-button" class="reminders-map-button-action" title="Activar/Desactivar Simulacin GPS (recorrido o clic)"><img src="GPS.PNG" alt="Simular Recorrido"></button>
                    <button id="simulate-route-button" class="reminders-map-button-action" title="Simular interacciones de ruta"><img src="SIMULAR.PNG" alt="Simular Ruta"></button>
                 </div>
                 <div class="button-row" id="search-row-map-header">
                    <button id="reorder-route-stages-button" title="Ordenar Etapas de Ruta"><img src="./MOVER.PNG" alt="Ordenar Etapas"></button>
                    <button id="map-location-search-button" class="reminders-map-button-action"><img src="./ANADIRPUNTO.PNG" alt="Aadir Punto Ruta"></button>
                    <button id="clear-map-search-input-button" title="Limpiar bsqueda">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="red" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    </button>
                    <input type="text" id="map-location-search-input" placeholder="Direccin,sitio,zona /Negocio /Ciudad /CP+Provincia (28001 Madrid /Lidl Lugo)">
                    <input type="text" id="filter-input" placeholder="Filtro"> 
                    <button id="navigation-map-help-button" class="reminders-map-button-action" title="Ayuda del mapa de navegacin/radares"><img src="IMG_4326.PNG" alt="Ayuda"></button>
                 </div>
            </div>
             <div id="reminders-location-map-div">
                <div id="leaflet-map-actual-container"></div>
                 <div id="map-info-overlay"></div>
                 <div id="navigation-bottom-progress-bar" style="display: none;">
                    <div style="flex-grow: 1; margin-left: 8px;">
                        <div id="navigation-top-info-bar">
                            <div id="turn-icon-container-styled">
                                <span id="turn-icon-display" class="turn-icon-display"></span>
                            </div>
                            <div class="maneuver-text-container">
                               <div>
                                   <span id="maneuver-text-display" class="maneuver-text"></span>
                                   <span id="street-name-display" class="street-name"></span>
                               </div>
                               <div id="distance-to-turn-formatted"></div>
                            </div>
                        </div>
                        <div id="distance-progress-bar-to-turn-container"> <div id="distance-progress-bar-to-turn"></div> </div>
                        <hr>
                        <div id="route-overall-progress-container">
                             <div id="route-overall-progress">
                                 <img id="route-progress-icon" src="AVANCE.PNG" alt="Avance" style="display:none;">
                                 <span id="route-progress-text"></span>
                             </div>
                        </div>
                        <div id="navigation-eta-info">
                            <div id="next-stage-info">
                                <strong>Prxima Etapa</strong>
                                <span id="next-stage-distance">-- km</span>  | 
                                <span id="next-stage-time">-- min</span>  |  ETA:
                                <span id="next-stage-eta">--:--</span>
                                <span id="next-stage-eta-deviation" class="eta-deviation"></span>
                            </div>
                            <div id="final-destination-info">
                                <strong> Final</strong>
                                <span id="final-destination-distance">-- km</span>  | 
                                <span id="final-destination-time">-- min</span>  |  ETA:
                                <span id="final-destination-eta">--:--</span>
                                <span id="final-destination-eta-deviation" class="eta-deviation"></span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(mapModal);

    const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresCheckbox) radaresCheckbox.checked = localStorage.getItem(RADARES_RUTA_CHECKED_KEY) === 'true';
    const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasCheckbox) tareasCheckbox.checked = localStorage.getItem(TAREAS_RUTA_CHECKED_KEY) === 'true';
    currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviacin ETA';

    toggleMapHeaderRowsVisibility(mapHeaderButtonsVisible);

    requestAnimationFrame(() => {
        const mapActualContainer = document.getElementById('leaflet-map-actual-container');
        if (!mapActualContainer) {
            isNavigationMapActive = false;
            sessionStorage.removeItem('mapContext');
            if (mapModal.parentNode) mapModal.remove();
            showToast("Error crtico: No se pudo crear el contenedor del mapa.", "error");
            return;
        }

        initDirectionWarningCards();
        assignMapButtonListeners();

        const mapLocationSearchInput = document.getElementById('map-location-search-input');
        const mapFilterInput = document.getElementById('filter-input');
        if (mapLocationSearchInput) mapLocationSearchInput.value = '';
        if (mapFilterInput) mapFilterInput.value = localStorage.getItem(MAP_FILTER_INPUT_KEY) || 'Espaa';
        if (mapLocationSearchInput) mapLocationSearchInput.dispatchEvent(new Event('input'));

        try {
            if (navigationMapInstance) navigationMapInstance.remove();
            if (mapLayersControl) mapLayersControl.remove();
            if (compassAndModeControl) compassAndModeControl.remove();

            navigationMapInstance = L.map(mapActualContainer, { zoomControl: false, attributionControl: false }).setView([40.416775, -3.703790], 6);
            
            L.control.attribution({ prefix: '<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>', position: 'bottomright' }).addTo(navigationMapInstance);

            const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: ' <a href="https://www.openstreetmap.org/copyright">OSM</a>' });
            const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles  Esri' });
            const satelliteWithLabels = L.layerGroup([
                L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles  Esri' }),
                L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', { attribution: ' OSM  CARTO', pane: 'labels' })
            ]);
            if (!navigationMapInstance.getPane('labels')) {
                navigationMapInstance.createPane('labels');
                navigationMapInstance.getPane('labels').style.zIndex = 650;
                navigationMapInstance.getPane('labels').style.pointerEvents = 'none';
            }
            const baseMaps = { "Mapa Normal": osmLayer, "Satlite Puro": satelliteLayer, "Satlite + Calles": satelliteWithLabels };
            const savedLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "Satlite + Calles";
            let initialLayer = baseMaps[savedLayerName] || satelliteWithLabels;
            initialLayer.addTo(navigationMapInstance);
            mapLayersControl = L.control.layers(baseMaps, null, { position: 'topright', collapsed: true }).addTo(navigationMapInstance);
            compassAndModeControl = L.control.compassAndMode({ position: 'bottomleft' }).addTo(navigationMapInstance);
            completedRouteSegmentsLayer = L.layerGroup().addTo(navigationMapInstance);
            maxSpeedMarkerLayer = L.layerGroup().addTo(navigationMapInstance);
            speedMilestoneLayer = L.layerGroup().addTo(navigationMapInstance);

            navigationMapInstance.on('baselayerchange', function(e) {
                localStorage.setItem(ACTIVE_MAP_LAYER_KEY, e.name);
                updateRouteAndCarIconStyle();
                updateNavigationGraphVisibilityAndMode();
            });

            navigationMapInstance.on('zoomend', () => {
                displayAlertsOnMap();
                renderWaypointMarkers();
                updateDirectionWarningCardsVisibility();
            });
            
            let centerAction = null;

            navigationMapInstance.on('load', function() {
                toggleMapHeaderRowsVisibility(mapHeaderButtonsVisible); 
                const loadingToast = document.getElementById("map-loading-toast");
                if (loadingToast) {
                    loadingToast.remove();
                    activeToasts = activeToasts.filter(t => t.id !== "map-loading-toast");
                }
                if(centerAction) {
                    centerAction();
                }
            });

            getCurrentLocation(
                (currentPos) => {
                    navigationCurrentLocation = currentPos;
                    updateInitialUserPosition(currentPos, navigationMapInstance);
                    const gpsCenterAction = () => {
                         if (navigationWaypoints.length === 0) {
                            navigationMapInstance.setView([currentPos.latitude, currentPos.longitude], 15);
                        }
                    };
                    if (navigationMapInstance._loaded) {
                        gpsCenterAction();
                    } else {
                        centerAction = gpsCenterAction;
                    }
                    startGpsWatching(); 
                },
                (errorMsg) => {
                    showToast("No se pudo obtener tu ubicacin actual. Algunas funciones pueden estar limitadas", "warning");
                    if (compassAndModeControl) { compassAndModeControl.updateOrientation(null); compassAndModeControl.updateAltitude(null); }
                    
                    const fallbackCenterAction = () => {
                        const remindersWithLocation = JSON.parse(localStorage.getItem('reminders') || '[]').filter(r => r.isLocationEnabled && r.locationCoordinates);
                        if (navigationWaypoints.length === 0 && remindersWithLocation.length > 0) {
                            const bounds = L.latLngBounds(remindersWithLocation.map(r => [r.locationCoordinates.latitude, r.locationCoordinates.longitude]));
                            if (bounds.isValid()) {
                                 navigationMapInstance.fitBounds(bounds.pad(0.15));
                            }
                        }
                    };

                    if (navigationMapInstance._loaded) {
                        fallbackCenterAction();
                    } else {
                        centerAction = fallbackCenterAction;
                    }
                    startGpsWatching(); 
                }
            );
            
            updateRouteAndCarIconStyle();
            plotRemindersOnNavigationMap();
            forceProcessTrafficAlerts();
            setNavigationMapClickHandler();
        } catch (error) {
             const errorContainer = document.getElementById('leaflet-map-actual-container') || mapActualContainer;
             if (errorContainer) errorContainer.innerHTML = `<p style="color:red; text-align:center; padding:20px;">Error al cargar el mapa: ${error.message}</p>`;
             isNavigationMapActive = false;
        }

        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        toggleMapLocationSearchVisibility(!isNavigating);
        actualizarContadorRadares(radaresEnRutaActual.length);
        actualizarContadorTareas(tareasEnRutaActual.length);
        updateNavigationGraphVisibilityAndMode();
    });
}




    

    


    
    // ===================================================================
// NOMBRE: assignMapButtonListeners
// RESUMEN: Asigna todos los listeners a los botones de accin del mapa de navegacin.
// ===================================================================
function assignMapButtonListeners() {
    const header = document.getElementById('reminders-location-map-header');
    const togglePanelButton = document.getElementById('toggle-map-header-buttons-panel');
    if (!header || !togglePanelButton) return;

    let swipeStartX = 0;
    let swipeStartY = 0;
    let isSwiping = false;
    let pressTimer = null;

    const handleGestureStart = (e) => {
        isSwiping = false;
        swipeStartX = e.touches ? e.touches[0].clientX : e.clientX;
        swipeStartY = e.touches ? e.touches[0].clientY : e.clientY;
        
        clearTimeout(pressTimer);
        pressTimer = setTimeout(() => {
            openAlertModal();
            swipeStartX = 0;
            swipeStartY = 0;
        }, 800);

        if(e.type === 'touchstart') e.preventDefault();
    };

    const handleGestureMove = (e) => {
        if (swipeStartX === 0) return;
        const moveX = e.touches ? e.touches[0].clientX : e.clientX;
        const moveY = e.touches ? e.touches[0].clientY : e.clientY;
        if (Math.abs(moveX - swipeStartX) > 10 || Math.abs(moveY - swipeStartY) > 10) {
            isSwiping = true;
            clearTimeout(pressTimer);
        }
    };

    const handleGestureEnd = (e) => {
        clearTimeout(pressTimer);
        if (swipeStartX === 0) return;

        const endX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
        const endY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
        const deltaX = endX - swipeStartX;
        const deltaY = endY - swipeStartY;
        const swipeThreshold = 50;

        if (!isSwiping) {
            toggleMapHeaderRowsVisibility(!mapHeaderButtonsVisible);
        } else {
            if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > swipeThreshold) {
                if (deltaY < 0) {
                    toggleNavigationState();
                } else {
                    loadRouteByName("TRABAJO", true);
                }
            } else if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > swipeThreshold) {
                if (deltaX < 0) {
                    toggleMapImmersiveMode();
                } else {
                    loadRouteByName("CASA", true);
                }
            }
        }
        
        swipeStartX = 0;
        swipeStartY = 0;
        isSwiping = false;
    };

    togglePanelButton.removeEventListener('mousedown', handleGestureStart);
    togglePanelButton.removeEventListener('mousemove', handleGestureMove);
    togglePanelButton.removeEventListener('mouseup', handleGestureEnd);
    togglePanelButton.removeEventListener('mouseleave', handleGestureEnd);
    togglePanelButton.removeEventListener('touchstart', handleGestureStart);
    togglePanelButton.removeEventListener('touchmove', handleGestureMove);
    togglePanelButton.removeEventListener('touchend', handleGestureEnd);
    togglePanelButton.addEventListener('mousedown', handleGestureStart);
    togglePanelButton.addEventListener('mousemove', handleGestureMove);
    togglePanelButton.addEventListener('mouseup', handleGestureEnd);
    togglePanelButton.addEventListener('mouseleave', handleGestureEnd);
    togglePanelButton.addEventListener('touchstart', handleGestureStart, { passive: false });
    togglePanelButton.addEventListener('touchmove', handleGestureMove, { passive: false });
    togglePanelButton.addEventListener('touchend', handleGestureEnd);
    header.addEventListener('click', (event) => {
        const button = event.target.closest('button');
        if (!button) return;
        if (button.id !== 'toggle-map-header-buttons-panel') {
            event.stopPropagation();
        }
        switch (button.id) {
            case 'close-reminders-location-map':
                closeNavigationMap(false);
                break;
            case 'locate-me-on-reminders-map':
                handleLocateMeClick(button);
                break;
            case 'nav-map-zoomtoggle-button':
                handleZoomToggleButtonClick(button);
                break;
            case 'start-navigation-button':
                toggleNavigationState();
                break;
            case 'save-route-button':
                saveCurrentRoute();
                break;
            case 'delete-current-route-button':
                handleLoadOrDeleteRouteClick(button);
                break;
            case 'load-saved-route-button':
                showLoadRouteModal();
                break;
            case 'add-radar-here':
                handleAddRadarHereClick(button);
                break;
            case 'accident-alert-button-map':
                openAlertModal();
                break;
            case 'pdrs-ruta-button':
                showPDRsFilterModal(); 
                break;
            case 'add-reminder-at-location-button':
                toggleAddReminderAtLocationMode();
                break;
            case 'toggle-simulate-gps-button':
                handleGpsSimulationToggle();
                break;
            case 'simulate-route-button':
                showSimulationModal();
                break;
            case 'reorder-route-stages-button':
                showReorderStagesModal();
                break;
            case 'navigation-map-help-button':
                showNavigationMapHelpModal();
                break;
            case 'map-location-search-button':
                const mapSearchInput = document.getElementById('map-location-search-input');
                const mapFilterInput = document.getElementById('filter-input');
                const mainTerm = mapSearchInput?.value.trim() || '';
                if (!mainTerm) {
                    showToast("El campo de bsqueda principal no puede estar vaco.", "warning");
                    return;
                }
                const filterTerm = mapFilterInput?.value.trim() || '';
                let combinedSearchTerm = mainTerm;
                if (filterTerm) {
                    combinedSearchTerm += ' ' + filterTerm;
                }
                searchAndAddWaypoint(combinedSearchTerm);
                break;
            case 'clear-map-search-input-button':
                const mapSearchInputToClear = document.getElementById('map-location-search-input');
                if (mapSearchInputToClear) {
                    mapSearchInputToClear.value = '';
                }
                mapSearchInputToClear?.dispatchEvent(new Event('input'));
                mapSearchInputToClear?.focus();
                hideAddressSuggestionsModal();
                break;
        }
    });
    document.getElementById('radares-ruta-checkbox')?.addEventListener('change', (e) => toggleRadaresRuta(e.target.checked));
    document.getElementById('tareas-ruta-checkbox')?.addEventListener('change', (e) => toggleTareasRuta(e.target.checked));
    const mapLocationSearchInput = document.getElementById('map-location-search-input');
    const mapFilterInput = document.getElementById('filter-input');
    if (mapLocationSearchInput) {
        let searchDebounceTimer;
        const handleSearchInput = () => {
            const hasMainText = mapLocationSearchInput.value.trim() !== '';
            document.getElementById('map-location-search-button').style.display = hasMainText ? 'inline-flex' : 'none';
            document.getElementById('clear-map-search-input-button').style.display = hasMainText ? 'inline-flex' : 'none';
            clearTimeout(searchDebounceTimer);
            const mainTerm = mapLocationSearchInput.value.trim();
            if (mainTerm) {
                const filterTerm = mapFilterInput.value.trim();
                let combinedSearchTerm = mainTerm;
                if (filterTerm) {
                    combinedSearchTerm += ' ' + filterTerm;
                }
                searchDebounceTimer = setTimeout(() => fetchAddressSuggestions(combinedSearchTerm), 300);
            } else {
                hideAddressSuggestionsModal();
            }
            localStorage.setItem(MAP_FILTER_INPUT_KEY, mapFilterInput.value);
        };
        mapLocationSearchInput.addEventListener('input', handleSearchInput);
        if (mapFilterInput) {
            mapFilterInput.addEventListener('input', handleSearchInput);
        }
        mapLocationSearchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                const mainTerm = mapLocationSearchInput.value.trim();
                if (!mainTerm) {
                    showToast("El campo de bsqueda principal no puede estar vaco.", "warning");
                    return;
                }
                const filterTerm = mapFilterInput?.value.trim() || '';
                let combinedSearchTerm = mainTerm;
                if (filterTerm) {
                    combinedSearchTerm += ' ' + filterTerm;
                }
                hideAddressSuggestionsModal();
                searchAndAddWaypoint(combinedSearchTerm);
            }
        });
    }
    document.getElementById('turn-icon-container-styled')?.addEventListener('click', (event) => {
        event.stopPropagation();
        if (navigationCurrentRouteData?.routes?.[0]) {
            const route = navigationCurrentRouteData.routes[0];
            const currentLeg = route.legs?.[currentLegIndexNav];
            let nextStep = null;
            if (currentLeg && currentStepIndexNav + 1 < currentLeg.steps.length) {
                nextStep = currentLeg.steps[currentStepIndexNav + 1];
            } else if (route.legs && currentLegIndexNav + 1 < route.legs.length) {
                nextStep = route.legs[currentLegIndexNav + 1].steps[0];
            } else {
                nextStep = currentLeg?.steps?.[currentStepIndexNav];
            }
            if (nextStep) {
                showIntersectionPreviewMap(nextStep, route, true, 7000);
            } else {
                showToast("No hay maniobra siguiente para mostrar detalle.", "info");
            }
        }
    });
}







    

    
    


// ===================================================================
// NOMBRE: handlePDRsResponse
// RESUMEN: Funcin de callback que recibe los datos de los PDRs desde el script JSONP.
// ===================================================================
function handlePDRsResponse(data) {
    console.log("handlePDRsResponse: Respuesta recibida del servidor!", data);
    
    // Limpiar el script inyectado una vez ha cumplido su misin
    const jsonpScript = document.getElementById('pdrs-jsonp-script');
    if (jsonpScript) {
        jsonpScript.remove();
    }

    const existingToast = document.getElementById("pdrs-search");
    if (existingToast) existingToast.remove();

    if (data.error) {
        console.error("El servidor devolvi un error:", data.error);
        showToast(`Error al buscar PDRs: ${data.error}`, "error");
        return;
    }

    if (data.points && Array.isArray(data.points)) {
        currentChargingPointsOnRoute = data.points;
        showToast(`${currentChargingPointsOnRoute.length} puntos de recarga encontrados en ruta.`, "success");
        displayChargingPointsOnMap();
    } else {
        console.error("La respuesta del servidor no tiene el formato esperado.");
        showToast("Respuesta del servidor invlida.", "error");
    }
}
    


// ===================================================================
// NOMBRE: displayChargingPointsOnMap
// RESUMEN: Dibuja las tarjetas de los puntos de recarga encontrados sobre el mapa.
// ===================================================================
function displayChargingPointsOnMap() {
    if (!navigationMapInstance) return;

    if (chargingPointsLayer) {
        chargingPointsLayer.clearLayers();
    } else {
        chargingPointsLayer = L.layerGroup().addTo(navigationMapInstance);
    }

    currentChargingPointsOnRoute.forEach((point, index) => {
        const displayNameText = point.displayName.length > 22 ? point.displayName.substring(0, 20) + '...' : point.displayName;
        const totalPointsText = `${point.numPoints} Poste${point.numPoints !== 1 ? 's' : ''}`;
        
        const cardHtml = `
            <div class="charging-point-card">
                <p class="operator">${displayNameText}</p>
                <p class="power">${point.power} kW${point.priceForCard}</p>
                <p class="availability">${totalPointsText}</p>
            </div>
        `;

        const icon = L.divIcon({
            html: cardHtml,
            className: '',
            iconSize: null, 
            iconAnchor: [80, 0]
        });

        const marker = L.marker([point.lat, point.lon], { icon: icon, zIndexOffset: 900 }).addTo(chargingPointsLayer);
        marker.on('click', () => showChargingPointDetails(point, index));
    });
}





    // ===================================================================
// NOMBRE: addChargingPointToRoute
// RESUMEN: Aade un PDR como etapa y limpia los dems del mapa.
// ===================================================================
async function addChargingPointToRoute(pointIndex) {
    const point = currentChargingPointsOnRoute[pointIndex];
    if (!point) return;

    let lastVisitedIndex = -1;
    navigationWaypoints.forEach((wp, index) => {
        if (wp.visited) {
            lastVisitedIndex = index;
        }
    });
    
    const insertIndex = lastVisitedIndex + 1;
    const newWaypoint = {
        id: Date.now(),
        lat: point.lat,
        lng: point.lon,
        type: '', 
        marker: null,
        label: '',
        address: point.address || 'Punto de Recarga',
        visited: false,
        isCriticalForRecalc: true,
        isInternal: false,
        isRecalculatedStart: false
    };

    navigationWaypoints.splice(insertIndex, 0, newWaypoint);
    updateWaypointTypesAndLabels();
    renderWaypointMarkers();
    showToast(`'${newWaypoint.address}' aadido a la ruta. Recalculando...`, "success");

    try {
        await recalculateAndDrawRoute();
        
        // --- INICIO DE LA CORRECCIN ---
        // Una vez la ruta est recalculada, limpiamos los puntos de recarga temporales.
        clearChargingPoints();
        // --- FIN DE LA CORRECCIN ---

        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
            toggleRadaresRuta(true);
        }
    } catch (e) {
        showToast("Error recalculando la ruta tras aadir el punto de recarga.", "error");
    }

    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}



    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: calculateDistanceToEndOfStep
    // RESUMEN: Calcula la distancia acumulada hasta el final de un paso especfico de la ruta.
    // ===================================================================
    function calculateDistanceToEndOfStep(route, targetLegIndex, targetStepIndex) {
        let totalDistance = 0;
        if (!route || !route.legs) return 0;
        for (let legIdx = 0; legIdx <= targetLegIndex; legIdx++) {
            const leg = route.legs[legIdx];
            if (!leg || !leg.steps) continue;
            const limitStepIndex = (legIdx === targetLegIndex) ? targetStepIndex : leg.steps.length - 1;
            for (let stepIdx = 0; stepIdx <= limitStepIndex; stepIdx++) {
                const step = leg.steps[stepIdx];
                if (step && typeof step.distance === 'number') {
                    totalDistance += step.distance;
                }
            }
        }
        return totalDistance;
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: plotRemindersOnNavigationMap
    // RESUMEN: Dibuja todos los recordatorios con ubicacin en el mapa de navegacin.
    // ===================================================================
    function plotRemindersOnNavigationMap() {
        if (!navigationMapInstance) return;
        reminderMapObjects.forEach(obj => {
            if (obj.marker && navigationMapInstance.hasLayer(obj.marker)) obj.marker.remove();
            if (obj.circle && navigationMapInstance.hasLayer(obj.circle)) obj.circle.remove();
        });
        reminderMapObjects = [];
        const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        const remindersWithLocation = reminders.filter(r => r.isLocationEnabled && r.locationCoordinates?.latitude && r.locationCoordinates?.longitude && !r.isFromRuta);
        remindersWithLocation.forEach(reminder => {
            const mapObject = plotSingleReminderOnMap(reminder, navigationMapInstance);
            if (mapObject) reminderMapObjects.push(mapObject);
        });
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: plotSingleReminderOnMap
    // RESUMEN: Dibuja un nico recordatorio (marcador y crculo) en un mapa.
    // ===================================================================
    function plotSingleReminderOnMap(reminder, mapInstance) {
        if (!mapInstance || !reminder.isLocationEnabled || !reminder.locationCoordinates) return null;
        const latLng = [reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude];
        const isRadarType = reminder.text.toUpperCase().includes("RADAR:") || reminder.excludeFromList;
        let markerIconToUse;
        let circleColor, circleFillColor, circleFillOpacity, circleWeight;
        if (isRadarType) {
            markerIconToUse = smallRadarMarkerIcon;
            circleColor = '#f1d7ff';
            circleFillColor = '#f1d7ff';
            circleFillOpacity = 0.25;
            circleWeight = 0.5;
        } else {
            markerIconToUse = largeGreenLocationMarkerIcon;
            circleColor = '#c7eb7a';
            circleFillColor = '#c7eb7a';
            circleFillOpacity = 0.35;
            circleWeight = 0.5;
        }
        const marker = L.marker(latLng, { icon: markerIconToUse, title: reminder.text.replace(/<[^>]*>/g, '').substring(0, 50) }).addTo(mapInstance);
        const circle = L.circle(latLng, { radius: reminder.radiusMeters || DEFAULT_LOCATION_RADIUS, color: circleColor, fillColor: circleFillColor, weight: circleWeight, fillOpacity: circleFillOpacity }).addTo(mapInstance);
        let popupContent = ` <div style="max-width: 250px; font-family: sans-serif; font-size: 0.9rem;"> <strong style="font-size: 1rem; color: #333; display: block; margin-bottom: 5px;">${reminder.text.replace(/<b>|<\/b>/gi,'')}</strong> <hr style="margin: 4px 0;"> ${reminder.time ? `<p style="margin: 3px 0;"><strong>Hora:</strong> ${formatTimeWithPeriod(reminder.time)}</p>` : ''} ${reminder.date ? `<p style="margin: 3px 0;"><strong>Fecha:</strong> ${formatDateDetailed(reminder.date)}</p>` : ''} <p style="margin: 3px 0;"><strong>Radio (si es por ubicacion):</strong> ${reminder.radiusMeters || DEFAULT_LOCATION_RADIUS}m</p> <button data-reminder-id="${reminder.id}" class="modify-reminder-from-map" style="margin-top: 8px; padding: 4px 8px; font-size: 0.8rem; background-color: #10B981; color: white; border: none; border-radius: 3px; cursor: pointer;">Modificar</button> </div>`;
        marker.bindPopup(popupContent);
        marker.on('popupopen', () => {
            const modifyButton = marker.getPopup().getElement().querySelector('.modify-reminder-from-map');
            if (modifyButton) {
                const newModifyButton = modifyButton.cloneNode(true); modifyButton.parentNode.replaceChild(newModifyButton, modifyButton);
                newModifyButton.addEventListener('click', (e) => {
                    const id = parseInt(e.target.dataset.reminderId);
                    let remToMod = null;
                    if (!isNaN(id)) {
                        const rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                        remToMod = rems.find(r => r.id === id);
                    }
                    if (!remToMod && reminder) {
                        remToMod = {...reminder};
                        if (typeof remToMod.id !== 'number') remToMod.id = null;
                    }
                    if (remToMod) {
                        const mapContextBeforeModal = sessionStorage.getItem('mapContext');
                        closeNavigationMap(true);
                        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                        if (mapContextBeforeModal) {
                            sessionStorage.setItem('mapContext', mapContextBeforeModal);
                        }
                        showReminderModal(remToMod);
                    } else {
                        showToast("Error: No se pudo encontrar el recordatorio para modificar", "error");
                    }
                });
            }
        });
        return { reminderId: reminder.id, marker, circle, isFromRuta: reminder.isFromRuta || false };
    }
    
    
    
    
    
    
    


// ===================================================================
// NOMBRE: showNavigationMapHelpModal
// RESUMEN: Muestra el modal de ayuda especfico para el mapa de navegacin.
// ===================================================================
function showNavigationMapHelpModal() {
    const existingHelpModal = document.getElementById('reminders-map-help-modal-instance');
    if (existingHelpModal) {
        clearModalAutoCloseTimer(existingHelpModal, existingHelpModal.querySelector('#close-reminders-map-help-instance'), 'reminders-map-help-modal-instance');
        existingHelpModal.remove();
    }

    const helpModal = document.createElement('div');
    helpModal.id = 'reminders-map-help-modal-instance';
    helpModal.className = 'help-modal';
    helpModal.setAttribute('aria-label', 'Ayuda Mapa de Navegacin/Radares');
    
    helpModal.innerHTML = `
        <h2 class="text-xl font-bold mb-4">Ayuda del Mapa de Navegacin y Ubicaciones</h2>
        <div class="modal-top-buttons" style="justify-content: flex-end;">
            <button type="button" id="close-reminders-map-help-instance" style="flex: 0 1 auto; min-width: 120px;">Entendido</button>
        </div>
        <p class="mb-2">Este mapa permite ver recordatorios con ubicacin y planificar/seguir rutas GPS.</p>
        
        <h3 class="font-semibold text-lg mt-3 mb-1">Controles Principales:</h3>
        <ul class="list-disc pl-5 space-y-1 text-sm">
            <li><strong>Botn de Alerta de Trfico <img src="https://boardinggate.github.io/Tesla/AACCIDENTE.png" alt="Alerta" style="height:1.2em; display:inline; vertical-align:middle;">:</strong> Pulsa este botn para abrir un men y notificar una incidencia (accidente, obras, etc.) en tu ubicacin actual. La alerta ser visible para otros usuarios.</li>
            <li><strong>Botn Lateral <img src="Coche_Sat.PNG" alt="Toggle Panel Mapa" style="height:1.2em; display:inline; vertical-align:middle; background:rgba(128,128,128,0.3); border-radius:50%; padding:2px;"> :</strong> Este botn tiene mltiples funciones gestuales:
                <ul>
                    <li><strong>Clic Simple:</strong> Muestra/Oculta la barra de botones superior.</li>
                    <li><strong>Pulsacin Larga:</strong> Abre el men de Alertas de Trfico.</li>
                    <li><strong>Deslizar hacia ARRIBA:</strong> Inicia o detiene la navegacin de la ruta actual.</li>
                    <li><strong>Deslizar hacia ABAJO:</strong> Carga y navega a la ruta "TRABAJO".</li>
                    <li><strong>Deslizar a la DERECHA:</strong> Carga y navega a la ruta "CASA".</li>
                    <li><strong>Deslizar a la IZQUIERDA:</strong> Activa/Desactiva el modo inmersivo (solo mapa).</li>
                </ul>
             </li>
        </ul>

        <h3 class="font-semibold text-lg mt-3 mb-1">Planificacin de Ruta:</h3>
        <ul class="list-disc pl-5 space-y-1 text-sm">
            <li><strong>Aadir Puntos Manualmente:</strong> Pulsa en el mapa para aadir puntos de ruta (Salida, Fin, Etapas).</li>
            <li><strong>Aadir Puntos por Bsqueda:</strong> Utiliza el campo de texto <img src="./IMG_4400.png" alt="Campo bsqueda" style="height:1.2em; display:inline; vertical-align:middle;"> y pulsa <img src="./ANADIRPUNTO.PNG" alt="Aadir punto" style="height:1.2em; display:inline; vertical-align:middle;">.</li>
            <li><strong>Reordenar Etapas:</strong> Pulsa el botn <img src="./MOVER.PNG" alt="Ordenar etapas" style="height:1.2em; display:inline; vertical-align:middle;"> para abrir la ventana de reordenacin.</li>
            <li><strong>Eliminar Punto:</strong> Pulsa el aspa (X) roja en un marcador de etapa.</li>
        </ul>

        <h3 class="font-semibold text-lg mt-3 mb-1">Durante la Navegacin:</h3>
         <ul class="list-disc pl-5 space-y-1 text-sm">
            <li><strong>Barra de Progreso (superior izquierda):</strong> Muestra indicaciones, ETA, etc. <strong>Pulsa el ICONO DE GIRO para ver un mapa detallado de la maniobra.</strong></li>
            <li><strong>Radares/Tareas en Ruta:</strong> Activa los checkboxes para ver en el mapa y en la barra de progreso los radares o tus tareas personales que se encuentren en la ruta.</li>
             <li><strong>Simular Recorrido <img src="./GPS.PNG" alt="Simular Recorrido" style="height:1.2em; display:inline; vertical-align:middle;">:</strong> Activa para que el coche recorra la ruta automticamente.</li>
        </ul>
    `;

    const mapModal = document.getElementById('reminders-location-map-modal');
    if (mapModal) {
        mapModal.style.zIndex = 6400;
    }

    document.body.appendChild(helpModal); 
    
    const closeButtonHelp = helpModal.querySelector('#close-reminders-map-help-instance');
    
    const closeHandlerHelp = () => { 
        clearModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance'); 
        if (helpModal.parentNode) {
            helpModal.parentNode.removeChild(helpModal); 
        }
        if (mapModal) {
            mapModal.style.zIndex = '';
        }
    };
    
    closeButtonHelp.addEventListener('click', closeHandlerHelp); 
    addModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance', 90000);
}

    

    
    
    
    
    
    
    
    // ===================================================================
// NOMBRE: addWaypoint
// RESUMEN: Aade un punto de ruta al array de waypoints y actualiza el mapa.
// ===================================================================
async function addWaypoint(latlng, displayName = null) {
    if (!navigationMapInstance || isNavigating) return;

    let address = displayName;
    if (!address) {
        // Si no tenemos un nombre, lo buscamos. 'await' es clave aqu.
        address = await getAddressForWaypoint(latlng.lat, latlng.lng);
    }

    const newWaypoint = {
        id: Date.now(),
        lat: latlng.lat,
        lng: latlng.lng,
        type: '', // Se determinar en updateWaypointTypesAndLabels
        marker: null,
        label: '', // Se determinar en updateWaypointTypesAndLabels
        address: address, // Guardamos la direccin resuelta
        visited: false,
        isCriticalForRecalc: true,
        isInternal: false,
        isRecalculatedStart: false
    };

    if (navigationWaypoints.length === 0 && navigationCurrentLocation) {
        const startPoint = {
            id: Date.now() - 1,
            lat: navigationCurrentLocation.latitude,
            lng: navigationCurrentLocation.longitude,
            type: 'S',
            marker: null,
            label: 'S',
            address: 'Posicin Actual (GPS)',
            visited: true,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false
        };
        navigationWaypoints.push(startPoint);
    }

    navigationWaypoints.push(newWaypoint);
    updateWaypointTypesAndLabels();
    renderWaypointMarkers();

    // El reclculo ahora siempre funcionar con waypoints que tienen direccin
    try {
        await recalculateAndDrawRoute();
        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
            toggleRadaresRuta(true);
        }
        const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
            toggleTareasRuta(true);
        }
    } catch (e) {
        showToast("Error recalculando la ruta tras aadir el punto.", "error");
    }

    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}
    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: formatPhotonFeatureName
    // RESUMEN: Formatea el nombre de una ubicacin obtenida del servicio Photon.
    // ===================================================================
    function formatPhotonFeatureName(feature) {
        if (!feature || !feature.properties) return "Ubicacin desconocida";
        const props = feature.properties;
        let nameParts = [];
        if (props.name) nameParts.push(props.name);
        if (props.street) { let streetPart = props.street; if (props.housenumber) streetPart += ` ${props.housenumber}`; nameParts.push(streetPart); }
        if (props.postcode) nameParts.push(props.postcode);
        if (props.city && (!props.name || props.name.toLowerCase() !== props.city.toLowerCase())) nameParts.push(props.city);
        else if (props.county && (!props.name || props.name.toLowerCase() !== props.county.toLowerCase())) nameParts.push(props.county);
        else if (props.state && (!props.name || props.name.toLowerCase() !== props.state.toLowerCase())) nameParts.push(props.state);
        if (props.country && nameParts.length > 0 && props.country.toLowerCase() !== nameParts[nameParts.length - 1].toLowerCase()) nameParts.push(props.country);
        else if (props.country && nameParts.length === 0) nameParts = [props.country];
        let formattedName = nameParts.filter((value, index, self) => self.map(v => v.toLowerCase()).indexOf(value.toLowerCase()) === index).join(', ');
        if (!formattedName && feature.geometry && feature.geometry.coordinates) { formattedName = `(${feature.geometry.coordinates[1].toFixed(4)}, ${feature.geometry.coordinates[0].toFixed(4)})`; }
        return formattedName || "Ubicacin desconocida";
    }
    
    
    
    
    
   
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: fetchAddressSuggestions
    // RESUMEN: Obtiene sugerencias de direcciones mientras el usuario escribe.
    // ===================================================================
    async function fetchAddressSuggestions(query) {
        if (!query || query.length < 3) {
            hideAddressSuggestionsModal();
            return;
        }
        try {
            let queryToSearch = query;
            if (typeof queryToSearch === 'string') {
                queryToSearch = queryToSearch.replace(/,/g, '');
            }
            const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(queryToSearch)}&limit=60&accept-language=es&addressdetails=1`;
            const response = await fetch(url);
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Error de red: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            if (data && data.length > 0) {
                const results = data.map(item => {
                    if (item.lat && item.lon) {
                        return {
                            display_name: item.display_name || "Ubicacin desconocida",
                            lat: parseFloat(item.lat),
                            lon: parseFloat(item.lon)
                        };
                    }
                    return null;
                }).filter(Boolean);
                if (results.length === 0) {
                     hideAddressSuggestionsModal();
                     if (query.length >=3 && !searchToastShown) {
                        searchToastShown = true;
                        showToast("Bsqueda de palabras tecleadas no encontradas... (de todas las palabras, da igual el orden)", "error not-found", 3000);
                        setTimeout(() => { searchToastShown = false; }, 3500);
                     }
                     return;
                }
                displayAddressSuggestionsModal(results.slice(0, 60));
            } else {
                hideAddressSuggestionsModal();
                if (query.length >=3 && !searchToastShown) {
                    searchToastShown = true;
                    showToast("Bsqueda de palabras tecleadas no encontradas... (de todas las palabras, da igual el orden)", "error not-found", 3000);
                    setTimeout(() => { searchToastShown = false; }, 3500);
                }
            }
        } catch (error) {
            showToast(`Error buscando sugerencias: ${error.message}`, "error");
            hideAddressSuggestionsModal();
        }
    }
    
    
    
    
    





// ===================================================================
// NOMBRE: snapCoordsToRoad (NUEVA FUNCIN)
// RESUMEN: Toma coordenadas y devuelve las coordenadas del punto ms cercano en la red de carreteras.
// ===================================================================
async function snapCoordsToRoad(lat, lon) {
    try {
        const nearestUrl = `${OSRM_SERVICE_URL}/nearest/v1/driving/${lon},${lat}?number=1`;
        const nearestResponse = await fetch(nearestUrl);
        if (!nearestResponse.ok) {
            console.warn(`OSRM /nearest fall, se usarn coordenadas originales.`);
            return L.latLng(lat, lon);
        }
        const nearestData = await nearestResponse.json();
        if (nearestData.code === "Ok" && nearestData.waypoints && nearestData.waypoints.length > 0) {
            const snappedCoords = nearestData.waypoints[0].location;
            // OSRM devuelve [longitude, latitude]
            return L.latLng(snappedCoords[1], snappedCoords[0]);
        } else {
            console.warn("OSRM /nearest no encontr un punto vlido, se usarn coordenadas originales.");
            return L.latLng(lat, lon);
        }
    } catch (error) {
        console.error("Error en snapCoordsToRoad:", error);
        return L.latLng(lat, lon); // Devuelve las originales como fallback
    }
}

// ===================================================================
// NOMBRE: searchAndAddWaypoint (MODIFICADA)
// RESUMEN: Busca una direccin, la transforma en coordenadas, las ajusta a la carretera y la aade como waypoint.
// ===================================================================
async function searchAndAddWaypoint(addressQuery = null) {
    const searchInput = document.getElementById('map-location-search-input');
    const address = addressQuery || searchInput.value.trim();
    if (!address) {
        showToast("Por favor, introduce una direccin para buscar", "warning");
        return;
    }

    const searchButton = document.getElementById('map-location-search-button');
    if (searchButton) {
        searchButton.disabled = true;
        searchButton.innerHTML = `<img src="BUSCANDO.PNG" alt="Buscando...">`;
    }

    try {
        showToast("Buscando direccin...", "info", 3000);
        const searchUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address.replace(/,/g, ''))}&limit=1&accept-language=es&addressdetails=1`;
        
        const searchResponse = await fetch(searchUrl);
        if (!searchResponse.ok) throw new Error(`Error de red en Nominatim: ${searchResponse.status}`);
        
        const searchData = await searchResponse.json();
        if (!searchData || searchData.length === 0) throw new Error("Direccin no encontrada");
        
        const result = searchData[0];
        const initialLat = parseFloat(result.lat);
        const initialLon = parseFloat(result.lon);
        const displayName = result.display_name || `Ubicacin (${initialLat.toFixed(3)}, ${initialLon.toFixed(3)})`;
        if (isNaN(initialLat) || isNaN(initialLon)) throw new Error("Coordenadas no vlidas de Nominatim");

        showToast("Ajustando a la carretera ms cercana...", "info", 3000);
        const snappedLatLng = await snapCoordsToRoad(initialLat, initialLon);
        
        await addWaypoint(snappedLatLng, displayName);
        
        if (navigationMapInstance) navigationMapInstance.setView(L.latLng(initialLat, initialLon), 15);
        if (searchInput) {
            searchInput.value = '';
            searchInput.dispatchEvent(new Event('input'));
        }
        showToast("Ubicacin aadida a la ruta", "success");

    } catch (error) {
        showToast(`Error al buscar direccin: ${error.message}`, "error", 4000, true);
    } finally {
        if (searchButton) {
            searchButton.disabled = false;
            searchButton.innerHTML = `<img src="ANADIRPUNTO.PNG" alt="Aadir Punto Ruta">`;
            if (searchInput && searchInput.value.trim() === '') {
                searchButton.style.display = 'none';
                const clearMapSearchBtn = document.getElementById('clear-map-search-input-button');
                if (clearMapSearchBtn) clearMapSearchBtn.style.display = 'none';
            }
        }
    }
}

// ===================================================================
// NOMBRE: displayAddressSuggestionsModal (MODIFICADA)
// RESUMEN: Muestra el modal con la lista de sugerencias de direcciones.
// ===================================================================
function displayAddressSuggestionsModal(suggestions) {
    const searchInput = document.getElementById('map-location-search-input');
    if (!searchInput) return;
    const modalId = 'address-suggestions-modal';
    closeOtherModals(modalId);
    let modal = document.getElementById(modalId);
    if (suggestions.length === 0) {
        hideAddressSuggestionsModal();
        return;
    }
    if (!modal) {
        modal = document.createElement('div');
        modal.id = modalId;
        modal.className = 'address-suggestions-modal';
        modal.innerHTML = `
            <h2 id="address-suggestions-title"></h2>
            <ul id="address-suggestions-list"></ul>
            <div class="modal-top-buttons" style="justify-content: flex-end; margin-top: 1rem;">
                <button id="close-address-suggestions-modal" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
            </div>
        `;
        document.body.appendChild(modal);
        const closeButton = modal.querySelector('#close-address-suggestions-modal');
        closeButton.addEventListener('click', hideAddressSuggestionsModal);
    }
    const titleElement = modal.querySelector('#address-suggestions-title');
    const listElement = modal.querySelector('#address-suggestions-list');
    const closeButton = modal.querySelector('#close-address-suggestions-modal');
    titleElement.textContent = `${suggestions.length} coincidencia${suggestions.length !== 1 ? 's' : ''} encontrada${suggestions.length !== 1 ? 's' : ''}`;
    listElement.innerHTML = '';
    suggestions.forEach(suggestion => {
        const li = document.createElement('li');
        li.textContent = suggestion.display_name;
        li.dataset.lat = suggestion.lat;
        li.dataset.lon = suggestion.lon;
        
        // --- LGICA DE CLIC CORREGIDA ---
        li.addEventListener('click', async () => {
            const lat = parseFloat(li.dataset.lat);
            const lon = parseFloat(li.dataset.lon);
            const displayName = li.textContent;
            
            if (isNaN(lat) || isNaN(lon)) {
                showToast("Error: Coordenadas de sugerencia no vlidas.", "error");
                return;
            }

            hideAddressSuggestionsModal();
            showToast("Ajustando a la carretera ms cercana...", "info", 3000);
            
            const snappedLatLng = await snapCoordsToRoad(lat, lon);
            await addWaypoint(snappedLatLng, displayName);

            if (navigationMapInstance) navigationMapInstance.setView(L.latLng(lat, lon), 15);
            if (searchInput) {
                searchInput.value = '';
                searchInput.dispatchEvent(new Event('input'));
            }
            showToast("Ubicacin aadida a la ruta", "success");
        });
        // --- FIN DE LA CORRECCIN ---

        listElement.appendChild(li);
    });
    const searchInputRect = searchInput.getBoundingClientRect();
    modal.style.top = `${searchInputRect.bottom + 5}px`;
    const viewportHeight = window.innerHeight;
    const modalTop = searchInputRect.bottom + 5;
    const availableHeight = viewportHeight - modalTop - 20;
    modal.style.maxHeight = `${availableHeight}px`;
    const titleHeight = titleElement.offsetHeight;
    const buttonsHeight = modal.querySelector('.modal-top-buttons').offsetHeight;
    const listMaxHeight = availableHeight - titleHeight - buttonsHeight - 30;
    listElement.style.maxHeight = `${Math.max(100, listMaxHeight)}px`;
    modal.classList.remove('hidden');
    addModalAutoCloseTimer(modal, closeButton, 'address-suggestions-modal', 30000);
}
    
    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: hideAddressSuggestionsModal
    // RESUMEN: Oculta el modal de sugerencias de direcciones.
    // ===================================================================
    function hideAddressSuggestionsModal() {
        const modal = document.getElementById('address-suggestions-modal');
        if (modal && !modal.classList.contains('hidden')) {
            clearModalAutoCloseTimer(modal, modal.querySelector('#close-address-suggestions-modal'), 'address-suggestions-modal');
            modal.classList.add('hidden');
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleMapLocationSearchVisibility
    // RESUMEN: Muestra u oculta la fila de bsqueda del mapa.
    // ===================================================================
    function toggleMapLocationSearchVisibility(show) {
        const searchRow = document.getElementById('search-row-map-header');
        const reorderButton = document.getElementById('reorder-route-stages-button');
        if (show) {
            if (searchRow) searchRow.style.display = 'flex';
            if (reorderButton && navigationWaypoints.length >= 2) reorderButton.style.display = 'inline-flex';
            else if (reorderButton) reorderButton.style.display = 'none';
        } else {
            if (searchRow) searchRow.style.display = 'none';
            if (reorderButton) reorderButton.style.display = 'none';
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getAddressForWaypoint
    // RESUMEN: Obtiene la direccin de un punto de ruta usando geocodificacin inversa.
    // ===================================================================
    async function getAddressForWaypoint(lat, lng) {
        if (typeof lat !== 'number' || typeof lng !== 'number' || isNaN(lat) || isNaN(lng)) {
            return "Ubicacin Desconocida";
        }
        try {
            const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=0&accept-language=es`);
            if (response.ok) {
                const data = await response.json();
                return data.display_name || `(${lat.toFixed(3)}, ${lng.toFixed(3)})`;
            } else {
                return `Etapa (${lat.toFixed(3)}, ${lng.toFixed(3)})`;
            }
        } catch (err) {
            return `Etapa (${lat.toFixed(3)}, ${lng.toFixed(3)})`;
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateWaypointTypesAndLabels
    // RESUMEN: Actualiza los tipos (inicio/fin/intermedio) y etiquetas de los puntos de ruta.
    // ===================================================================
    function updateWaypointTypesAndLabels() {
        const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
        if (actualWaypoints.length === 0) return;
        actualWaypoints.forEach(async (wp, index) => {
            if (!wp) return;
            if (actualWaypoints.length === 1) {
                wp.type = 'S';
                wp.label = 'S';
            } else if (index === 0) {
                wp.type = 'S';
                wp.label = 'S';
            } else if (index === actualWaypoints.length - 1) {
                wp.type = 'F';
                wp.label = 'F';
            } else {
                wp.type = 'intermediate';
                wp.label = String(index);
            }
            if (!wp.address) {
                if (typeof wp.lat === 'number' && typeof wp.lng === 'number') {
                     getAddressForWaypoint(wp.lat, wp.lng).then(addr => {
                        wp.address = addr;
                        if (wp.marker && wp.marker.getPopup()) {
                        }
                    });
                } else {
                    wp.address = "Coordenadas no disponibles para direccin";
                }
            }
        });
        navigationWaypoints.forEach(wp => {
            if(wp && (wp.isInternal || wp.isRecalculatedStart)) {
                wp.label = '';
            }
        });
    }
    
    
    
    
    
    
   // ===================================================================
// NOMBRE: createWaypointMarkerIcon
// RESUMEN: Crea un icono de marcador de punto de ruta personalizado.
// ===================================================================
function createWaypointMarkerIcon(label, type, visited, currentZoomLevel = null) {
    let className = 'navigation-waypoint-marker';
    let visitedStyle = '';
    if (visited) {
        visitedStyle = 'background-color: #888 !important; opacity: 0.7; border: 2px solid #555;';
    } else {
        if (type === 'S' || type === 'S_Recalc') {
            className += ' start-point';
        } else if (type === 'F') {
            className += ' finish-point';
        } else {
            className += ' intermediate-point';
        }
    }

    let baseIconSize = [35, 35]; // Original: [30, 30] -> 30 * 1.15  34.5 -> 35
    let baseFontSize = 16;       // Original: 14 -> 14 * 1.15  16.1 -> 16
    let baseDeleteButtonSize = [21, 21]; // Original: [18, 18] -> 18 * 1.15  20.7 -> 21
    let baseDeleteButtonFontSize = 16;   // Original: 14 -> 14 * 1.15  16.1 -> 16
    let baseDeleteButtonOffset = [-10, -10]; // Original: [-8, -8] -> -8 * 1.15  -9.2 -> -10
 
    let scale = 1;
    let iconSize = [Math.round(baseIconSize[0] * scale), Math.round(baseIconSize[1] * scale)];
    let fontSize = Math.round((baseFontSize * scale) * 10) / 10;
    let deleteButtonSize = [Math.round(baseDeleteButtonSize[0] * scale), Math.round(baseDeleteButtonSize[1] * scale)];
    let deleteButtonFontSize = Math.round(baseDeleteButtonFontSize * scale);
    let deleteButtonOffsetTop = Math.round(baseDeleteButtonOffset[0] * scale);
    let deleteButtonOffsetRight = Math.round(baseDeleteButtonOffset[1] * scale);
    let iconAnchor = [iconSize[0] / 2, iconSize[1] / 2];
    const showDelete = type !== 'S_Recalc';
    const iconHtml = `<div class="${className}" style="width: ${iconSize[0]}px; height: ${iconSize[1]}px; font-size: ${fontSize}px; line-height: ${iconSize[1]}px; ${visitedStyle}">
            ${label}
            ${showDelete ? `<div class="waypoint-delete-button" title="Eliminar este punto" style="width: ${deleteButtonSize[0]}px; height: ${deleteButtonSize[1]}px; font-size: ${deleteButtonFontSize}px; line-height: ${deleteButtonSize[1]}px; top: ${deleteButtonOffsetTop}px; right: ${deleteButtonOffsetRight}px;"></div>` : ''}
        </div>`;
    return L.divIcon({
        html: iconHtml,
        className: '',
        iconSize: iconSize,
        iconAnchor: iconAnchor
    });
} 
    
    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getRouteForSingleLeg
    // RESUMEN: Obtiene la distancia y duracin de un solo tramo de ruta.
    // ===================================================================
    async function getRouteForSingleLeg(lon1, lat1, lon2, lat2) {
        const url = `${OSRM_SERVICE_URL}/driving/${lon1},${lat1};${lon2},${lat2}?overview=false&alternatives=false&steps=false&annotations=false`;
        try {
            const response = await fetch(url);
            if (!response.ok) {
                return { distance: 0, duration: 0 };
            }
            const data = await response.json();
            if (data.routes && data.routes.length > 0 && data.routes[0]) {
                return {
                    distance: data.routes[0].distance || 0,
                    duration: data.routes[0].duration || 0
                };
            }
            return { distance: 0, duration: 0 };
        } catch (error) {
            return { distance: 0, duration: 0 };
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: clearAllWaypointMarkersFromMap
    // RESUMEN: Elimina todos los marcadores de puntos de ruta del mapa.
    // ===================================================================
    function clearAllWaypointMarkersFromMap() {
        if (!navigationMapInstance) {
            navigationWaypoints.forEach(wp => { wp.marker = null; }); 
            return;
        }
        navigationWaypoints.forEach(wp => {
            if (wp && wp.marker) {
                try {
                    if (navigationMapInstance.hasLayer(wp.marker)) {
                        navigationMapInstance.removeLayer(wp.marker);
                    }
                } catch (e) {
                }
                wp.marker = null;
            }
        });
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: renderWaypointMarkers
    // RESUMEN: Dibuja o redibuja todos los marcadores de puntos de ruta en el mapa.
    // ===================================================================
    function renderWaypointMarkers() {
        if (!navigationMapInstance) return;
        clearAllWaypointMarkersFromMap();
        const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
        actualWaypoints.forEach(async (wp) => {
            if (!wp) return;
            const waypointIcon = createWaypointMarkerIcon(wp.label, wp.type, wp.visited, null);
            wp.marker = L.marker([wp.lat, wp.lng], {
                icon: waypointIcon,
                draggable: !isNavigating,
                zIndexOffset: 1001
            });
            try {
                wp.marker.addTo(navigationMapInstance);
            } catch(e) {
                 return;
            }
            const markerElement = wp.marker.getElement();
            if (markerElement) {
                const deleteButton = markerElement.querySelector('.waypoint-delete-button');
                if (deleteButton) {
                    L.DomEvent.on(deleteButton, 'click', function(ev) {
                        L.DomEvent.stopPropagation(ev);
                        handleDeleteWaypointClick(wp.id);
                    });
                }
            }
            let popupContent = `<strong>Punto ${wp.label}</strong><br>Cargando datos...`;
            const popup = L.popup({ maxWidth: 250, autoPanPadding: L.point(50, 50), closeButton: true }).setContent(popupContent);
            wp.marker.bindPopup(popup);
            wp.marker.on('click', async (e) => {
                if (!navigationMapInstance) return;
                const waypoint = navigationWaypoints.find(w => w && w.id === wp.id);
                if (!waypoint) return;
                let address = waypoint.address || "Calculando direccin...";
                if (!waypoint.address) {
                     if (typeof waypoint.lat === 'number' && typeof waypoint.lng === 'number') {
                        waypoint.address = await getAddressForWaypoint(waypoint.lat, waypoint.lng);
                     } else {
                        waypoint.address = "Coordenadas no disponibles para direccin";
                     }
                     address = waypoint.address;
                }
                let distanceToWaypoint = 0;
                let timeToWaypoint = 0;
                let etaToWaypoint = "--:--";
                const currentCarPosForPopup = navigationCurrentLocation;
                const currentActualWaypointsForPopup = navigationWaypoints.filter(w => w && !w.isInternal && !w.isRecalculatedStart);
                const actualWaypointIndexInRoute = currentActualWaypointsForPopup.findIndex(awp => awp.id === wp.id);
                if (currentCarPosForPopup && navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
                    const route = navigationCurrentRouteData.routes[0];
                    let cumulativeDistanceToThisWp = 0;
                    let cumulativeDurationToThisWp = 0;
                    if (actualWaypointIndexInRoute === 0) {
                        if (isNavigating) {
                            distanceToWaypoint = 0;
                            timeToWaypoint = 0;
                        } else {
                             if (typeof waypoint.lat === 'number' && typeof waypoint.lng === 'number') {
                                const tempRouteToS = await getRouteForSingleLeg(currentCarPosForPopup.longitude, currentCarPosForPopup.latitude, waypoint.lng, waypoint.lat);
                                if (tempRouteToS) {
                                    distanceToWaypoint = tempRouteToS.distance;
                                    timeToWaypoint = tempRouteToS.duration;
                                }
                            }
                        }
                    } else if (actualWaypointIndexInRoute > 0) {
                        for (let i = 0; i < actualWaypointIndexInRoute && i < route.legs.length; i++) {
                            if (route.legs[i]) {
                               cumulativeDistanceToThisWp += (route.legs[i].distance || 0);
                               cumulativeDurationToThisWp += (route.legs[i].duration || 0);
                            }
                        }
                        distanceToWaypoint = cumulativeDistanceToThisWp;
                        timeToWaypoint = cumulativeDurationToThisWp;
                        if (isNavigating && navigationMapInstance && typeof L.GeometryUtil !== 'undefined' && L.GeometryUtil) {
                            let distanceCoveredOnRoute = lastCarDistanceAlongRouteForNavLogic;
                            distanceToWaypoint = Math.max(0, cumulativeDistanceToThisWp - distanceCoveredOnRoute);
                            if (route.distance && route.distance > 0) {
                                timeToWaypoint = route.duration * (distanceToWaypoint / route.distance);
                            } else {
                                timeToWaypoint = 0;
                            }
                        }
                    }
                     if (typeof timeToWaypoint === 'number' && !isNaN(timeToWaypoint)) {
                        etaToWaypoint = new Date(Date.now() + timeToWaypoint * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    }
                } else if (currentCarPosForPopup) {
                     if (typeof waypoint.lat === 'number' && typeof waypoint.lng === 'number') {
                        const tempRoute = await getRouteForSingleLeg(currentCarPosForPopup.longitude, currentCarPosForPopup.latitude, waypoint.lng, waypoint.lat);
                        if (tempRoute) {
                            distanceToWaypoint = tempRoute.distance;
                            timeToWaypoint = tempRoute.duration;
                            if (typeof timeToWaypoint === 'number' && !isNaN(timeToWaypoint)) {
                               etaToWaypoint = new Date(Date.now() + timeToWaypoint * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                            }
                        }
                    }
                }
                let distanciaTexto = "-- km";
                if (typeof distanceToWaypoint === 'number' && !isNaN(distanceToWaypoint)) {
                    distanciaTexto = `${(distanceToWaypoint / 1000).toFixed(1)} km`;
                }
                let tiempoTexto = "--:--";
                if (typeof timeToWaypoint === 'number' && !isNaN(timeToWaypoint)) {
                    const waypointTotalMinutes = Math.round(timeToWaypoint / 60);
                    const waypointHours = Math.floor(waypointTotalMinutes / 60);
                    const waypointMinutes = waypointTotalMinutes % 60;
                    tiempoTexto = `${String(waypointHours).padStart(2, '0')}:${String(waypointMinutes).padStart(2, '0')}`;
                }
                const showDeleteButtonInPopup = waypoint.type !== 'S_Recalc';
                const finalPopupContent = `
                    <div style="font-family: sans-serif; font-size: 0.9rem; max-width: 230px;">
                        <strong style="font-size: 1rem; color: #333; display: block; margin-bottom: 3px;">Punto ${waypoint.label}: ${address || 'Direccin no disponible'}</strong>
                        <hr style="margin: 3px 0;">
                        <p style="margin: 2px 0;"><strong>Distancia:</strong> ${distanciaTexto}</p>
                        <p style="margin: 2px 0;"><strong>Tiempo:</strong> ${tiempoTexto}</p>
                        <p style="margin: 2px 0;"><strong>Llegada (ETA):</strong> ${etaToWaypoint || '--:--'}</p>
                        ${showDeleteButtonInPopup ? `<button data-waypoint-id="${waypoint.id}" class="delete-waypoint-from-popup" style="margin-top: 8px; padding: 4px 8px; font-size: 0.8rem; background-color: #EF4444; color: white; border: none; border-radius: 3px; cursor: pointer;">BORRAR PUNTO</button>` : ''}
                    </div>`;
                popup.setContent(finalPopupContent).update();
                const deleteButtonPopup = popup.getElement().querySelector('.delete-waypoint-from-popup');
                if (deleteButtonPopup) {
                    L.DomEvent.on(deleteButtonPopup, 'click', function(ev) {
                        L.DomEvent.stopPropagation(ev);
                        const wpIdToDelete = parseInt(this.dataset.waypointId);
                        if (!isNaN(wpIdToDelete)) {
                             if(popup.isOpen()) popup.remove();
                             handleDeleteWaypointClick(wpIdToDelete);
                        }
                    });
                }
            });
            wp.marker.on('dragstart', function() {
                if (isNavigating) return;
                if(this.isPopupOpen()) this.closePopup();
            });
            wp.marker.on('dragend', function(event) {
                if (isNavigating) return;
                const newLatLng = event.target.getLatLng();
                wp.lat = newLatLng.lat;
                wp.lng = newLatLng.lng;
                wp.address = '';
                recalculateAndDrawRoute().then(() => {
                    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
                    if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                        toggleRadaresRuta(true);
                    }
                    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
                    if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                        toggleTareasRuta(true);
                    }
                });
            });
        });
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleDeleteWaypointClick
    // RESUMEN: Elimina un punto de ruta de la ruta actual.
    // ===================================================================
    function handleDeleteWaypointClick(waypointId) {
        if (isNavigating) {
            showToast("No se pueden borrar puntos mientras se navega.", "warning");
            return;
        }
        const waypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
        if (waypointIndex === -1) {
            return;
        }
        const waypointToDelete = navigationWaypoints[waypointIndex];
        if (waypointToDelete.marker && navigationMapInstance) {
            try { navigationMapInstance.removeLayer(waypointToDelete.marker); } catch (e) {}
            waypointToDelete.marker = null;
        }
        navigationWaypoints.splice(waypointIndex, 1);
        if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 1) { 
            clearAllWaypointMarkersFromMap(); 
            navigationWaypoints = [];
            if (navigationRouteLayer && navigationMapInstance) {
                try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch (e) {}
                navigationRouteLayer = null;
            }
            if (completedRouteSegmentsLayer && navigationMapInstance ) completedRouteSegmentsLayer.clearLayers();
            navigationCurrentRouteData = null;
            hideNavigationUI();
            hideMapInfoOverlay();
            const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
            if (radaresRutaCheckbox) {
                eliminarRadaresDeRuta();
                actualizarContadorRadares(0);
                localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked)); 
            }
             const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
            if (tareasRutaCheckbox) {
                eliminarTareasDeBarraProgreso();
                actualizarContadorTareas(0);
                localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
            }
        } else {
            updateWaypointTypesAndLabels();
            renderWaypointMarkers();
            if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
                if (navigationRouteLayer && navigationMapInstance) {
                    try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch (e) {}
                    navigationRouteLayer = null;
                }
                 if (completedRouteSegmentsLayer && navigationMapInstance ) completedRouteSegmentsLayer.clearLayers();
                navigationCurrentRouteData = null;
                hideMapInfoOverlay();
                 const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
                if (radaresRutaCheckbox) {
                    eliminarRadaresDeRuta();
                    actualizarContadorRadares(0);
                    localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked));
                }
                const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
                if (tareasRutaCheckbox) {
                    eliminarTareasDeBarraProgreso();
                    actualizarContadorTareas(0);
                    localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
                }
            } else {
                recalculateAndDrawRoute().then(() => {
                    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
                    if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                        toggleRadaresRuta(true);
                    }
                    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
                    if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                        toggleTareasRuta(true);
                    }
                });
            }
            showToast("Etapa eliminada.", "info");
        }
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: drawRouteOnMap
    // RESUMEN: Dibuja la geometra de la ruta en el mapa.
    // ===================================================================
    function drawRouteOnMap(route) {
        if (!navigationMapInstance) return;
        if (navigationRouteLayer) {
            try {
                navigationMapInstance.removeLayer(navigationRouteLayer);
            } catch(e) {
            }
            navigationRouteLayer = null;
        }
        if (!route || !route.geometry || !route.geometry.coordinates || route.geometry.coordinates.length < 2) {
            showToast("Geometra de ruta invlida para dibujar.", "warning");
            navigationRouteLayer = null;
            return;
        }
        const routeCoords = route.geometry.coordinates.map(coord => [coord[1], coord[0]]);
        navigationRouteLayer = L.polyline(routeCoords, {
            color: 'yellow',
            weight: 10,
            opacity: 1.0
        }).addTo(navigationMapInstance);
        if (navigationMapInstance.attributionControl) {
             navigationMapInstance.attributionControl.addAttribution('Rutas  <a href="http://project-osrm.org/">OSRM</a>');
        }
    }
    
    
    
    
    
    
    
    
    
// ===================================================================
// NOMBRE: clearChargingPoints
// RESUMEN: Elimina del mapa y de la memoria los puntos de recarga temporales.
// ===================================================================
function clearChargingPoints() {
    currentChargingPointsOnRoute = [];
    if (chargingPointsLayer) {
        chargingPointsLayer.clearLayers();
    }
}



    
    


// ===================================================================
// NOMBRE: showChargingPointDetails
// RESUMEN: Muestra el popup con informacin detallada de un PDR y oculta otros.
// ===================================================================
function showChargingPointDetails(point, index) {
    if (chargingPointsLayer) {
        chargingPointsLayer.eachLayer(layer => {
            if (layer.getLatLng().lat !== point.lat || layer.getLatLng().lng !== point.lon) {
                chargingPointsLayer.removeLayer(layer);
            }
        });
    }

    // Funcin para obtener el texto y color del estado del conector
    const getStatusInfo = (statusType) => {
        if (!statusType) return { text: 'Desconocido', color: '#808080' };
        switch (statusType.ID) {
            case 50: return { text: 'Operativo', color: '#28a745' };
            case 75: return { text: 'Ocupado (Parcial)', color: '#ffc107' }; // Puede que algunos conectores estn en uso
            case 100: return { text: 'Ocupado', color: '#dc3545' };
            case 200: return { text: 'Fuera de Servicio', color: '#6c757d' };
            default: return { text: statusType.Title || 'Desconocido', color: '#808080' };
        }
    };
    
    let connectionsListHtml = '<h4>Conectores:</h4><ul class="ocm-connection-list">';
    if (point.connections && point.connections.length > 0) {
        point.connections.forEach(conn => {
            const status = getStatusInfo(conn.StatusType);
            // CORREGIDO: Extrae el ttulo del tipo de conector de forma segura
            const connectionTitle = conn.ConnectionType ? conn.ConnectionType.Title.replace(' (Socket)', '').replace(' (Connector)', '') : 'Desconocido';
            
            connectionsListHtml += `
                <li>
                    <span class="conn-type">${connectionTitle}</span>
                    <span class="conn-power">${conn.PowerKW ? conn.PowerKW.toFixed(0) + ' kW' : ''}</span>
                    <span class="conn-status" style="background-color:${status.color};">${status.text}</span>
                </li>`;
        });
    } else {
        connectionsListHtml += '<li>No hay informacin detallada de conectores.</li>';
    }
    connectionsListHtml += '</ul>';

    const popupContent = `
        <div class="charging-point-popup">
            <h3>${point.address}</h3>
            <p><strong>Operador:</strong> ${point.operator}</p>
            <p><strong>Precio:</strong> ${point.fullPriceInfo}</p>
            ${connectionsListHtml}
            <div class="popup-buttons">
                <button class="add-to-route-btn" data-index="${index}">Aadir a la Ruta</button>
                <button class="cancel-btn">Cancelar</button>
            </div>
        </div>
    `;

    const popup = L.popup({ maxWidth: 320 })
        .setLatLng([point.lat, point.lon])
        .setContent(popupContent)
        .openOn(navigationMapInstance);
        
    popup.on('remove', () => {
        displayChargingPointsOnMap();
    });

    popup.getElement().querySelector('.cancel-btn').addEventListener('click', () => {
        navigationMapInstance.closePopup();
    });

    popup.getElement().querySelector('.add-to-route-btn').addEventListener('click', (e) => {
        const pointIndex = parseInt(e.target.dataset.index);
        addChargingPointToRoute(pointIndex);
        navigationMapInstance.closePopup();
    });
}    

    
    
    
    
    
    
    


  // ===================================================================
// NOMBRE: recalculateAndDrawRoute
// RESUMEN: Solicita una nueva ruta a OSRM basada en los puntos de ruta actuales y la redibuja.
// ===================================================================
async function recalculateAndDrawRoute(preserveAccumulatedStats = false) {
    isRecalculatingRoute = true;
    lastAutoShownManeuverId = null; // <-- CORRECCIN AADIDA AQU

    if (preserveAccumulatedStats) {
        // Al desviarse, guardamos la distancia real recorrida hasta ahora.
        accumulatedDistanceBeforeCurrentSegment = totalDistanceTravelledForStats;
    } else {
        isArrivalSequenceStarted = false;
        accumulatedDistanceBeforeCurrentSegment = 0;
        totalDistanceTravelledForStats = 0;
        maxDistanceReachedOnRoute = 0;
        lastPositionForStats = null;
        if (isNavigating) navigationStartTimeForStats = new Date();
        tripInitialOverallEtaTime = null;
        currentStageInitialExpectedEtaTime = null;
        accumulatedDeviationMs = 0;
        maxSpeedDuringTrip = 0;
        maxSpeedCoordinates = null;
        maxAltitudeDuringTrip = -Infinity;
        minAltitudeDuringTrip = Infinity;
        if (compassAndModeControl) {
            compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip);
        }
    }

    const recalculateToastId = "recalculating-route-toast";
    showToast("Recalculando ruta...", "info", 0, false, recalculateToastId);
    
    lastCarDistanceAlongRouteForNavLogic = 0;
    lastValidCarDistanceForDisplay = 0;

    let waypointsForRouteCalculation = [];
    if (navigationCurrentLocation) {
        const currentPositionAsWaypoint = { lat: navigationCurrentLocation.latitude, lng: navigationCurrentLocation.longitude };
        waypointsForRouteCalculation.push(currentPositionAsWaypoint);
    } else {
        const firstUnvisited = navigationWaypoints.find(wp => wp && !wp.visited);
        if (firstUnvisited) {
            waypointsForRouteCalculation.push(firstUnvisited);
        }
    }
    const remainingWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.visited);
    waypointsForRouteCalculation.push(...remainingWaypoints);

    if (waypointsForRouteCalculation.length < 2) {
        const existingRecalcToast = document.getElementById(recalculateToastId);
        if (existingRecalcToast) existingRecalcToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== recalculateToastId);
        showToast("No hay suficientes etapas restantes para calcular una nueva ruta.", "warning");
        if (navigationRouteLayer && navigationMapInstance) { try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch (e) {} navigationRouteLayer = null; }
        if (completedRouteSegmentsLayer && navigationMapInstance ) completedRouteSegmentsLayer.clearLayers();
        navigationCurrentRouteData = null;
        hideMapInfoOverlay();
        isRecalculatingRoute = false;
        return;
    }

    const coordsString = waypointsForRouteCalculation.map(wp => {
        if (typeof wp.lng !== 'number' || typeof wp.lat !== 'number' || isNaN(wp.lng) || isNaN(wp.lat) ) return null;
        return `${wp.lng},${wp.lat}`;
    }).filter(Boolean).join(';');

    if (!coordsString || waypointsForRouteCalculation.filter(wp => wp && typeof wp.lng === 'number' && typeof wp.lat === 'number').length < 2) {
        const existingRecalcToast = document.getElementById(recalculateToastId);
        if (existingRecalcToast) existingRecalcToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== recalculateToastId);
        showToast("No hay suficientes waypoints vlidos para calcular la ruta.", "warning");
        if (navigationRouteLayer && navigationMapInstance) { try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch (e) {} navigationRouteLayer = null; }
        if (completedRouteSegmentsLayer && navigationMapInstance ) completedRouteSegmentsLayer.clearLayers();
        navigationCurrentRouteData = null;
        hideMapInfoOverlay();
        isRecalculatingRoute = false;
        recalculationAttempts = 0;
        if (recalculationRetryTimeoutId) clearTimeout(recalculationRetryTimeoutId);
        recalculationRetryTimeoutId = null;
        updateStartNavigationButtonState();
        return;
    }

    const url = `${OSRM_SERVICE_URL}/driving/${coordsString}?overview=full&geometries=geojson&steps=true&alternatives=false&annotations=true`;
    try {
        const response = await fetch(url);
        if (!response.ok) {
            let errorData = { message: `HTTP error ${response.status}` };
            try { errorData = await response.json(); } catch (e) { errorData.message = response.statusText || errorData.message; }
            throw new Error(`OSRM Error: ${errorData.code || errorData.message || response.statusText}`);
        }
        const data = await response.json();
        const existingRecalcToastSuccess = document.getElementById(recalculateToastId);
        if (existingRecalcToastSuccess) existingRecalcToastSuccess.remove();
        activeToasts = activeToasts.filter(t => t.id !== recalculateToastId);

        if (data.routes && data.routes.length > 0) {
            navigationCurrentRouteData = data;
            if (completedRouteSegmentsLayer && navigationMapInstance ) completedRouteSegmentsLayer.clearLayers();
            drawRouteOnMap(data.routes[0]);
            currentLegIndexNav = 0;
            currentStepIndexNav = 0;
            lastProcessedStepManeuverLocation = null;
            
            if (preserveAccumulatedStats && data.routes[0]) {
                // Reiniciar la base del ETA para el nuevo tramo.
                tripInitialOverallEtaTime = new Date(Date.now() + (data.routes[0].duration * 1000));
                if (data.routes[0].legs && data.routes[0].legs.length > 0) {
                     currentStageInitialExpectedEtaTime = new Date(Date.now() + (data.routes[0].legs[0].duration * 1000));
                }
            }

            if (data.routes[0]) {
                 const currentCarPosForRecalc = navigationCurrentLocation;
                 let carDistanceAlongRouteForInternalUse = 0;
                 if (currentCarPosForRecalc && navigationMapInstance && navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
                    try {
                        const carPointTurf = turf.point([currentCarPosForRecalc.longitude, currentCarPosForRecalc.latitude]);
                        const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                        const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                        const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                        carDistanceAlongRouteForInternalUse = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                    } catch (turfError) {}
                 }
                 lastCarDistanceAlongRouteForNavLogic = carDistanceAlongRouteForInternalUse;
                 updateNavigationProgressDisplay(data.routes[0], carDistanceAlongRouteForInternalUse);
                 updateTurnByTurnDisplay(data.routes[0], carDistanceAlongRouteForInternalUse);
                 showDestinationName();
            }
            showNavigationUIElementsForPlanning();
            recalculationAttempts = 0;
            if (recalculationRetryTimeoutId) clearTimeout(recalculationRetryTimeoutId);
            recalculationRetryTimeoutId = null;
        } else {
            throw new Error("No se encontraron rutas.");
        }
    } catch (error) {
        const existingRecalcToastError = document.getElementById(recalculateToastId);
        if (existingRecalcToastError) existingRecalcToastError.remove();
        activeToasts = activeToasts.filter(t => t.id !== recalculateToastId);
        let errorMessageForToast = `Error al calcular ruta: ${error.message}`;
        showToast(errorMessageForToast, "error");
        if (navigationRouteLayer && navigationMapInstance) { try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch(e) {} navigationRouteLayer = null; }
        if (completedRouteSegmentsLayer && navigationMapInstance ) completedRouteSegmentsLayer.clearLayers();
        navigationCurrentRouteData = null;
        lastValidCarDistanceForDisplay = 0;
        hideMapInfoOverlay();
        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox) { eliminarRadaresDeRuta(); actualizarContadorRadares(0); localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked)); }
        const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasRutaCheckbox) { eliminarTareasDeBarraProgreso(); actualizarContadorTareas(0); localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked)); }
        if (recalculationRetryTimeoutId) clearTimeout(recalculationRetryTimeoutId);
        recalculationRetryTimeoutId = setTimeout(() => recalculateAndDrawRoute(preserveAccumulatedStats), 2000);
    }
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    if (!recalculationRetryTimeoutId) {
        isRecalculatingRoute = false;
    }
}




    
    

 







// ===================================================================
// NOMBRE: updateNavigationProgressDisplay (VERSIN FINAL)
// RESUMEN: Actualiza la barra de progreso, gestionando el estado "Stop" desde la planificacin.
// ===================================================================
function updateNavigationProgressDisplay(route, carDistanceAlongTheRoute = 0) {
    const progressBarContainer = document.getElementById('navigation-bottom-progress-bar');
    if (!progressBarContainer) return;

    if (!route || typeof route.distance !== 'number' || typeof route.duration !== 'number' || navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
        return;
    }

    const overallProgressFill = document.getElementById('route-overall-progress');
    const overallProgressContainer = document.getElementById('route-overall-progress-container');
    const routeProgressTextEl = document.getElementById('route-progress-text');
    const routeProgressIconEl = document.getElementById('route-progress-icon');
    const nextStageDistEl = document.getElementById('next-stage-distance');
    const nextStageTimeEl = document.getElementById('next-stage-time');
    const nextStageEtaEl = document.getElementById('next-stage-eta');
    const nextStageDeviationEl = document.getElementById('next-stage-eta-deviation');
    const finalDestDistEl = document.getElementById('final-destination-distance');
    const finalDestTimeEl = document.getElementById('final-destination-time');
    const finalDestEtaEl = document.getElementById('final-destination-eta');
    const finalDestDeviationEl = document.getElementById('final-destination-eta-deviation');
    const nextStageInfoDiv = document.getElementById('next-stage-info');
    const finalDestInfoDiv = document.getElementById('final-destination-info');
    const etaInfoContainer = document.getElementById('navigation-eta-info');

    const totalJourneyDistanceForBar = (accumulatedDistanceBeforeCurrentSegment || 0) + route.distance;
    const currentJourneyDistanceForBar = (accumulatedDistanceBeforeCurrentSegment || 0) + carDistanceAlongTheRoute;
    const progressPercent = totalJourneyDistanceForBar > 0 ? (currentJourneyDistanceForBar / totalJourneyDistanceForBar) * 100 : 0;
    
    overallProgressFill.style.width = `${Math.min(100, progressPercent)}%`;

    if (routeProgressIconEl) {
        if (progressPercent > 0 && progressPercent < 100) {
            routeProgressIconEl.style.display = 'block';
        } else {
            routeProgressIconEl.style.display = 'none';
        }
    }

    if (routeProgressTextEl) {
        let kmRecorridosTexto = "-- km";
        let timeInfoString = ""; 
        
        // --- LGICA DE VISUALIZACIN DE TIEMPO REESTRUCTURADA ---
        if (navigationCurrentRouteData) { // Condicin principal: hay una ruta planificada
            
            // Caso 1: Navegacin activa y el viaje "real" ya ha comenzado.
            if (isNavigating && navigationStartTimeForStats) {
                kmRecorridosTexto = `${(totalDistanceTravelledForStats / 1000).toFixed(1)} km`;
                const startTimeFormatted = `${navigationStartTimeForStats.getHours().toString().padStart(2, '0')}:${navigationStartTimeForStats.getMinutes().toString().padStart(2, '0')}`;
                const nowForTravelTime = new Date();
                const durationMs = nowForTravelTime - navigationStartTimeForStats;
                const totalTravelMinutes = Math.floor(durationMs / (1000 * 60));
                const travelHours = Math.floor(totalTravelMinutes / 60);
                const travelMinutes = totalTravelMinutes % 60;
                const travelTimeFormatted = `${String(travelHours).padStart(2, '0')}:${String(travelMinutes).padStart(2, '0')}`;
                timeInfoString = ` (${startTimeFormatted}  ${travelTimeFormatted})`;
            
            // Caso 2: Ruta planificada, pero o no se ha iniciado la navegacin, o se ha iniciado pero an no nos hemos movido 50m.
            } else { 
                kmRecorridosTexto = "0.0 km";
                timeInfoString = ` (Stop)`;
            }
        
        // Caso 3: No hay ninguna ruta planificada.
        } else { 
            kmRecorridosTexto = "-- km";
            timeInfoString = " (--:--  --:--)";
        }
        // --- FIN DE LA REESTRUCTURACIN ---

        routeProgressTextEl.innerHTML = `${kmRecorridosTexto}${timeInfoString}`;
    }

    const remainingDistanceTotal = Math.max(0, route.distance - carDistanceAlongTheRoute);
    const remainingDurationTotal = route.distance > 0 ? route.duration * (remainingDistanceTotal / route.distance) : 0;

    finalDestDistEl.textContent = `${(remainingDistanceTotal / 1000).toFixed(1)} km`;
    const finalDestTotalMinutes = Math.round(remainingDurationTotal / 60);
    const finalDestHours = Math.floor(finalDestTotalMinutes / 60);
    const finalDestMinutes = finalDestTotalMinutes % 60;
    finalDestTimeEl.textContent = `${String(finalDestHours).padStart(2, '0')}:${String(finalDestMinutes).padStart(2, '0')}`;
    const currentFinalEta = new Date(Date.now() + remainingDurationTotal * 1000);
    finalDestEtaEl.textContent = currentFinalEta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    
    // Solo mostramos la desviacin si el viaje "real" ha comenzado
    if (tripInitialOverallEtaTime && isNavigating && navigationStartTimeForStats) {
        const finalDeviationMs = currentFinalEta.getTime() - tripInitialOverallEtaTime.getTime();
        finalDestDeviationEl.innerHTML = formatDeviation(finalDeviationMs);
    } else {
        finalDestDeviationEl.innerHTML = "";
    }

    let currentLegIndexForNextStageDisplay = currentLegIndexNav;
    let cumulativeDistanceToStartOfCurrentLegOSRM = 0;
    if (route.legs) {
        for (let i = 0; i < currentLegIndexNav; i++) {
            if (route.legs[i] && typeof route.legs[i].distance === 'number') {
                cumulativeDistanceToStartOfCurrentLegOSRM += route.legs[i].distance;
            }
        }
    }

    const isMultiStageRoute = route.legs && route.legs.length > 1;
    if (isMultiStageRoute && currentLegIndexForNextStageDisplay < route.legs.length) {
        etaInfoContainer.classList.remove('single-destination');
        finalDestInfoDiv.classList.remove('single-destination-layout');
        nextStageInfoDiv.style.display = 'block';
        const totalEtapas = route.legs.length;
        const etapaActualUsuario = currentLegIndexNav + 1;
        const strongTagNextStage = nextStageInfoDiv.querySelector('strong');
        const waypointsInRoute = navigationWaypoints.filter(wp => !wp.isInternal && !wp.visited);
        const stageDestinationWaypoint = waypointsInRoute[1];
        let stageLabel = `Etapa ${etapaActualUsuario} de ${totalEtapas}`;
        if (stageDestinationWaypoint && stageDestinationWaypoint.address) {
             const addressParts = stageDestinationWaypoint.address.split(',');
             const shortAddress = addressParts[0];
             stageLabel += `: ${shortAddress}`;
        }
        if (strongTagNextStage) {
            strongTagNextStage.innerHTML = stageLabel;
        }

        const distanceIntoCurrentLegDisplay = Math.max(0, carDistanceAlongTheRoute - cumulativeDistanceToStartOfCurrentLegOSRM);
        const legForDisplay = route.legs[currentLegIndexForNextStageDisplay];
        const remainingDistanceThisLegDisplay = Math.max(0, (legForDisplay.distance || 0) - distanceIntoCurrentLegDisplay);
        const remainingDurationThisLegDisplay = (legForDisplay.distance > 0 && typeof legForDisplay.duration === 'number') ? legForDisplay.duration * (remainingDistanceThisLegDisplay / legForDisplay.distance) : 0;
        
        nextStageDistEl.textContent = `${(remainingDistanceThisLegDisplay / 1000).toFixed(1)} km`;
        const nextStageTotalMinutes = Math.round(remainingDurationThisLegDisplay / 60);
        const nextStageHours = Math.floor(nextStageTotalMinutes / 60);
        const nextStageMinutes = nextStageTotalMinutes % 60;
        nextStageTimeEl.textContent = `${String(nextStageHours).padStart(2, '0')}:${String(nextStageMinutes).padStart(2, '0')}`;
        
        const currentNextStageEta = new Date(Date.now() + remainingDurationThisLegDisplay * 1000);
        nextStageEtaEl.textContent = currentNextStageEta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

        // Solo mostramos la desviacin si el viaje "real" ha comenzado
        if (currentStageInitialExpectedEtaTime && isNavigating && navigationStartTimeForStats) {
           const deviationStageMs = currentNextStageEta.getTime() - currentStageInitialExpectedEtaTime.getTime();
           nextStageDeviationEl.innerHTML = formatDeviation(accumulatedDeviationMs + deviationStageMs);
        } else {
           nextStageDeviationEl.innerHTML = "";
        }
    } else {
        etaInfoContainer.classList.add('single-destination');
        finalDestInfoDiv.classList.add('single-destination-layout');
        nextStageInfoDiv.style.display = 'none';
        if(nextStageDeviationEl) nextStageDeviationEl.innerHTML = "";
    }

    overallProgressContainer.querySelectorAll('.waypoint-dot-on-progress-bar, .radar-marker-on-progress-bar, .task-marker-on-progress-bar').forEach(dot => dot.remove());

    if (navigationWaypoints.length > 2 && totalJourneyDistanceForBar > 0 && route.legs) {
        let distanceLegOsrm = 0;
        for (let i = 0; i < route.legs.length - 1; i++) { 
            if (route.legs[i] && typeof route.legs[i].distance === 'number') {
                distanceLegOsrm += route.legs[i].distance; 
                const totalDistanceToWaypoint = (accumulatedDistanceBeforeCurrentSegment || 0) + distanceLegOsrm;
                const percent = (totalDistanceToWaypoint / totalJourneyDistanceForBar) * 100;

                if (percent < 100 && percent > 0) { 
                    const dot = document.createElement('div');
                    dot.className = 'waypoint-dot-on-progress-bar';
                    dot.style.left = `calc(${percent}% - 7px)`;
                    const stageIndex = navigationWaypoints.filter(wp => wp && !wp.isInternal).findIndex(wp => wp.type === 'intermediate' && parseInt(wp.label) === i + 1);
                    if(stageIndex !== -1) dot.title = `Etapa ${navigationWaypoints.filter(wp => wp && !wp.isInternal)[stageIndex].label}`;
                    overallProgressContainer.appendChild(dot);
                }
            }
        }
    }

    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresRutaCheckbox && radaresRutaCheckbox.checked && radaresEnRutaActual.length > 0 && totalJourneyDistanceForBar > 0) {
        radaresEnRutaActual.forEach(radar => {
            if (radar.distanceOnRoute !== undefined) {
                const totalDistanceToRadar = (accumulatedDistanceBeforeCurrentSegment || 0) + radar.distanceOnRoute;
                if(totalDistanceToRadar <= totalJourneyDistanceForBar) {
                    const percent = (totalDistanceToRadar / totalJourneyDistanceForBar) * 100;
                     if (percent >= 0 && percent <= 100) {
                        const radarMarker = document.createElement('div');
                        radarMarker.className = 'radar-marker-on-progress-bar';
                        radarMarker.style.left = `${percent}%`;
                        radarMarker.title = radar.text.replace(/<b>|<\/b>/gi, '');
                        overallProgressContainer.appendChild(radarMarker);
                    }
                }
            }
        });
    }

    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasRutaCheckbox && tareasRutaCheckbox.checked && tareasEnRutaActual.length > 0 && totalJourneyDistanceForBar > 0) {
        tareasEnRutaActual.forEach(tarea => {
            if (tarea.distanceOnRoute !== undefined) {
                const totalDistanceToTask = (accumulatedDistanceBeforeCurrentSegment || 0) + tarea.distanceOnRoute;
                if(totalDistanceToTask <= totalJourneyDistanceForBar) {
                    const percent = (totalDistanceToTask / totalJourneyDistanceForBar) * 100;
                    if (percent >= 0 && percent <= 100) {
                        const taskMarker = document.createElement('div');
                        taskMarker.className = 'task-marker-on-progress-bar';
                        taskMarker.style.left = `${percent}%`;
                        taskMarker.title = tarea.text.replace(/<b>|<\/b>/gi, '');
                        overallProgressContainer.appendChild(taskMarker);
                    }
                }
            }
        });
    }

    if (isNavigating && !isArrivalSequenceStarted && remainingDistanceTotal < WAYPOINT_VISITED_THRESHOLD_METERS) {
        isArrivalSequenceStarted = true;
        setTimeout(() => {
            if (!document.getElementById('arrival-stats-modal') || document.getElementById('arrival-stats-modal').classList.contains('hidden')) {
                showArrivalStatsModal();
            }
        }, 7000);
        let countdown = 7;
        const toastId = `arrival-toast-${Date.now()}`;
        showToast(`FIN DEL VIAJE (${countdown})`, 'success', 10000, false, toastId);
        const countdownInterval = setInterval(() => {
            countdown--;
            const arrivalToast = document.getElementById(toastId);
            if (arrivalToast) {
                const span = arrivalToast.querySelector('span');
                if (span) span.innerHTML = `FIN DEL VIAJE (${countdown})`;
            }
            if (countdown <= 0) {
                clearInterval(countdownInterval);
            }
        }, 1000);
    } else if (isNavigating) {
        const destinationWp = navigationWaypoints[navigationWaypoints.length - 1];
        if (destinationWp && destinationWp.address) {
            const mapOverlay = document.getElementById('map-info-overlay');
            if (mapOverlay && !mapOverlay.textContent.startsWith("HA LLEGADO AL ")) {
                 showDestinationName();
            }
        }
    }
}    



    



    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleProgressiveManeuverZoom
    // RESUMEN: Calcula el nivel de zoom progresivo para una maniobra, acercando y alejando suavemente.
    // ===================================================================
    function handleProgressiveManeuverZoom(currentStep, distanceToManeuver) {
        if (!isNavigating || !navigationMapInstance || !currentStep) {
            if (isZoomedForManeuver) isZoomedForManeuver = false;
            return null;
        }
        const maxZoomForMap = navigationMapInstance.getMaxZoom() || 19;
        const currentMapLayerName = (localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "satlite + calles").toLowerCase();
        const isSatelliteWithLabels = currentMapLayerName.includes("satlite + calles");
        const MANEUVER_PEAK_ZOOM_LEVEL = isSatelliteWithLabels 
            ? Math.min(17.5, maxZoomForMap) 
            : Math.min(18.5, maxZoomForMap);
        const currentStepIdentifier = `${currentLegIndexNav}_${currentStepIndexNav}`;
        if (lastProcessedStepIdentifier !== null && lastProcessedStepIdentifier !== currentStepIdentifier) {
            if (progressiveZoomState === 'zooming-in' || progressiveZoomState === 'holding') {
                progressiveZoomState = 'zooming-out';
            }
        }
        lastProcessedStepIdentifier = currentStepIdentifier;
        const distanceIntoCurrentStep = currentStep.distance - distanceToManeuver;
        let targetZoom = null;
        switch (progressiveZoomState) {
            case 'zooming-out':
                isZoomedForManeuver = true;
                if (distanceIntoCurrentStep > PROGRESSIVE_ZOOM_EXIT_END_DISTANCE || mapPreviousZoomLevelForProgressive === null) {
                    targetZoom = mapPreviousZoomLevelForProgressive;
                    progressiveZoomState = 'none';
                    mapPreviousZoomLevelForProgressive = null;
                    isZoomedForManeuver = false;
                } else if (distanceIntoCurrentStep >= PROGRESSIVE_ZOOM_EXIT_START_DISTANCE) {
                    const progress = (distanceIntoCurrentStep - PROGRESSIVE_ZOOM_EXIT_START_DISTANCE) / (PROGRESSIVE_ZOOM_EXIT_END_DISTANCE - PROGRESSIVE_ZOOM_EXIT_START_DISTANCE);
                    targetZoom = MANEUVER_PEAK_ZOOM_LEVEL - (MANEUVER_PEAK_ZOOM_LEVEL - mapPreviousZoomLevelForProgressive) * Math.min(1, progress);
                } else {
                    targetZoom = MANEUVER_PEAK_ZOOM_LEVEL;
                }
                break;
            default:
                if (distanceToManeuver <= PROGRESSIVE_ZOOM_START_DISTANCE && distanceToManeuver > PROGRESSIVE_ZOOM_PEAK_DISTANCE) {
                    if (progressiveZoomState !== 'zooming-in' && progressiveZoomState !== 'holding') {
                        mapPreviousZoomLevelForProgressive = navigationMapInstance.getZoom();
                    }
                    progressiveZoomState = 'zooming-in';
                    const progress = (PROGRESSIVE_ZOOM_START_DISTANCE - distanceToManeuver) / (PROGRESSIVE_ZOOM_START_DISTANCE - PROGRESSIVE_ZOOM_PEAK_DISTANCE);
                    targetZoom = mapPreviousZoomLevelForProgressive + (MANEUVER_PEAK_ZOOM_LEVEL - mapPreviousZoomLevelForProgressive) * progress;
                    isZoomedForManeuver = true;
                } else if (distanceToManeuver <= PROGRESSIVE_ZOOM_PEAK_DISTANCE) {
                    if (progressiveZoomState !== 'holding' && mapPreviousZoomLevelForProgressive === null) {
                        mapPreviousZoomLevelForProgressive = navigationMapInstance.getZoom();
                    }
                    progressiveZoomState = 'holding';
                    targetZoom = MANEUVER_PEAK_ZOOM_LEVEL;
                    isZoomedForManeuver = true;
                } else {
                    if (progressiveZoomState !== 'none' && mapPreviousZoomLevelForProgressive !== null) {
                        targetZoom = mapPreviousZoomLevelForProgressive;
                    }
                    progressiveZoomState = 'none';
                    mapPreviousZoomLevelForProgressive = null;
                    isZoomedForManeuver = false;
                }
                break;
        }
        return targetZoom;
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    


// ===================================================================
// NOMBRE: initializeApp
// RESUMEN: Funcin principal que inicializa la aplicacin al cargar la pgina.
// ===================================================================
async function initializeApp() {
    loadCustomData();
    loadSavedSettings();
    const { isMobile, primaryId } = parseUserId(localStorage.getItem('userData_userId'));
    if (isMobile) {
        document.body.classList.add('mobile-view');
        await restoreCacheForMobile();
    } else {
        await syncDataOnLoad();
    }
    lastMobileSyncTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');
    const shouldDirectToNav = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
    const tempPreventDirectNav = sessionStorage.getItem(TEMP_PREVENT_DIRECT_NAV_KEY);
    if (shouldDirectToNav && !tempPreventDirectNav) {
        sessionStorage.setItem('isInDirectToMapMode', 'true');
        directToNavOnLoad = true;
        const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'none';
        const footerContent = document.querySelector('footer'); if (footerContent) footerContent.style.display = 'none';
        const noticesIconContainer = document.querySelector('.notices-icon-container'); if (noticesIconContainer) noticesIconContainer.style.display = 'none';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'none');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'none');
        document.getElementById('grid-filter-container').style.display = 'none';
        createOtherButtons();
        renderToggleButtons();
        openNavigationMap();
    } else {
        sessionStorage.removeItem('isInDirectToMapMode');
        directToNavOnLoad = false;
        const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'block';
        const footerContent = document.querySelector('footer'); if (footerContent) footerContent.style.display = 'block';
        const noticesIconContainer = document.querySelector('.notices-icon-container'); if (noticesIconContainer) noticesIconContainer.style.display = 'flex';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'flex');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'block');
        document.getElementById('grid-filter-container').style.display = 'flex';
        renderGrid();
        createOtherButtons();
        renderToggleButtons();
        updateButtonStyles();
        filterGridItems();
    }
    initializeConfigModalListeners();
    try { await updateVersion(); } catch (e) { }
    try { await loadNotices(); startNoticeRotation(); } catch (e) { }
    if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
    checkReminders();
    currentCheckIntervalDuration = 3000;
    reminderCheckIntervalId = setInterval(checkReminders, currentCheckIntervalDuration);
    const noticeToggleIcon = document.getElementById('notice-toggle-icon');
    if (noticeToggleIcon) noticeToggleIcon.addEventListener('click', toggleNotices);
    const countEl = document.getElementById('reminder-count-globe');
    if (countEl) {
         const openTable = (e) => {
             if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
             e.preventDefault(); e.stopPropagation();
             showAllReminders();
         };
         countEl.addEventListener('click', openTable);
         countEl.style.cursor = 'pointer';
    }
    const filterInput = document.getElementById('grid-filter-input');
    const clearButton = document.getElementById('clear-filter-button');
    if (filterInput) {
        const savedFilter = localStorage.getItem('gridFilterValue');
        if (savedFilter !== null) filterInput.value = savedFilter;
        filterInput.addEventListener('input', () => {
             localStorage.setItem('gridFilterValue', filterInput.value);
             filterGridItems();
             if(isKeywordAssignmentMode) applyInitialKeywordHighlights();
        });
    }
    if (clearButton) {
        clearButton.addEventListener('click', () => {
             if (filterInput) filterInput.value = '';
             localStorage.removeItem('gridFilterValue');
             filterGridItems();
             if(isKeywordAssignmentMode) applyInitialKeywordHighlights();
        });
    }
    adjustButtonPositions();
    window.addEventListener('resize', adjustButtonPositions);
    await checkVersionsIconOpacity();
    const generalTopButtonsElements = [
        document.getElementById('config-button'), document.getElementById('personal-button'),
        document.getElementById('radar-button'), document.getElementById('home-button'),
        document.getElementById('reload-button'), document.getElementById('keyword-assignment-button'),
        document.getElementById('password-toggle-button'), document.getElementById('versions-button'),
        document.getElementById('info-button')
    ].filter(el => el);
    const toggleGeneralTopButtonsPanel = document.getElementById('toggle-top-buttons-panel-general');
    if (toggleGeneralTopButtonsPanel) {
        let areGeneralTopButtonsVisible = true;
        toggleGeneralTopButtonsPanel.addEventListener('click', () => {
            areGeneralTopButtonsVisible = !areGeneralTopButtonsVisible;
            generalTopButtonsElements.forEach(el => {
                if (el) el.classList.toggle('hidden', !areGeneralTopButtonsVisible);
            });
            const mainContent = document.querySelector('main');
            const footerContent = document.querySelector('footer');
            const noticesContainer = document.querySelector('.notices-icon-container');
            if (areGeneralTopButtonsVisible) {
                if (mainContent) mainContent.style.marginTop = '76px';
                if (footerContent) footerContent.style.marginTop = '0.5rem';
                if (noticesContainer) noticesContainer.style.marginTop = '0';
            } else {
                if (mainContent) mainContent.style.marginTop = '10px';
                if (footerContent) footerContent.style.marginTop = '10px';
                if (noticesContainer) noticesContainer.style.marginTop = '10px';
            }
        });
    }
    if (!shouldDirectToNav) {
        filterGridItems();
    }
}    


    
    
    


  // ===================================================================
// NOMBRE: showReorderStagesModal
// RESUMEN: Muestra el modal para reordenar las etapas de la ruta.
// ===================================================================
function showReorderStagesModal() {
    if (isNavigating) {
        showToast("No se puede reordenar etapas mientras se navega.", "warning");
        return;
    }
    const actualWaypointsForReorder = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    if (actualWaypointsForReorder.length < 2) {
        showToast("Se necesitan al menos 2 puntos para reordenar", "warning");
        return;
    }
    const modal = document.getElementById('reorder-stages-modal');
    if (!modal) {
        showToast("Error interno: No se pudo mostrar el modal de reordenamiento.", "error");
        return;
    }
    const listElement = modal.querySelector('#sortable-stages-list');
    if (!listElement) {
         showToast("Error interno: No se pudo encontrar la lista de etapas", "error");
         return;
    }
    listElement.innerHTML = '';
    actualWaypointsForReorder.forEach(async (wp) => {
        const li = document.createElement('li');
        li.dataset.id = wp.id;
        const dragHandle = document.createElement('span');
        dragHandle.className = 'drag-handle';
        dragHandle.innerHTML = '<img src="MOVER.PNG" alt="Mover etapa">';
        dragHandle.title = 'Arrastrar para reordenar';
        dragHandle.draggable = true;
        const badge = document.createElement('span');
        badge.className = 'stage-label-badge';
        badge.textContent = wp.label;
        const nameSpan = document.createElement('span');
        nameSpan.className = 'stage-name-text';
        nameSpan.textContent = wp.address || `Cargando direccin para (${wp.lat.toFixed(3)}, ${wp.lng.toFixed(3)})...`;
        if (!wp.address) {
             wp.address = await getAddressForWaypoint(wp.lat, wp.lng);
             nameSpan.textContent = wp.address;
        }
        const deleteButton = document.createElement('span');
        deleteButton.className = 'delete-stage-button';
        deleteButton.innerHTML = '';
        deleteButton.title = 'Eliminar esta etapa';
        deleteButton.addEventListener('click', (e) => {
            e.stopPropagation();
            const listItem = e.target.closest('li');
            if (listItem) {
                const waypointIdToDelete = parseInt(listItem.dataset.id);
                const waypointIndexInNavigationArray = navigationWaypoints.findIndex(wp => wp && wp.id === waypointIdToDelete);
                if (waypointIndexInNavigationArray !== -1) {
                    const waypointObjectToDelete = navigationWaypoints[waypointIndexInNavigationArray];
                    if (waypointObjectToDelete.marker && navigationMapInstance) {
                        try {
                            navigationMapInstance.removeLayer(waypointObjectToDelete.marker);
                        } catch (mapError) {
                        }
                        waypointObjectToDelete.marker = null;
                    }
                }
                listItem.remove();
                navigationWaypoints = navigationWaypoints.filter(wayP => wayP.id !== waypointIdToDelete);
                updateWaypointTypesAndLabels();
                const remainingListItems = listElement.querySelectorAll('li');
                const currentActualWaypointsAfterDelete = navigationWaypoints.filter(w => w && !w.isInternal && !w.isRecalculatedStart);
                remainingListItems.forEach((remainingLi) => {
                     const currentWpIdInModal = parseInt(remainingLi.dataset.id);
                     const correspondingWp = currentActualWaypointsAfterDelete.find(w => w.id === currentWpIdInModal);
                     if(correspondingWp){
                        const badgeSpan = remainingLi.querySelector('.stage-label-badge');
                        if(badgeSpan) badgeSpan.textContent = correspondingWp.label;
                     }
                });
                const confirmBtn = modal.querySelector('#confirm-reorder-stages');
                const canConfirm = remainingListItems.length >= 2;
                if (confirmBtn) confirmBtn.disabled = !canConfirm;
                if (!canConfirm && remainingListItems.length > 0) {
                    showToast("Se necesitan al menos 2 puntos para una ruta.", "warning", 3000);
                } else if (remainingListItems.length === 0){
                    showToast("No quedan etapas. La ruta se eliminar al confirmar.", "info", 3000);
                }
            }
        });
        li.appendChild(dragHandle);
        li.appendChild(badge);
        li.appendChild(nameSpan);
        li.appendChild(deleteButton);
        listElement.appendChild(li);
    });
    modal.classList.remove('hidden');
    const confirmButton = modal.querySelector('#confirm-reorder-stages');
    const cancelButton = modal.querySelector('#cancel-reorder-stages');
    if (confirmButton) confirmButton.disabled = listElement.querySelectorAll('li').length < 2;
    const newConfirmButton = confirmButton.cloneNode(true);
    confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
    const newCancelButton = cancelButton.cloneNode(true);
    cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);
    const closeReorderModal = () => {
        clearModalAutoCloseTimer(modal, newConfirmButton, 'reorder-stages-modal');
        modal.classList.add('hidden');
        listElement.querySelectorAll('.drag-handle').forEach(handle => {
            handle.removeEventListener('dragstart', handleDragStartReorder);
            handle.removeEventListener('touchstart', handleStageTouchStart);
        });
        listElement.removeEventListener('dragend', handleDragEndReorder);
        listElement.removeEventListener('dragover', handleDragOverReorder);
        listElement.removeEventListener('touchmove', handleStageTouchMove);
        listElement.removeEventListener('touchend', handleStageTouchEnd);
        listElement.removeEventListener('touchcancel', handleStageTouchEnd);
        document.body.style.overflow = '';
    };
    newConfirmButton.addEventListener('click', async () => {
        const orderedLiElements = Array.from(listElement.children);
        const finalWaypointIds = orderedLiElements.map(li => parseInt(li.dataset.id));
        clearAllWaypointMarkersFromMap();
        if (finalWaypointIds.length < 2) {
            showToast("Se necesitan al menos 2 etapas para formar una ruta. Ruta actual eliminada.", "warning");
            navigationWaypoints = [];
            if (navigationRouteLayer && navigationMapInstance) {
                navigationMapInstance.removeLayer(navigationRouteLayer);
                navigationRouteLayer = null;
            }
            if (completedRouteSegmentsLayer && navigationMapInstance) completedRouteSegmentsLayer.clearLayers();
            navigationCurrentRouteData = null;
            updateStartNavigationButtonState();
            updateNavigationButtonColor();
            hideNavigationUI();
            hideMapInfoOverlay();
            eliminarRadaresDeRuta();
            actualizarContadorRadares(0);
             eliminarTareasDeBarraProgreso();
            actualizarContadorTareas(0);
            const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
            if (radaresCheckbox) {
                 localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckbox.checked));
            }
            const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
            if (tareasCheckbox) {
                localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckbox.checked));
            }
            closeReorderModal();
            return;
        }
        try {
            const newWaypointsOrdered = [];
            finalWaypointIds.forEach(id => {
                const foundWp = navigationWaypoints.find(wp => wp && wp.id === id);
                if(foundWp) newWaypointsOrdered.push(foundWp);
            });
            navigationWaypoints = newWaypointsOrdered;
            updateWaypointTypesAndLabels();
            renderWaypointMarkers();
            await recalculateAndDrawRoute();
            const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
            if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                toggleRadaresRuta(true);
            }
            const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
            if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                toggleTareasRuta(true);
            }
            showToast("Etapas reordenadas y ruta recalculada", "success");
        } catch (error) {
            showToast("Error recalculando ruta tras reordenar: " + error.message, "error");
        } finally {
             closeReorderModal();
             updateStartNavigationButtonState();
             updateNavigationButtonColor();
        }
    });
    newCancelButton.addEventListener('click', () => {
        showToast("Reordenacin cancelada. Los marcadores eliminados se restaurarn al recalcular/cargar ruta.", "info");
        closeReorderModal();
        if (navigationWaypoints.length >= 2) {
            renderWaypointMarkers();
            recalculateAndDrawRoute().then(() => {
                const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
                if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                    toggleRadaresRuta(true);
                }
                 const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
                if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                    toggleTareasRuta(true);
                }
            });
        } else {
            clearAllWaypointMarkersFromMap();
            navigationWaypoints = [];
             if (navigationRouteLayer && navigationMapInstance) {
                navigationMapInstance.removeLayer(navigationRouteLayer);
                navigationRouteLayer = null;
            }
            if (completedRouteSegmentsLayer && navigationMapInstance) completedRouteSegmentsLayer.clearLayers();
            navigationCurrentRouteData = null;
            hideNavigationUI();
            hideMapInfoOverlay();
            eliminarRadaresDeRuta();
            actualizarContadorRadares(0);
            eliminarTareasDeBarraProgreso();
            actualizarContadorTareas(0);
            const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
            if (radaresCheckbox) {
                localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckbox.checked));
            }
             const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
            if (tareasCheckbox) {
                localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckbox.checked));
            }
        }
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
    });
    addModalAutoCloseTimer(modal, newConfirmButton, 'reorder-stages-modal', 60000);
    listElement.querySelectorAll('.drag-handle').forEach(handle => {
        handle.addEventListener('dragstart', handleDragStartReorder);
        handle.addEventListener('touchstart', handleStageTouchStart, { passive: false });
    });
    listElement.addEventListener('dragend', handleDragEndReorder);
    listElement.addEventListener('dragover', handleDragOverReorder);
    listElement.addEventListener('touchmove', handleStageTouchMove, { passive: false });
    listElement.addEventListener('touchend', handleStageTouchEnd);
    listElement.addEventListener('touchcancel', handleStageTouchEnd);
}

// ===================================================================
// NOMBRE: handleDragStartReorder
// RESUMEN: Maneja el inicio de un arrastre en la lista de reordenacin.
// ===================================================================
function handleDragStartReorder(e) {
    if (e.target.closest('.drag-handle')) { 
        draggedStageLi = e.target.closest('li');
        if (!draggedStageLi) return;
        setTimeout(() => {
            if (draggedStageLi) draggedStageLi.classList.add('dragging');
        }, 0);
        if (e.dataTransfer) {
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedStageLi.dataset.id);
        }
    } else {
        e.preventDefault();
    }
}

// ===================================================================
// NOMBRE: handleStageTouchStart
// RESUMEN: Maneja el inicio de un toque en una etapa para reordenar (tctil).
// ===================================================================
function handleStageTouchStart(e) {
    if (e.touches.length === 1 && e.target.closest('.drag-handle')) {
        draggedStageLi = e.target.closest('li');
        if (!draggedStageLi) return;
        const touch = e.touches[0];
        stageTouchStartX = touch.clientX;
        stageTouchStartY = touch.clientY;
        clearTimeout(stageScrollTimeout);
        stageScrollTimeout = setTimeout(() => {
            if (draggedStageLi) {
                draggedStageLi.classList.add('dragging');
                document.body.style.overflow = 'hidden';
            }
        }, 150);
    }
}

// ===================================================================
// NOMBRE: handleStageTouchMove
// RESUMEN: Maneja el movimiento de un toque en una etapa para reordenar (tctil).
// ===================================================================
function handleStageTouchMove(e) {
    if (!draggedStageLi || e.touches.length !== 1) return;
    e.preventDefault();
    clearTimeout(stageScrollTimeout);
    if (!draggedStageLi.classList.contains('dragging')) {
        draggedStageLi.classList.add('dragging');
         document.body.style.overflow = 'hidden';
    }
    const touch = e.touches[0];
    const listElement = document.getElementById('sortable-stages-list');
    if (!listElement) return;
    const afterElement = getDragAfterElement(listElement, touch.clientY);
     if (afterElement == null) {
        listElement.appendChild(draggedStageLi);
    } else {
        listElement.insertBefore(draggedStageLi, afterElement);
    }
}

// ===================================================================
// NOMBRE: handleStageTouchEnd
// RESUMEN: Maneja el final de un toque en una etapa para reordenar (tctil).
// ===================================================================
function handleStageTouchEnd(e) {
    clearTimeout(stageScrollTimeout);
    if (draggedStageLi) {
        draggedStageLi.classList.remove('dragging');
        draggedStageLi = null;
    }
    document.body.style.overflow = '';
}





    





    


 //-----------------------




// ===================================================================
// NOMBRE: clearAllLocalData
// RESUMEN: Borra todos los datos guardados en el almacenamiento local del navegador.
// ===================================================================
function clearAllLocalData() {
    if (confirm('ATENCIN! Esto borrar TODOS los datos locales (marcadores personalizados, recordatorios, configuracin de usuario, PIN, etc.). Esta accin NO SE PUEDE DESHACER. Ests seguro?')) {
        if (confirm('DE VERDAD, ESTS COMPLETAMENTE SEGURO? SE BORRAR TODO.')) {
            managedKeys.forEach(key => localStorage.removeItem(key));
            localStorage.removeItem('personalizationHelpShown');
            localStorage.removeItem('gridFilterValue');
            showToast('Todos los datos locales borrados. Recargando...', 'success');
            setTimeout(() => location.reload(), 1500);
        } else {
            showToast('Borrado cancelado', 'info');
        }
    } else {
        showToast('Borrado cancelado', 'info');
    }
}





// ===================================================================
// NOMBRE: saveUserData
// RESUMEN: Guarda los datos de usuario en una hoja de clculo externa (obsoleto, usa Firebase).
// ===================================================================
function saveUserData() {
    const userId = document.getElementById('user-id').value.trim();
    const teslaModel = document.getElementById('tesla-model').value.trim();
    const teslaYear = document.getElementById('tesla-year').value.trim();
    const teslaProvince = document.getElementById('tesla-province').value.trim();
    const allowDMs = document.getElementById('allow-dms').checked;
    const statusEl = document.getElementById('config-user-status');
    if (!userId) {
        statusEl.textContent = 'El ID de Usuario (Apodo) es obligatorio.';
        statusEl.style.color = '#EF4444';
        showToast('El ID de Usuario (Apodo) es obligatorio.', 'error');
        return;
    }
    localStorage.setItem('userData_userId', userId);
    localStorage.setItem('userData_teslaModel', teslaModel);
    localStorage.setItem('userData_teslaYear', teslaYear);
    localStorage.setItem('userData_teslaProvince', teslaProvince);
    localStorage.setItem('userData_allowDMs', JSON.stringify(allowDMs));
    updateUserIdDisplay();
    const cacheData = {};
    managedKeys.forEach(key => {
        const value = localStorage.getItem(key);
        if (value !== null) {
            if (!key.startsWith('userData_') && key !== 'userData_allowDMs') {
                 cacheData[key] = value;
            }
        }
    });
    const cacheDataString = JSON.stringify(cacheData);
    const formData = new FormData();
    formData.append('usuario', userId);
    formData.append('modelo', teslaModel);
    formData.append('anio', teslaYear);
    formData.append('provincia', teslaProvince);
    formData.append('rss', allowDMs.toString());
    formData.append('datosCache', cacheDataString);
    statusEl.textContent = 'Guardando datos en hoja de clculo...';
    statusEl.style.color = '#17a2b8';
    showToast('Guardando en hoja de clculo...', 'info', 0);
    const SCRIPT_URL = SCRIPT_URL_GDRIVE;
    fetch(SCRIPT_URL, {
        method: 'POST',
        body: formData
    })
    .then(response => {
        if (!response.ok) {
            return response.text().then(text => { throw new Error(text || response.statusText) });
        }
        return response.json();
    })
    .then(data => {
        activeToasts.forEach(t => { if (t.element.textContent.includes('Guardando en hoja de clculo...')) t.element.remove(); });
        activeToasts = activeToasts.filter(t => !t.element.textContent.includes('Guardando en hoja de clculo...'));
        if (data.status === "success") {
            statusEl.textContent = 'Datos guardados en hoja de clculo y localmente. ' + (data.message || '');
            statusEl.style.color = '#28a745';
            showToast('Datos de usuario guardados en hoja de clculo. ' + (data.message || ''), 'success');
        } else {
            statusEl.textContent = 'Error al guardar en hoja de clculo: ' + (data.message || 'Error desconocido') + ' (Datos guardados localmente).';
            statusEl.style.color = '#EF4444';
            showToast('Error al guardar en hoja de clculo: ' + (data.message || 'Error desconocido'), 'error');
        }
    })
    .catch(error => {
        activeToasts.forEach(t => { if (t.element.textContent.includes('Guardando en hoja de clculo...')) t.element.remove(); });
        activeToasts = activeToasts.filter(t => !t.element.textContent.includes('Guardando en hoja de clculo...'));
        statusEl.textContent = 'Error de red/script al guardar en hoja de clculo: ' + error.message + ' (Datos guardados localmente).';
        statusEl.style.color = '#EF4444';
        showToast('Error de red/script al guardar en hoja de clculo: ' + error.message, 'error');
    });
}





// ===================================================================
// NOMBRE: resetUserData
// RESUMEN: Resetea los datos de usuario en la cach local.
// ===================================================================
function resetUserData() {
    if (confirm('Ests seguro de que deseas resetear tus datos de usuario compartidos (los eliminar de la cach local y deberas eliminarlos manualmente de la hoja de clculo si los enviaste)?')) {
        document.getElementById('user-id').value = '';
        document.getElementById('tesla-model').value = '';
        document.getElementById('tesla-year').value = '';
        document.getElementById('tesla-province').value = '';
        document.getElementById('allow-dms').checked = false;
        localStorage.removeItem('userData_userId');
        localStorage.removeItem('userData_teslaModel');
        localStorage.removeItem('userData_teslaYear');
        localStorage.removeItem('userData_teslaProvince');
        localStorage.removeItem('userData_allowDMs');
        updateUserIdDisplay();
        const statusEl = document.getElementById('config-user-status');
        statusEl.textContent = 'Datos de usuario reseteados.';
        statusEl.style.color = '#17a2b8';
        showToast('Datos de usuario reseteados', 'info');
    }
}





// ===================================================================
// NOMBRE: importRadars
// RESUMEN: Importa radares y otros POIs desde archivos KML externos.
// ===================================================================
async function importRadars() {
    const latFilterValue = document.getElementById('radar-filter-lat').value.trim();
    const lonFilterValue = document.getElementById('radar-filter-lon').value.trim();
    const keywordsFilterRaw = document.getElementById('radar-filter-keywords').value.trim().toUpperCase();
    const keywordsFilter = keywordsFilterRaw ? keywordsFilterRaw.split(/\s+/).filter(k => k) : [];
    const importExtra = document.getElementById('import-extra-radars-checkbox').checked;
    const progressBar = document.getElementById('radar-import-progress-bar');
    const statusMessage = document.getElementById('radar-import-status');
    const progressContainer = document.getElementById('radar-import-progress-container');
    progressContainer.style.display = 'block';
    progressBar.value = 0;
    statusMessage.textContent = 'Iniciando importacin...';
    statusMessage.style.color = '';
    try {
        let filesToProcess = await fetchKMLFilesList(KML_FILES_LIST_STANDARD);
        if (importExtra) {
            const extraFiles = await fetchKMLFilesList(KML_FILES_LIST_EXTRA);
            filesToProcess = filesToProcess.concat(extraFiles.filter(f => !filesToProcess.includes(f)));
        }
        if (filesToProcess.length === 0) {
            statusMessage.textContent = 'No se encontraron listas de archivos KML para procesar.';
            progressBar.value = 100;
            showToast('No hay archivos KML en las listas.', 'warning');
            setTimeout(() => { progressContainer.style.display = 'none'; }, 3000);
            return;
        }
        statusMessage.textContent = `Encontrados ${filesToProcess.length} archivos KML. Procesando...`;
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        let newRadarsCount = 0;
        let totalFilesProcessed = 0;
        for (const kmlFileName of filesToProcess) {
            try {
                statusMessage.textContent = `Procesando ${kmlFileName}... (${totalFilesProcessed + 1}/${filesToProcess.length})`;
                const placemarks = await fetchAndParseKML(KML_BASE_PATH + kmlFileName);
                placemarks.forEach(placemark => {
                    const name = placemark.name.toUpperCase();
                    const coords = placemark.coordinates;
                    const matchesKeywords = keywordsFilter.length === 0 || keywordsFilter.some(kw => name.includes(kw));
                    if (coords && matchesKeywords) {
                        const [lonStr, latStr] = coords.split(',');
                        const lon = parseFloat(lonStr);
                        const lat = parseFloat(latStr);
                        if (isNaN(lat) || isNaN(lon)) return;
                        const matchesLat = parseCoordinateFilter(latFilterValue, lat);
                        const matchesLon = parseCoordinateFilter(lonFilterValue, lon);
                        if (matchesLat && matchesLon) {
                            const existingRadar = reminders.find(r =>
                                r.isLocationEnabled &&
                                r.locationCoordinates &&
                                Math.abs(r.locationCoordinates.latitude - lat) < COORD_EPSILON &&
                                Math.abs(r.locationCoordinates.longitude - lon) < COORD_EPSILON &&
                                (r.text.toUpperCase().includes("RADAR:") || r.excludeFromList)
                            );
                            if (!existingRadar) {
                                const now = new Date();
                                const newRadar = {
                                    id: Date.now() + Math.random() + newRadarsCount,
                                    text: `<b>RADAR: ${placemark.name}</b>`,
                                    type: 'simple',
                                    time: '00:01',
                                    date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                                    createdAt: now.toISOString(),
                                    managedByUser: false,
                                    isLocationEnabled: true,
                                    locationCoordinates: { latitude: lat, longitude: lon },
                                    radiusMeters: 400,
                                    excludeFromList: true
                                };
                                reminders.push(newRadar);
                                newRadarsCount++;
                            }
                        }
                    }
                });
            } catch (fileError) {
                statusMessage.textContent = `Error en ${kmlFileName}: ${fileError.message}. Continuando...`;
                statusMessage.style.color = 'orange';
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
            totalFilesProcessed++;
            progressBar.value = (totalFilesProcessed / filesToProcess.length) * 100;
        }
        localStorage.setItem('reminders', JSON.stringify(reminders));
        statusMessage.textContent = `Importacin completa. ${newRadarsCount} nuevos radares/POIs aadidos.`;
        statusMessage.style.color = '#28a745';
        showToast(`${newRadarsCount} nuevos radares/POIs aadidos.`, 'success');
        updateReminderCount();
        updateButtonStyles();
        checkReminders();
    } catch (error) {
        statusMessage.textContent = `Error general: ${error.message}`;
        statusMessage.style.color = 'red';
        showToast('Error durante la importacin.', 'error');
    } finally {
         setTimeout(() => {
            progressContainer.style.display = 'none';
            statusMessage.style.color = '';
        }, 5000);
    }
}





// ===================================================================
// NOMBRE: fetchKMLFilesList
// RESUMEN: Obtiene la lista de archivos KML a procesar desde una URL.
// ===================================================================
async function fetchKMLFilesList(listUrl) {
    try {
        const response = await fetch(listUrl, { cache: 'no-cache' });
        if (!response.ok) throw new Error(`Error HTTP ${response.status} obteniendo lista KML: ${listUrl}`);
        const text = await response.text();
        return text.split('\n').map(f => f.trim()).filter(f => f.length > 0 && f.toLowerCase().endsWith('.kml'));
    } catch (error) {
        showToast(`Error cargando lista ${listUrl.split('/').pop()}`, 'error');
        return [];
    }
}





// ===================================================================
// NOMBRE: fetchAndParseKML
// RESUMEN: Descarga y decodifica un archivo KML.
// ===================================================================
async function fetchAndParseKML(kmlFileUrl) {
    try {
        const response = await fetch(kmlFileUrl, { cache: 'no-cache' });
        if (!response.ok) throw new Error(`Error HTTP ${response.status} obteniendo KML: ${kmlFileUrl}`);
        const buffer = await response.arrayBuffer();
        const decoder = new TextDecoder('iso-8859-1');
        const kmlText = decoder.decode(buffer);
        return parseKML(kmlText);
    } catch (error) {
        throw error;
    }
}





// ===================================================================
// NOMBRE: parseKML
// RESUMEN: Parsea el texto de un archivo KML para extraer los Placemarks.
// ===================================================================
function parseKML(kmlText) {
    const placemarks = [];
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(kmlText, "application/xml");
    const parserErrorNode = xmlDoc.querySelector("parsererror");
    if (parserErrorNode) {
        let errorMessage = "Error de parseo XML desconocido.";
        if (parserErrorNode.textContent) {
            const match = parserErrorNode.textContent.match(/error on line \d+ at column \d+: ([^\n]+)/);
            if (match && match[1]) {
                errorMessage = match[1];
            } else {
                errorMessage = parserErrorNode.textContent.split('\n')[0] || parserErrorNode.textContent;
            }
        } else if (parserErrorNode.innerText) {
             errorMessage = parserErrorNode.innerText.split('\n')[0] || parserErrorNode.innerText;
        }
        throw new Error("KML parsing error: " + errorMessage);
    }
    const KML_NS_GOOGLE = "http://earth.google.com/kml/2.0";
    const KML_NS_OGC = "http://www.opengis.net/kml/2.2";
    let placemarkNodes = xmlDoc.getElementsByTagNameNS(KML_NS_GOOGLE, 'Placemark');
    if (placemarkNodes.length === 0) {
        placemarkNodes = xmlDoc.getElementsByTagNameNS(KML_NS_OGC, 'Placemark');
    }
     if (placemarkNodes.length === 0) {
        placemarkNodes = xmlDoc.getElementsByTagName('Placemark');
    }
    for (let i = 0; i < placemarkNodes.length; i++) {
        const node = placemarkNodes[i];
        let nameNode, coordinatesNode;
        nameNode = node.getElementsByTagNameNS(KML_NS_GOOGLE, 'name')[0] || node.getElementsByTagNameNS(KML_NS_OGC, 'name')[0] || node.getElementsByTagName('name')[0];
        coordinatesNode = node.getElementsByTagNameNS(KML_NS_GOOGLE, 'coordinates')[0] || node.getElementsByTagNameNS(KML_NS_OGC, 'coordinates')[0] || node.getElementsByTagName('coordinates')[0];
        if (nameNode && coordinatesNode) {
            const name = nameNode.textContent.trim();
            const coordinatesRaw = coordinatesNode.textContent.trim();
            const coordPartsMatch = coordinatesRaw.match(/^(-?\d+\.?\d*)[,\s]+(-?\d+\.?\d*)/);
            if (name && coordPartsMatch && coordPartsMatch.length >= 3) {
                const lonStr = coordPartsMatch[1];
                const latStr = coordPartsMatch[2];
                const coordinates = `${lonStr},${latStr}`;
                const lon = parseFloat(lonStr);
                const lat = parseFloat(latStr);
                if (!isNaN(lon) && !isNaN(lat)) {
                    if (name.startsWith("Radares BBS www.laradiobbs.net") && lon === 0 && lat === 0) {
                        continue;
                    }
                    placemarks.push({ name, coordinates });
                }
            }
        }
    }
    return placemarks;
}





// ===================================================================
// NOMBRE: deleteFilteredRadars
// RESUMEN: Borra los recordatorios de tipo RADAR/POI segn los filtros especificados.
// ===================================================================
async function deleteFilteredRadars() {
    const latFilterValue = document.getElementById('radar-filter-lat').value.trim();
    const lonFilterValue = document.getElementById('radar-filter-lon').value.trim();
    const keywordsFilterRaw = document.getElementById('radar-filter-keywords').value.trim().toUpperCase();
    const keywordsFilter = keywordsFilterRaw ? keywordsFilterRaw.split(/\s+/).filter(k => k) : [];
    const statusMessage = document.getElementById('radar-import-status');
    const progressContainer = document.getElementById('radar-import-progress-container');
    const noFiltersProvided = !latFilterValue && !lonFilterValue && keywordsFilter.length === 0;
    let confirmationMessage = "";
    if (noFiltersProvided) {
        confirmationMessage = "Ests seguro de que quieres borrar TODOS los recordatorios tipo RADAR/POI (ya que no has especificado ningn filtro)? Esta accin no se puede deshacer.";
    } else {
        confirmationMessage = "Ests seguro de que quieres borrar los recordatorios tipo RADAR/POI que coincidan con los filtros actuales? Esta accin no se puede deshacer.";
    }
    if (!confirm(confirmationMessage)) {
        showToast("Borrado cancelado", "info");
        return;
    }
    progressContainer.style.display = 'block';
    const progressBar = document.getElementById('radar-import-progress-bar');
    if(progressBar) progressBar.style.display = 'none';
    statusMessage.textContent = 'Borrando recordatorios...';
    statusMessage.style.color = '';
    try {
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        let originalLength = reminders.length;
        reminders = reminders.filter(r => {
            const isRadarType = r.isLocationEnabled && (r.text.toUpperCase().includes("RADAR:") || r.excludeFromList);
            if (!isRadarType) return true;
            if (noFiltersProvided) {
                return false;
            }
            let matchesKeywords = true;
            if (keywordsFilter.length > 0) {
                matchesKeywords = keywordsFilter.some(kw => r.text.toUpperCase().includes(kw));
            }
            let matchesLat = true;
            if (latFilterValue) {
                if (r.locationCoordinates) {
                    matchesLat = parseCoordinateFilter(latFilterValue, r.locationCoordinates.latitude);
                } else {
                    matchesLat = false;
                }
            }
            let matchesLon = true;
            if (lonFilterValue) {
                if (r.locationCoordinates) {
                    matchesLon = parseCoordinateFilter(lonFilterValue, r.locationCoordinates.longitude);
                } else {
                    matchesLon = false;
                }
            }
            return !(matchesKeywords && matchesLat && matchesLon);
        });
        localStorage.setItem('reminders', JSON.stringify(reminders));
        const numDeleted = originalLength - reminders.length;
        statusMessage.textContent = `Borrado completo. ${numDeleted} recordatorios eliminados.`;
        statusMessage.style.color = '#28a745';
        showToast(`${numDeleted} recordatorios eliminados`, 'success');
        updateReminderCount();
        updateButtonStyles();
        checkReminders();
    } catch (error) {
        statusMessage.textContent = `Error: ${error.message}`;
        statusMessage.style.color = 'red';
        showToast('Error durante el borrado', 'error');
    } finally {
        setTimeout(() => {
            progressContainer.style.display = 'none';
            if(progressBar) progressBar.style.display = 'block';
            statusMessage.style.color = '';
        }, 3000);
    }
}





// ===================================================================
// NOMBRE: toggleRadaresRuta
// RESUMEN: Activa/desactiva la visualizacin de radares en la ruta actual.
// ===================================================================
async function toggleRadaresRuta(activo) {
    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(activo));
    if (actualWaypoints.length < 2) {
        if (activo) {
            showToast("Ruta invlida o inexistente. No se pueden buscar radares.", "warning");
        }
        eliminarRadaresDeRuta();
        actualizarContadorRadares(0);
        return;
    }
    eliminarRadaresDeRuta();
    radaresEnRutaActual = [];
    if (activo && navigationMapInstance && navigationRouteLayer) {
        try {
            const routeLineString = turf.lineString(navigationRouteLayer.getLatLngs().map(latlng => [latlng.lng, latlng.lat]));
            let filesToProcess = await fetchKMLFilesList(KML_FILES_LIST_STANDARD);
            const extraFiles = await fetchKMLFilesList(KML_FILES_LIST_EXTRA);
            filesToProcess = filesToProcess.concat(extraFiles.filter(f => !filesToProcess.includes(f)));
            for (const kmlFileName of filesToProcess) {
                const placemarks = await fetchAndParseKML(KML_BASE_PATH + kmlFileName);
                placemarks.forEach(placemark => {
                    const coords = placemark.coordinates;
                    if (coords) {
                        const [lonStr, latStr] = coords.split(',');
                        const lon = parseFloat(lonStr);
                        const lat = parseFloat(latStr);
                        if (isNaN(lat) || isNaN(lon)) return;
                        const radarPoint = turf.point([lon, lat]);
                        const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, radarPoint, { units: 'meters' });
                        if (nearestPointOnRoute && nearestPointOnRoute.properties.dist !== undefined && nearestPointOnRoute.properties.dist <= RUTA_RADAR_PROXIMITY_THRESHOLD) {
                            const existingMapObject = reminderMapObjects.find(obj =>
                                obj.isFromRuta &&
                                Math.abs(obj.marker.getLatLng().lat - lat) < COORD_EPSILON &&
                                Math.abs(obj.marker.getLatLng().lng - lon) < COORD_EPSILON
                            );
                            if (!existingMapObject) {
                                const now = new Date();
                                const radarData = {
                                    id: Date.now() + Math.random() + radaresEnRutaActual.length,
                                    text: `<b>RADAR RUTA: ${placemark.name}</b>`,
                                    type: 'simple', time: '00:00',
                                    date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                                    createdAt: now.toISOString(),
                                    managedByUser: false, isLocationEnabled: true,
                                    locationCoordinates: { latitude: lat, longitude: lon },
                                    radiusMeters: 350, excludeFromList: true,
                                    isFromRuta: true,
                                    distanceOnRoute: nearestPointOnRoute.properties.location
                                };
                                const mapObject = plotSingleReminderOnMap(radarData, navigationMapInstance);
                                if (mapObject) {
                                    reminderMapObjects.push(mapObject);
                                    radaresEnRutaActual.push(radarData);
                                }
                            }
                        }
                    }
                });
            }
            if (radaresEnRutaActual.length === 0 && activo) {
            }
        } catch (error) {
        }
    }
    actualizarContadorRadares(radaresEnRutaActual.length);
    if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
    if (radaresRutaCheckbox) {
        radaresRutaCheckbox.checked = activo;
    }
}





// ===================================================================
// NOMBRE: toggleTareasRuta
// RESUMEN: Activa/desactiva la visualizacin de tareas personales en la ruta.
// ===================================================================
async function toggleTareasRuta(activo) {
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(activo));
    if (actualWaypoints.length < 2) {
        if (activo) {
            showToast("Ruta invlida o inexistente. No se pueden buscar tareas en ruta.", "warning");
        }
        eliminarTareasDeBarraProgreso();
        actualizarContadorTareas(0);
        return;
    }
    eliminarTareasDeBarraProgreso();
    tareasEnRutaActual = [];
    if (activo && navigationMapInstance && navigationRouteLayer) {
        try {
            const routeLineString = turf.lineString(navigationRouteLayer.getLatLngs().map(latlng => [latlng.lng, latlng.lat]));
            const allReminders = JSON.parse(localStorage.getItem('reminders') || '[]');
            const locationReminders = allReminders.filter(r => r.isLocationEnabled && r.locationCoordinates);
            locationReminders.forEach(reminder => {
                const taskPoint = turf.point([reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]);
                const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, taskPoint, { units: 'meters' });
                const radius = reminder.radiusMeters || DEFAULT_LOCATION_RADIUS;
                if (nearestPointOnRoute && nearestPointOnRoute.properties.dist !== undefined && nearestPointOnRoute.properties.dist <= radius) {
                    tareasEnRutaActual.push({
                        ...reminder,
                        distanceOnRoute: nearestPointOnRoute.properties.location
                    });
                }
            });
        } catch (error) {
             showToast("Error al procesar tareas en ruta: " + error.message, "error");
        }
    }
    actualizarContadorTareas(tareasEnRutaActual.length);
    if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
    if (tareasRutaCheckbox) {
        tareasRutaCheckbox.checked = activo;
    }
}





// ===================================================================
// NOMBRE: eliminarRadaresDeRuta
// RESUMEN: Elimina del mapa los radares que se haban aadido dinmicamente a la ruta.
// ===================================================================
function eliminarRadaresDeRuta() {
    reminderMapObjects = reminderMapObjects.filter(obj => {
        if (obj.isFromRuta) {
            if (obj.marker && navigationMapInstance && navigationMapInstance.hasLayer(obj.marker)) obj.marker.remove();
            if (obj.circle && navigationMapInstance && navigationMapInstance.hasLayer(obj.circle)) obj.circle.remove();
            return false;
        }
        return true;
    });
    radaresEnRutaActual = [];
    actualizarContadorRadares(0);
    if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
         updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
}





// ===================================================================
// NOMBRE: eliminarTareasDeBarraProgreso
// RESUMEN: Limpia las tareas de la barra de progreso de la ruta.
// ===================================================================
function eliminarTareasDeBarraProgreso() {
    tareasEnRutaActual = [];
    actualizarContadorTareas(0);
    if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
}








    // ===================================================================
// NOMBRE: showSimulationModal
// RESUMEN: Muestra un modal con la lista de maniobras de la ruta.
// ===================================================================
async function showSimulationModal() {
    const canSimulate = (navigationWaypoints.filter(wp => !wp.isInternal && !wp.isRecalculatedStart).length >= 2 && navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) ||
                    (isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]);
    if (!canSimulate) {
        showToast("Se necesitan al menos 2 puntos y una ruta calculada para mostrar las intersecciones.", "warning");
        return;
    }
    const route = navigationCurrentRouteData.routes[0];
    if (!route || !route.legs || route.legs.length === 0) {
        showToast("Datos de ruta incompletos para mostrar intersecciones.", "error");
        return;
    }
    closeOtherModals('simulation-modal');
    
    // Mostramos un modal con placeholders primero
    let modal = document.getElementById('simulation-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'simulation-modal';
        document.body.appendChild(modal);
    }
    modal.innerHTML = `
        <h2 style="font-size: 1.3rem; font-weight: bold; text-align: center; margin-bottom: 1rem; color: #333;">Maniobras de la Ruta</h2>
        <div class="modal-top-buttons" style="justify-content: flex-start; margin-bottom: 1rem;">
            <button id="close-simulation-modal" style="flex: 0 0 auto; width: auto; min-width: unset;">Salir <span class="button-countdown-timer"></span></button>
        </div>
        <div id="simulation-content-area"><p>Cargando maniobras...</p></div>
    `;
    modal.classList.remove('hidden');

    const closeButton = modal.querySelector('#close-simulation-modal');
    const closeSimulationModalHandler = () => {
        if (simulationModalTimer) clearTimeout(simulationModalTimer);
        clearModalAutoCloseTimer(modal, closeButton, 'simulation-modal');
        modal.classList.add('hidden');
        hideIntersectionPreviewMap();
    };
    closeButton.addEventListener('click', closeSimulationModalHandler);
    addModalAutoCloseTimer(modal, closeButton, 'simulation-modal', 50000);

    // Ahora generamos el contenido asncronamente
    const carDist = lastCarDistanceAlongRouteForNavLogic;
    let simulationList = document.createElement('ul');
    let stepsShown = 0;
    let currentStageNumber = 1;
    let displayedStageHeader = false;
    let firstVisibleLegIndex = isNavigating ? currentLegIndexNav : 0;
    let firstVisibleStepIndex = isNavigating ? currentStepIndexNav : 0;
    
    for (let legIdx = firstVisibleLegIndex; legIdx < route.legs.length; legIdx++) {
        const leg = route.legs[legIdx];
        if (!leg || !leg.steps) continue;
        let startStepThisLegLoop = (legIdx === firstVisibleLegIndex) ? firstVisibleStepIndex : 0;
        if (!displayedStageHeader || legIdx > firstVisibleLegIndex) {
             const stageAddress = navigationWaypoints[legIdx + 1] ? navigationWaypoints[legIdx+1].address : "";
             const stageDistance = leg.distance ? (leg.distance / 1000).toFixed(1) + " km" : "Dist. desc.";
             const headerLi = document.createElement('li');
             headerLi.style.cssText = "background-color: #e0e0e0; font-weight: bold; padding: 5px; margin-top:5px;";
             headerLi.textContent = `ETAPA ${currentStageNumber}: ${stageAddress} (Total ${stageDistance})`;
             simulationList.appendChild(headerLi);
             currentStageNumber++;
             displayedStageHeader = true;
             if (legIdx > firstVisibleLegIndex) displayedStageHeader = false;
        }
        for (let stepIdx = startStepThisLegLoop; stepIdx < leg.steps.length; stepIdx++) {
            const step = leg.steps[stepIdx];
            if (!step || !step.maneuver) continue;
            const distanceToEndOfThisStep = calculateDistanceToEndOfStep(route, legIdx, stepIdx);
            const distanceToThisStepManeuver = Math.max(0, distanceToEndOfThisStep - carDist);
            if (distanceToEndOfThisStep > carDist || (legIdx === route.legs.length - 1 && stepIdx === leg.steps.length - 1 && distanceToThisStepManeuver <= 10) ) {
                const maneuver = step.maneuver;
                const type = maneuver.type || '';
                
                const maneuverText = getManeuverInstructionText(maneuver);
                let streetNameText = step.name || '';
                if (type === 'arrive' || type === 'depart' || type === 'end of road' || type === 'roundabout' || type === 'rotary') {
                    streetNameText = '';
                } else if (streetNameText.toLowerCase() === 'contina' && maneuverText.toLowerCase() !== 'contina') {
                    streetNameText = '';
                }
                
                let distanceFormatted = (distanceToThisStepManeuver >= 1000) ? `${(distanceToThisStepManeuver / 1000).toFixed(1)} km` : `${Math.round(distanceToThisStepManeuver)} m`;
                
                const li = document.createElement('li');
                li.dataset.legIndex = legIdx;
                li.dataset.stepIndex = stepIdx;
                li.style.cursor = 'pointer';
                
                const iconContainer = document.createElement('span');
                iconContainer.className = 'turn-icon-sim';
                
                const textContainer = document.createElement('span');
                textContainer.innerHTML = `${maneuverText}${streetNameText ? ` <strong>${streetNameText}</strong>` : ''} (${distanceFormatted})`;
                
                li.appendChild(iconContainer);
                li.appendChild(textContainer);
                simulationList.appendChild(li);

                // --- INICIO DE LA CORRECCIN ---
                // Se reemplaza la llamada a la funcin inexistente por la lgica correcta.
                const iconFilename = getManeuverIconFilename(maneuver);
                const iconUrl = `https://boardinggate.github.io/Tesla/${iconFilename}`;
                iconContainer.innerHTML = `<img src="${iconUrl}" alt="Maniobra" style="width:24px; height:24px; object-fit:contain;">`;
                // --- FIN DE LA CORRECCIN ---
                
                stepsShown++;
                if (stepsShown >= 15 && isNavigating) break;
            }
        }
        if (stepsShown >= 15 && isNavigating) break;
    }
    
    const contentArea = modal.querySelector('#simulation-content-area');
    if (stepsShown > 0) {
        contentArea.innerHTML = '';
        contentArea.appendChild(simulationList);
        contentArea.removeEventListener('click', handleSimulationItemClick);
        contentArea.addEventListener('click', handleSimulationItemClick);
    } else {
        contentArea.innerHTML = "<p>No hay ms interacciones futuras en la ruta o ests muy cerca del final.</p>";
    }
}
    

    





// ===================================================================
// NOMBRE: showIntersectionPreviewMap (VERSIN CORREGIDA Y ROBUSTA)
// RESUMEN: Muestra un minimapa detallado de la interseccin, asegurando su correcta inicializacin.
// ===================================================================
function showIntersectionPreviewMap(step, route, isSimulationContextOrClick = false, timerDurationMs = null) {
    const previewWindow = document.getElementById('intersection-preview-map-window');
    const progressBarEl = document.getElementById('navigation-bottom-progress-bar');
    if (!previewWindow || !step || !step.geometry || !route || !navigationMapInstance) {
        hideIntersectionPreviewMap();
        return;
    }
    const DISTANCE_BEFORE_MANEUVER_METERS = 110;
    const DISTANCE_AFTER_MANEUVER_METERS = 90;
    const CAR_POSITION_BEFORE_MANEUVER_METERS = 25;
    if (!previewWindow.querySelector('#intersection-rotator')) {
        previewWindow.innerHTML = `
            <div id="intersection-rotator" style="width: 100%; height: 100%; transition: transform 0.3s ease-out;">
                <div id="intersection-preview-map-container" style="width: 100%; height: 100%;"></div>
            </div>
        `;
    }
    const rotatorDiv = previewWindow.querySelector('#intersection-rotator');
    const mapContainerEl = previewWindow.querySelector('#intersection-preview-map-container');
    const isProgressBarVisible = progressBarEl && progressBarEl.offsetParent !== null;

    if (isProgressBarVisible) {
        const progressBarRect = progressBarEl.getBoundingClientRect();
        previewWindow.style.width = `${progressBarRect.width}px`;
        previewWindow.style.top = `${progressBarRect.bottom + 5}px`;
        previewWindow.style.left = `${progressBarRect.left}px`;
        previewWindow.style.transform = 'none';
    } else if (isSimulationContextOrClick) {
        previewWindow.style.width = '90%';
        previewWindow.style.maxWidth = '500px';
        previewWindow.style.left = '50%';
        previewWindow.style.top = '50%';
        previewWindow.style.transform = 'translate(-50%, -50%)';
    } else {
        hideIntersectionPreviewMap();
        return;
    }

    previewWindow.classList.remove('hidden');
    previewWindow.dataset.source = isSimulationContextOrClick ? 'click' : 'auto';
    if (intersectionPreviewTimer) clearTimeout(intersectionPreviewTimer);

    try {
        // --- INICIO DE LA CORRECCIN CLAVE ---
        // Destruimos la instancia del mapa anterior si existe. Esto fuerza a Leaflet
        // a reinicializarse y medir correctamente el contenedor cada vez.
        if (intersectionPreviewMap) {
            try {
                intersectionPreviewMap.remove();
            } catch(e) {}
            intersectionPreviewMap = null;
        }
        // --- FIN DE LA CORRECCIN CLAVE ---

        // Ahora, siempre creamos una nueva instancia del mapa
        intersectionPreviewMap = L.map(mapContainerEl, {
            zoomControl: false, dragging: false, touchZoom: false, scrollWheelZoom: false,
            doubleClickZoom: false, boxZoom: false, keyboard: false, attributionControl: false
        });

        if (rotatorDiv) {
            rotatorDiv.style.transition = 'none';
            rotatorDiv.style.transform = 'rotate(0deg)';
        }

        const currentMapLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "Satlite + Calles";
        let tileLayerInstance;
        if (currentMapLayerName.toLowerCase().includes("satlite puro")) {
            tileLayerInstance = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles  Esri' });
        } else if (currentMapLayerName.toLowerCase().includes("satlite + calles")) {
            const labelsPaneName = 'intersection_labels_pane_unique';
            tileLayerInstance = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles  Esri' });
            if (!intersectionPreviewMap.getPane(labelsPaneName)) {
                intersectionPreviewMap.createPane(labelsPaneName);
                intersectionPreviewMap.getPane(labelsPaneName).style.zIndex = 650;
                intersectionPreviewMap.getPane(labelsPaneName).style.pointerEvents = 'none';
            }
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', { attribution: ' OSM  CARTO', pane: labelsPaneName }).addTo(intersectionPreviewMap);
        } else {
            tileLayerInstance = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: ' OpenStreetMap' });
        }
        tileLayerInstance.addTo(intersectionPreviewMap);

        const maneuverPoint = L.latLng(step.maneuver.location[1], step.maneuver.location[0]);
        const fullRouteLineString = turf.lineString(route.geometry.coordinates);
        const maneuverPointOnRoute = turf.nearestPointOnLine(fullRouteLineString, step.maneuver.location, { units: 'kilometers' });
        const maneuverDistanceKm = maneuverPointOnRoute.properties.location;
        const startSliceDistanceKm = Math.max(0, maneuverDistanceKm - (DISTANCE_BEFORE_MANEUVER_METERS / 1000));
        const endSliceDistanceKm = Math.min(turf.length(fullRouteLineString), maneuverDistanceKm + (DISTANCE_AFTER_MANEUVER_METERS / 1000));
        const startSlicePoint = turf.along(fullRouteLineString, startSliceDistanceKm);
        const endSlicePoint = turf.along(fullRouteLineString, endSliceDistanceKm);
        const routeSlice = turf.lineSlice(startSlicePoint, endSlicePoint, fullRouteLineString);
        const routeSegmentCoords = routeSlice.geometry.coordinates.map(c => [c[1], c[0]]);

        intersectionPreviewRouteLayer = L.polyline(routeSegmentCoords, { color: 'orange', weight: 10, opacity: 1 }).addTo(intersectionPreviewMap);
        intersectionPreviewManeuverMarker = L.circleMarker(maneuverPoint, { radius: 5, color: 'white', weight: 1, fillColor: 'blue', fillOpacity: 1, zIndexOffset: 1000 }).addTo(intersectionPreviewMap);
        
        const lineStringToPlaceCar = turf.lineString(routeSegmentCoords.map(c => [c[1], c[0]]));
        const distanceForCarOnSegment = Math.max(0, DISTANCE_BEFORE_MANEUVER_METERS - CAR_POSITION_BEFORE_MANEUVER_METERS);
        const carPositionPointTurf = turf.along(lineStringToPlaceCar, distanceForCarOnSegment, { units: 'meters' });
        const carPositionLatLng = L.latLng(carPositionPointTurf.geometry.coordinates[1], carPositionPointTurf.geometry.coordinates[0]);
        intersectionPreviewCarMarker = L.marker(carPositionLatLng, { icon: vehicleIconMiniMap, zIndexOffset: 1001 }).addTo(intersectionPreviewMap);

        const bounds = L.latLngBounds(routeSegmentCoords).pad(0.5);

        requestAnimationFrame(() => {
            if (intersectionPreviewMap && document.body.contains(mapContainerEl)) {
                intersectionPreviewMap.invalidateSize();
                
                const maneuverType = step.maneuver.type || '';
                const maneuverModifier = step.maneuver.modifier || '';
                const isShortManeuver = maneuverType.includes('roundabout') || maneuverType.includes('rotary') || maneuverModifier.includes('sharp') || maneuverModifier.includes('uturn');
                const mapMaxZoom = intersectionPreviewMap.getMaxZoom() || 19;
                let targetZoom;
                if (isShortManeuver) {
                    targetZoom = mapMaxZoom;
                } else {
                    const zoomThatFitsBounds = intersectionPreviewMap.getBoundsZoom(bounds);
                    targetZoom = Math.max(16, zoomThatFitsBounds - 0.5);
                }
                targetZoom = Math.min(targetZoom, mapMaxZoom);
                intersectionPreviewMap.fitBounds(bounds, { animate: false, paddingTopLeft: [0, 50], paddingBottomRight: [0, 50], maxZoom: targetZoom });
                
                requestAnimationFrame(() => {
                    let segmentBearing = 0;
                    const lookAheadPointTurf = turf.along(lineStringToPlaceCar, distanceForCarOnSegment + 5, { units: 'meters' });
                    if (lookAheadPointTurf) {
                        segmentBearing = turf.bearing(carPositionPointTurf, lookAheadPointTurf);
                        if (segmentBearing < 0) segmentBearing += 360;
                    } else {
                        segmentBearing = (navigationCurrentLocation && typeof navigationCurrentLocation.heading === 'number') ? navigationCurrentLocation.heading : currentMapBearing;
                    }
                    const shouldRotateMap = (segmentBearing > 135 && segmentBearing < 225);
                    const mapRotation = shouldRotateMap ? 180 : 0;
                    if (rotatorDiv) {
                        rotatorDiv.style.transition = 'transform 0.3s ease-out';
                        rotatorDiv.style.transform = `rotate(${mapRotation}deg)`;
                    }
                    const finalIconRotation = segmentBearing - 90;
                    if (intersectionPreviewCarMarker && intersectionPreviewCarMarker.getElement()) {
                        const carWrapperMini = intersectionPreviewCarMarker.getElement().querySelector('.vehicle-icon-minimap');
                        if (carWrapperMini) {
                            carWrapperMini.style.transform = `rotate(${finalIconRotation}deg)`;
                        }
                    }
                });
            }
        });

        if (timerDurationMs && timerDurationMs > 0) {
            intersectionPreviewTimer = setTimeout(hideIntersectionPreviewMap, timerDurationMs);
        }
    } catch (error) {
        console.error("Error al mostrar el mapa de interseccin:", error);
        hideIntersectionPreviewMap();
    }
}






    





// ===================================================================
// NOMBRE: updateTurnByTurnDisplay (VERSIN CORREGIDA)
// RESUMEN: Actualiza la barra de informacin de giro en la navegacin.
// ===================================================================
function updateTurnByTurnDisplay(route, carDistanceAlongTheRoute = 0) {
    const topInfoBar = document.getElementById('navigation-top-info-bar');
    const intersectionPreviewWindow = document.getElementById('intersection-preview-map-window');
    
    if (!route || !topInfoBar || !route.legs || route.legs.length === 0) {
        if (topInfoBar) topInfoBar.style.display = 'none';
        if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
        updateDirectionWarningCardsVisibility();
        return;
    }
    if (!isNavigating && (!navigationCurrentRouteData || navigationWaypoints.length < 2)) {
         if (topInfoBar) topInfoBar.style.display = 'none';
         if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
         updateDirectionWarningCardsVisibility();
         return;
    }

    topInfoBar.style.display = 'flex';
    const turnIconDisplayEl = document.getElementById('turn-icon-display');
    const maneuverTextEl = document.getElementById('maneuver-text-display');
    const distanceFormattedEl = document.getElementById('distance-to-turn-formatted');
    const streetEl = document.getElementById('street-name-display');
    const progressBarEl = document.getElementById('distance-progress-bar-to-turn');
    
    // --- INICIO DE LA CORRECCIN ---
    // Aadimos estilos al contenedor <span> para que ocupe el 100% de su padre
    // (#turn-icon-container-styled) y as pueda centrar correctamente la imagen.
    if (turnIconDisplayEl) {
        turnIconDisplayEl.style.width = '100%';
        turnIconDisplayEl.style.height = '100%';
        turnIconDisplayEl.style.display = 'flex';
        turnIconDisplayEl.style.alignItems = 'center';
        turnIconDisplayEl.style.justifyContent = 'center';
    }
    // --- FIN DE LA CORRECCIN ---

    const carDistance = Math.min(Math.max(0, carDistanceAlongTheRoute), route.distance);
    let distanceCoveredInRoute = 0;
    let currentLegIndex = -1, currentStepIndex = -1;
    let nextStepToDisplay = null, distanceToEndOfCurrentStepForProgress = 0;
    let previousStepForPath = null;

    for (let i = 0; i < route.legs.length; i++) {
        const leg = route.legs[i];
        for (let j = 0; j < leg.steps.length; j++) {
            const step = leg.steps[j];
            if (carDistance < distanceCoveredInRoute + step.distance) {
                currentLegIndex = i; currentStepIndex = j;
                distanceToEndOfCurrentStepForProgress = distanceCoveredInRoute + step.distance;
                if (j > 0) {
                    previousStepForPath = leg.steps[j - 1];
                } else if (i > 0) {
                    previousStepForPath = route.legs[i-1].steps[route.legs[i-1].steps.length - 1];
                }
                break;
            }
            distanceCoveredInRoute += step.distance;
        }
        if (currentLegIndex !== -1) break;
    }

    if (currentLegIndex === -1) {
        currentLegIndex = route.legs.length - 1;
        currentStepIndex = route.legs[currentLegIndex].steps.length - 1;
    }
    
    currentLegIndexNav = currentLegIndex;
    currentStepIndexNav = currentStepIndex;
    const currentLeg = route.legs[currentLegIndex];
    if (currentStepIndex + 1 < currentLeg.steps.length) {
        nextStepToDisplay = currentLeg.steps[currentStepIndex + 1];
    } else if (currentLegIndex + 1 < route.legs.length) {
        nextStepToDisplay = route.legs[currentLegIndex + 1].steps[0];
    } else {
        nextStepToDisplay = currentLeg.steps[currentStepIndex];
    }
    const currentStepForProgress = currentLeg.steps[currentStepIndex];
    const distanceToNextManeuver = Math.max(0, distanceToEndOfCurrentStepForProgress - carDistance);
    navigationTargetZoom = handleProgressiveManeuverZoom(currentStepForProgress, distanceToNextManeuver);

    if (nextStepToDisplay && nextStepToDisplay.maneuver) {
        const maneuver = nextStepToDisplay.maneuver;
        const type = maneuver.type || '';
        const maneuverText = getManeuverInstructionText(maneuver);

        if (turnIconDisplayEl) {
            const iconFilename = getManeuverIconFilename(maneuver);
            const iconUrl = `https://boardinggate.github.io/Tesla/${iconFilename}`;
            turnIconDisplayEl.innerHTML = `<img src="${iconUrl}" alt="${maneuverText}" style="width: 95%; height: 95%; object-fit: contain; image-rendering: pixelated;">`;
        }

        let streetNameText = nextStepToDisplay.name || '';
        if (type === 'arrive' || type === 'depart' || type.includes('roundabout') || type === 'end of road') { streetNameText = ''; }
        
        maneuverTextEl.textContent = maneuverText ? `${maneuverText} ` : '';
        streetEl.textContent = streetNameText;
        
        distanceToNextManeuverOSRM = distanceToNextManeuver;
        distanceFormattedEl.textContent = distanceToNextManeuver < 1000 ? `${Math.round(distanceToNextManeuver / 5) * 5} m` : `${(distanceToNextManeuver / 1000).toFixed(1)} km`;

        const distanceCoveredInCurrentStep = (currentStepForProgress.distance || 0) - distanceToNextManeuver;
        const progressPercent = (currentStepForProgress.distance > 0) ? (distanceCoveredInCurrentStep / currentStepForProgress.distance) * 100 : (distanceToNextManeuver === 0 ? 100 : 0);
        if(progressBarEl) progressBarEl.style.width = `${Math.min(100, Math.max(0, progressPercent))}%`;

        if (isNavigating && previousStepForPath && completedRouteSegmentsLayer && navigationCurrentLocation) {
             if (previousStepForPath.maneuver && previousStepForPath.maneuver.location && previousStepForPath.maneuver.location.length === 2) {
                const prevManeuverLocLatLng = L.latLng(previousStepForPath.maneuver.location[1], previousStepForPath.maneuver.location[0]);
                 if (!lastProcessedStepManeuverLocation || (lastProcessedStepManeuverLocation.lat.toFixed(5) !== prevManeuverLocLatLng.lat.toFixed(5) || lastProcessedStepManeuverLocation.lng.toFixed(5) !== prevManeuverLocLatLng.lng.toFixed(5))) {
                    if (previousStepForPath.geometry && previousStepForPath.geometry.coordinates) {
                        const segmentCoords = previousStepForPath.geometry.coordinates.map(c => [c[1], c[0]]);
                        if (segmentCoords.length >= 2) {
                            if (completedRouteSegmentsLayer) L.polyline(segmentCoords, { color: 'green', weight: 6, opacity: 0.8 }).addTo(completedRouteSegmentsLayer);
                            lastProcessedStepManeuverLocation = prevManeuverLocLatLng;
                        }
                    }
                }
            }
        }
        
        const isRelevantIntersectionManeuver = type !== 'continue' && type !== 'new name' && type !== 'depart' && type !== 'straight';
        if (isNavigating && distanceToNextManeuver < 800 && distanceToNextManeuver >= 100 && isRelevantIntersectionManeuver && (!intersectionPreviewWindow || intersectionPreviewWindow.classList.contains('hidden') || intersectionPreviewWindow.dataset.source !== 'click') && (currentLegIndex + '_' + currentStepIndex) !== lastAutoShownManeuverId) {
            showIntersectionPreviewMap(nextStepToDisplay, route, false, 6000);
            lastAutoShownManeuverId = currentLegIndex + '_' + currentStepIndex;
        } else if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click' && (distanceToNextManeuver >= 800 || distanceToNextManeuver < 100 || !isRelevantIntersectionManeuver)) {
            hideIntersectionPreviewMap();
        }

    } else {
        if (turnIconDisplayEl) {
            turnIconDisplayEl.innerHTML = `<img src="https://boardinggate.github.io/Tesla/arrive.png" style="width:95%; height:95%; object-fit:contain;">`;
        }
        maneuverTextEl.textContent = '';
        streetEl.textContent = 'Has llegado a tu destino';
        distanceFormattedEl.textContent = '0 m';
        if(progressBarEl) progressBarEl.style.width = '100%';
        distanceToNextManeuverOSRM = Infinity;
        if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
    }
    
    updateDirectionWarningCardsVisibility();
}


// ===================================================================
// NOMBRE: handleSimulationItemClick (VERSIN CORREGIDA)
// RESUMEN: Maneja el clic en un elemento de la lista de maniobras para mostrar el detalle del mapa.
// ===================================================================
function handleSimulationItemClick(event) {
    const listItem = event.target.closest('li[data-leg-index][data-step-index]');
    if (!listItem) {
        return;
    }
    if (!navigationCurrentRouteData || !navigationCurrentRouteData.routes || navigationCurrentRouteData.routes.length === 0) {
        showToast("No hay datos de ruta actuales para mostrar el detalle de la maniobra.", "warning", 3000);
        return;
    }
    const legIndex = parseInt(listItem.dataset.legIndex);
    const stepIndex = parseInt(listItem.dataset.stepIndex);
    const route = navigationCurrentRouteData.routes[0];
    if (route.legs && legIndex < route.legs.length && route.legs[legIndex].steps && stepIndex < route.legs[legIndex].steps.length) {
        const step = route.legs[legIndex].steps[stepIndex];
        // La llamada a la funcin corregida se encargar de todo.
        showIntersectionPreviewMap(step, route, true, 7000);
    } else {
        showToast("No se pudo encontrar la maniobra seleccionada en los datos de la ruta.", "error", 3000);
        hideIntersectionPreviewMap();
    }
}





    

    









// ===================================================================
// NOMBRE: showMapInfoOverlay
// RESUMEN: Muestra un mensaje de informacin sobre el mapa de navegacin.
// ===================================================================
function showMapInfoOverlay(message, isError = false) {
    const overlay = document.getElementById('map-info-overlay');
    if (overlay) {
        let finalMessage = message;
        if (message.startsWith(" ")) {
            const destName = message.substring(" ".length).trim().replace(/<br>/gi, ' ');
            finalMessage = " " + (destName.length > 55 ? destName.substring(0, 52) + "..." : destName);
        } else if (message.startsWith("ETAPA ")) {
            const stageInfo = message.substring("ETAPA ".length).trim().replace(/<br>/gi, ' ');
            finalMessage = "ETAPA " + (stageInfo.length > 55 ? stageInfo.substring(0, 52) + "..." : stageInfo);
        } else if (message.startsWith("HA LLEGADO AL ")) {
            const destinationName = message.substring("HA LLEGADO AL : ".length).trim().replace(/<br>/gi, ' ');
            finalMessage = "HA LLEGADO A: " + (destinationName.length > 55 ? destinationName.substring(0, 52) + "..." : destinationName);
        }
        overlay.innerHTML = `<span>${finalMessage}</span>`;
        overlay.style.display = 'block';
        overlay.style.backgroundColor = isError ? 'rgba(220, 50, 50, 0.5)' : 'rgba(0,0,0,0.5)';
    }
}





// ===================================================================
// NOMBRE: hideMapInfoOverlay
// RESUMEN: Oculta el mensaje de informacin del mapa.
// ===================================================================
function hideMapInfoOverlay() {
    const overlay = document.getElementById('map-info-overlay');
    if (overlay) {
        overlay.textContent = '';
        overlay.style.display = 'none';
    }
}





// ===================================================================
// NOMBRE: showDestinationName
// RESUMEN: Muestra el nombre del destino o de la siguiente etapa en el overlay del mapa.
// ===================================================================
function showDestinationName() {
    if (!navigationWaypoints || navigationWaypoints.length === 0) {
        hideMapInfoOverlay();
        return;
    }
    let message = "";
    let nextUnvisitedStageWp = null;
    if (isNavigating) {
        const totalEtapas = navigationCurrentRouteData?.routes?.[0]?.legs?.length || 0;
        const etapaActualUsuario = currentLegIndexNav + 1;
        for(let i = currentLegIndexNav; i < navigationWaypoints.length; i++) {
            const waypointToCheck = navigationWaypoints[i];
            if (waypointToCheck && !waypointToCheck.isInternal && !waypointToCheck.visited && waypointToCheck.type !== 'S' && waypointToCheck.type !== 'S_Recalc') {
                nextUnvisitedStageWp = waypointToCheck;
                break;
            }
        }
         if (!nextUnvisitedStageWp && navigationWaypoints.length > 0) {
            const lastWaypoint = navigationWaypoints[navigationWaypoints.length -1];
            if (lastWaypoint.type === 'F' && !lastWaypoint.visited) {
                 nextUnvisitedStageWp = lastWaypoint;
            }
        }
        if (nextUnvisitedStageWp) {
            if (nextUnvisitedStageWp.type === 'F') {
                message = ` ${nextUnvisitedStageWp.address || ' Final'}`;
            } else if (nextUnvisitedStageWp.type === 'intermediate' && totalEtapas > 1) {
                message = `ETAPA ${etapaActualUsuario} de ${totalEtapas}: ${nextUnvisitedStageWp.address || `Etapa ${nextUnvisitedStageWp.label}`}`;
            } else {
                 message = ` ${nextUnvisitedStageWp.address || 'Siguiente Punto'}`;
            }
        } else {
            const finalDestination = navigationWaypoints[navigationWaypoints.length - 1];
            if (finalDestination && !finalDestination.isInternal) {
                 message = ` ${finalDestination.address || ' Final'}`;
            } else {
                 message = "RUTA NO DEFINIDA";
            }
        }
    } else {
        const finalDestination = navigationWaypoints[navigationWaypoints.length - 1];
        if (finalDestination && !finalDestination.isInternal) {
             message = ` ${finalDestination.address || ' Final'}`;
        } else {
             message = "RUTA NO DEFINIDA";
        }
    }
    showMapInfoOverlay(message);
}





// ===================================================================
// NOMBRE: openLocationsPreviewMap
// RESUMEN: Abre un mapa modal que muestra todos los recordatorios con ubicacin.
// ===================================================================
function openLocationsPreviewMap() {
    closeOtherModals('locations-preview-modal');
     let modal = document.getElementById('locations-preview-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'locations-preview-modal';
        modal.innerHTML = `
            <h2 id="locations-preview-title">Ubicaciones con Recordatorios</h2>
            <div id="locations-preview-map-container" style="height: calc(100% - 100px); width: 100%;"></div>
            <div class="modal-top-buttons" style="justify-content: center; margin-top: 1rem;">
                <button id="close-locations-preview">Salir</button>
            </div>
        `;
        document.body.appendChild(modal);
    }
    modal.classList.remove('hidden');
    const mapContainer = modal.querySelector('#locations-preview-map-container');
    const closeButton = modal.querySelector('#close-locations-preview');
    const titleElement = modal.querySelector('#locations-preview-title');
    const closeHandler = () => {
        if (locationsPreviewMap) {
            try { locationsPreviewMap.remove(); } catch (e) {}
            locationsPreviewMap = null;
        }
        if (mapLayersControlLocationsPreview) {
            try {mapLayersControlLocationsPreview.remove();} catch(e){}
            mapLayersControlLocationsPreview = null;
        }
        clearModalAutoCloseTimer(modal, closeButton, 'locations-preview-modal');
        modal.classList.add('hidden');
    };
    const newCloseButton = closeButton.cloneNode(true);
    closeButton.parentNode.replaceChild(newCloseButton, closeButton);
    newCloseButton.addEventListener('click', closeHandler);
    newCloseButton.style.backgroundColor = '#4A5568';
    newCloseButton.style.color = 'white';
    newCloseButton.style.border = '1px solid #2D3748';
    newCloseButton.style.fontWeight = 'bold';
    newCloseButton.onmouseover = () => newCloseButton.style.backgroundColor = '#2D3748';
    newCloseButton.onmouseout = () => newCloseButton.style.backgroundColor = '#4A5568';
    addModalAutoCloseTimer(modal, newCloseButton, 'locations-preview-modal', 120000);
    if (locationsPreviewMap) {
        try { locationsPreviewMap.remove(); } catch (e) {}
        if(mapLayersControlLocationsPreview) { try {mapLayersControlLocationsPreview.remove();} catch(e){} mapLayersControlLocationsPreview = null;}
    }
    locationsPreviewMap = L.map(mapContainer, { zoomControl: true }).setView([40.416775, -3.703790], 6);
    const osmLayerLP = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: ' <a href="https://www.openstreetmap.org/copyright">OSM</a>' });
    const satelliteLayerLP = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles  Esri' });
    const satelliteWithLabelsLP = L.layerGroup([
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles  Esri' }),
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', { attribution: ' OSM  CARTO', pane: 'labels_locations_preview' })
    ]);
    if (!locationsPreviewMap.getPane('labels_locations_preview')) {
        locationsPreviewMap.createPane('labels_locations_preview');
        locationsPreviewMap.getPane('labels_locations_preview').style.zIndex = 650;
        locationsPreviewMap.getPane('labels_locations_preview').style.pointerEvents = 'none';
    }
    const baseMapsLP = { "Mapa Normal": osmLayerLP, "Satlite Puro": satelliteLayerLP, "Satlite + Calles": satelliteWithLabelsLP };
    const savedLayerNameLP = localStorage.getItem(ACTIVE_MAP_LAYER_KEY + '_locations_preview') || "Satlite + Calles";
    let initialLayerLP = baseMapsLP[savedLayerNameLP] || satelliteWithLabelsLP;
    initialLayerLP.addTo(locationsPreviewMap);
    mapLayersControlLocationsPreview = L.control.layers(baseMapsLP, null, {position: 'topright', collapsed: true}).addTo(locationsPreviewMap);
    locationsPreviewMap.on('baselayerchange', function(e) {
        localStorage.setItem(ACTIVE_MAP_LAYER_KEY + '_locations_preview', e.name);
    });
    const allReminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
    const locationsToPlot = allReminders.filter(r => {
        const hasLocation = r.isLocationEnabled && r.locationCoordinates?.latitude && r.locationCoordinates?.longitude;
        if (!hasLocation) return false;
        const isRadarText = r.text && r.text.toUpperCase().includes("RADAR:");
        if (showExcluded) {
            return true;
        } else {
            return !isRadarText;
        }
    });
    if (titleElement) {
        titleElement.textContent = `Ubicaciones con Recordatorios ${showExcluded ? '(incluyendo "RADAR")' : '(sin "RADAR")'}`;
    }
    const markers = [];
    locationsToPlot.forEach(reminder => {
        const latLng = [reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude];
         const isRadarTypeForIcon = reminder.text.toUpperCase().includes("RADAR:") || reminder.excludeFromList;
        const markerIconToUse = isRadarTypeForIcon ? smallRadarMarkerIcon : largeGreenLocationMarkerIcon;
        const isRadar = reminder.text.toUpperCase().includes("RADAR:");
        const circleColor = isRadar ? 'rgba(255, 165, 0, 0.2)' : 'blue';
        const circleFillColor = isRadar ? 'rgba(255, 165, 0, 0.2)' : '#ADD8E6';
        const circleFillOpacity = isRadar ? 0.2 : 0.05;
        const circleWeight = 1;
        const marker = L.marker(latLng, { icon: markerIconToUse })
            .addTo(locationsPreviewMap)
            .bindPopup(`<b>${reminder.text.replace(/<b>|<\/b>/gi,'')}</b><br>${reminder.time || ''} ${reminder.date ? formatDateDetailed(reminder.date) : ''}<br><button data-reminder-id="${reminder.id}" class="edit-reminder-from-preview-map" style="margin-top:5px;padding:3px 6px;background-color:#10B981;color:white;border:none;border-radius:3px;cursor:pointer;">Ver/Editar</button>`);
         L.circle(latLng, { radius: reminder.radiusMeters || DEFAULT_LOCATION_RADIUS, color: circleColor, fillColor: circleFillColor, weight: circleWeight, fillOpacity: circleFillOpacity }).addTo(locationsPreviewMap);
        marker.on('popupopen', () => {
            const editButton = marker.getPopup().getElement().querySelector('.edit-reminder-from-preview-map');
            if (editButton) {
                const newEditButton = editButton.cloneNode(true);
                editButton.parentNode.replaceChild(newEditButton, editButton);
                newEditButton.addEventListener('click', () => {
                    const id = parseInt(newEditButton.dataset.reminderId);
                    const remToEdit = allReminders.find(r => r.id === id);
                    if (remToEdit) {
                        closeHandler();
                        showReminderModal(remToEdit);
                    }
                });
            }
        });
        markers.push(marker);
    });
    if (markers.length > 0) {
        const group = new L.featureGroup(markers);
        locationsPreviewMap.fitBounds(group.getBounds().pad(0.2));
    } else {
        showToast(`No hay recordatorios con ubicacin para mostrar segn el filtro actual.`, "info");
    }
     requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            if(locationsPreviewMap) locationsPreviewMap.invalidateSize();
        });
    });
}





// ===================================================================
// NOMBRE: closeModalAndProceed (para desvos)
// RESUMEN: Cierra el modal de desvo de ruta.
// ===================================================================
function closeModalAndProceed() {
    if (deviationModalTimerId) {
        clearInterval(deviationModalTimerId);
        deviationModalTimerId = null;
    }
    const modal = document.getElementById('deviation-modal');
    if (modal) {
        const anyButton = modal.querySelector('button');
        if (anyButton) {
            clearModalAutoCloseTimer(modal, anyButton, 'deviation-modal');
        }
        modal.classList.add('hidden');
    }
    isDeviationModalActive = false;
    deviationStartTime = 0;
}







// ===================================================================
// NOMBRE: handleFinalDestinationSelection
// RESUMEN: Gestiona la seleccin de "Ir a Destino Final" desde el modal de desvo.
// ===================================================================
function handleFinalDestinationSelection() {
    const finalDestination = navigationWaypoints.find(wp => wp.type === 'F');
    if (!finalDestination) {
        showToast("Error: No se encontr el destino final.", "error");
        closeModalAndProceed();
        return;
    }
    navigationWaypoints.forEach(wp => {
        if (wp.type === 'intermediate') {
            wp.visited = true;
        }
    });
    closeModalAndProceed();
    recalculateAndDrawRoute(true); // CORREGIDO: Se pasa 'true' para preservar estadsticas
    renderWaypointMarkers();
}

// ===================================================================
// NOMBRE: handleStageSelectionFromDeviationModal
// RESUMEN: Gestiona la seleccin de una etapa especfica desde el modal de desvo.
// ===================================================================
function handleStageSelectionFromDeviationModal(selectedWaypointId) {
    const selectedIndex = navigationWaypoints.findIndex(wp => wp.id === selectedWaypointId);
    if (selectedIndex === -1) {
        showToast("Error: No se encontr la etapa seleccionada.", "error");
        closeModalAndProceed();
        return;
    }
    for (let i = 0; i < selectedIndex; i++) {
        const wp = navigationWaypoints[i];
        if (wp && !wp.isInternal && wp.type !== 'S' && wp.type !== 'S_Recalc') {
            wp.visited = true;
        }
    }
    navigationWaypoints[selectedIndex].visited = false;
    closeModalAndProceed();
    recalculateAndDrawRoute(true); // CORREGIDO: Se pasa 'true' para preservar estadsticas
    renderWaypointMarkers();
}





    






    


 // ===================================================================
// NOMBRE: clearModalAutoCloseTimer
// RESUMEN: Limpia un temporizador de autocierre de un modal.
// ===================================================================
function clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId) {
    const timerIdToClear = modalId || (modalElement ? modalElement.dataset.modalTimerId : null);
    if (timerIdToClear && globalModalTimers[timerIdToClear]) {
        clearInterval(globalModalTimers[timerIdToClear].intervalId);
        const timerData = globalModalTimers[timerIdToClear];
        if (timerData.modalElement && timerData.resetHandler) {
            timerData.modalElement.removeEventListener('click', timerData.resetHandler);
            timerData.modalElement.removeEventListener('touchstart', timerData.resetHandler);
            timerData.modalElement.removeEventListener('input', timerData.resetHandler);
            timerData.modalElement.removeEventListener('scroll', timerData.resetHandler);
        }
        if (timerData.countdownSpan && timerData.countdownSpan.parentNode) {
            timerData.countdownSpan.remove();
        }
        delete globalModalTimers[timerIdToClear];
    }
    if(closeButtonElement){
        const orphanSpans = closeButtonElement.querySelectorAll('.button-countdown-timer');
        orphanSpans.forEach(s => s.remove());
    }
     if(modalElement && modalElement.dataset.modalTimerId) {
        delete modalElement.dataset.modalTimerId;
    }
}

// ===================================================================
// NOMBRE: formatDateToDDMMMYY
// RESUMEN: Formatea una fecha (YYYY-MM-DD) a un formato legible (DD Mes Abreviado YY).
// ===================================================================
function formatDateToDDMMMYY(dateString) {
     if (!dateString) return '-';
     try {
         const [year, month, day] = dateString.split('-').map(Number);
         const date = new Date(Date.UTC(year, month - 1, day));
         if (isNaN(date.getTime())) return '-';
         const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
         const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
         const monthName = monthNames[date.getUTCMonth()];
         const yearShort = String(date.getUTCFullYear()).slice(-2);
         return `${dayOfMonth} ${monthName} ${yearShort}`;
     } catch (e) {
         return '-';
     }
}

// ===================================================================
// NOMBRE: calculateNextOccurrence
// RESUMEN: Calcula la prxima fecha de vencimiento de un recordatorio cclico.
// ===================================================================
function calculateNextOccurrence(reminder, referenceDate) {
      if (!reminder || !reminder.type || !reminder.time || !reminder.date) { return null; } try {
          let [year, month, day] = reminder.date.split('-').map(Number); let [hour, minute] = reminder.time.split(':').map(Number);
          let baseDate = new Date(Date.UTC(year, month - 1, day, hour, minute)); if (isNaN(baseDate.getTime())) { return null; }
          const refDateUTC = new Date(referenceDate.getTime()); if (baseDate > refDateUTC) return baseDate;
          if (reminder.type === 'simple') { return null; }
          if (reminder.type === 'daily' || reminder.type === 'hourly') { let next = new Date(baseDate); while (next <= refDateUTC) { next.setUTCDate(next.getUTCDate() + 1); } return next; }
          if (reminder.type === 'weekly' && reminder.repeatDays && reminder.repeatDays.length > 0) {
              let next = new Date(refDateUTC); next.setUTCHours(hour, minute, 0, 0);
              if (next <= refDateUTC || !reminder.repeatDays.includes(next.getUTCDay())) { next.setUTCDate(next.getUTCDate() + 1); }
              for (let i = 0; i < 7; i++) { if (reminder.repeatDays.includes(next.getUTCDay())) { return next; } next.setUTCDate(next.getUTCDate() + 1); } return null;
          }
          if (reminder.type === 'interval' && reminder.intervalDays && reminder.intervalDays > 0) { let next = new Date(baseDate); while (next <= refDateUTC) { next.setUTCDate(next.getUTCDate() + reminder.intervalDays); } return next; }
          return null; } catch (e) { return null; }
 }

// ===================================================================
// NOMBRE: calculatePostponedDateTime
// RESUMEN: Calcula la fecha y hora para posponer un recordatorio.
// ===================================================================
function calculatePostponedDateTime(mins) {
      const now = new Date(); const postponedDate = new Date(now.getTime() + mins * 60000);
      const newDateISO = `${postponedDate.getFullYear()}-${(postponedDate.getMonth() + 1).toString().padStart(2, '0')}-${postponedDate.getDate().toString().padStart(2, '0')}`;
      const newTime = `${postponedDate.getHours().toString().padStart(2, '0')}:${postponedDate.getMinutes().toString().padStart(2, '0')}`; return { newDateISO, newTime };
 }

// ===================================================================
// NOMBRE: handleDragEndReorder
// RESUMEN: Maneja la finalizacin de una operacin de arrastre en la lista de etapas.
// ===================================================================
function handleDragEndReorder(e) {
    if (draggedStageLi) {
        draggedStageLi.classList.remove('dragging');
    }
    draggedStageLi = null;
}

// ===================================================================
// NOMBRE: handleDragOverReorder
// RESUMEN: Maneja el evento de pasar por encima al arrastrar en la lista de etapas.
// ===================================================================
function handleDragOverReorder(e) {
    e.preventDefault();
    if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
    const listElement = document.getElementById('sortable-stages-list');
    if (!listElement || !draggedStageLi) return;
    const afterElement = getDragAfterElement(listElement, e.clientY);
    const currentLi = e.target.closest('li');
    if (draggedStageLi && currentLi && draggedStageLi !== currentLi) {
        if (afterElement == null) {
            listElement.appendChild(draggedStageLi);
        } else {
            listElement.insertBefore(draggedStageLi, afterElement);
        }
    } else if (draggedStageLi && !currentLi && afterElement == null) {
         listElement.appendChild(draggedStageLi);
    } else if (draggedStageLi && !currentLi && afterElement) {
         listElement.insertBefore(draggedStageLi, afterElement);
    }
}

// ===================================================================
// NOMBRE: handleStageTouchStart
// RESUMEN: Maneja el inicio de un toque en una etapa para reordenar.
// ===================================================================
function handleStageTouchStart(e) {
    if (e.touches.length === 1 && e.target.closest('.drag-handle')) {
        draggedStageLi = e.target.closest('li');
        if (!draggedStageLi) return;
        const touch = e.touches[0];
        stageTouchStartX = touch.clientX;
        stageTouchStartY = touch.clientY;
        clearTimeout(stageScrollTimeout);
        stageScrollTimeout = setTimeout(() => {
            if (draggedStageLi) {
                draggedStageLi.classList.add('dragging');
                document.body.style.overflow = 'hidden';
            }
        }, 150);
    }
}

// ===================================================================
// NOMBRE: handleStageTouchMove
// RESUMEN: Maneja el movimiento de un toque en una etapa para reordenar.
// ===================================================================
function handleStageTouchMove(e) {
    if (!draggedStageLi || e.touches.length !== 1) return;
    e.preventDefault();
    clearTimeout(stageScrollTimeout);
    if (!draggedStageLi.classList.contains('dragging')) {
        draggedStageLi.classList.add('dragging');
         document.body.style.overflow = 'hidden';
    }
    const touch = e.touches[0];
    const listElement = document.getElementById('sortable-stages-list');
    if (!listElement) return;
    const afterElement = getDragAfterElement(listElement, touch.clientY);
     if (afterElement == null) {
        listElement.appendChild(draggedStageLi);
    } else {
        listElement.insertBefore(draggedStageLi, afterElement);
    }
}

// ===================================================================
// NOMBRE: handleStageTouchEnd
// RESUMEN: Maneja el final de un toque en una etapa para reordenar.
// ===================================================================
function handleStageTouchEnd(e) {
    clearTimeout(stageScrollTimeout);
    if (draggedStageLi) {
        draggedStageLi.classList.remove('dragging');
        draggedStageLi = null;
    }
    document.body.style.overflow = '';
}

// ===================================================================
// NOMBRE: getDragAfterElement
// RESUMEN: Encuentra el elemento despus del cual se debe soltar el elemento arrastrado.
// ===================================================================
function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('li:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

// ===================================================================
// NOMBRE: initializeNavigationGraph
// RESUMEN: Inicializa el grfico de Chart.js para la navegacin.
// ===================================================================
function initializeNavigationGraph() {
    const graphCard = document.getElementById('navigation-graph-card');
    const graphContainer = document.getElementById('navigation-graph-container');
    const graphTitleElement = document.getElementById('navigation-graph-title');
    if (!graphCard || !graphContainer || !graphTitleElement || !isNavigating || currentGraphMode === 'Grfica off') {
        if (graphCard) graphCard.classList.add('hidden');
        if (navigationChart) { navigationChart.destroy(); navigationChart = null; }
        return;
    }
    graphCard.classList.remove('hidden');
    const compassElement = document.querySelector('.leaflet-control-orientation-altitude');
    graphCard.style.height = compassElement ? (compassElement.offsetHeight + 'px') : '157px';
    isCarStoppedForGraph = false;
    graphDataPoints = { speed: [], altitude: [] };
    graphLabels = [];
    graphPlotState = { 
        lastPlotTime: Date.now(), 
        lastPlotCoords: navigationCurrentLocation ? { ...navigationCurrentLocation } : null 
    };
    if (navigationChart) {
        navigationChart.destroy();
        navigationChart = null;
    }
    const ctx = document.getElementById('navigation-chart')?.getContext('2d');
    if (!ctx || !ctx.canvas) {
        showToast("Error crtico: Canvas para grfica no encontrado.", "error");
        if (graphCard) graphCard.classList.add('hidden');
        return;
    }
    const canvasWidth = ctx.canvas.clientWidth;
    const maxPoints = Math.floor(canvasWidth / GRAPH_PIXELS_PER_DATAPOINT);
    const targetPointsForEta = Math.floor(maxPoints * (1 - GRAPH_BUFFER_PERCENTAGE));
    const initialRouteDurationSec = navigationCurrentRouteData?.routes?.[0]?.duration || 0;
    if (initialRouteDurationSec > 0 && targetPointsForEta > 0) {
        graphIntervalDuration = (initialRouteDurationSec * 1000) / targetPointsForEta;
    } else {
        graphIntervalDuration = 30000; 
    }
    const initialRouteDistance = navigationCurrentRouteData?.routes?.[0]?.distance || 0;
    graphExpectedAvgSpeed = (initialRouteDurationSec > 0 && initialRouteDistance > 0) ? (initialRouteDistance / initialRouteDurationSec) * 3.6 : 0;
    navigationChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'Dato', data: [],
                    borderColor: 'rgba(75, 192, 192, 1)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    tension: 0.1, yAxisID: 'yPrimary', pointRadius: 0, order: 2,
                    fill: false
                },
                {
                    label: 'rea Desnivel', data: [],
                    borderColor: 'rgba(255, 165, 0, 0.5)', 
                    backgroundColor: 'rgba(255, 165, 0, 0.2)', 
                    fill: 'origin',
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: true, order: 3
                },
                {
                    label: 'Referencia', data: [], borderColor: 'white',
                    borderWidth: 2, fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 1
                },
                {
                    label: 'Media/Min', data: [], borderColor: '#D9EF9F',
                    borderWidth: 1.5, borderDash: [5, 5], fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 0
                },
                {
                    label: 'Mxima', data: [], borderColor: '#FFA420',
                    borderWidth: 1.5, borderDash: [5, 5], fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 0
                }
            ]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            layout: {
                padding: { top: 5, bottom: 2, left: 0, right: 2 }
            },
            scales: {
                x: { type: 'category', ticks: { display: false }, grid: { drawOnChartArea: false } },
                yPrimary: {
                    type: 'linear', position: 'left',
                    grace: '5%',
                    min: 0,
                    ticks: { color: 'white', font: { size: 11 }, callback: (v) => Math.round(Number(v)).toString() },
                    grid: { color: 'rgba(255,255,255,0.1)' }, title: { display: false }
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: { 
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) { label += ': '; }
                            if (context.parsed.y !== null) {
                                label += context.parsed.y.toFixed(1);
                                if (currentGraphMode === 'Desviacin ETA') label += ' km/h';
                                else if (currentGraphMode === 'Altitud') label += ' m';
                            }
                            return label;
                        }
                    }
                 }
            },
            animation: { duration: 250 }
        }
    });
    startGraphIntervalTimer();
    updateNavigationGraphVisibilityAndMode();
}





// ===================================================================
// NOMBRE: updateChartData
// RESUMEN: Actualiza los datos y la configuracin de la grfica de navegacin.
// ===================================================================
function updateChartData() {
    if (!navigationChart) return;
    const graphCard = document.getElementById('navigation-graph-card');
    const isEnlarged = graphCard ? graphCard.classList.contains('enlarged') : false;
    const valueStyle = "font-size: 1.2em; opacity: 1.0; line-height: 1.4; font-weight: bold; text-align: right; padding-right: 22px;";
    const etaColor = "white";
    const avgColor = "#D9EF9F";
    const maxColor = "#FFA420";
    const mainDataset = navigationChart.data.datasets[0];
    const altitudeFillDataset = navigationChart.data.datasets[1];
    const referenceDataset = navigationChart.data.datasets[2];
    const avgSpeedOrMinAltitudeDataset = navigationChart.data.datasets[3];
    const maxSpeedOrMaxAltitudeDataset = navigationChart.data.datasets[4];
    if (currentGraphMode === 'Desviacin ETA') {
        navigationChart.options.scales.yPrimary.ticks.callback = function(value) { return Math.round(value) + ' km/h'; };
        navigationChart.options.scales.yPrimary.min = 0; 
        mainDataset.borderColor = 'rgba(129, 216, 208, 1)'; 
        mainDataset.backgroundColor = 'rgba(37, 99, 235, 0.2)';
        mainDataset.fill = true;
        altitudeFillDataset.hidden = true; 
        altitudeFillDataset.data = []; 
        const allRelevantSpeedValues = [
            ...(graphDataPoints.speed.length > 0 ? graphDataPoints.speed : [0]),
            maxSpeedDuringTrip || 0,
            graphExpectedAvgSpeed || 0
        ];
        const timeSinceStartMs = navigationStartTimeForStats ? Date.now() - navigationStartTimeForStats.getTime() : Infinity;
        if (timeSinceStartMs > 60000) {
            allRelevantSpeedValues.push(window.averageSpeedKmh || 0);
        }
        const currentMaxDataValue = Math.max(...allRelevantSpeedValues);
        const yAxisMax = Math.min(250, Math.max(50, currentMaxDataValue + 15));
        navigationChart.options.scales.yPrimary.max = yAxisMax;
        const targetTickCount = isEnlarged ? 30 : 10;
        const yAxisRange = yAxisMax - 0; 
        const rawStep = yAxisRange > 0 ? yAxisRange / targetTickCount : 10;
        const niceIntervals = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50];
        let stepSize = niceIntervals[niceIntervals.length - 1];
        for (const interval of niceIntervals) {
            if (rawStep <= interval) { stepSize = interval; break; }
        }
        navigationChart.options.scales.yPrimary.ticks.stepSize = stepSize;
        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            const etaVal = (graphExpectedAvgSpeed || 0).toFixed(1);
            const avgVal = (window.averageSpeedKmh || 0).toFixed(1);
            const maxVal = (maxSpeedDuringTrip || 0).toFixed(1);
            graphTitleElement.innerHTML = `
                <span style="font-size: 0.7em;">DATOS ETA</span> 
                <small style="${valueStyle}">
                    <span style="color:${etaColor};">ETA: ${etaVal}</span> 
                    <span style="color:${avgColor};">   |  Med: ${avgVal}</span> 
                    <span style="color:${maxColor};">   |  Mx: ${maxVal}Km/h</span>
                </small>`;
        }
        mainDataset.data = graphDataPoints.speed;
        mainDataset.label = 'Velocidad';
        referenceDataset.data = graphLabels.map(() => graphExpectedAvgSpeed);
        referenceDataset.label = 'Velocidad ETA';
        avgSpeedOrMinAltitudeDataset.data = graphLabels.map(() => window.averageSpeedKmh || 0);
        avgSpeedOrMinAltitudeDataset.label = 'Media del Viaje';
        maxSpeedOrMaxAltitudeDataset.data = graphLabels.map(() => maxSpeedDuringTrip || 0);
        maxSpeedOrMaxAltitudeDataset.label = 'Mxima del Viaje';
    } else if (currentGraphMode === 'Altitud') {
        navigationChart.options.scales.yPrimary.ticks.callback = function(value) { return Math.round(value) + ' m'; };
        navigationChart.options.scales.yPrimary.max = undefined;
        navigationChart.options.scales.yPrimary.min = undefined;
        mainDataset.borderColor = 'rgba(129, 216, 208, 1)'; 
        mainDataset.backgroundColor = 'rgba(255, 165, 0, 0.2)';
        mainDataset.fill = false;
        altitudeFillDataset.data = graphDataPoints.altitude;
        altitudeFillDataset.hidden = false; 
        const targetTickCountAlt = isEnlarged ? 15 : 8;
        const altitudeValues = graphDataPoints.altitude.length > 0 ? graphDataPoints.altitude : [0];
        const minAlt = Math.min(...altitudeValues);
        const maxAlt = Math.max(...altitudeValues);
        const altRange = maxAlt - minAlt;
        if (altRange > 0) {
            const rawStepAlt = altRange / targetTickCountAlt;
            const niceIntervalsAlt = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 100, 200, 500];
            let stepSizeAlt = niceIntervalsAlt[niceIntervalsAlt.length - 1];
            for (const interval of niceIntervalsAlt) { if(rawStepAlt <= interval) { stepSizeAlt = interval; break; } }
            navigationChart.options.scales.yPrimary.ticks.stepSize = stepSizeAlt;
        } else {
             navigationChart.options.scales.yPrimary.ticks.stepSize = undefined;
        }
        const altitudePoints = graphDataPoints.altitude;
        const avgAltitudeValue = altitudePoints.length > 0 ? altitudePoints.reduce((a, b) => a + b, 0) / altitudePoints.length : 0;
        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            const maxAltVal = (maxAltitudeDuringTrip !== -Infinity ? maxAltitudeDuringTrip : 0).toFixed(0);
            const avgAltVal = avgAltitudeValue.toFixed(0);
            const minAltVal = (minAltitudeDuringTrip !== Infinity ? minAltitudeDuringTrip : 0).toFixed(0);
            graphTitleElement.innerHTML = `
                <span style="font-size: 0.7em;">DESNIVEL RUTA</span>
                <small style="${valueStyle}">
                    <span style="color:${maxColor};">Mx: ${maxAltVal}</span> 
                    <span style="color:${etaColor};">   |  Med: ${avgAltVal}</span> 
                    <span style="color:${avgColor};">   |  Mn: ${minAltVal}m</span>
                </small>`;
        }
        mainDataset.data = graphDataPoints.altitude;
        mainDataset.label = 'Altitud';
        referenceDataset.data = graphLabels.map(() => avgAltitudeValue);
        referenceDataset.label = 'Media';
        avgSpeedOrMinAltitudeDataset.data = graphLabels.map(() => minAltitudeDuringTrip !== Infinity ? minAltitudeDuringTrip : null);
        avgSpeedOrMinAltitudeDataset.label = 'Mnima';
        maxSpeedOrMaxAltitudeDataset.data = graphLabels.map(() => maxAltitudeDuringTrip !== -Infinity ? maxAltitudeDuringTrip : null);
        maxSpeedOrMaxAltitudeDataset.label = 'Mxima';
    }
    navigationChart.data.labels = graphLabels; 
    navigationChart.update('none');
}





// ===================================================================
// NOMBRE: plotIntervalData
// RESUMEN: Aade un nuevo punto de datos a la grfica a intervalos regulares.
// ===================================================================
function plotIntervalData() {
    if (!isNavigating || !navigationChart || !graphPlotState.lastPlotCoords || !navigationCurrentLocation) {
        return;
    }
    const currentSpeed = window.currentSpeedKmh || 0;
    const isCurrentlyStopped = currentSpeed < 1;
    if (isCurrentlyStopped) {
        if (isCarStoppedForGraph) {
            return;
        }
    } else {
        if (isCarStoppedForGraph) {
            isCarStoppedForGraph = false;
        }
    }
    const currentTime = Date.now();
    const timeDiffSeconds = (currentTime - graphPlotState.lastPlotTime) / 1000;
    if (timeDiffSeconds < 1) return;
    const distanceMeters = calculateDistance(
        graphPlotState.lastPlotCoords.latitude, graphPlotState.lastPlotCoords.longitude,
        navigationCurrentLocation.latitude, navigationCurrentLocation.longitude
    );
    const avgSpeedKmh = (timeDiffSeconds > 0) ? (distanceMeters / timeDiffSeconds) * 3.6 : 0;
    const currentAltitude = navigationCurrentLocation.altitude || 0;
    const timeLabel = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    graphLabels.push(timeLabel);
    graphDataPoints.speed.push(avgSpeedKmh);
    graphDataPoints.altitude.push(currentAltitude);
    updateChartData();
    graphPlotState.lastPlotTime = currentTime;
    graphPlotState.lastPlotCoords = { ...navigationCurrentLocation };
    if (isCurrentlyStopped) {
        isCarStoppedForGraph = true;
    }
}





// ===================================================================
// NOMBRE: startGraphIntervalTimer
// RESUMEN: Inicia el temporizador para aadir datos a la grfica.
// ===================================================================
function startGraphIntervalTimer() {
    if (graphIntervalTimer) clearInterval(graphIntervalTimer);
    if (isNavigating && currentGraphMode !== 'Grfica off' && graphIntervalDuration > 0) { 
        graphIntervalTimer = setInterval(plotIntervalData, graphIntervalDuration);
    }
}





// ===================================================================
// NOMBRE: plotAccumulatedGraphData
// RESUMEN: Procesa y dibuja los datos acumulados en la grfica. (Funcin de apoyo interna)
// ===================================================================
function plotAccumulatedGraphData() {
    if (!navigationChart) {
        return;
    }
    if (graphDataAccumulator.count === 0) {
        return;
    }
    let avgSpeed = 0;
    if (graphDataAccumulator.count > 0 && graphDataAccumulator.speedSum > 0) {
        avgSpeed = graphDataAccumulator.speedSum / graphDataAccumulator.count;
    } else if (window.currentSpeedKmh !== undefined && graphDataAccumulator.count > 0) {
        avgSpeed = window.currentSpeedKmh;
    }
    const avgAltitude = graphDataAccumulator.altitudeSum / graphDataAccumulator.count;
    const now = new Date();
    const currentTimeLabel = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
    graphLabels.push(currentTimeLabel);
    if (graphLabels.length > GRAPH_TARGET_POINTS) {
        graphLabels.shift();
    }
    navigationChart.data.labels = graphLabels;
    if (currentGraphMode === 'Velocidad') {
        graphDataPoints.speed.push(avgSpeed);
        if (graphDataPoints.speed.length > GRAPH_TARGET_POINTS) {
            graphDataPoints.speed.shift();
        }
        navigationChart.data.datasets[0].data = graphDataPoints.speed;
        navigationChart.data.datasets[0].label = 'Velocidad Media Tramo';
        navigationChart.options.scales.yPrimary.ticks.callback = function(value) { return value.toFixed(0) + ' km/h'; };
        if (!navigationChart.data.datasets[1].hidden) {
            navigationChart.data.datasets[1].data = graphLabels.map(() => graphExpectedAvgSpeed);
        }
    } else if (currentGraphMode === 'Altitud') {
        graphDataPoints.altitude.push(avgAltitude);
        if (graphDataPoints.altitude.length > GRAPH_TARGET_POINTS) {
            graphDataPoints.altitude.shift();
        }
        navigationChart.data.datasets[0].data = graphDataPoints.altitude;
        navigationChart.data.datasets[0].label = 'Altitud Media Tramo';
        navigationChart.options.scales.yPrimary.ticks.callback = function(value) { return value.toFixed(0) + ' m'; };
    }
    navigationChart.update('none'); 
    graphDataAccumulator = { speedSum: 0, altitudeSum: 0, count: 0, lastPositionTime: graphDataAccumulator.lastPositionTime, lastPositionCoords: graphDataAccumulator.lastPositionCoords }; 
}   










document.addEventListener('DOMContentLoaded', async () => {
     storedPin = localStorage.getItem('password_pin');
     const savedPasswordActive = localStorage.getItem('password_active');
     isPasswordActive = savedPasswordActive ? JSON.parse(savedPasswordActive) : false;
     const initialDirectToNavPref = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
     const tempPreventDirectNav = sessionStorage.getItem(TEMP_PREVENT_DIRECT_NAV_KEY);
     if (isPasswordActive && storedPin && !(initialDirectToNavPref && !tempPreventDirectNav)) {
         promptForPin();
     } else {
         await initializeApp();
     }
    window.addEventListener('beforeunload', () => {
         if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
         if (locationWatchId !== null && navigator.geolocation) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
         if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
         const openReminderModal = document.querySelector('.reminder-modal');
         if (openReminderModal && typeof openReminderModal.cleanUpModalTimers === 'function') { openReminderModal.cleanUpModalTimers(true); }
         Object.keys(globalModalTimers).forEach(modalId => {
            const timerData = globalModalTimers[modalId];
            if (timerData) {
                clearModalAutoCloseTimer(timerData.modalElement, timerData.closeButtonElement, modalId);
            }
         });
         globalModalTimers = {};
         const openTableModal = document.querySelector('.reminder-table-modal');
         if(openTableModal && openTableModal.autoCloseInterval) { clearInterval(openTableModal.autoCloseInterval); }
         const openPostponeModal = document.getElementById('postpone-options-modal');
         if(openPostponeModal && openPostponeModal.autoPostponeInterval) { clearInterval(openPostponeModal.autoPostponeInterval); }
         const openSavedLocationsModal = document.querySelector('.saved-locations-modal');
         if (openSavedLocationsModal && locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
         const simModalUnload = document.getElementById('simulation-modal');
         if (simModalUnload && simulationModalTimer) clearTimeout(simulationModalTimer);
         if (autoStartNavTimer) clearTimeout(autoStartNavTimer);
         if (isNavigationMapActive || navigationMapInstance) {
            closeNavigationMap(true);
         }
         if (locationsPreviewMap) {
             try { locationsPreviewMap.remove(); } catch(e){}
             locationsPreviewMap = null;
         }
         if (isAssignmentMode || isEditMode || isKeywordAssignmentMode) { saveCustomData(); }
         const filterInput = document.getElementById('grid-filter-input');
         if (filterInput && filterInput.value.trim()) {
              localStorage.setItem('gridFilterValue', filterInput.value);
         } else {
              localStorage.removeItem('gridFilterValue');
         }
          saveSettings();
          if (reminderModalMap) try {reminderModalMap.remove();} catch(e){}
          Object.values(previewMaps).forEach(map => {try {map?.remove();} catch(e){}});
          if (intersectionPreviewMap) try {intersectionPreviewMap.remove();} catch(e){}
          if (navigationChart) navigationChart.destroy();
          if (graphIntervalTimer) clearInterval(graphIntervalTimer);
     });
    document.body.addEventListener('click', function(event) {
        const target = event.target;
        const targetId = target.id || (target.closest('[id]') ? target.closest('[id]').id : null);
        if (targetId === 'config-close-modal') {
            const modal = document.getElementById('config-modal');
            if (modal && !modal.classList.contains('hidden')) {
                clearModalAutoCloseTimer(modal, target, 'config-modal');
                modal.classList.add('hidden');
                 const mapWasOpenBeforeConfig = sessionStorage.getItem('boardinggate_map_should_reopen_after_config') === 'true';
                 const mapContextToReopen = sessionStorage.getItem('mapContextToReopenAfterConfig');
                 sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');
                 sessionStorage.removeItem('mapContextToReopenAfterConfig');
                 if (mapWasOpenBeforeConfig && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !document.getElementById('reminders-location-map-modal')) {
                    if (mapContextToReopen === 'navigation') {
                        setTimeout(() => openNavigationMap(), 50);
                    }
                }
            }
        }
        if (target.matches('.config-tab-button')) {
            const modal = document.getElementById('config-modal');
            if(modal && modal.classList.contains('hidden') === false) {
                const tabTarget = target.dataset.tabTarget;
                modal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                modal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (modal.querySelector(tabTarget)) {
                    modal.querySelector(tabTarget).classList.add('active');
                }
            }
        }
        if (targetId === 'close-reminders-top' || targetId === 'close-reminders-bottom') {
            const modalTable = document.querySelector('.reminder-table-modal');
            if (modalTable) {
                if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                modalTable.remove();
                const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                const mapContext = sessionStorage.getItem('mapContext');
                sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                sessionStorage.removeItem('mapContext');
                if (fromReminderModal) {
                    fromReminderModal = false;
                    if (mapShouldReopen) {
                        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                        sessionStorage.setItem('mapContext', mapContext);
                    }
                    showReminderModal();
                } else if (mapShouldReopen) {
                     if (mapContext === 'navigation') openNavigationMap();
                }
            }
        }
        if (targetId === 'view-all-locations-map') {
            const modalTable = document.querySelector('.reminder-table-modal');
             if (modalTable && modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
             if (modalTable) modalTable.remove();
            setTimeout(() => {
                openLocationsPreviewMap();
            }, 50);
        }
         if (targetId === 'close-locations-preview') {
            const previewModal = document.getElementById('locations-preview-modal');
            if (previewModal) {
                if (locationsPreviewMap) {
                    try { locationsPreviewMap.remove(); } catch (e) {}
                    locationsPreviewMap = null;
                }
                if (mapLayersControlLocationsPreview) {
                    try {mapLayersControlLocationsPreview.remove();} catch(e){}
                    mapLayersControlLocationsPreview = null;
                }
                clearModalAutoCloseTimer(previewModal, target, 'locations-preview-modal');
                previewModal.classList.add('hidden');
            }
        }
        if (targetId === 'close-address-suggestions-modal') {
            hideAddressSuggestionsModal();
        }
    });
    const bookmarkGrid = document.getElementById('bookmark-grid');
    if (bookmarkGrid) {
        bookmarkGrid.addEventListener('click', function(event) {
            const link = event.target.closest('a.bookmark-item');
            if (link && link.href && link.href.startsWith("map-action:")) {
                event.preventDefault();
                const action = link.href.split(":")[1];
                if (action === "openRemindersMapWithNoRadars") {
                    closeOtherModals();
                    setTimeout(() => {
                        const existingPreviewModal = document.getElementById('locations-preview-modal');
                        if (existingPreviewModal && !existingPreviewModal.classList.contains('hidden')) {
                            showToast("El mapa de ubicaciones (sin radar) ya est abierto", "info");
                        } else {
                           openLocationsPreviewMap();
                        }
                    }, 50);
                } else if (action === "openRemindersMap") {
                    closeOtherModals();
                    setTimeout(() => {
                        const mapModalElement = document.getElementById('reminders-location-map-modal');
                        if (mapModalElement && !mapModalElement.classList.contains('hidden')) {
                            showToast("El mapa de navegacin/ubicaciones ya est abierto", "info");
                            if (navigationMapInstance) {
                                requestAnimationFrame(() => {
                                    requestAnimationFrame(() => {
                                        if (navigationMapInstance) {
                                            try {
                                                 navigationMapInstance.invalidateSize({debounceMoveend: true});
                                             } catch (e) {  }
                                        }
                                    });
                                });
                            }
                        } else {
                           openNavigationMap();
                        }
                    }, 50);
                }
            }
        });
    }

    const accidentAlertButton = document.getElementById('accident-alert-button');
    if (accidentAlertButton) {
        accidentAlertButton.addEventListener('click', () => {
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
            openAlertModal();
        });
    }
});
       
</script> 
</body>
</html>  
