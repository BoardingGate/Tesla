




















isNew && !parsed.createdAt) { parsed.createdAt = new Date(0).toISOString(); }

    locationEnabledByUser = parsed.isLocationEnabled;
    currentReminderLocation = parsed.locationCoordinates;

    let fmtDate = '';
    if (parsed.date?.match(/^\d{4}-\d{2}-\d{2}$/)) {
        try {
            const [y,m,d] = parsed.date.split('-');
            const dt=new Date(Date.UTC(y,m-1,d));
            if(!isNaN(dt.getTime())&&dt.getUTCDate()==d&&dt.getUTCMonth()==m-1) {
                fmtDate=`${d.toString().padStart(2,'0')}/${m.toString().padStart(2,'0')}/${y}`;
            }
        } catch(e){}
    }


    const modal = document.createElement('div');
    modal.className = 'reminder-modal';
    modal.setAttribute('aria-label','Formulario recordatorio');

    const titleHtml = `
        <div style="display: flex; align-items: center; justify-content: space-between; width: 100%; flex-wrap: wrap;">
            <span class="font-bold" style="font-size: 1.5rem; margin-right: auto;">${isNew ? 'NUEVO RECORDATORIO' : 'MODIFICAR RECORDATORIO'}</span>
            <div style="display: flex; align-items: center; margin-left: 35px; white-space: nowrap;">
                <input type="checkbox" id="reminder-exclude-from-list" ${parsed.excludeFromList ? 'checked' : ''} style="transform: scale(1.1); margin-right: 5px;">
                <label for="reminder-exclude-from-list" style="font-size: 0.9rem; font-weight: normal; color: #555;">NO INCLUIRLO EN LA LISTA (radares, etc)</label>
            </div>
        </div>`;

    modal.innerHTML = `
         <h2 style="display: flex; align-items: center; justify-content: center; text-align: center;">${titleHtml}</h2>
         <p id="parse-status" class="text-sm mt-1"></p>
         <form id="reminder-form">
             <div class="full-width">
                <div style="display:flex;align-items:center;gap:.5rem;">
                    <button type="button" id="clear-fields" class="speech-button" title="Limpiar" style="background-color:#D1D5DB;color:#111827;flex-shrink:0;">Limpiar</button>
                    <textarea id="reminder-text" rows="4" required style="flex-grow:1;">${parsed.text.replace(/<b>|<\/b>/gi,'')}</textarea>
                    <button type="button" id="start-speech" class="speech-button" title="Voz" style="flex-shrink:0;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                    </button>
                </div>
                <p id="speech-status" class="speech-status"></p>
             </div>


             <div class="form-grid">
                 <div>
                     <label for="reminder-time">Hora:</label>
                     <input type="text" id="reminder-time" placeholder="HH:MM" pattern="\\d{2}:\\d{2}" value="${parsed.time||''}">
                 </div>
                 <div>
                     <label for="reminder-date">Fecha:</label>
                     <input type="text" id="reminder-date" placeholder="DD/MM/AAAA" pattern="\\d{2}/\\d{2}/\\d{4}" value="${fmtDate}">
                 </div>
                 <div style="display: flex; flex-direction: column; align-items: flex-start;">
                     <label for="reminder-interval" style="margin-bottom: 0.25rem; line-height: 1.2;">Intervalo<br>(días):</label>
                     <div style="display: flex; align-items: center; gap: 0.5rem;">
                         <input type="number" id="reminder-interval" min="1" max="9999" value="${parsed.intervalDays||''}" style="width: 90px;">
                         <input type="checkbox" id="location-enabled" ${parsed.isLocationEnabled ? 'checked' : ''} style="margin-left: 8px; transform: scale(1.2); margin-right: 0.2rem;">
                         <label for="location-enabled" style="font-weight: bold; white-space: nowrap; font-size: 1.1rem; color: #374151;">Ubicación</label>
                     </div>
                 </div>
                 <div class="location-controls-group" style="justify-content: flex-start; margin-top: 0; align-items: center;">
                    <label for="reminder-radius" style="margin-left: 0;">Radio(m):</label>
                    <input type="number" id="reminder-radius" min="50" max="100000" value="${parsed.radiusMeters || 1000}" style="width: 110px;">
                    <button type="button" id="expand-map-button">Ampliar Mapa</button>
                 </div>
             </div>

             <div id="location-map-container" class="full-width">
                 <button type="button" id="reduce-map-button" class="hidden">REDUCIR MAPA</button>
                 <button type="button" id="locate-me-button" class="hidden">ESTÁS AQUÍ</button>
             </div>

             <div class="days-group full-width">
                 <label>Días repetición:</label>
                 ${['Lun ','Mar ','Mié ','Jue ','Vie ','Sáb ','Dom '].map((d,i)=>`<label style="flex:0 0 auto;"><input type="checkbox" name="repeat" value="${(i+1)%7}" ${parsed.repeatDays?.includes((i+1)%7)?'checked':''}> ${d}</label>`).join('')}
             </div>

             <div class="button-group full-width" style="margin-top: 1.5rem; margin-bottom: 0.8rem;">
                <button type="submit" id="save-reminder">Aceptar <span id="countdown-save">25</span></button>
                <button type="button" id="cancel-reminder">Cancelar</button>
                <button type="button" id="delete-reminder" title="Borrar este recordatorio permanentemente" style="background-color: #8B0000; color: #FFFFFF; font-weight: bold; height: 70px; font-size: 1.2rem;">Borrar</button>
                <button type="button" id="view-reminders">Ver Recordatorios</button>
                <button type="button" id="manage-saved-locations">Ubicaciones</button>
                <button type="button" id="help-reminder">Ayuda</button>
             </div>

             <p id="auto-save-timer" class="text-sm text-gray-600 mt-2 full-width"></p>
         </form>`;
    document.body.appendChild(modal);
    modal.cleanUpModalTimers = cleanUpModalTimers;

    const parseStatus = modal.querySelector('#parse-status');
    const speechStatus = modal.querySelector('#speech-status');
    const autoSaveTimerLabel = modal.querySelector('#auto-save-timer');
    let countdownSaveElement = modal.querySelector('#countdown-save');
    const textInput = modal.querySelector('#reminder-text');
    const timeInput = modal.querySelector('#reminder-time');
    const dateInput = modal.querySelector('#reminder-date');
    const intervalInput = modal.querySelector('#reminder-interval');
    const speechButton = modal.querySelector('#start-speech');
    const saveButton = modal.querySelector('#save-reminder');
    const clearButton = modal.querySelector('#clear-fields');
    const locationCheckbox = modal.querySelector('#location-enabled');
    const radiusInput = modal.querySelector('#reminder-radius');
    const mapContainer = modal.querySelector('#location-map-container');
    const expandMapButton = modal.querySelector('#expand-map-button');
    const reduceMapButton = modal.querySelector('#reduce-map-button');
    const locateMeButton = modal.querySelector('#locate-me-button');
    const manageLocationsBtn = modal.querySelector('#manage-saved-locations');
    const excludeFromListCheckbox = modal.querySelector('#reminder-exclude-from-list');
    const deleteButton = modal.querySelector('#delete-reminder');


    if (deleteButton) {
        deleteButton.addEventListener('click', () => {
            cleanUpModalTimers(true);
            const mapShouldReopen = mapShouldReopenAfterForm;


            if (isNew) {
                destroyMap();
                if (modal.parentNode) document.body.removeChild(modal);
                showToast('Creación de recordatorio cancelada', 'info');

                if (mapShouldReopen && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
                    showAllRemindersLocationMap();
                } else if (mapShouldReopen) {
                    sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
                }
                return;
            }

            let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
            const initialLength = reminders.length;
            reminders = reminders.filter(r => r.id !== parsed.id);

            if (reminders.length < initialLength) {
                localStorage.setItem('reminders', JSON.stringify(reminders));
                showToast('Recordatorio borrado.', 'success');
            } else {
                showToast('Recordatorio no encontrado para borrar', 'warning');
            }

            destroyMap();
            if (modal.parentNode) document.body.removeChild(modal);
            updateReminderCount();
            updateButtonStyles();
            checkReminders();

            if (mapShouldReopen && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
                showAllRemindersLocationMap();
            } else if (mapShouldReopen) {
                 sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
            }
        });
    }


    if (manageLocationsBtn) {
        manageLocationsBtn.addEventListener('click', () => {
            showSavedLocationsModal(
                () => { },
                (selectedLocationData) => {
                    if (selectedLocationData && typeof selectedLocationData.lat === 'number' && typeof selectedLocationData.lng === 'number') {
                        currentReminderLocation = { latitude: selectedLocationData.lat, longitude: selectedLocationData.lng };
                        locationCheckbox.checked = true;
                        locationEnabledByUser = true;
                        radiusInput.disabled = false;

                        if (typeof selectedLocationData.radius === 'number' && selectedLocationData.radius > 0) {
                             radiusInput.value = selectedLocationData.radius;
                        } else {
                             radiusInput.value = 400;
                        }

                        if (mapContainer.classList.contains('expanded')) {
                            initializeOrUpdateMap(currentReminderLocation, radiusInput.value, true);
                        } else {
                            initializeOrUpdateMap(currentReminderLocation, radiusInput.value, false);
                        }
                        showToast(`Ubicación "${selectedLocationData.name || 'Seleccionada'}" aplicada.`, "success");
                        resetAndStartCountdown();
                    } else {
                        showToast("Error: Datos de ubicación seleccionada no válidos.", "error");
                    }
                }
            );
        });
    }

    const handleMapMoveStart = () => {
        if (reminderCircle && mapContainer.classList.contains('expanded')) {
            clearTimeout(mapMoveDebounceTimer);
            reminderCircle.setStyle({ stroke: false, fill: false });
        }
    };

    const handleMapMoveEnd = () => {
        clearTimeout(mapMoveDebounceTimer);
        mapMoveDebounceTimer = setTimeout(() => {
            if (reminderCircle && mapContainer.classList.contains('expanded')) {
                reminderCircle.setStyle({ stroke: true, color: 'blue', fill: true, fillColor: '#ADD8E6', fillOpacity: 0.05, weight: 1 });
            }
        }, 200);
    };

    function initializeOrUpdateMap(centerCoords, radius, isInteractive = false) {
        const mapDivId = 'reminder-modal-map-div';
        let mapDiv = document.getElementById(mapDivId);
        const effectiveLocationEnabled = locationCheckbox.checked;

        const showMap = effectiveLocationEnabled || isInteractive;

        if (!showMap) {
            destroyMap();
            return;
        }

        mapContainer.style.display = 'block';
        mapContainer.classList.toggle('preview', !isInteractive && effectiveLocationEnabled && centerCoords);
        mapContainer.classList.toggle('expanded', isInteractive && effectiveLocationEnabled);

        const effectiveCoords = centerCoords || { latitude: 40.416775, longitude: -3.703790 };
        const effectiveRadius = parseInt(radius) || 1000;

        if (!isInteractive && !centerCoords && effectiveLocationEnabled) {
             destroyMap();
             return;
        }


        const zoomLevel = isInteractive ? 13 : 11;

        const setupMapInteractions = (mapInstance) => {
            mapInstance.off('click', handleMapClick);
            mapInstance.off('movestart', handleMapMoveStart);
            mapInstance.off('moveend', handleMapMoveEnd);

            if (isInteractive && effectiveLocationEnabled) {
                mapInstance.dragging.enable(); mapInstance.touchZoom.enable(); mapInstance.scrollWheelZoom.enable();
                mapInstance.doubleClickZoom.enable(); mapInstance.tap?.enable();
                if(mapInstance.zoomControl) mapInstance.zoomControl.getContainer().style.display = 'block';

                mapInstance.on('click', handleMapClick);
                mapInstance.on('movestart', handleMapMoveStart);
                mapInstance.on('moveend', handleMapMoveEnd);
            } else {
                mapInstance.dragging.disable(); mapInstance.touchZoom.disable(); mapInstance.scrollWheelZoom.disable();
                mapInstance.doubleClickZoom.disable(); mapInstance.tap?.disable();
                if(mapInstance.zoomControl) mapInstance.zoomControl.getContainer().style.display = 'none';
            }
        };

        if (!reminderModalMap) {
            if (!mapDiv) {
                mapDiv = document.createElement('div');
                mapDiv.id = mapDivId;
                mapDiv.style.width = '100%'; mapDiv.style.height = '100%';
                mapContainer.insertBefore(mapDiv, reduceMapButton);
            }

            reminderModalMap = L.map(mapDivId, {
                 scrollWheelZoom: (isInteractive && effectiveLocationEnabled),
                 doubleClickZoom: (isInteractive && effectiveLocationEnabled),
                 touchZoom: (isInteractive && effectiveLocationEnabled),
                 dragging: (isInteractive && effectiveLocationEnabled),
                 tap: (isInteractive && effectiveLocationEnabled),
                 zoomControl: true
            }).setView([effectiveCoords.latitude, effectiveCoords.longitude], zoomLevel);

            reminderModalMap.zoomControl.setPosition('topright');

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: (isInteractive && effectiveLocationEnabled) ? '© <a href="https://www.openstreetmap.org/copyright">OSM</a>' : null
            }).addTo(reminderModalMap);

            setupMapInteractions(reminderModalMap);
            updateMarkerAndCircle(effectiveCoords, effectiveRadius);

        } else {
             reminderModalMap.setView([effectiveCoords.latitude, effectiveCoords.longitude], zoomLevel);
             updateMarkerAndCircle(effectiveCoords, effectiveRadius);
             setupMapInteractions(reminderModalMap);
        }

        if (reduceMapButton) reduceMapButton.classList.toggle('hidden', !(isInteractive && effectiveLocationEnabled));
        if (locateMeButton) locateMeButton.classList.toggle('hidden', !(isInteractive && effectiveLocationEnabled));
        if (reminderModalMap && reminderModalMap.zoomControl) {
            const zoomContainer = reminderModalMap.zoomControl.getContainer();
            if (zoomContainer) {
                zoomContainer.style.display = (isInteractive && effectiveLocationEnabled) ? 'block' : 'none';
            }
        }
        setTimeout(() => { if(reminderModalMap) reminderModalMap.invalidateSize(); }, 100);
    }


    function handleMapClick(e) {
         const latlng = e.latlng;
         currentReminderLocation = { latitude: latlng.lat, longitude: latlng.lng };
         updateMarkerAndCircle(currentReminderLocation, radiusInput.value);
         resetAndStartCountdown();
    }


function updateMarkerAndCircle(coords, radius) {
        if (!reminderModalMap || !coords) return;

        const latlng = L.latLng(coords.latitude, coords.longitude);
        const radiusMeters = parseInt(radius) || 1000;
        const isDraggable = mapContainer.classList.contains('expanded') && locationCheckbox.checked;

        if (!reminderMarker) {
            reminderMarker = L.marker(latlng, { icon: carIcon, draggable: isDraggable }).addTo(reminderModalMap);
            if (isDraggable) reminderMarker.on('dragend', handleMarkerDragEnd);
        } else {
            reminderMarker.setLatLng(latlng);
            reminderMarker.options.draggable = isDraggable;
            reminderMarker.off('dragend', handleMarkerDragEnd);
            if (isDraggable) reminderMarker.on('dragend', handleMarkerDragEnd);
        }
        const markerElement = reminderMarker.getElement();
        if(markerElement) {
             markerElement.style.transformOrigin = 'center center';
        }


        if (!reminderCircle) {
            reminderCircle = L.circle(latlng, { color: 'blue', weight: 1, fillColor: '#ADD8E6', fillOpacity: 0.05, radius: radiusMeters }).addTo(reminderModalMap);
        } else {
            reminderCircle.setLatLng(latlng);
            reminderCircle.setRadius(radiusMeters);
            if (!mapContainer.classList.contains('expanded') || (mapMoveDebounceTimer === null)) {
                 reminderCircle.setStyle({ stroke: true, color: 'blue', fill: true, fillColor: '#ADD8E6', weight: 1,fillOpacity: 0.05 });
            }
        }
    }

    function handleMarkerDragEnd(event) {
         const marker = event.target;
         const position = marker.getLatLng();
         currentReminderLocation = { latitude: position.lat, longitude: position.lng };
         updateMarkerAndCircle(currentReminderLocation, radiusInput.value);
         resetAndStartCountdown();
    }

    function destroyMap() {
        if (reminderModalMap) {
             reminderModalMap.off('click', handleMapClick);
             reminderModalMap.off('movestart', handleMapMoveStart);
             reminderModalMap.off('moveend', handleMapMoveEnd);
             if (reminderMarker) reminderMarker.off('dragend', handleMarkerDragEnd);
             try { reminderModalMap.remove(); } catch(e) { console.warn("Error removing map from destroyMap:", e); }
             reminderModalMap = null; reminderMarker = null; reminderCircle = null;
        }
        mapContainer.style.display = 'none';
        mapContainer.classList.remove('preview', 'expanded');
        if (reduceMapButton) reduceMapButton.classList.add('hidden');
        if (locateMeButton) locateMeButton.classList.add('hidden');
        const mapDiv = document.getElementById('reminder-modal-map-div');
        if(mapDiv && mapDiv.parentNode === mapContainer) {
             mapContainer.removeChild(mapDiv);
        }
    }

    function handleLocationCheckboxChange() {
        const wasEnabled = locationEnabledByUser;
        locationEnabledByUser = locationCheckbox.checked;
        radiusInput.disabled = !locationEnabledByUser;

        if (locationEnabledByUser) {
            if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && currentReminderLocation) {
                initializeOrUpdateMap(currentReminderLocation, radiusInput.value, false);
            } else if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && !currentReminderLocation) {
                destroyMap();
            }
             if (!currentReminderLocation && !wasEnabled) {
                getCurrentLocation(
                    (coords) => {
                        currentReminderLocation = coords;
                        if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && currentReminderLocation) {
                            initializeOrUpdateMap(currentReminderLocation, radiusInput.value, false);
                        }
                    }
                );
            }
        } else {
            destroyMap();
        }
        resetAndStartCountdown();
    }
    locationCheckbox.addEventListener('change', handleLocationCheckboxChange);

    if (parsed.isLocationEnabled && parsed.locationCoordinates) {
        initializeOrUpdateMap(parsed.locationCoordinates, parsed.radiusMeters, false);
    } else if (parsed.isLocationEnabled && !parsed.locationCoordinates) {
        radiusInput.disabled = false;
        destroyMap();
    } else {
        radiusInput.disabled = true;
        destroyMap();
    }


    if (expandMapButton) {
        expandMapButton.addEventListener('click', () => {
            if (!locationCheckbox.checked) {
                locationCheckbox.checked = true;
            }
            locationEnabledByUser = true;
            radiusInput.disabled = false;
            mapExpandedManually = true;

            if (!currentReminderLocation) {
                locateMeButton.disabled = true; locateMeButton.textContent = 'Buscando...';
                getCurrentLocation(
                    (gpsCoords) => {
                        currentReminderLocation = { latitude: gpsCoords.latitude, longitude: gpsCoords.longitude };
                        initializeOrUpdateMap(gpsCoords, radiusInput.value, true);
                        if (reminderModalMap) {
                             reminderModalMap.setZoom(16);
                        }
                        showToast("Mapa centrado en tu ubicación GPS. Pulsa en el mapa para ajustar si es necesario.", "info");
                        locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ';
                    },
                    (errorMsg) => {
                        initializeOrUpdateMap(null, radiusInput.value, true);
                        if (reminderModalMap) {
                            reminderModalMap.setZoom(6);
                        }
                        showToast(`Error GPS: ${errorMsg}. Mapa centrado por defecto.`, "warning", 3000);
                        locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ';
                    }
                );
            } else {
                initializeOrUpdateMap(currentReminderLocation, radiusInput.value, true);
            }

            resetAndStartCountdown();
            setTimeout(() => { mapExpandedManually = false; }, 100);
        });
    }

    if (reduceMapButton) {
        reduceMapButton.addEventListener('click', () => {
             if (locationEnabledByUser && currentReminderLocation) {
                 initializeOrUpdateMap(currentReminderLocation, radiusInput.value, false);
             } else {
                 destroyMap();
             }
             resetAndStartCountdown();
        });
    }

    if (locateMeButton) {
        locateMeButton.addEventListener('click', () => {
             if (!reminderModalMap || !mapContainer.classList.contains('expanded')) return;
             resetAndStartCountdown();
             locateMeButton.disabled = true; locateMeButton.textContent = 'Buscando...';
             getCurrentLocation(
                 (coords) => {
                     currentReminderLocation = { latitude: coords.latitude, longitude: coords.longitude };
                     if (reminderModalMap) {
                        reminderModalMap.setView([coords.latitude, coords.longitude], 16);
                        updateMarkerAndCircle(coords, radiusInput.value);
                     }
                     showToast('Ubicación actual fijada para el recordatorio.', 'success');
                     locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ';
                 },
                 (errorMsg) => {
                     showToast(`Error al localizar: ${errorMsg}`, 'error');
                     locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ';
                 }
             );
        });
    }


    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) { const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; const recognition = new SpeechRecognition(); recognition.continuous = false; recognition.interimResults = false; recognition.lang = 'es-ES'; speechButton.addEventListener('click', () => { cleanUpModalTimers(false); try { recognition.start(); } catch (e) { speechStatus.textContent = `Error inicio: ${e.message}`; speechStatus.style.color = '#EF4444'; resetAndStartCountdown(); } }); recognition.onstart = () => { speechStatus.textContent = 'Escuchando...'; speechStatus.style.color = '#10B981'; }; recognition.onresult = (event) => { const transcript = event.results[event.results.length - 1][0].transcript.trim(); textInput.value = textInput.value + transcript; speechStatus.textContent = ''; lastInputWasSpeech = true; const inputEvent = new Event('input', { bubbles: true }); textInput.dispatchEvent(inputEvent); textInput.focus(); textInput.selectionStart = textInput.selectionEnd = textInput.value.length; }; recognition.onerror = (event) => { speechStatus.textContent = `Error voz: ${event.error}`; speechStatus.style.color = '#EF4444'; resetAndStartCountdown(); }; recognition.onend = () => { if (speechStatus.textContent === 'Escuchando...') { setTimeout(() => { if (speechStatus.textContent === 'Escuchando...') speechStatus.textContent = ''; }, 1500); } if (!lastInputWasSpeech) { resetAndStartCountdown(); } }; } else { speechStatus.textContent = 'Voz no soportada.'; speechStatus.style.color = '#EF4444'; speechButton.disabled = true; speechButton.style.opacity = 0.5; }

    function startCountdown() { autoSaveInterval = setInterval(() => { if (!document.body.contains(modal)) { clearInterval(autoSaveInterval); autoSaveInterval = null; return; } countdownSave--; if (countdownSaveElement) countdownSaveElement.textContent = countdownSave; if (countdownSave === 23) { if (document.activeElement === textInput) { textInput.value += ' '; textInput.selectionStart = textInput.selectionEnd = textInput.value.length; } } if (countdownSave <= 0) { clearInterval(autoSaveInterval); autoSaveInterval = null; if (saveButton) saveButton.click(); } }, 1000); }
    
function resetAndStartCountdown() { countdownSave = 25; if (countdownSaveElement) countdownSaveElement.textContent = countdownSave; if (autoSaveInterval) { clearInterval(autoSaveInterval); autoSaveInterval = null; } startCountdown(); }
    timeInput.addEventListener('input', (e) => { manualTimeInput = true; let v = e.target.value.replace(/\D/g, ''); let fV=''; if(v.length>=2)fV=v.slice(0,2); if(v.length>2)fV+=':'+v.slice(2,4); else if(v.length<2)fV=v; e.target.value=fV; if (fV.match(/^\d{2}:\d{2}$/)) { const [h,m]=fV.split(':').map(Number); parseStatus.textContent=(h>23||m>59)?'Hora inválida':''; parseStatus.classList.toggle('text-red-600',h>23||m>59); parseStatus.classList.remove('text-green-600'); } else if(fV.length>0) { parseStatus.textContent='Formato HH:MM'; parseStatus.classList.remove('text-red-600','text-green-600'); } else { parseStatus.textContent=''; parseStatus.classList.remove('text-red-600','text-green-600'); } resetAndStartCountdown(); });
    dateInput.addEventListener('input', (e) => { let v = e.target.value.replace(/\D/g, ''); let fV=''; if(v.length>=2)fV=v.slice(0,2); if(v.length>2)fV+='/'+v.slice(2,4); if(v.length>4)fV+='/'+v.slice(4,8); else if(v.length<2)fV=v; e.target.value=fV; if (fV.match(/^\d{2}\/\d{2}\/\d{4}$/)) { const [d,m,y]=fV.split('/').map(Number); const dt=new Date(Date.UTC(y,m-1,d)); const ok=!isNaN(dt.getTime())&&dt.getUTCDate()===d&&dt.getUTCMonth()+1===m&&y>=2000&&y<=2099; parseStatus.textContent=ok?'':'Fecha inválida'; parseStatus.classList.toggle('text-red-600',!ok); parseStatus.classList.remove('text-green-600'); } else if(fV.length>0) { parseStatus.textContent='Formato DD/MM/AAAA'; parseStatus.classList.remove('text-red-600','text-green-600'); } else { parseStatus.textContent=''; parseStatus.classList.remove('text-red-600','text-green-600'); } resetAndStartCountdown(); });
    intervalInput.addEventListener('input', resetAndStartCountdown);
    modal.querySelectorAll('input[name="repeat"]').forEach(chk => chk.addEventListener('change', resetAndStartCountdown));
    autoSaveTimerLabel.style.display = 'block';
    if (countdownSaveElement) countdownSaveElement.textContent = countdownSave;

    function startFocusCheck() {
        if (restartTimeout) clearTimeout(restartTimeout);
        restartTimeout = setTimeout(() => {
            if (document.activeElement !== textInput &&
                document.activeElement !== timeInput &&
                document.activeElement !== dateInput &&
                document.activeElement !== intervalInput &&
                !Array.from(modal.querySelectorAll('input[name="repeat"]')).includes(document.activeElement) &&
                document.activeElement !== speechButton &&
                document.activeElement !== saveButton &&
                document.activeElement !== modal.querySelector('#cancel-reminder') &&
                document.activeElement !== modal.querySelector('#help-reminder') &&
                document.activeElement !== clearButton &&
                document.activeElement !== modal.querySelector('#view-reminders') &&
                document.activeElement !== locationCheckbox &&
                document.activeElement !== radiusInput &&
                document.activeElement !== expandMapButton &&
                document.activeElement !== reduceMapButton &&
                document.activeElement !== locateMeButton &&
                !(reminderModalMap && reminderModalMap.getContainer().contains(document.activeElement))
               ) {
                resetAndStartCountdown();
                restartTimeout = null;
            } else {
                restartTimeout = null;
            }
        }, 500);
    }
    resetAndStartCountdown();
    startFocusCheck();
    modal.addEventListener('input', resetAndStartCountdown);
    modal.addEventListener('click', resetAndStartCountdown);
    modal.addEventListener('focusin', () => {
        resetAndStartCountdown();
        if (focusTimeout) clearTimeout(focusTimeout);
        focusTimeout = null;
    });
    modal.addEventListener('focusout', () => {
        if (!focusTimeout) {
            startFocusCheck();
        }
    });

    textInput.addEventListener('input', (e) => {
        lastInputWasSpeech = false; const txt = e.target.value || ''; parseStatus.textContent = 'Parseando...'; parseStatus.classList.remove('text-green-600', 'text-red-600');
        if (parseTimeout) clearTimeout(parseTimeout);
        parseTimeout = setTimeout(() => {
            if (!document.body.contains(modal)) return;
            try {
                const uiElements = { timeInput: timeInput, dateInput: dateInput, intervalInput: intervalInput, repeatCheckboxes: modal.querySelectorAll('input[name="repeat"]'), locationCheckbox: locationCheckbox, radiusInput: radiusInput, manualTimeInput: manualTimeInput, mapExpandedManually: mapExpandedManually, excludeFromListCheckbox: excludeFromListCheckbox };
                 if (!manualTimeInput) uiElements.timeInput.value = '';
                 uiElements.dateInput.value = ''; uiElements.intervalInput.value = '';
                 uiElements.repeatCheckboxes.forEach(chk => chk.checked = false);

                const pD = parseReminderText(txt, uiElements);

                if (isNew && (pD.type === 'weekly' || pD.type === 'interval')) {
                    const tempReminderForCalc = { type: pD.type, time: pD.time, date: pD.date, repeatDays: pD.repeatDays, intervalDays: pD.intervalDays };
                    const nowForCalc = new Date();
                    if (!tempReminderForCalc.date) tempReminderForCalc.date = `${nowForCalc.getFullYear()}-${(nowForCalc.getMonth() + 1).toString().padStart(2, '0')}-${nowForCalc.getDate().toString().padStart(2, '0')}`;
                    if (!tempReminderForCalc.time) tempReminderForCalc.time = '00:01';

                    const firstOcc = calculateNextOccurrence(tempReminderForCalc, new Date());
                    if (firstOcc) {
                        const firstOccISO = `${firstOcc.getUTCFullYear()}-${(firstOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOcc.getUTCDate().toString().padStart(2, '0')}`;
                        const firstOccTime = `${firstOcc.getUTCHours().toString().padStart(2, '0')}:${firstOcc.getUTCMinutes().toString().padStart(2, '0')}`;

                        pD.date = firstOccISO;
                        pD.time = firstOccTime;

                        const datePartsCalc = pD.date.split('-');
                        if(datePartsCalc.length === 3) dateInput.value = `${datePartsCalc[2]}/${datePartsCalc[1]}/${datePartsCalc[0]}`;
                        if (!manualTimeInput) timeInput.value = pD.time;
                    } else {
                         if (!pD.date) { const today = new Date(); pD.date = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}-${today.getDate().toString().padStart(2, '0')}`; }
                         if (!pD.time) pD.time = '00:01';
                         const datePartsFb = pD.date.split('-');
                         if(datePartsFb.length === 3) dateInput.value = `${datePartsFb[2]}/${datePartsFb[1]}/${datePartsFb[0]}`;
                         if (!manualTimeInput) timeInput.value = pD.time;
                    }
                }

                parseStatus.textContent = 'Parseado OK'; parseStatus.classList.add('text-green-600'); parseStatus.classList.remove('text-red-600');
                handleLocationCheckboxChange();
            } catch (error) { parseStatus.textContent = `Error parse: ${error.message.substring(0, 100)}`; parseStatus.classList.add('text-red-600'); parseStatus.classList.remove('text-green-600'); }
            parseTimeout = null;
        }, 1000);
        resetAndStartCountdown();
    });

    const form = modal.querySelector('#reminder-form');
    form.addEventListener('submit', (e) => {
        e.preventDefault(); cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;

        const text = textInput.value.trim(); if (!text) { parseStatus.textContent = 'Texto obligatorio.'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; }
        let time = timeInput.value.trim(); let dateStr = dateInput.value.trim(); const repeatDays = Array.from(modal.querySelectorAll('input[name="repeat"]:checked')).map(input => parseInt(input.value)); const intervalDays = parseInt(intervalInput.value) || null;
        const isLocationChecked = locationCheckbox.checked; const radius = parseInt(radiusInput.value) || 1000;
        const locationCoords = currentReminderLocation;
        const excludeFromListVal = excludeFromListCheckbox.checked;
        if (isLocationChecked && !locationCoords) { parseStatus.textContent = 'Ubicación activada pero no fijada en el mapa.'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; }
        let dateISO = null; let finalTime = time; let reminderType = 'simple';
        if (dateStr) { if (dateStr.match(/^\d{2}\/\d{2}\/\d{4}$/)) { const [d, m, y] = dateStr.split('/').map(Number); const tD = new Date(Date.UTC(y, m - 1, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() + 1 === m && y >= 2000 && y <= 2099) { dateISO = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } else { parseStatus.textContent = 'Fecha inválida'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } } else { parseStatus.textContent = 'Formato DD/MM/AAAA'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } }
        if (finalTime && !finalTime.match(/^\d{2}:\d{2}$/)) { parseStatus.textContent = 'Formato HH:MM'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } else if (finalTime) { const [h, m] = finalTime.split(':').map(Number); if (h > 23 || m > 59) { parseStatus.textContent = 'Hora inválida'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } }
        if (intervalDays !== null && intervalDays > 0) { reminderType = 'interval'; if (!dateISO) { const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } if (!finalTime) finalTime = '00:01'; }
        else if (repeatDays.length > 0) { reminderType = 'weekly'; if (!dateISO) { const tempCalc = { type: 'weekly', time: finalTime || '00:01', date: null, repeatDays: repeatDays, intervalDays: null }; const firstOcc = calculateNextOccurrence(tempCalc, new Date()); if (firstOcc) { dateISO = `${firstOcc.getUTCFullYear()}-${(firstOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOcc.getUTCDate().toString().padStart(2, '0')}`; finalTime = finalTime || `${firstOcc.getUTCHours().toString().padStart(2, '0')}:${firstOcc.getUTCMinutes().toString().padStart(2, '0')}`; } else { const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; if (!finalTime) finalTime = '00:01'; } } else { if (!finalTime) finalTime = '00:01'; } }
        else if (dateISO && finalTime) { reminderType = 'daily'; } else if (finalTime) { reminderType = 'daily'; const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (dateISO) { reminderType = 'daily'; finalTime = '00:01'; } else { reminderType = 'simple'; const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; finalTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`; }
        const now = new Date();
        const finalCreatedAt = isNew ? now.toISOString() : (parsed.createdAt || now.toISOString());
        let finalDateISO = dateISO;

        if (isNew && (reminderType === 'weekly' || reminderType === 'interval')) {
            let needsRecalc = false;
            if (!dateInput.value.trim()) {
                 needsRecalc = true;
            } else {
                try {
                    const [d, m, y] = dateStr.split('/').map(Number);
                    const inputDate = new Date(Date.UTC(y, m - 1, d));
                    const todayForCompare = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    if (inputDate < todayForCompare) {
                        needsRecalc = true;
                    }
                } catch (e) { needsRecalc = true; }
            }

            if (needsRecalc) {
                const tempCalcForNewCyclic = {
                    type: reminderType,
                    time: finalTime || '00:01',
                    date: null,
                    repeatDays: reminderType === 'weekly' ? repeatDays : [],
                    intervalDays: reminderType === 'interval' ? intervalDays : null
                };
                const firstOccurrence = calculateNextOccurrence(tempCalcForNewCyclic, new Date());
                if (firstOccurrence) {
                    finalDateISO = `${firstOccurrence.getUTCFullYear()}-${(firstOccurrence.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOccurrence.getUTCDate().toString().padStart(2, '0')}`;
                } else {
                    if (!finalDateISO) {
                        finalDateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
                    }
                }
            }
        }


        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        const newReminder = {
            id: isNew ? Date.now() : parsed.id,
            text: `<b>${text.toUpperCase()}</b>`,
            type: reminderType,
            time: finalTime || null,
            date: finalDateISO,
            repeatDays: reminderType === 'weekly' ? repeatDays : [],
            intervalDays: reminderType === 'interval' ? intervalDays : null,
            createdAt: finalCreatedAt,
            managedByUser: false,
            isLocationEnabled: isLocationChecked,
            locationCoordinates: isLocationChecked ? locationCoords : null,
            radiusMeters: isLocationChecked ? radius : (parsed.radiusMeters || 1000),
            excludeFromList: excludeFromListVal
        };

        if (!newReminder.date || !newReminder.time || !newReminder.createdAt){
            showToast("Error GRAVE: Fechas/Hora inválidas al guardar.", "error");
            resetAndStartCountdown();
            return;
        }

        if (!isNew) {
            const index = reminders.findIndex(r => r.id === parsed.id);
            if (index !== -1) {
                reminders[index] = newReminder;
            } else {
                reminders.push(newReminder);
            }
        } else {
            reminders.push(newReminder);
        }

        localStorage.setItem('reminders', JSON.stringify(reminders));
        showToast('Recordatorio guardado', 'success');

        destroyMap();
        if (modal.parentNode) document.body.removeChild(modal);

        updateReminderCount();
        updateButtonStyles();
        checkReminders();

        sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');

        const unifiedWindowIsVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible');

        if (mapShouldReopen && !unifiedWindowIsVisible) {
            showAllRemindersLocationMap();
        } else if (mapShouldReopen && unifiedWindowIsVisible) {
            sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
        }
    });

    modal.querySelector('#cancel-reminder').addEventListener('click', () => {
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        destroyMap();
        if (modal.parentNode) document.body.removeChild(modal);

        if (mapShouldReopen) {
            showAllRemindersLocationMap();
        }
    });
    modal.querySelector('#help-reminder').addEventListener('click', showHelpModal);
    clearButton.addEventListener('click', () => {
        textInput.value=''; timeInput.value=''; dateInput.value='';
        modal.querySelectorAll('input[name="repeat"]').forEach(i=>i.checked=false);
        intervalInput.value='';
        locationCheckbox.checked = false;
        radiusInput.value = (parsed.radiusMeters || 1000);
        currentReminderLocation = null;
        destroyMap();
        radiusInput.disabled = true;
        excludeFromListCheckbox.checked = false;
        parseStatus.textContent='';
        speechStatus.textContent='';
        manualTimeInput=false;
        resetAndStartCountdown();
        textInput.focus();
    });
    modal.querySelector('#view-reminders').addEventListener('click', () => {
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        destroyMap();
        if (modal.parentNode) document.body.removeChild(modal);
        fromReminderModal = true;

        if (mapShouldReopen) {
            sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
        }
        showAllReminders();
    });
    textInput.focus();
}

    function markReminderAsManaged(reminderId, managedState = true) {
         if (typeof reminderId !== 'number') { return; } try { let reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); const index = reminders.findIndex(r => r.id === reminderId); if (index !== -1) { if (reminders[index].managedByUser !== managedState) { reminders[index].managedByUser = managedState; localStorage.setItem('reminders', JSON.stringify(reminders)); } } } catch (e) { console.error("Error updating managedByUser flag:", e); }
     }

     function displayUnifiedReminderWindow(overdueReminders) {
         const windowElement = document.getElementById('unified-reminder-window');
         const swiperContainer = document.getElementById('reminder-swiper-container');
         const countHeader = windowElement.querySelector('.reminder-count-header');
         const countSpan = document.getElementById('total-reminder-count');
         const currentIndexSpan = document.getElementById('current-reminder-index');
         const countTextContainer = document.getElementById('reminder-count-text-container');
         const swipeHint = document.getElementById('reminder-swipe-hint');
         const hideAllButton = document.getElementById('hide-all-reminders-button');

          Object.values(previewMaps).forEach(map => map?.remove());
          previewMaps = {};

         if (!windowElement || !swiperContainer || !countHeader || !countSpan || !currentIndexSpan || !countTextContainer || !swipeHint || !hideAllButton) {
             return;
         }
         swiperContainer.innerHTML = '';
         overdueReminders.sort((a, b) => { try { const dateA = new Date(`${a.date}T${a.time}:00Z`); const dateB = new Date(`${b.date}T${b.time}:00Z`); return dateA - dateB; } catch (e) { return 0; } });

         if (!isUnifiedWindowVisibleByLogic) {
             currentNotificationSlideIndex = 0;
         }

         overdueReminders.forEach((reminder, index) => {
             const slide = document.createElement('div');
             slide.className = 'reminder-slide';
             slide.dataset.id = reminder.id;
             slide.setAttribute('role', 'group');
             slide.setAttribute('aria-label', `Recordatorio: ${reminder.text.replace(/<[^>]*>/g, '')}`);

             let detailsHtml = '';
             if (reminder.time) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Hora: ${formatTimeWithPeriod(reminder.time)}</p>`;
             if (reminder.date) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Fecha: ${formatDateDetailed(reminder.date)}</p>`;
             if (reminder.type === 'weekly' && reminder.repeatDays?.length > 0) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Repite: ${reminder.repeatDays.map(d => ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'][d]).join(', ')}</p>`;
             if (reminder.type === 'interval' && reminder.intervalDays) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Cada: ${reminder.intervalDays} días</p>`;
             if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                 detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Ubicación: Activada (Radio ${reminder.radiusMeters || 1000}m)</p>`;
             }

             const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval';
             const showAdjustButton = isCyclic && reminder.time !== '00:01';
             const adjustButtonHtml = showAdjustButton ? `<button class="adjust-time-0001">Ajustar Hora 00:01 y Visto</button>` : '';
             const cyclicCancelButtonHtml = isCyclic ? `<button class="cancel-cyclic">Anular Ciclo</button>` : '';

             const mapPreviewHtml = reminder.isLocationEnabled && reminder.locationCoordinates ? `
                 <div class="reminder-map-preview-container">
                     <div id="map-preview-${reminder.id}" class="reminder-map-preview"></div>
                 </div>
             ` : '';

             slide.innerHTML = `
                 <div class="reminder-slide-content">
                     <div class="reminder-content-scrollable">
                         <p class="reminder-text">${reminder.text}</p>
                         ${detailsHtml}
                     </div>
                     <div class="button-group">
                         <button class="cancel">Visto / Próximo</button>
                         <button class="postpone">Posponer</button>
                         <button class="modify">Modificar</button>
                         ${adjustButtonHtml}
                         ${cyclicCancelButtonHtml}
                     </div>
                 </div>
                 ${mapPreviewHtml}
             `;

             addSlideButtonListeners(slide, reminder);
             swiperContainer.appendChild(slide);

             if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                  const mapPreviewElement = slide.querySelector(`#map-preview-${reminder.id}`);
                  if (mapPreviewElement) {
                     setTimeout(() => {
                         try {
                             if (!document.getElementById(mapPreviewElement.id)) return;

                             const map = L.map(mapPreviewElement, {
                                 dragging: false, touchZoom: false, scrollWheelZoom: false, doubleClickZoom: false,
                                 boxZoom: false, keyboard: false, tap: false, zoomControl: false
                             }).setView([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude], 14);

                             L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                             }).addTo(map);

                             L.marker([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude]).addTo(map);
                             L.circle([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude], {
                                 color: 'blue', weight: 1, fillColor: '#ADD8E6', fillOpacity: 0.05, radius: reminder.radiusMeters || 1000
                             }).addTo(map);

                             map.invalidateSize();
                             previewMaps[reminder.id] = map;
                         } catch (mapError) {
                              if (mapPreviewElement) mapPreviewElement.innerHTML = `<p style="font-size:0.8rem; color: red; text-align: center; padding: 5px;">Error al cargar mapa</p>`;
                         }
                     }, 50);
                  }
             }
         });

         const count = overdueReminders.length;
         countSpan.textContent = count;

         if (count > 0) {
              if (currentNotificationSlideIndex >= count) {
                  currentNotificationSlideIndex = 0;
              }
              swiperContainer.scrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
              updateReminderIndexDisplay();

              countHeader.classList.remove('hidden');
              if (count > 1) {
                 countTextContainer.style.display = 'inline';
                 swipeHint.style.display = 'block';
                 document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = 'calc(85vh - 60px)');
              } else {
                 countTextContainer.style.display = 'none';
                 swipeHint.style.display = 'none';
                 document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = '85vh');
              }
               hideAllButton.classList.remove('hidden');
               const newHideAllButton = hideAllButton.cloneNode(true);
               hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton);
               newHideAllButton.addEventListener('click', postponeAllVisibleReminders);
         } else {
             countHeader.classList.add('hidden');
             hideAllButton.classList.add('hidden');
             currentNotificationSlideIndex = 0;
         }
         windowElement.classList.add('visible');
         isUnifiedWindowVisibleByLogic = true;

         swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay);
         swiperContainer.addEventListener('scroll', updateReminderIndexDisplay);
     }

     function hideUnifiedReminderWindow() {
         const windowElement = document.getElementById('unified-reminder-window');
         if (windowElement && windowElement.classList.contains('visible')) {
             windowElement.classList.remove('visible');
             isUnifiedWindowVisibleByLogic = false;
             const swiperContainer = document.getElementById('reminder-swiper-container');
              Object.values(previewMaps).forEach(map => map?.remove());
              previewMaps = {};
             if (swiperContainer) {
                 swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay);
                  setTimeout(() => {
                      if (swiperContainer && !windowElement.classList.contains('visible')) {
                          swiperContainer.innerHTML = '';
                      }
                  }, 300);
             }
             const hideAllButton = document.getElementById('hide-all-reminders-button');
             if (hideAllButton) { const newHideAllButton = hideAllButton.cloneNode(true); hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton); }

            const mapShouldReopen = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
            sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');

            if (mapShouldReopen &&
                !document.querySelector('.reminder-modal') &&
                !document.querySelector('.reminder-table-modal') &&
                !document.getElementById('reminders-location-map-modal')
               ) {
                 showAllRemindersLocationMap();
            }
         }
     }

function postponeAllVisibleReminders() {
         const swiperContainer = document.getElementById('reminder-swiper-container'); if (!swiperContainer) return;
         const visibleSlides = swiperContainer.querySelectorAll('.reminder-slide'); if (visibleSlides.length === 0) return;

         let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
         let updated = false;
         const idsToUpdate = [];

         visibleSlides.forEach(slide => {
             const reminderId = parseInt(slide.dataset.id);
             if (isNaN(reminderId)) return;
             idsToUpdate.push(reminderId);

             const index = reminders.findIndex(r => r.id === reminderId);
             if (index !== -1) {
                 const { newDateISO, newTime } = calculatePostponedDateTime(1);
                 reminders[index].date = newDateISO;
                 reminders[index].time = newTime;
                 reminders[index].managedByUser = false;
                 updated = true;
             }
         });

         if (updated) {
             localStorage.setItem('reminders', JSON.stringify(reminders));
             showToast(`${idsToUpdate.length} recordatorio(s) pospuesto(s) 1 minuto.`, 'info');
             idsToUpdate.forEach(id => updateUnifiedWindowUI(id));
             updateReminderCount();
             updateButtonStyles();
         }
         if (idsToUpdate.length > 0 && document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
            hideUnifiedReminderWindow();
         }
     }


     function updateReminderIndexDisplay() {
         const swiperContainer = document.getElementById('reminder-swiper-container');
         const currentIndexSpan = document.getElementById('current-reminder-index');
         if (!swiperContainer || !currentIndexSpan) return;

         const totalSlides = swiperContainer.querySelectorAll('.reminder-slide').length;
         if (totalSlides === 0) {
             currentIndexSpan.textContent = '0';
             return;
         }

         const containerWidth = swiperContainer.offsetWidth;
         if (containerWidth <= 0) {
            return;
         }
         const currentScroll = swiperContainer.scrollLeft;
         const currentIndex = Math.round(currentScroll / containerWidth);

         currentNotificationSlideIndex = currentIndex;

         const displayIndex = Math.max(1, Math.min(currentIndex + 1, totalSlides));
         currentIndexSpan.textContent = displayIndex;

          const currentSlideElement = swiperContainer.querySelectorAll('.reminder-slide')[currentIndex];
          if (currentSlideElement) {
             const mapId = currentSlideElement.querySelector('.reminder-map-preview')?.id;
             if (mapId) {
                  const reminderId = parseInt(mapId.replace('map-preview-', ''));
                  if (previewMaps[reminderId]) {
                      setTimeout(() => { if(previewMaps[reminderId]) previewMaps[reminderId].invalidateSize(); }, 50);
                  }
             }
          }
     }

     function addSlideButtonListeners(slideElement, reminder) {
         const reminderId = reminder.id;
         const cancelButton = slideElement.querySelector('.cancel');
         const adjustTimeButton = slideElement.querySelector('.adjust-time-0001');
         const cancelCyclicButton = slideElement.querySelector('.cancel-cyclic');
         const modifyButton = slideElement.querySelector('.modify');
         const postponeButton = slideElement.querySelector('.postpone');

         const handleInteraction = (actionFn) => {
             markReminderAsManaged(reminderId, true);
             actionFn();
             updateUnifiedWindowUI(processedReminderId);
         };

         let processedReminderId = reminderId;

         if (cancelButton) {
             cancelButton.addEventListener('click', () => handleInteraction(() => {
                 let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                 const index = rems.findIndex(r => r.id === processedReminderId);
                 if (index === -1) return;

                 const currentReminder = rems[index];
                 let needsSave = false;

                 if (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval')) {
                    const { newDateISO, newTime } = calculatePostponedDateTime(15);
                    rems[index].date = newDateISO;
                    rems[index].time = newTime;
                    rems[index].managedByUser = false;
                    needsSave = true;
                    showToast('Recordatorio pospuesto 15 minutos', 'info');
                 } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                     let referenceDateForNext = new Date();
                     try {
                         const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                         const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                         const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                         if (!isNaN(reminderDateTime.getTime())) {
                             referenceDateForNext = new Date(reminderDateTime.getTime() + 60000);
                         }
                     } catch(e) { }

                     const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                     if (nextOcc) {
                         rems[index].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                         rems[index].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                         rems[index].managedByUser = false;
                         needsSave = true;
                         showToast('Recordatorio actualizado al próximo ciclo', 'info');
                     } else {
                         rems.splice(index, 1); needsSave = true;
                         showToast('Error calculando siguiente ciclo. Recordatorio eliminado.', 'error');
                     }
                 } else {
                     rems.splice(index, 1); needsSave = true;
                     showToast('Recordatorio marcado como visto y eliminado', 'info');
                 }

                 if (needsSave) localStorage.setItem('reminders', JSON.stringify(rems));
             }));
         }

         if (adjustTimeButton) {
             adjustTimeButton.addEventListener('click', () => handleInteraction(() => {
                 let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                 const index = rems.findIndex(r => r.id === processedReminderId);
                 if (index === -1) return;

                 const currentReminder = rems[index];
                 let needsSave = false;

                 if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                      let referenceDateForNext = new Date();
                      try {
                          const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                          const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, 0, 1));
                          if (!isNaN(reminderDateTime.getTime())) {
                              referenceDateForNext = new Date(reminderDateTime.getTime() + 60000);
                          }
                      } catch(e) { }

                     const reminderForCalc = { ...currentReminder, time: '00:01' };
                     const nextOcc = calculateNextOccurrence(reminderForCalc, referenceDateForNext);

                     if (nextOcc) {
                         rems[index].date= `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                         rems[index].time = '00:01';
                         rems[index].managedByUser = false;
                         needsSave = true;
                         showToast('Recordatorio ajustado a 00:01 y actualizado', 'info');
                     } else {
                         rems.splice(index, 1); needsSave = true;
                         showToast('Error calculando siguiente ciclo (ajuste 00:01). Eliminado.', 'error');
                     }
                 } else {
                     rems.splice(index, 1); needsSave = true;
                     showToast('Recordatorio no cíclico eliminado (ajuste 00:01)', 'info');
                 }

                 if (needsSave) localStorage.setItem('reminders', JSON.stringify(rems));
             }));
         }

         if (cancelCyclicButton) {
             cancelCyclicButton.addEventListener('click', () => handleInteraction(() => {
                 if (confirm('¿Estás seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE?')) {
                     let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                     rems = rems.filter(r => r.id !== processedReminderId);
                     localStorage.setItem('reminders', JSON.stringify(rems));
                     showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                 } else {
                     markReminderAsManaged(processedReminderId, false);
                 }
             }));
         }

         if (modifyButton) {
             modifyButton.addEventListener('click', () => {
                 markReminderAsManaged(reminder.id, true);
                 let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                 const reminderToModify = remindersFromStorage.find(r => r.id === reminder.id);

                 const mapShouldReopenWhenUnifiedCloses = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';

                 hideUnifiedReminderWindow();

                 if (reminderToModify) {
                     if (mapShouldReopenWhenUnifiedCloses) {
                          sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                     }
                     showReminderModal(reminderToModify);
                 }
                 else {
                     showToast("Error: no se pudo encontrar el recordatorio.", "error");
                     updateUnifiedWindowUI(reminder.id);
                     if (mapShouldReopenWhenUnifiedCloses &&
                         sessionStorage.getItem('boardinggate_map_should_reopen_after_form') !== 'true' &&
                         !document.getElementById('reminders-location-map-modal')
                        ) {
                         showAllRemindersLocationMap();
                     }
                 }
                 sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
             });
         }

         if (postponeButton) {
             postponeButton.addEventListener('click', () => {
                 markReminderAsManaged(processedReminderId, true);
                 let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                 const reminderToPostpone = remindersFromStorage.find(r => r.id === processedReminderId);
                 if (reminderToPostpone) {
                     showPostponeOptionsModal(reminderToPostpone, 'unified');
                 }
                 else {
                     showToast("Error: no se pudo encontrar el recordatorio.", "error");
                     updateUnifiedWindowUI(processedReminderId);
                 }
             });
         }
     }


     function updateUnifiedWindowUI(processedReminderId) {
         const windowElement = document.getElementById('unified-reminder-window');
         const swiperContainer = document.getElementById('reminder-swiper-container');
         const slideToRemove = swiperContainer ? swiperContainer.querySelector(`.reminder-slide[data-id="${processedReminderId}"]`) : null;

         if (previewMaps[processedReminderId]) {
             previewMaps[processedReminderId].remove();
             delete previewMaps[processedReminderId];
         }

         if (slideToRemove && slideToRemove.parentNode === swiperContainer) {
             swiperContainer.removeChild(slideToRemove);
         }

         const remainingSlides = swiperContainer ? swiperContainer.querySelectorAll('.reminder-slide') : [];
         const remainingCount = remainingSlides.length;

         if (remainingCount === 0) {
             hideUnifiedReminderWindow();
         }
         else {
             const countHeader = windowElement.querySelector('.reminder-count-header');
             const countSpan = document.getElementById('total-reminder-count');
             const countTextContainer = document.getElementById('reminder-count-text-container');
             const swipeHint = document.getElementById('reminder-swipe-hint');

             countSpan.textContent = remainingCount;
             updateReminderIndexDisplay();

             if (remainingCount > 1) {
                 countTextContainer.style.display = 'inline';
                 swipeHint.style.display = 'block';
                 countHeader.classList.remove('hidden');
             } else {
                 countTextContainer.style.display = 'none';
                 swipeHint.style.display = 'none';
                 countHeader.classList.remove('hidden');
             }

             const maxScrollIndex = remainingCount - 1;
             if (currentNotificationSlideIndex > maxScrollIndex) {
                  currentNotificationSlideIndex = maxScrollIndex;
                  swiperContainer.scrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
                  updateReminderIndexDisplay();
             }
         }

         updateReminderCount();
         updateButtonStyles();
     }

    function setupReminderTableListeners(modalTable) {
        modalTable.querySelectorAll('.visto-prox').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true);

                let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderIndex = rems.findIndex(r => r.id === id);
                let needsSave = false;
                const row = newButton.closest('tr');

                if (reminderIndex > -1 && row) {
                    const currentReminder = rems[reminderIndex];
                     if (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval')) {
                        const { newDateISO, newTime } = calculatePostponedDateTime(15);
                        rems[reminderIndex].date = newDateISO;
                        rems[reminderIndex].time = newTime;
                        rems[reminderIndex].managedByUser = false;
                        needsSave = true;
                        const dateCell = row.cells[3]; const timeCell = row.cells[2];
                        if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date);
                        if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                        showToast('Recordatorio con ubicación pospuesto 15 min', 'info');
                    } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                         let referenceDateForNext = new Date();
                         try {
                             const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                             const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                             const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                             if (!isNaN(reminderDateTime.getTime())) {
                                 referenceDateForNext = new Date(reminderDateTime.getTime() + 60000);
                             }
                         } catch(er) { }

                        const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                        if (nextOcc) {
                            rems[reminderIndex].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                            rems[reminderIndex].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                            rems[reminderIndex].managedByUser = false;
                            needsSave = true;
                            const dateCell = row.cells[3]; const timeCell = row.cells[2];
                            if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date);
                            if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                            showToast('Actualizado al próximo periodo', 'info');
                        } else {
                            rems.splice(reminderIndex, 1); needsSave = true;
                            row.remove(); showToast('Error calculando siguiente ciclo. Eliminado.', 'error');
                        }
                    } else {
                        rems.splice(reminderIndex, 1); needsSave = true;
                        row.remove(); showToast('Recordatorio borrado', 'info');
                    }
                    if (needsSave) localStorage.setItem('reminders', JSON.stringify(rems));

                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios.</td></tr>`;
                    }
                } else {
                    showToast('Error: Recordatorio no encontrado para actualizar/borrar.', 'error');
                    if(row) row.remove();
                }
                updateReminderCount(); updateButtonStyles(); checkReminders();
            });
        });

        modalTable.querySelectorAll('.postpone').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true);
                const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderToPostpone = reminders.find(r => r.id === id);
                if (reminderToPostpone) {
                    if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                    modalTable.remove();
                    showPostponeOptionsModal(reminderToPostpone, 'table');
                } else {
                    showToast('Error: Recordatorio no encontrado para posponer.', 'error');
                    markReminderAsManaged(id, false);
                }
            });
        });

        modalTable.querySelectorAll('.cancel-cyclic-table').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                if (confirm('¿Estás seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE?')) {
                    markReminderAsManaged(id, true);
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const initialLength = rems.length;
                    rems = rems.filter(r => r.id !== id);
                    if (rems.length < initialLength) {
                        localStorage.setItem('reminders', JSON.stringify(rems));
                        showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                    } else {
                        showToast('Error: No se encontró el ciclo para anular.', 'warning');
                    }
                    const row = newButton.closest('tr');
                    if (row) row.remove();
                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios.</td></tr>`;
                    }
                    updateReminderCount(); updateButtonStyles(); checkReminders();
                }
            });
        });

        const tableBody = modalTable.querySelector('#reminder-table-body');
        if (tableBody) {
            const newTableBody = tableBody.cloneNode(false);
            while(tableBody.firstChild) newTableBody.appendChild(tableBody.firstChild);
            tableBody.parentNode.replaceChild(newTableBody, tableBody);

            newTableBody.addEventListener('click', (e) => {
                if (e.target.closest('td:first-child button')) return;

                const row = e.target.closest('tr[data-id]');
                if (row?.dataset.id) {
                    const id = parseInt(row.dataset.id); if (isNaN(id)) return;
                    markReminderAsManaged(id, true);
                    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const reminderToModify = reminders.find(r => r.id === id);
                    if (reminderToModify) {
                        const mapWasOpenBeforeTable = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';

                        if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                        modalTable.remove();

                        if (mapWasOpenBeforeTable) {
                            sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                        }
                        sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                        showReminderModal(reminderToModify);
                    } else {
                        showToast('Error: Recordatorio no encontrado para modificar.', 'error');
                        markReminderAsManaged(id, false);
                    }
                }
            });
        }
    }

     function showAllReminders() {
         const mapWasOpenBeforeThisTable = !!document.getElementById('reminders-location-map-modal');
         if (mapWasOpenBeforeThisTable) {
             sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
         } else {
             sessionStorage.removeItem('boardinggate_map_was_open_before_table');
         }

         hideUnifiedReminderWindow();
         Object.values(previewMaps).forEach(map => map?.remove()); previewMaps = {};
         const otherModals = document.querySelectorAll('.choice-modal, .edit-modal, .edit-info-modal, .help-modal, .reminder-modal, .versions-modal-overlay, .saved-locations-modal, #reminders-location-map-modal, #reminders-map-help-modal-instance');
         otherModals.forEach(m => m.remove());


         let allReminders = [];
         try {
             allReminders = JSON.parse(localStorage.getItem('reminders') || '[]').map(r => ({ ...r }));
         } catch(e) {
             showToast("Error al cargar lista de recordatorios.", "error");
             return;
         }

         const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
         let remindersToDisplay = allReminders;
         if (!showExcluded) {
             remindersToDisplay = allReminders.filter(r => !r.excludeFromList);
         }


         remindersToDisplay.sort((a, b) => {
             const nowForSort = new Date();
             const nextA = calculateNextOccurrence(a, nowForSort);
             const nextB = calculateNextOccurrence(b, nowForSort);

             if (nextA && nextB) {
                 const timeDiff = nextA.getTime() - nextB.getTime();
                 if (timeDiff !== 0) return timeDiff;
             } else if (nextA) {
                 return -1;
             } else if (nextB) {
                 return 1;
             }
             const typeOrder = { 'simple': 1, 'hourly': 2, 'daily': 3, 'weekly': 4, 'interval': 5 };
             const typeDiff = (typeOrder[a.type] ?? 99) - (typeOrder[b.type] ?? 99);
             if (typeDiff !== 0) return typeDiff;

             const createdAtA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
             const createdAtB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
             return createdAtA - createdAtB;
         });

         const existingModal = document.querySelector('.reminder-table-modal');
         if (existingModal) {
             if (existingModal.autoCloseInterval) clearInterval(existingModal.autoCloseInterval);
             if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal);
         }

         const modalTable = document.createElement('div');
         modalTable.className = 'reminder-table-modal';
         modalTable.setAttribute('aria-label', 'Tabla recordatorios');

         modalTable.innerHTML = `
             <h2 style="text-align:center;margin-bottom:1rem;font-size:1.5rem;color:#333;">Recordatorios</h2>

           <div class="top-button-container">
                 <button type="button" id="close-reminders-top">SALIR <span class="button-countdown"></span></button>
                 <button type="button" id="view-all-locations-map">VER UBICACIONES</button>
                 <div style="display: flex; align-items: center; margin-left: 20px;">
                    <input type="checkbox" id="show-excluded-reminders" ${showExcluded ? 'checked' : ''} style="transform: scale(1.3);">
                    <label for="show-excluded-reminders" style="margin-left: 0.5rem; font-size: 1.1rem;">MOSTRAR RADARES u OTROS</label>
                 </div>
             </div>


             <table>
                 <thead>
                     <tr>
                         <th style="width:12%;">Acciones</th>
                         <th>Texto</th>
                         <th style="width:8%;">Hora</th>
                         <th style="width:10%;">Fecha Prox.</th>
                         <th style="width:15%;">Días Rep.</th>
                         <th style="width:8%;">Cada x días</th>
                         <th style="width:8%;">Geoloc.</th>
                         <th style="width:10%;">Creado</th>
                     </tr>
                 </thead>
                 <tbody id="reminder-table-body">
                     ${remindersToDisplay.length === 0 ? `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios ${showExcluded ? ' (incluyendo excluidos)' : ''}.</td></tr>` :
                     remindersToDisplay.map(r => {
                         const isCyclic = r.type === 'weekly' || r.type === 'interval';
                         const rowBackgroundColor = isCyclic ? (r.excludeFromList ? '#C0D8C0' : '#D9E5DB') : (r.excludeFromList ? '#D8BFBF' : '#EAD9D9');
                         const nextOccurrenceDate = calculateNextOccurrence(r, new Date());
                         const formattedNextDate = nextOccurrenceDate ? formatDateToDDMMMYY(nextOccurrenceDate.toISOString().split('T')[0]) : formatDateToDDMMMYY(r.date);
                         const timeDisplay = r.time ? r.time : '-';
                         const geoIndicator = r.isLocationEnabled ? '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#008000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>' : '-';

                         return `<tr data-id="${r.id}" style="background-color: ${rowBackgroundColor};">
                                     <td>
                                         <button class="visto-prox" data-id="${r.id}" title="${isCyclic ? 'Marcar Visto y Avanzar al Próximo Ciclo' : 'Marcar Visto y Borrar'}">Visto/Prox</button>
                                         <button class="postpone" data-id="${r.id}" title="Posponer">Posponer</button>
                                         ${isCyclic ? `<button class="cancel-cyclic-table" data-id="${r.id}" title="Anular Ciclo Permanente">Anular Ciclo</button>` : ''}
                                     </td>
                                     <td class="text-column" title="Modificar">${r.text}</td>
                                     <td class="time-column">${timeDisplay}</td>
                                     <td class="date-column">${formattedNextDate}</td>
                                     <td>${r.type === 'weekly' && r.repeatDays?.length > 0 ? r.repeatDays.map(d => ['Dom','Lun','Mar','Mié','Jue','Vie','Sáb'][d]).join(', ') : '-'}</td>
                                     <td>${r.type === 'interval' ? r.intervalDays || '-' : '-'}</td>
                                     <td>${geoIndicator}</td>
                                     <td class="date-column">${r.createdAt ? formatDateToDDMMMYY(r.createdAt.split('T')[0]) : '-'}</td>
                                 </tr>`;
                     }).join('')}
                 </tbody>
             </table>
             <div class="button-group flex justify-start"><button type="button" id="close-reminders">SALIR <span class="button-countdown"></span></button></div>`;
         document.body.appendChild(modalTable);

         const showExcludedCheckbox = modalTable.querySelector('#show-excluded-reminders');
         if (showExcludedCheckbox) {
             showExcludedCheckbox.addEventListener('change', () => {
                 localStorage.setItem(SHOW_EXCLUDED_REMINDERS_KEY, JSON.stringify(showExcludedCheckbox.checked));
                 if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                 modalTable.remove();
                 showAllReminders();
             });
         }

         const viewLocationsMapButton = modalTable.querySelector('#view-all-locations-map');
         if (viewLocationsMapButton) {
             viewLocationsMapButton.addEventListener('click', showAllRemindersLocationMap);
         }

         let count = 60;
         const countdownSpans = modalTable.querySelectorAll('.button-countdown');
         countdownSpans.forEach(span => span.textContent = `(${count})`);
         const closeClean = () => {
             clearInterval(modalTable.autoCloseInterval);
             modalTable.autoCloseInterval = null;
             if (modalTable.parentNode) modalTable.parentNode.removeChild(modalTable);

             const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
             sessionStorage.removeItem('boardinggate_map_was_open_before_table');

             if (fromReminderModal) {
                 fromReminderModal = false;
                 if (mapShouldReopen) {
                     sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                 }
                 showReminderModal();
             } else if (mapShouldReopen) {
                 showAllRemindersLocationMap();
             }
         };
         modalTable.autoCloseInterval = setInterval(() => {
             count--;
             countdownSpans.forEach(span => span.textContent = `(${count})`);
             if (count <= 0) {
                 closeClean();
             }
         }, 1000);
         const resetTimer = () => {
             if (!modalTable.autoCloseInterval) return;
             clearInterval(modalTable.autoCloseInterval);
             count = 60;
             countdownSpans.forEach(span => span.textContent = `(${count})`);
             modalTable.autoCloseInterval = setInterval(() => {
                 count--;
                 countdownSpans.forEach(span => span.textContent = `(${count})`);
                 if (count <= 0) {
                     closeClean();
                 }
             }, 1000);
         };
         modalTable.addEventListener('click', resetTimer);
         modalTable.addEventListener('touchstart', resetTimer, { passive: true });
         modalTable.addEventListener('input', resetTimer);

         modalTable.querySelector('#close-reminders').addEventListener('click', closeClean);
         modalTable.querySelector('#close-reminders-top').addEventListener('click', closeClean);

         setupReminderTableListeners(modalTable);
     }


     function updateReminderCount() {
         let reminders = [];
         try {
             reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
         } catch (e) {
             reminders = [];
         }
         const showExcludedInTable = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
         let remindersForCount = reminders;
         if (!showExcludedInTable) {
             remindersForCount = reminders.filter(r => !r.excludeFromList);
         }

         const totalCount = remindersForCount.length;

         const nonCyclicReminders = remindersForCount.filter(r => r.type !== 'weekly' && r.type !== 'interval');
         const nonCyclicCount = nonCyclicReminders.length;

         const countElGlobe = document.getElementById('reminder-count-globe');
         if (countElGlobe) {
             countElGlobe.textContent = nonCyclicCount > 0 ? nonCyclicCount : '';
             countElGlobe.style.display = nonCyclicCount > 0 ? 'flex' : 'none';
         }

         const reminderButtonElem = document.getElementById('reminder-button');
         if (reminderButtonElem) {
             let countSpanSide = reminderButtonElem.querySelector('.reminder-count');
             if (totalCount > 0) {
                 if (!countSpanSide) {
                     countSpanSide = document.createElement('span');
                     countSpanSide.className = 'reminder-count';
                     reminderButtonElem.appendChild(countSpanSide);
                 }
                 countSpanSide.textContent = totalCount;
             } else {
                 if (countSpanSide) {
                     countSpanSide.remove();
                 }
             }
         }
     }

     function calculateNextOccurrence(reminder, referenceDate) {
          if (!reminder || !reminder.type || !reminder.time || !reminder.date) {
              return null;
          }
          try {
              let [year, month, day] = reminder.date.split('-').map(Number);
              let [hour, minute] = reminder.time.split(':').map(Number);
              let baseDate = new Date(Date.UTC(year, month - 1, day, hour, minute));
              if (isNaN(baseDate.getTime())) {
                   return null;
              }

              const refDateUTC = new Date(referenceDate.getTime());

               if (baseDate > refDateUTC) return baseDate;

              if (reminder.type === 'simple') {
                   return null;
              }
              if (reminder.type === 'daily' || reminder.type === 'hourly') {
                  let next = new Date(baseDate);
                  while (next <= refDateUTC) {
                       next.setUTCDate(next.getUTCDate() + 1);
                  }
                  return next;
              }
              if (reminder.type === 'weekly' && reminder.repeatDays && reminder.repeatDays.length > 0) {
                  let next = new Date(refDateUTC);
                  next.setUTCHours(hour, minute, 0, 0);

                  if (next <= refDateUTC || !reminder.repeatDays.includes(next.getUTCDay())) {
                       next.setUTCDate(next.getUTCDate() + 1);
                  }
                  for (let i = 0; i < 7; i++) {
                      if (reminder.repeatDays.includes(next.getUTCDay())) {
                          return next;
                      }
                      next.setUTCDate(next.getUTCDate() + 1);
                  }
                  return null;
              }
              if (reminder.type === 'interval' && reminder.intervalDays && reminder.intervalDays > 0) {
                  let next = new Date(baseDate);
                  while (next <= refDateUTC) {
                      next.setUTCDate(next.getUTCDate() + reminder.intervalDays);
                  }
                  return next;
              }
              return null;
          } catch (e) {
              return null;
          }
     }
     function calculatePostponedDateTime(mins) {
          const now = new Date();
          const postponedDate = new Date(now.getTime() + mins * 60000);
          const newDateISO = `${postponedDate.getFullYear()}-${(postponedDate.getMonth() + 1).toString().padStart(2, '0')}-${postponedDate.getDate().toString().padStart(2, '0')}`;
          const newTime = `${postponedDate.getHours().toString().padStart(2, '0')}:${postponedDate.getMinutes().toString().padStart(2, '0')}`;
          return { newDateISO, newTime };
     }

     function showPostponeOptionsModal(reminder, source = 'unified') {
         const existingModal = document.getElementById('postpone-options-modal');
         if (existingModal) {
             if (existingModal.autoPostponeInterval) clearInterval(existingModal.autoPostponeInterval);
             if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal);
         }

         const modal = document.createElement('div');
         modal.id = 'postpone-options-modal';
         modal.className = 'postpone-options';
         modal.style.cssText = `position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); width:90%; max-width:480px; max-height:85vh; overflow-y:auto; background-color:#F5E1A9; padding:1.5rem; border-radius:1rem; box-shadow:0 10px 25px rgba(0,0,0,0.2); z-index:7500; `;
         modal.setAttribute('aria-label', 'Posponer recordatorio');

         let countdown = 10;
         const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval';
         const defaultMinutes = 15;

         let buttonHtml = `
             <button data-minutes="15" class="postpone-option">15 Minutos</button>
             <button data-minutes="60" class="postpone-option">1 Hora</button>
             <button data-minutes="180" class="postpone-option">3 Horas</button>
         `;
         if (!isCyclic) {
             buttonHtml += `
                 <button data-minutes="1440" class="postpone-option">1 Día</button>
                 <button data-minutes="4320" class="postpone-option">3 Días</button>
             `;
         }

         modal.innerHTML = `
             <style>
                 .postpone-options .reminder-text { color:#333; font-size:1.2rem; margin-bottom:.5rem; word-wrap:break-word; }
                 .postpone-options .reminder-details { color:#555; font-size:1rem; margin-bottom:1.5rem; }
                 .postpone-options .button-group { display:flex; flex-direction:column; gap:1rem; align-items:stretch; }
                 .postpone-options button.postpone-option { font-size:1.3rem; font-weight:bold; padding:.8rem 1rem; background-color:#F59E0B; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                 .postpone-options button.postpone-option:hover { background-color:#D97706; }
                 #postpone-countdown { text-align:center; margin-top:1.8rem; font-size:1.1rem; font-weight:500; color:#444; }
                 #postpone-timer-value { font-weight:bold; font-size:1.2rem; }
                 #cancel-postpone { margin-top:1.2rem; width:100%; padding:.7rem 1rem; font-size:1.1rem; background-color:#EF4444; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                 #cancel-postpone:hover { background-color:#DC2626; }
             </style>
             <p class="reminder-text">Posponer: ${reminder.text.replace(/<[^>]*>/g, '')}</p>
             <p class="reminder-details">Selecciona tiempo:</p>
             <div class="button-group">
                 ${buttonHtml}
             </div>
             <p id="postpone-countdown">Automático en <span id="postpone-timer-value">${countdown}</span>s (${defaultMinutes} min)</p>
             <button id="cancel-postpone">Cancelar</button>
         `;
         document.body.appendChild(modal);

         const countdownDisplay = modal.querySelector('#postpone-timer-value');

         const handlePostpone = (minutes) => {
             if (modal.autoPostponeInterval) clearInterval(modal.autoPostponeInterval);
             modal.autoPostponeInterval = null;

             updateUnifiedWindowUI(reminder.id);

             let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
             const index = reminders.findIndex(r => r.id === reminder.id);

             if (index === -1) {
                 showToast("Error: Recordatorio no encontrado.", "error");
                 checkReminders();
                 if (modal.parentNode) document.body.removeChild(modal);
                 return;
             }

             const { newDateISO, newTime } = calculatePostponedDateTime(minutes);
             reminders[index].date = newDateISO;
             reminders[index].time = newTime;
             reminders[index].managedByUser = false;

             if (!isCyclic) {
                  reminders[index].type = 'daily';
                  reminders[index].repeatDays = [];
                  reminders[index].intervalDays = null;
             }

             localStorage.setItem('reminders', JSON.stringify(reminders));
             updateReminderCount();
             updateButtonStyles();

             const durationText = minutes >= 1440 ? `${minutes / 1440} día(s)` : (minutes >= 60 ? `${minutes / 60} hora(s)` : `${minutes} minutos`);
             showToast(`Pospuesto ${durationText}`, 'info');

             if (modal.parentNode) document.body.removeChild(modal);
             if (source === 'table') {
                 setTimeout(showAllReminders, 100);
             } else {
                 const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                 if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
                     sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
                     if (!document.getElementById('reminders-location-map-modal')) {
                          showAllRemindersLocationMap();
                     }
                 }
             }
         };

         modal.autoPostponeInterval = setInterval(() => {
             countdown--;
             if (countdownDisplay) countdownDisplay.textContent = countdown;
             if (countdown <= 0) {
                 handlePostpone(defaultMinutes);
             }
         }, 1000);

         modal.querySelectorAll('.postpone-option').forEach(button => {
             button.addEventListener('click', () => {
                 const minutes = parseInt(button.dataset.minutes);
                 if (!isNaN(minutes)) {
                     handlePostpone(minutes);
                 }
             });
         });

         modal.querySelector('#cancel-postpone').addEventListener('click', () => {
             clearInterval(modal.autoPostponeInterval);
             modal.autoPostponeInterval = null;
             markReminderAsManaged(reminder.id, false);
             if (modal.parentNode) document.body.removeChild(modal);
             if (source === 'table') {
                 setTimeout(showAllReminders, 100);
             } else {
                 const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                 if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
                      sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
                      if (!document.getElementById('reminders-location-map-modal')) {
                           showAllRemindersLocationMap();
                      }
                 }
             }
             showToast('Posposición cancelada', 'info');
         });
     }

    function showYellowBorder() {
        const borderDiv = document.createElement('div');
        borderDiv.style.position = 'fixed';
        borderDiv.style.top = '0';
        borderDiv.style.left = '0';
        borderDiv.style.width = '100vw';
        borderDiv.style.height = '100vh';
        borderDiv.style.boxSizing = 'border-box';
        borderDiv.style.border = '25px solid #FFFF00';
        borderDiv.style.zIndex = '99999';
        borderDiv.style.pointerEvents = 'none';
        borderDiv.style.opacity = '1';
        borderDiv.style.transition = 'opacity 0.5s ease-out';
        document.body.appendChild(borderDiv);

        setTimeout(() => {
            borderDiv.style.opacity = '0';
            setTimeout(() => {
                if (borderDiv.parentNode) {
                    borderDiv.parentNode.removeChild(borderDiv);
                }
            }, 500);
        }, 3500);
    }


    function checkReminders() {
        let currentReminders = [];
        try {
            currentReminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        } catch (e) {
            localStorage.setItem('reminders_backup_error', localStorage.getItem('reminders') || '[]');
            localStorage.removeItem('reminders');
            showToast("Error al cargar recordatorios. Backup intentado.", "error", 5000);
            return;
        }

        const now = new Date();
        let overdueReminders = [];
        const validRemindersForStorage = [];
        let storageNeedsUpdate = false;
        const processedIds = new Set();
        let newOverdueFound = false;
        let isAnyReminderNearby = false;

        let currentLocationPromise = null;
        const needsLocationCheckForReminders = currentReminders.some(r => r.isLocationEnabled && !r.managedByUser);

        if (needsLocationCheckForReminders) {
            currentLocationPromise = new Promise((resolve) => {
                getCurrentLocation(
                    (coords) => resolve(coords),
                    (errorMsg) => {
                        resolve(null);
                    }
                );
            });
        } else {
            currentLocationPromise = Promise.resolve(null);
        }

        currentLocationPromise.then(currentCoords => {
            currentReminders.forEach(reminder => {
                if (!reminder || typeof reminder.id !== 'number' || typeof reminder.managedByUser === 'undefined' || !reminder.type || !reminder.time || !reminder.date || !reminder.createdAt) {
                    storageNeedsUpdate = true;
                    return;
                }
                if (processedIds.has(reminder.id)) {
                     storageNeedsUpdate = true;
                     return;
                }
                processedIds.add(reminder.id);

                const isManagedByUser = reminder.managedByUser === true;
                let keepInStorage = true;
                let isOverdue = false;
                let locationConditionMet = true;

                if (!isManagedByUser) {
                    let reminderLocalDueTime = null;
                    try {
                        const [year, month, day] = reminder.date.split('-').map(Number);
                        const [hour, minute] = reminder.time.split(':').map(Number);
                        reminderLocalDueTime = new Date(year, month - 1, day, hour, minute);

                        if (isNaN(reminderLocalDueTime.getTime())) {
                            throw new Error("Invalid date/time components");
                        }

                        if (reminderLocalDueTime <= now) {
                            isOverdue = true;
                            if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                                if (currentCoords) {
                                    const distance = calculateDistance(
                                        currentCoords.latitude, currentCoords.longitude,
                                        reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude
                                    );
                                    locationConditionMet = distance <= (reminder.radiusMeters || 1000);
                                    if (locationConditionMet && distance < 1500) {
                                        isAnyReminderNearby = true;
                                    }
                                } else {
                                    locationConditionMet = false;
                                }
                            }
                        } else if (reminder.isLocationEnabled && reminder.locationCoordinates && currentCoords) {
                            const distance = calculateDistance(
                                currentCoords.latitude, currentCoords.longitude,
                                reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude
                            );
                            if (distance < 1500) {
                                isAnyReminderNearby = true;
                            }
                        }


                    } catch (error) {
                        storageNeedsUpdate = true;
                        keepInStorage = false;
                        isOverdue = false;
                        locationConditionMet = false;
                    }
                }

                if (isOverdue && locationConditionMet) {
                    overdueReminders.push(reminder);
                     if (!isUnifiedWindowVisibleByLogic || !document.querySelector(`#unified-reminder-window .reminder-slide[data-id="${reminder.id}"]`)) {
                         newOverdueFound = true;
                     }
                }

                if (keepInStorage) {
                    validRemindersForStorage.push(reminder);
                }
            });

            if (storageNeedsUpdate) {
                try {
                    const oldStorageString = localStorage.getItem('reminders') || '[]';
                    const newStorageString = JSON.stringify(validRemindersForStorage);
                    if (oldStorageString !== newStorageString) {
                        localStorage.setItem('reminders', newStorageString);
                    }
                } catch (e) {
                    showToast("Error al actualizar recordatorios tras limpieza.", "error", 5000);
                }
            }

            if (overdueReminders.length > 0) {
                if (!isUnifiedWindowVisibleByLogic || newOverdueFound) {
                    currentNotificationSlideIndex = 0;
                    if (newOverdueFound) showYellowBorder();
                }
                 displayUnifiedReminderWindow(overdueReminders);
            }
            else {
                 hideUnifiedReminderWindow();
                 currentNotificationSlideIndex = 0;
            }

            updateReminderCount();
            updateButtonStyles();

            const newInterval = isAnyReminderNearby ? 2000 : 60000;
            if (newInterval !== currentCheckIntervalDuration) {
                currentCheckIntervalDuration = newInterval;
                if (reminderCheckIntervalId) {
                    clearInterval(reminderCheckIntervalId);
                }
                reminderCheckIntervalId = setInterval(checkReminders, currentCheckIntervalDuration);
            }


            const swiperContainer = document.getElementById('reminder-swiper-container');
            const windowElement = document.getElementById('unified-reminder-window');

            if (swiperContainer && overdueReminders.length > 0 && windowElement.classList.contains('visible')) {
                const totalSlides = overdueReminders.length;
                let nextSlideIndex = currentNotificationSlideIndex;

                if (totalSlides > 1) {
                    nextSlideIndex = (currentNotificationSlideIndex + 1) % totalSlides;
                } else {
                    nextSlideIndex = 0;
                }
                if (totalSlides === 1 || nextSlideIndex !== currentNotificationSlideIndex) {
                    currentNotificationSlideIndex = nextSlideIndex;
                    const targetScrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
                    swiperContainer.scrollTo({ left: targetScrollLeft, behavior: 'smooth' });
                    setTimeout(updateReminderIndexDisplay, 400);
                }
            }
        });
    }


    function getSavedLocations() {
        try {
            const locations = localStorage.getItem(SAVED_LOCATIONS_KEY);
            return locations ? JSON.parse(locations) : Array(MAX_SAVED_LOCATIONS).fill(null);
        } catch (e) {
            return Array(MAX_SAVED_LOCATIONS).fill(null);
        }
    }

    function saveLocationsToCache(locationsArray) {
        try {
            localStorage.setItem(SAVED_LOCATIONS_KEY, JSON.stringify(locationsArray));
        } catch (e) {
            showToast("Error al guardar ubicaciones.", "error");
        }
    }

    function showSavedLocationsModal(callbackOnClose, callbackOnSelectLocation) {
        const existingModal = document.querySelector('.saved-locations-modal');
        if (existingModal) {
            if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
            clearModalAutoCloseTimer(existingModal, existingModal.querySelector('#close-saved-locations-modal'), 'saved-locations-modal');
            existingModal.remove();
        }

        tempSavedLocations = getSavedLocations().map(loc => loc ? {...loc} : null);

        const modal = document.createElement('div');
        modal.className = 'saved-locations-modal';
        modal.innerHTML = `
            <h2>Gestionar Ubicaciones Guardadas (Máx. ${MAX_SAVED_LOCATIONS})</h2>
            <div id="saved-locations-list">
            </div>
            <div id="location-picker-map-container">
                <button id="picker-ok-map-button" title="Confirmar esta posición">OK</button>
                <button id="picker-locate-me-button" title="Ir a mi posición actual">Mi Ubic.</button>
            </div>
            <div class="button-group">
                <button id="save-all-user-locations">Guardar Cambios</button>
                <button id="close-saved-locations-modal">Cerrar</button>
            </div>
        `;
        document.body.appendChild(modal);

        const listElement = modal.querySelector('#saved-locations-list');
        const mapPickerContainer = modal.querySelector('#location-picker-map-container');
        const okMapBtn = modal.querySelector('#picker-ok-map-button');
        const locateMeMapBtn = modal.querySelector('#picker-locate-me-button');
        const saveAllButton = modal.querySelector('#save-all-user-locations');
        const closeButton = modal.querySelector('#close-saved-locations-modal');


        function loadAndDisplaySlots() {
            listElement.innerHTML = '';
            for (let i = 0; i < MAX_SAVED_LOCATIONS; i++) {
                const location = tempSavedLocations[i];
                const slotDiv = document.createElement('div');
                slotDiv.className = 'location-slot';
                slotDiv.innerHTML = `
                    <span style="width: 25px; text-align: right; font-weight: bold;">${i + 1}.</span>
                    <input type="text" placeholder="Nombre Ubicación" value="${location?.name || ''}" data-index="${i}">
                    <button class="map-button" data-index="${i}" title="Fijar en Mapa">📍 Mapa</button>
                    <button class="select-location-button" data-index="${i}" title="Seleccionar esta ubicación para el recordatorio actual">Seleccionar</button>
                    <span class="coords-display">${location?.lat && location?.lng ? `${parseFloat(location.lat).toFixed(4)}, ${parseFloat(location.lng).toFixed(4)}` : 'No fijada'}</span>
                `;
                listElement.appendChild(slotDiv);

                slotDiv.querySelector('input[type="text"]').addEventListener('input', (e) => {
                    if (!tempSavedLocations[i]) tempSavedLocations[i] = { name: '', lat: null, lng: null, radius: 1000 };
                    tempSavedLocations[i].name = e.target.value;
                });

                slotDiv.querySelector('.map-button').addEventListener('click', () => {
                    currentEditingLocationSlotIndex = i;
                    mapPickerContainer.classList.add('expanded');
                    initializeLocationPickerMap('location-picker-map-container', i);
                    const currentSlotLocation = tempSavedLocations[i];
                    const initialCoords = currentSlotLocation?.lat && currentSlotLocation?.lng
                        ? { latitude: currentSlotLocation.lat, longitude: currentSlotLocation.lng }
                        : null;

                    if (locationPickerMap && initialCoords) {
                        locationPickerMap.setView([initialCoords.latitude, initialCoords.longitude], 15);
                        if (locationPickerMarker) locationPickerMarker.setLatLng([initialCoords.latitude, initialCoords.longitude]);
                    } else if (locationPickerMap) {
                         getCurrentLocation(
                            (coords) => {
                                locationPickerMap.setView([coords.latitude, coords.longitude], 15);
                                if(locationPickerMarker) locationPickerMarker.setLatLng([coords.latitude, coords.longitude]);
                                else {
                                    locationPickerMarker = L.marker([coords.latitude, coords.longitude], {draggable: true}).addTo(locationPickerMap);
                                    locationPickerMarker.on('dragend', (event) => {
                                        const pos = event.target.getLatLng();
                                        if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
                                        tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat;
                                        tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng;
                                    });
                                }
                            },
                            () => { }
                        );
                    }
                });

                const selectButton = slotDiv.querySelector('.select-location-button');
                selectButton.addEventListener('click', () => {
                    const selectedIndex = parseInt(selectButton.dataset.index);
                    const selectedLocData = tempSavedLocations[selectedIndex];
                    if (selectedLocData && selectedLocData.lat && selectedLocData.lng) {
                        if (callbackOnSelectLocation && typeof callbackOnSelectLocation === 'function') {
                            callbackOnSelectLocation({
                                name: selectedLocData.name,
                                lat: selectedLocData.lat,
                                lng: selectedLocData.lng,
                                radius: selectedLocData.radius || 1000
                            });
                        }
                        if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
                        clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
                        modal.remove();
                    } else {
                        showToast("Ubicación no fijada. Fíjala en el mapa primero.", "warning");
                    }
                });
            }
        }
        loadAndDisplaySlots();

        okMapBtn.addEventListener('click', () => {
            if (locationPickerMarker && currentEditingLocationSlotIndex !== -1) {
                const pos = locationPickerMarker.getLatLng();
                if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
                tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat;
                tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng;

                const slotInput = listElement.querySelector(`.location-slot input[data-index="${currentEditingLocationSlotIndex}"]`);
                if (slotInput) {
                    const coordsDisplay = slotInput.closest('.location-slot').querySelector('.coords-display');
                    if (coordsDisplay) {
                        coordsDisplay.textContent = `${pos.lat.toFixed(4)}, ${pos.lng.toFixed(4)}`;
                    }
                }
            }
            mapPickerContainer.classList.remove('expanded');
            if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
            currentEditingLocationSlotIndex = -1;
        });

        locateMeMapBtn.addEventListener('click', () => {
            if (locationPickerMap) {
                locateMeMapBtn.disabled = true; locateMeMapBtn.textContent = 'Buscando...';
                getCurrentLocation(
                    (coords) => {
                        locationPickerMap.setView([coords.latitude, coords.longitude], 16);
                        if (locationPickerMarker) locationPickerMarker.setLatLng([coords.latitude, coords.longitude]);
                        if (currentEditingLocationSlotIndex !== -1) {
                           if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
                            tempSavedLocations[currentEditingLocationSlotIndex].lat = coords.latitude;
                            tempSavedLocations[currentEditingLocationSlotIndex].lng = coords.longitude;
                        }
                        locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.';
                    },
                    (errorMsg) => {
                        showToast(`Error localización: ${errorMsg}`, 'error');
                        locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.';
                    }
                );
            }
        });


        saveAllButton.addEventListener('click', () => {
            const locationsToSave = tempSavedLocations.map(loc => {
                if (loc && (!loc.name || loc.name.trim() === '') && (loc.lat === null || loc.lng === null)) {
                    return null;
                }
                if (loc && (loc.lat !== null && loc.lng !== null) && typeof loc.radius !== 'number') {
                    loc.radius = 1000;
                }
                return loc;
            });
            saveLocationsToCache(locationsToSave);
            showToast("Ubicaciones guardadas.", "success");
            if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose();
            if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
            clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
            modal.remove();
        });

        const closeHandler = () => {
            clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
            if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
            if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose();
            modal.remove();
        };
        closeButton.addEventListener('click', closeHandler);
        addModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
    }

    function initializeLocationPickerMap(mapContainerId, slotIndex) {
        if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }

        const mapDiv = document.createElement('div');
        mapDiv.style.width = '100%'; mapDiv.style.height = '100%';
        const container = document.getElementById(mapContainerId);
        while (container.firstChild && container.firstChild.id !== 'picker-ok-map-button' && container.firstChild.id !== 'picker-locate-me-button') {
             container.removeChild(container.firstChild);
        }
        container.insertBefore(mapDiv, container.firstChild);


        const initialLocation = tempSavedLocations[slotIndex] || {};
        const centerLat = initialLocation.lat || 40.416775;
        const centerLng = initialLocation.lng || -3.703790;
        const initialZoom = (initialLocation.lat && initialLocation.lng) ? 15 : 6;

        locationPickerMap = L.map(mapDiv, { zoomControl: true }).setView([centerLat, centerLng], initialZoom);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        }).addTo(locationPickerMap);

        locationPickerMarker = L.marker([centerLat, centerLng], { draggable: true }).addTo(locationPickerMap);
        locationPickerMarker.on('dragend', (event) => {
            const pos = event.target.getLatLng();
            if (!tempSavedLocations[slotIndex]) tempSavedLocations[slotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
            tempSavedLocations[slotIndex].lat = pos.lat;
            tempSavedLocations[slotIndex].lng = pos.lng;
        });

        locationPickerMap.on('click', (e) => handlePickerMapClick(e, slotIndex));
        setTimeout(() => locationPickerMap.invalidateSize(), 100);
    }

    function handlePickerMapClick(e, slotIndex) {
        const latlng = e.latlng;
        if (locationPickerMarker) {
            locationPickerMarker.setLatLng(latlng);
        }
        if (!tempSavedLocations[slotIndex]) tempSavedLocations[slotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
        tempSavedLocations[slotIndex].lat = latlng.lat;
        tempSavedLocations[slotIndex].lng = latlng.lng;
    }


L.Control.OrientationAltitude = L.Control.extend({
    onAdd: function(map) {
        const container = L.DomUtil.create('div', 'leaflet-control-orientation-altitude leaflet-bar');
        L.DomUtil.addClass(container, 'leaflet-control');
        container.style.backgroundColor = 'transparent';
        container.style.boxShadow = 'none';
        container.style.border = 'none';
        container.style.padding = '0';
        container.style.margin = '0';


        const compassContainer = L.DomUtil.create('div', '', container);
        compassContainer.style.backgroundColor = 'rgba(255, 255, 255, 0.65)';
        compassContainer.style.padding =  'calc(4px * 0.85) calc(6px * 0.85)';
        compassContainer.style.borderRadius = '3px';
        compassContainer.style.boxShadow = '0 1px 4px rgba(0,0,0,0.3)';
        compassContainer.style.textAlign = 'center';

        compassContainer.innerHTML = `
            <img id="compass-rose-icon" src="ROSA.PNG" alt="Orientación" style="width: calc(70px * 0.85); height: calc(70px * 0.85); display: block; margin: 0 auto 1px auto; transition: transform 0.3s ease-out;">
            <span id="orientation-text" style="display: block; font-size: calc(1.5em * 0.85); color: #333; line-height: 1.1; margin-bottom: 1px;">---</span>
            <span id="altitude-display" style="display: block; font-size: calc(1.5em * 0.85); color: #333; line-height: 1.1;">--- m</span>
        `;

        L.DomEvent.disableClickPropagation(container);
        return container;
    },
    updateOrientation: function(heading) {
        const compassRoseIcon = document.getElementById('compass-rose-icon');
        const orientationText = document.getElementById('orientation-text');
        if (compassRoseIcon && orientationText) {
            if (heading !== null && !isNaN(heading) && heading >= 0 && heading <= 360) {
                compassRoseIcon.style.transform = `rotate(${heading}deg)`;
                const directions = ["N", "NE", "E", "SE", "S", "SO", "O", "NO", "N"];
                const index = Math.round(heading / 45) % 8;
                orientationText.textContent = `${directions[index]}`;
            } else {
                compassRoseIcon.style.transform = 'rotate(0deg)';
                orientationText.textContent = '---';
            }
        }
    },
    updateAltitude: function(altitude) {
        const altitudeDisplay = document.getElementById('altitude-display');
        if (altitudeDisplay) {
            if (altitude !== null && !isNaN(altitude)) {
                altitudeDisplay.textContent = `${altitude.toFixed(0)} m`;
            } else {
                altitudeDisplay.textContent = '--- m';
            }
        }
    }
});
L.control.orientationAltitude = function(opts) {
    return new L.Control.OrientationAltitude(opts);
}


function showAllRemindersLocationMap() {
    isRemindersLocationMapActive = true;

    let currentRoutingMode = 'none';
    let currentRouteWaypointsLatLng = [];
    let routePreviewControl = null;
    let navigationRoutingControl = null;
    let userMarkerForRoute = null;
    let routeLineForProgress = null;
    let totalRouteDistance = 0;
    let simpleWaypointMarkers = [];
    let waypointPressTimer = null;
    let startRouteMarkerVisual = null;


    const SAVED_ROUTES_KEY = 'boardinggate_saved_routes';

    let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    let remindersWithLocation = reminders.filter(r => r.isLocationEnabled && r.locationCoordinates?.latitude && r.locationCoordinates?.longitude);

    const existingModal = document.getElementById('reminders-location-map-modal');
    if (existingModal) {
        existingModal.remove();
    }

    if (allLocationsMapInstance) {
        if (initialUserLocationMarker) { initialUserLocationMarker.remove(); initialUserLocationMarker = null; }
        if (initialUserLocationCircle) { initialUserLocationCircle.remove(); initialUserLocationCircle = null; }
        if (orientationAltitudeControl && allLocationsMapInstance && typeof allLocationsMapInstance.hasControl === 'function' && allLocationsMapInstance.hasControl(orientationAltitudeControl)) {
            allLocationsMapInstance.removeControl(orientationAltitudeControl);
        }
        orientationAltitudeControl = null;
        try { allLocationsMapInstance.remove(); } catch (e) { console.warn("Error removing previous allLocationsMapInstance:", e); }
        allLocationsMapInstance = null;
    }
    if (locationWatchId !== null) {
        navigator.geolocation.clearWatch(locationWatchId);
        locationWatchId = null;
    }
    shouldCenterOnUserInAllLocationsMap = false;


    const mapModal = document.createElement('div');
    mapModal.id = 'reminders-location-map-modal';
    mapModal.innerHTML = `
        <div id="reminders-location-map-content-wrapper">
            <div id="reminders-location-map-header">
                <div id="route-actions-group" class="button-group-route">
                    <button id="create-route-button" class="route-button-action" title="Crear o Iniciar/Detener Ruta">CREAR RUTA</button>
                    <button id="save-route-button" class="route-button-action" title="Guardar Ruta Actual" style="display:none;">GUARDAR RUTA</button>
                    <button id="load-route-button" class="route-button-action" title="Cargar Ruta Guardada">CARGAR RUTA</button>
                </div>
                <h2 style="display:none;"></h2>
                 <div style="display: flex; align-items: center; margin-left: auto; margin-right:10px; white-space: nowrap;">
                    <input type="checkbox" id="toggle-radar-visibility-map" checked style="transform: scale(1.2); margin-right: 5px;">
                    <label for="toggle-radar-visibility-map" style="font-size: 0.9rem; font-weight: normal; color: #555;">Ver Radares</label>
                </div>
                <div class="button-group-main">
                    <button id="close-reminders-location-map" class="reminders-map-button-action" title="Cerrar mapa">SALIR</button>
                    <button id="locate-me-on-reminders-map" class="reminders-map-button-action" title="Mostrar mi posición actual y activar seguimiento">ESTÁS AQUÍ</button>
                    <button id="add-radar-here" class="reminders-map-button-action" title="Crear RADAR en mi posición actual (radio 1000m)">AQUÍ HAY UN RADAR</button>
                    <button id="reminders-map-help-button" class="reminders-map-button-action" title="Ayuda del mapa">AYUDA</button>
                </div>
            </div>
            <div id="reminders-location-map-div">

                <div id="progress-bar-container">
                    <div id="progress-bar-fill">
                         <span id="progress-bar-text-overlay"></span>
                    </div>
                </div>
                 <div id="routing-info-panel" style="display:none;"></div>
                 <div id="current-maneuver-panel" style="display: none;">
                    <div class="maneuver-icon"></div>
                    <div class="maneuver-text-container">
                        <div class="maneuver-instruction"></div>
                        <div class="maneuver-distance"></div>
                        <div class="next-maneuver"></div>
                    </div>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(mapModal);

    const mapContainer = document.getElementById('reminders-location-map-div');
    const closeButton = document.getElementById('close-reminders-location-map');
    const locateMeButtonMap = document.getElementById('locate-me-on-reminders-map');
    const helpButton = document.getElementById('reminders-map-help-button');
    const addRadarButton = document.getElementById('add-radar-here');
    const toggleRadarVisibilityCheckbox = document.getElementById('toggle-radar-visibility-map');


    const createRouteButton = document.getElementById('create-route-button');
    const saveRouteButton = document.getElementById('save-route-button');
    const loadRouteButton = document.getElementById('load-route-button');
    const routingInfoPanel = document.getElementById('routing-info-panel');
    const currentManeuverPanel = document.getElementById('current-maneuver-panel');
    const progressBarContainer = document.getElementById('progress-bar-container');
    const progressBarFill = document.getElementById('progress-bar-fill');
    const progressBarTextOverlay = document.getElementById('progress-bar-text-overlay');

    let allMapMarkers = []; // Contendrá objetos: { marker, circle, reminderData }

    // --- Definición de plotReminders movida aquí ---
    const plotReminders = (showOnlyRadarsWhenNotNavigating = false) => {
        allMapMarkers.forEach(item => {
            if (item.marker && allLocationsMapInstance && allLocationsMapInstance.hasLayer(item.marker)) item.marker.remove();
            if (item.circle && allLocationsMapInstance && allLocationsMapInstance.hasLayer(item.circle)) item.circle.remove();
        });
        allMapMarkers = [];

        let remindersToPlot = remindersWithLocation;
        if (showOnlyRadarsWhenNotNavigating) { // Si true, mostrar SOLO los "radars"
            remindersToPlot = remindersWithLocation.filter(r => r.text.toUpperCase().includes("RADAR:") || r.excludeFromList);
        } else { // Si false, mostrar todos los demás (NO radares)
            remindersToPlot = remindersWithLocation.filter(r => !r.text.toUpperCase().includes("RADAR:") && !r.excludeFromList);
        }


        remindersToPlot.forEach(reminder => {
            const latLng = [reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude];
            const isRadarType = reminder.text.toUpperCase().includes("RADAR:") || reminder.excludeFromList;
            const markerIconToUse = isRadarType ? radarMarkerIcon : defaultLocationMarkerIconBlue;
            const circleColor = isRadarType ? '#800080' : 'blue';
            const circleFillColor = isRadarType ? '#DA70D6' : '#ADD8E6';
            const circleFillOpacity = isRadarType ? 0.1 : 0.05;

            const marker = L.marker(latLng, {
                icon: markerIconToUse,
                title: reminder.text.replace(/<[^>]*>/g, '').substring(0, 50)
            }).addTo(allLocationsMapInstance);

            const circle = L.circle(latLng, {
                radius: reminder.radiusMeters || 1000,
                color: circleColor,
                fillColor: circleFillColor,
                weight: 1,
                fillOpacity: circleFillOpacity
            }).addTo(allLocationsMapInstance);

            allMapMarkers.push({marker, circle, reminderData: reminder});


            let popupContent = `
                <div style="max-width: 250px; font-family: sans-serif; font-size: 0.9rem;">
                    <strong style="font-size: 1rem; color: #333; display: block; margin-bottom: 5px;">${reminder.text.replace(/<b>|<\/b>/gi,'')}</strong>
                    <hr style="margin: 4px 0;">
                    ${reminder.time ? `<p style="margin: 3px 0;"><strong>Hora:</strong> ${formatTimeWithPeriod(reminder.time)}</p>` : ''}
                    ${reminder.date ? `<p style="margin: 3px 0;"><strong>Fecha:</strong> ${formatDateDetailed(reminder.date)}</p>` : ''}
                    ${reminder.type === 'weekly' && reminder.repeatDays?.length > 0 ? `<p style="margin: 3px 0;"><strong>Repite:</strong> ${reminder.repeatDays.map(d => ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'][d]).join(', ')}</p>` : ''}
                    ${reminder.type === 'interval' && reminder.intervalDays ? `<p style="margin: 3px 0;"><strong>Cada:</strong> ${reminder.intervalDays} días</p>` : ''}
                    <p style="margin: 3px 0;"><strong>Radio:</strong> ${reminder.radiusMeters || 1000}m</p>
                    <button data-reminder-id="${reminder.id}" class="modify-reminder-from-map" style="margin-top: 8px; padding: 4px 8px; font-size: 0.8rem; background-color: #10B981; color: white; border: none; border-radius: 3px; cursor: pointer;">Modificar</button>
                </div>`;
            marker.bindPopup(popupContent);

            marker.on('popupopen', () => {
                const modifyButton = marker.getPopup().getElement().querySelector('.modify-reminder-from-map');
                if (modifyButton) {
                    const newModifyButton = modifyButton.cloneNode(true);
                    modifyButton.parentNode.replaceChild(newModifyButton, modifyButton);
                    newModifyButton.addEventListener('click', (e) => {
                        const id = parseInt(e.target.dataset.reminderId);
                        if (!isNaN(id)) {
                            const rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                            const remToMod = rems.find(r => r.id === id);
                            if (remToMod) {
                                closeHandlerAllMap();
                                showReminderModal(remToMod);
                            } else { showToast("Error: No se encontró el recordatorio para modificar.", "error"); }
                        }
                    });
                }
            });
        });
    };
    // --- Fin definición de plotReminders ---

    // --- Definición de filterMarkersNearRoute movida aquí ---
    function filterMarkersNearRoute() {
        if (!navigationRoutingControl || !navigationRoutingControl._selectedRoute) {
            plotReminders(!toggleRadarVisibilityCheckbox.checked);
            return;
        }
        const routeLine = navigationRoutingControl._selectedRoute.coordinates;
        if (!routeLine || routeLine.length === 0) {
            plotReminders(!toggleRadarVisibilityCheckbox.checked);
            return;
        }

        allMapMarkers.forEach(item => {
            if (item.marker && allLocationsMapInstance.hasLayer(item.marker)) item.marker.remove();
            if (item.circle && allLocationsMapInstance.hasLayer(item.circle)) item.circle.remove();
        });
        allMapMarkers = [];

        const proximity = 1500;
        remindersWithLocation.forEach(reminder => {
            if (!toggleRadarVisibilityCheckbox.checked && (reminder.text.toUpperCase().includes("RADAR:") || reminder.excludeFromList)) {
                return;
            }
            const reminderLatLng = L.latLng(reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude);
            let isNear = false;

            if (L.GeometryUtil.isVersion07x()) { // Leaflet-geometryutil < 0.8
                for (let i = 0; i < routeLine.length - 1; i++) {
                    if (L.GeometryUtil.distanceSegment(allLocationsMapInstance, reminderLatLng, routeLine[i], routeLine[i+1]) < proximity) {
                        isNear = true;
                        break;
                    }
                }
            } else { // Leaflet-geometryutil >= 0.8
                 isNear = L.GeometryUtil.isNear(allLocationsMapInstance, routeLine, reminderLatLng, proximity);
            }

            const isRadarType = reminder.text.toUpperCase().includes("RADAR:") || reminder.excludeFromList;
            const markerIconToUse = isRadarType ? radarMarkerIcon : defaultLocationMarkerIconBlue;
            const circleColor = isRadarType ? '#800080' : 'blue';
            const circleFillColor = isRadarType ? '#DA70D6' : '#ADD8E6';
            let circleFillOpacity = isRadarType ? 0.1 : 0.05;
            let markerOpacity = 1.0;
            let circleBorderOpacity = 1.0;

            if (!isNear) {
                markerOpacity = 0.15;
                circleFillOpacity = 0.02;
                circleBorderOpacity = 0.1;
            }

            const marker = L.marker([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude], {
                icon: markerIconToUse,
                title: reminder.text.replace(/<[^>]*>/g, '').substring(0, 50),
                opacity: markerOpacity
            }).addTo(allLocationsMapInstance);

            const circle = L.circle([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude], {
                radius: reminder.radiusMeters || 1000,
                color: circleColor,
                fillColor: circleFillColor,
                weight: 1,
                opacity: circleBorderOpacity,
                fillOpacity: circleFillOpacity
            }).addTo(allLocationsMapInstance);

            allMapMarkers.push({marker, circle, reminderData: reminder});

            if (isNear) {
                 let popupContent = `
                    <div style="max-width: 250px; font-family: sans-serif; font-size: 0.9rem;">
                        <strong style="font-size: 1rem; color: #333; display: block; margin-bottom: 5px;">${reminder.text.replace(/<b>|<\/b>/gi,'')}</strong>
                        <hr style="margin: 4px 0;">
                        ${reminder.time ? `<p style="margin: 3px 0;"><strong>Hora:</strong> ${formatTimeWithPeriod(reminder.time)}</p>` : ''}
                        ${reminder.date ? `<p style="margin: 3px 0;"><strong>Fecha:</strong> ${formatDateDetailed(reminder.date)}</p>` : ''}
                        <p style="margin: 3px 0;"><strong>Radio:</strong> ${reminder.radiusMeters || 1000}m</p>
                        <button data-reminder-id="${reminder.id}" class="modify-reminder-from-map" style="margin-top: 8px; padding: 4px 8px; font-size: 0.8rem; background-color: #10B981; color: white; border: none; border-radius: 3px; cursor: pointer;">Modificar</button>
                    </div>`;
                marker.bindPopup(popupContent);
                marker.on('popupopen', () => {
                    const modifyButton = marker.getPopup().getElement().querySelector('.modify-reminder-from-map');
                    if (modifyButton) {
                        const newModifyButton = modifyButton.cloneNode(true);
                        modifyButton.parentNode.replaceChild(newModifyButton, modifyButton);
                        newModifyButton.addEventListener('click', (e) => {
                            const id = parseInt(e.target.dataset.reminderId);
                            if (!isNaN(id)) {
                                const rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                                const remToMod = rems.find(r => r.id === id);
                                if (remToMod) {
                                    closeHandlerAllMap();
                                    showReminderModal(remToMod);
                                } else { showToast("Error: No se encontró el recordatorio para modificar.", "error"); }
                            }
                        });
                    }
                });
            }
        });
    }
    // --- Fin definición de filterMarkersNearRoute ---


    function updateRoutingUI() {
        if (currentRoutingMode === 'creating') {
            createRouteButton.textContent = currentRouteWaypointsLatLng.length >= 1 ? 'INICIAR NAVEGACIÓN' : 'CREAR RUTA';
            saveRouteButton.style.display = currentRouteWaypointsLatLng.length >= 1 ? 'inline-flex' : 'none';

            currentManeuverPanel.style.display = 'none';
            progressBarContainer.style.display = 'none';
            if (navigationRoutingControl && allLocationsMapInstance.hasControl(navigationRoutingControl)) {
                allLocationsMapInstance.removeControl(navigationRoutingControl);
                navigationRoutingControl = null;
            }
            if (routePreviewControl && allLocationsMapInstance.hasControl(routePreviewControl)) {
                 allLocationsMapInstance.removeControl(routePreviewControl);
                 routePreviewControl = null;
            }
             if (currentRouteWaypointsLatLng.length > 0 && initialUserLocationMarkerLat && initialUserLocationMarkerLng) {
                drawRoutePreview();
            } else {
                if(routingInfoPanel) routingInfoPanel.style.display = 'none';
            }
            plotReminders(!toggleRadarVisibilityCheckbox.checked);


        } else if (currentRoutingMode === 'navigating') {
            createRouteButton.textContent = 'DETENER NAVEGACIÓN';
            saveRouteButton.style.display = 'inline-flex';
            routingInfoPanel.style.display = 'flex';
            progressBarContainer.style.display = 'flex';
             if (routePreviewControl && allLocationsMapInstance.hasControl(routePreviewControl)) {
                 allLocationsMapInstance.removeControl(routePreviewControl);
                 routePreviewControl = null;
            }
            filterMarkersNearRoute();
        } else {
            createRouteButton.textContent = 'CREAR RUTA';
            saveRouteButton.style.display = 'none';
            routingInfoPanel.style.display = 'none';
            currentManeuverPanel.style.display = 'none';
            progressBarContainer.style.display = 'none';
            if (navigationRoutingControl && allLocationsMapInstance.hasControl(navigationRoutingControl)) {
                allLocationsMapInstance.removeControl(navigationRoutingControl);
                navigationRoutingControl = null;
            }
            if (routePreviewControl && allLocationsMapInstance.hasControl(routePreviewControl)) {
                 allLocationsMapInstance.removeControl(routePreviewControl);
                 routePreviewControl = null;
            }
            currentRouteWaypointsLatLng = [];
            clearSimpleWaypointMarkers();
            plotReminders(!toggleRadarVisibilityCheckbox.checked);
        }
    }

    function clearSimpleWaypointMarkers() {
        simpleWaypointMarkers.forEach(m => { if(m && allLocationsMapInstance && allLocationsMapInstance.hasLayer(m)) m.remove();});
        simpleWaypointMarkers = [];
        if (startRouteMarkerVisual && allLocationsMapInstance && allLocationsMapInstance.hasLayer(startRouteMarkerVisual)) {
             startRouteMarkerVisual.remove();
             startRouteMarkerVisual = null;
        }
    }

    function createNumberedIcon(numberOrChar, color = 'blue', size = 28) {
        const isCharF = numberOrChar === 'F';
        const fontWeight = isCharF ? 'bold' : 'normal';
        const fontSize = isCharF ? `${size * 0.65}px` : `${size * 0.55}px`;
        const charOffset = isCharF ? `${size * 0.05}px` : '0px';

        return L.divIcon({
            html: `<div style="background-color:${color}; color:white; width:${size}px; height:${size}px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:${fontSize}; font-weight:${fontWeight}; box-shadow: 0 0 3px rgba(0,0,0,0.5); transform: translateY(${charOffset});">${numberOrChar}</div>`,
            className: 'custom-waypoint-div-icon',
            iconSize: [size, size],
            iconAnchor: [size / 2, size / 2]
        });
    }

    function getManeuverTranslation(text) {
        if (!text) return "";
        let esText = text;

        const translations = {
            "Turn left": "Gira a la izquierda",
            "Turn right": "Gira a la derecha",
            "Go straight": "Sigue recto", "Continue straight": "Continúa recto",
            "Keep left": "Mantente a la izquierda",
            "Keep right": "Mantente a la derecha",
            "Make a U-turn": "Haz un cambio de sentido",
            "Enter the roundabout": "Entra en la rotonda",
            "onto": "hacia",
            "Destination will be on the left": "El destino estará a la izquierda",
            "Destination will be on the right": "El destino estará a la derecha",
            "You have arrived at your destination": "Has llegado a tu destino",
            "Arrive at destination": "Llegar al destino",
            "Head": "Dirígete",
            "north": "norte", "south": "sur", "east": "este", "west": "oeste",
            "northeast": "noreste", "northwest": "noroeste",
            "southeast": "sureste", "southwest": "suroeste",
            "Take the ramp": "Toma la rampa",
            "Merge": "Incorpórate",
            "Exit": "Sal",
            "Slight left": "Ligera a la izquierda",
            "Slight right": "Ligera a la derecha",
            "Sharp left": "Giro cerrado a la izquierda",
            "Sharp right": "Giro cerrado a la derecha",
            "on": "en"
        };

        for (const eng in translations) {
            const regex = new RegExp(`\\b${eng}\\b`, "gi");
            esText = esText.replace(regex, translations[eng]);
        }

        esText = esText.replace(/Take the (\d+)(st|nd|rd|th) exit/gi, (match, num) => `Toma la ${num}ª salida`);
        esText = esText.replace(/and take the (\d+)(st|nd|rd|th) exit/gi, (match, num) => `y toma la ${num}ª salida`);

        return esText.charAt(0).toUpperCase() + esText.slice(1);
    }

    function getManeuverIconClass(maneuverType) {
        const type = maneuverType ? maneuverType.toLowerCase() : '';
        if (type.includes('left')) return 'leaflet-routing-icon-turn-left';
        if (type.includes('right')) return 'leaflet-routing-icon-turn-right';
        if (type.includes('straight') || type.includes('continue')) return 'leaflet-routing-icon-continue';
        if (type.includes('u-turn')) return 'leaflet-routing-icon-u-turn';
        if (type.includes('roundabout')) return 'leaflet-routing-icon-roundabout';
        if (type.includes('merge')) return 'leaflet-routing-icon-merge';
        if (type.includes('fork') || type.includes('branch')) return 'leaflet-routing-icon-fork';
        if (type.includes('arrive')) return 'leaflet-routing-icon-arrive';

        return 'leaflet-routing-icon-depart';
    }


    function drawRoutePreview() {
        if (routePreviewControl && allLocationsMapInstance.hasControl(routePreviewControl)) {
            allLocationsMapInstance.removeControl(routePreviewControl);
            routePreviewControl = null;
        }


        const tempSimpleWaypointMarkers = simpleWaypointMarkers.filter(m => m !== startRouteMarkerVisual);
        tempSimpleWaypointMarkers.forEach(m => {if(m && allLocationsMapInstance && allLocationsMapInstance.hasLayer(m)) m.remove()});
        simpleWaypointMarkers = startRouteMarkerVisual && allLocationsMapInstance && allLocationsMapInstance.hasLayer(startRouteMarkerVisual) ? [startRouteMarkerVisual] : [];


        if (!initialUserLocationMarkerLat || !initialUserLocationMarkerLng || currentRouteWaypointsLatLng.length === 0) {
             if(routingInfoPanel) routingInfoPanel.style.display = 'none';
            return;
        }

        const waypointsForPreview = [
            L.Routing.waypoint(L.latLng(initialUserLocationMarkerLat, initialUserLocationMarkerLng)),
            ...currentRouteWaypointsLatLng.map(wp => L.Routing.waypoint(wp))
        ];

        routePreviewControl = L.Routing.control({
            waypoints: waypointsForPreview,
            routeWhileDragging: true,
            show: false,
            addWaypoints: false,
            draggableWaypoints: true,
            fitSelectedRoutes: false,
            lineOptions: {
                styles: [{ color: 'blue', opacity: 0.8, weight: 6 }]
            },
            createMarker: function(i, waypoint, n) {
                let icon;
                let isDraggableMarker = true;
                if (i === 0) {
                    return null;
                } else if (i === n -1) {
                    icon = createNumberedIcon('F', 'red');
                } else {
                     icon = createNumberedIcon(i, '#F59E0B');
                }
                const marker = L.marker(waypoint.latLng, { icon: icon, draggable: isDraggableMarker });

                marker.waypointArrayIndex = i -1;

                if(isDraggableMarker) {
                    marker.on('dragend', function(e) {
                        const newLatLng = e.target.getLatLng();
                        const markerIndexInLatLngArray = this.waypointArrayIndex;
                        if (markerIndexInLatLngArray !== undefined && currentRouteWaypointsLatLng[markerIndexInLatLngArray]) {
                           currentRouteWaypointsLatLng[markerIndexInLatLngArray] = newLatLng;
                           drawRoutePreview();
                        }
                    });
                     marker.on('mousedown touchstart', function(ev) {
                        const currentMarker = this;
                        if (ev.originalEvent.button === 2 || (L.Browser.touch && ev.originalEvent.touches && ev.originalEvent.touches.length === 1)) {
                            if(L.Browser.touch) ev.originalEvent.preventDefault();
                            waypointPressTimer = setTimeout(() => {
                                const deleteIconId = `delete-wp-${currentMarker.waypointArrayIndex}`;
                                let deleteIcon = document.getElementById(deleteIconId);

                                if (!deleteIcon) {
                                    const markerElement = currentMarker.getElement();
                                    if (markerElement) {
                                        deleteIcon = L.DomUtil.create('div', 'delete-waypoint-icon', markerElement);
                                        deleteIcon.id = deleteIconId;
                                        deleteIcon.innerHTML = '✖';
                                        L.DomEvent.on(deleteIcon, 'click', function(clickEvent) {
                                            L.DomEvent.stop(clickEvent);
                                            const markerIndexInLatLngArray = currentMarker.waypointArrayIndex;
                                             if (markerIndexInLatLngArray !== undefined && markerIndexInLatLngArray < currentRouteWaypointsLatLng.length) {
                                                currentRouteWaypointsLatLng.splice(markerIndexInLatLngArray, 1);
                                                if (allLocationsMapInstance && allLocationsMapInstance.hasLayer(currentMarker)) currentMarker.remove();
                                                simpleWaypointMarkers = simpleWaypointMarkers.filter(m => m !== currentMarker);


                                                simpleWaypointMarkers.forEach((m) => {
                                                   if (m !== startRouteMarkerVisual && m.waypointArrayIndex > markerIndexInLatLngArray) {
                                                       m.waypointArrayIndex--;
                                                        if(m.waypointArrayIndex + 1 === currentRouteWaypointsLatLng.length) {
                                                            m.setIcon(createNumberedIcon('F', 'red'));
                                                       } else if (m.options.icon.options.html.includes("background-color:#F59E0B")) {
                                                            m.setIcon(createNumberedIcon(m.waypointArrayIndex + 1, '#F59E0B'));
                                                       }
                                                   }
                                                });
                                                drawRoutePreview();
                                                updateRoutingUI();
                                            }
                                            deleteIcon.remove();
                                        });
                                    }
                                } else {
                                    deleteIcon.remove();
                                }
                            }, L.Browser.touch ? 800: 0);
                        }
                    });
                    marker.on('mouseup touchend', () => clearTimeout(waypointPressTimer));
                    marker.on('mouseleave touchcancel', () => clearTimeout(waypointPressTimer));
                    marker.on('dragstart', () => clearTimeout(waypointPressTimer));
                }
                if (i > 0) {
                     simpleWaypointMarkers.push(marker);
                }
                return marker;
            },
             router: L.Routing.osrmv1({
                serviceUrl: 'https://router.project-osrm.org/route/v1',
                profile: 'driving'
            })
        }).addTo(allLocationsMapInstance);

        routePreviewControl.on('routesfound', function(e) {
             if (e.routes && e.routes.length > 0) {
                const summary = e.routes[0].summary;
                if(routingInfoPanel && currentRoutingMode === 'creating'){
                    routingInfoPanel.innerHTML = `
                        <p><strong>Dist (previa):</strong> ${(summary.totalDistance / 1000).toFixed(1)} km</p>
                        <p><strong>Tiempo (previa):</strong> ${Math.round(summary.totalTime / 60)} min</p>`;
                    routingInfoPanel.style.display = 'flex';
                }
            }
        });
         routePreviewControl.on('routingerror', function(e) {
            showToast("Error previsualizando ruta.", "warning");
            if(routingInfoPanel) routingInfoPanel.style.display = 'none';
        });
    }

    createRouteButton.addEventListener('click', () => {
        if (currentRoutingMode === 'none') {
            currentRoutingMode = 'creating';
            currentRouteWaypointsLatLng = [];
            clearSimpleWaypointMarkers();
            if (initialUserLocationMarkerLat && initialUserLocationMarkerLng) {
                 startRouteMarkerVisual = L.marker([initialUserLocationMarkerLat, initialUserLocationMarkerLng], {
                    icon: createNumberedIcon('0', 'green'),
                    draggable:false
                 });
                 if(allLocationsMapInstance && !allLocationsMapInstance.hasLayer(startRouteMarkerVisual)) {
                    startRouteMarkerVisual.addTo(allLocationsMapInstance);
                 }
                 simpleWaypointMarkers.push(startRouteMarkerVisual);
            }
            showToast("Modo CREAR RUTA: Pulsa en el mapa para añadir DESTINO y ETAPAS.", "info");
        } else if (currentRoutingMode === 'creating') {
            if (currentRouteWaypointsLatLng.length >= 1) {
                currentRoutingMode = 'navigating';
                startNavigation();
            } else {
                showToast("Añade al menos un destino para iniciar la navegación.", "warning");
            }
        } else if (currentRoutingMode === 'navigating') {
            currentRoutingMode = 'none';
            if (userMarkerForRoute && allLocationsMapInstance.hasLayer(userMarkerForRoute)) {userMarkerForRoute.remove(); userMarkerForRoute = null;}
            currentRouteWaypointsLatLng = [];
            if (startRouteMarkerVisual && allLocationsMapInstance.hasLayer(startRouteMarkerVisual)) {startRouteMarkerVisual.remove(); startRouteMarkerVisual = null;}
            shouldCenterOnUserInAllLocationsMap = false; // Desactivar seguimiento al detener
            locateMeButtonMap.textContent = 'ESTÁS AQUÍ';
            locateMeButtonMap.title = "Mostrar mi posición actual y activar seguimiento";
        }
        updateRoutingUI();
    });

    saveRouteButton.addEventListener('click', () => {
        if (currentRouteWaypointsLatLng.length < 1) {
            showToast("No hay suficientes puntos para guardar la ruta.", "warning");
            return;
        }
        const routeName = prompt("Nombre para la ruta:", `Ruta ${new Date().toLocaleDateString()}`);
        if (routeName) {
            const routes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || '[]');
            routes.push({
                name: routeName,
                waypoints: currentRouteWaypointsLatLng.map(wp => ({ lat: wp.lat, lng: wp.lng }))
            });
            localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(routes));
            showToast(`Ruta "${routeName}" guardada.`, "success");
        }
    });

    loadRouteButton.addEventListener('click', () => {
        const routes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || '[]');
        if (routes.length === 0) {
            showToast("No hay rutas guardadas.", "info");
            return;
        }

        const modalId = 'saved-routes-modal';
        let existingModal = document.getElementById(modalId);
        if (existingModal) existingModal.remove();

        const modal = document.createElement('div');
        modal.id = modalId;
        modal.innerHTML = `
            <h3>Cargar Ruta</h3>
            <div id="saved-routes-list"></div>
            <button id="close-saved-routes-modal">Cancelar</button>
        `;
        document.body.appendChild(modal);

        const listElement = modal.querySelector('#saved-routes-list');
        routes.forEach((route, index) => {
            const item = document.createElement('div');
            item.textContent = route.name;

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'X';
            deleteBtn.className = 'delete-route-btn';
            deleteBtn.title = 'Borrar esta ruta';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                if (confirm(`¿Seguro que quieres borrar la ruta "${route.name}"?`)) {
                    routes.splice(index, 1);
                    localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(routes));
                    modal.remove();
                    loadRouteButton.click();
                     showToast(`Ruta "${route.name}" borrada.`, "info");
                }
            };
            item.appendChild(deleteBtn);

            item.addEventListener('click', () => {
                currentRoutingMode = 'creating';
                currentRouteWaypointsLatLng = route.waypoints.map(wp => L.latLng(wp.lat, wp.lng));


                if(allLocationsMapInstance && currentRouteWaypointsLatLng.length > 0) {
                    clearSimpleWaypointMarkers();
                    if (initialUserLocationMarkerLat && initialUserLocationMarkerLng) {
                       startRouteMarkerVisual = L.marker([initialUserLocationMarkerLat, initialUserLocationMarkerLng], {icon: createNumberedIcon('0', 'green'), draggable:false });
                       if (allLocationsMapInstance.hasLayer(startRouteMarkerVisual)) startRouteMarkerVisual.remove();
                       startRouteMarkerVisual.addTo(allLocationsMapInstance);
                       simpleWaypointMarkers = [startRouteMarkerVisual];
                    }
                    drawRoutePreview();
                    if (currentRouteWaypointsLatLng.length > 0 && initialUserLocationMarkerLat && initialUserLocationMarkerLng) {
                        const boundsToShow = [L.latLng(initialUserLocationMarkerLat, initialUserLocationMarkerLng), ...currentRouteWaypointsLatLng];
                        allLocationsMapInstance.fitBounds(L.latLngBounds(boundsToShow), {padding: [50,50]});
                    }
                }
                 updateRoutingUI();
                modal.remove();
                showToast(`Ruta "${route.name}" cargada. Pulsa 'INICIAR NAVEGACIÓN'.`, "success");
            });
            listElement.appendChild(item);
        });
        modal.querySelector('#close-saved-routes-modal').addEventListener('click', () => modal.remove());
    });


    function startNavigation() {
        if (navigationRoutingControl && allLocationsMapInstance.hasControl(navigationRoutingControl)) {
            allLocationsMapInstance.removeControl(navigationRoutingControl);
            navigationRoutingControl = null;
        }
        if (routePreviewControl && allLocationsMapInstance.hasControl(routePreviewControl)) {
            allLocationsMapInstance.removeControl(routePreviewControl);
            routePreviewControl = null;
        }
        clearSimpleWaypointMarkers();

        let waypointsToNavigate = [];
        if (initialUserLocationMarkerLat && initialUserLocationMarkerLng) {
             waypointsToNavigate.push(L.Routing.waypoint(L.latLng(initialUserLocationMarkerLat, initialUserLocationMarkerLng)));
        } else {
            showToast("No se puede iniciar navegación: posición de inicio desconocida.", "error");
            currentRoutingMode = 'creating';
            updateRoutingUI();
            return;
        }
        currentRouteWaypointsLatLng.forEach(wp => waypointsToNavigate.push(L.Routing.waypoint(wp)));

        if (waypointsToNavigate.length < 2) {
             showToast("Se necesitan al menos un inicio y un destino para navegar.", "error");
             currentRoutingMode = 'creating';
             updateRoutingUI();
             return;
        }


        navigationRoutingControl = L.Routing.control({
            waypoints: waypointsToNavigate,
            routeWhileDragging: false,
            show: false,
            addWaypoints: false,
            draggableWaypoints: false,
            lineOptions: {
                styles: [{ color: 'blue', opacity: 0.8, weight: 6 }]
            },
            createMarker: function(i, waypoint, n) {
                let icon;
                if (i === 0) {
                    icon = createNumberedIcon('0', 'green');
                } else if (i === n -1) {
                    icon = createNumberedIcon('F', 'red');
                } else {
                     icon = createNumberedIcon(i, '#F59E0B');
                }
                const marker = L.marker(waypoint.latLng, { icon: icon, draggable: false });
                simpleWaypointMarkers.push(marker);
                return marker;
            },
            router: L.Routing.osrmv1({
                serviceUrl: 'https://router.project-osrm.org/route/v1',
                profile: 'driving'
            }),
            language: 'es',
            summaryTemplate: function(o) {
                return '';
            },

        }).addTo(allLocationsMapInstance);


        const lrmContainer = navigationRoutingControl.getContainer();
        if (lrmContainer) lrmContainer.style.display = 'none';


        navigationRoutingControl.on('routesfound', function(e) {
            const routes = e.routes;
            if (routes.length > 0) {
                const summary = routes[0].summary;
                totalRouteDistance = summary.totalDistance;
                const totalTime = summary.totalTime;

                const distanceKm = (totalRouteDistance / 1000).toFixed(1);
                const timeHours = Math.floor(totalTime / 3600);
                const timeMinutes = Math.round((totalTime % 3600) / 60);
                const eta = new Date(Date.now() + totalTime * 1000);

                routingInfoPanel.innerHTML = `
                    <p><strong>Dist:</strong> ${distanceKm} km</p>
                    <p><strong>Tiempo:</strong> ${timeHours > 0 ? timeHours + 'h ' : ''}${timeMinutes}min</p>
                    <p><strong>Llegada:</strong> ${eta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</p>
                `;
                routingInfoPanel.style.display = 'flex';

                routeLineForProgress = routes[0].coordinates;
                updateProgressBar(0, totalRouteDistance, totalTime);


                const progressBarElem = document.getElementById('progress-bar-container');

                progressBarElem.querySelectorAll('.waypoint-marker-on-progress').forEach(m => m.remove());

                let accumulatedDistanceForBar = 0;
                 for (let k = 0; k < routes[0].instructions.length; k++) {
                    const instruction = routes[0].instructions[k];

                    if (instruction.waypointIndex !== undefined && instruction.waypointIndex > 0 && instruction.waypointIndex < routes[0].inputWaypoints.length -1) {
                        if (totalRouteDistance > 0) {
                            const percent = (accumulatedDistanceForBar / totalRouteDistance) * 100;
                            const markerDot = document.createElement('div');
                            markerDot.className = 'waypoint-marker-on-progress';
                            markerDot.style.left = `${percent}%`;
                            progressBarElem.appendChild(markerDot);
                        }
                    }
                    accumulatedDistanceForBar += instruction.distance;
                }



                if (routes[0].instructions.length > 0) {
                    updateCurrentManeuver(routes[0].instructions[0], routes[0].instructions[1]);
                }
                 filterMarkersNearRoute();
                  shouldCenterOnUserInAllLocationsMap = true;
                  locateMeButtonMap.textContent = 'DEJAR DE SEGUIR';
                  locateMeButtonMap.title = "Dejar de centrar el mapa automáticamente en mi posición";

            }
        });

        navigationRoutingControl.on('routingerror', function(e) {
            showToast("Error calculando la ruta: " + (e.error?.message || "Servicio de rutas no disponible o puntos inválidos"), "error");
            currentRoutingMode = 'creating';
            updateRoutingUI();
        });


        let currentInstructionIndex = 0;

        if (locationWatchId) {
            const watchCallback = (position) => {
                if (currentRoutingMode !== 'navigating' || !navigationRoutingControl || !navigationRoutingControl._selectedRoute) return;
                const userLatLng = L.latLng(position.coords.latitude, position.coords.longitude);

                if(userMarkerForRoute) {
                    userMarkerForRoute.setLatLng(userLatLng);
                } else {
                    userMarkerForRoute = L.marker(userLatLng, {icon: carIcon}).addTo(allLocationsMapInstance);
                }
                 if(shouldCenterOnUserInAllLocationsMap && allLocationsMapInstance) {
                    allLocationsMapInstance.setView(userLatLng, Math.max(allLocationsMapInstance.getZoom(), 16));
                }


                const route = navigationRoutingControl._selectedRoute;


                let currentDistanceAlongRoute = 0;
                let bestMatchInstructionIndex = -1;

                let smallestDistToRoute = Infinity;
                let cumulativeDistToInstructionStart = 0;

                for (let i = 0; i < route.instructions.length; i++) {
                    const instruction = route.instructions[i];
                    const instructionLine = route.coordinates.slice(instruction.index, (route.instructions[i+1] ? route.instructions[i+1].index : route.coordinates.length-1) +1);
                    if(instructionLine.length < 2) {
                        if (i > 0 && route.instructions[i-1]) cumulativeDistToInstructionStart += route.instructions[i-1].distance;
                        continue;
                    }
                    const closestPointOnInstructionLine = L.GeometryUtil.closest(allLocationsMapInstance, instructionLine, userLatLng);
                    const distToThisLine = userLatLng.distanceTo(closestPointOnInstructionLine);

                    if (distToThisLine < smallestDistToRoute) {
                        smallestDistToRoute = distToThisLine;
                        bestMatchInstructionIndex = i;


                        let distAlongSegment = 0;
                        for(let k=0; k < instructionLine.length -1; k++){
                            if(L.GeometryUtil.belongsSegment(closestPointOnInstructionLine, instructionLine[k], instructionLine[k+1])){
                                distAlongSegment += L.latLng(instructionLine[k]).distanceTo(closestPointOnInstructionLine);
                                break;
                            }
                            distAlongSegment += L.latLng(instructionLine[k]).distanceTo(instructionLine[k+1]);
                        }
                        currentDistanceAlongRoute = cumulativeDistToInstructionStart + distAlongSegment;
                    }
                     if (i > 0 && route.instructions[i-1]) cumulativeDistToInstructionStart += route.instructions[i-1].distance; else cumulativeDistToInstructionStart = 0;
                }


                 updateProgressBar(currentDistanceAlongRoute, totalRouteDistance, route.summary.totalTime);
                 if(bestMatchInstructionIndex !== -1 && bestMatchInstructionIndex < route.instructions.length){
                    updateCurrentManeuver(route.instructions[bestMatchInstructionIndex], route.instructions[bestMatchInstructionIndex + 1]);
                 }
            };

            const oldWatchId = locationWatchId;
            if (oldWatchId) navigator.geolocation.clearWatch(oldWatchId);

            locationWatchId = navigator.geolocation.watchPosition(watchCallback,
                (err) => console.warn("GPS error en navegación: " + err.message),
                {enableHighAccuracy: true, timeout: 10000, maximumAge: 0, distanceFilter: 5 }
            );
        }
    }

    function updateCurrentManeuver(currentInstruction, nextInstruction) {
        if (!currentInstruction) {
            currentManeuverPanel.style.display = 'none';
            return;
        }
        const maneuverIconDiv = currentManeuverPanel.querySelector('.maneuver-icon');
        const maneuverInstructionDiv = currentManeuverPanel.querySelector('.maneuver-instruction');
        const maneuverDistanceDiv = currentManeuverPanel.querySelector('.maneuver-distance');
        const nextManeuverDiv = currentManeuverPanel.querySelector('.next-maneuver');

        if(maneuverIconDiv) maneuverIconDiv.className = `maneuver-icon ${getManeuverIconClass(currentInstruction.type)}`;
        if(maneuverInstructionDiv) maneuverInstructionDiv.textContent = getManeuverTranslation(currentInstruction.text);
        if(maneuverDistanceDiv) maneuverDistanceDiv.textContent = `en ${formatDistance(currentInstruction.distance)}`;

        if (nextInstruction && nextManeuverDiv) {
            nextManeuverDiv.textContent = `Luego: ${getManeuverTranslation(nextInstruction.text)}`;
            nextManeuverDiv.style.display = 'block';
        } else if (nextManeuverDiv) {
            nextManeuverDiv.style.display = 'none';
        }
        currentManeuverPanel.style.display = 'flex';
    }

    function updateProgressBar(distanceCovered, totalDistance, totalTimeSeconds) {
        if (totalDistance === 0) {
            progressBarFill.style.width = '0%';
            if (progressBarTextOverlay) progressBarTextOverlay.textContent = '';
            return;
        }
        const percentage = Math.min(100, (distanceCovered / totalDistance) * 100);
        progressBarFill.style.width = `${percentage}%`;

        const remainingDistance = totalDistance - distanceCovered;
        if (progressBarTextOverlay) {
            let remainingTimeMinutes = 0;
            if (totalTimeSeconds && totalDistance > 0 && distanceCovered < totalDistance) {
                 remainingTimeSeconds = totalTimeSeconds * (1 - (distanceCovered / totalDistance));
                 remainingTimeMinutes = Math.round(remainingTimeSeconds / 60);
            } else if (distanceCovered >= totalDistance) {
                remainingTimeMinutes = 0;
            }

            progressBarTextOverlay.textContent = `${formatDistance(remainingDistance)} (${remainingTimeMinutes} min)`;
        }
    }

    function formatDistance(meters) {
        if (meters < 1000) {
            return `${Math.round(meters)} m`;
        } else {
            return `${(meters / 1000).toFixed(1)} km`;
        }
    }


    const closeHandlerAllMap = () => {
        isRemindersLocationMapActive = false;
        currentRoutingMode = 'none';
        currentRouteWaypointsLatLng = [];
        if (navigationRoutingControl && allLocationsMapInstance && allLocationsMapInstance.hasControl(navigationRoutingControl)) {
             try { allLocationsMapInstance.removeControl(navigationRoutingControl); } catch(e){}
        }
        if (routePreviewControl && allLocationsMapInstance && allLocationsMapInstance.hasControl(routePreviewControl)) {
             try { allLocationsMapInstance.removeControl(routePreviewControl); } catch(e){}
        }
        navigationRoutingControl = null;
        routePreviewControl = null;
        routeLineForProgress = null;
        totalRouteDistance = 0;
        if (userMarkerForRoute && allLocationsMapInstance && allLocationsMapInstance.hasLayer(userMarkerForRoute)) {userMarkerForRoute.remove(); userMarkerForRoute = null;}
        clearSimpleWaypointMarkers();
        if(startRouteMarkerVisual && allLocationsMapInstance && allLocationsMapInstance.hasLayer(startRouteMarkerVisual)) {startRouteMarkerVisual.remove(); startRouteMarkerVisual = null;}


        if (locationWatchId !== null) {
            navigator.geolocation.clearWatch(locationWatchId);
            locationWatchId = null;
        }
        if (allLocationsMapInstance) {
            if (orientationAltitudeControl && typeof allLocationsMapInstance.hasControl === 'function' && allLocationsMapInstance.hasControl(orientationAltitudeControl)) {
                allLocationsMapInstance.removeControl(orientationAltitudeControl);
                 const maneuverPanel = document.getElementById('current-maneuver-panel');
                 if(maneuverPanel && maneuverPanel.parentNode === orientationAltitudeControl.getContainer()){
                      document.getElementById('reminders-location-map-div').appendChild(maneuverPanel);
                 }
            }
             try { allLocationsMapInstance.remove(); } catch (e) { console.warn("Error removing allLocationsMapInstance on close:", e); }
            allLocationsMapInstance = null;
        }
        initialUserLocationMarker = null; initialUserLocationMarkerLat = null; initialUserLocationMarkerLng = null;
        if (initialUserLocationCircle) { initialUserLocationCircle.remove(); initialUserLocationCircle = null; }
        orientationAltitudeControl = null;

        const mapModalElement = document.getElementById('reminders-location-map-modal');
        if (mapModalElement) {
            mapModalElement.remove();
        }

        const helpModalInstance = document.getElementById('reminders-map-help-modal-instance');
        if (helpModalInstance) {
             const helpCloseButton = helpModalInstance.querySelector('#close-reminders-map-help-instance');
             if(helpCloseButton) clearModalAutoCloseTimer(helpModalInstance, helpCloseButton, 'reminders-map-help-modal-instance');
             helpModalInstance.remove();
        }
        const savedRoutesModal = document.getElementById('saved-routes-modal');
        if(savedRoutesModal) savedRoutesModal.remove();

        sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
        sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
        sessionStorage.removeItem('boardinggate_map_was_open_before_table');
        sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');

        hideUnifiedReminderWindow();
    };
    closeButton.addEventListener('click', closeHandlerAllMap);

    locateMeButtonMap.addEventListener('click', function handleLocateMeClick() {
        if (!allLocationsMapInstance) return;
        if (locateMeButtonMap.textContent === "ESTÁS AQUÍ") {
            shouldCenterOnUserInAllLocationsMap = true;
            locateMeButtonMap.textContent = 'DEJAR DE SEGUIR';
            locateMeButtonMap.title = "Dejar de centrar el mapa automáticamente en mi posición";
            if (initialUserLocationMarkerLat && initialUserLocationMarkerLng) {
                const latLng = L.latLng(initialUserLocationMarkerLat, initialUserLocationMarkerLng);
                allLocationsMapInstance.setView(latLng, Math.max(allLocationsMapInstance.getZoom(), 16));
            } else {
                 getCurrentLocation(
                    (coords) => {
                        const latLng = L.latLng(coords.latitude, coords.longitude);
                        if (allLocationsMapInstance) allLocationsMapInstance.setView(latLng, 16);
                        updateInitialUserPosition(coords, false);
                    },
                    () => showToast("No se pudo obtener tu ubicación para centrar.", "warning")
                );
            }
        } else if (locateMeButtonMap.textContent === "DEJAR DE SEGUIR") {
            shouldCenterOnUserInAllLocationsMap = false;
            locateMeButtonMap.textContent = 'ESTÁS AQUÍ';
            locateMeButtonMap.title = "Mostrar mi posición actual y activar seguimiento";
        }
    });


    addRadarButton.addEventListener('click', () => {
        addRadarButton.disabled = true; addRadarButton.textContent = 'Marcando...';
        getCurrentLocation(
            (coords) => {
                const now = new Date();
                const newRadarReminder = {
                    id: Date.now(),
                    text: '<b>RADAR: EN ESTA UBICACION (Añadido manualmente)</b>',
                    type: 'simple',
                    time: `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`,
                    date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                    createdAt: now.toISOString(),
                    managedByUser: false,
                    isLocationEnabled: true,
                    locationCoordinates: { latitude: coords.latitude, longitude: coords.longitude },
                    radiusMeters: 1000,
                    excludeFromList: true
                };

                let currentRemindersList = JSON.parse(localStorage.getItem('reminders') || '[]');
                currentRemindersList.push(newRadarReminder);
                localStorage.setItem('reminders', JSON.stringify(currentRemindersList));

                showToast("Recordatorio RADAR creado en tu ubicación actual (radio 1000 metros).", "success");
                updateReminderCount();
                updateButtonStyles();

                if (allLocationsMapInstance) {
                    const radarLatLng = [newRadarReminder.locationCoordinates.latitude, newRadarReminder.locationCoordinates.longitude];
                    const radarMapMarker = L.marker(radarLatLng, { icon: radarMarkerIcon })
                        .addTo(allLocationsMapInstance);
                    const radarCircle = L.circle(radarLatLng, {
                        radius: newRadarReminder.radiusMeters,
                        color: '#800080',
                        fillColor: '#DA70D6',
                        fillOpacity: 0.1
                    }).addTo(allLocationsMapInstance);

                     allMapMarkers.push({marker: radarMapMarker, circle: radarCircle, reminderData: newRadarReminder});

                    let popupContentRadar = `
                        <div style="max-width: 250px; font-family: sans-serif; font-size: 0.9rem;">
                            <strong style="font-size: 1rem; color: #333; display: block; margin-bottom: 5px;">${newRadarReminder.text.replace(/<b>|<\/b>/gi,'')}</strong>
                            <hr style="margin: 4px 0;">
                            <p style="margin: 3px 0;"><strong>Radio:</strong> ${newRadarReminder.radiusMeters}m</p>
                            <p style="margin: 3px 0;"><strong>Creado:</strong> Ahora</p>
                            <button data-reminder-id="${newRadarReminder.id}" class="modify-reminder-from-map" style="margin-top: 8px; padding: 4px 8px; font-size: 0.8rem; background-color: #10B981; color: white; border: none; border-radius: 3px; cursor: pointer;">Modificar</button>
                        </div>`;
                    radarMapMarker.bindPopup(popupContentRadar);
                    radarMapMarker.on('popupopen', () => {
                        const modifyButton = radarMapMarker.getPopup().getElement().querySelector('.modify-reminder-from-map');
                        if (modifyButton) {
                            const newModifyButton = modifyButton.cloneNode(true);
                            modifyButton.parentNode.replaceChild(newModifyButton, modifyButton);
                            newModifyButton.addEventListener('click', (e) => {
                                const id = parseInt(e.target.dataset.reminderId);
                                if (!isNaN(id)) {
                                    const rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                                    const remToMod = rems.find(r => r.id === id);
                                    if (remToMod) {
                                        closeHandlerAllMap();
                                        showReminderModal(remToMod);
                                    } else { showToast("Error: No se encontró el recordatorio para modificar.", "error"); }
                                }
                            });
                        }
                    });
                    allLocationsMapInstance.setView(radarLatLng, 15);
                }

                addRadarButton.disabled = false; addRadarButton.textContent = 'AQUÍ HAY UN RADAR';
            },
            (errorMsg) => {
                showToast(`Error al obtener ubicación para RADAR: ${errorMsg}`, "error");
                addRadarButton.disabled = false; addRadarButton.textContent = 'AQUÍ HAY UN RADAR';
            }
        );
    });

    helpButton.addEventListener('click', showRemindersMapHelpModal);

    try {
        allLocationsMapInstance = L.map(mapContainer, {
            zoomControl: true
        });
        allLocationsMapInstance.zoomControl.setPosition('topright');

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        }).addTo(allLocationsMapInstance);

        orientationAltitudeControl = L.control.orientationAltitude({ position: 'topleft' });
        if(allLocationsMapInstance && orientationAltitudeControl) {
            orientationAltitudeControl.addTo(allLocationsMapInstance);
            const maneuverPanel = document.getElementById('current-maneuver-panel');
            if (maneuverPanel) {
                 orientationAltitudeControl.getContainer().appendChild(maneuverPanel);
            }
        }


        allLocationsMapInstance.on('zoomend', () => {
            if (initialUserLocationCircle && initialUserLocationMarkerLat && initialUserLocationMarkerLng && allLocationsMapInstance) {
                const zoomLevel = allLocationsMapInstance.getZoom();
                const minZoom = allLocationsMapInstance.getMinZoom() || 0;
                const maxZoom = allLocationsMapInstance.getMaxZoom() || 18;
                const zoomFraction = Math.max(0, Math.min(1, (zoomLevel - minZoom) / (maxZoom - minZoom)));
                const minRadius = 3;
                const maxRadius = 150;
                const newRadius = minRadius + (maxRadius - minRadius) * (1 - zoomFraction);
                initialUserLocationCircle.setRadius(Math.max(minRadius, Math.min(maxRadius, newRadius)));
            }
        });


        const updateInitialUserPosition = (coords, isInitialViewSetup = false) => {
            if (!allLocationsMapInstance) return;

            const latLng = coords ? L.latLng(coords.latitude, coords.longitude) : null;
            initialUserLocationMarkerLat = coords ? coords.latitude : null;
            initialUserLocationMarkerLng = coords ? coords.longitude : null;
            const currentHeading = coords ? coords.heading : null;
            const currentAltitude = coords ? coords.altitude : null;

            if (userMarkerForRoute && currentRoutingMode === 'navigating' && latLng) {
                userMarkerForRoute.setLatLng(latLng);
            } else if (latLng) { // Solo actualiza el marcador de posición si tenemos coordenadas
                if (initialUserLocationMarker) {
                    initialUserLocationMarker.setLatLng(latLng);
                } else {
                    initialUserLocationMarker = L.marker(latLng, {
                        icon: carIcon,
                        zIndexOffset: 1000,
                    })
                    .addTo(allLocationsMapInstance)
                    .bindPopup("Tu posición actual");
                }
                 const markerElement = initialUserLocationMarker.getElement();
                 if (markerElement) {
                     markerElement.style.transformOrigin = 'center center';
                 }
            }


            if (orientationAltitudeControl) {
                orientationAltitudeControl.updateOrientation(currentHeading);
                orientationAltitudeControl.updateAltitude(currentAltitude);
            }

            if (latLng) { // Solo actualiza el círculo si tenemos coordenadas
                const zoomLevel = allLocationsMapInstance.getZoom();
                const minZoom = allLocationsMapInstance.getMinZoom() || 0;
                const maxZoom = allLocationsMapInstance.getMaxZoom() || 18;
                const zoomFraction = Math.max(0, Math.min(1, (zoomLevel - minZoom) / (maxZoom - minZoom)));
                const minRadius = 3;
                const maxRadius = 150;
                const dynamicRadius = minRadius + (maxRadius - minRadius) * (1 - zoomFraction);

                const circleStyle = {
                    radius: Math.max(minRadius, Math.min(maxRadius, dynamicRadius)),
                    color: 'green',
                    weight: 3,
                    fillColor: 'yellow',
                    fillOpacity: 0.4
                };

                if (currentRoutingMode !== 'navigating') {
                    if (initialUserLocationCircle) {
                        initialUserLocationCircle.setLatLng(latLng).setRadius(circleStyle.radius).setStyle({
                            color: circleStyle.color,
                            weight: circleStyle.weight,
                            fillColor: circleStyle.fillColor,
                            fillOpacity: circleStyle.fillOpacity
                        });
                    } else {
                         initialUserLocationCircle = L.circle(latLng, circleStyle).addTo(allLocationsMapInstance);
                    }
                } else if (initialUserLocationCircle && allLocationsMapInstance.hasLayer(initialUserLocationCircle)) {
                    initialUserLocationCircle.remove();
                    initialUserLocationCircle = null;
                }
            }


            if (isInitialViewSetup) {
                const currentRemindersToPlot = remindersWithLocation.filter(r =>
                    toggleRadarVisibilityCheckbox.checked ? true : (!r.text.toUpperCase().includes("RADAR:") && !r.excludeFromList)
                );
                 let bounds;
                 if (currentRemindersToPlot.length > 0) {
                    bounds = L.latLngBounds(currentRemindersToPlot.map(r => [r.locationCoordinates.latitude, r.locationCoordinates.longitude]));
                 } else {
                    bounds = L.latLngBounds([]);
                 }


                if (latLng) bounds.extend(latLng);

                if (bounds.isValid()) {
                    allLocationsMapInstance.fitBounds(bounds.pad(0.15));
                } else if (latLng) {
                    allLocationsMapInstance.setView(latLng, 16);
                } else {
                     allLocationsMapInstance.setView([40.416775, -3.703790], 6);
                }
            } else if (shouldCenterOnUserInAllLocationsMap && latLng) {
                 allLocationsMapInstance.setView(latLng, Math.max(allLocationsMapInstance.getZoom(), 16));
            }
        };

        plotReminders(!toggleRadarVisibilityCheckbox.checked);


        const handleMapClickForRouting = (e) => {
            if (currentRoutingMode === 'creating') {
                let icon;
                if (currentRouteWaypointsLatLng.length === 0) {
                    icon = createNumberedIcon('F', 'red');
                } else {
                    icon = createNumberedIcon(currentRouteWaypointsLatLng.length, '#F59E0B');
                }
                const marker = L.marker(e.latlng, { icon: icon, draggable: true })
                .addTo(allLocationsMapInstance);

                const waypointIndexInLatLngArray = currentRouteWaypointsLatLng.length;
                currentRouteWaypointsLatLng.push(e.latlng);

                marker.waypointArrayIndex = waypointIndexInLatLngArray;
                simpleWaypointMarkers.push(marker);


                marker.on('dragend', function(event) {
                    const newLatLng = event.target.getLatLng();
                    const markerIndexInLatLngArray = this.waypointArrayIndex;
                    if (markerIndexInLatLngArray !== undefined && currentRouteWaypointsLatLng[markerIndexInLatLngArray]) {
                       currentRouteWaypointsLatLng[markerIndexInLatLngArray] = newLatLng;
                       drawRoutePreview();
                    }
                });
                 marker.on('mousedown touchstart', function(ev) {
                    const currentMarker = this;
                    if (ev.originalEvent.button === 2 || (L.Browser.touch && ev.originalEvent.touches && ev.originalEvent.touches.length === 1)) {
                        if(L.Browser.touch) ev.originalEvent.preventDefault();
                        waypointPressTimer = setTimeout(() => {
                            const deleteIconId = `delete-wp-${currentMarker.waypointArrayIndex}`;
                            let deleteIcon = document.getElementById(deleteIconId);
                            if (!deleteIcon) {
                                const markerElement = currentMarker.getElement();
                                if (markerElement) {
                                    deleteIcon = L.DomUtil.create('div', 'delete-waypoint-icon', markerElement);
                                    deleteIcon.id = deleteIconId;
                                    deleteIcon.innerHTML = '✖';
                                    L.DomEvent.on(deleteIcon, 'click', function(clickEvent) {
                                        L.DomEvent.stop(clickEvent);
                                        const markerIndexInLatLngArray = currentMarker.waypointArrayIndex;
                                         if (markerIndexInLatLngArray !== undefined && markerIndexInLatLngArray < currentRouteWaypointsLatLng.length) {
                                            currentRouteWaypointsLatLng.splice(markerIndexInLatLngArray, 1);
                                            if(allLocationsMapInstance.hasLayer(currentMarker)) currentMarker.remove();
                                            simpleWaypointMarkers = simpleWaypointMarkers.filter(m => m !== currentMarker);


                                            simpleWaypointMarkers.forEach((m) => {
                                               if (m !== startRouteMarkerVisual && m.waypointArrayIndex > markerIndexInLatLngArray) {
                                                   m.waypointArrayIndex--;
                                                    if(m.waypointArrayIndex + 1 === currentRouteWaypointsLatLng.length) {
                                                        m.setIcon(createNumberedIcon('F', 'red'));
                                                   } else if (m.options.icon.options.html.includes("background-color:#F59E0B")) {
                                                        m.setIcon(createNumberedIcon(m.waypointArrayIndex + 1, '#F59E0B'));
                                                   }
                                               }
                                            });
                                            drawRoutePreview();
                                            updateRoutingUI();
                                        }
                                        deleteIcon.remove();
                                    });
                                }
                            } else {
                                deleteIcon.remove();
                            }

                        }, L.Browser.touch ? 800: 0);
                    }
                });
                marker.on('mouseup touchend', () => clearTimeout(waypointPressTimer));
                marker.on('mouseleave touchcancel', () => clearTimeout(waypointPressTimer));
                marker.on('dragstart', () => clearTimeout(waypointPressTimer));

                updateRoutingUI();
                if (currentRouteWaypointsLatLng.length >= 1 && initialUserLocationMarkerLat && initialUserLocationMarkerLng) {
                    drawRoutePreview();
                }
            } else if (currentRoutingMode === 'none') {
                if (e.latlng && L.Browser.touch) {
                    handleRadarMapLongPress(e.latlng);
                }
            }
        };


        allLocationsMapInstance.on('click', handleMapClickForRouting);
        allLocationsMapInstance.on('contextmenu', function(e) {
             if (currentRoutingMode === 'none') {
                 e.originalEvent.preventDefault();
                 if (e.latlng) { handleRadarMapLongPress(e.latlng); }
             } else if (currentRoutingMode === 'creating') {
                 e.originalEvent.preventDefault();
             }
        });


        getCurrentLocation(
            (currentPos) => {
                const userCoords = {
                    latitude: currentPos.latitude,
                    longitude: currentPos.longitude,
                    accuracy: currentPos.accuracy,
                    heading: currentPos.heading,
                    altitude: currentPos.altitude
                };
                updateInitialUserPosition(userCoords, remindersWithLocation.length === 0 && !initialUserLocationMarkerLat);

                if(currentRoutingMode !== 'navigating' && !userMarkerForRoute){
                     if(!initialUserLocationMarker) {
                        initialUserLocationMarker = L.marker([userCoords.latitude, userCoords.longitude], {icon: carIcon, zIndexOffset: 1000}).addTo(allLocationsMapInstance);
                     }
                     if(!startRouteMarkerVisual && allLocationsMapInstance && allLocationsMapInstance.hasLayer(initialUserLocationMarker)){
                         startRouteMarkerVisual = L.marker([userCoords.latitude, userCoords.longitude], {icon: createNumberedIcon('0', 'green'), draggable:false });
                         if(currentRoutingMode === 'creating' && allLocationsMapInstance && !allLocationsMapInstance.hasLayer(startRouteMarkerVisual)) {
                            startRouteMarkerVisual.addTo(allLocationsMapInstance);
                         }
                         simpleWaypointMarkers.unshift(startRouteMarkerVisual);
                     }
                }


                if (locationWatchId === null && 'geolocation' in navigator && 'watchPosition' in navigator.geolocation) {
                    locationWatchId = navigator.geolocation.watchPosition(
                        (position) => {
                            const coordsForUpdate = {
                                latitude: position.coords.latitude,
                                longitude: position.coords.longitude,
                                accuracy: position.coords.accuracy,
                                heading: position.coords.heading,
                                altitude: position.coords.altitude
                            };
                            updateInitialUserPosition(coordsForUpdate, false);


                             if (currentRoutingMode === 'navigating' && navigationRoutingControl) {
                                 const userCurrentLatLng = L.latLng(coordsForUpdate.latitude, coordsForUpdate.longitude);
                                 const waypoints = navigationRoutingControl.getWaypoints();
                                 if (waypoints && waypoints.length > 0 && waypoints[0].latLng.distanceTo(userCurrentLatLng) > 5) {
                                     waypoints[0].latLng = userCurrentLatLng;
                                     navigationRoutingControl.setWaypoints(waypoints);
                                 }
                             } else if (currentRoutingMode === 'creating' && startRouteMarkerVisual) {
                                 startRouteMarkerVisual.setLatLng([coordsForUpdate.latitude, coordsForUpdate.longitude]);
                                 if (currentRouteWaypointsLatLng.length > 0) drawRoutePreview();
                             }
                        },
                        (error) => {
                            showToast(`Error seguimiento GPS: ${error.message}`, "warning");
                            if (locationWatchId !== null) {
                                navigator.geolocation.clearWatch(locationWatchId);
                                locationWatchId = null;
                            }
                             if (orientationAltitudeControl) {
                                orientationAltitudeControl.updateOrientation(null);
                                orientationAltitudeControl.updateAltitude(null);
                            }
                        },
                        { enableHighAccuracy: true, timeout: 15000, maximumAge: 5000, distanceFilter: 5 }
                    );
                }
            },
            () => {
                showToast("No pudo obtener la ubicación inicial. El mapa mostrará los recordatorios.", "warning");
                 if (orientationAltitudeControl) {
                    orientationAltitudeControl.updateOrientation(null);
                    orientationAltitudeControl.updateAltitude(null);
                }
                updateInitialUserPosition(null, true);
            }
        );

        setTimeout(() => {
            if (allLocationsMapInstance) {
                allLocationsMapInstance.invalidateSize();
            }
        }, 150);
        updateRoutingUI();

    } catch (error) {
        mapContainer.innerHTML = `<p style="color:red; text-align:center; padding:20px;">Error al cargar el mapa: ${error.message}</p>`;
    }
}

    function handleRadarMapLongPress(latlng) {
        if (!latlng) return;
        const mapModalElement = document.getElementById('reminders-location-map-modal');

        if (mapModalElement) {
             if (locationWatchId !== null) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
             if (allLocationsMapInstance) { allLocationsMapInstance.remove(); allLocationsMapInstance = null; }
             initialUserLocationMarker = null; initialUserLocationMarkerLat = null; initialUserLocationMarkerLng = null;
             if (initialUserLocationCircle) { initialUserLocationCircle.remove(); initialUserLocationCircle = null; }
             orientationAltitudeControl = null;
             mapModalElement.remove();
        }

        const helpModalInstance = document.getElementById('reminders-map-help-modal-instance');
        if (helpModalInstance) helpModalInstance.remove();


        const reminderData = {
            text: 'RADAR',
            isLocationEnabled: true,
            locationCoordinates: {
                latitude: latlng.lat,
                longitude: latlng.lng
            },
            radiusMeters: 1000,
            excludeFromList: true,
        };
        showReminderModal(reminderData);
        showToast("Creando recordatorio RADAR en el punto seleccionado.", "info");
    }

    function showRemindersMapHelpModal() {
        const existingHelpModal = document.getElementById('reminders-map-help-modal-instance');
        if (existingHelpModal) {
            clearModalAutoCloseTimer(existingHelpModal, existingHelpModal.querySelector('#close-reminders-map-help-instance'), 'reminders-map-help-modal-instance');
            existingHelpModal.remove();
        }

        const helpModal = document.createElement('div');
        helpModal.id = 'reminders-map-help-modal-instance';
        helpModal.className = 'help-modal';
        helpModal.setAttribute('aria-label', 'Ayuda Mapa de Ubicaciones/Radares');
        helpModal.innerHTML = `
            <h2 class="text-xl font-bold mb-4">Ayuda del Mapa de Ubicaciones y Rutas</h2>
            <p class="mb-2">Este mapa muestra todos tus recordatorios que tienen una ubicación geográfica asociada y permite trazar rutas.</p>
            <ul class="list-disc pl-5 space-y-1 mb-4 text-sm">
                <li><strong>Ver Detalles (Recordatorios):</strong> Pulsa sobre un marcador (chincheta azul o morada) para ver los detalles del recordatorio y un botón para modificarlo.</li>
                <li><strong>Iconos de Marcadores:</strong>
                    <ul>
                        <li><img src="${defaultLocationMarkerIconBlue.options.iconUrl}" alt="Chincheta Azul" style="width:12px; height:20px; vertical-align:middle; display:inline;"> Recordatorio normal.</li>
                        <li><img src="${radarMarkerIcon.options.iconUrl}" alt="Chincheta Morada" style="width:12px; height:20px; vertical-align:middle; display:inline;"> Recordatorio con "RADAR" en el texto o excluido de lista.</li>
                        <li><img src="Coche.PNG" alt="Icono Coche" style="width:1.5em; height:1.5em; vertical-align:middle; display:inline;"> Tu posición actual. El icono <strong>no rota</strong> según tu orientación. El círculo que lo rodea tiene un radio variable de 3m (cerca) a 150m (lejos) según el zoom.</li>
                        <li><img src="data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 28 28'%3E%3Ccircle cx='14' cy='14' r='12' fill='red' stroke='white' stroke-width='2'/%3E%3Ctext x='14' y='19' font-size='16' font-weight='bold' fill='white' text-anchor='middle'%3EF%3C/text%3E%3C/svg%3E" alt="Icono Final" style="width:1.2em; height:1.2em; vertical-align:middle; display:inline;"> Destino final de una ruta en creación/navegación.</li>
                        <li><img src="data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 28 28'%3E%3Ccircle cx='14' cy='14' r='12' fill='%23F59E0B' stroke='white' stroke-width='2'/%3E%3Ctext x='14' y='19' font-size='16' fill='white' text-anchor='middle'%3E1%3C/text%3E%3C/svg%3E" alt="Icono Etapa" style="width:1.2em; height:1.2em; vertical-align:middle; display:inline;"> Etapa intermedia de una ruta en creación/navegación (ej. etapa 1).</li>
                        <li><img src="data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 28 28'%3E%3Ccircle cx='14' cy='14' r='12' fill='green' stroke='white' stroke-width='2'/%3E%3Ctext x='14' y='19' font-size='16' fill='white' text-anchor='middle'%3E0%3C/text%3E%3C/svg%3E" alt="Icono Inicio" style="width:1.2em; height:1.2em; vertical-align:middle; display:inline;"> Punto de inicio de ruta (tu ubicación GPS).</li>
                    </ul>
                </li>
                <li><strong>"ESTÁS AQUÍ" / "DEJAR DE SEGUIR":</strong>
                    <ul>
                        <li><strong>ESTÁS AQUÍ:</strong> Centra el mapa en tu ubicación actual (GPS), la marca con el icono del coche, y activa el seguimiento continuo. El mapa se mantendrá centrado en tu posición mientras te mueves. El botón cambia a "DEJAR DE SEGUIR".</li>
                        <li><strong>DEJAR DE SEGUIR:</strong> Desactiva el centrado automático del mapa. Tu posición (icono coche) seguirá actualizándose en tiempo real, pero el mapa no se moverá contigo. El botón vuelve a "ESTÁS AQUÍ".</li>
                    </ul>
                </li>
                <li><strong>"AQUÍ HAY UN RADAR":</strong> Crea automáticamente un recordatorio con el texto "RADAR", tu ubicación GPS actual, radio de 1000 metros y lo marca para no incluir en la lista general. El nuevo radar se añade al mapa.</li>
                 <li><strong>"VER RADARES" (Checkbox):</strong> Permite mostrar u ocultar los recordatorios que contienen "RADAR" en su texto o están marcados para no listar. Útil para despejar el mapa.</li>
                 <li><strong>Actualización Posición:</strong> La posición de tu coche (<img src="Coche.PNG" alt="Icono Coche" style="width:1.5em; height:1.5em; vertical-align:middle; display:inline;">) se actualiza en tiempo real.</li>
                 <li><strong>Orientación y Altitud:</strong> Panel superior izquierdo (<img src="ROSA.PNG" alt="Rosa Vientos" style="width:1.2em; height:1.2em; vertical-align:middle; display:inline;">) muestra rumbo y altitud si están disponibles. El panel de maniobras de ruta se integra a su derecha.</li>
            </ul>
            <h3 class="font-semibold text-lg mt-4 mb-2">TRAZAR Y NAVEGAR RUTAS</h3>
            <ul class="list-disc pl-5 space-y-1 text-sm">
                <li><strong>"CREAR RUTA":</strong> Inicia el modo de creación. Pulsa en el mapa para añadir puntos:
                    <ul>
                        <li>El <strong>primer clic</strong> establece el <strong>DESTINO FINAL</strong> (Icono 'F' Rojo).</li>
                        <li>Los <strong>clics siguientes</strong> añaden <strong>ETAPAS INTERMEDIAS</strong> (Iconos '1', '2'... Naranja), en el orden en que se pulsan.</li>
                        <li>El <strong>INICIO</strong> de la ruta será siempre tu ubicación GPS actual al pulsar "INICIAR NAVEGACIÓN" (Icono '0' Verde).</li>
                        <li>Las chinchetas de destino y etapas se pueden arrastrar para reposicionar. La ruta (línea azul) se actualiza dinámicamente.</li>
                         <li>Para <strong>eliminar un punto de ruta</strong> (destino o etapa) durante la creación: mantén pulsado sobre la chincheta correspondiente hasta que aparezca un aspa (X) roja. Pulsa el aspa para borrar el punto.</li>
                    </ul>
                </li>
                <li><strong>"INICIAR NAVEGACIÓN":</strong> (Botón "CREAR RUTA" cambia a este texto si hay al menos un destino). Calcula la ruta detallada desde tu posición actual, pasando por las etapas (si las hay, en el orden añadido) hasta el destino final. Se mostrará:
                    <ul>
                        <li><strong>Panel de Maniobras:</strong> Arriba a la derecha de la rosa de los vientos. Con instrucción actual, distancia, icono de maniobra y la siguiente instrucción. Las instrucciones están en castellano.</li>
                        <li><strong>Barra de Progreso:</strong> Parte inferior. Color naranja oscuro, traslúcida. Puntos azules en la barra marcan las etapas. Texto superpuesto con distancia/tiempo restante.</li>
                        <li><strong>Info Ruta:</strong> (Integrada en la barra de progreso) Muestra distancia total, tiempo estimado y hora de llegada, distribuidos horizontalmente.</li>
                         <li><strong>Filtro de Recordatorios:</strong> Durante la navegación, solo se mostrarán los recordatorios/radares cercanos a la ruta (aprox. 1500m de radio, los lejanos con transparencia).</li>
                    </ul>
                </li>
                 <li><strong>"DETENER NAVEGACIÓN":</strong> (Botón cambia a este texto durante la navegación). Limpia la ruta activa, detiene el seguimiento de navegación y los paneles de información de ruta. Se restauran todos los marcadores de recordatorios visibles.</li>
                <li><strong>"GUARDAR RUTA":</strong> Visible durante la creación (si hay al menos destino) o navegación. Permite guardar la ruta actual (destino y etapas) con un nombre para usarla más tarde.</li>
                <li><strong>"CARGAR RUTA":</strong> Muestra una lista de rutas guardadas. Al seleccionar una, se carga en el modo "CREAR RUTA" para que puedas revisarla o iniciar la navegación.</li>
            </ul>

             <h3 class="font-semibold text-lg mt-4 mb-2">Crear Recordatorio "RADAR" Manualmente (Alternativa)</h3>
            <p class="mb-2">También puedes añadir un recordatorio "RADAR" directamente desde este mapa haciendo clic o tap en cualquier punto del mapa (si no estás en modo "CREAR RUTA").</p>
            <ul class="list-disc pl-5 space-y-1 text-sm">
                <li><strong>PC:</strong> Haz clic derecho en cualquier punto del mapa.</li>
                <li><strong>Móvil/Táctil:</strong> Un tap/click simple en un punto del mapa.</li>
            </ul>
            <p class="mb-2">Al hacerlo, se abrirá la ventana de creación de recordatorios con datos pre-rellenados.</p>
            <div class="flex justify-end mt-6">
                <button type="button" id="close-reminders-map-help-instance">Entendido</button>
            </div>
        `;
        document.body.appendChild(helpModal);
        const closeButtonHelp = helpModal.querySelector('#close-reminders-map-help-instance');
        const closeHandlerHelp = () => {
            clearModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance');
            if (helpModal.parentNode) helpModal.parentNode.removeChild(helpModal);
        };
        closeButtonHelp.addEventListener('click', closeHandlerHelp);
        addModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance');
    }


    function showConfigModal() {
        const mapWasOpenBeforeConfig = isRemindersLocationMapActive;

        hideUnifiedReminderWindow();
        const otherModals = document.querySelectorAll('.choice-modal, .edit-modal, .edit-info-modal, .help-modal, .reminder-modal, .reminder-table-modal, #postpone-options-modal, .versions-modal-overlay, .saved-locations-modal, #reminders-location-map-modal, #reminders-map-help-modal-instance');
        otherModals.forEach(m => m.remove());

        const GAS_URL = 'AKfycbxrM-2kTU4irtHs-8wNEPteYpU7Jy7JWn2p92p8b1UQk-3P0e2bAAt0Z1qkHW025AF6qg';

        const modal = document.createElement('div');
        modal.id = 'config-modal';
        modal.setAttribute('aria-label','Configuración');

        const managedKeys = ['reminders','darkMode','toggleStates','zoomState','onOffState','noticesActive','footerVisible','teslaHtmlLastModified','teslaHtmlLastModifiedTimestamp','userData_userId','userData_teslaModel','userData_teslaYear','userData_teslaProvince','userData_allowDMs', 'customGridData', 'personalizationHelpShown', 'gridFilterValue', 'password_pin', 'password_active', 'lastUpdatesCheckDate', SAVED_LOCATIONS_KEY, SHOW_EXCLUDED_REMINDERS_KEY, 'boardinggate_saved_routes' ];
        const managedDesc = managedKeys.map(k => {
            switch(k){
                case 'reminders':return 'Recordatorios'; case 'darkMode':return 'Modo Oscuro'; case 'toggleStates':return 'Visibilidad Secc.';
                case 'zoomState':return 'Zoom Grid'; case 'onOffState':return 'On/Off Gral'; case 'noticesActive':return 'Avisos/Footer';
                case 'footerVisible':return 'Vis. Footer'; case 'teslaHtmlLastModified':return 'Cache Versión'; case 'teslaHtmlLastModifiedTimestamp':return 'TS Cache';
                case 'userData_userId':return 'ID Usuario'; case 'userData_teslaModel':return 'Modelo'; case 'userData_teslaYear':return 'Año';
                case 'userData_teslaProvince':return 'Provincia'; case 'userData_allowDMs':return 'Permitir DMs'; case 'customGridData': return 'Grid Pers.';
                case 'personalizationHelpShown': return 'Ayuda Pers. Vista'; case 'gridFilterValue': return 'Filtro Grid';
                case 'password_pin': return 'PIN Acceso'; case 'password_active': return 'PIN Activo'; case 'lastUpdatesCheckDate': return 'Cache Fecha Updates';
                case SAVED_LOCATIONS_KEY: return 'Ubicaciones Guardadas';
                case SHOW_EXCLUDED_REMINDERS_KEY: return 'Mostrar Excluidos Tabla';
                case 'boardinggate_saved_routes': return 'Rutas Guardadas';
                default:return k;
            }
        }).join(', ');

        modal.innerHTML = `
        <h2 style="flex-shrink:0;">Configuración y Datos</h2>
        <div class="tab-buttons" style="flex-shrink:0;">
            <button class="config-tab-button active" data-tab-target="#tab-content-usuario">Usuario</button>
            <button class="config-tab-button" data-tab-target="#tab-content-pin">Clave Acceso</button>
            <button class="config-tab-button" data-tab-target="#tab-content-radares">RADARES</button>
            <button class="config-tab-button" data-tab-target="#tab-content-backup-restore">Backup/Restore</button>
            <button class="config-tab-button" data-tab-target="#tab-content-borrar">Borrar Datos</button>
        </div>
        <div class="tab-contents">
            <div id="tab-content-usuario" class="config-tab-content active">
                <h3>Datos Compartidos (Opcional)</h3>
                <p style="font-size:.9rem;color:#555;margin-bottom:1.5rem;text-align:center;">Guardados en <a href="https://docs.google.com/spreadsheets/d/1-DiwTDrxpUrfYpa_yahHHqeOMYK0ny-KPdoLrDU3uYw/edit?usp=sharing" target="_blank" rel="noopener noreferrer" style="color:#1E40AF;">Hoja Cálculo</a>.</p>
                <div class="user-data-grid">
                    <div><label for="user-id">* ID Usuario (Apodo):</label><input type="text" id="user-id" name="userId" required></div>
                    <div><label for="tesla-model">Modelo Tesla:</label><input type="text" id="tesla-model" name="teslaModel"></div>
                    <div><label for="tesla-year">Año Modelo:</label><input type="number" id="tesla-year" name="teslaYear" min="2012" max="2099"></div>
                    <div><label for="tesla-province">Provincia:</label><input type="text" id="tesla-province" name="teslaProvince"></div>
                    <div class="checkbox-container"><input type="checkbox" id="allow-dms" name="allowDMs"><label for="allow-dms">Permitir MDs (vía admin)</label></div>
                </div>
                <div class="user-buttons-container">
                    <button id="config-save-user" style="background-color:#16A34A;color:white;">Guardar Datos</button>
                    <button id="config-reset-user" style="background-color:#D97706;color:white;">Resetear Reg.</button>
                </div>
                <p id="config-user-status" class="status-message"></p>
            </div>
             <div id="tab-content-pin" class="config-tab-content">
                 <h3>Clave de Acceso (Local)</h3>
                 <p style="font-size: 0.9rem; color: #555; margin-bottom: 1rem;">Establece una clave de 4 cifras para proteger el acceso inicial a la página. Se guarda sólo en tu navegador.</p>
                 <div class="pin-config-layout">
                     <div class="pin-input-group">
                         <label for="config-pin-set">Establecer/Cambiar Clave:</label>
                         <input type="password" id="config-pin-set" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="4 cifras">
                     </div>
                     <div class="pin-input-group">
                         <label for="config-pin-confirm">Confirmar Clave:</label>
                         <input type="password" id="config-pin-confirm" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="Repetir 4 cifras">
                     </div>
                     <div class="pin-buttons-container">
                         <button id="config-save-pin" style="background-color:#2563EB;color:white;">Guardar Clave</button>
                         <button id="config-remove-pin" style="background-color:#dc3545;color:white;">Quitar Clave</button>
                     </div>
                 </div>
                 <p id="config-pin-status" class="status-message"></p>
             </div>

             <div id="tab-content-radares" class="config-tab-content">
                <h3>Importar / Borrar Radares y Otros POIs</h3>
                <p style="font-size:0.85rem; color:#444; margin-bottom:0.5rem;">
                    Para <strong>importar</strong>, el filtro de "Palabras Clave" buscará coincidencias en el nombre del POI (ej: provincia, población, tipo).
                    Los filtros de Lat/Lon pueden ser un valor único (aprox.) o un rango (ej: "<code>40.1 40.5</code>" para buscar entre esas latitudes).
                </p>
                <p style="font-size:0.85rem; color:#444; margin-bottom:1rem;">
                    Los POIs importados (RADARES) se guardarán con un radio de <strong>400 metros</strong>.
                </p>
                <p style="font-size:0.85rem; color:#444; margin-bottom:1.5rem;">
                    Para <strong>borrar</strong>, se eliminarán los recordatorios de ubicación que cumplan TODOS los filtros activos (Lat, Lon, Palabras). Si un filtro está vacío, se ignora.
                </p>
                <div class="radar-filter-group">
                    <div>
                        <label for="radar-filter-lat">Latitud (valor o "min max"):</label>
                        <input type="text" id="radar-filter-lat" placeholder="Ej: 40.123 o 40.0 40.5">
                    </div>
                    <div>
                        <label for="radar-filter-lon">Longitud (valor o "min max"):</label>
                        <input type="text" id="radar-filter-lon" placeholder="Ej: -3.567 o -4.0 -3.0">
                    </div>
                    <div style="grid-column: span 2;">
                        <label for="radar-filter-keywords">Palabras Clave (en nombre POI, separadas por espacio):</label>
                        <input type="text" id="radar-filter-keywords" placeholder="Ej: FIJO CAMUFLADO MADRID">
                    </div>
                </div>
                <div class="radar-import-options">
                    <input type="checkbox" id="import-extra-radars-checkbox">
                    <label for="import-extra-radars-checkbox">Importar también radares móviles, semáforo, etc (sino, solo radares fijos y de tramo)</label>
                </div>
                <div class="radar-action-buttons">
                    <button id="import-radars-button">IMPORTAR RADARES y otros</button>
                    <button id="delete-filtered-radars-button">BORRAR CACHÉ (según filtro)</button>
                </div>
                <div id="radar-import-progress-container" style="display:none;">
                    <progress id="radar-import-progress-bar" value="0" max="100"></progress>
                    <p id="radar-import-status" class="status-message"></p>
                </div>
             </div>

            <div id="tab-content-backup-restore" class="config-tab-content">
                 <div style="background-color:#f7f9f7;padding:.8rem 1rem;border-radius:.25rem;margin-bottom:1.5rem;border:1px solid #ccc;">
                 <p style="font-size:.9rem;color:#555;margin:0;line-height:1.4;"><strong>Datos Incluidos:</strong> ${managedDesc}.<em style="font-size:.8rem;display:block;margin-top:.3rem;">(Backup TODO, Restore sólo compatibles).</em></p>
                </div>
                <div class="backup-restore-container">
                    <div>
                        <h3>Crear Backup</h3>
                        <p>Genera código. <strong style="color:#006400;">Guárdalo.</strong></p>
                        <button id="config-generate-backup" style="background-color:#2563EB;color:white;">Generar Backup</button>
                        <textarea id="config-backup-display" readonly style="display:none;"></textarea>
                        <p id="config-backup-status" class="status-message"></p>
                    </div>
                    <div>
                        <h3>Restaurar Copia</h3>
                        <p>Pega código. <strong style="color:blue;">Solo restaura compatibles</strong>.</p>
                        <textarea id="config-restore-input" placeholder="Pega aquí..."></textarea>
                        <button id="config-restore-backup" style="background-color:#10B981;color:white;">Restaurar</button>
                        <p id="config-restore-status" class="status-message"></p>
                    </div>
                </div>
            </div>
            <div id="tab-content-borrar" class="config-tab-content borrar-container">
                <h3>Borrar Datos Locales</h3>
                 <button id="config-restore-grid-button">RESTAURAR EL GRID ORIGINAL DE BOTONES</button>
                 <p id="config-restore-grid-status" class="status-message" style="margin-bottom: 1.5rem;"></p>

                <h3 style="border-top: 1px solid #ccc; padding-top: 1.5rem; margin-top:1.5rem;">Acción Irreversible</h3>
                <p>Elimina TODOS los datos locales.</p>
                <button id="config-clear-cache">Borrar TODO</button>
                <p><strong style="color:red;">¡Sin deshacer!</strong> Ten backup.</p>
            </div>
        </div>
        <div style="text-align:center;margin-top:1rem;flex-shrink:0;"><button id="config-close-modal">Cerrar</button></div>`;

        document.body.appendChild(modal);

        const tabBtns = modal.querySelectorAll('.config-tab-button');
        const tabConts = modal.querySelectorAll('.config-tab-content');
        const userIdI = modal.querySelector('#user-id');
        const modelI = modal.querySelector('#tesla-model');
        const yearI = modal.querySelector('#tesla-year');
        const provinceI = modal.querySelector('#tesla-province');
        const dmsChk = modal.querySelector('#allow-dms');
        const saveBtn = modal.querySelector('#config-save-user');
        const resetBtn = modal.querySelector('#config-reset-user');
        const userStat = modal.querySelector('#config-user-status');
        const genBkupBtn = modal.querySelector('#config-generate-backup');
        const bkupDisp = modal.querySelector('#config-backup-display');
        const restInp = modal.querySelector('#config-restore-input');
        const restBtn = modal.querySelector('#config-restore-backup');
        const clearBtn = modal.querySelector('#config-clear-cache');
        const closeBtn = modal.querySelector('#config-close-modal');
        const restoreGridBtn = modal.querySelector('#config-restore-grid-button');
        const restoreGridStatus = modal.querySelector('#config-restore-grid-status');
        const savePinBtn = modal.querySelector('#config-save-pin');
        const removePinBtn = modal.querySelector('#config-remove-pin');
        const pinSetInput = modal.querySelector('#config-pin-set');
        const pinConfirmInput = modal.querySelector('#config-pin-confirm');
        const pinStatus = modal.querySelector('#config-pin-status');

        const importRadarsButton = modal.querySelector('#import-radars-button');
        const deleteFilteredRadarsButton = modal.querySelector('#delete-filtered-radars-button');
        if (importRadarsButton) importRadarsButton.addEventListener('click', handleImportRadars);
        if (deleteFilteredRadarsButton) deleteFilteredRadarsButton.addEventListener('click', handleDeleteFilteredRadars);


        tabBtns.forEach(button => {
            button.addEventListener('click', () => {
                const tabTarget = button.dataset.tabTarget;
                tabBtns.forEach(btn => btn.classList.remove('active'));
                tabConts.forEach(content => content.classList.remove('active'));
                button.classList.add('active');
                modal.querySelector(tabTarget).classList.add('active');
            });
        });

        const loadUData = () => {
             userIdI.value = localStorage.getItem('userData_userId') || '';
             modelI.value = localStorage.getItem('userData_teslaModel') || '';
             yearI.value = localStorage.getItem('userData_teslaYear') || '';
             provinceI.value = localStorage.getItem('userData_teslaProvince') || '';
             dmsChk.checked = localStorage.getItem('userData_allowDMs') === 'true';
        };

        const callGAS = async (action, data = {}) => {
            if (!GAS_URL || GAS_URL === 'URL_DE_TU_GOOGLE_APPS_SCRIPT_WEB_APP') {
                 return { status:'error', message:'URL API no conf.' };
            }
            if(userStat)userStat.textContent='';
            setUserDataLoading(true);
            try {
                const resp = await fetch(GAS_URL, {
                     method:'POST', mode:'cors', cache:'no-cache',
                     headers:{'Content-Type':'application/json'},
                     redirect:'follow',
                     body:JSON.stringify({ action, ...data }),
                });
                let res;
                const ct = resp.headers.get("content-type");
                if(ct?.includes("application/json")) {
                    res = await resp.json();
                } else {
                    const txt = await resp.text();
                    try { res = JSON.parse(txt); }
                    catch (e) {
                        if (!resp.ok) throw new Error(`Server error (${resp.status}): ${txt.substring(0,200)}`);
                        res = { status:'success', message:'OK (non-JSON).' };
                    }
                }
                if (!resp.ok && res.status !== 'exists' && res.status !== 'not_found') {
                     throw new Error(res.message || `Server error (${resp.status})`);
                }
                return res;
            } catch (e) {
                return { status:'error', message: e.message || 'API Conn Error.' };
            } finally {
                setUserDataLoading(false);
            }
        };

        const setUserDataLoading = (isLoading)=> {
            [userIdI, modelI, yearI, provinceI, dmsChk, saveBtn, resetBtn, pinSetInput, pinConfirmInput, savePinBtn, removePinBtn].forEach(el => { if(el) el.disabled = isLoading; });
            if (saveBtn) saveBtn.style.opacity = isLoading?0.6:1;
            if (resetBtn) resetBtn.style.opacity = isLoading?0.6:1;
            if (savePinBtn) savePinBtn.style.opacity = isLoading?0.6:1;
            if (removePinBtn) removePinBtn.style.opacity = isLoading?0.6:1;
            if(isLoading && userStat) {
                 userStat.textContent = 'Procesando...';
                 userStat.style.color = '#1E40AF';
            } else if (userStat && userStat.textContent === 'Procesando...') {
                 userStat.textContent = '';
            }
        };

        saveBtn.addEventListener('click', async () => {
             const userId = userIdI.value.trim();
             const model = modelI.value.trim();
             const year = yearI.value.trim();
             const province = provinceI.value.trim();
             const allowDMs = dmsChk.checked;

             if (!userId) {
                 showToast('ID Usuario (Apodo) obligatorio.', 'warning', 4000);
                 if(userStat) { userStat.textContent = 'ID de Usuario es obligatorio.'; userStat.style.color = '#EF4444'; }
                 return;
             }

             const storedUserId = localStorage.getItem('userData_userId');
             let syncAttempted = false;
             let syncSuccess = false;
             let syncMessage = '';

             try {
                 localStorage.setItem('userData_userId', userId);
                 localStorage.setItem('userData_teslaModel', model);
                 localStorage.setItem('userData_teslaYear', year);
                 localStorage.setItem('userData_teslaProvince', province);
                 localStorage.setItem('userData_allowDMs', allowDMs.toString());
                 updateUserIdDisplay();
             }
             catch (e) {
                 showToast(`Error local: ${e.message}`, 'error', 5000);
                 if(userStat) { userStat.textContent = `Error local: ${e.message.substring(0, 100)}`; userStat.style.color = '#EF4444'; }
                 return;
             }

             let proceedRemoteSave = false;
             if(userStat)userStat.textContent='Sincronizando con servidor...';
             try {
                 if (!storedUserId || userId !== storedUserId) {
                     if(userStat)userStat.textContent='Validando ID en servidor...';
                     const chk = await callGAS('checkUserIdExists',{usuario:userId});
                     syncAttempted=true;
                     if(chk.status==='exists'){
                         syncMessage=`El ID "${userId}" ya existe. No se guardó remotamente.`;
                         showToast(syncMessage, 'error', 6000);
                         if(userStat) { userStat.textContent = syncMessage; userStat.style.color = '#EF4444'; }
                         return;
                     } else if(chk.status === 'not_found' || chk.status === 'success'){
                         if(storedUserId && userId !== storedUserId){
                             if(userStat) userStat.textContent='Eliminando registro antiguo...';
                             const delOld = await callGAS('deleteUserRow',{userId:storedUserId});
                             if(delOld.status !== 'success' && delOld.status !== 'not_found') {
                                 console.warn("Fallo al eliminar registro antiguo:", delOld.message);
                             }
                         }
                         proceedRemoteSave = true;
                     } else {
                         throw new Error(chk.message || "Error al validar ID.");
                     }
                 } else {
                     proceedRemoteSave = true;
                 }

                 if(proceedRemoteSave){
                     if(userStat) userStat.textContent = 'Guardando datos en servidor...';
                     const uData = {usuario: userId, modelo: model, anio: year, provincia: province, rss: allowDMs ? 'SI' : 'NO'};
                     const sav = await callGAS('addUserData', {userData: uData});
                     syncAttempted = true;
                     if(sav.status === 'success'){
                         syncSuccess = true;
                         syncMessage = 'Datos guardados local y remotamente.';
                         if(userStat) { userStat.textContent = 'Sincronización OK.'; userStat.style.color = '#28a745'; }
                     } else {
                         throw new Error(sav.message || "Error al guardar datos.");
                     }
                 }
             } catch (e) {
                 syncSuccess = false;
                 syncMessage = `Guardado local. Error sync: ${e.message}`;
                 if(userStat) { userStat.textContent = `Sync error: ${e.message.substring(0, 100)}`; userStat.style.color = '#ffc107'; }
             }
             finally {
                 if (syncAttempted) {
                     showToast(syncMessage, syncSuccess ? 'success' : (syncAttempted && !syncSuccess ? 'error' : 'warning'), syncSuccess ? 3000 : 6000);
                 } else {
                     showToast('Datos guardados localmente.', 'success', 3000);
                 }
                  if(userStat && (userStat.textContent === 'Procesando...' || userStat.textContent === 'Sincronizando con servidor...' || userStat.textContent === 'Validando ID en servidor...' || userStat.textContent === 'Eliminando registro antiguo...')) {
                       if (!syncAttempted || syncSuccess) {
                           userStat.textContent = 'Guardado local OK.';
                           userStat.style.color = '#28a745';
                       }
                  }
                 setUserDataLoading(false);
             }
        });

        resetBtn.addEventListener('click', async () => {
             const storedUserId = localStorage.getItem('userData_userId');
             if (!storedUserId) {
                 showToast('No hay registro local para resetear.', 'info', 3000);
                 if(userStat) { userStat.textContent = 'No hay registro local.'; userStat.style.color = '#17a2b8'; }
                 return;
             }
             if (!confirm(`¿Seguro resetear registro "${storedUserId}"?\nBorrará datos compartidos y locales.`)) {
                 showToast('Reseteo cancelado.', 'info', 2000);
                 if(userStat) { userStat.textContent = 'Reseteo cancelado.'; userStat.style.color = '#17a2b8'; }
                 return;
             }

             let remoteDeletionAttempted = false;
             let remoteDeletionSuccess = false;
             let remoteMessage = '';
             setUserDataLoading(true);

             if(userStat) userStat.textContent = `Eliminando remoto "${storedUserId}"...`;
             try {
                 const delRes = await callGAS('deleteUserRow', { userId: storedUserId });
                 remoteDeletionAttempted = true;
                 if (delRes.status === 'success') {
                     remoteDeletionSuccess = true;
                     remoteMessage = 'Registro remoto eliminado. ';
                     if(userStat) { userStat.textContent = 'Registro remoto eliminado.'; userStat.style.color = '#28a745'; }
                 } else if (delRes.status === 'not_found') {
                     remoteDeletionSuccess = true;
                     remoteMessage = 'Registro remoto no encontrado. ';
                     if(userStat) { userStat.textContent = 'Registro remoto no encontrado.'; userStat.style.color = '#ffc107'; }
                 } else {
                     remoteMessage = `Error eliminar remoto (${delRes.message || '?'}). `;
                     if(userStat) { userStat.textContent = `Error remoto: ${delRes.message.substring(0, 100)}`; userStat.style.color = '#EF4444'; }
                 }
             } catch (e) {
                 remoteMessage = `Error conexión eliminar remoto (${e.message}). `;
                 if(userStat) { userStat.textContent = `Error conexión: ${e.message.substring(0, 100)}`; userStat.style.color = '#EF4444'; }
             } finally {
                  if(!remoteDeletionAttempted && userStat) { userStat.textContent = ''; }
             }

             try {
                 localStorage.removeItem('userData_userId');
                 localStorage.removeItem('userData_teslaModel');
                 localStorage.removeItem('userData_teslaYear');
                 localStorage.removeItem('userData_teslaProvince');
                 localStorage.removeItem('userData_allowDMs');
                 userIdI.value=''; modelI.value=''; yearI.value=''; provinceI.value=''; dmsChk.checked=false;
                 updateUserIdDisplay();
                 showToast(`${remoteMessage}Datos locales reseteados.`, remoteDeletionSuccess ? 'success' : (remoteDeletionAttempted ? 'warning' : 'success'), 4000);
                 if(userStat && userStat.style.color !== '#EF4444') {
                      userStat.textContent = `Datos locales reseteados.`;
                      userStat.style.color = '#28a745';
                 }
             } catch (e) {
                 showToast(`${remoteMessage}Error al limpiar datos locales.`, 'error', 5000);
                 if(userStat) { userStat.textContent = `Error limpiar local: ${e.message.substring(0, 100)}`; userStat.style.color = '#EF4444'; }
             } finally {
                 setUserDataLoading(false);
             }
        });

        clearBtn.addEventListener('click', () => {
             if (confirm('¿Estás MUY SEGURO de borrar TODO el caché local?\n\n¡ACCIÓN IRREVERSIBLE!\nEliminará: Recordatorios, Ajustes UI, Datos Usuario, Grid Personalizado, PIN, Ubicaciones Guardadas, Rutas Guardadas.\n\nAsegúrate de tener Backup.')) {
                 const storedUserId = localStorage.getItem('userData_userId');
                 if (storedUserId) {
                     callGAS('deleteUserRow',{userId:storedUserId})
                         .then(r=>console.log("Remote deletion result (on clear all):",r))
                         .catch(e=>console.warn("Error remote deletion (on clear all):",e));
                 }
                 localStorage.clear();
                 sessionStorage.clear();
                 clearModalAutoCloseTimer(modal, closeBtn, 'config-modal');
                 if (modal.parentNode) modal.parentNode.removeChild(modal);
                 showToast('Datos borrados. Recargando...', 'info', 2000);
                 setTimeout(() => { location.reload(); }, 500);
             } else {
                 showToast('Borrado de caché cancelado.', 'info', 2000);
             }
        });

        restoreGridBtn.addEventListener('click', () => {
             if(restoreGridStatus) restoreGridStatus.textContent = '';
             if (confirm('¿Seguro restaurar grid original de botones?\nEliminará personalización de marcadores y asignación de botones.\nNO afecta recordatorios ni otros ajustes.')) {
                 try {
                     localStorage.removeItem('customGridData');
                     customData = { bookmarks: {}, toggles: {} };
                     if(restoreGridStatus) {
                          restoreGridStatus.textContent = 'Grid original restaurado. Recargando...';
                          restoreGridStatus.style.color = '#28a745';
                     }
                     showToast('Grid original restaurado. Recargando...', 'success', 2500);
                     clearModalAutoCloseTimer(modal, closeBtn, 'config-modal');
                     setTimeout(() => { location.reload(); }, 1500);
                 } catch (e) {
                     if(restoreGridStatus) {
                          restoreGridStatus.textContent = 'Error al restaurar.';
                          restoreGridStatus.style.color = '#EF4444';
                     }
                     showToast('Error al restaurar grid.', 'error', 4000);
                 }
             } else {
                 if(restoreGridStatus) {
                      restoreGridStatus.textContent = 'Restauración grid cancelada.';
                      restoreGridStatus.style.color = '#17a2b8';
                 }
                 showToast('Restauración grid cancelada.', 'info', 2000);
             }
        });

        genBkupBtn.addEventListener('click', () => {
             bkupDisp.value = '';
             bkupDisp.style.display = 'none';
             const backupData = {};
             let keysCount = 0;
             let skippedKeys = [];
             for (let i = 0; i < localStorage.length; i++) {
                 const key = localStorage.key(i);
                 if (key !== null) {
                     if (managedKeys.includes(key)) {
                         try {
                             backupData[key] = localStorage.getItem(key);
                             keysCount++;
                         } catch (e) {
                             skippedKeys.push(`${key}(err)`);
                         }
                     } else {
                         skippedKeys.push(key);
                     }
                 }
             }
             if (keysCount === 0) {
                 showToast('No hay datos locales para crear backup.', 'warning', 4000);
                 if(userStat) { userStat.textContent = 'No hay datos para backup.'; userStat.style.color = '#ffc107'; }
                 return;
             }
             try {
                 const jsonString = JSON.stringify(backupData, null, 2);
                 bkupDisp.value = jsonString;
                 bkupDisp.style.display = 'block';
                 bkupDisp.select();
                 let message = `Backup (${keysCount} claves) generado. Cópialo.`;
                 if(skippedKeys.length > 0) { message += ` (Ignoradas: ${skippedKeys.length})`; }
                 showToast(message, 'success', 5000);
                 if(userStat) { userStat.textContent = 'Backup generado OK.'; userStat.style.color = '#28a745'; }
             } catch (e) {
                 bkupDisp.value = `Error:\n${e.message}`;
                 bkupDisp.style.display = 'block';
                 showToast('Error al generar backup.', 'error', 5000);
                 if(userStat) { userStat.textContent = `Error backup: ${e.message.substring(0, 100)}`; userStat.style.color = '#EF4444'; }
             }
        });

        restBtn.addEventListener('click', () => {
             const jsonString = restInp.value.trim();
             if (!jsonString) {
                 showToast('Pega el código de backup.', 'warning', 4000);
                 if(userStat) { userStat.textContent = 'Pega el código.'; userStat.style.color = '#ffc107'; }
                 return;
             }
             try {
                 const restoredData = JSON.parse(jsonString);
                 if (typeof restoredData !== 'object' || restoredData === null || Array.isArray(restoredData)) {
                     throw new Error("Formato inválido.");
                 }
                 if (!confirm('¿Seguro restaurar datos?\nBorrará datos locales actuales y los reemplazará con los compatibles del backup.')) {
                     showToast('Restauración cancelada.', 'info', 2000);
                     if(userStat) { userStat.textContent = 'Restauración cancelada.'; userStat.style.color = '#17a2b8'; }
                     return;
                 }

                 managedKeys.forEach(key => localStorage.removeItem(key));
                 Object.keys(sessionStorage).forEach(key => {
                      if (key.startsWith('reminder_managed_') || key === 'personalizationHelpShown') {
                           sessionStorage.removeItem(key);
                      }
                 });


                 let restoredCount = 0;
                 let skippedKeys = [];
                 for (const key in restoredData) {
                     if (Object.hasOwnProperty.call(restoredData, key)) {
                         if (managedKeys.includes(key)) {
                             try {
                                 localStorage.setItem(key, restoredData[key]);
                                 restoredCount++;
                             } catch (e) {
                                 skippedKeys.push(`${key}(err)`);
                             }
                         } else {
                             skippedKeys.push(key);
                         }
                     }
                 }

                 let message = ''; let toastType = 'info';
                 if (restoredCount > 0) {
                     message = `Restauradas ${restoredCount} claves.`;
                     if (skippedKeys.length > 0) { message += ` Ignoradas ${skippedKeys.length}.`; }
                     message += ' Recargando...';
                     toastType = 'success';
                     clearModalAutoCloseTimer(modal, closeBtn, 'config-modal');
                     if (modal.parentNode) modal.parentNode.removeChild(modal);
                     showToast(message, toastType, 3000);
                     setTimeout(() => { location.reload(); }, 1800);
                 } else {
                     message = 'No se encontraron datos compatibles.';
                     if (skippedKeys.length > 0) { message += ` Ignoradas ${skippedKeys.length}.`; }
                     toastType = 'warning';
                     showToast(message, toastType, 5000);
                     if(userStat) { userStat.textContent = message.substring(0, 100); userStat.style.color = '#ffc107'; }
                 }

             } catch (e) {
                 showToast(`Error restaurar: ${e.message}`, 'error', 5000);
                 if(userStat) { userStat.textContent = `Error restaurar: ${e.message.substring(0, 100)}`; userStat.style.color = '#EF4444'; }
             }
        });

        if (savePinBtn) savePinBtn.addEventListener('click', savePinSettings);
        if (removePinBtn) removePinBtn.addEventListener('click', removePinSettings);

        const closeConfigHandler = () => {
            clearModalAutoCloseTimer(modal, closeBtn, 'config-modal');
            if (modal.parentNode) document.body.removeChild(modal);

            if (mapWasOpenBeforeConfig &&
                !document.getElementById('unified-reminder-window')?.classList.contains('visible') &&
                !document.getElementById('reminders-location-map-modal')) {
                showAllRemindersLocationMap();
            }
        };
        closeBtn.addEventListener('click', closeConfigHandler);
        addModalAutoCloseTimer(modal, closeBtn, 'config-modal', 200000);

        loadUData();
        const firstTabButton = modal.querySelector('.config-tab-button');
        if (firstTabButton) { firstTabButton.click(); }
    }

    function parseCoordinateFilter(inputValue) {
        const cleanedValue = inputValue.trim();
        if (!cleanedValue) return { type: 'empty' };

        const parts = cleanedValue.split(/\s+/).map(p => parseFloat(p));

        if (parts.some(isNaN)) return { type: 'error', message: 'Contiene valores no numéricos.' };

        if (parts.length === 1) {
            return { type: 'single', value: parts[0] };
        } else if (parts.length === 2) {
            return { type: 'range', min: Math.min(parts[0], parts[1]), max: Math.max(parts[0], parts[1]) };
        } else {
            return { type: 'error', message: 'Demasiados valores. Usar 1 o 2.' };
        }
    }

    async function handleImportRadars() {
        const importExtraCheckbox = document.getElementById('import-extra-radars-checkbox');
        const KML_FILES_LIST_STANDARD = './KLM/KLMFILES.TXT';
        const KML_FILES_LIST_EXTRA = './KLM/KLMFILES2.TXT';
        const KML_FILES_LIST_PATH = importExtraCheckbox.checked ? KML_FILES_LIST_EXTRA : KML_FILES_LIST_STANDARD;

        const KML_BASE_PATH = './KLM/';
        const COORD_EPSILON = 0.000001;

        const filterLatInput = document.getElementById('radar-filter-lat');
        const filterLonInput = document.getElementById('radar-filter-lon');
        const filterKeywordsInput = document.getElementById('radar-filter-keywords');
        const progressContainer = document.getElementById('radar-import-progress-container');
        const progressBar = document.getElementById('radar-import-progress-bar');
        const progressStatus = document.getElementById('radar-import-status');
        const isMobile = window.innerWidth < 768;

        const latFilterParsed = parseCoordinateFilter(filterLatInput.value);
        const lonFilterParsed = parseCoordinateFilter(filterLonInput.value);

        if (latFilterParsed.type === 'error') {
            if (!isMobile) showToast(`Error en filtro Latitud: ${latFilterParsed.message}`, "error");
            if (progressStatus) progressStatus.textContent = `Error en filtro Latitud: ${latFilterParsed.message}`;
            return;
        }
        if (lonFilterParsed.type === 'error') {
            if (!isMobile) showToast(`Error en filtro Longitud: ${lonFilterParsed.message}`, "error");
            if (progressStatus) progressStatus.textContent = `Error en filtro Longitud: ${lonFilterParsed.message}`;
            return;
        }

        const filterKeywordsRaw = filterKeywordsInput.value.trim();
        const filterKeywords = filterKeywordsRaw ? filterKeywordsRaw.toUpperCase().split(/\s+/).filter(k => k) : [];

        if (progressContainer) progressContainer.style.display = 'block';
        if (progressBar) { progressBar.value = 0; progressBar.max = 1; }
        if (progressStatus) progressStatus.textContent = 'Iniciando importación...';

        try {
            const response = await fetch(KML_FILES_LIST_PATH, { cache: 'no-cache' });
            if (!response.ok) {
                throw new Error(`No se pudo cargar ${KML_FILES_LIST_PATH}: ${response.statusText}`);
            }
            const fileListText = await response.text();
            const kmlFiles = fileListText.split('\n').map(f => f.trim()).filter(f => f && !f.startsWith('#'));

            if (kmlFiles.length === 0) {
                if (progressStatus) progressStatus.textContent = `No hay ficheros KML para importar en ${KML_FILES_LIST_PATH.split('/').pop()}.`;
                if (!isMobile) showToast(`No hay ficheros KML para importar en ${KML_FILES_LIST_PATH.split('/').pop()}.`, 'info');
                return;
            }

            if (progressBar) progressBar.max = kmlFiles.length;
            let totalImportedCount = 0;
            let existingReminders = JSON.parse(localStorage.getItem('reminders') || '[]');

            for (let i = 0; i < kmlFiles.length; i++) {
                const kmlFileName = kmlFiles[i];
                if (progressStatus) progressStatus.textContent = `Procesando fichero ${i + 1} de ${kmlFiles.length}: ${kmlFileName}...`;
                if (progressBar) progressBar.value = i + 1;
                await new Promise(resolve => setTimeout(resolve, 50));

                try {
                    const kmlResponse = await fetch(KML_BASE_PATH + kmlFileName, { cache: 'no-cache' });
                    if (!kmlResponse.ok) {
                        if (progressStatus) progressStatus.textContent += ` (Error carga: ${kmlResponse.statusText})`;
                        await sleep(1000); continue;
                    }
                    const kmlString = await kmlResponse.text();
                    const parser = new DOMParser();
                    const kmlDoc = parser.parseFromString(kmlString, "application/xml");

                    const placemarks = kmlDoc.getElementsByTagName('Placemark');
                    let fileRecordsFound = placemarks.length;
                    let fileImportedCount = 0;

                    for (let j = 0; j < placemarks.length; j++) {
                        const placemark = placemarks[j];
                        const nameElement = placemark.getElementsByTagName('name')[0];
                        const coordinatesElement = placemark.getElementsByTagName('coordinates')[0];

                        if (!nameElement || !coordinatesElement) continue;

                        const name = nameElement.textContent.trim();
                        const coordsString = coordinatesElement.textContent.trim();
                        const coordsParts = coordsString.split(',');
                        if (coordsParts.length < 2) continue;
                        const lon = parseFloat(coordsParts[0]);
                        const lat = parseFloat(coordsParts[1]);
                        if (isNaN(lat) || isNaN(lon)) continue;

                        let passesLatFilter = true;
                        if (latFilterParsed.type === 'single') {
                            passesLatFilter = Math.abs(lat - latFilterParsed.value) < 0.0001;
                        } else if (latFilterParsed.type === 'range') {
                            passesLatFilter = lat >= latFilterParsed.min && lat <= latFilterParsed.max;
                        }
                        if (!passesLatFilter) continue;

                        let passesLonFilter = true;
                        if (lonFilterParsed.type === 'single') {
                            passesLonFilter = Math.abs(lon - lonFilterParsed.value) < 0.0001;
                        } else if (lonFilterParsed.type === 'range') {
                            passesLonFilter = lon >= lonFilterParsed.min && lon <= lonFilterParsed.max;
                        }
                        if (!passesLonFilter) continue;

                        if (filterKeywords.length > 0) {
                            const nameUpper = name.toUpperCase();
                            if (!filterKeywords.some(kw => nameUpper.includes(kw))) {
                                continue;
                            }
                        }

                        const alreadyExists = existingReminders.some(r =>
                            r.isLocationEnabled && r.locationCoordinates &&
                            Math.abs(r.locationCoordinates.latitude - lat) < COORD_EPSILON &&
                            Math.abs(r.locationCoordinates.longitude - lon) < COORD_EPSILON
                        );
                        if (alreadyExists) continue;

                        const now = new Date();
                        const newRadarReminder = {
                            id: Date.now() + i * 10000 + j,
                            text: `<b>RADAR: ${name.toUpperCase()}</b>`,
                            type: 'simple',
                            time: '00:01',
                            date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                            createdAt: now.toISOString(),
                            managedByUser: false,
                            isLocationEnabled: true,
                            locationCoordinates: { latitude: lat, longitude: lon },
                            radiusMeters: 400,
                            excludeFromList: true
                        };
                        existingReminders.push(newRadarReminder);
                        fileImportedCount++;
                        totalImportedCount++;
                    }
                    if (progressStatus) {
                         progressStatus.textContent = `${kmlFileName}: Encontrados ${fileRecordsFound}. Importados ${fileImportedCount} nuevos.`;
                         if (progressBar) progressBar.value = i + 1;
                    }

                    if (fileImportedCount > 0 && !isMobile) showToast(`${kmlFileName}: ${fileImportedCount} nuevos radares importados.`, 'success');
                    await sleep(isMobile ? 500 : 200);

                } catch (fileError) {
                    if (progressStatus) progressStatus.textContent = `Error en ${kmlFileName}: ${fileError.message.substring(0,50)}`;
                    await sleep(1000);
                }
            }
            localStorage.setItem('reminders', JSON.stringify(existingReminders));
            if (progressBar) progressBar.value = kmlFiles.length;
            if (progressStatus) progressStatus.textContent = `Importación completada. Total importados: ${totalImportedCount} nuevos radares.`;
            if (!isMobile) showToast(`Proceso finalizado. ${totalImportedCount} radares nuevos añadidos.`, 'info');
            updateReminderCount();
            updateButtonStyles();

        } catch (error) {
            if (progressStatus) progressStatus.textContent = `Error: ${error.message}`;
            if (!isMobile) showToast(`Error en importación: ${error.message}`, 'error');
        }
    }

    async function handleDeleteFilteredRadars() {
        const filterLatInput = document.getElementById('radar-filter-lat');
        const filterLonInput = document.getElementById('radar-filter-lon');
        const filterKeywordsInput = document.getElementById('radar-filter-keywords');
        const progressStatus = document.getElementById('radar-import-status');
        const isMobile = window.innerWidth < 768;

        const latFilterParsed = parseCoordinateFilter(filterLatInput.value);
        const lonFilterParsed = parseCoordinateFilter(filterLonInput.value);

        if (latFilterParsed.type === 'error') {
            if (!isMobile) showToast(`Error en filtro Latitud: ${latFilterParsed.message}`, "error");
            if (progressStatus) progressStatus.textContent = `Error en filtro Latitud: ${latFilterParsed.message}`;
            return;
        }
        if (lonFilterParsed.type === 'error') {
            if (!isMobile) showToast(`Error en filtro Longitud: ${lonFilterParsed.message}`, "error");
            if (progressStatus) progressStatus.textContent = `Error en filtro Longitud: ${lonFilterParsed.message}`;
            return;
        }


        const filterKeywordsRaw = filterKeywordsInput.value.trim();
        const filterKeywords = filterKeywordsRaw ? filterKeywordsRaw.toUpperCase().split(/\s+/).filter(k => k) : [];

        const isAnyFilterActive = latFilterParsed.type !== 'empty' || lonFilterParsed.type !== 'empty' || filterKeywords.length > 0;

        if (!isAnyFilterActive) {
            if (!isMobile) showToast("Define al menos un filtro para borrar.", "warning");
            if(progressStatus) progressStatus.textContent = "Define al menos un filtro.";
            return;
        }

        if (!confirm("¿Seguro que quieres borrar los recordatorios de ubicación que coincidan con los filtros activos? Esta acción no se puede deshacer.")) {
            if (!isMobile) showToast("Borrado cancelado.", "info");
            if(progressStatus) progressStatus.textContent = "Borrado cancelado.";
            return;
        }

        if(progressStatus) progressStatus.textContent = "Buscando y borrando recordatorios...";

        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        let deletedCount = 0;

        const remindersToKeep = reminders.filter(reminder => {
            if (!reminder.isLocationEnabled || !reminder.locationCoordinates) {
                return true;
            }

            let matchesLat = latFilterParsed.type === 'empty';
            if (latFilterParsed.type === 'single') {
                matchesLat = Math.abs(reminder.locationCoordinates.latitude - latFilterParsed.value) < 0.0001;
            } else if (latFilterParsed.type === 'range') {
                matchesLat = reminder.locationCoordinates.latitude >= latFilterParsed.min && reminder.locationCoordinates.latitude <= latFilterParsed.max;
            }

            let matchesLon = lonFilterParsed.type === 'empty';
            if (lonFilterParsed.type === 'single') {
                matchesLon = Math.abs(reminder.locationCoordinates.longitude - lonFilterParsed.value) < 0.0001;
            } else if (lonFilterParsed.type === 'range') {
                matchesLon = reminder.locationCoordinates.longitude >= lonFilterParsed.min && reminder.locationCoordinates.longitude <= lonFilterParsed.max;
            }

            let matchesKeywords = filterKeywords.length === 0;
            if (filterKeywords.length > 0) {
                const reminderTextUpper = reminder.text.toUpperCase().replace(/<b>|<\/b>/gi,'');
                matchesKeywords = filterKeywords.some(kw => reminderTextUpper.includes(kw));
            }

            if (matchesLat && matchesLon && matchesKeywords) {
                deletedCount++;
                return false;
            }
            return true;
        });

        if (deletedCount > 0) {
            localStorage.setItem('reminders', JSON.stringify(remindersToKeep));
            if (!isMobile) showToast(`${deletedCount} recordatorios borrados.`, 'success');
            if(progressStatus) progressStatus.textContent = `${deletedCount} recordatorios borrados.`;
            updateReminderCount();
            updateButtonStyles();
            checkReminders();
        } else {
            if (!isMobile) showToast("No se encontraron recordatorios que coincidan con los filtros.", 'info');
            if(progressStatus) progressStatus.textContent = "No se encontraron coincidencias.";
        }
    }

    const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

    function showToast(message, type = 'info', duration = 3000) {
        const existingToast = document.getElementById('toast-notification-element');
        if (existingToast) { existingToast.remove(); }

        const toast = document.createElement('div');
        toast.id = 'toast-notification-element';
        toast.className = `toast-notification toast-${type}`;
        toast.textContent = message;
        document.body.appendChild(toast);

        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                toast.classList.add('show');
            });
        });

        setTimeout(() => {
            toast.classList.remove('show');
            toast.addEventListener('transitionend', () => {
                 if (toast.parentNode) { toast.parentNode.removeChild(toast); }
            }, { once: true });
        }, duration);
    }


    function formatDateToDDMMMYY(dateString) {
         if (!dateString) return '-';
         try {
             const [year, month, day] = dateString.split('-').map(Number);
             const date = new Date(Date.UTC(year, month - 1, day));
             if (isNaN(date.getTime())) return '-';

             const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
             const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
             const monthName = monthNames[date.getUTCMonth()];
             const yearShort = String(date.getUTCFullYear()).slice(-2);

             return `${dayOfMonth} ${monthName} ${yearShort}`;
         } catch (e) {
             return '-';
         }
    }
    function formatDateDetailed(dateString) {
        if (!dateString || !dateString.match(/^\d{4}-\d{2}-\d{2}$/)) return '-';
        try {
            const [year, month, day] = dateString.split('-').map(Number);
            const date = new Date(Date.UTC(year, month - 1, day));
            if (isNaN(date.getTime())) return dateString;

            const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
            const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
            const monthName = monthNames[date.getUTCMonth()];
            const fullYear = date.getUTCFullYear();

            return `${dayOfMonth}-${monthName}-${fullYear}`;
        } catch (e) {
            return dateString;
        }
    }
    function formatTimeWithPeriod(timeString) {
         if (!timeString || !timeString.match(/^\d{2}:\d{2}$/)) return '-';
         try {
             const [hourStr, minuteStr] = timeString.split(':');
             const hour = parseInt(hourStr);
             const minute = parseInt(minuteStr);
             if (isNaN(hour) || isNaN(minute) || hour < 0 || hour > 23 || minute < 0 || minute > 59) {
                 return timeString;
             }
             let period = '';
             if (hour >= 22 || hour < 5) { period = 'de la Noche'; }
             else if (hour >= 5 && hour < 12) { period = 'de la Mañana'; }
             else if (hour >= 12 && hour < 14) { period = 'del Mediodía'; }
             else { period = 'de la Tarde'; }

             return `${hourStr}:${minuteStr} (${period})`;
         } catch (e) {
             return timeString;
         }
    }

let globalModalTimers = {};

function addModalAutoCloseTimer(modalElement, closeButtonElement, modalId, duration = 60000) {
    if (!modalElement || !closeButtonElement || !modalId) {
        return;
    }
    modalElement.dataset.modalTimerId = modalId;

    clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId);

    let countdown = duration / 1000;
    const originalButtonText = closeButtonElement.textContent.split(' (')[0];
    const countdownSpanId = `modal-countdown-${modalId}`;
    let countdownSpan = closeButtonElement.querySelector(`.button-countdown-timer`);

    if (!countdownSpan) {
        countdownSpan = document.createElement('span');
        countdownSpan.className = 'button-countdown-timer';
        countdownSpan.style.marginLeft = '5px';
        countdownSpan.style.fontWeight = 'normal';
        closeButtonElement.appendChild(countdownSpan);
    }
    countdownSpan.textContent = ` (${countdown})`;

    const intervalId = setInterval(() => {
        countdown--;
        if (countdownSpan && document.body.contains(countdownSpan)) {
          countdownSpan.textContent = ` (${countdown})`;
        }
        if (countdown <= 0) {
            if (globalModalTimers[modalId]) {
                clearInterval(globalModalTimers[modalId].intervalId);
                delete globalModalTimers[modalId];
            }
            if (closeButtonElement && document.body.contains(closeButtonElement)) {
                closeButtonElement.click();
            } else if (modalElement && modalElement.parentNode) {
                modalElement.parentNode.removeChild(modalElement);
            }
        }
    }, 1000);

    const resetTimerHandler = () => {
        if (!globalModalTimers[modalId] || !globalModalTimers[modalId].intervalId) return;
        clearInterval(globalModalTimers[modalId].intervalId);
        countdown = duration / 1000;
        if (countdownSpan && document.body.contains(countdownSpan)) {
           countdownSpan.textContent = ` (${countdown})`;
        }
        const newIntervalId = setInterval(() => {
            countdown--;
            if (countdownSpan && document.body.contains(countdownSpan)) {
                countdownSpan.textContent = ` (${countdown})`;
            }
            if (countdown <= 0) {
                if (globalModalTimers[modalId]) {
                    clearInterval(globalModalTimers[modalId].intervalId);
                    delete globalModalTimers[modalId];
                }
                if (closeButtonElement && document.body.contains(closeButtonElement)) {
                    closeButtonElement.click();
                } else if (modalElement && modalElement.parentNode) {
                    modalElement.parentNode.removeChild(modalElement);
                }
            }
        }, 1000);
        globalModalTimers[modalId].intervalId = newIntervalId;
    };

    modalElement.addEventListener('click', resetTimerHandler);
    modalElement.addEventListener('touchstart', resetTimerHandler, { passive: true });
    modalElement.addEventListener('input', resetTimerHandler);
    modalElement.addEventListener('scroll', resetTimerHandler, { passive: true });

    globalModalTimers[modalId] = {
        intervalId: intervalId,
        resetHandler: resetTimerHandler,
        modalElement: modalElement,
        closeButtonElement: closeButtonElement,
        countdownSpan: countdownSpan
    };
}

function clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId) {
    const timerIdToClear = modalId || (modalElement ? modalElement.dataset.modalTimerId : null);

    if (timerIdToClear && globalModalTimers[timerIdToClear]) {
        clearInterval(globalModalTimers[timerIdToClear].intervalId);
        const timerData = globalModalTimers[timerIdToClear];
        if (timerData.modalElement && timerData.resetHandler) {
            timerData.modalElement.removeEventListener('click', timerData.resetHandler);
            timerData.modalElement.removeEventListener('touchstart', timerData.resetHandler);
            timerData.modalElement.removeEventListener('input', timerData.resetHandler);
            timerData.modalElement.removeEventListener('scroll', timerData.resetHandler);
        }
        if (timerData.countdownSpan && timerData.countdownSpan.parentNode) {
            timerData.countdownSpan.remove();
        }
        delete globalModalTimers[timerIdToClear];
    }
    if(closeButtonElement){
        const orphanSpans = closeButtonElement.querySelectorAll('.button-countdown-timer');
        orphanSpans.forEach(s => s.remove());
    }
     if(modalElement && modalElement.dataset.modalTimerId) {
        delete modalElement.dataset.modalTimerId;
    }
}

    async function initializeApp() {
        isRemindersLocationMapActive = false;
        renderGrid();
        createOtherButtons();
        renderToggleButtons();
        try { await updateVersion(); } catch (e) { console.error("Error updating version:", e); }
        loadSavedSettings();
        try { await loadNotices(); startNoticeRotation(); } catch (e) { console.error("Error loading notices:", e); }
        if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
        checkReminders();
        reminderCheckIntervalId = setInterval(checkReminders, currentCheckIntervalDuration);


        const noticeToggleIcon = document.getElementById('notice-toggle-icon');
        if (noticeToggleIcon) noticeToggleIcon.addEventListener('click', toggleNotices);

        const countEl = document.getElementById('reminder-count-globe');
        if (countEl) {
             const openTable = (e) => {
                 if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
                 e.preventDefault(); e.stopPropagation();
                 showAllReminders();
             };
             countEl.addEventListener('click', openTable);
             countEl.style.cursor = 'pointer';
        }

        const filterInput = document.getElementById('grid-filter-input');
        const clearButton = document.getElementById('clear-filter-button');
        if (filterInput) {
            filterInput.addEventListener('input', () => {
                 localStorage.setItem('gridFilterValue', filterInput.value);
                 filterGridItems();
                 if(isKeywordAssignmentMode) applyInitialKeywordHighlights();
            });
        }
        if (clearButton) {
            clearButton.addEventListener('click', () => {
                 if (filterInput) filterInput.value = '';
                 localStorage.removeItem('gridFilterValue');
                 filterGridItems();
                 if(isKeywordAssignmentMode) applyInitialKeywordHighlights();
            });
        }

        adjustButtonPositions();
        window.addEventListener('resize', adjustButtonPositions);
        checkVersionsIconOpacity();
    }

    document.addEventListener('DOMContentLoaded', async () => {
         loadCustomData();
         storedPin = localStorage.getItem('password_pin');
         const savedPasswordActive = localStorage.getItem('password_active');
         isPasswordActive = savedPasswordActive ? JSON.parse(savedPasswordActive) : false;

         if (isPasswordActive && storedPin) {
             promptForPin();
         } else {
             await initializeApp();
         }

         window.addEventListener('beforeunload', () => {
             if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
             if (locationWatchId !== null) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
             if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
             const openReminderModal = document.querySelector('.reminder-modal');
             if (openReminderModal && typeof openReminderModal.cleanUpModalTimers === 'function') { openReminderModal.cleanUpModalTimers(true); }

             Object.keys(globalModalTimers).forEach(modalId => {
                const timerData = globalModalTimers[modalId];
                if (timerData) {
                    clearModalAutoCloseTimer(timerData.modalElement, timerData.closeButtonElement, modalId);
                }
             });
             globalModalTimers = {};

             const openTableModal = document.querySelector('.reminder-table-modal');
             if(openTableModal && openTableModal.autoCloseInterval) { clearInterval(openTableModal.autoCloseInterval); }
             const openPostponeModal = document.getElementById('postpone-options-modal');
             if(openPostponeModal && openPostponeModal.autoPostponeInterval) { clearInterval(openPostponeModal.autoPostponeInterval); }
             const openSavedLocationsModal = document.querySelector('.saved-locations-modal');
             if (openSavedLocationsModal && locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
             const openAllLocationsMapModal = document.getElementById('reminders-location-map-modal');
             if (openAllLocationsMapModal && allLocationsMapInstance) {
                if (locationWatchId !== null) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
                try {allLocationsMapInstance.remove();} catch(e){}
                allLocationsMapInstance = null; initialUserLocationMarker = null; initialUserLocationMarkerLat = null; initialUserLocationMarkerLng = null;
                if (initialUserLocationCircle) { initialUserLocationCircle.remove(); initialUserLocationCircle = null; }
                orientationAltitudeControl = null;
             }


             if (isAssignmentMode || isEditMode || isKeywordAssignmentMode) { saveCustomData(); }

             const filterInput = document.getElementById('grid-filter-input');
             if (filterInput && filterInput.value.trim()) {
                  localStorage.setItem('gridFilterValue', filterInput.value);
             } else {
                  localStorage.removeItem('gridFilterValue');
             }
              saveSettings();

              if (reminderModalMap) try {reminderModalMap.remove();} catch(e){}
              Object.values(previewMaps).forEach(map => {try {map?.remove();} catch(e){}});
         });
    });

</script>
</body>
</html>