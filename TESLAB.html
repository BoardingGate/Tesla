.
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BoardingGate Lanzador</title>
    <link rel="icon" href="https://boardinggate.github.io/Tesla/th.jpeg" type="image/jpeg">
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module"> import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";import { getFirestore, doc, setDoc, getDoc, collection } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";console.log("Firebase Init Script: STARTING initialization."); const firebaseConfig = {apiKey: "AIzaSyCEAWL1Pj1OMBrGnXLOS79W3iDjMkmTQGw",authDomain: "boardinggate-1df74.firebaseapp.com",databaseURL: "https://boardinggate-1df74-default-rtdb.europe-west1.firebaseio.com",projectId: "boardinggate-1df74",storageBucket: "boardinggate-1df74.appspot.com", messagingSenderId: "771541345352",appId: "1:771541345352:web:0447d72b3383875ac5a47d" };try {const app = initializeApp(firebaseConfig);window.db = getFirestore(app);window.doc = doc;window.setDoc = setDoc;window.getDoc = getDoc;window.collection = collection; console.log("Firebase Init Script: SUCCESS Firestore initialized and functions exposed globally. window.db is:", window.db); } catch (e) {console.error("Firebase Init Script: ERROR during initialization!", e);} console.log("Firebase Init Script: END of initialization block."); </script>
    <script src="//cdn.jsdelivr.net/npm/eruda"></script>
    <script>eruda.init();</script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script src="https://unpkg.com/leaflet-geometryutil@0.10.3/src/leaflet.geometryutil.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    
    
<style>
    body { display: flex; flex-direction: column; min-height: 100vh; background-color: #ABAB99; margin: 0; overflow-x: hidden; }
    body.dark-mode { background-color: #92927E; }
    main { position: relative; margin: 0 auto 0.5rem 60px; margin-top: 76px; background-color: transparent; border-radius: 0.75rem; padding: 16px; min-height: 400px; max-width: 984px; width: 100%; transition: margin-top 0.5s ease-in-out; position: relative; }
    footer { margin: 0.5rem auto; text-align: center; max-width: 984px; width: 100%; display: block; background-color: #ABAB99; margin-left: 145px; transition: margin-top 0.5s ease-in-out; }
    body.dark-mode footer { background-color: #92927E; }
    .footer-content { color: #5C5C47; padding: 0.5rem; margin: 0 auto; max-width: 100%; position: relative; }
    .footer-subtext { font-size: 0.75rem; color: #5C5C47; margin-top: 0.25rem; text-align: center; }
    .footer-link-green { color: #5C5C47; text-decoration: none; transition: color 0.2s ease; }
    .footer-link-green:hover { color: #5C5C47; }
    .footer-line { display: flex; justify-content: center; align-items: center; gap: 0.5rem; flex-wrap: wrap; }
    .hidden { display: none !important; }
    .footer-hidden { display: none !important; }
    .header-container { display: flex; align-items: center; justify-content: center; gap: 0.5rem; background-color: #ABAB99; padding: 0.5rem; }
    body.dark-mode .header-container { background-color: #92927E; }
    .header-logo { width: 100px; height: 70px; transition: filter 0.2s ease; }
    body.dark-mode .header-logo { filter: brightness(85%); }
    .title-container { background-color: #ABAB99; padding: 0.5rem 1rem; border-radius: 0.5rem; display: inline-block; }
    body.dark-mode .title-container { background-color: #92927E; }
    .header-container h1 { color: #5C5C47; }
    .version-text { font-size: 0.75rem; color: #5C5C47; font-weight: normal; }
    #bookmark-grid { display: grid; grid-template-columns: repeat(6, minmax(120px, 1fr)); gap: 15px; background-color: transparent; border-radius: 0.75rem; position: relative; width: 100%; max-width: 984px; margin: 0 auto 0 85px; transition: all 0.3s ease; }
    #bookmark-grid > div { height: auto; aspect-ratio: 16 / 9; transition: all 0.3s ease; }
    .bookmark-item { width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; border-radius: 0.5rem; transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease; box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1); position: relative; cursor: pointer; }
    .bookmark-item:hover:not(.editing-active *):not(.assignment-active *):not(.dragging *):not(.editing-target *):not(.keyword-assignment-active *) { transform: scale(1.05) translateY(-1px); box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.6), -6px -6-12px rgba(255, 255, 255, 0.15); }
    .bookmark-item img { image-rendering: crisp-edges; width: 36px; height: auto; max-width: 40px; border-radius: 0.25rem; }
    .bookmark-name { font-size: clamp(0.85rem, 1.5vw, 1.15rem); font-weight: bold; color: #333; text-align: center; margin-top: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; }
    body.dark-mode .bookmark-item { filter: brightness(60%); }
    .empty-slot { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; border: 1px dashed #ccc; border-radius: 0.5rem; background-color: rgba(200, 200, 200, 0.1); color: #aaa; transition: background-color 0.2s ease, outline 0.2s ease, box-shadow 0.2s ease; cursor: default; }
    .empty-slot span { font-size: 2rem; pointer-events: none; }
    body.dark-mode .empty-slot { border-color: #666; color: #777; background-color: rgba(100, 100, 100, 0.2); }
    .toggle-image, .toggle-sign { width: 135px; height: 74px; margin-bottom: 2px; box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.4); border: 1px solid #7c7c68; left: 10px; z-index: 1000; transition: background-color 0.2s ease, filter 0.2s ease, top 0.3s ease, border 0.2s ease; border-radius: 35px; align-items: center; justify-content: center; cursor: pointer; display: flex; position: fixed; top: 90px; background-color: #ABAB99; }
    .toggle-sign { font-weight: bold; font-size: 1.25rem; color: #000000; text-align: center; }
    .toggle-sign .sign { font-size: 1.5rem; margin-right: 2px; }
    .toggle-sign img, .toggle-image img { max-width: 70%; max-height: 70%; object-fit: contain; }
    .toggle-sign:not(.range-toggle):not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *):hover { background-color: #D9A066; }
    .toggle-sign.range-toggle:not([data-state="hidden"]):not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *):hover { background-color: #D9A066; }
    .toggle-image:hover { filter: brightness(80%); }
    .toggle-sign.range-toggle[data-state="hidden"] { background-color: #ABAB99; color: #7F7F7F; }
    body.dark-mode .toggle-sign.range-toggle[data-state="hidden"] { background-color: #ABAB99; color: #A0A0A0; }
    body.dark-mode .toggle-sign:not(.range-toggle):not(#password-toggle-button), body.dark-mode .toggle-image, body.dark-mode .toggle-sign.range-toggle:not([data-state="hidden"]) { filter: brightness(85%); background-color: #ABAB99; }
    body.dark-mode .toggle-sign:not(.range-toggle):hover:not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *), body.dark-mode .toggle-sign.range-toggle:not([data-state="hidden"]):hover:not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *) { background-color: #ABAB99; }
    .scroll-toggle-button { position: fixed; width: 110px !important; height: clamp(75px, 20vw, 130px) !important; background-color: #ABAB99; border-radius: 60px; display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: clamp(10px, 2vw, 20px); cursor: pointer; box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.4) !important; border: 1px solid #808080 !important; z-index: 1001; transition: background-color 0.2s ease; left: 10px; top: 10px; }
    .scroll-toggle-button:hover { background-color: #668B8B; }
    .scroll-toggle-button svg { width: clamp(24px, 4vw, 32px); height: clamp(24px, 4vw, 32px); stroke: #E6E6DC; }
    .arrow-button { width: clamp(36px, 6vw, 48px); height: clamp(36px, 6vw, 48px); background-color: #668B8B; border-radius: 50%; display: flex; align-items: right; justify-content: center; cursor: pointer; box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3); transition: background-color 0.2s ease; }
    .arrow-button:hover { background-color: #5C5C47; }
    .arrow-button svg { stroke: #E6E6DC; }

    #config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button,
    #password-toggle-button, #versions-button, #info-button {
        width: auto !important;
        height: auto !important;
        background-color: transparent !important;
        border: none !important;
        box-shadow: none !important;
        padding: 5px !important;
        position: absolute !important;
        top: 37px !important;
        z-index: 900 !important;
        cursor: pointer;
        border-radius: 50%;
        transition: transform 0.1s ease, background-color 0.2s ease, box-shadow 0.2s ease, border 0.2s ease;
    }
    #config-button { left: 185px !important; }
    #personal-button { left: 260px !important; }
    #radar-button { left: 330px !important; }
    #home-button { left: 400px !important; }
    #reload-button { left: 470px !important; }
    #keyword-assignment-button { left: 555px !important; }

    #password-toggle-button { left: 1080px !important; top: 25px; }
    #info-button { left: 1027px !important;max-width: 30px !important; max-height: 30px !important; }
    #versions-button { left: 969px !important; max-width: 30px !important; max-height: 30px !important; }

    #config-button img { max-width: 52px !important; max-height: 52px !important; width: 52px; height: 52px; object-fit: contain; display: block; filter: none !important; }
    #personal-button img, #radar-button img, #home-button img, #reload-button img, #keyword-assignment-button img {
        max-width: 46px !important;
        max-height: 46px !important;
        width: 46px;
        height: 46px;
        object-fit: contain;
        display: block;
        filter: none !important;
    }
    #versions-button img, #info-button img, #password-toggle-button img { max-width: 53px !important; max-height: 40px !important; width: 40px; height: 40px; object-fit: contain; display: block; }
    #password-toggle-button img { filter: brightness(85%) !important; top: 25px; }
    #versions-button img { transition: opacity 0.5s ease; }

    #config-button:hover, #personal-button:hover, #radar-button:hover, #home-button:hover, #reload-button:hover, #keyword-assignment-button:hover:not(.active),
    #password-toggle-button:hover, #versions-button:hover:not(.versions-icon-dimmed), #info-button:hover {
        transform: scale(1.1);
        background-color: rgba(255, 255, 255, 0.2);
    }
    #personal-button.editing { border: 3px solid yellow !important; box-shadow: 0 0 10px yellow !important; }
    #personal-button.assigning { border: 3px solid cyan !important; box-shadow: 0 0 10px cyan !important; }

    #keyword-assignment-button.active {
        border: 3px solid yellow !important;
        box-shadow: 0 0 10px yellow !important;
        transform: scale(1.05);
        background-color: transparent !important;
    }
    body.dark-mode #keyword-assignment-button.active {
         border-color: yellow !important;
         box-shadow: 0 0 10px yellow !important;
    }
    .keyword-assignment-active .grid-cell:hover:not(.editing-active *):not(.assignment-active *):not(.dragging *):not(.editing-target *):not(.keyword-assigned-highlight) {
        transform: scale(1.05) translateY(-1px);
        box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.6), -6px -6-12px rgba(255, 255, 255, 0.15);
        outline: 3px dashed #10B981;
        cursor: crosshair;
    }
     .keyword-assignment-active .grid-cell.editing-target {
        outline: 3px solid #10B981 !important;
        outline-offset: 1px;
        box-shadow: 0 0 8px #10B981;
    }
    .keyword-assignment-active .grid-cell.keyword-assigned-highlight {
        outline: 3px solid yellow !important;
        outline-offset: 1px;
        box-shadow: 0 0 8px yellow;
        cursor: crosshair;
    }


    #grid-filter-container { position: absolute; top: 43px; left: 615px; display: flex; align-items: center; z-index: 900; }
    #grid-filter-input { padding: 8px 12px; border: 1px solid #7c7c68; border-radius: 4px; font-size: 1.3rem; font-weight: bold; height: 45px; width: 160px; background-color: #f0f0e0; }
    body.dark-mode #grid-filter-input { background-color: #a0a090; color: #e0e0e0; border-color: #666; }
    #clear-filter-button { background: none; border: none; cursor: pointer; padding: 0 8px; margin-left: -35px; font-size: 1.6rem; color: #555; height: 40px; line-height: 40px; z-index: 901; display: none; }
    body.dark-mode #clear-filter-button { color: #bbb; }
    #user-id-display { position: absolute; top: -25px; right: -69px; font-weight: bold; font-size: 1.1rem; color: #5C5C47; padding: 4px 4px; background-color: rgba(171, 171, 153, 0.7); border-radius: 1px; z-index: 800; white-space: nowrap; text-align: right; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4); }
    body.dark-mode #user-id-display { color: #E6E6DC; background-color: rgba(146, 146, 126, 0.7); opacity: 0.7; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6); }
    .notices-icon-container { display: flex; align-items: center; justify-content: center; width: 100%; max-width: 984px; margin: 0 auto; margin-left: 165px; position: relative; transition: margin-top 0.5s ease-in-out; }
    .notices-container { flex-grow: 1; padding: 0.5rem; border: none; border-radius: 0.5rem; overflow: hidden; display: flex; align-items: center; justify-content: center; gap: 0; margin-left: 2px; height: 3rem; }
    .notice-wrapper { padding: 0.5rem; height: 1.5rem; flex-grow: 1; overflow: hidden; position: relative; display: flex; align-items: center; justify-content: center; }
    .notice { color: #E6E6DC; font-size: 1.3rem; font-weight: bold; white-space: nowrap; text-align: center; opacity: 0; animation: fadeInOut 14s infinite; }
    @keyframes fadeInOut { 0% { opacity: 1; } 10% { opacity: 1; } 90% { opacity: 1; } 100% { opacity: 0; } }
    .notice-off-icon { width: auto; height: clamp(2rem, 5vw, 3rem); margin-right: 10px; align-self: center; cursor: pointer; transition: filter 0.3s ease; }
    body.dark-mode .notice-off-icon { filter: brightness(85%); }
    #reminder-button { display: flex; flex-direction: column; justify-content: center; align-items: center; position: fixed; background-color: #ABAB99; }
    #reminder-button img { object-fit: contain; }
    #reminder-button .reminder-count { position: absolute; top: 6px; left: 8px; background-color: #EF4444; color: #FFFFFF; border-radius: 55%; padding: 4px 10px; font-size: 1.1rem; font-weight: bold; line-height: 1; display: flex; align-items: center; justify-content: center; z-index: 1500; min-width: 1.9rem; max-width: 2.5rem; text-align: center; }
    .reminder-count-globe { position: fixed; top: 10px; left: 10px; background-color: #2563EB; color: white; border-radius: 65%; padding: 10px 15px; font-size: 1.3rem; font-weight: bold; z-index: 1500; transition: margin-top 0.5s ease-in-out; }

    #unified-reminder-window {
        position: fixed;
        top: 35px;
        left: 180px;
        transform: none;
        background-color: #FFFF99;
        border-radius: 1.5rem;
        border: 2px solid #ABAB99;
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        z-index: 7000 ;
        max-width: 550px;
        width: 95%;
        max-height: 85vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        transition: opacity 0.3s ease-out, transform 0.3s ease-out;
    }
    #unified-reminder-window:not(.visible) { opacity: 0; transform: scale(0.9); pointer-events: none; }
    #unified-reminder-window.visible { opacity: 1; transform: scale(1); pointer-events: auto; }
    .reminder-count-header { padding: 0.8rem 1.5rem; text-align: center; font-weight: bold; color: #0000FF; border-bottom: 1px solid #ABAB99; flex-shrink: 0; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 0px 10px; position: relative; }
    .reminder-title-container { display: flex; flex-direction: column; align-items: center; flex-grow: 1; }
    .reminder-title-container > span:first-child { font-size: 1.3rem; }
    .reminder-title-container .swipe-hint { font-size: smaller; }
    #reminder-swiper-container { display: flex; overflow-x: auto; scroll-snap-type: x mandatory; -webkit-overflow-scrolling: touch; scroll-behavior: smooth; flex-grow: 1; touch-action: pan-x; }
    .reminder-slide { flex: 0 0 100%; scroll-snap-align: start; padding: 1.5rem; box-sizing: border-box; display: flex; flex-direction: row; gap: 1rem; overflow-y: auto; align-items: flex-start; max-height: calc(85vh - 60px); }
    .reminder-slide-content { display: flex; flex-direction: column; flex-grow: 1; min-width: 0; }
    .reminder-slide .reminder-content-scrollable { max-height: 30vh; overflow-y: auto; margin-bottom: 1rem; word-wrap: break-word; overflow-wrap: break-word; text-align: left; padding-right: 5px; flex-grow: 1; }
    .reminder-slide .reminder-text { margin: 0 0 0.5rem 0; font-size: 1.6rem; font-weight: bold; color: #0000FF; }
    .reminder-slide .reminder-details { margin: 0.2rem 0; font-size: 1.15rem; font-weight: bold; color: #0000FF; }
    .reminder-slide .button-group { display: flex; flex-direction: column; justify-content: center; gap: 0.5rem; margin-top: auto; padding-top: 1rem; flex-shrink: 0; }
    .reminder-slide button { padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.9rem; width: 100%; background-color: #D1D5DB; }
    .reminder-slide button.cancel { background-color: #EF4444; color: #FFFFFF; font-weight: bold; height:70px; font-size: 1.2rem; order: 1; }
    .reminder-slide button.modify { background-color: #10B981; font-weight: bold; height:60px; font-size: 1.2rem; color: #FFFFFF; order: 5; }
    .reminder-slide button.postpone { background-color: #F59E0B; font-weight: bold; height:60px; font-size: 1.2rem; color: #FFFFFF; order: 3; }
    .reminder-slide button.adjust-time-0001 { background-color: #4F4F4F; color: #FFFFFF; font-weight: bold; height: 60px; font-size: 1.2rem; order: 2; margin-top: 0.5rem; }
    .reminder-slide button.cancel-cyclic { background-color: #8B0000; color: #FFFFFF; font-weight: bold; height: 60px; font-size: 1.2rem; order: 4; margin-top: 0.5rem; }
    .reminder-map-preview-container { flex-shrink: 0; width: 150px; display: flex; align-items: center; justify-content: center; align-self: stretch; }
    .reminder-map-preview { width: 100%; height: 100%; min-height: 100px; max-height: 25vh; border-radius: 0.5rem; }
    #hide-all-reminders-button { background: none; border: none; color: #0000FF; font-size: 1rem; font-weight: bold; cursor: pointer; padding: 0.2rem 0.5rem; position: absolute; right: 1rem; top: 50%; transform: translateY(-50%); z-index: 3001; }
    #hide-all-reminders-button:hover { text-decoration: underline; }

    .modal-top-buttons { display: flex; justify-content: space-between; gap: 1rem; margin-bottom: 1.5rem; flex-wrap: wrap; }
    .modal-top-buttons button { flex: 1 1 auto; min-width: 100px; background-color: #D1D5DB; }

    .reminder-modal, .help-modal, .edit-info-modal, .choice-modal, .edit-modal, .reminder-table-modal, .postpone-options, .saved-locations-modal, #reorder-stages-modal, #simulation-modal, #locations-preview-modal, #deviation-modal, #arrival-stats-modal, #simulation-speed-modal {
        z-index: 2000; background-color: #DAC8A0; padding: 1.0rem; border-radius: 0.3rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
    }
     
        #arrival-stats-modal {
        top: 5px;
        transform: translateX(-50%);
        z-index: 12000;
    }
     #arrival-stats-modal .eta-deviation { font-size: 2.1em; font-weight: bold; margin-left: 8px; vertical-align: middle; }
     #arrival-stats-modal .eta-deviation.positive { color: #EF4444; }
     #arrival-stats-modal .eta-deviation.negative { color: #013220; }

    #deviation-modal {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background-color: #E6D6A8; padding: 20px; border-radius: 10px;
        box-shadow: 0 0 15px rgba(0,0,0,0.5); z-index: 9000; text-align: center;
        max-width: 450px; width: 90%;
    }
    #deviation-modal p#deviation-modal-message { margin-bottom: 15px; font-size: 1.1rem; color: #333; }
    #deviation-modal button {
        padding: 10px 15px; margin: 0 5px; border-radius: 5px;
        font-size: 1rem; font-weight: bold; cursor: pointer; border: none;
    }
    #deviation-modal button#deviation-accept { background-color: #28a745; color: white; }
    #deviation-modal button#deviation-delete-stage { background-color: #EF4444; color: white; }


    #address-suggestions-modal {
        position: fixed;
        left: 5%;
        width: 90%;
        transform: none;
        background-color: #E6D6A8;
        padding: 1rem;
        border-radius: 0.5rem;
        box-shadow: 0 4px 10px rgba(0,0,0,0.25);
        z-index: 9000;
        display: flex;
        flex-direction: column;
        border: 1px solid #C0B080;
    }

    #address-suggestions-modal h2 {
        font-size: 1.1rem;
        font-weight: bold;
        text-align: center;
        margin-bottom: 0.75rem;
        color: #333;
    }

    #address-suggestions-list {
        list-style: none;
        padding: 0;
        margin: 0 0 0.75rem 0;
        overflow-y: auto;
        border: 1px solid #B0A898;
        border-radius: 4px;
        background-color: #D8CEC0;
    }

    #address-suggestions-list li {
        padding: 8px 12px;
        border-bottom: 1px solid #C8B890;
        cursor: pointer;
        font-size: 1.1rem;
        font-weight: bold;
        color: #F5F5DC;
        background-color: #5C5C47;
    }
    #address-suggestions-list li:last-child { border-bottom: none; }
    #address-suggestions-list li:hover { background-color: #6B6B56; }


    #locations-preview-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90vw;
        height: 90vh;
        max-width: none;
        max-height: none;
        display: flex;
        flex-direction: column;
        z-index: 7000;
    }
    #locations-preview-map-container { flex-grow: 1; border: 1px solid #ccc; border-radius: 0.5rem; margin-bottom: 1rem; }
    #locations-preview-modal h2 { font-size: 1.3rem; font-weight: bold; text-align: center; margin-bottom: 1rem; color: #333; }
    #close-locations-preview { padding: 0.7rem 1rem; font-size: 1.1rem; background-color: #4A5568; color: white; border: 1px solid #2D3748; border-radius: 5px; cursor: pointer; font-weight:bold; }
    #close-locations-preview:hover { background-color: #2D3748; }

    #address-suggestions-modal .modal-top-buttons button#close-address-suggestions-modal {
        background-color: #4A5568 !important; color: white !important;
        border: 1px solid #2D3748 !important; font-weight: bold !important;
    }
    #address-suggestions-modal .modal-top-buttons button#close-address-suggestions-modal:hover {
        background-color: #2D3748 !important;
    }

    #reorder-stages-modal {
        position: fixed !important;
        top: 30px !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        width: 80vw !important;
        height: 90vh !important;
        max-width: none !important;
        max-height: none !important;
        z-index: 8600 !important;
        display: flex;
        flex-direction: column;
        background-color: #DAC8A0;
    }
    #saved-routes-modal, #save-route-prompt-modal {
        position: fixed;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        width: 90%;
        z-index: 8600;
        max-height: calc(100vh - 20px);
        overflow-y: auto;
    }
     #simulation-modal {
        position: fixed;
        top: 10px;
        right: 40px;
        left: auto;
        transform: none;
        background-color: #E6D6A8;
        padding: 1.5rem;
        border-radius: 1rem;
        box-shadow: 0 6px 15px rgba(0,0,0,0.3);
        z-index: 8800;
        max-width: 450px;
        width: calc(100% - 80px);
        max-height: calc(100vh - 20px);
        display: flex;
        flex-direction: column;
    }

    #simulation-speed-modal {
        position: fixed;
        top: 50px;
        left: 50%;
        transform: translateX(-50%);
        width: 90%;
        max-width: 400px;
        z-index: 9100;
        background-color: #F5E1A9;
        padding: 1.5rem;
        border-radius: 1rem;
        box-shadow: 0 6px 15px rgba(0,0,0,0.3);
        text-align: center;
    }
    #simulation-speed-modal h2 { font-size: 1.2rem; font-weight: bold; margin-bottom: 1rem; color: #333; }
    #simulation-speed-modal input {
        width: 100px;
        padding: 0.5rem;
        margin-bottom: 1rem;
        font-size: 1.2rem;
        text-align: center;
        border: 1px solid #ccc;
        border-radius: 4px;
    }

    #reorder-stages-modal button { background-color: #D1D5DB; }
    #reorder-stages-modal #confirm-reorder-stages { background-color: #28a745; color: white; }
    #reorder-stages-modal #cancel-reorder-stages { background-color: #6c757d; color: white; }

    #saved-routes-modal { max-width: 500px; z-index: 8000; }
    #save-route-prompt-modal { max-width: 800px; z-index: 8500; }

    #simulation-modal #close-simulation-modal {
        background-color: #2563EB;
        color: white;
        position: absolute;
        top: 10px;
        left: 10px;
        height: 35px;
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
        min-height: unset;
        min-width: unset;
        width: auto;
        line-height: 1;
    }


    .postpone-options { background-color: #F5E1A9 !important; z-index: 7500 !important; top: 10px !important; transform: translateX(-50%) !important; }
    .versions-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; justify-content: center; align-items: flex-start; z-index: 5000; padding-top: 50px; }
    .versions-modal-content { background-color: #DAC8A0; padding: 1.5rem; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15); width: 85%; max-width: 900px; max-height: 85vh; overflow-y: auto; display: flex; flex-direction: column; }
    .versions-modal-content h2 { font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem; color: #111827; text-align: center; }
    .versions-modal-content .modal-top-buttons { margin-bottom: 1rem; }
    .versions-modal-content pre { white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; font-size: 1rem; line-height: 1.4; color: #333; margin-bottom: 1.5rem; padding: 0.8rem; background-color: #f0f0e0; border-radius: 0.25rem; max-height: calc(85vh - 150px); overflow-y: auto; }
    .versions-modal-content button { display: block; width: 100%; padding: 0.75rem 1rem; border-radius: 0.25rem; cursor: pointer; font-size: 1.1rem; text-align: center; border: none; background-color: #2563EB; color: white; }
    .versions-modal-content button:hover { background-color: #1D4ED8; }
    .reminder-modal { position: fixed; top: 1%; left: 50%; transform: translate(-50%, 0); max-width: 96%; width: 95%; max-height: 95vh; overflow-y: auto; font-weight: bold; font-size: 1.3rem; }
    .reminder-table-modal button.visto-prox { background-color: #EF4444; font-size: 0.9rem; color: #FFFFFF; border: 1px solid #A00000; font-weight:bold; }
    .reminder-table-modal button.visto-prox:hover { background-color: #D00000; }
    .help-modal, .edit-info-modal { position: fixed; top: 1%; left: 50%; transform: translate(-50%, 1%); max-width: 910px; width: 98%; max-height: 96vh; overflow-y: auto; font-size: 1.10rem; z-index: 5500; }
    #reminders-map-help-modal-instance { z-index: 7000 !important; top: 10px !important; transform: translateX(-50%) !important; }
    .choice-modal { position: fixed; top: 1%; left: 50%; transform: translate(-50%, 1%); max-width: 540px; width: 95%; max-height: 98vh; overflow-y: auto; font-size: 1.10rem; z-index: 5500; }
    .reminder-table-modal { position: fixed; top: 30px; left: 35px; transform: translateY(0); max-width: 99%; width: 1090px; max-height: 90vh; overflow-y: auto; background-color: #E6D6A8; border-radius: 1.5rem; }
    .reminder-table-modal h2 { font-size: 1.8rem !important; font-weight: bold !important; }
    .reminder-table-modal #view-all-locations-map { white-space: nowrap !important; }

    .edit-modal { position: fixed; top: 5%; left: 50%; transform: translate(-50%, 0); width: 75%; max-width: 900px; border: 5px solid #A0522D; background-color: #EADDCA; z-index: 6000; }
    .modal h2, .modal h3 { font-weight: bold; margin-bottom: 1rem; color: #111827; }
    .reminder-modal h2, .help-modal h2, .edit-info-modal h2, .choice-modal h2, .edit-modal h2, .saved-locations-modal h2, #reorder-stages-modal h2, #simulation-modal h2, #deviation-modal h2, #arrival-stats-modal h2, #simulation-speed-modal h2 { font-size: 1.5rem; }
    .reminder-modal label, .help-modal label, .edit-info-modal label, .choice-modal label, .edit-modal label, .saved-locations-modal label { display: block; margin-bottom: 0.25rem; font-weight: 500; color: #374151; font-size: 1.1rem; }
    .reminder-modal button, .help-modal button, .edit-info-modal button, .choice-modal button, .edit-modal button, .reminder-table-modal button, .versions-modal-content button, .saved-locations-modal button, #reorder-stages-modal button, #simulation-modal button, #address-suggestions-modal button, #deviation-modal button, #arrival-stats-modal button, #simulation-speed-modal button {
        padding: 0.75rem 1rem; border-radius: 0.25rem; cursor: pointer; font-size: 1.1rem;
        flex: 1; text-align: center; min-width: 100px; border: none;
        background-color: #D1D5DB;
        min-height: 60px;
    }
    .reminder-modal .modal-top-buttons button {
        height: 70px;
        min-height: 70px;
    }


    .edit-info-modal #close-edit-info, .help-modal #close-help, #reminders-map-help-modal-instance #close-reminders-map-help-instance, #simulation-modal #close-simulation-modal { background-color: #2563EB; color: white; }
    .edit-info-modal #close-edit-info:hover, .help-modal #close-help:hover, #reminders-map-help-modal-instance #close-reminders-map-help-instance:hover, #simulation-modal #close-simulation-modal:hover { background-color: #1D4ED8; }
    .reminder-modal textarea#reminder-text { width: 100%; padding: 0.5rem; margin-bottom: 0.3rem; border: 1px solid #D1D5DB; border-radius: 0.25rem; font-size: 1.4rem; font-weight: bold; text-transform: uppercase; }
    .reminder-modal input#reminder-time { max-width: 120px; width: auto; }
    .reminder-modal input#reminder-date { max-width: 160px; width: auto; }
    .reminder-modal input#reminder-interval { max-width: 100px; width: auto; }
    .reminder-modal input#reminder-radius { max-width: 120px; width: auto; }
    .reminder-modal input[type="text"], .reminder-modal input[type="number"] { padding: 0.5rem; margin-bottom: 0.3rem; border: 1px solid #D1D5DB; border-radius: 0.25rem; font-size: 1.5rem; text-align: center; }
    .reminder-modal .form-grid { display: grid; grid-template-columns: auto auto auto 1fr; gap: 1rem; align-items: end; margin-bottom: 1rem; }
    label[for="reminder-interval"] { line-height: 1.2; }
    .location-controls-group { grid-column: 4 / 5; display: flex; flex-wrap: wrap; align-items: center; justify-content: flex-start; gap: 0.5rem; margin-top: 0; }
    .location-controls-group label { margin-bottom: 0; }
    .location-controls-group input[type="checkbox"] { margin-right: 0.2rem; }
    .location-controls-group label[for="reminder-radius"] { margin-left: 0; }
    #expand-map-button { padding: 0.3rem 0.6rem !important; font-size: 1.3rem !important; height: auto !important; flex-shrink: 0; background-color: #668B8B !important; color: white !important; border: none !important; border-radius: 0.25rem !important; min-width: unset !important; flex: unset !important; margin-left: 0.5rem; }
    #expand-map-button:hover { background-color: #5C5C47 !important; }
    #location-map-container { grid-column: 1 / -1; width: 100%; border: 1px solid #ccc; border-radius: 0.25rem; background-color: #eee; position: relative; margin-top: 0.5rem; display: none; transition: height 0.3s ease-in-out; }
    #location-map-container.preview { display: block !important; height: 65px; }
    #location-map-container.expanded { display: block !important; height: 360px; }
    #reduce-map-button, #locate-me-button { position: absolute; top: 5px; z-index: 1001; padding: 0.8rem 1rem; font-size: 1rem; font-weight: bold; background-color: rgba(255, 255, 255, 0.9); border: 1px solid #777; border-radius: 4px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.25); transition: background-color 0.2s ease; }
    #reduce-map-button:hover, #locate-me-button:hover { background-color: rgba(230, 230, 230, 0.95); }
    #reduce-map-button { right: 5px; }
    #locate-me-button { right: calc(5px + 135px + 15px); }
    .reminder-modal .full-width { grid-column: 1 / -1; }
    .reminder-modal .days-group { display: flex; gap: 1rem; flex-wrap: wrap; grid-column: 1 / -1; margin-top: 1rem; }
    .reminder-modal .days-group label { font-size: 1.1rem; flex: 0 0 auto; }
    .reminder-modal button[type="submit"] { background-color: #2563EB; color: #FFFFFF; display: flex; align-items: center; justify-content: center; gap: 0.6rem; }
    .reminder-modal button[type="submit"] span#countdown-save { font-size: 1.6rem; font-weight: bold; justify-content: right; color: #e6e6dc; }
    .reminder-modal button[type="button"] { background-color: #D1D5DB; color: #111827; }

    #saved-routes-modal #close-saved-routes-modal,
    #config-modal #config-close-modal,
    #save-route-prompt-modal #cancel-save-route,
    #simulation-speed-modal #cancel-simulation-speed,
    .postpone-options #cancel-postpone {
        background-color: blue !important;
        color: white !important;
        border: 1px solid #2D3748 !important;
        font-weight: bold !important;
    }
    #saved-routes-modal #close-saved-routes-modal:hover,
    #config-modal #config-close-modal:hover,
    #save-route-prompt-modal #cancel-save-route:hover,
    #simulation-speed-modal #cancel-simulation-speed:hover,
    .postpone-options #cancel-postpone:hover {
         background-color: #2D3748 !important;
    }
    #simulation-speed-modal #confirm-simulation-speed {
        background-color: #28a745 !important;
        color: white !important;
    }


    .speech-button { background-color: #668B8B; color: white; border: none; border-radius: 0.25rem; padding: 0.5rem; cursor: pointer; margin-left: 0.5rem; font-size: 1rem; vertical-align: top; }
    .speech-button:hover { background-color: #5C5C47; }
    .speech-status { font-size: 0.85rem; color: #ABAB99; margin-top: 0.1rem; min-height: 1em; }
    #auto-save-timer { color: #1E40AF; grid-column: 1 / -1; text-align: center; }
    .reminder-table-modal table { width: 100%; border-collapse: collapse; margin-bottom: 1rem; }
    .reminder-table-modal tbody tr { cursor: pointer; transition: background-color: 0.1s ease; }
    .reminder-table-modal tbody tr:hover { background-color: rgba(0, 0, 0, 0.05) !important; }
    .reminder-table-modal th, .reminder-table-modal td { padding: 0.5rem; border: 1px solid #1E3A8A; font-size: 1.1rem; text-align: center; vertical-align: middle; }
    .reminder-table-modal td.text-column { text-align: left; }
    .reminder-table-modal th { background-color: #E5E7EB; font-weight: bold; }
    .reminder-table-modal td.date-column { white-space: nowrap; }
    .reminder-table-modal td:first-child { display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 0.5rem; padding: 0.5rem 0.3rem; border: none; }
    .reminder-table-modal td:first-child button { padding: 0.6rem; font-size: 0.9rem; width: 90%; flex: 0 0 auto; margin: 0; height: 60px; min-height: unset; line-height: 1.2; display: flex; align-items: center; justify-content: center; background-color: #D1D5DB; border: 1px solid #4A5568; }
    .reminder-table-modal button.modify { background-color: #10B981; font-size: 1rem; color: #FFFFFF; height: 60px; border: 1px solid #008000; font-weight:bold;}
    .reminder-table-modal button.modify:hover { background-color: #008000;}
    .reminder-table-modal button.delete { background-color: #EF4444; font-size: 0.9rem; color: #FFFFFF; border: 1px solid #A00000; font-weight:bold;}
    .reminder-table-modal button.delete:hover { background-color: #D00000;}
    .reminder-table-modal button.postpone { background-color: #F59E0B; font-size: 0.9rem; color: #FFFFFF; border: 1px solid #D97706; font-weight:bold;}
    .reminder-table-modal button.postpone:hover { background-color: #D97706;}
    .reminder-table-modal button.cancel-cyclic-table { background-color: #8B0000; font-size: 0.9rem; color: #FFFFFF; border: 1px solid #580000; font-weight:bold;}
    .reminder-table-modal button.cancel-cyclic-table:hover { background-color: #580000;}
    .reminder-table-modal #close-reminders-bottom, .reminder-table-modal #close-reminders-top { padding-left: 3rem; padding-right: 3rem; background-color: #2563EB; color: white; padding: 0.75rem 3rem; border-radius: 0.5rem; font-size: 1.25rem; font-weight: bold; border: 2px solid #1E3A8A; cursor: pointer; transition: background-color 0.2s ease; display: inline-flex; align-items: center; }
    .reminder-table-modal #close-reminders-bottom:hover, .reminder-table-modal #close-reminders-top:hover { background-color: #1D4ED8; }
    .reminder-table-modal .bottom-button-container { display: flex; justify-content: flex-end; margin-top: 1rem; }

    .choice-modal .personalization-options { display: flex; flex-direction: column; gap: 1rem; align-items: stretch; margin-bottom: 1.5rem; }
    .choice-modal .personalization-options button { font-weight: bold; width: 100%; background-color: #D1D5DB; }
    .choice-modal button.choice-edit { background-color: #ffc107; color: #333; }
    .choice-modal button.choice-assign { background-color: #17a2b8; color: white; }
    .choice-modal button.choice-help { background-color: #007bff; color: white; }
    .choice-modal button.choice-cancel { background-color: #6c757d; color: white; }
    .choice-modal .footer-buttons { display: flex; justify-content: center; gap: 1rem; margin-top: 1rem; }
    .choice-modal .footer-buttons button { flex: 0 1 auto; min-width: 120px; background-color: #D1D5DB; }
    .edit-modal h2 { font-size: 1.4rem; margin-bottom: 1rem; color: #333; font-weight: bold; text-align: center; }
    .edit-modal .modal-top-buttons { margin-bottom: 1.2rem; }
    .edit-modal label { display: block; margin-bottom: 0.3rem; font-weight: 500; color: #444; font-size: 1rem; }
    .edit-modal input[type="text"], .edit-modal input[type="url"] { width: 100%; padding: 0.6rem; margin-bottom: 0.8rem; border: 1px solid #BDB7AB; border-radius: 0.25rem; font-size: 1rem; }
    .edit-modal .input-with-button { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.8rem; }
    .edit-modal .input-with-button input { flex-grow: 1; margin-bottom: 0; }
    .edit-modal .search-button { padding: 0.4rem 0.6rem; font-size: 0.8rem; background-color: #668B8B; color: white; border: none; border-radius: 0.25rem; cursor: pointer; line-height: 1; height: fit-content; }
    .edit-modal .search-button:hover { background-color: #5C5C47; }
    .edit-modal button { padding: 0.7rem 1rem; font-size: 1.3rem; border-radius: 0.25rem; cursor: pointer; border: none; flex: 1 1 auto; min-width: 90px; background-color: #D1D5DB; }
    .edit-modal button.save { background-color: #28a745; color: white; } .edit-modal button.save:hover { background-color: #218838; }
    .edit-modal button.cancel { background-color: #6c757d; color: white; } .edit-modal button.cancel:hover { background-color: #5a6268; }
    .edit-modal button.reset { background-color: #ffc107; color: #333; } .edit-modal button.reset:hover { background-color: #e0a800; }
    .edit-modal button.empty { background-color: #fd7e14; color: white; } .edit-modal button.empty:hover { background-color: #e66b04; }
    .editing-active .bookmark-item:hover, .editing-active .range-toggle:hover, .editing-active .empty-slot:hover { transform: none; box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1); outline: 3px solid yellow; cursor: crosshair; }
    .editing-active .grid-cell.editing-target, .editing-active .range-toggle.editing-target { outline: 3px solid yellow !important; outline-offset: 1px; box-shadow: 0 0 8px yellow; }
    .editing-active .grid-cell { cursor: grab; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
    .editing-active .grid-cell:active { cursor: grabbing; }
    .grid-cell.dragging { opacity: 0.4; border: 2px dashed #aaa; cursor: grabbing; transform: scale(0.95); z-index: 10; }
    .grid-cell.drag-over { border: 3px solid #3498db !important; background-color: rgba(52, 152, 219, 0.1); box-shadow: inset 0 0 10px rgba(52, 152, 219, 0.3); }
    .editing-active .empty-slot { cursor: crosshair; }
    .empty-slot.drag-over { border: 3px solid #3498db !important; background-color: rgba(52, 152, 219, 0.2); }
    .empty-slot.dragging { opacity: 0.4; border: 2px dashed #aaa !important; cursor: grabbing; }
    .assignment-active .range-toggle.assigning-selected { outline: 4px solid cyan; box-shadow: 0 0 12px cyan; transform: scale(1.03); }
    .assignment-active .range-toggle:not(.assigning-selected) { opacity: 0.7; cursor: pointer; }
    .assignment-active .grid-cell.assigned-to-current { outline: 3px solid cyan; box-shadow: inset 0 0 8px rgba(0, 255, 255, 0.6); background-color: hsla(180, 70%, 80%, 0.3); opacity: 1; }
    .assignment-active .grid-cell:not(.assigned-to-current) { opacity: 0.6; outline: 1px dashed #aaa; }
    .assignment-active .grid-cell { cursor: pointer; }
    body.dark-mode .assignment-active .grid-cell.assigned-to-current { box-shadow: inset 0 0 10px rgba(0, 200, 200, 0.7); background-color: hsla(180, 60%, 30%, 0.4); }
    body.dark-mode .assignment-active .grid-cell:not(.assigned-to-current) { opacity: 0.5; outline-color: #555; }
    #pin-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; justify-content: center; align-items: flex-start; z-index: 9998; }
    #pin-modal-content { background-color: #DAC8A0; padding: 2rem; border-radius: 0.75rem; box-shadow: 0 5px 20px rgba(0,0,0,0.4); text-align: center; border: 1px solid #A0522D; margin-top: 50px; }
    #pin-modal-content h2 { font-size: 1.5rem; font-weight: bold; color: #333; margin-bottom: 1rem; }
    #pin-modal-content .modal-top-buttons { margin-bottom: 1.5rem; }
    #pin-modal-content label { display: block; font-size: 1.1rem; color: #444; margin-bottom: 0.8rem; }
    #pin-input { width: 150px; padding: 0.8rem; font-size: 1.8rem; text-align: center; border: 2px solid #A0522D; border-radius: 0.25rem; margin-bottom: 1.5rem; letter-spacing: 0.5em; background-color: #f0f0e0; }
    #pin-submit-button { padding: 0.8rem 2rem; font-size: 1.2rem; background-color: #28a745; color: white; border: none; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; }
    #pin-submit-button:hover { background-color: #218838; }
    #pin-error-message { color: #dc3545; font-weight: bold; margin-top: 1rem; min-height: 1.2em; }

    #config-modal { position: fixed; top: 15px; left: 50%; transform:translate(-50%, 0); background-color:#ECEFE8; padding:1.5rem; border-radius:.75rem; box-shadow:0 8px 16px rgba(0,0,0,.25); z-index:5000; max-width:1000px; width:95%; max-height: calc(63vh + 160px); display:flex; flex-direction:column; }
    #config-modal .modal-top-buttons { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
    #config-modal .modal-top-buttons h2 { margin-bottom: 0; }
    .config-tab-content{ max-height:calc(63vh + 130px - 160px); }
    .config-tab-button{padding:.7rem 1.2rem;cursor:pointer;border:1px solid #ccc;border-bottom:none;background-color:#e0e0d0;margin-right:.3rem;border-radius:.5rem .5rem 0 0;font-size:1rem;font-weight:500;color:#555;transition:background-color .2s ease,color .2s ease;outline:none;}
    .config-tab-button:hover{background-color:#d8d8c0;}
    .config-tab-button.active{background-color:#ECEFE8;border-color:#ccc;border-bottom:1px solid #ECEFE8;font-weight:bold;color:#2F4F4F;position:relative;top:1px;z-index:2;}
    .tab-buttons{margin-bottom:-1px;flex-shrink:0;border-bottom:1px solid #ccc;padding-left:1rem; display: flex; overflow-x: auto; }
    .tab-contents{flex-grow:1;overflow-y:auto;position:relative;z-index:1;border-top:none;min-height:200px;}
    .config-tab-content{display:none;padding:1.8rem;border:1px solid #ccc;border-top:none;border-radius:0 0 .5rem .5rem;background-color:#ECEFE8; }
    .config-tab-content.active{display:block;}
    #config-modal h2{font-size:1.6rem;margin-bottom:0;color:#2F4F4F;text-align:center;flex-shrink:0;}
    #config-modal h3{font-size:1.3rem;margin-bottom:.8rem;color:#4682B4;}
    #config-modal p,#config-modal label{font-size:1rem;line-height:1.5;color:#333;}#config-modal em{font-size:.85rem;}
    #config-modal button:not(.config-tab-button){font-size:1.05rem;padding:.8rem 1.5rem; background-color: #D1D5DB; }
    #config-modal textarea{font-size:.9rem;height:110px;width:100%;border:1px solid #ccc;border-radius:.25rem;padding:.5rem;resize:vertical;}
    #config-modal input[type=text],#config-modal input[type=number],#config-modal input[type=password]{font-size:1rem;padding:.6rem;width:100%;border:1px solid #ccc;border-radius:.25rem;}
    #config-modal .status-message{font-size:.9rem;min-height:1.1em;font-weight:500;text-align:center;margin-top:.5rem;}
    .user-data-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:1.2rem 1.8rem;align-items:start;margin-bottom:1rem;}
    .user-data-grid label{margin-bottom:.3rem;display:block;font-weight:500;}
    .user-data-grid .checkbox-container{grid-column:1 / -1;display:flex;align-items:center;gap:.5rem;justify-content:center;margin-top:.5rem;}
    .user-data-grid .checkbox-container input{width:1.2rem;height:1.2rem;}
    .user-data-grid .checkbox-container label{margin-bottom:0;}
    .user-buttons-container{display:flex;justify-content:space-around;gap:1.5rem;margin-top:1.5rem;margin-bottom:1rem;}
    .user-buttons-container button{border:none;border-radius:.25rem;cursor:pointer;flex-grow:1;}
    #config-user-status{min-height:1.2em;}
    .backup-restore-container{display:flex;gap:2.5rem;flex-wrap:wrap;}
    .backup-restore-container>div{flex:1;min-width:250px;}
    .backup-restore-container p{margin-bottom:1.2rem;}
    .backup-restore-container textarea{margin-bottom:1rem;background-color:#f9f9f9;}
    .backup-restore-container button{margin-bottom:1rem;border:none;border-radius:.25rem;cursor:pointer;width:100%;}
    #config-restore-grid-button{background-color:#E65100;color:black; margin-top: 10px;}
    #config-restore-grid-button:hover{background-color:#D84315;}
    .backup-restore-container .status-message{margin-top:.6rem;}
    .borrar-container h3{margin-bottom:.8rem;}
    .borrar-container p{margin-top:.6rem;}
    .borrar-container button{margin-top:1.5rem;border:none;border-radius:.25rem;cursor:pointer;width:100%;}
    .borrar-container button#config-clear-cache {background-color:#EF4444;color:white;}
    #config-close-modal-container { text-align:center; margin-top:1rem; flex-shrink:0; }
    #config-close-modal{font-size:1.15rem;padding:.8rem 2.5rem;background-color:#4A5568;color:white;border:1px solid #2D3748; font-weight:bold;}
    #config-close-modal:hover{ background-color: #2D3748; }
    .pin-config-section { border-top: 1px solid #ccc; margin-top: 2rem; padding-top: 1.5rem; }
    .pin-config-layout { display: grid; grid-template-columns: minmax(200px, 1fr) minmax(200px, 1fr); gap: 1rem 1.5rem; align-items: end; }
    .pin-config-layout .pin-input-group { grid-column: span 1; display: flex; flex-direction: column; }
    .pin-config-layout .pin-input-group label { margin-bottom: 0.3rem; }
    .pin-config-layout .pin-buttons-container { grid-column: 1 / 3; grid-row: 2; display: flex; justify-content: flex-start; gap: 1rem; margin-top: 0.5rem; }
    .pin-config-layout .pin-buttons-container button { flex-grow: 0; min-width: 120px; max-width: 180px; }
    #tab-content-pin .checkbox-container{grid-column:1 / -1;display:flex;align-items:center;gap:.5rem;justify-content:flex-start;margin-top:1.5rem; border-top: 1px solid #ccc; padding-top: 1rem;}
    #tab-content-pin .checkbox-container input{width:1.2rem;height:1.2rem;}
    #tab-content-pin .checkbox-container label{margin-bottom:0;}


    .toast-notification {
        position: fixed;
        top: 180px;
        right: 20px;
        transform: none;
        padding: 15px 30px;
        border-radius: 8px;
        color: white;
        font-size: 1.2rem;
        font-weight: bold;
        z-index: 9999;
        opacity: 0;
        transition: opacity 0.4s ease-in-out, top 0.4s ease-in-out;
        box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        text-align: center;
        min-width: 250px;
        max-width: 80%;
    }
    .toast-notification.show {
        opacity: 1;
    }
    .toast-success { background-color: #28a745; }
    .toast-error { background-color: #dc3545; }
    .toast-warning { background-color: #ffc107; color: #333; }
    .toast-info { background-color: #17a2b8; }
    .toast-debug {
        background-color: #663399;
        color: white;
        font-size: 0.9rem;
        text-align: left;
        max-width: 90%;
        white-space: pre-wrap;
        max-height: 80vh;
        overflow-y: auto;
        line-height: 1.3;
    }
    .toast-debug button {
        display: block;
        margin-top: 10px;
        padding: 5px 10px;
        background-color: rgba(255,255,255,0.2);
        color: white;
        border: 1px solid white;
        border-radius: 3px;
        cursor: pointer;
    }
    .toast-error.not-found {
        background-color: #a02020;
        border: 2px solid #ffdddd;
        font-size: 1.3rem;
        box-shadow: 0 8px 16px rgba(0,0,0,0.4);
    }


    .leaflet-container { cursor: default !important; }
    #location-map-container.expanded .leaflet-container,
    #location-picker-map-container.expanded .leaflet-container,
    #reminders-location-map-div #leaflet-map-actual-container .leaflet-container { cursor: crosshair !important; }

    #reminders-location-map-div.simulating-gps-click-mode #leaflet-map-actual-container .leaflet-container {
        cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="%23FF0000" stroke="white" stroke-width="1"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>') 14 28, crosshair !important;
    }

    #reminders-location-map-div.navigating #leaflet-map-actual-container .leaflet-container { cursor: default !important; }
    #reminders-location-map-div.add-reminder-mode #leaflet-map-actual-container .leaflet-container { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="%23008000" stroke="white" stroke-width="1"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle><line x1="12" y1="7" x2="12" y2="13"></line><line x1="9" y1="10" x2="15" y2="10"></line></svg>') 14 28, crosshair !important; }

    #location-map-container.expanded .leaflet-touch .leaflet-container,
    #location-picker-map-container.expanded .leaflet-touch .leaflet-container,
    #reminders-location-map-div #leaflet-map-actual-container .leaflet-touch .leaflet-container { cursor: pointer !important; }
    #reminders-location-map-div.navigating #leaflet-map-actual-container .leaflet-touch .leaflet-container { cursor: default !important; }
    #reminders-location-map-div.add-reminder-mode #leaflet-map-actual-container .leaflet-touch .leaflet-container { cursor: pointer !important; }

     .leaflet-top.leaflet-right .leaflet-control-layers {
        margin-top: 10px;
        margin-right: 10px;
    }
    .leaflet-control-layers {
        border-radius: 4px;
        box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        background-color: rgba(0,0,0,0.6) !important;
        color: white !important;
    }
    .leaflet-control-layers-expanded {
        max-height: 200px;
        overflow-y: auto;
        background-color: rgba(0,0,0,0.509) !important;
    }
     .leaflet-control-layers-selector {
        color: white !important;
    }
     .leaflet-control-layers-selector:hover {
        background-color: rgba(255,255,255,0.2) !important;
    }

    .leaflet-bottom.leaflet-left .leaflet-control-custom-map-controls {
        display: flex;
        align-items: flex-end;
        margin-bottom: 10px;
        margin-left: 10px;
    }


    #average-speed-display {
    color: #CBDDB5 !important; 
    }
    #max-speed-display {
        color: #FFA420 !important; 
        }

.leaflet-control-orientation-altitude {
    background-color: rgba(0,0,0,0.5);
    color: white;
    padding: 8px;
    border-radius: 3px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.40);
    text-align: center;
    height: auto;
    display: flex;
    flex-direction: column;
    justify-content: center;
    box-sizing: border-box;
    transform-origin: center;
    transform: scale(1.1);
    cursor: pointer;
    width: 115px; 
    min-width: 115px;
    flex-shrink: 0;                                   
}
    
    #compass-rose-icon {
        width: 55px;
        height: 57px;
        display: block;
        margin: 0 auto 2px auto;
        transition: transform 0.3s ease-out;
    }
    #orientation-text {
        display: block;
        font-size: 1.1em;
        font-weight: bold;
        line-height: 1.1;
        margin-bottom: 1px;
    }
    #altitude-display {
        display: block;
        font-size: 1.05em;
        line-height: 1.1;
    }
    #current-speed-display, #average-speed-display, #max-speed-display{
        display: block;
        font-size: 1.05em;
        line-height: 1.1;
        margin-top: 1px;
    }

    .leaflet-control-custom-map-controls {
        display: flex;
        align-items: flex-end;
        gap: 11px;
        z-index: 1001;
    }

#navigation-graph-card {
    width: 385px;
    min-height: 150px; 
    background-color: rgba(0, 0, 0, 0.50);
    color: white;
    border-radius: 5px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.45);
    z-index: auto;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    padding: 5px;
    position: relative; 
    transition: all 0.4s ease-in-out; 
    }

  #navigation-graph-card.enlarged {
    position: fixed; 
    background-color: rgba(0, 0, 0, 0.85); 
    z-index: 2000; 
    border: 1px solid #888;
    }  


/* Ajustes al contenedor del canvas cuando está ampliado */
#navigation-graph-card.enlarged #navigation-graph-container {
    flex-grow: 1; /* Permite que el canvas crezca */
}

/* El botón de ampliar/reducir */
#enlarge-graph-button {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 28px;
    height: 28px;
    cursor: pointer;
    z-index: 5; /* Para que esté sobre el canvas */
    opacity: 0.7;
    transition: opacity 0.2s;
}
#enlarge-graph-button:hover {
    opacity: 1;
}



    #navigation-graph-title {
    font-size: 1.1em;
    font-weight: bold;
    padding: 1px 5px; /* Añadimos un poco de padding lateral */
    color: #cb9a01;
    flex-shrink: 0;
    display: flex; /* CAMBIO: Habilitamos Flexbox */
    justify-content: space-between; /* CAMBIO: Separa los elementos a los extremos */
    align-items: center; /* CAMBIO: Los alinea verticalmente */
    width: 100%;
}

    
    
    #navigation-graph-container {
        width: 100%;
        flex-grow: 1;
        position: relative;
        min-height: 0;
    }
    #navigation-chart {
        display: block;
        width: 100%;
        height: 100%;
    }

    #reminders-location-map-div {
        position: relative;
        overflow: hidden;
    }
    #leaflet-map-actual-container {
        width: 100%;
        height: 100%;
        position: relative;
    }


    #location-map-container:not(.expanded) .leaflet-control-zoom,
    #location-picker-map-container:not(.expanded) .leaflet-control-zoom { display: none !important; }


    .saved-locations-modal { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); background-color: #E6D6A8; padding: 1.5rem; border-radius: 1rem; box-shadow: 0 6px 15px rgba(0,0,0,0.3); z-index: 3500; max-width: 700px; width: 95%; max-height: calc(100vh - 20px); display: flex; flex-direction: column; }
    .saved-locations-modal h2 { font-size: 1.5rem; font-weight: bold; text-align: center; margin-bottom: 1rem; color: #333; }
    .saved-locations-modal .modal-top-buttons { margin-bottom: 1rem; }
    .saved-locations-modal #saved-locations-list { max-height: calc(90vh - 200px - 50px); overflow-y: auto; margin-bottom: 1rem; padding-right: 5px;}
    .saved-locations-modal .location-slot { display: flex; align-items: center; margin-bottom: 0.75rem; gap: 0.5rem; }
    .saved-locations-modal .location-slot input[type="text"] { flex-grow: 1; padding: 0.5rem; border: 1px solid #ccc; border-radius: 0.25rem; font-size:1rem; }
    .saved-locations-modal .location-slot button.map-button { padding: 0.5rem 0.75rem; font-size: 0.9rem; background-color: #668B8B; color: white; border: none; border-radius: 0.25rem; cursor: pointer; flex-shrink:0; }
    .saved-locations-modal .location-slot button.map-button:hover { background-color: #5C5C47; }
    .saved-locations-modal .location-slot .coords-display { font-size: 0.8rem; color: #555; min-width: 120px; text-align: right; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .saved-locations-modal #save-all-user-locations { background-color: #2563EB; color: white; }
    .saved-locations-modal #close-saved-locations-modal { background-color: #D1D5DB; color: #111827; }
    .saved-locations-modal .location-slot button.select-location-button { padding: 0.5rem 0.75rem; font-size: 0.9rem; background-color: #34D399; color: white; border: none; border-radius: 0.25rem; cursor: pointer; flex-shrink:0; margin-left: 5px; }
    .saved-locations-modal .location-slot button.select-location-button:hover { background-color: #10B981; }

    #location-picker-map-container { height: 300px; border: 1px solid #ccc; position: relative; margin-top: 1rem; border-radius: 0.25rem; background-color: #eee; display: none; }
    #location-picker-map-container.expanded { display: block !important; }
    #location-picker-map-container button { padding: 0.5rem 0.8rem; font-size: 0.9rem; font-weight: bold; background-color: rgba(255, 255, 255, 0.9); border: 1px solid #777; border-radius: 4px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.25); position: absolute; z-index:1001; }
    #picker-ok-map-button { top:5px; right:5px; }
    #picker-locate-me-button { top:5px; right: calc(5px + 90px + 10px); }

    #reminders-location-map-modal { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: #D8D8D0; z-index: 6500; display: flex; flex-direction: column; padding: 2px; box-sizing: border-box; }
    #reminders-location-map-content-wrapper { background-color: #F0EFE4; width: 100%; height: 100%; border-radius: 0.75rem; box-shadow: 0 4px 15px rgba(0,0,0,0.2); display: flex; flex-direction: column; overflow: hidden; }
    #reminders-location-map-header { display: flex; flex-direction: column; padding: 0rem 0rem; border-bottom: 0px solid #D8D8D0; flex-shrink: 0; background-color: #D8D8D0; }
   
    reminders-location-map-header .button-row {
    height: 60px; /* Establece la altura fija que necesitan tus botones */
    min-height: 60px; /* Asegura que no se encoja */
    max-height: 60px; /* Asegura que no crezca */
    overflow: hidden; /* Oculta cualquier contenido que se desborde, evitando que empuje el layout */
    /* MANTÉN el resto de propiedades como display: flex, gap, etc. */
}


#search-row-map-header .reminders-map-button-action {
    height: 57px; /* Altura consistente para todos los botones de la fila */
}
#search-row-map-header {
    height: 57px !important;
    min-height: 57px !important;
    max-height: 57px !important;
    margin-bottom: 2px;
}
#search-row-map-header > #reorder-route-stages-button,
#search-row-map-header > #map-location-search-button,
#search-row-map-header > #clear-map-search-input-button,
#search-row-map-header > #map-location-search-input,
#search-row-map-header > #filter-input,
#search-row-map-header > #navigation-map-help-button {
    height: 57px !important;
}    
    
   #reminders-location-map-header .button-row {
    display: flex;
    gap: 10px;
    justify-content: flex-start; /* Alinea los botones al inicio */
    align-items: center;
    width: 100%;
    height: 60px; /* Altura fija para la primera fila */
    min-height: 60px;
    max-height: 60px;
    
    /* --- INICIO DE LA CORRECCIÓN --- */
    flex-wrap: nowrap;         /* Evita que los botones salten de línea */
    overflow-x: auto;          /* Permite el desplazamiento horizontal si es necesario */
    overflow-y: hidden;        /* Oculta cualquier barra de desplazamiento vertical */
    /* --- FIN DE LA CORRECCIÓN --- */
    
    transition: opacity 0.3s ease, visibility 0.3s ease, max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
}


    
    #reminders-location-map-header .button-row.hidden-map-header {
    opacity: 0;
    visibility: hidden;
    max-height: 0 !important;
    min-height: 0 !important; /* <-- ESTA ES LA LÍNEA CLAVE AÑADIDA */
    overflow: hidden !important;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    margin-bottom: 0 !important;
    border-bottom: none !important;
}
     #reminders-location-map-header .button-row:first-child {
        margin-bottom: 10px;
    }
    #reminders-location-map-header h2 { display: none; }
    #reminders-location-map-header .reminders-map-button-action {
        padding: 5px;
        font-size: 0.9rem;
        height: 60px;
        min-height: 60px;
        max-width: 90px;
        font-weight: bold;
        border-radius: 0.375rem;
        cursor: pointer;
        border: 1px solid #777;
        color: white;
        transition: background-color 0.2s ease, opacity 0.2s ease;
        box-shadow: 2px 5px 4px rgba(0,0,0,0.65);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        flex-shrink: 0;
        white-space: nowrap;
        background-color: white !important;
        min-width: 59px;
        margin-bottom: 5px;
    }
     #reminders-location-map-header .reminders-map-button-action img,
     #reminders-location-map-header .reminders-map-button-action svg {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }
    #reminders-location-map-header .reminders-map-button-action:hover { opacity: 0.88; }

    #toggle-map-header-buttons-panel {
        position: fixed;
        left: 15px;
        top: 50%;
        transform: translateY(-50%);
        width: calc(100px);
        height: calc(100px);
        background-color: rgba(100, 100, 100, 0.45);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 1010;
        box-shadow: 1px 1px 3px rgba(0,0,0,0.45);
        touch-action: none;
    }
    #toggle-map-header-buttons-panel img {
        width: 60%;
        height: 60%;
        object-fit: contain;
    }


    #load-route-button, #save-route-button { background-color: #0000CD !important; }
    #navigation-map-help-button { background-color: #4A5568 !important; box-shadow: 2px 2px 5px rgba(0,0,0,0.50); }

    #add-reminder-at-location-button {
        background-color: #FFA500 !important;
        width: 59px;
        height: 60px;
        padding: 5px;
        gap: 0;
    }
    #add-reminder-at-location-button.active-reminder-mode {
        background-color: #EF4444 !important;
    }
     #add-reminder-at-location-button svg {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }

    .radares-ruta-control {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0.3rem 0.6rem;
        background-color: rgba(200,200,180,0.7);
        border-radius: 5px;
        height: 60px;
        min-width: 70px;
        box-sizing: border-box;
        gap: 4px;
    }
    #radares-ruta-checkbox {
        margin-right: 0px;
        margin-bottom: 0px;
        transform: scale(1.1);
    }
    .radares-ruta-label-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }
    #radares-ruta-checkbox + .radares-ruta-label-container > label {
        font-weight: bold;
        font-size: 0.85rem;
        color: #333;
        cursor:pointer;
        text-align: center;
        line-height: 1.1;
        margin-bottom: 1px;
    }
    #radares-ruta-count {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
        background-color: #6600a1;
        color: white;
        border-radius: 50%;
        font-size: 0.75rem;
        font-weight: bold;
        line-height: 1;
        margin-top: 2px;
    }

    .tareas-ruta-control {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0.3rem 0.6rem;
        background-color: rgba(200,200,180,0.7);
        border-radius: 5px;
        height: 60px;
        min-width: 70px;
        box-sizing: border-box;
        gap: 4px;
    }
    #tareas-ruta-checkbox {
        margin-right: 0px;
        margin-bottom: 0px;
        transform: scale(1.1);
    }
    .tareas-ruta-label-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }
    #tareas-ruta-checkbox + .tareas-ruta-label-container > label {
        font-weight: bold;
        font-size: 0.85rem;
        color: #333;
        cursor:pointer;
        text-align: center;
        line-height: 1.1;
        margin-bottom: 1px;
    }
    #tareas-ruta-count {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
        background-color: #008f39;
        color: white;
        border-radius: 50%;
        font-size: 0.75rem;
        font-weight: bold;
        line-height: 1;
        margin-top: 2px;
    }


    #reorder-route-stages-button {
        height: 60px;
        width: 59px;
        border: 1px solid #777;
        box-shadow: 2px 3px 5px rgba(0,0,0,0.70);
        padding: 2px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 0.9rem;
        font-weight: bold;
        color: white;
        border-radius: 4px;
        cursor: pointer;
        flex-shrink: 0;
        white-space: nowrap;
        background-color: white !important;
        margin-right: 4px;
    }
    #reorder-route-stages-button img {
        max-height: 90%;
        max-width: 90%;
        object-fit: contain;
    }



    #map-location-search-button {
        height: 60px;
        width: 59px;
        border: 1px solid #777;
        box-shadow: 2px 3px 5px rgba(0,0,0,0.70);
        padding: 3px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 0.9rem;
        font-weight: bold;
        color: white;
        border-radius: 4px;
        cursor: pointer;
        flex-shrink: 0;
        white-space: nowrap;
        background-color: white !important;
        margin-left: 2px;
    }
    #map-location-search-button img {
        max-height: 90%;
        max-width: 90%;
        object-fit: contain;
    }


#map-location-search-input { /* El campo de búsqueda principal del mapa */
    flex-grow: 1; /* Permite que este campo se expanda */
    padding: 8px 12px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background-color: #fff;
    min-width: 120px; /* Ancho mínimo para el campo de búsqueda principal del mapa */
    height: 60px;
    font-weight: bold;
    text-transform: uppercase;
    font-size: 1.1rem;
    box-sizing: border-box; /* Incluir padding y border en el tamaño total */
    /* NO TIENE MARGEN A LA DERECHA, el siguiente elemento se pega a él */
}
#map-location-search-input::placeholder {
    color: #CDCDCD;
    opacity: 1;
}
#filter-input { /* EL NUEVO CAMPO DE FILTRO (para el mapa), A CONTINUACIÓN DEL DE BÚSQUEDA */
    width: 200px; 
    font-size: 0.9rem; /* Tamaño de letra más pequeño */
    padding: 8px 5px; /* Menor padding para que quepa la fuente más pequeña */
    margin-left: 2px; /* Pequeño espacio para separarlo del campo de búsqueda */
    border: 1px solid #7c7c68;
    border-radius: 4px;
    font-weight: bold;
    height: 60px; /* Misma altura que el campo principal del mapa */
    background-color: #f0f0e0;
    box-sizing: border-box;
}
#filter-input::placeholder {
    color: #CDCDCD;
    opacity: 1;
}



    
    #map-location-search-input::-webkit-input-placeholder { color: #CDCDCD; }
    #map-location-search-input::-moz-placeholder { color: #CDCDCD; opacity: 1; }
    #map-location-search-input:-ms-input-placeholder { color: #CDCDCD; }
    #map-location-search-input::-ms-input-placeholder { color: #CDCDCD; }

    body.dark-mode #map-location-search-input {
        background-color: #a0a090;
        color: #e0e0e0;
        border-color: #666;
    }
    body.dark-mode #map-location-search-input::placeholder {
        color: #A0A0A0;
    }

    #clear-map-search-input-button {
        height: 60px !important;
        width: 50px !important;
        background-color: #e0e0e0;
        border: 1px solid #ccc;
        box-shadow: 2px 3px 5px rgba(0,0,0,0.70);
        border-radius: 4px;
        cursor: pointer;
        flex-shrink: 0;
        padding: 0;
        z-index: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-left: 2px;
    }
    #clear-map-search-input-button svg {
        width: 60%;
        height: 60%;
        stroke: red;
        stroke-width: 3;
    }
    body.dark-mode #clear-map-search-input-button {
        background-color: #555;
        border-color: #444;
    }
    body.dark-mode #clear-map-search-input-button svg {
        stroke: #ff6666;
    }

    #toggle-simulate-gps-button {
        background-color: #DAA520 !important;
        width: 59px; height: 60px; padding: 5px !important;
    }
    #toggle-simulate-gps-button.active-simulate-gps-mode {
        background-color: #B22222 !important;
        box-shadow: 0 0 8px #FF4500;
    }
    #toggle-simulate-gps-button img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }

    #simulate-route-button {
        padding: 5px;
    }
    #simulate-route-button img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }

    #view-all-locations-map { padding: 0.75rem 1.2rem; font-size: 1.1rem; font-weight: bold; border-radius: 0.5rem; cursor: pointer; border: 2px solid #506C6C; color: white; background-color: #668B8B; margin-left: 10px; transition: background-color 0.2s ease; display: inline-flex; align-items: center; justify-content: center; height: auto; min-height: 46px; white-space: nowrap; }
    #view-all-locations-map:hover { background-color: #5C7A7A; }

    #reminders-location-map-div { flex-grow: 1; background-color: #E0E0E0; position:relative; overflow: hidden; }
    #leaflet-map-actual-container { width: 100%; height: 100%; position: relative; }

    #map-info-overlay {
    position: absolute;
    top: 10px;
    right: 90px;
    left: auto;
    transform: none;
    z-index: 1002;
    background: rgba(0,0,0,0.1);
    color: white;
    padding: 8px 15px;
    border-radius: 8px;
    font-size: 0.8em;
    font-weight: bold;
    text-align: right;
    display: none;
    /* CAMBIO: Un ancho máximo fijo o un porcentaje más restrictivo para controlar el tamaño */
    max-width: 55%;
    /* CAMBIO: Evita que el texto salte de línea */
    white-space: nowrap;
    /* CAMBIO: Oculta el texto que se desborda del contenedor */
    overflow: hidden;
    /* CAMBIO: Muestra "..." cuando el texto se desborda */
    text-overflow: ellipsis;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    line-height: 1.3;
}
    #map-info-overlay span {

    }


    #tab-content-radares .radar-filter-group { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem; align-items: end; }
    #tab-content-radares .radar-filter-group label { margin-bottom: 0.25rem; font-weight: 500; font-size: 0.9rem; }
    #tab-content-radares .radar-filter-group input { padding: 0.5rem; font-size: 1rem; border: 1px solid #ccc; border-radius: 0.25rem; }
    #tab-content-radares .radar-import-options { margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem; }
    #tab-content-radares .radar-import-options input[type=checkbox] { width: 1.1rem; height: 1.1rem; }
    #tab-content-radares .radar-import-options label { margin-bottom: 0; font-size: 0.9rem; }
    #tab-content-radares .radar-action-buttons { display: flex; justify-content: space-around; gap: 1rem; margin-top: 1rem; margin-bottom: 1.5rem; }
    #tab-content-radares .radar-action-buttons button { flex: 1; padding: 0.8rem 1rem; font-size: 1.1rem; border-radius: 0.3rem; background-color: #D1D5DB; }
    #import-radars-button, #delete-filtered-radars-button { background-color: #F59E0B !important; color: white !important; border: 1px solid #D97706 !important; }
    #import-radars-button:hover, #delete-filtered-radars-button:hover { background-color: #D97706 !important; }

    #radar-import-progress-container { margin-top: 1rem; padding: 0.8rem; border: 1px solid #ccc; border-radius: 0.25rem; background-color: #f9f9f9; }
    #radar-import-progress-bar { width: 100%; height: 20px; margin-bottom: 0.5rem; }
    #radar-import-status { font-size: 0.9rem; color: #333; min-height: 1.2em; text-align: center; }

    .navigation-waypoint-marker { display: flex; align-items: center; justify-content: center; border-radius: 50%; color: white; font-weight: bold; text-align: center; box-shadow: 0 0 3px rgba(0,0,0,0.5); opacity: 0.85; position: relative; }
    .navigation-waypoint-marker.start-point { background-color: rgba(0, 128, 0, 0.80); }
    .navigation-waypoint-marker.finish-point { background-color: rgba(0, 0, 255, 0.80); }
    .navigation-waypoint-marker.intermediate-point { background-color: rgba(230, 140, 0, 0.80); }

    .waypoint-delete-button { position: absolute; background-color: rgba(255, 0, 0, 0.85); color: white; border-radius: 50%; text-align: center; cursor: pointer; border: 1px solid white; z-index: 10; }

    #navigation-bottom-progress-bar {
        position: absolute;
        top: 10px;
        left: 10px;
        transform: none;
        width: auto;
        max-width: 500px;
        min-width: 480px;
        background-color: rgba(0, 0, 0, 0.6);
        padding: 8px;
        border-radius: 5px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        z-index: 1001;
        color: white;
        display: none;
    }
    #navigation-top-info-bar {
        margin-bottom: 8px;
        font-size: 1.2em;
        display: flex;
        align-items: center;
        position: relative;
        cursor: pointer;
    }
    #navigation-bottom-progress-bar hr {
        border: none;
        border-top: 1px solid rgba(229, 209, 193, 0.5);
        margin: 10px 0;
    }

    #turn-icon-container-styled {
        position: relative;
        background-color: white;
        padding: 5px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 48px;
        height: 48px;
        box-sizing: border-box;
        z-index: 1;
        flex-shrink: 0;
        margin-right: 8px;
    }
    #navigation-top-info-bar .turn-icon-display .leaflet-routing-icon {
        width: 24px !important;
        height: 24px !important;
        background-size: 288px 24px !important;
        background-position-x: var(--bg-pos-x, 0);
        background-position-y: var(--bg-pos-y, 0);
        display: block;
        margin: auto;
        transform: none !important;
    }

    #navigation-top-info-bar .turn-icon-display img {
        width: 95% !important;
        height: 95% !important;
        background-size: contain;
        background-position: center;
        display: block;
        margin: auto;
        object-fit: contain;
    }


    #navigation-top-info-bar .maneuver-text-container {
        flex-grow: 1;
        text-align: center;

        max-width: calc(100% - 60px);
    }
    #navigation-top-info-bar .maneuver-text,
    #navigation-top-info-bar .street-name {
        font-weight: bold;
        color: white;
        text-shadow:
           -1px -1px 0 #000000,
            1px -1px 0 #000000,
           -1px  1px 0 #000000,
            1px  1px 0 #000000;
        white-space: normal;
        word-wrap: break-word;
        overflow-wrap: break-word;
        line-height: 1.3;
    }
    #navigation-top-info-bar .maneuver-text {
        font-size: 1em;
        margin-right: 8px;
        display: inline;
    }
    #navigation-top-info-bar .street-name {
        font-size: 1em;
        display: inline;
    }


    #distance-to-turn-formatted {
        text-align: center;
        font-weight: bold;
        font-size: 1.5em;
        margin-top: 4px;
    }

    #distance-progress-bar-to-turn-container { width: 100%; height: 7px; background-color: #e0e0e0; border-radius: 4px; margin-top: 5px; overflow: hidden; }
    
    #distance-progress-bar-to-turn {
    width: 100%; 
    height: 100%;
    background: linear-gradient(to right, 
        #680000  0%,   
        #FF0000 50%,  
        #FA8072 97%  
    );
    border-radius: 4px;
    transition: width 0.3s linear; 
}
    #route-overall-progress-container {
        width: 100%;
        height: 18px;
        background-color: #e0e0e0;
        border-radius: 9px;
        margin-bottom: 9px;
        position: relative;
        overflow: visible;
    }

    #route-overall-progress {
        width: 0%;
        height: 100%;
        z-index: 3;
        background-color: #4CAF50;
        background: linear-gradient(to right, 
        #006600 30%,  
        #258D19 92%,  
        #b4ff9a 99%                                                                
    );
        border-radius: 9px;
        transition: width 0.5s linear;
        position: relative;
    }
    
    .radar-marker-on-progress-bar {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 0;
    height: 0;
    z-index: 1; 
    border-left: 11px solid transparent;   
    border-right: 11px solid transparent;  
    border-bottom: 14px solid white;     
}

.radar-marker-on-progress-bar::after { 
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    z-index: 2; 
    border-left: 9px solid transparent;
    border-right: 9px solid transparent;
    border-bottom: 12px solid #8A36D2; 
    
    top: 1px;   
    left: -9px;
}

.task-marker-on-progress-bar {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 0;
    height: 0;
    z-index: 1; 
    border-left: 11px solid transparent;   
    border-right: 11px solid transparent;
    border-bottom: 14px solid white;      
}

.task-marker-on-progress-bar::after { 
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    z-index: 2; 
    border-left: 9px solid transparent;
    border-right: 9px solid transparent;
    border-bottom: 12px solid #608414; 
    top: 1px;
    left: -9px; 
}    

    #route-progress-icon {
        position: absolute;
        height: 100%;
        width: auto;
        max-height: 18px;
        left: 100%;
        top: 50%;
        transform: translate(-50%, -50%);
        z-index: 4;
        display: none;
    }

     #route-progress-text {
        position: absolute;
        text-align: left;
        top: 50%;
        left: 10px;
        transform: translateY(-50%);
        font-family: 'Arial', 'Helvetica Neue', Helvetica, sans-serif; 
        font-weight: bold;        
        color: yellow; 
        -webkit-text-stroke-width: 2px; 
        -webkit-text-stroke-color: #006400; 
        paint-order: stroke fill; 
        font-size: clamp(0.8em, 3vw, 0.9em); 
        line-height: 1;
        pointer-events: none;
        z-index: 3;
        background-color: transparent; 
        padding: 2px; 
        white-space: nowrap;
    }

    .waypoint-dot-on-progress-bar { position: absolute; top: 50%; transform: translateY(-50%); width: 13px; height: 13px; background-color: #3498db; border-radius: 50%; border: 1px solid white; z-index: 2; }
    
    #navigation-eta-info { display: flex; justify-content: space-between; margin-top: 6px; font-size: 1em; }
    #navigation-eta-info.single-destination { justify-content: center; }
    #navigation-eta-info > div { flex-basis: 48%; text-align: center; }
    #final-destination-info.single-destination-layout { text-align: center; flex-basis: auto !important; }
    #final-destination-info.single-destination-layout strong { font-size: 0.7em !important; }
    #final-destination-info.single-destination-layout span { font-size: 1.1em !important; }
    #navigation-eta-info strong { display: block; font-size: 0.7em; margin-bottom: 2px; }
    #navigation-eta-info span { font-size: 1.1em; font-weight: bold; }
    #next-stage-info { display: block; }
    #navigation-eta-info #next-stage-distance, #navigation-eta-info #final-destination-distance { margin-right: 3px; }
    #navigation-eta-info #next-stage-time, #navigation-eta-info #final-destination-time { margin-left: 3px; margin-right: 3px; }
    #navigation-eta-info #next-stage-eta, #navigation-eta-info #final-destination-eta { margin-left: 3px; }
    .eta-deviation { font-size: 0.9em !important; font-weight: bold; margin-left: 6px !important; }
    .eta-deviation.positive { color: #FF7C39; }
    .eta-deviation.negative { color: #10B981; }

#next-stage-info .eta-deviation {
    font-size: 0.9em !important;
    font-weight: bold;
    margin-left: 6px;
}

#final-destination-info .eta-deviation {
    font-size: 0.9em !important;
    font-weight: bold;
    margin-left: 6px;
}


    #simulation-modal .modal-top-buttons { margin-bottom: 1rem; }
    #simulation-content-area {
        overflow-y: auto;
        margin-bottom: 1rem;
        padding: 0.5rem;
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 0.5rem;
        min-height: 150px;
        font-size: 0.9rem;
        line-height: 1.4;
        flex-grow: 1;
    }
    #simulation-content-area ul {
        list-style-type: none;
        padding-left: 0;
    }
    #simulation-content-area li {
        padding: 0.3rem 0;
        border-bottom: 1px solid #eee;
        display: flex;
        align-items: center;
    }
    #simulation-content-area li:last-child {
        border-bottom: none;
    }
    #simulation-modal .turn-icon-sim {
        margin-right: 8px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
        flex-shrink: 0;
        vertical-align: middle;
    }
    #simulation-modal .turn-icon-sim .leaflet-routing-icon {
        width: 24px !important;
        height: 24px !important;
        background-size: 288px 24px !important;
        transform: none !important;
        display: block;
        object-fit: contain;
        background-position-x: var(--bg-pos-x, 0);
        background-position-y: var(--bg-pos-y, 0);
    }
    #simulation-modal .turn-icon-sim img {
        width: 24px !important;
        height: 24px !important;
        object-fit: contain;
    }


    #saved-routes-modal { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); background-color: #E6D6A8; padding: 1.5rem; border-radius: 1rem; box-shadow: 0 6px 15px rgba(0,0,0,0.3); z-index: 8000; max-width: 750px; width: 95%; max-height: calc(100vh - 10px); display: flex; flex-direction: column; }
    #saved-routes-modal h2 { font-size: 1.3rem; font-weight: bold; text-align: center; margin-bottom: 1rem; color: #333; }
    #saved-routes-modal .modal-top-buttons { margin-bottom: 1rem; display: flex; justify-content: flex-start; align-items: center; }
    #saved-routes-modal #close-saved-routes-modal {
        background-color: #C0392B !important;
        color: white !important;
        border: 1px solid #A93226 !important;
        padding: 0.9rem 1.8rem !important;
        font-size: 1.15rem !important;
        font-weight: bold !important;
        border-radius: 0.3rem;
        min-width: 130px;
        flex-grow: 0;
        flex-shrink: 0;
        flex-basis: flex-start ;
    }
    #saved-routes-modal #close-saved-routes-modal:hover {
        background-color: #A93226 !important;
    }

    #saved-routes-modal .filter-container { display: flex; margin-bottom: 1rem; gap: 5px; }
    #saved-routes-modal input#filter-saved-routes {
        flex-grow: 1;
        padding: 8px 12px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 1.5rem;
        font-weight: bold !important;
        text-transform: uppercase !important;
    }
    #saved-routes-modal button#clear-filter-saved-routes {
        padding: 8px 12px;
        background-color: #e0e0e0;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
        color: #EF4444;
        font-weight: bold;
        font-size: 1.5rem;
        line-height: 1;
    }

    #saved-routes-list { list-style: none; padding: 0; margin: 0 0 1rem 0; max-height: calc(60vh - 80px - 50px); overflow-y: auto; border: 1px solid #A9A18C; border-radius: 5px; background-color: #D3CBB8; }
    #saved-routes-list li { padding: 10px 15px; border-bottom: 1px solid #ddd; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 1.1rem; font-weight: bold; background-color: #F5F5DC; }
    #saved-routes-list li:last-child { border-bottom: none; }
    #saved-routes-list li:hover { background-color: #FFD700; }
    #saved-routes-list .delete-route-btn { background-color: #ef4444; color: white; border: none; border-radius: 3px; padding: 3px 7px; font-size: 0.8rem; cursor: pointer; }

    #save-route-prompt-modal {
        position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
        background-color: #E6D6A8; padding: 1.5rem; border-radius: 1rem;
        box-shadow: 0 6px 15px rgba(0,0,0,0.3); z-index: 8500;
        max-width: 800px; width: 90%; display: flex; flex-direction: column;
        max-height: calc(100vh - 20px);
    }
    #save-route-prompt-modal h2 { font-size: 1.3rem; font-weight: bold; text-align: center; margin-bottom: 1rem; color: #333; }
    #save-route-prompt-modal .modal-top-buttons { margin-bottom: 1rem; }
    #save-route-prompt-modal label { margin-bottom: 0.5rem; font-weight: 500; display:block; }
    #save-route-prompt-modal input[type="text"]#route-name-input {
        padding: 0.5rem;
        border: 1px solid #ccc;
        border-radius: 0.25rem;
        margin-bottom: 1rem;
        width: 100%;
        font-weight: bold !important;
        text-transform: uppercase !important;
        font-size: 1.3rem !important;
    }
    #save-route-prompt-modal button { padding: 0.7rem 1rem; font-size: 1.1rem; border: none; border-radius: 5px; cursor: pointer; flex: 1; background-color: #D1D5DB; }
    #save-route-prompt-modal #confirm-save-route { background-color: #2563EB; color: white; display: flex; align-items: center; justify-content: center; gap: 0.5rem;}
    #save-route-prompt-modal #cancel-save-route { background-color: #4A5568; color: white; border:1px solid #2D3748; font-weight: bold;}
    #save-route-prompt-modal #cancel-save-route:hover { background-color: #2D3748;}

    .leaflet-control-attribution {
       opacity: 0.2;
       background-color: rgba(255, 255, 255, 0.3) !important;
    }


    .leaflet-routing-icon {
        background-image: url('https://cdnjs.cloudflare.com/ajax/libs/leaflet-routing-machine/3.2.12/leaflet.routing.icons.png');
        background-repeat: no-repeat;
        display: inline-block;
        width: 24px;
        height: 24px;
        vertical-align: middle;
        background-size: 288px 24px;
        overflow: visible;
    }
    .leaflet-routing-icon-continue { --bg-pos-x: 0; --bg-pos-y: 0; }
    .leaflet-routing-icon-sharp-right { --bg-pos-x: -24px; --bg-pos-y: 0; }
    .leaflet-routing-icon-turn-right { --bg-pos-x: -48px; --bg-pos-y: 0; }
    .leaflet-routing-icon-bear-right { --bg-pos-x: -72px; --bg-pos-y: 0; }
    .leaflet-routing-icon-sharp-left { --bg-pos-x: -96px; --bg-pos-y: 0; }
    .leaflet-routing-icon-turn-left { --bg-pos-x: -120px; --bg-pos-y: 0; }
    .leaflet-routing-icon-bear-left { --bg-pos-x: -144px; --bg-pos-y: 0; }
    .leaflet-routing-icon-u-turn { --bg-pos-x: -168px; --bg-pos-y: 0; }
    .leaflet-routing-icon-depart { --bg-pos-x: -192px; --bg-pos-y: 0; }
    .leaflet-routing-icon-arrive { --bg-pos-x: -216px; --bg-pos-y: 0; }
    .leaflet-routing-icon-roundabout { --bg-pos-x: -24px; --bg-pos-y: -24px; }


    .favicon-red { filter: hue-rotate(0deg) saturate(200%) brightness(80%); }
    .favicon-blue { filter: hue-rotate(200deg) saturate(150%) brightness(90%); }
    .button-countdown-timer { margin-left: 5px; font-weight: normal; font-size: 1em; opacity: 0.9; }

    #sortable-stages-list {
        max-height: calc(100% - 130px);
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        touch-action: pan-y;
        padding: 0;
        margin: 0;
        list-style-type: none;
        background-color: #C8BBA0;
    }
    #sortable-stages-list li {
        padding: 15px;
        min-height: 60px;
        border-bottom: 1px solid #ddd;
        transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
        cursor: grab;
        user-select: none;
        display: flex;
        align-items: center;
        gap: 12px;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        margin-bottom: 10px;
        color: #333;
    }

#sortable-stages-list li:hover:not(.dragging) {
    background-color: #f0e6c8;
    color: #FFFF00;
    box-shadow: 0 3px 7px rgba(0,0,0,0.15);
}

.drag-handle {
    cursor: grab;
    padding: 0 10px;
    align-self: stretch;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 8px;
    touch-action: none;
}
.drag-handle:hover {
}

.drag-handle img {
    width: 24px;
    height: 24px;
    object-fit: contain;
}


#sortable-stages-list li.dragging .drag-handle,
.drag-handle:active {
    cursor: grabbing;
}

#sortable-stages-list li:hover:not(.dragging) {
    background-color: #E0D8C8;
    color: #FFFF00;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}
#sortable-stages-list li:hover:not(.dragging) .drag-handle {
}
#sortable-stages-list li:hover:not(.dragging) .stage-label-badge {
    color: white;
}
#sortable-stages-list li:hover:not(.dragging) .delete-stage-button {
    color: #EF4444;
}
#sortable-stages-list li:hover:not(.dragging) .delete-stage-button:hover {
    color: #B91C1C;
}

#sortable-stages-list li:hover:not(.dragging) .stage-name-text {
    color: #FFFF00;
}


    #sortable-stages-list li:last-child {
        border-bottom: none;
        margin-bottom: 0;
    }
    #sortable-stages-list li.dragging {
        opacity: 0.7;
        background-color: #4a4a3b;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    .stage-label-badge {
        background-color: #555;
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.85rem;
        min-width: 25px;
        text-align: center;
        flex-shrink: 0;
        font-weight: bold;
    }
    .stage-name-text {
        flex-grow: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        font-size: 1rem;
        color: #333;
    }
    .delete-stage-button {
        cursor: pointer;
        margin-left: auto;
        padding: 0 10px;
        font-size: 1.8rem;
        color: #EF4444;
        font-weight: bold;
        line-height: 1;
        flex-shrink: 0;
    }
    .delete-stage-button:hover {
        color: #B91C1C;
    }

#vehicle-icon-wrapper {
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    transform-origin: center center;
    position: relative;
}

#vehicle-icon-wrapper img {
    width: 100%;
    height: 100%;
    display: block;
    object-fit: contain;
    position: absolute;
    top: 0px;
    left: 0px;
}

.vehicle-icon-minimap {
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    transform-origin: center center;
    position: relative;
}

.vehicle-icon-minimap img {
    width: 100%;
    height: 100%;
    display: block;
    object-fit: contain;
    position: absolute;
    top: 0px;
    left: 0px;
}


#intersection-preview-map-window {
    position: absolute;
    height: 480px;
    background-color: rgba(0, 0, 0, 0.75);
    border: 6px solid #bf875d;
    border-radius: 7px;
    z-index: 7000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    overflow: hidden;

}

#intersection-preview-map-container {
    width: 100%;
    height: 100%;
}

.direction-warning-card {
    position: absolute;
    background-color: rgba(100, 100, 100, 0.70);
    color: white;
    font-weight: bold;
    font-size: 1.1rem;
    padding: 8px 12px;
    border-radius: 5px;
    z-index: 1005;
    display: none;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.45);
}

</style>
</head>
<body class="min-h-screen bg-[#ABAB99] flex flex-col items-center p-6">

    <div class="reminder-count-globe" id="reminder-count-globe" style="display: none;"></div>

    <div id="unified-reminder-window" role="alertdialog" aria-labelledby="reminder-window-title" aria-describedby="reminder-window-desc">
        <div class="reminder-count-header" id="reminder-window-title">
            <div class="reminder-title-container">
                <span style="font-size: 1.3rem;" id="reminder-count-text-container">
                    <span id="current-reminder-index">1</span> de <span id="total-reminder-count">X</span> Recordatorios
                </span>
                <span class="swipe-hint" id="reminder-swipe-hint" style="font-size: smaller;">
                    (deslice lateralmente)
                </span>
            </div>
            <button id="hide-all-reminders-button" title="Posponer 1 minuto todos los recordatorios visibles">OCULTAR</button>
        </div>
        <div id="reminder-swiper-container" aria-live="polite">
        </div>
        <span id="reminder-window-desc" class="hidden">Deslice para ver los recordatorios vencidos. Use los botones para gestionar cada recordatorio.</span>
    </div>

    <div id="grid-filter-container">
        <input type="text" id="grid-filter-input" placeholder="Filtrar grid...">
        <button id="clear-filter-button" title="Limpiar filtro">×</button>
    </div>

<main>
    <div id="user-id-display"></div>
    <div id="bookmark-grid">
    </div>
</main>

<div class="notices-icon-container">
    <img src="https://boardinggate.github.io/Tesla/IMG_4194.jpg" alt="Toggle Avisos" class="notice-off-icon" id="notice-toggle-icon">
    <div class="notices-container">
        <div class="notice-wrapper">
            <span class="notice" id="current-notice"></span>
        </div>
    </div>
</div>

<footer>
    <div class="footer-content">
        <div class="header-container">
            <img src="https://boardinggate.github.io/Tesla/LOGOTESLA.jpg" class="header-logo">
            <div class="title-container">
                <h1 class="text-2xl font-bold inline">
                    <span class="text-2xl">BoardingGate</span>
                    <span class="text-base">Lanzador</span>
                    <span id="version" class="version-text"></span>
                </h1>
            </div>
        </div>
        <div class="footer-line">
          <a href="https://x.com/boardinggate/status/1857325553742721116?s=46" class="footer-link-green" target="_blank" rel="noopener noreferrer">Ahorremos un dinero con mis REFERIDOS</a>
        </div>

        <div class="statcounter-container">
          <div style="display: inline-flex; align-items: center; gap: 10px;">
            <script type="text/javascript">
              var sc_project=13126275;
              var sc_invisible=0;
              var sc_security="0fc568cc";
              var scJsHost = "https://";
              document.write("<sc"+"ript type='text/javascript' src='" +
              scJsHost+
              "statcounter.com/counter/counter.js'>"+"<"+"/script>");
            </script>
            <noscript><div class="statcounter"><a title="Web Analytics"
            href="https://statcounter.com/" target="_blank"><img
            class="statcounter"
            src="https://c.statcounter.com/13126275/0/0fc568cc/0/"
            alt="Web Analytics"
            referrerPolicy="no-referrer-when-downgrade"></a></div></noscript>
            <a href="https://statcounter.com/p13126275/?guest=1" class="footer-subtext">Legionarios de Elon</a>
          </div>
        </div>

        <p class="footer-subtext">La inteligencia tiene ciertos limites. La locura, casi ninguno 🫶 🤟</p>
    </div>
</footer>

<div id="pin-modal-overlay" class="hidden">
    <div id="pin-modal-content">
        <h2>Introducir Clave de Acceso</h2>
        <div class="modal-top-buttons" style="justify-content: center;">
            <button id="pin-submit-button">Entrar</button>
        </div>
        <label for="pin-input">Clave (4 cifras):</label>
        <input type="password" id="pin-input" maxlength="4" pattern="\d{4}" inputmode="numeric" required>
        <p id="pin-error-message"></p>
    </div>
</div>

<div id="versions-modal-overlay" class="versions-modal-overlay hidden">
    <div class="versions-modal-content">
        <h2>Histórico de versiones y recomendaciones</h2>
        <div class="modal-top-buttons" style="justify-content: flex-end;">
             <button id="close-versions-modal" style="flex: 0 1 auto; min-width: 120px;">Salir</button>
        </div>
        <pre id="versions-content">Cargando...</pre>
    </div>
</div>

<div id="reorder-stages-modal" class="hidden">
    <h2>Ordenar Etapas de Ruta</h2>
    <div class="modal-top-buttons">
        <button id="confirm-reorder-stages">Aceptar <span class="button-countdown-timer"></span></button>
        <button id="cancel-reorder-stages">Cancelar</button>
    </div>
    <p style="font-size: 0.9rem; color: #555; margin-bottom: 1rem;">Arrastra y suelta las etapas para cambiar su orden. Pulsa el aspa (X) para eliminar una etapa.</p>
    <ul id="sortable-stages-list">
    </ul>
</div>


<div id="scroll-toggle" class="scroll-toggle-button" title="Ir al inicio o fin">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M19 12l-7 7-7-7"/></svg>
</div>

<div id="config-modal" class="hidden">
    <div class="modal-top-buttons">
        <h2>Configuración y Datos</h2>
        <button id="config-close-modal" style="padding: 0.5rem 1rem; font-size:1rem;">Cerrar</button>
    </div>
    <div class="tab-buttons">
        <button class="config-tab-button active" data-tab-target="#tab-content-usuario">Usuario</button>
        <button class="config-tab-button" data-tab-target="#tab-content-pin">Clave Acceso</button>
        <button class="config-tab-button" data-tab-target="#tab-content-radares">RADARES</button>
        <button class="config-tab-button" data-tab-target="#tab-content-backup-restore">Backup/Restore</button>
        <button class="config-tab-button" data-tab-target="#tab-content-borrar">Borrar Datos</button>
    </div>
    <div class="tab-contents">
        <div id="tab-content-usuario" class="config-tab-content active">
            <h3>Datos de Usuario y Sincronización</h3>
            <p style="font-size:.9rem;color:#555;margin-bottom:1.5rem;text-align:center;">
                Introduce un nombre de usuario único para guardar y recuperar tus datos en la nube.
            </p>
            <p style="font-size: .95rem; color: #005A9C; margin-bottom: 1.5rem; text-align: left; background-color: #e6f7ff; padding: 10px; border-radius: 5px; border-left: 5px solid #007bff;">
                <strong>Modo Compañero (Móvil):</strong> Para sincronizar datos desde tu móvil, usa tu nombre de usuario seguido de <strong>@MOVIL o MÓVIL</strong> (ej: `MI_USUARIO@MOVIL`).
                Al iniciar sesión, se cargarán los datos del coche. Cada cambio que hagas en el móvil (crear rutas, etc.) se guardará automáticamente en la nube para que esté disponible en el coche. Para sincronizar los datos del coche con la nube y/ recibir los del móvil, debes RECARGAR LA PÁGINA y se hará automáticamente si activas el check de backup (de más abajo). Los datos de la nube se sincronizarán según la fecha más reciente, es decir, si los datos de la caché del navegador del coche tienen una fecha anterior a los de la nube, se entiende que has enviado datos desde otro periférico para sincronizarlos y se cargarán sustituyendo todos los datos del coche por los de la nube. Ten en cuenta que la cuenta COMPAÑERO (@MÓVIL) siempre recibirá la última copia de la nube y cualquier cambio que haga sobre esa copia, la volcará a su vez en la nube, ese usuario está más pensado para añadir remotamente datos qué para usar la app en si. Si quieres forzar un backup o restauración desde la nube USA LA OPCIÓN RESTORE/BACKUP.
            </p>
            <div class="user-data-grid">
                <div><label for="user-id">* ID Usuario (Único, no se puede cambiar):</label><input type="text" id="user-id" name="userId" required></div>
                <div><label for="tesla-model">Modelo Tesla:</label><input type="text" id="tesla-model" name="teslaModel"></div>
                <div><label for="tesla-year">Año Modelo:</label><input type="number" id="tesla-year" name="teslaYear" min="2012" max="2099"></div>
                <div><label for="tesla-province">Provincia:</label><input type="text" id="tesla-province" name="teslaProvince"></div>
                <div class="checkbox-container">
                    <input type="checkbox" id="allow-dms" name="allowDMs"><label for="allow-dms">Permitir MDs (vía admin)</label>
                </div>
                <div class="checkbox-container" style="border-top: 1px solid #ccc; padding-top: 1rem; margin-top: 1rem;">
                    <input type="checkbox" id="config-auto-backup-on-load" name="autoBackup">
                    <label for="config-auto-backup-on-load">Sincronizar/Hacer copia de seguridad automática al cargar la página (en el coche)</label>
                </div>
            </div>
            <div class="user-buttons-container" style="margin-top:1.5rem;">
                <button id="config-save-user-firebase" style="background-color:#16A34A;color:white;">Validar usuario y/o Sincronizar/Guardar en la nube</button>
            </div>
            <p id="config-user-status" class="status-message"></p>
            </div>
        <!-- Pestaña de Clave de Acceso (SIN MODIFICAR) -->
         <div id="tab-content-pin" class="config-tab-content">
             <h3>Clave de Acceso (Local)</h3>
             <div class="pin-buttons-container" style="margin-bottom: 1rem;">
                 <button id="config-save-pin" style="background-color:#2563EB;color:white;">Guardar Clave y Preferencias</button>
                 <button id="config-remove-pin" style="background-color:#dc3545;color:white;">Quitar Clave</button>
             </div>
             <p style="font-size: 0.9rem; color: #555; margin-bottom: 1rem;">Establece una clave de 4 cifras para proteger el acceso inicial a la página</p>
             <div class="pin-config-layout">
                 <div class="pin-input-group">
                     <label for="config-pin-set">Establecer/Cambiar Clave:</label>
                     <input type="password" id="config-pin-set" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="4 cifras">
                 </div>
                 <div class="pin-input-group">
                     <label for="config-pin-confirm">Confirmar Clave:</label>
                     <input type="password" id="config-pin-confirm" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="Repetir 4 cifras">
                 </div>
             </div>
             <div class="checkbox-container" style="margin-top: 1.5rem; border-top: 1px solid #ccc; padding-top: 1rem;">
                <input type="checkbox" id="config-direct-to-nav" name="directToNav">
                <label for="config-direct-to-nav">Entrar directamente al Navegador de rutas</label>
            </div>
             <p id="config-pin-status" class="status-message"></p>
         </div>

        <!-- Pestaña de Radares (SIN MODIFICAR) -->
         <div id="tab-content-radares" class="config-tab-content">
            <h3>Importar / Borrar Radares y Otros POIs</h3>
            <div class="radar-action-buttons" style="margin-bottom: 1rem;">
                <button id="import-radars-button">IMPORTAR RADARES y otros</button>
                <button id="delete-filtered-radars-button">BORRAR CACHÉ (según filtro)</button>
            </div>
            <p style="font-size:0.85rem; color:#444; margin-bottom:0.5rem;">
                Para <strong>importar</strong>, el filtro de "Palabras Clave" buscará coincidencias (OR) en el nombre del POI (ej: provincia, población, tipo).
                Los filtros de Lat/Lon pueden ser un valor único (aprox.) o un rango (ej: "<code>40.1 40.5</code>" para buscar entre esas latitudes). Si un filtro está vacío, no se aplica.
            </p>
             <p style="font-size:0.85rem; color:#444; margin-bottom:1rem;">
                 Los POIs importados (RADARES) se guardarán con un radio de <strong>400 metros</strong> y excluidos de la lista por defecto.
             </p>
            <p style="font-size:0.85rem; color:#444; margin-bottom:1.5rem;">
                Para <strong>borrar</strong>: Si NO se especifica NINGÚN filtro, se borrarán TODOS los recordatorios de tipo "RADAR:" o excluidos de lista. Si se especifica algún filtro, se borrarán los que cumplan TODAS las condiciones activas (Palabras Clave OR, Latitud Y Longitud).
            </p>
            <div class="radar-filter-group">
                <div>
                    <label for="radar-filter-lat">Latitud (valor o "min max"):</label>
                    <input type="text" id="radar-filter-lat" placeholder="Ej: 40.123 o 40.0 40.5">
                </div>
                <div>
                    <label for="radar-filter-lon">Longitud (valor o "min max"):</label>
                    <input type="text" id="radar-filter-lon" placeholder="Ej: -3.567 o -4.0 -3.0">
                </div>
                <div style="grid-column: span 2;">
                    <label for="radar-filter-keywords">Palabras Clave (en nombre POI, separadas por espacio, condición OR):</label>
                    <input type="text" id="radar-filter-keywords" placeholder="Ej: FIJO CAMUFLADO MADRID">
                </div>
            </div>
            <div class="radar-import-options">
                <input type="checkbox" id="import-extra-radars-checkbox">
                <label for="import-extra-radars-checkbox">Importar también radares móviles, semáforo, etc (usa ficheros KLM adicionales)</label>
            </div>
             <div id="radar-import-progress-container" style="display:none;">
                 <progress id="radar-import-progress-bar" value="0" max="100"></progress>
                 <p id="radar-import-status" class="status-message"></p>
             </div>
         </div>

        <div id="tab-content-backup-restore" class="config-tab-content">
            <h3>Recuperar Backup / Hacer Copia en la Nube</h3>
            <p style="margin-bottom:1.2rem;">
                Para <strong>Recuperar</strong>, introduce tu ID de usuario y pulsa el botón naranja.<br>
                Para <strong>Hacer una Copia de Seguridad</strong>, asegúrate de que tu ID está introducido en la pestaña "Usuario" y pulsa el botón verde.
            </p>
            
            <div class="user-data-grid" style="grid-template-columns: 1fr auto; align-items: end; gap: 1rem;">
                <div style="grid-column: 1 / 2;">
                    <label for="restore-user-id">ID Usuario a recuperar:</label>
                    <input type="text" id="restore-user-id" placeholder="Tu apodo único (el que está en la pestaña usuario)...">
                </div>
                <div style="grid-column: 2 / 3; display: flex; flex-direction: column; gap: 0.5rem;">
                    <button id="config-restore-backup-firebase" style="background-color:#E65100;color:white;width:100%;padding: 0.6rem 1rem;">Recuperar Backup de la nube</button>
                    <button id="config-save-user-firebase-from-backup-tab" style="background-color:#16A34A;color:white;width:100%;padding: 0.6rem 1rem;">Hacer la copia de seguridad en la nube</button>
                </div>
            </div>
            <p id="config-restore-status" class="status-message"></p>
            <hr style="margin: 2rem 0;">
            <h3>Backup/Restore Local (Manual)</h3>
            <p style="font-size:.85rem; color:#555;">Esto es para copias manuales de texto. No interactúa con la nube</p>
            <div class="backup-restore-container" style="margin-top:1rem;">
                 <div>
                    <h4>Crear Backup Local</h4>
                     <button id="config-generate-backup" style="background-color:#2563EB;color:white; margin-bottom: 1rem;">Generar Código</button>
                    <textarea id="config-backup-display" readonly style="display:none;"></textarea>
                    <p id="config-backup-status" class="status-message"></p>
                </div>
                <div>
                    <h4>Restaurar Copia Local</h4>
                    <button id="config-restore-backup" style="background-color:#10B981;color:white; margin-bottom: 1rem;">Restaurar</button>
                    <textarea id="config-restore-input" placeholder="Pega el código de backup local aquí..."></textarea>
                </div>
            </div>
        </div>
        
                <!-- Pestaña de Borrar Datos (SIN MODIFICAR) -->
        <div id="tab-content-borrar" class="config-tab-content borrar-container">
            <h3>Borrar Datos Locales</h3>
             <button id="config-restore-grid-button">RESTAURAR EL GRID ORIGINAL DE BOTONES</button>
             <p id="config-restore-grid-status" class="status-message" style="margin-bottom: 1.5rem;"></p>

            <h3 style="border-top: 1px solid #ccc; padding-top: 1.5rem; margin-top:1.5rem;">Acción Irreversible</h3>
            <button id="config-clear-cache" style="margin-bottom: 0.5rem;">Borrar TODO</button>
            <p>Elimina TODOS los datos locales.</p>
            <p><strong style="color:red;">¡Sin deshacer!</strong> Ten backup.</p>
        </div>
    </div>
</div>



    

<div id="simulation-modal" class="hidden">
</div>

<div id="simulation-speed-modal" class="hidden">
</div>

<div id="locations-preview-modal" class="hidden">
    <h2 id="locations-preview-title">Ubicaciones (filtrado según tabla)</h2>
    <div id="locations-preview-map-container" style="height: calc(100% - 100px); width: 100%;"></div>
    <div class="modal-top-buttons" style="justify-content: center; margin-top: 1rem;">
        <button id="close-locations-preview">Salir</button>
    </div>
</div>

<div id="address-suggestions-modal" class="hidden">
    <h2 id="address-suggestions-title">Sugerencias de Dirección</h2>
    <ul id="address-suggestions-list"></ul>
    <div class="modal-top-buttons" style="justify-content: flex-end; margin-top: 1rem;">
        <button id="close-address-suggestions-modal" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
    </div>
</div>

<div id="deviation-modal" class="hidden">
</div>

<div id="arrival-stats-modal" class="hidden">
</div>

<div id="intersection-preview-map-window" class="hidden">
    <div id="intersection-preview-map-container"></div>
</div>

<script>
    

    const originalToFixed = Number.prototype.toFixed;
    Number.prototype.toFixed = function(digits) {
        if (this === undefined || this === null || isNaN(this)) {
            try {
                throw new Error("Debug toFixed Call");
            } catch (e) {
            }
            return "NaN";
        }
        return originalToFixed.call(this, digits);
    };

    const originalBookmarks = [ { name: "YouTube", url: "https://www.youtube.com" }, { name: "Google", url: "https://www.google.com" }, { name: "GDrive", url: "https://drive.google.com", favicon: "./IMG_4172.png" }, { name: "GMail", url: "https://mail.google.com/mail/mu/mp/603/#tl/Recibidos", favicon: "./IMG_4171.png"}, { name: "Google Fotos", url: "https://photos.google.com" }, { name: "iCloud", url: "https://www.icloud.com/", favicon: "https://www.google.com/s2/favicons?domain=icloud.com&sz=64t" }, { name: "ABRP", url: "https://abetterrouteplanner.com" }, { name: "ElectroMaps", url: "https://map.electromaps.com/es/", favicon: "https://www.google.com/s2/favicons?domain=electromaps.com&sz=64" }, { name: "REVE PdR España", url: "https://www.mapareve.es/mapa-puntos-recarga", favicon: "https://www.google.com/s2/favicons?domain=mapareve.es&sz=64" }, { name: "Ver ubicaciones", url: "map-action:openRemindersMapWithNoRadars", favicon: "https://www.google.com/s2/favicons?domain=google.com/maps&sz=64" }, { name: "Google Maps", url: "https://maps.google.com" }, { name: "WhatsApp", url: "https://web.whatsapp.com/" }, { name: "TESSIE", url: "https://dash.tessie.com/signin", favicon: "https://www.google.com/s2/favicons?domain=tessie.com&sz=64" }, { name: "Mis Updates", url: "https://dash.tessie.com/software", favicon: "https://cdn-icons-png.flaticon.com/512/148/148767.png" }, { name: "Olas Updates", url: "https://es.stats.tessie.com/", favicon: "https://cdn-icons-png.flaticon.com/512/5815/5815902.png" }, { name: "NotaTeslaApp", url: "https://www.notateslaapp.com/software-updates/" }, { name: "ENHAUTO", url: "https://www.enhauto.com" }, { name: "MAREAS", url: "https://www.meteogalicia.gal/web/predicion/mareas-e-luas" }, { name: "ELECTROVERSE", url: "https://electroverse.com/es/map", favicon: "https://www.google.com/s2/favicons?domain=electroverse.com&sz=64" }, { name: "ACCIONA", url: "https://www.google.com/maps/search/recarga+Acciona", favicon: "https://www.google.com/s2/favicons?domain=acciona.com&sz=64" }, { name: "IBERDROLA", url: "https://www.google.com/maps/search/recarga+IBERDROLA", favicon: "https://www.google.com/s2/favicons?domain=iberdrola.com&sz=64" }, { name: "WAYLET Repsol", url: "https://www.google.com/maps/search/recarga+REPSOL+Waylet", favicon: "https://www.google.com/s2/favicons?domain=repsol.com&sz=64" }, { name: "ENDESA xWay", url: "https://www.google.com/maps/search/recarga+ENDESA+XWAY", favicon: "https://www.google.com/s2/favicons?domain=endesa.com&sz=64" }, { name: "ZUNDER", url: "https://www.google.com/maps/search/recarga+ZUNDER", favicon: "https://www.google.com/s2/favicons?domain=zunder.com&sz=64" }, { name: "IONITY", url: "https://www.google.com/maps/search/recarga+IONITY", favicon: "https://www.google.com/s2/favicons?domain=ionity.eu&sz=64" }, { name: "WENEA", url: "https://www.google.com/maps/search/recarga+WENEA", favicon: "https://www.google.com/s2/favicons?domain=wenea.com&sz=64" }, { name: "T.ENERGIES", url: "https://www.google.com/maps/search/recarga+TOTAL+ENERGIES", favicon: "https://www.google.com/s2/favicons?domain=totalenergies.com&sz=64" }, { name: "GALP", url: "https://www.google.com/maps/search/recarga+GALP", favicon: "https://www.google.com/s2/favicons?domain=galp.com&sz=64" }, { name: "MIIO", url: "https://miio.com", favicon: "https://www.google.com/s2/favicons?domain=miio.com&sz=64" }, { name: "EVDC", url: "https://evdc.network", favicon: "https://www.google.com/s2/favicons?domain=evdc.network&sz=64" }, { name: "GROK", url: "https://grok.com/?referrer=website" }, { name: "CHATGPT", url: "https://chat.openai.com" }, { name: "CLAUDE", url: "https://claude.ai/new" }, { name: "GEMINI", url: "https://gemini.google.com" }, { name: "NOTEBOOKLM", url: "https://notebooklm.google.com" }, { name: "Batería", url: "https://docs.google.com/spreadsheets/d/1bLZmgVGTBqg2bS2E45JpORjs9eK2nb05AWXYLLDY-RI/edit?gid=1398548891#gid=1398548891", favicon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='10'/><polyline points='12 6 12 12 16 14'/></svg>" }, { name: "TeslaParaTodos", url: "https://teslaparatodos.com/cine/" }, { name: "BetterTheater", url: "https://abettertheater.com", favicon: "https://www.google.com/s2/favicons?domain=abettertheater.com&sz=64" }, { name: "Filmin", url: "https://www.filmin.es/catalogo/peliculas" }, { name: "Octopus", url: "https://octopusenergy.es/login" }, { name: "App MCE", url: "https://www.oscarabilleira.com/app-mi-coche-electrico/#ayuda" }, { name: "Patrón Luz", url: "https://docs.google.com/spreadsheets/d/1R7UUZ9i4BAYWAGAX6PQT1WGd12GEZ4Ja/edit?usp=sharing&ouid=108345701896498198132&rtpof=true&sd=true" }, { name: "TradingView", url: "https://es.tradingview.com/chart/t5g9UFG0/" }, { name: "Telegram", url: "https://web.telegram.org/a/" }, { name: "Twitter", url: "https://x.com" }, { name: "Maesal Detailer", url: "https://www.maesaldetailer.es/" }, { name: "Superchargers", url: "https://www.tesla.com/es_es/findus?bounds=45.41107111786193%2C19.27853056943938%2C29.703668286784747%2C-16.64676239931062" }, { name: "TESLA web", url: "https://www.tesla.com/es_es" }, { name: "Manual M3", url: "https://www.tesla.com/ownersmanual/model3/es_es/" }, { name: "de Servicio", url: "https://service.tesla.com/docs/Model3/ServiceManual/2024/es-es/" }, { name: "de Despiece", url: "https://epc.tesla.com/es-MX/catalogs/e0e07c3d-272f-4d06-b8b6-9e92f857e5f3" }, { name: "de Usted Mismo", url: "https://www.tesla.com/es_es/support/do-it-yourself-guides" }, { name: "de Filtro Cabina", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-DB0A1E3C-926E-498C-A2FD-A27B8421A471.html" }, { name: "de Móvil remoto", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-53651B16-A2E3-4118-933E-B5F41C74D433.html" }, { name: "Waze (consultas)", url: "https://www.waze.com/es/live-map/", favicon: "https://www.google.com/s2/favicons?domain=waze.com&sz=64" }, { name: "AMAZON", url: "https://www.amazon.es" }, { name: "BIP&DRIVE", url: "https://areaprivada.bipdrive.com/login" }, { name: "ITV Cita", url: "https://www.sycitv.com/es/cita-previa-particulares/", favicon: "https://boardinggate.github.io/Tesla/itv.png" }, { name: "Deportes", url: "https://www.sofascore.com/es/tenis" }, null, { name: "Jaime Odena", url: "https://www.youtube.com/@JOdena", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Eduardo Arcos", url: "https://www.youtube.com/@earcos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "AutoIngenium", url: "https://www.youtube.com/@AutoIngenium", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Gallego en Munich", url: "https://www.youtube.com/@ungallegoenmunich", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Electromiaumiau", url: "https://www.youtube.com/@electromiaumiau", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Manuel Martos", url: "https://www.youtube.com/@Manuel_Martos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Todos Electricos", url: "https://www.youtube.com/@TodosElectricos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Juan Vidal Haces", url: "https://www.youtube.com/@JuanVidalHaces", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Ruedana", url: "https://www.youtube.com/@ruedana", favicon: "https://www.youtube.com/favicon.ico" }, { name: "STR-600", url: "https://www.youtube.com/@STR-600", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Juanjo T. Aventuras", url: "https://www.youtube.com/@juanjoteslaventuras", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Carlos Cuezva", url: "https://www.youtube.com/@CarlosCuezva", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Javi Manzanoo", url: "https://www.youtube.com/@javimanzanoo", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Crifedi", url: "https://www.youtube.com/@Crifedi", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Tescno Tesla", url: "https://www.youtube.com/@TecnoTesla", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Full Electric Mex", url: "https://www.youtube.com/@FullElectricMexico", favicon: "https://www.youtube.com/favicon.ico" }, null, null, { name: "La iA Jon", url: "https://www.youtube.com/@la_inteligencia_artificial", favicon: "https://www.youtube.com/favicon.ico" }, { name: "JF Ccalero", url: "https://www.youtube.com/@jfcalero", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Visual Politik", url: "https://www.youtube.com/@VisualPolitik", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Fabian Barrio", url: "https://www.youtube.com/@fabiancbarrio", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Loquetudigas", url: "https://www.youtube.com/@Loquetudigas", favicon: "https://www.youtube.com/favicon.ico" }, { name: "David Antunes", url: "https://www.youtube.com/@davidantunesmusic", favicon: "https://www.youtube.com/favicon.ico" }, { name: "TheWildProject", url: "https://www.youtube.com/@TheWildProject", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Estas Tonne", url: "https://www.youtube.com/@Estastonne", favicon: "https://www.youtube.com/favicon.ico" }, { name: "BBC6 Music", url: "https://www.youtube.com/@BBC6Music", favicon: "https://www.youtube.com/favicon.ico" }, null, null ];
    const originalToggleRanges = [ { start: 18, end: 29, name: "ELECTROVERSE", label: "PdR,s" }, { start: 30, end: 41, name: "GROK", label: "iAs" }, { start: 42, end: 59, name: "TradingView", label: "Útil" }, { start: 60, end: 95, name: "JOdena", label: "Varios" } ];

    const sectionColors = { 18: '#F0E0D3', 30: '#D8D4E0', 42: '#D9E5DB', 60: '#F2ECD0', unassigned: '#C5C8B8', off: '#ABAB99' };
    const darkModeGenericButtonColor = '#ABAB99';
    let snoozedRouteRadars = new Map();


const MAP_SEARCH_INPUT_KEY = 'boardinggate_map_search_value';    
// ... (tus otras variables globales) ...

let gpsRetryTimeoutId = null; // ID del temporizador para reintentar el GPS
let gpsRetryAttempt = 0; // Contador de intentos de reconexión GPS
const MAX_GPS_RETRIES = 10; // Número máximo de reintentos antes de dar un error persistente
const GPS_RETRY_DELAY_MS = 5000; // Retraso en milisegundos entre reintentos de GPS

// ... (resto de tus variables) ...

    
let isArrivalSequenceStarted = false;
// --- INICIO DE LA MODIFICACIÓN ---
let maxSpeedCoordinates = null; // Para guardar las coordenadas de la velocidad máxima
// --- FIN DE LA MODIFICACIÓN ---    
    
    // --- INICIO: Nuevas variables para el zoom con flyTo ---
let progressiveZoomState = 'none'; // 'none', 'zooming-in', 'holding', 'zooming-out'
let mapPreviousZoomLevelForProgressive = null;
let lastProcessedStepIdentifier = null;
const PROGRESSIVE_ZOOM_START_DISTANCE = 180;
const PROGRESSIVE_ZOOM_PEAK_DISTANCE = 50;
const PROGRESSIVE_ZOOM_EXIT_START_DISTANCE = 60;
const PROGRESSIVE_ZOOM_EXIT_END_DISTANCE = 150;

// ... tus otras variables ...
let isZoomedForManeuver = false;
let isFlying = false; // <-- ASEGÚRATE DE QUE ESTA LÍNEA EXISTA
let navigationTargetZoom = null; // <-- Y TAMBIÉN ESTA
let currentSmoothedMapCenter = null;    
// ...    

 // ... junto a tus otras variables globales ...
let lastMobileSyncTimestamp = 0; // Timestamp del último guardado exitoso desde el móvil.   
    
    
    const TOTAL_CELLS = 96; const COLS = 6; const grid = document.getElementById('bookmark-grid');
    let isDarkMode = false; let pressStartTime = null; let reminderPressStartTime = null; let isActive = true; let isFooterVisible = true; let notices = []; let currentNoticeIndex = 0; let fromReminderModal = false;
    let isEditMode = false; let isAssignmentMode = false;
    let isKeywordAssignmentMode = false;
    let currentlyAssigningToggleStart = null;
    let customData = { bookmarks: {}, toggles: {} };
    let cellElements = []; let toggleButtonElements = {}; let currentBookmarks = []; let currentToggleRanges = [];
    let onOffToggle, weatherButton, reminderButton, zoomButton, darkModeToggle, versionsButton, infoButton;
    let radarButton;
    let initialUserLocationCircle = null;

    let firstPersonalizationSession = !sessionStorage.getItem('personalizationHelpShown');
    let editingTargetElement = null; let draggedItem = null; let draggedItemIndex = null; let dragOverIndex = null;

    let touchStartX = 0; let touchStartY = 0; let currentTouchTarget = null;
    let isPasswordActive = false; let storedPin = null;
    let reminderCheckIntervalId = null;
    let currentCheckIntervalDuration = 3000;
    let lastUpdatesCheckDate = localStorage.getItem('lastUpdatesCheckDate');
    let currentNotificationSlideIndex = 0;
    let isUnifiedWindowVisibleByLogic = false;

    let reminderModalMap = null;
    let reminderMarker = null;
    let reminderCircle = null;
    let previewMaps = {};

    const MAX_SAVED_LOCATIONS = 15;
    const SAVED_LOCATIONS_KEY = 'boardinggate_saved_locations';
    const SHOW_EXCLUDED_REMINDERS_KEY = 'boardinggate_showExcludedRemindersInTable';
    const RADARES_RUTA_CHECKED_KEY = 'boardinggate_radaresRutaCheckboxChecked';
    const TAREAS_RUTA_CHECKED_KEY = 'boardinggate_tareasRutaCheckboxChecked';
    const ACTIVE_MAP_LAYER_KEY = 'boardinggate_activeMapLayer';
    const DIRECT_TO_NAVIGATION_KEY = 'boardinggate_directToNavigation';
    const MAP_ENTRY_OVERRIDE_KEY = 'boardinggate_map_entry_override';
    const TEMP_PREVENT_DIRECT_NAV_KEY = 'tempPreventDirectNavAfterMapExit';
    const GRAPH_STATE_KEY = 'boardinggate_graphState';


    let locationPickerMap = null;
    let locationPickerMarker = null;
    let currentEditingLocationSlotIndex = -1;
    let tempSavedLocations = [];

    let navigationMapInstance = null;
    let isNavigationMapActive = false;
    let completedRouteSegmentsLayer = null;


    let initialUserLocationMarker = null;
    let initialUserLocationMarkerLat = null;
    let initialUserLocationMarkerLng = null;
    let navigationCurrentLocation = null;
    let locationWatchId = null;
    let shouldCenterOnUser = false;
    let navigationFollowUser = false;
    let mapPreviousZoomLevel = null;
    const MIN_MANEUVER_ZOOM_LEVEL = 17;
    let currentMapBearing = 0;
    let currentMapRotationAngle = 0;
   
    let currentMapCenterOffset = { x: 0, y: 0 };
    let targetMapCenterOffset = { x: 0, y: 0 };
    let mapOffsetAnimationId = null;
    let miniMapOffsetActive = { x: 0, y: 0 };


    let lastHeadingForTilt = 0;


    let compassAndModeControl = null;

    let navigationWaypoints = [];
    let navigationRouteLayer = null;
    let navigationCurrentRouteData = null;
    let isNavigating = false;
    let routeStartTime = null;
    let navigationStartTimeForStats = null;
    let totalDistanceTravelledForStats = 0;
    let accumulatedDistanceBeforeCurrentSegment = 0;
    let lastPositionForStats = null;
    let maxDistanceReachedOnRoute = 0; 
    
    let maxSpeedDuringTrip = 0;
    let maxAltitudeDuringTrip = -Infinity;
    let minAltitudeDuringTrip = Infinity;


    window.lastPositionForSpeedCalc = null;
    window.currentSpeedKmh = 0;
    window.averageSpeedKmh = 0;


    let isSimulatingGpsLocation = false;
    let simulatedGpsLocation = null;
    let automatedSimulationIntervalId = null;
    let simulatedDistanceAlongRoute = 0;
    let simulationSpeedKmph = 85;
    let currentSimulationSpeedKmph = 85; 
    const SIMULATION_TICK_INTERVAL_MS = 300;
    
    let maxSpeedMarkerLayer = null; 

    let speedMilestoneLayer = null; // <-- NUEVA VARIABLE para los hitos de velocidad
    let lastSpeedMilestone = 0;     // <-- NUEVA VARIABLE para la lógica de cruce de hitos
    const SPEED_MILESTONES = [50, 60, 80, 100, 110, 120, 130, 150]; // <-- CONSTANTE con los hitos


    const OSRM_SERVICE_URL = 'https://router.project-osrm.org/route/v1';
    const SAVED_ROUTES_KEY = 'boardinggate_saved_routes';
    const MAX_SAVED_ROUTES = 100;
    let currentRouteNameForSaving = null;
    let navigationMapClickHandler = null;
    let draggedStageLi = null;
    const DEVIATION_THRESHOLD_METERS = 100;
    const DEVIATION_MIN_TIME_SECONDS = 5;
    let deviationStartTime = 0;
    let isRecalculatingRoute = false;
    let deviationModalTimerId = null;
    let isDeviationModalActive = false;

    const WAYPOINT_VISITED_THRESHOLD_METERS = 100;

    let currentLegIndexNav = 0;
    let currentStepIndexNav = 0;
    let lastCarDistanceAlongRouteForNavLogic = 0;
    let lastValidCarDistanceForDisplay = 0;
    let lastProcessedStepManeuverLocation = null;
    let recalculationRetryTimeoutId = null;
    let recalculationAttempts = 0;


    let isAddReminderAtLocationModeActive = false;
    let addReminderAtLocationButton = null;

    let simulationModalTimer = null;
    let autoStartNavTimer = null;


    let mapLayersControl = null;
    let searchToastShown = false;

    let pendingPositionToProcess = null;

    const KML_FILES_LIST_STANDARD = './KLM/KLMFILES.TXT';
    const KML_FILES_LIST_EXTRA = './KLM/KLMFILES2.TXT';
    const KML_BASE_PATH = './KLM/';
    const COORD_EPSILON = 0.00001;
    const RUTA_RADAR_PROXIMITY_THRESHOLD = 75;
    let reminderMapObjects = [];
    let radaresEnRutaActual = [];
    let tareasEnRutaActual = [];

    const STATIC_MODAL_IDS = ['config-modal', 'versions-modal-overlay', 'pin-modal-overlay', 'reorder-stages-modal', 'simulation-modal', 'locations-preview-modal', 'address-suggestions-modal', 'deviation-modal', 'arrival-stats-modal', 'simulation-speed-modal'];

    let activeToasts = [];

    let intersectionPreviewMap = null;
    let intersectionPreviewRouteLayer = null;
    let intersectionPreviewManeuverMarker = null;
    let intersectionPreviewCarMarker = null;
    let intersectionPreviewTimer = null;
    let lastAutoShownManeuverId = null;
    let directToNavOnLoad = false;

    let mapLayersControlReminder = null;
    let mapLayersControlLocationsPreview = null;

    let directionCardDerecha = null;
    let directionCardIzquierda = null;

    let navigationChart = null;
    let currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviación Ruta';
    
    // --- INICIO: Variables para la nueva lógica de gráficas ---
    let graphPlotState = { lastPlotTime: null, lastPlotCoords: null };
    let graphIntervalDuration = 0; 
    let graphIntervalTimer = null;
    let graphDataPoints = { speed: [], altitude: [] };
    let graphLabels = [];
    let graphExpectedAvgSpeed = 0;
    let isCarStoppedForGraph = false; 
    
    
    const GRAPH_PIXELS_PER_DATAPOINT = 2; 
    const GRAPH_BUFFER_PERCENTAGE = 0.15;    
  
                             
const managedKeys = [
    'reminders','darkMode','toggleStates','zoomState','onOffState','noticesActive',
    'footerVisible','teslaHtmlLastModified','teslaHtmlLastModifiedTimestamp',
    'userData_userId','userData_teslaModel','userData_teslaYear','userData_teslaProvince',
    'userData_allowDMs', 'customGridData', 'personalizationHelpShown', 'gridFilterValue', 
    'password_pin', 'password_active', 'lastUpdatesCheckDate', SAVED_LOCATIONS_KEY, 
    SHOW_EXCLUDED_REMINDERS_KEY, SAVED_ROUTES_KEY, RADARES_RUTA_CHECKED_KEY, 
    TAREAS_RUTA_CHECKED_KEY, ACTIVE_MAP_LAYER_KEY, DIRECT_TO_NAVIGATION_KEY, GRAPH_STATE_KEY,
    'boardinggate_autoBackupOnLoad', 'userData_backupPassword', MAP_SEARCH_INPUT_KEY
];


const MAP_FILTER_INPUT_KEY = 'boardinggate_map_filter_value'; // Para guardar el valor del campo de filtro secundario del mapa

const managedDesc = managedKeys.map(k => {
        switch(k){
            case 'reminders':return 'Recordatorios'; case 'darkMode':return 'Modo Oscuro'; case 'toggleStates':return 'Visibilidad Secc.';
            case 'zoomState':return 'Zoom Grid'; case 'onOffState':return 'On/Off Gral'; case 'noticesActive':return 'Avisos/Footer';
            case 'footerVisible':return 'Vis. Footer'; case 'teslaHtmlLastModified':return 'Cache Versión'; case 'teslaHtmlLastModifiedTimestamp':return 'TS Cache';
            case 'userData_userId':return 'ID Usuario'; case 'userData_teslaModel':return 'Modelo'; case 'userData_teslaYear':return 'Año';
            case 'userData_teslaProvince':return 'Provincia'; case 'userData_allowDMs':return 'Permitir DMs'; case 'customGridData': return 'Grid Pers.';
            case 'personalizationHelpShown': return 'Ayuda Pers. Vista'; case 'gridFilterValue': return 'Filtro Grid'; // Ahora es solo el filtro del grid
            case 'password_pin': return 'PIN Acceso'; case 'password_active': return 'PIN Activo'; case 'lastUpdatesCheckDate': return 'Cache Fecha Updates';
            case SAVED_LOCATIONS_KEY: return 'Ubicaciones Guardadas';
            case SHOW_EXCLUDED_REMINDERS_KEY: return 'Mostrar Excluidos Tabla';
            case SAVED_ROUTES_KEY: return 'Rutas Guardadas';
            case RADARES_RUTA_CHECKED_KEY: return 'Check Radares Ruta';
            case TAREAS_RUTA_CHECKED_KEY: return 'Check Tareas Ruta';
            case ACTIVE_MAP_LAYER_KEY: return 'Capa de Mapa Activa';
            case DIRECT_TO_NAVIGATION_KEY: return 'Directo a Navegación';
            case GRAPH_STATE_KEY: return 'Estado Gráfica';
            case MAP_SEARCH_INPUT_KEY: return 'Buscador Mapa (Principal)'; // Nuevo nombre
            case MAP_FILTER_INPUT_KEY: return 'Buscador Mapa (Filtro)'; // Nuevo campo de filtro para el mapa
            default:return k;
        }
    }).join(', ');


    
  const vehicleIcon = L.divIcon({
    html: `<div id="vehicle-icon-wrapper">
               <img src="AVANCE.PNG" alt="Coche">
           </div>`,
    className: 'vehicle-icon-leaflet-container',
    iconSize: [48, 48],
    iconAnchor: [24, 24]
});

const vehicleIconMiniMap = L.divIcon({
    html: `<div class="vehicle-icon-minimap">
               <img src="AVANCE.PNG" alt="Coche Mini">
           </div>`,
    className: 'vehicle-icon-minimap-leaflet-container',
    iconSize: [24, 24],
    iconAnchor: [12, 12]
});


    const smallRadarMarkerIcon = L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-violet.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [13, 21], iconAnchor: [6, 21], popupAnchor: [1, -18], shadowSize: [21, 21]
    });
    const largeGreenLocationMarkerIcon = L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [17, 28], iconAnchor: [8, 28], popupAnchor: [1, -24], shadowSize: [28, 28]
    });
    const defaultLocationMarkerIconBlue = L.icon({ iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png', shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png', iconSize: [15, 25], iconAnchor: [7, 25], popupAnchor: [1, -20], shadowSize: [25, 25] });


    const maneuverTexts = {
        'turn-sharp right': 'Giro brusco a la derecha',
        'turn-right': 'Gira a la derecha',
        'bear-right': 'Mantente a la derecha',
        'turn-sharp left': 'Giro brusco a la izquierda',
        'turn-left': 'Gira a la izquierda',
        'bear-left': 'Mantente a la izquierda',
        'turn-': 'Gira',
        'straight-straight': 'Sigue recto',
        'straight-': 'Sigue recto',
        'roundabout-': 'Entra en la rotonda',
        'roundabout turn-': 'Toma la salida de la rotonda',
        'rotary-': 'Entra en la glorieta',
        'roundabout turn-left': 'En la rotonda, toma la salida hacia la izquierda',
        'roundabout turn-right': 'En la rotonda, toma la salida hacia la derecha',
        'roundabout turn-straight': 'En la rotonda, sigue recto',
        'destination-left': 'Has llegado a tu destino  (a la izquierda)',
        'destination-right': 'Has llegado a tu destino (a la derecha)',
        'destination-': ' tu destino ',
        'depart-': 'Inicia la ruta',
        'arrive-left': 'Has llegado a tu destino (a la izquierda)',
        'arrive-right': 'Has llegado a tu destino  (a la derecha)',
        'arrive-': 'Has llegado a tu destino',
        'continue-straight': 'Continúa recto',
        'continue-': 'Continúa',
        'new name-': 'Continúa por',
        'fork-right': 'En la bifurcación, mantente a la derecha',
        'fork-left': 'En la bifurcación, mantente a la izquierda',
        'fork-': 'En la bifurcación',
        'merge-left': 'Incorpórate por la izquierda',
        'merge-right': 'Incorpórate por la derecha',
        'merge-straight': 'Incorpórate',
        'merge-': 'Incorpórate',
        'end of road-left': 'Al final de la vía, gira a la izquierda',
        'end of road-right': 'Al final de la vía, gira a la derecha',
        'end of road-': 'Fin de la vía',
        'u turn-left': 'Haz un cambio de sentido (hacia la izquierda)',
        'u turn-right': 'Haz un cambio de sentido (hacia la derecha)',
        'u turn-': 'Haz un cambio de sentido',
        'use lane-': 'Usa el carril indicado',
        'notification-': 'Atención',
        'exit roundabout-': 'Sal de la rotonda',
        'exit rotary-': 'Sal de la glorieta',
        'off ramp-': 'Vía de salida',
    };

    const SMOOTH_ZOOM_DURATION = 5.0;





function startGpsWatching() {
    if (gpsRetryTimeoutId) {
        clearTimeout(gpsRetryTimeoutId);
        gpsRetryTimeoutId = null;
    }

    if (locationWatchId !== null) {
        return;
    }

    if (!('geolocation' in navigator) || !('watchPosition' in navigator.geolocation)) {
        showToast("Geolocalización no soportada por este navegador.", "error", 5000);
        return;
    }

    if (gpsRetryAttempt >= MAX_GPS_RETRIES) {
        showToast("Error persistente: No se pudo conectar al GPS. Revisa la configuración del dispositivo.", "error", 0, false, "gps-persistent-error");
        return;
    }

    gpsRetryAttempt++;
    showToast(`Intentando conectar al GPS (Intento ${gpsRetryAttempt}/${MAX_GPS_RETRIES})...`, "info", GPS_RETRY_DELAY_MS, false, "gps-attempt-toast");

    locationWatchId = navigator.geolocation.watchPosition(
        (position) => {
            if (isSimulatingGpsLocation) return;

            const attemptToast = document.getElementById("gps-attempt-toast");
            if (attemptToast) attemptToast.remove();
            activeToasts = activeToasts.filter(t => t.id !== "gps-attempt-toast");

            gpsRetryAttempt = 0;
            const persistentErrorToast = document.getElementById("gps-persistent-error");
            if (persistentErrorToast) persistentErrorToast.remove();

            const coordsForUpdate = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                heading: position.coords.heading,
                speed: position.coords.speed,
                altitude: position.coords.altitude
            };

            navigationCurrentLocation = coordsForUpdate;
            updateInitialUserPosition(coordsForUpdate, navigationMapInstance);

            if (isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0] && coordsForUpdate) {
                const routeForDistCalc = navigationCurrentRouteData.routes[0];
                let carDistTurf = 0;
                if (navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
                    try {
                        const carPointTurf = turf.point([coordsForUpdate.longitude, coordsForUpdate.latitude]);
                        const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                        const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                        const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                        carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                    } catch (e) { }
                }
                const totalRouteLength = routeForDistCalc.distance;
                if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                    if (carDistTurf > lastCarDistanceAlongRouteForNavLogic - 100) {
                         lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                    }
                } else if (carDistTurf > totalRouteLength + 500) {
                    lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
                }

                updateTurnByTurnDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                updateNavigationProgressDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
            }
        },
        (error) => {
            showToast(`Error GPS: ${error.message}`, "warning");

            if (locationWatchId !== null) {
                navigator.geolocation.clearWatch(locationWatchId);
                locationWatchId = null;
            }

            gpsRetryTimeoutId = setTimeout(startGpsWatching, GPS_RETRY_DELAY_MS);
        },
        { enableHighAccuracy: true, timeout: 15000, maximumAge: 2000, distanceFilter: 3 }
    );
}



    


/**
 * Parsea un ID de usuario para identificar si es un usuario móvil y obtener el ID primario.
 * @param {string} rawUserId - El ID de usuario del input o localStorage.
 * @returns {{primaryId: string, isMobile: boolean, originalId: string}}
 */
function parseUserId(rawUserId) {
    if (!rawUserId) {
        return { primaryId: null, isMobile: false, originalId: null };
    }
    const mobileRegex = /^(.*?)@(MÓVIL|MOVIL)$/i;
    const match = rawUserId.trim().match(mobileRegex);

    if (match && match[1]) {
        return {
            primaryId: match[1].trim(),
            isMobile: true,
            originalId: rawUserId.trim()
        };
    } else {
        return {
            primaryId: rawUserId.trim(),
            isMobile: false,
            originalId: rawUserId.trim()
        };
    }
}



    

/**
 * Actualiza el timestamp en localStorage para indicar que la caché ha sido modificada.
 * Esta es la función central para marcar la caché como "sucia" y pendiente de sincronización.
 */
function markCacheAsDirty() {
    localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
}
    



/**
 * Muestra un modal para que el usuario introduzca o establezca un PIN de 6 dígitos.
 * @param {string} message - Mensaje a mostrar al usuario (ej: "Introduce tu PIN", "Establece un PIN").
 * @param {function(string): void} onConfirm - Callback que se ejecuta con el PIN introducido si es válido.
 * @param {function(): void} onCancel - Callback que se ejecuta si el usuario cancela.
 * @param {boolean} isSettingPassword - True si es para establecer un nuevo PIN (mostrará confirmación).
 * @returns {void}
 */
function promptForBackupPassword(message, onConfirm, onCancel, isSettingPassword = false) {
    // Elimina cualquier modal existente para evitar duplicados
    const existingModal = document.getElementById('backup-password-modal-overlay');
    if (existingModal) existingModal.remove();

    const modalOverlay = document.createElement('div');
    modalOverlay.id = 'backup-password-modal-overlay';
    modalOverlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.85); display: flex; justify-content: center;
        align-items: center; z-index: 9999;
    `;

    const modalContent = document.createElement('div');
    modalContent.id = 'backup-password-modal-content';
    modalContent.style.cssText = `
        background-color: #DAC8A0; padding: 2rem; border-radius: 0.75rem;
        box-shadow: 0 5px 20px rgba(0,0,0,0.4); text-align: center; border: 1px solid #A0522D;
        margin-top: -50px; /* Un poco más arriba del centro */
        max-width: 350px; width: 90%;
    `;

    modalContent.innerHTML = `
        <h2 style="font-size: 1.5rem; font-weight: bold; color: #333; margin-bottom: 1rem;">${message}</h2>
        <input type="password" id="backup-password-input" maxlength="6" pattern="\\d{6}" inputmode="numeric" style="
            width: 150px; padding: 0.8rem; font-size: 1.8rem; text-align: center;
            border: 2px solid #A0522D; border-radius: 0.25rem; margin-bottom: 1.5rem;
            letter-spacing: 0.5em; background-color: #f0f0e0;
        " required>
        ${isSettingPassword ? `
            <label for="backup-password-confirm" style="display: block; font-size: 1.1rem; color: #444; margin-bottom: 0.8rem;">Confirmar PIN:</label>
            <input type="password" id="backup-password-confirm" maxlength="6" pattern="\\d{6}" inputmode="numeric" style="
                width: 150px; padding: 0.8rem; font-size: 1.8rem; text-align: center;
                border: 2px solid #A0522D; border-radius: 0.25rem; margin-bottom: 1.5rem;
                letter-spacing: 0.5em; background-color: #f0f0e0;
            " required>
        ` : ''}
        <p id="backup-password-error" style="color: #dc3545; font-weight: bold; margin-top: -0.5rem; margin-bottom: 1rem; min-height: 1.2em;"></p>
        <div style="display:flex; justify-content: space-around; gap:1rem;">
            <button id="backup-password-submit" style="padding: 0.8rem 1.5rem; font-size: 1.2rem; background-color: #28a745; color: white; border: none; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; flex: 1;">Aceptar</button>
            <button id="backup-password-cancel" style="padding: 0.8rem 1.5rem; font-size: 1.2rem; background-color: #6c757d; color: white; border: none; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; flex: 1;">Cancelar</button>
        </div>
    `;

    document.body.appendChild(modalOverlay);
    modalOverlay.appendChild(modalContent);

    const pinInput = document.getElementById('backup-password-input');
    const pinConfirmInput = document.getElementById('backup-password-confirm');
    const errorEl = document.getElementById('backup-password-error');
    const submitBtn = document.getElementById('backup-password-submit');
    const cancelBtn = document.getElementById('backup-password-cancel');

    pinInput.focus();

    const validateAndSubmit = () => {
        errorEl.textContent = '';
        const pin = pinInput.value;

        if (!/^\d{6}$/.test(pin)) {
            errorEl.textContent = 'El PIN debe ser de 6 dígitos numéricos.';
            if (navigator.vibrate) navigator.vibrate(100);
            return;
        }

        if (isSettingPassword) {
            const confirmPin = pinConfirmInput.value;
            if (pin !== confirmPin) {
                errorEl.textContent = 'Los PINs no coinciden.';
                if (navigator.vibrate) navigator.vibrate(100);
                return;
            }
        }

        modalOverlay.remove();
        onConfirm(pin);
    };

    submitBtn.addEventListener('click', validateAndSubmit);
    cancelBtn.addEventListener('click', () => {
        modalOverlay.remove();
        onCancel();
    });

    pinInput.addEventListener('keyup', (e) => {
        if (e.key === 'Enter') {
            if (isSettingPassword && pinConfirmInput) {
                pinConfirmInput.focus();
            } else {
                validateAndSubmit();
            }
        }
    });

    if (isSettingPassword && pinConfirmInput) {
        pinConfirmInput.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                validateAndSubmit();
            }
        });
    }

    addModalAutoCloseTimer(modalOverlay, submitBtn, 'backup-password-modal', isSettingPassword ? 90000 : 30000); // Más tiempo para establecer
}




async function callFirebase(action, data) {
    if (!window.db || !window.doc || !window.setDoc || !window.getDoc || !window.collection) { // Aseguramos que las funciones estén expuestas
        console.error("Firebase Firestore SDK functions no están expuestas globalmente.");
        return { status: "error", message: "Error interno: Funciones de Firebase no están disponibles." };
    }

    const userId = data.userId;
    if (!userId) {
        return { status: "error", message: "ID de Usuario es obligatorio para las operaciones de Firebase." };
    }

    try {
        const userDocRef = window.doc(window.db, "user_data", userId);

        if (action === 'saveUser') {
            const documentData = {
                usuario: data.usuario,
                modelo: data.modelo || '',
                anio: data.anio || '',
                provincia: data.provincia || '',
                rss: data.rss || false,
                contenidoCacheCompleto: JSON.stringify(data.datosCache), // Guarda el objeto de caché como una cadena JSON
                fechaBackup: new Date().toISOString(),
                backupPassword: data.backupPassword || null // <-- AÑADIDO: Guardar el PIN de backup
            };
            await window.setDoc(userDocRef, documentData); // Usa window.setDoc
            return { status: "success", message: "Datos guardados en Firebase." };
        } else if (action === 'getUserData') {
            const docSnap = await window.getDoc(userDocRef); // Usa window.getDoc
            if (docSnap.exists()) {
                const firebaseData = docSnap.data();
                try {
                    // Intenta parsear el contenidoCacheCompleto
                    firebaseData.contenidoCacheCompleto = JSON.parse(firebaseData.contenidoCacheCompleto);
                } catch (e) {
                    console.error("Error al parsear contenidoCacheCompleto de Firebase:", e);
                    // Si falla el parseo de la caché, aún podemos devolver los otros datos (como el PIN)
                }
                return { status: "success", message: "Datos recuperados de Firebase.", data: firebaseData };
            } else {
                return { status: "not_found", message: "No se encontró ningún backup para ese ID de Usuario." };
            }
        } else if (action === 'checkUserExists') {
             const docSnap = await window.getDoc(userDocRef); // Usa window.getDoc
             return { status: "success", exists: docSnap.exists() };
        } else {
            return { status: "error", message: "Acción de Firebase no reconocida." };
        }
    } catch (error) {
        console.error("Error en la operación de Firebase:", error);
        return { status: "error", message: `Error de Firebase: ${error.message}` };
    }
}   



async function validateAndSaveUserToFirebase() {
    const statusEl = document.getElementById('config-user-status');
    const userIdInput = document.getElementById('user-id');
    const { primaryId, isMobile, originalId } = parseUserId(userIdInput.value);

    if (!primaryId) {
        statusEl.textContent = 'El ID de Usuario es obligatorio.';
        statusEl.style.color = '#EF4444';
        return;
    }

    statusEl.textContent = 'Validando y preparando guardado...';
    statusEl.style.color = '#17a2b8';
    const toastId = "firebase-save-toast";
    showToast('Validando en la nube...', 'info', 0, false, toastId);

    const currentLocalUserId = localStorage.getItem('userData_userId');
    const localBackupPassword = localStorage.getItem('userData_backupPassword');
    const hasChangedUser = originalId.toLowerCase() !== (currentLocalUserId || '').toLowerCase();

    // Función interna para realizar el guardado final
    const completeSaveProcess = async (finalBackupPin) => {
        // ... (el contenido de esta función interna no cambia, es el mismo que en la versión anterior)
        localStorage.setItem('userData_userId', originalId);
        localStorage.setItem('userData_teslaModel', document.getElementById('tesla-model').value.trim());
        localStorage.setItem('userData_teslaYear', document.getElementById('tesla-year').value.trim());
        localStorage.setItem('userData_teslaProvince', document.getElementById('tesla-province').value.trim());
        localStorage.setItem('userData_allowDMs', JSON.stringify(document.getElementById('allow-dms').checked));
        localStorage.setItem('boardinggate_autoBackupOnLoad', JSON.stringify(document.getElementById('config-auto-backup-on-load').checked));
        localStorage.setItem('userData_backupPassword', finalBackupPin);
        updateUserIdDisplay();

        const cacheData = {};
        managedKeys.forEach(key => {
            const value = localStorage.getItem(key);
            if (value !== null) cacheData[key] = value;
        });

        const saveData = {
            userId: primaryId,
            usuario: primaryId,
            modelo: localStorage.getItem('userData_teslaModel') || '',
            anio: localStorage.getItem('userData_teslaYear') || '',
            provincia: localStorage.getItem('userData_teslaProvince') || '',
            rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
            datosCache: cacheData,
            backupPassword: finalBackupPin,
            fechaBackup: new Date().toISOString()
        };

        const saveResult = await callFirebase('saveUser', saveData);
        
        const existingToast = document.getElementById(toastId);
        if (existingToast) existingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== toastId);

        if (saveResult.status === 'success') {
            const successMsg = isMobile ?
                `Datos sincronizados con el usuario "${primaryId}".` :
                "Datos guardados en la nube y localmente.";
            statusEl.textContent = successMsg;
            statusEl.style.color = '#28a745';
            showToast(successMsg, 'success');
            localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
        } else {
            statusEl.textContent = `Error al guardar: ${saveResult.message}. (Datos guardados localmente).`;
            statusEl.style.color = '#EF4444';
            showToast(`Error al guardar: ${saveResult.message}`, 'error');
        }
    };

    // --- NUEVA LÓGICA DE VALIDACIÓN ---
    if (!hasChangedUser && localBackupPassword) {
        // CASO 1: El usuario no ha cambiado y ya tenemos un PIN local. GUARDADO SILENCIOSO.
        await completeSaveProcess(localBackupPassword);
    } else {
        // CASO 2: El usuario es nuevo, ha cambiado, o no tenemos PIN. Se requiere validación.
        const checkResult = await callFirebase('checkUserExists', { userId: primaryId });
        if (checkResult.status === 'error') {
            statusEl.textContent = `Error al verificar usuario en la nube: ${checkResult.message}.`;
            statusEl.style.color = '#EF4444';
            return;
        }

        if (checkResult.exists) {
            // El usuario existe en la nube, pedimos PIN para validar
            promptForBackupPassword(
                `Introduce el PIN para "${primaryId}":`,
                async (enteredPin) => {
                    const retrieveResult = await callFirebase('getUserData', { userId: primaryId });
                    if (retrieveResult.status === 'success' && retrieveResult.data && retrieveResult.data.backupPassword === enteredPin) {
                        await completeSaveProcess(enteredPin);
                    } else {
                        statusEl.textContent = 'PIN incorrecto. Guardado cancelado.';
                        statusEl.style.color = '#EF4444';
                        showToast('PIN incorrecto. Acceso denegado.', 'error');
                    }
                },
                () => { /* Cancelado por usuario */ }
            );
        } else {
            // El usuario no existe en la nube.
            if(isMobile) {
                statusEl.textContent = `El usuario primario "${primaryId}" no existe. No se puede sincronizar.`;
                statusEl.style.color = '#EF4444';
                return;
            }
            // Es un nuevo usuario primario, pedimos establecer PIN
            promptForBackupPassword(
                'Nuevo usuario. Establece un PIN de 6 dígitos:',
                (pin) => completeSaveProcess(pin),
                () => { /* Cancelado por usuario */ },
                true
            );
        }
    }
}
    
/**
 * Realiza el guardado automático en Firebase para un usuario móvil.
 * Esta función es llamada por checkReminders cuando detecta cambios.
 * @param {string} primaryId - El ID del usuario primario al que pertenece el móvil.
 * @param {string} backupPassword - El PIN de seguridad para autenticar.
 */
async function autoSaveFromMobile(primaryId, backupPassword) {
    showToast(`Sincronizando cambios con "${primaryId}"...`, 'info', 0, false, 'mobile-autosave');
    
    const cacheData = {};
    managedKeys.forEach(key => {
        const value = localStorage.getItem(key);
        if (value !== null) cacheData[key] = value;
    });

    const saveData = {
        userId: primaryId,
        usuario: primaryId,
        modelo: localStorage.getItem('userData_teslaModel') || '',
        anio: localStorage.getItem('userData_teslaYear') || '',
        provincia: localStorage.getItem('userData_teslaProvince') || '',
        rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
        datosCache: cacheData,
        backupPassword: backupPassword,
        fechaBackup: new Date().toISOString()
    };
    
    const saveResult = await callFirebase('saveUser', saveData);
    
    const toast = document.getElementById('mobile-autosave');
    if(toast) toast.remove();

    if (saveResult.status === 'success') {
        showToast('Cambios sincronizados con la nube.', 'success');
        // --- INICIO DE LA MODIFICACIÓN CLAVE ---
        // Actualizamos el timestamp de la última sincronización exitosa.
        lastMobileSyncTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');
        // --- FIN DE LA MODIFICACIÓN CLAVE ---
    } else {
        showToast(`Error al sincronizar: ${saveResult.message}`, 'error');
        // Si falló, NO actualizamos el timestamp, para que lo reintente en el próximo ciclo.
    }
}

    



/**
 * Sincroniza los datos al cargar la página.
 * Compara timestamps y decide si descargar de la nube (si es más nueva)
 * o subir a la nube (si lo local es más nuevo y es un usuario primario).
 */
async function syncDataOnLoad() {
    const autoSyncEnabled = JSON.parse(localStorage.getItem('boardinggate_autoBackupOnLoad') || 'false');
    const { primaryId, isMobile } = parseUserId(localStorage.getItem('userData_userId'));
    const backupPassword = localStorage.getItem('userData_backupPassword');

    if (!autoSyncEnabled || !primaryId || !backupPassword) {
        // Si no hay sync activado, al menos inicializamos el timestamp para el móvil
        if (isMobile) {
            lastMobileSyncTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');
        }
        return;
    }
    
    showToast(`Sincronizando datos para ${primaryId}...`, 'info', 4000, false, "auto-sync-toast");

    const result = await callFirebase('getUserData', { userId: primaryId });
    const existingToast = document.getElementById("auto-sync-toast");
    if (existingToast) existingToast.remove();
    activeToasts = activeToasts.filter(t => t.id !== "auto-sync-toast");
    
    if (result.status === 'success' && result.data) {
        const cloudTimestamp = new Date(result.data.fechaBackup || 0).getTime();
        const localTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');

        if (cloudTimestamp > localTimestamp + 10000) { 
            showToast(`Nuevos datos encontrados en la nube para ${primaryId}. Aplicando...`, 'info', 5000);
            
            const firebaseData = result.data;
            const backupCacheData = firebaseData.contenidoCacheCompleto;

            if (backupCacheData) {
                const currentUserIdentity = localStorage.getItem('userData_userId');

                for (const key in backupCacheData) {
                    if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                        localStorage.setItem(key, backupCacheData[key]);
                    }
                }
                
                if (currentUserIdentity) {
                    localStorage.setItem('userData_userId', currentUserIdentity);
                }

                const newTimestamp = Date.now().toString();
                localStorage.setItem('lastCacheUpdateTimestamp', newTimestamp);
                
                // --- CORRECCIÓN CRÍTICA ---
                // Sincronizamos el timestamp del móvil después de la descarga exitosa.
                if (isMobile) {
                    lastMobileSyncTimestamp = parseInt(newTimestamp);
                }
                // --- FIN DE LA CORRECCIÓN ---

                showToast('Datos sincronizados desde la nube. La página se recargará.', 'success', 3000);
                setTimeout(() => location.reload(), 2500);
            } else {
                showToast('Los datos en la nube están corruptos. No se pudo sincronizar.', 'error');
            }
            return;
        }
        
        if (!isMobile && (localTimestamp > cloudTimestamp + 10000)) {
            // ... (lógica de backup para el coche sin cambios)
            showToast('Realizando copia de seguridad automática...', 'info', 3000);
            const cacheData = {};
            managedKeys.forEach(key => {
                const value = localStorage.getItem(key);
                if (value !== null) cacheData[key] = value;
            });
            const requestData = {
                userId: primaryId, usuario: primaryId,
                modelo: localStorage.getItem('userData_teslaModel') || '',
                anio: localStorage.getItem('userData_teslaYear') || '',
                provincia: localStorage.getItem('userData_teslaProvince') || '',
                rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
                datosCache: cacheData,
                backupPassword: backupPassword,
                fechaBackup: new Date().toISOString()
            };
            await callFirebase('saveUser', requestData);
        }
    } else if (result.status === 'not_found' && !isMobile) {
        // ... (lógica para crear primer backup sin cambios)
        showToast(`Creando primera copia de seguridad para ${primaryId}...`, 'info', 3000);
        const cacheData = {};
        managedKeys.forEach(key => {
            const value = localStorage.getItem(key);
            if (value !== null) cacheData[key] = value;
        });
        const requestData = {
            userId: primaryId, usuario: primaryId,
            modelo: localStorage.getItem('userData_teslaModel') || '',
            anio: localStorage.getItem('userData_teslaYear') || '',
            provincia: localStorage.getItem('userData_teslaProvince') || '',
            rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
            datosCache: cacheData,
            backupPassword: backupPassword,
            fechaBackup: new Date().toISOString()
        };
        await callFirebase('saveUser', requestData);
    }
    
    // --- CORRECCIÓN CRÍTICA ---
    // Nos aseguramos de que el timestamp de sincronización móvil esté actualizado
    // incluso si no hubo descarga, para evitar un envío innecesario.
    if (isMobile) {
        lastMobileSyncTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');
    }
    // --- FIN DE LA CORRECCIÓN ---
}




    



async function restoreBackupFromFirebase(isAutoLoad = false) {
    const statusEl = document.getElementById('config-restore-status');
    const { primaryId, isMobile, originalId } = parseUserId(document.getElementById('restore-user-id').value || localStorage.getItem('userData_userId'));

    if (!primaryId) {
        if (!isAutoLoad) statusEl.textContent = 'Introduce un ID de Usuario para recuperar.';
        if (!isAutoLoad) statusEl.style.color = '#EF4444';
        return;
    }

    if (!isAutoLoad) {
        statusEl.textContent = `Buscando backup para "${primaryId}"...`;
        statusEl.style.color = '#17a2b8';
        showToast(`Recuperando backup de "${primaryId}"...`, 'info', 0, false, "firebase-restore-toast");
    }

    const result = await callFirebase('getUserData', { userId: primaryId });
    
    if (!isAutoLoad) {
        const existingToast = document.getElementById("firebase-restore-toast");
        if (existingToast) existingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== "firebase-restore-toast");
    }

    if (result.status === 'success' && result.data) {
        const firebaseData = result.data;
        const backupCacheData = firebaseData.contenidoCacheCompleto;

        if (!backupCacheData) {
            if (!isAutoLoad) {
                statusEl.textContent = `El backup para "${primaryId}" no contiene datos de caché.`;
                statusEl.style.color = '#EF4444';
                showToast('Backup incompleto.', 'error');
            }
            return;
        }

        const applyChanges = () => {
            const currentUserIdentity = localStorage.getItem('userData_userId') || originalId;
            for (const key in backupCacheData) {
                if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                    localStorage.setItem(key, backupCacheData[key]);
                }
            }
            localStorage.setItem('userData_userId', currentUserIdentity);
            const newTimestamp = Date.now().toString();
            localStorage.setItem('lastCacheUpdateTimestamp', newTimestamp);
            if (isMobile) {
                lastMobileSyncTimestamp = parseInt(newTimestamp);
            }
            showToast('Restauración completada. Recargando...', 'success', 3000);
            setTimeout(() => location.reload(), 2500);
        };

        if (isAutoLoad) {
            applyChanges();
        } else {
             promptForBackupPassword(
                `Introduce el PIN para "${primaryId}":`,
                (enteredPin) => {
                    if (enteredPin === firebaseData.backupPassword) {
                        if (confirm(`Se encontró un backup para "${primaryId}". ¿Estás seguro de que quieres restaurar estos datos?`)) {
                            applyChanges();
                        } else {
                            statusEl.textContent = 'Restauración cancelada.';
                            statusEl.style.color = '#6c757d';
                        }
                    } else {
                        statusEl.textContent = 'PIN incorrecto. Restauración cancelada.';
                        statusEl.style.color = '#EF4444';
                        showToast('PIN incorrecto.', 'error');
                    }
                },
                () => {
                    statusEl.textContent = 'Restauración cancelada.';
                    statusEl.style.color = '#6c757d';
                }
            );
        }
    } else if (result.status === 'not_found' && !isAutoLoad) {
        statusEl.textContent = `No se encontró backup para "${primaryId}".`;
        statusEl.style.color = '#EF4444';
        showToast('Backup no encontrado.', 'error not-found');
    } else if (!isAutoLoad) {
        statusEl.textContent = `Error al recuperar: ${result.message}`;
        statusEl.style.color = '#EF4444';
        showToast(`Error de recuperación: ${result.message}`, 'error');
    }
}


    






    
    
    



function getRandomSpeedMultiplierForManeuver(maneuver) {
    const type = maneuver.type || '';
    const modifier = maneuver.modifier || '';
    let min, max;

    if (type === 'roundabout' || type === 'rotary' || modifier.includes('sharp') || modifier.includes('uturn')) {
        // Maniobras lentas
        min = -0.30;
        max = 0.10;
    } else if (type === 'turn' || type === 'fork' || type === 'merge' || type === 'end of road') {
        // Maniobras normales
        min = -0.20;
        max = 0.20;
    } else {
        // Tramos rectos o maniobras suaves
        min = -0.05;
        max = 0.25;
    }

    return Math.random() * (max - min) + min;
}


    










function checkReminders() {
    if (isRecalculatingRoute && recalculationAttempts > 0) {
        return;
    }

    let currentReminders = []; try { currentReminders = JSON.parse(localStorage.getItem('reminders') || '[]'); } catch (e) { localStorage.setItem('reminders_backup_error', localStorage.getItem('reminders') || '[]'); localStorage.removeItem('reminders'); showToast("Error al cargar recordatorios. Backup intentado.", "error", 5000); return; }
    const now = new Date(); let overdueReminders = []; const validRemindersForStorage = []; let storageNeedsUpdate = false; const processedIds = new Set(); let newOverdueFound = false; let isAnyReminderNearby = false;

    new Promise((resolve) => {
        if (isSimulatingGpsLocation && simulatedGpsLocation) {
            resolve(simulatedGpsLocation);
        } else if (navigationCurrentLocation) {
            resolve(navigationCurrentLocation);
        } else if ('geolocation' in navigator) {
             getCurrentLocation( (coordsParam) => resolve(coordsParam), (errorMsg) => { resolve(null); } );
        } else {
            resolve(null);
        }
    }).then(async coords => {
        let allRemindersToCheck = [...currentReminders];
        const radaresRutaActivos = document.getElementById('radares-ruta-checkbox')?.checked;

        if (isNavigating && radaresRutaActivos && reminderMapObjects && reminderMapObjects.length > 0) {
            reminderMapObjects.forEach(mapObj => {
                if (mapObj.isFromRuta) {
                    const tempReminderFromMap = {
                        id: mapObj.reminderId, text: mapObj.marker.options.title || "RADAR RUTA", type: 'simple',
                        time: '00:00', date: new Date().toISOString().split('T')[0], createdAt: new Date().toISOString(),
                        managedByUser: false, isLocationEnabled: true,
                        locationCoordinates: { latitude: mapObj.marker.getLatLng().lat, longitude: mapObj.marker.getLatLng().lng },
                        radiusMeters: mapObj.circle ? mapObj.circle.getRadius() : 600,
                        excludeFromList: true, isFromRuta: true
                    };
                    allRemindersToCheck.push(tempReminderFromMap);
                }
            });
        }

        allRemindersToCheck.forEach(reminder => {
            if (!reminder || typeof reminder.id !== 'number' || typeof reminder.managedByUser === 'undefined' || !reminder.type || !reminder.time || !reminder.date || !reminder.createdAt) {
                if (!reminder.isFromRuta) storageNeedsUpdate = true;
                return;
            }
            if (processedIds.has(reminder.id)) {
                if (!reminder.isFromRuta) storageNeedsUpdate = true;
                return;
            }
            processedIds.add(reminder.id);
            if (reminder.isFromRuta && snoozedRouteRadars.has(reminder.id)) {
                const snoozeEndTime = snoozedRouteRadars.get(reminder.id);
                if (Date.now() < snoozeEndTime) { return; } else { snoozedRouteRadars.delete(reminder.id); }
            }
            const isManagedByUser = reminder.managedByUser === true; let keepInStorage = true; let isOverdue = false; let locationConditionMet = true;
            if (!isManagedByUser) {
                let reminderLocalDueTime = null; try { const [year, month, day] = reminder.date.split('-').map(Number); const [hour, minute] = reminder.time.split(':').map(Number); reminderLocalDueTime = new Date(year, month - 1, day, hour, minute);
                    if (isNaN(reminderLocalDueTime.getTime())) { throw new Error("Invalid date/time components"); }
                    if (reminderLocalDueTime <= now) {
                        isOverdue = true;
                        if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                            if (coords) {
                                const distance = calculateDistance( coords.latitude, coords.longitude, reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude );
                                locationConditionMet = distance <= (reminder.radiusMeters || DEFAULT_LOCATION_RADIUS);
                                if (locationConditionMet && distance < 1500) { isAnyReminderNearby = true; }
                            } else { locationConditionMet = false; }
                        }
                    } else if (reminder.isLocationEnabled && reminder.locationCoordinates && coords) {
                        const distance = calculateDistance( coords.latitude, coords.longitude, reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude );
                        if (distance < 1500) { isAnyReminderNearby = true; }
                    }
                } catch (error) {
                    if (!reminder.isFromRuta) storageNeedsUpdate = true;
                    keepInStorage = false; isOverdue = false; locationConditionMet = false;
                }
            }
             if (isOverdue && locationConditionMet) {
                overdueReminders.push(reminder);
                if (!isUnifiedWindowVisibleByLogic || !document.querySelector(`#unified-reminder-window .reminder-slide[data-id="${reminder.id}"]`)) {
                    newOverdueFound = true;
                }
            }
            if (keepInStorage && !reminder.isFromRuta) { validRemindersForStorage.push(reminder); }
        });
        if (storageNeedsUpdate) { try { const oldStorageString = localStorage.getItem('reminders') || '[]'; const newStorageString = JSON.stringify(validRemindersForStorage); if (oldStorageString !== newStorageString) { localStorage.setItem('reminders', newStorageString); } } catch (e) { showToast("Error al actualizar recordatorios tras limpieza.", "error", 5000); } }
        let shouldDisplayWindow = false;
        if (overdueReminders.length > 0) {
            if (!isUnifiedWindowVisibleByLogic || newOverdueFound) {
                shouldDisplayWindow = true;
                currentNotificationSlideIndex = 0;
                if (newOverdueFound) showYellowBorder();
            } else {
                const currentDisplayedIds = Array.from(document.querySelectorAll('#unified-reminder-window .reminder-slide')).map(el => parseInt(el.dataset.id));
                const newOverdueIds = overdueReminders.map(r => r.id);
                if (currentDisplayedIds.length !== newOverdueIds.length || !currentDisplayedIds.every(id => newOverdueIds.includes(id))) {
                    shouldDisplayWindow = true;
                }
            }
        }
        if (shouldDisplayWindow) {
             displayUnifiedReminderWindow(overdueReminders);
        } else if (overdueReminders.length === 0 && isUnifiedWindowVisibleByLogic) {
             hideUnifiedReminderWindow();
             currentNotificationSlideIndex = 0;
        }
        if (isNavigating && navigationCurrentLocation && !isRecalculatingRoute && !isDeviationModalActive && !isAddReminderAtLocationModeActive) {
            const currentCoords = navigationCurrentLocation;
            if (navigationMapInstance && navigationRouteLayer && navigationRouteLayer.getLatLngs().length > 0 && typeof L.GeometryUtil !== 'undefined' && L.GeometryUtil.closestLayerSnap) {
                const closestPointInfo = L.GeometryUtil.closestLayerSnap(navigationMapInstance, [navigationRouteLayer], L.latLng(currentCoords.latitude, currentCoords.longitude), DEVIATION_THRESHOLD_METERS * 2 , false);
                if (closestPointInfo) {
                    const distanceToRoute = closestPointInfo.distance;
                    if (distanceToRoute > DEVIATION_THRESHOLD_METERS) {
                        if (deviationStartTime === 0) {
                            deviationStartTime = Date.now();
                        } else if ((Date.now() - deviationStartTime) / 1000 > DEVIATION_MIN_TIME_SECONDS) {
                            showDeviationModal();
                            deviationStartTime = 0;
                        }
                    } else { deviationStartTime = 0; }
                } else {
                    if (deviationStartTime === 0) {
                         deviationStartTime = Date.now();
                    } else if ((Date.now() - deviationStartTime) / 1000 > DEVIATION_MIN_TIME_SECONDS) {
                         showDeviationModal();
                         deviationStartTime = 0;
                    }
                }
            }
        } else {
            deviationStartTime = 0;
        }
        updateReminderCount(); updateButtonStyles();
        let newInterval = isNavigating ? 1000 : 3000;
        if (isNavigating) {
            const distToNextManeuver = distanceToNextManeuverOSRM || Infinity;
             if (distToNextManeuver < 500 && distToNextManeuver > 0) {
                newInterval = 1000;
            } else if (distToNextManeuver < 1000 && distToNextManeuver > 0) {
                newInterval = 1500;
            } else {
                newInterval = 3000;
            }
        } else if (isAnyReminderNearby) {
             newInterval = 5000;
        }
        const unifiedWindowCurrentlyVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible');
        if (unifiedWindowCurrentlyVisible && (isNavigationMapActive)) {
            newInterval = Math.min(newInterval, 5000);
        }
        if (newInterval !== currentCheckIntervalDuration) {
            currentCheckIntervalDuration = newInterval;
            if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
            reminderCheckIntervalId = setInterval(checkReminders, currentCheckIntervalDuration);
        }
        const swiperContainer = document.getElementById('reminder-swiper-container');
        const windowElement = document.getElementById('unified-reminder-window');
        if (swiperContainer && overdueReminders.length > 0 && windowElement.classList.contains('visible') && newInterval !== 1000 && newInterval !== 5000) {
            const totalSlides = overdueReminders.length; let nextSlideIndex = currentNotificationSlideIndex;
            if (totalSlides > 1) { nextSlideIndex = (currentNotificationSlideIndex + 1) % totalSlides; } else { nextSlideIndex = 0; }
            if (totalSlides === 1 || nextSlideIndex !== currentNotificationSlideIndex) { currentNotificationSlideIndex = nextSlideIndex; const targetScrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth; swiperContainer.scrollTo({ left: targetScrollLeft, behavior: 'smooth' }); setTimeout(updateReminderIndexDisplay, 400); }
        }

        // --- LÓGICA DE SINCRONIZACIÓN SOLO PARA EL MÓVIL ---
        const { isMobile, primaryId } = parseUserId(localStorage.getItem('userData_userId'));
        
        if (isMobile) {
            const localTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');
            const backupPassword = localStorage.getItem('userData_backupPassword');
            
            if (backupPassword && localTimestamp > lastMobileSyncTimestamp) {
                autoSaveFromMobile(primaryId, backupPassword);
            }
        }
    });
}











    

    








/**
 * Llama al cálculo del zoom y guarda el resultado en una variable global.
 * No mueve el mapa directamente.
 */
function updateTurnByTurnDisplay(route, carDistanceAlongTheRoute = 0) {
    const topInfoBar = document.getElementById('navigation-top-info-bar');
    const intersectionPreviewWindow = document.getElementById('intersection-preview-map-window');

    if (!route || !topInfoBar || !route.legs || route.legs.length === 0) {
        if(topInfoBar) topInfoBar.style.display = 'none';
        if(intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
        updateDirectionWarningCardsVisibility();
        return;
    }

    if (!isNavigating && (!navigationCurrentRouteData || navigationWaypoints.length < 2)) {
         if(topInfoBar) topInfoBar.style.display = 'none';
         if(intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
         updateDirectionWarningCardsVisibility();
         return;
    }
    topInfoBar.style.display = 'flex';

    // --- Lógica de cálculo de indicaciones (sin cambios) ---
    const turnIconContainerEl = document.getElementById('turn-icon-container-styled');
    const turnIconDisplayEl = document.getElementById('turn-icon-display');
    const maneuverTextEl = document.getElementById('maneuver-text-display');
    const distanceFormattedEl = document.getElementById('distance-to-turn-formatted');
    const streetEl = document.getElementById('street-name-display');
    const progressBarEl = document.getElementById('distance-progress-bar-to-turn');

    const carDistance = Math.min(Math.max(0, carDistanceAlongTheRoute), route.distance);
    let distanceCoveredInRoute = 0;
    let currentLegIndex = -1; let currentStepIndex = -1;
    let nextStepToDisplay = null; let distanceToEndOfCurrentStepForProgress = 0;

    for (let i = 0; i < route.legs.length; i++) {
        const leg = route.legs[i];
        for (let j = 0; j < leg.steps.length; j++) {
            const step = leg.steps[j];
            if (carDistance < distanceCoveredInRoute + step.distance) { currentLegIndex = i; currentStepIndex = j; distanceToEndOfCurrentStepForProgress = distanceCoveredInRoute + step.distance; break; }
            distanceCoveredInRoute += step.distance;
        }
        if (currentLegIndex !== -1) break;
    }
    if (currentLegIndex === -1) { currentLegIndex = route.legs.length - 1; currentStepIndex = route.legs[currentLegIndex].steps.length - 1; distanceToEndOfCurrentStepForProgress = route.distance; }
    
    currentLegIndexNav = currentLegIndex; currentStepIndexNav = currentStepIndex;
    const currentLeg = route.legs[currentLegIndex];
    if (currentStepIndex + 1 < currentLeg.steps.length) { nextStepToDisplay = currentLeg.steps[currentStepIndex + 1]; } 
    else if (currentLegIndex + 1 < route.legs.length) { nextStepToDisplay = route.legs[currentLegIndex + 1].steps[0]; } 
    else { nextStepToDisplay = currentLeg.steps[currentStepIndex]; }
    
    const currentStepForProgress = currentLeg.steps[currentStepIndex];
    const distanceToNextManeuver = Math.max(0, distanceToEndOfCurrentStepForProgress - carDistance);
    
    // --- INICIO DE LA CORRECCIÓN ---
    // Guardamos el zoom calculado en la variable global. `updateInitialUserPosition` se encargará de usarlo.
    navigationTargetZoom = handleProgressiveManeuverZoom(currentStepForProgress, distanceToNextManeuver);
    // --- FIN DE LA CORRECCIÓN ---
    
    // El resto de la función (actualizar UI de indicaciones) no cambia
    if (nextStepToDisplay && nextStepToDisplay.maneuver) {
        const maneuver = nextStepToDisplay.maneuver;
        const type = maneuver.type || '';
        if (turnIconDisplayEl) {
            turnIconDisplayEl.innerHTML = '';
            const roundaboutExitTypes = ['roundabout turn', 'exit roundabout', 'rotary', 'roundabout'];
            if (roundaboutExitTypes.includes(type) && maneuver.exit && maneuver.exit >= 1 && maneuver.exit <= 5 && getManeuverInstructionText(maneuver).toLowerCase().includes("salida")) {
                const img = document.createElement('img'); img.src = `./S${maneuver.exit}.PNG`; img.alt = `Salida ${maneuver.exit}`; turnIconDisplayEl.appendChild(img);
            } else { const iconSpan = document.createElement('span'); const lrmIconClass = getLrmIconClass(maneuver); iconSpan.className = `leaflet-routing-icon ${lrmIconClass}`; turnIconDisplayEl.appendChild(iconSpan); }
        }
        let maneuverText = getManeuverInstructionText(maneuver);
        let streetNameText = nextStepToDisplay.name || '';
        if (type === 'arrive' || type === 'depart' || type === 'end of road' || type === 'roundabout' || type === 'rotary') { streetNameText = ''; }
        maneuverTextEl.textContent = maneuverText ? `${maneuverText} ` : ''; streetEl.textContent = streetNameText;
        distanceToNextManeuverOSRM = distanceToNextManeuver;
        if (distanceToNextManeuver < 1000) { distanceFormattedEl.textContent = `${Math.round(distanceToNextManeuver / 5) * 5} m`; } 
        else { distanceFormattedEl.textContent = `${(distanceToNextManeuver / 1000).toFixed(1)} km`; }
        const distanceCoveredInCurrentStep = (currentStepForProgress.distance || 0) - distanceToNextManeuver;
        const progressPercent = (currentStepForProgress.distance > 0) ? (distanceCoveredInCurrentStep / currentStepForProgress.distance) * 100 : (distanceToNextManeuver === 0 ? 100 : 0);
        progressBarEl.style.width = `${Math.min(100, Math.max(0, progressPercent))}%`;

        const isRelevantIntersectionManeuver = type !== 'continue' && type !== 'new name' && type !== 'depart' && type !== 'straight';
        if (isNavigating && distanceToNextManeuver < 800 && distanceToNextManeuver >= 100 && isRelevantIntersectionManeuver && (!intersectionPreviewWindow || intersectionPreviewWindow.classList.contains('hidden') || intersectionPreviewWindow.dataset.source !== 'click') && (currentLegIndex + '_' + currentStepIndex) !== lastAutoShownManeuverId) {
            showIntersectionPreviewMap(nextStepToDisplay, route, false, 4000);
            lastAutoShownManeuverId = currentLegIndex + '_' + currentStepIndex;
        } else if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click' && (distanceToNextManeuver >= 800 || distanceToNextManeuver < 100 || !isRelevantIntersectionManeuver)) {
            hideIntersectionPreviewMap();
        }
    } else {
        if (turnIconDisplayEl) turnIconDisplayEl.innerHTML = `<span class="leaflet-routing-icon leaflet-routing-icon-arrive"></span>`;
        maneuverTextEl.textContent = ''; distanceFormattedEl.textContent = '0 m'; streetEl.textContent = 'Calculando... o alcanzado.'; progressBarEl.style.width = '100%';
        distanceToNextManeuverOSRM = Infinity;
        if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
    }
    
    updateDirectionWarningCardsVisibility();
}










 /**
 * Controlador principal de la vista del mapa. Actualiza el icono y ejecuta una única animación
 * para el seguimiento (centrado/descentrado) y el zoom.
 * Incluye lógica de suavizado (smoothing) para un movimiento menos nervioso.
 */
function updateInitialUserPosition(coords, mapInstanceToUse) {
    if (!mapInstanceToUse || !coords || typeof coords.latitude !== 'number' || typeof coords.longitude !== 'number') {
        return;
    }
    const latLng = L.latLng(coords.latitude, coords.longitude);

    // --- Lógica de actualización del icono y estadísticas (SIN CAMBIOS) ---
    initialUserLocationMarkerLat = coords.latitude; initialUserLocationMarkerLng = coords.longitude;
    if (!initialUserLocationMarker) {
        initialUserLocationMarker = L.marker(latLng, { icon: vehicleIcon, zIndexOffset: 1000, interactive: false });
        if (mapInstanceToUse && mapInstanceToUse.getPane) { try { initialUserLocationMarker.addTo(mapInstanceToUse); } catch (e) { return; } } else { return; }
    } else { initialUserLocationMarker.setLatLng(latLng); }
    const currentHeading = (coords && typeof coords.heading === 'number' && coords.heading !== null) ? coords.heading : (currentMapBearing || 0);
    const vehicleWrapper = initialUserLocationMarker.getElement()?.querySelector('#vehicle-icon-wrapper');
    if (vehicleWrapper) { let iconRotationAngle = currentHeading - 90; vehicleWrapper.style.transform = `rotate(${iconRotationAngle}deg)`; }
    if (compassAndModeControl) { /* ... toda la lógica de estadísticas se mantiene igual ... */
        compassAndModeControl.updateOrientation(currentHeading); compassAndModeControl.updateAltitude(coords.altitude);
        if (window.lastPositionForSpeedCalc && typeof coords.latitude === 'number' && typeof coords.longitude === 'number' && typeof coords.speed === 'number' && coords.speed !== null) { const distM = calculateDistance(window.lastPositionForSpeedCalc.latitude, window.lastPositionForSpeedCalc.longitude, coords.latitude, coords.longitude); const timeS = (Date.now() - window.lastPositionForSpeedCalc.time) / 1000; if (timeS > 0 && distM >= 0) { let speedMs = coords.speed; if (typeof speedMs !== 'number' || speedMs === null || speedMs < 0) { speedMs = distM / timeS; } window.currentSpeedKmh = speedMs * 3.6; } else { window.currentSpeedKmh = 0; } } else { if (typeof coords.speed === 'number' && coords.speed !== null && coords.speed >= 0) { window.currentSpeedKmh = coords.speed * 3.6; } else { window.currentSpeedKmh = 0; } }
        window.lastPositionForSpeedCalc = { latitude: coords.latitude, longitude: coords.longitude, time: Date.now() };
        if (isNavigating || (isSimulatingGpsLocation && automatedSimulationIntervalId)) { if (window.currentSpeedKmh > maxSpeedDuringTrip) { maxSpeedDuringTrip = window.currentSpeedKmh; if (coords) { maxSpeedCoordinates = { lat: coords.latitude, lng: coords.longitude }; } } const currentSpeed = window.currentSpeedKmh; for (const milestone of SPEED_MILESTONES) { if (currentSpeed >= milestone && lastSpeedMilestone < milestone) { const milestoneIcon = L.divIcon({ className: 'speed-milestone-icon', html: `<div style="background-color: #007bff; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; border: 2px solid white; box-shadow: 0 0 4px black;">${milestone}</div>`, iconSize: [36, 36], iconAnchor: [18, 18] }); if (speedMilestoneLayer) { L.marker([coords.latitude, coords.longitude], { icon: milestoneIcon }).addTo(speedMilestoneLayer); } lastSpeedMilestone = milestone; break; } } if (currentSpeed < lastSpeedMilestone) { let newMilestone = 0; for (let i = SPEED_MILESTONES.length - 1; i >= 0; i--) { if (currentSpeed >= SPEED_MILESTONES[i]) { newMilestone = SPEED_MILESTONES[i]; break; } } lastSpeedMilestone = newMilestone; } if (coords.altitude !== null && !isNaN(coords.altitude)) { maxAltitudeDuringTrip = Math.max(maxAltitudeDuringTrip, coords.altitude); minAltitudeDuringTrip = Math.min(minAltitudeDuringTrip, coords.altitude); } }
        if (isNavigating && navigationStartTimeForStats && typeof totalDistanceTravelledForStats === 'number') { if (lastPositionForStats && coords) { const distanceIncrement = calculateDistance(lastPositionForStats.latitude, lastPositionForStats.longitude, coords.latitude, coords.longitude); if (distanceIncrement > 0 && distanceIncrement < 5000) { totalDistanceTravelledForStats += distanceIncrement; } } lastPositionForStats = { ...coords }; const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000; if (timeElapsedS > 0 && totalDistanceTravelledForStats > 0) { const avgSpeedMs = totalDistanceTravelledForStats / timeElapsedS; window.averageSpeedKmh = avgSpeedMs * 3.6; } else { window.averageSpeedKmh = 0; } } else if (isSimulatingGpsLocation && automatedSimulationIntervalId && navigationStartTimeForStats && typeof simulatedDistanceAlongRoute === 'number') { const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000; if (timeElapsedS > 0 && simulatedDistanceAlongRoute > 0) { const avgSpeedMs = simulatedDistanceAlongRoute / timeElapsedS; window.averageSpeedKmh = avgSpeedMs * 3.6; } else { window.averageSpeedKmh = 0; } } else { window.averageSpeedKmh = 0; }
        compassAndModeControl.updateCurrentSpeed(window.currentSpeedKmh); compassAndModeControl.updateAverageSpeed(window.averageSpeedKmh); compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip);
    }

    const shouldFollow = shouldCenterOnUser || navigationFollowUser;
    
    // --- INICIO DE LA LÓGICA DE CONTROL Y SUAVIZADO ---
    if (shouldFollow && navigationMapInstance && !isFlying) {
        // 1. Determina el nivel de zoom objetivo
        const finalZoom = navigationTargetZoom !== null ? navigationTargetZoom : navigationMapInstance.getZoom();

        // 2. Calcula el centro IDEAL del mapa (con descentrado)
        const effectiveHeading = (coords && typeof coords.heading === 'number' && coords.heading !== null) ? coords.heading : (currentMapBearing || 0);
        const mapSize = mapInstanceToUse.getSize();
        const offsetFactor = 0.33;
        const minMapDimension = Math.min(mapSize.x, mapSize.y);
        const offsetDistance = minMapDimension * offsetFactor;
        const headingRad = (effectiveHeading % 360) * Math.PI / 180;
        targetMapCenterOffset = { x: -offsetDistance * Math.sin(headingRad), y: offsetDistance * Math.cos(headingRad) };
        
        const vehicleLatLng = L.latLng(coords.latitude, coords.longitude);
        const vehicleScreenPos = navigationMapInstance.project(vehicleLatLng);
        const idealMapCenterScreenPos = L.point(vehicleScreenPos.x - targetMapCenterOffset.x, vehicleScreenPos.y - targetMapCenterOffset.y);
        const idealMapCenterLatLng = navigationMapInstance.unproject(idealMapCenterScreenPos);

        // --- LÓGICA DE SUAVIZADO (LERP) ---
        // Si es la primera vez, el centro suavizado es el ideal.
        if (currentSmoothedMapCenter === null) {
            currentSmoothedMapCenter = idealMapCenterLatLng;
        }

        // Interpolación lineal: Mueve el centro suavizado un pequeño porcentaje
        // hacia el centro ideal en cada fotograma. Un valor más bajo es más suave.
        const lerpFactor = 0.1; // 10% del camino en cada tick
        currentSmoothedMapCenter = L.latLng(
            currentSmoothedMapCenter.lat + (idealMapCenterLatLng.lat - currentSmoothedMapCenter.lat) * lerpFactor,
            currentSmoothedMapCenter.lng + (idealMapCenterLatLng.lng - currentSmoothedMapCenter.lng) * lerpFactor
        );

        // 3. Ejecutar la animación usando el centro SUAVIZADO
        const currentZoom = navigationMapInstance.getZoom();
        const zoomDifference = Math.abs(currentZoom - finalZoom);
        
        // El umbral de diferencia de centro ahora es más pequeño, ya que el movimiento es más sutil
        if (zoomDifference > 0.05 || currentSmoothedMapCenter.distanceTo(navigationMapInstance.getCenter()) > 1) {
            isFlying = true;
            navigationMapInstance.flyTo(currentSmoothedMapCenter, finalZoom, {
                animate: true,
                duration: 1.0, // Duración consistente
                easeLinearity: 0.5
            });
            setTimeout(() => { isFlying = false; }, 1050);
        }
    } else {
        // Si no estamos siguiendo, reseteamos el centro suavizado.
        currentSmoothedMapCenter = null;
    }
    
    navigationTargetZoom = null;
    updateDirectionWarningCardsVisibility();
}   








    



    
    



    










/**
 * Realiza una animación de zoom suave y fluida usando requestAnimationFrame.
 * @param {number} startZoom - El nivel de zoom inicial.
 * @param {number} endZoom - El nivel de zoom final.
 * @param {number} duration - Duración de la animación en milisegundos.
 */
function smoothZoomAnimation(startZoom, endZoom, duration = 1200) {
    if (isAnimatingZoom || !navigationMapInstance) return;

    isAnimatingZoom = true;
    const startTime = performance.now();

    function animate(currentTime) {
        const elapsedTime = currentTime - startTime;
        const progress = Math.min(elapsedTime / duration, 1); // Progreso de 0 a 1

        // Interpolación lineal para el nivel de zoom
        const currentZoom = startZoom + (endZoom - startZoom) * progress;
        
        // El centro del mapa se mantiene en la posición actual del vehículo (descentrado)
        let targetCenter = navigationMapInstance.getCenter();
        if (navigationCurrentLocation) {
            const vehicleLatLng = L.latLng(navigationCurrentLocation.latitude, navigationCurrentLocation.longitude);
            const vehicleScreenPos = navigationMapInstance.project(vehicleLatLng);
            const idealMapCenterScreenPos = L.point(
                vehicleScreenPos.x - targetMapCenterOffset.x,
                vehicleScreenPos.y - targetMapCenterOffset.y
            );
            targetCenter = navigationMapInstance.unproject(idealMapCenterScreenPos);
        }

        // Usamos setView para actualizar centro y zoom en cada fotograma
        navigationMapInstance.setView(targetCenter, currentZoom, { animate: false });

        if (progress < 1) {
            // Si la animación no ha terminado, solicita el siguiente fotograma
            requestAnimationFrame(animate);
        } else {
            // La animación ha terminado, reseteamos el flag
            isAnimatingZoom = false;
        }
    }

    // Inicia el primer fotograma de la animación
    requestAnimationFrame(animate);
}






    

    




/**
 * Procede con el recálculo de la ruta basándose en la acción del usuario desde el modal de desvío.
 * @param {string} action - La acción decidida: 'recalculate_forward', 'recalculate_turn_back', 'skip_one', 'skip_multiple'.
 */
async function proceedWithRecalculation(action) {
    if (!isNavigating || !navigationCurrentLocation) {
        showToast("No se puede recalcular: no se está navegando o la ubicación es desconocida.", "error");
        return;
    }

    if (action === 'skip_one') {
        const nextUnvisitedStageIndex = navigationWaypoints.findIndex(wp => wp && !wp.isInternal && !wp.isRecalculatedStart && !wp.visited && wp.type !== 'S' && wp.type !== 'S_Recalc');
        if (nextUnvisitedStageIndex !== -1) {
            navigationWaypoints[nextUnvisitedStageIndex].visited = true;
            showToast(`Omitiendo etapa: ${navigationWaypoints[nextUnvisitedStageIndex].address || 'Siguiente' }`, "info");
        } else {
            showToast("No hay próximas etapas para omitir. Recalculando a destino.", "info");
        }
    } else if (action === 'skip_multiple') {
        const stagesToSkip = [];
        const currentHeading = navigationCurrentLocation.heading;
        navigationWaypoints.forEach(wp => {
            if (wp.visited || wp.type === 'S' || wp.type === 'S_Recalc') return;
            const bearingToWp = turf.bearing(
                turf.point([navigationCurrentLocation.longitude, navigationCurrentLocation.latitude]),
                turf.point([wp.lng, wp.lat])
            );
            let angleDiff = Math.abs(currentHeading - (bearingToWp < 0 ? bearingToWp + 360 : bearingToWp));
            if (angleDiff > 180) angleDiff = 360 - angleDiff;
            if (angleDiff > 110) {
                stagesToSkip.push(wp.id);
            }
        });
        if (stagesToSkip.length > 0) {
            navigationWaypoints.forEach(wp => {
                if (stagesToSkip.includes(wp.id)) wp.visited = true;
            });
            showToast(`Saltando ${stagesToSkip.length} etapas que han quedado atrás.`, "info");
        }
    }
    
    // 'recalculate_forward' y 'recalculate_turn_back' no necesitan marcar etapas aquí.
    // Todas las acciones ('recalculate_forward', 'recalculate_turn_back', y las de skip) terminan en un recálculo.
    await recalculateAndDrawRoute(true);
}
    




    

    



/**
 * Cierra el modal de desvío y ejecuta la acción seleccionada por el usuario.
 * @param {string} action - La acción a realizar ('recalculate_forward', 'recalculate_turn_back', 'skip_one', 'skip_multiple').
 */
function closeModalAndProceed(action) {
    if (deviationModalTimerId) {
        clearInterval(deviationModalTimerId);
        deviationModalTimerId = null;
    }
    const modal = document.getElementById('deviation-modal');
    if (modal) {
        const primaryButton = modal.querySelector('#deviation-primary') || modal.querySelector('button');
        clearModalAutoCloseTimer(modal, primaryButton, 'deviation-modal');
        modal.classList.add('hidden');
    }
    isDeviationModalActive = false;
    deviationStartTime = 0;

    proceedWithRecalculation(action);
}



    

    




    

function clearNavigationGraph() {
    // Detiene el temporizador que añade datos a la gráfica.
    if (graphIntervalTimer) {
        clearInterval(graphIntervalTimer);
        graphIntervalTimer = null;
    }
    // Destruye la instancia del gráfico si existe.
    if (navigationChart) {
        navigationChart.destroy();
        navigationChart = null;
    }
    // Oculta el contenedor de la gráfica.
    const graphCard = document.getElementById('navigation-graph-card');
    if (graphCard) {
        graphCard.classList.add('hidden');
    }
    // Resetea los arrays de datos.
    graphDataPoints = { speed: [], altitude: [] };
    graphLabels = [];
}



    
    
    
    
function hideNavigationUI() {
    const topInfoBar = document.getElementById('navigation-top-info-bar');
    const bottomProgressBar = document.getElementById('navigation-bottom-progress-bar');
    const startNavButton = document.getElementById('start-navigation-button');
    const saveRouteButton = document.getElementById('save-route-button');
    const reorderBtn = document.getElementById('reorder-route-stages-button');
    const simulateBtn = document.getElementById('simulate-route-button');
    const toggleSimulateGpsBtn = document.getElementById('toggle-simulate-gps-button');
    const graphCard = document.getElementById('navigation-graph-card');

    if (topInfoBar) topInfoBar.style.display = 'none';
    if (bottomProgressBar) bottomProgressBar.style.display = 'none';
    if (startNavButton) startNavButton.classList.add('hidden');
    if (saveRouteButton) saveRouteButton.classList.add('hidden');
    if (reorderBtn) reorderBtn.style.display = 'none';
    if (simulateBtn) simulateBtn.style.display = 'none';
    if (graphCard) graphCard.classList.add('hidden');


    if (toggleSimulateGpsBtn && isSimulatingGpsLocation) {
    } else if (toggleSimulateGpsBtn) {
        toggleSimulateGpsBtn.style.display = 'none';
    }


    hideIntersectionPreviewMap();
    updateDirectionWarningCardsVisibility();
}


function showNavigationUIElementsForPlanning() {
    const topInfoBar = document.getElementById('navigation-top-info-bar');
    const bottomProgressBar = document.getElementById('navigation-bottom-progress-bar');

    if (!navigationCurrentRouteData || !navigationCurrentRouteData.routes || navigationCurrentRouteData.routes.length === 0 || navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
        if (topInfoBar) topInfoBar.style.display = 'none';
        if (bottomProgressBar) bottomProgressBar.style.display = 'none';
        hideMapInfoOverlay();
        hideIntersectionPreviewMap();
    } else {
        if (topInfoBar) topInfoBar.style.display = 'flex';
        if (bottomProgressBar) bottomProgressBar.style.display = 'flex';

        let carDistAlongRoutePlan = 0;
        const currentCarPosForShowUI = navigationCurrentLocation;
        if (currentCarPosForShowUI && navigationMapInstance && navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
            try {
                const carPointTurf = turf.point([currentCarPosForShowUI.longitude, currentCarPosForShowUI.latitude]);
                const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
               
                const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                carDistAlongRoutePlan = turf.length(lineSliceToNearestTurf, { units: 'meters' });
            } catch(e){  }
         }
        updateTurnByTurnDisplay(navigationCurrentRouteData.routes[0], carDistAlongRoutePlan);
        showDestinationName();
    }
    updateDirectionWarningCardsVisibility();
}

    function getManeuverInstructionText(maneuver) {
        if (!maneuver) return '';
        const type = maneuver.type || '';
        const modifier = maneuver.modifier || '';
        let exit = maneuver.exit;

        let key = `${type}-${modifier}`;
        let text = maneuverTexts[key];

        if (!text) {
            key = `${type}-`;
            text = maneuverTexts[key];
        }

        if (!text && type === 'turn' && !modifier) {
            text = maneuverTexts['turn-'] || type.replace(/-/g, ' ');
        } else if (!text) {
            text = type.replace(/-/g, ' ');
        }

        const roundaboutExitTypes = ['roundabout turn', 'exit roundabout', 'rotary', 'roundabout'];
        if (roundaboutExitTypes.includes(type) && typeof exit === 'number' && exit > 0) {
             const ordinals = ["", "primera", "segunda", "tercera", "cuarta", "quinta"];
             const ordinalText = (exit >= 1 && exit <= 5) ? ordinals[exit] : `${exit}ª`;
             text = `Sal en la rotonda en la ${ordinalText} salida`;
        }

        let baseText = text.charAt(0).toUpperCase() + text.slice(1);
        return baseText;
    }

    function getLrmIconClass(maneuver) {
        if (!maneuver) return 'leaflet-routing-icon-continue';
        const type = maneuver.type || '';
        const modifier = maneuver.modifier || '';

        if (type === 'depart') return 'leaflet-routing-icon-depart';
        if (type === 'arrive') return 'leaflet-routing-icon-arrive';

        if (type === 'turn') {
            if (modifier.includes('sharp left')) return 'leaflet-routing-icon-sharp-left';
            if (modifier.includes('left')) return 'leaflet-routing-icon-turn-left';
            if (modifier.includes('slight left')) return 'leaflet-routing-icon-bear-left';
            if (modifier.includes('sharp right')) return 'leaflet-routing-icon-sharp-right';
            if (modifier.includes('right')) return 'leaflet-routing-icon-turn-right';
            if (modifier.includes('slight right')) return 'leaflet-routing-icon-bear-right';
  if (modifier.includes('uturn')) return 'leaflet-routing-icon-u-turn';
        } else if (type === 'new name' || type === 'continue') {
            if (modifier.includes('straight')) return 'leaflet-routing-icon-continue';
            if (modifier.includes('slight left')) return 'leaflet-routing-icon-bear-left';
            if (modifier.includes('slight right')) return 'leaflet-routing-icon-bear-right';
        } else if (type === 'roundabout' || type === 'rotary' || type === 'roundabout turn' || type === 'exit roundabout' || type === 'exit rotary') {
            if (maneuver.exit && maneuver.exit >= 1 && maneuver.exit <= 5) {
                return 'leaflet-routing-icon-roundabout';
            }
            return 'leaflet-routing-icon-roundabout';
        } else if (type === 'fork') {
            if (modifier.includes('left')) return 'leaflet-routing-icon-bear-left';
            if (modifier.includes('right')) return 'leaflet-routing-icon-bear-right';
            return 'leaflet-routing-icon-continue';
        } else if (type === 'merge') {
            if (modifier.includes('left')) return 'leaflet-routing-icon-bear-left';
            if (modifier.includes('right')) return 'leaflet-routing-icon-bear-right';
            return 'leaflet-routing-icon-continue';
        } else if (type === 'end of road') {
            if (modifier.includes('left')) return 'leaflet-routing-icon-turn-left';
            if (modifier.includes('right')) return 'leaflet-routing-icon-turn-right';
            return 'leaflet-routing-icon-continue';
        }
        if (type === 'turn' && !modifier) return 'leaflet-routing-icon-continue';

        return 'leaflet-routing-icon-continue';
    }


    let lastPreciseRecalcTime = 0;
    const PRECISE_RECALC_INTERVAL = 120000;
    let distanceToNextManeuverOSRM = Infinity;

    function formatDeviation(milliseconds) {
    if (typeof milliseconds !== 'number' || isNaN(milliseconds)) {
        return '';
    }

    const totalSeconds = Math.round(Math.abs(milliseconds) / 1000);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);

    const sign = milliseconds >= 0 ? '+' : '-';
    const colorClass = milliseconds >= 0 ? 'positive' : 'negative';

    const formattedTime = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;

    return `<span class="eta-deviation ${colorClass}">[${sign}${formattedTime}]</span>`;
}
    

function updateRouteAndCarIconStyle() {
    if (!navigationMapInstance) return;

    let activeLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "satélite + calles";
    activeLayerName = activeLayerName.toLowerCase();

    if (!localStorage.getItem(ACTIVE_MAP_LAYER_KEY) && mapLayersControl && mapLayersControl._map && mapLayersControl._map._layers) {
        const layersArray = Object.values(mapLayersControl._map._layers);
        const baseLayerMapObject = layersArray.find(l => l._map && l.options && !l.options.pane && l.options.attribution);

        if (baseLayerMapObject) {
            const activeLayerEntry = mapLayersControl._layers.find(l => l.layer === baseLayerMapObject);
             if (activeLayerEntry && activeLayerEntry.name) {
                activeLayerName = activeLayerEntry.name.toLowerCase();
            }
        }
    }

    if (navigationRouteLayer) {
        const isSatelliteViewForRoute = activeLayerName.includes('satélite') || activeLayerName.includes('satellite');
        
        // --- INICIO DE LA MODIFICACIÓN ---
        if (isSatelliteViewForRoute) {
            // Estilo para mapas de satélite (amarillo, grueso, opaco)
            navigationRouteLayer.setStyle({ 
                color: 'yellow', 
                weight: 10,
                opacity: 1.0 
            });
        } else {
            // Estilo para mapa normal (azul, grueso, semitransparente)
            navigationRouteLayer.setStyle({ 
                color: 'blue', 
                weight: 10,       // Mismo grosor
                opacity: 0.5    // Opacidad reducida
            });
        }
        // --- FIN DE LA MODIFICACIÓN ---
    }
}








    

function parseCoordinateFilter(filterValue, coordinate) {
    if (!filterValue) return true;
    const parts = filterValue.trim().split(/\s+/).map(s => parseFloat(s.replace(',','.'))).filter(n => !isNaN(n));

    if (parts.length === 1) {
        return Math.abs(coordinate - parts[0]) < COORD_EPSILON;
    } else if (parts.length === 2) {
        const minVal = Math.min(parts[0], parts[1]);
        const maxVal = Math.max(parts[0], parts[1]);
        return coordinate >= minVal && coordinate <= maxVal;
    } else if (parts.length === 0 && filterValue.trim() !== "") {
        return false;
    }
    return true;
}

function closeOtherModals(modalToKeepOpenId = null) {
    STATIC_MODAL_IDS.forEach(id => {
        if (id === modalToKeepOpenId) return;
        const modal = document.getElementById(id);
        if (modal && !modal.classList.contains('hidden')) {
            if (id === 'reorder-stages-modal') {
                const listElement = modal.querySelector('#sortable-stages-list');
                if (listElement) {
                    listElement.removeEventListener('dragstart', handleDragStartReorder);
                    listElement.removeEventListener('dragend', handleDragEndReorder);
                    listElement.removeEventListener('dragover', handleDragOverReorder);
                    listElement.removeEventListener('touchstart', handleStageTouchStart);
                    listElement.removeEventListener('touchmove', handleStageTouchMove);
                    listElement.removeEventListener('touchend', handleStageTouchEnd);
                    listElement.removeEventListener('touchcancel', handleStageTouchEnd);
                }
                if (draggedStageLi) {
                    draggedStageLi.classList.remove('dragging');
                    draggedStageLi = null;
                }
                clearTimeout(stageScrollTimeout);
                document.body.style.overflow = '';
            }
             if (id === 'deviation-modal') {
                if (deviationModalTimerId) clearInterval(deviationModalTimerId);
                deviationModalTimerId = null;
                isDeviationModalActive = false;
            }
             if (id === 'arrival-stats-modal') {
                const acceptButton = modal.querySelector('#arrival-stats-accept-button');
                if (acceptButton) clearModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal');
             }
             if (id === 'simulation-speed-modal') {
                const confirmBtn = modal.querySelector('#confirm-simulation-speed');
                if(confirmBtn) clearModalAutoCloseTimer(modal, confirmBtn, 'simulation-speed-modal');
             }
            modal.classList.add('hidden');
            const closeBtn = modal.querySelector('button[id^="close-"], button[id*="-close"], #cancel-postpone, #close-saved-routes-modal, #cancel-reorder-stages, #config-close-modal, #close-versions-modal, #pin-submit-button, #close-simulation-modal, #close-locations-preview, #close-address-suggestions-modal, #deviation-accept, #arrival-stats-accept-button, #cancel-simulation-speed');
            if (closeBtn) clearModalAutoCloseTimer(modal, closeBtn, id.replace(/-/g, '_') || `modal_timer_${Date.now()}`);
             if (id === 'simulation-modal') {
                 if (simulationModalTimer) {
                     clearTimeout(simulationModalTimer);
                     simulationModalTimer = null;
                 }
                 hideIntersectionPreviewMap();
             }
        }
    });

    document.querySelectorAll(
        '.choice-modal, .edit-modal, .edit-info-modal, .help-modal, .reminder-modal, .reminder-table-modal, #postpone-options-modal, .saved-locations-modal, #reminders-map-help-modal-instance'
    ).forEach(m => {
        if (m.id === modalToKeepOpenId) return;
        if (m.parentNode) {
             const closeBtn = m.querySelector('button[id^="close-"], button[id*="-close"], #cancel-postpone');
             if(closeBtn) clearModalAutoCloseTimer(m, closeBtn, m.id.replace(/-/g, '_') || `modal_timer_${Date.now()}`);
             m.remove();
        }
    });

     if (modalToKeepOpenId !== 'unified-reminder-window') {
        hideUnifiedReminderWindow();
     }
}


  function showConfigModal() {
    closeOtherModals('config-modal');
    const modal = document.getElementById('config-modal');
    if (modal) {
        const firstTabButton = modal.querySelector('.config-tab-button[data-tab-target="#tab-content-usuario"]');
        const firstTabContent = modal.querySelector('#tab-content-usuario');
        if (firstTabButton && firstTabContent) {
            modal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
            modal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
            firstTabButton.classList.add('active');
            firstTabContent.classList.add('active');
        }
        const statusMessages = modal.querySelectorAll('.status-message');
        statusMessages.forEach(msg => msg.textContent = '');

        modal.querySelectorAll('input[type="text"], input[type="number"], textarea').forEach(input => {
            if (input.id !== 'user-id' && input.id !== 'config-pin-set' && input.id !== 'config-pin-confirm') {
                input.value = '';
            }
        });
        modal.querySelector('#config-pin-set').value = '';
        modal.querySelector('#config-pin-confirm').value = '';
        modal.querySelector('#config-backup-display').value = '';
        modal.querySelector('#config-restore-input').value = '';
        if(modal.querySelector('#config-backup-display')) modal.querySelector('#config-backup-display').style.display = 'none';


        const userIdInput = modal.querySelector('#user-id');
        const storedUserId = localStorage.getItem('userData_userId');
        if (userIdInput && storedUserId) {
            userIdInput.value = storedUserId;
        } else if (userIdInput) {
            userIdInput.value = '';
        }
         const teslaModelInput = modal.querySelector('#tesla-model');
         if (teslaModelInput) teslaModelInput.value = localStorage.getItem('userData_teslaModel') || '';
         const teslaYearInput = modal.querySelector('#tesla-year');
         if (teslaYearInput) teslaYearInput.value = localStorage.getItem('userData_teslaYear') || '';
         const teslaProvinceInput = modal.querySelector('#tesla-province');
         if (teslaProvinceInput) teslaProvinceInput.value = localStorage.getItem('userData_teslaProvince') || '';
         const allowDmsCheckbox = modal.querySelector('#allow-dms');
         if (allowDmsCheckbox) allowDmsCheckbox.checked = JSON.parse(localStorage.getItem('userData_allowDMs')) || false;

        const directToNavCheckbox = document.getElementById('config-direct-to-nav');
        if (directToNavCheckbox) {
            directToNavCheckbox.checked = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
        }

        const backupDescSpan = modal.querySelector('#backup-data-description');
        if(backupDescSpan) backupDescSpan.textContent = managedDesc || 'No se pudo cargar descripción.';


        const importRadarsButton = modal.querySelector('#import-radars-button');
        const deleteFilteredRadarsButton = modal.querySelector('#delete-filtered-radars-button');

        if (importRadarsButton && !importRadarsButton.dataset.listenerAttached) {
            importRadarsButton.addEventListener('click', importRadars);
            importRadarsButton.dataset.listenerAttached = "true";
        }

        if (deleteFilteredRadarsButton && !deleteFilteredRadarsButton.dataset.listenerAttached) {
            deleteFilteredRadarsButton.addEventListener('click', deleteFilteredRadars);
            deleteFilteredRadarsButton.dataset.listenerAttached = "true";
        }
        modal.classList.remove('hidden');
        const closeButtonConfig = modal.querySelector('#config-close-modal');
        addModalAutoCloseTimer(modal, closeButtonConfig, 'config-modal', 120000);
    }
}
    async function loadNotices() { try { const r = await fetch('https://boardinggate.github.io/Tesla/avisos.txt', { cache: 'no-cache' }); if (!r.ok) throw new Error('Fetch failed'); const txt = await r.text(); notices = txt.split('\n').map(l => l.trim()).filter(l => l.length > 0); if (notices.length === 0) notices = ['No hay avisos.']; } catch (e) { notices = ['Error carga avisos.']; } updateNotice(); }
    function updateNotice() { const noticeElement = document.getElementById('current-notice'); if (!noticeElement || notices.length === 0) { return; } if (!isActive) { noticeElement.textContent = ''; noticeElement.style.animation = 'none'; return; } noticeElement.textContent = notices[currentNoticeIndex]; noticeElement.style.animation = 'none'; void noticeElement.offsetWidth; noticeElement.style.animation = 'fadeInOut 14s infinite'; currentNoticeIndex = (currentNoticeIndex + 1) % notices.length; }
    function toggleNotices() { isActive = !isActive; const nC = document.querySelector('.notices-container'); if (nC) nC.style.display = isActive ? 'flex' : 'none'; const fC = document.querySelector('footer'); if (fC) fC.classList.toggle('footer-hidden', !isActive); isFooterVisible = isActive; const nE = document.getElementById('current-notice'); if (nE) { if (!isActive) { nE.textContent = ''; nE.style.animation = 'none'; } else { currentNoticeIndex = 0; updateNotice(); } } saveSettings(); }
    function startNoticeRotation() { if (notices.length === 0) return; if (isActive) updateNotice(); setInterval(updateNotice, 14000); }
    function adjustButtonPositions() { const scrollToggle = document.getElementById('scroll-toggle'); if (!scrollToggle) { return; }
    const scrollToggleHeight = scrollToggle.offsetHeight; const buttonHeight = 74; const buttonSpacing = 10; const startTop = scrollToggleHeight + 20; const fixedButtons = [ document.getElementById('on-off-toggle'), ...document.querySelectorAll('.range-toggle'), document.getElementById('weather-button'), document.getElementById('reminder-button'), document.getElementById('zoom-button'), document.getElementById('dark-mode-toggle') ].filter(button => button !== null).sort((a, b) => { const startA = parseInt(a.dataset.rangeStart) || Infinity; const startB = parseInt(b.dataset.rangeStart) || Infinity; if (a.id === 'on-off-toggle') return -1; if (b.id === 'on-off-toggle') return 1; if (isFinite(startA) && isFinite(startB)) return startA - startB; if (isFinite(startA)) return -1; if (isFinite(startB)) return 1; const order = ['weather-button', 'reminder-button', 'zoom-button', 'dark-mode-toggle']; return order.indexOf(a.id) - order.indexOf(b.id); }); if (fixedButtons.length < 6) { return; } let currentTop = startTop; fixedButtons.forEach((button) => { button.style.position = 'fixed'; button.style.top = `${currentTop}px`; button.style.left = '10px'; currentTop += buttonHeight + buttonSpacing; }); }
    


// --- FUNCION saveSettings() ---
// Busca esta función y reemplázala por completo con el siguiente código.
function saveSettings() {
    localStorage.setItem('darkMode', JSON.stringify(isDarkMode));
    const tS = {};
    document.querySelectorAll('.range-toggle').forEach(t => {
        const start = t.dataset.rangeStart;
        if (start) tS[start] = t.dataset.state;
    });
    localStorage.setItem('toggleStates', JSON.stringify(tS));
    const zoomButton = document.getElementById('zoom-button');
    if (zoomButton) localStorage.setItem('zoomState', zoomButton.dataset.zoomState);
    const onOffBtn = document.getElementById('on-off-toggle');
    if (onOffBtn) localStorage.setItem('onOffState', onOffBtn.dataset.state);
    localStorage.setItem('noticesActive', JSON.stringify(isActive));
    localStorage.setItem('footerVisible', JSON.stringify(isFooterVisible));
    localStorage.setItem('password_active', JSON.stringify(isPasswordActive));
    localStorage.setItem('lastUpdatesCheckDate', lastUpdatesCheckDate);
    localStorage.setItem(GRAPH_STATE_KEY, currentGraphMode);

    const radaresCheckboxElement = document.getElementById('radares-ruta-checkbox');
    if (radaresCheckboxElement) {
        localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckboxElement.checked));
    }
    
    const tareasCheckboxElement = document.getElementById('tareas-ruta-checkbox');
    if (tareasCheckboxElement) { 
        localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckboxElement.checked));
    }

    // --- MODIFICACIÓN: Guardar el filtro del grid y los campos del mapa ---
    // Guardar el valor del filtro del grid principal (main-search-input)
    const mainSearchInputGrid = document.getElementById('main-search-input'); 
    if (mainSearchInputGrid) {
        localStorage.setItem('gridFilterValue', mainSearchInputGrid.value);
    }
    // Guardar SOLO el campo de filtro del MAPA (mapFilterInput)
    const mapFilterInput = document.getElementById('filter-input'); 
    if (mapFilterInput) {
        localStorage.setItem(MAP_FILTER_INPUT_KEY, mapFilterInput.value);
    }
    // NOTA: El campo principal de búsqueda del mapa (map-location-search-input) NO SE GUARDA.
    // --- FIN MODIFICACIÓN ---

    if (mapLayersControl && mapLayersControl._map && mapLayersControl._map._layers) {
        const layersArray = Object.values(mapLayersControl._map._layers);
        const baseLayerMapObject = layersArray.find(l => l._map && l.options && !l.options.pane && l.options.attribution);
        if (baseLayerMapObject) {
            const activeLayerEntry = mapLayersControl._layers.find(l => l.layer === baseLayerMapObject);
            if (activeLayerEntry && activeLayerEntry.name) {
                localStorage.setItem(ACTIVE_MAP_LAYER_KEY, activeLayerEntry.name);
            }
        }
    }
}


    

    

function saveCustomData() {
    try {
        if (customData.bookmarks) {
            // ... (lógica interna de customData.bookmarks sin cambios)
            Object.keys(customData.bookmarks).forEach(indexKey => {
                const index = parseInt(indexKey);
                const custom = customData.bookmarks[index];
                const original = index < originalBookmarks.length ? originalBookmarks[index] : null;
                const bookmarksAreEqual = (b1, b2) => {
                    if (b1 === null && b2 === null) return true;
                    if (b1 === null || b2 === null) return false;
                    return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null);
                };
                if (bookmarksAreEqual(custom, original)) {
                    delete customData.bookmarks[index];
                }
            });
            if (Object.keys(customData.bookmarks).length === 0) {
                delete customData.bookmarks;
            }
        }
        if (customData.toggles) {
            // ... (lógica interna de customData.toggles sin cambios)
            Object.keys(customData.toggles).forEach(startKey => {
                const customToggle = customData.toggles[startKey];
                const originalRange = originalToggleRanges.find(r => r.start == startKey);
                if (customToggle && customToggle.assignedIndexes && originalRange) {
                    const originalDefaultIndexes = [];
                    for (let i = originalRange.start; i <= originalRange.end; i++) {
                        originalDefaultIndexes.push(i);
                    }
                    if (customToggle.assignedIndexes.length === originalDefaultIndexes.length &&
                        customToggle.assignedIndexes.every((val, idx) => val === originalDefaultIndexes[idx])) {
                        delete customToggle.assignedIndexes;
                    }
                }
                if (customToggle && originalRange && customToggle.label === originalRange.label) {
                    delete customToggle.label;
                }
                if (customData.toggles[startKey] && Object.keys(customData.toggles[startKey]).length === 0) {
                    delete customData.toggles[startKey];
                }
            });
            if (Object.keys(customData.toggles).length === 0) {
                delete customData.toggles;
            }
        }
        localStorage.setItem('customGridData', JSON.stringify(customData));
        
        // Llamada explícita para marcar que hubo un cambio
        markCacheAsDirty();

    } catch (e) {
        showToast("Error al guardar personalización", "error");
    }
}  
    
    
function loadCustomData() { const savedData = localStorage.getItem('customGridData'); currentBookmarks = []; currentToggleRanges = []; customData = { bookmarks: {}, toggles: {} }; if (savedData) { try { customData = JSON.parse(savedData) || { bookmarks: {}, toggles: {} }; } catch (e) { customData = { bookmarks: {}, toggles: {} }; } } if (!customData.bookmarks) customData.bookmarks = {}; if (!customData.toggles) customData.toggles = {}; currentBookmarks = Array.from({ length: TOTAL_CELLS }).map((_, index) => { if (customData.bookmarks.hasOwnProperty(index)) { return customData.bookmarks[index] ? { ...customData.bookmarks[index] } : null; } else { const original = index < originalBookmarks.length ? originalBookmarks[index] : null; return original ? { ...original } : null; } }); currentToggleRanges = originalToggleRanges.map(originalRange => { const customToggle = customData.toggles[originalRange.start]; const rangeCopy = { ...originalRange }; if (customToggle) { if (typeof customToggle.label === 'string') rangeCopy.label = customToggle.label; if (Array.isArray(customToggle.assignedIndexes)) rangeCopy.assignedIndexes = [...customToggle.assignedIndexes]; } if (!rangeCopy.assignedIndexes) rangeCopy.assignedIndexes = Array.from({ length: rangeCopy.end - originalRange.start + 1 }, (_, i) => originalRange.start + i); return rangeCopy; }); }
 
    
    
    


// --- FUNCION loadSavedSettings() ---
// Busca esta función y reemplázala por completo con el siguiente código.
function loadSavedSettings() {
    const savedDarkMode = localStorage.getItem('darkMode');
    isDarkMode = savedDarkMode ? JSON.parse(savedDarkMode) : false;
    if (isDarkMode) document.body.classList.add('dark-mode');

    const savedZoomState = localStorage.getItem('zoomState');
    const zoomButtonElem = document.getElementById('zoom-button');
    if (zoomButtonElem) {
        zoomButtonElem.dataset.zoomState = savedZoomState || 'off';
        applyZoom(zoomButtonElem.dataset.zoomState);
    }

    const savedPasswordActive = localStorage.getItem('password_active');
    isPasswordActive = savedPasswordActive ? JSON.parse(savedPasswordActive) : false;
    storedPin = localStorage.getItem('password_pin');

    lastUpdatesCheckDate = localStorage.getItem('lastUpdatesCheckDate');

    const savedNoticesActive = localStorage.getItem('noticesActive');
    const savedFooterVisible = localStorage.getItem('footerVisible');
    isActive = savedNoticesActive ? JSON.parse(savedNoticesActive) : true;
    isFooterVisible = savedFooterVisible ? JSON.parse(savedFooterVisible) : true;
    const noticeContainer = document.querySelector('.notices-container');
    if (noticeContainer) noticeContainer.style.display = isActive ? 'flex' : 'none';
    const footerElement = document.querySelector('footer');
    if (footerElement) footerElement.classList.toggle('footer-hidden', !isFooterVisible);

    const onOffBtn = document.getElementById('on-off-toggle');
    if (onOffBtn) {
        const savedOnOffState = localStorage.getItem('onOffState');
        onOffBtn.dataset.state = savedOnOffState ? savedOnOffState : 'on';
    }

    const toggleStatesFromCache = JSON.parse(localStorage.getItem('toggleStates') || '{}');
    document.querySelectorAll('.range-toggle').forEach(toggle => {
        const start = parseInt(toggle.dataset.rangeStart);
        const savedState = toggleStatesFromCache[start] || 'visible';
        toggle.dataset.state = savedState;
    });

    // --- MODIFICACIÓN: Cargar el filtro del grid ---
    const mainSearchInputGrid = document.getElementById('main-search-input'); 
    if (mainSearchInputGrid) {
        const savedMainFilter = localStorage.getItem('gridFilterValue');
        if (savedMainFilter !== null) {
            mainSearchInputGrid.value = savedMainFilter;
        } else {
            mainSearchInputGrid.value = '';
        }
    }
    // NOTA: Los campos de búsqueda/filtro del MAPA se inicializan dentro de `openNavigationMap()`
    // para asegurar que los elementos HTML existan antes de intentar acceder a ellos.
    // --- FIN MODIFICACIÓN ---

    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresRutaCheckbox) {
        const savedCheckState = localStorage.getItem(RADARES_RUTA_CHECKED_KEY);
        radaresRutaCheckbox.checked = savedCheckState === 'true';
    }
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasRutaCheckbox) {
        const savedTareasCheckState = localStorage.getItem(TAREAS_RUTA_CHECKED_KEY);
        tareasRutaCheckbox.checked = savedTareasCheckState === 'true';
    }

    currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviación ETA';

    const userIdInput = document.getElementById('user-id');
    const modelInput = document.getElementById('tesla-model');
    const yearInput = document.getElementById('tesla-year');
    const provinceInput = document.getElementById('tesla-province');
    const dmsCheckbox = document.getElementById('allow-dms');
    const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');

    if (userIdInput) userIdInput.value = localStorage.getItem('userData_userId') || '';
    if (modelInput) modelInput.value = localStorage.getItem('userData_teslaModel') || '';
    if (yearInput) yearInput.value = localStorage.getItem('userData_teslaYear') || '';
    if (provinceInput) provinceInput.value = localStorage.getItem('userData_teslaProvince') || '';
    if (dmsCheckbox) dmsCheckbox.checked = JSON.parse(localStorage.getItem('userData_allowDMs') || 'false');
    
    if (autoBackupCheckbox) {
        const savedAutoBackup = localStorage.getItem('boardinggate_autoBackupOnLoad');
        autoBackupCheckbox.checked = savedAutoBackup === null ? true : JSON.parse(savedAutoBackup);
    }
    
    actualizarContadorRadares(0);
    actualizarContadorTareas(0);
    updateUserIdDisplay();
    updateReminderCount();
}
    







    
    function loadReminders() { updateReminderCount(); }
    function updateUserIdDisplay() { const userIdDisplay = document.getElementById('user-id-display'); const userId = localStorage.getItem('userData_userId'); if (userIdDisplay) { if (userId) { userIdDisplay.textContent = userId.trim(); userIdDisplay.style.display = 'block'; } else { userIdDisplay.textContent = ''; userIdDisplay.style.display = 'none'; } } }
    function applyZoom(state) { const originalWidth = 984; const adjustedWidth = 935; const originalCols = 6; const zoomedCols = 4; const gap = 15; const zoomButton = document.getElementById('zoom-button'); if (state === 'on') { grid.style.gridTemplateColumns = `repeat(${zoomedCols}, 1fr)`; grid.style.gap = `${gap}px`; grid.style.maxWidth = `${adjustedWidth}px`; document.querySelectorAll('.bookmark-item img').forEach(i => { i.style.width = '48px'; i.style.maxWidth = '56px'; }); document.querySelectorAll('.bookmark-name').forEach(n => { n.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)'; }); document.querySelectorAll('.small-bookmark img').forEach(i => { i.style.width = '48px'; i.style.maxWidth = '56px'; }); document.querySelectorAll('.small-bookmark .bookmark-name').forEach(n => { n.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)'; }); if (zoomButton) zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/zoon+.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; } else { grid.style.gridTemplateColumns = `repeat(${originalCols}, minmax(120px, 1fr))`; grid.style.gap = `${gap}px`; grid.style.maxWidth = `${originalWidth}px`; document.querySelectorAll('.bookmark-item img').forEach(i => { i.style.width = '36px'; i.style.maxWidth = '40px'; }); document.querySelectorAll('.bookmark-name').forEach(n => { n.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)'; }); document.querySelectorAll('.small-bookmark img').forEach(i => { i.style.width = '24px'; i.style.maxWidth = '28px'; }); document.querySelectorAll('.small-bookmark .bookmark-name').forEach(n => { n.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)'; }); if (zoomButton) zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; } }
    function getSectionForIndex(index) { return currentToggleRanges.find(range => range.assignedIndexes.includes(index)); }
    function getColorForSection(sectionStart, state = 'visible') { if (state === 'hidden') { return sectionColors.off; } if (isDarkMode) { return darkModeGenericButtonColor; } else { return sectionColors[sectionStart] || sectionColors.unassigned; } }
    function updateButtonStyles() {
    const darkModeToggleElem = document.getElementById('dark-mode-toggle');
    const onOffToggleElem = document.getElementById('on-off-toggle');
    const rangeToggleButtonsElems = document.querySelectorAll('.toggle-sign.range-toggle');
    const reminderButtonElem = document.getElementById('reminder-button');

    if (onOffToggleElem) {
        onOffToggleElem.src = `https://boardinggate.github.io/Tesla/${onOffToggleElem.dataset.state === 'on' ? 'IMG_4192.jpg' : 'IMG_4191.jpg'}`;
        onOffToggleElem.alt = `Toggle ${onOffToggleElem.dataset.state === 'on' ? 'On' : 'Off'}`;
        onOffToggleElem.style.backgroundColor = sectionColors.off;
        if (isDarkMode) {
            onOffToggleElem.style.filter = 'brightness(85%)';
             if (onOffToggleElem.dataset.state === 'on') {
                onOffToggleElem.style.backgroundColor = darkModeGenericButtonColor;
             }
        } else {
            onOffToggleElem.style.filter = '';
        }
    }
    if (darkModeToggleElem) {
        darkModeToggleElem.src = `https://boardinggate.github.io/Tesla/${isDarkMode ? 'oscuro2.png' : 'claro2.png'}`;
        darkModeToggleElem.alt = `Toggle ${isDarkMode ? 'Oscuro' : 'Claro'}`;
        darkModeToggleElem.style.backgroundColor = sectionColors.off;
        if (isDarkMode) darkModeToggleElem.style.filter = 'brightness(85%)'; else darkModeToggleElem.style.filter = '';
    }

    let reminders = [];
    try {
        reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    } catch(e) {
        reminders = [];
    }
    const showExcludedInTable = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
    let remindersForButtonStyleCount = reminders;
    if (!showExcludedInTable) {
        remindersForButtonStyleCount = reminders.filter(r => !r.excludeFromList);
    }
    const totalPendingCount = remindersForButtonStyleCount.length;

    if (reminderButtonElem) {
        reminderButtonElem.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4197.jpg" alt="Recordatorio" style="max-width: 70%; max-height: 70%; object-fit: contain;">${totalPendingCount > 0 ? `<span class="reminder-count">${totalPendingCount}</span>` : ''}`;
        reminderButtonElem.style.backgroundColor = sectionColors.off;
        if (isDarkMode) reminderButtonElem.style.filter = 'brightness(85%)'; else reminderButtonElem.style.filter = '';
    }

    rangeToggleButtonsElems.forEach(toggle => {
        const start = parseInt(toggle.dataset.rangeStart);
        const state = toggle.dataset.state || 'visible';
        const rangeConfig = currentToggleRanges.find(r => r.start === start);
        if (rangeConfig) {
            toggle.innerHTML = `<span class="sign">${state === 'visible' ? '-' : '+'}</span>${rangeConfig.label}`;
        }
        toggle.style.backgroundColor = getColorForSection(start, state);
        if (isDarkMode && state === 'visible') {
            toggle.style.filter = 'brightness(85%)';
        } else {
            toggle.style.filter = '';
        }
    });

    updatePasswordToggleIcon();
    const zoomButtonElem = document.getElementById('zoom-button');
    if (zoomButtonElem && zoomButtonElem.dataset.zoomState) {
        applyZoom(zoomButtonElem.dataset.zoomState);
    }


    if (cellElements && cellElements.length > 0) {
        cellElements.forEach((cell, index) => {
            const bookmarkItem = cell.querySelector('.bookmark-item');
            const emptySlot = cell.classList.contains('empty-slot');
            const section = getSectionForIndex(index);
            const color = sectionColors[section ? section.start : null] || sectionColors.unassigned;
            if (bookmarkItem) {
                bookmarkItem.style.backgroundColor = color;
            } else if (emptySlot) {
                cell.style.backgroundColor = color;
            }
        });
    }
}

    function formatVersionDate(date) { const y = date.getUTCFullYear().toString().slice(-2); const m = String(date.getUTCMonth() + 1).padStart(2, '0'); const d = String(date.getUTCDate()).padStart(2, '0'); const h = String(date.getUTCHours()).padStart(2, '0'); return `${y}.${m}.${d}${h}`; }
    async function getLastModifiedDate() {
        const k = 'teslaHtmlLastModified';
        const tk = 'teslaHtmlLastModifiedTimestamp';
        const dur = 86400000;
        const cd = localStorage.getItem(k);
        const ct = localStorage.getItem(tk);
        const now = Date.now();

        if (cd && ct && (now - parseInt(ct)) < dur) {

            return new Date(cd);
        }

        try {
            const r = await fetch('https://boardinggate.github.io/Tesla/version.txt', { cache: 'no-cache' });
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const txt = await r.text();
            const lmd = new Date(txt.trim());
            if (isNaN(lmd.getTime())) throw new Error('Invalid date format');
            localStorage.setItem(k, lmd.toISOString());
            localStorage.setItem(tk, now.toString());
            return lmd;
        } catch (e) {
            if (cd) return new Date(cd);
            return new Date('2024-01-01T00:00:00Z');
        }
    }
    async function updateVersion() { try { const lmd = await getLastModifiedDate(); const v = formatVersionDate(lmd); const el = document.getElementById('version'); if (el) el.textContent = `versión: ${v}`; } catch (e) { const el = document.getElementById('version'); if (el) el.textContent = 'versión: error'; } }
    const getFaviconUrl = (bookmarkData) => { try { const urlToParse = bookmarkData?.url || ''; const customFavicon = bookmarkData?.favicon; if (customFavicon && (customFavicon.startsWith('data:image') || customFavicon.startsWith('http') || customFavicon.startsWith('./'))) return customFavicon; if (urlToParse) { const domain = new URL(urlToParse).hostname; return `https://www.google.com/s2/favicons?domain=${domain}&sz=64`; } } catch (e) { } return 'https://via.placeholder.com/64'; };


    function renderGrid() { grid.innerHTML = ''; cellElements = []; Array.from({ length: TOTAL_CELLS }).forEach((_, index) => { const cellContainer = document.createElement('div'); cellContainer.classList.add('grid-cell'); cellContainer.dataset.index = index; const bookmarkData = currentBookmarks[index]; const section = getSectionForIndex(index); const bgColor = sectionColors[section ? section.start : null] || sectionColors.unassigned; if (bookmarkData) { const link = document.createElement('a'); link.className = 'bookmark-item'; link.title = bookmarkData.name; link.style.backgroundColor = bgColor; link.href = bookmarkData.url || "#"; link.dataset.index = index;
        if (isKeywordAssignmentMode || (bookmarkData.name && bookmarkData.name === "Inicio Tesla") || !bookmarkData.url || bookmarkData.url === '#') { } else { link.target = "_blank"; link.rel = "noopener noreferrer"; }
        const img = document.createElement('img'); img.src = getFaviconUrl(bookmarkData); img.alt = `Favicon ${bookmarkData.name}`; img.loading = "lazy"; img.onerror = function() { this.src = 'https://via.placeholder.com/64'; this.onerror = null; }; if (bookmarkData.name === "Mis Updates") img.classList.add('favicon-red'); else if (bookmarkData.name === "Olas Updates") img.classList.add('favicon-blue'); const nameSpan = document.createElement('span'); nameSpan.className = 'bookmark-name'; nameSpan.textContent = bookmarkData.name; link.appendChild(img); link.appendChild(nameSpan); cellContainer.appendChild(link); } else { cellContainer.classList.add('empty-slot'); const addIcon = document.createElement('span'); addIcon.textContent = '+'; cellContainer.appendChild(addIcon); cellContainer.style.backgroundColor = bgColor; }
        cellContainer.addEventListener('click', handleGridCellClick);
        if (isEditMode) {
             cellContainer.draggable = true;
             cellContainer.addEventListener('dragstart', handleDragStart); cellContainer.addEventListener('dragover', handleDragOver);
             cellContainer.addEventListener('dragleave', handleDragLeave);
             cellContainer.addEventListener('drop', handleDrop);
             cellContainer.addEventListener('dragend', handleDragEnd);
             cellContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
             cellContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
             cellContainer.addEventListener('touchend', handleTouchEnd);
             cellContainer.addEventListener('touchcancel', handleTouchCancel);
             cellContainer.classList.add('editable');
        } else {
             cellContainer.draggable = false;
             cellContainer.removeEventListener('dragstart', handleDragStart);
             cellContainer.removeEventListener('dragover', handleDragOver);
             cellContainer.removeEventListener('dragleave', handleDragLeave);
             cellContainer.removeEventListener('drop', handleDrop);
             cellContainer.removeEventListener('dragend', handleDragEnd);
             cellContainer.removeEventListener('touchstart', handleTouchStart);
             cellContainer.removeEventListener('touchmove', handleTouchMove);
             cellContainer.removeEventListener('touchend', handleTouchEnd);
             cellContainer.removeEventListener('touchcancel', handleTouchCancel);
             cellContainer.classList.remove('editable');
        }      
                                                                                                                               
grid.appendChild(cellContainer); cellElements.push(cellContainer); }); }

function renderToggleButtons() {
    document.querySelectorAll('.range-toggle').forEach(btn => btn.remove());
    toggleButtonElements = {};
    const toggleStatesFromCache = JSON.parse(localStorage.getItem('toggleStates') || '{}');

    currentToggleRanges.forEach((range) => {
        const toggle = document.createElement('span');
        toggle.className = 'toggle-sign range-toggle';
        toggle.dataset.rangeStart = range.start;
        toggle.dataset.rangeEnd = range.end;
        toggle.style.position = 'fixed';
        toggle.style.top = '100px';
        toggle.style.left = '10px';

        const initialState = toggleStatesFromCache[range.start] || 'visible';
        toggle.dataset.state = initialState;


        toggle.addEventListener('click', handleToggleClick);
        document.body.appendChild(toggle);
        toggleButtonElements[range.start] = toggle;
    });


}

    function createOtherButtons() {
        if (!document.getElementById('on-off-toggle')) {
            onOffToggle = document.createElement('img');
            onOffToggle.className = 'toggle-image';
            onOffToggle.id = 'on-off-toggle';
            const savedOnOffState = localStorage.getItem('onOffState');
            onOffToggle.dataset.state = savedOnOffState ? savedOnOffState : 'on';
            document.body.appendChild(onOffToggle);
            onOffToggle.addEventListener('mousedown', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) pressStartTime = Date.now(); });
            onOffToggle.addEventListener('mouseup', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) handleOnOffAction(); });
            onOffToggle.addEventListener('mouseleave', () => { pressStartTime = null; });
            onOffToggle.addEventListener('touchstart', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); pressStartTime = Date.now(); } });
            onOffToggle.addEventListener('touchend', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); handleOnOffAction(); } });
        }
        if (!document.getElementById('weather-button')) { weatherButton = document.createElement('span'); weatherButton.className = 'toggle-sign'; weatherButton.id = 'weather-button'; weatherButton.innerHTML = `<img src="https://www.google.com/s2/favicons?domain=accuweather.com&sz=64" alt="Tiempo" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; document.body.appendChild(weatherButton); weatherButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; window.open('https://www.ventusky.com/?p=40.2;-4.7;5&l=rain-3h', '_blank'); }); }
        if (!document.getElementById('reminder-button')) { reminderButton = document.createElement('span'); reminderButton.className = 'toggle-sign'; reminderButton.id = 'reminder-button'; document.body.appendChild(reminderButton); reminderButton.addEventListener('mousedown', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) reminderPressStartTime = Date.now(); }); reminderButton.addEventListener('mouseup', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) handleReminderLongPress(); }); reminderButton.addEventListener('mouseleave', () => { reminderPressStartTime = null; }); reminderButton.addEventListener('touchstart', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); reminderPressStartTime = Date.now(); } }); reminderButton.addEventListener('touchend', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); handleReminderLongPress(); } }); }
        if (!document.getElementById('zoom-button')) { zoomButton = document.createElement('span'); zoomButton.className = 'toggle-sign'; zoomButton.id = 'zoom-button'; zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; zoomButton.dataset.zoomState = localStorage.getItem('zoomState') || 'off'; document.body.appendChild(zoomButton); zoomButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const cS = zoomButton.dataset.zoomState; const nS = cS === 'off' ? 'on' : 'off'; applyZoom(nS); zoomButton.dataset.zoomState = nS; updateButtonStyles(); saveSettings(); adjustButtonPositions(); }); }
        if (!document.getElementById('dark-mode-toggle')) { darkModeToggle = document.createElement('img'); darkModeToggle.className = 'toggle-image'; darkModeToggle.id = 'dark-mode-toggle'; document.body.appendChild(darkModeToggle); darkModeToggle.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; isDarkMode = !isDarkMode; document.body.classList.toggle('dark-mode', isDarkMode); updateButtonStyles(); saveSettings(); }); }
        if (!document.getElementById('config-button')) {
            const configButton = document.createElement('span');
            configButton.id = 'config-button';
            configButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/config.jpg" alt="Configuración">`;
            document.body.appendChild(configButton);
            configButton.addEventListener('click', () => {
                if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) {
                    const mapIsCurrentlyOpen = isNavigationMapActive;
                    const currentMapContext = sessionStorage.getItem('mapContext');

                    if (mapIsCurrentlyOpen && currentMapContext) {
                        sessionStorage.setItem('boardinggate_map_should_reopen_after_config', 'true');
                        sessionStorage.setItem('mapContextToReopenAfterConfig', currentMapContext);
                        closeNavigationMap(true);
                    }
                    showConfigModal();
                }
            });
        }

        if (!document.getElementById('personal-button')) {
            const personalButton = document.createElement('span');
            personalButton.id = 'personal-button';
            personalButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/personal.png" alt="Personal">`;
            document.body.appendChild(personalButton);
            personalButton.addEventListener('click', handlePersonalizationClick);
        }

        if (!document.getElementById('radar-button')) {
            radarButton = document.createElement('span');
            radarButton.id = 'radar-button';
            radarButton.innerHTML = `<img src="RADAR.PNG" alt="Radar/Ubicaciones/Navegación">`;
            document.body.appendChild(radarButton);
            radarButton.addEventListener('click', () => {
                if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
                openNavigationMap();
            });
        }

        if (!document.getElementById('home-button')) {
            const homeButton = document.createElement('span');
            homeButton.id = 'home-button';
            homeButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/home.webp" alt="Inicio">`;
            document.body.appendChild(homeButton);
            homeButton.addEventListener('click', (e) => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) { e.preventDefault(); return; } window.history.back(); });
        }
        if (!document.getElementById('reload-button')) {
            const reloadButton = document.createElement('span');
            reloadButton.id = 'reload-button';
            reloadButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/reload.webp" alt="Recargar">`;
            document.body.appendChild(reloadButton);
            reloadButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; location.reload(); });
        }

        if (!document.getElementById('keyword-assignment-button')) {
             const keywordButton = document.createElement('span');
             keywordButton.id = 'keyword-assignment-button';
             keywordButton.title = "Asignar/Quitar palabra clave filtro";
             keywordButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4314.PNG" alt="Asignar Keyword">`;
             document.body.appendChild(keywordButton);
             keywordButton.addEventListener('click', () => { toggleKeywordAssignmentMode(!isKeywordAssignmentMode); });
        }

        if (!document.getElementById('password-toggle-button')) {
            const passwordButton = document.createElement('span');
            passwordButton.id = 'password-toggle-button';
            passwordButton.innerHTML = `<img src="" alt="Clave">`;
            document.body.appendChild(passwordButton);
            passwordButton.addEventListener('click', handlePasswordToggleClick);
        }

        if (!document.getElementById('versions-button')) {
             versionsButton = document.createElement('span');
             versionsButton.id = 'versions-button';
             versionsButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4309.PNG" alt="Versiones">`;
             document.body.appendChild(versionsButton);
             versionsButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; showVersionsModal(); });
        }

        if (!document.getElementById('info-button')) {
             infoButton = document.createElement('span');
             infoButton.id = 'info-button';
             infoButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4326.PNG" alt="Info">`;
             document.body.appendChild(infoButton);
             infoButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; window.open('https://boardinggate.github.io/Tesla/manual.html', '_blank'); });
        }
    }

function handleGridCellClick(event) {
        const cellContainer = event.currentTarget; const index = parseInt(cellContainer.dataset.index);
        if (isEditMode) { const link = cellContainer.querySelector('a.bookmark-item'); if (link) event.preventDefault(); showEditModal(index, false); }
        else if (isAssignmentMode) { event.preventDefault(); handleGridCellClickForAssignment(index); }
        else if (isKeywordAssignmentMode) { event.preventDefault(); handleKeywordAssignmentClick(index); }
        else { const link = cellContainer.querySelector('a.bookmark-item'); const bookmarkData = currentBookmarks[index];
            if (!link || !link.href || link.href === '#') {
                event.preventDefault();
                if (bookmarkData && bookmarkData.url && bookmarkData.url.startsWith("map-action:")) {
                    const action = bookmarkData.url.split(":")[1];
                    if (action === "openRemindersMapWithNoRadars") {
                        openLocationsPreviewMap();
                    } else if (action === "openRemindersMap") {
                        openNavigationMap();
                    }
                }
            } else {
                if (!link.target && bookmarkData && bookmarkData.name !== "Inicio Tesla") {
                    link.target = "_blank"; link.rel = "noopener noreferrer";
                }
            }
        }
    }
    function handleToggleClick(event) { const toggle = event.currentTarget; if (isEditMode) { event.preventDefault(); const start = parseInt(toggle.dataset.rangeStart); showEditModal(start, true); } else if (isAssignmentMode) { event.preventDefault(); handleToggleClickForAssignment(toggle); } else if (isKeywordAssignmentMode) { event.preventDefault(); } else { updateToggleState(toggle); } }
    function updateToggleState(toggle) { if (!toggle || isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const start = parseInt(toggle.dataset.rangeStart); if (isNaN(start)) return; const rangeConfig = currentToggleRanges.find(r => r.start === start); if (!rangeConfig) return; const currentState = toggle.dataset.state; const newState = currentState === 'visible' ? 'hidden' : 'visible'; toggle.dataset.state = newState; const savedStates = JSON.parse(localStorage.getItem('toggleStates') || '{}'); savedStates[start] = newState; localStorage.setItem('toggleStates', JSON.stringify(savedStates)); updateButtonStyles(); filterGridItems(); }
    function updateAllToggles(newState) { const onOffToggleElem = document.getElementById('on-off-toggle'); if (!onOffToggleElem) return; onOffToggleElem.dataset.state = newState; localStorage.setItem('onOffState', newState); updateButtonStyles(); filterGridItems(); saveSettings(); }
    const scrollToggle = document.getElementById('scroll-toggle'); if (scrollToggle) scrollToggle.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const sP = window.scrollY; const mS = document.body.scrollHeight - window.innerHeight; window.scrollTo({ top: sP < 100 ? mS : 0, behavior: 'smooth' }); });
    function handleOnOffAction() { if (pressStartTime !== null) { const t = document.getElementById('on-off-toggle'); if (t) { const nS = t.dataset.state === 'on' ? 'off' : 'on'; updateAllToggles(nS); } } pressStartTime = null; }

function handleReminderLongPress() { if (reminderPressStartTime === null) return; const dur = Date.now() - reminderPressStartTime; if (dur >= 2000) showAllReminders(); else showReminderModal(); reminderPressStartTime = null; }
    function handlePersonalizationClick() {
        const personalButton = document.getElementById('personal-button'); const wasEditing = isEditMode; const wasAssigning = isAssignmentMode; const wasKeywordAssigning = isKeywordAssignmentMode;
        if (wasKeywordAssigning) { toggleKeywordAssignmentMode(false); }
        if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
        if (wasEditing) { toggleEditMode(false); } else if (wasAssigning) { toggleAssignmentMode(false); } else if (!wasKeywordAssigning) { showPersonalizationChoice(); }
    }
    function showPersonalizationChoice() {
        const existingModal = document.querySelector('.choice-modal'); if (existingModal) existingModal.remove();
        const modal = document.createElement('div'); modal.className = 'choice-modal'; modal.setAttribute('aria-label', 'Elegir tipo de personalización');
        modal.innerHTML = `
            <h2>¿Qué quieres personalizar?</h2>
            <div class="modal-top-buttons">
                <button class="choice-cancel">Cancelar</button>
            </div>
            <p class="mb-6">Elige una opción:</p>
            <div class="personalization-options">
                <button class="choice-edit">URLs / Etiquetas / Reordenar</button>
                <button class="choice-assign">Asignar Botones Ocultación</button>
                <button class="choice-help">Ver Ayuda</button>
            </div>
        `;
        modal.querySelector('.choice-edit').addEventListener('click', () => { modal.remove(); toggleEditMode(true); });
        modal.querySelector('.choice-assign').addEventListener('click', () => { modal.remove(); toggleAssignmentMode(true); });
        modal.querySelector('.choice-help').addEventListener('click', () => { modal.remove(); showEditInfoModal(); });
        modal.querySelector('.choice-cancel').addEventListener('click', () => { modal.remove(); });
        document.body.appendChild(modal);
        addModalAutoCloseTimer(modal, modal.querySelector('.choice-cancel'), 'choice-modal', 30000);
    }

    function toggleEditMode(activate) {
        const personalButton = document.getElementById('personal-button'); isEditMode = activate; personalButton.classList.toggle('editing', isEditMode); document.body.classList.toggle('editing-active', isEditMode);
        
        if (isEditMode) {
            if (isAssignmentMode) toggleAssignmentMode(false); if (isKeywordAssignmentMode) toggleKeywordAssignmentMode(false);
            if (firstPersonalizationSession) { showEditInfoModal(); firstPersonalizationSession = false; sessionStorage.setItem('personalizationHelpShown', 'true'); }
            showToast("Modo Edición (URLs/Etiquetas/Arrastrar) Activado", "info", 4000);
        } else {
            showToast("Modo Edición Desactivado", "info", 2000);
            cellElements.forEach(cell => cell.classList.remove('dragging', 'drag-over')); draggedItem = null; draggedItemIndex = null; currentTouchTarget = null; dragOverIndex = null;
            if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
        } renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles(); adjustButtonPositions();
        document.querySelectorAll('.range-toggle').forEach(el => { el.classList.toggle('editable', isEditMode); }); filterGridItems();
    }

function toggleAssignmentMode(activate) {
        const personalButton = document.getElementById('personal-button'); isAssignmentMode = activate; personalButton.classList.toggle('assigning', isAssignmentMode); document.body.classList.toggle('assignment-active', isAssignmentMode);
        if (isAssignmentMode) {
            if (isEditMode) toggleEditMode(false); if (isKeywordAssignmentMode) toggleKeywordAssignmentMode(false);
            if (firstPersonalizationSession) { showEditInfoModal(); firstPersonalizationSession = false; sessionStorage.setItem('personalizationHelpShown', 'true'); }
            showToast("Modo Asignación Botones Activado", "info", 4000);
            const firstToggle = document.querySelector('.range-toggle');
            if (firstToggle) { handleToggleClickForAssignment(firstToggle); } else { currentlyAssigningToggleStart = null; updateGridAssignmentVisuals(); }
        } else {
            showToast("Modo Asignación Botones Desactivado", "info", 2000); saveCustomData();
            document.querySelectorAll('.range-toggle.assigning-selected').forEach(t => t.classList.remove('assigning-selected'));
            document.querySelectorAll('.grid-cell.assigned-to-current').forEach(c => { c.classList.remove('assigned-to-current'); c.style.opacity = ''; c.style.outline=''; c.style.boxShadow=''; c.style.backgroundColor = ''; });
            document.querySelectorAll('.range-toggle').forEach(t => t.style.opacity = '');
            currentlyAssigningToggleStart = null;
        } renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles(); adjustButtonPositions(); filterGridItems(); 
    }
    function toggleKeywordAssignmentMode(activate) {
         const keywordButton = document.getElementById('keyword-assignment-button'); const filterInput = document.getElementById('grid-filter-input'); isKeywordAssignmentMode = activate;
         if (keywordButton) { keywordButton.classList.toggle('active', isKeywordAssignmentMode); }

document.body.classList.toggle('keyword-assignment-active', isKeywordAssignmentMode);
         if (isKeywordAssignmentMode) {
              if (isEditMode) toggleEditMode(false); if (isAssignmentMode) toggleAssignmentMode(false);
              const toastMessage = "Modo activo: Escribe palabra(s) en el campo filtro grid (separadas por espacio si son varias). Pulsa ICONO FILTRO para añadir/quitar esa(s) palabra(s) al nombre del botón(es) que vaya seleccionando. Pulsa el icono para salir de este modo.";
              showToast(toastMessage, "info", 15000); filterGridItems(); applyInitialKeywordHighlights();
         } else {
              showToast("Modo Asignación de Palabras Clave Desactivado", "info", 2000); cellElements.forEach(cell => cell.classList.remove('keyword-assigned-highlight')); filterGridItems();
         }
    }
    function applyInitialKeywordHighlights() { const filterInput = document.getElementById('grid-filter-input'); const keyword = filterInput.value.trim().replace(/\s+/g, '').toUpperCase(); if (!keyword) return; const keywordTag = `[${keyword}]`; cellElements.forEach((cell, index) => { const bookmark = currentBookmarks[index]; if (bookmark && bookmark.name && bookmark.name.includes(keywordTag)) { cell.classList.add('keyword-assigned-highlight'); } else { cell.classList.remove('keyword-assigned-highlight'); } }); }
    
    function handleKeywordAssignmentClick(index) {
        const filterInput = document.getElementById('grid-filter-input'); const keyword = filterInput.value.trim().replace(/\s+/g, '').toUpperCase();
        if (!keyword) { showToast("Escribe una palabra en el campo filtro primero.", "warning"); return; }
        const bookmark = currentBookmarks[index]; const cellElement = cellElements[index];
        if (!bookmark || !cellElement) { showToast(`No hay un marcador en la posición ${index + 1}.`, "warning"); return; }
        const keywordTag = `[${keyword}]`; const currentName = bookmark.name || ""; const nameSpan = cellElement.querySelector('.bookmark-name');
        let newName = currentName; let actionTaken = '';
        if (currentName.includes(keywordTag)) { newName = currentName.replace(keywordTag, '').replace(/\s{2,}/g, ' ').trim(); cellElement.classList.remove('keyword-assigned-highlight'); actionTaken = 'removed'; }
        else { newName = currentName.trim(); const lastBracketIndex = newName.lastIndexOf(']'); const endsWithBracket = lastBracketIndex !== -1 && lastBracketIndex === newName.length - 1;
            if (endsWithBracket) { newName += '  ' + keywordTag; } else { newName += '          ' + keywordTag; } cellElement.classList.add('keyword-assigned-highlight'); actionTaken = 'added';
        } bookmark.name = newName; currentBookmarks[index] = { ...bookmark }; if (!customData.bookmarks) customData.bookmarks = {}; customData.bookmarks[index] = { ...bookmark }; saveCustomData();
        if (nameSpan) { nameSpan.textContent = newName; }
        if (actionTaken === 'added') { showToast(`"${keyword}" añadido. Nombre: ${newName}`, "success", 2500); } else if (actionTaken === 'removed') { showToast(`"${keyword}" quitado. Nombre: ${newName}`, "info", 2500); }
    }
    function handleToggleClickForAssignment(toggleElement) { const start = parseInt(toggleElement.dataset.rangeStart); if (isNaN(start)) return; currentlyAssigningToggleStart = start; document.querySelectorAll('.range-toggle').forEach(t => { t.classList.toggle('assigning-selected', t === toggleElement); t.style.opacity = t === toggleElement ? '' : '0.7'; }); updateGridAssignmentVisuals(); showToast(`Asignando botones para: ${toggleElement.textContent.substring(1)}`, "info", 2500); }
    
    function handleGridCellClickForAssignment(cellIndex) {
        if (currentlyAssigningToggleStart === null) { showToast("Selecciona primero un botón lateral (PdR,s, iAs, etc.)", "warning"); return; }
        const startKey = currentlyAssigningToggleStart.toString(); if (!customData.toggles[startKey]) { const currentRange = currentToggleRanges.find(r => r.start == startKey); customData.toggles[startKey] = { label: currentRange ? currentRange.label : `Rango ${startKey}`, assignedIndexes: currentRange ? [...currentRange.assignedIndexes] : [] }; }
        else if (!customData.toggles[startKey].assignedIndexes) { const currentRange = currentToggleRanges.find(r => r.start == startKey); customData.toggles[startKey].assignedIndexes = currentRange ? [...currentRange.assignedIndexes] : []; }
        const assigned = customData.toggles[startKey].assignedIndexes; const indexInArray = assigned.indexOf(cellIndex);
        if (indexInArray > -1) { assigned.splice(indexInArray, 1); } else { assigned.push(cellIndex); assigned.sort((a, b) => a - b); }
        const currentRangeIndex = currentToggleRanges.findIndex(r => r.start == startKey); if (currentRangeIndex > -1) { currentToggleRanges[currentRangeIndex].assignedIndexes = [...assigned]; }
        updateGridAssignmentVisuals(); saveCustomData(); showToast('Asignación guardada', 'success', 500);
    }

  function updateGridAssignmentVisuals() { if (!isAssignmentMode || currentlyAssigningToggleStart === null) { cellElements.forEach(cell => { cell.classList.remove('assigned-to-current'); cell.style.opacity = ''; cell.style.outline = ''; cell.style.boxShadow = ''; }); return; } const startKey = currentlyAssigningToggleStart.toString(); let assignedIndexesForCurrentToggle = []; if (customData.toggles[startKey] && customData.toggles[startKey].assignedIndexes) { assignedIndexesForCurrentToggle = customData.toggles[startKey].assignedIndexes; } else { const currentRange = currentToggleRanges.find(r => r.start == startKey); if (currentRange?.assignedIndexes) { assignedIndexesForCurrentToggle = currentRange.assignedIndexes; } } cellElements.forEach((cell, index) => { const isAssigned = assignedIndexesForCurrentToggle.includes(index); cell.classList.toggle('assigned-to-current', isAssigned); if (isAssigned) { cell.style.opacity = ''; cell.style.outline = '3px solid cyan'; cell.style.boxShadow = document.body.classList.contains('dark-mode') ? 'inset 0 0 10px rgba(0, 200, 200, 0.7)' : 'inset 0 0 8px rgba(0, 255, 255, 0.6)'; } else { cell.style.opacity = document.body.classList.contains('dark-mode') ? '0.5' : '0.6'; cell.style.outline = `1px dashed ${document.body.classList.contains('dark-mode') ? '#555' : '#aaa'}`; cell.style.boxShadow = ''; } }); }
    function showEditInfoModal() {
        const existingModal = document.querySelector('.edit-info-modal'); if (existingModal) existingModal.remove();
        const modal = document.createElement('div'); modal.className = 'edit-info-modal'; modal.setAttribute('aria-label', 'Ayuda Personalización');
        modal.innerHTML = `
            <h2 class="text-xl font-bold mb-4">Ayuda de Personalización</h2>
            <div class="modal-top-buttons" style="justify-content: flex-end;">
                <button type="button" id="close-edit-info" class="px-6 py-2" style="flex: 0 1 auto; min-width: 120px;">Entendido</button>
            </div>
            <p class="mb-3">Al pulsar el botón <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (personalizar) o el icono <img src="https://boardinggate.github.io/Tesla/IMG_4314.PNG" alt="Key" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (llave) puedes elegir entre varios modos:</p>
            <div class="mb-4 p-3 bg-yellow-100 border border-yellow-300 rounded">
                 <h3 class="font-semibold text-lg mb-2">1. Editar URLs / Etiquetas / Reordenar (Botón Personalizar Amarillo)</h3>
                 <ul class="list-disc pl-5 space-y-1 text-sm">
                    <li><strong>Activar:</strong> Elige "URLs / Etiquetas / Reordenar" en el menú inicial. El botón <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> se pondrá amarillo.</li>
                    <li><strong>Editar Marcador/Botón Lateral:</strong> Haz clic en un marcador del grid o en un botón lateral (PdR,s, iAs, etc.). Se abrirá una ventana para editar su nombre, URL (si es marcador) o etiqueta (si es botón lateral). <strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                    <li><strong>Arrastrar y Soltar:</strong> Mantén pulsado un marcador del grid y arrástralo a otra posición (incluso vacía) para reordenarlos.</li>
                    <li><strong>Guardar Cambios:</strong> Los cambios en nombre/URL/etiqueta se guardan al pulsar "Guardar" en la ventana de edición. El reordenamiento se guarda automáticamente al soltar.</li>
                    <li><strong>Vaciar Casilla:</strong> En la ventana de edición de un marcador, pulsa "Vaciar" para eliminarlo.</li>
                    <li><strong>Resetear:</strong> En la ventana de edición, pulsa "Resetear" para volver a los valores originales (si los tenía).</li>
                 </ul>
            </div>
            <div class="mb-4 p-3 bg-cyan-100 border border-cyan-300 rounded">
                <h3 class="font-semibold text-lg mb-2">2. Asignar Botones Ocultación (Botón Personalizar Cian)</h3>
                <ul class="list-disc pl-5 space-y-1 text-sm">
                    <li><strong>Activar:</strong> Elige "Asignar Botones Ocultación" en el menú inicial. El botón <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> se pondrá cian.</li>
                    <li><strong>Seleccionar Botón Lateral:</strong> Haz clic en el botón lateral (PdR,s, iAs, etc.) cuyos marcadores quieres definir. Se resaltará.</li>
                    <li><strong>Asignar/Desasignar Marcadores:</strong> Haz clic en cualquier marcador de la rejilla. Si estaba asignado, se desasignará (atenuado). Si no lo estaba, se asignará (resaltado). <strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                    <li><strong>Cambiar Botón Lateral:</strong> Haz clic en otro botón lateral para asignar sus marcadores.</li>
                    <li><strong>Guardar:</strong> Los cambios se guardan automáticamente al salir de este modo (pulsando el botón <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> cian).</li>
                    <li><strong>Visibilidad por defecto:</strong> Marcadores no asignados a <i>ningún</i> botón lateral siempre serán visibles (salvo que el botón general <img src="https://boardinggate.github.io/Tesla/IMG_4191.jpg" alt="OFF" style="width:20px; height:11px; display:inline; vertical-align:middle;"> esté desactivado).</li>
                </ul>
            </div>
            <div class="mb-4 p-3 bg-green-100 border border-green-300 rounded">
            <h3 class="font-semibold text-lg mb-2">3. Asignar Palabra Clave Filtro (Icono Llave Verde)</h3>
            <ul class="list-disc pl-5 space-y-1 text-sm">
                <li><strong>Activar:</strong> Pulsa el icono de la llave <img src="https://boardinggate.github.io/Tesla/IMG_4314.PNG" alt="Key" style="width:16px; height:16px; display:inline; vertical-align:middle;"> junto al campo de filtro. El icono se pondrá verde. Si vuelves a pulsar, se desactivará.</li>
                <li><strong>Escribe la Palabra:</strong> Escribe la palabra que quieres añadir al nombre de los botones en el campo de filtro. Se eliminarán los espacios automáticamente.</li>
                <li><strong>Asignar:</strong> Haz clic en el botón del grid al que quieres añadir la palabra clave. La palabra (en corchetes) se añadirá a su nombre (si no existe ya).</li>
<li><strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                <li><strong>Guardar:</strong> Los cambios se guardan automáticamente cada vez que asignas una palabra clave a un botón.</li>
                <li><strong>Mostrar Todo:</strong> Al activar este modo, se limpiará el filtro y se mostrarán todos los botones para facilitar la asignación.</li>
            </ul>
            </div>
            <p class="mb-4"><strong>Salir de Personalización:</strong> Pulsa el botón activo <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (amarillo o cian) o el icono de la llave <img src="https://boardinggate.github.io/Tesla/IMG_4314.PNG" alt="Key" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (verde) para desactivar el modo actual y volver al uso normal.</p>
        `;
        document.body.appendChild(modal);
        const closeEditInfoButton = modal.querySelector('#close-edit-info');
        const closeHandler = () => { clearModalAutoCloseTimer(modal, closeEditInfoButton, 'edit-info-modal'); if (modal.parentNode) modal.parentNode.removeChild(modal); };
        closeEditInfoButton.addEventListener('click', closeHandler); addModalAutoCloseTimer(modal, closeEditInfoButton, 'edit-info-modal');
    }
    function showEditModal(targetIndexOrStart, isToggle = false) { if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); } const existingModal = document.querySelector('.edit-modal'); if (existingModal) existingModal.remove(); const modal = document.createElement('div'); modal.className = 'edit-modal'; if (isToggle) { editingTargetElement = toggleButtonElements[targetIndexOrStart]; } else { editingTargetElement = cellElements[targetIndexOrStart]; } if (editingTargetElement) { editingTargetElement.classList.add('editing-target'); } else { } let currentItemData = {}; let originalItemData = {}; let title = ''; let isNewBookmark = false; const targetIndex = isToggle ? -1 : targetIndexOrStart; if (isToggle) { const targetStart = targetIndexOrStart; const currentRange = currentToggleRanges.find(r => r.start === targetStart); const originalRange = originalToggleRanges.find(r => r.start === targetStart); const currentLabel = customData.toggles[targetStart]?.label ?? currentRange?.label ?? ''; currentItemData = { label: currentLabel }; originalItemData = { label: originalRange?.label || '' }; title = `Editar Etiqueta Sección`;
    modal.innerHTML = `
        <h2>${title}</h2>
        <div class="modal-top-buttons" style="margin-bottom: 1.2rem;">
            <button class="save">Guardar</button>
            <button class="reset">Resetear</button>
            <button class="cancel">Cancelar</button>
        </div>
        <div><label for="edit-label">Etiqueta (máx 7):</label><input type="text" id="edit-label" value="${currentItemData.label}" maxlength="7"></div>
    `;
    } else { const currentBookmark = currentBookmarks[targetIndex]; const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null; currentItemData = currentBookmark ? { ...currentBookmark } : { name: '', url: '', favicon: '' }; originalItemData = originalBookmark ? { ...originalBookmark } : { name: '', url: '', favicon: '' }; isNewBookmark = !currentBookmark; title = currentBookmark ? `Editar Marcador: ${currentItemData?.name || `Índice ${targetIndex}`}` : `Añadir Marcador (Posición ${targetIndex + 1})`;
    modal.innerHTML = `
        <h2>${title}</h2>
        <div class="modal-top-buttons" style="margin-bottom: 1.2rem;">
            <button class="save">Guardar</button>
            <button class="reset">Resetear</button>
            <button class="empty">Vaciar</button>
            <button class="cancel">Cancelar</button>
        </div>
        <div><label for="edit-name">Nombre:</label><input type="text" id="edit-name" value="${currentItemData.name || ''}"></div>
        <div><label for="edit-url">URL:</label><div class="input-with-button"><input type="url" id="edit-url" value="${currentItemData.url || ''}" placeholder="https://ejemplo.com"><button class="search-button" id="search-url-button" title="Buscar URL en Google (basado en URL/Nombre)">🔍</button></div></div>
        <div><label for="edit-favicon">URL Favicon (Opcional):</label><div class="input-with-button"><input type="text" id="edit-favicon" value="${currentItemData.favicon || ''}" placeholder="Dejar vacío para auto"><button class="search-button" id="search-favicon-button" title="Buscar Favicon en Google Images (basado en Favicon/Nombre)">🖼️</button></div></div>
    `;
    } document.body.appendChild(modal); const cleanupEditModal = () => { if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; } if (modal.parentNode) modal.parentNode.removeChild(modal); }; modal.querySelector('.save').addEventListener('click', () => { let dataChanged = false; if (isToggle) { const targetStart = targetIndexOrStart; const newLabel = modal.querySelector('#edit-label').value.trim(); if (!newLabel) { showToast("La etiqueta no puede estar vacía.", "warning"); return; } if (newLabel.length > 7) { showToast("La etiqueta no puede exceder 7 caracteres.", "warning"); return; } const originalLabel = originalToggleRanges.find(r => r.start === targetStart)?.label || ''; if (newLabel !== originalLabel) { if (!customData.toggles[targetStart]) customData.toggles[targetStart] = {}; customData.toggles[targetStart].label = newLabel; dataChanged = true; } else { if (customData.toggles[targetStart] && customData.toggles[targetStart].hasOwnProperty('label')) { delete customData.toggles[targetStart].label; if (Object.keys(customData.toggles[targetStart]).length === 0) delete customData.toggles[targetStart]; dataChanged = true; } } const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetStart); if (rangeIdx > -1) currentToggleRanges[rangeIdx].label = newLabel; } else { const nameInput = modal.querySelector('#edit-name'); const urlInput = modal.querySelector('#edit-url'); const faviconInput = modal.querySelector('#edit-favicon');
                const newName = nameInput.value.trim();
                const newUrl = urlInput.value.trim();
                const newFavicon = faviconInput.value.trim() || null;
                const isEmpty = !newName && !newUrl && !newFavicon;
                const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;

                if (isEmpty) {
                    if (originalBookmark !== null && originalBookmark !== undefined) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = null;
                        dataChanged = true;
                    } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = null;
                } else {
                    if (!newName || !newUrl) {
                        showToast("Nombre y URL son obligatorios.", "warning");
                        return;
                    }
                    try { new URL(newUrl); } catch (_) {
                        showToast("URL inválida.", "warning");
                        return;
                    }
                    const bookmarkUpdate = { name: newName, url: newUrl, favicon: newFavicon };
                    const originalData = originalBookmark ? { name: originalBookmark.name, url: originalBookmark.url, favicon: originalBookmark.favicon || null } : null;

                    const bookmarksAreEqual = (b1, b2) => { if (b1 === null && b2 === null) return true; if (b1 === null || b2 === null) return false; return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null); };
                    if (!bookmarksAreEqual(bookmarkUpdate, originalData)) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = bookmarkUpdate;
                        dataChanged = true;
                   } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = bookmarkUpdate;
                }
            }
            if (dataChanged) {
                saveCustomData();
                showToast("Cambios guardados", "success");
            } else {
                showToast("No se detectaron cambios", "info");
            }
            updateGridItemUI(targetIndexOrStart, isToggle);
            cleanupEditModal();
        });
        modal.querySelector('.reset').addEventListener('click', () => {
            let dataChanged = false;
            if (isToggle) {
                const targetStart = targetIndexOrStart;
                const originalRange = originalToggleRanges.find(r => r.start === targetStart);
                const originalLabel = originalRange?.label || '';
                modal.querySelector('#edit-label').value = originalLabel;
                if (customData.toggles && customData.toggles[targetStart] && customData.toggles[targetStart].hasOwnProperty('label')) {
                    delete customData.toggles[targetStart].label;
                    if (Object.keys(customData.toggles[targetStart]).length === 0) delete customData.toggles[targetStart];
                    dataChanged = true;
                }
                const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetStart);
                if (rangeIdx > -1) currentToggleRanges[rangeIdx].label = originalLabel;
            } else {
                const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                modal.querySelector('#edit-name').value = originalBookmark?.name || '';
                modal.querySelector('#edit-url').value = originalBookmark?.url || '';
                modal.querySelector('#edit-favicon').value = originalBookmark?.favicon || '';
                if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                    delete customData.bookmarks[targetIndex];
                    dataChanged = true;
                }
                currentBookmarks[targetIndex] = originalBookmark ? { ...originalBookmark } : null;
            }
            if (dataChanged) {
                saveCustomData();
                showToast("Valores reseteados al original y guardados", "info");
            } else {
                showToast("Ya estaba con los valores originales", "info");
            }
            updateGridItemUI(targetIndexOrStart, isToggle);
            cleanupEditModal();
        });
        modal.querySelector('.cancel').addEventListener('click', cleanupEditModal);
        if (!isToggle) {
            const emptyBtn = modal.querySelector('.empty');
            if (emptyBtn) {
                emptyBtn.addEventListener('click', () => {
                    modal.querySelector('#edit-name').value = '';
                    modal.querySelector('#edit-url').value = '';
                    modal.querySelector('#edit-favicon').value = '';
                    const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                    let dataChanged = false;
                    if (originalBookmark !== null && originalBookmark !== undefined) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = null;
                        dataChanged = true;
                    } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = null;
                    if(dataChanged) {
                        saveCustomData();
                        showToast("Marcador vaciado y guardado.", "success");
                    } else {
                        showToast("Marcador ya estaba vacío.", "info");
                    }
                    updateGridItemUI(targetIndex, false);
                    cleanupEditModal();
                });
            }
            const searchUrlBtn = modal.querySelector('#search-url-button');
            const searchFaviconBtn = modal.querySelector('#search-favicon-button');
            const nameInput = modal.querySelector('#edit-name');
            const urlInputSearch = modal.querySelector('#edit-url');
            const faviconInputSearch = modal.querySelector('#edit-favicon');

            if (searchUrlBtn) {
                searchUrlBtn.addEventListener('click', () => {
                    const urlValue = urlInputSearch.value.trim();
                    const nameValue = nameInput.value.trim();
                    const query = urlValue || nameValue;
                    if (query) { window.open(`https://www.google.com/search?q=${encodeURIComponent(query)}`, '_blank'); }
                    else { showToast("Escribe un Nombre o URL para buscar.", "warning"); }
                });
            }
            if (searchFaviconBtn) {
                searchFaviconBtn.addEventListener('click', () => {
                    const faviconValue = faviconInputSearch.value.trim();
                    const nameValue = nameInput.value.trim();
                    const query = faviconValue || nameValue;
                    if (query) { window.open(`https://www.google.com/search?tbm=isch&q=${encodeURIComponent(`"${query}" favicon logo icon`)}`, '_blank'); }
                    else { showToast("Escribe un Nombre o URL de Favicon para buscar.", "warning"); }
                });
            }
        }
    }
    function updateGridItemUI(indexOrStart, isToggle = false) {
        renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles();adjustButtonPositions();
        if (isAssignmentMode) {
            updateGridAssignmentVisuals();
            if (currentlyAssigningToggleStart !== null && toggleButtonElements[currentlyAssigningToggleStart]) {
                toggleButtonElements[currentlyAssigningToggleStart].classList.add('assigning-selected');
                toggleButtonElements[currentlyAssigningToggleStart].style.opacity = '';
            }
        } else if (isKeywordAssignmentMode) { applyInitialKeywordHighlights(); }
    }

    function performInsertAndSave(sourceIndex, targetIndex) { if (sourceIndex === targetIndex || sourceIndex === null || targetIndex === null) { return false; } const draggedData = currentBookmarks.splice(sourceIndex, 1)[0]; currentBookmarks.splice(targetIndex, 0, draggedData); if (!customData.bookmarks) customData.bookmarks = {}; if (!customData.toggles) customData.toggles = {}; const minIdx = Math.min(sourceIndex, targetIndex); const maxIdx = Math.max(sourceIndex, targetIndex); currentToggleRanges.forEach(range => { if (range.assignedIndexes) {
        range.assignedIndexes = range.assignedIndexes.map(idx => { if (idx === sourceIndex) return targetIndex; else if (idx > sourceIndex && idx <= targetIndex) return idx - 1; else if (idx < sourceIndex && idx >= targetIndex) return idx + 1; else return idx; }).sort((a, b) => a - b); const startKey = range.start.toString(); if (customData.toggles[startKey] && customData.toggles[startKey].hasOwnProperty('assignedIndexes')) { customData.toggles[startKey].assignedIndexes = [...range.assignedIndexes]; } } }); for (let i = minIdx; i <= maxIdx; i++) { const currentItem = currentBookmarks[i]; const originalItem = i < originalBookmarks.length ? originalBookmarks[i] : null; const bookmarksAreEqual = (b1, b2) => { if (b1 === null && b2 === null) return true; if (b1 === null || b2 === null) return false; return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null); }; if (!bookmarksAreEqual(currentItem, originalItem)) { customData.bookmarks[i] = currentItem ? { ...currentItem } : null; } else if (customData.bookmarks.hasOwnProperty(i)) { delete customData.bookmarks[i]; } } saveCustomData(); renderGrid(); loadSavedSettings(); updateButtonStyles(); showToast(`Movido de ${sourceIndex + 1} a ${targetIndex + 1}`, "success", 1500); return true; }
    function handleDragStart(e) { if (!isEditMode) return; draggedItem = e.currentTarget; draggedItemIndex = parseInt(draggedItem.dataset.index); e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', draggedItemIndex); setTimeout(() => { if (draggedItem) draggedItem.classList.add('dragging'); }, 0); }
    function handleDragOver(e) { if (!isEditMode || !draggedItem) return; e.preventDefault(); e.dataTransfer.dropEffect = 'move'; const targetCell = e.target.closest('.grid-cell'); const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetCell && targetIndex !== dragOverIndex) { if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } if (targetIndex !== draggedItemIndex) { targetCell.classList.add('drag-over'); dragOverIndex = targetIndex; } else { dragOverIndex = null; } } else if (!targetCell && dragOverIndex !== null) { if (cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } dragOverIndex = null; } }
    function handleDragLeave(e) { if (!isEditMode || !draggedItem) return; const targetCell = e.target.closest('.grid-cell'); if (targetCell && !targetCell.contains(e.relatedTarget)) { if (parseInt(targetCell.dataset.index) === dragOverIndex) { targetCell.classList.remove('drag-over'); dragOverIndex = null; } } }
    function handleDrop(e) { if (!isEditMode || !draggedItem) return; e.preventDefault(); const targetCell = e.target.closest('.grid-cell'); const sourceIndex = draggedItemIndex; const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetIndex !== null && sourceIndex !== targetIndex) { performInsertAndSave(sourceIndex, targetIndex); } else { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } } handleDragEndCleanup(); }
    function handleDragEnd(e) { if (!isEditMode) return; handleDragEndCleanup(); }
    function handleDragEndCleanup() { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } draggedItem = null; draggedItemIndex = null; dragOverIndex = null; }
    function handleTouchStart(e) { if (!isEditMode || e.touches.length !== 1) return; draggedItem = e.currentTarget; draggedItemIndex = parseInt(draggedItem.dataset.index); const touch = e.touches[0]; touchStartX = touch.clientX; touchStartY = touch.clientY; draggedItem.classList.add('dragging'); currentTouchTarget = draggedItem; }
    function handleTouchMove(e) { if (!isEditMode || !draggedItem || e.touches.length !== 1) return; e.preventDefault(); const touch = e.touches[0]; const elementOver = document.elementFromPoint(touch.clientX, touch.clientY); const targetCell = elementOver?.closest('.grid-cell'); const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetCell && targetIndex !== dragOverIndex) { if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } if (targetIndex !== draggedItemIndex) { targetCell.classList.add('drag-over'); dragOverIndex = targetIndex; currentTouchTarget = targetCell; } else { dragOverIndex = null; currentTouchTarget = draggedItem; } } else if (!targetCell && dragOverIndex !== null) { if (cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } dragOverIndex = null; currentTouchTarget = null; } }
    function handleTouchEnd(e) { if (!isEditMode || !draggedItem) return; if (dragOverIndex !== null && dragOverIndex !== draggedItemIndex) { performInsertAndSave(draggedItemIndex, dragOverIndex); e.preventDefault(); } else { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } } handleTouchEndCleanup(); }
    function handleTouchCancel(e) { if (!isEditMode) return; handleTouchEndCleanup(); }
    function handleTouchEndCleanup() { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } draggedItem = null; draggedItemIndex = null; dragOverIndex = null; currentTouchTarget = null; touchStartX = 0; touchStartY = 0; }
    function normalizeText(text) { if (!text) return ''; return text.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, ''); }

    function filterGridItems() {
        const filterInput = document.getElementById('grid-filter-input');
        const clearButton = document.getElementById('clear-filter-button');
        if (!filterInput || !clearButton || !cellElements || cellElements.length === 0) { return; }

        if (isKeywordAssignmentMode) {
            cellElements.forEach(cellContainer => { cellContainer.classList.remove('hidden'); });
            clearButton.style.display = filterInput.value.trim() ? 'inline-block' : 'none';
            return;
        }

        const rawFilterText = filterInput.value.trim();
        clearButton.style.display = rawFilterText ? 'inline-block' : 'none';
        const filterWords = rawFilterText.split(/\s+/).filter(word => word.length > 0).map(word => normalizeText(word));
        const onOffToggleElem = document.getElementById('on-off-toggle');
        const masterState = onOffToggleElem ? (onOffToggleElem.dataset.state || 'on') : 'on';


        cellElements.forEach((cellContainer, index) => {
            const isMasterOff = masterState === 'off';
            if (isMasterOff) {
                cellContainer.classList.add('hidden');
                return;
            }

            const bookmark = currentBookmarks[index];
            const bookmarkName = bookmark ? normalizeText(bookmark.name) : '';
            const isEmptySlot = !bookmark;
            let matchesFilter = true;

            if (filterWords.length > 0) {
                if (isEmptySlot) {
                    matchesFilter = false;
                } else {
                    matchesFilter = filterWords.every(word => bookmarkName.includes(word));
                }
            }
            const shouldBeHiddenByFilter = filterWords.length > 0 && !matchesFilter;

            let shouldBeHiddenByToggles = false;
            const containingRange = getSectionForIndex(index);
            if (containingRange) {
                const toggleButton = toggleButtonElements[containingRange.start] || document.querySelector(`.range-toggle[data-range-start="${containingRange.start}"]`);
                if (toggleButton) {
                    const toggleState = toggleButton.dataset.state || 'visible';
                    shouldBeHiddenByToggles = toggleState === 'hidden';
                }
            } else {
                shouldBeHiddenByToggles = false;
            }

            const shouldBeHidden = shouldBeHiddenByToggles || shouldBeHiddenByFilter;
            cellContainer.classList.toggle('hidden', shouldBeHidden);
        });
    }

    function promptForPin() { const pinModal = document.getElementById('pin-modal-overlay'); const pinInput = document.getElementById('pin-input'); const pinSubmit = document.getElementById('pin-submit-button'); const pinError = document.getElementById('pin-error-message'); pinModal.classList.remove('hidden');
        pinInput.value = ''; pinError.textContent = ''; pinInput.focus(); const newPinSubmit = pinSubmit.cloneNode(true); pinSubmit.parentNode.replaceChild(newPinSubmit, pinSubmit); newPinSubmit.addEventListener('click', checkPin); pinInput.addEventListener('keyup', (event) => { if (event.key === 'Enter') { checkPin(); } }); }
    function checkPin() { const pinModal = document.getElementById('pin-modal-overlay'); const pinInput = document.getElementById('pin-input'); const pinError = document.getElementById('pin-error-message'); const enteredPin = pinInput.value; if (enteredPin === storedPin) { pinModal.classList.add('hidden'); initializeApp(); } else { pinError.textContent = 'Clave incorrecta.'; pinInput.value = ''; pinInput.focus(); if (navigator.vibrate) navigator.vibrate(100); } }
    function handlePasswordToggleClick() { if (!storedPin) { showToast('Primero establece una clave en Configuración -> Usuario.', 'warning'); return; } isPasswordActive = !isPasswordActive; updatePasswordToggleIcon(); saveSettings(); showToast(`Solicitar clave al inicio: ${isPasswordActive ? 'Activado' : 'Desactivado'}`, 'info'); }
    function updatePasswordToggleIcon() { const passwordButton = document.getElementById('password-toggle-button'); if (passwordButton) { const img = passwordButton.querySelector('img'); if(img) { const iconPath = isPasswordActive ? 'IMG_4281.png' : 'IMG_4280.png'; img.src = `https://boardinggate.github.io/Tesla/${iconPath}`;
        img.alt = isPasswordActive ? 'Clave Activada' : 'Clave Desactivada'; passwordButton.title = `Clave al inicio: ${isPasswordActive ? 'Activada' : 'Desactivada'}`; } } }

    function savePinSettings() {
        const pinSetInput = document.getElementById('config-pin-set');
        const pinConfirmInput = document.getElementById('config-pin-confirm');
        const pinStatus = document.getElementById('config-pin-status');
        const directToNavCheckbox = document.getElementById('config-direct-to-nav');

        const newPin = pinSetInput.value;
        const confirmPin = pinConfirmInput.value;
        pinStatus.textContent = '';
        let keySaved = false;
        let prefSaved = false;

  if (newPin || confirmPin) {
            if (!/^\d{4}$/.test(newPin)) {
                pinStatus.textContent = 'La clave debe tener exactamente 4 cifras.';
                pinStatus.style.color = '#EF4444';
                return;
            }
            if (newPin !== confirmPin) {
                pinStatus.textContent = 'Las claves no coinciden.';
                pinStatus.style.color = '#EF4444';
                return;
            }
            try {
                localStorage.setItem('password_pin', newPin);
                storedPin = newPin;
                if (!localStorage.getItem('password_active') || isPasswordActive) {
                    isPasswordActive = true;
                    localStorage.setItem('password_active', 'true');
                }
                pinStatus.textContent = 'Clave guardada. ';
                pinStatus.style.color = '#28a745';
                pinSetInput.value = '';
                pinConfirmInput.value = '';
                updatePasswordToggleIcon();
                keySaved = true;
            } catch (e) {
                pinStatus.textContent ='Error al guardar la clave.';
                pinStatus.style.color = '#EF4444';
                showToast('Error al guardar la clave.', 'error');
            }
        }

        const directToNavChecked = directToNavCheckbox.checked;

        localStorage.setItem(DIRECT_TO_NAVIGATION_KEY, JSON.stringify(directToNavChecked));
        prefSaved = true;

        if (keySaved && prefSaved) {
            showToast('Clave y preferencia de inicio guardadas.', 'success');
            pinStatus.textContent += (pinStatus.textContent ? "Y " : "") + "Preferencia de inicio guardada.";
             pinStatus.style.color = '#28a745';
        } else if (keySaved) {
            showToast('Clave guardada. Preferencia de inicio también actualizada.', 'success');
             pinStatus.textContent += (pinStatus.textContent ? " " : "") + "Preferencia de inicio guardada.";
             pinStatus.style.color = '#28a745';
        } else if (prefSaved) {
            showToast('Preferencia de inicio guardada.', 'success');
            pinStatus.textContent = "Preferencia de inicio guardada.";
            pinStatus.style.color = '#28a745';
        } else if (!newPin && !confirmPin) {
             pinStatus.textContent = "No se realizaron cambios en la clave. Preferencia de inicio no cambió.";
             pinStatus.style.color = '#17a2b8';
        }
        saveSettings();
    }


    function removePinSettings() { const pinStatus = document.getElementById('config-pin-status'); if (confirm('¿Estás seguro de que deseas eliminar la clave de acceso? Ya no se solicitará al inicio.')) { try { localStorage.removeItem('password_pin'); localStorage.setItem('password_active', 'false'); storedPin = null; isPasswordActive = false; pinStatus.textContent = 'Clave eliminada.'; pinStatus.style.color = '#17a2b8'; document.getElementById('config-pin-set').value = ''; document.getElementById('config-pin-confirm').value = ''; updatePasswordToggleIcon(); saveSettings(); showToast('Clave eliminada.', 'info'); } catch (e) { pinStatus.textContent = 'Error al eliminar la clave.'; pinStatus.style.color = '#EF4444'; showToast('Error al eliminar la clave.', 'error'); } } }
    async function getRemoteUpdatesDate() { try { const response = await fetch('https://boardinggate.github.io/Tesla/updates.txt', { cache: 'no-cache' }); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const text = await response.text(); const firstLine = text.split('\n')[0].trim(); const dateMatch = firstLine.match(/^\d{4}-\d{2}-\d{2}/); if (dateMatch) { const [year, month, day] = dateMatch[0].split('-').map(Number); const remoteDate = new Date(Date.UTC(year, month - 1, day)); if (!isNaN(remoteDate.getTime())) { return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`; } } return null; } catch (e) { return null; } }
    function isRemoteDateNewer(remoteDateStr, cachedDateStr) { if (!remoteDateStr) return false; if (!cachedDateStr) return true; try { return remoteDateStr > cachedDateStr; } catch (e) { return false; } }

    async function checkVersionsIconOpacity() { const versionsIcon = document.getElementById('versions-button'); const versionsImg = versionsIcon ? versionsIcon.querySelector('img') : null; if (!versionsImg) return;
        let showAsNew = false; const remoteDateStr = await getRemoteUpdatesDate();
        if (remoteDateStr) { showAsNew = isRemoteDateNewer(remoteDateStr, lastUpdatesCheckDate); } versionsImg.style.opacity = showAsNew ? '1.0' : '0.1';
    }
    async function showVersionsModal() {
    const versionsModalOverlay = document.getElementById('versions-modal-overlay');
    const versionsContent = document.getElementById('versions-content');
    const closeButton = document.getElementById('close-versions-modal');
    if (!versionsModalOverlay || !versionsContent || !closeButton) return;

    const newCloseButton = closeButton.cloneNode(true);
    closeButton.parentNode.replaceChild(newCloseButton, closeButton);

    const closeHandler = () => {
        versionsModalOverlay.classList.add('hidden');
        clearModalAutoCloseTimer(versionsModalOverlay, newCloseButton, 'versions-modal');
    };
    newCloseButton.addEventListener('click', closeHandler);

    versionsContent.textContent = 'Cargando histórico...';
    versionsModalOverlay.classList.remove('hidden');
    addModalAutoCloseTimer(versionsModalOverlay, newCloseButton, 'versions-modal');

    try {
        const response = await fetch('https://boardinggate.github.io/Tesla/updates.txt', { cache: 'no-cache' });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const text = await response.text();
        versionsContent.textContent = text;

        const firstLine = text.split('\n')[0].trim();
        const dateMatch = firstLine.match(/^\d{4}-\d{2}-\d{2}/);
        let dateToStore = null;
        if (dateMatch) {
            const [year, month, day] = dateMatch[0].split('-').map(Number);
            const checkDate = new Date(Date.UTC(year, month - 1, day));
            if (!isNaN(checkDate.getTime())) {
                dateToStore = dateMatch[0];
            }
        }

        if (dateToStore) {
            lastUpdatesCheckDate = dateToStore;
        } else {

            const today = new Date();
            lastUpdatesCheckDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
        }
        saveSettings();
        await checkVersionsIconOpacity();
    } catch (e) {
        versionsContent.textContent = `Error al cargar el histórico:\n${e.message}`;
    }
}
    



function getCurrentLocation(callback, errorCallback) {
    if ('geolocation' in navigator) {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                callback({
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy,
                    altitude: position.coords.altitude,
                    heading: position.coords.heading,
                    speed: position.coords.speed
                });
            },
            (error) => {
                let message = "No se pudo obtener la ubicación.";
                switch (error.code) {
                    case error.PERMISSION_DENIED:
                        message = "Permiso de ubicación denegado.";
                        break;
                    case error.POSITION_UNAVAILABLE:
                        message = "Información de ubicación no disponible.";
                        break;
                    case error.TIMEOUT:
                        message = "Timeout obteniendo ubicación.";
                        break;
                }
                if (errorCallback) errorCallback(message);
                else showToast(message, "error");
            },
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );
    } else {
        const message = "Geolocalización no soportada por este navegador.";
        if (errorCallback) errorCallback(message);
        else showToast(message, "error");
    }
}

    
    
    
    
    function calculateDistance(lat1, lon1, lat2, lon2) {
        if (typeof lat1 !== 'number' || typeof lon1 !== 'number' || typeof lat2 !== 'number' || typeof lon2 !== 'number' || isNaN(lat1) || isNaN(lon1) || isNaN(lat2) || isNaN(lon2)) {
             return Infinity;
        }
        const R = 6371e3; const φ1 = lat1 * Math.PI / 180; const φ2 = lat2 * Math.PI / 180; const Δφ = (lat2 - lat1) * Math.PI / 180; const Δλ = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return R * c;
    }
    function parseReminderText(text, elementsToUpdate = null) {
        const result = { text: `<b>${text.trim().toUpperCase()}</b>`, time: null, date: null, repeatDays: [], intervalDays: null, type: null, isLocationEnabled: false, locationCoordinates: null, radiusMeters: 600, excludeFromList: false };
        let norm = text.toUpperCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');

        const numW = { 'UNA': 1, 'UNO': 1, 'DOS': 2, 'TRES': 3, 'CUATRO': 4, 'CINCO': 5, 'SEIS': 6, 'SIETE': 7, 'OCHO': 8, 'NUEVE': 9, 'DIEZ': 10, 'ONCE': 11, 'DOCE': 12, 'TRECE': 13, 'CATORCE': 14, 'QUINCE': 15, 'DIECISEIS': 16, 'DIECISIETE': 17, 'DIECIOCHO': 18, 'DIECINUEVE': 19, 'VEINTE': 20, 'VEINTIUNO': 21, 'VEINTIDOS': 22, 'VEINTITRES': 23, 'VEINTICUATRO': 24, 'VEINTICINCO': 25, 'VEINTISEIS': 26, 'VEINTISIETE': 27, 'VEINTIOCHO': 28, 'VEINTINUEVE': 29, 'TREINTA': 30, 'TREINTAYUNO': 31 }; const tRgx = /\b(\d{1,2}):(\d{2})\b/; const ttRgx = /.*\bA\s*LAS?\s*(\d+|\w+)\s*(?:Y\s*(CUARTO|MEDIA|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA)|MENOS\s*(CUARTO|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA))?\s*(DE\s*LA\s*(MANANA|TARDE|NOCHE))?/i; const tM = norm.match(tRgx); if (tM) { let h = parseInt(tM[1]); let m = parseInt(tM[2]); if (h >= 0 && h <= 23 && m >= 0 && m <= 59) result.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`; } else { const ttM = norm.match(ttRgx); if (ttM) { let h = numW[ttM[1].toUpperCase()] || parseInt(ttM[1]); if (!isNaN(h)) { const minTxt = ttM[2]?.toUpperCase() || ''; const minus = ttM[3]?.toUpperCase() || ''; const period = ttM[5]?.toUpperCase() || null; let m = 0; if (minTxt) m = minTxt === 'CUARTO' ? 15 : minTxt === 'MEDIA' ? 30 : numW[minTxt] || parseInt(minTxt) || 0; else if (minus) { m = minus === 'CUARTO' ? 15 : numW[minus] || parseInt(minus) || 0; h = (h - 1 + 24) % 24; m = (60 - m + 60) % 60; } if (period) { if (period === 'TARDE' && h >= 1 && h <= 11) h += 12; if (period === 'NOCHE' && h >= 1 && h <= 11) h += 12; if (period === 'MANANA' && h === 12) h = 0; if (period === 'TARDE' && h === 12) h = 12; if (period === 'NOCHE' && h === 12) h = 0; } else if (h >= 1 && h <= 5) h += 12; if (h >= 0 && h <= 23 && m >= 0 && m <= 59) result.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`; } } } const daysMap = { 'LUNES': 1, 'MARTES': 2, 'MIERCOLES': 3, 'MIÉRCOLES': 3, 'JUEVES': 4, 'VIERNES': 5, 'SABADO': 6, 'SÁBADO': 6, 'DOMINGO': 0 }; const wRgx = /(TODOS\s+LOS|LOS|CADA)?\s*(LUNES|MARTES|MIERCOLES|MIÉRCOLES|JUEVES|VIERNES|SABADO|SÁBADO|DOMINGO)/g; let wM; while ((wM = wRgx.exec(norm)) !== null) { const day = daysMap[wM[2]]; if (day !== undefined && !result.repeatDays.includes(day)) result.repeatDays.push(day); }
        const now = new Date(); const manDRgx = /(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{2}|\d{4})\b/; const manDM = norm.match(manDRgx);
        if (manDM && !result.date) { let d = parseInt(manDM[1]); let m = parseInt(manDM[2]); let y = parseInt(manDM[3]); if (y >= 0 && y <= 99) y += 2000; if (d >= 1 && d <= 31 && m >= 1 && m <= 12 && y >= 2000 && y <= 2099) { const tD = new Date(Date.UTC(y, m - 1, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() + 1 === m && tD.getUTCFullYear() === y) { result.date = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } } }
        const todayRgx = /\bHOY\b/; const tomRgx = /\bMANANA\b/; const dayAftRgx = /\bPASADO\s*MANANA\b/;
        if (!result.date) { if (norm.match(todayRgx)) { result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (norm.match(dayAftRgx)) { const tD = new Date(now); tD.setDate(now.getDate() + 2); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } else if (norm.match(tomRgx)) { const tD = new Date(now); tD.setDate(now.getDate() + 1); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } }
        const dndRgx = /(?:EL\s*(PROXIMO)?\s*)?(LUNES|MARTES|MIERCOLES|MIÉRCOLES|JUEVES|VIERNES|SABADO|SÁBADO|DOMINGO)/i; const dndM = norm.match(dndRgx);
        if (dndM && !result.date) { const tDN = dndM[2].toUpperCase(); const tD = daysMap[tDN]; if (tD !== undefined) { const curD = now.getDay(); let dU = (tD - curD + 7) % 7; if (dU === 0) dU = 7; if (dndM[1]?.toUpperCase() === 'PROXIMO') dU += 7; const target = new Date(now); target.setDate(now.getDate() + dU); result.date = `${target.getFullYear()}-${(target.getMonth() + 1).toString().padStart(2, '0')}-${target.getDate().toString().padStart(2, '0')}`; } }
        const didRgx = /DENTRO\s*DE\s*(\d+)\s*DIAS?/; const didM = norm.match(didRgx);
        if (didM && !result.date) { const d = parseInt(didM[1]); if (!isNaN(d) && d > 0) { const tD = new Date(now); tD.setDate(now.getDate() + d); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } }
        const dsdRgx = /\bEL\s*DIA\s*(\d{1,2})\b/; const dsdM = norm.match(dsdRgx);
        if (dsdM && !result.date) { const d = parseInt(dsdM[1]); if (!isNaN(d) && d >= 1 && d <= 31) { let tM = now.getMonth(); let tY = now.getFullYear(); if (d < now.getDate()) { tM++; if (tM > 11) { tM = 0; tY++; } } const tD = new Date(Date.UTC(tY, tM, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() === tM) { result.date = `${tY}-${(tM + 1).toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } } }
        const intRgx = /CADA\s*(\d+)\s*DIAS?/; const intM = norm.match(intRgx);
        if (intM) { result.intervalDays = parseInt(intM[1]); if (!result.date) { result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } }
        const timRgx = /(ALARMA|AVISO|AVISAR|AVISARME|AVÍSAME|TEMPORIZADOR|TIMER|RECORDAR|RECORDARME|RECUÉRDAME)\b.*?\b(\d+|\w+)\s*(MINUTOS?|HORAS?|MINS?|HRS?)/i; const timM = norm.match(timRgx);
        if (timM) { const valStr = timM[2]; const unit = timM[3]?.toUpperCase(); let val = numW[valStr.toUpperCase()] || parseInt(valStr); if (!isNaN(val) && val > 0 && unit) { let tmc = 0; if (unit.startsWith('HORA') || unit.startsWith('HR')) { tmc = val * 60; } else if (unit.startsWith('MINUTO') || unit.startsWith('MIN')) { tmc = val; }
                if (tmc > 0) { const endT = new Date(Date.now() + tmc * 60000); result.date = `${endT.getFullYear()}-${(endT.getMonth() + 1).toString().padStart(2, '0')}-${endT.getDate().toString().padStart(2, '0')}`; result.time = `${endT.getHours().toString().padStart(2, '0')}:${endT.getMinutes().toString().padStart(2, '0')}`; result.repeatDays = []; result.intervalDays = null; result.type = 'simple'; } } }
        const locationPhrases = ["EN EL LUGAR", "EN EL SITIO", "EN LA UBICACION", "EN LA LOCALIZACION"]; if (locationPhrases.some(phrase => norm.includes(phrase))) { result.isLocationEnabled = true; }
        const radiusRgx = /(?:RADIO|MARGEN)\s*DE\s*(\d+)\s*METROS?/i; const radiusMatch = norm.match(radiusRgx);
        if (radiusMatch && radiusMatch[1]) { const parsedRadius = parseInt(radiusMatch[1]); if (!isNaN(parsedRadius) && parsedRadius > 0) { result.radiusMeters = parsedRadius; result.isLocationEnabled = true; } }
        const excludePhrases = ["NO LISTAR", "NO MOSTRAR EN LISTA", "EXCLUIR LISTA", "OCULTAR LISTA", "RADAR"]; if (excludePhrases.some(phrase => norm.includes(phrase))) { result.excludeFromList = true; }

        if (norm.toUpperCase().startsWith("<b>RADAR:") && result.radiusMeters === 600 && !radiusMatch) {
            result.radiusMeters = 600;
        } else if (result.radiusMeters === 600 && !norm.toUpperCase().startsWith("<b>RADAR:") && !radiusMatch && !excludePhrases.some(phrase => norm.includes(phrase))) {
            result.radiusMeters = 600;
        }


        if (result.type === null) {
            if (result.intervalDays !== null && result.date) { result.type = 'interval'; } else if (result.repeatDays.length > 0 && result.time) { result.type = 'weekly'; } else if (result.date && result.time) { result.type = 'daily'; } else if (result.time) { result.type = 'daily'; if (!result.date) result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (result.date) { result.type = 'daily'; } else { result.type = 'simple'; } }
        if (!result.time && (result.type === 'daily' || result.type === 'weekly' || result.type === 'interval' )) { result.time = '00:01'; }
        if (elementsToUpdate) {
             if (elementsToUpdate.locationCheckbox) { const shouldBeChecked = result.isLocationEnabled; if (elementsToUpdate.locationCheckbox.checked !== shouldBeChecked && !elementsToUpdate.mapExpandedManually) { elementsToUpdate.locationCheckbox.checked = shouldBeChecked; } }
             if (elementsToUpdate.radiusInput) { elementsToUpdate.radiusInput.value = result.radiusMeters; }
             if (!elementsToUpdate.manualTimeInput && elementsToUpdate.timeInput && result.time) { elementsToUpdate.timeInput.value = result.time; }
             if (elementsToUpdate.dateInput && result.date) { const dateParts = result.date.split('-');
             if(dateParts.length === 3) { elementsToUpdate.dateInput.value = `${dateParts[2]}/${dateParts[1]}/${dateParts[0]}`; } else { elementsToUpdate.dateInput.value = ''; } } else if (elementsToUpdate.dateInput) { elementsToUpdate.dateInput.value = ''; }
             if (elementsToUpdate.intervalInput) { elementsToUpdate.intervalInput.value = result.intervalDays || ''; }
             if (elementsToUpdate.repeatCheckboxes && result.repeatDays && result.repeatDays.length > 0) { elementsToUpdate.repeatCheckboxes.forEach(input => { input.checked = result.repeatDays.includes(parseInt(input.value)); }); } else if (elementsToUpdate.repeatCheckboxes) { elementsToUpdate.repeatCheckboxes.forEach(input => { input.checked = false; }); }
             if (elementsToUpdate.excludeFromListCheckbox) { elementsToUpdate.excludeFromListCheckbox.checked = result.excludeFromList; }
        } return result;
    }
    



function showHelpModal(options = {}) {
    const modal = document.createElement('div'); modal.className = 'help-modal'; modal.setAttribute('aria-label', 'Ayuda recordatorios');
    modal.innerHTML = `
            <h2 class="text-2xl font-bold">Ayuda Recordatorios</h2>
            <div class="modal-top-buttons" style="justify-content: flex-end;">
                <button type="button" id="close-help" style="flex: 0 1 auto; min-width: 120px;">Cerrar</button>
            </div>
            <p class="mb-4">Ejemplos:</p>
            <ul class="list-disc pl-6 mb-4">
                <li><strong>Texto:</strong> "Recordar cita", "Llamar mamá"</li>
                <li><strong>Hora:</strong> "A LAS DIEZ Y CUARTO" → 10:15, "A LAS CINCO Y MEDIA TARDE" → 17:30</li>
                <li><strong>Fecha:</strong> "HOY", "MAÑANA", "DENTRO DE 15 DÍAS", "EL DÍA 22", "PRÓXIMO LUNES", "25/05/2025"</li>
                <li><strong>Repetición:</strong> "CADA LUNES", "TODOS LOS VIERNES Y SÁBADOS"</li>
                <li><strong>Intervalo:</strong> "CADA 7 DÍAS"</li>
                <li><strong>Alarma:</strong> "ALARMA EN 30 MINUTOS", "RECORDAR EN 2 HORAS". Crea recordatorio para fecha/hora exacta.</li>
                <li><strong>Excluir de Lista/Radar:</strong> Añadir "NO LISTAR", "EXCLUIR LISTA" o "RADAR" para ocultarlo de la lista general y que aparezca con chincheta morada en el mapa de ubicaciones.</li>
            </ul>
            <p class="mb-4">Formatos fecha: DD/MM/YYYY, DD-MM-YY, etc.</p>
            <p class="mb-4">Nota: Combina hora, fecha, días, intervalo. Palabra Alarma/Aviso/sar/Recordar/torio/dame,Timer crean alarmas.</p>
            <h3 class="text-xl font-bold mt-6 mb-2">Recordatorios por Ubicación</h3>
            <ul class="list-disc pl-6 mb-4">
                <li><strong>Activar:</strong>
                    <ul>
                        <li>Marca la casilla "Ubicación".</li>
                        <li>O escribe frases como: "EN EL LUGAR", "EN EL SITIO", "EN LA UBICACION", "EN LA LOCALIZACION".</li>
                    </ul>
                </li>
                <li><strong>Ver/Ampliar Mapa (Formulario):</strong>
                    <ul>
                        <li>Pulsa el botón "Ampliar Mapa" que aparece junto al check "Ubicación".</li>
                        <li>Si la ubicación está activa y fijada, verás un pequeño mapa de previsualización debajo.</li>
                    </ul>
                </li>
                <li><strong>Fijar Punto (Formulario):</strong>
                    <ul>
                        <li>Una vez ampliado el mapa, pulsa en él para fijar la ubicación deseada.</li>
                        <li>El mapa ampliado mostrará tu ubicación actual por defecto si concedes permiso y está disponible.</li>
                        <li>Usa el botón <strong style="color:green;">ESTÁS AQUÍ</strong> (en el mapa ampliado del formulario) para centrar rápidamente en tu posición actual y <strong>fijar esa posición como la del recordatorio</strong>. Si pulsas de nuevo vuelves a la anterior.</li>
                    </ul>
                </li>
                <li><strong>Radio de Acción:</strong>
                    <ul>
                        <li>Indica el radio en metros (por defecto ${DEFAULT_LOCATION_RADIUS}m para normales, 600m para "RADAR:") en el campo correspondiente.</li>
                        <li>Puedes escribir "RADIO DE 200 METROS" o "MARGEN DE 500 METROS" en el texto para ajustarlo automáticamente.</li>
                    </ul>
                </li>
                <li><strong>Funcionamiento:</strong> El recordatorio solo saltará si, además de cumplirse la hora/fecha, te encuentras DENTRO del radio de la ubicación guardada.</li>
                <li><strong>Reducir Mapa (Formulario):</strong> Pulsa el botón "REDUCIR MAPA" (visible en el mapa ampliado del formulario) para volver a la vista pequeña de previsualización.</li>
                <li><strong>Ubicaciones Guardadas:</strong> Puedes guardar hasta ${MAX_SAVED_LOCATIONS} ubicaciones frecuentes desde el botón "Ubicaciones" en este formulario. Luego, para usarlas, ve a "Ubicaciones", busca la deseada y pulsa "Seleccionar".</li>
                <li><strong>Mapa General de Ubicaciones/Navegación:</strong>
                    <ul>
                        <li>Accede a él pulsando el icono <img src="RADAR.PNG" alt="Radar Icon" style="width:1em; height:1em; vertical-align:middle; display:inline;"> en la barra superior.</li>
                        <li>Desde aquí puedes gestionar recordatorios con ubicación (como antes) o planificar y seguir rutas GPS.</li>
                        <li>Al entrar, el mapa está en modo "Planificación de Ruta". Pulsa en el mapa para añadir puntos.
                            Si quieres añadir un punto buscando por dirección, usa el campo de búsqueda <img src="./IMG_4400.png" alt="Campo búsqueda" style="height:1.2em; display:inline; vertical-align:middle;">.
                            El botón de añadir punto de ruta <img src="./ANADIRPUNTO.PNG" alt="Añadir punto" style="height:1.2em; display:inline; vertical-align:middle;"> estará visible si hay texto en el campo de búsqueda y está antes pegado a él.
                            El botón de ordenar etapas <img src="./MOVER.PNG" alt="Ordenar etapas" style="height:1.2em; display:inline; vertical-align:middle;"> está a la izquierda del de añadir punto de ruta.
                        </li>
                        <li>Consulta la ayuda específica del "Mapa de Navegación" (botón AYUDA <img src="./IMG_4326.PNG" alt="Ayuda" style="height:1.2em; display:inline; vertical-align:middle;"> en ese mapa) para más detalles sobre la planificación de rutas y navegación.</li>
                         <li>En la barra de progreso de la navegación, pulsa el icono de la maniobra para mostrar una vista de minimapa detallada de la próxima intersección.</li>
                    </ul>
                </li>
            </ul>
            <p class="mb-4">Usa micrófono para voz.</p>
        `;
    const parent = options.parentContainer || document.body;
    parent.appendChild(modal);

    const closeHelpButton = modal.querySelector('#close-help');
    const closeHandler = () => { clearModalAutoCloseTimer(modal, closeHelpButton, 'help-modal'); if (modal.parentNode) modal.parentNode.removeChild(modal); };
    closeHelpButton.addEventListener('click', closeHandler); addModalAutoCloseTimer(modal, closeHelpButton, 'help-modal');
}











function showReminderModal(reminder = null, options = {}) {
    const mapShouldReopenAfterForm = sessionStorage.getItem('boardinggate_map_should_reopen_after_form') === 'true';
    const mapContextBeforeThisModal = sessionStorage.getItem('mapContext');

    closeOtherModals();

    let autoSaveInterval = null; let parseTimeout = null; let restartTimeout = null; let focusTimeout = null; let countdownSave = 25; let manualTimeInput = false; let lastInputWasSpeech = false;
    let currentReminderLocation = null;
    let locationEnabledByUser = false;
    let mapExpandedManually = false;
    let mapMoveDebounceTimer = null;

    function cleanUpModalTimers(clearAll = true) {
            if (autoSaveInterval) { clearInterval(autoSaveInterval); autoSaveInterval = null; }
            if (clearAll) {
                if (parseTimeout) clearTimeout(parseTimeout);
                if (restartTimeout) clearTimeout(restartTimeout);

                if (focusTimeout) clearTimeout(focusTimeout);
                parseTimeout = null; restartTimeout = null; focusTimeout = null;
            }
        }
        const existingModal = document.querySelector('.reminder-modal');
        if (existingModal && typeof existingModal.cleanUpModalTimers === 'function') {
            existingModal.cleanUpModalTimers(true);
            if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal);
        }

        let isNew = true;
        let parsed = {
             id: null, text: '', time: null, date: null, repeatDays: [], intervalDays: null, type: 'simple',
             createdAt: new Date().toISOString(), managedByUser: false,
             isLocationEnabled: false, locationCoordinates: null, radiusMeters: DEFAULT_LOCATION_RADIUS,
             excludeFromList: false
        };

        if (reminder && typeof reminder.id === 'number' && reminder.id !== null) {
            const remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
            const foundReminder = remindersFromStorage.find(r => r.id === reminder.id);
            if (foundReminder) {
                parsed = { ...foundReminder };
                isNew = false;
            } else {
                parsed = { ...reminder, id: null, createdAt: new Date().toISOString(), managedByUser: false };
                isNew = true;
                if(reminder.text && reminder.text.toUpperCase().includes("RADAR RUTA:")) {
                     parsed.text = reminder.text.replace("RADAR RUTA:", "RADAR:");
                     parsed.excludeFromList = true;
                     parsed.radiusMeters = 600;
                }
            }
        } else if (reminder) {
            parsed = { ...reminder, id: null, createdAt: new Date().toISOString(), managedByUser: false };
            isNew = true;
             if(reminder.text && reminder.text.toUpperCase().includes("RADAR RUTA:")) {
                parsed.text = reminder.text.replace("RADAR RUTA:", "RADAR:");
                parsed.excludeFromList = true;
                parsed.radiusMeters = 600;
            }
        }

        if (parsed.text && parsed.text.toUpperCase().startsWith("<b>RADAR:") && (parsed.radiusMeters === DEFAULT_LOCATION_RADIUS || !parsed.radiusMeters)) {
            parsed.radiusMeters = 600;
        }


        if (!isNew && !parsed.createdAt) { parsed.createdAt = new Date(0).toISOString(); }

        locationEnabledByUser = parsed.isLocationEnabled;
        currentReminderLocation = parsed.locationCoordinates;

        let fmtDate = '';
        if (parsed.date?.match(/^\d{4}-\d{2}-\d{2}$/)) {
            try {
                const [y,m,d] = parsed.date.split('-');
                const dt=new Date(Date.UTC(y,m-1,d));
                if(!isNaN(dt.getTime())&&dt.getUTCDate()==d&&dt.getUTCMonth()==m-1) {
                    fmtDate=`${d.toString().padStart(2,'0')}/${m.toString().padStart(2,'0')}/${y}`;
                }
            } catch(e){}
        }


        const modal = document.createElement('div');
        modal.className = 'reminder-modal';
        modal.setAttribute('aria-label','Formulario recordatorio');

        const titleHtml = `
            <div style="display: flex; align-items: center; justify-content: space-between; width: 100%; flex-wrap: wrap;">
                <span class="font-bold" style="font-size: 1.5rem; margin-right: auto;">${isNew ? 'NUEVO RECORDATORIO' : 'MODIFICAR RECORDATORIO'}</span>
                <div style="display: flex; align-items: center; margin-left: 35px; white-space: nowrap;">
                    <input type="checkbox" id="reminder-exclude-from-list" ${parsed.excludeFromList ? 'checked' : ''} style="transform: scale(1.1); margin-right: 5px;">
                    <label for="reminder-exclude-from-list" style="font-size: 0.9rem; font-weight: normal; color: #555;">NO INCLUIRLO EN LA LISTA (radares, etc)</label>
                </div>
            </div>`;

        modal.innerHTML = `
             <h2 style="display: flex; align-items: center; justify-content: center; text-align: center;">${titleHtml}</h2>
             <div class="modal-top-buttons full-width" style="margin-top: 1rem; margin-bottom: 0.8rem;">
                <button type="submit" id="save-reminder">Aceptar <span id="countdown-save">25</span></button>
                <button type="button" id="cancel-reminder">Cancelar</button>
                <button type="button" id="delete-reminder" title="Borrar este recordatorio permanentemente">Borrar</button>
                <button type="button" id="view-reminders">Ver Recordatorios</button>
                <button type="button" id="manage-saved-locations">Ubicaciones</button>
                <button type="button" id="help-reminder">Ayuda</button>
             </div>
             <p id="parse-status" class="text-sm mt-1"></p>
             <form id="reminder-form">
                 <div class="full-width">
                    <div style="display:flex;align-items:center;gap:.5rem;">
                        <button type="button" id="clear-fields" class="speech-button" title="Limpiar" style="background-color:#D1D5DB;color:#111827;flex-shrink:0;">Limpiar</button>
                        <textarea id="reminder-text" rows="4" required style="flex-grow:1;">${parsed.text.replace(/<b>|<\/b>/gi,'')}</textarea>
                        <button type="button" id="start-speech" class="speech-button" title="Voz" style="flex-shrink:0;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                        </button>
                    </div>
                    <p id="speech-status" class="speech-status"></p>
                 </div>


                 <div class="form-grid">
                     <div>
                         <label for="reminder-time">Hora:</label>
                         <input type="text" id="reminder-time" placeholder="HH:MM" pattern="\\d{2}:\\d{2}" value="${parsed.time||''}">
                     </div>
                     <div>
                         <label for="reminder-date">Fecha:</label>
                         <input type="text" id="reminder-date" placeholder="DD/MM/AAAA" pattern="\\d{2}/\\d{2}/\\d{4}" value="${fmtDate}">
                     </div>
                     <div style="display: flex; flex-direction: column; align-items: flex-start;">
                         <label for="reminder-interval" style="margin-bottom: 0.25rem; line-height: 1.2;">Intervalo<br>(días):</label>
                         <div style="display: flex; align-items: center; gap: 0.5rem;">
                             <input type="number" id="reminder-interval" min="1" max="9999" value="${parsed.intervalDays||''}" style="width: 90px;">
                             <input type="checkbox" id="location-enabled" ${parsed.isLocationEnabled ? 'checked' : ''} style="margin-left: 8px; transform: scale(1.2); margin-right: 0.2rem;">
                             <label for="location-enabled" style="font-weight: bold; white-space: nowrap; font-size: 1.1rem; color: #374151;">Ubicación</label>
                         </div>
                     </div>
                     <div class="location-controls-group" style="justify-content: flex-start; margin-top: 0; align-items: center;">
                        <label for="reminder-radius" style="margin-left: 0;">Radio(m):</label>
                        <input type="number" id="reminder-radius" min="50" max="100000" value="${parsed.radiusMeters || DEFAULT_LOCATION_RADIUS}" style="width: 110px;">
                        <button type="button" id="expand-map-button">Ampliar Mapa</button>
                     </div>
                 </div>

                 <div id="location-map-container" class="full-width">
                     <button type="button" id="reduce-map-button" class="hidden">REDUCIR MAPA</button>
                     <button type="button" id="locate-me-button" class="hidden">ESTÁS AQUÍ</button>
                 </div>

                 <div class="days-group full-width">
                     <label>Días repetición:</label>
                     ${['Lun ','Mar ','Mié ','Jue ','Vie ','Sáb ','Dom '].map((d,i)=>`<label style="flex:0 0 auto;"><input type="checkbox" name="repeat" value="${(i+1)%7}" ${parsed.repeatDays?.includes((i+1)%7)?'checked':''}> ${d}</label>`).join('')}
                 </div>
                 <p id="auto-save-timer" class="text-sm text-gray-600 mt-2 full-width"></p>
             </form>`;
        
        if (options.onTopOfMap) {
            const mapContainer = document.getElementById('reminders-location-map-modal');
            if (mapContainer) {
                mapContainer.appendChild(modal);
            } else {
                document.body.appendChild(modal);
            }
        } else {
            document.body.appendChild(modal);
        }

        modal.cleanUpModalTimers = cleanUpModalTimers;

        const parseStatus = modal.querySelector('#parse-status');
        const speechStatus = modal.querySelector('#speech-status');
        const autoSaveTimerLabel = modal.querySelector('#auto-save-timer');
        let countdownSaveElement = modal.querySelector('#countdown-save');
        const textInput = modal.querySelector('#reminder-text');
        const timeInput = modal.querySelector('#reminder-time');
        const dateInput = modal.querySelector('#reminder-date');
        const intervalInput = modal.querySelector('#reminder-interval');
        const speechButton = modal.querySelector('#start-speech');
        const saveButton = modal.querySelector('#save-reminder');
        const clearButton = modal.querySelector('#clear-fields');
        const locationCheckbox = modal.querySelector('#location-enabled');
        const radiusInput = modal.querySelector('#reminder-radius');
        const mapContainer = modal.querySelector('#location-map-container');
        const expandMapButton = modal.querySelector('#expand-map-button');
        const reduceMapButton = modal.querySelector('#reduce-map-button');
        const locateMeButton = modal.querySelector('#locate-me-button');
        const manageLocationsBtn = modal.querySelector('#manage-saved-locations');
        const excludeFromListCheckbox = modal.querySelector('#reminder-exclude-from-list');
        const deleteButton = modal.querySelector('#delete-reminder');


        if (deleteButton) {
            deleteButton.style.backgroundColor = '#8B0000';
            deleteButton.style.color = '#FFFFFF';
            deleteButton.style.fontWeight = 'bold';
            deleteButton.style.fontSize = '1.2rem';
            deleteButton.style.border = '1px solid #580000';
            deleteButton.style.height = '70px';
            deleteButton.addEventListener('click', () => {
                cleanUpModalTimers(true);
                const mapShouldReopen = mapShouldReopenAfterForm;
                const mapContextToReopen = mapContextBeforeThisModal;

                if (isNew) {
                    destroyMap();
                    if (modal.parentNode) modal.parentNode.removeChild(modal);
                    showToast('Creación de recordatorio cancelada', 'info');

                    if (mapShouldReopen && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
                        if (mapContextToReopen === 'navigation') openNavigationMap();
                    } else if (mapShouldReopen) {
                        sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
                        if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen);
                    }
                     sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
                    return;
                }

                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const initialLength = reminders.length;
                reminders = reminders.filter(r => r.id !== parsed.id);

                if (reminders.length < initialLength) {
                    localStorage.setItem('reminders', JSON.stringify(reminders));
                    markCacheAsDirty(); // <--- LLAMADA AÑADIDA
                    showToast('Recordatorio borrado.', 'success');
                } else {
                    showToast('Recordatorio no encontrado para borrar', 'warning');
                }

                destroyMap();
                if (modal.parentNode) modal.parentNode.removeChild(modal);
                updateReminderCount();
                updateButtonStyles();
                checkReminders();

                 if (mapShouldReopen && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
                    if (mapContextToReopen === 'navigation') openNavigationMap();
                } else if (mapShouldReopen) {
                     sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
                     if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen);
                }
                sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
            });
        }

        modal.querySelectorAll('.modal-top-buttons button').forEach(btn => {
            if (btn.id !== 'save-reminder' && btn.id !== 'delete-reminder') {
                btn.style.height = '70px';
            }

            const defaultBgColor = window.getComputedStyle(btn).backgroundColor;
            const defaultTextColor = window.getComputedStyle(btn).color;
        
        if ((defaultTextColor === 'rgb(255, 255, 255)' || defaultTextColor.toLowerCase() === '#ffffff') &&
                (defaultBgColor === 'rgb(209, 213, 219)' || defaultBgColor.toLowerCase() === '#d1d5db') &&
                 btn.id !== 'save-reminder' &&
                 btn.id !== 'delete-reminder' &&
                 !btn.style.backgroundColor.includes('rgb(37, 99, 235)') &&
                 !btn.style.backgroundColor.includes('rgb(139, 0, 0)') ) {

                btn.style.backgroundColor = '#4A5568';
                btn.style.border = '1px solid #2D3748';
                btn.style.fontWeight = 'bold';
                 btn.onmouseover = () => btn.style.backgroundColor = '#2D3748';
                 btn.onmouseout = () => btn.style.backgroundColor = '#4A5568';
            }
        });

        if (manageLocationsBtn) {
            manageLocationsBtn.addEventListener('click', () => {
                showSavedLocationsModal(
                    () => { },
                    (selectedLocationData) => {
                        if (selectedLocationData && typeof selectedLocationData.lat === 'number' && typeof selectedLocationData.lng === 'number') {
                            currentReminderLocation = { latitude: selectedLocationData.lat, longitude: selectedLocationData.lng };
                            locationCheckbox.checked = true;
                            locationEnabledByUser = true;
                            radiusInput.disabled = false;

                            if (typeof selectedLocationData.radius === 'number' && selectedLocationData.radius > 0) {
                                 radiusInput.value = selectedLocationData.radius;
                            } else {
                                 radiusInput.value = DEFAULT_LOCATION_RADIUS;
                            }

                            if (mapContainer.classList.contains('expanded')) {
                                initializeOrUpdateMap(currentReminderLocation, radiusInput.value, true);
                            } else {
                                initializeOrUpdateMap(currentReminderLocation, radiusInput.value, false);
                            }
                            showToast(`Ubicación "${selectedLocationData.name || 'Seleccionada'}" aplicada.`, "success");
                            resetAndStartCountdown();
                        } else {
                            showToast("Error: Datos de ubicación seleccionada no válidos.", "error");
                        }
                    },
                    { parentContainer: modal } 
                );
            });
        }

        const handleMapMoveStart = () => {
            if (reminderCircle && mapContainer.classList.contains('expanded')) {
                clearTimeout(mapMoveDebounceTimer);
                reminderCircle.setStyle({ stroke: false, fill: false });
            }
        };

        const handleMapMoveEnd = () => {
            clearTimeout(mapMoveDebounceTimer);
            mapMoveDebounceTimer = setTimeout(() => {
                if (reminderCircle && mapContainer.classList.contains('expanded')) {
                    const effectiveRadius = parseInt(radiusInput.value) || DEFAULT_LOCATION_RADIUS;
                    const isRadar = textInput.value.toUpperCase().includes("RADAR:");
                    const circleColor = isRadar ? 'rgba(255, 165, 0, 0.2)' : 'blue';
                    const circleFillColor = isRadar ? 'rgba(255, 165, 0, 0.2)' : '#ADD8E6';
                    const circleFillOpacity = isRadar ? 0.2 : 0.05;
                    const circleWeight = isRadar ? 1 : 1;
                    reminderCircle.setStyle({ stroke: true, color: circleColor, fill: true, fillColor: circleFillColor, fillOpacity: circleFillOpacity, weight: circleWeight });
                }
            }, 200);
        };   
    
            function initializeOrUpdateMap(centerCoords, radius, isInteractive = false) {
            const mapDivId = 'reminder-modal-map-div';
            let mapDiv = document.getElementById(mapDivId);
            const effectiveLocationEnabled = locationCheckbox.checked;

            const showMap = effectiveLocationEnabled || isInteractive;

            if (!showMap) {
                destroyMap();
                return;
            }

            mapContainer.style.display = 'block';
            mapContainer.classList.toggle('preview', !isInteractive && effectiveLocationEnabled && centerCoords);
            mapContainer.classList.toggle('expanded', isInteractive && effectiveLocationEnabled);

            const effectiveCoords = centerCoords || { latitude: 40.416775, longitude: -3.703790 };
            const effectiveRadius = parseInt(radius) || DEFAULT_LOCATION_RADIUS;

            if (!isInteractive && !centerCoords && effectiveLocationEnabled) {
                 destroyMap();
                 return;
            }


            const zoomLevel = isInteractive ? 13 : 11;

            const setupMapInteractions = (mapInstance) => {
                mapInstance.off('click', handleMapClick);
                mapInstance.off('movestart', handleMapMoveStart);
                mapInstance.off('moveend', handleMapMoveEnd);

                if (isInteractive && effectiveLocationEnabled) {
                    mapInstance.dragging.enable(); mapInstance.touchZoom.enable(); mapInstance.scrollWheelZoom.enable();
                    mapInstance.doubleClickZoom.enable(); mapInstance.tap?.enable();

                    mapInstance.on('click', handleMapClick);
                    mapInstance.on('movestart', handleMapMoveStart);
                    mapInstance.on('moveend', handleMapMoveEnd);
                } else {
                    mapInstance.dragging.disable(); mapInstance.touchZoom.disable(); mapInstance.scrollWheelZoom.disable();
                    mapInstance.doubleClickZoom.disable(); mapInstance.tap?.disable();

                }
            };

            const activeLayerKeyReminder = 'boardinggate_activeMapLayer_reminderModal';

            if (!reminderModalMap) {
                if (!mapDiv) {
                    mapDiv = document.createElement('div');
                    mapDiv.id = mapDivId;
                    mapDiv.style.width = '100%'; mapDiv.style.height = '100%';
                    mapContainer.insertBefore(mapDiv, reduceMapButton);
                }

                reminderModalMap = L.map(mapDivId, {
                     scrollWheelZoom: (isInteractive && effectiveLocationEnabled),
                     doubleClickZoom: (isInteractive && effectiveLocationEnabled),
                     touchZoom: (isInteractive && effectiveLocationEnabled),
                     dragging: (isInteractive && effectiveLocationEnabled),
                     tap: (isInteractive && effectiveLocationEnabled),
                     zoomControl: isInteractive && effectiveLocationEnabled
                }).setView([effectiveCoords.latitude, effectiveCoords.longitude], zoomLevel);

                const osmLayerRem = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: (isInteractive && effectiveLocationEnabled) ? '© <a href="https://www.openstreetmap.org/copyright">OSM</a>' : null });
                const satelliteLayerRem = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' });
                const satelliteWithLabelsRem = L.layerGroup([
                    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' }),
                    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', { attribution: '© OSM © CARTO', pane: 'labels_reminder' })
                ]);

                if (!reminderModalMap.getPane('labels_reminder')) {
                    reminderModalMap.createPane('labels_reminder');
                    reminderModalMap.getPane('labels_reminder').style.zIndex = 650;
                    reminderModalMap.getPane('labels_reminder').style.pointerEvents = 'none';
                }


                const baseMapsRem = { "Mapa Normal": osmLayerRem, "Satélite Puro": satelliteLayerRem, "Satélite + Calles": satelliteWithLabelsRem };
                const savedLayerNameRem = localStorage.getItem(activeLayerKeyReminder) || "Satélite + Calles";
                let initialLayerRem = baseMapsRem[savedLayerNameRem] || satelliteWithLabelsRem;
                initialLayerRem.addTo(reminderModalMap);

                if (mapLayersControlReminder) mapLayersControlReminder.remove();
                mapLayersControlReminder = L.control.layers(baseMapsRem, null, { position: 'topright', collapsed: true });
                if (isInteractive && effectiveLocationEnabled) {
                   mapLayersControlReminder.addTo(reminderModalMap);
                }

                reminderModalMap.on('baselayerchange', function(e) {
                    localStorage.setItem(activeLayerKeyReminder, e.name);
                    markCacheAsDirty(); // <--- LLAMADA AÑADIDA
                });

                setupMapInteractions(reminderModalMap);
                updateMarkerAndCircle(effectiveCoords, effectiveRadius);

            } else {
                 reminderModalMap.setView([effectiveCoords.latitude, effectiveCoords.longitude], zoomLevel);
                 updateMarkerAndCircle(effectiveCoords, effectiveRadius);
                 setupMapInteractions(reminderModalMap);

                 if (mapLayersControlReminder) {
                     if (isInteractive && effectiveLocationEnabled && !reminderModalMap.hasControl(mapLayersControlReminder)) {
                         mapLayersControlReminder.addTo(reminderModalMap);
                     } else if ((!isInteractive || !effectiveLocationEnabled) && reminderModalMap.hasControl(mapLayersControlReminder)) {
                        mapLayersControlReminder.remove();
                     }
                 }
                 if (reminderModalMap.zoomControl) {
                    if (isInteractive && effectiveLocationEnabled) reminderModalMap.zoomControl.addTo(reminderModalMap);
                    else reminderModalMap.zoomControl.remove();
                 }
            }

            if (reduceMapButton) reduceMapButton.classList.toggle('hidden', !(isInteractive && effectiveLocationEnabled));
            if (locateMeButton) locateMeButton.classList.toggle('hidden', !(isInteractive && effectiveLocationEnabled));

            if (mapContainer.classList.contains('expanded') || mapContainer.classList.contains('preview')) {
                 requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        if (reminderModalMap && mapContainer.offsetHeight > 0) {
                            try {
                                reminderModalMap.invalidateSize();
                            } catch (e) { }
                        } else if (reminderModalMap) {
                        }
                    });
                });
            }
        }
        
        function handleMapClick(e) {
             const latlng = e.latlng;
             currentReminderLocation = { latitude: latlng.lat, longitude: latlng.lng };
             updateMarkerAndCircle(currentReminderLocation, radiusInput.value);
             resetAndStartCountdown();
        }
     
            function updateMarkerAndCircle(coords, radius) {
            if (!reminderModalMap || !coords) return;

            const latlng = L.latLng(coords.latitude, coords.longitude);
            const radiusMeters = parseInt(radius) || DEFAULT_LOCATION_RADIUS;
            const isDraggable = mapContainer.classList.contains('expanded') && locationCheckbox.checked;
            const currentCarIcon = vehicleIcon;


            if (!reminderMarker) {
                reminderMarker = L.marker(latlng, { icon: currentCarIcon, draggable: isDraggable }).addTo(reminderModalMap);
                if (isDraggable) reminderMarker.on('dragend', handleMarkerDragEnd);
            } else {
                reminderMarker.setLatLng(latlng);
                 if (reminderMarker.getIcon().options.iconAnchor[0] !== vehicleIcon.options.iconAnchor[0] ||
                    reminderMarker.getIcon().options.iconAnchor[1] !== vehicleIcon.options.iconAnchor[1]) {
                    reminderMarker.setIcon(vehicleIcon);
                }
                reminderMarker.options.draggable = isDraggable;
                reminderMarker.off('dragend', handleMarkerDragEnd);
                if (isDraggable) reminderMarker.on('dragend', handleMarkerDragEnd);
            }
            const markerElementContainer = reminderMarker.getElement();
            if(markerElementContainer) {
                 const vehicleWrapper = markerElementContainer.querySelector('#vehicle-icon-wrapper');
                 if (vehicleWrapper) {
                    const currentHeading = (navigationCurrentLocation && typeof navigationCurrentLocation.heading === 'number') ? navigationCurrentLocation.heading : (currentMapBearing || 0);
                    const rotationAngle = currentHeading - 90;
                    vehicleWrapper.style.transform = `rotate(${rotationAngle}deg)`;
                 }
            }


            const isRadar = textInput.value.toUpperCase().includes("RADAR:");
            const circleColor = isRadar ? 'rgba(255, 165, 0, 0.2)' : 'blue';
            const circleFillColor = isRadar ? 'rgba(255, 165, 0, 0.2)' : '#ADD8E6';
            const circleFillOpacity = isRadar ? 0.2 : 0.05;
            const circleWeight = isRadar ? 1 : 1;


            if (!reminderCircle) {
                reminderCircle = L.circle(latlng, { color: circleColor, fillColor: circleFillColor, weight: circleWeight, fillOpacity: circleFillOpacity, radius: radiusMeters }).addTo(reminderModalMap);
            } else {
                reminderCircle.setLatLng(latlng);
                reminderCircle.setRadius(radiusMeters);
                 reminderCircle.setStyle({ color: circleColor, fillColor: circleFillColor, weight: circleWeight, fillOpacity: circleFillOpacity });
                if (!mapContainer.classList.contains('expanded') || (mapMoveDebounceTimer === null)) {
                     reminderCircle.setStyle({ stroke: true });
                }
            }
        }

        function handleMarkerDragEnd(event) {
             const marker = event.target;
             const position = marker.getLatLng();
             currentReminderLocation = { latitude: position.lat, longitude: position.lng };
             updateMarkerAndCircle(currentReminderLocation, radiusInput.value);
             resetAndStartCountdown();
        }

        function destroyMap() {
            if (reminderModalMap) {
                 reminderModalMap.off('click', handleMapClick);
                 reminderModalMap.off('movestart', handleMapMoveStart);
                 reminderModalMap.off('moveend', handleMapMoveEnd);
                 if (reminderMarker) reminderMarker.off('dragend', handleMarkerDragEnd);
                 if (mapLayersControlReminder) mapLayersControlReminder.remove();
                 mapLayersControlReminder = null;
                 try { reminderModalMap.remove(); } catch(e) { }
                 reminderModalMap = null; reminderMarker = null; reminderCircle = null;
            }
            mapContainer.style.display = 'none';
            mapContainer.classList.remove('preview', 'expanded');
            if (reduceMapButton) reduceMapButton.classList.add('hidden');
            if (locateMeButton) locateMeButton.classList.add('hidden');
            const mapDiv = document.getElementById('reminder-modal-map-div');
            if(mapDiv && mapDiv.parentNode === mapContainer) {
                 mapContainer.removeChild(mapDiv);
            }
        }
        
            function handleLocationCheckboxChange() {
            const wasEnabled = locationEnabledByUser;
            locationEnabledByUser = locationCheckbox.checked;
            radiusInput.disabled = !locationEnabledByUser;

            if (locationEnabledByUser) {
                if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && currentReminderLocation) {
                    initializeOrUpdateMap(currentReminderLocation, radiusInput.value, false);
                } else if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && !currentReminderLocation) {
                    destroyMap();
                }
                 if (!currentReminderLocation && !wasEnabled) {
                    getCurrentLocation(
                        (coords) => {
                            currentReminderLocation = coords;
                            if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && currentReminderLocation) {
                                initializeOrUpdateMap(currentReminderLocation, radiusInput.value, false);
                            }
                        }
                    );
                }
            } else {
                destroyMap();
            }
            resetAndStartCountdown();
        }
        locationCheckbox.addEventListener('change', handleLocationCheckboxChange);

        if (parsed.isLocationEnabled && parsed.locationCoordinates) {
            initializeOrUpdateMap(parsed.locationCoordinates, parsed.radiusMeters, false);
        } else if (parsed.isLocationEnabled && !parsed.locationCoordinates) {
            radiusInput.disabled = false;
            destroyMap();
        } else {
            radiusInput.disabled = true;
            destroyMap();
        }

        if (expandMapButton) {
            expandMapButton.addEventListener('click', () => {
                if (!locationCheckbox.checked) {
                    locationCheckbox.checked = true;
                }
                locationEnabledByUser = true;
                radiusInput.disabled = false;
                mapExpandedManually = true;

                if (!currentReminderLocation) {
                    locateMeButton.disabled = true;
                    locateMeButton.textContent = 'Buscando...';
                    getCurrentLocation(
                        (gpsCoords) => {
                            currentReminderLocation = { latitude: gpsCoords.latitude, longitude: gpsCoords.longitude };
                            initializeOrUpdateMap(gpsCoords, radiusInput.value, true);
                            if (reminderModalMap) {
                                 reminderModalMap.setZoom(16);
                            }
                            showToast("Mapa centrado en tu ubicación GPS. Pulsa en el mapa para ajustar si es necesario", "info");
                            locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ';
                        },
                        (errorMsg) => {
                            initializeOrUpdateMap(null, radiusInput.value, true);
                            if (reminderModalMap) {
                                reminderModalMap.setZoom(6);
                            }
                            showToast(`Error GPS: ${errorMsg}. Mapa centrado por defecto`, "warning", 3000);
                            locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ';
                        }
                    );
                } else {
                    initializeOrUpdateMap(currentReminderLocation, radiusInput.value, true);
                }

                resetAndStartCountdown();
                setTimeout(() => { mapExpandedManually = false; }, 100);
            });
        }

        if (reduceMapButton) {
            reduceMapButton.addEventListener('click', () => {
                 if (locationEnabledByUser && currentReminderLocation) {
                     initializeOrUpdateMap(currentReminderLocation, radiusInput.value, false);
                 } else {
                     destroyMap();
                 }
                 resetAndStartCountdown();
            });
        }

        if (locateMeButton) {
            locateMeButton.addEventListener('click', () => {
                 if (!reminderModalMap || !mapContainer.classList.contains('expanded')) return;
                 resetAndStartCountdown();
                 locateMeButton.disabled = true; locateMeButton.textContent = 'Buscando...';
                 getCurrentLocation(
                     (coords) => {
                         currentReminderLocation = { latitude: coords.latitude, longitude: coords.longitude };
                         if (reminderModalMap) {
                            reminderModalMap.setView([coords.latitude, coords.longitude], 16);
                            updateMarkerAndCircle(coords, radiusInput.value);
                         }
                         showToast('Ubicación actual fijada para el recordatorio', 'success');
                         locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ';
                     },
                     (errorMsg) => {
                         showToast(`Error al localizar: ${errorMsg}`, 'error');
                         locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ';
                     }
                 );
            });
        }

        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) { const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; const recognition = new SpeechRecognition(); recognition.continuous = false; recognition.interimResults = false; recognition.lang = 'es-ES'; speechButton.addEventListener('click', () => { cleanUpModalTimers(false); try { recognition.start(); } catch (e) { speechStatus.textContent = `Error inicio: ${e.message}`; speechStatus.style.color = '#EF4444'; resetAndStartCountdown(); } }); recognition.onstart = () => { speechStatus.textContent = 'Escuchando...'; speechStatus.style.color = '#10B981'; }; recognition.onresult = (event) => { const transcript = event.results[event.results.length - 1][0].transcript.trim(); textInput.value = textInput.value + transcript; speechStatus.textContent = ''; lastInputWasSpeech = true; const inputEvent = new Event('input', { bubbles: true }); textInput.dispatchEvent(inputEvent); textInput.focus(); textInput.selectionStart = textInput.selectionEnd = textInput.value.length; }; recognition.onerror = (event) => { speechStatus.textContent = `Error voz: ${event.error}`; speechStatus.style.color = '#EF4444'; resetAndStartCountdown(); }; recognition.onend = () => { if (speechStatus.textContent === 'Escuchando...') { setTimeout(() => { if (speechStatus.textContent === 'Escuchando...') speechStatus.textContent = ''; }, 1500); } if (!lastInputWasSpeech) { resetAndStartCountdown(); } }; } else { speechStatus.textContent = 'Voz no soportada.'; speechStatus.style.color = '#EF4444'; speechButton.disabled = true; speechButton.style.opacity = 0.5; }

        function startCountdown() { autoSaveInterval = setInterval(() => { if (!document.body.contains(modal)) { clearInterval(autoSaveInterval); autoSaveInterval = null; return; } countdownSave--; if (countdownSaveElement) countdownSaveElement.textContent = countdownSave; if (countdownSave === 23) { if (document.activeElement === textInput) { textInput.value += ' '; textInput.selectionStart = textInput.selectionEnd = textInput.value.length; } } if (countdownSave <= 0) { clearInterval(autoSaveInterval); autoSaveInterval = null; if (saveButton) saveButton.click(); } }, 1000); }
        function resetAndStartCountdown() { countdownSave = 25; if (countdownSaveElement) countdownSaveElement.textContent = countdownSave; if (autoSaveInterval) { clearInterval(autoSaveInterval); autoSaveInterval = null; } startCountdown(); }
        timeInput.addEventListener('input', (e) => { manualTimeInput = true; let v = e.target.value.replace(/\D/g, ''); let fV=''; if(v.length>=2)fV=v.slice(0,2); if(v.length>2)fV+=':'+v.slice(2,4); else if(v.length<2)fV=v; e.target.value=fV; if (fV.match(/^\d{2}:\d{2}$/)) { const [h,m]=fV.split(':').map(Number); parseStatus.textContent=(h>23||m>59)?'Hora inválida':''; parseStatus.classList.toggle('text-red-600',h>23||m>59); parseStatus.classList.remove('text-green-600'); } else if(fV.length>0) { parseStatus.textContent='Formato HH:MM'; parseStatus.classList.remove('text-red-600','text-green-600'); } else { parseStatus.textContent=''; parseStatus.classList.remove('text-red-600','text-green-600'); } resetAndStartCountdown(); }); dateInput.addEventListener('input', (e) => { let v = e.target.value.replace(/\D/g, ''); let fV=''; if(v.length>=2)fV=v.slice(0,2); if(v.length>2)fV+='/'+v.slice(2,4); if(v.length>4)fV+='/'+v.slice(4,8); else if(v.length<2)fV=v; e.target.value=fV; if (fV.match(/^\d{2}\/\d{2}\/\d{4}$/)) { const [d,m,y]=fV.split('/').map(Number); const dt=new Date(Date.UTC(y,m-1,d)); const ok=!isNaN(dt.getTime())&&dt.getUTCDate()===d&&dt.getUTCMonth()+1===m&&y>=2000&&y<=2099; parseStatus.textContent=ok?'':'Fecha inválida'; parseStatus.classList.toggle('text-red-600',!ok); parseStatus.classList.remove('text-green-600'); } else if(fV.length>0) { parseStatus.textContent='Formato DD/MM/AAAA';
        parseStatus.classList.remove('text-red-600','text-green-600'); } else { parseStatus.textContent=''; parseStatus.classList.remove('text-red-600','text-green-600'); } resetAndStartCountdown(); }); intervalInput.addEventListener('input', resetAndStartCountdown); modal.querySelectorAll('input[name="repeat"]').forEach(chk => chk.addEventListener('change', resetAndStartCountdown)); autoSaveTimerLabel.style.display = 'block'; if (countdownSaveElement) countdownSaveElement.textContent = countdownSave;
        function startFocusCheck() { if (restartTimeout) clearTimeout(restartTimeout); restartTimeout = setTimeout(() => { if (document.activeElement !== textInput && document.activeElement !== timeInput && document.activeElement !== dateInput && document.activeElement !== intervalInput && !Array.from(modal.querySelectorAll('input[name="repeat"]')).includes(document.activeElement) && document.activeElement !== speechButton && document.activeElement !== saveButton && document.activeElement !== modal.querySelector('#cancel-reminder') && document.activeElement !== modal.querySelector('#help-reminder') && document.activeElement !== clearButton && document.activeElement !== modal.querySelector('#view-reminders') && document.activeElement !== locationCheckbox && document.activeElement !== radiusInput && document.activeElement !== expandMapButton && document.activeElement !== reduceMapButton && document.activeElement !== locateMeButton && !(reminderModalMap && reminderModalMap.getContainer().contains(document.activeElement)) ) { resetAndStartCountdown(); restartTimeout = null; } else { restartTimeout = null; } }, 500); } resetAndStartCountdown(); startFocusCheck(); modal.addEventListener('input', resetAndStartCountdown); modal.addEventListener('click', resetAndStartCountdown); modal.addEventListener('touchstart', resetAndStartCountdown, { passive: true }); modal.addEventListener('focusin', () => { resetAndStartCountdown(); if (focusTimeout) clearTimeout(focusTimeout); focusTimeout = null; }); modal.addEventListener('focusout', () => { if (!focusTimeout) { startFocusCheck(); } });

        textInput.addEventListener('input', (e) => {
            lastInputWasSpeech = false; const txt = e.target.value || ''; parseStatus.textContent = 'Parseando...'; parseStatus.classList.remove('text-green-600', 'text-red-600');
            if (parseTimeout) clearTimeout(parseTimeout);
            parseTimeout = setTimeout(() => {
                if (!document.body.contains(modal)) return;
                try {
                    const uiElements = { timeInput: timeInput, dateInput: dateInput, intervalInput: intervalInput, repeatCheckboxes: modal.querySelectorAll('input[name="repeat"]'), locationCheckbox: locationCheckbox, radiusInput: radiusInput, manualTimeInput: manualTimeInput, mapExpandedManually: mapExpandedManually, excludeFromListCheckbox: excludeFromListCheckbox };
                    if (!manualTimeInput) uiElements.timeInput.value = '';
                     uiElements.dateInput.value = ''; uiElements.intervalInput.value = '';
                     uiElements.repeatCheckboxes.forEach(chk => chk.checked = false);

                    const pD = parseReminderText(txt, uiElements);

                    if (isNew && (pD.type === 'weekly' || pD.type === 'interval')) {
                        const tempReminderForCalc = { type: pD.type, time: pD.time, date: pD.date, repeatDays: pD.repeatDays, intervalDays: pD.intervalDays };
                        const nowForCalc = new Date();
                        if (!tempReminderForCalc.date) tempReminderForCalc.date = `${nowForCalc.getFullYear()}-${(nowForCalc.getMonth() + 1).toString().padStart(2, '0')}-${nowForCalc.getDate().toString().padStart(2, '0')}`;
                        if (!tempReminderForCalc.time) tempReminderForCalc.time = '00:01';

                        const firstOcc = calculateNextOccurrence(tempReminderForCalc, new Date());
                        if (firstOcc) {
                            const firstOccISO = `${firstOcc.getUTCFullYear()}-${(firstOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOcc.getUTCDate().toString().padStart(2, '0')}`;
                            const firstOccTime = `${firstOcc.getUTCHours().toString().padStart(2, '0')}:${firstOcc.getUTCMinutes().toString().padStart(2, '0')}`;

                            pD.date = firstOccISO;
                            pD.time = firstOccTime;

                            const datePartsCalc = pD.date.split('-');
                            if(datePartsCalc.length === 3) dateInput.value = `${datePartsCalc[2]}/${datePartsCalc[1]}/${datePartsCalc[0]}`;
                            if (!manualTimeInput) timeInput.value = pD.time;
                        } else {
                             if (!pD.date) { const today = new Date(); pD.date = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}-${today.getDate().toString().padStart(2, '0')}`; }
                             if (!pD.time) pD.time = '00:01';
                             const datePartsFb = pD.date.split('-');
                             if(datePartsFb.length === 3) dateInput.value = `${datePartsFb[2]}/${datePartsFb[1]}/${datePartsFb[0]}`;
                             if (!manualTimeInput) timeInput.value = pD.time;
                        }
                    }

                    parseStatus.textContent = 'Parseado OK'; parseStatus.classList.add('text-green-600'); parseStatus.classList.remove('text-red-600');
                    handleLocationCheckboxChange();
                } catch (error) { parseStatus.textContent = `Error parse: ${error.message.substring(0, 100)}`; parseStatus.classList.add('text-red-600'); parseStatus.classList.remove('text-green-600'); }
                parseTimeout = null;
            }, 1000);
            resetAndStartCountdown();
        });

        saveButton.addEventListener('click', (e) => {
            e.preventDefault();
            const form = modal.querySelector('#reminder-form');
            if (form.checkValidity && !form.checkValidity()) {
                 form.reportValidity();
                 return;
            }
            cleanUpModalTimers(true);
            const mapShouldReopen = mapShouldReopenAfterForm;
            const mapContextToReopen = mapContextBeforeThisModal;

            const text = textInput.value.trim(); if (!text) { parseStatus.textContent = 'Texto obligatorio.'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; }
            let time = timeInput.value.trim(); let dateStr = dateInput.value.trim(); const repeatDays = Array.from(modal.querySelectorAll('input[name="repeat"]:checked')).map(input => parseInt(input.value)); const intervalDays = parseInt(intervalInput.value) || null;
            const isLocationChecked = locationCheckbox.checked; const radius = parseInt(radiusInput.value) || DEFAULT_LOCATION_RADIUS;
            const locationCoords = currentReminderLocation;
            const excludeFromListVal = excludeFromListCheckbox.checked;
            if (isLocationChecked && !locationCoords) { parseStatus.textContent = 'Ubicación activada pero no fijada en el mapa.'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; }
            let dateISO = null; let finalTime = time; let reminderType = 'simple';
            if (dateStr) { if (dateStr.match(/^\d{2}\/\d{2}\/\d{4}$/)) { const [d, m, y] = dateStr.split('/').map(Number); const tD = new Date(Date.UTC(y, m - 1, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() + 1 === m && y >= 2000 && y <= 2099) { dateISO = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } else { parseStatus.textContent = 'Fecha inválida'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } } else { parseStatus.textContent = 'Formato DD/MM/AAAA'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } }
            if (finalTime && !finalTime.match(/^\d{2}:\d{2}$/)) { parseStatus.textContent = 'Formato HH:MM'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } else if (finalTime) { const [h, m] = finalTime.split(':').map(Number); if (h > 23 || m > 59) { parseStatus.textContent = 'Hora inválida'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } }
            if (intervalDays !== null && intervalDays > 0) { reminderType = 'interval'; if (!dateISO) { const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } if (!finalTime) finalTime = '00:01'; }
            else if (repeatDays.length > 0) { reminderType = 'weekly'; if (!dateISO) { const tempCalc = { type: 'weekly', time: finalTime || '00:01', date: null, repeatDays: repeatDays, intervalDays: null }; const firstOcc = calculateNextOccurrence(tempCalc, new Date()); if (firstOcc) { dateISO = `${firstOcc.getUTCFullYear()}-${(firstOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOcc.getUTCDate().toString().padStart(2, '0')}`; finalTime = finalTime || `${firstOcc.getUTCHours().toString().padStart(2, '0')}:${firstOcc.getUTCMinutes().toString().padStart(2, '0')}`; } else { const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; if (!finalTime) finalTime = '00:01'; } } else { if (!finalTime) finalTime = '00:01'; } }
            else if (dateISO && finalTime) { reminderType = 'daily'; } else if (finalTime) { reminderType = 'daily'; const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (dateISO) { reminderType = 'daily'; finalTime = '00:01'; } else { reminderType = 'simple'; const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; finalTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`; }
            const now = new Date();
            const finalCreatedAt = isNew ? now.toISOString() : (parsed.createdAt || now.toISOString());
            let finalDateISO = dateISO;

            if (isNew && (reminderType === 'weekly' || reminderType === 'interval')) {
                let needsRecalc = false;
                if (!dateInput.value.trim()) {
                     needsRecalc = true;
                } else {
                    try {
                        const [d, m, y] = dateStr.split('/').map(Number);
                        const inputDate = new Date(Date.UTC(y, m - 1, d));
                        const todayForCompare = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                        if (inputDate < todayForCompare) {
                            needsRecalc = true;
                        }
                    } catch (e) { needsRecalc = true; }
                }

                if (needsRecalc) {
                    const tempCalcForNewCyclic = {
                        type: reminderType,
                        time: finalTime || '00:01',
                        date: null,
                        repeatDays: reminderType === 'weekly' ? repeatDays : [],
                        intervalDays: reminderType === 'interval' ? intervalDays : null
                    };
                    const firstOccurrence = calculateNextOccurrence(tempCalcForNewCyclic, new Date());
                    if (firstOccurrence) {
                        finalDateISO = `${firstOccurrence.getUTCFullYear()}-${(firstOccurrence.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOccurrence.getUTCDate().toString().padStart(2, '0')}`;
                    } else {
                        if (!finalDateISO) {
                            finalDateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
                        }
                    }
                }
            }


            let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
            const newReminder = {
                id: isNew ? Date.now() : parsed.id,
                text: `<b>${text.toUpperCase()}</b>`,
                type: reminderType,
                time: finalTime || null,
                date: finalDateISO,
                repeatDays: reminderType === 'weekly' ? repeatDays : [],
                intervalDays: reminderType === 'interval' ? intervalDays : null,
                createdAt: finalCreatedAt,
                managedByUser: false,
                isLocationEnabled: isLocationChecked,
                locationCoordinates: isLocationChecked ? locationCoords : null,
                radiusMeters: isLocationChecked ? radius : (parsed.radiusMeters || (text.toUpperCase().startsWith("RADAR:") ? 600 : DEFAULT_LOCATION_RADIUS)),
                excludeFromList: excludeFromListVal,
                isFromRuta: parsed.isFromRuta || false
            };

            if (!newReminder.date || !newReminder.time || !newReminder.createdAt){
                showToast("Error GRAVE: Fechas/Hora inválidas al guardar", "error");
                resetAndStartCountdown();
                return;
            }

            if (!isNew) {
                const index = reminders.findIndex(r => r.id === parsed.id);
                if (index !== -1) {
                    reminders[index] = newReminder;
                } else {
                    newReminder.id = Date.now() + Math.random();
                    reminders.push(newReminder);
                }
            } else {
                reminders.push(newReminder);
            }

            localStorage.setItem('reminders', JSON.stringify(reminders));
            markCacheAsDirty(); // <--- LLAMADA AÑADIDA
            showToast('Recordatorio guardado', 'success');

            destroyMap();
            if (modal.parentNode) modal.parentNode.removeChild(modal);

            updateReminderCount();
            updateButtonStyles();
            checkReminders();

            const unifiedWindowIsVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible');

            if (mapShouldReopen && !unifiedWindowIsVisible) {
                if (mapContextToReopen === 'navigation') openNavigationMap();
            } else if (mapShouldReopen && unifiedWindowIsVisible) {
                 sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
                 if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen);
            }
            sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
            sessionStorage.removeItem('mapContext');
        });

        modal.querySelector('#cancel-reminder').addEventListener('click', () => {
            cleanUpModalTimers(true);
            const mapShouldReopen = mapShouldReopenAfterForm;
            const mapContextToReopen = mapContextBeforeThisModal;
            destroyMap();
            if (modal.parentNode) modal.parentNode.removeChild(modal);

            if (mapShouldReopen) {
                 if (mapContextToReopen === 'navigation') openNavigationMap();
            }
            sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
            sessionStorage.removeItem('mapContext');
        });

        modal.querySelector('#help-reminder').addEventListener('click', () => {
            showHelpModal({ parentContainer: modal }); 
        });

        clearButton.addEventListener('click', () => {
            textInput.value=''; timeInput.value=''; dateInput.value='';
            modal.querySelectorAll('input[name="repeat"]').forEach(i=>i.checked=false);
            intervalInput.value='';
            locationCheckbox.checked = false;
            radiusInput.value = (parsed.radiusMeters || DEFAULT_LOCATION_RADIUS);
            currentReminderLocation = null;
            destroyMap();
            radiusInput.disabled = true;
            excludeFromListCheckbox.checked = false;
            parseStatus.textContent='';
            speechStatus.textContent='';
            manualTimeInput=false;
            resetAndStartCountdown();
            textInput.focus();
        });

        modal.querySelector('#view-reminders').addEventListener('click', () => {
            cleanUpModalTimers(true);
            const mapShouldReopen = mapShouldReopenAfterForm;
            const mapContextToReopen = mapContextBeforeThisModal;

            destroyMap();
            if (modal.parentNode) document.body.removeChild(modal);
            fromReminderModal = true;

            if (mapShouldReopen) {
                sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
                if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen);
            }
            showAllReminders({ parentContainer: document.getElementById('reminders-location-map-modal') }); 
        });
        
        textInput.focus();
    }




    



    

    

    
function markReminderAsManaged(reminderId, managedState = true) {
         if (typeof reminderId !== 'number') { return; } try { let reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); const index = reminders.findIndex(r => r.id === reminderId); if (index !== -1) { if (reminders[index].managedByUser !== managedState) { reminders[index].managedByUser = managedState; localStorage.setItem('reminders', JSON.stringify(reminders)); markCacheAsDirty(); } } } catch (e) { }
     }





// REEMPLAZA LA FUNCIÓN ENTERA CON ESTA VERSIÓN COMPLETA Y CORREGIDA
function addSlideButtonListeners(slideElement, reminder) {
    const reminderId = reminder.id;
    const cancelButton = slideElement.querySelector('.cancel');
    const adjustTimeButton = slideElement.querySelector('.adjust-time-0001');
    const cancelCyclicButton = slideElement.querySelector('.cancel-cyclic');
    const modifyButton = slideElement.querySelector('.modify');
    const postponeButton = slideElement.querySelector('.postpone');
    const routeRadarVistoButton = slideElement.querySelector('.route-radar-seen');

    const handleInteraction = (actionFn) => {
        markReminderAsManaged(reminderId, true);
        actionFn();
        updateUnifiedWindowUI(processedReminderId);
    };

    let processedReminderId = reminderId;

    if (routeRadarVistoButton) {
        routeRadarVistoButton.addEventListener('click', () => {
            const minutesToSnooze = 5;
            const snoozeEndTime = Date.now() + minutesToSnooze * 60 * 1000;
            // Añade el ID y la hora de fin al mapa global.
            snoozedRouteRadars.set(reminderId, snoozeEndTime);

            // Marca el recordatorio temporal como manejado para que desaparezca de la UI.
            markReminderAsManaged(reminderId, true);
            
            showToast(`Radar pospuesto ${minutesToSnooze} minutos`, 'info');
            
            // Elimina el slide de la vista.
            updateUnifiedWindowUI(reminderId);
        });
    }

    if (cancelButton) {
        cancelButton.addEventListener('click', () => { 
            if (reminder.isFromRuta === true) { 
                showToast(`Radar en ruta "${reminder.text.replace(/<[^>]*>/g, '')}" marcado como visto para esta alerta.`, 'info');
                updateUnifiedWindowUI(reminder.id); 
                markReminderAsManaged(reminder.id, true); 
            } else { 
                handleInteraction(() => { 
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const index = rems.findIndex(r => r.id === processedReminderId); 
                    if (index === -1) {
                        showToast("Error: No se encontró el recordatorio en localStorage para actualizar.", "error");
                        return;
                    }

                    const currentReminder = rems[index];
                    let needsSave = false;
                    const isRadarTypeStored = currentReminder.text.toUpperCase().includes("RADAR:") || currentReminder.excludeFromList;

                    if (isRadarTypeStored) { 
                       const minutesToPostponeRadar = 15;
                       const { newDateISO, newTime } = calculatePostponedDateTime(minutesToPostponeRadar);
                       rems[index].date = newDateISO;
                       rems[index].time = newTime;
                       rems[index].managedByUser = false;
                       needsSave = true;
                       showToast(`Radar guardado pospuesto ${minutesToPostponeRadar} minutos`, 'info');
                    } else if (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval')) {
                       const minutesToPostponeLocation = 15; 
                       const { newDateISO, newTime } = calculatePostponedDateTime(minutesToPostponeLocation);
                       rems[index].date = newDateISO;
                       rems[index].time = newTime;
                       rems[index].managedByUser = false;
                       needsSave = true;
                       showToast(`Recordatorio de ubicación pospuesto ${minutesToPostponeLocation} minutos`, 'info');
                    } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                        let referenceDateForNext = new Date();
                        try {
                            const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                            const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                            const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                            if (!isNaN(reminderDateTime.getTime())) {
                                referenceDateForNext = new Date(reminderDateTime.getTime() + 60000); 
                            }
                        } catch(er) {  }

                        const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                        if (nextOcc) {
                            rems[index].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                            rems[index].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                            rems[index].managedByUser = false;
                            needsSave = true;
                            showToast('Recordatorio actualizado al próximo ciclo', 'info');
                        } else {
                            rems.splice(index, 1); needsSave = true;
                            showToast('Error calculando siguiente ciclo. Recordatorio eliminado.', 'error');
                        }
                    } else {
                       // --- INICIO DE LA CORRECCIÓN ---
                       // Si es un recordatorio simple (no cíclico, no de ubicación, no radar)
                       // se elimina al pulsar "Visto/Próximo".
                       rems.splice(index, 1);
                       needsSave = true;
                       showToast('Recordatorio inmediato marcado como visto y eliminado.', 'info');
                       // --- FIN DE LA CORRECCIÓN ---
                    }

                    if (needsSave) localStorage.setItem('reminders', JSON.stringify(rems)); 
                }); 
            } 
        });
    }

    if (adjustTimeButton) {
        adjustTimeButton.addEventListener('click', () => handleInteraction(() => {
            let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
            const index = rems.findIndex(r => r.id === processedReminderId);
            if (index === -1) return;

            const currentReminder = rems[index];
            let needsSave = false;

            if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                 let referenceDateForNext = new Date();
                 try {
                     const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                     const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, 0, 1)); 
                     if (!isNaN(reminderDateTime.getTime())) {
                         referenceDateForNext = new Date(reminderDateTime.getTime() + 60000); 
                     }
                 } catch(e) {  }

                const reminderForCalc = { ...currentReminder, time: '00:01' };
                const nextOcc = calculateNextOccurrence(reminderForCalc, referenceDateForNext);

                if (nextOcc) {
                    rems[index].date= `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                    rems[index].time = '00:01';
                    rems[index].managedByUser = false;
                    needsSave = true;
                    showToast('Recordatorio ajustado a 00:01 y actualizado', 'info');
                } else {
                    rems.splice(index, 1); needsSave = true;
                    showToast('Error calculando siguiente ciclo (ajuste 00:01). Eliminado.', 'error');
                }
            } else { 
                rems.splice(index, 1); needsSave = true;
                showToast('Recordatorio no cíclico eliminado (acción "Ajustar 00:01")', 'info');
            }

            if (needsSave) localStorage.setItem('reminders', JSON.stringify(rems)); 
        }));
    }

    if (cancelCyclicButton) {
        cancelCyclicButton.addEventListener('click', () => handleInteraction(() => {
            if (confirm('¿Estás seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE?')) {
                let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                const initialLength = rems.length;
                rems = rems.filter(r => r.id !== processedReminderId);
                if (rems.length < initialLength) {
                   localStorage.setItem('reminders', JSON.stringify(rems)); 
                   showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                } else {
                    showToast('Error: No se encontró el ciclo para anular.', 'warning');
                }
            } else {
                markReminderAsManaged(processedReminderId, false); 
            }
        }));
    }

    if (modifyButton) {
        modifyButton.addEventListener('click', () => {
            markReminderAsManaged(reminder.id, true);
            let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
            let reminderToModify = remindersFromStorage.find(r => r.id === reminder.id);

            if (!reminderToModify && reminder.isFromRuta) {
               reminderToModify = { ...reminder };
               reminderToModify.isFromRuta = false;
            }

            // AÑADIMOS ESTA LÍNEA PARA VER SI EL MAPA ESTÁ ACTIVO
            const mapIsVisible = document.getElementById('reminders-location-map-modal') && !document.getElementById('reminders-location-map-modal').classList.contains('hidden');

            const mapShouldReopenWhenUnifiedCloses = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
            const mapContextBeforeUnified = sessionStorage.getItem('mapContext');

            hideUnifiedReminderWindow();

            if (reminderToModify) {
                if (mapShouldReopenWhenUnifiedCloses) {
                     sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                     if (mapContextBeforeUnified) {
                       sessionStorage.setItem('mapContext', mapContextBeforeUnified);
                     }
                }
                // PASAMOS LA INFORMACIÓN A LA FUNCIÓN QUE ABRE EL MODAL
                showReminderModal(reminderToModify, { onTopOfMap: mapIsVisible });
            }
            else {
                showToast("Error: no se pudo encontrar el recordatorio para modificar.", "error");
                updateUnifiedWindowUI(reminder.id);

                if (mapShouldReopenWhenUnifiedCloses &&
                    sessionStorage.getItem('boardinggate_map_should_reopen_after_form') !== 'true' &&
                    !document.getElementById('reminders-location-map-modal')
                   ) {
                    if (mapContextBeforeUnified === 'navigation') openNavigationMap();
                     sessionStorage.removeItem('mapContext');
                }
            }
            sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
        });
    }

    if (postponeButton) {
        postponeButton.addEventListener('click', () => {
            markReminderAsManaged(processedReminderId, true); 
            
            let reminderToPostpone;
            if (reminder.isFromRuta) {
                showToast(`Radar en ruta "${reminder.text.replace(/<[^>]*>/g, '')}" marcado como visto (acción Posponer).`, 'info');
                updateUnifiedWindowUI(reminder.id);
                return; 
            } else {
                let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                reminderToPostpone = remindersFromStorage.find(r => r.id === processedReminderId);
            }
            
            if (reminderToPostpone) {
                showPostponeOptionsModal(reminderToPostpone, 'unified');
            }
            else {
                showToast("Error: no se pudo encontrar el recordatorio para posponer", "error");
                updateUnifiedWindowUI(processedReminderId); 
            }
        });
    }
}



    


    
async function syncDataOnLoad() {
    const autoSyncEnabled = JSON.parse(localStorage.getItem('boardinggate_autoBackupOnLoad') || 'false');
    const { primaryId, isMobile } = parseUserId(localStorage.getItem('userData_userId'));
    const backupPassword = localStorage.getItem('userData_backupPassword');

    // Esta función solo debe ejecutarse para el usuario primario (no móvil).
    if (!autoSyncEnabled || !primaryId || isMobile || !backupPassword) {
        return;
    }
    
    showToast(`Sincronizando datos del coche para ${primaryId}...`, 'info', 4000, false, "auto-sync-toast");

    const result = await callFirebase('getUserData', { userId: primaryId });
    const existingToast = document.getElementById("auto-sync-toast");
    if (existingToast) existingToast.remove();
    
    if (result.status === 'success' && result.data) {
        const cloudTimestamp = new Date(result.data.fechaBackup || 0).getTime();
        const localTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');

        // Si la nube es más nueva, descarga.
        if (cloudTimestamp > localTimestamp + 10000) {
            showToast(`Nuevos datos encontrados en la nube. Aplicando...`, 'info', 5000);
            const backupCacheData = result.data.contenidoCacheCompleto;
            if (backupCacheData) {
                const currentUserIdentity = localStorage.getItem('userData_userId');
                for (const key in backupCacheData) {
                    if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                        localStorage.setItem(key, backupCacheData[key]);
                    }
                }
                if (currentUserIdentity) {
                    localStorage.setItem('userData_userId', currentUserIdentity);
                }
                localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
                showToast('Datos sincronizados desde la nube. La página se recargará.', 'success', 3000);
                setTimeout(() => location.reload(), 2500);
            } else {
                showToast('Los datos en la nube están corruptos.', 'error');
            }
        }
        // Si lo local es más nuevo, haz backup.
        else if (localTimestamp > cloudTimestamp + 10000) {
            showToast('Realizando copia de seguridad automática...', 'info', 3000);
            const cacheData = {};
            managedKeys.forEach(key => {
                const value = localStorage.getItem(key);
                if (value !== null) cacheData[key] = value;
            });
            const requestData = {
                userId: primaryId, usuario: primaryId,
                modelo: localStorage.getItem('userData_teslaModel') || '',
                anio: localStorage.getItem('userData_teslaYear') || '',
                provincia: localStorage.getItem('userData_teslaProvince') || '',
                rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
                datosCache: cacheData,
                backupPassword: backupPassword,
                fechaBackup: new Date().toISOString()
            };
            await callFirebase('saveUser', requestData);
        }
    } else if (result.status === 'not_found') {
        // Si no hay backup en la nube, crea el primero.
        showToast(`Creando primera copia de seguridad para ${primaryId}...`, 'info', 3000);
        const cacheData = {};
        managedKeys.forEach(key => {
            const value = localStorage.getItem(key);
            if (value !== null) cacheData[key] = value;
        });
        const requestData = {
            userId: primaryId, usuario: primaryId,
            modelo: localStorage.getItem('userData_teslaModel') || '',
            anio: localStorage.getItem('userData_teslaYear') || '',
            provincia: localStorage.getItem('userData_teslaProvince') || '',
            rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
            datosCache: cacheData,
            backupPassword: backupPassword,
            fechaBackup: new Date().toISOString()
        };
        await callFirebase('saveUser', requestData);
    }
}

    


    

     function hideUnifiedReminderWindow() {
         const windowElement = document.getElementById('unified-reminder-window');
         if (windowElement && windowElement.classList.contains('visible')) {
             windowElement.classList.remove('visible');
             isUnifiedWindowVisibleByLogic = false;
             const swiperContainer = document.getElementById('reminder-swiper-container');
              Object.values(previewMaps).forEach(map => {
                if (map && typeof map.remove === 'function') {
                    map.remove();
                }
              });
              previewMaps = {};
             if (swiperContainer) {
                 swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay);
                  setTimeout(() => {
                      if (swiperContainer && !windowElement.classList.contains('visible')) {
                          swiperContainer.innerHTML = '';
                      }
                  }, 600);
             }
             const hideAllButton = document.getElementById('hide-all-reminders-button');
             if (hideAllButton) { const newHideAllButton = hideAllButton.cloneNode(true); hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton); }

            const mapShouldReopen = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
            const mapContextToReopen = sessionStorage.getItem('mapContext');
            sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');

            if (mapShouldReopen &&
                !document.querySelector('.reminder-modal') &&
                !document.querySelector('.reminder-table-modal') &&
                !document.getElementById('reminders-location-map-modal')
               ) {
                 if (mapContextToReopen === 'navigation') openNavigationMap();
                  sessionStorage.removeItem('mapContext');
            }
         }
     }


    
    
function postponeAllVisibleReminders() {
         const swiperContainer = document.getElementById('reminder-swiper-container'); if (!swiperContainer) return;
         const visibleSlides = swiperContainer.querySelectorAll('.reminder-slide'); if (visibleSlides.length === 0) return;

         let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
         let updated = false;
         const idsToUpdate = [];

         visibleSlides.forEach(slide => {
             const reminderId = parseInt(slide.dataset.id);
             if (isNaN(reminderId)) return;
             idsToUpdate.push(reminderId);

             const index = reminders.findIndex(r => r.id === reminderId);
             if (index !== -1) {
                 const { newDateISO, newTime } = calculatePostponedDateTime(1);
                 reminders[index].date = newDateISO;
                 reminders[index].time = newTime;
                 reminders[index].managedByUser = false;
                 updated = true;
             }
         });

         if (updated) {
             localStorage.setItem('reminders', JSON.stringify(reminders));
             showToast(`${idsToUpdate.length} recordatorio(s) pospuesto(s) 1 minuto`, 'info');
             idsToUpdate.forEach(id => updateUnifiedWindowUI(id));
             updateReminderCount();
             updateButtonStyles();
         }
         if (idsToUpdate.length > 0 && document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
            hideUnifiedReminderWindow();
         }
     }



    
     function updateReminderIndexDisplay() {
         const swiperContainer = document.getElementById('reminder-swiper-container');
         const currentIndexSpan = document.getElementById('current-reminder-index');
         if (!swiperContainer || !currentIndexSpan) return;

         const totalSlides = swiperContainer.querySelectorAll('.reminder-slide').length;
         if (totalSlides === 0) {
             currentIndexSpan.textContent = '0';
             return;
         }

         const containerWidth = swiperContainer.offsetWidth;
         if (containerWidth <= 0) {
            return;
         }
         const currentScroll = swiperContainer.scrollLeft;
         const currentIndex = Math.round(currentScroll / containerWidth);

         currentNotificationSlideIndex = currentIndex;

         const displayIndex = Math.max(1, Math.min(currentIndex + 1, totalSlides));
         currentIndexSpan.textContent = displayIndex;

          const currentSlideElement = swiperContainer.querySelectorAll('.reminder-slide')[currentIndex];
          if (currentSlideElement && !isNavigationMapActive) {
             const mapId = currentSlideElement.querySelector('.reminder-map-preview')?.id;
             if (mapId) {
                  const reminderId = parseInt(mapId.replace('map-preview-', ''));
                  if (previewMaps[reminderId]) {
                      setTimeout(() => { if(previewMaps[reminderId]) previewMaps[reminderId].invalidateSize(); }, 50);
                  }
             }
          }
     }
 


    
     function updateUnifiedWindowUI(processedReminderId) {
         const windowElement = document.getElementById('unified-reminder-window');
         const swiperContainer = document.getElementById('reminder-swiper-container');
         const slideToRemove = swiperContainer ? swiperContainer.querySelector(`.reminder-slide[data-id="${processedReminderId}"]`) : null;

         
         if (previewMaps[processedReminderId]) {
            if (typeof previewMaps[processedReminderId].remove === 'function') {
                previewMaps[processedReminderId].remove();
            }
            delete previewMaps[processedReminderId];
         }

         if (slideToRemove && slideToRemove.parentNode === swiperContainer) {
             swiperContainer.removeChild(slideToRemove);
         }

         const remainingSlides = swiperContainer ? swiperContainer.querySelectorAll('.reminder-slide') : [];
         const remainingCount = remainingSlides.length;

         if (remainingCount === 0) {
             hideUnifiedReminderWindow();
         }
         else {
             const countHeader = windowElement.querySelector('.reminder-count-header');
             const countSpan = document.getElementById('total-reminder-count');
             const countTextContainer = document.getElementById('reminder-count-text-container');
             const swipeHint = document.getElementById('reminder-swipe-hint');

             countSpan.textContent = remainingCount;
             updateReminderIndexDisplay();

             if (remainingCount > 1) {
                 countTextContainer.style.display = 'inline';
                 swipeHint.style.display = 'block';
                 countHeader.classList.remove('hidden');
             } else {
                 countTextContainer.style.display = 'none';
                 swipeHint.style.display = 'none';
                 countHeader.classList.remove('hidden');
             }

             const maxScrollIndex = remainingCount - 1;
             if (currentNotificationSlideIndex > maxScrollIndex) {
                  currentNotificationSlideIndex = maxScrollIndex;
                  swiperContainer.scrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
                  updateReminderIndexDisplay();
             }
         }

         updateReminderCount();
         updateButtonStyles();
     }


    

    function setupReminderTableListeners(modalTable) {
        modalTable.querySelectorAll('.visto-prox').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#EF4444';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #B91C1C';
            newButton.style.fontWeight = 'bold';

            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true);

                let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderIndex = rems.findIndex(r => r.id === id);
                let needsSave = false;
                const row = newButton.closest('tr');

                if (reminderIndex > -1 && row) {
            
                     const currentReminder = rems[reminderIndex];
                     if (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval')) {
                        const { newDateISO, newTime } = calculatePostponedDateTime(15);
                        rems[reminderIndex].date = newDateISO;
                        rems[reminderIndex].time = newTime;
                        rems[reminderIndex].managedByUser = false;
                        needsSave = true;
                        const dateCell = row.cells[3]; const timeCell = row.cells[2];
                        if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date);
                        if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                        showToast('Recordatorio con ubicación pospuesto 15 min', 'info');
                    } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                         let referenceDateForNext = new Date();
                         try {
                             const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                             const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                             const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                             if (!isNaN(reminderDateTime.getTime())) {
                                 referenceDateForNext = new Date(reminderDateTime.getTime() + 60000);
                             }
                         } catch(er) { }

                        const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                        if (nextOcc) {
                            rems[reminderIndex].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                            rems[reminderIndex].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                            rems[reminderIndex].managedByUser = false;
                            needsSave = true;
                            const dateCell = row.cells[3]; const timeCell = row.cells[2];
                            if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date);
                            if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                            showToast('Actualizado al próximo periodo', 'info');
                        } else {
                            rems.splice(reminderIndex, 1); needsSave = true;
                            row.remove(); showToast('Error calculando siguiente ciclo. Eliminado.', 'error');
                        }
                    } else {
                        rems.splice(reminderIndex, 1); needsSave = true;
                        row.remove(); showToast('Recordatorio borrado', 'info');
                    }
                    if (needsSave) localStorage.setItem('reminders', JSON.stringify(rems)); 

                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios.</td></tr>`;
                    }
                } else {
                    showToast('Error: Recordatorio no encontrado para actualizar/borrar.', 'error');
                    if(row) row.remove();
                }
                updateReminderCount(); updateButtonStyles(); checkReminders();
            });
        });

        modalTable.querySelectorAll('.postpone').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#F59E0B';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #B45309';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true);
                const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderToPostpone = reminders.find(r => r.id === id);
                if (reminderToPostpone) {
                    if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                    modalTable.remove();
                    showPostponeOptionsModal(reminderToPostpone, 'table');
                } else {
                    showToast('Error: Recordatorio no encontrado para posponer.', 'error');
                    markReminderAsManaged(id, false);
                }
            });
        });

        modalTable.querySelectorAll('.cancel-cyclic-table').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#8B0000';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #580000';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                if (confirm('¿Estás seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE?')) {
                    markReminderAsManaged(id, true);
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const initialLength = rems.length;
                    rems = rems.filter(r => r.id !== id);
                    if (rems.length < initialLength) {
                        localStorage.setItem('reminders', JSON.stringify(rems)); 
                        showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                    } else {
                        showToast('Error: No se encontró el ciclo para anular', 'warning');
                    }
                    const row = newButton.closest('tr');
                    if (row) row.remove();
                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios.</td></tr>`;
                    }
                    updateReminderCount(); updateButtonStyles(); checkReminders();
                }
            });
        });

        const tableBody = modalTable.querySelector('#reminder-table-body');
        if (tableBody) {
            const newTableBody = tableBody.cloneNode(false);
            while(tableBody.firstChild) newTableBody.appendChild(tableBody.firstChild);
            tableBody.parentNode.replaceChild(newTableBody, tableBody);

            newTableBody.addEventListener('click', (e) => {
                if (e.target.closest('td:first-child button')) return;

               const row = e.target.closest('tr[data-id]');
                if (row?.dataset.id) {
                    const id = parseInt(row.dataset.id); if (isNaN(id)) return;
                    markReminderAsManaged(id, true);
                    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const reminderToModify = reminders.find(r => r.id === id);
                    if (reminderToModify) {
                        const mapWasOpenBeforeTable = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                        const mapContextBeforeTable = sessionStorage.getItem('mapContext');


                        if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                        modalTable.remove();

                        if (mapWasOpenBeforeTable) {
                            sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                            if (mapContextBeforeTable) {
                                sessionStorage.setItem('mapContext', mapContextBeforeTable);
                            }
                        }
                        sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                        showReminderModal(reminderToModify);
                    } else {
                        showToast('Error: Recordatorio no encontrado para modificar', 'error');
                        markReminderAsManaged(id, false);
                    }
                }
            });
        }
    }






function showAllReminders(options = {}) {
         const mapWasOpenBeforeThisTable = isNavigationMapActive;
         if (mapWasOpenBeforeThisTable) {
             sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
             sessionStorage.setItem('mapContext', 'navigation');
         } else {
             sessionStorage.removeItem('boardinggate_map_was_open_before_table');
             sessionStorage.removeItem('mapContext');
         }
         closeOtherModals();
         let allReminders = []; try { allReminders = JSON.parse(localStorage.getItem('reminders') || '[]').map(r => ({ ...r })); } catch(e) { showToast("Error al cargar lista de recordatorios.", "error"); return; }
         const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false; let remindersToDisplay = allReminders;
         if (!showExcluded) { remindersToDisplay = allReminders.filter(r => !r.excludeFromList); }
         remindersToDisplay.sort((a, b) => {
             const nowForSort = new Date(); const nextA = calculateNextOccurrence(a, nowForSort); const nextB = calculateNextOccurrence(b, nowForSort);
             if (nextA && nextB) { const timeDiff = nextA.getTime() - nextB.getTime(); if (timeDiff !== 0) return timeDiff; } else if (nextA) { return -1; } else if (nextB) { return 1; }
             const typeOrder = { 'simple': 1, 'hourly': 2, 'daily': 3, 'weekly': 4, 'interval': 5 }; const typeDiff = (typeOrder[a.type] ?? 99) - (typeOrder[b.type] ?? 99); if (typeDiff !== 0) return typeDiff;
             const createdAtA = a.createdAt ? new Date(a.createdAt).getTime() : 0; const createdAtB = b.createdAt ? new Date(b.createdAt).getTime() : 0; return createdAtA - createdAtB;
         });
         const existingModal = document.querySelector('.reminder-table-modal');
         if (existingModal) { if (existingModal.autoCloseInterval) clearInterval(existingModal.autoCloseInterval); if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal); }
         const modalTable = document.createElement('div');
         modalTable.className = 'reminder-table-modal';
         modalTable.setAttribute('aria-label', 'Tabla recordatorios');

         modalTable.innerHTML = `
            <div class="modal-top-buttons" style="justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <div style="display: flex; align-items: center;">
                    <input type="checkbox" id="show-excluded-reminders" ${showExcluded ? 'checked' : ''} style="transform: scale(1.3);">
                    <label for="show-excluded-reminders" style="margin-left: 0.5rem; font-size: 1.1rem;">MOSTRAR RADARES u OTROS</label>
                </div>
                <h2 style="text-align:center; font-size:1.8rem;color:#333; flex-grow:1; font-weight:bold;">Recordatorios</h2>
                <div style="display: flex; align-items: center;">
                    <button type="button" id="view-all-locations-map" style="white-space: nowrap;">VER UBICACIONES</button>
                    <button type="button" id="close-reminders-top" style="margin-left:10px;">SALIR <span class="button-countdown"></span></button>
                </div>
            </div>
            <table>
                <thead>
                    <tr>
                        <th style="width:12%;">Acciones</th> <th>Texto</th> <th style="width:8%;">Hora</th>
                        <th style="width:10%;">Fecha Prox.</th> <th style="width:15%;">Días Rep.</th>
                        <th style="width:8%;">Cada x días</th> <th style="width:8%;">Geoloc.</th>
                        <th style="width:10%;">Creado</th>
                    </tr>
                </thead>
                <tbody id="reminder-table-body">
                    ${remindersToDisplay.length === 0 ? `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios ${showExcluded ? ' (incluyendo excluidos)' : ''}.</td></tr>` : remindersToDisplay.map(r => { const isCyclic = r.type === 'weekly' || r.type === 'interval'; const rowBackgroundColor = isCyclic ? (r.excludeFromList ? '#C0D8C0' : '#D9E5DB') : (r.excludeFromList ? '#D8BFBF' : '#EAD9D9'); const nextOccurrenceDate = calculateNextOccurrence(r, new Date()); const formattedNextDate = nextOccurrenceDate ? formatDateToDDMMMYY(nextOccurrenceDate.toISOString().split('T')[0]) : formatDateToDDMMMYY(r.date); const timeDisplay = r.time ? r.time : '-'; const geoIndicator = r.isLocationEnabled ? '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#008000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>' : '-'; return `<tr data-id="${r.id}" style="background-color: ${rowBackgroundColor};"> <td> <button class="visto-prox" data-id="${r.id}" title="${isCyclic ? 'Marcar Visto y Avanzar al Próximo Ciclo' : 'Marcar Visto y Borrar'}">Visto/Prox</button> <button class="postpone" data-id="${r.id}" title="Posponer">Posponer</button> ${isCyclic ? `<button class="cancel-cyclic-table" data-id="${r.id}" title="Anular Ciclo Permanente">Anular Ciclo</button>` : ''} </td> <td class="text-column" title="Modificar">${r.text}</td> <td class="time-column">${timeDisplay}</td> <td class="date-column">${formattedNextDate}</td> <td>${r.type === 'weekly' && r.repeatDays?.length > 0 ? r.repeatDays.map(d => ['Dom','Lun','Mar','Mié','Jue','Vie','Sáb'][d]).join(', ') : '-'}</td> <td>${r.type === 'interval' ? r.intervalDays || '-' : '-'}</td> <td>${geoIndicator}</td> <td class="date-column">${r.createdAt ? formatDateToDDMMMYY(r.createdAt.split('T')[0]) : '-'}</td> </tr>`; }).join('')}
                </tbody>
            </table>
             <div class="bottom-button-container" style="margin-top: 1rem; display:flex; justify-content:flex-end;">
                <button type="button" id="close-reminders-bottom">SALIR <span class="button-countdown"></span></button>
            </div>
        `;
        
         const parent = options.parentContainer || document.body;
         parent.appendChild(modalTable);

         const showExcludedCheckbox = modalTable.querySelector('#show-excluded-reminders');
         if (showExcludedCheckbox) { 
             showExcludedCheckbox.addEventListener('change', () => { 
                 localStorage.setItem(SHOW_EXCLUDED_REMINDERS_KEY, JSON.stringify(showExcludedCheckbox.checked)); 
                 markCacheAsDirty(); // <--- LLAMADA AÑADIDA
                 if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval); 
                 modalTable.remove(); 
                 showAllReminders(); 
            }); 
        }
         const viewLocationsMapButton = modalTable.querySelector('#view-all-locations-map');
         if (viewLocationsMapButton) {
            viewLocationsMapButton.addEventListener('click', () => {
                if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                if (modalTable.parentNode) modalTable.remove();
                setTimeout(() => {
                    openLocationsPreviewMap();
                }, 50);
            });
        }
         let count = 60; const countdownSpans = modalTable.querySelectorAll('.button-countdown'); countdownSpans.forEach(span => span.textContent = `(${count})`);
         const closeClean = () => { clearInterval(modalTable.autoCloseInterval); modalTable.autoCloseInterval = null; if (modalTable.parentNode) modalTable.parentNode.removeChild(modalTable);
             const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true'; sessionStorage.removeItem('boardinggate_map_was_open_before_table');
             const mapContext = sessionStorage.getItem('mapContext'); sessionStorage.removeItem('mapContext');
             if (fromReminderModal) { fromReminderModal = false; if (mapShouldReopen) { sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true'); sessionStorage.setItem('mapContext', mapContext); } showReminderModal(); }
             else if (mapShouldReopen) { if (mapContext === 'navigation') openNavigationMap(); }
         };
         modalTable.autoCloseInterval = setInterval(() => { count--; countdownSpans.forEach(span => span.textContent = `(${count})`); if (count <= 0) { closeClean(); } }, 1000);
         const resetTimer = () => { if (!modalTable.autoCloseInterval) return; clearInterval(modalTable.autoCloseInterval); count = 60; countdownSpans.forEach(span => span.textContent = `(${count})`); modalTable.autoCloseInterval = setInterval(() => { count--; countdownSpans.forEach(span => span.textContent = `(${count})`); if (count <= 0) { closeClean(); } }, 1000); };
         modalTable.addEventListener('click', resetTimer); modalTable.addEventListener('touchstart', resetTimer, { passive: true }); modalTable.addEventListener('input', resetTimer);
         modalTable.querySelector('#close-reminders-top').addEventListener('click', closeClean);
         modalTable.querySelector('#close-reminders-bottom').addEventListener('click', closeClean);
         setupReminderTableListeners(modalTable);
     }



    

  
    
     function updateReminderCount() {
         let reminders = []; try { reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); } catch (e) { reminders = []; }
         const showExcludedInTable = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false; let remindersForCount = reminders;
         if (!showExcludedInTable) { remindersForCount = reminders.filter(r => !r.excludeFromList); }
         const totalCount = remindersForCount.length; const nonCyclicReminders = remindersForCount.filter(r => r.type !== 'weekly' && r.type !== 'interval'); const nonCyclicCount = nonCyclicReminders.length;
         const countElGlobe = document.getElementById('reminder-count-globe'); if (countElGlobe) { countElGlobe.textContent = nonCyclicCount > 0 ? nonCyclicCount : ''; countElGlobe.style.display = nonCyclicCount > 0 ? 'flex' : 'none'; }

         const reminderButtonElem = document.getElementById('reminder-button'); if (reminderButtonElem) { let countSpanSide = reminderButtonElem.querySelector('.reminder-count'); if (totalCount > 0) { if (!countSpanSide) { countSpanSide = document.createElement('span'); countSpanSide.className = 'reminder-count'; reminderButtonElem.appendChild(countSpanSide); } countSpanSide.textContent = totalCount; } else { if (countSpanSide) { countSpanSide.remove(); } } } }
    function calculateNextOccurrence(reminder, referenceDate) {
          if (!reminder || !reminder.type || !reminder.time || !reminder.date) { return null; } try {
              let [year, month, day] = reminder.date.split('-').map(Number); let [hour, minute] = reminder.time.split(':').map(Number);
              let baseDate = new Date(Date.UTC(year, month - 1, day, hour, minute)); if (isNaN(baseDate.getTime())) { return null; }
              const refDateUTC = new Date(referenceDate.getTime()); if (baseDate > refDateUTC) return baseDate;
              if (reminder.type === 'simple') { return null; }
              if (reminder.type === 'daily' || reminder.type === 'hourly') { let next = new Date(baseDate); while (next <= refDateUTC) { next.setUTCDate(next.getUTCDate() + 1); } return next; }
              if (reminder.type === 'weekly' && reminder.repeatDays && reminder.repeatDays.length > 0) {
                  let next = new Date(refDateUTC); next.setUTCHours(hour, minute, 0, 0);
                  if (next <= refDateUTC || !reminder.repeatDays.includes(next.getUTCDay())) { next.setUTCDate(next.getUTCDate() + 1); }
                  for (let i = 0; i < 7; i++) { if (reminder.repeatDays.includes(next.getUTCDay())) { return next; } next.setUTCDate(next.getUTCDate() + 1); } return null;
              }
              if (reminder.type === 'interval' && reminder.intervalDays && reminder.intervalDays > 0) { let next = new Date(baseDate); while (next <= refDateUTC) { next.setUTCDate(next.getUTCDate() + reminder.intervalDays); } return next; }
              return null; } catch (e) { return null; }
     }
     function calculatePostponedDateTime(mins) {
          const now = new Date(); const postponedDate = new Date(now.getTime() + mins * 60000);
          const newDateISO = `${postponedDate.getFullYear()}-${(postponedDate.getMonth() + 1).toString().padStart(2, '0')}-${postponedDate.getDate().toString().padStart(2, '0')}`;
          const newTime = `${postponedDate.getHours().toString().padStart(2, '0')}:${postponedDate.getMinutes().toString().padStart(2, '0')}`; return { newDateISO, newTime };
     }
     function showPostponeOptionsModal(reminder, source = 'unified') {
         const existingModal = document.getElementById('postpone-options-modal'); if (existingModal) { if (existingModal.autoPostponeInterval) clearInterval(existingModal.autoPostponeInterval); if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal); }
         const modal = document.createElement('div'); modal.id = 'postpone-options-modal'; modal.className = 'postpone-options';
         modal.style.cssText = `position:fixed; top:10px; left:50%; transform:translateX(-50%); width:90%; max-width:480px; max-height:calc(100vh - 20px); overflow-y:auto; background-color:#F5E1A9; padding:1.5rem; border-radius:1rem; box-shadow:0 10px 25px rgba(0,0,0,0.2); z-index:7500; `;
         modal.setAttribute('aria-label', 'Posponer recordatorio');
         let countdown = 10; const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval'; const defaultMinutes = 15;
         let buttonHtml = ` <button data-minutes="15" class="postpone-option">15 Minutos</button> <button data-minutes="60" class="postpone-option">1 Hora</button> <button data-minutes="180" class="postpone-option">3 Horas</button> `;

      if (!isCyclic) { buttonHtml += ` <button data-minutes="1440" class="postpone-option">1 Día</button> <button data-minutes="4320" class="postpone-option">3 Días</button> `; }
         modal.innerHTML = `
            <style>
                .postpone-options .reminder-text { color:#333; font-size:1.2rem; margin-bottom:.5rem; word-wrap:break-word; }
                .postpone-options .reminder-details { color:#555; font-size:1rem; margin-bottom:1.5rem; }
                .postpone-options .button-group { display:flex; flex-direction:column; gap:1rem; align-items:stretch; }
                .postpone-options button.postpone-option { font-size:1.3rem; font-weight:bold; padding:.8rem 1rem; background-color:#F59E0B; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                .postpone-options button.postpone-option:hover { background-color:#D97706; }
                #postpone-countdown { text-align:center; margin-top:1.8rem; font-size:1.1rem; font-weight:500; color:#444; }
                #postpone-timer-value { font-weight:bold; font-size:1.2rem; }
                #cancel-postpone { margin-top:1.2rem; width:100%; padding:.7rem 1rem; font-size:1.1rem; background-color:#EF4444; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                #cancel-postpone:hover { background-color:#DC2626; }
            </style>
            <div class="modal-top-buttons" style="justify-content: flex-end; margin-bottom: 1rem;">
                 <button id="cancel-postpone" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
            </div>
            <p class="reminder-text">Posponer: ${reminder.text.replace(/<[^>]*>/g, '')}</p>
            <p class="reminder-details">Selecciona tiempo:</p>
            <div class="button-group">
                ${buttonHtml}
            </div>
            <p id="postpone-countdown">Autom&aacute;tico en <span id="postpone-timer-value">${countdown}</span>s (${defaultMinutes} min)</p>
         `;
         document.body.appendChild(modal);

         const countdownDisplay = modal.querySelector('#postpone-timer-value');
         const handlePostpone = (minutes) => {
             if (modal.autoPostponeInterval) clearInterval(modal.autoPostponeInterval); modal.autoPostponeInterval = null;
             updateUnifiedWindowUI(reminder.id);
             let reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); const index = reminders.findIndex(r => r.id === reminder.id);
             if (index === -1) { showToast("Error: Recordatorio no encontrado", "error"); checkReminders(); if (modal.parentNode) document.body.removeChild(modal); return; }
             const { newDateISO, newTime } = calculatePostponedDateTime(minutes); reminders[index].date = newDateISO; reminders[index].time = newTime; reminders[index].managedByUser = false;
             if (!isCyclic) { reminders[index].type = 'daily'; reminders[index].repeatDays = []; reminders[index].intervalDays = null; }
             localStorage.setItem('reminders', JSON.stringify(reminders)); updateReminderCount(); updateButtonStyles(); 
             const durationText = minutes >= 1440 ? `${minutes / 1440} día(s)` : (minutes >= 60 ? `${minutes / 60} hora(s)` : `${minutes} minutos`);
             showToast(`Pospuesto ${durationText}`, 'info');
             if (modal.parentNode) document.body.removeChild(modal);
             if (source === 'table') { setTimeout(showAllReminders, 100); }
             else { const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                 const mapContextToReopen = sessionStorage.getItem('mapContext');
                 if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) { sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); if (!document.getElementById('reminders-location-map-modal')) { if (mapContextToReopen === 'navigation') openNavigationMap(); sessionStorage.removeItem('mapContext');} } } };
         modal.autoPostponeInterval = setInterval(() => { countdown--; if (countdownDisplay) countdownDisplay.textContent = countdown; if (countdown <= 0) { handlePostpone(defaultMinutes); } }, 1000);
         modal.querySelectorAll('.postpone-option').forEach(button => { button.addEventListener('click', () => { const minutes = parseInt(button.dataset.minutes); if (!isNaN(minutes)) { handlePostpone(minutes); } }); });
         modal.querySelector('#cancel-postpone').addEventListener('click', () => {
             clearInterval(modal.autoPostponeInterval); modal.autoPostponeInterval = null; markReminderAsManaged(reminder.id, false); if (modal.parentNode) document.body.removeChild(modal);
             if (source === 'table') { setTimeout(showAllReminders, 100); }
             else { const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                  const mapContextToReopen = sessionStorage.getItem('mapContext');
                 if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) { sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); if (!document.getElementById('reminders-location-map-modal')) { if (mapContextToReopen === 'navigation') openNavigationMap(); sessionStorage.removeItem('mapContext');} } } showToast('Posposición cancelada', 'info'); });
     }
    function showYellowBorder() {
        const borderDiv = document.createElement('div'); borderDiv.style.position = 'fixed'; borderDiv.style.top = '0'; borderDiv.style.left = '0'; borderDiv.style.width = '100vw'; borderDiv.style.height = '100vh'; borderDiv.style.boxSizing = 'border-box'; borderDiv.style.border = '25px solid #FFFF00'; borderDiv.style.zIndex = '99999'; borderDiv.style.pointerEvents = 'none'; borderDiv.style.opacity = '1'; borderDiv.style.transition = 'opacity 0.5s ease-out'; document.body.appendChild(borderDiv);
        setTimeout(() => { borderDiv.style.opacity = '0'; setTimeout(() => { if (borderDiv.parentNode) { borderDiv.parentNode.removeChild(borderDiv); } }, 500); }, 3500);
    }

function displayUnifiedReminderWindow(overdueReminders) {
    const windowElement = document.getElementById('unified-reminder-window');
    const swiperContainer = document.getElementById('reminder-swiper-container');
    const countHeader = windowElement.querySelector('.reminder-count-header');
    const countSpan = document.getElementById('total-reminder-count');
    const currentIndexSpan = document.getElementById('current-reminder-index');
    const countTextContainer = document.getElementById('reminder-count-text-container');
    const swipeHint = document.getElementById('reminder-swipe-hint');
    const hideAllButton = document.getElementById('hide-all-reminders-button');

     Object.values(previewMaps).forEach(map => {
       if (map && typeof map.remove === 'function') {
           map.remove();
       }
     });
     previewMaps = {};

    if (!windowElement || !swiperContainer || !countHeader || !countSpan || !currentIndexSpan || !countTextContainer || !swipeHint || !hideAllButton) {
        return;
    }
    swiperContainer.innerHTML = '';
    overdueReminders.sort((a, b) => { try { const dateA = new Date(`${a.date}T${a.time}:00Z`); const dateB = new Date(`${b.date}T${b.time}:00Z`); return dateA - dateB; } catch (e) { return 0; } });

    if (!isUnifiedWindowVisibleByLogic) {
        currentNotificationSlideIndex = 0;
    }

    overdueReminders.forEach((reminder, index) => {
        const slide = document.createElement('div');
        slide.className = 'reminder-slide';
        slide.dataset.id = reminder.id;
        slide.setAttribute('role', 'group');
        slide.setAttribute('aria-label', `Recordatorio: ${reminder.text.replace(/<[^>]*>/g, '')}`);

        let detailsHtml = '';
        if (reminder.time) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Hora: ${formatTimeWithPeriod(reminder.time)}</p>`;
        if (reminder.date) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Fecha: ${formatDateDetailed(reminder.date)}</p>`;
        if (reminder.type === 'weekly' && reminder.repeatDays?.length > 0) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Repite: ${reminder.repeatDays.map(d => ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'][d]).join(', ')}</p>`;
        if (reminder.type === 'interval' && reminder.intervalDays) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Cada: ${reminder.intervalDays} días</p>`;
        if (reminder.isLocationEnabled && reminder.locationCoordinates) {
            detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Ubicación: Activada (Radio ${reminder.radiusMeters || DEFAULT_LOCATION_RADIUS}m)</p>`;
        }
        
        let buttonsHtml = '';
        if (reminder.isFromRuta === true) {
            // Modal especial para radares de ruta: solo el botón "Visto"
            buttonsHtml = `
                <div class="button-group">
                    <button class="route-radar-seen" style="background-color: #2563EB; color: white; font-weight: bold; height: 70px; font-size: 1.2rem;">Visto (Posponer 5 min)</button>
                </div>`;
        } else {
            // Comportamiento normal para otros recordatorios
            const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval';
            const showAdjustButton = isCyclic && reminder.time !== '00:01';
            const adjustButtonHtml = showAdjustButton ? `<button class="adjust-time-0001">Ajustar Hora 00:01 y Visto</button>` : '';
            const cyclicCancelButtonHtml = isCyclic ? `<button class="cancel-cyclic">Anular Ciclo</button>` : '';
            buttonsHtml = `
                <div class="button-group">
                    <button class="cancel">Visto / Próximo</button>
                    <button class="postpone">Posponer</button>
                    <button class="modify">Modificar</button>
                    ${adjustButtonHtml}
                    ${cyclicCancelButtonHtml}
                </div>`;
        }
        
        const mapPreviewHtml = (reminder.isLocationEnabled && reminder.locationCoordinates && !isNavigationMapActive) ? `
            <div class="reminder-map-preview-container">
                <div id="map-preview-${reminder.id}" class="reminder-map-preview"></div>
            </div>
        ` : '';

        slide.innerHTML = `
            <div class="reminder-slide-content">
                <div class="reminder-content-scrollable">
                    <p class="reminder-text">${reminder.text}</p>
                    ${detailsHtml}
                </div>
                ${buttonsHtml} 
            </div>
            ${mapPreviewHtml}
        `;

        addSlideButtonListeners(slide, reminder);
        swiperContainer.appendChild(slide);

        if (reminder.isLocationEnabled && reminder.locationCoordinates && !isNavigationMapActive) {
             const mapPreviewElement = slide.querySelector(`#map-preview-${reminder.id}`);
             if (mapPreviewElement) {
                setTimeout(() => {
                    try {
                        if (!document.getElementById(mapPreviewElement.id)) return;

                        if (previewMaps[reminder.id] && typeof previewMaps[reminder.id].remove === 'function') {
                           previewMaps[reminder.id].remove();
                        }
                        const isRadarType = reminder.text.toUpperCase().includes("RADAR:") || reminder.excludeFromList;
                        
                        const circleColor = isRadarType ? 'rgba(255, 165, 0, 0.2)' : 'blue';
                        const circleFillColor = isRadarType ? 'rgba(255, 165, 0, 0.2)' : '#ADD8E6';
                        const circleFillOpacity = isRadarType ? 0.2 : 0.05;
                        const circleWeight = 1;


                        const map = L.map(mapPreviewElement, {
                            dragging: false, touchZoom: false, scrollWheelZoom: false, doubleClickZoom: false,
                            boxZoom: false, keyboard: false, tap: false, zoomControl: false
                        }).setView([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude], 14);

                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        }).addTo(map);

                        L.marker([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude]).addTo(map);
                        L.circle([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude], {
                            color: circleColor, fillColor: circleFillColor, weight: circleWeight, fillOpacity: circleFillOpacity, radius: reminder.radiusMeters || DEFAULT_LOCATION_RADIUS
                        }).addTo(map);

                        map.invalidateSize();
                        previewMaps[reminder.id] = map;
                    } catch (mapError) {
                         if (mapPreviewElement) mapPreviewElement.innerHTML = `<p style="font-size:0.8rem; color: red; text-align: center; padding: 5px;">Error al cargar mapa</p>`;
                    }
                }, 100);
             }
        }
    });

    const count = overdueReminders.length;
    countSpan.textContent = count;

    if (count > 0) {
         if (currentNotificationSlideIndex >= count) {
             currentNotificationSlideIndex = 0;
         }
         swiperContainer.scrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
         updateReminderIndexDisplay();

         countHeader.classList.remove('hidden');
         if (count > 1) {
            countTextContainer.style.display = 'inline';
            swipeHint.style.display = 'block';
            document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = 'calc(85vh - 60px)');
         } else {
            countTextContainer.style.display = 'none';
            swipeHint.style.display = 'none';
            document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = '85vh');
         }
          hideAllButton.classList.remove('hidden');
          const newHideAllButton = hideAllButton.cloneNode(true);
          hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton);
          newHideAllButton.addEventListener('click', postponeAllVisibleReminders);
    } else {
        countHeader.classList.add('hidden');
        hideAllButton.classList.add('hidden');
        currentNotificationSlideIndex = 0;
    }
    windowElement.classList.add('visible');
    isUnifiedWindowVisibleByLogic = true;

    swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay);
    swiperContainer.addEventListener('scroll', updateReminderIndexDisplay);
}

    
    function getSavedLocations() { try { const locations = localStorage.getItem(SAVED_LOCATIONS_KEY); return locations ? JSON.parse(locations) : Array(MAX_SAVED_LOCATIONS).fill(null); } catch (e) { return Array(MAX_SAVED_LOCATIONS).fill(null); } }
    function saveLocationsToCache(locationsArray) { try { localStorage.setItem(SAVED_LOCATIONS_KEY, JSON.stringify(locationsArray));} catch (e) { showToast("Error al guardar ubicaciones.", "error"); } }
  
   
    
    
    
function showSavedLocationsModal(callbackOnClose, callbackOnSelectLocation, options = {}) {
    const existingModal = document.querySelector('.saved-locations-modal');
    if (existingModal) { if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; } clearModalAutoCloseTimer(existingModal, existingModal.querySelector('#close-saved-locations-modal'), 'saved-locations-modal'); existingModal.remove(); }
    tempSavedLocations = getSavedLocations().map(loc => loc ? {...loc} : null);
    const modal = document.createElement('div'); modal.className = 'saved-locations-modal';
    modal.innerHTML = `
            <h2>Gestionar Ubicaciones Guardadas (Máx. ${MAX_SAVED_LOCATIONS})</h2>
            <div class="modal-top-buttons">
                <button id="save-all-user-locations">Guardar Cambios</button>
                <button id="close-saved-locations-modal">Cerrar</button>
            </div>
            <div id="saved-locations-list"> </div>
            <div id="location-picker-map-container">
                <button id="picker-ok-map-button" title="Confirmar esta posición">OK</button>
                <button id="picker-locate-me-button" title="Ir a mi posición actual">Mi Ubic.</button>
            </div>
        `;
    const parent = options.parentContainer || document.body;
    parent.appendChild(modal);

    const listElement = modal.querySelector('#saved-locations-list'); const mapPickerContainer = modal.querySelector('#location-picker-map-container');
    const okMapBtn = modal.querySelector('#picker-ok-map-button'); const locateMeMapBtn = modal.querySelector('#picker-locate-me-button');
    const saveAllButton = modal.querySelector('#save-all-user-locations'); const closeButton = modal.querySelector('#close-saved-locations-modal');
    function loadAndDisplaySlots() {
        listElement.innerHTML = '';
        for (let i = 0; i < MAX_SAVED_LOCATIONS; i++) {
            const location = tempSavedLocations[i]; const slotDiv = document.createElement('div'); slotDiv.className = 'location-slot';
            slotDiv.innerHTML = ` <span style="width: 25px; text-align: right; font-weight: bold;">${i + 1}.</span> <input type="text" placeholder="Nombre Ubicación" value="${location?.name || ''}" data-index="${i}"> <button class="map-button" data-index="${i}" title="Fijar en Mapa">📍 Mapa</button> <button class="select-location-button" data-index="${i}" title="Seleccionar esta ubicación para el recordatorio actual">Seleccionar</button> <span class="coords-display">${location?.lat && location?.lng ? `${parseFloat(location.lat).toFixed(4)}, ${parseFloat(location.lng).toFixed(4)}` : 'No fijada'}</span> `;
            listElement.appendChild(slotDiv);
            slotDiv.querySelector('input[type="text"]').addEventListener('input', (e) => { if (!tempSavedLocations[i]) tempSavedLocations[i] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS }; tempSavedLocations[i].name = e.target.value; });
            slotDiv.querySelector('.map-button').addEventListener('click', () => {
                currentEditingLocationSlotIndex = i; mapPickerContainer.classList.add('expanded'); initializeLocationPickerMap('location-picker-map-container', i);
                const currentSlotLocation = tempSavedLocations[i]; const initialCoords = currentSlotLocation?.lat && currentSlotLocation?.lng ? { latitude: currentSlotLocation.lat, longitude: currentSlotLocation.lng } : null;
                if (locationPickerMap && initialCoords) { locationPickerMap.setView([initialCoords.latitude, initialCoords.longitude], 15); if (locationPickerMarker) locationPickerMarker.setLatLng([initialCoords.latitude, initialCoords.longitude]); }
                else if (locationPickerMap) { getCurrentLocation( (coords) => { locationPickerMap.setView([coords.latitude, coords.longitude], 15); if(locationPickerMarker) locationPickerMarker.setLatLng([coords.latitude, coords.longitude]); else { locationPickerMarker = L.marker([coords.latitude, coords.longitude], {draggable: true}).addTo(locationPickerMap); locationPickerMarker.on('dragend', (event) => { const pos = event.target.getLatLng(); if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS }; tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat; tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng; }); } }, () => { } ); } });
            const selectButton = slotDiv.querySelector('.select-location-button');
            selectButton.addEventListener('click', () => { const selectedIndex = parseInt(selectButton.dataset.index); const selectedLocData = tempSavedLocations[selectedIndex];
                if (selectedLocData && selectedLocData.lat && selectedLocData.lng) {
                    if (callbackOnSelectLocation && typeof callbackOnSelectLocation === 'function') { callbackOnSelectLocation({ name: selectedLocData.name, lat: selectedLocData.lat, lng: selectedLocData.lng, radius: selectedLocData.radius || DEFAULT_LOCATION_RADIUS }); }
                    if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; } clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal'); modal.remove();
                } else { showToast("Ubicación no fijada. Fíjala en el mapa primero", "warning"); } }); } }
    loadAndDisplaySlots();
    okMapBtn.addEventListener('click', () => { if (locationPickerMarker && currentEditingLocationSlotIndex !== -1) { const pos = locationPickerMarker.getLatLng(); if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS }; tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat; tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng;
            const slotInput = listElement.querySelector(`.location-slot input[dataindex="${currentEditingLocationSlotIndex}"]`); if (slotInput) { const coordsDisplay = slotInput.closest('.location-slot').querySelector('.coords-display'); if (coordsDisplay) { coordsDisplay.textContent = `${pos.lat.toFixed(4)}, ${pos.lng.toFixed(4)}`; } } }
        mapPickerContainer.classList.remove('expanded'); if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; } currentEditingLocationSlotIndex = -1; });
    locateMeMapBtn.addEventListener('click', () => { if (locationPickerMap) { locateMeMapBtn.disabled = true; locateMeMapBtn.textContent = 'Buscando...';
            getCurrentLocation( (coords) => { locationPickerMap.setView([coords.latitude, coords.longitude], 16); if (locationPickerMarker) locationPickerMarker.setLatLng([coords.latitude, coords.longitude]); if (currentEditingLocationSlotIndex !== -1) { if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS }; tempSavedLocations[currentEditingLocationSlotIndex].lat = coords.latitude; tempSavedLocations[currentEditingLocationSlotIndex].lng = coords.longitude; } locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.'; }, (errorMsg) => { showToast(`Error localización: ${errorMsg}`, 'error'); locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.'; } ); } });
    saveAllButton.addEventListener('click', () => {
        const locationsToSave = tempSavedLocations.map(loc => { if (loc && (!loc.name || loc.name.trim() === '') && (loc.lat === null || loc.lng === null)) { return null; } if (loc && (loc.lat !== null && loc.lng !== null) && typeof loc.radius !== 'number') { loc.radius = DEFAULT_LOCATION_RADIUS; } return loc; });
        saveLocationsToCache(locationsToSave);

        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        savedRoutes = savedRoutes.filter(r => !r.name.startsWith("UBICACIÓN: "));

        locationsToSave.forEach(loc => {
            if (loc && loc.name && loc.lat && loc.lng) {
                const routeName = `UBICACIÓN: ${loc.name.toUpperCase()}`;
                const routeWaypoint = {
                    id: Date.now() + Math.random(),
                    lat: loc.lat,
                    lng: loc.lng,
                    type: 'F',
                    label: 'F',
                    address: loc.name,
                    visited: false,
                    isCriticalForRecalc: true
                };
                const existingRouteIndex = savedRoutes.findIndex(r => r.name === routeName);
                const routeToSave = {
                    name: routeName,
                    waypoints: [routeWaypoint],
                    createdAt: new Date().toISOString()
                };
                if (existingRouteIndex !== -1) {
                    savedRoutes[existingRouteIndex] = routeToSave;
                } else {
                    savedRoutes.push(routeToSave);
                }
            }
        });
        if (savedRoutes.length > MAX_SAVED_ROUTES) {
             savedRoutes.sort((a,b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
             savedRoutes = savedRoutes.slice(0, MAX_SAVED_ROUTES);
        }
        localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes)); 

        showToast("Ubicaciones guardadas y sincronizadas como s.", "success");
        if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose();
        if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; } clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal'); modal.remove(); });
    const closeHandler = () => { clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal'); if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; } if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose(); modal.remove(); };
    closeButton.addEventListener('click', closeHandler); addModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
}







function toggleEnlargedGraph() {
    const graphCard = document.getElementById('navigation-graph-card');
    const enlargeButton = document.getElementById('enlarge-graph-button');
    const compassControlContainer = document.querySelector('.leaflet-control-orientation-altitude');
    const mapModal = document.getElementById('reminders-location-map-modal');

    if (!graphCard || !enlargeButton || !compassControlContainer || !mapModal) return;

    const isCurrentlyEnlarged = graphCard.classList.contains('enlarged');

    if (!isCurrentlyEnlarged) {
        // --- AMPLIAR GRÁFICA ---
        graphCard.classList.add('enlarged');

        const compassRect = compassControlContainer.getBoundingClientRect();
        
        const fixedWidth = 950; 
        const fixedHeight = 690; 

        const newLeft = compassRect.left;
        const distanceFromBottom = window.innerHeight - compassRect.bottom;
        const newBottom = distanceFromBottom;

        graphCard.style.left = `${newLeft}px`;
        graphCard.style.bottom = `${newBottom}px`;
        graphCard.style.width = `${fixedWidth}px`;
        graphCard.style.height = `${fixedHeight}px`;

        enlargeButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        `;
        enlargeButton.title = 'Reducir gráfica';

    } else {
        // --- REDUCIR GRÁFICA ---
        graphCard.classList.remove('enlarged');

        graphCard.style.left = '';
        graphCard.style.bottom = '';
        graphCard.style.width = '';
        graphCard.style.height = '';
        graphCard.style.top = '';
        graphCard.style.right = '';
        graphCard.style.transform = '';

        enlargeButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="11" y1="8" x2="11" y2="14"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        `;
        enlargeButton.title = 'Ampliar gráfica';
    }
    
    if (navigationChart) {
        updateChartData(); 
        setTimeout(() => {
            navigationChart.resize();
        }, 200);
    }
    
    updateNavigationGraphVisibilityAndMode();
}
    
    




    


    

    
    function initializeLocationPickerMap(mapContainerId, slotIndex) {
        if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
        const mapDiv = document.createElement('div'); mapDiv.style.width = '100%'; mapDiv.style.height = '100%';
        const container = document.getElementById(mapContainerId); while (container.firstChild && container.firstChild.id !== 'picker-ok-map-button' && container.firstChild.id !== 'picker-locate-me-button') { container.removeChild(container.firstChild); } container.insertBefore(mapDiv, container.firstChild);
        const initialLocation = tempSavedLocations[slotIndex] || {}; const centerLat = initialLocation.lat || 40.416775; const centerLng = initialLocation.lng || -3.703790; const initialZoom = (initialLocation.lat && initialLocation.lng) ? 15 : 6;
        locationPickerMap = L.map(mapDiv, { zoomControl: false }).setView([centerLat, centerLng], initialZoom);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap contributors' }).addTo(locationPickerMap);
        locationPickerMarker = L.marker([centerLat, centerLng], { draggable: true }).addTo(locationPickerMap);
        locationPickerMarker.on('dragend', (event) => { const pos = event.target.getLatLng(); if (!tempSavedLocations[slotIndex]) tempSavedLocations[slotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS }; tempSavedLocations[slotIndex].lat = pos.lat; tempSavedLocations[slotIndex].lng = pos.lng; });
        locationPickerMap.on('click', (e) => handlePickerMapClick(e, slotIndex));
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                if (locationPickerMap) {
                     try { locationPickerMap.invalidateSize(); } catch(e){}
                }
            });
        });
    }
    function handlePickerMapClick(e, slotIndex) {
        const latlng = e.latlng; if (locationPickerMarker) { locationPickerMarker.setLatLng(latlng); }
        if (!tempSavedLocations[slotIndex]) tempSavedLocations[slotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
        tempSavedLocations[slotIndex].lat = latlng.lat; tempSavedLocations[slotIndex].lng = latlng.lng;
    }




    
    

    
    


function toggleMapTilt(activate) {
}


function updateMapTiltBasedOnHeading(heading) {
}


let mapHeaderButtonsVisible = true;
let mapHeaderToggleDragStartPos = null;
let mapHeaderToggleIsDragging = false;








    


 /**
 * Gestiona la visibilidad de las filas de botones en la cabecera del mapa.
 * @param {boolean} show - True para mostrar, false para ocultar.
 */
function toggleMapHeaderRowsVisibility(show) {
    const header = document.getElementById('reminders-location-map-header');
    if (!header) return;

    mapHeaderButtonsVisible = show;
    header.querySelectorAll('.button-row').forEach(row => {
        row.classList.toggle('hidden-map-header', !show);
    });

    // ----- INICIO DE LA CORRECCIÓN -----
    // Notificamos a Leaflet que el tamaño de su contenedor ha cambiado.
    // Cuando la cabecera se oculta, el div del mapa se expande para llenar el espacio,
    // y Leaflet necesita recalcular sus dimensiones para dibujar el mapa
    // correctamente en el nuevo tamaño.
    if (navigationMapInstance) {
        // Usamos un pequeño retardo para dar tiempo a la transición CSS a que comience.
        // La transición en el CSS dura 0.3s (300ms), así que 350ms es un buen valor.
        setTimeout(() => {
            if (navigationMapInstance) {
                try {
                    // Esta función le dice a Leaflet que compruebe el tamaño de su contenedor y se ajuste.
                    navigationMapInstance.invalidateSize();
                } catch(e) {
                    console.error("Error al invalidar el tamaño del mapa:", e);
                }
            }
        }, 350);
    }
    // ----- FIN DE LA CORRECCIÓN -----
}

// --- FUNCION assignMapButtonListeners() ---
// Busca esta función y reemplázala por completo con el siguiente código.
function assignMapButtonListeners() {
    const header = document.getElementById('reminders-location-map-header');
    const togglePanelButton = document.getElementById('toggle-map-header-buttons-panel');

    if (!header) return;

    // Listener general para los botones de acción
    header.addEventListener('click', (event) => {
        const button = event.target.closest('button');
        if (!button) return;

        switch (button.id) {
            case 'close-reminders-location-map':
                closeNavigationMap(false);
                break;
            case 'locate-me-on-reminders-map':
                handleLocateMeClick(button);
                break;
            case 'nav-map-zoomtoggle-button':
                handleZoomToggleButtonClick(button);
                break;
            case 'start-navigation-button':
                toggleNavigationState();
                break;
            case 'save-route-button':
                saveCurrentRoute();
                break;
            case 'delete-current-route-button': 
                handleLoadOrDeleteRouteClick(button); 
                break;
            case 'load-saved-route-button': 
                showLoadRouteModal(); 
                break;
            case 'add-radar-here':
                handleAddRadarHereClick(button);
                break;
            case 'add-reminder-at-location-button':
                toggleAddReminderAtLocationMode();
                break;
            case 'toggle-simulate-gps-button':
                handleGpsSimulationToggle();
                break;
            case 'simulate-route-button':
                showSimulationModal();
                break;
            case 'reorder-route-stages-button':
                showReorderStagesModal();
                break;
            case 'navigation-map-help-button':
                showNavigationMapHelpModal();
                break;
            case 'map-location-search-button':
                const mapSearchInput = document.getElementById('map-location-search-input');
                const mapFilterInput = document.getElementById('filter-input');
                
                const mainTerm = mapSearchInput?.value.trim() || '';

                if (!mainTerm) {
                    showToast("El campo de búsqueda principal no puede estar vacío.", "warning");
                    return; 
                }
                
                const filterTerm = mapFilterInput?.value.trim() || '';
                let combinedSearchTerm = mainTerm;
                
                if (filterTerm) {
                    combinedSearchTerm += ' ' + filterTerm;
                }
                
                searchAndAddWaypoint(combinedSearchTerm);
                break;
            case 'clear-map-search-input-button':
                const mapSearchInputToClear = document.getElementById('map-location-search-input');
                
                if (mapSearchInputToClear) {
                    mapSearchInputToClear.value = ''; 
                }
                
                mapSearchInputToClear?.dispatchEvent(new Event('input')); 
                mapSearchInputToClear?.focus();
                hideAddressSuggestionsModal();
                break;
        }
    });

    if (togglePanelButton) {
        let isDragging = false;
        
        togglePanelButton.addEventListener('click', () => {
            if (!isDragging) {
                toggleMapHeaderRowsVisibility(!mapHeaderButtonsVisible);
            }
        });

        const handleDragStart = (startEvent) => {
            isDragging = false; 
            const startX = startEvent.touches ? startEvent.touches[0].clientX : startEvent.clientX;
            const startY = startEvent.touches ? startEvent.touches[0].clientY : startEvent.clientY;

            const handleDragMove = (moveEvent) => {
                const moveX = moveEvent.touches ? moveEvent.touches[0].clientX : moveEvent.clientX;
                const moveY = moveEvent.touches ? moveEvent.touches[0].clientY : moveEvent.clientY;
                const dx = moveX - startX;
                const dy = moveY - startY;

                if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
                    isDragging = true;
                }
            };

            const handleDragEnd = (endEvent) => {
                const endX = endEvent.changedTouches ? endEvent.changedTouches[0].clientX : endEvent.clientX;
                const endY = endEvent.changedTouches ? endEvent.changedTouches[0].clientY : endEvent.clientY;
                const dx = endX - startX;
                const dy = endY - startY;
                const dragThreshold = 50;

                if (isDragging && (Math.abs(dx) > dragThreshold || Math.abs(dy) > dragThreshold)) {
                    if (dx > dragThreshold) {
                        loadRouteByName("CASA", true);
                    } else if (dy > dragThreshold) { 
                        loadRouteByName("TRABAJO", true);
                    }
                }
                
                document.removeEventListener('mousemove', handleDragMove);
                document.removeEventListener('mouseup', handleDragEnd);
                document.removeEventListener('touchmove', handleDragMove);
                document.removeEventListener('touchend', handleDragEnd);
            };

            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);
            document.addEventListener('touchmove', handleDragMove);
            document.addEventListener('touchend', handleDragEnd);
        };

        togglePanelButton.addEventListener('mousedown', handleDragStart);
        togglePanelButton.addEventListener('touchstart', handleDragStart, { passive: true });
    }

    document.getElementById('radares-ruta-checkbox')?.addEventListener('change', (e) => toggleRadaresRuta(e.target.checked));
    document.getElementById('tareas-ruta-checkbox')?.addEventListener('change', (e) => toggleTareasRuta(e.target.checked));

    const mapLocationSearchInput = document.getElementById('map-location-search-input');
    const mapFilterInput = document.getElementById('filter-input');

    if (mapLocationSearchInput) {
        let searchDebounceTimer;
        const handleSearchInput = () => {
            // --- INICIO DE LA MODIFICACIÓN ---
            // Ahora la visibilidad de los botones solo depende del campo de búsqueda principal.
            const hasMainText = mapLocationSearchInput.value.trim() !== '';
            
            document.getElementById('map-location-search-button').style.display = hasMainText ? 'inline-flex' : 'none';
            document.getElementById('clear-map-search-input-button').style.display = hasMainText ? 'inline-flex' : 'none';
            // --- FIN DE LA MODIFICACIÓN ---
            
            clearTimeout(searchDebounceTimer);
            
            const mainTerm = mapLocationSearchInput.value.trim();

            if (mainTerm) {
                const filterTerm = mapFilterInput.value.trim();
                let combinedSearchTerm = mainTerm;
                
                if (filterTerm) {
                    combinedSearchTerm += ' ' + filterTerm;
                }
                
                searchDebounceTimer = setTimeout(() => fetchAddressSuggestions(combinedSearchTerm), 300);
            } else {
                hideAddressSuggestionsModal();
            }
            
            localStorage.setItem(MAP_FILTER_INPUT_KEY, mapFilterInput.value);
        };

        mapLocationSearchInput.addEventListener('input', handleSearchInput);
        if (mapFilterInput) {
            mapFilterInput.addEventListener('input', handleSearchInput);
        }

        mapLocationSearchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                const mainTerm = mapLocationSearchInput.value.trim();
                
                if (!mainTerm) {
                    showToast("El campo de búsqueda principal no puede estar vacío.", "warning");
                    return;
                }
                
                const filterTerm = mapFilterInput?.value.trim() || '';
                let combinedSearchTerm = mainTerm;
                if (filterTerm) {
                    combinedSearchTerm += ' ' + filterTerm;
                }
                
                hideAddressSuggestionsModal();
                searchAndAddWaypoint(combinedSearchTerm);
            }
        });
    }

    document.getElementById('turn-icon-container-styled')?.addEventListener('click', (event) => {
        event.stopPropagation();
        if (navigationCurrentRouteData?.routes?.[0]) {
            const route = navigationCurrentRouteData.routes[0];
            const step = route.legs?.[currentLegIndexNav]?.steps?.[currentStepIndexNav];
            if (step) {
                showIntersectionPreviewMap(step, route, true, 7000);
            } else {
                showToast("No hay maniobra actual para mostrar detalle.", "info");
            }
        }
    });
}






    








    



function updateNavigationButtonColor() {
    const startNavButton = document.getElementById('start-navigation-button');
    if (startNavButton) {
        if (isNavigating) {
            startNavButton.style.setProperty('background-color', '#000000', 'important');

        } else {
            startNavButton.style.backgroundColor = 'white';
            startNavButton.style.boxShadow = '2px 3px 5px rgba(0,0,0,0.60)';
        }
    }
}


function initDirectionWarningCards() {
    const mapContainer = document.getElementById('leaflet-map-actual-container');
    if (!mapContainer) return;

    if (!directionCardDerecha) {
        directionCardDerecha = document.createElement('div');
        directionCardDerecha.id = 'direction-card-derecha';
        directionCardDerecha.className = 'direction-warning-card';
        directionCardDerecha.textContent = 'DERECHA';
        directionCardDerecha.style.left = '170px';
        directionCardDerecha.style.bottom = '200px';
        mapContainer.appendChild(directionCardDerecha);
    }

    if (!directionCardIzquierda) {
        directionCardIzquierda = document.createElement('div');
        directionCardIzquierda.id = 'direction-card-izquierda';
        directionCardIzquierda.className = 'direction-warning-card';
        directionCardIzquierda.textContent = 'IZQUIERDA';
        directionCardIzquierda.style.right = '170px';
        directionCardIzquierda.style.bottom = '200px';
        mapContainer.appendChild(directionCardIzquierda);
    }
}


function updateDirectionWarningCardsVisibility() {
    if (!directionCardDerecha || !directionCardIzquierda) {
        return;
    }

    const heading = navigationCurrentLocation?.heading;

    // Condición 1: Rumbo hacia el sur
    const isStrictlySouth = (heading >= 145 && heading <= 215);

    // Condición 2: Modo de seguimiento activo
    // 'navigationFollowUser' se gestiona en el botón "ESTÁS AQUÍ"

    // Condición 3: El zoom para maniobra está activo (gestionado por handleProgressiveManeuverZoom)
    // 'isZoomedForManeuver' es ahora una variable global fiable

    // Combinamos las tres condiciones para determinar la visibilidad
    const showCards = isStrictlySouth && navigationFollowUser && isZoomedForManeuver;

    directionCardDerecha.style.display = showCards ? 'block' : 'none';
    directionCardIzquierda.style.display = showCards ? 'block' : 'none';
}


    



L.Control.CompassAndMode = L.Control.extend({
    options: {
        position: 'bottomleft'
    },

    onAdd: function(map) {
        const container = L.DomUtil.create('div', 'leaflet-control-custom-map-controls leaflet-bar');
        const compassContainer = L.DomUtil.create('div', 'leaflet-control-orientation-altitude', container);
        compassContainer.innerHTML = `
            <img id="compass-rose-icon" src="ROSA.PNG" alt="Orientación">
            <span id="orientation-text">---</span>
            <span id="altitude-display">--- m</span>
            <span id="current-speed-display">--- km/h</span>
            <span id="average-speed-display" class="speed-stats-text">Med: --- km/h</span>
            <span id="max-speed-display" class="speed-stats-text">Máx: --- km/h</span>
        `;
        L.DomEvent.disableClickPropagation(compassContainer);
        L.DomEvent.on(compassContainer, 'click', this._toggleGraphMode, this);

        const graphCard = L.DomUtil.create('div', 'hidden', container);
        graphCard.id = 'navigation-graph-card';
        graphCard.style.position = 'relative'; 

        // --- INICIO DE LA MODIFICACIÓN ---
        // Hacemos que todo el panel de la gráfica sea "clicable" para ampliar/reducir
        graphCard.style.cursor = 'pointer'; // Cambiamos el cursor para indicar que es interactivo
        L.DomEvent.on(graphCard, 'click', toggleEnlargedGraph, this);
        // --- FIN DE LA MODIFICACIÓN ---

        const graphTitle = L.DomUtil.create('div', '', graphCard);
        graphTitle.id = 'navigation-graph-title';

        const enlargeButton = L.DomUtil.create('div', '', graphCard);
        enlargeButton.id = 'enlarge-graph-button';
        enlargeButton.title = 'Ampliar/Reducir gráfica';
        enlargeButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="11" y1="8" x2="11" y2="14"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        `;
        L.DomEvent.disableClickPropagation(enlargeButton);
        L.DomEvent.on(enlargeButton, 'click', (e) => {
            e.stopPropagation(); 
            toggleEnlargedGraph();
        });

        const graphCanvasContainer = L.DomUtil.create('div', '', graphCard);
        graphCanvasContainer.id = 'navigation-graph-container';
        graphCanvasContainer.style.width = '100%';
        graphCanvasContainer.style.height = '100%';

        const canvas = L.DomUtil.create('canvas', '', graphCanvasContainer);
        canvas.id = 'navigation-chart';

        L.DomEvent.disableClickPropagation(graphCard);

        this._updateGraphTitle();
        return container;
    },

    _toggleGraphMode: function(e) {
        if (e) L.DomEvent.stopPropagation(e);
    
        if (!navigationCurrentRouteData) {
            showToast("La gráfica estará disponible cuando se calcule una ruta.", "info");
            return;
        }
        
        const modes = ['Desviación ETA', 'Altitud', 'Gráfica off'];
        let currentIndex = modes.indexOf(currentGraphMode);
        currentIndex = (currentIndex + 1) % modes.length;
        currentGraphMode = modes[currentIndex];
        
        localStorage.setItem(GRAPH_STATE_KEY, currentGraphMode); 
        
        updateNavigationGraphVisibilityAndMode();
        
        if (currentGraphMode !== 'Gráfica off') {
            showToast(`Gráfica cambiada a: ${currentGraphMode}`, 'info');
        } else {
            showToast(`Gráfica desactivada`, 'info');
        }
    },

    _updateGraphTitle: function() {
        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            if (currentGraphMode === 'Desviación ETA') {
                graphTitleElement.textContent = 'Desviación ETA';
            } else if (currentGraphMode === 'Altitud') {
                graphTitleElement.textContent = 'Desnivel Ruta';
            } else {
                graphTitleElement.textContent = ''; 
            }
        }
    },

    onRemove: function(map) { },

    updateOrientation: function(heading) {
        const compassRoseIcon = document.getElementById('compass-rose-icon');
        const orientationText = document.getElementById('orientation-text');
        if (compassRoseIcon && orientationText) {
            if (heading !== null && !isNaN(heading) && heading >= 0 && heading <= 360) {
                compassRoseIcon.style.transform = `rotate(${heading}deg)`;
                currentMapBearing = heading;
                const directions = ["N", "NE", "E", "SE", "S", "SO", "O", "NO", "N"];
                const index = Math.round(heading / 45) % 8;
                orientationText.textContent = `${directions[index]}`;
            } else {
                compassRoseIcon.style.transform = 'rotate(0deg)';
                orientationText.textContent = '---';
                currentMapBearing = 0;
            }
        }
    },

    updateAltitude: function(altitude) {
        const altitudeDisplay = document.getElementById('altitude-display');
        if (altitudeDisplay) {
            let displayText = '--- m';
            if (altitude !== null && !isNaN(altitude)) {
                displayText = `${altitude.toFixed(0)} m`;
                if (maxAltitudeDuringTrip !== -Infinity && isNavigating) {
                    displayText += ` \u2261 ${maxAltitudeDuringTrip.toFixed(0)} m`;
                }
            } else if (isNavigating && maxAltitudeDuringTrip !== -Infinity) {
                 displayText = `-- m \u2261 ${maxAltitudeDuringTrip.toFixed(0)} m`;
            }
            altitudeDisplay.textContent = displayText;
        }
    },

    updateCurrentSpeed: function(speedKmh) {
        const speedDisplay = document.getElementById('current-speed-display');
        if (speedDisplay) {
            if (speedKmh !== null && !isNaN(speedKmh)) {
                speedDisplay.textContent = `${speedKmh.toFixed(1)} km/h`;
            } else {
                speedDisplay.textContent = '--- km/h';
            }
        }
    },

    updateAverageSpeed: function(avgSpeedKmh) {
        const avgSpeedDisplay = document.getElementById('average-speed-display');
        if (avgSpeedDisplay) {
            let displayText = 'Med: --- km/h';
            if (avgSpeedKmh !== null && !isNaN(avgSpeedKmh) && (isNavigating || (isSimulatingGpsLocation && automatedSimulationIntervalId))) {
                 displayText = `Med: ${avgSpeedKmh.toFixed(1)} km/h`;
            }
            avgSpeedDisplay.textContent = displayText;
        }
    },
    
    updateMaxSpeed: function(currentSpeedKmh, currentCoords) {
        
        if (typeof currentSpeedKmh === 'number' && currentSpeedKmh > maxSpeedDuringTrip) {
            maxSpeedDuringTrip = currentSpeedKmh;
            
            if (currentCoords) {
                maxSpeedCoordinates = { lat: currentCoords.latitude, lng: currentCoords.longitude };
            }
        }

        const maxSpeedDisplay = document.getElementById('max-speed-display');
        if (maxSpeedDisplay) {
            let displayText = 'Máx: --- km/h'; 
            if (typeof maxSpeedDuringTrip === 'number' && !isNaN(maxSpeedDuringTrip)) {
                if (maxSpeedDuringTrip > 0) {
                    displayText = `Máx: ${maxSpeedDuringTrip.toFixed(1)} km/h`;
                } else if ((isNavigating || (isSimulatingGpsLocation && automatedSimulationIntervalId)) && maxSpeedDuringTrip === 0) {
                    displayText = `Máx: 0.0 km/h`;
                }
            }
            maxSpeedDisplay.textContent = displayText;
        }
    }
});


// "Constructor" para crear una instancia del control
L.control.compassAndMode = function(opts) {
    return new L.Control.CompassAndMode(opts);
}




    
    




      
  


    

    
    







  

// Funciones de apoyo para los listeners (para mantener el código limpio)
function handleLocateMeClick(locateMeButton) {
    if (!navigationMapInstance || !locateMeButton) return;
    const locateMeImg = locateMeButton.querySelector('img');
    const isSatelliteWithLabelsLayer = (localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "").toLowerCase().includes("satélite + calles");
    const targetZoom = isSatelliteWithLabelsLayer ? 17 : 19;
    
    if (locateMeButton.title.includes("Mostrar mi posición")) {
        shouldCenterOnUser = true; navigationFollowUser = true;
        if(locateMeImg) locateMeImg.src = "DEJARSEGUIR.PNG";
        locateMeButton.title = "Dejar de centrar el mapa en mi posición";
        if (navigationCurrentLocation) {
            navigationMapInstance.setView([navigationCurrentLocation.latitude, navigationCurrentLocation.longitude], targetZoom);
        } else {
            getCurrentLocation(coords => {
                if (navigationMapInstance) navigationMapInstance.setView([coords.latitude, coords.longitude], targetZoom);
                updateInitialUserPosition(coords, navigationMapInstance);
            }, () => showToast("No se pudo obtener tu ubicación.", "warning"));
        }
    } else {
        shouldCenterOnUser = false; navigationFollowUser = false;
        if(locateMeImg) locateMeImg.src = "ESTASAQUI.PNG";
        locateMeButton.title = "Mostrar mi posición actual y activar seguimiento";
        targetMapCenterOffset = { x: 0, y: 0 };
        if (navigationMapInstance) navigationMapInstance.panTo(navigationMapInstance.getCenter(), { animate: false });
    }
    updateStartNavigationButtonState(); updateNavigationButtonColor(); updateDirectionWarningCardsVisibility();
}

function handleZoomToggleButtonClick(zoomButton) {
    if (!navigationMapInstance || !zoomButton) return;
    const currentState = zoomButton.dataset.zoomState;
    const img = zoomButton.querySelector('img');
    if (!img) return;

    if (currentState === 'waypoints' || currentState === 'no_route_zoom_out') {
        if (navigationCurrentLocation) {
            const targetZoom = (navigationMapInstance.getMaxZoom() || 19) - 1;
            zoomButton.dataset.zoomState = 'car';
            img.src = 'ZOOM-.PNG';
            zoomButton.title = "Zoom para ver la ruta completa";
            navigationMapInstance.setView([navigationCurrentLocation.latitude, navigationCurrentLocation.longitude], targetZoom, { animate: true, duration: 0.5 });
        }
    } else {
        if (navigationRouteLayer?.getBounds().isValid()) {
            navigationMapInstance.fitBounds(navigationRouteLayer.getBounds().pad(0.15), { animate: true, duration: 0.5 });
            zoomButton.dataset.zoomState = 'waypoints';
        } else {
            navigationMapInstance.setView(navigationMapInstance.getCenter(), 10, { animate: true, duration: 0.5 });
            zoomButton.dataset.zoomState = 'no_route_zoom_out';
        }
        img.src = 'ZOOM+.PNG';
        zoomButton.title = "Zoom a la ubicación del coche";
    }
}




    

function handleLoadOrDeleteRouteClick(button) {
    // --- INICIO DE LA MODIFICACIÓN ---
    // Esta función ahora SIEMPRE borra la ruta.
    // La lógica de "Cargar Ruta" se maneja por un botón separado si lo creas.
    if (isNavigating) {
        toggleNavigationState();
    }

    if (isSimulatingGpsLocation) {
        stopAutomatedRouteSimulation();
    }

    clearNavigationGraph();
    clearAllWaypointMarkersFromMap();
    navigationWaypoints = [];
    if (navigationRouteLayer) { 
        try { 
            navigationMapInstance.removeLayer(navigationRouteLayer); 
        } catch (e) {} 
        navigationRouteLayer = null; 
    }
    if (completedRouteSegmentsLayer) completedRouteSegmentsLayer.clearLayers();
    if (maxSpeedMarkerLayer) maxSpeedMarkerLayer.clearLayers();
    if (speedMilestoneLayer) speedMilestoneLayer.clearLayers();
    
    navigationCurrentRouteData = null;

    hideNavigationUI();
    hideMapInfoOverlay();
    eliminarRadaresDeRuta();
    eliminarTareasDeBarraProgreso();
    actualizarContadorRadares(0);
    actualizarContadorTareas(0);
    showToast("Ruta actual borrada del mapa", "info");
    // --- FIN DE LA MODIFICACIÓN ---
    
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}




    

    




    
function handleAddRadarHereClick(button) {
    button.disabled = true;
    const radarImg = button.querySelector('img');
    if (radarImg) radarImg.src = "MARCANDO.PNG";
    getCurrentLocation(
        (coords) => {
            const now = new Date();
            const newRadarReminder = {
                id: Date.now(),
                text: '<b>RADAR: EN ESTA UBICACION (Añadido manualmente)</b>',
                type: 'simple',
                time: `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`,
                date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                createdAt: now.toISOString(),
                managedByUser: false,
                isLocationEnabled: true,
                locationCoordinates: { latitude: coords.latitude, longitude: coords.longitude },
                radiusMeters: 600,
                excludeFromList: true
            };
            let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
            reminders.push(newRadarReminder);
            localStorage.setItem('reminders', JSON.stringify(reminders));
            showToast("Recordatorio RADAR creado en tu ubicación (radio 600m)", "success");
            updateReminderCount();
            updateButtonStyles();
            if (navigationMapInstance) {
                plotSingleReminderOnMap(newRadarReminder, navigationMapInstance);
                navigationMapInstance.setView([coords.latitude, coords.longitude], 15);
            }
            button.disabled = false;
            if (radarImg) radarImg.src = "RADARAQUI.PNG";
        },
        (errorMsg) => {
            showToast(`Error al obtener ubicación para RADAR: ${errorMsg}`, "error");
            button.disabled = false;
            if (radarImg) radarImg.src = "RADARAQUI.PNG";
        }
    );
}

    
    

    


        

function handleSimulateGpsPositionClick(e, forceExactPosition = false) {
    if (!isSimulatingGpsLocation || !navigationMapInstance) return;

    if (automatedSimulationIntervalId) {
        stopAutomatedRouteSimulationInternal();
        showToast("Simulación automática detenida. Posición GPS fijada manualmente.", "info");
    }

    let latLngToUse = e.latlng;

    if (!forceExactPosition && navigationRouteLayer && navigationRouteLayer.getLatLngs().length > 0 && typeof L.GeometryUtil !== 'undefined' && L.GeometryUtil.closest) {
        const closestPointOnRoute = L.GeometryUtil.closest(navigationMapInstance, navigationRouteLayer, e.latlng);
        if (closestPointOnRoute && closestPointOnRoute.distance < 50) { 
            latLngToUse = L.latLng(closestPointOnRoute.lat, closestPointOnRoute.lng);
        }
    }

    simulatedGpsLocation = {
        latitude: latLngToUse.lat,
        longitude: latLngToUse.lng,
        accuracy: 10,
        heading: navigationCurrentLocation ? navigationCurrentLocation.heading : 0,
        altitude: navigationCurrentLocation ? navigationCurrentLocation.altitude : 0,
        speed: 0
    };
    processSimulatedGpsPosition(true); 
    setNavigationMapClickHandler(); 
}

function stopAutomatedRouteSimulationInternal() {
    if (automatedSimulationIntervalId) {
        clearInterval(automatedSimulationIntervalId);
        automatedSimulationIntervalId = null;
    }
    const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
    if (simulateGpsButton) {
    }
    setNavigationMapClickHandler();
}

function handleGpsSimulationToggle() {
    const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
    const mapDiv = document.getElementById('reminders-location-map-div');

    if (isSimulatingGpsLocation) { 
        stopAutomatedRouteSimulationInternal(); 
        isSimulatingGpsLocation = false;
        reactivateRealGpsAfterSimulation();
        if (mapDiv) mapDiv.classList.remove('simulating-gps-click-mode');
        if (simulateGpsButton) {
            simulateGpsButton.classList.remove('active-simulate-gps-mode'); 
            simulateGpsButton.title = "Activar Simulación GPS (recorrido automático o clic manual)";
        }
        showToast("Modo simulación GPS desactivado. Volviendo a GPS real.", "info");
    } else { 
        isSimulatingGpsLocation = true;
        if (locationWatchId !== null && navigator.geolocation) {
            navigator.geolocation.clearWatch(locationWatchId);
            locationWatchId = null;
        }
        if (simulateGpsButton) {
            simulateGpsButton.classList.add('active-simulate-gps-mode'); 
            simulateGpsButton.title = "Desactivar Simulación GPS (Volver a GPS Real)";
        }

        if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0] && navigationWaypoints.length >= 2) {
            showSimulationSpeedModal(simulationSpeedKmph, (newSpeed) => {
                simulationSpeedKmph = newSpeed;
                startAutomatedRouteSimulation(simulationSpeedKmph); 
                if (mapDiv) mapDiv.classList.remove('simulating-gps-click-mode'); 
            });
        } else {
            if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode'); 
            showToast("Modo simulación GPS por clic ACTIVADO. Carga una ruta para recorrido automático o toca el mapa.", "info", 6000);
        }
    }
    setNavigationMapClickHandler();
}








function startAutomatedRouteSimulation(speedKmph) {
    if (!isSimulatingGpsLocation) {
        showToast("Error: El modo de simulación GPS no está activo.", "error");
        return;
    }
    if (!navigationRouteLayer || !navigationCurrentRouteData || !navigationCurrentRouteData.routes[0] || navigationWaypoints.length < 2) {
        showToast("No hay ruta válida para simular.", "warning");
        stopAutomatedRouteSimulationInternal();
        if (isSimulatingGpsLocation) { 
            const mapDiv = document.getElementById('reminders-location-map-div');
            if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode');
            setNavigationMapClickHandler();
        }
        return;
    }

    if (automatedSimulationIntervalId) clearInterval(automatedSimulationIntervalId);

    if (!isNavigating) {
        toggleNavigationState(); 
    }

    // --- INICIO DE LA MODIFICACIÓN ---
    simulationSpeedKmph = speedKmph; // Guardamos la velocidad base
    currentSimulationSpeedKmph = speedKmph; // La velocidad actual empieza igual que la base

    const routeLine = navigationRouteLayer.getLatLngs();
    const route = navigationCurrentRouteData.routes[0];
    const startWaypoint = navigationWaypoints.find(wp => wp.type === 'S' || wp.isRecalculatedStart) || navigationWaypoints[0];
    let initialHeading = 0;
    if (routeLine.length >= 2) {
        const firstPoint = turf.point([routeLine[0].lng, routeLine[0].lat]);
        const secondPoint = turf.point([routeLine[1].lng, routeLine[1].lat]);
        initialHeading = turf.bearing(firstPoint, secondPoint);
        if (initialHeading < 0) initialHeading += 360;
    }
    
    // Inicialización de variables de simulación
    simulatedGpsLocation = {
        latitude: startWaypoint.lat,
        longitude: startWaypoint.lng,
        accuracy: 5,
        heading: initialHeading,
        altitude: (navigationCurrentLocation?.altitude) ?? 0,
        speed: 0
    };
    simulatedDistanceAlongRoute = 0;
    lastCarDistanceAlongRouteForNavLogic = 0;
    lastValidCarDistanceForDisplay = 0;
    totalDistanceTravelledForStats = 0;
    if (!navigationStartTimeForStats || !isNavigating) {
        navigationStartTimeForStats = new Date();
    }

    // Inicialización de estadísticas de viaje
    maxSpeedDuringTrip = 0;
    maxSpeedCoordinates = { lat: startWaypoint.lat, lng: startWaypoint.lng };
    
    processSimulatedGpsPosition(true); 

    const totalRouteDistance = route.distance;
    
    showToast(`Simulación automática de ruta iniciada a ${speedKmph.toFixed(0)} km/h (velocidad variable).`, "info");
    setNavigationMapClickHandler(); 

    let simulationStepIndex = 0;
    let simulationLegIndex = 0;
    let distanceToEndOfCurrentStep = calculateDistanceToEndOfStep(route, 0, 0);

    automatedSimulationIntervalId = setInterval(() => {
        // Usamos la velocidad variable actual para el cálculo
        const speedMps = (currentSimulationSpeedKmph * 1000) / 3600;
        const distanceIncrement = speedMps * (SIMULATION_TICK_INTERVAL_MS / 1000);
        simulatedDistanceAlongRoute += distanceIncrement;
        totalDistanceTravelledForStats = simulatedDistanceAlongRoute;
        
        // Comprobar si hemos pasado al siguiente paso de la ruta
        if (simulatedDistanceAlongRoute > distanceToEndOfCurrentStep) {
            simulationStepIndex++;
            if (simulationStepIndex >= route.legs[simulationLegIndex].steps.length) {
                simulationStepIndex = 0;
                simulationLegIndex++;
            }
            
            if (simulationLegIndex < route.legs.length) {
                const currentStep = route.legs[simulationLegIndex].steps[simulationStepIndex];
                // Aplicar variación de velocidad para la nueva maniobra
                const multiplier = getRandomSpeedMultiplierForManeuver(currentStep.maneuver);
                let newSpeed = simulationSpeedKmph * (1 + multiplier);
                // Limitar la velocidad a un rango lógico
                currentSimulationSpeedKmph = Math.max(20, Math.min(160, newSpeed));
                
                distanceToEndOfCurrentStep = calculateDistanceToEndOfStep(route, simulationLegIndex, simulationStepIndex);
            }
        }
        // --- FIN DE LA MODIFICACIÓN ---

        if (simulatedDistanceAlongRoute >= totalRouteDistance) {
            stopAutomatedRouteSimulationInternal();
            const endPointCoords = routeLine[routeLine.length - 1];
            simulatedGpsLocation = {
                ...simulatedGpsLocation,
                latitude: endPointCoords.lat,
                longitude: endPointCoords.lng,
                speed: 0
            };
            processSimulatedGpsPosition(true);
            showToast("Simulación de ruta completada. Modo simulación por clic activo.", "success");
            const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
            const mapDiv = document.getElementById('reminders-location-map-div');
            if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode'); 
            if (isNavigating || (!isNavigating && navigationWaypoints.length > 0)) {
                 showArrivalStatsModal();
            }
            setNavigationMapClickHandler();
            return;
        }

        const turfLine = turf.lineString(routeLine.map(p => [p.lng, p.lat]));
        const pointOnLine = turf.along(turfLine, simulatedDistanceAlongRoute / 1000, { units: 'kilometers' });

        if (pointOnLine && pointOnLine.geometry && pointOnLine.geometry.coordinates) {
            const [lng, lat] = pointOnLine.geometry.coordinates;
            let headingSim = 0;
            const lookAheadDistance = Math.min(distanceIncrement * 2, totalRouteDistance - simulatedDistanceAlongRoute);
            if (simulatedDistanceAlongRoute + lookAheadDistance <= totalRouteDistance && lookAheadDistance > 0) {
                const nextPointOnLine = turf.along(turfLine, (simulatedDistanceAlongRoute + lookAheadDistance) / 1000, { units: 'kilometers' });
                if (nextPointOnLine && nextPointOnLine.geometry && nextPointOnLine.geometry.coordinates) {
                    headingSim = turf.bearing(pointOnLine, nextPointOnLine);
                    if (headingSim < 0) headingSim += 360;
                }
            } else {
                if (simulatedGpsLocation && typeof simulatedGpsLocation.heading === 'number' && simulatedGpsLocation.heading !== null) {
                    headingSim = simulatedGpsLocation.heading;
                }
            }
            simulatedGpsLocation = {
                latitude: lat,
                longitude: lng,
                accuracy: 5,
                heading: headingSim,
                altitude: (navigationCurrentLocation?.altitude) ?? 0,
                speed: speedMps
            };
            processSimulatedGpsPosition(false);
        }
    }, SIMULATION_TICK_INTERVAL_MS);
}
    





    

    

function processSimulatedGpsPosition(forceExactPosition = false) {
    if (!isSimulatingGpsLocation || !simulatedGpsLocation) return;

    navigationCurrentLocation = { ...simulatedGpsLocation };
    updateInitialUserPosition(navigationCurrentLocation, navigationMapInstance);
    

    if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
        const route = navigationCurrentRouteData.routes[0];
        let carDistTurf = 0;
        if (navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
            try {
                const carPointTurf = turf.point([simulatedGpsLocation.longitude, simulatedGpsLocation.latitude]);
                const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                let nearestPointOnLineTurf;
                if (forceExactPosition) {
                     nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                } else {
                    nearestPointOnLineTurf = carPointTurf;
                }
                const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });

            } catch (turfError) {
            }
         }

        let cumulativeDistance = 0;
        navigationWaypoints.forEach((wp, index) => {
            if (wp) {
                if (index === 0 && (wp.type === 'S' || wp.isRecalculatedStart)) {
                    wp.visited = true;
                } else if (navigationCurrentRouteData.routes[0].legs && index -1 < navigationCurrentRouteData.routes[0].legs.length) {
                    const leg = navigationCurrentRouteData.routes[0].legs[index-1];
                    if (leg) {
                       cumulativeDistance += (leg.distance || 0);
                       wp.visited = (carDistTurf >= cumulativeDistance - WAYPOINT_VISITED_THRESHOLD_METERS);
                    }
                } else if (wp.type === 'F') {
                     wp.visited = (carDistTurf >= route.distance - WAYPOINT_VISITED_THRESHOLD_METERS);
                }
            }
        });


        lastCarDistanceAlongRouteForNavLogic = carDistTurf;
        updateTurnByTurnDisplay(route, carDistTurf);
        updateNavigationProgressDisplay(route, carDistTurf);
    }
    if (!automatedSimulationIntervalId) { 
        showToast(`Posición GPS simulada: ${simulatedGpsLocation.latitude.toFixed(4)}, ${simulatedGpsLocation.longitude.toFixed(4)}`, "info");
    }
}



/**
 * Asigna el manejador de eventos correcto al mapa según el estado actual de la aplicación
 * (añadiendo recordatorio, simulando GPS, planificando ruta o navegando).
 */
function setNavigationMapClickHandler() {
    if (!navigationMapInstance) return;

    // 1. Siempre eliminamos cualquier listener de clic anterior para evitar duplicados.
    if (navigationMapClickHandler) {
        navigationMapInstance.off('click', navigationMapClickHandler);
        navigationMapClickHandler = null;
    }

    const mapDiv = document.getElementById('reminders-location-map-div');
    if (mapDiv) {
        // Limpiamos las clases de estado del cursor.
        mapDiv.classList.remove('add-reminder-mode', 'simulating-gps-click-mode', 'navigating');
    }

    // 2. Asignamos el nuevo manejador de clic y la clase de cursor según el modo activo.
    if (isAddReminderAtLocationModeActive) {
        navigationMapClickHandler = handleMapClickToAddReminder;
        if (mapDiv) mapDiv.classList.add('add-reminder-mode');
    } else if (isSimulatingGpsLocation) {
        navigationMapClickHandler = (e) => {
            if (automatedSimulationIntervalId) {
                stopAutomatedRouteSimulationInternal();
                showToast("Simulación automática detenida. Posición GPS fijada manualmente.", "info");
            }
            handleSimulateGpsPositionClick(e, true);
        };
        if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode');
    } else if (!isNavigating) {
        // Modo por defecto: planificación de ruta.
        navigationMapClickHandler = (e) => addWaypoint(e.latlng);
        // No se necesita una clase específica, el cursor por defecto es crosshair.
    } else {
        // Modo navegación: no se hace nada al hacer clic.
        if (mapDiv) mapDiv.classList.add('navigating');
        navigationMapClickHandler = null; // explícitamente no hay handler
    }

    // 3. Si hemos definido un manejador, lo asignamos al mapa.
    if (navigationMapClickHandler) {
        navigationMapInstance.on('click', navigationMapClickHandler);
    }
}






    

function showSimulationSpeedModal(defaultSpeed, callback) {
    closeOtherModals('simulation-speed-modal');
    let modal = document.getElementById('simulation-speed-modal');
    if (modal) modal.remove();

    modal = document.createElement('div');
    modal.id = 'simulation-speed-modal';
    modal.innerHTML = `
        <h2>Velocidad de Simulación</h2>
        <label for="simulation-speed-input">Velocidad (km/h):</label>
        <input type="number" id="simulation-speed-input" value="${defaultSpeed}" min="10" max="200">
        <div class="modal-top-buttons">
            <button id="confirm-simulation-speed">Aceptar <span class="button-countdown-timer"></span></button>
            <button id="cancel-simulation-speed">Cancelar</button>
        </div>
    `;
    document.body.appendChild(modal);

    const input = modal.querySelector('#simulation-speed-input');
    const confirmBtn = modal.querySelector('#confirm-simulation-speed');
    const cancelBtn = modal.querySelector('#cancel-simulation-speed');
    input.focus();

    const closeHandler = () => {
        clearModalAutoCloseTimer(modal, confirmBtn, 'simulation-speed-modal');
        if (modal.parentNode) modal.remove();
    };

    confirmBtn.addEventListener('click', () => {
        const speed = parseFloat(input.value);
        if (!isNaN(speed) && speed > 0) {
            callback(speed);
            closeHandler();
        } else {
            showToast("Por favor, introduce una velocidad válida.", "warning");
        }
    });

    cancelBtn.addEventListener('click', () => {
        showToast("Inicio de simulación cancelado", "info");
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) simulateGpsButton.classList.remove('active-simulate-gps-mode');
        isSimulatingGpsLocation = false;
        reactivateRealGpsAfterSimulation();
        setNavigationMapClickHandler();
        closeHandler();
    });

    addModalAutoCloseTimer(modal, confirmBtn, 'simulation-speed-modal', 30000);
}







function stopAutomatedRouteSimulation() {
    stopAutomatedRouteSimulationInternal();

    isSimulatingGpsLocation = false;

    const mapDiv = document.getElementById('reminders-location-map-div');
    if (mapDiv) {
        mapDiv.classList.remove('simulating-gps-click-mode');
    }
    
    const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
    if (simulateGpsButton) {
        simulateGpsButton.classList.remove('active-simulate-gps-mode');
        simulateGpsButton.title = "Activar Simulación GPS (recorrido automático o clic manual)";
    }

    startGpsWatching();
    
    setNavigationMapClickHandler();
}




    



    



function reactivateRealGpsAfterSimulation() {
    // Solo inicia el watchPosition si no hay uno activo.
    if (locationWatchId === null && 'geolocation' in navigator && 'watchPosition' in navigator.geolocation) {
        // ***** INICIO DE LA CORRECCIÓN CLAVE en reactivateRealGpsAfterSimulation *****
        locationWatchId = navigator.geolocation.watchPosition(
            (position) => {
                // Si la simulación de GPS se activa mientras tanto, ignoramos el GPS real.
                if (isSimulatingGpsLocation) return;

                // Recopila las coordenadas y otra información relevante.
                const coordsForUpdate = {
                     latitude: position.coords.latitude, longitude: position.coords.longitude,
                     accuracy: position.coords.accuracy, heading: position.coords.heading,
                     altitude: position.coords.altitude, speed: position.coords.speed
                };
                // Actualiza la ubicación actual global de la navegación.
                navigationCurrentLocation = coordsForUpdate;
                // Pasa la nueva posición a la función que actualiza el marcador del coche y las estadísticas.
                updateInitialUserPosition(coordsForUpdate, navigationMapInstance);

                // Si estamos navegando y hay una ruta, actualiza la visualización del progreso y las indicaciones.
                 if(isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
                    const routeForDistCalc = navigationCurrentRouteData.routes[0];
                    let carDistTurf = 0;
                    if (navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
                        try {
                            const carPointTurf = turf.point([coordsForUpdate.longitude, coordsForUpdate.latitude]);
                            const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                            const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                            const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                            carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                        } catch(e){
                            // Puedes añadir un log o toast de depuración si los cálculos de turf fallan.
                        }
                    }
                    const totalRouteLength = routeForDistCalc.distance;
                    // Asegura que la distancia no retroceda drásticamente (excepto al inicio o grandes saltos).
                     if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                        if (carDistTurf < lastCarDistanceAlongRouteForNavLogic - 100 && lastCarDistanceAlongRouteForNavLogic > 100) {
                            // Si la distancia disminuye significativamente (más de 100m), no actualizamos el lastCarDistanceAlongRouteForNavLogic para evitar saltos.
                            // Esto implica que el usuario podría haber vuelto por la ruta o el GPS saltó.
                        } else {
                            lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                        }
                    } else if (carDistTurf > totalRouteLength + 500) {
                        lastCarDistanceAlongRouteForNavLogic = totalRouteLength; // Si excede mucho, asume el final.
                    }
                    // Actualiza la visualización de la información de navegación.
                    updateTurnByTurnDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                    updateNavigationProgressDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                    // AÑADIDO: Log de depuración de Turf.
                    console.log('Turf Log (reactivateRealGpsAfterSimulation):', {
                        lat: coordsForUpdate.latitude.toFixed(4),
                        lng: coordsForUpdate.longitude.toFixed(4),
                        speed: coordsForUpdate.speed ? coordsForUpdate.speed.toFixed(1) : 'N/A',
                        distanceAlongRoute: carDistTurf.toFixed(2)
                    });
                }
            },
            (error) => {
                // Manejo de errores del GPS (SIN CAMBIOS)
                showToast(`Error al reactivar GPS: ${error.message}`, "warning");
            },
            { enableHighAccuracy: true, timeout: 15000, maximumAge: 3000, distanceFilter: 3 }
        );
        // ***** FIN DE LA CORRECCIÓN CLAVE en reactivateRealGpsAfterSimulation *****

        // Intenta obtener una posición actual inmediatamente para actualizar el mapa.
        getCurrentLocation(coords => {
            // Asegúrate de que la simulación no se haya activado justo después de esta llamada.
            if (!isSimulatingGpsLocation) {
                navigationCurrentLocation = coords;
                updateInitialUserPosition(coords, navigationMapInstance);

                // Si estamos navegando y hay una ruta, actualiza la visualización del progreso y las indicaciones.
                if (isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
                    const routeForDistCalc = navigationCurrentRouteData.routes[0];
                    let carDistTurf = 0;
                     if (navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
                        try {
                            const carPointTurf = turf.point([coords.longitude, coords.latitude]);
                            const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                            const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                            const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                            carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                        } catch(e){
                            // Puedes añadir un log o toast de depuración si los cálculos de turf fallan.
                        }
                     }
                    const totalRouteLength = routeForDistCalc.distance;
                     if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                        if (carDistTurf < lastCarDistanceAlongRouteForNavLogic - 100 && lastCarDistanceAlongRouteForNavLogic > 100) {
                        }
                        lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                    } else if (carDistTurf > totalRouteLength + 500) {
                        lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
                    }
                    updateTurnByTurnDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                    updateNavigationProgressDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                }
            }
        });
    }
}


    





/**
 * Activa o desactiva el modo para añadir un recordatorio en un punto del mapa.
 * Actualiza el estado visual del botón y el cursor del mapa.
 */
function toggleAddReminderAtLocationMode() {
    isAddReminderAtLocationModeActive = !isAddReminderAtLocationModeActive;
    
    const mapDiv = document.getElementById('reminders-location-map-div');
    const button = document.getElementById('add-reminder-at-location-button');

    if (button) {
        if (isAddReminderAtLocationModeActive) {
            button.classList.add('active-reminder-mode');
            if (mapDiv) mapDiv.classList.add('add-reminder-mode');
            showToast("Modo 'Añadir Recordatorio en Mapa' ACTIVADO. Pulsa en el mapa para crear un recordatorio.", "info", 5000);
        } else {
            button.classList.remove('active-reminder-mode');
            if (mapDiv) mapDiv.classList.remove('add-reminder-mode');
            showToast("Modo 'Añadir Recordatorio en Mapa' DESACTIVADO.", "info");
        }
    }
    
    // Es crucial llamar a esta función para que el mapa sepa qué hacer cuando se haga clic.
    setNavigationMapClickHandler();
}    





    

/**
 * Se ejecuta cuando el usuario hace clic en el mapa mientras el modo
 * 'Añadir Recordatorio' está activo.
 */
function handleMapClickToAddReminder(e) {
    if (!isAddReminderAtLocationModeActive || !navigationMapInstance) return;
    const latlng = e.latlng;
    
    // Importante: Inmediatamente desactivamos el modo para evitar múltiples clics.
    toggleAddReminderAtLocationMode(); 
    
    const mapContextBeforeModal = sessionStorage.getItem('mapContext');
    
    // Cerramos el mapa (forzando, ya que vamos a abrir otro modal)
    closeNavigationMap(true); 

    // Guardamos el contexto para poder reabrir el mapa después
    sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
    if (mapContextBeforeModal) {
      sessionStorage.setItem('mapContext', mapContextBeforeModal);
    }

    // Mostramos el modal de creación de recordatorio con los datos de ubicación pre-cargados.
    showReminderModal({
        isLocationEnabled: true,
        locationCoordinates: { latitude: latlng.lat, longitude: latlng.lng },
        radiusMeters: DEFAULT_LOCATION_RADIUS,
        text: 'Recordatorio en mapa: ',
        excludeFromList: false
    });
}    

    






// --- FUNCION openNavigationMap() ---
// Busca esta función y reemplázala por completo con el siguiente código.
function openNavigationMap() {
    isNavigationMapActive = true;
    sessionStorage.setItem('mapContext', 'navigation');

    closeOtherModals('reminders-location-map-modal');
    showToast("Cargando cartografía...", "info", 0, false, "map-loading-toast");

    const mapModal = document.createElement('div');
    mapModal.id = 'reminders-location-map-modal';
    // --- MODIFICACIÓN: HTML del modal de mapa con el ORDEN CORRECTO y el nuevo input de filtro ---
    mapModal.innerHTML = `
        <div id="toggle-map-header-buttons-panel">
             <img src="Coche_Sat.PNG" alt="Toggle Panel Mapa">
        </div>
        <div id="reminders-location-map-content-wrapper">
            <div id="reminders-location-map-header">
                 <div class="button-row">
                    <button id="close-reminders-location-map" class="reminders-map-button-action" title="Cerrar mapa y navegación"><img src="SALIR.PNG" alt="Salir"></button>
                    <button id="locate-me-on-reminders-map" class="reminders-map-button-action" title="Mostrar mi posición actual y activar seguimiento"><img src="ESTASAQUI.PNG" alt="Estás Aquí"></button>
                    <button id="nav-map-zoomtoggle-button" class="reminders-map-button-action" style="background-color: white;" data-zoom-state="waypoints" title="Alternar zoom entre vista de ruta y coche"><img src="ZOOM+.PNG" alt="Zoom" style="width:30px; height:30px;"></button>
                    <button id="start-navigation-button" class="reminders-map-button-action hidden" title="Iniciar/Terminar Navegación"><img src="INICIARNAVEGACION.PNG" alt="Iniciar Navegación"></button>
                    <button id="save-route-button" class="reminders-map-button-action hidden" title="Guardar Ruta Actual"><img src="GUARDARRUTA.PNG" alt="Guardar Ruta"></button>
                    <button id="load-saved-route-button" class="reminders-map-button-action" title="Cargar Ruta Guardada"><img src="CARGARRUTA.PNG" alt="Cargar Ruta"></button>
                    <button id="delete-current-route-button" class="reminders-map-button-action hidden" title="Borrar Ruta Actual del Mapa"><img src="BORRARRUTA.PNG" alt="Borrar Ruta"></button>
                    <button id="add-radar-here" class="reminders-map-button-action" title="Crear RADAR en mi posición actual (radio 600m)"><img src="RADARAQUI.PNG" alt="Radar Aquí"></button>
                     <div class="radares-ruta-control">
                        <input type="checkbox" id="radares-ruta-checkbox">
                        <div class="radares-ruta-label-container">
                            <label for="radares-ruta-checkbox">Radares<br>Ruta</label>
                            <span id="radares-ruta-count" class="hidden">0</span>
                        </div>
                    </div>
                    <div class="tareas-ruta-control">
                        <input type="checkbox" id="tareas-ruta-checkbox">
                        <div class="tareas-ruta-label-container">
                            <label for="tareas-ruta-checkbox">Tareas<br>Ruta</label>
                            <span id="tareas-ruta-count" class="hidden">0</span>
                        </div>
                    </div>
                    <button id="add-reminder-at-location-button" class="reminders-map-button-action" title="Añadir recordatorio en punto del mapa">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="green" stroke="white" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                            <circle cx="12" cy="10" r="3"></circle>
                        </svg>
                    </button>
                     <button id="toggle-simulate-gps-button" class="reminders-map-button-action" title="Activar/Desactivar Simulación GPS (recorrido o clic)"><img src="GPS.PNG" alt="Simular Recorrido"></button>
                    <button id="simulate-route-button" class="reminders-map-button-action" title="Simular interacciones de ruta"><img src="SIMULAR.PNG" alt="Simular Ruta"></button>
                 </div>
                 <div class="button-row" id="search-row-map-header">
                    <button id="reorder-route-stages-button" title="Ordenar Etapas de Ruta"><img src="./MOVER.PNG" alt="Ordenar Etapas"></button>
                    <!-- ORDEN ORIGINAL: BOTÓN AÑADIR PUNTO Y BOTÓN DE LIMPIAR PRIMERO -->
                    <button id="map-location-search-button" class="reminders-map-button-action"><img src="./ANADIRPUNTO.PNG" alt="Añadir Punto Ruta"></button>
                    <button id="clear-map-search-input-button" title="Limpiar búsqueda">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="red" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    </button>
                    <!-- CAMPOS DE BÚSQUEDA Y FILTRO DESPUÉS DE LOS BOTONES -->
                    <input type="text" id="map-location-search-input" placeholder="Dirección,sitio,zona /Negocio /Ciudad /CP+Provincia (28001 Madrid /Lidl Lugo)">
                    <input type="text" id="filter-input" placeholder="Filtro"> 
                    <button id="navigation-map-help-button" class="reminders-map-button-action" title="Ayuda del mapa de navegación/radares"><img src="IMG_4326.PNG" alt="Ayuda"></button>
                 </div>
            </div>
             <div id="reminders-location-map-div">
                <div id="leaflet-map-actual-container"></div>
                 <div id="map-info-overlay"></div>
                 <div id="navigation-bottom-progress-bar" style="display: none;">
                    <div style="flex-grow: 1; margin-left: 8px;">
                        <div id="navigation-top-info-bar">
                            <div id="turn-icon-container-styled">
                                <span id="turn-icon-display" class="turn-icon-display"></span>
                            </div>
                            <div class="maneuver-text-container">
                               <div>
                                   <span id="maneuver-text-display" class="maneuver-text"></span>
                                   <span id="street-name-display" class="street-name"></span>
                               </div>
                               <div id="distance-to-turn-formatted"></div>
                            </div>
                        </div>
                        <div id="distance-progress-bar-to-turn-container"> <div id="distance-progress-bar-to-turn"></div> </div>
                        <hr>
                        <div id="route-overall-progress-container">
                             <div id="route-overall-progress">
                                 <img id="route-progress-icon" src="AVANCE.PNG" alt="Avance" style="display:none;">
                                 <span id="route-progress-text"></span>
                             </div>
                        </div>
                        <div id="navigation-eta-info">
                            <div id="next-stage-info">
                                <strong>Próxima Etapa</strong>
                                <span id="next-stage-distance">-- km</span>   |  
                                <span id="next-stage-time">-- min</span>   |   ETA:
                                <span id="next-stage-eta">--:--</span>
                                <span id="next-stage-eta-deviation" class="eta-deviation"></span>
                            </div>
                            <div id="final-destination-info">
                                <strong> Final</strong>
                                <span id="final-destination-distance">-- km</span>   |  
                                <span id="final-destination-time">-- min</span>   |   ETA:
                                <span id="final-destination-eta">--:--</span>
                                <span id="final-destination-eta-deviation" class="eta-deviation"></span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
    // --- FIN MODIFICACIÓN ---
    document.body.appendChild(mapModal);

    const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresCheckbox) {
        radaresCheckbox.checked = localStorage.getItem(RADARES_RUTA_CHECKED_KEY) === 'true';
    }
    const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasCheckbox) {
        tareasCheckbox.checked = localStorage.getItem(TAREAS_RUTA_CHECKED_KEY) === 'true';
    }
    currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviación ETA';

    toggleMapHeaderRowsVisibility(mapHeaderButtonsVisible);

    requestAnimationFrame(() => {
        const mapActualContainer = document.getElementById('leaflet-map-actual-container');
        if (!mapActualContainer) {
            isNavigationMapActive = false;
            sessionStorage.removeItem('mapContext');
            const loadingToast = document.getElementById("map-loading-toast");
            if (loadingToast) loadingToast.remove();
            activeToasts = activeToasts.filter(t => t.id !== "map-loading-toast");
            if (mapModal.parentNode) mapModal.remove();
            showToast("Error crítico: No se pudo crear el contenedor del mapa.", "error");
            return;
        }

        initDirectionWarningCards();

        assignMapButtonListeners();

        // --- MODIFICACIÓN: Inicializar valores de los campos del mapa ---
        const mapLocationSearchInput = document.getElementById('map-location-search-input');
        const mapFilterInput = document.getElementById('filter-input');
        if (mapLocationSearchInput) {
            // map-location-search-input NO se guarda en caché, siempre empieza vacío.
            mapLocationSearchInput.value = ''; 
        }
        if (mapFilterInput) {
            const savedFilterValue = localStorage.getItem(MAP_FILTER_INPUT_KEY);
            mapFilterInput.value = savedFilterValue !== null ? savedFilterValue : 'España'; // Valor por defecto "España"
        }
        // Disparar evento input en el campo principal para actualizar visibilidad de botones.
        if (mapLocationSearchInput) {
            mapLocationSearchInput.dispatchEvent(new Event('input')); 
        }
        // --- FIN MODIFICACIÓN ---

        try {
            if (navigationMapInstance) navigationMapInstance.remove();
            if (mapLayersControl) mapLayersControl.remove();
            if (compassAndModeControl) compassAndModeControl.remove();

            navigationMapInstance = L.map(mapActualContainer, { zoomControl: false, attributionControl: false });
            L.control.attribution({ prefix: '<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>', position: 'bottomright' }).addTo(navigationMapInstance);

            const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© <a href="https://www.openstreetmap.org/copyright">OSM</a>' });
            const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' });
            const satelliteWithLabels = L.layerGroup([
                L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' }),
                L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', { attribution: '© OSM © CARTO', pane: 'labels' })
            ]);
            if (!navigationMapInstance.getPane('labels')) {
                navigationMapInstance.createPane('labels');
                navigationMapInstance.getPane('labels').style.zIndex = 650;
                navigationMapInstance.getPane('labels').style.pointerEvents = 'none';
            }
            const baseMaps = { "Mapa Normal": osmLayer, "Satélite Puro": satelliteLayer, "Satélite + Calles": satelliteWithLabels };
            const savedLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "Satélite + Calles";
            let initialLayer = baseMaps[savedLayerName] || satelliteWithLabels;
            initialLayer.addTo(navigationMapInstance);

            mapLayersControl = L.control.layers(baseMaps, null, { position: 'topright', collapsed: true }).addTo(navigationMapInstance);
            compassAndModeControl = L.control.compassAndMode({ position: 'bottomleft' }).addTo(navigationMapInstance);
            
            completedRouteSegmentsLayer = L.layerGroup().addTo(navigationMapInstance);
            maxSpeedMarkerLayer = L.layerGroup().addTo(navigationMapInstance);
            speedMilestoneLayer = L.layerGroup().addTo(navigationMapInstance);

            navigationMapInstance.on('baselayerchange', function(e) {
                localStorage.setItem(ACTIVE_MAP_LAYER_KEY, e.name);
                updateRouteAndCarIconStyle();
                updateNavigationGraphVisibilityAndMode();
            });
            navigationMapInstance.on('load', function() {
                toggleMapHeaderRowsVisibility(mapHeaderButtonsVisible); 
                const loadingToast = document.getElementById("map-loading-toast");
                if (loadingToast) {
                    loadingToast.remove();
                    activeToasts = activeToasts.filter(t => t.id !== "map-loading-toast");
                }
            });
            navigationMapInstance.on('zoomend', () => {
                renderWaypointMarkers();
                updateDirectionWarningCardsVisibility();
            });
            
            updateRouteAndCarIconStyle();
            plotRemindersOnNavigationMap();

            getCurrentLocation(
                (currentPos) => {
                    navigationCurrentLocation = currentPos;
                    updateInitialUserPosition(currentPos, navigationMapInstance);
                    if (navigationWaypoints.length === 0) {
                        navigationMapInstance.setView([currentPos.latitude, currentPos.longitude], 15);
                    }
                    startGpsWatching(); 
                },
                (errorMsg) => {
                    showToast("No se pudo obtener tu ubicación actual. Algunas funciones pueden estar limitadas", "warning");
                    if (compassAndModeControl) { compassAndModeControl.updateOrientation(null); compassAndModeControl.updateAltitude(null); }
                    if (navigationWaypoints.length === 0 && remindersWithLocation.length === 0) {
                        navigationMapInstance.setView([40.416775, -3.703790], 6);
                    } else if (remindersWithLocation.length > 0 && navigationWaypoints.length === 0) {
                        const bounds = L.latLngBounds(remindersWithLocation.map(r => [r.locationCoordinates.latitude, r.locationCoordinates.longitude]));
                        if (bounds.isValid()) {
                             navigationMapInstance.fitBounds(bounds.pad(0.15));
                        }
                    }
                     const loadingToast = document.getElementById("map-loading-toast");
                     if (loadingToast) {
                         loadingToast.remove();
                         activeToasts = activeToasts.filter(t => t.id !== "map-loading-toast");
                     }
                    startGpsWatching(); 
                }
            );

            setNavigationMapClickHandler();
            requestAnimationFrame(() => requestAnimationFrame(() => {
                if(navigationMapInstance) navigationMapInstance.invalidateSize({debounceMoveend: true});
            }));
        } catch (error) {
             const errorContainer = document.getElementById('leaflet-map-actual-container') || mapActualContainer;
             if (errorContainer) errorContainer.innerHTML = `<p style="color:red; text-align:center; padding:20px;">Error al cargar el mapa: ${error.message}</p>`;
             isNavigationMapActive = false;
             const loadingToast = document.getElementById("map-loading-toast");
             if (loadingToast) loadingToast.remove();
             activeToasts = activeToasts.filter(t => t.id !== "map-loading-toast");
        }

        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        toggleMapLocationSearchVisibility(!isNavigating);
        actualizarContadorRadares(radaresEnRutaActual.length);
        actualizarContadorTareas(tareasEnRutaActual.length);
        updateNavigationGraphVisibilityAndMode();
    });
}




    
    





    

    

function calculateDistanceToEndOfStep(route, targetLegIndex, targetStepIndex) {
    let totalDistance = 0;
    if (!route || !route.legs) return 0;

    for (let legIdx = 0; legIdx <= targetLegIndex; legIdx++) {
        const leg = route.legs[legIdx];
        if (!leg || !leg.steps) continue;
        const limitStepIndex = (legIdx === targetLegIndex) ? targetStepIndex : leg.steps.length - 1;
        for (let stepIdx = 0; stepIdx <= limitStepIndex; stepIdx++) {
            const step = leg.steps[stepIdx];
            if (step && typeof step.distance === 'number') {
                totalDistance += step.distance;
            }
        }
    }
    return totalDistance;
}


function plotRemindersOnNavigationMap() {
    if (!navigationMapInstance) return;
    reminderMapObjects.forEach(obj => {
        if (obj.marker && navigationMapInstance.hasLayer(obj.marker)) obj.marker.remove();
        if (obj.circle && navigationMapInstance.hasLayer(obj.circle)) obj.circle.remove();
    });
    reminderMapObjects = [];

    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    const remindersWithLocation = reminders.filter(r => r.isLocationEnabled && r.locationCoordinates?.latitude && r.locationCoordinates?.longitude && !r.isFromRuta);
    remindersWithLocation.forEach(reminder => {
        const mapObject = plotSingleReminderOnMap(reminder, navigationMapInstance);
        if (mapObject) reminderMapObjects.push(mapObject);
    });
}

function plotSingleReminderOnMap(reminder, mapInstance) {
    if (!mapInstance || !reminder.isLocationEnabled || !reminder.locationCoordinates) return null;
    const latLng = [reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude];
    const isRadarType = reminder.text.toUpperCase().includes("RADAR:") || reminder.excludeFromList;

    let markerIconToUse;
    let circleColor, circleFillColor, circleFillOpacity, circleWeight;

    if (isRadarType) {
        markerIconToUse = smallRadarMarkerIcon;
        circleColor = '#f1d7ff';
        circleFillColor = '#f1d7ff';
        circleFillOpacity = 0.25;
        circleWeight = 0.5;
    } else {
        markerIconToUse = largeGreenLocationMarkerIcon;
        circleColor = '#c7eb7a';
        circleFillColor = '#c7eb7a';
        circleFillOpacity = 0.35;
        circleWeight = 0.5;
    }

    const marker = L.marker(latLng, { icon: markerIconToUse, title: reminder.text.replace(/<[^>]*>/g, '').substring(0, 50) }).addTo(mapInstance);
    const circle = L.circle(latLng, { radius: reminder.radiusMeters || DEFAULT_LOCATION_RADIUS, color: circleColor, fillColor: circleFillColor, weight: circleWeight, fillOpacity: circleFillOpacity }).addTo(mapInstance);

let popupContent = ` <div style="max-width: 250px; font-family: sans-serif; font-size: 0.9rem;"> <strong style="font-size: 1rem; color: #333; display: block; margin-bottom: 5px;">${reminder.text.replace(/<b>|<\/b>/gi,'')}</strong> <hr style="margin: 4px 0;"> ${reminder.time ? `<p style="margin: 3px 0;"><strong>Hora:</strong> ${formatTimeWithPeriod(reminder.time)}</p>` : ''} ${reminder.date ? `<p style="margin: 3px 0;"><strong>Fecha:</strong> ${formatDateDetailed(reminder.date)}</p>` : ''} <p style="margin: 3px 0;"><strong>Radio:</strong> ${reminder.radiusMeters || DEFAULT_LOCATION_RADIUS}m</p> <button data-reminder-id="${reminder.id}" class="modify-reminder-from-map" style="margin-top: 8px; padding: 4px 8px; font-size: 0.8rem; background-color: #10B981; color: white; border: none; border-radius: 3px; cursor: pointer;">Modificar</button> </div>`;
    marker.bindPopup(popupContent);
    marker.on('popupopen', () => {
        const modifyButton = marker.getPopup().getElement().querySelector('.modify-reminder-from-map');
        if (modifyButton) {
            const newModifyButton = modifyButton.cloneNode(true); modifyButton.parentNode.replaceChild(newModifyButton, modifyButton);
            newModifyButton.addEventListener('click', (e) => {
                const id = parseInt(e.target.dataset.reminderId);
                let remToMod = null;
                if (!isNaN(id)) {
                    const rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    remToMod = rems.find(r => r.id === id);
                }
                if (!remToMod && reminder) {
                    remToMod = {...reminder};
                    if (typeof remToMod.id !== 'number') remToMod.id = null;
                }

                if (remToMod) {
                    const mapContextBeforeModal = sessionStorage.getItem('mapContext');
                    closeNavigationMap(true);
                    sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                    if (mapContextBeforeModal) {
                        sessionStorage.setItem('mapContext', mapContextBeforeModal);
                    }
                    showReminderModal(remToMod);
                } else {
                    showToast("Error: No se pudo encontrar el recordatorio para modificar", "error");
                }
            });
        }
    });
    return { reminderId: reminder.id, marker, circle, isFromRuta: reminder.isFromRuta || false };
}

    function showNavigationMapHelpModal() {
    const existingHelpModal = document.getElementById('reminders-map-help-modal-instance');
    if (existingHelpModal) { clearModalAutoCloseTimer(existingHelpModal, existingHelpModal.querySelector('#close-reminders-map-help-instance'), 'reminders-map-help-modal-instance'); existingHelpModal.remove(); }
    const helpModal = document.createElement('div'); helpModal.id = 'reminders-map-help-modal-instance'; helpModal.className = 'help-modal'; helpModal.setAttribute('aria-label', 'Ayuda Mapa de Navegación/Radares');
    helpModal.innerHTML = `
            <h2 class="text-xl font-bold mb-4">Ayuda del Mapa de Navegaci&oacute;n y Ubicaciones</h2>
            <div class="modal-top-buttons" style="justify-content: flex-end;">
                <button type="button" id="close-reminders-map-help-instance" style="flex: 0 1 auto; min-width: 120px;">Entendido</button>
            </div>
            <p class="mb-2">Este mapa permite ver recordatorios con ubicaci&oacute;n y planificar/seguir rutas GPS.</p>
            <h3 class="font-semibold text-lg mt-3 mb-1">Planificaci&oacute;n de Ruta:</h3>
            <ul class="list-disc pl-5 space-y-1 text-sm">
                <li><strong>A&ntilde;adir Puntos Manualmente:</strong> Pulsa en el mapa para a&ntilde;adir puntos de ruta.
                    <ul>
                        <li>El primer punto es la Salida (S - Verde).</li>
                        <li>El &uacute;ltimo punto es el Fin (F - Azul).</li>
                        <li>Puntos intermedios son Etapas (1, 2... - Naranja).</li>
                    </ul>
                </li>
                <li><strong>A&ntilde;adir Puntos por B&uacute;squeda:</strong> Utiliza el campo de texto <img src="./IMG_4400.png" alt="Campo búsqueda" style="height:1.2em; display:inline; vertical-align:middle;">. Escribe una direcci&oacute;n y pulsa el bot&oacute;n <img src="./ANADIRPUNTO.PNG" alt="Añadir punto" style="height:1.2em; display:inline; vertical-align:middle;"> (visible si hay texto en el campo).</li>
                <li><strong>Reordenar Etapas:</strong> Pulsa el bot&oacute;n <img src="./MOVER.PNG" alt="Ordenar etapas" style="height:1.2em; display:inline; vertical-align:middle;">. Se abrir&aacute; una ventana donde podr&aacute;s arrastrar y soltar las etapas para cambiar su orden. Pulsa "Aceptar" para aplicar los cambios.</li>
                <li><strong>Eliminar Punto:</strong> Pulsa el aspa (X) roja en un marcador de etapa. O desde el popup que se abre al pulsar un punto de la ruta, el botón "BORRAR PUNTO" (o "BORRAR ETAPA" si es intermedio)</li>
                <li><strong>Punto de Salida:</strong> Por defecto es tu ubicaci&oacute;n actual (si est&aacute; disponible al a&ntilde;adir el primer punto). Puedes arrastrarlo para cambiarlo.</li>
                <li><strong>Rec&aacute;lculo:</strong> La ruta se recalcula autom&aacute;ticamente al a&ntilde;adir, mover, reordenar o eliminar puntos.</li>
                <li><strong>Botones de Ruta:</strong>
                    <ul>
                        <li><strong>Iniciar/Terminar Navegaci&oacute;n <img src="./INICIARNAVEGACION.PNG" alt="Iniciar Navegación" style="height:1.2em; display:inline; vertical-align:middle;"> / <img src="./TERMINARNAVEGACION.PNG" alt="Terminar Navegación" style="height:1.2em; display:inline; vertical-align:middle;"> :</strong> Comienza/Finaliza el seguimiento de la ruta.</li>
                        <li><strong>Guardar Ruta <img src="./GUARDARRUTA.PNG" alt="Guardar Ruta" style="height:1.2em; display:inline; vertical-align:middle;"> :</strong> Guarda la ruta actual en la cach&eacute; del navegador para usarla despu&eacute;s. Se te pedir&aacute; un nombre.</li>
                        <li><strong>Cargar <img src="./CARGARRUTA.PNG" alt="Cargar Ruta" style="height:1.2em; display:inline; vertical-align:middle;"> / Borrar Ruta del Mapa <img src="./BORRARRUTA.PNG" alt="Borrar Ruta" style="height:1.2em; display:inline; vertical-align:middle;"> :</strong> Abre una lista de rutas guardadas para cargar una o borrarla. Al pulsar "Cargar", se borrará la ruta actual del mapa.</li>
                    </ul>
                </li>
            </ul>
            <h3 class="font-semibold text-lg mt-3 mb-1">Durante la Navegaci&oacute;n:</h3>
             <ul class="list-disc pl-5 space-y-1 text-sm">
                <li><strong>Barra de Progreso (superior izquierda):</strong> Muestra indicaciones de giro, progreso total, kilometraje, tiempo y ETA. <strong>Pulsa el ICONO DE GIRO en esta barra para mostrar/ocultar un mapa detallado de la maniobra actual.</strong> Automáticamente, este mapa detallado aparecerá cuando falten menos de 800m para una intersección (no para "seguir recto") y se ocultará a menos de 100m o al cambiar de maniobra.</li>
                <li><strong>Seguimiento:</strong> El mapa te sigue si "EST&Aacute;S AQU&Iacute;" <img src="ESTASAQUI.PNG" alt="Estás Aquí" style="height:1.2em; display:inline; vertical-align:middle;"> est&aacute; activado (bot&oacute;n cambia a "DEJAR DE SEGUIR" <img src="DEJARSEGUIR.PNG" alt="Dejar de Seguir" style="height:1.2em; display:inline; vertical-align:middle;">). Tu icono de coche (<img src="AVANCE.PNG" alt="Coche" style="width:1.2em; height:1.2em; display:inline; vertical-align:middle;">) se mueve en el mapa.</li>
                <li><strong>Rec&aacute;lculo Autom&aacute;tico:</strong> Si te desv&iacute;as de la ruta, el sistema intentar&aacute; recalcular una nueva ruta.</li>
                <li><strong>Radares Ruta (Checkbox <input type="checkbox" checked disabled style="transform: scale(0.8); vertical-align: middle;">):</strong> Si est&aacute; activado y hay una ruta cargada, busca y muestra en el mapa los radares que est&aacute;n en el trazado de la ruta.</li>
                <li><strong>Tareas Ruta (Checkbox <input type="checkbox" checked disabled style="transform: scale(0.8); vertical-align: middle;">):</strong> Similar a radares, pero para tus recordatorios de ubicación.</li>
                <li><strong>Recordatorios:</strong> El sistema de aviso de recordatorios y radares cercanos sigue activo.</li>
                 <li><strong>Simular Recorrido de Ruta <img src="./GPS.PNG" alt="Simular Recorrido" style="height:1.2em; display:inline; vertical-align:middle;">:</strong> Activa este modo (botón rojo). Introduce una velocidad y el coche recorrerá la ruta. Pulsa de nuevo para desactivar y volver al GPS real.</li>
            </ul>
            <h3 class="font-semibold text-lg mt-3 mb-1">Controles Generales del Mapa:</h3>
            <ul class="list-disc pl-5 space-y-1 text-sm">
                 <li><strong>Botón Lateral <img src="Coche_Sat.PNG" alt="Toggle Panel Mapa" style="height:1.2em; display:inline; vertical-align:middle; background:rgba(128,128,128,0.3); border-radius:50%; padding:2px;"> :</strong> Tap para Mostrar/Ocultar botones de la cabecera del mapa. Arrastrar hacia abajo para ruta a "TRABAJO" o hacia la derecha para ruta a "CASA" (si están guardadas).</li>
                 <li><strong>"AQU&Iacute; HAY RADAR" <img src="RADARAQUI.PNG" alt="Radar Aquí" style="height:1.2em; display:inline; vertical-align:middle;">:</strong> Crea un recordatorio tipo RADAR en tu ubicaci&oacute;n actual.</li>
                 <li><strong>"A&Ntilde;ADIR RECORDATORIO AQU&Iacute;" (icono chincheta verde <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="green" stroke="white" stroke-width="1" style="vertical-align:middle; display:inline;"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>):</strong> Pulsa para activar el modo (botón rojo). Pulsa en el mapa para crear un recordatorio.</li>
                 <li><strong>Orientaci&oacute;n y Altitud:</strong> Panel inferior izquierdo (Brújula <img src="ROSA.PNG" alt="Brújula" style="height:1.2em; display:inline; vertical-align:middle;">) muestra rumbo y altitud.</li>
                <li><strong>Capas de Mapa:</strong> Control en la esquina superior derecha <img src="https://unpkg.com/leaflet@1.9.4/dist/images/layers.png" alt="Capas" style="height:1.2em; display:inline; vertical-align:middle; border: 1px solid grey;"> para cambiar entre Mapa Normal y Satélite.</li>
                <li><strong>Ver Recordatorios:</strong> Los recordatorios con ubicaci&oacute;n se muestran como chinchetas. Pulsa para ver detalles y modificar.</li>
                 <li><strong>Gráfica de Ruta (en Brújula <img src="ROSA.PNG" alt="Brújula" style="height:1.2em; display:inline; vertical-align:middle;">):</strong> Botón para alternar entre gráfica de Velocidad, Altitud o desactivarla. Muestra datos como velocidad media/máxima, etc.</li>
            </ul>
        `;
    document.body.appendChild(helpModal); const closeButtonHelp = helpModal.querySelector('#close-reminders-map-help-instance');
    const closeHandlerHelp = () => { clearModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance'); if (helpModal.parentNode) helpModal.parentNode.removeChild(helpModal); };
    closeButtonHelp.addEventListener('click', closeHandlerHelp); addModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance', 90000);
}

function addWaypoint(latlng, labelOverride = null, typeOverride = null, isInternalWaypoint = false) {
    if (!navigationMapInstance || isNavigating) return;

    const newWaypoint = {
        id: Date.now(),
        lat: latlng.lat,
        lng: latlng.lng,
        type: typeOverride || '',
        marker: null,
        label: labelOverride || '',
        address: '',
        visited: false,
        isCriticalForRecalc: !isInternalWaypoint,
        isInternal: isInternalWaypoint,
        isRecalculatedStart: false
    };

    if (navigationWaypoints.length === 0 && navigationCurrentLocation && !typeOverride && !isInternalWaypoint ) {
        const startPoint = {
            id: Date.now() -1,
            lat: navigationCurrentLocation.latitude,
            lng: navigationCurrentLocation.longitude,
            type: 'S',
            marker: null,
            label: 'S',
            address: 'Posición Actual (GPS)',
            visited: true,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false
        };
        navigationWaypoints.push(startPoint);
    }

    navigationWaypoints.push(newWaypoint);
    updateWaypointTypesAndLabels();
    renderWaypointMarkers();
    recalculateAndDrawRoute().then(() => {
        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
            toggleRadaresRuta(true);
        }
        const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
            toggleTareasRuta(true);
        }
    });
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}


function formatPhotonFeatureName(feature) {
    if (!feature || !feature.properties) return "Ubicación desconocida";
    const props = feature.properties;
    let nameParts = [];
    if (props.name) nameParts.push(props.name);
    if (props.street) { let streetPart = props.street; if (props.housenumber) streetPart += ` ${props.housenumber}`; nameParts.push(streetPart); }
    if (props.postcode) nameParts.push(props.postcode);
    if (props.city && (!props.name || props.name.toLowerCase() !== props.city.toLowerCase())) nameParts.push(props.city);
    else if (props.county && (!props.name || props.name.toLowerCase() !== props.county.toLowerCase())) nameParts.push(props.county);
    else if (props.state && (!props.name || props.name.toLowerCase() !== props.state.toLowerCase())) nameParts.push(props.state);
    if (props.country && nameParts.length > 0 && props.country.toLowerCase() !== nameParts[nameParts.length - 1].toLowerCase()) nameParts.push(props.country);
    else if (props.country && nameParts.length === 0) nameParts = [props.country];
    let formattedName = nameParts.filter((value, index, self) => self.map(v => v.toLowerCase()).indexOf(value.toLowerCase()) === index).join(', ');
    if (!formattedName && feature.geometry && feature.geometry.coordinates) { formattedName = `(${feature.geometry.coordinates[1].toFixed(4)}, ${feature.geometry.coordinates[0].toFixed(4)})`; }
    return formattedName || "Ubicación desconocida";
}


async function searchAndAddWaypoint(addressQuery = null) {
    const searchInput = document.getElementById('map-location-search-input');
    const address = addressQuery || searchInput.value.trim();
    if (!address) {
        showToast("Por favor, introduce una dirección para buscar", "warning");
        return;
    }

    const searchButton = document.getElementById('map-location-search-button');
    if (searchButton) {
        searchButton.disabled = true;
        searchButton.innerHTML = `<img src="BUSCANDO.PNG" alt="Buscando...">`;
    }

    try {
        let addressToSearch = address;
        if (typeof addressToSearch === 'string') {
          addressToSearch = addressToSearch.replace(/,/g, '');
        }
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(addressToSearch)}&limit=1&accept-language=es&addressdetails=1`;

        const response = await fetch(url);

if (!response.ok) {
            throw new Error(`Error de red Nominatim: ${response.status} ${response.statusText}`);
        }
        const data = await response.json();

        if (data && data.length > 0) {
            const result = data[0];
            const lat = parseFloat(result.lat);
            const lon = parseFloat(result.lon);
            const displayName = result.display_name || "Ubicación Desconocida";

            if (!isNaN(lat) && !isNaN(lon)) {
                const latlng = L.latLng(lat, lon);
                addWaypoint(latlng, displayName.substring(0,30));
                if(navigationMapInstance) navigationMapInstance.setView(latlng, 15);
                if (searchInput) {
                    searchInput.value = '';
                    searchInput.dispatchEvent(new Event('input'));
                }
                showToast("Ubicación añadida como etapa", "success");
            } else {
                showToast("Nominatim devolvió coordenadas no válidas para la dirección", "error", 4000, true);
            }
        } else {
            showToast("Dirección no encontrada vía Nominatim", "warning", 4000, true);
        }
    } catch (error) {
        showToast(`Error al buscar (Nominatim): ${error.message}`, "error", 4000, true);
    } finally {
        if (searchButton) {
            searchButton.disabled = false;
            searchButton.innerHTML = `<img src="ANADIRPUNTO.PNG" alt="Añadir Punto Ruta">`;
            if (searchInput && searchInput.value.trim() === '') {
                searchButton.style.display = 'none';
                const clearMapSearchBtn = document.getElementById('clear-map-search-input-button');
                if (clearMapSearchBtn) clearMapSearchBtn.style.display = 'none';
            }
        }
    }
}

async function fetchAddressSuggestions(query) {
    if (!query || query.length < 3) {
        hideAddressSuggestionsModal();
        return;
    }

    try {

        let queryToSearch = query;
        if (typeof queryToSearch === 'string') {
            queryToSearch = queryToSearch.replace(/,/g, '');
        }
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(queryToSearch)}&limit=60&accept-language=es&addressdetails=1`;

        const response = await fetch(url);


        if (!response.ok) {
            const errorText = await response.text();

            throw new Error(`Error de red Nominatim: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();


  if (data && data.length > 0) {
            const results = data.map(item => {
                if (item.lat && item.lon) {
                    return {
                        display_name: item.display_name || "Ubicación desconocida",
                        lat: parseFloat(item.lat),
                        lon: parseFloat(item.lon)
                    };
                }

                return null;
            }).filter(Boolean);



            if (results.length === 0) {
                 hideAddressSuggestionsModal();
                 if (query.length >=3 && !searchToastShown) {
                    searchToastShown = true;
                    showToast("Búsqueda de palabras tecleadas no encontradas... (de todas las palabras, da igual el orden)", "error not-found", 3000);
                    setTimeout(() => { searchToastShown = false; }, 3500);
                 }
                 return;
            }

            displayAddressSuggestionsModal(results.slice(0, 60));


        } else {

            hideAddressSuggestionsModal();
            if (query.length >=3 && !searchToastShown) {
                searchToastShown = true;
                showToast("Búsqueda de palabras tecleadas no encontradas... (de todas las palabras, da igual el orden)", "error not-found", 3000);
                setTimeout(() => { searchToastShown = false; }, 3500);
            }
        }
    } catch (error) {
        showToast(`Error buscando sugerencias (Nominatim): ${error.message}`, "error");
        hideAddressSuggestionsModal();
    }
}


function displayAddressSuggestionsModal(suggestions) {
    const searchInput = document.getElementById('map-location-search-input');
    if (!searchInput) return;

    const modalId = 'address-suggestions-modal';
    closeOtherModals(modalId);
    let modal = document.getElementById(modalId);

    if (suggestions.length === 0) {
        hideAddressSuggestionsModal();
        return;
    }

    if (!modal) {
        modal = document.createElement('div');
        modal.id = modalId;
        modal.className = 'address-suggestions-modal';
        modal.innerHTML = `
            <h2 id="address-suggestions-title"></h2>
            <ul id="address-suggestions-list"></ul>
            <div class="modal-top-buttons" style="justify-content: flex-end; margin-top: 1rem;">
                <button id="close-address-suggestions-modal" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
            </div>
        `;
        document.body.appendChild(modal);
        const closeButton = modal.querySelector('#close-address-suggestions-modal');
        closeButton.addEventListener('click', hideAddressSuggestionsModal);
    }

    const titleElement = modal.querySelector('#address-suggestions-title');
    const listElement = modal.querySelector('#address-suggestions-list');
    const closeButton = modal.querySelector('#close-address-suggestions-modal');

    titleElement.textContent = `${suggestions.length} coincidencia${suggestions.length !== 1 ? 's' : ''} encontrada${suggestions.length !== 1 ? 's' : ''}`;
    listElement.innerHTML = '';

    suggestions.forEach(suggestion => {
        const li = document.createElement('li');
        li.textContent = suggestion.display_name;
        li.dataset.lat = suggestion.lat;
        li.dataset.lon = suggestion.lon;
        li.addEventListener('click', () => {
            searchInput.value = suggestion.display_name;
            hideAddressSuggestionsModal();
            searchAndAddWaypoint(suggestion.display_name);
        });
        listElement.appendChild(li);
    });

    const searchInputRect = searchInput.getBoundingClientRect();
    modal.style.top = `${searchInputRect.bottom + 5}px`;

    const viewportHeight = window.innerHeight;
    const modalTop = searchInputRect.bottom + 5;
    const availableHeight = viewportHeight - modalTop - 20;
    modal.style.maxHeight = `${availableHeight}px`;

    const titleHeight = titleElement.offsetHeight;
    const buttonsHeight = modal.querySelector('.modal-top-buttons').offsetHeight;
    const listMaxHeight = availableHeight - titleHeight - buttonsHeight - 30;
    listElement.style.maxHeight = `${Math.max(100, listMaxHeight)}px`;


    modal.classList.remove('hidden');
    addModalAutoCloseTimer(modal, closeButton, 'address-suggestions-modal', 30000);
}

function hideAddressSuggestionsModal() {
    const modal = document.getElementById('address-suggestions-modal');
    if (modal && !modal.classList.contains('hidden')) {
        clearModalAutoCloseTimer(modal, modal.querySelector('#close-address-suggestions-modal'), 'address-suggestions-modal');
        modal.classList.add('hidden');
    }
}


function toggleMapLocationSearchVisibility(show) {
    const searchRow = document.getElementById('search-row-map-header');
    const reorderButton = document.getElementById('reorder-route-stages-button');

    if (show) {
        if (searchRow) searchRow.style.display = 'flex';
        if (reorderButton && navigationWaypoints.length >= 2) reorderButton.style.display = 'inline-flex';
        else if (reorderButton) reorderButton.style.display = 'none';
    } else {
        if (searchRow) searchRow.style.display = 'none';
        if (reorderButton) reorderButton.style.display = 'none';
    }
}


async function getAddressForWaypoint(lat, lng) {
    if (typeof lat !== 'number' || typeof lng !== 'number' || isNaN(lat) || isNaN(lng)) {
        return "Ubicación Desconocida";
    }

    try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=0&accept-language=es`);
        if (response.ok) {
            const data = await response.json();
            return data.display_name || `(${lat.toFixed(3)}, ${lng.toFixed(3)})`;
        } else {
            return `Etapa (${lat.toFixed(3)}, ${lng.toFixed(3)})`;
        }
    } catch (err) {
        return `Etapa (${lat.toFixed(3)}, ${lng.toFixed(3)})`;
    }
}

function updateWaypointTypesAndLabels() {
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);

    if (actualWaypoints.length === 0) return;

    actualWaypoints.forEach(async (wp, index) => {
        if (!wp) return;

        if (actualWaypoints.length === 1) {
            wp.type = 'S';
            wp.label = 'S';
        } else if (index === 0) {
            wp.type = 'S';
            wp.label = 'S';
        } else if (index === actualWaypoints.length - 1) {
            wp.type = 'F';
            wp.label = 'F';
        } else {
            wp.type = 'intermediate';
            wp.label = String(index);
        }

        if (!wp.address) {
            if (typeof wp.lat === 'number' && typeof wp.lng === 'number') {
                 getAddressForWaypoint(wp.lat, wp.lng).then(addr => {
                    wp.address = addr;
                    if (wp.marker && wp.marker.getPopup()) {
                    }
                });
            } else {
                wp.address = "Coordenadas no disponibles para dirección";
            }
        }
    });

    navigationWaypoints.forEach(wp => {
        if(wp && (wp.isInternal || wp.isRecalculatedStart)) {
            wp.label = '';
        }
    });
}


function createWaypointMarkerIcon(label, type, currentZoomLevel = null) {
    let className = 'navigation-waypoint-marker';

    let baseIconSize = [30, 30];
    let baseFontSize = 14;
    let baseDeleteButtonSize = [18, 18];
    let baseDeleteButtonFontSize = 14;
    let baseDeleteButtonOffset = [-8, -8];


    let scale = 1;


    let iconSize = [Math.round(baseIconSize[0] * scale), Math.round(baseIconSize[1] * scale)];
    let fontSize = Math.round((baseFontSize * scale) * 10) / 10;
    let deleteButtonSize = [Math.round(baseDeleteButtonSize[0] * scale), Math.round(baseDeleteButtonSize[1] * scale)];
    let deleteButtonFontSize = Math.round(baseDeleteButtonFontSize * scale);
    let deleteButtonOffsetTop = Math.round(baseDeleteButtonOffset[0] * scale);
    let deleteButtonOffsetRight = Math.round(baseDeleteButtonOffset[1] * scale);

    if (type === 'S' || type === 'S_Recalc') {
        className += ' start-point';
    } else if (type === 'F') {
        className += ' finish-point';
    } else {
        className += ' intermediate-point';
    }

    let iconAnchor = [iconSize[0] / 2, iconSize[1] / 2];

    const showDelete = type !== 'S_Recalc';

    const iconHtml = `<div class="${className}" style="width: ${iconSize[0]}px; height: ${iconSize[1]}px; font-size: ${fontSize}px; line-height: ${iconSize[1]}px;">
            ${label}
            ${showDelete ? `<div class="waypoint-delete-button" title="Eliminar este punto" style="width: ${deleteButtonSize[0]}px; height: ${deleteButtonSize[1]}px; font-size: ${deleteButtonFontSize}px; line-height: ${deleteButtonSize[1]}px; top: ${deleteButtonOffsetTop}px; right: ${deleteButtonOffsetRight}px;">×</div>` : ''}
        </div>`;

    return L.divIcon({
        html: iconHtml,
        className: '',
        iconSize: iconSize,
        iconAnchor: iconAnchor
    });
}

async function getRouteForSingleLeg(lon1, lat1, lon2, lat2) {
    const url = `${OSRM_SERVICE_URL}/driving/${lon1},${lat1};${lon2},${lat2}?overview=false&alternatives=false&steps=false&annotations=false`;
    try {
        const response = await fetch(url);
        if (!response.ok) {
            return { distance: 0, duration: 0 };
        }
        const data = await response.json();
        if (data.routes && data.routes.length > 0 && data.routes[0]) {
            return {
                distance: data.routes[0].distance || 0,
                duration: data.routes[0].duration || 0
            };
        }
        return { distance: 0, duration: 0 };
    } catch (error) {
        return { distance: 0, duration: 0 };
    }
}
function clearAllWaypointMarkersFromMap() {
    if (!navigationMapInstance) {
        navigationWaypoints.forEach(wp => { wp.marker = null; }); 
        return;
    }
    navigationWaypoints.forEach(wp => {
        if (wp && wp.marker) {
            try {
                if (navigationMapInstance.hasLayer(wp.marker)) {
                    navigationMapInstance.removeLayer(wp.marker);
                }
            } catch (e) {
            }
            wp.marker = null;
        }
    });
}


function renderWaypointMarkers() {
    if (!navigationMapInstance) return;

    clearAllWaypointMarkersFromMap();

    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);

    actualWaypoints.forEach(async (wp) => {
        if (!wp) return;

        const waypointIcon = createWaypointMarkerIcon(wp.label, wp.type, null);
        wp.marker = L.marker([wp.lat, wp.lng], {
            icon: waypointIcon,
            draggable: !isNavigating,
            zIndexOffset: 1001
        });

        try {
            wp.marker.addTo(navigationMapInstance);
        } catch(e) {
             return;
        }


        const markerElement = wp.marker.getElement();
        if (markerElement) {
            const deleteButton = markerElement.querySelector('.waypoint-delete-button');
            if (deleteButton) {
                L.DomEvent.on(deleteButton, 'click', function(ev) {
                    L.DomEvent.stopPropagation(ev);
                    handleDeleteWaypointClick(wp.id);
                });
            }
        }

        let popupContent = `<strong>Punto ${wp.label}</strong><br>Cargando datos...`;
        const popup = L.popup({ maxWidth: 250, autoPanPadding: L.point(50, 50), closeButton: true }).setContent(popupContent);
        wp.marker.bindPopup(popup);

        wp.marker.on('click', async (e) => {
            if (!navigationMapInstance) return;
            const waypoint = navigationWaypoints.find(w => w && w.id === wp.id);
            if (!waypoint) return;

            let address = waypoint.address || "Calculando dirección...";
            if (!waypoint.address) {
                 if (typeof waypoint.lat === 'number' && typeof waypoint.lng === 'number') {
                    waypoint.address = await getAddressForWaypoint(waypoint.lat, waypoint.lng);
                 } else {
                    waypoint.address = "Coordenadas no disponibles para dirección";
                 }
                 address = waypoint.address;
            }

            let distanceToWaypoint = 0;
            let timeToWaypoint = 0;
            let etaToWaypoint = "--:--";
            const currentCarPosForPopup = navigationCurrentLocation;
            const currentActualWaypointsForPopup = navigationWaypoints.filter(w => w && !w.isInternal && !w.isRecalculatedStart);
            const actualWaypointIndexInRoute = currentActualWaypointsForPopup.findIndex(awp => awp.id === wp.id);


            if (currentCarPosForPopup && navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
                const route = navigationCurrentRouteData.routes[0];
                let cumulativeDistanceToThisWp = 0;
                let cumulativeDurationToThisWp = 0;

                if (actualWaypointIndexInRoute === 0) {
                    if (isNavigating) {
                        distanceToWaypoint = 0;
                        timeToWaypoint = 0;
                    } else {
                         if (typeof waypoint.lat === 'number' && typeof waypoint.lng === 'number') {
                            const tempRouteToS = await getRouteForSingleLeg(currentCarPosForPopup.longitude, currentCarPosForPopup.latitude, waypoint.lng, waypoint.lat);
                            if (tempRouteToS) {
                                distanceToWaypoint = tempRouteToS.distance;
                                timeToWaypoint = tempRouteToS.duration;
                            }
                        }
                    }
                } else if (actualWaypointIndexInRoute > 0) {
                    for (let i = 0; i < actualWaypointIndexInRoute && i < route.legs.length; i++) {
                        if (route.legs[i]) {
                           cumulativeDistanceToThisWp += (route.legs[i].distance || 0);
                           cumulativeDurationToThisWp += (route.legs[i].duration || 0);
                        }
                    }
                    distanceToWaypoint = cumulativeDistanceToThisWp;
                    timeToWaypoint = cumulativeDurationToThisWp;

                    if (isNavigating && navigationMapInstance && typeof L.GeometryUtil !== 'undefined' && L.GeometryUtil) {
                        let distanceCoveredOnRoute = lastCarDistanceAlongRouteForNavLogic;
                        distanceToWaypoint = Math.max(0, cumulativeDistanceToThisWp - distanceCoveredOnRoute);
                        if (route.distance && route.distance > 0) {
                            timeToWaypoint = route.duration * (distanceToWaypoint / route.distance);
                        } else {
                            timeToWaypoint = 0;
                        }
                    }
                }
                 if (typeof timeToWaypoint === 'number' && !isNaN(timeToWaypoint)) {
                    etaToWaypoint = new Date(Date.now() + timeToWaypoint * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                }


            } else if (currentCarPosForPopup) {
                 if (typeof waypoint.lat === 'number' && typeof waypoint.lng === 'number') {
                    const tempRoute = await getRouteForSingleLeg(currentCarPosForPopup.longitude, currentCarPosForPopup.latitude, waypoint.lng, waypoint.lat);
                    if (tempRoute) {
                        distanceToWaypoint = tempRoute.distance;
                        timeToWaypoint = tempRoute.duration;
                        if (typeof timeToWaypoint === 'number' && !isNaN(timeToWaypoint)) {
                           etaToWaypoint = new Date(Date.now() + timeToWaypoint * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        }
                    }
                }
            }

            let distanciaTexto = "-- km";
            if (typeof distanceToWaypoint === 'number' && !isNaN(distanceToWaypoint)) {
                distanciaTexto = `${(distanceToWaypoint / 1000).toFixed(1)} km`;
            }

            let tiempoTexto = "--:--";
            if (typeof timeToWaypoint === 'number' && !isNaN(timeToWaypoint)) {
                const waypointTotalMinutes = Math.round(timeToWaypoint / 60);
                const waypointHours = Math.floor(waypointTotalMinutes / 60);
                const waypointMinutes = waypointTotalMinutes % 60;
                tiempoTexto = `${String(waypointHours).padStart(2, '0')}:${String(waypointMinutes).padStart(2, '0')}`;
            }

            const showDeleteButtonInPopup = waypoint.type !== 'S_Recalc';

            const finalPopupContent = `
                <div style="font-family: sans-serif; font-size: 0.9rem; max-width: 230px;">
                    <strong style="font-size: 1rem; color: #333; display: block; margin-bottom: 3px;">Punto ${waypoint.label}: ${address || 'Dirección no disponible'}</strong>
                    <hr style="margin: 3px 0;">
                    <p style="margin: 2px 0;"><strong>Distancia:</strong> ${distanciaTexto}</p>
                    <p style="margin: 2px 0;"><strong>Tiempo:</strong> ${tiempoTexto}</p>
                    <p style="margin: 2px 0;"><strong>Llegada (ETA):</strong> ${etaToWaypoint || '--:--'}</p>
                    ${showDeleteButtonInPopup ? `<button data-waypoint-id="${waypoint.id}" class="delete-waypoint-from-popup" style="margin-top: 8px; padding: 4px 8px; font-size: 0.8rem; background-color: #EF4444; color: white; border: none; border-radius: 3px; cursor: pointer;">BORRAR PUNTO</button>` : ''}
                </div>`;
            popup.setContent(finalPopupContent).update();

            const deleteButtonPopup = popup.getElement().querySelector('.delete-waypoint-from-popup');
            if (deleteButtonPopup) {
                L.DomEvent.on(deleteButtonPopup, 'click', function(ev) {
                    L.DomEvent.stopPropagation(ev);
                    const wpIdToDelete = parseInt(this.dataset.waypointId);
                    if (!isNaN(wpIdToDelete)) {
                         if(popup.isOpen()) popup.remove();
                         handleDeleteWaypointClick(wpIdToDelete);
                    }
                });
            }
        });


        wp.marker.on('dragstart', function() {
            if (isNavigating) return;
            if(this.isPopupOpen()) this.closePopup();
        });

        wp.marker.on('dragend', function(event) {
            if (isNavigating) return;
            const newLatLng = event.target.getLatLng();
            wp.lat = newLatLng.lat;
            wp.lng = newLatLng.lng;
            wp.address = '';
            recalculateAndDrawRoute().then(() => {
                const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
                if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                    toggleRadaresRuta(true);
                }
                const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
                if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                    toggleTareasRuta(true);
                }
            });
        });
    });
}

function handleDeleteWaypointClick(waypointId) {
    if (isNavigating) {
        showToast("No se pueden borrar puntos mientras se navega.", "warning");
        return;
    }

    const waypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    if (waypointIndex === -1) {
        return;
    }

    const waypointToDelete = navigationWaypoints[waypointIndex];

    if (waypointToDelete.marker && navigationMapInstance) {
        try { navigationMapInstance.removeLayer(waypointToDelete.marker); } catch (e) {}
        waypointToDelete.marker = null;
    }
    navigationWaypoints.splice(waypointIndex, 1);


    if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 1) { 
        clearAllWaypointMarkersFromMap(); 
        navigationWaypoints = [];
        if (navigationRouteLayer && navigationMapInstance) {
            try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch (e) {}
            navigationRouteLayer = null;
        }
        if (completedRouteSegmentsLayer && navigationMapInstance ) completedRouteSegmentsLayer.clearLayers();
        navigationCurrentRouteData = null;
        hideNavigationUI();
        hideMapInfoOverlay();
        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox) {
            eliminarRadaresDeRuta();
            actualizarContadorRadares(0);
            localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked)); 
        }
         const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasRutaCheckbox) {
            eliminarTareasDeBarraProgreso();
            actualizarContadorTareas(0);
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
        }
    } else {
        updateWaypointTypesAndLabels();
        renderWaypointMarkers();
        if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
            if (navigationRouteLayer && navigationMapInstance) {
                try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch (e) {}
                navigationRouteLayer = null;
            }
             if (completedRouteSegmentsLayer && navigationMapInstance ) completedRouteSegmentsLayer.clearLayers();
            navigationCurrentRouteData = null;
            hideMapInfoOverlay();
             const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
            if (radaresRutaCheckbox) {
                eliminarRadaresDeRuta();
                actualizarContadorRadares(0);
                localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked));
            }
            const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
            if (tareasRutaCheckbox) {
                eliminarTareasDeBarraProgreso();
                actualizarContadorTareas(0);
                localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
            }

        } else {
            recalculateAndDrawRoute().then(() => {
                const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
                if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                    toggleRadaresRuta(true);
                }
                const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
                if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                    toggleTareasRuta(true);
                }
            });
        }
        showToast("Etapa eliminada.", "info");
    }
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}


    







function drawRouteOnMap(route) {
    if (!navigationMapInstance) return;
    if (navigationRouteLayer) {
        try {
            navigationMapInstance.removeLayer(navigationRouteLayer);
        } catch(e) {
        }
        navigationRouteLayer = null;
    }
    if (!route || !route.geometry || !route.geometry.coordinates || route.geometry.coordinates.length < 2) {
        showToast("Geometría de ruta inválida para dibujar.", "warning");
        navigationRouteLayer = null;
        return;
    }

    const routeCoords = route.geometry.coordinates.map(coord => [coord[1], coord[0]]);
    
    // --- INICIO DE LA MODIFICACIÓN ---
    // Eliminamos la lógica condicional del color y lo fijamos a 'yellow'.
    navigationRouteLayer = L.polyline(routeCoords, {
        color: 'yellow',
        weight: 10,
        opacity: 1.0
    }).addTo(navigationMapInstance);
    // --- FIN DE LA MODIFICACIÓN ---

    if (navigationMapInstance.attributionControl) {
         navigationMapInstance.attributionControl.addAttribution('Rutas © <a href="http://project-osrm.org/">OSRM</a>');
    }
}




    






/**
 * Inicia o detiene la navegación de la ruta.
 * @param {boolean} [isRecalculationStop=false] - Indica si la detención es parte de un recálculo.
 */
async function toggleNavigationState(isRecalculationStop = false) {
    const startNavButton = document.getElementById('start-navigation-button');
    const startNavImg = startNavButton ? startNavButton.querySelector('img') : null;
    const mapContainer = document.getElementById('reminders-location-map-div');

    if (isNavigating) {
        // ... (la lógica para detener la navegación no cambia) ...
        isNavigating = false;
        navigationFollowUser = false;
        if(startNavImg) startNavImg.src = "INICIARNAVEGACION.PNG";
        if(startNavButton) startNavButton.classList.remove('navigating');
        if (mapContainer) mapContainer.classList.remove('navigating');
        setNavigationMapClickHandler();

        navigationWaypoints.forEach(wp => { if (wp && wp.marker && wp.marker.dragging) wp.marker.dragging.enable(); });
        showToast("Navegación finalizada", "info", 3000);

        if (!isRecalculationStop && !isArrivalSequenceStarted) {
            if (!document.getElementById('arrival-stats-modal') || document.getElementById('arrival-stats-modal').classList.contains('hidden')) {
                showArrivalStatsModal();
            }
        }
        
        mapHeaderButtonsVisible = true; 
        toggleMapHeaderRowsVisibility(true); 

        if (locationWatchId !== null) {
            navigator.geolocation.clearWatch(locationWatchId);
            locationWatchId = null;
        }
        if (gpsRetryTimeoutId) {
            clearTimeout(gpsRetryTimeoutId);
            gpsRetryTimeoutId = null;
        }
        gpsRetryAttempt = 0;

    } else {
        if (!navigationCurrentRouteData || !navigationCurrentRouteData.routes || navigationCurrentRouteData.routes.length === 0 || navigationWaypoints.filter(wp => !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
            showToast("No hay ruta calculada para iniciar la navegación", "warning");
            return;
        }
        
        clearNavigationGraph();
        
        if(startNavImg) startNavImg.src = "TERMINARNAVEGACION.PNG";
        showToast("Iniciando GPS para comenzar navegación...", "info", 0, false, "gps-init-toast");

        // --- INICIO DE LA MODIFICACIÓN ---
        // Marcar el punto de salida como visitado al iniciar la navegación
        navigationWaypoints.forEach(wp => {
            if(wp && (wp.type === 'S' || wp.isRecalculatedStart)) {
                wp.visited = true;
            }
        });
        // --- FIN DE LA MODIFICACIÓN ---

        getCurrentLocation(
            (initialCoords) => {
                navigationCurrentLocation = initialCoords;
                updateInitialUserPosition(initialCoords, navigationMapInstance);
            },
            (errorMsg) => {
                showToast(`No se pudo obtener tu ubicación inicial: ${errorMsg}. El mapa se centrará cuando el GPS esté listo.`, "warning", 5000);
            }
        );

        startGpsWatching();

        // ... (el resto de la función para iniciar navegación no cambia) ...
        const loadingToast = document.getElementById("gps-init-toast");
        if (loadingToast) loadingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== "gps-init-toast");

        isNavigating = true;
        shouldCenterOnUser = true; 
        navigationFollowUser = true; 

        const locateMeButton = document.getElementById('locate-me-on-reminders-map');
        const locateMeImg = locateMeButton ? locateMeButton.querySelector('img') : null;
        if(locateMeImg) locateMeImg.src = "DEJARSEGUIR.PNG";
        if(locateMeButton) locateMeButton.title = "Dejar de centrar el mapa automáticamente en mi posición";

        if (navigationMapInstance && navigationCurrentLocation) {
            const mapSize = navigationMapInstance.getSize();
            const progressBar = document.getElementById('navigation-bottom-progress-bar');
            let progressBarHeight = 0;
            if (progressBar && progressBar.offsetParent !== null && progressBar.style.display !== 'none') {
                progressBarHeight = progressBar.offsetHeight;
            }

            const offsetFactor = 0.33; 
            const minMapDimension = Math.min(mapSize.x, mapSize.y);
            const offsetDistance = minMapDimension * offsetFactor;
            const effectiveHeading = (navigationCurrentLocation && typeof navigationCurrentLocation.heading === 'number' && navigationCurrentLocation.heading !== null) ? navigationCurrentLocation.heading : (currentMapBearing || 0);
            const headingRad = (effectiveHeading % 360) * Math.PI / 180;

            let calculatedInitialMapCenterOffset = { x: 0, y: 0 };
            calculatedInitialMapCenterOffset.x = -offsetDistance * Math.sin(headingRad);
            calculatedInitialMapCenterOffset.y = offsetDistance * Math.cos(headingRad);

            const isGoingNorth = (effectiveHeading <= 60 || effectiveHeading >= 300);
            const isGoingSouth = effectiveHeading > 120 && effectiveHeading < 240;

            if (progressBarHeight > 0) { 
                if (isGoingNorth) {
                    calculatedInitialMapCenterOffset.y -= progressBarHeight * 0.1; 
                } else if (isGoingSouth) {
                    calculatedInitialMapCenterOffset.y += progressBarHeight * 0.4; 
                }
            }

            const vehicleLatLng = L.latLng(navigationCurrentLocation.latitude, navigationCurrentLocation.longitude);
            const vehicleScreenPos = navigationMapInstance.project(vehicleLatLng);
            const idealInitialMapCenterScreenPos = L.point(
                vehicleScreenPos.x - calculatedInitialMapCenterOffset.x,
                vehicleScreenPos.y - calculatedInitialMapCenterOffset.y
            );
            const idealInitialMapCenterLatLng = navigationMapInstance.unproject(idealInitialMapCenterScreenPos);
            const targetZoom = Math.min(navigationMapInstance.getMaxZoom() || 19, 17); 
            
            navigationMapInstance.setView(idealInitialMapCenterLatLng, targetZoom, {
                animate: true,
                duration: 0.8,
                easeLinearity: 0.75
            });
            targetMapCenterOffset = { ...calculatedInitialMapCenterOffset };
        }


        mapHeaderButtonsVisible = false;
        toggleMapHeaderRowsVisibility(false);

        if(startNavButton) startNavButton.classList.add('navigating');
        if (mapContainer) mapContainer.classList.add('navigating');
        setNavigationMapClickHandler();

        routeStartTime = new Date();
        navigationStartTimeForStats = new Date();
        totalDistanceTravelledForStats = 0;
        maxDistanceReachedOnRoute = 0; 
        maxSpeedDuringTrip = 0; 
        maxSpeedCoordinates = null; 
        maxAltitudeDuringTrip = -Infinity; 
        minAltitudeDuringTrip = Infinity; 
        lastPositionForStats = {...navigationCurrentLocation};
        if (speedMilestoneLayer) speedMilestoneLayer.clearLayers();
        lastSpeedMilestone = 0;
        if (compassAndModeControl) {
            compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip); 
        }
        
        let carDistanceAlongRouteStart = 0;
        if (navigationCurrentLocation && navigationMapInstance && navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
            try {
                const carPointTurf = turf.point([navigationCurrentLocation.longitude, navigationCurrentLocation.latitude]);
                const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                carDistanceAlongRouteStart = turf.length(lineSliceToNearestTurf, { units: 'meters' });
            } catch(e){}
        }
        
        maxDistanceReachedOnRoute = carDistanceAlongRouteStart; 

        tripInitialOverallEtaTime = new Date(Date.now() + (navigationCurrentRouteData.routes[0].duration * 1000 * (1 - (carDistanceAlongRouteStart / navigationCurrentRouteData.routes[0].distance))));
        
        if (navigationCurrentRouteData.routes[0].legs && navigationCurrentRouteData.routes[0].legs.length > 0) {
            const firstLegDurationS = navigationCurrentRouteData.routes[0].legs[0].duration || 0;
            currentStageInitialExpectedEtaTime = new Date(Date.now() + (firstLegDurationS * 1000));
        } else {
            currentStageInitialExpectedEtaTime = null;
        }
        accumulatedDeviationMs = 0;

        navigationWaypoints.forEach(wp => { if(wp) wp.visited = false; if (wp && wp.marker && wp.marker.dragging) wp.marker.dragging.disable(); });
        showToast("Navegación iniciada", "success");
        
        currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviación ETA';
        initializeNavigationGraph();
        
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        updateDirectionWarningCardsVisibility();
    } 
    
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    actualizarContadorRadares(radaresEnRutaActual.length);
    actualizarContadorTareas(tareasEnRutaActual.length);
    updateDirectionWarningCardsVisibility();
}




    



    




    




function closeNavigationMap(force = false) {
    const wasInDirectToMapModeSession = sessionStorage.getItem('isInDirectToMapMode') === 'true';
    const userPrefersDirectToNav = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;

    if (wasInDirectToMapModeSession && userPrefersDirectToNav && !force) {
        sessionStorage.removeItem('isInDirectToMapMode');
        sessionStorage.setItem(TEMP_PREVENT_DIRECT_NAV_KEY, 'true');
        location.reload();
        return;
    }

    directToNavOnLoad = false;
    sessionStorage.removeItem('isInDirectToMapMode');
    isNavigationMapActive = false;
    sessionStorage.removeItem('mapContext');

    if (locationWatchId !== null && navigator.geolocation) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
    if (gpsRetryTimeoutId) {
        clearTimeout(gpsRetryTimeoutId);
        gpsRetryTimeoutId = null;
    }
    gpsRetryAttempt = 0;

    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresRutaCheckbox) {
        localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked));
        if (radaresRutaCheckbox.checked) {
             eliminarRadaresDeRuta();
        }
    }
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasRutaCheckbox) {
        localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
        if (tareasRutaCheckbox.checked) {
            eliminarTareasDeBarraProgreso();
        }
    }
    actualizarContadorRadares(0);
    actualizarContadorTareas(0);

    if (isAddReminderAtLocationModeActive) { toggleAddReminderAtLocationMode(); }
    if (isSimulatingGpsLocation) { stopAutomatedRouteSimulation(); isSimulatingGpsLocation = false; }

    clearAllWaypointMarkersFromMap();
    navigationWaypoints = [];

    if (navigationMapInstance) {
        const toggleMapHeaderButton = document.getElementById('toggle-map-header-buttons-panel');
        if (toggleMapHeaderButton && toggleMapHeaderButton.parentNode) {
            toggleMapHeaderButton.parentNode.removeChild(toggleMapHeaderButton);
        }
        if (compassAndModeControl && navigationMapInstance._controlContainer && navigationMapInstance._controlContainer.contains(compassAndModeControl.getContainer())) { try { navigationMapInstance.removeControl(compassAndModeControl); } catch(e) {} }
        if (mapLayersControl && navigationMapInstance._controlContainer && navigationMapInstance._controlContainer.contains(mapLayersControl.getContainer())) {
             try {mapLayersControl.remove();} catch(e){}
             mapLayersControl = null;
        }
        if (navigationMapClickHandler) { navigationMapInstance.off('click', navigationMapClickHandler); navigationMapClickHandler = null; }
        if (completedRouteSegmentsLayer) { completedRouteSegmentsLayer.clearLayers(); completedRouteSegmentsLayer.remove(); completedRouteSegmentsLayer = null; }
        if (maxSpeedMarkerLayer) { maxSpeedMarkerLayer.clearLayers(); maxSpeedMarkerLayer.remove(); maxSpeedMarkerLayer = null; }
        if (speedMilestoneLayer) { speedMilestoneLayer.clearLayers(); speedMilestoneLayer.remove(); speedMilestoneLayer = null; }
        if (navigationRouteLayer) { try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch(e){} navigationRouteLayer = null; }
        try { navigationMapInstance.remove(); } catch (e) {} navigationMapInstance = null;
    }

    navigationCurrentRouteData = null; isNavigating = false; navigationFollowUser = false;
    routeStartTime = null; navigationStartTimeForStats = null; totalDistanceTravelledForStats = 0; lastPositionForStats = null;
    tripInitialOverallEtaTime = null; currentStageInitialExpectedEtaTime = null; accumulatedDeviationMs = 0;
    currentMapRotationAngle = 0; lastValidCarDistanceForDisplay = 0;
    accumulatedDistanceBeforeCurrentSegment = 0;
    initialUserLocationMarker = null; initialUserLocationMarkerLat = null; initialUserLocationMarkerLng = null;
    if (initialUserLocationCircle) { try {initialUserLocationCircle.remove();} catch(e){} initialUserLocationCircle = null; }
    navigationCurrentLocation = null; compassAndModeControl = null;
    maxSpeedDuringTrip = 0;
    maxSpeedCoordinates = null;
    lastSpeedMilestone = 0;
    maxAltitudeDuringTrip = -Infinity; 
    minAltitudeDuringTrip = Infinity; 
    if (window.compassAndModeControl) { 
        window.compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip); 
    }

    const mapModalElement = document.getElementById('reminders-location-map-modal'); if (mapModalElement) { mapModalElement.remove(); }
    const helpModalInstance = document.getElementById('reminders-map-help-modal-instance'); if (helpModalInstance) { const helpCloseButton = helpModalInstance.querySelector('#close-reminders-map-help-instance'); if(helpCloseButton) clearModalAutoCloseTimer(helpModalInstance, helpCloseButton, 'reminders-map-help-modal-instance'); helpModalInstance.remove(); }
    const savedRoutesModal = document.getElementById('saved-routes-modal'); if (savedRoutesModal) { const closeBtnSRM = savedRoutesModal.querySelector('#close-saved-routes-modal'); if(closeBtnSRM) clearModalAutoCloseTimer(savedRoutesModal, closeBtnSRM, 'saved-routes-modal'); savedRoutesModal.remove(); }
    const saveRoutePromptModal = document.getElementById('save-route-prompt-modal'); if (saveRoutePromptModal) { const closeBtnSRPM = saveRoutePromptModal.querySelector('#cancel-save-route'); if(closeBtnSRPM) clearModalAutoCloseTimer(saveRoutePromptModal, closeBtnSRPM, 'save-route-prompt-modal'); saveRoutePromptModal.remove(); }
    const reorderStagesModalElement = document.getElementById('reorder-stages-modal'); if (reorderStagesModalElement && !reorderStagesModalElement.classList.contains('hidden')) {
        const cancelBtnReorder = reorderStagesModalElement.querySelector('#cancel-reorder-stages');
        if(cancelBtnReorder) clearModalAutoCloseTimer(reorderStagesModalElement, cancelBtnReorder, 'reorder-stages-modal');
        reorderStagesModalElement.classList.add('hidden');
    }
    const simModal = document.getElementById('simulation-modal');
    if (simModal && !simModal.classList.contains('hidden')) {
        if (simulationModalTimer) clearTimeout(simulationModalTimer);
        const simCloseBtn = simModal.querySelector('#close-simulation-modal');
        if (simCloseBtn) clearModalAutoCloseTimer(simModal, simCloseBtn, 'simulation-modal');
        simModal.classList.add('hidden');
        hideIntersectionPreviewMap();
    }
    hideMapInfoOverlay();
    sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
    sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
    sessionStorage.removeItem('boardinggate_map_was_open_before_table');
    sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');
    hideUnifiedReminderWindow();
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    checkReminders();
    const generalTopButtonsPanel = document.getElementById('toggle-top-buttons-panel-general');
    if (generalTopButtonsPanel) generalTopButtonsPanel.classList.remove('hidden');

    const mainContent = document.querySelector('main');
    if (mainContent && mainContent.style.display === 'none') {
         mainContent.style.display = 'block';
         document.querySelector('footer').style.display = 'block';
         document.querySelector('.notices-icon-container').style.display = 'flex';
         document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button').forEach(el => el.style.display = 'flex');
         document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'block');
         document.getElementById('grid-filter-container').style.display = 'flex';

        loadCustomData();
        renderGrid();
        createOtherButtons();
        renderToggleButtons();
        loadSavedSettings();
        updateButtonStyles();
        filterGridItems();
    }
    hideIntersectionPreviewMap();
    updateDirectionWarningCardsVisibility();
    
    clearNavigationGraph();
}




    

    
    
   




 
    
    




async function recalculateAndDrawRoute(preserveAccumulatedStats = false) {
    isRecalculatingRoute = true;
    let carDistanceAlongRouteForInternalUse = 0;
    
    if (!preserveAccumulatedStats) {
        isArrivalSequenceStarted = false;
    }

    const recalculateToastId = "recalculating-route-toast";
    showToast("Recalculando ruta...", "info", 0, false, recalculateToastId);

    // --- INICIO DE LA MODIFICACIÓN ---
    if (!preserveAccumulatedStats) {
        // Si no preservamos estadísticas, es como empezar un viaje nuevo.
        // Reseteamos todo.
        totalDistanceTravelledForStats = 0;
        maxDistanceReachedOnRoute = 0; 
        lastPositionForStats = null;
        if (isNavigating) navigationStartTimeForStats = new Date();
        tripInitialOverallEtaTime = null;
        currentStageInitialExpectedEtaTime = null;
        accumulatedDeviationMs = 0;
        maxSpeedDuringTrip = 0;
        maxSpeedCoordinates = null; // Reseteo sincronizado.
        maxAltitudeDuringTrip = -Infinity;
        minAltitudeDuringTrip = Infinity;
        if (compassAndModeControl) {
            compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip);
        }
    } 
    // --- FIN DE LA MODIFICACIÓN ---

    lastCarDistanceAlongRouteForNavLogic = 0;
    lastValidCarDistanceForDisplay = 0;

    let waypointsForRouteCalculation;

    if (preserveAccumulatedStats && navigationCurrentLocation) {
        const currentPositionAsWaypoint = {
            lat: navigationCurrentLocation.latitude,
            lng: navigationCurrentLocation.longitude,
        };
        const remainingWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.visited);
        waypointsForRouteCalculation = [currentPositionAsWaypoint, ...remainingWaypoints];
    } else {
        waypointsForRouteCalculation = navigationWaypoints.filter(wp => wp && !wp.isInternal);
    }
    
    if (waypointsForRouteCalculation.length < 2) {
        const existingRecalcToast = document.getElementById(recalculateToastId);
        if (existingRecalcToast) existingRecalcToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== recalculateToastId);
        showToast("No hay suficientes waypoints válidos para calcular la ruta", "warning");

        if (navigationRouteLayer && navigationMapInstance) {
            try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch (e) {}
            navigationRouteLayer = null;
        }
        if (completedRouteSegmentsLayer && navigationMapInstance ) completedRouteSegmentsLayer.clearLayers();
        navigationCurrentRouteData = null;
        hideMapInfoOverlay();
        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox) {
            eliminarRadaresDeRuta();
            actualizarContadorRadares(0);
            localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked));
        }
         const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasRutaCheckbox) {
            eliminarTareasDeBarraProgreso();
            actualizarContadorTareas(0);
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
        }
        isRecalculatingRoute = false;
        recalculationAttempts = 0;
        if (recalculationRetryTimeoutId) clearTimeout(recalculationRetryTimeoutId);
        recalculationRetryTimeoutId = null;
        updateStartNavigationButtonState();
        return;
    }

    const coordsString = waypointsForRouteCalculation.map(wp => {
        if (typeof wp.lng !== 'number' || typeof wp.lat !== 'number' || isNaN(wp.lng) || isNaN(wp.lat) ) {
            return null;
        }
        return `${wp.lng},${wp.lat}`;
    }).filter(Boolean).join(';');

    if (!coordsString || waypointsForRouteCalculation.filter(wp => wp && typeof wp.lng === 'number' && typeof wp.lat === 'number').length < 2) {
        const existingRecalcToast = document.getElementById(recalculateToastId);
        if (existingRecalcToast) existingRecalcToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== recalculateToastId);
        showToast("No hay suficientes waypoints válidos para calcular la ruta", "warning");

        if (navigationRouteLayer && navigationMapInstance) {
            try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch (e) {}
            navigationRouteLayer = null;
        }
        if (completedRouteSegmentsLayer && navigationMapInstance ) completedRouteSegmentsLayer.clearLayers();
        navigationCurrentRouteData = null;
        hideMapInfoOverlay();
        isRecalculatingRoute = false;
        recalculationAttempts = 0;
        if (recalculationRetryTimeoutId) clearTimeout(recalculationRetryTimeoutId);
        recalculationRetryTimeoutId = null;
        updateStartNavigationButtonState();
        return;
    }

    const url = `${OSRM_SERVICE_URL}/driving/${coordsString}?overview=full&geometries=geojson&steps=true&alternatives=false&annotations=true`;

    try {
        const response = await fetch(url);
        if (!response.ok) {
            let errorData = { message: `HTTP error ${response.status}` };
            try {
                errorData = await response.json();
            } catch (e) {
                errorData.message = response.statusText || errorData.message;
            }
            throw new Error(`OSRM Error: ${errorData.code || errorData.message || response.statusText}`);
        }
        const data = await response.json();

        const existingRecalcToastSuccess = document.getElementById(recalculateToastId);
        if (existingRecalcToastSuccess) existingRecalcToastSuccess.remove();
        activeToasts = activeToasts.filter(t => t.id !== recalculateToastId);


        if (data.routes && data.routes.length > 0) {
            navigationCurrentRouteData = data;
             if (completedRouteSegmentsLayer && navigationMapInstance ) completedRouteSegmentsLayer.clearLayers();
            drawRouteOnMap(data.routes[0]);

            showToast("Ruta recalculada con éxito", "success");

            currentLegIndexNav = 0;
            currentStepIndexNav = 0;
            lastProcessedStepManeuverLocation = null;
            
            if (data.routes[0]) {
                 const currentCarPosForRecalc = navigationCurrentLocation;
                 if (currentCarPosForRecalc && navigationMapInstance && navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
                    try {
                        const carPointTurf = turf.point([currentCarPosForRecalc.longitude, currentCarPosForRecalc.latitude]);
                        const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                        const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                        const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                        carDistanceAlongRouteForInternalUse = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                    } catch (turfError) {
                    }
                 }
                 lastCarDistanceAlongRouteForNavLogic = carDistanceAlongRouteForInternalUse;
                 updateNavigationProgressDisplay(data.routes[0], carDistanceAlongRouteForInternalUse);
                 updateTurnByTurnDisplay(data.routes[0], carDistanceAlongRouteForInternalUse);
                 showDestinationName();
            }
            showNavigationUIElementsForPlanning();
            recalculationAttempts = 0;
            if (recalculationRetryTimeoutId) clearTimeout(recalculationRetryTimeoutId);
            recalculationRetryTimeoutId = null;

        } else {
            throw new Error("No se encontraron rutas.");
        }
    } catch (error) {
        const existingRecalcToastError = document.getElementById(recalculateToastId);
        if (existingRecalcToastError) existingRecalcToastError.remove();
        activeToasts = activeToasts.filter(t => t.id !== recalculateToastId);

        let errorMessageForToast = "Error al calcular ruta (OSRM)";
        if (error && error.message) {
            errorMessageForToast = `Error al calcular ruta: ${error.message}`;
        }
        showToast(errorMessageForToast, "error");

        if (navigationRouteLayer && navigationMapInstance) {
            try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch(e) {}
            navigationRouteLayer = null;
        }
        if (completedRouteSegmentsLayer && navigationMapInstance ) completedRouteSegmentsLayer.clearLayers();
        navigationCurrentRouteData = null;
        lastValidCarDistanceForDisplay = 0;
        hideMapInfoOverlay();
        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox) {
            eliminarRadaresDeRuta();
            actualizarContadorRadares(0);
             localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked));
        }
        const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasRutaCheckbox) {
            eliminarTareasDeBarraProgreso();
            actualizarContadorTareas(0);
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
        }

        if (recalculationRetryTimeoutId) clearTimeout(recalculationRetryTimeoutId);
        recalculationRetryTimeoutId = setTimeout(() => recalculateAndDrawRoute(preserveAccumulatedStats), 2000);


    }
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    if (!recalculationRetryTimeoutId) {
        isRecalculatingRoute = false;
    }
}    










/**
 * CALCULA el nivel de zoom progresivo para una maniobra.
 * @param {object} currentStep - El paso actual de la ruta de OSRM.
 * @param {number} distanceToManeuver - Distancia en metros hasta la siguiente maniobra.
 * @returns {number|null} El nivel de zoom objetivo, o null si no se necesita cambio.
 */
function handleProgressiveManeuverZoom(currentStep, distanceToManeuver) {
    if (!isNavigating || !navigationMapInstance || !currentStep) {
        if (isZoomedForManeuver) isZoomedForManeuver = false;
        return null;
    }

    // --- INICIO DE LA CORRECCIÓN ---
    // Obtenemos el zoom máximo permitido por la capa de teselas actual
    // y lo usamos para limitar nuestro zoom pico.
    const maxZoomForMap = navigationMapInstance.getMaxZoom() || 19;
    // --- FIN DE LA CORRECCIÓN ---

    const currentMapLayerName = (localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "satélite + calles").toLowerCase();
    const isSatelliteWithLabels = currentMapLayerName.includes("satélite + calles");

    // Ahora, el nivel pico de zoom se limita dinámicamente
    const MANEUVER_PEAK_ZOOM_LEVEL = isSatelliteWithLabels 
        ? Math.min(17.5, maxZoomForMap) 
        : Math.min(18.5, maxZoomForMap);

    const currentStepIdentifier = `${currentLegIndexNav}_${currentStepIndexNav}`;

    if (lastProcessedStepIdentifier !== null && lastProcessedStepIdentifier !== currentStepIdentifier) {
        if (progressiveZoomState === 'zooming-in' || progressiveZoomState === 'holding') {
            progressiveZoomState = 'zooming-out';
        }
    }
    lastProcessedStepIdentifier = currentStepIdentifier;

    const distanceIntoCurrentStep = currentStep.distance - distanceToManeuver;
    let targetZoom = null;

    switch (progressiveZoomState) {
        case 'zooming-out':
            isZoomedForManeuver = true;
            if (distanceIntoCurrentStep > PROGRESSIVE_ZOOM_EXIT_END_DISTANCE || mapPreviousZoomLevelForProgressive === null) {
                targetZoom = mapPreviousZoomLevelForProgressive;
                progressiveZoomState = 'none';
                mapPreviousZoomLevelForProgressive = null;
                isZoomedForManeuver = false;
            } else if (distanceIntoCurrentStep >= PROGRESSIVE_ZOOM_EXIT_START_DISTANCE) {
                const progress = (distanceIntoCurrentStep - PROGRESSIVE_ZOOM_EXIT_START_DISTANCE) / (PROGRESSIVE_ZOOM_EXIT_END_DISTANCE - PROGRESSIVE_ZOOM_EXIT_START_DISTANCE);
                targetZoom = MANEUVER_PEAK_ZOOM_LEVEL - (MANEUVER_PEAK_ZOOM_LEVEL - mapPreviousZoomLevelForProgressive) * Math.min(1, progress);
            } else {
                targetZoom = MANEUVER_PEAK_ZOOM_LEVEL;
            }
            break;

        default: // 'none', 'zooming-in', 'holding'
            if (distanceToManeuver <= PROGRESSIVE_ZOOM_START_DISTANCE && distanceToManeuver > PROGRESSIVE_ZOOM_PEAK_DISTANCE) {
                if (progressiveZoomState !== 'zooming-in' && progressiveZoomState !== 'holding') {
                    mapPreviousZoomLevelForProgressive = navigationMapInstance.getZoom();
                }
                progressiveZoomState = 'zooming-in';
                const progress = (PROGRESSIVE_ZOOM_START_DISTANCE - distanceToManeuver) / (PROGRESSIVE_ZOOM_START_DISTANCE - PROGRESSIVE_ZOOM_PEAK_DISTANCE);
                targetZoom = mapPreviousZoomLevelForProgressive + (MANEUVER_PEAK_ZOOM_LEVEL - mapPreviousZoomLevelForProgressive) * progress;
                isZoomedForManeuver = true;
            } else if (distanceToManeuver <= PROGRESSIVE_ZOOM_PEAK_DISTANCE) {
                if (progressiveZoomState !== 'holding' && mapPreviousZoomLevelForProgressive === null) {
                    mapPreviousZoomLevelForProgressive = navigationMapInstance.getZoom();
                }
                progressiveZoomState = 'holding';
                targetZoom = MANEUVER_PEAK_ZOOM_LEVEL;
                isZoomedForManeuver = true;
            } else {
                if (progressiveZoomState !== 'none' && mapPreviousZoomLevelForProgressive !== null) {
                    targetZoom = mapPreviousZoomLevelForProgressive;
                }
                progressiveZoomState = 'none';
                mapPreviousZoomLevelForProgressive = null;
                isZoomedForManeuver = false;
            }
            break;
    }
    return targetZoom;
}




// Reemplaza la función existente por esta
function updateNavigationProgressDisplay(route, carDistanceAlongTheRoute = 0) {
    const progressBarContainer = document.getElementById('navigation-bottom-progress-bar');

    if (!progressBarContainer) return;

    if (!route || typeof route.distance !== 'number' || typeof route.duration !== 'number' || navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
        return;
    }

    const overallProgressFill = document.getElementById('route-overall-progress');
    const overallProgressContainer = document.getElementById('route-overall-progress-container');
    const routeProgressTextEl = document.getElementById('route-progress-text');
    const routeProgressIconEl = document.getElementById('route-progress-icon');
    const nextStageDistEl = document.getElementById('next-stage-distance');
    const nextStageTimeEl = document.getElementById('next-stage-time');
    const nextStageEtaEl = document.getElementById('next-stage-eta');
    const nextStageDeviationEl = document.getElementById('next-stage-eta-deviation');
    const finalDestDistEl = document.getElementById('final-destination-distance');
    const finalDestTimeEl = document.getElementById('final-destination-time');
    const finalDestEtaEl = document.getElementById('final-destination-eta');
    const finalDestDeviationEl = document.getElementById('final-destination-eta-deviation');
    const nextStageInfoDiv = document.getElementById('next-stage-info');
    const finalDestInfoDiv = document.getElementById('final-destination-info');
    const etaInfoContainer = document.getElementById('navigation-eta-info');

    maxDistanceReachedOnRoute = Math.max(maxDistanceReachedOnRoute, carDistanceAlongTheRoute);
    const distanceForProgressBar = maxDistanceReachedOnRoute;
    const totalRouteLength = route.distance;
    const progressPercent = totalRouteLength > 0 ? (distanceForProgressBar / totalRouteLength) * 100 : 0;
    
    overallProgressFill.style.width = `${Math.min(100, progressPercent)}%`;

    if (routeProgressIconEl) {
        if (progressPercent > 0 && progressPercent < 100) {
            routeProgressIconEl.style.display = 'block';
        } else {
            routeProgressIconEl.style.display = 'none';
        }
    }

    if (routeProgressTextEl) {
        let kmRecorridosTexto = "-- km";
        let timeInfoString = ""; 

        if (isNavigating || (isSimulatingGpsLocation && automatedSimulationIntervalId)) {
            kmRecorridosTexto = `${(totalDistanceTravelledForStats / 1000).toFixed(1)} km`;
            
            if (navigationStartTimeForStats) {
                const startTimeFormatted = `${navigationStartTimeForStats.getHours().toString().padStart(2, '0')}:${navigationStartTimeForStats.getMinutes().toString().padStart(2, '0')}`;
                const nowForTravelTime = new Date();
                const durationMs = nowForTravelTime - navigationStartTimeForStats;
                const totalTravelMinutes = Math.floor(durationMs / (1000 * 60));
                const travelHours = Math.floor(totalTravelMinutes / 60);
                const travelMinutes = totalTravelMinutes % 60;
                const travelTimeFormatted = `${String(travelHours).padStart(2, '0')}:${String(travelMinutes).padStart(2, '0')}`;
                
                timeInfoString = ` (${startTimeFormatted} • ${travelTimeFormatted})`;
            } else {
                 timeInfoString = " (--:-- • --:--)";
            }
        } else if (navigationCurrentRouteData) { 
            kmRecorridosTexto = "0.0 km";
            const now = new Date();
            const currentTimeFormatted = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
            timeInfoString = ` (${currentTimeFormatted} • 00:00)`;
        } else { 
            kmRecorridosTexto = "-- km";
            timeInfoString = " (--:-- • --:--)";
        }
        routeProgressTextEl.innerHTML = `${kmRecorridosTexto}${timeInfoString}`;
    }

    const remainingDistanceTotal = Math.max(0, totalRouteLength - carDistanceAlongTheRoute);
    const remainingDurationTotal = route.duration * (remainingDistanceTotal / totalRouteLength);
    
    finalDestDistEl.textContent = `${(remainingDistanceTotal / 1000).toFixed(1)} km`;
    const finalDestTotalMinutes = Math.round(remainingDurationTotal / 60);
    const finalDestHours = Math.floor(finalDestTotalMinutes / 60);
    const finalDestMinutes = finalDestTotalMinutes % 60;
    finalDestTimeEl.textContent = `${String(finalDestHours).padStart(2, '0')}:${String(finalDestMinutes).padStart(2, '0')}`;
    const currentFinalEta = new Date(Date.now() + remainingDurationTotal * 1000);
    finalDestEtaEl.textContent = currentFinalEta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

    if (tripInitialOverallEtaTime && isNavigating) {
        const finalDeviationMs = currentFinalEta.getTime() - tripInitialOverallEtaTime.getTime();
        finalDestDeviationEl.innerHTML = formatDeviation(finalDeviationMs);
    } else {
        finalDestDeviationEl.innerHTML = "";
    }

    let currentLegIndexForNextStageDisplay = currentLegIndexNav;
    let cumulativeDistanceToStartOfCurrentLegOSRM = 0;
    if (route.legs) {
        for (let i = 0; i < currentLegIndexNav; i++) {
            if (route.legs[i] && typeof route.legs[i].distance === 'number') {
                cumulativeDistanceToStartOfCurrentLegOSRM += route.legs[i].distance;
            }
        }
    }

    const isMultiStageRoute = route.legs && route.legs.length > 1;
    // --- LÓGICA MEJORADA PARA ETIQUETAS DE ETAPA ---
    if (isMultiStageRoute && currentLegIndexForNextStageDisplay < route.legs.length) {
        etaInfoContainer.classList.remove('single-destination');
        finalDestInfoDiv.classList.remove('single-destination-layout');
        nextStageInfoDiv.style.display = 'block';

        const totalEtapas = route.legs.length;
        const etapaActualUsuario = currentLegIndexNav + 1;
        const strongTagNextStage = nextStageInfoDiv.querySelector('strong');

        // Buscar el waypoint que corresponde al final de esta etapa
        const waypointsInRoute = navigationWaypoints.filter(wp => !wp.isInternal && !wp.visited);
        const stageDestinationWaypoint = waypointsInRoute[1]; // El siguiente waypoint no visitado es el destino de la etapa actual

        let stageLabel = `Etapa ${etapaActualUsuario} de ${totalEtapas}`;
        if (stageDestinationWaypoint && stageDestinationWaypoint.address) {
             const addressParts = stageDestinationWaypoint.address.split(',');
             const shortAddress = addressParts[0];
             stageLabel += `: ${shortAddress}`;
        }

        if (strongTagNextStage) {
            strongTagNextStage.innerHTML = stageLabel;
        }

        const distanceIntoCurrentLegDisplay = Math.max(0, carDistanceAlongTheRoute - cumulativeDistanceToStartOfCurrentLegOSRM);
        const legForDisplay = route.legs[currentLegIndexForNextStageDisplay];
        const remainingDistanceThisLegDisplay = Math.max(0, (legForDisplay.distance || 0) - distanceIntoCurrentLegDisplay);
        const remainingDurationThisLegDisplay = (legForDisplay.distance > 0 && typeof legForDisplay.duration === 'number') ? legForDisplay.duration * (remainingDistanceThisLegDisplay / legForDisplay.distance) : 0;

        nextStageDistEl.textContent = `${(remainingDistanceThisLegDisplay / 1000).toFixed(1)} km`;
        const nextStageTotalMinutes = Math.round(remainingDurationThisLegDisplay / 60);
        const nextStageHours = Math.floor(nextStageTotalMinutes / 60);
        const nextStageMinutes = nextStageTotalMinutes % 60;
        nextStageTimeEl.textContent = `${String(nextStageHours).padStart(2, '0')}:${String(nextStageMinutes).padStart(2, '0')}`;
        const currentNextStageEta = new Date(Date.now() + remainingDurationThisLegDisplay * 1000);
        nextStageEtaEl.textContent = currentNextStageEta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

        if (currentStageInitialExpectedEtaTime && isNavigating) {
           const deviationStageMs = currentNextStageEta.getTime() - currentStageInitialExpectedEtaTime.getTime();
           nextStageDeviationEl.innerHTML = formatDeviation(accumulatedDeviationMs + deviationStageMs);
        } else {
           nextStageDeviationEl.innerHTML = "";
        }
    } else {
        // Para rutas de una sola etapa o cuando estamos en la última, ocultamos la info de "Próxima etapa"
        etaInfoContainer.classList.add('single-destination');
        finalDestInfoDiv.classList.add('single-destination-layout');
        nextStageInfoDiv.style.display = 'none';
        if(nextStageDeviationEl) nextStageDeviationEl.innerHTML = "";
    }
    // --- FIN LÓGICA MEJORADA ---

    overallProgressContainer.querySelectorAll('.waypoint-dot-on-progress-bar, .radar-marker-on-progress-bar, .task-marker-on-progress-bar').forEach(dot => dot.remove());

    if (navigationWaypoints.length > 2 && totalRouteLength > 0 && route.legs) {
        let accumulatedDistanceForDots = 0;
        const actualWaypointsForDots = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);

        let distanceLegOsrm = 0;
        for (let i = 0; i < actualWaypointsForDots.length - 1; i++) { 
            if (i < route.legs.length && route.legs[i] && typeof route.legs[i].distance === 'number') {
                distanceLegOsrm += route.legs[i].distance; 
                const percent = (distanceLegOsrm / totalRouteLength) * 100;
                if (percent < 100 && percent > 0) { 
                    const dot = document.createElement('div');
                    dot.className = 'waypoint-dot-on-progress-bar';
                    dot.style.left = `calc(${percent}% - 7px)`;
                    dot.title = `Etapa ${actualWaypointsForDots[i+1] ? actualWaypointsForDots[i+1].label : 'Desconocida'}`;
                    overallProgressContainer.appendChild(dot);
                }
            }
        }
    }

    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresRutaCheckbox && radaresRutaCheckbox.checked && radaresEnRutaActual.length > 0 && totalRouteLength > 0) {
        radaresEnRutaActual.forEach(radar => {
            if (radar.distanceOnRoute !== undefined && radar.distanceOnRoute <= totalRouteLength) {
                const percent = (radar.distanceOnRoute / totalRouteLength) * 100;
                 if (percent >= 0 && percent <= 100) {
                    const radarMarker = document.createElement('div');
                    radarMarker.className = 'radar-marker-on-progress-bar';
                    radarMarker.style.left = `${percent}%`;
                    radarMarker.title = radar.text.replace(/<b>|<\/b>/gi, '');
                    overallProgressContainer.appendChild(radarMarker);
                }
            }
        });
    }

    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasRutaCheckbox && tareasRutaCheckbox.checked && tareasEnRutaActual.length > 0 && totalRouteLength > 0) {
        tareasEnRutaActual.forEach(tarea => {
            if (tarea.distanceOnRoute !== undefined && tarea.distanceOnRoute <= totalRouteLength) {
                const percent = (tarea.distanceOnRoute / totalRouteLength) * 100;
                if (percent >= 0 && percent <= 100) {
                    const taskMarker = document.createElement('div');
                    taskMarker.className = 'task-marker-on-progress-bar';
                    taskMarker.style.left = `${percent}%`;
                    taskMarker.title = tarea.text.replace(/<b>|<\/b>/gi, '');
                    overallProgressContainer.appendChild(taskMarker);
                }
            }
        });
    }

    if (isNavigating && !isArrivalSequenceStarted && remainingDistanceTotal < WAYPOINT_VISITED_THRESHOLD_METERS) {
        isArrivalSequenceStarted = true;
        setTimeout(() => {
            if (!document.getElementById('arrival-stats-modal') || document.getElementById('arrival-stats-modal').classList.contains('hidden')) {
                showArrivalStatsModal();
            }
        }, 7000);
        let countdown = 7;
        const toastId = `arrival-toast-${Date.now()}`;
        showToast(`FIN DEL VIAJE (${countdown})`, 'success', 10000, false, toastId);
        const countdownInterval = setInterval(() => {
            countdown--;
            const arrivalToast = document.getElementById(toastId);
            if (arrivalToast) {
                const span = arrivalToast.querySelector('span');
                if (span) span.innerHTML = `FIN DEL VIAJE (${countdown})`;
            }
            if (countdown <= 0) {
                clearInterval(countdownInterval);
            }
        }, 1000);
    } else if (isNavigating) {
        const destinationWp = navigationWaypoints[navigationWaypoints.length - 1];
        if (destinationWp && destinationWp.address) {
            const mapOverlay = document.getElementById('map-info-overlay');
            if (mapOverlay && !mapOverlay.textContent.startsWith("HA LLEGADO AL ")) {
                 showDestinationName();
            }
        }
    }
}
    

    



    

    



 



// REEMPLAZA ESTA FUNCIÓN COMPLETA EN TU CÓDIGO
function showIntersectionPreviewMap(step, route, isSimulationContextOrClick = false, timerDurationMs = null) {
    const previewWindow = document.getElementById('intersection-preview-map-window');
    const progressBarEl = document.getElementById('navigation-bottom-progress-bar');

    if (!previewWindow || !step || !step.geometry || !route || !navigationMapInstance) {
        hideIntersectionPreviewMap();
        return;
    }
    
    // --- PARÁMETROS DE AJUSTE DEL MINIMAPA ---
    const DISTANCE_BEFORE_MANEUVER_METERS = 110;
    const DISTANCE_AFTER_MANEUVER_METERS = 90;
    const CAR_POSITION_BEFORE_MANEUVER_METERS = 25;
    // --- FIN DE LOS AJUSTES ---

    if (!previewWindow.querySelector('#intersection-rotator')) {
        previewWindow.innerHTML = `
            <div id="intersection-rotator" style="width: 100%; height: 100%; transition: transform 0.3s ease-out;">
                <div id="intersection-preview-map-container" style="width: 100%; height: 100%;"></div>
            </div>
        `;
    }
    const rotatorDiv = previewWindow.querySelector('#intersection-rotator');
    const mapContainerEl = previewWindow.querySelector('#intersection-preview-map-container');

    if (progressBarEl && progressBarEl.offsetParent !== null) {
        const progressBarRect = progressBarEl.getBoundingClientRect();
        previewWindow.style.width = `${progressBarRect.width}px`;
        previewWindow.style.top = `${progressBarRect.bottom + 5}px`;
        previewWindow.style.left = `${progressBarRect.left}px`;
        previewWindow.style.transform = 'none';
    } else if (isSimulationContextOrClick) {
        previewWindow.style.width = '90%';
        previewWindow.style.maxWidth = '500px';
        previewWindow.style.left = '50%';
        previewWindow.style.top = '50%';
        previewWindow.style.transform = 'translate(-50%, -50%)';
    } else {
        hideIntersectionPreviewMap();
        return;
    }

    previewWindow.classList.remove('hidden');
    previewWindow.dataset.source = isSimulationContextOrClick ? 'click' : 'auto';
    if (intersectionPreviewTimer) clearTimeout(intersectionPreviewTimer);

    try {
        if (!intersectionPreviewMap) {
            intersectionPreviewMap = L.map(mapContainerEl, {
                zoomControl: false, dragging: false, touchZoom: false, scrollWheelZoom: false,
                doubleClickZoom: false, boxZoom: false, keyboard: false, attributionControl: false
            });
        }

        requestAnimationFrame(() => {
            if (intersectionPreviewMap) intersectionPreviewMap.invalidateSize();
        });

        Object.values(intersectionPreviewMap._layers).forEach(layer => {
            if (layer instanceof L.TileLayer || layer instanceof L.Polyline || layer instanceof L.Marker || layer instanceof L.CircleMarker) {
                try { intersectionPreviewMap.removeLayer(layer); } catch(e){}
            }
        });

        const currentMapLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "Satélite + Calles";
        let tileLayerInstance;
        if (currentMapLayerName.toLowerCase().includes("satélite puro")) {
            tileLayerInstance = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' });
        } else if (currentMapLayerName.toLowerCase().includes("satélite + calles")) {
            const labelsPaneName = 'intersection_labels_pane_unique';
            tileLayerInstance = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' });
            if (!intersectionPreviewMap.getPane(labelsPaneName)) {
                intersectionPreviewMap.createPane(labelsPaneName);
                intersectionPreviewMap.getPane(labelsPaneName).style.zIndex = 650;
                intersectionPreviewMap.getPane(labelsPaneName).style.pointerEvents = 'none';
            }
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', { attribution: '© OSM © CARTO', pane: labelsPaneName }).addTo(intersectionPreviewMap);
        } else {
            tileLayerInstance = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap' });
        }
        tileLayerInstance.addTo(intersectionPreviewMap);

        const maneuverPoint = L.latLng(step.maneuver.location[1], step.maneuver.location[0]);
        
        const fullRouteLineString = turf.lineString(route.geometry.coordinates);
        const maneuverPointOnRoute = turf.nearestPointOnLine(fullRouteLineString, step.maneuver.location, { units: 'kilometers' });
        const maneuverDistanceKm = maneuverPointOnRoute.properties.location;
        
        const startSliceDistanceKm = Math.max(0, maneuverDistanceKm - (DISTANCE_BEFORE_MANEUVER_METERS / 1000));
        const endSliceDistanceKm = Math.min(turf.length(fullRouteLineString), maneuverDistanceKm + (DISTANCE_AFTER_MANEUVER_METERS / 1000));

        const startSlicePoint = turf.along(fullRouteLineString, startSliceDistanceKm);
        const endSlicePoint = turf.along(fullRouteLineString, endSliceDistanceKm);
        
        const routeSlice = turf.lineSlice(startSlicePoint, endSlicePoint, fullRouteLineString);
        const routeSegmentCoords = routeSlice.geometry.coordinates.map(c => [c[1], c[0]]);
        
        intersectionPreviewRouteLayer = L.polyline(routeSegmentCoords, { color: 'orange', weight: 10, opacity: 1 }).addTo(intersectionPreviewMap);
        intersectionPreviewManeuverMarker = L.circleMarker(maneuverPoint, { radius: 5, color: 'white', weight: 1, fillColor: 'blue', fillOpacity: 1, zIndexOffset: 1000 }).addTo(intersectionPreviewMap);
        
        const lineStringToPlaceCar = turf.lineString(routeSegmentCoords.map(c => [c[1], c[0]]));
        const distanceForCarOnSegment = Math.max(0, DISTANCE_BEFORE_MANEUVER_METERS - CAR_POSITION_BEFORE_MANEUVER_METERS);
        const carPositionPointTurf = turf.along(lineStringToPlaceCar, distanceForCarOnSegment, { units: 'meters' });
        const carPositionLatLng = L.latLng(carPositionPointTurf.geometry.coordinates[1], carPositionPointTurf.geometry.coordinates[0]);
        
        let segmentBearing = 0;
        const lookAheadPointTurf = turf.along(lineStringToPlaceCar, distanceForCarOnSegment + 5, { units: 'meters' });
        
        if (lookAheadPointTurf) {
            segmentBearing = turf.bearing(carPositionPointTurf, lookAheadPointTurf);
            if (segmentBearing < 0) segmentBearing += 360;
        } else {
            segmentBearing = (navigationCurrentLocation && typeof navigationCurrentLocation.heading === 'number') ? navigationCurrentLocation.heading : currentMapBearing;
        }
        
        const shouldRotateMap = (segmentBearing >= 145 && segmentBearing <= 215);
        const mapRotation = shouldRotateMap ? 180 : 0;
        const finalIconRotation = segmentBearing - 90 - mapRotation;
        
        if (rotatorDiv) rotatorDiv.style.transform = `rotate(${mapRotation}deg)`;
        
        intersectionPreviewCarMarker = L.marker(carPositionLatLng, { icon: vehicleIconMiniMap, zIndexOffset: 1001 }).addTo(intersectionPreviewMap);
        
        if (intersectionPreviewCarMarker.getElement()) {
            const carWrapperMini = intersectionPreviewCarMarker.getElement().querySelector('.vehicle-icon-minimap');
            if (carWrapperMini) carWrapperMini.style.transform = `rotate(${finalIconRotation}deg)`;
        }

        const bounds = L.latLngBounds(routeSegmentCoords).pad(0.5);
        
        requestAnimationFrame(() => {
            if (intersectionPreviewMap) {
                intersectionPreviewMap.invalidateSize();
                
                // --- INICIO DE LA LÓGICA DE ZOOM DINÁMICO ---
                const maneuverType = step.maneuver.type || '';
                const maneuverModifier = step.maneuver.modifier || '';
                
                // Maniobras "cortas" que necesitan más zoom
                const isShortManeuver = maneuverType.includes('roundabout') || 
                                        maneuverType.includes('rotary') || 
                                        maneuverModifier.includes('sharp') || 
                                        maneuverModifier.includes('uturn');

                const mapMaxZoom = intersectionPreviewMap.getMaxZoom() || 19;
                let targetZoom;

                if (isShortManeuver) {
                    // Para maniobras cortas, usamos el zoom máximo posible
                    targetZoom = mapMaxZoom;
                } else {
                    // Para maniobras largas, calculamos el zoom que encaje el trazado y luego lo reducimos un poco
                    const zoomThatFitsBounds = intersectionPreviewMap.getBoundsZoom(bounds);
                    targetZoom = Math.max(16, zoomThatFitsBounds - 0.5); // Usamos un zoom intermedio, pero nunca menos de 16
                }
                
                // Nos aseguramos de no exceder el máximo de la capa
                targetZoom = Math.min(targetZoom, mapMaxZoom);

                // Aplicamos el encuadre y el zoom calculado
                intersectionPreviewMap.fitBounds(bounds, { animate: false, paddingTopLeft: [0, 50], paddingBottomRight: [0, 50], maxZoom: targetZoom });
                // --- FIN DE LA LÓGICA DE ZOOM DINÁMICO ---
            }
        });

        if (timerDurationMs && timerDurationMs > 0) {
            intersectionPreviewTimer = setTimeout(hideIntersectionPreviewMap, timerDurationMs);
        }

    } catch (error) {
        console.error("Error al mostrar el mapa de intersección:", error);
        hideIntersectionPreviewMap();
    }
}


    

    


    


    






function hideIntersectionPreviewMap() {
    const card = document.getElementById('intersection-preview-map-window');
    if (card) {
        card.classList.add('hidden');
        // --- INICIO DE LA MODIFICACIÓN ---
        // Reseteamos la rotación del contenedor interior al ocultar la ventana
        const rotator = card.querySelector('#intersection-rotator');
        if (rotator) {
            rotator.style.transform = 'rotate(0deg)';
        }
        // --- FIN DE LA MODIFICACIÓN ---
        miniMapOffsetActive.x = 0;
        targetMapCenterOffset.x -= miniMapOffsetActive.x;
    }
    if (intersectionPreviewTimer) {
        clearTimeout(intersectionPreviewTimer);
        intersectionPreviewTimer = null;
    }
}    
    






    

async function getSuggestedRouteName(lat, lng, isMultiStage = false, totalWaypoints = 0) {
    let baseName = `RUTA: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
    try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=1&accept-language=es`);
        if (response.ok) {
            const data = await response.json();
            if (data.address) {
                const road = data.address.road;
                const city = data.address.city || data.address.town || data.address.village || data.address.hamlet;
                if (road && city) baseName = `${road}, ${city}`;
                else if (city) baseName = city;
                else if (road) baseName = road;
            }
        }
    } catch (e) {
    }

    if (isMultiStage) {
        const numStages = Math.max(0, totalWaypoints - 1);
        return `${numStages} ETAPAS: ${baseName}`;
    } else {
        return `  ${baseName}`;
    }
}


async function saveCurrentRoute() {
    if (navigationWaypoints.length < 2) {
        showToast("No hay ruta activa para guardar (se necesitan al menos 2 puntos)", "warning");
        return;
    }

    const isMultiStage = navigationWaypoints.length > 2;
    const lastWp = navigationWaypoints[navigationWaypoints.length - 1];
    let defaultRouteName = await getSuggestedRouteName(lastWp.lat, lastWp.lng, isMultiStage, navigationWaypoints.length);

    currentRouteNameForSaving = null;

    const existingModal = document.getElementById('save-route-prompt-modal');
    if (existingModal) existingModal.remove();

    const modal = document.createElement('div');
    modal.id = 'save-route-prompt-modal';
    modal.innerHTML = `
        <h2>Guardar Ruta</h2>
        <div class="modal-top-buttons">
            <button id="confirm-save-route">Guardar <span class="button-countdown-timer"></span></button>
            <button id="cancel-save-route">Cancelar</button>
        </div>
        <label for="route-name-input">Nombre de la Ruta:</label>
        <input type="text" id="route-name-input" value="${defaultRouteName.toUpperCase()}">
    `;
    document.body.appendChild(modal);

    const nameInput = modal.querySelector('#route-name-input');
    nameInput.style.textTransform = 'uppercase';
    const confirmButton = modal.querySelector('#confirm-save-route');
    const cancelButton = modal.querySelector('#cancel-save-route');
    nameInput.focus();
    const textLength = nameInput.value.length;
    nameInput.setSelectionRange(textLength, textLength);

    const closePrompt = () => {
        clearModalAutoCloseTimer(modal, confirmButton, 'save-route-prompt-modal');
        if (modal.parentNode) modal.remove();
    };

    const saveAction = () => {
        let routeName = nameInput.value.trim().toUpperCase();
        if (!routeName) {
            showToast("El nombre de la ruta no puede estar vacío", "warning");
            addModalAutoCloseTimer(modal, confirmButton, 'save-route-prompt-modal', 15000);
            return;
        }
        currentRouteNameForSaving = routeName;

        let waypointsToSave = navigationWaypoints.map(wp => (wp ? { id: wp.id, lat: wp.lat, lng: wp.lng, label:wp.label, type:wp.type, address: wp.address || '', visited: wp.visited || false, isCriticalForRecalc: wp.isCriticalForRecalc !== false, isInternal: wp.isInternal || false, isRecalculatedStart: wp.isRecalculatedStart || false } : null)).filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);

       if (waypointsToSave.length === 2 && !isMultiStage) {
            const startPoint = waypointsToSave.find(wp => wp.type === 'S');
            const endPoint = waypointsToSave.find(wp => wp.type === 'F');
            if (startPoint && endPoint) {
                 waypointsToSave = [endPoint];
            }
        }

        const routeToSave = {
            name: routeName,
            waypoints: waypointsToSave,
            createdAt: new Date().toISOString()
        };

        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        const existingRouteIndex = savedRoutes.findIndex(r => r.name === routeName);
        if (existingRouteIndex !== -1) {
            if (!confirm(`Ya existe una ruta llamada "${routeName}". ¿Sobreescribir?`)) {
                showToast("Guardado cancelado", "info");
                addModalAutoCloseTimer(modal, confirmButton, 'save-route-prompt-modal', 15000);
                return;
            }
            savedRoutes[existingRouteIndex] = routeToSave;
        } else {
            savedRoutes.push(routeToSave);
        }

        if (savedRoutes.length > MAX_SAVED_ROUTES) {
            savedRoutes.sort((a,b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
            savedRoutes = savedRoutes.slice(0, MAX_SAVED_ROUTES);
        }

        localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes));
        // Actualizamos el timestamp general porque se ha modificado la caché
        localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
        markCacheAsDirty(); 
        showToast(`Ruta "${routeName}" guardada`, "success");
        closePrompt();
    };

    confirmButton.addEventListener('click', saveAction);
    cancelButton.addEventListener('click', () => {
        closePrompt();
    });
    addModalAutoCloseTimer(modal, confirmButton, 'save-route-prompt-modal', 15000);
}

    
    
function showLoadRouteModal() {
    clearAllWaypointMarkersFromMap();
    if (navigationMapInstance) {
        if (navigationRouteLayer) navigationMapInstance.removeLayer(navigationRouteLayer);
        if (completedRouteSegmentsLayer) completedRouteSegmentsLayer.clearLayers();
    }
    navigationWaypoints = [];
    navigationRouteLayer = null;
    navigationCurrentRouteData = null;
    isNavigating = false;
    lastValidCarDistanceForDisplay = 0;
    tripInitialOverallEtaTime = null; currentStageInitialExpectedEtaTime = null; accumulatedDeviationMs = 0;
    accumulatedDistanceBeforeCurrentSegment = 0;
    totalDistanceTravelledForStats = 0;
    maxSpeedDuringTrip = 0; maxAltitudeDuringTrip = -Infinity; minAltitudeDuringTrip = Infinity;


    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    hideNavigationUI();
    hideMapInfoOverlay();

    eliminarRadaresDeRuta();
    actualizarContadorRadares(0);
    eliminarTareasDeBarraProgreso();
    actualizarContadorTareas(0);


    const existingModal = document.getElementById('saved-routes-modal');
    if (existingModal) existingModal.remove();

    const modal = document.createElement('div');
    modal.id = 'saved-routes-modal';
    modal.innerHTML = `
        <h2>Cargar/Borrar Rutas Guardadas (Máx. ${MAX_SAVED_ROUTES})</h2>
        <div class="modal-top-buttons" style="justify-content: flex-end;">
             <button id="close-saved-routes-modal" style="flex: 0 1 auto; min-width: 120px;">Cerrar</button>
        </div>
        <div class="filter-container">
            <input type="text" id="filter-saved-routes" placeholder="FILTRAR RUTAS...">
            <button id="clear-filter-saved-routes" title="Limpiar filtro">X</button>
        </div>
        <ul id="saved-routes-list"></ul>
    `;
    document.body.appendChild(modal);

    const listElement = modal.querySelector('#saved-routes-list');
    const closeButton = modal.querySelector('#close-saved-routes-modal');
    const filterInput = modal.querySelector('#filter-saved-routes');
    const clearFilterButton = modal.querySelector('#clear-filter-saved-routes');

    if(closeButton){
        closeButton.style.backgroundColor = '#4A5568';
        closeButton.style.color = 'white';
        closeButton.style.border = '1px solid #2D3748';
        closeButton.style.fontWeight = 'bold';
        closeButton.onmouseover = () => closeButton.style.backgroundColor = '#2D3748';
        closeButton.onmouseout = () => closeButton.style.backgroundColor = '#4A5568';
    }


    let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
    savedRoutes.sort((a,b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

    function displayRoutes(routesToDisplay) {
        listElement.innerHTML = '';
        if (routesToDisplay.length === 0) {
            listElement.innerHTML = '<li>No hay rutas que coincidan con el filtro.</li>';
        } else {
            routesToDisplay.forEach(route => {
                const li = document.createElement('li');
                li.textContent = route.name;
                li.dataset.routeName = route.name;

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Borrar';
                deleteBtn.className = 'delete-route-btn';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    let currentSavedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
                    currentSavedRoutes = currentSavedRoutes.filter(r => r.name !== route.name);
                    localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(currentSavedRoutes));
                    savedRoutes = currentSavedRoutes;
                    filterRoutes();
                    markCacheAsDirty()
                    showToast(`Ruta "${route.name}" borrada`, "info");
                };
                li.appendChild(deleteBtn);

                li.addEventListener('click', () => {
                    loadRouteByName(route.name, true);
                    clearModalAutoCloseTimer(modal, closeButton, 'saved-routes-modal');
                    if (modal.parentNode) modal.remove();
                });
                listElement.appendChild(li);
            });
        }
    }

    function filterRoutes() {
        const filterText = filterInput.value.toUpperCase().trim();
        if (!filterText) {
            displayRoutes(savedRoutes);
            clearFilterButton.style.display = 'none';
            return;
        }
        clearFilterButton.style.display = 'inline-block';
        const filtered = savedRoutes.filter(route => route.name.toUpperCase().includes(filterText));
        displayRoutes(filtered);
    }

    filterInput.addEventListener('input', filterRoutes);
    clearFilterButton.addEventListener('click', () => {
        filterInput.value = '';
        filterRoutes();
    });
    filterRoutes();

    const closeHandler = () => {
        clearModalAutoCloseTimer(modal, closeButton, 'saved-routes-modal');
        if (modal.parentNode) modal.remove();
    };
    closeButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(modal, closeButton, 'saved-routes-modal', 30000);
}






// Busca esta función en tu código y reemplázala por completo.
function loadRouteByName(routeName, autoStartNavigation = false) {
    const savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
    const routeToLoad = savedRoutes.find(r => r.name.toUpperCase() === routeName.toUpperCase());
    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');

    if (!routeToLoad) {
        showToast(`No se pudo cargar la ruta "${routeName}". No encontrada`, "error");
        if (radaresRutaCheckbox) {
           localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked));
        }
        if (tareasRutaCheckbox) {
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
        }
        return;
    }
    
    // --- INICIO DE LA MODIFICACIÓN ---
    // Limpiamos todos los elementos de la ruta anterior ANTES de cargar la nueva.
    clearAllWaypointMarkersFromMap();
    if (navigationMapInstance) {
        if (navigationRouteLayer) {
            try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch(e) {}
        }
        if (completedRouteSegmentsLayer) {
            completedRouteSegmentsLayer.clearLayers();
        }
    }
    navigationWaypoints = [];
    navigationRouteLayer = null;
    navigationCurrentRouteData = null;
    isNavigating = false;
    // Reseteamos todas las variables de estado de la navegación
    routeStartTime = null; 
    navigationStartTimeForStats = null; 
    totalDistanceTravelledForStats = 0; 
    lastPositionForStats = null;
    tripInitialOverallEtaTime = null; 
    currentStageInitialExpectedEtaTime = null; 
    accumulatedDeviationMs = 0;
    lastValidCarDistanceForDisplay = 0;
    accumulatedDistanceBeforeCurrentSegment = 0;
    maxSpeedDuringTrip = 0; 
    maxAltitudeDuringTrip = -Infinity; 
    minAltitudeDuringTrip = Infinity;
    if (compassAndModeControl) { 
        compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip); 
    }
    // Limpiamos los elementos de la barra de progreso
    eliminarRadaresDeRuta();
    actualizarContadorRadares(0);
    eliminarTareasDeBarraProgreso();
    actualizarContadorTareas(0);
    // Limpiamos la gráfica
    clearNavigationGraph();
    // --- FIN DE LA MODIFICACIÓN ---

    currentRouteNameForSaving = routeToLoad.name;

    const isSavedLocationRoute = routeToLoad.name.startsWith("UBICACIÓN: ");

    if (isSavedLocationRoute && routeToLoad.waypoints.length === 1 && navigationCurrentLocation) {
        const startPoint = {
            id: Date.now() -1,
            lat: navigationCurrentLocation.latitude,
            lng: navigationCurrentLocation.longitude,
            type: 'S',
            marker: null,
            label: 'S',
            address: 'Posición Actual (GPS)',
            visited: true,
            isCriticalForRecalc: true,
            isRecalculatedStart: false
        };
        navigationWaypoints.push(startPoint);
    }

    routeToLoad.waypoints.forEach(wpData => {
        if (wpData) {
            navigationWaypoints.push({
                id: wpData.id || Date.now() + Math.random(),
                lat: wpData.lat,
                lng: wpData.lng,
                type: wpData.type,
                label: wpData.label,
                marker: null,
                address: wpData.address || '',
                visited: wpData.visited || false,
                isCriticalForRecalc: wpData.isCriticalForRecalc !== false,
                isRecalculatedStart: false
            });
        }
    });

    if (navigationCurrentLocation && navigationWaypoints.length > 0) {
        const firstWp = navigationWaypoints[0];
        const distanceToFirstWp = calculateDistance(
            navigationCurrentLocation.latitude, navigationCurrentLocation.longitude,
            firstWp.lat, firstWp.lng
        );

        if (distanceToFirstWp < 15000) {
            if (firstWp.type === 'S') {
                navigationWaypoints.shift();
            }

            const newStartPoint = {
                id: Date.now() -1,
                lat: navigationCurrentLocation.latitude,
                lng: navigationCurrentLocation.longitude,
                type: 'S', marker: null, label: 'S',
                address: 'Posición Actual (GPS)',
                visited: true, isCriticalForRecalc: true,
                isRecalculatedStart: false
            };
            navigationWaypoints.unshift(newStartPoint);
        } else {
             const newStartPoint = {
                id: Date.now() -1,
                lat: navigationCurrentLocation.latitude,
                lng: navigationCurrentLocation.longitude,
                type: 'S', marker: null, label: 'S',
                address: 'Posición Actual (GPS)',
                visited: true, isCriticalForRecalc: true,
                isRecalculatedStart: false
            };
            navigationWaypoints.unshift(newStartPoint);
        }
    }

    updateWaypointTypesAndLabels();
    renderWaypointMarkers();

    if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2) {
        recalculateAndDrawRoute(false).then(() => {
            showToast(`Ruta "${routeToLoad.name}" cargada y recalculada`, "success");
            if (navigationMapInstance && navigationRouteLayer) {
                navigationMapInstance.fitBounds(navigationRouteLayer.getBounds().pad(0.1));
            }
             if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
                let carDistAlongRouteLoad = 0;
                const currentCarPosForLoad = navigationCurrentLocation;
                 if (currentCarPosForLoad && navigationMapInstance && navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
                    try {
                        const carPointTurf = turf.point([currentCarPosForLoad.longitude, currentCarPosForLoad.latitude]);
                        const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                        const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                        const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                        carDistAlongRouteLoad = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                    } catch (e) {  }
                 }
                updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], carDistAlongRouteLoad);
                updateTurnByTurnDisplay(navigationCurrentRouteData.routes[0], carDistAlongRouteLoad);
                showNavigationUIElementsForPlanning();

                if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                    toggleRadaresRuta(true);
                }
                 if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                    toggleTareasRuta(true);
                }

                if (autoStartNavigation) {
                    if (autoStartNavTimer) clearTimeout(autoStartNavTimer);
                    let countdown = 3;
                    const startNavToastId = `start-nav-toast-${Date.now()}`;
                    const updateNavToast = () => {
                        showToast(`Iniciando navegación automática en ${countdown} segundos... <button onclick="cancelAutoStartNav('${startNavToastId}')" style="background:rgba(255,255,255,0.2);border:1px solid white;padding:2px 5px;margin-left:10px;border-radius:3px;">Cancelar</button>`, 'info', countdown * 1000 + 500, false, startNavToastId);
                    };
                    updateNavToast();

                    autoStartNavTimer = setInterval(() => {
                        countdown--;
                        if (countdown > 0) {
                            updateNavToast();
                        } else {
                            clearInterval(autoStartNavTimer);
                            autoStartNavTimer = null;
                            const existingToast = document.getElementById(startNavToastId);
                            if (existingToast) existingToast.remove();

                            if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2 && !isNavigating) {
                                toggleNavigationState();
                            }
                        }
                    }, 1000);
                }
            }
        }).catch(error => {
            showToast(`Error al recalcular la ruta "${routeToLoad.name}": ${error.message}`, "error");
        });
    } else {
        showToast(`Ruta "${routeToLoad.name}" cargada (solo waypoints, no hay suficientes para una ruta)`, "info");
        hideNavigationUI();
         if (radaresRutaCheckbox) {
           localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked));
        }
         if (tareasRutaCheckbox) {
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
        }
    }

    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    actualizarContadorRadares(radaresEnRutaActual.length);
    actualizarContadorTareas(tareasEnRutaActual.length);
}






    
    

    
    
window.cancelAutoStartNav = function(toastId) {
    if (autoStartNavTimer) {
        clearInterval(autoStartNavTimer);
        autoStartNavTimer = null;
    }
    const existingToast = document.getElementById(toastId);
    if (existingToast) existingToast.remove();
    showToast("Inicio automático de navegación cancelado", "info");
};



    function handleDragEndReorder(e) {
        if (draggedStageLi) {
            draggedStageLi.classList.remove('dragging');
        }
        draggedStageLi = null;
    }

    function handleDragOverReorder(e) {
        e.preventDefault();
        if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';

        const listElement = document.getElementById('sortable-stages-list');
        if (!listElement || !draggedStageLi) return;

        const afterElement = getDragAfterElement(listElement, e.clientY);
        const currentLi = e.target.closest('li');
        if (draggedStageLi && currentLi && draggedStageLi !== currentLi) {
            if (afterElement == null) {
                listElement.appendChild(draggedStageLi);
            } else {
                listElement.insertBefore(draggedStageLi, afterElement);
            }
        } else if (draggedStageLi && !currentLi && afterElement == null) {
             listElement.appendChild(draggedStageLi);
        } else if (draggedStageLi && !currentLi && afterElement) {
             listElement.insertBefore(draggedStageLi, afterElement);
        }
    }

    let stageTouchStartX, stageTouchStartY, stageScrollTimeout;

 function showReorderStagesModal() {
    if (isNavigating) {
        showToast("No se puede reordenar etapas mientras se navega.", "warning");
        return;
    }
    const actualWaypointsForReorder = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    if (actualWaypointsForReorder.length < 2) {
        showToast("Se necesitan al menos 2 puntos para reordenar", "warning");
        return;
    }

    const modal = document.getElementById('reorder-stages-modal');
    if (!modal) {
        showToast("Error interno: No se pudo mostrar el modal de reordenamiento.", "error");
        return;
    }

    const listElement = modal.querySelector('#sortable-stages-list');
    if (!listElement) {
         showToast("Error interno: No se pudo encontrar la lista de etapas", "error");
         return;
    }
    listElement.innerHTML = '';

    actualWaypointsForReorder.forEach(async (wp) => {
        const li = document.createElement('li');
        li.dataset.id = wp.id;

        const dragHandle = document.createElement('span');
        dragHandle.className = 'drag-handle';
        dragHandle.innerHTML = '<img src="MOVER.PNG" alt="Mover etapa">';
        dragHandle.title = 'Arrastrar para reordenar';
        dragHandle.draggable = true;

        const badge = document.createElement('span');
        badge.className = 'stage-label-badge';
        badge.textContent = wp.label;

        const nameSpan = document.createElement('span');
        nameSpan.className = 'stage-name-text';
        nameSpan.textContent = wp.address || `Cargando dirección para (${wp.lat.toFixed(3)}, ${wp.lng.toFixed(3)})...`;
        if (!wp.address) {
             wp.address = await getAddressForWaypoint(wp.lat, wp.lng);
             nameSpan.textContent = wp.address;
        }

        const deleteButton = document.createElement('span');
        deleteButton.className = 'delete-stage-button';
        deleteButton.innerHTML = '×';
        deleteButton.title = 'Eliminar esta etapa';
        deleteButton.addEventListener('click', (e) => {
            e.stopPropagation();
            const listItem = e.target.closest('li');
            if (listItem) {
                const waypointIdToDelete = parseInt(listItem.dataset.id);

                const waypointIndexInNavigationArray = navigationWaypoints.findIndex(wp => wp && wp.id === waypointIdToDelete);
                if (waypointIndexInNavigationArray !== -1) {
                    const waypointObjectToDelete = navigationWaypoints[waypointIndexInNavigationArray];
                    if (waypointObjectToDelete.marker && navigationMapInstance) {
                        try {
                            navigationMapInstance.removeLayer(waypointObjectToDelete.marker);
                        } catch (mapError) {
                        }
                        waypointObjectToDelete.marker = null;
                    }
                }

                listItem.remove();

                navigationWaypoints = navigationWaypoints.filter(wayP => wayP.id !== waypointIdToDelete);
                updateWaypointTypesAndLabels();

                const remainingListItems = listElement.querySelectorAll('li');
                const currentActualWaypointsAfterDelete = navigationWaypoints.filter(w => w && !w.isInternal && !w.isRecalculatedStart);

                remainingListItems.forEach((remainingLi) => {
                     const currentWpIdInModal = parseInt(remainingLi.dataset.id);
                     const correspondingWp = currentActualWaypointsAfterDelete.find(w => w.id === currentWpIdInModal);
                     if(correspondingWp){
                        const badgeSpan = remainingLi.querySelector('.stage-label-badge');
                        if(badgeSpan) badgeSpan.textContent = correspondingWp.label;
                     }
                });

                const confirmBtn = modal.querySelector('#confirm-reorder-stages');
                const canConfirm = remainingListItems.length >= 2;
                if (confirmBtn) confirmBtn.disabled = !canConfirm;
                if (!canConfirm && remainingListItems.length > 0) {
                    showToast("Se necesitan al menos 2 puntos para una ruta.", "warning", 3000);
                } else if (remainingListItems.length === 0){
                    showToast("No quedan etapas. La ruta se eliminará al confirmar.", "info", 3000);
                }
            }
        });

        li.appendChild(dragHandle);
        li.appendChild(badge);
        li.appendChild(nameSpan);
        li.appendChild(deleteButton);
        listElement.appendChild(li);
    });

    modal.classList.remove('hidden');

    const confirmButton = modal.querySelector('#confirm-reorder-stages');
    const cancelButton = modal.querySelector('#cancel-reorder-stages');
    if (confirmButton) confirmButton.disabled = listElement.querySelectorAll('li').length < 2;


    const newConfirmButton = confirmButton.cloneNode(true);
    confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
    const newCancelButton = cancelButton.cloneNode(true);
    cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);


    const closeReorderModal = () => {
        clearModalAutoCloseTimer(modal, newConfirmButton, 'reorder-stages-modal');
        modal.classList.add('hidden');
        listElement.querySelectorAll('.drag-handle').forEach(handle => {
            handle.removeEventListener('dragstart', handleDragStartReorder);
            handle.removeEventListener('touchstart', handleStageTouchStart);
        });
        listElement.removeEventListener('dragend', handleDragEndReorder);
        listElement.removeEventListener('dragover', handleDragOverReorder);
        listElement.removeEventListener('touchmove', handleStageTouchMove);
        listElement.removeEventListener('touchend', handleStageTouchEnd);
        listElement.removeEventListener('touchcancel', handleStageTouchEnd);
        document.body.style.overflow = '';
    };

    newConfirmButton.addEventListener('click', async () => {
        const orderedLiElements = Array.from(listElement.children);
        const finalWaypointIds = orderedLiElements.map(li => parseInt(li.dataset.id));

        clearAllWaypointMarkersFromMap();

        if (finalWaypointIds.length < 2) {
            showToast("Se necesitan al menos 2 etapas para formar una ruta. Ruta actual eliminada.", "warning");
            navigationWaypoints = [];
            if (navigationRouteLayer && navigationMapInstance) {
                navigationMapInstance.removeLayer(navigationRouteLayer);
                navigationRouteLayer = null;
            }
            if (completedRouteSegmentsLayer && navigationMapInstance) completedRouteSegmentsLayer.clearLayers();
            navigationCurrentRouteData = null;
            updateStartNavigationButtonState();
            updateNavigationButtonColor();
            hideNavigationUI();
            hideMapInfoOverlay();
            eliminarRadaresDeRuta();
            actualizarContadorRadares(0);
             eliminarTareasDeBarraProgreso();
            actualizarContadorTareas(0);
            const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
            if (radaresCheckbox) {
                 localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckbox.checked));
            }
            const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
            if (tareasCheckbox) {
                localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckbox.checked));
            }
            closeReorderModal();
            return;
        }

        try {
            const newWaypointsOrdered = [];
            finalWaypointIds.forEach(id => {
                const foundWp = navigationWaypoints.find(wp => wp && wp.id === id);
                if(foundWp) newWaypointsOrdered.push(foundWp);
            });

            navigationWaypoints = newWaypointsOrdered;
            updateWaypointTypesAndLabels();
            renderWaypointMarkers();
            await recalculateAndDrawRoute();
            const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
            if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                toggleRadaresRuta(true);
            }
            const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
            if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                toggleTareasRuta(true);
            }
            showToast("Etapas reordenadas y ruta recalculada", "success");
        } catch (error) {
            showToast("Error recalculando ruta tras reordenar: " + error.message, "error");
        } finally {
             closeReorderModal();
             updateStartNavigationButtonState();
             updateNavigationButtonColor();
        }
    });


    newCancelButton.addEventListener('click', () => {
        showToast("Reordenación cancelada. Los marcadores eliminados se restaurarán al recalcular/cargar ruta.", "info");
        closeReorderModal();
        if (navigationWaypoints.length >= 2) {
            renderWaypointMarkers();
            recalculateAndDrawRoute().then(() => {
                const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
                if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                    toggleRadaresRuta(true);
                }
                 const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
                if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                    toggleTareasRuta(true);
                }
            });
        } else {
            clearAllWaypointMarkersFromMap();
            navigationWaypoints = [];
             if (navigationRouteLayer && navigationMapInstance) {
                navigationMapInstance.removeLayer(navigationRouteLayer);
                navigationRouteLayer = null;
            }
            if (completedRouteSegmentsLayer && navigationMapInstance) completedRouteSegmentsLayer.clearLayers();
            navigationCurrentRouteData = null;
            hideNavigationUI();
            hideMapInfoOverlay();
            eliminarRadaresDeRuta();
            actualizarContadorRadares(0);
            eliminarTareasDeBarraProgreso();
            actualizarContadorTareas(0);

            const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
            if (radaresCheckbox) {
                localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckbox.checked));
            }
             const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
            if (tareasCheckbox) {
                localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckbox.checked));
            }
        }
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
    });

    addModalAutoCloseTimer(modal, newConfirmButton, 'reorder-stages-modal', 60000);

    listElement.querySelectorAll('.drag-handle').forEach(handle => {
        handle.addEventListener('dragstart', handleDragStartReorder);
        handle.addEventListener('touchstart', handleStageTouchStart, { passive: false });
    });

    listElement.addEventListener('dragend', handleDragEndReorder);
    listElement.addEventListener('dragover', handleDragOverReorder);
    listElement.addEventListener('touchmove', handleStageTouchMove, { passive: false });
    listElement.addEventListener('touchend', handleStageTouchEnd);
    listElement.addEventListener('touchcancel', handleStageTouchEnd);
}

function handleDragStartReorder(e) {
    if (e.target.closest('.drag-handle')) { 
        draggedStageLi = e.target.closest('li');
        if (!draggedStageLi) return;

        setTimeout(() => {
            if (draggedStageLi) draggedStageLi.classList.add('dragging');
        }, 0);

        if (e.dataTransfer) {
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedStageLi.dataset.id);
        }
    } else {
        e.preventDefault();
    }
}

function handleStageTouchStart(e) {
    if (e.touches.length === 1 && e.target.closest('.drag-handle')) {
        draggedStageLi = e.target.closest('li');
        if (!draggedStageLi) return;

        const touch = e.touches[0];
        stageTouchStartX = touch.clientX;
        stageTouchStartY = touch.clientY;

        clearTimeout(stageScrollTimeout);
        stageScrollTimeout = setTimeout(() => {
            if (draggedStageLi) {
                draggedStageLi.classList.add('dragging');
                document.body.style.overflow = 'hidden';
            }
        }, 150);
    }
}

function handleStageTouchMove(e) {
        if (!draggedStageLi || e.touches.length !== 1) return;
        e.preventDefault();

        clearTimeout(stageScrollTimeout);
        if (!draggedStageLi.classList.contains('dragging')) {
            draggedStageLi.classList.add('dragging');
             document.body.style.overflow = 'hidden';
        }

        const touch = e.touches[0];
        const listElement = document.getElementById('sortable-stages-list');
        if (!listElement) return;

        const afterElement = getDragAfterElement(listElement, touch.clientY);
         if (afterElement == null) {
            listElement.appendChild(draggedStageLi);
        } else {
            listElement.insertBefore(draggedStageLi, afterElement);
        }
    }

    function handleStageTouchEnd(e) {
        clearTimeout(stageScrollTimeout);
        if (draggedStageLi) {
            draggedStageLi.classList.remove('dragging');
            draggedStageLi = null;
        }
        document.body.style.overflow = '';
    }


    function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('li:not(.dragging)')];
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }


    function showToast(message, type = 'info', duration = 3000, isErrorNotFound = false, toastId = null) {
        const uniqueToastId = toastId || 'toast-notification-element' + (type === 'debug' ? '-debug' : '') + `-${Date.now()}`;

        let currentTopOffset = 180;
        const toastSpacing = 10;

        activeToasts.forEach(activeToast => {
            const toastElement = document.getElementById(activeToast.id);
            if (toastElement) {
                 currentTopOffset += toastElement.offsetHeight + toastSpacing;
            }
        });

        const existingToast = document.getElementById(uniqueToastId);
        if (existingToast && !toastId) {
            existingToast.remove();
            activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
        } else if (existingToast && toastId) {
             existingToast.remove();
             activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);

             currentTopOffset = 180;
             activeToasts.forEach(activeToast => {
                const toastElement = document.getElementById(activeToast.id);
                if (toastElement) {
                    currentTopOffset += toastElement.offsetHeight + toastSpacing;
                }
             });
        }


        const toast = document.createElement('div');
        toast.id = uniqueToastId;
        toast.className = `toast-notification toast-${type}`;
        if (isErrorNotFound && type === 'error') {
            toast.classList.add('not-found');
        }

        const messageSpan = document.createElement('span');
        messageSpan.innerHTML = message.replace(/\n/g, '<br>');
        toast.appendChild(messageSpan);

        if (type === 'debug') {
            toast.style.top = 'auto';
            toast.style.bottom = '20px';
            toast.style.right = '20px';
            toast.style.left = 'auto';
            toast.style.transform = 'none';
            toast.style.maxWidth = 'calc(100% - 40px)';
            const closeButtonToast = document.createElement('button');
            closeButtonToast.textContent = 'Cerrar Info Debug';
            closeButtonToast.style.cssText = "display: block; margin-top: 10px; padding: 5px 10px; background-color: rgba(255,255,255,0.2); color: white; border: 1px solid white; border-radius: 3px; cursor: pointer;";
            closeButtonToast.onclick = () => {
                if (toast.parentNode) toast.parentNode.removeChild(toast);
                 activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
            };
            toast.appendChild(closeButtonToast);
        }

        toast.style.top = `${currentTopOffset}px`;

        document.body.appendChild(toast);
        activeToasts.push({ id: uniqueToastId, element: toast });


        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                toast.classList.add('show');
            });
        });

        if (duration > 0 && type !== 'debug') {
            setTimeout(() => {
                if (toast.classList.contains('show')) {
                    toast.classList.remove('show');
                    toast.addEventListener('transitionend', () => {
                         if (toast.parentNode) { toast.parentNode.removeChild(toast); }
                         activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
                    }, { once: true });
                } else {
                     if (toast.parentNode) { toast.parentNode.removeChild(toast); }
                     activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
                }
            }, duration);
        }
    }


    function formatDateToDDMMMYY(dateString) {
         if (!dateString) return '-';
         try {
             const [year, month, day] = dateString.split('-').map(Number);
             const date = new Date(Date.UTC(year, month - 1, day));
             if (isNaN(date.getTime())) return '-';

             const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
             const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
             const monthName = monthNames[date.getUTCMonth()];
             const yearShort = String(date.getUTCFullYear()).slice(-2);

             return `${dayOfMonth} ${monthName} ${yearShort}`;
         } catch (e) {
             return '-';
         }
    }
    function formatDateDetailed(dateString) {
        if (!dateString || !dateString.match(/^\d{4}-\d{2}-\d{2}$/)) return '-';
        try {
            const [year, month, day] = dateString.split('-').map(Number);
            const date = new Date(Date.UTC(year, month - 1, day));
            if (isNaN(date.getTime())) return dateString;

            const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
            const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
            const monthName = monthNames[date.getUTCMonth()];
            const fullYear = date.getUTCFullYear();

            return `${dayOfMonth}-${monthName}-${fullYear}`;
        } catch (e) {
            return dateString;
        }
    }
    function formatTimeWithPeriod(timeString) {
         if (!timeString || !timeString.match(/^\d{2}:\d{2}$/)) return '-';
         try {
             const [hourStr, minuteStr] = timeString.split(':');
             const hour = parseInt(hourStr);
             const minute = parseInt(minuteStr);
             if (isNaN(hour) || isNaN(minute) || hour < 0 || hour > 23 || minute < 0 || minute > 59) {
                 return timeString;
             }
             let period = '';
             if (hour >= 22 || hour < 5) { period = 'de la Noche'; }
             else if (hour >= 5 && hour < 12) { period = 'de la Mañana'; }
             else if (hour >= 12 && hour < 14) { period = 'del Mediodía'; }
             else { period = 'de la Tarde'; }

             return `${hourStr}:${minuteStr} (${period})`;
         } catch (e) {
             return timeString;
         }
    }

let globalModalTimers = {};


function addModalAutoCloseTimer(modalElement, closeButtonElement, modalId, duration = 60000) {
    if (!modalElement || !closeButtonElement || !modalId) {
        return;
    }
    modalElement.dataset.modalTimerId = modalId;

    clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId);

    let countdown = duration / 1000;
    const originalButtonText = closeButtonElement.textContent.split(' (')[0];
    const countdownSpanId = `modal-countdown-${modalId}`;
    let countdownSpan = closeButtonElement.querySelector(`.button-countdown-timer`);

    if (!countdownSpan) {
        countdownSpan = document.createElement('span');
        countdownSpan.className = 'button-countdown-timer';
        countdownSpan.style.marginLeft = '5px';
        countdownSpan.style.fontWeight = 'normal';
        closeButtonElement.appendChild(countdownSpan);
    }
    countdownSpan.textContent = ` (${countdown})`;

    const intervalId = setInterval(() => {
        countdown--;
        if (countdownSpan && document.body.contains(countdownSpan)) {
          countdownSpan.textContent = ` (${countdown})`;
        }
        if (countdown <= 0) {
            if (globalModalTimers[modalId]) {
                clearInterval(globalModalTimers[modalId].intervalId);
                delete globalModalTimers[modalId];
            }
            if (closeButtonElement && document.body.contains(closeButtonElement)) {
                closeButtonElement.click();
            } else if (modalElement && modalElement.parentNode) {
                 if (!STATIC_MODAL_IDS.includes(modalElement.id)) {
                    modalElement.parentNode.removeChild(modalElement);
                 } else {
                    modalElement.classList.add('hidden');
                 }
            }
        }
    }, 1000);

    const resetTimerHandler = () => {
        if (!globalModalTimers[modalId] || !globalModalTimers[modalId].intervalId) return;
        clearInterval(globalModalTimers[modalId].intervalId);
        countdown = duration / 1000;
        if (countdownSpan && document.body.contains(countdownSpan)) {
           countdownSpan.textContent = ` (${countdown})`;
        }
        const newIntervalId = setInterval(() => {
            countdown--;
            if (countdownSpan && document.body.contains(countdownSpan)) {
                countdownSpan.textContent = ` (${countdown})`;
            }
            if (countdown <= 0) {
                if (globalModalTimers[modalId]) {
                    clearInterval(globalModalTimers[modalId].intervalId);
                    delete globalModalTimers[modalId];
                }
                if (closeButtonElement && document.body.contains(closeButtonElement)) {
                    closeButtonElement.click();
                } else if (modalElement && modalElement.parentNode) {
                    if (!STATIC_MODAL_IDS.includes(modalElement.id)) {
                       modalElement.parentNode.removeChild(modalElement);
                    } else {
                       modalElement.classList.add('hidden');
                    }
                }
            }
        }, 1000);
        globalModalTimers[modalId].intervalId = newIntervalId;
    };

    modalElement.addEventListener('click', resetTimerHandler);
    modalElement.addEventListener('touchstart', resetTimerHandler, { passive: true });
    modalElement.addEventListener('input', resetTimerHandler);
    modalElement.addEventListener('scroll', resetTimerHandler, { passive: true });

    globalModalTimers[modalId] = {
        intervalId: intervalId,
        resetHandler: resetTimerHandler,
        modalElement: modalElement,
        closeButtonElement: closeButtonElement,
        countdownSpan: countdownSpan
    };
}

function clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId) {
    const timerIdToClear = modalId || (modalElement ? modalElement.dataset.modalTimerId : null);

    if (timerIdToClear && globalModalTimers[timerIdToClear]) {
        clearInterval(globalModalTimers[timerIdToClear].intervalId);
        const timerData = globalModalTimers[timerIdToClear];
        if (timerData.modalElement && timerData.resetHandler) {
            timerData.modalElement.removeEventListener('click', timerData.resetHandler);
            timerData.modalElement.removeEventListener('touchstart', timerData.resetHandler);
            timerData.modalElement.removeEventListener('input', timerData.resetHandler);
            timerData.modalElement.removeEventListener('scroll', timerData.resetHandler);
        }
        if (timerData.countdownSpan && timerData.countdownSpan.parentNode) {
            timerData.countdownSpan.remove();
        }
        delete globalModalTimers[timerIdToClear];
    }
    if(closeButtonElement){
        const orphanSpans = closeButtonElement.querySelectorAll('.button-countdown-timer');
        orphanSpans.forEach(s => s.remove());
    }
     if(modalElement && modalElement.dataset.modalTimerId) {
        delete modalElement.dataset.modalTimerId;
    }
}

    function saveUserData() {
        const userId = document.getElementById('user-id').value.trim();
        const teslaModel = document.getElementById('tesla-model').value.trim();
        const teslaYear = document.getElementById('tesla-year').value.trim();
        const teslaProvince = document.getElementById('tesla-province').value.trim();
        const allowDMs = document.getElementById('allow-dms').checked;
        const statusEl = document.getElementById('config-user-status');

        if (!userId) {
            statusEl.textContent = 'El ID de Usuario (Apodo) es obligatorio.';
            statusEl.style.color = '#EF4444';
            showToast('El ID de Usuario (Apodo) es obligatorio.', 'error');
            return;
        }

        localStorage.setItem('userData_userId', userId);
        localStorage.setItem('userData_teslaModel', teslaModel);
        localStorage.setItem('userData_teslaYear', teslaYear);
        localStorage.setItem('userData_teslaProvince', teslaProvince);
        localStorage.setItem('userData_allowDMs', JSON.stringify(allowDMs));
        updateUserIdDisplay();

        const cacheData = {};
        managedKeys.forEach(key => {
            const value = localStorage.getItem(key);
            if (value !== null) {
                if (!key.startsWith('userData_') && key !== 'userData_allowDMs') {
                     cacheData[key] = value;
                }
            }
        });
        const cacheDataString = JSON.stringify(cacheData);

        const formData = new FormData();
        formData.append('usuario', userId);
        formData.append('modelo', teslaModel);
        formData.append('anio', teslaYear);
        formData.append('provincia', teslaProvince);
        formData.append('rss', allowDMs.toString());
        formData.append('datosCache', cacheDataString);

        statusEl.textContent = 'Guardando datos en hoja de cálculo...';
        statusEl.style.color = '#17a2b8';
        showToast('Guardando en hoja de cálculo...', 'info', 0);

        const SCRIPT_URL = SCRIPT_URL_GDRIVE;

        fetch(SCRIPT_URL, {
            method: 'POST',
            body: formData
        })
        .then(response => {
            if (!response.ok) {
                return response.text().then(text => { throw new Error(text || response.statusText) });
            }
            return response.json();
        })
        .then(data => {
            activeToasts.forEach(t => { if (t.element.textContent.includes('Guardando en hoja de cálculo...')) t.element.remove(); });
            activeToasts = activeToasts.filter(t => !t.element.textContent.includes('Guardando en hoja de cálculo...'));

            if (data.status === "success") {
                statusEl.textContent = 'Datos guardados en hoja de cálculo y localmente. ' + (data.message || '');
                statusEl.style.color = '#28a745';
                showToast('Datos de usuario guardados en hoja de cálculo. ' + (data.message || ''), 'success');
            } else {
                statusEl.textContent = 'Error al guardar en hoja de cálculo: ' + (data.message || 'Error desconocido') + ' (Datos guardados localmente).';
                statusEl.style.color = '#EF4444';
                showToast('Error al guardar en hoja de cálculo: ' + (data.message || 'Error desconocido'), 'error');
            }
        })
        .catch(error => {
            activeToasts.forEach(t => { if (t.element.textContent.includes('Guardando en hoja de cálculo...')) t.element.remove(); });
            activeToasts = activeToasts.filter(t => !t.element.textContent.includes('Guardando en hoja de cálculo...'));
            statusEl.textContent = 'Error de red/script al guardar en hoja de cálculo: ' + error.message + ' (Datos guardados localmente).';
            statusEl.style.color = '#EF4444';
            showToast('Error de red/script al guardar en hoja de cálculo: ' + error.message, 'error');
        });
    }



    function resetUserData() {
        if (confirm('¿Estás seguro de que deseas resetear tus datos de usuario compartidos (los eliminará de la caché local y deberías eliminarlos manualmente de la hoja de cálculo si los enviaste)?')) {
            document.getElementById('user-id').value = '';
            document.getElementById('tesla-model').value = '';
            document.getElementById('tesla-year').value = '';
            document.getElementById('tesla-province').value = '';
            document.getElementById('allow-dms').checked = false;
            localStorage.removeItem('userData_userId');
            localStorage.removeItem('userData_teslaModel');
            localStorage.removeItem('userData_teslaYear');
            localStorage.removeItem('userData_teslaProvince');
            localStorage.removeItem('userData_allowDMs');
            updateUserIdDisplay();
            const statusEl = document.getElementById('config-user-status');
            statusEl.textContent = 'Datos de usuario reseteados.';
            statusEl.style.color = '#17a2b8';
            showToast('Datos de usuario reseteados', 'info');
        }
    }

    function generateBackup() {
        const backupData = {};
        managedKeys.forEach(key => {
            const value = localStorage.getItem(key);
            if (value !== null) {
                backupData[key] = value;
            }
        });
        const backupString = JSON.stringify(backupData);
        const backupDisplay = document.getElementById('config-backup-display');
        backupDisplay.value = btoa(unescape(encodeURIComponent(backupString)));
        backupDisplay.style.display = 'block';
        backupDisplay.select();
        try {
            document.execCommand('copy');
            showToast('Backup copiado al portapapeles', 'success');
             document.getElementById('config-backup-status').textContent = '¡Copiado! Guarda este código en un lugar seguro.';
             document.getElementById('config-backup-status').style.color = '#28a745';
        } catch (err) {
            showToast('Error al copiar. Por favor, copia manualmente', 'warning');
            document.getElementById('config-backup-status').textContent = 'Copia este código manualmente y guárdalo.';
            document.getElementById('config-backup-status').style.color = '#ffc107';
        }
    }

    function restoreBackup() {
        const restoreInput = document.getElementById('config-restore-input');
        const backupStringBase64 = restoreInput.value.trim();
        const statusEl = document.getElementById('config-restore-status');
        statusEl.textContent = '';

        if (!backupStringBase64) {
            statusEl.textContent = 'Pega el código de backup primero.';
            statusEl.style.color = '#EF4444';
            return;
        }

        try {
            const backupString = decodeURIComponent(escape(atob(backupStringBase64)));
            const backupData = JSON.parse(backupString);
            let restoredCount = 0;
            let incompatibleCount = 0;

            if (confirm('Esto sobreescribirá tus datos actuales con los del backup. ¿Estás seguro?')) {
                Object.keys(backupData).forEach(key => {
            
                    if (managedKeys.includes(key)) {
                        localStorage.setItem(key, backupData[key]);
                        restoredCount++;
                    } else {
                        incompatibleCount++;
                    }
                });

                loadCustomData();
                loadSavedSettings();
                updateUserIdDisplay();
                checkReminders();

                statusEl.textContent = `Restauración completada. ${restoredCount} claves restauradas. ${incompatibleCount} claves ignoradas (incompatibles). La página se recargará.`;
                statusEl.style.color = '#28a745';
                showToast('Restauración completada. Recargando...', 'success');
                setTimeout(() => location.reload(), 2500);
            } else {
                 statusEl.textContent = 'Restauración cancelada.';
                 statusEl.style.color = '#6c757d';
            }
        } catch (e) {
            statusEl.textContent = 'Error: Código de backup inválido o corrupto.';
            statusEl.style.color = '#EF4444';
            showToast('Error en el código de backup', 'error');
        }
    }

    function restoreOriginalGrid() {
        if (confirm('¿Restaurar el grid de botones a su estado original? Perderás tu personalización del grid (URLs, nombres, orden).')) {
            localStorage.removeItem('customGridData');
            localStorage.removeItem('gridFilterValue');
            loadCustomData();
            renderGrid();
            renderToggleButtons();
            loadSavedSettings();
            updateButtonStyles();
            filterGridItems();
            document.getElementById('config-restore-grid-status').textContent = 'Grid restaurado al original. Recargando...';
            document.getElementById('config-restore-grid-status').style.color = '#28a745';
            showToast('Grid restaurado. Recargando...', 'success');
            setTimeout(() => location.reload(), 1500);
        }
    }

    function clearAllLocalData() {
        if (confirm('¡ATENCIÓN! Esto borrará TODOS los datos locales (marcadores personalizados, recordatorios, configuración de usuario, PIN, etc.). Esta acción NO SE PUEDE DESHACER. ¿Estás seguro?')) {
            if (confirm('DE VERDAD, ¿ESTÁS COMPLETAMENTE SEGURO? SE BORRARÁ TODO.')) {
                managedKeys.forEach(key => localStorage.removeItem(key));
                localStorage.removeItem('personalizationHelpShown');
                localStorage.removeItem('gridFilterValue');
                showToast('Todos los datos locales borrados. Recargando...', 'success');
                setTimeout(() => location.reload(), 1500);
            } else {
                showToast('Borrado cancelado', 'info');
            }
        } else {
            showToast('Borrado cancelado', 'info');
        }
    }

    async function importRadars() {
        const latFilterValue = document.getElementById('radar-filter-lat').value.trim();
        const lonFilterValue = document.getElementById('radar-filter-lon').value.trim();
        const keywordsFilterRaw = document.getElementById('radar-filter-keywords').value.trim().toUpperCase();
        const keywordsFilter = keywordsFilterRaw ? keywordsFilterRaw.split(/\s+/).filter(k => k) : [];
        const importExtra = document.getElementById('import-extra-radars-checkbox').checked;

        const progressBar = document.getElementById('radar-import-progress-bar');
        const statusMessage = document.getElementById('radar-import-status');
        const progressContainer = document.getElementById('radar-import-progress-container');

        progressContainer.style.display = 'block';
        progressBar.value = 0;
        statusMessage.textContent = 'Iniciando importación...';
        statusMessage.style.color = '';

        try {
            let filesToProcess = await fetchKMLFilesList(KML_FILES_LIST_STANDARD);
            if (importExtra) {
                const extraFiles = await fetchKMLFilesList(KML_FILES_LIST_EXTRA);
                filesToProcess = filesToProcess.concat(extraFiles.filter(f => !filesToProcess.includes(f)));
            }

            if (filesToProcess.length === 0) {
                statusMessage.textContent = 'No se encontraron listas de archivos KML para procesar.';
                progressBar.value = 100;
                showToast('No hay archivos KML en las listas.', 'warning');
                setTimeout(() => { progressContainer.style.display = 'none'; }, 3000);
                return;
            }

            statusMessage.textContent = `Encontrados ${filesToProcess.length} archivos KML. Procesando...`;
            let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
            let newRadarsCount = 0;
            let totalFilesProcessed = 0;

            for (const kmlFileName of filesToProcess) {
                try {
                    statusMessage.textContent = `Procesando ${kmlFileName}... (${totalFilesProcessed + 1}/${filesToProcess.length})`;
                    const placemarks = await fetchAndParseKML(KML_BASE_PATH + kmlFileName);

                    placemarks.forEach(placemark => {
                        const name = placemark.name.toUpperCase();
                        const coords = placemark.coordinates;

                        const matchesKeywords = keywordsFilter.length === 0 || keywordsFilter.some(kw => name.includes(kw));

                        if (coords && matchesKeywords) {
                            const [lonStr, latStr] = coords.split(',');
                            const lon = parseFloat(lonStr);
                            const lat = parseFloat(latStr);

                            if (isNaN(lat) || isNaN(lon)) return;
                            const matchesLat = parseCoordinateFilter(latFilterValue, lat);
                            const matchesLon = parseCoordinateFilter(lonFilterValue, lon);

                            if (matchesLat && matchesLon) {
                                const existingRadar = reminders.find(r =>
                                    r.isLocationEnabled &&
                                    r.locationCoordinates &&
                                    Math.abs(r.locationCoordinates.latitude - lat) < COORD_EPSILON &&
                                    Math.abs(r.locationCoordinates.longitude - lon) < COORD_EPSILON &&
                                    (r.text.toUpperCase().includes("RADAR:") || r.excludeFromList)
                                );

    
                                    if (!existingRadar) {
                                    const now = new Date();
                                    const newRadar = {
                                        id: Date.now() + Math.random() + newRadarsCount,
                                        text: `<b>RADAR: ${placemark.name}</b>`,
                                        type: 'simple',
                                        time: '00:01',
                                        date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                                        createdAt: now.toISOString(),
                                        managedByUser: false,
                                        isLocationEnabled: true,
                                        locationCoordinates: { latitude: lat, longitude: lon },
                                        radiusMeters: 400,
                                        excludeFromList: true
                                    };
                                    reminders.push(newRadar);
                                    newRadarsCount++;
                                }
                            }
                        }
                    });
                } catch (fileError) {
                    statusMessage.textContent = `Error en ${kmlFileName}: ${fileError.message}. Continuando...`;
                    statusMessage.style.color = 'orange';
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
                totalFilesProcessed++;
                progressBar.value = (totalFilesProcessed / filesToProcess.length) * 100;
            }


localStorage.setItem('reminders', JSON.stringify(reminders));
            statusMessage.textContent = `Importación completa. ${newRadarsCount} nuevos radares/POIs añadidos.`;
            statusMessage.style.color = '#28a745';
            showToast(`${newRadarsCount} nuevos radares/POIs añadidos.`, 'success');
            updateReminderCount();
            updateButtonStyles();
            checkReminders();

        } catch (error) {
            statusMessage.textContent = `Error general: ${error.message}`;
            statusMessage.style.color = 'red';
            showToast('Error durante la importación.', 'error');
        } finally {
             setTimeout(() => {
                progressContainer.style.display = 'none';
                statusMessage.style.color = '';
            }, 5000);
        }
    }

    async function fetchKMLFilesList(listUrl) {
        try {
            const response = await fetch(listUrl, { cache: 'no-cache' });
            if (!response.ok) throw new Error(`Error HTTP ${response.status} obteniendo lista KML: ${listUrl}`);
            const text = await response.text();
            return text.split('\n').map(f => f.trim()).filter(f => f.length > 0 && f.toLowerCase().endsWith('.kml'));
        } catch (error) {
            showToast(`Error cargando lista ${listUrl.split('/').pop()}`, 'error');
            return [];
        }
    }

  async function fetchAndParseKML(kmlFileUrl) {
        try {
            const response = await fetch(kmlFileUrl, { cache: 'no-cache' });
            if (!response.ok) throw new Error(`Error HTTP ${response.status} obteniendo KML: ${kmlFileUrl}`);

            const buffer = await response.arrayBuffer();
            const decoder = new TextDecoder('iso-8859-1');
            const kmlText = decoder.decode(buffer);

            return parseKML(kmlText);
        } catch (error) {
            throw error;
        }
    }

    function parseKML(kmlText) {
        const placemarks = [];
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(kmlText, "application/xml");

        const parserErrorNode = xmlDoc.querySelector("parsererror");
        if (parserErrorNode) {
            let errorMessage = "Error de parseo XML desconocido.";
            if (parserErrorNode.textContent) {
                const match = parserErrorNode.textContent.match(/error on line \d+ at column \d+: ([^\n]+)/);
                if (match && match[1]) {
                    errorMessage = match[1];
                } else {
                    errorMessage = parserErrorNode.textContent.split('\n')[0] || parserErrorNode.textContent;
                }
            } else if (parserErrorNode.innerText) {
                 errorMessage = parserErrorNode.innerText.split('\n')[0] || parserErrorNode.innerText;
            }
            throw new Error("KML parsing error: " + errorMessage);
        }

        const KML_NS_GOOGLE = "http://earth.google.com/kml/2.0";
        const KML_NS_OGC = "http://www.opengis.net/kml/2.2";

        let placemarkNodes = xmlDoc.getElementsByTagNameNS(KML_NS_GOOGLE, 'Placemark');
        if (placemarkNodes.length === 0) {
            placemarkNodes = xmlDoc.getElementsByTagNameNS(KML_NS_OGC, 'Placemark');
        }
         if (placemarkNodes.length === 0) {
            placemarkNodes = xmlDoc.getElementsByTagName('Placemark');
        }

        for (let i = 0; i < placemarkNodes.length; i++) {
            const node = placemarkNodes[i];
            let nameNode, coordinatesNode;

            nameNode = node.getElementsByTagNameNS(KML_NS_GOOGLE, 'name')[0] || node.getElementsByTagNameNS(KML_NS_OGC, 'name')[0] || node.getElementsByTagName('name')[0];
            coordinatesNode = node.getElementsByTagNameNS(KML_NS_GOOGLE, 'coordinates')[0] || node.getElementsByTagNameNS(KML_NS_OGC, 'coordinates')[0] || node.getElementsByTagName('coordinates')[0];

            if (nameNode && coordinatesNode) {
                const name = nameNode.textContent.trim();
                const coordinatesRaw = coordinatesNode.textContent.trim();
                const coordPartsMatch = coordinatesRaw.match(/^(-?\d+\.?\d*)[,\s]+(-?\d+\.?\d*)/);

                if (name && coordPartsMatch && coordPartsMatch.length >= 3) {
                    const lonStr = coordPartsMatch[1];
                    const latStr = coordPartsMatch[2];
                    const coordinates = `${lonStr},${latStr}`;

                    const lon = parseFloat(lonStr);
                    const lat = parseFloat(latStr);

                    if (!isNaN(lon) && !isNaN(lat)) {
                        if (name.startsWith("Radares BBS www.laradiobbs.net") && lon === 0 && lat === 0) {
                            continue;
                        }
                        placemarks.push({ name, coordinates });
                    }
                }
            }
        }
        return placemarks;
    }

    async function deleteFilteredRadars() {
        const latFilterValue = document.getElementById('radar-filter-lat').value.trim();
        const lonFilterValue = document.getElementById('radar-filter-lon').value.trim();
        const keywordsFilterRaw = document.getElementById('radar-filter-keywords').value.trim().toUpperCase();
        const keywordsFilter = keywordsFilterRaw ? keywordsFilterRaw.split(/\s+/).filter(k => k) : [];

        const statusMessage = document.getElementById('radar-import-status');
        const progressContainer = document.getElementById('radar-import-progress-container');

        const noFiltersProvided = !latFilterValue && !lonFilterValue && keywordsFilter.length === 0;
        let confirmationMessage = "";

        if (noFiltersProvided) {
            confirmationMessage = "¿Estás seguro de que quieres borrar TODOS los recordatorios tipo RADAR/POI (ya que no has especificado ningún filtro)? Esta acción no se puede deshacer.";
        } else {
            confirmationMessage = "¿Estás seguro de que quieres borrar los recordatorios tipo RADAR/POI que coincidan con los filtros actuales? Esta acción no se puede deshacer.";
        }

        if (!confirm(confirmationMessage)) {
            showToast("Borrado cancelado", "info");
            return;
        }

        progressContainer.style.display = 'block';
        const progressBar = document.getElementById('radar-import-progress-bar');
        if(progressBar) progressBar.style.display = 'none';
        statusMessage.textContent = 'Borrando recordatorios...';
        statusMessage.style.color = '';

        try {
            let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
            let originalLength = reminders.length;

            reminders = reminders.filter(r => {
                const isRadarType = r.isLocationEnabled && (r.text.toUpperCase().includes("RADAR:") || r.excludeFromList);
                if (!isRadarType) return true;

                if (noFiltersProvided) {
                    return false;
                }

                let matchesKeywords = true;
                if (keywordsFilter.length > 0) {
                    matchesKeywords = keywordsFilter.some(kw => r.text.toUpperCase().includes(kw));
                }

                let matchesLat = true;
                if (latFilterValue) {
                    if (r.locationCoordinates) {
                        matchesLat = parseCoordinateFilter(latFilterValue, r.locationCoordinates.latitude);
                    } else {
                        matchesLat = false;
                    }
                }

                let matchesLon = true;
                if (lonFilterValue) {
                    if (r.locationCoordinates) {
                        matchesLon = parseCoordinateFilter(lonFilterValue, r.locationCoordinates.longitude);
                    } else {
                        matchesLon = false;
                    }
                }

                return !(matchesKeywords && matchesLat && matchesLon);
            });

            localStorage.setItem('reminders', JSON.stringify(reminders));
            const numDeleted = originalLength - reminders.length;
            statusMessage.textContent = `Borrado completo. ${numDeleted} recordatorios eliminados.`;
            statusMessage.style.color = '#28a745';
            showToast(`${numDeleted} recordatorios eliminados`, 'success');
            updateReminderCount();
            updateButtonStyles();
            checkReminders();

        } catch (error) {
            statusMessage.textContent = `Error: ${error.message}`;
            statusMessage.style.color = 'red';
            showToast('Error durante el borrado', 'error');
        } finally {
            setTimeout(() => {
                progressContainer.style.display = 'none';
                if(progressBar) progressBar.style.display = 'block';
                statusMessage.style.color = '';
            }, 3000);
        }
    }
    function actualizarContadorRadares(count) {
        const contadorElement = document.getElementById('radares-ruta-count');
        if (contadorElement) {
            contadorElement.textContent = count;
            const checkbox = document.getElementById('radares-ruta-checkbox');
            contadorElement.classList.toggle('hidden', count === 0 && (!checkbox || !checkbox.checked));
        }
    }
     function actualizarContadorTareas(count) {
        const contadorElement = document.getElementById('tareas-ruta-count');
        if (contadorElement) {
            contadorElement.textContent = count;
            const checkbox = document.getElementById('tareas-ruta-checkbox');
            contadorElement.classList.toggle('hidden', count === 0 && (!checkbox || !checkbox.checked));
        }
    }


    async function toggleRadaresRuta(activo) {
        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);

        localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(activo));

        if (actualWaypoints.length < 2) {
            if (activo) {
                showToast("Ruta inválida o inexistente. No se pueden buscar radares.", "warning");
            }
            eliminarRadaresDeRuta();
            actualizarContadorRadares(0);
            return;
        }

        eliminarRadaresDeRuta();
        radaresEnRutaActual = [];

        if (activo && navigationMapInstance && navigationRouteLayer) {
            try {
                const routeLineString = turf.lineString(navigationRouteLayer.getLatLngs().map(latlng => [latlng.lng, latlng.lat]));
                let filesToProcess = await fetchKMLFilesList(KML_FILES_LIST_STANDARD);
                const extraFiles = await fetchKMLFilesList(KML_FILES_LIST_EXTRA);
                filesToProcess = filesToProcess.concat(extraFiles.filter(f => !filesToProcess.includes(f)));

                for (const kmlFileName of filesToProcess) {
                    const placemarks = await fetchAndParseKML(KML_BASE_PATH + kmlFileName);
                    placemarks.forEach(placemark => {
                        const coords = placemark.coordinates;
                        if (coords) {
                            const [lonStr, latStr] = coords.split(',');
                            const lon = parseFloat(lonStr);
                            const lat = parseFloat(latStr);
                            if (isNaN(lat) || isNaN(lon)) return;

                            const radarPoint = turf.point([lon, lat]);
                            const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, radarPoint, { units: 'meters' });

                            if (nearestPointOnRoute && nearestPointOnRoute.properties.dist !== undefined && nearestPointOnRoute.properties.dist <= RUTA_RADAR_PROXIMITY_THRESHOLD) {
                                const existingMapObject = reminderMapObjects.find(obj =>
                                    obj.isFromRuta &&
                                    Math.abs(obj.marker.getLatLng().lat - lat) < COORD_EPSILON &&
                                    Math.abs(obj.marker.getLatLng().lng - lon) < COORD_EPSILON
                                );

                                if (!existingMapObject) {
                                    const now = new Date();
                                    const radarData = {
                                        id: Date.now() + Math.random() + radaresEnRutaActual.length,
                                        text: `<b>RADAR RUTA: ${placemark.name}</b>`,
                                        type: 'simple', time: '00:00',
                                        date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                                        createdAt: now.toISOString(),
                                        managedByUser: false, isLocationEnabled: true,
                                        locationCoordinates: { latitude: lat, longitude: lon },
                                        radiusMeters: 600, excludeFromList: true,
                                        isFromRuta: true,
                                        distanceOnRoute: nearestPointOnRoute.properties.location
                                    };
                                    const mapObject = plotSingleReminderOnMap(radarData, navigationMapInstance);
                                    if (mapObject) {
                                        reminderMapObjects.push(mapObject);
                                        radaresEnRutaActual.push(radarData);
                                    }
                                }
                            }
                        }
                    });
                }

                if (radaresEnRutaActual.length === 0 && activo) {
                }
            } catch (error) {
            }
        }
        actualizarContadorRadares(radaresEnRutaActual.length);
        if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
            updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
        }
        if (radaresRutaCheckbox) {
            radaresRutaCheckbox.checked = activo;
        }
    }

    async function toggleTareasRuta(activo) {
        const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
        const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);

        localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(activo));

        if (actualWaypoints.length < 2) {
            if (activo) {
                showToast("Ruta inválida o inexistente. No se pueden buscar tareas en ruta.", "warning");
            }
            eliminarTareasDeBarraProgreso();
            actualizarContadorTareas(0);
            return;
        }

        eliminarTareasDeBarraProgreso();
        tareasEnRutaActual = [];

        if (activo && navigationMapInstance && navigationRouteLayer) {
            try {
                const routeLineString = turf.lineString(navigationRouteLayer.getLatLngs().map(latlng => [latlng.lng, latlng.lat]));
                const allReminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const locationReminders = allReminders.filter(r => r.isLocationEnabled && r.locationCoordinates);

                locationReminders.forEach(reminder => {
                    const taskPoint = turf.point([reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]);
                    const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, taskPoint, { units: 'meters' });
                    const radius = reminder.radiusMeters || DEFAULT_LOCATION_RADIUS;

                    if (nearestPointOnRoute && nearestPointOnRoute.properties.dist !== undefined && nearestPointOnRoute.properties.dist <= radius) {
                        tareasEnRutaActual.push({
                            ...reminder,
                            distanceOnRoute: nearestPointOnRoute.properties.location
                        });
                    }
                });
            } catch (error) {
                 showToast("Error al procesar tareas en ruta: " + error.message, "error");
            }
        }
        actualizarContadorTareas(tareasEnRutaActual.length);
        if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
            updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
        }
        if (tareasRutaCheckbox) {
            tareasRutaCheckbox.checked = activo;
        }
    }


    function eliminarRadaresDeRuta() {
        reminderMapObjects = reminderMapObjects.filter(obj => {
            if (obj.isFromRuta) {
                if (obj.marker && navigationMapInstance && navigationMapInstance.hasLayer(obj.marker)) obj.marker.remove();
                if (obj.circle && navigationMapInstance && navigationMapInstance.hasLayer(obj.circle)) obj.circle.remove();
                return false;
            }
            return true;
        });
        radaresEnRutaActual = [];
        actualizarContadorRadares(0);
        if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
             updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
        }
    }

    function eliminarTareasDeBarraProgreso() {
        tareasEnRutaActual = [];
        actualizarContadorTareas(0);
        if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
            updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
        }
    }


    function showSimulationModal() {
        const canSimulate = (navigationWaypoints.filter(wp => !wp.isInternal && !wp.isRecalculatedStart).length >= 2 && navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) ||
                        (isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]);

        if (!canSimulate) {
            showToast("Se necesitan al menos 2 puntos y una ruta calculada para mostrar las intersecciones.", "warning");
            return;
        }

        const route = navigationCurrentRouteData.routes[0];
        if (!route || !route.legs || route.legs.length === 0) {
            showToast("Datos de ruta incompletos para mostrar intersecciones.", "error");
            return;
        }
        closeOtherModals('simulation-modal');

        let carDist = lastCarDistanceAlongRouteForNavLogic;
        let simulationContent = "<ul>";

        let stepsShown = 0;
        let currentStageNumber = 1;
        let displayedStageHeader = false;
        let firstVisibleLegIndex = isNavigating ? currentLegIndexNav : 0;
        let firstVisibleStepIndex = isNavigating ? currentStepIndexNav : 0;

        for (let legIdx = firstVisibleLegIndex; legIdx < route.legs.length; legIdx++) {
            const leg = route.legs[legIdx];
            if (!leg || !leg.steps) continue;
            let startStepThisLegLoop = (legIdx === firstVisibleLegIndex) ? firstVisibleStepIndex : 0;
            if (!displayedStageHeader || legIdx > firstVisibleLegIndex) {
                 const stageAddress = navigationWaypoints[legIdx + 1] ? navigationWaypoints[legIdx+1].address : "";
                 const stageDistance = leg.distance ? (leg.distance / 1000).toFixed(1) + " km" : "Dist. desc.";
                 simulationContent += `<li style="background-color: #e0e0e0; font-weight: bold; padding: 5px; margin-top:5px;">ETAPA ${currentStageNumber}: ${stageAddress} (Total ${stageDistance})</li>`;
                 currentStageNumber++;
                 displayedStageHeader = true;
                 if (legIdx > firstVisibleLegIndex) displayedStageHeader = false;
            }
            for (let stepIdx = startStepThisLegLoop; stepIdx < leg.steps.length; stepIdx++) {
                const step = leg.steps[stepIdx];
                if (!step || !step.maneuver) continue;
                const distanceToEndOfThisStep = calculateDistanceToEndOfStep(route, legIdx, stepIdx);


                 const distanceToThisStepManeuver = Math.max(0, distanceToEndOfThisStep - carDist);
                 if (distanceToEndOfThisStep > carDist || (legIdx === route.legs.length - 1 && stepIdx === leg.steps.length - 1 && distanceToThisStepManeuver <= 10) ) {
                    const maneuver = step.maneuver;
                    const type = maneuver.type || '';
                    const modifier = maneuver.modifier || '';
                    let iconHtmlSim = '';

                    const roundaboutExitTypesSim = ['roundabout turn', 'exit roundabout', 'rotary', 'roundabout'];
                    if (roundaboutExitTypesSim.includes(type) && maneuver.exit && maneuver.exit >= 1 && maneuver.exit <= 5 && getManeuverInstructionText(maneuver).toLowerCase().includes("salida")) {
                        iconHtmlSim = `<img src="./S${maneuver.exit}.PNG" alt="Salida ${maneuver.exit}" style="width:24px; height:24px; object-fit:contain;">`;
                    } else {
                        const iconSpan = document.createElement('span');
                        iconSpan.className = `leaflet-routing-icon ${getLrmIconClass(maneuver)}`;
                        iconHtmlSim = iconSpan.outerHTML;
                    }
                    const maneuverText = getManeuverInstructionText(maneuver);
                    let streetNameText = step.name || '';
                    if (type === 'arrive' || type === 'depart' || type === 'end of road' || type === 'roundabout' || type === 'rotary') {
                        streetNameText = '';
                    } else if (streetNameText.toLowerCase() === 'continúa' && maneuverText.toLowerCase() !== 'continúa') {
                        streetNameText = '';
                    }
                    let displayText = `${maneuverText}`;
                    if (streetNameText) {
                        displayText += ` <strong>${streetNameText}</strong>`;
                    }
                    let distanceFormatted = '';
                    if (distanceToThisStepManeuver >= 1000) {
                        distanceFormatted = `${(distanceToThisStepManeuver / 1000).toFixed(1)} km`;
                    } else {
                        distanceFormatted = `${Math.round(distanceToThisStepManeuver)} m`;
                    }
                    simulationContent += `<li data-leg-index="${legIdx}" data-step-index="${stepIdx}" style="cursor:pointer;"><span class="turn-icon-sim">${iconHtmlSim}</span> <span>${displayText} (${distanceFormatted})</span></li>`;
                    stepsShown++;
                    if (stepsShown >= 15 && isNavigating) break;
                }
            }
            if (stepsShown >= 15 && isNavigating) break;
        }
        simulationContent += "</ul>";
        if (stepsShown === 0) {
            simulationContent = "<p>No hay más interacciones futuras en la ruta o estás muy cerca del final.</p>";
        }

        let modal = document.getElementById('simulation-modal');
        let closeButton;

        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'simulation-modal';
            modal.innerHTML = `
                <h2 style="font-size: 1.3rem; font-weight: bold; text-align: center; margin-bottom: 1rem; color: #333;">Maniobras de la Ruta</h2>
                <div class="modal-top-buttons" style="justify-content: flex-start; margin-bottom: 1rem;">
                    <button id="close-simulation-modal" style="flex: 0 0 auto; width: auto; min-width: unset;">Salir <span class="button-countdown-timer"></span></button>
                </div>
                <div id="simulation-content-area"></div>
            `;
            document.body.appendChild(modal);
            closeButton = modal.querySelector('#close-simulation-modal');
        } else {
            closeButton = modal.querySelector('#close-simulation-modal');
            if (!closeButton) {
                const headerContainer = modal.querySelector('.modal-top-buttons');
                if (headerContainer) {
                     headerContainer.innerHTML = `<button id="close-simulation-modal" style="flex: 0 0 auto; width: auto; min-width: unset;">Salir <span class="button-countdown-timer"></span></button>`;
                } else {
                    const headerHtml = `
                        <h2 style="font-size: 1.3rem; font-weight: bold; text-align: center; margin-bottom: 1rem; color: #333;">Maniobras Ruta</h2>
                        <div class="modal-top-buttons" style="justify-content: flex-start; margin-bottom: 1rem;">
                            <button id="close-simulation-modal" style="flex: 0 0 auto; width: auto; min-width: unset;">Salir <span class="button-countdown-timer"></span></button>
                        </div>`;
                    const contentAreaRef = modal.querySelector('#simulation-content-area');
                    modal.innerHTML = headerHtml + (contentAreaRef ? contentAreaRef.outerHTML : '<div id="simulation-content-area"></div>');
                }
                closeButton = modal.querySelector('#close-simulation-modal');
            }
        }

        if (!closeButton) {
            return;
        }

        const closeSimulationModalHandler = () => {
            if (simulationModalTimer) clearTimeout(simulationModalTimer);
            clearModalAutoCloseTimer(modal, closeButton, 'simulation-modal');
            modal.classList.add('hidden');
            hideIntersectionPreviewMap();
        };

        if (closeButton.handlerAttached !== closeSimulationModalHandler) {
            if(closeButton.handlerAttached) closeButton.removeEventListener('click', closeButton.handlerAttached);
            closeButton.addEventListener('click', closeSimulationModalHandler);
            closeButton.handlerAttached = closeSimulationModalHandler;
        }

        const contentArea = modal.querySelector('#simulation-content-area');
        if(contentArea) {
            contentArea.innerHTML = simulationContent;
            contentArea.removeEventListener('click', handleSimulationItemClick);
            contentArea.addEventListener('click', handleSimulationItemClick);
        } else {
        }

        if (modal.classList.contains('hidden')) {
            modal.classList.remove('hidden');
        }
        addModalAutoCloseTimer(modal, closeButton, 'simulation-modal', 50000);

        if (simulationModalTimer) clearTimeout(simulationModalTimer);
        simulationModalTimer = setTimeout(() => {
            const currentSimModal = document.getElementById('simulation-modal');
            if (currentSimModal && !currentSimModal.classList.contains('hidden')) {
                 const simCloseBtn = currentSimModal.querySelector('#close-simulation-modal');
                 if(simCloseBtn) simCloseBtn.click();
            }
        }, 50000);
    }

    function handleSimulationItemClick(event) {
        const listItem = event.target.closest('li[data-leg-index][data-step-index]');
        if (!listItem) {
            return;
        }

        if (!navigationCurrentRouteData || !navigationCurrentRouteData.routes || navigationCurrentRouteData.routes.length === 0) {
            showToast("No hay datos de ruta actuales para mostrar el detalle de la maniobra.", "warning", 3000);
            return;
        }

        const legIndex = parseInt(listItem.dataset.legIndex);
        const stepIndex = parseInt(listItem.dataset.stepIndex);

        const route = navigationCurrentRouteData.routes[0];
        if (route.legs && legIndex < route.legs.length && route.legs[legIndex].steps && stepIndex < route.legs[legIndex].steps.length) {
            const step = route.legs[legIndex].steps[stepIndex];
            showIntersectionPreviewMap(step, route, true, 7000);
        } else {
            showToast("No se pudo encontrar la maniobra seleccionada en los datos de la ruta.", "error", 3000);
            hideIntersectionPreviewMap();
        }
    }



    function showMapInfoOverlay(message, isError = false) {
        const overlay = document.getElementById('map-info-overlay');
        if (overlay) {
            let finalMessage = message;
            if (message.startsWith(" ")) {
                const destName = message.substring(" ".length).trim().replace(/<br>/gi, ' ');
                finalMessage = " " + (destName.length > 55 ? destName.substring(0, 52) + "..." : destName);
            } else if (message.startsWith("ETAPA ")) {
                const stageInfo = message.substring("ETAPA ".length).trim().replace(/<br>/gi, ' ');
                finalMessage = "ETAPA " + (stageInfo.length > 55 ? stageInfo.substring(0, 52) + "..." : stageInfo);
            // --- INICIO DE LA CORRECCIÓN ---
            } else if (message.startsWith("HA LLEGADO AL ")) {
                const destinationName = message.substring("HA LLEGADO AL : ".length).trim().replace(/<br>/gi, ' ');
                // Acortamos el nombre del  si es muy largo
                finalMessage = "HA LLEGADO A SU : " + (destinationName.length > 55 ? destinationName.substring(0, 52) + "..." : destinationName);
            }
            // --- FIN DE LA CORRECCIÓN ---
            overlay.innerHTML = `<span>${finalMessage}</span>`;
            overlay.style.display = 'block';
            overlay.style.backgroundColor = isError ? 'rgba(220, 50, 50, 0.5)' : 'rgba(0,0,0,0.5)';
        }
    }




    
    function hideMapInfoOverlay() {
        const overlay = document.getElementById('map-info-overlay');
        if (overlay) {
            overlay.textContent = '';
            overlay.style.display = 'none';
        }
    }



 function showDestinationName() {
    if (!navigationWaypoints || navigationWaypoints.length === 0) {
        hideMapInfoOverlay();
        return;
    }

    let message = "";
    let nextUnvisitedStageWp = null;

    if (isNavigating) {
        // CAMBIO: Obtenemos el número total de etapas (legs) y la etapa actual.
        const totalEtapas = navigationCurrentRouteData?.routes?.[0]?.legs?.length || 0;
        const etapaActualUsuario = currentLegIndexNav + 1;

        // La lógica para encontrar el siguiente punto de ruta no cambia.
        for(let i = currentLegIndexNav; i < navigationWaypoints.length; i++) {
            const waypointToCheck = navigationWaypoints[i];
            if (waypointToCheck && !waypointToCheck.isInternal && !waypointToCheck.visited && waypointToCheck.type !== 'S' && waypointToCheck.type !== 'S_Recalc') {
                nextUnvisitedStageWp = waypointToCheck;
                break;
            }
        }
         if (!nextUnvisitedStageWp && navigationWaypoints.length > 0) {
            const lastWaypoint = navigationWaypoints[navigationWaypoints.length -1];
            if (lastWaypoint.type === 'F' && !lastWaypoint.visited) {
                 nextUnvisitedStageWp = lastWaypoint;
            }
        }

        if (nextUnvisitedStageWp) {
            // CAMBIO: Se ajusta el mensaje según si es una etapa intermedia o la final.
            if (nextUnvisitedStageWp.type === 'F') {
                // Si es la última etapa (destino final), se muestra como antes.
                message = ` ${nextUnvisitedStageWp.address || ' Final'}`;
            } else if (nextUnvisitedStageWp.type === 'intermediate' && totalEtapas > 1) {
                // Si es una etapa intermedia, se usa el nuevo formato "ETAPA X de Y".
                message = `ETAPA ${etapaActualUsuario} de ${totalEtapas}: ${nextUnvisitedStageWp.address || `Etapa ${nextUnvisitedStageWp.label}`}`;
            } else {
                 // Fallback para otros casos.
                 message = ` ${nextUnvisitedStageWp.address || 'Siguiente Punto'}`;
            }
        } else {
            // Si no hay más etapas, mostramos el destino final.
            const finalDestination = navigationWaypoints[navigationWaypoints.length - 1];
            if (finalDestination && !finalDestination.isInternal) {
                 message = ` ${finalDestination.address || ' Final'}`;
            } else {
                 message = "RUTA NO DEFINIDA";
            }
        }
    } else {
        // Comportamiento cuando no se está navegando (sin cambios).
        const finalDestination = navigationWaypoints[navigationWaypoints.length - 1];
        if (finalDestination && !finalDestination.isInternal) {
             message = ` ${finalDestination.address || ' Final'}`;
        } else {
             message = "RUTA NO DEFINIDA";
        }
    }
    
    showMapInfoOverlay(message);
}   
    


    
let locationsPreviewMap = null;
 

            



    
/**
 * Muestra el modal de desvío con lógica mejorada, incluyendo la opción de "No dar la vuelta"
 * y la identificación completa de las etapas.
 */
function showDeviationModal() {
    closeOtherModals('deviation-modal');
    isDeviationModalActive = true;

    let modal = document.getElementById('deviation-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'deviation-modal';
        document.body.appendChild(modal);
    }

    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    const totalStagesInRoute = actualWaypoints.length > 1 ? actualWaypoints.length - 1 : 0;

    // --- CASO ESPECIAL: RUTA SIMPLE (SOLO INICIO Y FIN) ---
    if (actualWaypoints.length === 2) {
        let countdown = 5;
        modal.innerHTML = `
            <style>
                 #deviation-modal { position: fixed; top: 10px; left: 10px; transform: none; max-width: 450px; }
                 #deviation-modal button { background-color: #007bff; color: white; padding: 12px 20px; border: none; border-radius: 5px; font-size: 1.1rem; font-weight: bold; cursor: pointer; }
                 #deviation-modal h2 { font-size: 1.4rem; margin-bottom: 10px; }
                 #deviation-modal p { font-size: 1.1rem; line-height: 1.4; }
            </style>
            <h2>Desvío Detectado</h2>
            <p id="deviation-modal-message">Se ha detectado un desvío de la ruta. Se recalculará automáticamente la ruta hacia el destino final.</p>
            <div style="margin-top:15px;">
                <button id="deviation-primary">Recalculando...</button>
            </div>`;

        const primaryButton = modal.querySelector('#deviation-primary');
        const updateButtonText = () => {
            if (primaryButton) primaryButton.textContent = `Recalculando... (${countdown})`;
        };
        updateButtonText();

        if (deviationModalTimerId) clearInterval(deviationModalTimerId);
        deviationModalTimerId = setInterval(() => {
            countdown--;
            if (countdown >= 0) {
                updateButtonText();
            }
            if (countdown < 0) {
                closeModalAndProceed('recalculate_forward');
            }
        }, 1000);

        primaryButton.addEventListener('click', () => closeModalAndProceed('recalculate_forward'));
        modal.classList.remove('hidden');
        addModalAutoCloseTimer(modal, primaryButton, 'deviation-modal', (countdown + 2) * 1000);
        return;
    }

    // --- LÓGICA PARA RUTAS CON ETAPAS ---
    let stagesLeftBehind = [];
    const getSummarizedAddress = (address) => {
        if (!address) return "la etapa";
        const parts = address.split(',');
        return parts[0].trim();
    };

    if (navigationCurrentLocation && typeof navigationCurrentLocation.heading === 'number') {
        const currentHeading = navigationCurrentLocation.heading;
        actualWaypoints.forEach(wp => {
            if (wp.visited || wp.type === 'S' || wp.type === 'S_Recalc') return;
            const bearingToWp = turf.bearing(
                turf.point([navigationCurrentLocation.longitude, navigationCurrentLocation.latitude]),
                turf.point([wp.lng, wp.lat])
            );
            let angleDiff = Math.abs(currentHeading - (bearingToWp < 0 ? bearingToWp + 360 : bearingToWp));
            if (angleDiff > 180) angleDiff = 360 - angleDiff;
            if (angleDiff > 110) { stagesLeftBehind.push(wp); }
        });
    }

    let message = "", primaryButtonText = "", secondaryButtonText = "", tertiaryButtonText = "";
    let showSecondaryButton = false, showTertiaryButton = false;
    let defaultAction = 'recalculate_forward';

    if (stagesLeftBehind.length > 1) {
        defaultAction = 'recalculate_turn_back'; // Default es volver
        const firstSkippedStage = stagesLeftBehind[0];
        const firstSkippedStageLabel = `ETAPA ${firstSkippedStage.label} de ${totalStagesInRoute}: ${getSummarizedAddress(firstSkippedStage.address)}`;
        message = `PARECE QUE TE HAS SALTADO <strong>${stagesLeftBehind.length} ETAPAS</strong>. ¿Qué deseas hacer?`;
        primaryButtonText = `IR A LA PRIMERA ETAPA ATRÁS (${firstSkippedStageLabel})`;
        secondaryButtonText = `NO DAR LA VUELTA (Saltar las ${stagesLeftBehind.length} etapas)`;
        showSecondaryButton = true;
    } else if (stagesLeftBehind.length === 1) {
        defaultAction = 'recalculate_turn_back'; // Default es volver
        const skippedWp = stagesLeftBehind[0];
        const skippedStageLabel = `ETAPA ${skippedWp.label} de ${totalStagesInRoute}`;
        message = `TE HAS PASADO LA ETAPA:<br><strong>${skippedStageLabel}: ${getSummarizedAddress(skippedWp.address)}</strong>`;
        primaryButtonText = `IR A ETAPA (DAR LA VUELTA)`;
        secondaryButtonText = `NO DAR LA VUELTA (Saltar esta etapa)`;
        showSecondaryButton = true;
    } else {
        defaultAction = 'recalculate_forward';
        const nextUnvisitedWp = actualWaypoints.find(wp => !wp.visited && wp.type !== 'S' && wp.type !== 'S_Recalc');
        message = "TE HAS DESVIADO de la ruta. ¿Continuamos recalculando?";
        primaryButtonText = "RECALCULAR A LA SIGUIENTE ETAPA";
        if (nextUnvisitedWp) {
            const nextStageLabel = `ETAPA ${nextUnvisitedWp.label} de ${totalStagesInRoute}`;
            secondaryButtonText = `SALTAR PRÓXIMA ETAPA (${nextStageLabel}: ${getSummarizedAddress(nextUnvisitedWp.address)})`;
            showSecondaryButton = true;
        }
    }

    modal.innerHTML = `
        <style>
            #deviation-modal { position: fixed; top: 10px; left: 10px; transform: none; max-width: 450px; }
            #deviation-modal button { background-color: #007bff; color: white; padding: 12px 20px; border: none; border-radius: 5px; font-size: 1.1rem; font-weight: bold; cursor: pointer; transition: background-color 0.2s ease; }
            #deviation-modal button:hover { background-color: #0056b3; }
            #deviation-modal button#deviation-secondary { background-color: #ffc107; color: #212529; }
            #deviation-modal button#deviation-secondary:hover { background-color: #e0a800; }
            #deviation-modal h2 { font-size: 1.4rem; margin-bottom: 10px; }
            #deviation-modal p { font-size: 1.1rem; line-height: 1.4; }
        </style>
        <h2>Desvío Detectado</h2>
        <p id="deviation-modal-message">${message}</p>
        <div style="display:flex; flex-direction: column; align-items: stretch; gap:10px; margin-top:15px;">
            <button id="deviation-primary">${primaryButtonText}</button>
            ${showSecondaryButton ? `<button id="deviation-secondary">${secondaryButtonText}</button>` : ''}
        </div>
    `;

    const primaryButton = modal.querySelector('#deviation-primary');
    const secondaryButton = modal.querySelector('#deviation-secondary');
    let countdown = 10;

    const updatePrimaryButtonText = () => {
        if (primaryButton) primaryButton.textContent = `${primaryButtonText} (${countdown})`;
    };
    updatePrimaryButtonText();

    if (deviationModalTimerId) clearInterval(deviationModalTimerId);
    deviationModalTimerId = setInterval(() => {
        countdown--;
        if (countdown >= 0) updatePrimaryButtonText();
        if (countdown < 0) closeModalAndProceed(defaultAction);
    }, 1000);

    primaryButton.addEventListener('click', () => {
        if (stagesLeftBehind.length >= 1) closeModalAndProceed('recalculate_turn_back');
        else closeModalAndProceed('recalculate_forward');
    });

    if (secondaryButton) {
        secondaryButton.addEventListener('click', () => {
            if (stagesLeftBehind.length > 1) closeModalAndProceed('skip_multiple');
            else if (stagesLeftBehind.length === 1) closeModalAndProceed('skip_one');
            else closeModalAndProceed('skip_one');
        });
    }

    modal.classList.remove('hidden');
    addModalAutoCloseTimer(modal, primaryButton, 'deviation-modal', (countdown + 2) * 1000);

    if (navigationMapInstance && navigationRouteLayer?.getBounds().isValid()) {
        const allBounds = L.latLngBounds(navigationRouteLayer.getBounds());
        if (navigationCurrentLocation) allBounds.extend([navigationCurrentLocation.latitude, navigationCurrentLocation.longitude]);
        navigationMapInstance.fitBounds(allBounds.pad(0.2), { animate: true, duration: 0.8 });
    }
}





    




    


    



    
    
function initializeNavigationGraph() {
    const graphCard = document.getElementById('navigation-graph-card');
    const graphContainer = document.getElementById('navigation-graph-container');
    const graphTitleElement = document.getElementById('navigation-graph-title');

    if (!graphCard || !graphContainer || !graphTitleElement || !isNavigating || currentGraphMode === 'Gráfica off') {
        if (graphCard) graphCard.classList.add('hidden');
        if (navigationChart) { navigationChart.destroy(); navigationChart = null; }
        return;
    }

    graphCard.classList.remove('hidden');
    
    const compassElement = document.querySelector('.leaflet-control-orientation-altitude');
    graphCard.style.height = compassElement ? (compassElement.offsetHeight + 'px') : '157px';

    isCarStoppedForGraph = false;
    graphDataPoints = { speed: [], altitude: [] };
    graphLabels = [];
    graphPlotState = { 
        lastPlotTime: Date.now(), 
        lastPlotCoords: navigationCurrentLocation ? { ...navigationCurrentLocation } : null 
    };

    if (navigationChart) {
        navigationChart.destroy();
        navigationChart = null;
    }

    const ctx = document.getElementById('navigation-chart')?.getContext('2d');
    if (!ctx || !ctx.canvas) {
        showToast("Error crítico: Canvas para gráfica no encontrado.", "error");
        if (graphCard) graphCard.classList.add('hidden');
        return;
    }
    
    const canvasWidth = ctx.canvas.clientWidth;
    const maxPoints = Math.floor(canvasWidth / GRAPH_PIXELS_PER_DATAPOINT);
    const targetPointsForEta = Math.floor(maxPoints * (1 - GRAPH_BUFFER_PERCENTAGE));

    const initialRouteDurationSec = navigationCurrentRouteData?.routes?.[0]?.duration || 0;
    
    if (initialRouteDurationSec > 0 && targetPointsForEta > 0) {
        graphIntervalDuration = (initialRouteDurationSec * 1000) / targetPointsForEta;
    } else {
        graphIntervalDuration = 30000; 
    }
    
    const initialRouteDistance = navigationCurrentRouteData?.routes?.[0]?.distance || 0;
    graphExpectedAvgSpeed = (initialRouteDurationSec > 0 && initialRouteDistance > 0) ? (initialRouteDistance / initialRouteDurationSec) * 3.6 : 0;
    
    navigationChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'Dato', data: [], // Color inicial neutro, se ajusta en updateChartData
                    borderColor: 'rgba(75, 192, 192, 1)', // Ejemplo, se sobrescribe
                    backgroundColor: 'rgba(75, 192, 192, 0.2)', // Ejemplo, se sobrescribe
                    tension: 0.1, yAxisID: 'yPrimary', pointRadius: 0, order: 2,
                    fill: false // 'fill' se ajustará a 'origin' para la Altitud, o true/false para ETA
                },
                { // Dataset para el relleno de Altitud hasta el eje Y=0
                    label: 'Área Desnivel', data: [],
                    borderColor: 'rgba(255, 165, 0, 0.5)', 
                    backgroundColor: 'rgba(255, 165, 0, 0.2)', 
                    fill: 'origin', // Rellena hasta el eje Y=0
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: true, order: 3 // Oculto por defecto
                },
                {
                    label: 'Referencia', data: [], borderColor: 'white',
                    borderWidth: 2, fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 1
                },
                {
                    label: 'Media/Min', data: [], borderColor: '#D9EF9F',
                    borderWidth: 1.5, borderDash: [5, 5], fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 0
                },
                {
                    label: 'Máxima', data: [], borderColor: '#FFA420',
                    borderWidth: 1.5, borderDash: [5, 5], fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 0
                }
            ]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            layout: {
                padding: { top: 5, bottom: 2, left: 0, right: 2 }
            },
            scales: {
                x: { type: 'category', ticks: { display: false }, grid: { drawOnChartArea: false } },
                yPrimary: {
                    type: 'linear', position: 'left',
                    grace: '5%',
                    min: 0, // Asegura que el eje Y siempre empiece en 0
                    ticks: { color: 'white', font: { size: 11 }, callback: (v) => Math.round(Number(v)).toString() },
                    grid: { color: 'rgba(255,255,255,0.1)' }, title: { display: false }
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: { 
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) { label += ': '; }
                            if (context.parsed.y !== null) {
                                label += context.parsed.y.toFixed(1);
                                if (currentGraphMode === 'Desviación ETA') label += ' km/h';
                                else if (currentGraphMode === 'Altitud') label += ' m';
                            }
                            return label;
                        }
                    }
                 }
            },
            animation: { duration: 250 }
        }
    });

    startGraphIntervalTimer();
    updateNavigationGraphVisibilityAndMode();
}



    
    

function updateChartData() {
    if (!navigationChart) return;

    const graphCard = document.getElementById('navigation-graph-card');
    const isEnlarged = graphCard ? graphCard.classList.contains('enlarged') : false;

    const valueStyle = "font-size: 1.2em; opacity: 1.0; line-height: 1.4; font-weight: bold; text-align: right; padding-right: 22px;";
    
    const etaColor = "white";
    const avgColor = "#D9EF9F";
    const maxColor = "#FFA420";

    const mainDataset = navigationChart.data.datasets[0]; // El dataset principal
    const altitudeFillDataset = navigationChart.data.datasets[1]; // El nuevo dataset para el relleno de altitud
    const referenceDataset = navigationChart.data.datasets[2]; // Antes era [1]
    const avgSpeedOrMinAltitudeDataset = navigationChart.data.datasets[3]; // Antes era [2]
    const maxSpeedOrMaxAltitudeDataset = navigationChart.data.datasets[4]; // Antes era [3]


    if (currentGraphMode === 'Desviación ETA') {
        navigationChart.options.scales.yPrimary.ticks.callback = function(value) { return Math.round(value) + ' km/h'; };
        navigationChart.options.scales.yPrimary.min = 0; 

        mainDataset.borderColor = 'rgba(129, 216, 208, 1)'; 
        mainDataset.backgroundColor = 'rgba(37, 99, 235, 0.2)';
        mainDataset.fill = true; // Rellena el área bajo la línea

        altitudeFillDataset.hidden = true; 
        altitudeFillDataset.data = []; 

        const allRelevantSpeedValues = [
            ...(graphDataPoints.speed.length > 0 ? graphDataPoints.speed : [0]),
            maxSpeedDuringTrip || 0,
            graphExpectedAvgSpeed || 0
        ];
        const timeSinceStartMs = navigationStartTimeForStats ? Date.now() - navigationStartTimeForStats.getTime() : Infinity;
        if (timeSinceStartMs > 60000) {
            allRelevantSpeedValues.push(window.averageSpeedKmh || 0);
        }
        const currentMaxDataValue = Math.max(...allRelevantSpeedValues);
        
        const yAxisMax = Math.min(250, Math.max(50, currentMaxDataValue + 15));
        navigationChart.options.scales.yPrimary.max = yAxisMax;

        const targetTickCount = isEnlarged ? 30 : 10;
        const yAxisRange = yAxisMax - 0; 
        const rawStep = yAxisRange > 0 ? yAxisRange / targetTickCount : 10;
        const niceIntervals = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50];
        let stepSize = niceIntervals[niceIntervals.length - 1];
        for (const interval of niceIntervals) {
            if (rawStep <= interval) { stepSize = interval; break; }
        }
        navigationChart.options.scales.yPrimary.ticks.stepSize = stepSize;
        
        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            const etaVal = (graphExpectedAvgSpeed || 0).toFixed(1);
            const avgVal = (window.averageSpeedKmh || 0).toFixed(1);
            const maxVal = (maxSpeedDuringTrip || 0).toFixed(1);

            graphTitleElement.innerHTML = `
                <span style="font-size: 0.7em;">DATOS ETA</span> 
                <small style="${valueStyle}">
                    <span style="color:${etaColor};">ETA: ${etaVal}</span> 
                    <span style="color:${avgColor};">   |  Med: ${avgVal}</span> 
                    <span style="color:${maxColor};">   |  Máx: ${maxVal}Km/h</span>
                </small>`;
        }

        mainDataset.data = graphDataPoints.speed;
        mainDataset.label = 'Velocidad';
        referenceDataset.data = graphLabels.map(() => graphExpectedAvgSpeed);
        referenceDataset.label = 'Velocidad ETA';
        avgSpeedOrMinAltitudeDataset.data = graphLabels.map(() => window.averageSpeedKmh || 0);
        avgSpeedOrMinAltitudeDataset.label = 'Media del Viaje';
        maxSpeedOrMaxAltitudeDataset.data = graphLabels.map(() => maxSpeedDuringTrip || 0);
        maxSpeedOrMaxAltitudeDataset.label = 'Máxima del Viaje';

    } else if (currentGraphMode === 'Altitud') {
        navigationChart.options.scales.yPrimary.ticks.callback = function(value) { return Math.round(value) + ' m'; };
        navigationChart.options.scales.yPrimary.max = undefined;
        navigationChart.options.scales.yPrimary.min = undefined;

        // Colores para Altitud (anaranjado)
        mainDataset.borderColor = 'rgba(129, 216, 208, 1)'; 
        mainDataset.backgroundColor = 'rgba(255, 165, 0, 0.2)';
        mainDataset.fill = false; // El relleno lo hará el dataset específico de área
        
        // Configura el dataset para el relleno de área hasta Y=0
        altitudeFillDataset.data = graphDataPoints.altitude;
        altitudeFillDataset.hidden = false; 

        const targetTickCountAlt = isEnlarged ? 15 : 8;
        const altitudeValues = graphDataPoints.altitude.length > 0 ? graphDataPoints.altitude : [0];
        const minAlt = Math.min(...altitudeValues);
        const maxAlt = Math.max(...altitudeValues);
        const altRange = maxAlt - minAlt;
        if (altRange > 0) {
            const rawStepAlt = altRange / targetTickCountAlt;
            const niceIntervalsAlt = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 100, 200, 500];
            let stepSizeAlt = niceIntervalsAlt[niceIntervalsAlt.length - 1];
            for (const interval of niceIntervalsAlt) { if(rawStepAlt <= interval) { stepSizeAlt = interval; break; } }
            navigationChart.options.scales.yPrimary.ticks.stepSize = stepSizeAlt;
        } else {
             navigationChart.options.scales.yPrimary.ticks.stepSize = undefined;
        }
        
        const altitudePoints = graphDataPoints.altitude;
        const avgAltitudeValue = altitudePoints.length > 0 ? altitudePoints.reduce((a, b) => a + b, 0) / altitudePoints.length : 0;
        
        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            const maxAltVal = (maxAltitudeDuringTrip !== -Infinity ? maxAltitudeDuringTrip : 0).toFixed(0);
            const avgAltVal = avgAltitudeValue.toFixed(0);
            const minAltVal = (minAltitudeDuringTrip !== Infinity ? minAltitudeDuringTrip : 0).toFixed(0);

            graphTitleElement.innerHTML = `
                
                <span style="font-size: 0.7em;">DESNIVEL RUTA</span>
                <small style="${valueStyle}">
                    <span style="color:${maxColor};">Máx: ${maxAltVal}</span> 
                    <span style="color:${etaColor};">   |  Med: ${avgAltVal}</span> 
                    <span style="color:${avgColor};">   |  Mín: ${minAltVal}m</span>
                </small>`;
        }

        mainDataset.data = graphDataPoints.altitude;
        mainDataset.label = 'Altitud';
        referenceDataset.data = graphLabels.map(() => avgAltitudeValue);
        referenceDataset.label = 'Media';
        avgSpeedOrMinAltitudeDataset.data = graphLabels.map(() => minAltitudeDuringTrip !== Infinity ? minAltitudeDuringTrip : null);
        avgSpeedOrMinAltitudeDataset.label = 'Mínima';
        maxSpeedOrMaxAltitudeDataset.data = graphLabels.map(() => maxAltitudeDuringTrip !== -Infinity ? maxAltitudeDuringTrip : null);
        maxSpeedOrMaxAltitudeDataset.label = 'Máxima';
    }
    
    navigationChart.data.labels = graphLabels; 
    navigationChart.update('none');
}



    


    

    

function plotIntervalData() {
    if (!isNavigating || !navigationChart || !graphPlotState.lastPlotCoords || !navigationCurrentLocation) {
        return;
    }

    // --- INICIO DE LA NUEVA LÓGICA ---
    const currentSpeed = window.currentSpeedKmh || 0;
    const isCurrentlyStopped = currentSpeed < 1; // Umbral para considerar el coche parado (ej. < 1 km/h)

    if (isCurrentlyStopped) {
        // El coche está parado.
        if (isCarStoppedForGraph) {
            // Ya estamos en modo "parado" y ya hemos dibujado el último punto. No hacemos nada más.
            return;
        }
        // Si llegamos aquí, es la primera vez que detectamos la parada.
        // Permitiremos que el código de abajo se ejecute UNA VEZ MÁS para registrar el final del tramo.
    } else {
        // El coche se está moviendo.
        if (isCarStoppedForGraph) {
            // Si antes estábamos parados, reseteamos el estado para que vuelva a dibujar.
            isCarStoppedForGraph = false;
        }
    }
    // --- FIN DE LA NUEVA LÓGICA ---

    const currentTime = Date.now();
    const timeDiffSeconds = (currentTime - graphPlotState.lastPlotTime) / 1000;

    if (timeDiffSeconds < 1) return;

    const distanceMeters = calculateDistance(
        graphPlotState.lastPlotCoords.latitude, graphPlotState.lastPlotCoords.longitude,
        navigationCurrentLocation.latitude, navigationCurrentLocation.longitude
    );
    
    const avgSpeedKmh = (timeDiffSeconds > 0) ? (distanceMeters / timeDiffSeconds) * 3.6 : 0;
    const currentAltitude = navigationCurrentLocation.altitude || 0;
    const timeLabel = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    
    graphLabels.push(timeLabel);
    graphDataPoints.speed.push(avgSpeedKmh);
    graphDataPoints.altitude.push(currentAltitude);

    updateChartData();

    graphPlotState.lastPlotTime = currentTime;
    graphPlotState.lastPlotCoords = { ...navigationCurrentLocation };
    
    // --- LÓGICA FINAL ---
    // Si el coche está parado, después de dibujar este último punto, activamos el flag.
    if (isCurrentlyStopped) {
        isCarStoppedForGraph = true;
    }
}

    







/**
 * Descarga y aplica silenciosamente la caché desde Firebase.
 * Diseñada para el usuario móvil al iniciar la app. No recarga la página.
 */
async function restoreCacheForMobile() {
    const { primaryId } = parseUserId(localStorage.getItem('userData_userId'));
    if (!primaryId) return;

    const result = await callFirebase('getUserData', { userId: primaryId });

    if (result.status === 'success' && result.data) {
        const backupCacheData = result.data.contenidoCacheCompleto;
        if (backupCacheData) {
            showToast('Sincronizando datos desde la nube...', 'info', 2000);
            const currentUserIdentity = localStorage.getItem('userData_userId');
            for (const key in backupCacheData) {
                if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                    localStorage.setItem(key, backupCacheData[key]);
                }
            }
            if (currentUserIdentity) {
                localStorage.setItem('userData_userId', currentUserIdentity);
            }
            // Actualizamos la caché local con los datos frescos antes de renderizar
            loadCustomData();
            loadSavedSettings();
            updateUserIdDisplay();
            checkReminders();
        }
    }
}






    



    



async function initializeApp() {
    loadCustomData();
    loadSavedSettings();

    const { isMobile, primaryId } = parseUserId(localStorage.getItem('userData_userId'));

    if (isMobile && primaryId) {
        await restoreCacheForMobile();
    } else {
        await syncDataOnLoad();
    }
    
    lastMobileSyncTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');

    const shouldDirectToNav = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
    const tempPreventDirectNav = sessionStorage.getItem(TEMP_PREVENT_DIRECT_NAV_KEY);

    if (shouldDirectToNav && !tempPreventDirectNav) {
        sessionStorage.setItem('isInDirectToMapMode', 'true');
        directToNavOnLoad = true;
        const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'none';
        const footerContent = document.querySelector('footer'); if (footerContent) footerContent.style.display = 'none';
        const noticesIconContainer = document.querySelector('.notices-icon-container'); if (noticesIconContainer) noticesIconContainer.style.display = 'none';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'none');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'none');
        document.getElementById('grid-filter-container').style.display = 'none';
        createOtherButtons();
        renderToggleButtons();
        openNavigationMap();
    } else {
        sessionStorage.removeItem('isInDirectToMapMode');
        directToNavOnLoad = false;
        const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'block';
        const footerContent = document.querySelector('footer'); if (footerContent) footerContent.style.display = 'block';
        const noticesIconContainer = document.querySelector('.notices-icon-container'); if (noticesIconContainer) noticesIconContainer.style.display = 'flex';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'flex');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'block');
        document.getElementById('grid-filter-container').style.display = 'flex';
        renderGrid();
        createOtherButtons();
        renderToggleButtons();
        updateButtonStyles();
        filterGridItems();
    }

    initializeConfigModalListeners();
    try { await updateVersion(); } catch (e) { }
    try { await loadNotices(); startNoticeRotation(); } catch (e) { }

    if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
    checkReminders();
    currentCheckIntervalDuration = 3000;
    reminderCheckIntervalId = setInterval(checkReminders, currentCheckIntervalDuration);

    const noticeToggleIcon = document.getElementById('notice-toggle-icon');
    if (noticeToggleIcon) noticeToggleIcon.addEventListener('click', toggleNotices);

    const countEl = document.getElementById('reminder-count-globe');
    if (countEl) {
         const openTable = (e) => {
             if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
             e.preventDefault(); e.stopPropagation();
             showAllReminders();
         };
         countEl.addEventListener('click', openTable);
         countEl.style.cursor = 'pointer';
    }

    const filterInput = document.getElementById('grid-filter-input');
    const clearButton = document.getElementById('clear-filter-button');
    if (filterInput) {
        const savedFilter = localStorage.getItem('gridFilterValue');
        if (savedFilter !== null) filterInput.value = savedFilter;
        filterInput.addEventListener('input', () => {
             localStorage.setItem('gridFilterValue', filterInput.value);
             filterGridItems();
             if(isKeywordAssignmentMode) applyInitialKeywordHighlights();
        });
    }
    if (clearButton) {
        clearButton.addEventListener('click', () => {
             if (filterInput) filterInput.value = '';
             localStorage.removeItem('gridFilterValue');
             filterGridItems();
             if(isKeywordAssignmentMode) applyInitialKeywordHighlights();
        });
    }
    adjustButtonPositions();
    window.addEventListener('resize', adjustButtonPositions);
    await checkVersionsIconOpacity();

    const generalTopButtonsElements = [
        document.getElementById('config-button'), document.getElementById('personal-button'),
        document.getElementById('radar-button'), document.getElementById('home-button'),
        document.getElementById('reload-button'), document.getElementById('keyword-assignment-button'),
        document.getElementById('password-toggle-button'), document.getElementById('versions-button'),
        document.getElementById('info-button')
    ].filter(el => el);

    const toggleGeneralTopButtonsPanel = document.getElementById('toggle-top-buttons-panel-general');
    if (toggleGeneralTopButtonsPanel) {
        let areGeneralTopButtonsVisible = true;
        toggleGeneralTopButtonsPanel.addEventListener('click', () => {
            areGeneralTopButtonsVisible = !areGeneralTopButtonsVisible;
            generalTopButtonsElements.forEach(el => {
                if (el) el.classList.toggle('hidden', !areGeneralTopButtonsVisible);
            });
            const mainContent = document.querySelector('main');
            const footerContent = document.querySelector('footer');
            const noticesContainer = document.querySelector('.notices-icon-container');
            if (areGeneralTopButtonsVisible) {
                if (mainContent) mainContent.style.marginTop = '76px';
                if (footerContent) footerContent.style.marginTop = '0.5rem';
                if (noticesContainer) noticesContainer.style.marginTop = '0';
            } else {
                if (mainContent) mainContent.style.marginTop = '10px';
                if (footerContent) footerContent.style.marginTop = '10px';
                if (noticesContainer) noticesContainer.style.marginTop = '10px';
            }
        });
    }
    if (!shouldDirectToNav) {
        filterGridItems();
    }
}

    
    

        





    

    
    function openLocationsPreviewMap() {
        closeOtherModals('locations-preview-modal');
         let modal = document.getElementById('locations-preview-modal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'locations-preview-modal';
            modal.innerHTML = `
                <h2 id="locations-preview-title">Ubicaciones con Recordatorios</h2>
                <div id="locations-preview-map-container" style="height: calc(100% - 100px); width: 100%;"></div>
                <div class="modal-top-buttons" style="justify-content: center; margin-top: 1rem;">
                    <button id="close-locations-preview">Salir</button>
                </div>
            `;
            document.body.appendChild(modal);
        }
        modal.classList.remove('hidden');

        const mapContainer = modal.querySelector('#locations-preview-map-container');
        const closeButton = modal.querySelector('#close-locations-preview');
        const titleElement = modal.querySelector('#locations-preview-title');

        const closeHandler = () => {
            if (locationsPreviewMap) {
                try { locationsPreviewMap.remove(); } catch (e) {}
                locationsPreviewMap = null;
            }
            if (mapLayersControlLocationsPreview) {
                try {mapLayersControlLocationsPreview.remove();} catch(e){}
                mapLayersControlLocationsPreview = null;
            }
            clearModalAutoCloseTimer(modal, closeButton, 'locations-preview-modal');
            modal.classList.add('hidden');
        };

        const newCloseButton = closeButton.cloneNode(true);
        closeButton.parentNode.replaceChild(newCloseButton, closeButton);
        newCloseButton.addEventListener('click', closeHandler);
        newCloseButton.style.backgroundColor = '#4A5568';
        newCloseButton.style.color = 'white';
        newCloseButton.style.border = '1px solid #2D3748';
        newCloseButton.style.fontWeight = 'bold';
        newCloseButton.onmouseover = () => newCloseButton.style.backgroundColor = '#2D3748';
        newCloseButton.onmouseout = () => newCloseButton.style.backgroundColor = '#4A5568';

        addModalAutoCloseTimer(modal, newCloseButton, 'locations-preview-modal', 120000);

        if (locationsPreviewMap) {
            try { locationsPreviewMap.remove(); } catch (e) {}
            if(mapLayersControlLocationsPreview) { try {mapLayersControlLocationsPreview.remove();} catch(e){} mapLayersControlLocationsPreview = null;}
        }

        locationsPreviewMap = L.map(mapContainer, { zoomControl: true }).setView([40.416775, -3.703790], 6);

        const osmLayerLP = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a>' });
        const satelliteLayerLP = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles &copy; Esri' });
        const satelliteWithLabelsLP = L.layerGroup([
            L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles &copy; Esri' }),
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', { attribution: '&copy; OSM &copy; CARTO', pane: 'labels_locations_preview' })
        ]);
        if (!locationsPreviewMap.getPane('labels_locations_preview')) {
            locationsPreviewMap.createPane('labels_locations_preview');
            locationsPreviewMap.getPane('labels_locations_preview').style.zIndex = 650;
            locationsPreviewMap.getPane('labels_locations_preview').style.pointerEvents = 'none';
        }
        const baseMapsLP = { "Mapa Normal": osmLayerLP, "Satélite Puro": satelliteLayerLP, "Satélite + Calles": satelliteWithLabelsLP };
        const savedLayerNameLP = localStorage.getItem(ACTIVE_MAP_LAYER_KEY + '_locations_preview') || "Satélite + Calles";
        let initialLayerLP = baseMapsLP[savedLayerNameLP] || satelliteWithLabelsLP;
        initialLayerLP.addTo(locationsPreviewMap);

        mapLayersControlLocationsPreview = L.control.layers(baseMapsLP, null, {position: 'topright', collapsed: true}).addTo(locationsPreviewMap);
        locationsPreviewMap.on('baselayerchange', function(e) {
            localStorage.setItem(ACTIVE_MAP_LAYER_KEY + '_locations_preview', e.name);
        });


        const allReminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;

        const locationsToPlot = allReminders.filter(r => {
            const hasLocation = r.isLocationEnabled && r.locationCoordinates?.latitude && r.locationCoordinates?.longitude;
            if (!hasLocation) return false;
            const isRadarText = r.text && r.text.toUpperCase().includes("RADAR:");
            if (showExcluded) {
                return true;
            } else {
                return !isRadarText;
            }
        });

        if (titleElement) {
            titleElement.textContent = `Ubicaciones con Recordatorios ${showExcluded ? '(incluyendo "RADAR")' : '(sin "RADAR")'}`;
        }


        const markers = [];
        locationsToPlot.forEach(reminder => {
            const latLng = [reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude];
             const isRadarTypeForIcon = reminder.text.toUpperCase().includes("RADAR:") || reminder.excludeFromList;
            const markerIconToUse = isRadarTypeForIcon ? smallRadarMarkerIcon : largeGreenLocationMarkerIcon;
            const isRadar = reminder.text.toUpperCase().includes("RADAR:");
            const circleColor = isRadar ? 'rgba(255, 165, 0, 0.2)' : 'blue';
            const circleFillColor = isRadar ? 'rgba(255, 165, 0, 0.2)' : '#ADD8E6';
            const circleFillOpacity = isRadar ? 0.2 : 0.05;
            const circleWeight = 1;

            const marker = L.marker(latLng, { icon: markerIconToUse })
                .addTo(locationsPreviewMap)
                .bindPopup(`<b>${reminder.text.replace(/<b>|<\/b>/gi,'')}</b><br>${reminder.time || ''} ${reminder.date ? formatDateDetailed(reminder.date) : ''}<br><button data-reminder-id="${reminder.id}" class="edit-reminder-from-preview-map" style="margin-top:5px;padding:3px 6px;background-color:#10B981;color:white;border:none;border-radius:3px;cursor:pointer;">Ver/Editar</button>`);

             L.circle(latLng, { radius: reminder.radiusMeters || DEFAULT_LOCATION_RADIUS, color: circleColor, fillColor: circleFillColor, weight: circleWeight, fillOpacity: circleFillOpacity }).addTo(locationsPreviewMap);


            marker.on('popupopen', () => {
                const editButton = marker.getPopup().getElement().querySelector('.edit-reminder-from-preview-map');
                if (editButton) {
                    const newEditButton = editButton.cloneNode(true);
                    editButton.parentNode.replaceChild(newEditButton, editButton);
                    newEditButton.addEventListener('click', () => {
                        const id = parseInt(newEditButton.dataset.reminderId);
                        const remToEdit = allReminders.find(r => r.id === id);
                        if (remToEdit) {
                            closeHandler();
                            showReminderModal(remToEdit);
                        }
                    });
                }
            });
            markers.push(marker);
        });

        if (markers.length > 0) {
            const group = new L.featureGroup(markers);
            locationsPreviewMap.fitBounds(group.getBounds().pad(0.2));
        } else {
            showToast(`No hay recordatorios con ubicación para mostrar según el filtro actual.`, "info");
        }
         requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                if(locationsPreviewMap) locationsPreviewMap.invalidateSize();
            });
        });
    }




    
    



/**
 * Cierra el modal de desvío y ejecuta la acción seleccionada por el usuario.
 * @param {string} action - La acción a realizar ('recalculate_forward', 'recalculate_turn_back', 'skip_one', 'skip_multiple').
 */
function closeModalAndProceed(action) {
    if (deviationModalTimerId) {
        clearInterval(deviationModalTimerId);
        deviationModalTimerId = null;
    }
    const modal = document.getElementById('deviation-modal');
    if (modal) {
        clearModalAutoCloseTimer(modal, modal.querySelector('button'), 'deviation-modal');
        modal.classList.add('hidden');
    }
    isDeviationModalActive = false;
    deviationStartTime = 0;

    proceedWithRecalculation(action);
}
    




    


    





function initializeConfigModalListeners() {

    document.getElementById('config-save-user-firebase')?.addEventListener('click', validateAndSaveUserToFirebase);
    document.getElementById('config-save-user-firebase-from-backup-tab')?.addEventListener('click', validateAndSaveUserToFirebase); // NUEVO LISTENER
    document.getElementById('config-restore-backup-firebase')?.addEventListener('click', restoreBackupFromFirebase);
    
    document.getElementById('config-save-pin')?.addEventListener('click', savePinSettings);
    document.getElementById('config-remove-pin')?.addEventListener('click', removePinSettings);
    document.getElementById('config-generate-backup')?.addEventListener('click', generateBackup);
    document.getElementById('config-restore-backup')?.addEventListener('click', restoreBackup);
    document.getElementById('config-restore-grid-button')?.addEventListener('click', restoreOriginalGrid);
    document.getElementById('config-clear-cache')?.addEventListener('click', clearAllLocalData);

    const importBtn = document.getElementById('import-radars-button');
    if (importBtn && !importBtn.dataset.listenerAttached) {
        importBtn.addEventListener('click', importRadars);
        importBtn.style.backgroundColor = '#FFA500';
        importBtn.style.border = '1px solid #D97706';
        importBtn.dataset.listenerAttached = "true";
    }

    const deleteBtn = document.getElementById('delete-filtered-radars-button');
    if (deleteBtn && !deleteBtn.dataset.listenerAttached) {
        deleteBtn.addEventListener('click', deleteFilteredRadars);
        deleteBtn.style.backgroundColor = '#FFA500';
        deleteBtn.style.border = '1px solid #D97706';
        deleteBtn.dataset.listenerAttached = "true";
    }

    const configCloseBtn = document.getElementById('config-close-modal');
    if (configCloseBtn) {
        configCloseBtn.style.backgroundColor = '#4A5568';
        configCloseBtn.style.color = 'white';
        configCloseBtn.style.border = '1px solid #2D3748';
        configCloseBtn.style.fontWeight = 'bold';
        configCloseBtn.onmouseover = () => configCloseBtn.style.backgroundColor = '#2D3748';
        configCloseBtn.onmouseout = () => configCloseBtn.style.backgroundColor = '#4A5568';
    }

    const directToNavCheckbox = document.getElementById('config-direct-to-nav');
    if (directToNavCheckbox && !directToNavCheckbox.dataset.listenerAttached) {
        directToNavCheckbox.addEventListener('change', () => {
            localStorage.setItem(DIRECT_TO_NAVIGATION_KEY, JSON.stringify(directToNavCheckbox.checked));
            showToast('Preferencia de inicio directo al mapa guardada.', 'success', 2000);
        });
        directToNavCheckbox.dataset.listenerAttached = "true";
    }
    
    const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
    if (autoBackupCheckbox && !autoBackupCheckbox.dataset.listenerAttached) {
        autoBackupCheckbox.addEventListener('change', () => {
            const isEnabled = autoBackupCheckbox.checked;
            localStorage.setItem('boardinggate_autoBackupOnLoad', JSON.stringify(isEnabled));
            showToast(`Copia de seguridad automática al inicio: ${isEnabled ? 'Activada' : 'Desactivada'}`, 'info', 3000);
        });
        autoBackupCheckbox.dataset.listenerAttached = "true";
    }
}


    
    




    
    
const DEFAULT_LOCATION_RADIUS = 450;









function updateStartNavigationButtonState() {
    const startNavButton = document.getElementById('start-navigation-button');
    const saveRouteButton = document.getElementById('save-route-button');
    const reorderBtn = document.getElementById('reorder-route-stages-button');
    const startNavImg = startNavButton ? startNavButton.querySelector('img') : null;
    const simulateBtn = document.getElementById('simulate-route-button');
    const deleteRouteBtn = document.getElementById('delete-current-route-button');
    const loadRouteBtn = document.getElementById('load-saved-route-button'); 
    const toggleSimulateGpsBtn = document.getElementById('toggle-simulate-gps-button');
    const graphCard = document.getElementById('navigation-graph-card');

    if (!startNavButton || !saveRouteButton || !reorderBtn || !simulateBtn || !loadRouteBtn || !deleteRouteBtn || !toggleSimulateGpsBtn || !graphCard) return;

    const hasEnoughWaypointsForRoute = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2;
    const hasRouteData = navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0];
    const canDisplayRoute = hasEnoughWaypointsForRoute && hasRouteData;
    const hasAtLeastOneWaypoint = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 1;

    // Lógica para mostrar/ocultar botones específicos
    startNavButton.classList.toggle('hidden', !(hasEnoughWaypointsForRoute || isNavigating));
    saveRouteButton.classList.toggle('hidden', !(!isNavigating && canDisplayRoute));
    if (reorderBtn) reorderBtn.style.display = (!isNavigating && canDisplayRoute) ? 'inline-flex' : 'none';
    
    const canSimulate = (canDisplayRoute || (isNavigating && hasRouteData));
    if(simulateBtn) simulateBtn.style.display = canSimulate ? 'inline-flex' : 'none';
    if(toggleSimulateGpsBtn) toggleSimulateGpsBtn.style.display = hasAtLeastOneWaypoint ? 'inline-flex' : 'none';
    
    // --- INICIO DE LA MODIFICACIÓN FINAL ---
    // Aseguramos que los botones de cargar y borrar estén siempre visibles.
    if (deleteRouteBtn) {
        deleteRouteBtn.classList.remove('hidden');
    }
    if (loadRouteBtn) {
        loadRouteBtn.classList.remove('hidden');
    }
    // --- FIN DE LA MODIFICACIÓN FINAL ---

    const hasGraphData = graphDataPoints && (graphDataPoints.speed.length > 0 || graphDataPoints.altitude.length > 0);
    graphCard.classList.toggle('hidden', !hasGraphData || currentGraphMode === 'Gráfica off');

    if (isNavigating) {
        if(reorderBtn) reorderBtn.style.display = 'none';
        if(startNavImg) startNavImg.src = "TERMINARNAVEGACION.PNG";
    } else {
        if (hasEnoughWaypointsForRoute) {
            if(startNavImg) startNavImg.src = "INICIARNAVEGACION.PNG";
        } else {
            if (navigationRouteLayer && navigationMapInstance) { try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch(e){} navigationRouteLayer = null; }
            if (completedRouteSegmentsLayer && navigationMapInstance) completedRouteSegmentsLayer.clearLayers();
            navigationCurrentRouteData = null;
            hideNavigationUI();
            hideMapInfoOverlay();
        }
    }

    updateNavigationGraphVisibilityAndMode();
}    




    


    



function startGraphIntervalTimer() {
    if (graphIntervalTimer) clearInterval(graphIntervalTimer);
    if (isNavigating && currentGraphMode !== 'Gráfica off' && graphIntervalDuration > 0) { 
        graphIntervalTimer = setInterval(plotIntervalData, graphIntervalDuration);
    }
}

    



function updateNavigationGraphVisibilityAndMode() {
    const graphCard = document.getElementById('navigation-graph-card');
    const graphContainer = document.getElementById('navigation-graph-container');
    const graphTitleElement = document.getElementById('navigation-graph-title');
    const compassControl = document.querySelector('.leaflet-control-orientation-altitude');

    if (!graphCard || !graphContainer || !graphTitleElement) {
        return;
    }

    if (compassControl && compassControl._updateGraphTitle) {
        compassControl._updateGraphTitle();
    }
    
    // CAMBIO: Se añade una variable para saber si la gráfica está ampliada
    const isEnlarged = graphCard.classList.contains('enlarged');

    if (navigationCurrentRouteData && currentGraphMode !== 'Gráfica off') {
        graphCard.classList.remove('hidden');

        // CAMBIO: La altura solo se ajusta al tamaño de la brújula si NO está ampliada.
        if (!isEnlarged) {
            const compassHeight = compassControl ? compassControl.offsetHeight : 0;
            graphCard.style.height = compassHeight > 0 ? `${compassHeight}px` : '157px';
        }
    
        if (navigationChart) {
            updateChartData(); 
        } else if (isNavigating) {
            ; 
        }
    } else {
        graphCard.classList.add('hidden');
    }
}    



    




    

function plotAccumulatedGraphData() {
    if (!navigationChart) {
        return;
    }
    if (graphDataAccumulator.count === 0) {
        return;
    }

    let avgSpeed = 0;
    if (graphDataAccumulator.count > 0 && graphDataAccumulator.speedSum > 0) {
        avgSpeed = graphDataAccumulator.speedSum / graphDataAccumulator.count;
    } else if (window.currentSpeedKmh !== undefined && graphDataAccumulator.count > 0) {
        
        avgSpeed = window.currentSpeedKmh;
    }


    const avgAltitude = graphDataAccumulator.altitudeSum / graphDataAccumulator.count;

    const now = new Date();
    const currentTimeLabel = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
    
    graphLabels.push(currentTimeLabel);
    if (graphLabels.length > GRAPH_TARGET_POINTS) {
        graphLabels.shift();
    }
    navigationChart.data.labels = graphLabels;


    if (currentGraphMode === 'Velocidad') {
        graphDataPoints.speed.push(avgSpeed);
        if (graphDataPoints.speed.length > GRAPH_TARGET_POINTS) {
            graphDataPoints.speed.shift();
        }
        navigationChart.data.datasets[0].data = graphDataPoints.speed;
        navigationChart.data.datasets[0].label = 'Velocidad Media Tramo';
        navigationChart.options.scales.yPrimary.ticks.callback = function(value) { return value.toFixed(0) + ' km/h'; };
        
        if (!navigationChart.data.datasets[1].hidden) {
            navigationChart.data.datasets[1].data = graphLabels.map(() => graphExpectedAvgSpeed);
        }

    } else if (currentGraphMode === 'Altitud') {
        graphDataPoints.altitude.push(avgAltitude);
        if (graphDataPoints.altitude.length > GRAPH_TARGET_POINTS) {
            graphDataPoints.altitude.shift();
        }
        navigationChart.data.datasets[0].data = graphDataPoints.altitude;
        navigationChart.data.datasets[0].label = 'Altitud Media Tramo';
        navigationChart.options.scales.yPrimary.ticks.callback = function(value) { return value.toFixed(0) + ' m'; };
    }

    navigationChart.update('none'); 

    graphDataAccumulator = { speedSum: 0, altitudeSum: 0, count: 0, lastPositionTime: graphDataAccumulator.lastPositionTime, lastPositionCoords: graphDataAccumulator.lastPositionCoords }; 
}



    





    
// BUSCAR:
// function showArrivalStatsModal() {
// ... todo el contenido de la función ...
// }

// REEMPLAZAR COMPLETO CON ESTO:
function showArrivalStatsModal() {
    closeOtherModals('arrival-stats-modal');
    let modal = document.getElementById('arrival-stats-modal');
    if (modal) {
        clearModalAutoCloseTimer(modal, modal.querySelector('#arrival-stats-accept-button'), 'arrival-stats-modal');
        modal.remove();
    }
    modal = document.createElement('div');
    modal.id = 'arrival-stats-modal';
    modal.style.cssText = `
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background-color: #E6D6A8; padding: 25px; border-radius: 10px;
        box-shadow: 0 0 20px rgba(0,0,0,0.5); z-index: 10000; text-align: center;
        max-width: 550px; width: 90%;
    `;

    const destinationWp = navigationWaypoints[navigationWaypoints.length - 1];
    const destinationName = destinationWp?.address || "";
    const startTime = navigationStartTimeForStats ? new Date(navigationStartTimeForStats) : new Date();
    const arrivalTime = new Date();
    const durationMs = arrivalTime - startTime;
    const durationHours = Math.floor(durationMs / (1000 * 60 * 60));
    const durationMinutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
    const durationSeconds = Math.floor((durationMs % (1000 * 60)) / 1000);

    let kmRealizados;
    if (isSimulatingGpsLocation && automatedSimulationIntervalId) {
        kmRealizados = (simulatedDistanceAlongRoute / 1000).toFixed(2);
    } else {
        kmRealizados = (totalDistanceTravelledForStats / 1000).toFixed(2);
    }
    const velocidadMedia = window.averageSpeedKmh.toFixed(1);
    const velocidadMaxima = maxSpeedDuringTrip.toFixed(1);
    const altitudMaxima = maxAltitudeDuringTrip !== -Infinity ? maxAltitudeDuringTrip.toFixed(0) + ' m' : 'N/D';
    const altitudMinima = minAltitudeDuringTrip !== Infinity ? minAltitudeDuringTrip.toFixed(0) + ' m' : 'N/D';

    let altitudMediaHtml = '';
    if (graphDataPoints && graphDataPoints.altitude && graphDataPoints.altitude.length > 0) {
        const sum = graphDataPoints.altitude.reduce((a, b) => a + b, 0);
        const avg = sum / graphDataPoints.altitude.length;
        altitudMediaHtml = `
            <div style="text-align: center;">
                <span style="font-size: 1.1rem; color: black; font-weight: bold;">(Media:</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;"> ${avg.toFixed(0)} m)</span>
            </div>
        `;
    }

    let deviationHtml = "";
    let finalDeviationMs = 0;
    if (tripInitialOverallEtaTime) {
        finalDeviationMs = arrivalTime.getTime() - tripInitialOverallEtaTime.getTime();
        deviationHtml = formatDeviation(finalDeviationMs);
    }
    
    let initialEtaDetailsHtml = '';
    const initialRoute = navigationCurrentRouteData?.routes?.[0];

    if (initialRoute && tripInitialOverallEtaTime && Math.abs(finalDeviationMs) < 5000) { 
        const realEtaTime = arrivalTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const realDurationTotalMinutes = Math.round(durationMs / (1000 * 60));
        const realDurationHours = Math.floor(realDurationTotalMinutes / 60);
        const realDurationMins = realDurationTotalMinutes % 60;
        const realDurationFormatted = `${String(realDurationHours).padStart(2,'0')}:${String(realDurationMins).padStart(2,'0')}`;
        const realAvgSpeed = velocidadMedia;
        initialEtaDetailsHtml = `
        <div id="initial-eta-details" style="font-size: 0.9rem; color: #333; margin-top: 8px; padding-top: 8px; border-top: 1px solid #ccc; text-align: center; font-weight: bold; line-height: 1.4;">
            <strong>Previsión (coincide con real):</strong><br>
            Hora llegada: ${realEtaTime} | Tiempo: ${realDurationFormatted} h. | Vel. media: ${realAvgSpeed} Km/h
        </div>
        `;
    } else if (initialRoute && tripInitialOverallEtaTime) {
        const initialEtaTime = tripInitialOverallEtaTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const initialDurationTotalMinutes = Math.round(initialRoute.duration / 60);
        const initialDurationHours = Math.floor(initialDurationTotalMinutes / 60);
        const initialDurationMins = initialDurationTotalMinutes % 60;
        const initialDurationFormatted = `${String(initialDurationHours).padStart(2,'0')}:${String(initialDurationMins).padStart(2,'0')}`;
        const initialAvgSpeed = ((initialRoute.distance / initialRoute.duration) * 3.6).toFixed(1);
        initialEtaDetailsHtml = `
        <div id="initial-eta-details" style="font-size: 0.9rem; color: #555; margin-top: 8px; padding-top: 8px; border-top: 1px solid #ccc; text-align: center; font-weight: bold; line-height: 1.4;">
            <strong>Previsión inicial:</strong><br>
            Hora llegada: ${initialEtaTime} | Tiempo: ${initialDurationFormatted} h. | Vel. media: ${initialAvgSpeed} Km/h
        </div>
        `;
    }
    
    modal.innerHTML = `
        <h2 style="font-size: 1.6rem; color: #006400; font-weight: bold; margin-bottom: 15px; display: flex; align-items: center; justify-content: center;">
            <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path></svg>
            ¡HA LLEGADO A !
        </h2>
        <div style="font-size: 1.1rem; color: #006400; font-weight: bold; text-align: center; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #ccc;">
             <span style="font-size: 1.5em; vertical-align: middle;">🏁</span> ${destinationName}
        </div>
        <div style="display: flex; justify-content: space-around; align-items: center; margin-bottom: 15px; font-size: 1.1rem;">
            <div style="text-align: center;">
                <span style="font-size: 1.1rem; color: black; font-weight: bold; display: block;">Hora Salida</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;">${startTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
            </div>
            <div style="font-size: 4rem; color: black;">→</div>
            <div style="text-align: center;">
                <span style="font-size: 1.1rem; color: black; font-weight: bold; display: block;">Hora Llegada</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;">${arrivalTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
            </div>
        </div>
        <div style="text-align: center; margin-bottom: 20px;">
            <span style="font-size: 1.1rem; color: black; font-weight: bold; display: block;">Tiempo Viaje</span>
            <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;">${String(durationHours).padStart(2,'0')}:${String(durationMinutes).padStart(2,'0')}:${String(durationSeconds).padStart(2,'0')}</span>
         </div>
          <div style="text-align: center; margin-bottom: 10px;">
            <span style="font-size: 1.1rem; color: blue; font-weight: bold;">Desviación ETA: ${deviationHtml}</span>
            ${initialEtaDetailsHtml}
         </div>
        </div>
        <div style="display: flex; justify-content: space-around; margin-bottom: 10px; font-size: 1.1rem; border-top: 1px solid #ccc; padding-top: 10px; margin-top:10px;">
            <div>
                <span style="font-size: 1.1rem; color: black; font-weight: bold;">Km realizados:</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;"> ${kmRealizados} km</span>
            </div>
            <div>
                <span style="font-size: 1.1rem; color: black; font-weight: bold;">Vel. media:</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;"> ${velocidadMedia} km/h</span>
            </div>
        </div>
        <div style="display: flex; justify-content: center; align-items: center; gap: 10px; margin-bottom: 20px; font-size: 1.1rem;">
            <div>
                <span style="font-size: 1.1rem; color: black; font-weight: bold;">Vel. máxima:</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;"> ${velocidadMaxima} km/h</span>
            </div>
            <button id="show-max-speed-location-button" style="padding: 0; font-size: 1rem; background-color: #f59e0b; color: white; border: 1px solid #d97706; border-radius: 4px; cursor: pointer; max-width: 12px; max-height: 8px;">¿Dónde?</button>
        </div>
        <div style="display: flex; justify-content: space-around; align-items: center; margin-bottom: 20px; font-size: 1.1rem; border-top: 1px solid #ccc; padding-top: 15px; margin-top:15px;">
            <div>
                <span style="font-size: 1.1rem; color: black; font-weight: bold;">Altitud Máx:</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;"> ${altitudMaxima}</span>
            </div>
            ${altitudMediaHtml}
            <div>
                <span style="font-size: 1.1rem; color: black; font-weight: bold;">Altitud Mín:</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;"> ${altitudMinima}</span>
            </div>
        </div>
        <button id="arrival-stats-accept-button" style="background-color: #007bff; color: white; padding: 12px 25px; font-size: 1.2rem; border-radius: 5px; border: none; cursor: pointer;">ACEPTAR</button>
    `;
    document.body.appendChild(modal);

    // --- INICIO DE LA MODIFICACIÓN ---
    // Añadir el marcador de velocidad máxima al mapa automáticamente
    const coordsAreValid = maxSpeedCoordinates &&
                            typeof maxSpeedCoordinates.lat === 'number' && !isNaN(maxSpeedCoordinates.lat) &&
                            typeof maxSpeedCoordinates.lng === 'number' && !isNaN(maxSpeedCoordinates.lng);

    if (coordsAreValid && navigationMapInstance) {
        const maxSpeedIcon = L.divIcon({
            className: 'max-speed-marker-icon',
            html: `<div style="background-color: red; color: white; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; border: 2px solid white; box-shadow: 0 0 5px black;">${Math.round(velocidadMaxima)}</div>`,
            iconSize: [44, 44],
            iconAnchor: [22, 22]
        });

        const markerPosition = [maxSpeedCoordinates.lat, maxSpeedCoordinates.lng];
        
        // Asegurarse de que el maxSpeedMarkerLayer exista y limpiar marcadores previos
        if (!maxSpeedMarkerLayer) {
            maxSpeedMarkerLayer = L.layerGroup().addTo(navigationMapInstance);
        } else {
            maxSpeedMarkerLayer.clearLayers();
        }

        L.marker(markerPosition, { 
            icon: maxSpeedIcon,
            zIndexOffset: 2000 // Asegura que esté por encima de otros marcadores
        }).addTo(maxSpeedMarkerLayer);
    }
    // --- FIN DE LA MODIFICACIÓN ---

    const acceptButton = modal.querySelector('#arrival-stats-accept-button');
    acceptButton.addEventListener('click', () => {
        clearModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal');
        if (modal.parentNode) modal.remove();
        
        if (isNavigating) {
            toggleNavigationState(); 
        } else {
            mapHeaderButtonsVisible = true;
            toggleMapHeaderRowsVisibility(true);
        }
        
        showMapInfoOverlay("HA LLEGADO AL : " + destinationName);
    });

    const showLocationButton = modal.querySelector('#show-max-speed-location-button');
    showLocationButton.addEventListener('click', () => {
        // --- INICIO DE LA MODIFICACIÓN ---
        // El icono ya está en el mapa, solo necesitamos centrar y ocultar el modal
        const coordsAreValid = maxSpeedCoordinates &&
                              typeof maxSpeedCoordinates.lat === 'number' && !isNaN(maxSpeedCoordinates.lat) &&
                              typeof maxSpeedCoordinates.lng === 'number' && !isNaN(maxSpeedCoordinates.lng);

        if (!coordsAreValid || !navigationMapInstance) {
            showToast("No se han registrado coordenadas válidas para la velocidad máxima.", "warning");
            return;
        }

        clearModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal');
        if (modal.parentNode) modal.remove();
        
        const markerPosition = [maxSpeedCoordinates.lat, maxSpeedCoordinates.lng];
        navigationMapInstance.setView(markerPosition, 16); // Centra el mapa en el marcador que ya existe
        showToast("Mapa centrado en el punto de velocidad máxima.", "info");
        
        mapHeaderButtonsVisible = true;
        toggleMapHeaderRowsVisibility(true);
        // --- FIN DE LA MODIFICACIÓN ---
    });

    addModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal', 60000);
}
    
    
    
    
    

    

    


    
document.addEventListener('DOMContentLoaded', async () => {
         storedPin = localStorage.getItem('password_pin');
         const savedPasswordActive = localStorage.getItem('password_active');
         isPasswordActive = savedPasswordActive ? JSON.parse(savedPasswordActive) : false;
         const initialDirectToNavPref = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
         const tempPreventDirectNav = sessionStorage.getItem(TEMP_PREVENT_DIRECT_NAV_KEY);


         if (isPasswordActive && storedPin && !(initialDirectToNavPref && !tempPreventDirectNav)) {
             promptForPin();
         } else {
             await initializeApp();
         }


        window.addEventListener('beforeunload', () => {
             if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
             if (locationWatchId !== null && navigator.geolocation) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
             if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
             const openReminderModal = document.querySelector('.reminder-modal');
             if (openReminderModal && typeof openReminderModal.cleanUpModalTimers === 'function') { openReminderModal.cleanUpModalTimers(true); }

             Object.keys(globalModalTimers).forEach(modalId => {
                const timerData = globalModalTimers[modalId];
                if (timerData) {
                    clearModalAutoCloseTimer(timerData.modalElement, timerData.closeButtonElement, modalId);
                }
             });
             globalModalTimers = {};

             const openTableModal = document.querySelector('.reminder-table-modal');
             if(openTableModal && openTableModal.autoCloseInterval) { clearInterval(openTableModal.autoCloseInterval); }
             const openPostponeModal = document.getElementById('postpone-options-modal');
             if(openPostponeModal && openPostponeModal.autoPostponeInterval) { clearInterval(openPostponeModal.autoPostponeInterval); }
             const openSavedLocationsModal = document.querySelector('.saved-locations-modal');
             if (openSavedLocationsModal && locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
             const simModalUnload = document.getElementById('simulation-modal');
             if (simModalUnload && simulationModalTimer) clearTimeout(simulationModalTimer);
             if (autoStartNavTimer) clearTimeout(autoStartNavTimer);


             if (isNavigationMapActive || navigationMapInstance) {
                closeNavigationMap(true);
             }
             if (locationsPreviewMap) {
                 try { locationsPreviewMap.remove(); } catch(e){}
                 locationsPreviewMap = null;
             }

             if (isAssignmentMode || isEditMode || isKeywordAssignmentMode) { saveCustomData(); }

             const filterInput = document.getElementById('grid-filter-input');
             if (filterInput && filterInput.value.trim()) {
                  localStorage.setItem('gridFilterValue', filterInput.value);
             } else {
                  localStorage.removeItem('gridFilterValue');
             }
              saveSettings();

              if (reminderModalMap) try {reminderModalMap.remove();} catch(e){}
              Object.values(previewMaps).forEach(map => {try {map?.remove();} catch(e){}});
              if (intersectionPreviewMap) try {intersectionPreviewMap.remove();} catch(e){}
              if (navigationChart) navigationChart.destroy();
              if (graphIntervalTimer) clearInterval(graphIntervalTimer);
         });

        document.body.addEventListener('click', function(event) {
            const target = event.target;
            const targetId = target.id || (target.closest('[id]') ? target.closest('[id]').id : null);


            if (targetId === 'config-close-modal') {
                const modal = document.getElementById('config-modal');
                if (modal && !modal.classList.contains('hidden')) {
                    clearModalAutoCloseTimer(modal, target, 'config-modal');
                    modal.classList.add('hidden');
                     const mapWasOpenBeforeConfig = sessionStorage.getItem('boardinggate_map_should_reopen_after_config') === 'true';
                     const mapContextToReopen = sessionStorage.getItem('mapContextToReopenAfterConfig');
                     sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');
                     sessionStorage.removeItem('mapContextToReopenAfterConfig');

                     if (mapWasOpenBeforeConfig && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !document.getElementById('reminders-location-map-modal')) {
                        if (mapContextToReopen === 'navigation') {
                            setTimeout(() => openNavigationMap(), 50);
                        }
                    }
                }
            }
            if (target.matches('.config-tab-button')) {
                const modal = document.getElementById('config-modal');
                if(modal && modal.classList.contains('hidden') === false) {
                    const tabTarget = target.dataset.tabTarget;
                    modal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                    modal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                    target.classList.add('active');
                    if (modal.querySelector(tabTarget)) {
                        modal.querySelector(tabTarget).classList.add('active');
                    }
                }
            }

            if (targetId === 'close-reminders-top' || targetId === 'close-reminders-bottom') {
                const modalTable = document.querySelector('.reminder-table-modal');
                if (modalTable) {
                    if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                    modalTable.remove();
                    const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                    const mapContext = sessionStorage.getItem('mapContext');

                    sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                    sessionStorage.removeItem('mapContext');

                    if (fromReminderModal) {
                        fromReminderModal = false;
                        if (mapShouldReopen) {
                            sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                            sessionStorage.setItem('mapContext', mapContext);
                        }
                        showReminderModal();
                    } else if (mapShouldReopen) {
                         if (mapContext === 'navigation') {
                            setTimeout(() => openNavigationMap(), 50);
                         }
                    }
                }
            }
            if (targetId === 'view-all-locations-map') {
                const modalTable = document.querySelector('.reminder-table-modal');
                 if (modalTable && modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                 if (modalTable) modalTable.remove();
                setTimeout(() => {
                    openLocationsPreviewMap();
                }, 50);
            }
             if (targetId === 'close-locations-preview') {
                const previewModal = document.getElementById('locations-preview-modal');
                if (previewModal) {
                    if (locationsPreviewMap) {
                        try { locationsPreviewMap.remove(); } catch (e) {}
                        locationsPreviewMap = null;
                    }
                    if (mapLayersControlLocationsPreview) {
                        try {mapLayersControlLocationsPreview.remove();} catch(e){}
                        mapLayersControlLocationsPreview = null;
                    }
                    clearModalAutoCloseTimer(previewModal, target, 'locations-preview-modal');
                    previewModal.classList.add('hidden');
                }
            }
            if (targetId === 'close-address-suggestions-modal') {
                hideAddressSuggestionsModal();
            }
        });

const bookmarkGrid = document.getElementById('bookmark-grid');
        if (bookmarkGrid) {
            bookmarkGrid.addEventListener('click', function(event) {
                const link = event.target.closest('a.bookmark-item');
                if (link && link.href && link.href.startsWith("map-action:")) {
                    event.preventDefault();
                    const action = link.href.split(":")[1];
                    if (action === "openRemindersMapWithNoRadars") {
                        closeOtherModals();
                        setTimeout(() => {
                            const existingPreviewModal = document.getElementById('locations-preview-modal');
                            if (existingPreviewModal && !existingPreviewModal.classList.contains('hidden')) {
                                showToast("El mapa de ubicaciones (sin radar) ya está abierto", "info");
                            } else {
                               openLocationsPreviewMap();
                            }
                        }, 50);
                    } else if (action === "openRemindersMap") {
                        closeOtherModals();
                        setTimeout(() => {
                            const mapModalElement = document.getElementById('reminders-location-map-modal');
                            if (mapModalElement && !mapModalElement.classList.contains('hidden')) {
                                showToast("El mapa de navegación/ubicaciones ya está abierto", "info");
                                if (navigationMapInstance) {
                                    requestAnimationFrame(() => {
                                        requestAnimationFrame(() => {
                                            if (navigationMapInstance) {
                                                try {
                                                     navigationMapInstance.invalidateSize({debounceMoveend: true});
                                 } catch (e) {  }
                                            }
                                        });
                                    });
                                }
                            } else {
                               openNavigationMap();
                            }
                        }, 50);
                    }
                }
            });
        }
    });
</script> 
</body>
</html>
                                                                                 
