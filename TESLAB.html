
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tesla Boarding Gate</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20n6fxhV1W+HF1wNq4NV5CaA/HOkP7BC36hZ0fzaL0" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.geometryutil/0.10.3/leaflet.geometryutil.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder@latest/dist/Control.Geocoder.css" />
    <script src="https://unpkg.com/leaflet-control-geocoder@latest/dist/Control.Geocoder.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

    <style>
        body { font-family: sans-serif; background-color: #18181b; color: #f4f4f5; margin: 0; padding: 0; overflow-x: hidden; }
        body.light-mode { background-color: #f4f4f5; color: #18181b; }
        .grid-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 12px; padding: 16px; }
        .grid-item { background-color: #374151; padding: 12px; border-radius: 8px; text-align: center; cursor: pointer; user-select: none; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: transform 0.2s, background-color 0.2s, box-shadow 0.2s; }
        .grid-item:hover { background-color: #4b5563; transform: scale(1.03); }
        .grid-item.hidden-filter { display: none !important; }
        .grid-item img { width: 40px; height: 40px; margin-bottom: 8px; pointer-events: none; user-select: none; -webkit-user-drag: none; }
        .grid-item span { font-size: 0.9em; color: #d1d5db; pointer-events: none; user-select: none; -webkit-user-drag: none; }
        body.light-mode .grid-item { background-color: #e5e7eb; color: #374151; }
        body.light-mode .grid-item span { color: #4b5563; }
        body.light-mode .grid-item:hover { background-color: #d1d5db; }

        .button-bar { display: flex; justify-content: center; gap: 1rem; padding: 0.5rem 0; background-color: #262626; flex-wrap: wrap; }
        body.light-mode .button-bar { background-color: #e5e7eb; }

        .on-off-button, .settings-button, .edit-button { padding: 0.5rem 1rem; border-radius: 0.5rem; border: none; cursor: pointer; font-weight: bold; transition: background-color 0.2s; }
        .on-off-button { background-color: #ef4444; color: white; }
        .on-off-button.active { background-color: #22c55e; }
        .settings-button { background-color: #f59e0b; color: white; }
        .edit-button { background-color: #3b82f6; color: white; }

        .edit-mode-active .grid-item { cursor: grab; }
        .edit-mode-active .grid-item:active { cursor: grabbing; }
        .edit-mode-active .grid-item:hover { background-color: #fde68a !important; }
        .edit-mode-active .grid-item img, .edit-mode-active .grid-item span { pointer-events: none !important; user-select: none !important; -webkit-user-drag: none !important; }

        .edit-modal, .edit-info-modal, .help-modal, .versions-modal-overlay, .saved-locations-modal, #postpone-options-modal, .reminder-table-modal, #config-modal, #saved-routes-modal {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000;
            background-color: #374151; color: #d1d5db; padding: 1.5rem; border-radius: 1rem; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            max-width: 95%; max-height: 90vh; overflow-y: auto;
            display: flex; flex-direction: column;
            width: 500px; /* Default width, adjusted by specific modal styles */
        }

         #config-modal { width: 600px; }
         .reminder-table-modal { width: 90%; max-width: 1000px; padding: 1rem; font-size: 0.9rem; }
         .reminder-table-modal table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
         .reminder-table-modal th, .reminder-table-modal td { border: 1px solid #4b5563; padding: 8px; text-align: left; }
         .reminder-table-modal th { background-color: #4b5563; color: white; }
         .reminder-table-modal td { color: #d1d5db; }
         .reminder-table-modal .button-group { display: flex; gap: 5px; flex-wrap: wrap; }
         .reminder-table-modal .button-group button { padding: 4px 8px; font-size: 0.8rem; border-radius: 4px; cursor: pointer; }
         .reminder-table-modal .visto-prox { background-color: #ef4444; color: white; }
         .reminder-table-modal .postpone { background-color: #f59e0b; color: white; }
         .reminder-table-modal .cancel-cyclic-table { background-color: #dc2626; color: white; }
         .reminder-table-modal .text-column { cursor: pointer; text-decoration: underline; }
         .reminder-table-modal .date-column, .reminder-table-modal .time-column { white-space: nowrap; }
         .reminder-table-modal .top-button-container { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }

        #saved-locations-modal { width: 550px; }
        #saved-locations-list { max-height: 30vh; overflow-y: auto; margin-bottom: 1rem; border: 1px solid #4b5563; border-radius: 5px; padding: 10px; }
        .location-slot { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; padding: 8px; background-color: #4b5563; border-radius: 5px; }
        .location-slot input[type="text"] { flex-grow: 1; padding: 4px 8px; border-radius: 4px; border: 1px solid #6b7280; background-color: #374151; color: #d1d5db; }
        .location-slot .map-button, .location-slot .select-location-button { padding: 4px 8px; font-size: 0.8rem; border-radius: 4px; cursor: pointer; }
        .location-slot .map-button { background-color: #3b82f6; color: white; }
         .location-slot .select-location-button { background-color: #22c55e; color: white;}
        .location-slot .coords-display { font-size: 0.85em; color: #9ca3af; white-space: nowrap; }

        #location-picker-map-container { height: 300px; width: 100%; margin-top: 1rem; border: 1px solid #4b5563; border-radius: 5px; position: relative; overflow: hidden; display: none; }
        #location-picker-map-container.expanded { display: block; }
        #location-picker-map-container .leaflet-container { height: 100%; width: 100%; }
        #location-picker-map-container button { position: absolute; z-index: 401; padding: 5px 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em; }
        #picker-ok-map-button { bottom: 10px; left: 10px; background-color: #22c55e; color: white; }
        #picker-locate-me-button { bottom: 10px; right: 10px; background-color: #f59e0b; color: white; }


        body.light-mode .edit-modal, body.light-mode .edit-info-modal, body.light-mode .help-modal, body.light-mode .versions-modal-overlay, body.light-mode .saved-locations-modal, body.light-mode #postpone-options-modal, body.light-mode .reminder-table-modal, body.light-mode #config-modal, body.light-mode #saved-routes-modal {
             background-color: #e5e7eb; color: #18181b; box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
         body.light-mode .reminder-table-modal th { background-color: #d1d5db; color: #18181b; }
         body.light-mode .reminder-table-modal td { color: #18181b; border-color: #d1d5db; }
         body.light-mode .location-slot { background-color: #d1d5db; }
         body.light-mode .location-slot input[type="text"] { background-color: #e5e7eb; color: #18181b; border-color: #d1d5db; }
         body.light-mode #location-picker-map-container { border-color: #d1d5db; }


        .edit-modal h2, .edit-info-modal h2, .help-modal h2, .versions-modal-overlay h2, .saved-locations-modal h2, #postpone-options-modal h2, .reminder-table-modal h2, #config-modal h2, #saved-routes-modal h3 {
             text-align: center; color: #f59e0b; margin-bottom: 1.5rem;
        }
         body.light-mode .edit-modal h2, body.light-mode .edit-info-modal h2, body.light-mode .help-modal h2, body.light-mode .versions-modal-overlay h2, body.light-mode .saved-locations-modal h2, body.light-mode #postpone-options-modal h2, body.light-mode .reminder-table-modal h2, body.light-mode #config-modal h2, body.light-mode #saved-routes-modal h3 {
             color: #d97706;
         }


        .edit-modal label, .edit-modal input, .edit-modal select { display: block; margin-bottom: 10px; width: 100%; }
        .edit-modal input, .edit-modal select { padding: 8px; border-radius: 4px; border: 1px solid #6b7280; background-color: #4b5563; color: #d1d5db; }
         body.light-mode .edit-modal input, body.light-mode .edit-modal select { background-color: #d1d5db; color: #18181b; border-color: #6b7280;}

        .edit-modal button { padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px; }
        .edit-modal button:last-child { margin-right: 0; }
        .edit-modal .button-group { display: flex; justify-content: space-between; margin-top: 1.5rem; }

        .edit-modal .upload-section { margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid #6b7280; }
        .edit-modal .upload-section input[type="file"] { display: none; }
        .edit-modal .upload-button { display: inline-block; background-color: #3b82f6; color: white; padding: 8px 12px; border-radius: 4px; cursor: pointer; }
         body.light-mode .edit-modal .upload-button { background-color: #2563eb;}

        .editing-target { outline: 3px solid #f59e0b !important; outline-offset: 3px; box-shadow: 0 0 10px rgba(245, 158, 11, 0.5); }

        .help-modal, .versions-modal-overlay { z-index: 2000; }
        .help-modal h3, .versions-modal-overlay h3 { margin-top: 1rem; margin-bottom: 0.5rem; font-size: 1.1rem; color: #f59e0b; }
         body.light-mode .help-modal h3, body.light-mode .versions-modal-overlay h3 { color: #d97706; }
        .help-modal ul, .versions-modal-overlay ul { list-style-type: disc; margin-left: 20px; }
        .help-modal li, .versions-modal-overlay li { margin-bottom: 5px; font-size: 0.95rem; }
        .help-modal strong, .versions-modal-overlay strong { color: #d1d5db; }
        body.light-mode .help-modal strong, body.light-mode .versions-modal-overlay strong { color: #18181b; }

        .versions-modal-overlay .version-entry { margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid #6b7280; }
        .versions-modal-overlay .version-entry:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        .versions-modal-overlay .version-title { font-weight: bold; font-size: 1.2rem; color: #22c55e; }
         body.light-mode .versions-modal-overlay .version-title { color: #16a34a; }
        .versions-modal-overlay .version-date { font-style: italic; font-size: 0.9rem; color: #9ca3af; }
        .versions-modal-overlay .version-notes { margin-top: 5px; font-size: 0.95rem; }
        .versions-modal-overlay .version-notes ul { list-style-type: disc; margin-left: 20px; }
        .versions-modal-overlay .version-notes li { margin-bottom: 3px; }

        .versions-icon { position: fixed; bottom: 10px; right: 10px; font-size: 0.8rem; color: #9ca3af; cursor: pointer; text-decoration: underline; z-index: 500; opacity: 0.8; transition: opacity 0.3s; }
        .versions-icon:hover { opacity: 1; }
        body.light-mode .versions-icon { color: #6b7280; }
        .versions-icon.new-version-available { color: #f59e0b; font-weight: bold; animation: pulse 1.5s infinite; }
         body.light-mode .versions-icon.new-version-available { color: #d97706; }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }


        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
            z-index: 1001;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .grid-item:hover .tooltip { opacity: 1; }

        .draggable-marker { position: absolute; background-color: red; color: white; border-radius: 50%; width: 20px; height: 20px; text-align: center; line-height: 20px; font-weight: bold; cursor: grab; }
         .drag-helper { position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 999; }


        .modal-overlay {
             position: fixed;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             background-color: rgba(0, 0, 0, 0.7);
             z-index: 990;
        }

        .reminder-modal {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000;
            background-color: #374151; color: #d1d5db; padding: 1.5rem; border-radius: 1rem; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            max-width: 95%; max-height: 90vh; overflow-y: auto;
            width: 500px; display: flex; flex-direction: column;
        }
        body.light-mode .reminder-modal { background-color: #e5e7eb; color: #18181b; }
        .reminder-modal h2 { text-align: center; color: #f59e0b; margin-bottom: 1.5rem; }
         body.light-mode .reminder-modal h2 { color: #d97706; }
        .reminder-modal label { display: block; margin-bottom: 5px; font-weight: bold; }
        .reminder-modal input[type="text"],
        .reminder-modal input[type="time"],
        .reminder-modal input[type="date"],
        .reminder-modal input[type="number"] {
             display: block; width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #6b7280;
             background-color: #4b5563; color: #d1d5db; margin-bottom: 10px;
        }
         body.light-mode .reminder-modal input { background-color: #d1d5db; color: #18181b; border-color: #6b7280;}

        .reminder-modal .checkbox-group { margin-bottom: 10px; }
        .reminder-modal .checkbox-group label { display: inline-block; font-weight: normal; margin-right: 10px; }
        .reminder-modal .button-group { display: flex; justify-content: space-between; margin-top: 1.5rem; gap: 10px; }
        .reminder-modal .button-group button { padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; flex-grow: 1; }
        .reminder-modal .save-button { background-color: #22c55e; color: white; }
        .reminder-modal .cancel-button { background-color: #ef4444; color: white; }
        .reminder-modal .help-button { background-color: #3b82f6; color: white; }
        .reminder-modal .clear-button { background-color: #f59e0b; color: white; }
        .reminder-modal .view-button { background-color: #6366f1; color: white; }
        .reminder-modal .status-message { margin-top: 10px; text-align: center; font-size: 0.9rem; }

        .reminder-modal .map-container { width: 100%; height: 250px; margin-top: 10px; border: 1px solid #6b7280; border-radius: 4px; position: relative;}
         .reminder-modal .map-container .leaflet-container { height: 100%; width: 100%; }
        .reminder-modal .map-container .map-button { position: absolute; z-index: 401; padding: 5px 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em; }
        .reminder-modal .map-container .ok-map-button { bottom: 10px; left: 10px; background-color: #22c55e; color: white; }
        .reminder-modal .map-container .locate-me-button { bottom: 10px; right: 10px; background-color: #f59e0b; color: white; }
        .reminder-modal .map-container .saved-locations-button { bottom: 10px; left: 50%; transform: translateX(-50%); background-color: #3b82f6; color: white;}


        #reminder-button { position: relative; display: inline-flex; align-items: center; }
        #reminder-button .reminder-count {
             position: absolute; top: -5px; right: -5px; background-color: red; color: white;
             border-radius: 50%; padding: 2px 6px; font-size: 0.75rem; font-weight: bold;
        }

        #reminder-count-globe {
            position: fixed; top: 10px; left: 10px;
            width: 30px; height: 30px; border-radius: 50%; background-color: red; color: white;
            display: flex; justify-content: center; align-items: center;
            font-size: 0.8rem; font-weight: bold; z-index: 500;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            pointer-events: all; /* Make it clickable */
            cursor: pointer;
        }

        .unified-reminder-window {
             position: fixed;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             width: 95%;
             max-width: 600px;
             max-height: 95vh;
             background-color: #374151;
             border-radius: 1rem;
             box-shadow: 0 10px 30px rgba(0,0,0,0.5);
             z-index: 7000;
             display: none;
             flex-direction: column;
             overflow: hidden;
             transition: opacity 0.3s ease;
             opacity: 0;
        }
        body.light-mode .unified-reminder-window {
            background-color: #e5e7eb;
        }

        .unified-reminder-window.visible {
            display: flex;
            opacity: 1;
        }

        .reminder-count-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 1.5rem;
            background-color: #2d3748; /* Slightly darker header */
            border-bottom: 1px solid #4a5568;
            flex-shrink: 0;
        }
         body.light-mode .reminder-count-header { background-color: #cbd5e0; border-bottom-color: #a0aec0;}


        .reminder-count-header h2 {
            font-size: 1.3rem;
            color: #f59e0b;
            margin: 0;
        }
         body.light-mode .reminder-count-header h2 { color: #d97706;}


        .reminder-count-text-container {
            font-size: 1.1rem;
            color: #d1d5db;
        }
         body.light-mode .reminder-count-text-container { color: #4a5568; }


        #reminder-swiper-container {
            display: flex;
            overflow-x: auto;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch; /* Enable smooth scrolling on iOS */
             scrollbar-width: none; /* Hide scrollbar for Firefox */
            -ms-overflow-style: none; /* Hide scrollbar for Internet Explorer and Edge */
             flex-grow: 1;
        }
        #reminder-swiper-container::-webkit-scrollbar {
            display: none; /* Hide scrollbar for Chrome, Safari and Opera */
        }


        .reminder-slide {
            flex: 0 0 100%; /* Each slide takes 100% of the container width */
            width: 100%;
            scroll-snap-align: start;
            padding: 1.5rem;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            max-height: calc(95vh - 60px); /* Adjust based on header height */
            overflow-y: auto; /* Allow content inside slide to scroll if needed */
             scrollbar-width: thin; /* Show scrollbar for Firefox */
        }
         .reminder-slide::-webkit-scrollbar {
             width: 8px;
         }
         .reminder-slide::-webkit-scrollbar-track {
             background: #4b5563; /* Darker track */
             border-radius: 4px;
         }
         .reminder-slide::-webkit-scrollbar-thumb {
             background-color: #6b7280; /* Grey thumb */
             border-radius: 4px;
             border: 2px solid #4b5563; /* Padding around thumb */
         }
         body.light-mode .reminder-slide::-webkit-scrollbar-track { background: #d1d5db; }
         body.light-mode .reminder-slide::-webkit-scrollbar-thumb { background-color: #a0aec0; border-color: #d1d5db; }


        .reminder-slide-content {
             display: flex;
             flex-direction: column;
             flex-grow: 1;
        }
        .reminder-content-scrollable {
             flex-grow: 1;
             margin-bottom: 1rem;
        }

        .reminder-text {
            font-size: 1.5rem;
            font-weight: bold;
            color: #e5e7eb;
            margin-bottom: 1rem;
            word-wrap: break-word;
        }
         body.light-mode .reminder-text { color: #18181b;}


        .reminder-details {
            font-size: 1.15rem;
            color: #a0aec0;
            margin-bottom: 0.5rem;
        }
         body.light-mode .reminder-details { color: #4b5563; }


        .unified-reminder-window .button-group {
             display: flex;
             flex-direction: column;
             gap: 0.8rem;
             margin-top: auto; /* Push buttons to the bottom */
             flex-shrink: 0;
        }

        .unified-reminder-window .button-group button {
            padding: 0.8rem 1.5rem;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .unified-reminder-window .cancel { background-color: #ef4444; color: white; }
        .unified-reminder-window .cancel:hover { background-color: #dc2626; }
        .unified-reminder-window .postpone { background-color: #f59e0b; color: white; }
        .unified-reminder-window .postpone:hover { background-color: #d97706; }
        .unified-reminder-window .modify { background-color: #3b82f6; color: white; }
        .unified-reminder-window .modify:hover { background-color: #2563eb; }
         .unified-reminder-window .adjust-time-0001 { background-color: #10b981; color: white; font-size: 1.1rem; }
         .unified-reminder-window .adjust-time-0001:hover { background-color: #059669; }
         .unified-reminder-window .cancel-cyclic { background-color: #6b7280; color: white; font-size: 1.1rem; }
         .unified-reminder-window .cancel-cyclic:hover { background-color: #4b5563; }


        .reminder-swipe-hint {
            text-align: center;
            font-size: 0.9rem;
            color: #a0aec0;
            margin-top: 0.5rem;
             flex-shrink: 0;
        }
         body.light-mode .reminder-swipe-hint { color: #4b5563; }


         #hide-all-reminders-button {
             padding: 0.5rem 1rem;
             font-size: 0.9rem;
             background-color: #4b5563;
             color: white;
             border: none;
             border-radius: 0.3rem;
             cursor: pointer;
             transition: background-color 0.2s ease;
         }
         #hide-all-reminders-button:hover { background-color: #374151; }
         body.light-mode #hide-all-reminders-button { background-color: #a0aec0; color: #18181b; }
         body.light-mode #hide-all-reminders-button:hover { background-color: #8896a9; }


        .reminder-map-preview-container {
            margin-top: 1rem;
            width: 100%;
            /* height: 200px; */ /* Removed fixed height, flex will handle */
            border-radius: 0.5rem;
            overflow: hidden;
            flex-shrink: 0; /* Don't let it shrink */
             flex-basis: 200px; /* Give it a base size */
             min-height: 100px; /* Ensure min height */
        }
        .reminder-map-preview {
            width: 100%;
            height: 100%;
        }
        .reminder-map-preview .leaflet-container {
             height: 100%; width: 100%;
             z-index: 1; /* Ensure map is below modals/popups */
        }
         /* Specific z-index for Leaflet popups if needed */
        .reminder-map-preview .leaflet-popup-pane { z-index: 2; }


        .toast-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 1rem;
            z-index: 8000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none; /* Allow clicks through */
            min-width: 200px;
            text-align: center;
        }
        .toast-notification.show { opacity: 1; }
        .toast-success { background-color: #22c55e; }
        .toast-error { background-color: #ef4444; }
        .toast-warning { background-color: #f59e0b; }
        .toast-info { background-color: #3b82f6; }


        .yellow-border {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            box-sizing: border-box;
            border: 25px solid #FFFF00;
            z-index: 99999;
            pointer-events: none;
            opacity: 1;
            transition: opacity 0.5s ease-out;
        }


         #pin-modal {
             position: fixed;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             background-color: #18181b; /* Dark background */
             color: #f4f4f5; /* Light text */
             z-index: 10000; /* Ensure it's on top */
             display: flex;
             flex-direction: column;
             justify-content: center;
             align-items: center;
             font-family: sans-serif;
         }
         #pin-modal h2 {
             font-size: 2rem;
             margin-bottom: 1rem;
             color: #f59e0b;
         }
          #pin-modal p {
              margin-bottom: 1.5rem;
              font-size: 1.1rem;
          }
         #pin-input-container {
             display: flex;
             gap: 10px;
             margin-bottom: 1.5rem;
         }
         .pin-digit-input {
             width: 50px;
             height: 60px;
             font-size: 2rem;
             text-align: center;
             border: 2px solid #4b5563;
             border-radius: 8px;
             background-color: #374151;
             color: #f4f4f5;
             caret-color: #f59e0b;
             outline: none;
         }
         .pin-digit-input:focus {
             border-color: #f59e0b;
             box-shadow: 0 0 8px rgba(245, 158, 11, 0.5);
         }
          #pin-modal button {
              padding: 0.7rem 1.5rem;
              font-size: 1.1rem;
              font-weight: bold;
              background-color: #3b82f6;
              color: white;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              transition: background-color 0.2s ease;
          }
          #pin-modal button:hover {
              background-color: #2563eb;
          }
          #pin-modal .status-message {
              margin-top: 1rem;
              font-size: 1rem;
              color: #ef4444; /* Error color */
          }


        /* Styles for Config Modal */
         #config-modal { width: 90%; max-width: 700px; z-index: 8000; }
         #config-modal h2 { margin-bottom: 1rem; }
         #config-modal .tab-buttons { display: flex; justify-content: center; gap: 10px; margin-bottom: 1.5rem; }
         #config-modal .config-tab-button { padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; background-color: #6b7280; color: white; transition: background-color 0.2s; }
         #config-modal .config-tab-button.active { background-color: #f59e0b; }
         body.light-mode #config-modal .config-tab-button { background-color: #a0aec0; color: #18181b; }
         body.light-mode #config-modal .config-tab-button.active { background-color: #d97706; color: white; }

         #config-modal .tab-contents { border-top: 1px solid #6b7280; padding-top: 1.5rem; }
         #config-modal .config-tab-content { display: none; }
         #config-modal .config-tab-content.active { display: block; }

         #config-modal h3 { font-size: 1.3rem; margin-bottom: 1rem; color: #d1d5db; }
         body.light-mode #config-modal h3 { color: #374151; }

         #config-modal label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 0.95rem; }
         #config-modal input[type="text"], #config-modal input[type="number"], #config-modal textarea {
             display: block; width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #6b7280;
             background-color: #4b5563; color: #d1d5db; margin-bottom: 10px; box-sizing: border-box;
         }
          body.light-mode #config-modal input, body.light-mode #config-modal textarea { background-color: #d1d5db; color: #18181b; border-color: #6b7280;}

         #config-modal .user-data-grid {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
             gap: 15px;
             margin-bottom: 1.5rem;
         }
         #config-modal .user-data-grid .checkbox-container {
              grid-column: span 2; /* Make checkbox span two columns */
              display: flex; align-items: center;
         }
         #config-modal .user-data-grid .checkbox-container input { width: auto; margin-right: 8px; margin-bottom: 0; }
         #config-modal .user-data-grid .checkbox-container label { margin-bottom: 0; font-weight: normal; }


         #config-modal .pin-config-layout {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
              gap: 15px;
              align-items: end;
              margin-bottom: 1.5rem;
         }
         #config-modal .pin-input-group label { margin-bottom: 5px; }
         #config-modal .pin-input-group input { margin-bottom: 0; }
         #config-modal .pin-buttons-container { grid-column: span 2; display: flex; gap: 10px; justify-content: center; }
          #config-modal .pin-buttons-container button { flex-grow: 1; max-width: 200px; }


         #config-modal .backup-restore-container {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
             gap: 20px;
         }
         #config-modal .backup-restore-container > div {
              padding: 1rem; border: 1px solid #6b7280; border-radius: 8px;
              background-color: #4b5563;
         }
          body.light-mode #config-modal .backup-restore-container > div { background-color: #d1d5db; border-color: #a0aec0;}

         #config-modal .backup-restore-container h3 { margin-bottom: 0.5rem; font-size: 1.1rem; color: #e5e7eb; }
         body.light-mode #config-modal .backup-restore-container h3 { color: #18181b; }

         #config-modal .backup-restore-container p { font-size: 0.9rem; margin-bottom: 1rem; color: #a0aec0; }
         body.light-mode #config-modal .backup-restore-container p { color: #374151; }


         #config-backup-display { height: 150px; margin-top: 1rem; font-size: 0.8rem; }
         #config-restore-input { height: 150px; font-size: 0.8rem; }

         #config-modal button { padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px; font-weight: bold;}
         #config-modal button:last-child { margin-right: 0; }

         #config-modal .status-message { margin-top: 10px; text-align: center; font-size: 0.9rem; }

         #config-modal .borrar-container button { background-color: #ef4444; color: white; margin-bottom: 1rem; }
          body.light-mode #config-modal .borrar-container button { background-color: #dc2626; }
         #config-modal .borrar-container h3 { color: #ef4444; }
         body.light-mode #config-modal .borrar-container h3 { color: #dc2626; }
         #config-modal .borrar-container p { font-weight: bold; margin-bottom: 0; }
          #config-modal .borrar-container strong { color: red; }

         #config-modal .radar-filter-group {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
              gap: 10px;
              margin-bottom: 1rem;
         }
         #config-modal .radar-action-buttons {
              display: flex;
              gap: 15px;
              flex-wrap: wrap;
              margin-top: 1.5rem;
         }
         #config-modal #import-radars-button { background-color: #10b981; color: white; flex-grow: 1; }
         #config-modal #delete-filtered-radars-button { background-color: #ef4444; color: white; flex-grow: 1; }
          body.light-mode #config-modal #import-radars-button { background-color: #059669; }
          body.light-mode #config-modal #delete-filtered-radars-button { background-color: #dc2626; }

         #config-modal #radar-import-progress-container {
              margin-top: 1rem;
         }
         #config-modal #radar-import-progress-bar {
             width: 100%; height: 10px; border-radius: 5px;
             overflow: hidden; /* Ensure progress bar fills rounded edges */
             appearance: none; /* Remove default styles */
             -webkit-appearance: none; /* Safari/Chrome */
             border: 1px solid #6b7280; /* Border */
             background-color: #4b5563; /* Background for the 'empty' part */
         }

         /* Style for the filled part of the progress bar */
         #config-modal #radar-import-progress-bar::-webkit-progress-bar { background-color: #4b5563; }
         #config-modal #radar-import-progress-bar::-webkit-progress-value { background-color: #22c55e; } /* Green fill */
         #config-modal #radar-import-progress-bar::-moz-progress-bar { background-color: #22c55e; } /* Green fill */
         #config-modal #radar-import-progress-bar::-ms-fill { background-color: #22c55e; } /* Green fill */

          body.light-mode #config-modal #radar-import-progress-bar { border-color: #a0aec0; background-color: #d1d5db; }
          body.light-mode #config-modal #radar-import-progress-bar::-webkit-progress-bar { background-color: #d1d5db; }
          body.light-mode #config-modal #radar-import-progress-bar::-webkit-progress-value { background-color: #16a34a; }
          body.light-mode #config-modal #radar-import-progress-bar::-moz-progress-bar { background-color: #16a34a; }
          body.light-mode #config-modal #radar-import-progress-bar::-ms-fill { background-color: #16a34a; }


         #config-modal #radar-import-status { margin-top: 5px; font-size: 0.85rem; text-align: center; color: #a0aec0; }
          body.light-mode #config-modal #radar-import-status { color: #4b5563;}

         #config-modal .radar-import-options { display: flex; align-items: center; font-size: 0.9rem; margin-top: 1rem;}
         #config-modal .radar-import-options input { margin-right: 8px; width: auto; margin-bottom: 0;}
         #config-modal .radar-import-options label { margin-bottom: 0; font-weight: normal; color: #d1d5db; }
         body.light-mode #config-modal .radar-import-options label { color: #374151; }


         #reminders-location-map-modal {
             position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 999;
             background-color: #fff; /* Base background for map */
             display: flex; flex-direction: column;
         }
         #reminders-location-map-content-wrapper { display: flex; flex-direction: column; width: 100%; height: 100%;}
         #reminders-location-map-header {
             display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center;
             padding: 8px; background-color: #f4f4f5; flex-shrink: 0;
             box-shadow: 0 2px 5px rgba(0,0,0,0.1);
         }
         #reminders-location-map-header .button-group-main, #reminders-location-map-header .button-group-route { display: flex; gap: 5px; flex-wrap: wrap;}
         #reminders-location-map-header button { padding: 6px 10px; font-size: 0.85rem; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;}
         #reminders-location-map-header .reminders-map-button-action { background-color: #d1d5db; color: #374151;}
         #reminders-location-map-header .route-button-action { background-color: #f59e0b; color: white;}
          #reminders-location-map-header #create-route-button { background-color: #22c55e; color: white;}


         #reminders-location-map-div { flex-grow: 1; width: 100%; position: relative; }
         #reminders-location-map-div .leaflet-container { height: 100%; width: 100%; }


        /* Styles for Waypoint delete icon */
         .delete-waypoint-icon {
              position: absolute;
              top: -10px; /* Adjust position relative to marker element */
              right: -10px; /* Adjust position relative to marker element */
              width: 20px;
              height: 20px;
              background-color: red;
              color: white;
              border-radius: 50%;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 14px;
              font-weight: bold;
              cursor: pointer;
              z-index: 500; /* Ensure it's above other map elements */
              box-shadow: 0 0 5px rgba(0,0,0,0.5);
         }
        /* Ensure LRM waypoint markers have a position context for the delete icon */
        .leaflet-routing-container .leaflet-marker-draggable:not(.leaflet-marker-icon) {
             position: relative !important; /* Override LRM default if necessary */
         }
          /* Custom waypoint div icon needs relative position */
          .custom-waypoint-div-icon div { position: relative; }


         /* Styles for Progress Bar */
         #progress-bar-container {
              position: absolute; bottom: 0; left: 0; right: 0; height: 25px;
              background-color: rgba(0, 0, 0, 0.5); z-index: 400; display: none;
              box-sizing: border-box; padding: 0 5px; display: flex; align-items: center;
              flex-direction: column; justify-content: center;
         }
          #progress-bar-container #routing-info-panel {
              display: flex; justify-content: space-around; width: 100%;
              color: white; font-size: 0.8em; margin-bottom: 2px;
          }
           #progress-bar-container #routing-info-panel p { margin: 0; }
            #progress-bar-container #routing-info-panel strong { font-weight: bold; }

         #progress-bar-fill {
             height: 10px; background-color: orange; width: 0%;
             position: absolute; bottom: 0; left: 0; transition: width 0.5s linear;
             z-index: 401;
         }
         #progress-bar-text-overlay {
             position: absolute; bottom: 5px; left: 50%; transform: translateX(-50%);
             color: white; font-size: 0.8em; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
             z-index: 402; white-space: nowrap;
         }
          .waypoint-marker-on-progress {
              position: absolute;
              bottom: 0px; /* Align with the progress bar bottom */
              width: 8px;
              height: 8px;
              background-color: blue;
              border-radius: 50%;
              z-index: 403;
              transform: translateX(-50%); /* Center the dot on the calculated percentage */
          }


        /* Styles for Current Maneuver Panel */
         #current-maneuver-panel {
             position: absolute;
             top: 10px; /* Below the compass */
             left: 70px; /* To the right of the compass */
             background-color: rgba(255, 255, 255, 0.85);
             padding: 5px 10px;
             border-radius: 3px;
             box-shadow: 0 1px 4px rgba(0,0,0,0.3);
             z-index: 400; /* Below Leaflet controls */
             display: none; /* Hidden by default */
             align-items: center;
             gap: 10px;
             max-width: calc(100% - 85px); /* Leave space on the right */
             overflow: hidden; /* Prevent content overflow */
         }

         #current-maneuver-panel .maneuver-icon {
             width: 30px;
             height: 30px;
             background-size: contain;
             background-repeat: no-repeat;
             background-position: center;
              /* Map Leaflet Routing Machine icons */
         }
         .leaflet-routing-icon-continue { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 2a10 10 0 1010 10A10 10 0 0012 2zm0 18a8 8 0 118-8 8 8 0 01-8 8zm1-13v7a1 1 0 01-2 0v-7a1 1 0 012 0z"/></svg>'); }
         .leaflet-routing-icon-turn-left { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M13 18v-6h3.5a1 1 0 00.7-.29A1 1 0 0018 11.5V7a1 1 0 00-.3-.71 1 1 0 00-.7-.29h-2v-3a1 1 0 00-1.71-.71l-5 5a1 1 0 000 1.42l5 5A1 1 0 0013 18z"/></svg>'); transform: scaleX(-1); }
         .leaflet-routing-icon-turn-right { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M13 18v-6h3.5a1 1 0 00.7-.29A1 1 0 0018 11.5V7a1 1 0 00-.3-.71 1 1 0 00-.7-.29h-2v-3a1 1 0 00-1.71-.71l-5 5a1 1 0 000 1.42l5 5A1 1 0 0013 18z"/></svg>');}
         .leaflet-routing-icon-slight-left { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M13 19v-7a1 1 0 00-2 0v7a1 1 0 002 0zm-1-10a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h2a1 1 0 001-1V9zm0-4a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h2a1 1 0 001-1V5z"/></svg>'); transform: rotate(45deg) scaleX(-1);}
         .leaflet-routing-icon-slight-right { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M13 19v-7a1 1 0 00-2 0v7a1 1 0 002 0zm-1-10a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h2a1 1 0 001-1V9zm0-4a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h2a1 1 0 001-1V5z"/></svg>'); transform: rotate(-45deg); }
         .leaflet-routing-icon-sharp-left { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 18v-6a1 1 0 00-2 0v6a1 1 0 002 0zm0-10a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V8zm0-4a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V4z"/></svg>'); transform: rotate(90deg) scaleX(-1); }
         .leaflet-routing-icon-sharp-right { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 18v-6a1 1 0 00-2 0v6a1 1 0 002 0zm0-10a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V8zm0-4a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V4z"/></svg>'); transform: rotate(-90deg); }
         .leaflet-routing-icon-u-turn { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 18v-6a1 1 0 00-2 0v6a1 1 0 002 0zm0-10a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V8zm0-4a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V4z"/></svg>'); transform: rotate(180deg); } /* Using sharp turn icon rotated */
         .leaflet-routing-icon-roundabout { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 2a10 10 0 1010 10A10 10 0 0012 2zm0 18a8 8 0 118-8 8 8 0 01-8 8zm1-13v7a1 1 0 01-2 0v-7a1 1 0 012 0z"/></svg>'); } /* Using continue icon for simplicity */
          .leaflet-routing-icon-arrive { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 2a10 10 0 1010 10A10 10 0 0012 2zm0 18a8 8 0 118-8 8 8 0 01-8 8zm3-8a3 3 0 11-3-3 3 3 0 013 3z"/></svg>'); }
         .leaflet-routing-icon-depart { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 2a10 10 0 1010 10A10 10 0 0012 2zm0 18a8 8 0 118-8 8 8 0 01-8 8zm1-13v7a1 1 0 01-2 0v-7a1 1 0 012 0z"/></svg>'); } /* Using continue icon */
         .leaflet-routing-icon-fork { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 18v-6h3.5a1 1 0 00.7-.29A1 1 0 0018 11.5V7a1 1 0 00-.3-.71 1 1 0 00-.7-.29h-2v-3a1 1 0 00-1.71-.71l-5 5a1 1 0 000 1.42l5 5A1 1 0 0013 18z"/></svg>'); transform: rotate(-45deg); } /* Using right turn rotated */
         .leaflet-routing-icon-ramp { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 18v-6a1 1 0 00-2 0v6a1 1 0 002 0zm0-10a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V8zm0-4a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V4z"/></svg>'); transform: rotate(45deg); } /* Using sharp turn rotated */
         .leaflet-routing-icon-off-ramp { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 18v-6a1 1 0 00-2 0v6a1 1 0 002 0zm0-10a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V8zm0-4a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V4z"/></svg>'); transform: rotate(-135deg); } /* Using sharp turn rotated */


         #current-maneuver-panel .maneuver-text-container {
             display: flex;
             flex-direction: column;
             flex-grow: 1;
             min-width: 0; /* Allow text to shrink */
         }
         #current-maneuver-panel .maneuver-instruction {
             font-size: 1.1em;
             font-weight: bold;
             color: #333;
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis; /* Ellipsis for long instructions */
             line-height: 1.2;
         }
         #current-maneuver-panel .maneuver-distance {
             font-size: 0.9em;
             color: #555;
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
             line-height: 1.1;
         }
         #current-maneuver-panel .next-maneuver {
             font-size: 0.8em;
             color: #666;
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
             line-height: 1.1;
             margin-top: 2px;
         }


         /* Styles for Orientation Altitude Control (Top Left) */
         .leaflet-control-orientation-altitude {
             display: flex;
             flex-direction: column;
             align-items: center;
             margin-top: 10px;
             margin-left: 10px;
             z-index: 400; /* Below default Leaflet controls but above map */
         }

         #orientation-altitude-text-container {
            /* Styles defined inline in JS */
         }

         /* Responsive Adjustments */
         @media (max-width: 768px) {
             .grid-container { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 8px; padding: 12px;}
             .grid-item { padding: 8px; border-radius: 6px; }
             .grid-item img { width: 32px; height: 32px; margin-bottom: 4px; }
             .grid-item span { font-size: 0.8em; }

             .button-bar { gap: 0.5rem; padding: 0.3rem 0;}
             .on-off-button, .settings-button, .edit-button { padding: 0.4rem 0.8rem; font-size: 0.9rem;}

             .edit-modal, .edit-info-modal, .help-modal, .versions-modal-overlay, .saved-locations-modal, #postpone-options-modal, .reminder-table-modal, #config-modal, #saved-routes-modal {
                 width: 98%; padding: 1rem; border-radius: 0.8rem;
             }
             .reminder-modal { width: 98%; padding: 1rem; border-radius: 0.8rem; }

             .reminder-modal .button-group button { padding: 8px 12px; font-size: 1rem; }

             .reminder-table-modal { font-size: 0.8rem; padding: 0.5rem;}
             .reminder-table-modal th, .reminder-table-modal td { padding: 5px; }
             .reminder-table-modal .button-group button { padding: 3px 6px; font-size: 0.7rem; }

             #saved-locations-modal { width: 98%;}
             #saved-locations-list { max-height: 25vh; padding: 8px; }
             .location-slot { gap: 5px; margin-bottom: 8px; padding: 6px; }
             .location-slot input[type="text"] { padding: 3px 6px; }
             .location-slot .map-button, .location-slot .select-location-button { padding: 3px 6px; font-size: 0.7rem; }
             .location-slot .coords-display { font-size: 0.7em; }
             #location-picker-map-container { height: 200px; }

              #config-modal { width: 98%; padding: 1rem;}
              #config-modal .tab-buttons { flex-wrap: wrap; gap: 5px; }
              #config-modal .config-tab-button { flex-grow: 1; text-align: center; padding: 6px;}
              #config-modal .user-data-grid, #config-modal .pin-config-layout, #config-modal .backup-restore-container {
                  grid-template-columns: 1fr; gap: 10px;
              }
               #config-modal .user-data-grid .checkbox-container { grid-column: span 1;}
               #config-modal .pin-buttons-container { grid-column: span 1; flex-direction: column; }
               #config-modal .pin-buttons-container button { max-width: none; }

              #config-modal .radar-filter-group { grid-template-columns: 1fr; gap: 10px; }
              #config-modal .radar-filter-group div:nth-child(3) { grid-column: span 1;} /* Keywords input */
              #config-modal .radar-action-buttons { flex-direction: column; gap: 10px;}

             #reminders-location-map-header { padding: 5px; gap: 5px;}
             #reminders-location-map-header .button-group-main, #reminders-location-map-header .button-group-route { flex-direction: column; gap: 3px; flex-basis: 100%; align-items: stretch;}
             #reminders-location-map-header button { padding: 5px 8px; font-size: 0.8rem; }
             #reminders-location-map-header .route-button-action, #reminders-location-map-header .reminders-map-button-action { flex-grow: 1;}
              #reminders-location-map-header > div:last-child { margin-left: 0; width: 100%; justify-content: space-between;}
              #reminders-location-map-header > div:last-child .button-group-main { flex-direction: row; flex-grow: 1;}
              #reminders-location-map-header label { font-size: 0.8rem; }

             #current-maneuver-panel {
                 top: 5px;
                 left: auto;
                 right: 5px;
                 max-width: calc(100% - 55px); /* Leave space for smaller compass if needed */
                 padding: 3px 6px;
                 gap: 5px;
             }
             #current-maneuver-panel .maneuver-icon { width: 25px; height: 25px;}
             #current-maneuver-panel .maneuver-text-container { font-size: 0.9em;}
             #current-maneuver-panel .maneuver-instruction { font-size: 1em;}
             #current-maneuver-panel .maneuver-distance, #current-maneuver-panel .next-maneuver { font-size: 0.8em;}


             .leaflet-control-orientation-altitude {
                  margin-top: 5px;
                  margin-left: 5px;
             }
              .leaflet-control-orientation-altitude #compass-rose-icon {
                  width: calc(70px * 1.5 * 0.9); height: calc(70px * 1.5 * 0.9);
                  margin-bottom: 3px;
              }
              .leaflet-control-orientation-altitude #orientation-altitude-text-container {
                   padding: calc(4px * 0.6) calc(6px * 0.6);
              }
               .leaflet-control-orientation-altitude #orientation-text,
              .leaflet-control-orientation-altitude #altitude-display {
                  font-size: calc(1.5em * 0.85 * 1.0);
              }
         }


         /* Styles for Light Mode */
         body.light-mode #reminders-location-map-header { background-color: #d1d5db; }
         body.light-mode #reminders-location-map-header .reminders-map-button-action { background-color: #e5e7eb; color: #18181b; }
          body.light-mode #reminders-location-map-header .route-button-action { background-color: #d97706; color: white;}
           body.light-mode #reminders-location-map-header #create-route-button { background-color: #16a34a; color: white;}


         body.light-mode #pin-modal { background-color: #f4f4f5; color: #18181b; }
         body.light-mode #pin-modal h2 { color: #d97706; }
         body.light-mode #pin-digit-input {
             border-color: #a0aec0;
             background-color: #e5e7eb;
             color: #18181b;
             caret-color: #d97706;
         }
         body.light-mode #pin-digit-input:focus { border-color: #d97706; box-shadow: 0 0 8px rgba(217, 119, 6, 0.5);}
         body.light-mode #pin-modal button { background-color: #2563eb; }
         body.light-mode #pin-modal .status-message { color: #dc2626;}

          body.light-mode .button-countdown { color: #555; }
          body.light-mode .button-countdown-timer { color: #555; }


        /* General modal button styling */
         .edit-modal button, .edit-info-modal button, .help-modal button,
         .versions-modal-overlay button, .saved-locations-modal button,
         #postpone-options-modal button, .reminder-table-modal button,
         #config-modal button, #saved-routes-modal button {
              transition: background-color 0.2s ease, opacity 0.2s ease;
         }

         .edit-modal button:hover, .edit-info-modal button:hover, .help-modal button:hover,
         .versions-modal-overlay button:hover, .saved-locations-modal button:hover,
         #postpone-options-modal button:not(#cancel-postpone):hover, .reminder-table-modal button:hover,
         #config-modal button:not(#config-clear-cache):hover, #saved-routes-modal button:not(.delete-route-btn):hover {
              opacity: 0.8; /* Simple hover effect */
         }
          #postpone-options-modal #cancel-postpone:hover,
          #config-modal #config-clear-cache:hover, #saved-routes-modal .delete-route-btn:hover {
               opacity: 0.8;
          }


         /* Styles for modal countdown timers */
         .button-countdown { font-weight: normal; }
         .button-countdown-timer { font-weight: normal; }


    </style>
</head>
<body class="dark-mode">
    <div class="modal-overlay" style="display:none;"></div>

    <div class="button-bar">
         <button id="on-off-button" class="on-off-button" title="Activar/Desactivar Recordatorios">ON/OFF</button>
         <button id="reminder-button" class="settings-button" title="Gestionar Recordatorios">RECORDATORIOS</button>
         <button id="map-button" class="settings-button" title="Mapa de Ubicaciones/Radares y Rutas">MAPA</button>
         <button id="settings-button" class="settings-button" title="Configuración y Datos">CONFIG</button>
         <button id="edit-grid-button" class="edit-button" title="Editar Grid (Mover/Borrar)">EDITAR GRID</button>
    </div>
    <div id="filter-bar" class="flex justify-center items-center p-3" style="display: none;">
         <input type="text" id="grid-filter-input" placeholder="Filtrar botones..." class="px-2 py-1 rounded border text-sm" style="min-width: 200px; background-color: #4b5563; border-color: #6b7280; color: #d1d5db;">
         <button id="clear-filter-button" class="ml-2 px-3 py-1 text-sm rounded" style="background-color: #ef4444; color: white;">X</button>
     </div>

    <div id="grid-container" class="grid-container">
        <!-- Grid items will be rendered here -->
    </div>

    <div id="unified-reminder-window" class="unified-reminder-window">
         <div class="reminder-count-header">
             <h2>Recordatorios Activos</h2>
             <div class="reminder-count-text-container">
                 <span id="current-reminder-index">0</span> / <span id="total-reminder-count">0</span>
             </div>
             <button id="hide-all-reminders-button" class="hidden">Posponer Todos 1 min</button>
         </div>
         <div id="reminder-swiper-container">
             <!-- Reminder slides will be added here -->
         </div>
         <p id="reminder-swipe-hint" style="text-align:center; font-size:0.9rem; color:#a0aec0; padding: 0.5rem 0; display:none;">Desliza para ver más recordatorios</p>
    </div>

    <span id="reminder-count-globe" style="display:none;"></span>
    <span id="versions-icon" class="versions-icon">Versiones</span>


    <script>
    // Global Variables
    let allLocationsMapInstance = null;
    let locationWatchId = null;
    let shouldCenterOnUserInAllLocationsMap = true;
    let initialUserLocationMarker = null;
    let initialUserLocationMarkerLat = null;
    let initialUserLocationMarkerLng = null;
    let initialUserLocationCircle = null;
    let orientationAltitudeControl = null;
    let radarMarkerIcon;
    let defaultLocationMarkerIconBlue;
    let carIcon;

    let customData = {
        bookmarks: {},
        toggles: {}
    };
    let isEditMode = false;
    let isAssignmentMode = false;
    let isKeywordAssignmentMode = false;
    let editingTargetElement = null;
    let dragTargetElement = null;
    let dragPlaceholderElement = null;
    let dragOffsetX, dragOffsetY;

    const MAX_SAVED_LOCATIONS = 10;
    const SAVED_LOCATIONS_KEY = 'boardinggate_saved_locations';
    const SHOW_EXCLUDED_REMINDERS_KEY = 'boardinggate_show_excluded_reminders';
    let tempSavedLocations = []; // Used for modal editing

    let reminderModalMap = null;
    let reminderModalMarker = null;
    let currentReminderLocation = null;
    let currentReminderBeingEdited = null;
    let mapShouldReopenAfterForm = false;

    let locationPickerMap = null;
    let locationPickerMarker = null;
    let currentEditingLocationSlotIndex = -1;

    let previewMaps = {}; // Store Leaflet map instances for unified window previews

    let reminderCheckIntervalId = null;
    let currentCheckIntervalDuration = 60000; // Start with 60 seconds
    let isUnifiedWindowVisibleByLogic = false;
    let currentNotificationSlideIndex = 0;
    let fromReminderModal = false; // Flag to indicate if opening table from reminder modal

    let storedPin = null;
    let isPasswordActive = false;
    let isRemindersLocationMapActive = false;


    // Map Related Icons
    radarMarkerIcon = new L.Icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-violet.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
    });
    defaultLocationMarkerIconBlue = new L.Icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
    });
     carIcon = L.icon({
        iconUrl: 'Coche.PNG', // Path to your car icon image
        iconSize: [30, 30], // Size of the icon
        iconAnchor: [15, 15] // Point of the icon which will correspond to marker's location (center of the icon)
    });


    // Helper to get URL parameter
    function getUrlParameter(name) {
        name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
        const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
        const results = regex.exec(location.search);
        return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
    }

    // Load custom grid data from localStorage
    function loadCustomData() {
        try {
            const data = localStorage.getItem('customGridData');
            if (data) {
                customData = JSON.parse(data);
            }
        } catch (e) {
            console.error("Error loading custom grid data:", e);
        }
    }

    // Save custom grid data to localStorage
    function saveCustomData() {
        try {
            localStorage.setItem('customGridData', JSON.stringify(customData));
        } catch (e) {
            console.error("Error saving custom grid data:", e);
        }
    }

     // Load settings from localStorage
     function loadSavedSettings() {
        try {
            const darkMode = localStorage.getItem('darkMode');
            if (darkMode !== null) {
                document.body.classList.toggle('light-mode', darkMode !== 'true');
            } else {
                document.body.classList.remove('light-mode'); // Default to dark mode
            }

            const onOffState = localStorage.getItem('onOffState');
            const onOffButton = document.getElementById('on-off-button');
            if (onOffButton) {
                 if (onOffState === 'false') {
                     onOffButton.classList.remove('active');
                     onOffButton.textContent = 'OFF';
                     // Disable reminders logic here if needed
                 } else {
                     onOffButton.classList.add('active');
                     onOffButton.textContent = 'ON';
                      // Enable reminders logic here if needed
                 }
            }

            const filterValue = localStorage.getItem('gridFilterValue');
            const filterInput = document.getElementById('grid-filter-input');
            if (filterInput && filterValue !== null) {
                 filterInput.value = filterValue;
                 filterGridItems();
                 document.getElementById('filter-bar').style.display = 'flex'; // Show filter bar if value exists
            } else if (document.getElementById('filter-bar')) {
                 document.getElementById('filter-bar').style.display = 'none';
            }


        } catch (e) {
            console.error("Error loading saved settings:", e);
        }
    }

     // Save settings to localStorage
     function saveSettings() {
         try {
             const darkMode = document.body.classList.contains('dark-mode');
             localStorage.setItem('darkMode', darkMode.toString());

             const onOffButton = document.getElementById('on-off-button');
             if (onOffButton) {
                 localStorage.setItem('onOffState', onOffButton.classList.contains('active').toString());
             }

              const filterInput = document.getElementById('grid-filter-input');
              if (filterInput && filterInput.value.trim()) {
                   localStorage.setItem('gridFilterValue', filterInput.value);
              } else {
                   localStorage.removeItem('gridFilterValue');
              }

         } catch (e) {
             console.error("Error saving settings:", e);
         }
     }


    // Initial grid data
    const initialGridData = {
        'start-reminder': { icon: 'Reloj.PNG', text: 'RECORDATORIO', action: 'showReminderModal', category: 'reminder', keywords: 'alarma fecha hora' },
        'list-reminders': { icon: 'Lista.PNG', text: 'VER LISTA', action: 'showAllReminders', category: 'reminder', keywords: 'lista tabla' },
        'saved-locations': { icon: 'Guardados.PNG', text: 'UBICACIONES', action: 'showSavedLocationsModal', category: 'location', keywords: 'guardar ubicacion mapa poi' },
        'map-radars': { icon: 'Mapa.PNG', text: 'MAPA RUTAS', action: 'showAllRemindersLocationMap', category: 'location', keywords: 'mapa gps ruta navegar radar' },
        'dark-mode': { icon: 'ModoOscuro.PNG', text: 'MODO OSCURO', action: 'toggleDarkMode', category: 'ui', keywords: 'apariencia luz noche dia' },
         'help': { icon: 'Ayuda.PNG', text: 'AYUDA', action: 'showHelpModal', category: 'ui', keywords: 'instrucciones manual' },
         'config': { icon: 'Config.PNG', text: 'CONFIG', action: 'showConfigModal', category: 'system', keywords: 'ajustes datos backup importar borrar' },
        // Add more initial items as needed
    };

    // Render the grid based on current customData or initialData
    function renderGrid() {
        const gridContainer = document.getElementById('grid-container');
        if (!gridContainer) return;

        // Use initial data keys if custom data is empty
        const itemsToRender = Object.keys(customData.bookmarks).length > 0 ? customData.bookmarks : initialGridData;

        gridContainer.innerHTML = ''; // Clear current grid

        // Ensure customData.bookmarks is populated from initial data if empty
        if (Object.keys(customData.bookmarks).length === 0) {
             customData.bookmarks = { ...initialGridData };
             saveCustomData(); // Save the initial state to customData
        }


        // Create grid items from customData.bookmarks
        for (const key in customData.bookmarks) {
             if (Object.hasOwnProperty.call(customData.bookmarks, key)) {
                 const itemData = customData.bookmarks[key];
                 const gridItem = document.createElement('div');
                 gridItem.className = 'grid-item';
                 gridItem.dataset.key = key;
                 gridItem.setAttribute('role', 'button');
                 gridItem.setAttribute('aria-label', itemData.text);


                 gridItem.innerHTML = `
                     <img src="${itemData.icon}" alt="${itemData.text}">
                     <span>${itemData.text}</span>
                 `;

                 // Add event listener for action
                 if (itemData.action && typeof window[itemData.action] === 'function') {
                     gridItem.addEventListener('click', () => {
                         if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) {
                              window[itemData.action]();
                         } else if (isAssignmentMode && editingTargetElement) {
                              assignActionToButton(editingTargetElement, key, itemData.action, itemData.icon, itemData.text);
                         } else if (isKeywordAssignmentMode && editingTargetElement) {
                             addKeywordToButton(editingTargetElement, itemData.keywords);
                         }
                     });
                      // Add event listener for editing mode
                     gridItem.addEventListener('mousedown', (e) => { handleItemMouseDown(e, gridItem); });
                     gridItem.addEventListener('touchstart', (e) => { handleItemTouchStart(e, gridItem); }, { passive: false });
                 } else {
                      // Handle items with no action (e.g., placeholders in editing mode)
                      gridItem.style.opacity = 0.7;
                 }


                 gridContainer.appendChild(gridItem);
             }
        }

         filterGridItems();
         checkToggleButtonsState();
         adjustButtonPositions(); // Adjust positions after rendering

         // Attach drag end listeners to the document to handle drops anywhere
        document.removeEventListener('mouseup', handleItemMouseUp);
        document.addEventListener('mouseup', handleItemMouseUp);
        document.removeEventListener('touchend', handleItemTouchEnd);
        document.addEventListener('touchend', handleItemTouchEnd, { passive: false });
        document.removeEventListener('mousemove', handleItemMouseMove);
        document.addEventListener('mousemove', handleItemMouseMove);
        document.removeEventListener('touchmove', handleItemTouchMove);
        document.addEventListener('touchmove', handleItemTouchMove, { passive: false });

    }

     function filterGridItems() {
         const filterInput = document.getElementById('grid-filter-input');
         const filterValue = filterInput ? filterInput.value.trim().toUpperCase() : '';
         const gridItems = document.querySelectorAll('.grid-item');

         if (!filterValue) {
             gridItems.forEach(item => {
                 item.classList.remove('hidden-filter');
                 item.style.display = ''; // Reset display style
             });
             document.getElementById('filter-bar').style.display = 'none'; // Hide filter bar
             return;
         }

         document.getElementById('filter-bar').style.display = 'flex'; // Show filter bar

         gridItems.forEach(item => {
             const key = item.dataset.key;
             const itemData = customData.bookmarks[key]; // Use customData for filtering

             if (!itemData) { // Should not happen if renderGrid is correct, but for safety
                 item.classList.add('hidden-filter');
                 item.style.display = 'none';
                 return;
             }

             const textMatch = itemData.text.toUpperCase().includes(filterValue);
             const keyMatch = key.toUpperCase().includes(filterValue);
             const keywordsMatch = itemData.keywords ? itemData.keywords.toUpperCase().includes(filterValue) : false;

             if (textMatch || keyMatch || keywordsMatch) {
                 item.classList.remove('hidden-filter');
                 item.style.display = '';
             } else {
                 item.classList.add('hidden-filter');
                 item.style.display = 'none';
             }
         });
     }


    // Drag and drop logic
    function handleItemMouseDown(e, item) {
        if (!isEditMode) return;
        if (e.button !== 0) return; // Only left click

        dragTargetElement = item;
        const rect = dragTargetElement.getBoundingClientRect();
        dragOffsetX = e.clientX - rect.left;
        dragOffsetY = e.clientY - rect.top;

        dragTargetElement.classList.add('dragging');
        dragTargetElement.style.position = 'fixed';
        dragTargetElement.style.zIndex = 1000;
        dragTargetElement.style.width = `${rect.width}px`;
        dragTargetElement.style.height = `${rect.height}px`;
        dragTargetElement.style.pointerEvents = 'none'; // Prevent clicks on the dragged element

        // Create placeholder
        dragPlaceholderElement = document.createElement('div');
        dragPlaceholderElement.className = 'grid-item placeholder';
        dragPlaceholderElement.style.opacity = 0.5;
        dragPlaceholderElement.style.border = '2px dashed #f59e0b';
        dragPlaceholderElement.style.backgroundColor = 'rgba(245, 158, 11, 0.2)';
        dragPlaceholderElement.style.boxSizing = 'border-box';
        dragPlaceholderElement.style.width = `${rect.width}px`;
        dragPlaceholderElement.style.height = `${rect.height}px`;

        dragTargetElement.parentNode.insertBefore(dragPlaceholderElement, dragTargetElement);

        // Add a helper div to track mouse movement outside the grid
        const dragHelper = document.createElement('div');
        dragHelper.className = 'drag-helper';
        document.body.appendChild(dragHelper);

        // Initial position update
        handleItemMouseMove(e);

        document.body.style.cursor = 'grabbing';
    }

    function handleItemMouseMove(e) {
         if (!dragTargetElement) return;

         // Prevent default scrolling behavior on touch devices
         if (e.type === 'touchmove') {
              e.preventDefault();
              e = e.touches[0]; // Use the first touch point
         }

        const x = e.clientX - dragOffsetX;
        const y = e.clientY - dragOffsetY;

        dragTargetElement.style.left = `${x}px`;
        dragTargetElement.style.top = `${y}px`;

         // Reorder items in the grid based on drag position
        const gridContainer = document.getElementById('grid-container');
        const children = Array.from(gridContainer.children).filter(child => child !== dragTargetElement && child !== dragPlaceholderElement);
        let targetIndex = children.length;

        // Find the closest child center to the dragged element's center
        const draggedCenterX = e.clientX;
        const draggedCenterY = e.clientY;

        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            const childRect = child.getBoundingClientRect();
            const childCenterX = childRect.left + childRect.width / 2;
            const childCenterY = childRect.top + childRect.height / 2;

             // Determine insertion point based on distance to centers
             // More complex logic needed for proper sorting in multi-column grid
             // Simple implementation: insert before the first item whose center is after the dragged item's center
             if (draggedCenterY < childCenterY || (draggedCenterY === childCenterY && draggedCenterX < childCenterX)) {
                 targetIndex = i;
                 break;
             }
        }

        // Insert placeholder at the target index
        if (targetIndex < children.length) {
            gridContainer.insertBefore(dragPlaceholderElement, children[targetIndex]);
        } else {
            gridContainer.appendChild(dragPlaceholderElement);
        }
    }


    function handleItemMouseUp(e) {
        if (!dragTargetElement) return;
        if (e.button !== 0) return;

        finalizeDrag(e);
    }

     function handleItemTouchStart(e, item) {
         if (!isEditMode) return;
         if (e.touches.length !== 1) return; // Only single touch

         e.preventDefault(); // Prevent default touch behavior (like scrolling)

         dragTargetElement = item;
         const rect = dragTargetElement.getBoundingClientRect();
         dragOffsetX = e.touches[0].clientX - rect.left;
         dragOffsetY = e.touches[0].clientY - rect.top;

         dragTargetElement.classList.add('dragging');
         dragTargetElement.style.position = 'fixed';
         dragTargetElement.style.zIndex = 1000;
         dragTargetElement.style.width = `${rect.width}px`;
         dragTargetElement.style.height = `${rect.height}px`;
         dragTargetElement.style.pointerEvents = 'none'; // Prevent further touch events on the dragged element

         // Create placeholder
         dragPlaceholderElement = document.createElement('div');
         dragPlaceholderElement.className = 'grid-item placeholder';
         dragPlaceholderElement.style.opacity = 0.5;
         dragPlaceholderElement.style.border = '2px dashed #f59e0b';
         dragPlaceholderElement.style.backgroundColor = 'rgba(245, 158, 11, 0.2)';
         dragPlaceholderElement.style.boxSizing = 'border-box';
         dragPlaceholderElement.style.width = `${rect.width}px`;
         dragPlaceholderElement.style.height = `${rect.height}px`;

         dragTargetElement.parentNode.insertBefore(dragPlaceholderElement, dragTargetElement);

          // Add a helper div for touch
         const dragHelper = document.createElement('div');
         dragHelper.className = 'drag-helper';
         document.body.appendChild(dragHelper);


         // Initial position update
         handleItemTouchMove(e);

         document.body.style.cursor = 'grabbing';
     }

    function handleItemTouchMove(e) {
        if (!dragTargetElement) return;
        if (e.touches.length !== 1) return;

        e.preventDefault(); // Prevent default touch behavior (like scrolling)

        const x = e.touches[0].clientX - dragOffsetX;
        const y = e.touches[0].clientY - dragOffsetY;

        dragTargetElement.style.left = `${x}px`;
        dragTargetElement.style.top = `${y}px`;

        // Reorder items in the grid based on drag position (using touch coordinates)
        const gridContainer = document.getElementById('grid-container');
        const children = Array.from(gridContainer.children).filter(child => child !== dragTargetElement && child !== dragPlaceholderElement);
        let targetIndex = children.length;

        // Find the closest child center to the dragged element's center
        const draggedCenterX = e.touches[0].clientX;
        const draggedCenterY = e.touches[0].clientY;


        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            const childRect = child.getBoundingClientRect();
            const childCenterX = childRect.left + childRect.width / 2;
            const childCenterY = childRect.top + childRect.height / 2;

             // Determine insertion point based on distance to centers
             if (draggedCenterY < childCenterY || (draggedCenterY === childCenterY && draggedCenterX < childCenterX)) {
                 targetIndex = i;
                 break;
             }
        }

        // Insert placeholder at the target index
        if (targetIndex < children.length) {
            gridContainer.insertBefore(dragPlaceholderElement, children[targetIndex]);
        } else {
            gridContainer.appendChild(dragPlaceholderElement);
        }
    }


     function handleItemTouchEnd(e) {
         if (!dragTargetElement) return;
         // Prevent synthetic mouse events after touch end if needed
         // e.preventDefault();

         finalizeDrag(e);
     }


    function finalizeDrag(e) {
        if (!dragTargetElement) return;

        const gridContainer = document.getElementById('grid-container');
        const children = Array.from(gridContainer.children).filter(child => child !== dragTargetElement); // Filter out the dragged element

        // Find the current position of the placeholder among the other grid items
        let placeholderIndex = -1;
        for(let i = 0; i < children.length; i++){
            if(children[i] === dragPlaceholderElement){
                placeholderIndex = i;
                break;
            }
        }

         // If placeholder found, insert the dragged element before it.
         // If not found (shouldn't happen with current logic, but fallback), append to end.
        if (placeholderIndex !== -1) {
             gridContainer.insertBefore(dragTargetElement, children[placeholderIndex]);
        } else {
             gridContainer.appendChild(dragTargetElement);
        }


        // Remove dragging styles and temporary elements
        dragTargetElement.classList.remove('dragging');
        dragTargetElement.style.position = '';
        dragTargetElement.style.zIndex = '';
        dragTargetElement.style.width = '';
        dragTargetElement.style.height = '';
        dragTargetElement.style.pointerEvents = '';

        if (dragPlaceholderElement && dragPlaceholderElement.parentNode) {
            dragPlaceholderElement.parentNode.removeChild(dragPlaceholderElement);
        }
         const dragHelper = document.querySelector('.drag-helper');
         if (dragHelper && dragHelper.parentNode) {
             dragHelper.parentNode.removeChild(dragHelper);
         }

        dragTargetElement = null;
        dragPlaceholderElement = null;
        document.body.style.cursor = 'default';

        // Save the new order
        saveGridOrder();
    }

     function saveGridOrder() {
         const gridContainer = document.getElementById('grid-container');
         const currentOrder = Array.from(gridContainer.children)
             .map(item => item.dataset.key)
             .filter(key => key); // Filter out potential non-grid-item children

         const newBookmarks = {};
          // Create a new bookmarks object based on the current DOM order
         currentOrder.forEach(key => {
             if (customData.bookmarks[key]) {
                 newBookmarks[key] = customData.bookmarks[key];
             } else if (initialGridData[key]) { // Fallback to initial data if somehow missed
                 newBookmarks[key] = initialGridData[key];
             }
         });

         // Add back any items that might have been in customData but not in the current DOM (e.g., were hidden by filter)
         // This shouldn't be necessary if we render ALL items and only hide with CSS, but is a safer approach
          for (const key in customData.bookmarks) {
              if (Object.hasOwnProperty.call(customData.bookmarks, key) && !newBookmarks[key]) {
                  newBookmarks[key] = customData.bookmarks[key];
              }
          }

         customData.bookmarks = newBookmarks;
         saveCustomData();
         console.log("Grid order saved.");
     }


    // Toggle edit mode for grid
    function toggleEditMode() {
        isEditMode = !isEditMode;
        const editButton = document.getElementById('edit-grid-button');
        const gridContainer = document.getElementById('grid-container');
        const filterBar = document.getElementById('filter-bar');

        if (isEditMode) {
            document.body.classList.add('edit-mode-active');
            if (editButton) editButton.textContent = 'SALIR EDITOR';
             if (filterBar) filterBar.style.display = 'flex'; // Always show filter in edit mode
             // Allow dragging handles for deletion
             addDeleteHandlesToItems();

        } else {
            document.body.classList.remove('edit-mode-active');
            if (editButton) editButton.textContent = 'EDITAR GRID';
             // Hide filter bar if filter input is empty
             const filterInput = document.getElementById('grid-filter-input');
             if (filterInput && filterInput.value.trim() === '' && filterBar) {
                 filterBar.style.display = 'none';
             }
             removeDeleteHandlesFromItems();
             // Ensure no drag/assign/keyword modes are left active
             stopAssignmentMode();
             stopKeywordAssignmentMode();
        }
    }

     function addDeleteHandlesToItems() {
         document.querySelectorAll('.grid-item').forEach(item => {
             if (!item.querySelector('.delete-handle')) {
                 const deleteHandle = document.createElement('div');
                 deleteHandle.className = 'delete-handle';
                 deleteHandle.innerHTML = 'X';
                 deleteHandle.style.cssText = `
                     position: absolute; top: -8px; right: -8px;
                     width: 24px; height: 24px; background-color: red;
                     color: white; border-radius: 50%; text-align: center;
                     line-height: 24px; font-weight: bold; cursor: pointer;
                     z-index: 10; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
                 `;
                 item.style.position = 'relative'; // Ensure position context for handle
                 item.appendChild(deleteHandle);

                 deleteHandle.addEventListener('click', (e) => {
                     e.stopPropagation(); // Prevent grid item click
                     const itemKey = item.dataset.key;
                     if (confirm(`¿Seguro que quieres borrar "${customData.bookmarks[itemKey]?.text || itemKey}"?`)) {
                         delete customData.bookmarks[itemKey];
                         saveCustomData();
                         item.remove();
                         showToast(`Botón "${itemKey}" borrado.`, 'info');
                         saveGridOrder(); // Resave order after deletion
                     }
                 });
             }
         });
     }

     function removeDeleteHandlesFromItems() {
         document.querySelectorAll('.grid-item .delete-handle').forEach(handle => {
             handle.remove();
         });
          document.querySelectorAll('.grid-item').forEach(item => {
              item.style.position = ''; // Remove relative position if added
          });
     }


     function startAssignmentMode(targetElement) {
        if (!isEditMode) return; // Only allow assignment if in edit mode
        stopAssignmentMode(); // Stop any existing assignment mode
        stopKeywordAssignmentMode(); // Stop keyword assignment too

        isAssignmentMode = true;
        editingTargetElement = targetElement;
        editingTargetElement.classList.add('editing-target');

        const assignButton = document.getElementById('assign-action-button'); // Assumes this button exists in edit mode UI
        if (assignButton) assignButton.textContent = 'CANCELAR ASIGNACIÓN';

        showToast('Pulsa el botón del grid que quieres asignar.', 'info', 5000);
     }

      function stopAssignmentMode() {
         isAssignmentMode = false;
         if (editingTargetElement) {
             editingTargetElement.classList.remove('editing-target');
             editingTargetElement = null;
         }
          const assignButton = document.getElementById('assign-action-button');
          if (assignButton) assignButton.textContent = 'ASIGNAR ACCIÓN'; // Reset button text
     }

      function assignActionToButton(targetElement, sourceKey, action, icon, text) {
          const targetKey = targetElement.dataset.key;
          if (!targetKey) {
              showToast("Error: No se encontró la clave del botón de destino.", "error");
              stopAssignmentMode();
              return;
          }

           if (customData.bookmarks[targetKey] && customData.bookmarks[targetKey].isStatic) {
               showToast("No puedes sobrescribir un botón estático.", "warning");
               stopAssignmentMode();
               return;
           }


          // Update the target button's data
          customData.bookmarks[targetKey] = {
              action: action,
              icon: icon,
              text: text,
              category: customData.bookmarks[sourceKey]?.category || 'custom', // Keep category if exists or set to custom
              keywords: customData.bookmarks[sourceKey]?.keywords || '', // Copy keywords
              isStatic: false // Make sure custom assigned buttons are not static
          };
          saveCustomData();

          // Update the target button's appearance in the DOM
          targetElement.querySelector('img').src = icon;
          targetElement.querySelector('span').textContent = text;
          targetElement.setAttribute('aria-label', text);

           // Re-attach click listener to the target button (important if action changed)
          if (action && typeof window[action] === 'function') {
              // Remove old listener first
              const oldListener = targetElement._clickListener;
              if (oldListener) {
                  targetElement.removeEventListener('click', oldListener);
              }
               // Add new listener
              const newListener = () => {
                  if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) {
                      window[action]();
                  } else if (isAssignmentMode && editingTargetElement === targetElement) {
                       // Do nothing, this is the target button you clicked
                  } else if (isAssignmentMode && editingTargetElement) {
                       // Assigning *from* this button *to* the editingTargetElement
                       assignActionToButton(editingTargetElement, targetKey, action, icon, text);
                  } else if (isKeywordAssignmentMode && editingTargetElement) {
                       addKeywordToButton(editingTargetElement, customData.bookmarks[targetKey]?.keywords);
                  }
              };
              targetElement.addEventListener('click', newListener);
              targetElement._clickListener = newListener; // Store reference to remove later

          } else {
              // If action is removed or invalid, clear listener
              const oldListener = targetElement._clickListener;
              if (oldListener) {
                  targetElement.removeEventListener('click', oldListener);
                  targetElement._clickListener = null;
              }
          }
           // Re-attach drag listeners (they might be removed/added by renderGrid)
          targetElement.removeEventListener('mousedown', handleItemMouseDown);
          targetElement.removeEventListener('touchstart', handleItemTouchStart);
          targetElement.addEventListener('mousedown', (e) => { handleItemMouseDown(e, targetElement); });
          targetElement.addEventListener('touchstart', (e) => { handleItemTouchStart(e, targetElement); }, { passive: false });

          showToast(`Acción de "${sourceKey}" asignada a "${targetKey}".`, 'success');
          stopAssignmentMode(); // Exit assignment mode
      }

    function startKeywordAssignmentMode(targetElement) {
         if (!isEditMode) return;
         stopAssignmentMode();
         stopKeywordAssignmentMode(); // Ensure only one assignment mode is active

         isKeywordAssignmentMode = true;
         editingTargetElement = targetElement;
         editingTargetElement.classList.add('editing-target');

         // Show all items and apply initial highlights based on target's keywords
         const filterInput = document.getElementById('grid-filter-input');
         if (filterInput) filterInput.value = ''; // Clear filter to show all
         filterGridItems();
         applyInitialKeywordHighlights();

         const keywordButton = document.getElementById('assign-keyword-button'); // Assumes this button exists
         if (keywordButton) keywordButton.textContent = 'CANCELAR KEYWORD';


         showToast('Pulsa en los botones para añadir/quitar sus palabras clave.', 'info', 5000);
    }

     function stopKeywordAssignmentMode() {
         isKeywordAssignmentMode = false;
         if (editingTargetElement) {
             editingTargetElement.classList.remove('editing-target');
             editingTargetElement = null;
         }
         document.querySelectorAll('.grid-item.keyword-highlight').forEach(item => item.classList.remove('keyword-highlight'));

         const keywordButton = document.getElementById('assign-keyword-button');
         if (keywordButton) keywordButton.textContent = 'AÑADIR KEYWORD';

         // Restore filter based on saved value
         const filterInput = document.getElementById('grid-filter-input');
         const savedFilterValue = localStorage.getItem('gridFilterValue');
         if (filterInput && savedFilterValue !== null) {
              filterInput.value = savedFilterValue;
              filterGridItems();
         } else if (document.getElementById('filter-bar')) {
              document.getElementById('filter-bar').style.display = 'none';
         }
     }

     function applyInitialKeywordHighlights() {
         if (!isKeywordAssignmentMode || !editingTargetElement) return;

         const targetKey = editingTargetElement.dataset.key;
         const targetItem = customData.bookmarks[targetKey];
         if (!targetItem || !targetItem.keywords) return;

         const targetKeywords = targetItem.keywords.toUpperCase().split(/\s+/).filter(k => k);
         if (targetKeywords.length === 0) return;

         document.querySelectorAll('.grid-item').forEach(item => {
              const itemKey = item.dataset.key;
              const itemData = customData.bookmarks[itemKey];
              if (!itemData || !itemData.keywords) return;

              const itemKeywords = itemData.keywords.toUpperCase().split(/\s+/).filter(k => k);
              // Check if ANY keyword from the target exists in the item's keywords
              const isMatch = itemKeywords.some(keyword => targetKeywords.includes(keyword));

              if (isMatch) {
                  item.classList.add('keyword-highlight');
              } else {
                  item.classList.remove('keyword-highlight');
              }
         });
     }

    function addKeywordToButton(targetElement, sourceKeywordsString) {
         if (!isKeywordAssignmentMode || !editingTargetElement) return;

         const targetKey = editingTargetElement.dataset.key;
         const targetItem = customData.bookmarks[targetKey];
          if (!targetItem) return;

         const sourceKeywords = (sourceKeywordsString || '').toUpperCase().split(/\s+/).filter(k => k);
         if (sourceKeywords.length === 0) {
             showToast('El botón pulsado no tiene palabras clave definidas.', 'warning');
             return;
         }

         let targetKeywords = (targetItem.keywords || '').toUpperCase().split(/\s+/).filter(k => k);
         let keywordsAdded = [];
         let keywordsRemoved = [];

         sourceKeywords.forEach(kw => {
             if (targetKeywords.includes(kw)) {
                 // Keyword already exists, so clicking removes it
                 targetKeywords = targetKeywords.filter(existingKw => existingKw !== kw);
                 keywordsRemoved.push(kw);
             } else {
                 // Keyword doesn't exist, add it
                 targetKeywords.push(kw);
                 keywordsAdded.push(kw);
             }
         });

         // Update keywords for the target button
         targetItem.keywords = targetKeywords.join(' ').trim();
         customData.bookmarks[targetKey] = targetItem; // Ensure object is updated in place or reassigned
         saveCustomData();

         // Update the highlight for the item that was clicked (source)
         const clickedItemKey = document.querySelector('.grid-item.editing-target')?.dataset.key; // Get the key of the button being edited
          if (clickedItemKey !== targetKey) { // Only update highlight if we clicked a different button
               const clickedItemElement = document.querySelector(`.grid-item[data-key="${sourceKeywordsString ? Object.keys(customData.bookmarks).find(k => customData.bookmarks[k]?.keywords?.toUpperCase().includes(sourceKeywordsString.toUpperCase())) : ''}"]`);
               if (clickedItemElement) {
                   if (targetItem.keywords.toUpperCase().includes(sourceKeywordsString.toUpperCase())) {
                       clickedItemElement.classList.add('keyword-highlight');
                   } else {
                       clickedItemElement.classList.remove('keyword-highlight');
                   }
               }
          }


         let message = '';
         if (keywordsAdded.length > 0 && keywordsRemoved.length > 0) {
             message = `Añadido: ${keywordsAdded.join(', ')}. Quitado: ${keywordsRemoved.join(', ')}.`;
         } else if (keywordsAdded.length > 0) {
             message = `Añadido: ${keywordsAdded.join(', ')}.`;
         } else if (keywordsRemoved.length > 0) {
             message = `Quitado: ${keywordsRemoved.join(', ')}.`;
         } else {
              message = 'No se encontraron palabras clave para añadir/quitar.';
         }

          showToast(message, (keywordsAdded.length > 0 || keywordsRemoved.length > 0) ? 'success' : 'warning', 3000);
          applyInitialKeywordHighlights(); // Re-apply highlights based on the modified target keywords
    }


    // Create toggle buttons and settings button
    function createOtherButtons() {
        const buttonBar = document.querySelector('.button-bar');
        if (!buttonBar) return;

        const editButton = document.getElementById('edit-grid-button');
        if (editButton) {
             editButton.addEventListener('click', toggleEditMode);
        }

         // Add "Assign Action" button if needed (e.g., within an edit panel)
         // For simplicity here, assuming the edit mode UI handles assignment buttons
    }

    // Render the state of toggle buttons
    function renderToggleButtons() {
        // Not needed for this specific request's scope based on the provided HTML structure
        // (Assuming toggles are handled differently or not present in this snippet)
    }


    // Adjust button positions based on screen size and filter bar visibility
    function adjustButtonPositions() {
        const filterBar = document.getElementById('filter-bar');
        const gridContainer = document.getElementById('grid-container');
        if (!filterBar || !gridContainer) return;

        const filterBarHeight = filterBar.offsetHeight;
        // If filter bar is visible, add its height as top padding to the grid container
        if (filterBar.style.display !== 'none') {
             gridContainer.style.paddingTop = `${filterBarHeight + 16}px`; // 16px is original padding
        } else {
             gridContainer.style.paddingTop = '16px'; // Reset to original padding
        }

         // Adjust globe position
         const countElGlobe = document.getElementById('reminder-count-globe');
         if(countElGlobe) {
             const buttonBarHeight = document.querySelector('.button-bar')?.offsetHeight || 0;
             const filterBarVisible = filterBar.style.display !== 'none';
             const topOffset = buttonBarHeight + (filterBarVisible ? filterBarHeight : 0) + 10; // 10px margin
             countElGlobe.style.top = `${topOffset}px`;
         }
    }

     function toggleDarkMode() {
         document.body.classList.toggle('light-mode');
         const isDarkMode = !document.body.classList.contains('light-mode');
         document.body.classList.toggle('dark-mode', isDarkMode);
         saveSettings();
         // Update map tile layer if map is active
          if (allLocationsMapInstance) {
              // Remove old tile layer
              allLocationsMapInstance.eachLayer(layer => {
                  if (layer instanceof L.TileLayer) {
                      allLocationsMapInstance.removeLayer(layer);
                  }
              });
               // Add new tile layer (standard for both modes in this example)
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                 attribution: '© OpenStreetMap contributors'
             }).addTo(allLocationsMapInstance);
          }
     }

     // --- Version Check and Display ---
     const LATEST_VERSION_URL = 'https://raw.githubusercontent.com/yourusername/yourrepo/main/latest_version.json'; // Replace with your actual URL
     let currentVersion = '1.0.0'; // Define your app's current version here

     async function updateVersion() {
         const versionsIcon = document.getElementById('versions-icon');
         const lastCheckDate = localStorage.getItem('lastUpdatesCheckDate');
         const oneDay = 24 * 60 * 60 * 1000; // 1 day in milliseconds

         // Check for updates only if it's been more than a day or if user explicitly opens versions modal
         if (lastCheckDate && (Date.now() - new Date(lastCheckDate).getTime() < oneDay)) {
             checkVersionsIconOpacity(); // Just check if icon should be visible
             return; // Skip fetch if checked recently
         }

         if (versionsIcon) versionsIcon.style.opacity = 0.5; // Indicate checking
         localStorage.setItem('lastUpdatesCheckDate', new Date().toISOString());

         try {
             const response = await fetch(LATEST_VERSION_URL, { cache: 'no-cache' });
             if (!response.ok) throw new Error('Failed to fetch version info');
             const data = await response.json();

             if (data && data.versions && data.versions.length > 0) {
                 const latestRemoteVersion = data.versions[0].version;
                 const storedVersion = localStorage.getItem('appVersion') || currentVersion;

                 // Simple version comparison (e.g., 1.10 > 1.9)
                 const isNewVersionAvailable = latestRemoteVersion.localeCompare(storedVersion, undefined, { numeric: true, sensitivity: 'base' }) > 0;

                 if (isNewVersionAvailable) {
                     versionsIcon.classList.add('new-version-available');
                     showToast(`¡Nueva versión disponible (${latestRemoteVersion})! Recarga la página.`, 'info', 5000);
                 } else {
                     versionsIcon.classList.remove('new-version-available');
                 }
                 localStorage.setItem('appVersion', latestRemoteVersion); // Store the latest known version
             }
         } catch (error) {
             console.warn("Failed to fetch latest version:", error);
              // If fetch fails, use the locally stored version or current version
             localStorage.setItem('appVersion', localStorage.getItem('appVersion') || currentVersion);
             versionsIcon.classList.remove('new-version-available'); // Assume no new version if check failed
         } finally {
              checkVersionsIconOpacity(); // Ensure visibility is correct after check
         }
     }

     function showVersionsModal() {
         const versionsIcon = document.getElementById('versions-icon');
          if (versionsIcon) versionsIcon.style.opacity = 1; // Make sure icon is visible when modal opens

         const modalOverlay = document.querySelector('.modal-overlay');
         if(modalOverlay) modalOverlay.style.display = 'block';

         const versionsModal = document.createElement('div');
         versionsModal.className = 'versions-modal-overlay';
          versionsModal.setAttribute('aria-label', 'Registro de Versiones');


         versionsModal.innerHTML = `
             <h2>Historial de Versiones</h2>
             <div id="versions-list"></div>
             <div style="text-align:center;margin-top:1rem;">
                 <button id="close-versions-modal">Cerrar</button>
             </div>
         `;
         document.body.appendChild(versionsModal);

         const versionsList = versionsModal.querySelector('#versions-list');

         // Fetch the full version list again to display in the modal
         fetch(LATEST_VERSION_URL, { cache: 'no-cache' })
             .then(response => {
                 if (!response.ok) throw new Error('Failed to fetch version info');
                 return response.json();
             })
             .then(data => {
                 if (data && data.versions) {
                     data.versions.sort((a, b) => b.version.localeCompare(a.version, undefined, { numeric: true })); // Sort latest first
                     versionsList.innerHTML = data.versions.map(v => `
                         <div class="version-entry">
                             <div class="version-title">v${v.version}</div>
                             <div class="version-date">${v.date}</div>
                             <div class="version-notes">${v.notes || ''}</div>
                         </div>
                     `).join('');
                 } else {
                     versionsList.innerHTML = "<p>No se pudo cargar el historial de versiones.</p>";
                 }
             })
             .catch(error => {
                 console.error("Error loading versions for modal:", error);
                 versionsList.innerHTML = "<p>Error al cargar el historial de versiones.</p>";
             });


         versionsModal.querySelector('#close-versions-modal').addEventListener('click', () => {
             if(modalOverlay) modalOverlay.style.display = 'none';
             versionsModal.remove();
             checkVersionsIconOpacity(); // Restore icon opacity
         });
     }

     function checkVersionsIconOpacity() {
          const versionsIcon = document.getElementById('versions-icon');
          const currentFilterValue = localStorage.getItem('gridFilterValue');
          // Hide if there's an active filter in the grid
          if (versionsIcon) {
              if (currentFilterValue) {
                   versionsIcon.style.display = 'none';
              } else {
                   versionsIcon.style.display = 'block';
                   versionsIcon.style.opacity = versionsIcon.classList.contains('new-version-available') ? 1 : 0.8;
              }
          }
     }


     // Add event listener for versions icon
     const versionsIconElement = document.getElementById('versions-icon');
     if (versionsIconElement) {
         versionsIconElement.addEventListener('click', showVersionsModal);
     }


     // --- Reminder Modals and Logic ---

     function getCurrentLocation(successCallback, errorCallback) {
          if ('geolocation' in navigator) {
              navigator.geolocation.getCurrentPosition(
                  (position) => {
                       successCallback(position.coords);
                  },
                  (error) => {
                       let errorMessage = 'Error de Geolocalización: ';
                       switch(error.code) {
                           case error.PERMISSION_DENIED:
                               errorMessage += 'Permiso denegado.'; break;
                           case error.POSITION_UNAVAILABLE:
                               errorMessage += 'Posición no disponible.'; break;
                           case error.TIMEOUT:
                               errorMessage += 'Tiempo de espera agotado.'; break;
                           case error.UNKNOWN_ERROR:
                           default:
                               errorMessage += 'Error desconocido.'; break;
                       }
                      errorCallback(errorMessage);
                  },
                  { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
              );
          } else {
              errorCallback('Geolocalización no soportada.');
          }
     }

     function initializeMapForReminderModal(mapContainerId, initialCoords = null) {
        if (reminderModalMap) {
            try { reminderModalMap.remove(); } catch (e) { console.warn("Error removing reminderModalMap:", e); }
            reminderModalMap = null;
            reminderModalMarker = null;
        }

        const mapDiv = document.createElement('div');
        mapDiv.style.width = '100%'; mapDiv.style.height = '100%';
        const container = document.getElementById(mapContainerId);
         // Clear existing map divs but keep buttons
        while (container.firstChild && container.firstChild.classList && !container.firstChild.classList.contains('map-button')) {
             container.removeChild(container.firstChild);
        }
        container.insertBefore(mapDiv, container.firstChild);


        const centerLat = initialCoords?.latitude || 40.416775; // Default to Madrid if no initial coords
        const centerLng = initialCoords?.longitude || -3.703790;
        const initialZoom = (initialCoords?.latitude && initialCoords?.longitude) ? 15 : 6;

        reminderModalMap = L.map(mapDiv, { zoomControl: true }).setView([centerLat, centerLng], initialZoom);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        }).addTo(reminderModalMap);

        if (initialCoords) {
            reminderModalMarker = L.marker([initialCoords.latitude, initialCoords.longitude]).addTo(reminderModalMap);
             currentReminderLocation = initialCoords; // Set global location variable
        }

        reminderModalMap.on('click', handleReminderMapClick);
        setTimeout(() => reminderModalMap.invalidateSize(), 100); // Fix map rendering issue
    }

    function handleReminderMapClick(e) {
        const latlng = e.latlng;
        if (reminderModalMarker) {
            reminderModalMarker.setLatLng(latlng);
        } else {
            reminderModalMarker = L.marker(latlng).addTo(reminderModalMap);
        }
        currentReminderLocation = { latitude: latlng.lat, longitude: latlng.lng };
    }

     function showReminderModal(parsed = null) {
    console.log("showReminderModal called with:", parsed);
    mapShouldReopenAfterForm = isRemindersLocationMapActive || sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true' || sessionStorage.getItem('boardinggate_map_should_reopen_after_form') === 'true';
    sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
    sessionStorage.removeItem('boardinggate_map_was_open_before_table');


    // Close any open map modals
    const mapModalElement = document.getElementById('reminders-location-map-modal');
    if (mapModalElement) {
         const mapCloseButton = mapModalElement.querySelector('#close-reminders-location-map');
         if (mapCloseButton) mapCloseButton.click();
         else mapModalElement.remove();
    }


    hideUnifiedReminderWindow();
    Object.values(previewMaps).forEach(map => map?.remove()); previewMaps = {};
    const otherModals = document.querySelectorAll('.choice-modal, .edit-modal, .edit-info-modal, .help-modal, .versions-modal-overlay, .saved-locations-modal, .reminder-table-modal, #postpone-options-modal, #reminders-map-help-modal-instance');
    otherModals.forEach(m => m.remove());


    const isNew = parsed === null || typeof parsed.id === 'undefined';
    currentReminderBeingEdited = parsed;
    currentReminderLocation = parsed?.isLocationEnabled ? parsed.locationCoordinates : null;

    const modalOverlay = document.querySelector('.modal-overlay');
    if(modalOverlay) modalOverlay.style.display = 'block';

    const modal = document.createElement('div');
    modal.className = 'reminder-modal';
    modal.setAttribute('aria-label', isNew ? 'Crear Recordatorio' : 'Modificar Recordatorio');

    modal.innerHTML = `
        <h2>${isNew ? 'Crear Recordatorio' : 'Modificar Recordatorio'}</h2>
        <form id="reminder-form">
            <div>
                <label for="reminder-text">Texto:</label>
                <input type="text" id="reminder-text" required value="${parsed?.text?.replace(/<[^>]*>/g, '') || ''}">
            </div>
            <div>
                 <label for="reminder-time">Hora (HH:MM, ej. 08:30):</label>
                 <input type="time" id="reminder-time" value="${parsed?.time || ''}">
            </div>
            <div>
                 <label for="reminder-date">Fecha (DD/MM/AAAA):</label>
                 <input type="text" id="reminder-date" placeholder="DD/MM/AAAA" value="${parsed?.date ? parsed.date.split('-').reverse().join('/') : ''}">
            </div>
            <div class="checkbox-group">
                 <label>Repetir Semanalmente:</label>
                 <input type="checkbox" name="repeat" value="0" id="repeat-dom" ${parsed?.type === 'weekly' && parsed.repeatDays?.includes(0) ? 'checked' : ''}><label for="repeat-dom">Dom</label>
                 <input type="checkbox" name="repeat" value="1" id="repeat-lun" ${parsed?.type === 'weekly' && parsed.repeatDays?.includes(1) ? 'checked' : ''}><label for="repeat-lun">Lun</label>
                 <input type="checkbox" name="repeat" value="2" id="repeat-mar" ${parsed?.type === 'weekly' && parsed.repeatDays?.includes(2) ? 'checked' : ''}><label for="repeat-mar">Mar</label>
                 <input type="checkbox" name="repeat" value="3" id="repeat-mie" ${parsed?.type === 'weekly' && parsed.repeatDays?.includes(3) ? 'checked' : ''}><label for="repeat-mie">Mié</label>
                 <input type="checkbox" name="repeat" value="4" id="repeat-jue" ${parsed?.type === 'weekly' && parsed.repeatDays?.includes(4) ? 'checked' : ''}><label for="repeat-jue">Jue</label>
                 <input type="checkbox" name="repeat" value="5" id="repeat-vie" ${parsed?.type === 'weekly' && parsed.repeatDays?.includes(5) ? 'checked' : ''}><label for="repeat-vie">Vie</label>
                 <input type="checkbox" name="repeat" value="6" id="repeat-sab" ${parsed?.type === 'weekly' && parsed.repeatDays?.includes(6) ? 'checked' : ''}><label for="repeat-sab">Sáb</label>
            </div>
            <div>
                 <label for="interval-days">Repetir Cada (días, ej. 7):</label>
                 <input type="number" id="interval-days" min="1" value="${parsed?.type === 'interval' ? (parsed.intervalDays || '') : ''}">
            </div>
            <div class="checkbox-group">
                 <input type="checkbox" id="location-checkbox" ${parsed?.isLocationEnabled ? 'checked' : ''}>
                 <label for="location-checkbox">Asociar a Ubicación:</label>
                 <input type="number" id="radius-input" min="1" value="${parsed?.radiusMeters || 1000}" ${!parsed?.isLocationEnabled ? 'disabled' : ''} style="width: 80px; display: inline-block; margin-left: 10px;"> metros
            </div>
             <div class="checkbox-group">
                  <input type="checkbox" id="exclude-from-list-checkbox" ${parsed?.excludeFromList ? 'checked' : ''}>
                  <label for="exclude-from-list-checkbox">No mostrar en lista general (ej. Radares)</label>
             </div>

            <div id="reminder-map-container" class="map-container">
                <!-- Map will be initialized here -->
                <button type="button" class="map-button ok-map-button">OK Ubicación</button>
                <button type="button" class="map-button locate-me-button">Mi Ubicación</button>
                 <button type="button" class="map-button saved-locations-button">Ubicaciones Guardadas</button>
            </div>

            <p id="parse-status" class="status-message"></p>

            <div class="button-group">
                <button type="submit" class="save-button">${isNew ? 'Crear' : 'Guardar'}</button>
                <button type="button" id="cancel-reminder" class="cancel-button">Cancelar</button>
                 ${!isNew ? `<button type="button" id="delete-reminder" class="cancel-button">Borrar</button>` : ''}
                <button type="button" id="clear-reminder" class="clear-button">Limpiar</button>
                 <button type="button" id="view-reminders" class="view-button">Ver Lista</button>
                 <button type="button" id="help-reminder" class="help-button">Ayuda</button>

            </div>
        </form>
    `;
    document.body.appendChild(modal);

    const textInput = modal.querySelector('#reminder-text');
    const timeInput = modal.querySelector('#reminder-time');
    const dateInput = modal.querySelector('#reminder-date');
    const repeatCheckboxes = modal.querySelectorAll('input[name="repeat"]');
    const intervalInput = modal.querySelector('#interval-days');
    const locationCheckbox = modal.querySelector('#location-checkbox');
    const radiusInput = modal.querySelector('#radius-input');
    const mapContainer = modal.querySelector('#reminder-map-container');
    const parseStatus = modal.querySelector('#parse-status');
    const deleteButton = modal.querySelector('#delete-reminder');
     const clearButton = modal.querySelector('#clear-reminder');
     const excludeFromListCheckbox = modal.querySelector('#exclude-from-list-checkbox');


    let manualTimeInput = !!parsed?.time;

     modal.cleanUpModalTimers = function(closeOverlay = false) {
        if (reminderModalMap) { try { reminderModalMap.remove(); } catch(e){console.warn("Error removing reminderModalMap:", e); } reminderModalMap = null; reminderModalMarker = null; }
        currentReminderLocation = null;
        currentReminderBeingEdited = null;
        if(modalOverlay && closeOverlay) modalOverlay.style.display = 'none';
         if(modal.autoCloseInterval) clearInterval(modal.autoCloseInterval);
         modal.autoCloseInterval = null;
         const countdownSpan = modal.querySelector('.button-countdown-timer');
         if(countdownSpan) countdownSpan.remove();
     };

     addModalAutoCloseTimer(modal, modal.querySelector('#cancel-reminder'), 'reminder-modal');


    if (!isNew && deleteButton) {
        deleteButton.addEventListener('click', () => {
            if (confirm('¿Estás seguro de borrar este recordatorio?')) {
                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                reminders = reminders.filter(r => r.id !== parsed.id);
                localStorage.setItem('reminders', JSON.stringify(reminders));
                showToast('Recordatorio borrado', 'success');
                modal.cleanUpModalTimers(true);
                if (modal.parentNode) document.body.removeChild(modal);
                 updateReminderCount();
                 updateButtonStyles();
                 checkReminders(); // Re-check reminders in case the deleted one was overdue

                const mapShouldReopen = mapShouldReopenAfterForm;
                if (mapShouldReopen) {
                     showAllRemindersLocationMap();
                }

            }
        });
    }

    const updateMapVisibility = () => {
        if (locationCheckbox.checked) {
            mapContainer.style.display = 'block';
             radiusInput.disabled = false;
            if (!reminderModalMap) {
                 initializeMapForReminderModal('reminder-map-container', currentReminderLocation);
            } else {
                setTimeout(() => reminderModalMap.invalidateSize(), 100);
            }
        } else {
            mapContainer.style.display = 'none';
            radiusInput.disabled = true;
            if (reminderModalMap) {
                try { reminderModalMap.remove(); } catch(e){console.warn("Error removing reminderModalMap:", e); }
                reminderModalMap = null;
                reminderModalMarker = null;
            }
            currentReminderLocation = null;
        }
    };

    locationCheckbox.addEventListener('change', updateMapVisibility);

    // Initialize map on load if location is enabled
    if (parsed?.isLocationEnabled) {
        updateMapVisibility();
    } else {
         mapContainer.style.display = 'none';
    }


     const locateMeButton = modal.querySelector('.locate-me-button');
     if(locateMeButton) {
         locateMeButton.addEventListener('click', () => {
             locateMeButton.disabled = true;
             locateMeButton.textContent = 'Buscando...';
              if (reminderModalMap) reminderModalMap.setView([40.416775, -3.703790], 6); // Reset view slightly while searching

             getCurrentLocation(
                 (coords) => {
                     currentReminderLocation = { latitude: coords.latitude, longitude: coords.longitude };
                     if (reminderModalMap) {
                         reminderModalMap.setView([coords.latitude, coords.longitude], 15);
                         if (reminderModalMarker) {
                             reminderModalMarker.setLatLng([coords.latitude, coords.longitude]);
                         } else {
                             reminderModalMarker = L.marker([coords.latitude, coords.longitude]).addTo(reminderModalMap);
                         }
                          showToast('Ubicación fijada.', 'success');
                     } else {
                          initializeMapForReminderModal('reminder-map-container', currentReminderLocation);
                     }
                     locateMeButton.disabled = false;
                     locateMeButton.textContent = 'Mi Ubicación';
                 },
                 (errorMsg) => {
                     showToast(`Error al obtener ubicación: ${errorMsg}`, 'error');
                     locateMeButton.disabled = false;
                     locateMeButton.textContent = 'Mi Ubicación';
                 }
             );
         });
     }

      const okMapButton = modal.querySelector('.ok-map-button');
      if (okMapButton) {
          okMapButton.addEventListener('click', () => {
              if (!reminderModalMarker) {
                  showToast("Fija una ubicación en el mapa primero.", "warning");
                  return;
              }
              const pos = reminderModalMarker.getLatLng();
              currentReminderLocation = { latitude: pos.lat, longitude: pos.lng };
              showToast(`Ubicación seleccionada: ${pos.lat.toFixed(4)}, ${pos.lng.toFixed(4)}`, 'info');
               // No need to hide map container, it stays visible if checkbox is checked
          });
      }

     const savedLocationsButton = modal.querySelector('.saved-locations-button');
     if (savedLocationsButton) {
         savedLocationsButton.addEventListener('click', () => {
              // Pass callbacks to handle closing the saved locations modal
             showSavedLocationsModal(
                 // Callback on close
                 () => {
                     // Re-initialize/show the reminder map if location is still checked
                      if (locationCheckbox.checked) {
                          updateMapVisibility(); // This will re-init the map
                      }
                 },
                 // Callback on selecting a location
                 (selectedLocation) => {
                      if (locationCheckbox.checked) {
                          currentReminderLocation = { latitude: selectedLocation.lat, longitude: selectedLocation.lng };
                           radiusInput.value = selectedLocation.radius || 1000;
                           // Initialize map with selected location
                           initializeMapForReminderModal('reminder-map-container', currentReminderLocation);
                           showToast(`Ubicación "${selectedLocation.name}" cargada.`, 'success');
                      } else {
                           showToast("Activa 'Asociar a Ubicación' primero.", "warning");
                      }
                 }
             );
         });
     }


    const form = modal.querySelector('#reminder-form');
    form.addEventListener('submit', (e) => {
        e.preventDefault(); modal.cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;

        const text = textInput.value.trim(); if (!text) { parseStatus.textContent = 'Texto obligatorio.'; parseStatus.classList.add('text-red-600'); return; }
        let time = timeInput.value.trim(); let dateStr = dateInput.value.trim(); const repeatDays = Array.from(modal.querySelectorAll('input[name="repeat"]:checked')).map(input => parseInt(input.value)); const intervalDays = parseInt(intervalInput.value) || null;
        const isLocationChecked = locationCheckbox.checked; const radius = parseInt(radiusInput.value) || 1000;
        const locationCoords = currentReminderLocation;
        const excludeFromListVal = excludeFromListCheckbox.checked;
        if (isLocationChecked && !locationCoords) { parseStatus.textContent = 'Ubicación activada pero no fijada en el mapa.'; parseStatus.classList.add('text-red-600'); return; }
        let dateISO = null; let finalTime = time; let reminderType = 'simple';
        if (dateStr) { if (dateStr.match(/^\d{2}\/\d{2}\/\d{4}$/)) { const [d, m, y] = dateStr.split('/').map(Number); const tD = new Date(Date.UTC(y, m - 1, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() + 1 === m && y >= 2000 && y <= 2099) { dateISO = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } else { parseStatus.textContent = 'Fecha inválida'; parseStatus.classList.add('text-red-600'); return; } } else { parseStatus.textContent = 'Formato DD/MM/AAAA'; parseStatus.classList.add('text-red-600'); return; } }
        if (finalTime && !finalTime.match(/^\d{2}:\d{2}$/)) { parseStatus.textContent = 'Formato HH:MM'; parseStatus.classList.add('text-red-600'); return; } else if (finalTime) { const [h, m] = finalTime.split(':').map(Number); if (h > 23 || m > 59) { parseStatus.textContent = 'Hora inválida'; parseStatus.classList.add('text-red-600'); return; } }
        if (intervalDays !== null && intervalDays > 0) { reminderType = 'interval'; if (!dateISO) { const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } if (!finalTime) finalTime = '00:01'; }
        else if (repeatDays.length > 0) { reminderType = 'weekly'; if (!dateISO) { const tempCalc = { type: 'weekly', time: finalTime || '00:01', date: null, repeatDays: repeatDays, intervalDays: null }; const firstOcc = calculateNextOccurrence(tempCalc, new Date()); if (firstOcc) { dateISO = `${firstOcc.getUTCFullYear()}-${(firstOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOcc.getUTCDate().toString().padStart(2, '0')}`; finalTime = finalTime || `${firstOcc.getUTCHours().toString().padStart(2, '0')}:${firstOcc.getUTCMinutes().toString().padStart(2, '0')}`; } else { const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; if (!finalTime) finalTime = '00:01'; } } else { if (!finalTime) finalTime = '00:01'; } }
        else if (dateISO && finalTime) { reminderType = 'daily'; } else if (finalTime) { reminderType = 'daily'; const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (dateISO) { reminderType = 'daily'; finalTime = '00:01'; } else { reminderType = 'simple'; const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; finalTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`; }
        const now = new Date();
        const finalCreatedAt = isNew ? now.toISOString() : (parsed.createdAt || now.toISOString());
        let finalDateISO = dateISO;

        // Recalculate date for new cyclic reminders if initial date is in the past or not set
        if (isNew && (reminderType === 'weekly' || reminderType === 'interval')) {
            let needsRecalc = false;
            if (!dateInput.value.trim()) {
                 // If date is empty, always calculate the next occurrence from now
                 needsRecalc = true;
            } else {
                // If date is provided, check if it's in the past
                try {
                    const [d, m, y] = dateStr.split('/').map(Number);
                    // Create a Date object for the input date at midnight UTC for comparison
                    const inputDate = new Date(Date.UTC(y, m - 1, d));
                    // Create a Date object for today at midnight UTC
                    const todayForCompare = new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate());
                    if (inputDate < todayForCompare) {
                        needsRecalc = true;
                    }
                } catch (e) {
                    // If date parsing failed, treat as needing recalculation
                    needsRecalc = true;
                }
            }

            if (needsRecalc) {
                const tempCalcForNewCyclic = {
                    type: reminderType,
                    time: finalTime || '00:01', // Use determined time or default
                    date: null, // Pass null date to calculateNextOccurrence to start from now
                    repeatDays: reminderType === 'weekly' ? repeatDays : [],
                    intervalDays: reminderType === 'interval' ? intervalDays : null
                };
                const firstOccurrence = calculateNextOccurrence(tempCalcForNewCyclic, new Date()); // Calculate from *current* moment
                if (firstOccurrence) {
                    // Update the date ISO to the date of the first upcoming occurrence
                    finalDateISO = `${firstOccurrence.getUTCFullYear()}-${(firstOccurrence.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOccurrence.getUTCDate().toString().padStart(2, '0')}`;
                    // Note: We don't update finalTime here, as the user specified the time.
                    // The next occurrence calculation only guarantees the date is valid, the time should remain user-defined.
                    // If time was empty, it defaulted to '00:01' earlier, which is fine.
                } else {
                    // Fallback if calculation fails (shouldn't happen for weekly/interval with valid params)
                    if (!finalDateISO) {
                         finalDateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
                    }
                }
            }
        }


        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        const newReminder = {
            id: isNew ? Date.now() : parsed.id, // Keep old ID if modifying
            text: `<b>${text.toUpperCase()}</b>`,
            type: reminderType,
            time: finalTime || null,
            date: finalDateISO, // Use the determined or recalculated date
            repeatDays: reminderType === 'weekly' ? repeatDays : [],
            intervalDays: reminderType === 'interval' ? intervalDays : null,
            createdAt: finalCreatedAt, // Keep old createdAt date if modifying
            managedByUser: false, // Reset managed status when saved
            isLocationEnabled: isLocationChecked,
            locationCoordinates: isLocationChecked ? locationCoords : null,
            radiusMeters: isLocationChecked ? radius : (parsed?.radiusMeters || 1000), // Keep old radius if disabling location? No, use default or new if enabled. Updated logic: if location checked, use new radius, otherwise use old parsed radius or 1000
            excludeFromList: excludeFromListVal
        };

        // Basic validation for required fields
        if (!newReminder.date || !newReminder.time || !newReminder.createdAt){
            parseStatus.textContent = "Error GRAVE: Fechas/Hora inválidas al guardar.";
            parseStatus.classList.add('text-red-600');
            showToast("Error GRAVE: Fechas/Hora inválidas al guardar.", "error");
            // Don't reset timer on validation error, let user fix
            return;
        }

        if (!isNew) {
            // Find and replace the old reminder
            const index = reminders.findIndex(r => r.id === parsed.id);
            if (index !== -1) {
                reminders[index] = newReminder;
            } else {
                // Should not happen if editing, but add as new if somehow not found
                reminders.push(newReminder);
            }
        } else {
            // Add the new reminder
            reminders.push(newReminder);
        }

        localStorage.setItem('reminders', JSON.stringify(reminders));
        showToast('Recordatorio guardado', 'success');

        modal.cleanUpModalTimers(true); // Clean up timers and remove modal
        if (modal.parentNode) document.body.removeChild(modal); // Ensure modal is removed

        updateReminderCount();
        updateButtonStyles();
        checkReminders(); // Re-check reminders as list has changed

        // Logic to reopen map if it was open before the form
        const unifiedWindowIsVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible');

        if (mapShouldReopen && !unifiedWindowIsVisible) {
            showAllRemindersLocationMap();
        } else if (mapShouldReopen && unifiedWindowIsVisible) {
            // If unified window is open, defer reopening the map until it closes
            sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
        }
    });

    modal.querySelector('#cancel-reminder').addEventListener('click', () => {
        modal.cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        if (modal.parentNode) document.body.removeChild(modal);

        // Reopen map if it was open before, unless unified window is now open
        const unifiedWindowIsVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible');
        if (mapShouldReopen && !unifiedWindowIsVisible) {
            showAllRemindersLocationMap();
        } else if (mapShouldReopen && unifiedWindowIsVisible) {
             // Defer reopening if unified window is open
             sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
        }
    });
    modal.querySelector('#help-reminder').addEventListener('click', showHelpModal); // Assuming showHelpModal exists
    clearButton.addEventListener('click', () => {
        textInput.value=''; timeInput.value=''; dateInput.value='';
        modal.querySelectorAll('input[name="repeat"]').forEach(i=>i.checked=false);
        intervalInput.value='';
        locationCheckbox.checked = false;
        radiusInput.value = (parsed?.radiusMeters || 1000); // Reset radius to default or previous if exists
        currentReminderLocation = null;
        updateMapVisibility(); // Hide map and clear its state
        radiusInput.disabled = true;
        excludeFromListCheckbox.checked = false; // Uncheck exclude by default
        parseStatus.textContent='';
        // No speech status in this modal based on HTML provided

        // No timer reset needed for clear button as timer is attached to the modal itself
        textInput.focus();
    });
    modal.querySelector('#view-reminders').addEventListener('click', () => {
        modal.cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        if (modal.parentNode) document.body.removeChild(modal);
        fromReminderModal = true; // Set flag before opening table

        // Pass the mapShouldReopen state to the table modal context if needed
        if (mapShouldReopen) {
            sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
        }
        showAllReminders(); // Assuming showAllReminders exists
    });
    textInput.focus(); // Focus on text input when modal opens
}

    function markReminderAsManaged(reminderId, managedState = true) {
         if (typeof reminderId !== 'number') { console.warn("Invalid reminderId type:", reminderId); return; }
         try {
             let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
             const index = reminders.findIndex(r => r.id === reminderId);
             if (index !== -1) {
                 // Only update if the state is different to avoid unnecessary storage writes
                 if (reminders[index].managedByUser !== managedState) {
                     reminders[index].managedByUser = managedState;
                     localStorage.setItem('reminders', JSON.stringify(reminders));
                     // console.log(`Reminder ${reminderId} managedByUser set to ${managedState}`);
                 }
             } else {
                 console.warn(`Reminder with id ${reminderId} not found in storage.`);
             }
         } catch (e) {
             console.error("Error updating managedByUser flag:", e);
         }
     }

     function displayUnifiedReminderWindow(overdueReminders) {
         const windowElement = document.getElementById('unified-reminder-window');
         const swiperContainer = document.getElementById('reminder-swiper-container');
         const countHeader = windowElement.querySelector('.reminder-count-header');
         const countSpan = document.getElementById('total-reminder-count');
         const currentIndexSpan = document.getElementById('current-reminder-index');
         const countTextContainer = document.getElementById('reminder-count-text-container');
         const swipeHint = document.getElementById('reminder-swipe-hint');
         const hideAllButton = document.getElementById('hide-all-reminders-button');

          // Clean up previous maps before adding new ones
          Object.values(previewMaps).forEach(map => map?.remove());
          previewMaps = {};

         if (!windowElement || !swiperContainer || !countHeader || !countSpan || !currentIndexSpan || !countTextContainer || !swipeHint || !hideAllButton) {
             console.error("Missing required elements for unified reminder window.");
             return;
         }
         swiperContainer.innerHTML = ''; // Clear previous slides
         // Sort reminders by next occurrence time
         overdueReminders.sort((a, b) => {
             try {
                  // Calculate next occurrence from now for sorting
                 const nextA = calculateNextOccurrence(a, new Date());
                 const nextB = calculateNextOccurrence(b, new Date());

                 // If both have next occurrences, sort by that
                 if (nextA && nextB) return nextA.getTime() - nextB.getTime();
                 // If only one has a next occurrence, that one comes first
                 if (nextA) return -1;
                 if (nextB) return 1;

                 // If neither has a calculated next occurrence (e.g., simple past reminders), sort by original date/time
                 const dateA = new Date(`${a.date}T${a.time}:00Z`); // Assume Z for comparison consistency
                 const dateB = new Date(`${b.date}T${b.time}:00Z`);
                 return dateA - dateB;

             } catch (e) {
                  console.warn("Error sorting reminders:", e);
                 return 0; // Maintain original order in case of error
             }
         });

         // If the window was not visible, reset to the first slide
         if (!isUnifiedWindowVisibleByLogic) {
             currentNotificationSlideIndex = 0;
         }

         overdueReminders.forEach((reminder, index) => {
             const slide = document.createElement('div');
             slide.className = 'reminder-slide';
             slide.dataset.id = reminder.id;
             slide.setAttribute('role', 'group');
             slide.setAttribute('aria-label', `Recordatorio ${index + 1} de ${overdueReminders.length}: ${reminder.text.replace(/<[^>]*>/g, '')}`);

             let detailsHtml = '';
             if (reminder.time) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Hora: ${formatTimeWithPeriod(reminder.time)}</p>`;
             if (reminder.date) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Fecha: ${formatDateDetailed(reminder.date)}</p>`;
             if (reminder.type === 'weekly' && reminder.repeatDays?.length > 0) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Repite: ${reminder.repeatDays.map(d => ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'][d]).join(', ')}</p>`;
             if (reminder.type === 'interval' && reminder.intervalDays) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Cada: ${reminder.intervalDays} días</p>`;
             if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                 detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Ubicación: Activada (Radio ${reminder.radiusMeters || 1000}m)</p>`;
             }

             const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval';
             // Only show adjust time button if it's cyclic AND the time is NOT already 00:01
             const showAdjustButton = isCyclic && reminder.time !== '00:01';
             const adjustButtonHtml = showAdjustButton ? `<button class="adjust-time-0001">Ajustar Hora 00:01 y Visto</button>` : '';
             const cyclicCancelButtonHtml = isCyclic ? `<button class="cancel-cyclic">Anular Ciclo</button>` : '';

             const mapPreviewHtml = reminder.isLocationEnabled && reminder.locationCoordinates ? `
                 <div class="reminder-map-preview-container">
                     <div id="map-preview-${reminder.id}" class="reminder-map-preview"></div>
                 </div>
             ` : '';

             slide.innerHTML = `
                 <div class="reminder-slide-content">
                     <div class="reminder-content-scrollable">
                         <p class="reminder-text">${reminder.text}</p>
                         ${detailsHtml}
                     </div>
                     <div class="button-group">
                         <button class="cancel">${isCyclic ? 'Visto / Próximo' : 'Visto / Borrar'}</button>
                         <button class="postpone">Posponer</button>
                         <button class="modify">Modificar</button>
                         ${adjustButtonHtml}
                         ${cyclicCancelButtonHtml}
                     </div>
                 </div>
                 ${mapPreviewHtml}
             `;

             addSlideButtonListeners(slide, reminder); // Add event listeners to buttons within the slide
             swiperContainer.appendChild(slide);

             // Initialize map preview if location is enabled
             if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                  const mapPreviewElement = slide.querySelector(`#map-preview-${reminder.id}`);
                  if (mapPreviewElement) {
                     // Use a small delay to ensure the map container div is fully rendered and has dimensions
                     setTimeout(() => {
                         try {
                             // Double check element exists before initializing
                             if (!document.getElementById(mapPreviewElement.id)) return;

                             const map = L.map(mapPreviewElement, {
                                 dragging: false, touchZoom: false, scrollWheelZoom: false, doubleClickZoom: false,
                                 boxZoom: false, keyboard: false, tap: false, zoomControl: false // Disable interaction
                             }).setView([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude], 14); // Set a reasonable default zoom

                             L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                                 // attribution: '© OpenStreetMap contributors' // Keep attribution if space allows
                             }).addTo(map);

                             // Add marker and circle
                             L.marker([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude]).addTo(map);
                             L.circle([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude], {
                                 color: 'blue', weight: 1, fillColor: '#ADD8E6', fillOpacity: 0.05, radius: reminder.radiusMeters || 1000
                             }).addTo(map);

                             // Invalidate size is crucial for maps in hidden/flex containers
                             map.invalidateSize();
                             // Store map instance to remove later
                             previewMaps[reminder.id] = map;
                         } catch (mapError) {
                              console.error("Error initializing map preview:", mapError);
                              // Display an error message in the map container if it fails
                              if (mapPreviewElement) mapPreviewElement.innerHTML = `<p style="font-size:0.8rem; color: red; text-align: center; padding: 5px;">Error al cargar mapa</p>`;
                         }
                     }, 50); // Small delay
                  }
             }
         });

         const count = overdueReminders.length;
         countSpan.textContent = count; // Update total count

         if (count > 0) {
              // Ensure current index is valid for the new list
              if (currentNotificationSlideIndex >= count) {
                  currentNotificationSlideIndex = 0;
              }
              // Scroll to the current slide index (might be 0 if new session or window just opened)
              swiperContainer.scrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
              updateReminderIndexDisplay(); // Update the "X / Y" display

              countHeader.classList.remove('hidden'); // Show header
              if (count > 1) {
                 countTextContainer.style.display = 'inline'; // Show "X / Y" if more than one
                 swipeHint.style.display = 'block'; // Show swipe hint
                 // Adjust slide max height if hint is present
                 document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = 'calc(85vh - 60px)'); // Assuming 60px for header+hint
              } else {
                 countTextContainer.style.display = 'none'; // Hide "X / Y" if only one
                 swipeHint.style.display = 'none'; // Hide swipe hint
                 // Adjust slide max height if no hint
                 document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = '85vh');
              }
               hideAllButton.classList.remove('hidden'); // Show "Hide All" button if any reminders
               // Re-add event listener to "Hide All" button to prevent duplicates
               const newHideAllButton = hideAllButton.cloneNode(true);
               hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton);
               newHideAllButton.addEventListener('click', postponeAllVisibleReminders);
         } else {
             // No overdue reminders
             countHeader.classList.add('hidden'); // Hide header
             hideAllButton.classList.add('hidden'); // Hide "Hide All" button
             currentNotificationSlideIndex = 0; // Reset index
         }
         windowElement.classList.add('visible'); // Make the window visible
         isUnifiedWindowVisibleByLogic = true; // Update internal state

         // Add scroll listener to update index display
         swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay); // Remove previous listener
         swiperContainer.addEventListener('scroll', updateReminderIndexDisplay);
     }

     function hideUnifiedReminderWindow() {
         const windowElement = document.getElementById('unified-reminder-window');
         if (windowElement && windowElement.classList.contains('visible')) {
             windowElement.classList.remove('visible');
             isUnifiedWindowVisibleByLogic = false; // Update internal state
             const swiperContainer = document.getElementById('reminder-swiper-container');
              // Clean up map instances when window is hidden
              Object.values(previewMaps).forEach(map => map?.remove());
              previewMaps = {};
             if (swiperContainer) {
                 swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay); // Remove scroll listener
                  // Clear slides after animation completes
                  setTimeout(() => {
                      if (swiperContainer && !windowElement.classList.contains('visible')) { // Only clear if still hidden
                          swiperContainer.innerHTML = '';
                      }
                  }, 300); // Match CSS transition duration
             }
             // Re-add Hide All button listener if it exists to avoid duplicates
             const hideAllButton = document.getElementById('hide-all-reminders-button');
             if (hideAllButton) { const newHideAllButton = hideAllButton.cloneNode(true); hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton); }


            // Check if map should reopen after this window closes
            const mapShouldReopen = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
            sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); // Consume the flag

            // Reopen map ONLY if no other reminder-related modals are open
            if (mapShouldReopen &&
                !document.querySelector('.reminder-modal') &&
                !document.querySelector('.reminder-table-modal') &&
                !document.getElementById('reminders-location-map-modal') &&
                 !document.getElementById('postpone-options-modal') // Also check postpone modal
               ) {
                 showAllRemindersLocationMap(); // Assuming showAllRemindersLocationMap exists
            }
         }
     }

     function postponeAllVisibleReminders() {
         const swiperContainer = document.getElementById('reminder-swiper-container');
         if (!swiperContainer) return;
         // Select only the currently visible slides in the DOM. This might need refinement
         // based on actual swiper behavior vs overflow scroll. Assuming all are 'visible' in overflow scroll here.
         const visibleSlides = swiperContainer.querySelectorAll('.reminder-slide');
         if (visibleSlides.length === 0) {
             showToast("No hay recordatorios para posponer.", "warning");
             return;
         }

         let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
         let updated = false;
         const idsToUpdate = [];

         visibleSlides.forEach(slide => {
             const reminderId = parseInt(slide.dataset.id);
             if (isNaN(reminderId)) return;
             idsToUpdate.push(reminderId);

             const index = reminders.findIndex(r => r.id === reminderId);
             if (index !== -1) {
                 const { newDateISO, newTime } = calculatePostponedDateTime(1); // Postpone by 1 minute
                 reminders[index].date = newDateISO;
                 reminders[index].time = newTime;
                 reminders[index].managedByUser = false; // Mark as not managed so it can become overdue again
                 updated = true;
             }
         });

         if (updated) {
             localStorage.setItem('reminders', JSON.stringify(reminders));
             showToast(`${idsToUpdate.length} recordatorio(s) pospuesto(s) 1 minuto.`, 'info');
             // Remove the postponed reminders from the UI and hide the window
             idsToUpdate.forEach(id => updateUnifiedWindowUI(id));
             updateReminderCount(); // Update counts everywhere
             updateButtonStyles(); // Update button styles
              // Re-check reminders immediately to catch any others or update state
         }
         // If any reminders were postponed and the window is still open, close it
         if (idsToUpdate.length > 0 && document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
            hideUnifiedReminderWindow();
         }
     }


     function updateReminderIndexDisplay() {
         const swiperContainer = document.getElementById('reminder-swiper-container');
         const currentIndexSpan = document.getElementById('current-reminder-index');
         if (!swiperContainer || !currentIndexSpan) return;

         const totalSlides = swiperContainer.querySelectorAll('.reminder-slide').length;
         if (totalSlides === 0) {
             currentIndexSpan.textContent = '0';
             return;
         }

         const containerWidth = swiperContainer.offsetWidth;
         if (containerWidth <= 0) {
             // Cannot calculate index if container has no width
            return;
         }
         const currentScroll = swiperContainer.scrollLeft;
         // Calculate index based on scroll position and container width
         // Add a small tolerance (e.g., 10px) to handle fractional scrolling and ensure accurate rounding near snap points
         const currentIndex = Math.round((currentScroll + 10) / containerWidth);

         currentNotificationSlideIndex = currentIndex; // Store the calculated index

         // Display index (1-based)
         const displayIndex = Math.max(1, Math.min(currentIndex + 1, totalSlides));
         currentIndexSpan.textContent = displayIndex;

          // Invalidate size for the map on the currently displayed slide to fix rendering if needed
          const currentSlideElement = swiperContainer.querySelectorAll('.reminder-slide')[currentIndex];
          if (currentSlideElement) {
             const mapId = currentSlideElement.querySelector('.reminder-map-preview')?.id;
             if (mapId) {
                  const reminderId = parseInt(mapId.replace('map-preview-', ''));
                  if (previewMaps[reminderId]) {
                      // Use a timeout as map might not be ready instantly
                      setTimeout(() => { if(previewMaps[reminderId]) previewMaps[reminderId].invalidateSize(); }, 50);
                  }
             }
          }
     }

     function addSlideButtonListeners(slideElement, reminder) {
         const reminderId = reminder.id;
         const cancelButton = slideElement.querySelector('.cancel');
         const adjustTimeButton = slideElement.querySelector('.adjust-time-0001');
         const cancelCyclicButton = slideElement.querySelector('.cancel-cyclic');
         const modifyButton = slideElement.querySelector('.modify');
         const postponeButton = slideElement.querySelector('.postpone');

         // Helper to handle button clicks and then update the UI
         const handleInteraction = (actionFn) => {
             markReminderAsManaged(reminderId, true); // Mark as managed first
             actionFn(); // Perform the action (delete, postpone, update date/time etc.)
             // After action, update the UI for this specific reminder (removes the slide if deleted/handled)
             updateUnifiedWindowUI(processedReminderId);
         };

         let processedReminderId = reminderId; // Use this internally if needed

         if (cancelButton) {
             cancelButton.addEventListener('click', () => handleInteraction(() => {
                 let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                 const index = rems.findIndex(r => r.id === processedReminderId);
                 if (index === -1) {
                     showToast('Error: Recordatorio no encontrado para cancelar.', 'error');
                     return; // Reminder not found
                 }

                 const currentReminder = rems[index];
                 let needsSave = false;

                 if (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval')) {
                    // For non-cyclic location-based reminders, postpone by 15 mins
                    const { newDateISO, newTime } = calculatePostponedDateTime(15);
                    rems[index].date = newDateISO;
                    rems[index].time = newTime;
                    rems[index].managedByUser = false; // Allow it to trigger again
                    needsSave = true;
                    showToast('Recordatorio con ubicación pospuesto 15 minutos', 'info');
                 } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                     // For cyclic reminders, calculate the next occurrence
                     let referenceDateForNext = new Date(); // Start calculation from now
                     try {
                          // If the current reminder's scheduled time is in the past but close, start calculation slightly after its time
                          // This prevents calculating the *same* occurrence again immediately
                         const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                         const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                         const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                         const nowUTC = new Date();
                         if (!isNaN(reminderDateTime.getTime()) && reminderDateTime <= nowUTC) {
                             referenceDateForNext = new Date(nowUTC.getTime() + 1000); // Start calculation 1 second from now
                         } else if (!isNaN(reminderDateTime.getTime())) {
                              referenceDateForNext = reminderDateTime; // If scheduled in future, start from there
                         }
                     } catch(e) { console.warn("Error parsing reminder date/time for next occurrence:", e); }


                     const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                     if (nextOcc) {
                         // Update date and time to the next occurrence
                         rems[index].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                         rems[index].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                         rems[index].managedByUser = false; // Allow it to trigger again
                         needsSave = true;
                         showToast('Recordatorio actualizado al próximo ciclo', 'info');
                     } else {
                         // If no next occurrence can be calculated, delete the reminder
                         rems.splice(index, 1); needsSave = true;
                         showToast('Error calculando siguiente ciclo. Recordatorio eliminado.', 'error');
                     }
                 } else {
                     // For non-cyclic, non-location reminders, delete it
                     rems.splice(index, 1); needsSave = true;
                     showToast('Recordatorio marcado como visto y eliminado', 'info');
                 }

                 if (needsSave) localStorage.setItem('reminders', JSON.stringify(rems));
             }));
         }

         if (adjustTimeButton) {
             adjustTimeButton.addEventListener('click', () => handleInteraction(() => {
                 let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                 const index = rems.findIndex(r => r.id === processedReminderId);
                 if (index === -1) {
                      showToast('Error: Recordatorio no encontrado para ajustar hora.', 'error');
                      return;
                 }

                 const currentReminder = rems[index];
                 let needsSave = false;

                 // This action is intended for cyclic reminders (weekly/interval) that are NOT 00:01
                 if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                      // Calculate the next occurrence starting from now, but forcing the time to 00:01
                      let referenceDateForNext = new Date();
                       try {
                           const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                           const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, 0, 1)); // Use 00:01 for reference
                            const nowUTC = new Date();
                           if (!isNaN(reminderDateTime.getTime()) && reminderDateTime <= nowUTC) {
                               referenceDateForNext = new Date(nowUTC.getTime() + 1000); // Start calculation 1 second from now
                           } else if (!isNaN(reminderDateTime.getTime())) {
                                referenceDateForNext = reminderDateTime;
                           }
                       } catch(e) { console.warn("Error parsing reminder date/time for next occurrence (00:01 adjust):", e); }


                     const reminderForCalc = { ...currentReminder, time: '00:01' }; // Use 00:01 for calculation logic
                     const nextOcc = calculateNextOccurrence(reminderForCalc, referenceDateForNext);

                     if (nextOcc) {
                         rems[index].date= `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                         rems[index].time = '00:01'; // Explicitly set time to 00:01
                         rems[index].managedByUser = false;
                         needsSave = true;
                         showToast('Recordatorio ajustado a 00:01 y actualizado', 'info');
                     } else {
                         // If calculation fails, delete the reminder
                         rems.splice(index, 1); needsSave = true;
                         showToast('Error calculando siguiente ciclo (ajuste 00:01). Eliminado.', 'error');
                     }
                 } else {
                     // This button shouldn't appear for non-cyclic, but handle defensively
                     rems.splice(index, 1); needsSave = true;
                     showToast('Recordatorio no cíclico eliminado (ajuste 00:01)', 'info');
                 }

                 if (needsSave) localStorage.setItem('reminders', JSON.stringify(rems));
             }));
         }

         if (cancelCyclicButton) {
             cancelCyclicButton.addEventListener('click', () => handleInteraction(() => {
                 // Confirm with user before permanent deletion
                 if (confirm('¿Estás seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE? Esto borrará este recordatorio y no volverá a aparecer.')) {
                     let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                     const initialLength = rems.length;
                     rems = rems.filter(r => r.id !== processedReminderId); // Filter out the reminder
                     if (rems.length < initialLength) {
                         localStorage.setItem('reminders', JSON.stringify(rems));
                         showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                     } else {
                         showToast('Error: No se encontró el ciclo para anular.', 'warning');
                          // If not found/deleted, unmark as managed
                         markReminderAsManaged(processedReminderId, false);
                     }
                 } else {
                     // If user cancels confirm, unmark as managed so it can be seen again
                     markReminderAsManaged(processedReminderId, false);
                      // Prevent updateUnifiedWindowUI from removing the slide
                     throw new Error("Anulación cancelada por el usuario."); // Throw to stop the handleInteraction flow
                 }
             }));
         }

         if (modifyButton) {
             modifyButton.addEventListener('click', () => {
                 markReminderAsManaged(reminder.id, true); // Mark as managed before opening modify modal
                 let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                 const reminderToModify = remindersFromStorage.find(r => r.id === reminder.id);

                 // Check if map should reopen AFTER the reminder modal closes and the unified window is hidden
                 const mapShouldReopenWhenUnifiedCloses = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';

                 hideUnifiedReminderWindow(); // Close the unified window

                 if (reminderToModify) {
                     // Set a flag so showReminderModal knows to potentially reopen the map later
                     if (mapShouldReopenWhenUnifiedCloses) {
                          sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                     }
                     showReminderModal(reminderToModify); // Open the modify modal
                 }
                 else {
                     showToast("Error: no se pudo encontrar el recordatorio para modificar.", "error");
                      // If reminder not found, unmark as managed
                     markReminderAsManaged(reminder.id, false);
                     // Re-check reminders to update the list in case it was deleted elsewhere
                     checkReminders();
                      // Attempt to reopen map if the flag was set and no other map is open
                     if (mapShouldReopenWhenUnifiedCloses &&
                         sessionStorage.getItem('boardinggate_map_should_reopen_after_form') !== 'true' && // Don't re-open if the form is supposed to do it
                         !document.getElementById('reminders-location-map-modal') // Check if map is already open
                        ) {
                         showAllRemindersLocationMap();
                     }
                 }
                 // Always clear the flag, it's handled now
                 sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
             });
         }

         if (postponeButton) {
             postponeButton.addEventListener('click', () => {
                 markReminderAsManaged(processedReminderId, true); // Mark as managed before showing options
                 let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                 const reminderToPostpone = remindersFromStorage.find(r => r.id === processedReminderId);
                 if (reminderToPostpone) {
                     // Pass the source context ('unified')
                     showPostponeOptionsModal(reminderToPostpone, 'unified');
                 }
                 else {
                     showToast("Error: no se pudo encontrar el recordatorio para posponer.", "error");
                     markReminderAsManaged(processedReminderId, false); // Unmark if not found
                     // Re-check reminders to update the list
                     checkReminders();
                 }
             });
         }
     }


     // Function to update the Unified Window UI after an action on a reminder
     function updateUnifiedWindowUI(processedReminderId) {
         const windowElement = document.getElementById('unified-reminder-window');
         const swiperContainer = document.getElementById('reminder-swiper-container');
         // Find the slide element corresponding to the processed reminder ID
         const slideToRemove = swiperContainer ? swiperContainer.querySelector(`.reminder-slide[data-id="${processedReminderId}"]`) : null;

         // Remove the map preview instance if it exists
         if (previewMaps[processedReminderId]) {
             previewMaps[processedReminderId].remove();
             delete previewMaps[processedReminderId];
         }

         // Remove the slide element from the DOM
         if (slideToRemove && slideToRemove.parentNode === swiperContainer) {
             swiperContainer.removeChild(slideToRemove);
         }

         // Re-evaluate remaining slides
         const remainingSlides = swiperContainer ? swiperContainer.querySelectorAll('.reminder-slide') : [];
         const remainingCount = remainingSlides.length;

         if (remainingCount === 0) {
             // If no slides left, hide the entire window
             hideUnifiedReminderWindow();
         }
         else {
             // Update counts and index display for the remaining slides
             const countHeader = windowElement.querySelector('.reminder-count-header');
             const countSpan = document.getElementById('total-reminder-count');
             const currentIndexSpan = document.getElementById('current-reminder-index'); // Ensure this is present
             const countTextContainer = document.getElementById('reminder-count-text-container');
             const swipeHint = document.getElementById('reminder-swipe-hint');

             countSpan.textContent = remainingCount; // Update total count displayed
             updateReminderIndexDisplay(); // Recalculate and display current index


             // Adjust UI elements based on remaining count
             if (remainingCount > 1) {
                 countTextContainer.style.display = 'inline';
                 swipeHint.style.display = 'block';
                 countHeader.classList.remove('hidden');
             } else {
                 countTextContainer.style.display = 'none';
                 swipeHint.style.display = 'none';
                 countHeader.classList.remove('hidden'); // Keep header visible even for 1 item
             }

             // Adjust scroll position if the current slide index is now out of bounds
             const maxScrollIndex = remainingCount - 1;
             if (currentNotificationSlideIndex > maxScrollIndex) {
                  currentNotificationSlideIndex = maxScrollIndex; // Go to the last slide
                   // Scroll smoothly to the new index
                  if (swiperContainer) {
                       const targetScrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
                       swiperContainer.scrollTo({ left: targetScrollLeft, behavior: 'smooth' });
                       // Update display after scroll finishes (or after a small delay)
                       setTimeout(updateReminderIndexDisplay, 400);
                  }
             } else {
                  // If the current index is still valid, just update the display
                   updateReminderIndexDisplay();
             }
         }

         // Always update global counts and check for new overdue reminders
         updateReminderCount();
         updateButtonStyles();
         checkReminders();
     }

    function setupReminderTableListeners(modalTable) {
        modalTable.querySelectorAll('.visto-prox').forEach(button => {
            // Clone and replace to ensure fresh listeners
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent row click
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true); // Mark as managed

                let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderIndex = rems.findIndex(r => r.id === id);
                let needsSave = false;
                const row = newButton.closest('tr'); // Get the table row

                if (reminderIndex > -1 && row) {
                    const currentReminder = rems[reminderIndex];
                     if (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval')) {
                        // Location-based, non-cyclic: postpone 15 mins
                        const { newDateISO, newTime } = calculatePostponedDateTime(15);
                        rems[reminderIndex].date = newDateISO;
                        rems[reminderIndex].time = newTime;
                        rems[reminderIndex].managedByUser = false;
                        needsSave = true;
                        // Update date/time display in the table row
                        const dateCell = row.cells[3]; const timeCell = row.cells[2];
                        if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date);
                        if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                        showToast('Recordatorio con ubicación pospuesto 15 min', 'info');
                    } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                         // Cyclic: calculate next occurrence
                         let referenceDateForNext = new Date();
                          try {
                              const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                              const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                              const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                              const nowUTC = new Date();
                              if (!isNaN(reminderDateTime.getTime()) && reminderDateTime <= nowUTC) {
                                   referenceDateForNext = new Date(nowUTC.getTime() + 1000);
                              } else if (!isNaN(reminderDateTime.getTime())) {
                                   referenceDateForNext = reminderDateTime;
                              }
                          } catch(er) { console.warn("Error parsing reminder date/time for next occurrence (table):", er); }


                        const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                        if (nextOcc) {
                            rems[reminderIndex].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                            rems[reminderIndex].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                            rems[reminderIndex].managedByUser = false;
                            needsSave = true;
                             // Update date/time display in the table row
                            const dateCell = row.cells[3]; const timeCell = row.cells[2];
                            if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date); // Need to recalculate formatted next date
                            if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                            showToast('Actualizado al próximo periodo', 'info');
                        } else {
                             // If no next occurrence, delete it
                            rems.splice(reminderIndex, 1); needsSave = true;
                            row.remove(); // Remove row from table
                            showToast('Error calculando siguiente ciclo. Eliminado.', 'error');
                        }
                    } else {
                        // Simple or daily non-location: delete it
                        rems.splice(reminderIndex, 1); needsSave = true;
                        row.remove(); // Remove row from table
                        showToast('Recordatorio borrado', 'info');
                    }
                    if (needsSave) localStorage.setItem('reminders', JSON.stringify(rems));

                    // Check if table is now empty
                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                        // Add empty message row
                         const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
                         tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios ${showExcluded ? ' (incluyendo excluidos)' : ''}.</td></tr>`;
                    }
                } else {
                    showToast('Error: Recordatorio no encontrado para actualizar/borrar.', 'error');
                     // If row was somehow found but reminder wasn't, just remove the row
                    if(row) row.remove();
                }
                // Update counts and check reminders globally
                updateReminderCount(); updateButtonStyles(); checkReminders();
            });
        });

        modalTable.querySelectorAll('.postpone').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent row click
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true); // Mark as managed

                const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderToPostpone = reminders.find(r => r.id === id);
                if (reminderToPostpone) {
                    // Clear table modal auto-close timer and remove the modal
                    if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                    modalTable.remove(); // Remove table modal before opening postpone modal
                    showPostponeOptionsModal(reminderToPostpone, 'table'); // Open postpone options modal
                } else {
                    showToast('Error: Recordatorio no encontrado para posponer.', 'error');
                    markReminderAsManaged(id, false); // Unmark if not found
                    checkReminders(); // Re-check reminders
                }
            });
        });

        modalTable.querySelectorAll('.cancel-cyclic-table').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent row click
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                if (confirm('¿Estás seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE? Esta acción no se puede deshacer.')) {
                    markReminderAsManaged(id, true); // Mark as managed (briefly)
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const initialLength = rems.length;
                    rems = rems.filter(r => r.id !== id); // Remove the reminder
                    if (rems.length < initialLength) {
                        localStorage.setItem('reminders', JSON.stringify(rems));
                        showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                    } else {
                        showToast('Error: No se encontró el ciclo para anular.', 'warning');
                         // If not found/deleted, unmark as managed
                        markReminderAsManaged(id, false);
                    }
                    const row = newButton.closest('tr'); // Get the row
                    if (row) row.remove(); // Remove row from table
                    // Check if table is now empty
                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                         const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
                        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios ${showExcluded ? ' (incluyendo excluidos)' : ''}.</td></tr>`;
                    }
                    // Update counts and check reminders globally
                    updateReminderCount(); updateButtonStyles(); checkReminders();
                }
            });
        });

        // Add click listener to table rows to open modify modal
        const tableBody = modalTable.querySelector('#reminder-table-body');
        if (tableBody) {
             // Clone and replace tbody to remove old listeners, then add new one
            const newTableBody = tableBody.cloneNode(false); // Clone tbody structure
            while(tableBody.firstChild) newTableBody.appendChild(tableBody.firstChild); // Move existing rows
            tableBody.parentNode.replaceChild(newTableBody, tableBody); // Replace old tbody with new

            newTableBody.addEventListener('click', (e) => {
                 // Ignore clicks on buttons within the first cell (actions)
                if (e.target.closest('td:first-child button')) {
                    return;
                }

                const row = e.target.closest('tr[data-id]');
                if (row?.dataset.id) {
                    const id = parseInt(row.dataset.id); if (isNaN(id)) return;
                    markReminderAsManaged(id, true); // Mark as managed before opening modify modal

                    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const reminderToModify = reminders.find(r => r.id === id);
                    if (reminderToModify) {
                         // Check if map was open before table was opened
                         const mapWasOpenBeforeTable = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';

                         // Clear table modal auto-close timer and remove the modal
                        if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                        modalTable.remove(); // Remove table modal before opening reminder modal

                         // Set flag so showReminderModal knows to potentially reopen the map later
                         if (mapWasOpenBeforeTable) {
                             sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                         }
                         // Clear the flag indicating table was opened from map
                         sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                        showReminderModal(reminderToModify); // Open the modify modal
                    } else {
                        showToast('Error: Recordatorio no encontrado para modificar.', 'error');
                         markReminderAsManaged(id, false); // Unmark if not found
                         checkReminders(); // Re-check reminders
                    }
                }
            });
        }
    }

     function showAllReminders() {
         // Check if map is active before closing it to open the table
         const mapWasOpenBeforeThisTable = isRemindersLocationMapActive || !!document.getElementById('reminders-location-map-modal');
         if (mapWasOpenBeforeThisTable) {
             // Set a flag to potentially reopen map after the table is closed
             sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
              // Close the map if it's open
              const mapModalElement = document.getElementById('reminders-location-map-modal');
              if (mapModalElement) {
                  const mapCloseButton = mapModalElement.querySelector('#close-reminders-location-map');
                  if (mapCloseButton) mapCloseButton.click();
                   else mapModalElement.remove();
              }
         } else {
             sessionStorage.removeItem('boardinggate_map_was_open_before_table');
         }

         hideUnifiedReminderWindow(); // Close the unified reminder window if open
         Object.values(previewMaps).forEach(map => map?.remove()); previewMaps = {}; // Clean up preview maps
         // Close any other non-reminder related modals
         const otherModals = document.querySelectorAll('.choice-modal, .edit-modal, .edit-info-modal, .help-modal, .reminder-modal, .versions-modal-overlay, .saved-locations-modal, #postpone-options-modal, #reminders-map-help-modal-instance');
         otherModals.forEach(m => m.remove());


         let allReminders = [];
         try {
             // Retrieve and parse reminders, creating copies to avoid modifying stored data directly during sorting/filtering
             allReminders = JSON.parse(localStorage.getItem('reminders') || '[]').map(r => ({ ...r }));
         } catch(e) {
             showToast("Error al cargar lista de recordatorios.", "error");
             return;
         }

         // Get user preference for showing excluded items (like radars)
         const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
         let remindersToDisplay = allReminders;
         if (!showExcluded) {
             // Filter out items marked as excluded from list
             remindersToDisplay = allReminders.filter(r => !r.excludeFromList);
         }


         // Sort reminders for display
         remindersToDisplay.sort((a, b) => {
             const nowForSort = new Date();
             // Calculate the *next* occurrence time for sorting cyclic reminders
             const nextA = calculateNextOccurrence(a, nowForSort);
             const nextB = calculateNextOccurrence(b, nowForSort);

             if (nextA && nextB) {
                 // If both have a next occurrence, sort by the time of that occurrence
                 const timeDiff = nextA.getTime() - nextB.getTime();
                 if (timeDiff !== 0) return timeDiff;
             } else if (nextA) {
                 // If only A has a future occurrence, A comes first
                 return -1;
             } else if (nextB) {
                 // If only B has a future occurrence, B comes first
                 return 1;
             }
              // If neither has a future occurrence (e.g., simple past reminders), sort by type, then creation date
             const typeOrder = { 'simple': 1, 'hourly': 2, 'daily': 3, 'weekly': 4, 'interval': 5 };
             const typeDiff = (typeOrder[a.type] ?? 99) - (typeOrder[b.type] ?? 99);
             if (typeDiff !== 0) return typeDiff;

             const createdAtA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
             const createdAtB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
             return createdAtA - createdAtB; // Sort by creation date ascending if types/next occurrences are the same
         });

         // Remove any existing reminder table modal
         const existingModal = document.querySelector('.reminder-table-modal');
         if (existingModal) {
             // Clear its auto-close timer if it exists
             const closeButton = existingModal.querySelector('#close-reminders'); // Assuming there's a close button with this ID
             if (closeButton) clearModalAutoCloseTimer(existingModal, closeButton, 'reminder-table-modal');
             else if (existingModal.autoCloseInterval) clearInterval(existingModal.autoCloseInterval);

             if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal);
         }

         const modalTable = document.createElement('div');
         modalTable.className = 'reminder-table-modal';
         modalTable.setAttribute('aria-label', 'Tabla recordatorios');

         modalTable.innerHTML = `
             <h2 style="text-align:center;margin-bottom:1rem;font-size:1.5rem;color:#333;">Recordatorios</h2>

           <div class="top-button-container">
                 <button type="button" id="close-reminders-top">SALIR <span class="button-countdown-timer"></span></button>
                 <button type="button" id="view-all-locations-map">VER UBICACIONES</button>
                 <div style="display: flex; align-items: center; margin-left: 20px;">
                    <input type="checkbox" id="show-excluded-reminders" ${showExcluded ? 'checked' : ''} style="transform: scale(1.2); margin-right: 5px;">
                    <label for="show-excluded-reminders" style="margin-left: 0.5rem; font-size: 1.1rem;">MOSTRAR RADARES u OTROS</label>
                 </div>
             </div>


             <table>
                 <thead>
                     <tr>
                         <th style="width:12%;">Acciones</th>
                         <th>Texto</th>
                         <th style="width:8%;">Hora</th>
                         <th style="width:10%;">Fecha Prox.</th>
                         <th style="width:15%;">Días Rep.</th>
                         <th style="width:8%;">Cada x días</th>
                         <th style="width:8%;">Geoloc.</th>
                         <th style="width:10%;">Creado</th>
                     </tr>
                 </thead>
                 <tbody id="reminder-table-body">
                     ${remindersToDisplay.length === 0 ? `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios ${showExcluded ? ' (incluyendo excluidos)' : ''}.</td></tr>` :
                     remindersToDisplay.map(r => {
                         const isCyclic = r.type === 'weekly' || r.type === 'interval';
                         // Alternate row background colors based on type and excludeFromList status
                         const rowBackgroundColor = isCyclic ? (r.excludeFromList ? '#C0D8C0' : '#D9E5DB') : (r.excludeFromList ? '#D8BFBF' : '#EAD9D9');
                         // Calculate the next occurrence date for display in the table
                         const nextOccurrenceDate = calculateNextOccurrence(r, new Date());
                         const formattedNextDate = nextOccurrenceDate ? formatDateToDDMMMYY(nextOccurrenceDate.toISOString().split('T')[0]) : formatDateToDDMMMYY(r.date);
                         const timeDisplay = r.time ? r.time : '-';
                         const geoIndicator = r.isLocationEnabled ? '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#008000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>' : '-';
                         // Format creation date
                         const formattedCreatedAt = r.createdAt ? formatDateToDDMMMYY(r.createdAt.split('T')[0]) : '-';


                         return `<tr data-id="${r.id}" style="background-color: ${rowBackgroundColor};">
                                     <td>
                                         <button class="visto-prox" data-id="${r.id}" title="${isCyclic ? 'Marcar Visto y Avanzar al Próximo Ciclo' : 'Marcar Visto y Borrar'}">Visto/Prox</button>
                                         <button class="postpone" data-id="${r.id}" title="Posponer">Posponer</button>
                                         ${isCyclic ? `<button class="cancel-cyclic-table" data-id="${r.id}" title="Anular Ciclo Permanente">Anular Ciclo</button>` : ''}
                                     </td>
                                     <td class="text-column" title="Modificar">${r.text}</td>
                                     <td class="time-column">${timeDisplay}</td>
                                     <td class="date-column">${formattedNextDate}</td>
                                     <td>${r.type === 'weekly' && r.repeatDays?.length > 0 ? r.repeatDays.map(d => ['Dom','Lun','Mar','Mié','Jue','Vie','Sáb'][d]).join(', ') : '-'}</td>
                                     <td>${r.type === 'interval' ? r.intervalDays || '-' : '-'}</td>
                                     <td>${geoIndicator}</td>
                                     <td class="date-column">${formattedCreatedAt}</td>
                                 </tr>`;
                     }).join('')}
                 </tbody>
             </table>
             <div class="button-group flex justify-start" style="margin-top:1rem;"><button type="button" id="close-reminders">SALIR <span class="button-countdown-timer"></span></button></div>`;
         document.body.appendChild(modalTable);

         // Add event listener for the "Show Excluded" checkbox
         const showExcludedCheckbox = modalTable.querySelector('#show-excluded-reminders');
         if (showExcludedCheckbox) {
             showExcludedCheckbox.addEventListener('change', () => {
                 localStorage.setItem(SHOW_EXCLUDED_REMINDERS_KEY, JSON.stringify(showExcludedCheckbox.checked));
                 // Close the current modal and re-open it with the new filter setting
                 const closeButton = modalTable.querySelector('#close-reminders');
                 if (closeButton) clearModalAutoCloseTimer(modalTable, closeButton, 'reminder-table-modal');
                 else if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);

                 modalTable.remove();
                 showAllReminders(); // Re-open the table
             });
         }

         // Add event listener for "View Locations Map" button
         const viewLocationsMapButton = modalTable.querySelector('#view-all-locations-map');
         if (viewLocationsMapButton) {
             viewLocationsMapButton.addEventListener('click', () => {
                  // Close the table modal before opening the map
                 const closeButton = modalTable.querySelector('#close-reminders');
                 if (closeButton) clearModalAutoCloseTimer(modalTable, closeButton, 'reminder-table-modal');
                 else if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);

                 modalTable.remove();
                 showAllRemindersLocationMap(); // Open the map
             });
         }


         // Add auto-close timer to the modal
         const closeButton = modalTable.querySelector('#close-reminders');
         const closeButtonTop = modalTable.querySelector('#close-reminders-top');

         const closeClean = () => {
             clearModalAutoCloseTimer(modalTable, closeButton, 'reminder-table-modal');
             // If the modal is still in the DOM (e.g., not removed by another action), remove it
             if (modalTable.parentNode) modalTable.parentNode.removeChild(modalTable);

             // Check if map should reopen after the table is closed
             const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
             sessionStorage.removeItem('boardinggate_map_was_open_before_table'); // Consume the flag

             // Handle case where table was opened from Reminder Modal
             if (fromReminderModal) {
                 fromReminderModal = false; // Reset flag
                  // If map should reopen, set flag for reminder modal to handle it
                 if (mapShouldReopen) {
                     sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                 }
                 showReminderModal(); // Reopen reminder modal
             } else if (mapShouldReopen) {
                 // Reopen map if it was open before and we didn't come from Reminder Modal
                 showAllRemindersLocationMap(); // Assuming showAllRemindersLocationMap exists
             }
         };

          // Add event listeners to both close buttons
         closeButton.addEventListener('click', closeClean);
         closeButtonTop.addEventListener('click', closeClean);

         // Add auto-close timer (e.g., 60 seconds)
         addModalAutoCloseTimer(modalTable, closeButton, 'reminder-table-modal');


         // Setup listeners for buttons within the table rows (postpone, delete etc.)
         setupReminderTableListeners(modalTable);
     }


     function updateReminderCount() {
         let reminders = [];
         try {
             reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
         } catch (e) {
             console.error("Error parsing reminders for count update:", e);
             reminders = []; // Use empty array if parsing fails
         }

         // Get preference for table view (affects the side button count)
         const showExcludedInTable = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
         let remindersForCount = reminders;
         if (!showExcludedInTable) {
             // Filter out excluded items for the count on the side button
             remindersForCount = reminders.filter(r => !r.excludeFromList);
         }

         const totalCount = remindersForCount.length;

         // The globe count shows only non-cyclic (or potentially only overdue non-cyclic?)
         // Based on checkReminders logic, it counts *overdue* reminders. Let's stick to that.
         // The checkReminders function itself calculates and updates this count based on current overdue state.
         // This function should only update the *total* count displayed on the sidebar button.

         // const nonCyclicReminders = remindersForCount.filter(r => r.type !== 'weekly' && r.type !== 'interval');
         // const nonCyclicCount = nonCyclicReminders.length;

         // const countElGlobe = document.getElementById('reminder-count-globe');
         // if (countElGlobe) {
         //     // The globe is updated by checkReminders() with the *overdue* count
         //     // We don't update it here.
         // }

         const reminderButtonElem = document.getElementById('reminder-button');
         if (reminderButtonElem) {
             let countSpanSide = reminderButtonElem.querySelector('.reminder-count');
             if (totalCount > 0) {
                 if (!countSpanSide) {
                     // Create the span if it doesn't exist
                     countSpanSide = document.createElement('span');
                     countSpanSide.className = 'reminder-count';
                     reminderButtonElem.appendChild(countSpanSide);
                 }
                 // Update the text content with the total count displayed in the table (filtered by excluded preference)
                 countSpanSide.textContent = totalCount;
             } else {
                 // Remove the span if count is 0
                 if (countSpanSide) {
                     countSpanSide.remove();
                 }
             }
         }
     }

     function calculateNextOccurrence(reminder, referenceDate) {
          if (!reminder || !reminder.type || !reminder.time || !reminder.date) {
              // console.warn("Invalid reminder data for calculateNextOccurrence:", reminder);
              return null;
          }
          try {
               // Parse date and time in UTC assuming reminder.date/time are UTC components
              let [year, month, day] = reminder.date.split('-').map(Number);
              let [hour, minute] = reminder.time.split(':').map(Number);
              // Create the base date in UTC
              let baseDate = new Date(Date.UTC(year, month - 1, day, hour, minute));

              if (isNaN(baseDate.getTime())) {
                   console.warn("Invalid Date object created for reminder:", reminder);
                   return null;
              }

               // Use UTC time for the reference date as well for consistent comparison
              const refDateUTC = new Date(referenceDate.getTime());
              const refDateUTCMidnight = new Date(Date.UTC(refDateUTC.getUTCFullYear(), refDateUTC.getUTCMonth(), refDateUTC.getUTCDate()));


               // For sorting purposes in the table, we might need the next occurrence even if the baseDate is in the future.
               // However, for determining *overdue* reminders, we only care if the baseDate is <= now.
               // The `checkReminders` function uses `now` as the reference. This function is used by both.
               // Let's assume `referenceDate` is the point in time from which we need to find the *next* occurrence strictly *after* or *at* (depending on context) the reference.
               // The logic in `checkReminders` handles the "overdue" check (baseDate <= now).
               // This function should find the first occurrence *at or after* referenceDate if baseDate is in the past,
               // or simply return baseDate if baseDate is in the future compared to referenceDate.

              if (baseDate > refDateUTC) {
                   // If the original scheduled time is in the future relative to the reference, that's the next occurrence
                   return baseDate;
              }

              // If baseDate is in the past relative to referenceDate, calculate the next one based on the type
              if (reminder.type === 'simple') {
                   // Simple reminders don't repeat, so if the base date is past the reference, there is no "next" occurrence.
                   return null;
              }

              if (reminder.type === 'daily' || reminder.type === 'hourly') { // Hourly isn't strictly implemented but follows daily pattern for next date
                  let next = new Date(baseDate);
                   // Advance day by day until it's after the reference date/time
                  while (next <= refDateUTC) {
                       next.setUTCDate(next.getUTCDate() + 1);
                  }
                  return next;
              }

              if (reminder.type === 'weekly' && reminder.repeatDays && reminder.repeatDays.length > 0) {
                   // Find the next occurrence on a repeating day at the specified time, starting from referenceDate
                  let next = new Date(refDateUTC); // Start checking from the reference date/time
                   // Normalize time to the reminder's time for comparison/calculation
                  next.setUTCHours(hour, minute, 0, 0);


                   // If the time on the reference date is already past the reminder time, start checking from the next day
                  if (next <= refDateUTC && reminder.time !== '00:00') { // Add a small buffer or check strictly after
                       next.setUTCDate(next.getUTCDate() + 1);
                  } else if (reminder.time === '00:00' && next < refDateUTC) {
                       // If time is midnight and reference date is after midnight of next, start next day
                       next.setUTCDate(next.getUTCDate() + 1);
                  }


                  // Iterate through the next 7 days to find the first matching repeat day
                  for (let i = 0; i < 7; i++) {
                      if (reminder.repeatDays.includes(next.getUTCDay())) {
                          return next; // Found the next occurrence date and time
                      }
                       // Move to the next day
                      next.setUTCDate(next.getUTCDate() + 1);
                  }
                  // If no matching day found in the next 7 days (shouldn't happen if repeatDays is not empty)
                  return null;
              }

              if (reminder.type === 'interval' && reminder.intervalDays && reminder.intervalDays > 0) {
                   // Calculate the next occurrence by adding intervals to the base date
                  let next = new Date(baseDate);
                   // Advance by interval days until it's after the reference date/time
                  while (next <= refDateUTC) {
                      next.setUTCDate(next.getUTCDate() + reminder.intervalDays);
                  }
                  return next;
              }

              // Should not reach here if reminder.type is valid
              return null;
          } catch (e) {
              console.error("Error calculating next occurrence:", e, "Reminder:", reminder);
              return null;
          }
     }
     function calculatePostponedDateTime(mins) {
          const now = new Date();
          const postponedDate = new Date(now.getTime() + mins * 60000);
           // Format to YYYY-MM-DD and HH:MM
          const newDateISO = `${postponedDate.getFullYear()}-${(postponedDate.getMonth() + 1).toString().padStart(2, '0')}-${postponedDate.getDate().toString().padStart(2, '0')}`;
          const newTime = `${postponedDate.getHours().toString().padStart(2, '0')}:${postponedDate.getMinutes().toString().padStart(2, '0')}`;
          return { newDateISO, newTime };
     }

     function showPostponeOptionsModal(reminder, source = 'unified') {
         // Close any existing postpone modal
         const existingModal = document.getElementById('postpone-options-modal');
         if (existingModal) {
             // Clear its auto-postpone timer
             if (existingModal.autoPostponeInterval) clearInterval(existingModal.autoPostponeInterval);
             if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal);
         }

         const modal = document.createElement('div');
         modal.id = 'postpone-options-modal';
         modal.className = 'postpone-options';
         // Apply basic styling for positioning/appearance
         modal.style.cssText = `position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); width:90%; max-width:480px; max-height:85vh; overflow-y:auto; background-color:#F5E1A9; padding:1.5rem; border-radius:1rem; box-shadow:0 10px 25px rgba(0,0,0,0.2); z-index:7500; `;
         modal.setAttribute('aria-label', 'Posponer recordatorio');

         let countdown = 10; // Auto-postpone countdown in seconds
         const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval';
         const defaultMinutes = 15; // Default postpone time

         // Create buttons. Different options for cyclic vs non-cyclic.
         let buttonHtml = `
             <button data-minutes="15" class="postpone-option">15 Minutos</button>
             <button data-minutes="60" class="postpone-option">1 Hora</button>
             <button data-minutes="180" class="postpone-option">3 Horas</button>
         `;
         // Add longer options only for non-cyclic reminders
         if (!isCyclic) {
             buttonHtml += `
                 <button data-minutes="1440" class="postpone-option">1 Día</button>
                 <button data-minutes="4320" class="postpone-option">3 Días</button>
             `;
         }

         // Build the modal content
         modal.innerHTML = `
             <style>
                 /* Inline styles or link to a stylesheet */
                 .postpone-options .reminder-text { color:#333; font-size:1.2rem; margin-bottom:.5rem; word-wrap:break-word; }
                 .postpone-options .reminder-details { color:#555; font-size:1rem; margin-bottom:1.5rem; }
                 .postpone-options .button-group { display:flex; flex-direction:column; gap:1rem; align-items:stretch; }
                 .postpone-options button.postpone-option { font-size:1.3rem; font-weight:bold; padding:.8rem 1rem; background-color:#F59E0B; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                 .postpone-options button.postpone-option:hover { background-color:#D97706; }
                 #postpone-countdown { text-align:center; margin-top:1.8rem; font-size:1.1rem; font-weight:500; color:#444; }
                 #postpone-timer-value { font-weight:bold; font-size:1.2rem; }
                 #cancel-postpone { margin-top:1.2rem; width:100%; padding:.7rem 1rem; font-size:1.1rem; background-color:#EF4444; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                 #cancel-postpone:hover { background-color:#DC2626; }
             </style>
             <p class="reminder-text">Posponer: ${reminder.text.replace(/<[^>]*>/g, '')}</p>
             <p class="reminder-details">Selecciona tiempo:</p>
             <div class="button-group">
                 ${buttonHtml}
             </div>
             <p id="postpone-countdown">Automático en <span id="postpone-timer-value">${countdown}</span>s (${defaultMinutes} min)</p>
             <button id="cancel-postpone">Cancelar</button>
         `;
         document.body.appendChild(modal);

         const countdownDisplay = modal.querySelector('#postpone-timer-value');

         // Function to handle the actual postponement logic
         const handlePostpone = (minutes) => {
             // Clear the auto-postpone timer
             if (modal.autoPostponeInterval) clearInterval(modal.autoPostponeInterval);
             modal.autoPostponeInterval = null;

             // If the source was the unified window, remove that reminder's slide
             if (source === 'unified') {
                  updateUnifiedWindowUI(reminder.id); // Removes the slide and updates counts/display
             }


             let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
             const index = reminders.findIndex(r => r.id === reminder.id);

             if (index === -1) {
                 showToast("Error: Recordatorio no encontrado para posponer.", "error");
                 checkReminders(); // Re-check reminders if one seems missing
                 if (modal.parentNode) document.body.removeChild(modal); // Close modal
                 return;
             }

             // Calculate the new date and time after postponement
             const { newDateISO, newTime } = calculatePostponedDateTime(minutes);
             reminders[index].date = newDateISO;
             reminders[index].time = newTime;
             reminders[index].managedByUser = false; // Reset managed state so it can trigger again

             // If it was a cyclic reminder and we postponed it, it now effectively acts like a simple/daily reminder for this next occurrence.
             // However, keeping the original type might be better for calculating the *next* cycle after this postponed one expires.
             // Let's not change the type here. The logic in `checkReminders` and `calculateNextOccurrence` should handle a past date correctly for cyclic reminders.
             // NO, if you postpone a cyclic reminder, it should become a simple reminder for *that specific* postponement instance, until that instance is cleared.
             // The original cyclic definition (repeatDays/intervalDays) should probably be preserved but ignored until the postponed date is past.
             // A simpler approach: When a cyclic is postponed, turn it into a simple reminder with the new date/time. The user can then modify it back to cyclic if needed via the modify button.
             // Reverting this: The current calculateNextOccurrence handles past dates for cyclic reminders by finding the *next* future date. If we postpone a cyclic reminder, its `date` and `time` properties are updated to the postponed time. `calculateNextOccurrence` should then use *these* new properties as the base date for finding the *subsequent* occurrence. This seems more correct - the user is just delaying the *current* notification, not breaking the cycle structure.
             // Okay, let's stick to just updating date/time and managedByUser flag.


             localStorage.setItem('reminders', JSON.stringify(reminders)); // Save changes
             updateReminderCount(); // Update counts everywhere
             updateButtonStyles(); // Update button styles
             checkReminders(); // Re-check reminders immediately

             // Show confirmation toast
             const durationText = minutes >= 1440 ? `${minutes / 1440} día(s)` : (minutes >= 60 ? `${minutes / 60} hora(s)` : `${minutes} minutos`);
             showToast(`Pospuesto ${durationText}`, 'info');

             if (modal.parentNode) document.body.removeChild(modal); // Close modal

             // If the source was the table, reopen the table after postponing
             if (source === 'table') {
                 setTimeout(showAllReminders, 100); // Small delay to allow modal to close
             } else if (source === 'unified') {
                  // If source was unified window, check if map should reopen after unified window closes
                  const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                 sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); // Consume flag

                  // Reopen map ONLY if no other reminder-related modals are open
                  if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !document.getElementById('reminders-location-map-modal')) {
                      showAllRemindersLocationMap();
                  }
             }
         };

         // Start the auto-postpone timer
         modal.autoPostponeInterval = setInterval(() => {
             countdown--;
             // Update countdown display if the element exists and is in the document
             if (countdownDisplay && document.body.contains(countdownDisplay)) countdownDisplay.textContent = countdown;

             if (countdown <= 0) {
                 // Auto-postpone with the default time
                 handlePostpone(defaultMinutes);
             }
         }, 1000);

         // Add event listeners to the postpone option buttons
         modal.querySelectorAll('.postpone-option').forEach(button => {
             button.addEventListener('click', () => {
                 const minutes = parseInt(button.dataset.minutes); // Get minutes from data attribute
                 if (!isNaN(minutes)) {
                     handlePostpone(minutes); // Postpone with the selected time
                 }
             });
         });

         // Add event listener to the cancel button
         modal.querySelector('#cancel-postpone').addEventListener('click', () => {
             // Clear the auto-postpone timer
             clearInterval(modal.autoPostponeInterval);
             modal.autoPostponeInterval = null;
             // Unmark the reminder as managed so it can become overdue again
             markReminderAsManaged(reminder.id, false);
             if (modal.parentNode) document.body.removeChild(modal); // Close modal

             // Handle reopening based on source
             if (source === 'table') {
                 setTimeout(showAllReminders, 100); // Reopen table
             } else if (source === 'unified') {
                  // Check if map should reopen after unified window closes
                 const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                 sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); // Consume flag

                  // Reopen map ONLY if no other reminder-related modals are open
                 if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !document.getElementById('reminders-location-map-modal')) {
                      showAllRemindersLocationMap();
                 }
             }
             showToast('Posposición cancelada', 'info');
         });
     }

    function showYellowBorder() {
        const borderDiv = document.createElement('div');
        borderDiv.style.position = 'fixed';
        borderDiv.style.top = '0';
        borderDiv.style.left = '0';
        borderDiv.style.width = '100vw';
        borderDiv.style.height = '100vh';
        borderDiv.style.boxSizing = 'border-box';
        borderDiv.style.border = '25px solid #FFFF00';
        borderDiv.style.zIndex = '99999';
        borderDiv.style.pointerEvents = 'none';
        borderDiv.style.opacity = '1';
        borderDiv.style.transition = 'opacity 0.5s ease-out';
        document.body.appendChild(borderDiv);

        setTimeout(() => {
            borderDiv.style.opacity = '0';
            setTimeout(() => {
                if (borderDiv.parentNode) {
                    borderDiv.parentNode.removeChild(borderDiv);
                }
            }, 500); // Match opacity transition time
        }, 3500); // Keep border visible for 3.5 seconds
    }


    function checkReminders() {
        let currentReminders = [];
        try {
            // Attempt to parse reminders from localStorage
            currentReminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        } catch (e) {
            // If parsing fails, log error and try to save the corrupted data as backup
            console.error("Error parsing reminders from storage:", e);
            localStorage.setItem('reminders_backup_error', localStorage.getItem('reminders') || '[]'); // Save raw data
            localStorage.removeItem('reminders'); // Clear corrupted data
            showToast("Error al cargar recordatorios. Backup intentado.", "error", 5000);
            currentReminders = []; // Reset to empty array
            // No need to continue check with corrupted data
            return;
        }

        const now = new Date(); // Get current time
        let overdueReminders = []; // List for reminders that are overdue and location condition met
        const validRemindersForStorage = []; // List to rebuild storage if cleanup is needed
        let storageNeedsUpdate = false; // Flag to indicate if localStorage needs to be rewritten
        const processedIds = new Set(); // Use a Set to track processed IDs and filter duplicates

        let newOverdueFound = false; // Flag to trigger yellow border if new overdue reminders appear
        let isAnyReminderNearby = false; // Flag to potentially speed up checks if near a location reminder

        let currentLocationPromise = null;
        // Check if we need location at all (only if there are location-enabled reminders that are not yet managed)
        const needsLocationCheckForReminders = currentReminders.some(r => r.isLocationEnabled && !r.managedByUser);

        if (needsLocationCheckForReminders) {
            // Get current location asynchronously
            currentLocationPromise = new Promise((resolve) => {
                getCurrentLocation(
                    (coords) => resolve(coords), // Resolve with coords on success
                    (errorMsg) => {
                        console.warn("Could not get current location for reminder check:", errorMsg);
                        resolve(null); // Resolve with null on error
                    }
                );
            });
        } else {
             // If no location-based reminders need checking, resolve immediately with null
            currentLocationPromise = Promise.resolve(null);
        }


        currentLocationPromise.then(currentCoords => {
            // Process each reminder after location is obtained (or failed)
            currentReminders.forEach(reminder => {
                 // Basic validation for reminder structure
                if (!reminder || typeof reminder.id !== 'number' || typeof reminder.managedByUser === 'undefined' || !reminder.type || !reminder.time || !reminder.date || !reminder.createdAt) {
                    console.warn("Skipping invalid reminder:", reminder);
                    storageNeedsUpdate = true; // Mark for cleanup
                    return; // Skip this reminder
                }
                 // Skip if already processed (handles potential duplicates from bad storage saves)
                if (processedIds.has(reminder.id)) {
                     console.warn("Skipping duplicate reminder id:", reminder.id);
                     storageNeedsUpdate = true; // Mark for cleanup
                     return;
                }
                processedIds.add(reminder.id); // Mark as processed

                const isManagedByUser = reminder.managedByUser === true; // Check if user has marked it as managed
                let keepInStorage = true; // Assume keeping unless invalid
                let isOverdue = false; // Assume not overdue
                let locationConditionMet = true; // Assume location condition met if not location-enabled or coords obtained

                if (!isManagedByUser) { // Only check managed=false reminders
                    let reminderLocalDueTime = null;
                    try {
                        // Parse reminder date and time assuming they are local time components for comparison with `new Date()`
                        // NOTE: Using Date.UTC was more correct for cross-timezone consistency, but comparing `new Date()` (local) with UTC might be tricky.
                        // Let's stick to local time comparison for simplicity, assuming reminder.date and reminder.time are meant as local time.
                        // If reminder.date and time are meant as UTC components, comparison logic here needs adjustment to use UTC methods or compare UTC Date objects.
                        // Assuming YYYY-MM-DD and HH:MM for local interpretation:
                        const [year, month, day] = reminder.date.split('-').map(Number);
                        const [hour, minute] = reminder.time.split(':').map(Number);
                        // Create Date object using local timezone interpretation
                        reminderLocalDueTime = new Date(year, month - 1, day, hour, minute);


                        if (isNaN(reminderLocalDueTime.getTime())) {
                            throw new Error("Invalid date/time components"); // Trigger error handling for invalid dates
                        }

                        // Check if the reminder's time is in the past relative to now
                        if (reminderLocalDueTime <= now) {
                            isOverdue = true;

                            // If location is enabled, check if location condition is met
                            if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                                if (currentCoords) {
                                    // Calculate distance between current location and reminder location
                                    const distance = calculateDistance(
                                        currentCoords.latitude, currentCoords.longitude,
                                        reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude
                                    );
                                     // Location condition met if distance is within the specified radius
                                    locationConditionMet = distance <= (reminder.radiusMeters || 1000);
                                     // Also flag if any location reminder is nearby (< 1500m)
                                    if (distance < 1500) {
                                        isAnyReminderNearby = true;
                                    }
                                } else {
                                     // Location condition not met if location is required but current coords could not be obtained
                                    locationConditionMet = false;
                                }
                            }
                        } else if (reminder.isLocationEnabled && reminder.locationCoordinates && currentCoords) {
                            // Even if not overdue by time, check if any location reminder is nearby for faster checks
                            const distance = calculateDistance(
                                currentCoords.latitude, currentCoords.longitude,
                                reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude
                            );
                            if (distance < 1500) {
                                isAnyReminderNearby = true;
                            }
                        }


                    } catch (error) {
                        // Handle errors during date parsing or comparison
                        console.error("Error checking reminder date/time/location:", error, "Reminder:", reminder);
                        storageNeedsUpdate = true; // Mark for cleanup
                        keepInStorage = false; // Don't keep invalid reminder
                        isOverdue = false; // Not overdue if invalid
                        locationConditionMet = false; // Location condition not met if invalid or error
                    }
                }

                // If the reminder is overdue by time AND location condition is met (or not applicable), add to overdue list
                if (isOverdue && locationConditionMet) {
                    overdueReminders.push(reminder);
                     // Check if this is a *new* overdue reminder that wasn't already shown in the unified window
                     // This prevents showing the yellow border for reminders already present.
                     if (!isUnifiedWindowVisibleByLogic || !document.querySelector(`#unified-reminder-window .reminder-slide[data-id="${reminder.id}"]`)) {
                         newOverdueFound = true;
                     }
                }

                // Keep valid reminders for potential storage update
                if (keepInStorage) {
                    validRemindersForStorage.push(reminder);
                }
            });

            // If any invalid or duplicate reminders were found, rewrite localStorage
            if (storageNeedsUpdate) {
                try {
                    const oldStorageString = localStorage.getItem('reminders') || '[]';
                    const newStorageString = JSON.stringify(validRemindersForStorage);
                    // Only write if there's actually a change to avoid unnecessary writes
                    if (oldStorageString !== newStorageString) {
                        localStorage.setItem('reminders', newStorageString);
                         console.log("Cleaned up reminders storage.");
                    }
                } catch (e) {
                    console.error("Error saving cleaned reminders storage:", e);
                    showToast("Error al actualizar recordatorios tras limpieza.", "error", 5000);
                }
            }

            // Display or hide the unified reminder window based on the overdue list
            if (overdueReminders.length > 0) {
                 // If new overdue reminders are found, show the yellow border and reset slide index
                if (!isUnifiedWindowVisibleByLogic || newOverdueFound) {
                    currentNotificationSlideIndex = 0; // Start from the first slide
                    if (newOverdueFound) showYellowBorder(); // Show border only for new overdue ones
                }
                 // Display the window with the filtered/sorted overdue list
                 displayUnifiedReminderWindow(overdueReminders);
            }
            else {
                 // If no overdue reminders, hide the window and reset slide index
                 hideUnifiedReminderWindow();
                 currentNotificationSlideIndex = 0;
            }

            // Update counts and styles globally
            updateReminderCount();
            updateButtonStyles();

            // Adjust check interval based on whether any location reminder is nearby
            const newInterval = isAnyReminderNearby ? 2000 : 60000; // 2 seconds if nearby, 60 seconds otherwise
            if (newInterval !== currentCheckIntervalDuration) {
                currentCheckIntervalDuration = newInterval; // Update interval duration
                if (reminderCheckIntervalId) {
                    clearInterval(reminderCheckIntervalId); // Clear old interval
                }
                // Set new interval with the potentially adjusted duration
                reminderCheckIntervalId = setInterval(checkReminders, currentCheckIntervalDuration);
                 console.log(`Reminder check interval adjusted to ${currentCheckIntervalDuration} ms.`);
            }


            // Auto-swipe logic for the unified window (if visible and multiple items)
            const swiperContainer = document.getElementById('reminder-swiper-container');
            const windowElement = document.getElementById('unified-reminder-window');

            if (swiperContainer && overdueReminders.length > 0 && windowElement.classList.contains('visible')) {
                const totalSlides = overdueReminders.length;
                let nextSlideIndex = currentNotificationSlideIndex;

                // Only auto-swipe if there's more than one slide
                if (totalSlides > 1) {
                    nextSlideIndex = (currentNotificationSlideIndex + 1) % totalSlides; // Move to the next slide cyclically
                } else {
                    nextSlideIndex = 0; // Stay on the first slide if only one
                }
                // Perform the scroll only if the index changes (or if there's only one slide but the window just opened/updated)
                if (totalSlides === 1 || nextSlideIndex !== currentNotificationSlideIndex) {
                     // Check if the slide at currentNotificationSlideIndex actually exists before attempting to scroll to it
                    if (swiperContainer.querySelectorAll('.reminder-slide')[nextSlideIndex]) {
                         currentNotificationSlideIndex = nextSlideIndex; // Update stored index
                         const targetScrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
                         swiperContainer.scrollTo({ left: targetScrollLeft, behavior: 'smooth' }); // Smooth scroll
                         // Update display after scroll animation completes (or after a brief moment)
                         setTimeout(updateReminderIndexDisplay, 400);
                     } else {
                         // If the target slide doesn't exist (e.g., removed by user action just before auto-swipe),
                         // trigger a checkReminders to refresh the UI.
                         console.warn("Attempted to auto-swipe to non-existent slide index. Triggering recheck.");
                         checkReminders();
                     }
                }
            }
        });
    }


    // Basic distance calculation (Haversine formula is more accurate but this is simpler)
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3; // metres
        const φ1 = lat1 * Math.PI/180; // φ, λ in radians
        const φ2 = lat2 * Math.PI/180;
        const Δφ = (lat2-lat1) * Math.PI/180;
        const Δλ = (lon2-lon1) * Math.PI/180;

        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                  Math.cos(φ1) * Math.cos(φ2) *
                  Math.sin(Δλ/2) * Math.sin(Δλ/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

        const distance = R * c; // in metres
        return distance;
    }


     function getSavedLocations() {
        try {
            const locations = localStorage.getItem(SAVED_LOCATIONS_KEY);
            // Ensure the returned array has MAX_SAVED_LOCATIONS slots, filling with null if needed
            const parsedLocations = locations ? JSON.parse(locations) : [];
            while (parsedLocations.length < MAX_SAVED_LOCATIONS) {
                parsedLocations.push(null);
            }
            return parsedLocations.slice(0, MAX_SAVED_LOCATIONS); // Ensure it doesn't exceed max length either
        } catch (e) {
            console.error("Error loading saved locations:", e);
             // Return an array of nulls in case of error
            return Array(MAX_SAVED_LOCATIONS).fill(null);
        }
    }

    function saveLocationsToCache(locationsArray) {
        try {
             // Filter out empty/null slots before saving to keep storage clean, but ensure structure is correct on load
             const filteredLocations = locationsArray.filter(loc => loc && (loc.name?.trim() !== '' || (loc.lat !== null && loc.lng !== null)));
            localStorage.setItem(SAVED_LOCATIONS_KEY, JSON.stringify(filteredLocations));
            showToast("Ubicaciones guardadas.", "success");
        } catch (e) {
            console.error("Error saving locations:", e);
            showToast("Error al guardar ubicaciones.", "error");
        }
    }

    function showSavedLocationsModal(callbackOnClose, callbackOnSelectLocation) {
         // Close existing modal if open
        const existingModal = document.querySelector('.saved-locations-modal');
        if (existingModal) {
             // Clean up map picker if it's initialized within the existing modal
            if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
             // Clear its auto-close timer
             const closeButton = existingModal.querySelector('#close-saved-locations-modal');
             if (closeButton) clearModalAutoCloseTimer(existingModal, closeButton, 'saved-locations-modal');

            existingModal.remove();
        }

        // Load locations into a temporary array for editing in the modal
        tempSavedLocations = getSavedLocations();

         // Create and show the modal
        const modal = document.createElement('div');
        modal.className = 'saved-locations-modal';
        modal.setAttribute('aria-label', 'Gestionar Ubicaciones Guardadas');

        modal.innerHTML = `
            <h2>Gestionar Ubicaciones Guardadas (Máx. ${MAX_SAVED_LOCATIONS})</h2>
            <div id="saved-locations-list">
                <!-- Location slots will be added here by loadAndDisplaySlots -->
            </div>
            <div id="location-picker-map-container">
                <!-- Map picker will be initialized here -->
                <button id="picker-ok-map-button" class="map-button" title="Confirmar esta posición">OK Ubicación</button>
                <button id="picker-locate-me-button" class="map-button" title="Ir a mi posición actual">Mi Ubicación</button>
            </div>
            <div class="button-group">
                <button id="save-all-user-locations">Guardar Cambios</button>
                <button id="close-saved-locations-modal">Cerrar</button>
            </div>
        `;
        document.body.appendChild(modal);

        const listElement = modal.querySelector('#saved-locations-list');
        const mapPickerContainer = modal.querySelector('#location-picker-map-container');
        const okMapBtn = modal.querySelector('#picker-ok-map-button');
        const locateMeMapBtn = modal.querySelector('#picker-locate-me-button');
        const saveAllButton = modal.querySelector('#save-all-user-locations');
        const closeButton = modal.querySelector('#close-saved-locations-modal');


        // Function to populate the list of location slots
        function loadAndDisplaySlots() {
            listElement.innerHTML = ''; // Clear current list
            for (let i = 0; i < MAX_SAVED_LOCATIONS; i++) {
                const location = tempSavedLocations[i];
                const slotDiv = document.createElement('div');
                slotDiv.className = 'location-slot';
                slotDiv.innerHTML = `
                    <span style="width: 25px; text-align: right; font-weight: bold;">${i + 1}.</span>
                    <input type="text" placeholder="Nombre Ubicación" value="${location?.name || ''}" data-index="${i}">
                    <button class="map-button" data-index="${i}" title="Fijar en Mapa">📍 Mapa</button>
                    <button class="select-location-button" data-index="${i}" title="Seleccionar esta ubicación para el recordatorio actual">Seleccionar</button>
                    <span class="coords-display">${location?.lat && location?.lng ? `${parseFloat(location.lat).toFixed(4)}, ${parseFloat(location.lng).toFixed(4)}` : 'No fijada'}</span>
                `;
                listElement.appendChild(slotDiv);

                 // Add input listener to update name in temp array
                slotDiv.querySelector('input[type="text"]').addEventListener('input', (e) => {
                     // Initialize slot data if it's null
                    if (!tempSavedLocations[i]) tempSavedLocations[i] = { name: '', lat: null, lng: null, radius: 1000 };
                    tempSavedLocations[i].name = e.target.value;
                     // Reset auto-close timer on input
                     if (modal.autoCloseInterval) clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
                });

                 // Add listener for the "Map" button to open the map picker for this slot
                slotDiv.querySelector('.map-button').addEventListener('click', () => {
                    currentEditingLocationSlotIndex = i; // Store which slot is being edited
                    mapPickerContainer.classList.add('expanded'); // Show the map container
                    initializeLocationPickerMap('location-picker-map-container', i); // Initialize the map

                    const currentSlotLocation = tempSavedLocations[i];
                    const initialCoords = currentSlotLocation?.lat && currentSlotLocation?.lng
                        ? { latitude: currentSlotLocation.lat, longitude: currentSlotLocation.lng }
                        : null;

                    // Set map view and marker to current location if available
                    if (locationPickerMap && initialCoords) {
                        locationPickerMap.setView([initialCoords.latitude, initialCoords.longitude], 15);
                        if (locationPickerMarker) locationPickerMarker.setLatLng([initialCoords.latitude, initialCoords.longitude]);
                         // If marker doesn't exist yet, create a draggable one
                        else {
                             locationPickerMarker = L.marker([initialCoords.latitude, initialCoords.longitude], {draggable: true}).addTo(locationPickerMap);
                             locationPickerMarker.on('dragend', (event) => {
                                 const pos = event.target.getLatLng();
                                 if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
                                 tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat;
                                 tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng;
                             });
                        }
                    } else if (locationPickerMap) {
                         // If no initial location for this slot, try to center on user's current location
                         getCurrentLocation(
                            (coords) => {
                                locationPickerMap.setView([coords.latitude, coords.longitude], 16);
                                 if(locationPickerMarker) locationPickerMarker.setLatLng([coords.latitude, coords.longitude]);
                                 else {
                                     locationPickerMarker = L.marker([coords.latitude, coords.longitude], {draggable: true}).addTo(locationPickerMap);
                                     locationPickerMarker.on('dragend', (event) => {
                                         const pos = event.target.getLatLng();
                                         if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
                                         tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat;
                                         tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng;
                                     });
                                 }
                                 // Also update the temp location data with current coords immediately
                                if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
                                tempSavedLocations[currentEditingLocationSlotIndex].lat = coords.latitude;
                                tempSavedLocations[currentEditingLocationSlotIndex].lng = coords.longitude;
                            },
                            () => { } // Ignore error, just don't center
                        );
                    }
                     // Reset auto-close timer
                     if (modal.autoCloseInterval) clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
                });

                 // Add listener for the "Select" button to pass the location back to the calling modal
                const selectButton = slotDiv.querySelector('.select-location-button');
                selectButton.addEventListener('click', () => {
                    const selectedIndex = parseInt(selectButton.dataset.index);
                    const selectedLocData = tempSavedLocations[selectedIndex];
                     // Only select if location coordinates are set
                    if (selectedLocData && selectedLocData.lat && selectedLocData.lng) {
                         // Call the callback function passed from the reminder modal
                        if (callbackOnSelectLocation && typeof callbackOnSelectLocation === 'function') {
                            callbackOnSelectLocation({
                                name: selectedLocData.name,
                                lat: selectedLocData.lat,
                                lng: selectedLocData.lng,
                                radius: selectedLocData.radius || 1000 // Provide default radius if not set
                            });
                        }
                         // Clean up map picker
                        if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
                         // Clear auto-close timer and close modal
                        clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
                        modal.remove();
                    } else {
                        showToast("Ubicación no fijada. Fíjala en el mapa primero.", "warning");
                    }
                });
            }
        }
        // Load and display the slots initially
        loadAndDisplaySlots();


        // Add listener for the "OK" button on the map picker
        okMapBtn.addEventListener('click', () => {
             // Update the coordinates in the temp array if a marker is set and a slot is being edited
            if (locationPickerMarker && currentEditingLocationSlotIndex !== -1) {
                const pos = locationPickerMarker.getLatLng();
                 // Initialize slot data if null
                if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
                tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat;
                tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng;

                 // Update the displayed coordinates text in the list
                const slotInput = listElement.querySelector(`.location-slot input[data-index="${currentEditingLocationSlotIndex}"]`);
                if (slotInput) {
                    const coordsDisplay = slotInput.closest('.location-slot').querySelector('.coords-display');
                    if (coordsDisplay) {
                        coordsDisplay.textContent = `${pos.lat.toFixed(4)}, ${pos.lng.toFixed(4)}`;
                    }
                }
            }
            mapPickerContainer.classList.remove('expanded'); // Hide the map container
            if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; } // Clean up map
            currentEditingLocationSlotIndex = -1; // Reset editing index
        });

        // Add listener for the "Locate Me" button on the map picker
        locateMeMapBtn.addEventListener('click', () => {
            if (locationPickerMap) {
                locateMeMapBtn.disabled = true; locateMeMapBtn.textContent = 'Buscando...';
                getCurrentLocation(
                    (coords) => {
                         // Center map and set marker to current location
                        locationPickerMap.setView([coords.latitude, coords.longitude], 16);
                        if (locationPickerMarker) locationPickerMarker.setLatLng([coords.latitude, coords.longitude]);
                         // If marker doesn't exist, create a draggable one
                        else {
                             locationPickerMarker = L.marker([coords.latitude, coords.longitude], {draggable: true}).addTo(locationPickerMap);
                             locationPickerMarker.on('dragend', (event) => {
                                 const pos = event.target.getLatLng();
                                 if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
                                 tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat;
                                 tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng;
                             });
                        }
                         // Update the temp location data with current coords
                        if (currentEditingLocationSlotIndex !== -1) {
                           if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
                            tempSavedLocations[currentEditingLocationSlotIndex].lat = coords.latitude;
                            tempSavedLocations[currentEditingLocationSlotIndex].lng = coords.longitude;
                        }
                        locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.'; // Reset button state
                    },
                    (errorMsg) => {
                        showToast(`Error localización: ${errorMsg}`, 'error');
                        locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.'; // Reset button state
                    }
                );
            }
        });


        // Add listener for the "Save Changes" button
        saveAllButton.addEventListener('click', () => {
             // Clean up empty slots before saving
            const locationsToSave = tempSavedLocations.map(loc => {
                // Keep slot if it has a name OR coordinates set. Otherwise, discard.
                if (loc && ((loc.name && loc.name.trim() !== '') || (loc.lat !== null && loc.lng !== null))) {
                     // Ensure radius is a number if coords are set
                    if (loc.lat !== null && loc.lng !== null && typeof loc.radius !== 'number') {
                        loc.radius = 1000; // Default radius
                    }
                    return loc;
                }
                return null; // Discard this slot
            }).filter(loc => loc !== null); // Filter out null entries


            saveLocationsToCache(locationsToSave); // Save the filtered list

             // Call the close callback passed from the reminder modal
            if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose();
             // Clean up map picker
            if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
             // Clear auto-close timer and close modal
            clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
            modal.remove();
        });

        // Add listener for the "Close" button
        const closeHandler = () => {
             // Clear auto-close timer
            clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
             // Clean up map picker
            if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
             // Call the close callback
            if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose();
             // Remove the modal
            modal.remove();
        };
        closeButton.addEventListener('click', closeHandler);

         // Add auto-close timer to the modal
        addModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
    }

    function initializeLocationPickerMap(mapContainerId, slotIndex) {
         // Remove any existing map picker instance
        if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }

        const mapDiv = document.createElement('div');
        mapDiv.style.width = '100%'; mapDiv.style.height = '100%';
        const container = document.getElementById(mapContainerId);
         // Clear previous map instance divs but keep buttons
        while (container.firstChild && container.firstChild.classList && !container.firstChild.classList.contains('map-button')) {
             container.removeChild(container.firstChild);
        }
        container.insertBefore(mapDiv, container.firstChild); // Insert the new map div before the buttons


        // Set initial view based on the location data for this slot or a default
        const initialLocation = tempSavedLocations[slotIndex] || {};
        const centerLat = initialLocation.lat || 40.416775; // Default to Madrid
        const centerLng = initialLocation.lng || -3.703790;
        const initialZoom = (initialLocation.lat && initialLocation.lng) ? 15 : 6; // Zoom in if coords exist, otherwise zoom out

        locationPickerMap = L.map(mapDiv, { zoomControl: true }).setView([centerLat, centerLng], initialZoom);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        }).addTo(locationPickerMap);

         // Add a draggable marker to the initial location or center
        locationPickerMarker = L.marker([centerLat, centerLng], { draggable: true }).addTo(locationPickerMap);
         // Update the temp location data when the marker is dragged
        locationPickerMarker.on('dragend', (event) => {
            const pos = event.target.getLatLng();
            if (!tempSavedLocations[slotIndex]) tempSavedLocations[slotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
            tempSavedLocations[slotIndex].lat = pos.lat;
            tempSavedLocations[slotIndex].lng = pos.lng;
        });

         // Add click listener to set the marker position by clicking the map
        locationPickerMap.on('click', (e) => handlePickerMapClick(e, slotIndex));
         // Invalidate map size to fix rendering issues in modals
        setTimeout(() => locationPickerMap.invalidateSize(), 100);
    }

    function handlePickerMapClick(e, slotIndex) {
        const latlng = e.latlng;
         // Update marker position
        if (locationPickerMarker) {
            locationPickerMarker.setLatLng(latlng);
        }
         // Update the temp location data for the current slot
        if (!tempSavedLocations[slotIndex]) tempSavedLocations[slotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
        tempSavedLocations[slotIndex].lat = latlng.lat;
        tempSavedLocations[slotIndex].lng = latlng.lng;
    }


L.Control.OrientationAltitude = L.Control.extend({
    onAdd: function(map) {
        const container = L.DomUtil.create('div', 'leaflet-control-orientation-altitude leaflet-bar');
        L.DomUtil.addClass(container, 'leaflet-control'); // Add standard leaflet control class
        // Apply styles to make it blend better and allow flex column
        container.style.backgroundColor = 'transparent';
        container.style.boxShadow = 'none';
        container.style.border = 'none';
        container.style.padding = '0';
        container.style.margin = '0';


        const compassContainer = L.DomUtil.create('div', '', container);
        compassContainer.style.backgroundColor = 'transparent';
        compassContainer.style.padding = '0';
        compassContainer.style.boxShadow = 'none';
        compassContainer.style.textAlign = 'center';
        compassContainer.style.display = 'flex';
        compassContainer.style.flexDirection = 'column';
        compassContainer.style.alignItems = 'center';


        compassContainer.innerHTML = `
            <img id="compass-rose-icon" src="ROSA.PNG" alt="Orientación" style="width: calc(70px * 2.5 * 0.9); height: calc(70px * 2.5 * 0.9); opacity: 0.5; display: block; margin: 0 auto 5px auto; transition: transform 0.3s ease-out;">
            <div id="orientation-altitude-text-container" style="background-color: rgba(255, 255, 255, 0.85); padding: calc(4px * 0.85) calc(6px * 0.85); border-radius: 3px; box-shadow: 0 1px 4px rgba(0,0,0,0.3); text-align: center; display: flex; flex-direction: column; align-items: center;">
                 <span id="orientation-text" style="display: block; font-size: calc(1.5em * 0.85 * 1.5); color: #333; line-height: 1.1; margin-bottom: 1px;">---</span>
                 <span id="altitude-display" style="display: block; font-size: calc(1.5em * 0.85 * 1.5); color: #333; line-height: 1.1;">--- m</span>
            </div>
        `;

        // Prevent map events from propagating from this control
        L.DomEvent.disableClickPropagation(container);
        return container;
    },
    // Update the compass rose rotation and text display
    updateOrientation: function(heading) {
        const compassRoseIcon = document.getElementById('compass-rose-icon');
        const orientationText = document.getElementById('orientation-text');
        if (compassRoseIcon && orientationText) {
            if (heading !== null && !isNaN(heading) && heading >= 0 && heading <= 360) {
                compassRoseIcon.style.transform = `rotate(${heading}deg)`;
                const directions = ["N", "NE", "E", "SE", "S", "SO", "O", "NO", "N"];
                const index = Math.round(heading / 45) % 8;
                orientationText.textContent = `${directions[index]}`;
            } else {
                compassRoseIcon.style.transform = 'rotate(0deg)';
                orientationText.textContent = '---'; // Show placeholder if no heading
            }
        }
    },
    // Update the altitude text display
    updateAltitude: function(altitude) {
        const altitudeDisplay = document.getElementById('altitude-display');
        if (altitudeDisplay) {
            if (altitude !== null && !isNaN(altitude)) {
                 // Format altitude to 0 decimal places
                altitudeDisplay.textContent = `${altitude.toFixed(0)} m`;
            } else {
                altitudeDisplay.textContent = '--- m'; // Show placeholder if no altitude
            }
        }
    }
});
// Factory function for the control
L.control.orientationAltitude = function(opts) {
    return new L.Control.OrientationAltitude(opts);
}


function showAllRemindersLocationMap() {
    isRemindersLocationMapActive = true;
    console.log("showAllRemindersLocationMap: Iniciando");

    // State variables for routing and navigation
    let currentRoutingMode = 'none'; // 'none', 'creating', 'navigating'
    let currentRouteWaypointsLatLng = []; // Array of L.LatLng for user-added waypoints (excluding start)
    let routePreviewControl = null; // LRM control for route preview during creation
    let navigationRoutingControl = null; // LRM control for navigation
    let userMarkerForRoute = null; // Marker for user position during navigation (car icon)
    let routeLineForProgress = null; // Coordinates of the primary route line for progress tracking
    let totalRouteDistance = 0; // Total distance of the route for progress calculation
    let simpleWaypointMarkers = []; // Markers for points added during route creation (F, 1, 2...)
    let startRouteMarkerVisual = null; // Marker for the dynamic start point (user location) during route creation (S)


    const SAVED_ROUTES_KEY = 'boardinggate_saved_routes'; // Key for localStorage


    // Get reminders with location enabled
    let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    let remindersWithLocation = reminders.filter(r => r.isLocationEnabled && r.locationCoordinates?.latitude && r.locationCoordinates?.longitude);

    // Close any existing map modal instance
    const existingModal = document.getElementById('reminders-location-map-modal');
    if (existingModal) {
        // Clean up any existing map instance and watchers
        if (allLocationsMapInstance) {
            if (initialUserLocationMarker) { initialUserLocationMarker.remove(); initialUserLocationMarker = null; }
            if (initialUserLocationCircle) { initialUserLocationCircle.remove(); initialUserLocationCircle = null; }
            if (orientationAltitudeControl && allLocationsMapInstance && typeof allLocationsMapInstance.hasControl === 'function' && allLocationsMapInstance.hasControl(orientationAltitudeControl)) {
                allLocationsMapInstance.removeControl(orientationAltitudeControl);
            }
            orientationAltitudeControl = null;
            try { allLocationsMapInstance.remove(); } catch (e) { console.warn("Error removing previous allLocationsMapInstance:", e); }
            allLocationsMapInstance = null;
        }
        if (locationWatchId !== null) {
            navigator.geolocation.clearWatch(locationWatchId);
            locationWatchId = null;
        }
         // Remove the modal element from the DOM
        existingModal.remove();
    }

     // Reset map state variables
    if (allLocationsMapInstance) { // Should be null after cleanup, but defensive check
        if (initialUserLocationMarker) { initialUserLocationMarker.remove(); initialUserLocationMarker = null; }
        if (initialUserLocationCircle) { initialUserLocationCircle.remove(); initialUserLocationCircle = null; }
        if (orientationAltitudeControl && allLocationsMapInstance && typeof allLocationsMapInstance.hasControl === 'function' && allLocationsMapInstance.hasControl(orientationAltitudeControl)) {
            allLocationsMapInstance.removeControl(orientationAltitudeControl);
        }
        orientationAltitudeControl = null;
        try { allLocationsMapInstance.remove(); } catch (e) { console.warn("Error removing previous allLocationsMapInstance:", e); }
        allLocationsMapInstance = null;
    }
    if (locationWatchId !== null) { // Should be null after cleanup
        navigator.geolocation.clearWatch(locationWatchId);
        locationWatchId = null;
    }
     shouldCenterOnUserInAllLocationsMap = true; // Default to centering on user initially


     // Create the modal element for the map
    const mapModal = document.createElement('div');
    mapModal.id = 'reminders-location-map-modal';
    mapModal.innerHTML = `
        <div id="reminders-location-map-content-wrapper">
            <div id="reminders-location-map-header">
                <div id="route-actions-group" class="button-group-route">
                    <button id="create-route-button" class="route-button-action" title="Crear o Iniciar/Detener Ruta">CREAR RUTA</button>
                    <button id="save-route-button" class="route-button-action" title="Guardar Ruta Actual" style="display:none;">GUARDAR RUTA</button>
                    <button id="load-route-button" class="route-button-action" title="Cargar Ruta Guardada">CARGAR RUTA</button>
                </div>
                <h2 style="display:none;"></h2>
                 <div style="display: flex; align-items: center; margin-left: auto; margin-right:10px; white-space: nowrap;">
                    <input type="checkbox" id="toggle-radar-visibility-map" checked style="transform: scale(1.2); margin-right: 5px;">
                    <label for="toggle-radar-visibility-map" style="font-size: 0.9rem; font-weight: normal; color: #555;">Ver Radares</label>
                </div>
                <div class="button-group-main">
                    <button id="close-reminders-location-map" class="reminders-map-button-action" title="Cerrar mapa">SALIR</button>
                    <button id="locate-me-on-reminders-map" class="reminders-map-button-action" title="Mostrar mi posición actual y activar seguimiento">ESTÁS AQUÍ</button>
                    <button id="add-radar-here" class="reminders-map-button-action" title="Crear RADAR en mi posición actual (radio 1000m)">AQUÍ HAY UN RADAR</button>
                    <button id="reminders-map-help-button" class="reminders-map-button-action" title="Ayuda del mapa">AYUDA</button>
                </div>
            </div>
            <div id="reminders-location-map-div">

                <div id="progress-bar-container">
                    <div id="progress-bar-fill">
                         <span id="progress-bar-text-overlay"></span>
                    </div>
                </div>
                 <div id="routing-info-panel" style="display:none;"></div>
                 <div id="current-maneuver-panel" style="display: none;">
                    <div class="maneuver-icon"></div>
                    <div class="maneuver-text-container">
                        <div class="maneuver-instruction"></div>
                        <div class="maneuver-distance">
                           <div class="distance-bar-fill-container" style="width:100%; height:5px; background-color: #555; border-radius:2.5px; margin-top:2px;">
                               <div class="distance-bar-fill" style="width:100%; height:100%; background-color:orange; border-radius:2.5px; transition: width 0.2s linear;"></div>
                           </div>
                        </div>
                        <div class="next-maneuver"></div>
                    </div>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(mapModal);

    // Get references to DOM elements within the modal
    const mapContainer = document.getElementById('reminders-location-map-div');
    const closeButton = document.getElementById('close-reminders-location-map');
    const locateMeButtonMap = document.getElementById('locate-me-on-reminders-map');
    const helpButton = document.getElementById('reminders-map-help-button');
    const addRadarButton = document.getElementById('add-radar-here');
    const toggleRadarVisibilityCheckbox = document.getElementById('toggle-radar-visibility-map');


    const createRouteButton = document.getElementById('create-route-button');
    const saveRouteButton = document.getElementById('save-route-button');
    const loadRouteButton = document.getElementById('load-route-button');
    const routingInfoPanel = document.getElementById('routing-info-panel');
    const currentManeuverPanel = document.getElementById('current-maneuver-panel');
    const progressBarContainer = document.getElementById('progress-bar-container');
    const progressBarFill = document.getElementById('progress-bar-fill');
    const progressBarTextOverlay = document.getElementById('progress-bar-text-overlay');

    let allMapMarkers = []; // Markers for reminders

    // Function to plot reminder markers on the map
    const plotReminders = (showRadars = true) => {
         // Remove existing reminder markers and circles from the map
        allMapMarkers.forEach(item => {
            if (item.marker && allLocationsMapInstance && allLocationsMapInstance.hasLayer(item.marker)) item.marker.remove();
            if (item.circle && allLocationsMapInstance && allLocationsMapInstance.hasLayer(item.circle)) item.circle.remove();
        });
        allMapMarkers = []; // Clear the array

        // Iterate through reminders with location and add markers/circles
        remindersWithLocation.forEach(reminder => {
            // Determine if the reminder is a 'Radar' type
            const isRadarType = reminder.text.toUpperCase().includes("RADAR:") || reminder.excludeFromList;

            // Skip plotting if showRadars is false and it's a radar type
            if (!showRadars && isRadarType) {
                return;
            }

            const latLng = [reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude];
            // Choose icon and circle color based on type
            const markerIconToUse = isRadarType ? radarMarkerIcon : defaultLocationMarkerIconBlue;
            const circleColor = isRadarType ? '#800080' : 'blue';
            const circleFillColor = isRadarType ? '#DA70D6' : '#ADD8E6';
            const circleFillOpacity = isRadarType ? 0.1 : 0.05;

            // Add marker to map
            const marker = L.marker(latLng, {
                icon: markerIconToUse,
                title: reminder.text.replace(/<[^>]*>/g, '').substring(0, 50) // Set title for hover/tooltip
            }).addTo(allLocationsMapInstance);

            // Add circle to map
            const circle = L.circle(latLng, {
                radius: reminder.radiusMeters || 1000,
                color: circleColor,
                fillColor: circleFillColor,
                weight: 1,
                fillOpacity: circleFillOpacity
            }).addTo(allLocationsMapInstance);

            // Store marker, circle, and reminder data
            allMapMarkers.push({marker, circle, reminderData: reminder});


            // Create and bind popup content
            let popupContent = `
                <div style="max-width: 250px; font-family: sans-serif; font-size: 0.9rem;">
                    <strong style="font-size: 1rem; color: #333; display: block; margin-bottom: 5px;">${reminder.text.replace(/<b>|<\/b>/gi,'')}</strong>
                    <hr style="margin: 4px 0;">
                    ${reminder.time ? `<p style="margin: 3px 0;"><strong>Hora:</strong> ${formatTimeWithPeriod(reminder.time)}</p>` : ''}
                    ${reminder.date ? `<p style="margin: 3px 0;"><strong>Fecha:</strong> ${formatDateDetailed(reminder.date)}</p>` : ''}
                    ${reminder.type === 'weekly' && reminder.repeatDays?.length > 0 ? `<p style="margin: 3px 0;"><strong>Repite:</strong> ${reminder.repeatDays.map(d => ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'][d]).join(', ')}</p>` : ''}
                    ${reminder.type === 'interval' && reminder.intervalDays ? `<p style="margin: 3px 0;"><strong>Cada:</strong> ${reminder.intervalDays} días</p>` : ''}
                    <p style="margin: 3px 0;"><strong>Radio:</strong> ${reminder.radiusMeters || 1000}m</p>
                    <button data-reminder-id="${reminder.id}" class="modify-reminder-from-map" style="margin-top: 8px; padding: 4px 8px; font-size: 0.8rem; background-color: #10B981; color: white; border: none; border-radius: 3px; cursor: pointer;">Modificar</button>
                </div>`;
            marker.bindPopup(popupContent);

             // Add event listener to the modify button inside the popup when the popup opens
            marker.on('popupopen', () => {
                const modifyButton = marker.getPopup().getElement().querySelector('.modify-reminder-from-map');
                if (modifyButton) {
                     // Clone and replace the button to ensure a fresh listener
                    const newModifyButton = modifyButton.cloneNode(true);
                    modifyButton.parentNode.replaceChild(newModifyButton, modifyButton);
                    newModifyButton.addEventListener('click', (e) => {
                        const id = parseInt(e.target.dataset.reminderId);
                        if (!isNaN(id)) {
                            const rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                            const remToMod = rems.find(r => r.id === id);
                            if (remToMod) {
                                 // Close the map modal before opening the reminder modal
                                closeHandlerAllMap();
                                showReminderModal(remToMod); // Open the reminder modal
                            } else { showToast("Error: No se encontró el recordatorio para modificar.", "error"); }
                        }
                    });
                }
            });
        });
    };

    // Function to filter reminder markers based on proximity to the current navigation route
    function filterMarkersNearRoute() {
        // If no navigation or route is selected, plot all reminders
        if (!navigationRoutingControl || !navigationRoutingControl._selectedRoute) {
            plotReminders(toggleRadarVisibilityCheckbox.checked);
            return;
        }
        const routeLine = navigationRoutingControl._selectedRoute.coordinates;
        if (!routeLine || routeLine.length === 0) {
            plotReminders(toggleRadarVisibilityCheckbox.checked); // If route has no geometry, show all
            return;
        }

        // Remove all existing reminder markers and circles
        allMapMarkers.forEach(item => {
            if (item.marker && allLocationsMapInstance && allLocationsMapInstance.hasLayer(item.marker)) item.marker.remove();
            if (item.circle && allLocationsMapInstance && allLocationsMapInstance.hasLayer(item.circle)) item.circle.remove();
        });
        allMapMarkers = []; // Clear the array

        const proximity = 1500; // Distance threshold in meters (1.5 km)
        remindersWithLocation.forEach(reminder => {
            const isRadarTypeReminder = reminder.text.toUpperCase().includes("RADAR:") || reminder.excludeFromList;
            // Skip radar types if the visibility checkbox is unchecked
            if (!toggleRadarVisibilityCheckbox.checked && isRadarTypeReminder) {
                return;
            }

            const reminderLatLng = L.latLng(reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude);
            let isNear = false;

            // Check if the reminder location is near the route line
            // Use L.GeometryUtil.isNear for efficiency if available, fallback for older versions or simple check
            if (L.GeometryUtil.isVersion07x()) {
                 // Fallback for older Leaflet/plugin versions that might not have isNear
                 for (let i = 0; i < routeLine.length - 1; i++) {
                     if (L.GeometryUtil.distanceSegment(allLocationsMapInstance, reminderLatLng, routeLine[i], routeLine[i+1]) < proximity) {
                         isNear = true;
                         break;
                     }
                 }
            } else {
                 // Modern L.GeometryUtil approach
                 try {
                     isNear = L.GeometryUtil.isNear(allLocationsMapInstance, routeLine, reminderLatLng, proximity);
                 } catch(e) {
                     // Fallback if isNear is not working as expected
                     console.warn("Error using L.GeometryUtil.isNear, falling back.", e);
                      for (let i = 0; i < routeLine.length - 1; i++) {
                          if (L.GeometryUtil.distanceSegment(allLocationsMapInstance, reminderLatLng, routeLine[i], routeLine[i+1]) < proximity) {
                              isNear = true;
                              break;
                          }
                      }
                 }
            }


            const markerIconToUse = isRadarTypeReminder ? radarMarkerIcon : defaultLocationMarkerIconBlue;
            const circleColor = isRadarTypeReminder ? '#800080' : 'blue';
            const circleFillColor = isRadarTypeReminder ? '#DA70D6' : '#ADD8E6';
            let circleFillOpacity = isRadarTypeReminder ? 0.1 : 0.05;
            let markerOpacity = 1.0;
            let circleBorderOpacity = 1.0;

            // Reduce opacity for markers that are not near the route
            if (!isNear) {
                markerOpacity = 0.15;
                circleFillOpacity = 0.02;
                circleBorderOpacity = 0.1;
            }

            // Add marker with potentially reduced opacity
            const marker = L.marker([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude], {
                icon: markerIconToUse,
                title: reminder.text.replace(/<[^>]*>/g, '').substring(0, 50),
                opacity: markerOpacity
            }).addTo(allLocationsMapInstance);

            // Add circle with potentially reduced opacity
            const circle = L.circle([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude], {
                radius: reminder.radiusMeters || 1000,
                color: circleColor,
                fillColor: circleFillColor,
                weight: 1,
                opacity: circleBorderOpacity,
                fillOpacity: circleFillOpacity
            }).addTo(allLocationsMapInstance);

            // Store the map items
            allMapMarkers.push({marker, circle, reminderData: reminder});

            // Only bind popup for markers near the route
            if (isNear) {
                 let popupContent = `
                    <div style="max-width: 250px; font-family: sans-serif; font-size: 0.9rem;">
                        <strong style="font-size: 1rem; color: #333; display: block; margin-bottom: 5px;">${reminder.text.replace(/<b>|<\/b>/gi,'')}</strong>
                        <hr style="margin: 4px 0;">
                        ${reminder.time ? `<p style="margin: 3px 0;"><strong>Hora:</strong> ${formatTimeWithPeriod(reminder.time)}</p>` : ''}
                        ${reminder.date ? `<p style="margin: 3px 0;"><strong>Fecha:</strong> ${formatDateDetailed(reminder.date)}</p>` : ''}
                        <p style="margin: 3px 0;"><strong>Radio:</strong> ${reminder.radiusMeters || 1000}m</p>
                        <button data-reminder-id="${reminder.id}" class="modify-reminder-from-map" style="margin-top: 8px; padding: 4px 8px; font-size: 0.8rem; background-color: #10B981; color: white; border: none; border-radius: 3px; cursor: pointer;">Modificar</button>
                    </div>`;
                marker.bindPopup(popupContent);
                 // Add event listener to modify button in popup
                marker.on('popupopen', () => {
                    const modifyButton = marker.getPopup().getElement().querySelector('.modify-reminder-from-map');
                    if (modifyButton) {
                        const newModifyButton = modifyButton.cloneNode(true);
                        modifyButton.parentNode.replaceChild(newModifyButton, modifyButton);
                        newModifyButton.addEventListener('click', (e) => {
                            const id = parseInt(e.target.dataset.reminderId);
                            if (!isNaN(id)) {
                                const rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                                const remToMod = rems.find(r => r.id === id);
                                if (remToMod) {
                                    closeHandlerAllMap(); // Close map modal
                                    showReminderModal(remToMod); // Open reminder modal
                                } else { showToast("Error: No se encontró el recordatorio para modificar.", "error"); }
                            }
                        });
                    }
                });
            }
        });
    }


    // Update UI elements (buttons, panels) based on current routing mode
    function updateRoutingUI() {
        if (currentRoutingMode === 'creating') {
            createRouteButton.textContent = currentRouteWaypointsLatLng.length >= 1 ? 'INICIAR NAVEGACIÓN' : 'CREAR RUTA';
            saveRouteButton.style.display = currentRouteWaypointsLatLng.length >= 1 ? 'inline-flex' : 'none';
            addRadarButton.style.display = 'inline-flex'; // Show add radar button

            currentManeuverPanel.style.display = 'none'; // Hide maneuver panel
            progressBarContainer.style.display = 'none'; // Hide progress bar
            // Remove LRM controls if they exist
            if (navigationRoutingControl && allLocationsMapInstance.hasControl(navigationRoutingControl)) {
                allLocationsMapInstance.removeControl(navigationRoutingControl);
                navigationRoutingControl = null;
            }
            if (routePreviewControl && allLocationsMapInstance.hasControl(routePreviewControl)) {
                 allLocationsMapInstance.removeControl(routePreviewControl);
                 routePreviewControl = null;
            }
            // Draw route preview if points exist
             if (currentRouteWaypointsLatLng.length > 0 && initialUserLocationMarkerLat && initialUserLocationMarkerLng) {
                drawRoutePreview(); // Redraw preview if points exist
            } else {
                if(routingInfoPanel) routingInfoPanel.style.display = 'none'; // Hide info panel
                clearSimpleWaypointMarkers(); // Clear waypoint markers if no points
                 // Remove static start marker if no waypoints are set yet
                 if (startRouteMarkerVisual && allLocationsMapInstance && allLocationsMapInstance.hasLayer(startRouteMarkerVisual)) {
                    startRouteMarkerVisual.remove();
                    startRouteMarkerVisual = null;
                 }
            }
            plotReminders(toggleRadarVisibilityCheckbox.checked); // Show all reminders


        } else if (currentRoutingMode === 'navigating') {
            createRouteButton.textContent = 'DETENER NAVEGACIÓN';
            saveRouteButton.style.display = 'inline-flex';
            addRadarButton.style.display = 'none'; // Hide add radar button during navigation
            routingInfoPanel.style.display = 'flex';
            currentManeuverPanel.style.display = 'flex'; // Ensure maneuver panel is shown
            progressBarContainer.style.display = 'flex';
             // Remove route preview control if it exists
             if (routePreviewControl && allLocationsMapInstance.hasControl(routePreviewControl)) {
                 allLocationsMapInstance.removeControl(routePreviewControl);
                 routePreviewControl = null;
            }
            clearSimpleWaypointMarkers(); // Waypoint markers are handled by navigationRoutingControl now
             // Remove static start marker during navigation (user position marker is used)
             if (startRouteMarkerVisual && allLocationsMapInstance && allLocationsMapInstance.hasLayer(startRouteMarkerVisual)) {
                 startRouteMarkerVisual.remove();
                 startRouteMarkerVisual = null;
            }
            filterMarkersNearRoute(); // Show only nearby reminders/radars


        } else { // 'none' mode
            createRouteButton.textContent = 'CREAR RUTA';
            saveRouteButton.style.display = 'none';
            addRadarButton.style.display = 'inline-flex'; // Show add radar button
            routingInfoPanel.style.display = 'none'; // Hide info panel
            currentManeuverPanel.style.display = 'none'; // Hide maneuver panel
            progressBarContainer.style.display = 'none'; // Hide progress bar
            // Remove LRM controls
            if (navigationRoutingControl && allLocationsMapInstance.hasControl(navigationRoutingControl)) {
                allLocationsMapInstance.removeControl(navigationRoutingControl);
                navigationRoutingControl = null;
            }
            if (routePreviewControl && allLocationsMapInstance.hasControl(routePreviewControl)) {
                 allLocationsMapInstance.removeControl(routePreviewControl);
                 routePreviewControl = null;
            }
            currentRouteWaypointsLatLng = []; // Clear waypoints
            clearSimpleWaypointMarkers(); // Clear waypoint markers
             // Remove static start marker
             if (startRouteMarkerVisual && allLocationsMapInstance && allLocationsMapInstance.hasLayer(startRouteMarkerVisual)) {
                startRouteMarkerVisual.remove();
                startRouteMarkerVisual = null;
             }
            plotReminders(toggleRadarVisibilityCheckbox.checked); // Show all reminders
        }
    }

    // Remove simple waypoint markers used during route creation
    function clearSimpleWaypointMarkers() {
        simpleWaypointMarkers.forEach(m => { if(m && allLocationsMapInstance && allLocationsMapInstance.hasLayer(m)) m.remove();});
        simpleWaypointMarkers = [];
    }

     // Update icons and `waypointArrayIndex` for remaining simple markers after deletion
     function updateSimpleWaypointIcons() {
         let indexInLatLng = 0;
         simpleWaypointMarkers.forEach((marker) => {
             if (marker === startRouteMarkerVisual) {
                 // Start marker icon is always 'S' and doesn't need index update
                 return;
             }

             // Find the corresponding LatLng in the currentRouteWaypointsLatLng array
             const foundIndex = currentRouteWaypointsLatLng.findIndex(wp => wp.lat === marker.getLatLng().lat && wp.lng === marker.getLatLng().lng);

             if (foundIndex !== -1) {
                 marker.waypointArrayIndex = foundIndex; // Update the stored index

                 let icon;
                 // Check if it's the new last waypoint in the list
                 if (foundIndex === currentRouteWaypointsLatLng.length - 1) {
                     icon = createNumberedIcon('F', 'red', 28, true);
                 } else {
                     // It's an intermediate waypoint, number them 1-based
                     icon = createNumberedIcon(foundIndex + 1, '#F59E0B', 28, false);
                 }

                 // Only update icon if it's different to avoid unnecessary DOM changes
                 if (!marker.getIcon().options.html.includes(icon.options.html)) { // Simple HTML check
                      marker.setIcon(icon);
                 }
                 indexInLatLng++; // Increment for the next simple marker (excluding start)
             } else {
                  // This marker's LatLng is no longer in currentRouteWaypointsLatLng, it should ideally be removed.
                  // This case shouldn't happen if deletion logic is correct.
                  console.warn("Simple waypoint marker found without matching LatLng in array. Removing.");
                  if(allLocationsMapInstance && allLocationsMapInstance.hasLayer(marker)) marker.remove();
             }
         });
          // Filter out any markers that were removed from the map
          simpleWaypointMarkers = simpleWaypointMarkers.filter(m => m === startRouteMarkerVisual || (m && allLocationsMapInstance && allLocationsMapInstance.hasLayer(m)));
     }


    // Create custom numbered/lettered div icons for waypoints
    function createNumberedIcon(numberOrChar, color = 'blue', baseSize = 28, isStartEnd = false) {
        const finalSize = isStartEnd ? Math.round(baseSize * 1.5) : Math.round(baseSize * 1.2);
        const isCharF = numberOrChar === 'F';
        const isCharS = numberOrChar === 'S';
        const fontWeight = 'bold';
        const fontSize = (isCharF || isCharS) ? `${finalSize * 0.65}px` : `${finalSize * 0.55}px`;
        const charOffset = (isCharF || isCharS) ? `${finalSize * 0.05}px` : '0px'; // Vertical adjustment for letters

        return L.divIcon({
            html: `<div style="background-color:${color}; color:white; width:${finalSize}px; height:${finalSize}px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:${fontSize}; font-weight:${fontWeight}; box-shadow: 0 0 3px rgba(0,0,0,0.5); transform: translateY(${charOffset}); opacity: 0.75;">${numberOrChar}</div>`,
            className: 'custom-waypoint-div-icon', // Add custom class for styling
            iconSize: [finalSize, finalSize],
            iconAnchor: [finalSize / 2, finalSize / 2] // Center the icon
        });
    }

    // Translate OSRM maneuver instructions to Spanish
    function getManeuverTranslation(text) {
        if (!text) return "";
        let esText = text;

        const translations = {
            "Turn left": "Gira a la izquierda",
            "Turn right": "Gira a la derecha",
            "Go straight": "Sigue recto", "Continue straight": "Continúa recto",
            "Keep left": "Mantente a la izquierda",
            "Keep right": "Mantente a la derecha",
            "Make a U-turn": "Haz un cambio de sentido",
            "Enter the roundabout": "Entra en la rotonda",
            "onto": "hacia",
            "Destination will be on the left": "El destino estará a la izquierda",
            "Destination will be on the right": "El destino estará a la derecha",
            "You have arrived at your destination": "Has llegado a tu destino",
            "Arrive at destination": "Llegar al destino",
            "Head": "Dirígete",
            "north": "norte", "south": "sur", "east": "este", "west": "oeste",
            "northeast": "noreste", "northwest": "noroeste",
            "southeast": "sureste", "southwest": "suroeste",
            "Take the ramp": "Toma la rampa",
            "Merge": "Incorpórate",
            "Exit": "Sal",
            "Slight left": "Ligera a la izquierda",
            "Slight right": "Ligera a la derecha",
            "Sharp left": "Giro cerrado a la izquierda",
            "Sharp right": "Giro cerrado a la derecha",
            "on": "en", // Contextual translation might vary
            "at": "en", // Contextual translation might vary
            "and": "y",
            "road": "carretera", "street": "calle", "avenue": "avenida", "boulevard": "bulevar",
            "highway": "autopista", "freeway": "autovía", "interstate": "interestatal",
            "roundabout": "rotonda"
        };

        // Sort keys by length descending to avoid replacing parts of longer words (e.g., 'left' before 'slight left')
        const sortedTranslationsKeys = Object.keys(translations).sort((a, b) => b.length - a.length);

        for (const eng of sortedTranslationsKeys) {
            // Use a regular expression to replace whole words matching the English key, case-insensitive
            const regex = new RegExp(`\\b${eng}\\b`, "gi");
            esText = esText.replace(regex, translations[eng]);
        }

        // Specific exit number translation (e.g., "Take the 1st exit" -> "Toma la 1ª salida")
        // Updated regex to handle st, nd, rd, th correctly and use Spanish ordinal symbol ª
        esText = esText.replace(/Take the (\d+)(?:st|nd|rd|th) exit/gi, (match, num) => `Toma la ${num}ª salida`);
        esText = esText.replace(/and take the (\d+)(?:st|nd|rd|th) exit/gi, (match, num) => `y toma la ${num}ª salida`);
         esText = esText.replace(/from roundabout take the (\d+)(?:st|nd|rd|th) exit/gi, (match, num) => `de la rotonda toma la ${num}ª salida`);
         esText = esText.replace(/take the (\d+)(?:st|nd|rd|th) exit from the roundabout/gi, (match, num) => `toma la ${num}ª salida de la rotonda`);


        // Clean up potential double spaces created by replacements and trim leading/trailing spaces
        esText = esText.replace(/\s+/g, ' ').trim();

        // Capitalize the first letter of the resulting sentence
        return esText.charAt(0).toUpperCase() + esText.slice(1);
    }


    // Map OSRM maneuver types to CSS classes for icons
    function getManeuverIconClass(maneuverType) {
        const type = maneuverType ? maneuverType.toLowerCase() : '';
        // Prioritize specific turns
        if (type.includes('slight left')) return 'leaflet-routing-icon-slight-left';
        if (type.includes('slight right')) return 'leaflet-routing-icon-slight-right';
        if (type.includes('sharp left')) return 'leaflet-routing-icon-sharp-left';
        if (type.includes('sharp right')) return 'leaflet-routing-icon-sharp-right';
         // Then general turns
        if (type.includes('left')) return 'leaflet-routing-icon-turn-left';
        if (type.includes('right')) return 'leaflet-routing-icon-turn-right';

        if (type.includes('straight') || type.includes('continue')) return 'leaflet-routing-icon-continue';
        if (type.includes('u-turn')) return 'leaflet-routing-icon-u-turn';
        if (type.includes('roundabout')) return 'leaflet-routing-icon-roundabout';
        if (type.includes('merge')) return 'leaflet-routing-icon-merge';
         // Added common OSRM types
        if (type.includes('fork')) return 'leaflet-routing-icon-fork';
        if (type.includes('ramp') || type.includes('on ramp')) return 'leaflet-routing-icon-ramp';
        if (type.includes('off ramp') || type.includes('exit')) return 'leaflet-routing-icon-off-ramp';
        if (type.includes('end of road')) return 'leaflet-routing-icon-arrive'; // or some other end icon


        if (type.includes('arrive')) return 'leaflet-routing-icon-arrive';

        // Default icon if type is not matched
        return 'leaflet-routing-icon-depart'; // Default or 'start' icon
    }


    // Draw the route preview during route creation mode
    function drawRoutePreview() {
         // Remove any existing LRM controls (preview or navigation)
        if (routePreviewControl && allLocationsMapInstance.hasControl(routePreviewControl)) {
            allLocationsMapInstance.removeControl(routePreviewControl);
            routePreviewControl = null;
        }
        if (navigationRoutingControl && allLocationsMapInstance.hasControl(navigationRoutingControl)) {
             allLocationsMapInstance.removeControl(navigationRoutingControl);
             navigationRoutingControl = null;
        }

        // Keep only the manual start marker if it exists, remove other simple markers
        simpleWaypointMarkers = simpleWaypointMarkers.filter(m => m === startRouteMarkerVisual);
         // Ensure the start marker is on the map if it exists
        if (startRouteMarkerVisual && allLocationsMapInstance && !allLocationsMapInstance.hasLayer(startRouteMarkerVisual)) {
             startRouteMarkerVisual.addTo(allLocationsMapInstance);
        }


        // If there are no user-added waypoints or no known start location, hide route info and clear markers (except the manual start if it exists)
        if (!initialUserLocationMarkerLat || !initialUserLocationMarkerLng || currentRouteWaypointsLatLng.length === 0) {
             if(routingInfoPanel) routingInfoPanel.style.display = 'none'; // Hide info panel
             // Ensure only the start marker remains if it was added manually
             if (startRouteMarkerVisual && allLocationsMapInstance && allLocationsMapInstance.hasLayer(startRouteMarkerVisual)) {
                 simpleWaypointMarkers = [startRouteMarkerVisual];
             } else {
                 clearSimpleWaypointMarkers(); // Clear all simple markers if no start marker
             }
             // Also remove the start marker visual if there are no waypoints at all
             if (currentRouteWaypointsLatLng.length === 0 && startRouteMarkerVisual && allLocationsMapInstance && allLocationsMapInstance.hasLayer(startRouteMarkerVisual)) {
                 startRouteMarkerVisual.remove();
                 startRouteMarkerVisual = null;
                 simpleWaypointMarkers = [];
             }
            return;
        }

        // Define the start point based on current user location
        const startPoint = L.latLng(initialUserLocationMarkerLat, initialUserLocationMarkerLng);

        // Ensure the static start marker visual is present and updated during creation mode
        if (!startRouteMarkerVisual) {
            startRouteMarkerVisual = L.marker(startPoint, {icon: createNumberedIcon('S', 'green', 28, true), draggable:false });
            if (allLocationsMapInstance && !allLocationsMapInstance.hasLayer(startRouteMarkerVisual)) {
                 startRouteMarkerVisual.addTo(allLocationsMapInstance);
            }
             // Add to simple markers list if not already there
             if (!simpleWaypointMarkers.includes(startRouteMarkerVisual)) {
                simpleWaypointMarkers.unshift(startRouteMarkerVisual); // Add to the beginning
            } else {
                startRouteMarkerVisual.setLatLng(startPoint); // Update position if it exists
            }
        } else {
             startRouteMarkerVisual.setLatLng(startPoint); // Always update start marker position
             if (allLocationsMapInstance && !allLocationsMapInstance.hasLayer(startRouteMarkerVisual)) {
                 startRouteMarkerVisual.addTo(allLocationsMapInstance);
             }
              if (!simpleWaypointMarkers.includes(startRouteMarkerVisual)) {
                 simpleWaypointMarkers.unshift(startRouteMarkerVisual);
             }
        }


        // Prepare waypoints array for LRM preview control
        // The first waypoint for LRM is the start point (user location)
        // Subsequent waypoints are the user-added points
        const waypointsForPreview = [
            L.Routing.waypoint(startPoint),
            ...currentRouteWaypointsLatLng.map(wp => L.Routing.waypoint(wp))
        ];

        // Initialize LRM control for route preview
        routePreviewControl = L.Routing.control({
            waypoints: waypointsForPreview,
            routeWhileDragging: true, // Keep route line updated when dragging waypoint markers
            show: false, // Don't show default LRM panel
            addWaypoints: false, // Prevent adding waypoints via LRM interface
            draggableWaypoints: true, // Allow dragging the *created* markers added by LRM
            fitSelectedRoutes: false, // Don't auto-zoom to route bounds initially
            lineOptions: {
                styles: [{ color: 'blue', opacity: 0.8, weight: 6 }] // Style for the route line
            },
             // Custom function to create markers for LRM
            createMarker: function(i, waypoint, n) {
                 // We handle the start marker (index 0) manually (startRouteMarkerVisual)
                if (i === 0) {
                    // Return a transparent marker for the start waypoint so LRM includes it in the route calculation
                    return L.marker(waypoint.latLng, { opacity: 0 });
                }

                let icon;
                let isLastWaypoint = (i === n - 1); // Check if this is the last waypoint (user-added destination)

                if (isLastWaypoint) {
                    icon = createNumberedIcon('F', 'red', 28, true); // 'F' icon for final destination
                } else {
                    icon = createNumberedIcon(i, '#F59E0B', 28, false); // Numbered icon for intermediate points (1-based)
                }

                 // Create the LRM marker at the waypoint location
                const marker = L.marker(waypoint.latLng, { icon: icon, draggable: true });
                // Store the index in our `currentRouteWaypointsLatLng` array (0-based, excluding the initial user location)
                marker.waypointArrayIndex = i - 1; // LRM index starts from 0 (user location), our array starts from 0

                // Add delete icon to the marker element
                const deleteIcon = L.DomUtil.create('div', 'delete-waypoint-icon');
                deleteIcon.innerHTML = '✖';
                // Use a timeout to ensure marker element is ready before adding the delete icon
                setTimeout(() => {
                    if (marker.getElement()) {
                         marker.getElement().appendChild(deleteIcon);

                         // Add delete listener to the delete icon
                         L.DomEvent.on(deleteIcon, 'click', function(clickEvent) {
                             L.DomEvent.stop(clickEvent); // Prevent click propagating to the map/marker
                             const markerIndexInLatLngArray = marker.waypointArrayIndex;
                             // Ensure the index is valid before attempting to remove
                             if (markerIndexInLatLngArray !== undefined && markerIndexInLatLngArray < currentRouteWaypointsLatLng.length) {
                                currentRouteWaypointsLatLng.splice(markerIndexInLatLngArray, 1); // Remove the waypoint from our LatLng array
                                // The LRM control will automatically redraw the route and markers after its waypoints change (due to draggableWaypoints=true or manual setWaypoints).
                                // We need to trigger a redraw explicitly only if LRM doesn't handle it reliably on array mutation.
                                // A safer approach is to just call drawRoutePreview() which rebuilds the LRM control.
                                drawRoutePreview(); // Redraw the route and markers from scratch
                                updateRoutingUI(); // Update UI state (e.g., button text)
                                updateSimpleWaypointIcons(); // Update indices/icons on remaining simple markers
                             }
                         });
                    }
                }, 0); // Use setTimeout 0 to defer execution until the next event loop tick


                // Add dragend listener to update waypoint position in our array when dragged
                marker.on('dragend', function(event) {
                    const newLatLng = event.target.getLatLng();
                    const markerIndexInLatLngArray = this.waypointArrayIndex;
                    if (markerIndexInLatLngArray !== undefined && currentRouteWaypointsLatLng[markerIndexInLatLngArray]) {
                       currentRouteWaypointsLatLng[markerIndexInLatLngArray] = newLatLng; // Update LatLng in our array
                       drawRoutePreview(); // Redraw the route based on new position
                    }
                });

                 // Add the LRM-created marker to our simpleWaypointMarkers list (excluding the invisible start marker)
                // This list helps us manage delete handles and potentially update icons.
                if (i > 0) { // Skip the start marker (index 0)
                     simpleWaypointMarkers.push(marker);
                }
                return marker; // Return the marker for LRM to add to the map
            },
             router: L.Routing.osrmv1({
                serviceUrl: 'https://router.project-osrm.org/route/v1',
                profile: 'driving' // Or 'walking', 'cycling'
            })
        }).addTo(allLocationsMapInstance);

        // Event listener for when LRM finds a route (preview)
        routePreviewControl.on('routesfound', function(e) {
             if (e.routes && e.routes.length > 0) {
                const summary = e.routes[0].summary;
                // Display preview distance and time in the info panel
                if(routingInfoPanel && currentRoutingMode === 'creating'){ // Ensure we are still in creating mode
                    routingInfoPanel.innerHTML = `
                        <p><strong>Dist (previa):</strong> ${(summary.totalDistance / 1000).toFixed(1)} km</p>
                        <p><strong>Tiempo (previa):</strong> ${Math.round(summary.totalTime / 60)} min</p>`;
                    routingInfoPanel.style.display = 'flex';

                    // Update indices and icons on the markers that LRM created
                     // LRM adds markers *before* routesfound, so they should exist here.
                    const lrmMarkers = routePreviewControl.getMarkers();
                    // Filter out the invisible start marker that LRM creates internally
                    const visibleLrmMarkers = lrmMarkers.filter(m => m.options.opacity !== 0);

                    // Sync our simpleWaypointMarkers list with the visible markers LRM created
                    // Keep our manual start marker if it exists
                    simpleWaypointMarkers = simpleWaypointMarkers.filter(m => m === startRouteMarkerVisual);
                    simpleWaypointMarkers.push(...visibleLrmMarkers);

                    // Update indices and ensure delete handles/listeners are attached/correct
                     visibleLrmMarkers.forEach((lrmMarker, i) => {
                         // The index `i` here corresponds to the index in the `visibleLrmMarkers` array (0-based for the first user-added point)
                         // which maps directly to the index in our `currentRouteWaypointsLatLng` array.
                         lrmMarker.waypointArrayIndex = i; // Correct index mapping

                         let icon;
                         let isLastWaypoint = (i === visibleLrmMarkers.length - 1);

                         if (isLastWaypoint) {
                             icon = createNumberedIcon('F', 'red', 28, true);
                         } else {
                             icon = createNumberedIcon(i + 1, '#F59E0B', 28, false); // Use 1-based index for icon number
                         }
                         // Update icon if it's not the expected one
                         if (!lrmMarker.getIcon().options.html.includes(icon.options.html)) {
                             lrmMarker.setIcon(icon);
                         }

                          // Ensure delete icon and listener are present and correct
                          setTimeout(() => { // Use timeout as element might not be fully ready
                              if (lrmMarker.getElement()) {
                                   let deleteIcon = lrmMarker.getElement().querySelector('.delete-waypoint-icon');
                                  // If delete icon is missing, create and add it
                                  if (!deleteIcon) {
                                      deleteIcon = L.DomUtil.create('div', 'delete-waypoint-icon');
                                      deleteIcon.innerHTML = '✖';
                                      lrmMarker.getElement().appendChild(deleteIcon);
                                  } else {
                                       // Remove old listeners before adding a new one
                                      L.DomEvent.off(deleteIcon, 'click');
                                  }

                                   // Add or re-add click listener for deletion
                                   L.DomEvent.on(deleteIcon, 'click', function(clickEvent) {
                                       L.DomEvent.stop(clickEvent);
                                       const markerIndexInLatLngArray = lrmMarker.waypointArrayIndex;
                                       if (markerIndexInLatLngArray !== undefined && markerIndexInLatLngArray < currentRouteWaypointsLatLng.length) {
                                          currentRouteWaypointsLatLng.splice(markerIndexInLatLngArray, 1); // Remove from our array
                                          drawRoutePreview(); // Redraw the preview (which rebuilds LRM and markers)
                                          updateRoutingUI(); // Update UI
                                          // updateSimpleWaypointIcons will be called within the redraw process
                                       }
                                   });
                              }
                          }, 0); // Defer execution


                     });
                      updateSimpleWaypointIcons(); // Final update pass on our consolidated list

                }
            }
        });
         // Event listener for routing errors during preview
         routePreviewControl.on('routingerror', function(e) {
            showToast("Error previsualizando ruta.", "warning");
            if(routingInfoPanel) routingInfoPanel.style.display = 'none'; // Hide info panel on error

            // Keep the points and markers, just clear the route line/control
            if (routePreviewControl && allLocationsMapInstance.hasControl(routePreviewControl)) {
                allLocationsMapInstance.removeControl(routePreviewControl);
                routePreviewControl = null; // Clear the control
            }

            // Re-add simple markers manually if LRM didn't create them or removed them due to error
            clearSimpleWaypointMarkers(); // Remove any potentially leftover LRM markers
             // Add the manual start marker
             if (startRouteMarkerVisual && allLocationsMapInstance && !allLocationsMapInstance.hasLayer(startRouteMarkerVisual)) {
                  startRouteMarkerVisual.addTo(allLocationsMapInstance);
                  simpleWaypointMarkers.push(startRouteMarkerVisual);
             }
             // Add markers for user-added waypoints
             currentRouteWaypointsLatLng.forEach((wp, index) => {
                 const icon = index === currentRouteWaypointsLatLng.length - 1 ? createNumberedIcon('F', 'red', 28, true) : createNumberedIcon(index + 1, '#F59E0B', 28, false);
                 const marker = L.marker(wp, { icon: icon, draggable: true }).addTo(allLocationsMapInstance);
                 marker.waypointArrayIndex = index; // Store the index
                 simpleWaypointMarkers.push(marker); // Add to our list

                  // Add delete icon and listener (similar to createMarker in drawRoutePreview)
                   setTimeout(() => {
                       if (marker.getElement()) {
                            const deleteIcon = L.DomUtil.create('div', 'delete-waypoint-icon');
                            deleteIcon.innerHTML = '✖';
                            marker.getElement().appendChild(deleteIcon);
                             L.DomEvent.on(deleteIcon, 'click', function(clickEvent) {
                                 L.DomEvent.stop(clickEvent);
                                 const markerIndexInLatLngArray = marker.waypointArrayIndex;
                                 if (markerIndexInLatLngArray !== undefined && markerIndexInLatLngArray < currentRouteWaypointsLatLng.length) {
                                    currentRouteWaypointsLatLng.splice(markerIndexInLatLngArray, 1);
                                     // Re-draw if user location becomes known later, else just update markers
                                    if (initialUserLocationMarkerLat && initialUserLocationMarkerLng) drawRoutePreview();
                                    else { // If no user location, we can't use LRM preview, just manage markers manually
                                        if (allLocationsMapInstance.hasLayer(marker)) marker.remove();
                                        simpleWaypointMarkers = simpleWaypointMarkers.filter(m => m !== marker);
                                        updateSimpleWaypointIcons(); // Update indices/icons
                                    }
                                    updateRoutingUI(); // Update button text
                                 }
                             });
                       }
                   }, 0);

                   // Add dragend listener for manual markers
                  marker.on('dragend', function(event) {
                       const newLatLng = event.target.getLatLng();
                       const markerIndexInLatLngArray = this.waypointArrayIndex;
                       if (markerIndexInLatLngArray !== undefined && currentRouteWaypointsLatLng[markerIndexInLatLngArray]) {
                          currentRouteWaypointsLatLng[markerIndexInLatLngArray] = newLatLng;
                           // Re-draw preview if user location is known
                          if (initialUserLocationMarkerLat && initialUserLocationMarkerLng) drawRoutePreview();
                       }
                   });
             });
             updateSimpleWaypointIcons(); // Ensure icons are numbered correctly after manual redraw
        });
    }

    // Start navigation mode and initialize LRM navigation control
    function startNavigation() {
        // Clean up any existing LRM controls (preview or navigation)
        if (navigationRoutingControl && allLocationsMapInstance.hasControl(navigationRoutingControl)) {
            allLocationsMapInstance.removeControl(navigationRoutingControl);
            navigationRoutingControl = null;
        }
        if (routePreviewControl && allLocationsMapInstance.hasControl(routePreviewControl)) {
            allLocationsMapInstance.removeControl(routePreviewControl);
            routePreviewControl = null;
        }
        clearSimpleWaypointMarkers(); // Clear the creation markers (F, 1, 2...)
         if (startRouteMarkerVisual && allLocationsMapInstance.hasLayer(startRouteMarkerVisual)) {
             startRouteMarkerVisual.remove();
             startRouteMarkerVisual = null;
        }


        let waypointsToNavigate = [];
        // Add current user location as the start waypoint
        if (initialUserLocationMarkerLat && initialUserLocationMarkerLng) {
             waypointsToNavigate.push(L.Routing.waypoint(L.latLng(initialUserLocationMarkerLat, initialUserLocationMarkerLng)));
        } else {
             // Cannot start navigation without knowing the start position
            showToast("No se puede iniciar navegación: posición de inicio desconocida.", "error");
            currentRoutingMode = 'creating'; // Revert mode back to creation
            updateRoutingUI(); // Update UI state
            return; // Stop the function
        }
        // Add user-defined waypoints
        currentRouteWaypointsLatLng.forEach(wp => waypointsToNavigate.push(L.Routing.waypoint(wp)));

        // Check if there are at least two points (start and at least one destination/waypoint)
        if (waypointsToNavigate.length < 2) {
             showToast("Se necesitan al menos un inicio y un destino para navegar.", "error");
             currentRoutingMode = 'creating'; // Revert mode
             updateRoutingUI();
             return;
        }

        // Initialize LRM control for navigation
        navigationRoutingControl = L.Routing.control({
            waypoints: waypointsToNavigate,
            routeWhileDragging: false, // Do not recalculate route while dragging markers (markers are not draggable in nav mode anyway)
            show: false, // Hide the default LRM panel
            addWaypoints: false, // Prevent adding waypoints
            draggableWaypoints: false, // Prevent dragging waypoints
            lineOptions: {
                styles: [{ color: 'blue', opacity: 0.8, weight: 6 }] // Style for the route line
            },
             // Custom function to create markers for LRM in navigation mode
            createMarker: function(i, waypoint, n) {
                 // LRM's default markers are automatically created/managed in navigation mode
                let icon;
                if (i === 0) { // Start waypoint (current user location)
                    icon = createNumberedIcon('S', 'green', 28, true);
                } else if (i === n -1) { // End waypoint (final destination)
                    icon = createNumberedIcon('F', 'red', 28, true);
                } else { // Intermediate waypoint
                     icon = createNumberedIcon(i, '#F59E0B', 28, false); // 1-based indexing
                }
                 // Use the default LRM marker creation but with custom icons
                return L.marker(waypoint.latLng, { icon: icon, draggable: false }); // Markers are not draggable in nav mode
            },
            router: L.Routing.osrmv1({
                serviceUrl: 'https://router.project-osrm.org/route/v1',
                profile: 'driving' // Use driving profile
            }),
            language: 'es', // Request instructions in Spanish
            summaryTemplate: function(o) {
                // Hide default summary by returning an empty string
                return '';
            },
             // Custom formatter to get maneuver type and distance for our panel
             formatInstruction: function(instruction) {
                 // Use default formatting to get the text, but also pass type and distance
                 const formatter = L.Routing.Formatter.defaultFormatter({language: 'es'});
                 const formatted = formatter.format(instruction); // Get the formatted text
                 return {
                     text: formatted.text, // The instruction text (e.g., "Gira a la izquierda")
                     type: instruction.type, // The raw OSRM maneuver type (e.g., "turn")
                     distance: instruction.distance // The distance until this maneuver
                 };
             }


        }).addTo(allLocationsMapInstance); // Add the control to the map


        const lrmContainer = navigationRoutingControl.getContainer();
        if (lrmContainer) lrmContainer.style.display = 'none'; // Hide the LRM default container


        // Event listener for when LRM finds a route (navigation)
        navigationRoutingControl.on('routesfound', function(e) {
            const routes = e.routes;
            if (routes.length > 0) {
                const summary = routes[0].summary;
                totalRouteDistance = summary.totalDistance; // Store total distance
                const totalTime = summary.totalTime; // Store total time

                // Calculate distance, time, and ETA for display
                const distanceKm = (totalRouteDistance / 1000).toFixed(1);
                const timeHours = Math.floor(totalTime / 3600);
                const timeMinutes = Math.round((totalTime % 3600) / 60);
                const eta = new Date(Date.now() + totalTime * 1000);

                // Populate routing info panel (now integrated into progress bar container for layout)
                 const progressBarElem = document.getElementById('progress-bar-container');
                 if (progressBarElem && routingInfoPanel) {
                      // Insert the info panel before the progress bar fill div
                      if(routingInfoPanel.parentNode !== progressBarElem) { // Prevent appending multiple times
                          progressBarElem.insertBefore(routingInfoPanel, progressBarFill); // Insert info above the bar
                      }

                      routingInfoPanel.innerHTML = `
                          <p><strong>Dist:</strong> ${distanceKm} km</p>
                          <p><strong>Tiempo:</strong> ${timeHours > 0 ? timeHours + 'h ' : ''}${timeMinutes}min</p>
                          <p><strong>Llegada:</strong> ${eta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</p>
                      `;
                     routingInfoPanel.style.display = 'flex';
                     routingInfoPanel.style.justifyContent = 'space-around';
                     routingInfoPanel.style.fontSize = '0.9em';
                     routingInfoPanel.style.padding = '5px';
                 }


                routeLineForProgress = routes[0].coordinates; // Store route geometry for progress tracking
                updateProgressBar(0, totalRouteDistance, totalTime); // Initialize progress bar at 0

                // Add waypoint markers on the progress bar
                if (progressBarElem) {
                     progressBarElem.querySelectorAll('.waypoint-marker-on-progress').forEach(m => m.remove()); // Clear old markers

                     // Iterate through instructions to find waypoint points
                     let accumulatedDistanceForBar = 0; // Distance *before* the current instruction
                     for (let k = 0; k < routes[0].instructions.length; k++) {
                        const instruction = routes[0].instructions[k];

                         // If this instruction corresponds to an intermediate waypoint (index > 0 and not the last input waypoint)
                        if (instruction.waypointIndex !== undefined && instruction.waypointIndex > 0 && instruction.waypointIndex < routes[0].inputWaypoints.length -1) {
                            if (totalRouteDistance > 0) {
                                // Calculate the percentage of the total route distance covered *up to the start of this instruction*
                                // The OSRM instruction distance is the distance *until* that instruction/maneuver.
                                // So, summing the distances of all instructions *before* the current one gives the distance travelled along the route to the start of the current maneuver.
                                let distToWaypointInstructionStart = 0;
                                 for (let prevIdx = 0; prevIdx < k; prevIdx++) {
                                      distToWaypointInstructionStart += routes[0].instructions[prevIdx].distance;
                                 }
                                const percent = (distToWaypointInstructionStart / totalRouteDistance) * 100;

                                // Create and position the marker dot on the progress bar
                                const markerDot = document.createElement('div');
                                markerDot.className = 'waypoint-marker-on-progress'; // CSS handles appearance
                                markerDot.style.left = `${percent}%`;
                                progressBarElem.appendChild(markerDot);
                            }
                        }
                         // accumulatedDistanceForBar += instruction.distance; // This is the distance *of* the segment AFTER this maneuver. Not used for bar position here.
                    }
                }


                // Display the first maneuver instruction
                if (routes[0].instructions.length > 0) {
                    updateCurrentManeuver(routes[0].instructions[0], routes[0].instructions[1]); // Show first maneuver
                } else {
                     // If no instructions (very short route?), hide maneuver panel
                    currentManeuverPanel.style.display = 'none';
                }
                 filterMarkersNearRoute(); // Filter reminders based on the calculated route
                  shouldCenterOnUserInAllLocationsMap = true; // Activate auto-centering during navigation
                  locateMeButtonMap.textContent = 'DEJAR DE SEGUIR'; // Change button text
                  locateMeButtonMap.title = "Dejar de centrar el mapa automáticamente en mi posición";

            } else {
                 showToast("No se pudo encontrar una ruta.", "warning");
                 currentRoutingMode = 'creating'; // Revert mode back to creation
                 updateRoutingUI(); // Update UI state
            }
        });

        // Event listener for routing errors during navigation
        navigationRoutingControl.on('routingerror', function(e) {
            showToast("Error calculando la ruta: " + (e.error?.message || "Servicio de rutas no disponible o puntos inválidos"), "error");
            currentRoutingMode = 'creating'; // Revert mode on error
            updateRoutingUI();
        });


        // Start/update watchPosition for user tracking and navigation updates
        let currentInstructionIndex = 0; // Track the index of the current maneuver instruction
        let lastUpdateTime = 0;
        const MIN_UPDATE_INTERVAL = 500; // Minimum interval between processing GPS updates (ms)


        // Ensure watchPosition is started or updated for navigation
        if (locationWatchId) {
            navigator.geolocation.clearWatch(locationWatchId); // Clear old watch if any
            locationWatchId = null; // Reset watch ID
        }

        // Start watching user position if browser supports it
        if ('geolocation' in navigator && 'watchPosition' in navigator.geolocation) {
             locationWatchId = navigator.geolocation.watchPosition(
                 (position) => {
                     const now = Date.now();
                     // Optional: Throttle updates to improve performance, especially when in navigation mode
                     // if (currentRoutingMode === 'navigating' && now - lastUpdateTime < MIN_UPDATE_INTERVAL) {
                     //     // Update basic position/marker if needed but skip heavy routing calculation
                     //      if(userMarkerForRoute) userMarkerForRoute.setLatLng([position.coords.latitude, position.coords.longitude]);
                     //      if (orientationAltitudeControl) orientationAltitudeControl.updateOrientation(position.coords.heading);
                     //      return;
                     // }
                     // lastUpdateTime = now; // Update timestamp if update is processed


                     const coordsForUpdate = {
                         latitude: position.coords.latitude,
                         longitude: position.coords.longitude,
                         accuracy: position.coords.accuracy,
                         heading: position.coords.heading,
                         altitude: position.coords.altitude
                     };
                     updateInitialUserPosition(coordsForUpdate, false); // Update main user marker/circle and orientation/altitude


                      // Handle updates specific to the current routing mode
                      if (currentRoutingMode === 'navigating' && navigationRoutingControl && navigationRoutingControl._selectedRoute) {
                         const userCurrentLatLng = L.latLng(coordsForUpdate.latitude, coordsForUpdate.longitude);

                         // Update user marker for route following (car icon)
                         if(userMarkerForRoute) {
                             userMarkerForRoute.setLatLng(userCurrentLatLng);
                         } else {
                             // Create the car icon marker if it doesn't exist
                             userMarkerForRoute = L.marker(userCurrentLatLng, {icon: carIcon, zIndexOffset: 1000}).addTo(allLocationsMapInstance);
                         }
                          // Rotate the car icon marker based on heading if available
                          if (userMarkerForRoute.getElement()) {
                              userMarkerForRoute.getElement().style.transformOrigin = 'center center';
                              // Add rotation if heading is available and reasonable
                              if (coordsForUpdate.heading !== null && !isNaN(coordsForUpdate.heading) && coordsForUpdate.heading >= 0 && coordsForUpdate.heading <= 360) {
                                   userMarkerForRoute.getElement().style.transform = `rotate(${coordsForUpdate.heading}deg)`;
                               } else {
                                   userMarkerForRoute.getElement().style.transform = ''; // No rotation if heading is bad or missing
                               }
                           }

                          // Auto-center if enabled
                          if(shouldCenterOnUserInAllLocationsMap && allLocationsMapInstance) {
                             allLocationsMapInstance.setView(userCurrentLatLng, Math.max(allLocationsMapInstance.getZoom(), 16), { pan: { animate: true, duration: 0.5 } }); // Smooth pan
                          }


                         // --- Navigation progress and maneuver update logic ---
                         const route = navigationRoutingControl._selectedRoute;

                         if (route && route.coordinates && route.instructions && route.instructions.length > 0) {
                              // Find the closest point on the route to the user's current location
                             // Calculate the distance along the route to that closest point
                             let currentDistanceAlongRoute = 0; // Total distance from route start to the closest point on route
                             let closestInstructionIndex = -1; // Index of the instruction segment closest to the user
                             let minDistanceToRoute = Infinity; // Minimum distance from user to any point on the route
                             let cumulativeDistUpToInstructionStart = 0; // Distance along route *before* the current instruction segment

                              // Iterate through each instruction segment to find the closest point
                             for (let i = 0; i < route.instructions.length; i++) {
                                 const instruction = route.instructions[i];
                                  // Get the segment of the route line corresponding to this instruction
                                 // Slice from the start index of the instruction to the start index of the *next* instruction (or end of route if last)
                                 const instructionLine = route.coordinates.slice(instruction.index, (route.instructions[i+1] ? route.instructions[i+1].index : route.coordinates.length)); // Slice includes end index
                                  // Skip if the segment is empty (e.g., invalid instruction or route end point)
                                  if (instructionLine.length < 2 && instructionLine.length > 0) {
                                     // This instruction is just a point, likely the start or end of the route or a very sharp turn
                                     // Add the distance of the *previous* instruction to the cumulative distance if applicable
                                     if (i > 0) cumulativeDistUpToInstructionStart += route.instructions[i-1].distance;
                                     continue;
                                  } else if (instructionLine.length === 0 && i > 0) {
                                       cumulativeDistUpToInstructionStart += route.instructions[i-1].distance;
                                       continue;
                                  } else if (instructionLine.length === 0 && i === 0) {
                                       cumulativeDistUpToInstructionStart = 0; // Start of route, no previous distance
                                       continue;
                                  }


                                 try {
                                      // Find the point on the instruction's polyline closest to the user's current location
                                     const closestPointOnLine = L.GeometryUtil.closest(allLocationsMapInstance, instructionLine, userCurrentLatLng);
                                      // Calculate the straight-line distance from the user to this closest point on the line segment
                                     const distToThisLine = userCurrentLatLng.distanceTo(closestPointOnLine);

                                      // If this segment is closer than any previous one
                                     if (distToThisLine < minDistanceToRoute) {
                                         minDistanceToRoute = distToThisLine; // Update minimum distance
                                         closestInstructionIndex = i; // Store the index of this closest instruction segment

                                          // Calculate the distance along *this instruction's segment* from its start to the closest point
                                          let distanceAlongClosestInstruction = 0;
                                           // Iterate through the coordinates of the closest instruction segment
                                           for(let k=0; k < instructionLine.length -1; k++){
                                               // If the closest point lies on the segment between point k and k+1
                                               if(L.GeometryUtil.belongsSegment(closestPointOnLine, instructionLine[k], instructionLine[k+1])){
                                                    // Add the distance from point k to the closest point
                                                   distanceAlongClosestInstruction += L.latLng(instructionLine[k]).distanceTo(closestPointOnLine);
                                                   break; // Found the segment, stop accumulating distance on this line
                                               }
                                                // Otherwise, add the distance of the segment k to k+1
                                               distanceAlongClosestInstruction += L.latLng(instructionLine[k]).distanceTo(instructionLine[k+1]);
                                           }
                                          // The total distance along the route to the user's position is the distance accumulated before this instruction + distance along this instruction's segment
                                         currentDistanceAlongRoute = cumulativeDistUpToInstructionStart + distanceAlongClosestInstruction;
                                     }
                                 } catch(geoError) {
                                     console.warn("GeometryUtil error in navigation:", geoError);
                                 }

                                  // Add the distance *of* the current instruction segment to the cumulative distance for the *next* iteration
                                  // OSRM instruction.distance is the distance *of* the segment *after* the maneuver point, leading to the next maneuver point.
                                  // So, cumulativeDistUpToInstructionStart tracks distance to the start of the instruction being processed.
                                  // Update cumulative distance for the *next* iteration
                                  cumulativeDistUpToInstructionStart += instruction.distance; // Add the distance of the segment leading to the start of the *next* instruction's maneuver
                             }


                             // --- Logic to determine if we have advanced to the next maneuver ---
                             // A simple approach is to check if the user is past the point where the current instruction's maneuver is located,
                             // or if they are now closer to the next instruction's segment.
                             // Using the `closestInstructionIndex` found above is a robust way to determine which segment the user is currently near.
                             // If the closest segment's instruction index has changed and is greater than the currentInstructionIndex, we have advanced.
                             let hasAdvanced = false;
                             if (closestInstructionIndex !== -1 && closestInstructionIndex > currentInstructionIndex) {
                                  currentInstructionIndex = closestInstructionIndex; // Update the current instruction index
                                  hasAdvanced = true; // Flag that we have advanced
                                   // Check if we reached the final instruction
                                  if (currentInstructionIndex === route.instructions.length - 1) {
                                       // Reached the final maneuver point - now check distance to actual final destination
                                        const finalPoint = route.coordinates[route.coordinates.length - 1]; // Last coordinate of the route
                                       if (userCurrentLatLng.distanceTo(finalPoint) < 50) { // Within 50m of destination
                                          // Reached destination - stop navigation
                                          showToast("Has llegado a tu destino.", "success", 5000);
                                          createRouteButton.click(); // Simulate click on "DETENER NAVEGACIÓN" button to stop navigation
                                          return; // Stop processing this update
                                       }
                                  }
                             } else if (currentInstructionIndex === route.instructions.length - 1) {
                                   // If we are already on the last instruction, keep checking proximity to the final destination
                                   const finalPoint = route.coordinates[route.coordinates.length - 1];
                                   if (userCurrentLatLng.distanceTo(finalPoint) < 50) {
                                      showToast("Has llegado a tu destino.", "success", 5000);
                                      createRouteButton.click();
                                      return;
                                   }
                             }


                             // --- Update UI based on current instruction ---
                            if (currentInstructionIndex !== -1) { // Ensure we have a valid current instruction
                                 // Get the current and next instruction objects
                                 const currentInstruction = route.instructions[currentInstructionIndex];
                                 const nextInstruction = route.instructions[currentInstructionIndex + 1];

                                 // Only update the maneuver panel text/icon if we have just advanced to a new instruction
                                 if (hasAdvanced) {
                                    updateCurrentManeuver(currentInstruction, nextInstruction);
                                 }

                                 // Update the distance bar for the current maneuver
                                  const instructionTotalDistance = currentInstruction.distance; // Distance of the segment leading to this maneuver
                                   // Calculate the distance covered *within* the current instruction's segment.
                                   // This requires knowing the cumulative distance *up to the start* of the current instruction.
                                    let cumulativeDistBeforeCurrentInstruction = 0;
                                     for(let i = 0; i < currentInstructionIndex; i++){
                                         cumulativeDistBeforeCurrentInstruction += route.instructions[i].distance;
                                     }
                                  const distanceCoveredInCurrentInstructionSegment = Math.max(0, currentDistanceAlongRoute - cumulativeDistBeforeCurrentInstruction);
                                  const distanceRemainingInInstructionSegment = instructionTotalDistance - distanceCoveredInCurrentInstructionSegment;

                                  // Calculate the percentage of the instruction segment remaining
                                  const percentageRemainingInInstruction = instructionTotalDistance > 0 ? (distanceRemainingInInstructionSegment / instructionTotalDistance) * 100 : 0;
                                  const distanceBarFill = currentManeuverPanel.querySelector('.maneuver-distance .distance-bar-fill');
                                  if (distanceBarFill) {
                                       distanceBarFill.style.width = `${percentageRemainingInInstruction}%`; // Bar fills as distance decreases
                                  }

                                 // Update the distance text for the current maneuver
                                  const maneuverDistanceSpan = currentManeuverPanel.querySelector('.maneuver-distance');
                                   if (maneuverDistanceSpan){
                                        // The first child node is the text node "en X m/km"
                                        const distanceTextNode = maneuverDistanceSpan.childNodes[0];
                                         if (distanceTextNode && distanceTextNode.nodeType === Node.TEXT_NODE) {
                                             distanceTextNode.nodeValue = `en ${formatDistance(distanceRemainingInInstructionSegment)}`;
                                         }
                                   }
                             }


                             // Update overall progress bar (distance covered vs total distance)
                              updateProgressBar(currentDistanceAlongRoute, totalRouteDistance, route.summary.totalTime);

                            // Filter markers based on *new* user position
                            filterMarkersNearRoute();
                         }
                      } else if (currentRoutingMode === 'creating' && startRouteMarkerVisual) {
                          // Update the static visual start marker position during route creation
                          startRouteMarkerVisual.setLatLng([coordsForUpdate.latitude, coordsForUpdate.longitude]);
                          // If waypoints exist, redraw the route preview from the new start location
                          if (currentRouteWaypointsLatLng.length > 0) drawRoutePreview();
                      }

                 },
                 // Error callback for watchPosition
                 (error) => {
                     // Handle GPS errors during watch
                     console.warn("GPS error en navegación: " + error.message);
                      showToast(`Error seguimiento GPS: ${error.message}`, "warning");
                     // Decide how to handle persistent errors: stop navigation?
                     // Optional: if error.code === 1 (PERMISSION_DENIED) or other critical errors, stop navigation
                     // if (error.code === 1) { createRouteButton.click(); showToast("Permisos de localización denegados. Navegación detenida.", "error"); }

                      // Clear orientation/altitude display on error
                      if (orientationAltitudeControl) {
                         orientationAltitudeControl.updateOrientation(null);
                         orientationAltitudeControl.updateAltitude(null);
                     }
                 },
                 // watchPosition options
                 { enableHighAccuracy: true, timeout: 15000, maximumAge: 5000, distanceFilter: 5 } // Use distanceFilter to reduce updates while stationary
             );
         } else {
              // Browser does not support geolocation
              showToast("Tu navegador no soporta seguimiento GPS.", "error");
              if (currentRoutingMode === 'navigating') {
                   createRouteButton.click(); // Stop navigation if not supported
              }
         }
    }

    // Update the current maneuver panel display
    function updateCurrentManeuver(currentInstruction, nextInstruction) {
        const maneuverIconDiv = currentManeuverPanel.querySelector('.maneuver-icon');
        const maneuverInstructionDiv = currentManeuverPanel.querySelector('.maneuver-instruction');
        const maneuverDistanceDiv = currentManeuverPanel.querySelector('.maneuver-distance');
        const nextManeuverDiv = currentManeuverPanel.querySelector('.next-maneuver');
        const distanceBarFill = currentManeuverPanel.querySelector('.distance-bar-fill');

        // If no current instruction, hide the panel and clear content
        if (!currentInstruction) {
            currentManeuverPanel.style.display = 'none';
            if (maneuverInstructionDiv) maneuverInstructionDiv.textContent = '';
            if (nextManeuverDiv) nextManeuverDiv.textContent = '';
            if (maneuverIconDiv) maneuverIconDiv.className = 'maneuver-icon'; // Reset class
             if (distanceBarFill) distanceBarFill.style.width = '0%';
            return;
        }

        // Set the maneuver icon class based on the instruction type
        if(maneuverIconDiv) maneuverIconDiv.className = `maneuver-icon ${getManeuverIconClass(currentInstruction.type)}`;
        // Set the translated instruction text
        if(maneuverInstructionDiv) maneuverInstructionDiv.textContent = getManeuverTranslation(currentInstruction.text);

        // Set the distance text and reset the distance bar fill
        if(maneuverDistanceDiv){
             // The distance text node is the first child
             const distanceText = maneuverDistanceDiv.childNodes[0];
             if (distanceText && distanceText.nodeType === Node.TEXT_NODE) {
                 distanceText.nodeValue = `en ${formatDistance(currentInstruction.distance)}`;
             } else {
                 // If the text node doesn't exist (e.g., first time), create and insert it
                 maneuverDistanceDiv.insertBefore(document.createTextNode(`en ${formatDistance(currentInstruction.distance)}`), maneuverDistanceDiv.firstChild);
             }
             // Reset the distance bar to 100% filled (indicating distance is still full at the start of the maneuver segment)
             if (distanceBarFill) distanceBarFill.style.width = '100%';
        }

        // Display the next maneuver instruction if it exists
        if (nextInstruction && nextManeuverDiv) {
            nextManeuverDiv.textContent = `Luego: ${getManeuverTranslation(nextInstruction.text)}`;
            nextManeuverDiv.style.display = 'block'; // Show next maneuver text
        } else if (nextManeuverDiv) {
            nextManeuverDiv.style.display = 'none'; // Hide if no next maneuver
        }

        // Make the maneuver panel visible
        currentManeuverPanel.style.display = 'flex';
    }

    // Update the overall progress bar and remaining distance/time text
    function updateProgressBar(distanceCovered, totalDistance, totalTimeSeconds) {
        // Handle case where total distance is 0 (e.g., route error)
        if (totalDistance === 0) {
            progressBarFill.style.width = '0%';
            if (progressBarTextOverlay) progressBarTextOverlay.textContent = '';
            return;
        }
        // Calculate percentage of route covered (capped at 100%)
        const percentage = Math.min(100, (distanceCovered / totalDistance) * 100);
        progressBarFill.style.width = `${percentage}%`; // Update the fill width

        // Calculate remaining distance and time
        const remainingDistance = Math.max(0, totalDistance - distanceCovered); // Ensure non-negative
        if (progressBarTextOverlay) {
            let remainingTimeMinutes = 0;
             // Estimate remaining time based on percentage covered and total time
             // Avoid division by zero and handle case where distanceCovered exceeds totalDistance (near end)
            if (totalTimeSeconds && totalDistance > 0 && distanceCovered < totalDistance) {
                 const remainingTimeSeconds = totalTimeSeconds * (1 - (distanceCovered / totalDistance));
                 remainingTimeMinutes = Math.round(remainingTimeSeconds / 60);
            } else if (distanceCovered >= totalDistance) {
                 // If distance covered is >= total distance, remaining time is 0
                remainingTimeMinutes = 0;
            }

            // Update the text overlay
            progressBarTextOverlay.textContent = `${formatDistance(remainingDistance)} (${remainingTimeMinutes} min)`;
        }
    }

    // Format distance in meters or kilometers
    function formatDistance(meters) {
        if (meters < 1000) {
            return `${Math.round(meters)} m`; // Show in meters if less than 1km
        } else {
            return `${(meters / 1000).toFixed(1)} km`; // Show in kilometers with 1 decimal place
        }
    }


    // Handler for closing the reminders location map modal
    const closeHandlerAllMap = () => {
        console.log("Intentando cerrar mapa de todas las ubicaciones...");
        try {
            isRemindersLocationMapActive = false; // Update state flag
            currentRoutingMode = 'none'; // Reset routing mode

            // Clear geolocation watch
            if (locationWatchId !== null) {
                navigator.geolocation.clearWatch(locationWatchId);
                locationWatchId = null;
                console.log("Location watch detenido.");
            }

            // Remove LRM controls from the map
            if (navigationRoutingControl && allLocationsMapInstance && allLocationsMapInstance.hasControl(navigationRoutingControl)) {
                 try { allLocationsMapInstance.removeControl(navigationRoutingControl); console.log("Control de navegación LRM eliminado."); } catch(e){ console.warn("Error eliminando control de navegación LRM:", e); }
            }
            navigationRoutingControl = null; // Clear reference

            if (routePreviewControl && allLocationsMapInstance && allLocationsMapInstance.hasControl(routePreviewControl)) {
                 try { allLocationsMapInstance.removeControl(routePreviewControl); console.log("Control de previsualización LRM eliminado."); } catch(e){ console.warn("Error eliminando control de previsualización LRM:", e); }
            }
            routePreviewControl = null; // Clear reference

            routeLineForProgress = null; // Clear route line data
            totalRouteDistance = 0; // Reset total distance

            // Remove user position marker used during navigation (if exists)
            if (userMarkerForRoute && allLocationsMapInstance && allLocationsMapInstance.hasLayer(userMarkerForRoute)) {
                try { userMarkerForRoute.remove(); console.log("Marcador de usuario en ruta eliminado."); } catch(e){}
            }
            userMarkerForRoute = null; // Clear reference
            clearSimpleWaypointMarkers(); // Remove simple waypoint markers (F, 1, 2...)
            // Remove the manual start marker visual if it exists
            if (startRouteMarkerVisual && allLocationsMapInstance && allLocationsMapInstance.hasLayer(startRouteMarkerVisual)) {
                try { startRouteMarkerVisual.remove(); console.log("Marcador visual de inicio de ruta eliminado."); } catch(e){}
            }
            startRouteMarkerVisual = null; // Clear reference

            // Remove all reminder markers and circles from the map
            allMapMarkers.forEach(item => {
                if (item.marker && allLocationsMapInstance && allLocationsMapInstance.hasLayer(item.marker)) try { item.marker.remove(); } catch(e){}
                if (item.circle && allLocationsMapInstance && allLocationsMapInstance.hasLayer(item.circle)) try { item.circle.remove(); } catch(e){}
            });
            allMapMarkers = []; // Clear the array
             console.log("Todos los marcadores de recordatorios del mapa limpiados.");


            // Remove orientation/altitude control
            if (orientationAltitudeControl && allLocationsMapInstance && typeof allLocationsMapInstance.hasControl === 'function' && allLocationsMapInstance.hasControl(orientationAltitudeControl)) {
                try {
                    allLocationsMapInstance.removeControl(orientationAltitudeControl);
                     // If the maneuver panel was moved inside the compass control, move it back before closing
                    const maneuverPanel = document.getElementById('current-maneuver-panel');
                    const mapDiv = document.getElementById('reminders-location-map-div');
                    if(maneuverPanel && mapDiv && maneuverPanel.parentNode !== mapDiv){
                         mapDiv.appendChild(maneuverPanel);
                    }
                    console.log("Control de orientación/altitud eliminado.");
                } catch(e) { console.warn("Error eliminando control de orientación/altitud:", e); }
            }
            orientationAltitudeControl = null; // Clear reference

            // Remove the initial user location marker and circle
            if (initialUserLocationMarker && allLocationsMapInstance && allLocationsMapInstance.hasLayer(initialUserLocationMarker)) {
                try { initialUserLocationMarker.remove(); } catch(e){}
            }
            initialUserLocationMarker = null; // Clear reference
            initialUserLocationMarkerLat = null; // Clear stored coords
            initialUserLocationMarkerLng = null;
            if (initialUserLocationCircle && allLocationsMapInstance && allLocationsMapInstance.hasLayer(initialUserLocationCircle)) {
                try { initialUserLocationCircle.remove(); } catch(e){}
            }
            initialUserLocationCircle = null; // Clear reference

            // Remove the Leaflet map instance itself
            if (allLocationsMapInstance) {
                 try { allLocationsMapInstance.remove(); console.log("Instancia del mapa eliminada."); } catch (e) { console.warn("Error eliminando instancia del mapa:", e); }
                allLocationsMapInstance = null; // Clear reference
            }

            // Remove the map modal element from the DOM
            const mapModalElement = document.getElementById('reminders-location-map-modal');
            if (mapModalElement) {
                mapModalElement.remove();
                 console.log("Modal del mapa eliminado del DOM.");
            }

            // Close any open helper modals related to the map
            const helpModalInstance = document.getElementById('reminders-map-help-modal-instance');
            if (helpModalInstance) {
                 const helpCloseButton = helpModalInstance.querySelector('#close-reminders-map-help-instance');
                 if(helpCloseButton) clearModalAutoCloseTimer(helpModalInstance, helpCloseButton, 'reminders-map-help-modal-instance');
                 helpModalInstance.remove();
            }
            const savedRoutesModal = document.getElementById('saved-routes-modal');
            if(savedRoutesModal) savedRoutesModal.remove(); // Close saved routes modal if open

             // Clear session storage flags related to map state
            sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
            sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
            sessionStorage.removeItem('boardinggate_map_was_open_before_table');
            sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');

            // Ensure the unified reminder window is hidden if it was deferred from showing
            hideUnifiedReminderWindow();
            console.log("Cierre del mapa completado.");
        } catch (error) {
            console.error("Error durante closeHandlerAllMap:", error);
             // Attempt to forcefully remove the modal element as a fallback
            const mapModalElement = document.getElementById('reminders-location-map-modal');
            if (mapModalElement) {
                mapModalElement.remove();
            }
            isRemindersLocationMapActive = false; // Ensure flag is false even on error
        }
    };
    // Add event listener to the close button
    closeButton.addEventListener('click', closeHandlerAllMap);


    // Handler for the "ESTÁS AQUÍ" / "DEJAR DE SEGUIR" button
    locateMeButtonMap.addEventListener('click', function handleLocateMeClick() {
        if (!allLocationsMapInstance) return; // Do nothing if map is not initialized

        if (locateMeButtonMap.textContent === "ESTÁS AQUÍ") {
             // Start following mode
            shouldCenterOnUserInAllLocationsMap = true; // Enable auto-centering
            locateMeButtonMap.textContent = 'DEJAR DE SEGUIR'; // Change button text
            locateMeButtonMap.title = "Dejar de centrar el mapa automáticamente en mi posición"; // Update button title

             // If we already have a known user location, immediately center on it
            if (initialUserLocationMarkerLat && initialUserLocationMarkerLng) {
                const latLng = L.latLng(initialUserLocationMarkerLat, initialUserLocationMarkerLng);
                allLocationsMapInstance.setView(latLng, Math.max(allLocationsMapInstance.getZoom(), 16), {pan: {animate: true, duration: 0.5}}); // Center and potentially zoom in smoothly
            } else {
                 // If user location is not yet known, try to get it and then center
                 getCurrentLocation(
                    (coords) => {
                        const latLng = L.latLng(coords.latitude, coords.longitude);
                        if (allLocationsMapInstance) allLocationsMapInstance.setView(latLng, 16, {pan: {animate: true, duration: 0.5}});
                        updateInitialUserPosition(coords, false); // Update marker/circle
                    },
                    () => showToast("No se pudo obtener tu ubicación para centrar.", "warning")
                );
            }
        } else if (locateMeButtonMap.textContent === "DEJAR DE SEGUIR") {
             // Stop following mode
            shouldCenterOnUserInAllLocationsMap = false; // Disable auto-centering
            locateMeButtonMap.textContent = 'ESTÁS AQUÍ'; // Change button text back
            locateMeButtonMap.title = "Mostrar mi posición actual y activar seguimiento"; // Update button title
        }
    });


    // Handler for the "AQUÍ HAY UN RADAR" button
    addRadarButton.addEventListener('click', () => {
        addRadarButton.disabled = true; addRadarButton.textContent = 'Marcando...'; // Disable button and show status
        getCurrentLocation(
            (coords) => {
                const now = new Date();
                // Create a new reminder object with location data and 'RADAR' text
                const newRadarReminder = {
                    id: Date.now(), // Unique ID based on timestamp
                    text: '<b>RADAR: EN ESTA UBICACION (Añadido manualmente)</b>', // Default text
                    type: 'simple', // Simple type
                    time: `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`, // Current time
                    date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`, // Current date
                    createdAt: now.toISOString(), // Creation timestamp
                    managedByUser: false, // Not managed yet
                    isLocationEnabled: true, // Location enabled
                    locationCoordinates: { latitude: coords.latitude, longitude: coords.longitude }, // Current location
                    radiusMeters: 1000, // Default radius
                    excludeFromList: true // Mark as excluded from general list
                };

                // Load existing reminders, add the new one, and save back to localStorage
                let currentRemindersList = JSON.parse(localStorage.getItem('reminders') || '[]');
                currentRemindersList.push(newRadarReminder);
                localStorage.setItem('reminders', JSON.stringify(currentRemindersList));

                showToast("Recordatorio RADAR creado en tu ubicación actual (radio 1000 metros).", "success");
                updateReminderCount(); // Update global counts
                updateButtonStyles(); // Update button styles
                checkReminders(); // Re-check reminders to potentially trigger the new radar notification

                // Add the new radar marker and circle to the map immediately
                if (allLocationsMapInstance) {
                    const radarLatLng = [newRadarReminder.locationCoordinates.latitude, newRadarReminder.locationCoordinates.longitude];
                    const radarMapMarker = L.marker(radarLatLng, { icon: radarMarkerIcon })
                        .addTo(allLocationsMapInstance);
                    const radarCircle = L.circle(radarLatLng, {
                        radius: newRadarReminder.radiusMeters,
                        color: '#800080',
                        fillColor: '#DA70D6',
                        fillOpacity: 0.1
                    }).addTo(allLocationsMapInstance);

                     // Add to our list of map markers
                     allMapMarkers.push({marker: radarMapMarker, circle: radarCircle, reminderData: newRadarReminder});

                    // Bind a popup to the new marker
                    let popupContentRadar = `
                        <div style="max-width: 250px; font-family: sans-serif; font-size: 0.9rem;">
                            <strong style="font-size: 1rem; color: #333; display: block; margin-bottom: 5px;">${newRadarReminder.text.replace(/<b>|<\/b>/gi,'')}</strong>
                            <hr style="margin: 4px 0;">
                            <p style="margin: 3px 0;"><strong>Radio:</strong> ${newRadarReminder.radiusMeters}m</p>
                            <p style="margin: 3 px 0;"><strong>Creado:</strong> Ahora</p>
                            <button data-reminder-id="${newRadarReminder.id}" class="modify-reminder-from-map" style="margin-top: 8px; padding: 4px 8px; font-size: 0.8rem; background-color: #10B981; color: white; border: none; border-radius: 3px; cursor: pointer;">Modificar</button>
                        </div>`;
                    radarMapMarker.bindPopup(popupContentRadar);
                     // Add modify listener to the popup button
                    radarMapMarker.on('popupopen', () => {
                        const modifyButton = radarMapMarker.getPopup().getElement().querySelector('.modify-reminder-from-map');
                        if (modifyButton) {
                            const newModifyButton = modifyButton.cloneNode(true);
                            modifyButton.parentNode.replaceChild(newModifyButton, modifyButton);
                            newModifyButton.addEventListener('click', (e) => {
                                const id = parseInt(e.target.dataset.reminderId);
                                if (!isNaN(id)) {
                                    const rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                                    const remToMod = rems.find(r => r.id === id);
                                    if (remToMod) {
                                        closeHandlerAllMap(); // Close map
                                        showReminderModal(remToMod); // Open reminder modal
                                    } else { showToast("Error: No se encontró el recordatorio para modificar.", "error"); }
                                }
                            });
                        }
                    });
                     // Center map on the new radar location
                    allLocationsMapInstance.setView(radarLatLng, 15);
                }

                addRadarButton.disabled = false; addRadarButton.textContent = 'AQUÍ HAY UN RADAR'; // Reset button state
            },
            // Error callback for getting location
            (errorMsg) => {
                showToast(`Error al obtener ubicación para RADAR: ${errorMsg}`, "error");
                addRadarButton.disabled = false; addRadarButton.textContent = 'AQUÍ HAY UN RADAR'; // Reset button state
            }
        );
    });

    // Add event listener for the help button
    helpButton.addEventListener('click', showRemindersMapHelpModal); // Assuming showRemindersMapHelpModal exists


    // Initialize the Leaflet map
    try {
        allLocationsMapInstance = L.map(mapContainer, {
            zoomControl: true // Enable default zoom control
        });
        // Position the default zoom control
        allLocationsMapInstance.zoomControl.setPosition('topright');

        // Add the base tile layer (OpenStreetMap)
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        }).addTo(allLocationsMapInstance);

        // Set a default initial view (very zoomed out)
        allLocationsMapInstance.setView([20,0], 2);

        // Add the custom orientation and altitude control
        orientationAltitudeControl = L.control.orientationAltitude({ position: 'topleft' });
        if(allLocationsMapInstance && orientationAltitudeControl) {
            orientationAltitudeControl.addTo(allLocationsMapInstance);
             // Move the maneuver panel div inside the compass control container
            const maneuverPanel = document.getElementById('current-maneuver-panel');
            if (maneuverPanel) {
                 orientationAltitudeControl.getContainer().appendChild(maneuverPanel);
            }
        }

        // Add event listener for zoom changes to adjust user location circle radius
        allLocationsMapInstance.on('zoomend', () => {
            if (initialUserLocationCircle && initialUserLocationMarkerLat && initialUserLocationMarkerLng && allLocationsMapInstance) {
                const zoomLevel = allLocationsMapInstance.getZoom();
                const minZoom = allLocationsMapInstance.getMinZoom() || 0;
                const maxZoom = allLocationsMapInstance.getMaxZoom() || 18; // Assuming max zoom 18
                // Calculate radius based on zoom level (smaller radius when zoomed in)
                const zoomFraction = Math.max(0, Math.min(1, (zoomLevel - minZoom) / (maxZoom - minZoom))); // Normalize zoom to 0-1
                const minRadius = 3; // Minimum radius in meters
                const maxRadius = 150; // Maximum radius in meters
                // Linear interpolation: radius decreases as zoom level increases
                const newRadius = minRadius + (maxRadius - minRadius) * (1 - zoomFraction);
                initialUserLocationCircle.setRadius(Math.max(minRadius, Math.min(maxRadius, newRadius))); // Update circle radius
            }
        });

         // Function to plot initial content (reminders) and update UI state
        const showMapContent = () => {
            if (!allLocationsMapInstance) return;
            plotReminders(toggleRadarVisibilityCheckbox.checked); // Plot reminders (optionally filtered)
            updateRoutingUI(); // Update UI based on initial routing mode ('none')
            allLocationsMapInstance.invalidateSize(); // Invalidate map size after modal is shown
        };


        // Function to update the user's initial position marker, circle, orientation, and altitude
        const updateInitialUserPosition = (coords, isInitialViewSetup = false) => {
            if (!allLocationsMapInstance) return;

            // Convert coords to L.LatLng object
            const latLng = coords ? L.latLng(coords.latitude, coords.longitude) : null;
            // Store coordinates globally
            initialUserLocationMarkerLat = coords ? coords.latitude : null;
            initialUserLocationMarkerLng = coords ? coords.longitude : null;
            const currentHeading = coords ? coords.heading : null; // Get heading
            const currentAltitude = coords ? coords.altitude : null; // Get altitude

            // Update the user's position marker (car icon)
            // In navigation mode, userMarkerForRoute is used. In other modes, initialUserLocationMarker is used.
            if (userMarkerForRoute && currentRoutingMode === 'navigating' && latLng) {
                userMarkerForRoute.setLatLng(latLng); // Update position if navigating
                 // Rotate car icon if heading is available
                 if (userMarkerForRoute.getElement()) {
                     userMarkerForRoute.getElement().style.transformOrigin = 'center center';
                     if (currentHeading !== null && !isNaN(currentHeading) && currentHeading >= 0 && currentHeading <= 360) {
                          userMarkerForRoute.getElement().style.transform = `rotate(${currentHeading}deg)`;
                     } else {
                          userMarkerForRoute.getElement().style.transform = '';
                     }
                 }
            } else if (latLng) { // If location is available and not in navigation mode
                if (initialUserLocationMarker) {
                    initialUserLocationMarker.setLatLng(latLng); // Update position if marker exists
                } else {
                     // Create the initial user location marker if it doesn't exist
                    initialUserLocationMarker = L.marker(latLng, {
                        icon: carIcon, // Use the car icon
                        zIndexOffset: 1000, // Ensure it's on top
                    })
                    .addTo(allLocationsMapInstance)
                    .bindPopup("Tu posición actual"); // Bind a simple popup
                }
                 // Ensure the car icon element is available before trying to rotate
                 const markerElement = initialUserLocationMarker.getElement();
                 if (markerElement) {
                     markerElement.style.transformOrigin = 'center center';
                      // Rotate car icon based on heading if available
                     if (currentHeading !== null && !isNaN(currentHeading) && currentHeading >= 0 && currentHeading <= 360) {
                          markerElement.style.transform = `rotate(${currentHeading}deg)`;
                     } else {
                          markerElement.style.transform = ''; // No rotation if heading is bad or missing
                     }
                 }
            }

            // Update orientation and altitude display
            if (orientationAltitudeControl) {
                orientationAltitudeControl.updateOrientation(currentHeading);
                orientationAltitudeControl.updateAltitude(currentAltitude);
            }

            // Update the user location circle (only shown when not navigating)
            if (latLng) {
                 // Calculate dynamic radius based on zoom level
                const zoomLevel = allLocationsMapInstance.getZoom();
                const minZoom = allLocationsMapInstance.getMinZoom() || 0;
                const maxZoom = allLocationsMapInstance.getMaxZoom() || 18;
                const zoomFraction = Math.max(0, Math.min(1, (zoomLevel - minZoom) / (maxZoom - minZoom)));
                const minRadius = 3;
                const maxRadius = 150;
                const dynamicRadius = minRadius + (maxRadius - minRadius) * (1 - zoomFraction);

                const circleStyle = {
                    radius: Math.max(minRadius, Math.min(maxRadius, dynamicRadius)), // Apply dynamic radius
                    color: 'green',
                    weight: 3,
                    fillColor: 'yellow',
                    fillOpacity: 0.4
                };

                // Show the circle only when not in navigation mode
                if (currentRoutingMode !== 'navigating') {
                    if (initialUserLocationCircle) {
                         // Update circle position and style if it exists
                        initialUserLocationCircle.setLatLng(latLng).setRadius(circleStyle.radius).setStyle({
                            color: circleStyle.color,
                            weight: circleStyle.weight,
                            fillColor: circleStyle.fillColor,
                            fillOpacity: circleStyle.fillOpacity
                        });
                    } else {
                         // Create the user location circle if it doesn't exist
                         initialUserLocationCircle = L.circle(latLng, circleStyle).addTo(allLocationsMapInstance);
                    }
                } else if (initialUserLocationCircle && allLocationsMapInstance.hasLayer(initialUserLocationCircle)) {
                    // Remove the circle if entering navigation mode
                    initialUserLocationCircle.remove();
                    initialUserLocationCircle = null; // Clear reference
                }
            }


            // Initial view setup logic (center map and plot reminders)
            if (isInitialViewSetup) {
                 // Determine which reminders to plot initially based on radar visibility setting
                const currentRemindersToPlot = remindersWithLocation.filter(r =>
                    toggleRadarVisibilityCheckbox.checked ? true : (!r.text.toUpperCase().includes("RADAR:") && !r.excludeFromList)
                );
                 let bounds;
                 if (currentRemindersToPlot.length > 0) {
                    // Create bounds from reminder locations
                    bounds = L.latLngBounds(currentRemindersToPlot.map(r => [r.locationCoordinates.latitude, r.locationCoordinates.longitude]));
                 } else {
                    // Start with empty bounds if no reminders to plot
                    bounds = L.latLngBounds([]);
                 }

                 // Extend bounds to include user's current location if available
                if (latLng) bounds.extend(latLng);

                // Fit the map view to the calculated bounds
                if (bounds.isValid()) { // Check if bounds contain at least one point
                    allLocationsMapInstance.fitBounds(bounds.pad(0.15)); // Fit with some padding
                } else if (latLng) {
                     // If no reminders and only user location, center on user location
                    allLocationsMapInstance.setView(latLng, 16);
                } else {
                     // If no reminders and no user location, center on the initial default view
                     allLocationsMapInstance.setView([20,0], 2);
                }
                showMapContent(); // Plot reminders and set initial UI state


            } else if (shouldCenterOnUserInAllLocationsMap && latLng) {
                 // If not initial setup but tracking is enabled, center view on user location
                 // Use setView with pan animation for smoother movement
                 allLocationsMapInstance.setView(latLng, Math.max(allLocationsMapInstance.getZoom(), 16), {pan: {animate: true, duration: 0.5}}); // Keep current zoom or zoom in slightly
            }
        };

         // Add event listener for the 'Ver Radares' checkbox
        toggleRadarVisibilityCheckbox.addEventListener('change', (e) => {
            // Re-plot or filter markers based on the checkbox state and current routing mode
            if (currentRoutingMode !== 'navigating') {
                plotReminders(e.target.checked); // Re-plot all markers with filtering
            } else {
                 // Re-filter markers near the route
                filterMarkersNearRoute();
            }
        });


        // Handle map clicks for adding waypoints during route creation
        const handleMapClickForRouting = (e) => {
            if (currentRoutingMode === 'creating') {
                 // Only add waypoints if user location is known (start point is required)
                 if (!initialUserLocationMarkerLat || !initialUserLocationMarkerLng) {
                     showToast("Obteniendo ubicación... Intenta añadir puntos después.", "info");
                     // Attempt to get location if not already doing so
                     if (locationWatchId === null) {
                          getCurrentLocation(updateInitialUserPosition, () => showToast("No se pudo obtener ubicación para crear ruta.", "error"));
                     }
                     return;
                 }

                let icon;
                let isStartEnd = false;
                // Determine the icon and if it's the final destination
                if (currentRouteWaypointsLatLng.length === 0) { // The first click adds the final destination
                    icon = createNumberedIcon('F', 'red', 28, true);
                    isStartEnd = true;
                } else { // Subsequent clicks add intermediate stages
                    icon = createNumberedIcon(currentRouteWaypointsLatLng.length + 1, '#F59E0B', 28, false); // Use 1-based index for icon
                }
                // Create a draggable marker for the clicked location
                const marker = L.marker(e.latlng, { icon: icon, draggable: true })
                .addTo(allLocationsMapInstance);

                // Store the LatLng in our array of waypoints (excluding the start point)
                const waypointIndexInLatLngArray = currentRouteWaypointsLatLng.length; // This will be 0 for the first added point, 1 for the second, etc.
                currentRouteWaypointsLatLng.push(e.latlng);

                // Store the index in our array on the marker itself
                marker.waypointArrayIndex = waypointIndexInLatLngArray;
                // Add the marker to our list of simple waypoint markers
                simpleWaypointMarkers.push(marker);


                // Add dragend listener to update the LatLng in our array when the marker is dragged
                marker.on('dragend', function(event) {
                    const newLatLng = event.target.getLatLng();
                    const markerIndexInLatLngArray = this.waypointArrayIndex;
                    if (markerIndexInLatLngArray !== undefined && currentRouteWaypointsLatLng[markerIndexInLatLngArray]) {
                       currentRouteWaypointsLatLng[markerIndexInLatLngArray] = newLatLng; // Update LatLng
                       drawRoutePreview(); // Redraw the route preview
                    }
                });

                // Add delete icon to the marker
                    const deleteIcon = L.DomUtil.create('div', 'delete-waypoint-icon');
                    deleteIcon.innerHTML = '✖';
                    // Use a timeout to ensure the marker element is available before adding the icon
                    setTimeout(() => {
                         if (marker.getElement()) {
                              marker.getElement().appendChild(deleteIcon);
                               // Add delete listener
                              L.DomEvent.on(deleteIcon, 'click', function(clickEvent) {
                                  L.DomEvent.stop(clickEvent); // Prevent click propagating
                                  const markerIndexInLatLngArray = marker.waypointArrayIndex;
                                   // Ensure index is valid
                                   if (markerIndexInLatLngArray !== undefined && markerIndexInLatLngArray < currentRouteWaypointsLatLng.length) {
                                      currentRouteWaypointsLatLng.splice(markerIndexInLatLngArray, 1); // Remove from array
                                      // Remove the marker from the map if it's there
                                      if(allLocationsMapInstance.hasLayer(marker)) marker.remove();
                                      // Remove from our tracking list
                                      simpleWaypointMarkers = simpleWaypointMarkers.filter(m => m !== marker);
                                      // Redraw the preview (rebuilds LRM control and markers)
                                      drawRoutePreview();
                                      // Update UI state (e.g., button text)
                                      updateRoutingUI();
                                       // Update icons and indices on remaining markers manually if LRM doesn't handle it
                                      updateSimpleWaypointIcons();
                                   }
                              });
                         }
                    }, 0);


                updateRoutingUI(); // Update button text ("CREAR RUTA" to "INICIAR NAVEGACIÓN")
                 // Draw or redraw the route preview if we have at least one waypoint and start location is known
                if (currentRouteWaypointsLatLng.length >= 1 && initialUserLocationMarkerLat && initialUserLocationMarkerLng) {
                    drawRoutePreview();
                }
            } else if (currentRoutingMode === 'none') {
                 // If not in creation mode, a simple click (or tap) can be used to add a RADAR reminder
                 // Check if it's a touch device for single tap or mouse for right-click (contextmenu)
                if (e.latlng) {
                     // Handle tap on touch devices or click on non-touch
                     if (L.Browser.touch) {
                         handleRadarMapLongPress(e.latlng); // Use same handler as contextmenu
                     } else {
                          // For non-touch, clicks don't trigger radar creation here, only contextmenu
                          // This prevents accidentally adding radars with every click.
                     }
                }
            }
        };

         // Add event listener for map clicks (for adding waypoints or radars)
        allLocationsMapInstance.on('click', handleMapClickForRouting);
         // Add event listener for right-click (contextmenu) to add a RADAR
        allLocationsMapInstance.on('contextmenu', function(e) {
             // Prevent default browser context menu
             e.originalEvent.preventDefault();
             // Only handle contextmenu in 'none' mode
             if (currentRoutingMode === 'none') {
                 if (e.latlng) { handleRadarMapLongPress(e.latlng); } // Use the same handler as touch tap
             } else if (currentRoutingMode === 'creating') {
                  // Prevent context menu in creation mode
                 // e.originalEvent.preventDefault(); // Already called above
             }
        });


        // Get the user's current location for initial map view and tracking
        getCurrentLocation(
            (currentPos) => {
                const userCoords = {
                    latitude: currentPos.coords.latitude,
                    longitude: currentPos.coords.longitude,
                    accuracy: currentPos.coords.accuracy,
                    heading: currentPos.coords.heading,
                    altitude: currentPos.coords.altitude
                };
                // Update user position markers/display and set initial map view
                updateInitialUserPosition(userCoords, true); // Pass true for initial view setup


                // If not navigating and user marker for route doesn't exist, create the initial user location marker
                // The initialUserLocationMarker is used before navigation starts.
                if(currentRoutingMode !== 'navigating' && !userMarkerForRoute){
                     if(!initialUserLocationMarker) {
                        initialUserLocationMarker = L.marker([userCoords.latitude, userCoords.longitude], {icon: carIcon, zIndexOffset: 1000}).addTo(allLocationsMapInstance);
                         if (initialUserLocationMarker.getElement()) {
                             initialUserLocationMarker.getElement().style.transformOrigin = 'center center';
                             if (userCoords.heading !== null && !isNaN(userCoords.heading) && userCoords.heading >= 0 && userCoords.heading <= 360) {
                                  initialUserLocationMarker.getElement().style.transform = `rotate(${userCoords.heading}deg)`;
                             }
                         }
                     }
                }


                // Start watching the user's position for real-time updates if not already watching
                if (locationWatchId === null && 'geolocation' in navigator && 'watchPosition' in navigator.geolocation) {
                    locationWatchId = navigator.geolocation.watchPosition(
                        // Success callback for watchPosition
                        (position) => {
                            const coordsForUpdate = {
                                latitude: position.coords.latitude,
                                longitude: position.coords.longitude,
                                accuracy: position.coords.accuracy,
                                heading: position.coords.heading,
                                altitude: position.coords.altitude
                            };
                            // Update initial user position marker/circle and orientation display
                            updateInitialUserPosition(coordsForUpdate, false); // Pass false as not initial setup


                            // If in navigation mode, update the start waypoint of the route control
                             if (currentRoutingMode === 'navigating' && navigationRoutingControl) {
                                 const userCurrentLatLng = L.latLng(coordsForUpdate.latitude, coordsForUpdate.longitude);
                                 const waypoints = navigationRoutingControl.getWaypoints();
                                 // Update the first waypoint (start) if user position changes significantly (e.g., more than 5 meters)
                                 if (waypoints && waypoints.length > 0 && waypoints[0].latLng.distanceTo(userCurrentLatLng) > 5) {
                                     waypoints[0].latLng = userCurrentLatLng; // Update the LatLng of the start waypoint
                                     navigationRoutingControl.setWaypoints(waypoints); // Trigger route recalculation from new start
                                      // The routingfound event listener will handle updating UI and filters
                                 }
                                  // The more detailed navigation progress (maneuvers, progress bar) is handled within the watchPosition callback itself.
                             } else if (currentRoutingMode === 'creating' && startRouteMarkerVisual) {
                                 // If in creation mode, update the position of the static start marker visual
                                 startRouteMarkerVisual.setLatLng([coordsForUpdate.latitude, coordsForUpdate.longitude]);
                                 // If waypoints exist, redraw the preview route from the new start position
                                 if (currentRouteWaypointsLatLng.length > 0) drawRoutePreview();
                             }
                        },
                        // Error callback for watchPosition
                        (error) => {
                            showToast(`Error seguimiento GPS: ${error.message}`, "warning");
                            console.warn("GPS error in watchPosition:", error);
                            // Clear the watch if an error occurs
                            if (locationWatchId !== null) {
                                navigator.geolocation.clearWatch(locationWatchId);
                                locationWatchId = null;
                            }
                             // Clear orientation/altitude display on error
                             if (orientationAltitudeControl) {
                                orientationAltitudeControl.updateOrientation(null);
                                orientationAltitudeControl.updateAltitude(null);
                            }
                            // Optionally, stop navigation if GPS is lost critical errors
                             if (currentRoutingMode === 'navigating' && error.code === error.POSITION_UNAVAILABLE) {
                                showToast("Posición GPS perdida. Deteniendo navegación.", "error");
                                createRouteButton.click(); // Simulate click to stop navigation
                             }
                        },
                        // watchPosition options
                        { enableHighAccuracy: true, timeout: 15000, maximumAge: 5000, distanceFilter: 5 } // Use distanceFilter to reduce updates while stationary
                    );
                     console.log("Started watching user position.");
                }
                 // Trigger the "ESTÁS AQUÍ" button click programmatically once location is obtained
                 // This fulfills the requirement: "Al entrar en la opción de mapas se debe llamar automáticamente al proceso que se desencadena cuando se pulsa el botón estoy aquí pero solo una vez."
                 // By clicking the button, we trigger its logic (centering, changing text) as if the user clicked it.
                 // The shouldCenterOnUserInAllLocationsMap flag is already true by default, ensuring centering happens.
                 // The locateMeButtonMap.textContent check inside its handler prevents re-triggering the centering logic if the button is already in the "DEJAR DE SEGUIR" state.
                 // This should happen only once upon entering the map and successfully getting location.
                 if (locateMeButtonMap.textContent === "ESTÁS AQUÍ") { // Ensure it's in the initial state
                      locateMeButtonMap.click();
                 }


            },
            // Error callback for initial getCurrentLocation
            () => {
                showToast("No pudo obtener la ubicación inicial. Mostrando mapa por defecto.", "warning");
                console.warn("Could not get initial user location.");
                 // Clear orientation/altitude display if location fails
                 if (orientationAltitudeControl) {
                    orientationAltitudeControl.updateOrientation(null);
                    orientationAltitudeControl.updateAltitude(null);
                }
                 // Proceed with map setup but without user location
                updateInitialUserPosition(null, true); // Pass null coords, but do initial view setup
            }
        );

        // Invalidate map size again after a short delay to fix rendering issues that might occur after DOM manipulation
        setTimeout(() => {
            if (allLocationsMapInstance) {
                allLocationsMapInstance.invalidateSize();
            }
        }, 250);


    } catch (error) {
        // Handle general errors during map initialization
        console.error("Error al cargar el mapa:", error);
        mapContainer.innerHTML = `<p style="color:red; text-align:center; padding:20px;">Error al cargar el mapa: ${error.message}</p>`;
         // Ensure map instance is null if initialization failed
        allLocationsMapInstance = null;
    }
}

    // Handler for long press/right-click on the map to create a RADAR reminder
    function handleRadarMapLongPress(latlng) {
        if (!latlng) return;
        // Close the current map modal before opening the reminder modal
        const mapModalElement = document.getElementById('reminders-location-map-modal');

        if (mapModalElement) {
             // Clean up map instance and watchers before closing
             if (locationWatchId !== null) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
             if (allLocationsMapInstance) {
                  if (initialUserLocationMarker) { initialUserLocationMarker.remove(); initialUserLocationMarker = null; }
                  if (initialUserLocationCircle) { initialUserLocationCircle.remove(); initialUserLocationCircle = null; }
                  if (orientationAltitudeControl && allLocationsMapInstance.hasControl(orientationAltitudeControl)) { allLocationsMapInstance.removeControl(orientationAltitudeControl); orientationAltitudeControl = null; }
                  try { allLocationsMapInstance.remove(); } catch(e){} allLocationsMapInstance = null;
             }
              // Remove the modal element
             mapModalElement.remove();
        }
         // Close map help modal if open
        const helpModalInstance = document.getElementById('reminders-map-help-modal-instance');
        if (helpModalInstance) helpModalInstance.remove();


        // Prepare data for the new reminder modal
        const reminderData = {
            text: 'RADAR', // Pre-fill text
            isLocationEnabled: true, // Enable location
            locationCoordinates: { // Set location coordinates to the clicked point
                latitude: latlng.lat,
                longitude: latlng.lng
            },
            radiusMeters: 1000, // Default radius
            excludeFromList: true, // Mark as excluded by default
        };
        // Open the reminder modal with pre-filled data
        showReminderModal(reminderData);
        showToast("Creando recordatorio RADAR en el punto seleccionado.", "info");
    }

    // Show the help modal for the reminders location map
    function showRemindersMapHelpModal() {
         // Remove any existing help modal instance
        const existingHelpModal = document.getElementById('reminders-map-help-modal-instance');
        if (existingHelpModal) {
             // Clear its auto-close timer
            const closeButton = existingHelpModal.querySelector('#close-reminders-map-help-instance');
            if (closeButton) clearModalAutoCloseTimer(existingHelpModal, closeButton, 'reminders-map-help-modal-instance');
            existingHelpModal.remove();
        }

        // Create the help modal element
        const helpModal = document.createElement('div');
        helpModal.id = 'reminders-map-help-modal-instance';
        helpModal.className = 'help-modal'; // Use generic help modal styling
        helpModal.setAttribute('aria-label', 'Ayuda Mapa de Ubicaciones/Radares');
        helpModal.innerHTML = `
            <h2 class="text-xl font-bold mb-4">Ayuda del Mapa de Ubicaciones y Rutas</h2>
            <p class="mb-2">Este mapa muestra todos tus recordatorios que tienen una ubicación geográfica asociada y permite trazar rutas.</p>
            <ul class="list-disc pl-5 space-y-1 mb-4 text-sm">
                <li><strong>Ver Detalles (Recordatorios):</strong> Pulsa sobre un marcador (chincheta azul o morada) para ver los detalles del recordatorio y un botón para modificarlo.</li>
                <li><strong>Iconos de Marcadores:</strong>
                    <ul>
                        <li><img src="${defaultLocationMarkerIconBlue.options.iconUrl}" alt="Chincheta Azul" style="width:12px; height:20px; vertical-align:middle; display:inline;"> Recordatorio normal.</li>
                        <li><img src="${radarMarkerIcon.options.iconUrl}" alt="Chincheta Morada" style="width:12px; height:20px; vertical-align:middle; display:inline;"> Recordatorio con "RADAR" en el texto o excluido de lista.</li>
                        <li><img src="Coche.PNG" alt="Icono Coche" style="width:1.5em; height:1.5em; vertical-align:middle; display:inline;"> Tu posición actual. El icono <strong>rota</strong> según tu orientación si la proporciona el GPS. El círculo que lo rodea tiene un radio variable de 3m (cerca) a 150m (lejos) según el zoom, indicando la precisión aproximada o simplemente visualización.</li>
                        <li><img src="data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 28 28'%3E%3Ccircle cx='14' cy='14' r='12' fill='red' stroke='white' stroke-width='2'/%3E%3Ctext x='14' y='19' font-size='16' font-weight='bold' fill='white' text-anchor='middle'%3EF%3C/text%3E%3C/svg%3E" alt="Icono Final" style="width:1.2em; height:1.2em; vertical-align:middle; display:inline;"> Destino final de una ruta en creación/navegación.</li>
                        <li><img src="data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 28 28'%3E%3Ccircle cx='14' cy='14' r='12' fill='%23F59E0B' stroke='white' stroke-width='2'/%3E%3Ctext x='14' y='19' font-size='16' fill='white' text-anchor='middle'%3E1%3C/text%3E%3Csvg%3E" alt="Icono Etapa" style="width:1.2em; height:1.2em; vertical-align:middle; display:inline;"> Etapa intermedia de una ruta en creación/navegación (ej. etapa 1).</li>
                        <li><img src="data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 28 28'%3E%3Ccircle cx='14' cy='14' r='12' fill='green' stroke='white' stroke-width='2'/%3E%3Ctext x='14' y='19' font-size='16' fill='white' text-anchor='middle'%3ES%3C/text%3E%3Csvg%3E" alt="Icono Inicio" style="width:1.2em; height:1.2em; vertical-align:middle; display:inline;"> Punto de inicio de ruta (tu ubicación GPS, dinámico).</li>
                    </ul>
                </li>
                <li><strong>"ESTÁS AQUÍ" / "DEJAR DE SEGUIR":</strong>
                    <ul>
                        <li><strong>ESTÁS AQUÍ:</strong> Centra el mapa en tu ubicación actual (GPS), la marca con el icono del coche, y activa el seguimiento continuo. El mapa se mantendrá centrado en tu posición mientras te mueves. El botón cambia a "DEJAR DE SEGUIR".</li>
                        <li><strong>DEJAR DE SEGUIR:</strong> Desactiva el centrado automático del mapa. Tu posición (icono coche) seguirá actualizándose en tiempo real, pero el mapa no se moverá contigo. El botón vuelve a "ESTÁS AQUÍ".</li>
                    </ul>
                </li>
                <li><strong>"AQUÍ HAY UN RADAR":</strong> Crea automáticamente un recordatorio con el texto "RADAR", tu ubicación GPS actual, radio de 1000 metros y lo marca para no incluir en la lista general. El nuevo radar se añade al mapa.</li>
                 <li><strong>"VER RADARES" (Checkbox):</strong> Permite mostrar u ocultar los recordatorios que contienen "RADAR" en su texto o están marcados para no listar. Útil para despejar el mapa.</li>
                 <li><strong>Actualización Posición:</strong> La posición de tu coche (<img src="Coche.PNG" alt="Icono Coche" style="width:1.5em; height:1.5em; vertical-align:middle; display:inline;">) se actualiza en tiempo real.</li>
                 <li><strong>Orientación y Altitud:</strong> Panel superior izquierdo (<img src="ROSA.PNG" alt="Rosa Vientos" style="width:1.2em; height:1.2em; vertical-align:middle; display:inline;">) muestra rumbo y altitud si están disponibles. El panel de maniobras de ruta se integra a su derecha.</li>
            </ul>
            <h3 class="font-semibold text-lg mt-4 mb-2">TRAZAR Y NAVEGAR RUTAS</h3>
            <ul class="list-disc pl-5 space-y-1 text-sm">
                <li><strong>"CREAR RUTA":</strong> Inicia el modo de creación. Pulsa en el mapa para añadir puntos:
                    <ul>
                        <li>El <strong>primer clic</strong> establece el <strong>DESTINO FINAL</strong> (Icono 'F' Rojo).</li>
                        <li>Los <strong>clics siguientes</strong> añaden <strong>ETAPAS INTERMEDIAS</strong> (Iconos '1', '2'... Naranja), en el orden en que se pulsan.</li>
                        <li>El <strong>INICIO</strong> de la ruta será siempre tu ubicación GPS actual al pulsar "INICIAR NAVEGACIÓN" (Icono 'S' Verde, dinámico).</li>
                        <li>Las chinchetas de destino y etapas se pueden arrastrar para reposicionar. La ruta (línea azul) se actualiza dinámicamente.</li>
                         <li>Para <strong>eliminar un punto de ruta</strong> (destino o etapa) durante la creación: Pulsa sobre la chincheta correspondiente hasta que aparezca un aspa (X) roja. Pulsa el aspa para borrar el punto.</li>
                    </ul>
                </li>
                <li><strong>"INICIAR NAVEGACIÓN":</strong> (Botón "CREAR RUTA" cambia a este texto si hay al menos un destino). Calcula la ruta detallada desde tu posición actual, pasando por las etapas (si las hay, en el orden añadido) hasta el destino final. Se mostrará:
                    <ul>
                        <li><strong>Panel de Maniobras:</strong> Arriba a la derecha de la rosa de los vientos. Con instrucción actual, distancia, icono de maniobra y la siguiente instrucción. Las instrucciones están en castellano.</li>
                        <li><strong>Barra de Progreso:</strong> Parte inferior. Color naranja oscuro, traslúcida. Puntos azules en la barra marcan las etapas. Texto superpuesto con distancia/tiempo restante.</li>
                        <li><strong>Info Ruta:</strong> (Integrada en la barra de progreso) Muestra distancia total, tiempo estimado y hora de llegada, distribuidos horizontalmente.</li>
                         <li><strong>Filtro de Recordatorios:</strong> Durante la navegación, solo se mostrarán los recordatorios/radares cercanos a la ruta (aprox. 1500m de radio, los lejanos con transparencia).</li>
                    </ul>
                </li>
                 <li><strong>"DETENER NAVEGACIÓN":</strong> (Botón cambia a este texto durante la navegación). Limpia la ruta activa, detiene el seguimiento de navegación y los paneles de información de ruta. Se restauran todos los marcadores de recordatorios visibles.</li>
                <li><strong>"GUARDAR RUTA":</strong> Visible durante la creación (si hay al menos destino) o navegación. Permite guardar la ruta actual (destino y etapas) con un nombre para usarla más tarde.</li>
                <li><strong>"CARGAR RUTA":</strong> Muestra una lista de rutas guardadas. Al seleccionar una, se carga en el modo "CREAR RUTA" para que puedas revisarla o iniciar la navegación.</li>
            </ul>

             <h3 class="font-semibold text-lg mt-4 mb-2">Crear Recordatorio "RADAR" Manualmente (Alternativa)</h3>
            <p class="mb-2">También puedes añadir un recordatorio "RADAR" directamente desde este mapa haciendo clic o tap en cualquier punto del mapa (si no estás en modo "CREAR RUTA").</p>
            <ul class="list-disc pl-5 space-y-1 text-sm">
                <li><strong>PC:</strong> Haz clic derecho en cualquier punto del mapa.</li>
                <li><strong>Móvil/Táctil:</strong> Un tap/click simple en un punto del mapa.</li>
            </ul>
            <p class="mb-2">Al hacerlo, se abrirá la ventana de creación de recordatorios con datos pre-rellenados.</p>
            <div class="flex justify-end mt-6">
                <button type="button" id="close-reminders-map-help-instance">Entendido</button>
            </div>
        `;
        document.body.appendChild(helpModal);
        const closeButtonHelp = helpModal.querySelector('#close-reminders-map-help-instance');
        const closeHandlerHelp = () => {
            // Clear auto-close timer and remove modal
            clearModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance');
            if (helpModal.parentNode) helpModal.parentNode.removeChild(helpModal);
        };
        closeButtonHelp.addEventListener('click', closeHandlerHelp);
        // Add auto-close timer (e.g., 2 minutes)
        addModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance', 120000);
    }


    // Show the configuration modal
    function showConfigModal() {
         // Check if map was active before opening config
         const mapWasOpenBeforeConfig = isRemindersLocationMapActive || !!document.getElementById('reminders-location-map-modal');

         // Close any other open modals
         hideUnifiedReminderWindow();
         const otherModals = document.querySelectorAll('.choice-modal, .edit-modal, .edit-info-modal, .help-modal, .reminder-modal, .reminder-table-modal, #postpone-options-modal, .versions-modal-overlay, .saved-locations-modal, #reminders-location-map-modal, #reminders-map-help-modal-instance');
         otherModals.forEach(m => m.remove());

        const GAS_URL = 'AKfycbxrM-2kTU4irtHs-8wNEPteYpU7Jy7JWn2p92p8b1UQk-3P0e2bAAt0Z1qkHW025AF6qg'; // Replace with your actual GAS Web App URL

        const modal = document.createElement('div');
        modal.id = 'config-modal';
        modal.setAttribute('aria-label','Configuración');

         // List of localStorage keys managed by backup/restore
        const managedKeys = ['reminders','darkMode','toggleStates','zoomState','onOffState','noticesActive','footerVisible','teslaHtmlLastModified','teslaHtmlLastModifiedTimestamp','userData_userId','userData_teslaModel','userData_teslaYear','userData_teslaProvince','userData_allowDMs', 'customGridData', 'personalizationHelpShown', 'gridFilterValue', 'password_pin', 'password_active', 'lastUpdatesCheckDate', SAVED_LOCATIONS_KEY, SHOW_EXCLUDED_REMINDERS_KEY, 'boardinggate_saved_routes' ];
        const managedDesc = managedKeys.map(k => {
            switch(k){
                case 'reminders':return 'Recordatorios'; case 'darkMode':return 'Modo Oscuro'; case 'toggleStates':return 'Visibilidad Secc.';
                case 'zoomState':return 'Zoom Grid'; case 'onOffState':return 'On/Off Gral'; case 'noticesActive':return 'Avisos/Footer';
                case 'footerVisible':return 'Vis. Footer'; case 'teslaHtmlLastModified':return 'Cache Versión'; case 'teslaHtmlLastModifiedTimestamp':return 'TS Cache';
                case 'userData_userId':return 'ID Usuario'; case 'userData_teslaModel':return 'Modelo'; case 'userData_teslaYear':return 'Año';
                case 'userData_teslaProvince':return 'Provincia'; case 'userData_allowDMs':return 'Permitir MDs (vía admin)'; case 'customGridData': return 'Grid Pers.';
                case 'personalizationHelpShown': return 'Ayuda Pers. Vista'; case 'gridFilterValue': return 'Filtro Grid';
                case 'password_pin': return 'PIN Acceso'; case 'password_active': return 'PIN Activo'; case 'lastUpdatesCheckDate': return 'Cache Fecha Updates';
                case SAVED_LOCATIONS_KEY: return 'Ubicaciones Guardadas';
                case SHOW_EXCLUDED_REMINDERS_KEY: return 'Mostrar Excluidos Tabla';
                case 'boardinggate_saved_routes': return 'Rutas Guardadas';
                default:return k;
            }
        }).join(', '); // Comma-separated list for display

        modal.innerHTML = `
        <h2 style="flex-shrink:0;">Configuración y Datos</h2>
        <div class="tab-buttons" style="flex-shrink:0;">
            <button class="config-tab-button active" data-tab-target="#tab-content-usuario">Usuario</button>
            <button class="config-tab-button" data-tab-target="#tab-content-pin">Clave Acceso</button>
            <button class="config-tab-button" data-tab-target="#tab-content-radares">RADARES</button>
            <button class="config-tab-button" data-tab-target="#tab-content-backup-restore">Backup/Restore</button>
            <button class="config-tab-button" data-tab-target="#tab-content-borrar">Borrar Datos</button>
        </div>
        <div class="tab-contents">
            <div id="tab-content-usuario" class="config-tab-content active">
                <h3>Datos Compartidos (Opcional)</h3>
                <p style="font-size:.9rem;color:#555;margin-bottom:1.5rem;text-align:center;">Guardados en <a href="https://docs.google.com/spreadsheets/d/1-DiwTDrxpUrfYpa_yahHHqeOMYK0ny-KPdoLrDU3uYw/edit?usp=sharing" target="_blank" rel="noopener noreferrer" style="color:#1E40AF;">Hoja Cálculo</a>.</p>
                <div class="user-data-grid">
                    <div><label for="user-id">* ID Usuario (Apodo):</label><input type="text" id="user-id" name="userId" required></div>
                    <div><label for="tesla-model">Modelo Tesla:</label><input type="text" id="tesla-model" name="teslaModel"></div>
                    <div><label for="tesla-year">Año Modelo:</label><input type="number" id="tesla-year" name="teslaYear" min="2012" max="2099"></div>
                    <div><label for="tesla-province">Provincia:</label><input type="text" id="tesla-province" name="teslaProvince"></div>
                    <div class="checkbox-container"><input type="checkbox" id="allow-dms" name="allowDMs"><label for="allow-dms">Permitir MDs (vía admin)</label></div>
                </div>
                <div class="user-buttons-container">
                    <button id="config-save-user" style="background-color:#16A34A;color:white;">Guardar Datos</button>
                    <button id="config-reset-user" style="background-color:#D97706;color:white;">Resetear Reg.</button>
                </div>
                <p id="config-user-status" class="status-message"></p>
            </div>
             <div id="tab-content-pin" class="config-tab-content">
                 <h3>Clave de Acceso (Local)</h3>
                 <p style="font-size: 0.9rem; color: #555; margin-bottom: 1rem;">Establece una clave de 4 cifras para proteger el acceso inicial a la página. Se guarda sólo en tu navegador.</p>
                 <div class="pin-config-layout">
                     <div class="pin-input-group">
                         <label for="config-pin-set">Establecer/Cambiar Clave:</label>
                         <input type="password" id="config-pin-set" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="4 cifras">
                     </div>
                     <div class="pin-input-group">
                         <label for="config-pin-confirm">Confirmar Clave:</label>
                         <input type="password" id="config-pin-confirm" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="Repetir 4 cifras">
                     </div>
                     <div class="pin-buttons-container">
                         <button id="config-save-pin" style="background-color:#2563EB;color:white;">Guardar Clave</button>
                         <button id="config-remove-pin" style="background-color:#dc3545;color:white;">Quitar Clave</button>
                     </div>
                 </div>
                 <p id="config-pin-status" class="status-message"></p>
             </div>

             <div id="tab-content-radares" class="config-tab-content">
                <h3>Importar / Borrar Radares y Otros POIs</h3>
                <p style="font-size:0.85rem; color:#444; margin-bottom:0.5rem;">
                    Para <strong>importar</strong>, el filtro de "Palabras Clave" buscará coincidencias en el nombre del POI (ej: provincia, población, tipo).
                    Los filtros de Lat/Lon pueden ser un valor único (aprox.) o un rango (ej: "<code>40.1 40.5</code>" para buscar entre esas latitudes).
                </p>
                <p style="font-size:0.85rem; color:#444; margin-bottom:1rem;">
                    Los POIs importados (RADARES) se guardarán con un radio de <strong>400 metros</strong>.
                </p>
                <p style="font-size:0.85rem; color:#444; margin-bottom:1.5rem;">
                    Para <strong>borrar</strong>, se eliminarán los recordatorios de ubicación que cumplan TODOS los filtros activos (Lat, Lon, Palabras). Si un filtro está vacío, se ignora.
                </p>
                <div class="radar-filter-group">
                    <div>
                        <label for="radar-filter-lat">Latitud (valor o "min max"):</label>
                        <input type="text" id="radar-filter-lat" placeholder="Ej: 40.123 o 40.0 40.5">
                    </div>
                    <div>
                        <label for="radar-filter-lon">Longitud (valor o "min max"):</label>
                        <input type="text" id="radar-filter-lon" placeholder="Ej: -3.567 o -4.0 -3.0">
                    </div>
                    <div style="grid-column: span 2;">
                        <label for="radar-filter-keywords">Palabras Clave (en nombre POI, separadas por espacio):</label>
                        <input type="text" id="radar-filter-keywords" placeholder="Ej: FIJO CAMUFLADO MADRID">
                    </div>
                </div>
                <div class="radar-import-options">
                    <input type="checkbox" id="import-extra-radars-checkbox">
                    <label for="import-extra-radars-checkbox">Importar también radares móviles, semáforo, etc (sino, solo radares fijos y de tramo)</label>
                </div>
                <div class="radar-action-buttons">
                    <button id="import-radars-button">IMPORTAR RADARES y otros</button>
                    <button id="delete-filtered-radars-button">BORRAR CACHÉ (según filtro)</button>
                </div>
                <div id="radar-import-progress-container" style="display:none;">
                    <progress id="radar-import-progress-bar" value="0" max="100"></progress>
                    <p id="radar-import-status" class="status-message"></p>
                </div>
             </div>

            <div id="tab-content-backup-restore" class="config-tab-content">
                 <div style="background-color:#f7f9f7;padding:.8rem 1rem;border-radius:.25rem;margin-bottom:1.5rem;border:1px solid #ccc;">
                 <p style="font-size:.9rem;color:#555;margin:0;line-height:1.4;"><strong>Datos Incluidos:</strong> ${managedDesc}.<em style="font-size:.8rem;display:block;margin-top:.3rem;">(Backup TODO, Restore sólo compatibles).</em></p>
                </div>
                <div class="backup-restore-container">
                    <div>
                        <h3>Crear Backup</h3>
                        <p>Genera código. <strong style="color:#006400;">Guárdalo.</strong></p>
                        <button id="config-generate-backup" style="background-color:#2563EB;color:white;">Generar Backup</button>
                        <textarea id="config-backup-display" readonly style="display:none;"></textarea>
                        <p id="config-backup-status" class="status-message"></p>
                    </div>
                    <div>
                        <h3>Restaurar Copia</h3>
                        <p>Pega código. <strong style="color:blue;">Solo restaura compatibles</strong>.</p>
                        <textarea id="config-restore-input" placeholder="Pega aquí..."></textarea>
                        <button id="config-restore-backup" style="background-color:#10B981;color:white;">Restaurar</button>
                        <p id="config-restore-status" class="status-message"></p>
                    </div>
                </div>
            </div>
            <div id="tab-content-borrar" class="config-tab-content borrar-container">
                <h3>Borrar Datos Locales</h3>
                 <button id="config-restore-grid-button">RESTAURAR EL GRID ORIGINAL DE BOTONES</button>
                 <p id="config-restore-grid-status" class="status-message" style="margin-bottom: 1.5rem;"></p>

                <h3 style="border-top: 1px solid #ccc; padding-top: 1.5rem; margin-top:1.5rem;">Acción Irreversible</h3>
                <p>Elimina TODOS los datos locales.</p>
                <button id="config-clear-cache">Borrar TODO</button>
                <p><strong style="color:red;">¡Sin deshacer!</strong> Ten backup.</p>
            </div>
        </div>
        <div style="text-align:center;margin-top:1rem;flex-shrink:0;"><button id="config-close-modal">Cerrar <span class="button-countdown-timer"></span></button></div>`;

        document.body.appendChild(modal);

        // Get references to modal elements
        const tabBtns = modal.querySelectorAll('.config-tab-button');
        const tabConts = modal.querySelectorAll('.config-tab-content');
        const userIdI = modal.querySelector('#user-id');
        const modelI = modal.querySelector('#tesla-model');
        const yearI = modal.querySelector('#tesla-year');
        const provinceI = modal.querySelector('#tesla-province');
        const dmsChk = modal.querySelector('#allow-dms');
        const saveBtn = modal.querySelector('#config-save-user');
        const resetBtn = modal.querySelector('#config-reset-user');
        const userStat = modal.querySelector('#config-user-status');
        const genBkupBtn = modal.querySelector('#config-generate-backup');
        const bkupDisp = modal.querySelector('#config-backup-display');
        const restInp = modal.querySelector('#config-restore-input');
        const restBtn = modal.querySelector('#config-restore-backup');
        const clearBtn = modal.querySelector('#config-clear-cache');
        const closeBtn = modal.querySelector('#config-close-modal');
        const restoreGridBtn = modal.querySelector('#config-restore-grid-button');
        const restoreGridStatus = modal.querySelector('#config-restore-grid-status');
        const savePinBtn = modal.querySelector('#config-save-pin');
        const removePinBtn = modal.querySelector('#config-remove-pin');
        const pinSetInput = modal.querySelector('#config-pin-set');
        const pinConfirmInput = modal.querySelector('#config-pin-confirm');
        const pinStatus = modal.querySelector('#config-pin-status');

        const importRadarsButton = modal.querySelector('#import-radars-button');
        const deleteFilteredRadarsButton = modal.querySelector('#delete-filtered-radars-button');
        if (importRadarsButton) importRadarsButton.addEventListener('click', handleImportRadars);
        if (deleteFilteredRadarsButton) deleteFilteredRadarsButton.addEventListener('click', handleDeleteFilteredRadars);


        // Add event listeners for tab buttons
        tabBtns.forEach(button => {
            button.addEventListener('click', () => {
                const tabTarget = button.dataset.tabTarget;
                tabBtns.forEach(btn => btn.classList.remove('active'));
                tabConts.forEach(content => content.classList.remove('active'));
                button.classList.add('active');
                modal.querySelector(tabTarget).classList.add('active');
            });
        });

        // Function to load user data from localStorage into form fields
        const loadUData = () => {
             userIdI.value = localStorage.getItem('userData_userId') || '';
             modelI.value = localStorage.getItem('userData_teslaModel') || '';
             yearI.value = localStorage.getItem('userData_teslaYear') || '';
             provinceI.value = localStorage.getItem('userData_teslaProvince') || '';
             dmsChk.checked = localStorage.getItem('userData_allowDMs') === 'true';
        };

        // Function to call Google Apps Script Web App
        const callGAS = async (action, data = {}) => {
            if (!GAS_URL || GAS_URL === 'URL_DE_TU_GOOGLE_APPS_SCRIPT_WEB_APP') {
                 console.error("GAS_URL not configured.");
                 return { status:'error', message:'URL API no conf.' };
            }
            // Clear previous status message
            if(userStat)userStat.textContent='';
            // Indicate loading state
            setUserDataLoading(true);
            try {
                 // Send POST request to GAS Web App
                const resp = await fetch(GAS_URL, {
                     method:'POST', mode:'cors', cache:'no-cache',
                     headers:{'Content-Type':'application/json'},
                     redirect:'follow',
                     body:JSON.stringify({ action, ...data }),
                });
                let res;
                // Parse response based on Content-Type header
                const ct = resp.headers.get("content-type");
                if(ct?.includes("application/json")) {
                    res = await resp.json();
                } else {
                     // Attempt to parse as JSON even if content-type is not exactly json
                    const txt = await resp.text();
                    try { res = JSON.parse(txt); }
                    catch (e) {
                         // If JSON parsing fails and response is not OK, throw an error
                        if (!resp.ok) throw new Error(`Server error (${resp.status}): ${txt.substring(0,200)}`);
                         // Otherwise, assume success with non-JSON response
                        res = { status:'success', message:'OK (non-JSON).' };
                    }
                }
                 // Check for server errors or specific status codes from GAS
                if (!resp.ok && res.status !== 'exists' && res.status !== 'not_found') {
                     throw new Error(res.message || `Server error (${resp.status})`);
                }
                return res; // Return the response object
            } catch (e) {
                 // Handle fetch or parsing errors
                 console.error("Error calling GAS API:", e);
                return { status:'error', message: e.message || 'API Conn Error.' };
            } finally {
                 // Reset loading state
                setUserDataLoading(false);
            }
        };

        // Function to set loading state on user data related inputs/buttons
        const setUserDataLoading = (isLoading)=> {
            // Disable/enable relevant form elements
            [userIdI, modelI, yearI, provinceI, dmsChk, saveBtn, resetBtn, pinSetInput, pinConfirmInput, savePinBtn, removePinBtn].forEach(el => { if(el) el.disabled = isLoading; });
             // Adjust button opacity
            if (saveBtn) saveBtn.style.opacity = isLoading?0.6:1;
            if (resetBtn) resetBtn.style.opacity = isLoading?0.6:1;
            if (savePinBtn) savePinBtn.style.opacity = isLoading?0.6:1;
            if (removePinBtn) removePinBtn.style.opacity = isLoading?0.6:1;

            // Update status message
            if(isLoading && userStat) {
                 userStat.textContent = 'Procesando...';
                 userStat.style.color = '#1E40AF'; // Blue-ish color for processing
            } else if (userStat && (userStat.textContent === 'Procesando...' || userStat.textContent === 'Sincronizando con servidor...' || userStat.textContent === 'Validando ID en servidor...' || userStat.textContent === 'Eliminando registro antiguo...')) {
                 // Clear status only if it was a processing message
                 userStat.textContent = '';
            }
        };

        // Event listener for saving user data
        saveBtn.addEventListener('click', async () => {
             const userId = userIdI.value.trim();
             const model = modelI.value.trim();
             const year = yearI.value.trim();
             const province = provinceI.value.trim();
             const allowDMs = dmsChk.checked;

             // Validate User ID
             if (!userId) {
                 showToast('ID Usuario (Apodo) obligatorio.', 'warning', 4000);
                 if(userStat) { userStat.textContent = 'ID de Usuario es obligatorio.'; userStat.style.color = '#EF4444'; } // Red color for error
                 return;
             }

             const storedUserId = localStorage.getItem('userData_userId');
             let syncAttempted = false;
             let syncSuccess = false;
             let syncMessage = '';

             // Save data to local storage first
             try {
                 localStorage.setItem('userData_userId', userId);
                 localStorage.setItem('userData_teslaModel', model);
                 localStorage.setItem('userData_teslaYear', year);
                 localStorage.setItem('userData_teslaProvince', province);
                 localStorage.setItem('userData_allowDMs', allowDMs.toString());
                 updateUserIdDisplay(); // Update user ID display globally if applicable
             }
             catch (e) {
                 showToast(`Error local: ${e.message}`, 'error', 5000);
                 if(userStat) { userStat.textContent = `Error local: ${e.message.substring(0, 100)}`; userStat.style.color = '#EF4444'; }
                 return; // Stop if local save fails
             }

             let proceedRemoteSave = false;
             if(userStat)userStat.textContent='Sincronizando con servidor...';
             try {
                 // Check if user ID has changed or is new
                 if (!storedUserId || userId !== storedUserId) {
                     if(userStat)userStat.textContent='Validando ID en servidor...';
                     const chk = await callGAS('checkUserIdExists',{usuario:userId}); // Check if new ID exists
                     syncAttempted=true;
                     if(chk.status==='exists'){
                         syncMessage=`El ID "${userId}" ya existe. No se guardó remotamente.`;
                         showToast(syncMessage, 'error', 6000);
                         if(userStat) { userStat.textContent = syncMessage; userStat.style.color = '#EF4444'; }
                         return; // Stop if new ID already exists
                     } else if(chk.status === 'not_found' || chk.status === 'success'){
                          // If old ID exists and is different, try to delete the old record
                         if(storedUserId && userId !== storedUserId){
                             if(userStat) userStat.textContent='Eliminando registro antiguo...';
                             const delOld = await callGAS('deleteUserRow',{userId:storedUserId});
                              // Log warning if deletion fails but don't block saving the new one
                             if(delOld.status !== 'success' && delOld.status !== 'not_found') {
                                 console.warn("Fallo al eliminar registro antiguo:", delOld.message);
                             }
                         }
                         proceedRemoteSave = true; // Proceed to save the new/updated record
                     } else {
                         // Handle unexpected response from check
                         throw new Error(chk.message || "Error al validar ID.");
                     }
                 } else {
                     // If user ID hasn't changed, proceed directly to saving
                     proceedRemoteSave = true;
                 }

                 // Save data to Google Sheet
                 if(proceedRemoteSave){
                     if(userStat) userStat.textContent = 'Guardando datos en servidor...';
                     const uData = {usuario: userId, modelo: model, anio: year, provincia: province, rss: allowDMs ? 'SI' : 'NO'};
                     const sav = await callGAS('addUserData', {userData: uData}); // Add/Update user data
                     syncAttempted = true;
                     if(sav.status === 'success'){
                         syncSuccess = true;
                         syncMessage = 'Datos guardados local y remotamente.';
                         if(userStat) { userStat.textContent = 'Sincronización OK.'; userStat.style.color = '#28a745'; } // Green color for success
                     } else {
                         // Handle error saving data
                         throw new Error(sav.message || "Error al guardar datos.");
                     }
                 }
             } catch (e) {
                  // Handle errors during remote sync process
                 syncSuccess = false;
                 syncMessage = `Guardado local. Error sync: ${e.message}`;
                 if(userStat) { userStat.textContent = `Sync error: ${e.message.substring(0, 100)}`; userStat.style.color = '#ffc107'; } // Yellow/Orange for partial success/warning
             }
             finally {
                  // Show final toast message based on sync result
                 if (syncAttempted) {
                     showToast(syncMessage, syncSuccess ? 'success' : (syncAttempted && !syncSuccess ? 'error' : 'warning'), syncSuccess ? 3000 : 6000);
                 } else {
                     // If sync wasn't attempted, just confirm local save
                     showToast('Datos guardados localmente.', 'success', 3000);
                 }
                  // Ensure status message is updated correctly if it was showing processing state
                  if(userStat && (userStat.textContent === 'Procesando...' || userStat.textContent === 'Sincronizando con servidor...' || userStat.textContent === 'Validando ID en servidor...' || userStat.textContent === 'Eliminando registro antiguo...')) {
                       if (!syncAttempted || syncSuccess) {
                           userStat.textContent = 'Guardado local OK.';
                           userStat.style.color = '#28a745';
                       }
                  }
                 setUserDataLoading(false); // Reset loading state
             }
        });

        // Event listener for resetting user data
        resetBtn.addEventListener('click', async () => {
             const storedUserId = localStorage.getItem('userData_userId');
             // Check if there is any local user data to reset
             if (!storedUserId) {
                 showToast('No hay registro local para resetear.', 'info', 3000);
                 if(userStat) { userStat.textContent = 'No hay registro local.'; userStat.style.color = '#17a2b8'; } // Blue-ish color for info
                 return;
             }
             // Confirm reset action
             if (!confirm(`¿Seguro resetear registro "${storedUserId}"?\nEsto borrará tus datos compartidos (ID, Modelo, Año, Provincia) tanto localmente como en el servidor.`)) {
                 showToast('Reseteo cancelado.', 'info', 2000);
                 if(userStat) { userStat.textContent = 'Reseteo cancelado.'; userStat.style.color = '#17a2b8'; }
                 return;
             }

             let remoteDeletionAttempted = false;
             let remoteDeletionSuccess = false;
             let remoteMessage = '';
             setUserDataLoading(true); // Indicate loading

             // Attempt to delete data from Google Sheet first
             if(userStat) userStat.textContent = `Eliminando remoto "${storedUserId}"...`;
             try {
                 const delRes = await callGAS('deleteUserRow', { userId: storedUserId });
                 remoteDeletionAttempted = true;
                 if (delRes.status === 'success') {
                     remoteDeletionSuccess = true;
                     remoteMessage = 'Registro remoto eliminado. ';
                     if(userStat) { userStat.textContent = 'Registro remoto eliminado.'; userStat.style.color = '#28a745'; }
                 } else if (delRes.status === 'not_found') {
                     remoteDeletionSuccess = true; // Treat not_found as success for deletion purpose
                     remoteMessage = 'Registro remoto no encontrado. ';
                     if(userStat) { userStat.textContent = 'Registro remoto no encontrado.'; userStat.style.color = '#ffc107'; }
                 } else {
                     // Handle error during remote deletion
                     remoteMessage = `Error eliminar remoto (${delRes.message || '?'}). `;
                     if(userStat) { userStat.textContent = `Error remoto: ${delRes.message.substring(0, 100)}`; userStat.style.color = '#EF4444'; }
                 }
             } catch (e) {
                 // Handle connection error during remote deletion
                 remoteMessage = `Error conexión eliminar remoto (${e.message}). `;
                 if(userStat) { userStat.textContent = `Error conexión: ${e.message.substring(0, 100)}`; userStat.style.color = '#EF4444'; }
             } finally {
                  // Clear status message if it was showing processing and remote attempt finished without specific error handling
                  if(!remoteDeletionAttempted && userStat) { userStat.textContent = ''; }
             }

             // Delete data from local storage
             try {
                 localStorage.removeItem('userData_userId');
                 localStorage.removeItem('userData_teslaModel');
                 localStorage.removeItem('userData_teslaYear');
                 localStorage.removeItem('userData_teslaProvince');
                 localStorage.removeItem('userData_allowDMs');
                 // Clear form fields
                 userIdI.value=''; modelI.value=''; yearI.value=''; provinceI.value=''; dmsChk.checked=false;
                 updateUserIdDisplay(); // Update global user ID display
                 // Show combined toast message
                 showToast(`${remoteMessage}Datos locales reseteados.`, remoteDeletionSuccess ? 'success' : (remoteDeletionAttempted ? 'warning' : 'success'), 4000);
                  // Update status message color unless remote error occurred
                 if(userStat && userStat.style.color !== '#EF4444') {
                      userStat.textContent = `Datos locales reseteados.`;
                      userStat.style.color = '#28a745';
                 }
             } catch (e) {
                  // Handle error clearing local storage
                 showToast(`${remoteMessage}Error al limpiar datos locales.`, 'error', 5000);
                 if(userStat) { userStat.textContent = `Error limpiar local: ${e.message.substring(0, 100)}`; userStat.style.color = '#EF4444'; }
             } finally {
                 setUserDataLoading(false); // Reset loading state
             }
        });

        // Event listener for clearing ALL local data
        clearBtn.addEventListener('click', () => {
             // Confirm irreversible action
             if (confirm('¿Estás MUY SEGURO de borrar TODO el caché local?\n\n¡ACCIÓN IRREVERSIBLE!\nEsto eliminará: Recordatorios, Ajustes de UI, Datos de Usuario, Grid Personalizado, PIN de Acceso, Ubicaciones Guardadas y Rutas Guardadas.\n\nAsegúrate de tener un Backup si deseas conservar algo.')) {
                 // Attempt to delete remote user data before clearing local
                 const storedUserId = localStorage.getItem('userData_userId');
                 if (storedUserId) {
                      callGAS('deleteUserRow',{userId:storedUserId})
                         .then(r=>console.log("Remote deletion result (on clear all):",r))
                         .catch(e=>console.warn("Error remote deletion (on clear all):",e));
                 }
                 localStorage.clear(); // Clear all localStorage data
                 sessionStorage.clear(); // Clear all sessionStorage data
                 // Clear modal auto-close timer before removing modal
                 clearModalAutoCloseTimer(modal, closeBtn, 'config-modal');
                 if (modal.parentNode) modal.parentNode.removeChild(modal); // Remove modal
                 showToast('Datos borrados. Recargando...', 'info', 2000);
                 // Reload the page after a short delay
                 setTimeout(() => { location.reload(); }, 500);
             } else {
                 showToast('Borrado de caché cancelado.', 'info', 2000);
             }
        });

        // Event listener for restoring default grid buttons
        restoreGridBtn.addEventListener('click', () => {
             if(restoreGridStatus) restoreGridStatus.textContent = ''; // Clear previous status message
             // Confirm action
             if (confirm('¿Seguro restaurar el grid original de botones?\nEsto eliminará tu personalización actual de marcadores y asignación de botones.\nEsta acción NO afecta tus recordatorios ni otros ajustes de configuración.')) {
                 try {
                     localStorage.removeItem('customGridData'); // Remove custom grid data
                      // Reset the in-memory customData to initial state
                     customData = { bookmarks: { ...initialGridData }, toggles: {} };
                     // Note: A full page reload is the easiest way to re-render the grid correctly from initial data
                     if(restoreGridStatus) {
                          restoreGridStatus.textContent = 'Grid original restaurado. Recargando...';
                          restoreGridStatus.style.color = '#28a745'; // Green for success
                     }
                     showToast('Grid original restaurado. Recargando...', 'success', 2500);
                      // Clear modal timer and close
                     clearModalAutoCloseTimer(modal, closeBtn, 'config-modal');
                      // Reload the page
                     setTimeout(() => { location.reload(); }, 1500);
                 } catch (e) {
                      console.error("Error restoring default grid:", e);
                     if(restoreGridStatus) {
                          restoreGridStatus.textContent = 'Error al restaurar.';
                          restoreGridStatus.style.color = '#EF4444'; // Red for error
                     }
                     showToast('Error al restaurar grid.', 'error', 4000);
                 }
             } else {
                 if(restoreGridStatus) {
                      restoreGridStatus.textContent = 'Restauración grid cancelada.';
                      restoreGridStatus.style.color = '#17a2b8'; // Blue-ish for info
                 }
                 showToast('Restauración grid cancelada.', 'info', 2000);
             }
        });

        // Event listener for generating backup code
        genBkupBtn.addEventListener('click', () => {
             bkupDisp.value = ''; // Clear previous backup code
             bkupDisp.style.display = 'none'; // Hide textarea
             const backupData = {}; // Object to store data for backup
             let keysCount = 0; // Counter for backed-up keys
             let skippedKeys = []; // List of keys not included (e.g., static or error)

             // Iterate through all localStorage keys
             for (let i = 0; i < localStorage.length; i++) {
                 const key = localStorage.key(i);
                 if (key !== null) {
                      // Only include keys specified in the managedKeys list
                     if (managedKeys.includes(key)) {
                         try {
                             backupData[key] = localStorage.getItem(key); // Get item value
                             keysCount++;
                         } catch (e) {
                             console.error(`Error getting item ${key} for backup:`, e);
                             skippedKeys.push(`${key}(err)`); // Add key with error indicator
                         }
                     } else {
                         skippedKeys.push(key); // List keys that are not managed
                     }
                 }
             }
             // If no managed data was found
             if (keysCount === 0) {
                 showToast('No hay datos locales para crear backup.', 'warning', 4000);
                 if(userStat) { userStat.textContent = 'No hay datos para backup.'; userStat.style.color = '#ffc107'; }
                 return;
             }
             try {
                 // Stringify the backup data object into a pretty JSON string
                 const jsonString = JSON.stringify(backupData, null, 2);
                 bkupDisp.value = jsonString; // Set the textarea value
                 bkupDisp.style.display = 'block'; // Show the textarea
                 bkupDisp.select(); // Select the text for easy copying
                 let message = `Backup (${keysCount} claves) generado. Cópialo.`;
                 if(skippedKeys.length > 0) { message += ` (Ignoradas: ${skippedKeys.length} claves no gestionadas o con error)`; }
                 showToast(message, 'success', 5000);
                 if(userStat) { userStat.textContent = 'Backup generado OK.'; userStat.style.color = '#28a745'; }
             } catch (e) {
                 console.error("Error generating backup JSON:", e);
                 bkupDisp.value = `Error al generar backup:\n${e.message}`; // Display error in textarea
                 bkupDisp.style.display = 'block';
                 showToast('Error al generar backup.', 'error', 5000);
                 if(userStat) { userStat.textContent = `Error backup: ${e.message.substring(0, 100)}`; userStat.style.color = '#EF4444'; }
             }
        });

        // Event listener for restoring data from backup code
        restBtn.addEventListener('click', () => {
             const jsonString = restInp.value.trim(); // Get input code
             if (!jsonString) {
                 showToast('Pega el código de backup en el área de texto.', 'warning', 4000);
                 if(userStat) { userStat.textContent = 'Pega el código.'; userStat.style.color = '#ffc107'; }
                 return;
             }
             try {
                 const restoredData = JSON.parse(jsonString); // Parse the JSON string
                 // Validate the parsed data is a non-null object
                 if (typeof restoredData !== 'object' || restoredData === null || Array.isArray(restoredData)) {
                     throw new Error("Formato JSON inválido. Debe ser un objeto.");
                 }
                 // Confirm restoration
                 if (!confirm('¿Seguro restaurar datos?\nEsto borrará los datos locales actuales para las claves compatibles y los reemplazará con los del backup.')) {
                     showToast('Restauración cancelada.', 'info', 2000);
                     if(userStat) { userStat.textContent = 'Restauración cancelada.'; userStat.style.color = '#17a2b8'; }
                     return;
                 }

                 // Clear existing managed data from localStorage and some sessionStorage keys
                 managedKeys.forEach(key => localStorage.removeItem(key));
                 Object.keys(sessionStorage).forEach(key => {
                      // Clear only specific session storage keys related to UI state that might conflict
                      if (key.startsWith('reminder_managed_') || key === 'personalizationHelpShown' || key === 'boardinggate_map_should_reopen_after_form' || key === 'boardinggate_map_should_reopen_when_unified_closes' || key === 'boardinggate_map_was_open_before_table') {
                           sessionStorage.removeItem(key);
                      }
                 });


                 let restoredCount = 0; // Counter for restored keys
                 let skippedKeys = []; // List of keys not restored (e.g., not in managed list or error)
                 // Iterate through keys in the restored data
                 for (const key in restoredData) {
                     if (Object.hasOwnProperty.call(restoredData, key)) {
                          // Only restore keys that are in the managedKeys list
                         if (managedKeys.includes(key)) {
                             try {
                                 localStorage.setItem(key, restoredData[key]); // Set item in localStorage
                                 restoredCount++;
                             } catch (e) {
                                 console.error(`Error setting item ${key} during restore:`, e);
                                 skippedKeys.push(`${key}(err)`); // Add key with error
                             }
                         } else {
                             skippedKeys.push(key); // Add keys not in managed list
                         }
                     }
                 }

                 let message = ''; let toastType = 'info';
                 if (restoredCount > 0) {
                     message = `Restauradas ${restoredCount} claves compatibles.`;
                     if (skippedKeys.length > 0) { message += ` Ignoradas ${skippedKeys.length} (no compatibles o error).`; }
                     message += ' Recargando página para aplicar cambios...';
                     toastType = 'success';
                      // Clear modal timer and close before reload
                     clearModalAutoCloseTimer(modal, closeBtn, 'config-modal');
                     if (modal.parentNode) modal.parentNode.removeChild(modal);
                     showToast(message, toastType, 3000);
                      // Reload page after a short delay to apply restored settings
                     setTimeout(() => { location.reload(); }, 1800);
                 } else {
                     message = 'No se encontraron datos compatibles en el backup.';
                     if (skippedKeys.length > 0) { message += ` Ignoradas ${skippedKeys.length} (no compatibles o error).`; }
                     toastType = 'warning';
                     showToast(message, toastType, 5000);
                     if(userStat) { userStat.textContent = message.substring(0, 100); userStat.style.color = '#ffc107'; }
                 }

             } catch (e) {
                  // Handle errors during parsing or restoration process
                 console.error("Error during restore process:", e);
                 showToast(`Error restaurar: ${e.message}`, 'error', 5000);
                 if(userStat) { userStat.textContent = `Error restaurar: ${e.message.substring(0, 100)}`; userStat.style.color = '#EF4444'; }
             }
        });

        // Add listeners for PIN related buttons
        if (savePinBtn) savePinBtn.addEventListener('click', savePinSettings);
        if (removePinBtn) removePinBtn.addEventListener('click', removePinSettings);

        // Handler for closing the config modal
        const closeConfigHandler = () => {
             // Clear auto-close timer and remove modal
            clearModalAutoCloseTimer(modal, closeBtn, 'config-modal');
            if (modal.parentNode) document.body.removeChild(modal);

            // Check if map should reopen after config modal is closed
            // This flag is set if the map was open when config was triggered from the map
             const mapShouldReopenAfterConfig = sessionStorage.getItem('boardinggate_map_should_reopen_after_config') === 'true';
             sessionStorage.removeItem('boardinggate_map_should_reopen_after_config'); // Consume flag

            // Reopen map ONLY if no other reminder-related modals are open
            if (mapShouldReopenAfterConfig &&
                !document.getElementById('unified-reminder-window')?.classList.contains('visible') &&
                !document.getElementById('reminders-location-map-modal') &&
                 !document.querySelector('.reminder-modal') &&
                 !document.querySelector('.reminder-table-modal') &&
                 !document.getElementById('postpone-options-modal') &&
                 !document.querySelector('.saved-locations-modal') &&
                 !document.getElementById('reminders-map-help-modal-instance')
               ) {
                 showAllRemindersLocationMap(); // Reopen the map
             }
        };
        closeBtn.addEventListener('click', closeConfigHandler);
        // Add auto-close timer to config modal (e.g., 3.5 minutes)
        addModalAutoCloseTimer(modal, closeBtn, 'config-modal', 210000);


        loadUData(); // Load user data into the form when the modal opens
        // Click the first tab button to show the default tab content
        const firstTabButton = modal.querySelector('.config-tab-button');
        if (firstTabButton) { firstTabButton.click(); }
    }

    // Function to parse the Latitude/Longitude filter input value
    function parseCoordinateFilter(inputValue) {
        const cleanedValue = inputValue.trim();
        // Return empty type if input is empty
        if (!cleanedValue) return { type: 'empty' };

        // Split input by whitespace and parse each part as float
        const parts = cleanedValue.split(/\s+/).map(p => parseFloat(p));

        // Check if any part is not a number
        if (parts.some(isNaN)) return { type: 'error', message: 'Contiene valores no numéricos.' };

        // Determine filter type based on number of numeric parts
        if (parts.length === 1) {
            return { type: 'single', value: parts[0] }; // Single value for approximate match
        } else if (parts.length === 2) {
            return { type: 'range', min: Math.min(parts[0], parts[1]), max: Math.max(parts[0], parts[1]) }; // Two values for a range
        } else {
            return { type: 'error', message: 'Demasiados valores. Usar 1 o 2.' }; // More than two values is invalid
        }
    }

    // Handler for importing radars from KML files
    async function handleImportRadars() {
        const importExtraCheckbox = document.getElementById('import-extra-radars-checkbox');
        // Define paths to KML file lists based on checkbox state
        const KML_FILES_LIST_STANDARD = './KLM/KLMFILES.TXT'; // Standard radars list
        const KML_FILES_LIST_EXTRA = './KLM/KLMFILES2.TXT'; // Extra radars list
        const KML_FILES_LIST_PATH = importExtraCheckbox.checked ? KML_FILES_LIST_EXTRA : KML_FILES_LIST_STANDARD;

        const KML_BASE_PATH = './KLM/'; // Base path for KML files
        const COORD_EPSILON = 0.000001; // Tolerance for checking if a coordinate already exists

        // Get filter input elements and status display elements
        const filterLatInput = document.getElementById('radar-filter-lat');
        const filterLonInput = document.getElementById('radar-filter-lon');
        const filterKeywordsInput = document.getElementById('radar-filter-keywords');
        const progressContainer = document.getElementById('radar-import-progress-container');
        const progressBar = document.getElementById('radar-import-progress-bar');
        const progressStatus = document.getElementById('radar-import-status');
        const isMobile = window.innerWidth < 768; // Simple mobile detection

        // Parse latitude and longitude filters
        const latFilterParsed = parseCoordinateFilter(filterLatInput.value);
        const lonFilterParsed = parseCoordinateFilter(filterLonInput.value);

        // Validate filters
        if (latFilterParsed.type === 'error') {
            if (!isMobile) showToast(`Error en filtro Latitud: ${latFilterParsed.message}`, "error");
            if (progressStatus) progressStatus.textContent = `Error en filtro Latitud: ${latFilterParsed.message}`;
            return;
        }
        if (lonFilterParsed.type === 'error') {
            if (!isMobile) showToast(`Error en filtro Longitud: ${lonFilterParsed.message}`, "error");
            if (progressStatus) progressStatus.textContent = `Error en filtro Longitud: ${lonFilterParsed.message}`;
            return;
        }

        // Parse keyword filter
        const filterKeywordsRaw = filterKeywordsInput.value.trim();
        const filterKeywords = filterKeywordsRaw ? filterKeywordsRaw.toUpperCase().split(/\s+/).filter(k => k) : []; // Split by space, filter empty strings, uppercase

        // Show progress elements
        if (progressContainer) progressContainer.style.display = 'block';
        if (progressBar) { progressBar.value = 0; progressBar.max = 1; } // Initialize progress bar
        if (progressStatus) progressStatus.textContent = 'Iniciando importación...';

        try {
            // Fetch the list of KML files
            const response = await fetch(KML_FILES_LIST_PATH, { cache: 'no-cache' });
            if (!response.ok) {
                throw new Error(`No se pudo cargar la lista de ficheros KML (${KML_FILES_LIST_PATH}): ${response.statusText}`);
            }
            const fileListText = await response.text();
            // Parse the list of files, skipping empty lines and comments
            const kmlFiles = fileListText.split('\n').map(f => f.trim()).filter(f => f && !f.startsWith('#'));

            if (kmlFiles.length === 0) {
                if (progressStatus) progressStatus.textContent = `No hay ficheros KML para importar en ${KML_FILES_LIST_PATH.split('/').pop()}.`;
                if (!isMobile) showToast(`No hay ficheros KML para importar en ${KML_FILES_LIST_PATH.split('/').pop()}.`, 'info');
                // Hide progress bar if no files
                if (progressContainer) progressContainer.style.display = 'block'; // Keep container visible to show the final message
                return;
            }

            if (progressBar) progressBar.max = kmlFiles.length; // Set max value for progress bar
            let totalImportedCount = 0; // Counter for total imported reminders
            let existingReminders = JSON.parse(localStorage.getItem('reminders') || '[]'); // Load existing reminders

            // Process each KML file sequentially
            for (let i = 0; i < kmlFiles.length; i++) {
                const kmlFileName = kmlFiles[i];
                // Update status message and progress bar value
                if (progressStatus) progressStatus.textContent = `Procesando fichero ${i + 1} de ${kmlFiles.length}: ${kmlFileName}...`;
                if (progressBar) progressBar.value = i + 1; // Update progress bar value based on file index
                await new Promise(resolve => setTimeout(resolve, 50)); // Small delay to allow UI update

                try {
                    // Fetch the KML file
                    const kmlResponse = await fetch(KML_BASE_PATH + kmlFileName, { cache: 'no-cache' });
                    if (!kmlResponse.ok) {
                        if (progressStatus) progressStatus.textContent += ` (Error carga: ${kmlResponse.statusText})`;
                        await sleep(1000); // Wait a bit on error
                        continue; // Skip to the next file
                    }
                    const kmlString = await kmlResponse.text();
                    const parser = new DOMParser();
                    const kmlDoc = parser.parseFromString(kmlString, "application/xml"); // Parse KML string

                    const placemarks = kmlDoc.getElementsByTagName('Placemark'); // Find all <Placemark> elements
                    let fileRecordsFound = placemarks.length; // Count records found in this file
                    let fileImportedCount = 0; // Count imported records from this file

                    // Process each Placemark
                    for (let j = 0; j < placemarks.length; j++) {
                        const placemark = placemarks[j];
                        const nameElement = placemark.getElementsByTagName('name')[0];
                        const coordinatesElement = placemark.getElementsByTagName('coordinates')[0];

                        if (!nameElement || !coordinatesElement) continue; // Skip if name or coordinates are missing

                        const name = nameElement.textContent.trim();
                        const coordsString = coordinatesElement.textContent.trim();
                        const coordsParts = coordsString.split(',');
                        if (coordsParts.length < 2) continue; // Skip if coordinates format is invalid
                        const lon = parseFloat(coordsParts[0]);
                        const lat = parseFloat(coordsParts[1]);
                        if (isNaN(lat) || isNaN(lon)) continue; // Skip if coordinates are not numbers

                        // Apply Lat/Lon filters
                        let passesLatFilter = true;
                        if (latFilterParsed.type === 'single') {
                            passesLatFilter = Math.abs(lat - latFilterParsed.value) < COORD_EPSILON; // Check if latitude is approximately the single value
                        } else if (latFilterParsed.type === 'range') {
                            passesLatFilter = lat >= latFilterParsed.min && lat <= latFilterParsed.max; // Check if latitude is within the range
                        }
                        if (!passesLatFilter) continue; // Skip if filter not passed

                        let passesLonFilter = true;
                        if (lonFilterParsed.type === 'single') {
                            passesLonFilter = Math.abs(lon - lonFilterParsed.value) < COORD_EPSILON; // Check if longitude is approximately the single value
                        } else if (lonFilterParsed.type === 'range') {
                            passesLonFilter = lon >= lonFilterParsed.min && lon <= lonFilterParsed.max; // Check if longitude is within the range
                        }
                        if (!passesLonFilter) continue; // Skip if filter not passed

                        // Apply keyword filter
                        if (filterKeywords.length > 0) {
                            const nameUpper = name.toUpperCase();
                             // Check if ANY of the keywords are included in the POI name (case-insensitive)
                            if (!filterKeywords.some(kw => nameUpper.includes(kw))) {
                                continue; // Skip if no keyword match
                            }
                        }

                        // Check if a reminder with these exact coordinates already exists to avoid duplicates
                        const alreadyExists = existingReminders.some(r =>
                            r.isLocationEnabled && r.locationCoordinates &&
                            Math.abs(r.locationCoordinates.latitude - lat) < COORD_EPSILON &&
                            Math.abs(r.locationCoordinates.longitude - lon) < COORD_EPSILON
                        );
                        if (alreadyExists) continue; // Skip if reminder already exists

                        // Create a new reminder object for the imported radar
                        const now = new Date();
                        const newRadarReminder = {
                            id: Date.now() + i * 10000 + j, // Generate a unique ID (timestamp + file index + item index)
                            text: `<b>RADAR: ${name.toUpperCase()}</b>`, // Prefix text with "RADAR:"
                            type: 'simple', // Simple type
                            time: '00:01', // Default time (midnight + 1 min)
                            date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`, // Current date
                            createdAt: now.toISOString(), // Creation timestamp
                            managedByUser: false, // Not managed yet
                            isLocationEnabled: true, // Location enabled
                            locationCoordinates: { latitude: lat, longitude: lon }, // Coordinates from KML
                            radiusMeters: 400, // Default radius for imported radars
                            excludeFromList: true // Mark as excluded from general list
                        };
                        existingReminders.push(newRadarReminder); // Add to the list
                        fileImportedCount++; // Increment file import count
                        totalImportedCount++; // Increment total import count
                    }
                     // Update status message for the current file
                    if (progressStatus) {
                         progressStatus.textContent = `${kmlFileName}: Encontrados ${fileRecordsFound}. Importados ${fileImportedCount} nuevos.`;
                         if (progressBar) progressBar.value = i + 1; // Update progress bar
                    }

                    // Show a toast notification for each file processed on non-mobile
                    if (fileImportedCount > 0 && !isMobile) showToast(`${kmlFileName}: ${fileImportedCount} nuevos radares importados.`, 'success', 2000);
                    await sleep(isMobile ? 500 : 200); // Pause briefly between files

                } catch (fileError) {
                    console.error(`Error processing KML file ${kmlFileName}:`, fileError);
                    // Update status message on file error
                    if (progressStatus) progressStatus.textContent = `Error en ${kmlFileName}: ${fileError.message.substring(0,50)}`;
                    await sleep(1000); // Wait longer on error
                }
            }
            // Save the updated list of reminders to localStorage after processing all files
            localStorage.setItem('reminders', JSON.stringify(existingReminders));
            // Final status updates
            if (progressBar) progressBar.value = kmlFiles.length; // Ensure progress bar is full
            if (progressStatus) progressStatus.textContent = `Importación completada. Total importados: ${totalImportedCount} nuevos radares.`;
            if (!isMobile) showToast(`Proceso finalizado. ${totalImportedCount} radares nuevos añadidos.`, 'info', 5000);
            // Update global reminder counts and check reminders
            updateReminderCount();
            updateButtonStyles();
             // checkReminders(); // Optionally re-check reminders after import
             // Hide progress bar container after completion (optional)
             // setTimeout(() => { if(progressContainer) progressContainer.style.display = 'none'; }, 5000);


        } catch (error) {
            console.error("Error during import process:", error);
            // Handle errors during the main process (e.g., fetching file list)
            if (progressStatus) progressStatus.textContent = `Error: ${error.message}`;
            if (!isMobile) showToast(`Error en importación: ${error.message}`, 'error', 5000);
             // Hide progress bar container on error (optional)
            // setTimeout(() => { if(progressContainer) progressContainer.style.display = 'none'; }, 5000);
        }
    }

    // Handler for deleting filtered radars
    async function handleDeleteFilteredRadars() {
        // Get filter inputs and status display
        const filterLatInput = document.getElementById('radar-filter-lat');
        const filterLonInput = document.getElementById('radar-filter-lon');
        const filterKeywordsInput = document.getElementById('radar-filter-keywords');
        const progressStatus = document.getElementById('radar-import-status'); // Use the same status element
        const isMobile = window.innerWidth < 768;

        // Parse filters
        const latFilterParsed = parseCoordinateFilter(filterLatInput.value);
        const lonFilterParsed = parseCoordinateFilter(filterLonInput.value);

        // Validate filters
        if (latFilterParsed.type === 'error') {
            if (!isMobile) showToast(`Error en filtro Latitud: ${latFilterParsed.message}`, "error");
            if (progressStatus) progressStatus.textContent = `Error en filtro Latitud: ${latFilterParsed.message}`;
            return;
        }
        if (lonFilterParsed.type === 'error') {
            if (!isMobile) showToast(`Error en filtro Longitud: ${lonFilterParsed.message}`, "error");
            if (progressStatus) progressStatus.textContent = `Error en filtro Longitud: ${lonFilterParsed.message}`;
            return;
        }

        // Parse keyword filter
        const filterKeywordsRaw = filterKeywordsInput.value.trim();
        const filterKeywords = filterKeywordsRaw ? filterKeywordsRaw.toUpperCase().split(/\s+/).filter(k => k) : [];

        // Check if any filter is active
        const isAnyFilterActive = latFilterParsed.type !== 'empty' || lonFilterParsed.type !== 'empty' || filterKeywords.length > 0;

        if (!isAnyFilterActive) {
            if (!isMobile) showToast("Define al menos un filtro (latitud, longitud o palabra clave) para borrar.", "warning");
            if(progressStatus) progressStatus.textContent = "Define al menos un filtro.";
            return;
        }

        // Confirm deletion action
        if (!confirm("¿Estás seguro que quieres borrar los recordatorios de ubicación que coincidan con TODOS los filtros activos?\n\n¡Esta acción no se puede deshacer!")) {
            if (!isMobile) showToast("Borrado cancelado.", "info");
            if(progressStatus) progressStatus.textContent = "Borrado cancelado.";
            return;
        }

        if(progressStatus) progressStatus.textContent = "Buscando y borrando recordatorios...";

        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        let deletedCount = 0; // Counter for deleted reminders

        // Filter reminders to keep only those that DO NOT match the criteria for deletion
        const remindersToKeep = reminders.filter(reminder => {
            // Only consider reminders with location enabled
            if (!reminder.isLocationEnabled || !reminder.locationCoordinates) {
                return true; // Keep reminders without location
            }

            // Check if reminder matches latitude filter
            let matchesLat = latFilterParsed.type === 'empty'; // Matches if filter is empty
            if (latFilterParsed.type === 'single') {
                matchesLat = Math.abs(reminder.locationCoordinates.latitude - latFilterParsed.value) < COORD_EPSILON;
            } else if (latFilterParsed.type === 'range') {
                matchesLat = reminder.locationCoordinates.latitude >= latFilterParsed.min && reminder.locationCoordinates.latitude <= latFilterParsed.max;
            }

            // Check if reminder matches longitude filter
            let matchesLon = lonFilterParsed.type === 'empty'; // Matches if filter is empty
            if (lonFilterParsed.type === 'single') {
                matchesLon = Math.abs(reminder.locationCoordinates.longitude - lonFilterParsed.value) < COORD_EPSILON;
            } else if (lonFilterParsed.type === 'range') {
                matchesLon = reminder.locationCoordinates.longitude >= lonFilterParsed.min && reminder.locationCoordinates.longitude <= lonFilterParsed.max;
            }

            // Check if reminder matches keyword filter
            let matchesKeywords = filterKeywords.length === 0; // Matches if filter is empty
            if (filterKeywords.length > 0) {
                const reminderTextUpper = reminder.text.toUpperCase().replace(/<b>|<\/b>/gi,'');
                 // Check if ANY keyword from the filter is included in the reminder text
                matchesKeywords = filterKeywords.some(kw => reminderTextUpper.includes(kw));
            }

            // A reminder is marked for deletion if it matches ALL active filters
            if (matchesLat && matchesLon && matchesKeywords) {
                deletedCount++; // Increment delete counter
                return false; // Do not keep this reminder
            }
            return true; // Keep this reminder
        });

        // If any reminders were deleted, update localStorage
        if (deletedCount > 0) {
            localStorage.setItem('reminders', JSON.stringify(remindersToKeep));
            if (!isMobile) showToast(`${deletedCount} recordatorios borrados.`, 'success');
            if(progressStatus) progressStatus.textContent = `${deletedCount} recordatorios borrados.`;
            updateReminderCount(); // Update global counts
            updateButtonStyles(); // Update button styles
             checkReminders(); // Re-check reminders after deletion
        } else {
            if (!isMobile) showToast("No se encontraron recordatorios que coincidan con los filtros.", 'info');
            if(progressStatus) progressStatus.textContent = "No se encontraron coincidencias.";
        }
         // Hide progress bar container after completion (optional)
         // setTimeout(() => { if(progressContainer) progressContainer.style.display = 'none'; }, 3000);
    }


    // Helper function for creating delays
    const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));


    // Function to show consistent toast notifications
    function showToast(message, type = 'info', duration = 3000) {
         // Remove any existing toast notification
        const existingToast = document.getElementById('toast-notification-element');
        if (existingToast) { existingToast.remove(); }

        // Create the toast element
        const toast = document.createElement('div');
        toast.id = 'toast-notification-element'; // Assign an ID
        toast.className = `toast-notification toast-${type}`; // Add base and type classes for styling
        toast.textContent = message; // Set the message text
        document.body.appendChild(toast); // Add to body

        // Use requestAnimationFrame to ensure the element is in the DOM before applying the 'show' class
        // This triggers the CSS transition for appearance.
        requestAnimationFrame(() => {
            requestAnimationFrame(() => { // Double rAF for some browsers
                toast.classList.add('show'); // Add class to start transition
            });
        });

        // Set timeout to hide and remove the toast
        setTimeout(() => {
            toast.classList.remove('show'); // Remove class to start hide transition
            // Remove the element after the hide transition completes
            toast.addEventListener('transitionend', () => {
                 if (toast.parentNode) { toast.parentNode.removeChild(toast); }
            }, { once: true }); // Use { once: true } to automatically remove the listener after it runs once
        }, duration); // Hide after the specified duration
    }


    // --- Date and Time Formatting Helpers ---

    // Format date string (YYYY-MM-DD) to DD Mon YY (e.g., 01 Ene 24)
    function formatDateToDDMMMYY(dateString) {
         if (!dateString) return '-';
         try {
             const [year, month, day] = dateString.split('-').map(Number);
             // Create date object assuming UTC components for consistency
             const date = new Date(Date.UTC(year, month - 1, day));
             if (isNaN(date.getTime())) return '-'; // Handle invalid date

             const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
             const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
             const monthName = monthNames[date.getUTCMonth()];
             const yearShort = String(date.getUTCFullYear()).slice(-2); // Get last two digits of year

             return `${dayOfMonth} ${monthName} ${yearShort}`;
         } catch (e) {
             console.error("Error formatting date to DDMMMYY:", e, dateString);
             return '-'; // Return placeholder on error
         }
    }
    // Format date string (YYYY-MM-DD) to DD-MonthName-YYYY (e.g., 01-Enero-2024)
    function formatDateDetailed(dateString) {
        if (!dateString || !dateString.match(/^\d{4}-\d{2}-\d{2}$/)) return '-'; // Basic format check
        try {
            const [year, month, day] = dateString.split('-').map(Number);
             // Create date object assuming UTC components
            const date = new Date(Date.UTC(year, month - 1, day));
            if (isNaN(date.getTime())) return dateString; // Return original string if invalid but parsable somehow

            const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
            const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
            const monthName = monthNames[date.getUTCMonth()];
            const fullYear = date.getUTCFullYear();

            return `${dayOfMonth}-${monthName}-${fullYear}`;
        } catch (e) {
            console.error("Error formatting date detailed:", e, dateString);
            return dateString; // Return original string on error
        }
    }
    // Format time string (HH:MM) and add a period of day description
    function formatTimeWithPeriod(timeString) {
         if (!timeString || !timeString.match(/^\d{2}:\d{2}$/)) return '-'; // Basic format check
         try {
             const [hourStr, minuteStr] = timeString.split(':');
             const hour = parseInt(hourStr);
             const minute = parseInt(minuteStr);
              // Validate hour and minute values
             if (isNaN(hour) || isNaN(minute) || hour < 0 || hour > 23 || minute < 0 || minute > 59) {
                 return timeString; // Return original string if values are invalid
             }
             let period = '';
             if (hour >= 22 || hour < 5) { period = 'de la Noche'; }
             else if (hour >= 5 && hour < 12) { period = 'de la Mañana'; }
             else if (hour >= 12 && hour < 14) { period = 'del Mediodía'; }
             else { period = 'de la Tarde'; }

             return `${hourStr}:${minuteStr} (${period})`;
         } catch (e) {
             console.error("Error formatting time with period:", e, timeString);
             return timeString; // Return original string on error
         }
    }

// --- Modal Auto-Close Timer Logic ---
// Object to hold references to active modal timers
let globalModalTimers = {};

// Function to add an auto-close timer to a modal
function addModalAutoCloseTimer(modalElement, closeButtonElement, modalId, duration = 60000) {
    // Validate inputs
    if (!modalElement || !closeButtonElement || !modalId) {
        console.error("addModalAutoCloseTimer: Invalid arguments", {modalElement, closeButtonElement, modalId, duration});
        return;
    }
     // Store the modal ID on the element for easy lookup during clearing
    modalElement.dataset.modalTimerId = modalId;

    // Clear any existing timer for this modal ID
    clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId);

    let countdown = duration / 1000; // Countdown in seconds
    const originalButtonText = closeButtonElement.textContent.split(' (')[0]; // Get original button text without countdown
    const countdownSpanId = `modal-countdown-${modalId}`; // Unique ID for the span

    // Find or create the countdown span element
    let countdownSpan = closeButtonElement.querySelector(`.button-countdown-timer[data-modal-id="${modalId}"]`);
    if (!countdownSpan) {
        countdownSpan = document.createElement('span');
        countdownSpan.className = 'button-countdown-timer';
        countdownSpan.dataset.modalId = modalId; // Link span to modal ID
        countdownSpan.style.marginLeft = '5px';
        countdownSpan.style.fontWeight = 'normal'; // Normal weight for the number
        closeButtonElement.appendChild(countdownSpan);
    }
    // Set initial countdown text
    countdownSpan.textContent = ` (${countdown})`;

    // Set up the interval timer
    const intervalId = setInterval(() => {
        countdown--;
        // Update countdown display only if the span is still in the document
        if (countdownSpan && document.body.contains(countdownSpan)) {
          countdownSpan.textContent = ` (${countdown})`;
        }
        // If countdown reaches 0, trigger the close action
        if (countdown <= 0) {
            // Clear the timer explicitly
            if (globalModalTimers[modalId]) {
                clearInterval(globalModalTimers[modalId].intervalId);
                delete globalModalTimers[modalId]; // Remove from tracking object
            }
             // Trigger the close button click if the button is still in the document
            if (closeButtonElement && document.body.contains(closeButtonElement)) {
                closeButtonElement.click();
            } else if (modalElement && modalElement.parentNode) {
                 // As a fallback, remove the modal element directly if the button is gone
                modalElement.parentNode.removeChild(modalElement);
            }
        }
    }, 1000); // Update every second

    // Function to reset the timer
    const resetTimerHandler = () => {
         // Do nothing if the timer has already been cleared
        if (!globalModalTimers[modalId] || !globalModalTimers[modalId].intervalId) {
             // console.log(`Timer ${modalId} already cleared, cannot reset.`);
            return;
        }
        // Clear the current interval
        clearInterval(globalModalTimers[modalId].intervalId);
        // Reset the countdown value
        countdown = duration / 1000;
        // Update the display immediately
        if (countdownSpan && document.body.contains(countdownSpan)) {
           countdownSpan.textContent = ` (${countdown})`;
        }
        // Start a new interval
        const newIntervalId = setInterval(() => {
            countdown--;
            if (countdownSpan && document.body.contains(countdownSpan)) {
                countdownSpan.textContent = ` (${countdown})`;
            }
            if (countdown <= 0) {
                if (globalModalTimers[modalId]) {
                    clearInterval(globalModalTimers[modalId].intervalId);
                    delete globalModalTimers[modalId];
                }
                if (closeButtonElement && document.body.contains(closeButtonElement)) {
                    closeButtonElement.click();
                } else if (modalElement && modalElement.parentNode) {
                    modalElement.parentNode.removeChild(modalElement);
                }
            }
        }, 1000);
        // Update the intervalId reference in the tracking object
        globalModalTimers[modalId].intervalId = newIntervalId;
        // console.log(`Timer ${modalId} reset.`);
    };

    // Add event listeners to the modal element to reset the timer on user interaction
    modalElement.addEventListener('click', resetTimerHandler);
    modalElement.addEventListener('touchstart', resetTimerHandler, { passive: true }); // Use passive: true for touchstart if it doesn't prevent scrolling
    modalElement.addEventListener('input', resetTimerHandler); // Reset on input in form elements
    modalElement.addEventListener('scroll', resetTimerHandler, { passive: true }); // Reset on scroll


    // Store timer information in the global tracking object
    globalModalTimers[modalId] = {
        intervalId: intervalId,
        resetHandler: resetTimerHandler, // Store handler reference to remove it later
        modalElement: modalElement,
        closeButtonElement: closeButtonElement,
        countdownSpan: countdownSpan // Store span reference
    };
    // console.log(`Timer added for modal ${modalId} with duration ${duration}ms.`);
}

// Function to clear an auto-close timer for a specific modal
function clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId) {
     // Determine the modal ID to clear
    const timerIdToClear = modalId || (modalElement ? modalElement.dataset.modalTimerId : null);

    if (timerIdToClear && globalModalTimers[timerIdToClear]) {
        // Clear the interval
        clearInterval(globalModalTimers[timerIdToClear].intervalId);
        const timerData = globalModalTimers[timerIdToClear];
         // Remove event listeners from the modal element
        if (timerData.modalElement && timerData.resetHandler) {
            timerData.modalElement.removeEventListener('click', timerData.resetHandler);
            timerData.modalElement.removeEventListener('touchstart', timerData.resetHandler);
            timerData.modalElement.removeEventListener('input', timerData.resetHandler);
            timerData.modalElement.removeEventListener('scroll', timerData.resetHandler);
        }
         // Remove the countdown span from the button
        if (timerData.countdownSpan && timerData.countdownSpan.parentNode) {
            timerData.countdownSpan.remove();
        }
        // Remove the timer from the global tracking object
        delete globalModalTimers[timerIdToClear];
        // console.log(`Timer cleared for modal ${timerIdToClear}.`);
    }
     // Also clean up any orphaned countdown spans from the button element
    if(closeButtonElement){
        closeButtonElement.querySelectorAll('.button-countdown-timer').forEach(s => s.remove());
    }
     // Remove the data attribute linking modal element to timer ID
     if(modalElement && modalElement.dataset.modalTimerId) {
        delete modalElement.dataset.modalTimerId;
    }
}


    // --- Application Initialization ---

    // Main initialization function
    async function initializeApp() {
         // Reset map active state flag
        isRemindersLocationMapActive = false;
        // Render the initial grid of buttons
        renderGrid();
        // Create other main buttons (ON/OFF, Settings, Edit)
        createOtherButtons();
        // Render toggle buttons state (if applicable, currently handled by loadSavedSettings)
        renderToggleButtons();
        // Attempt to update the version information from remote source
        try { await updateVersion(); } catch (e) { console.error("Error updating version:", e); }
        // Load saved settings (dark mode, on/off state, filter value)
        loadSavedSettings();
        // Load notices and start rotation (if applicable)
        try { await loadNotices(); startNoticeRotation(); } catch (e) { console.error("Error loading notices:", e); }

        // Start the reminder check interval if not already running
        if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
        checkReminders(); // Perform an immediate check
        reminderCheckIntervalId = setInterval(checkReminders, currentCheckIntervalDuration); // Start the interval


        // Add event listener to the reminder count globe to open the table
        const noticeToggleIcon = document.getElementById('notice-toggle-icon'); // Assuming noticeToggleIcon exists
        if (noticeToggleIcon) noticeToggleIcon.addEventListener('click', toggleNotices);

        const countEl = document.getElementById('reminder-count-globe');
        if (countEl) {
             // Prevent opening the table if in edit/assignment mode
             const openTable = (e) => {
                 if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
                 e.preventDefault(); e.stopPropagation(); // Prevent potential default actions
                 showAllReminders(); // Open the reminder table
             };
             countEl.addEventListener('click', openTable);
             countEl.style.cursor = 'pointer'; // Indicate it's clickable
        }

        // Add event listeners for the grid filter input and clear button
        const filterInput = document.getElementById('grid-filter-input');
        const clearButton = document.getElementById('clear-filter-button');
        if (filterInput) {
            filterInput.addEventListener('input', () => {
                 localStorage.setItem('gridFilterValue', filterInput.value); // Save filter value
                 filterGridItems(); // Apply filter
                 if(isKeywordAssignmentMode) applyInitialKeywordHighlights(); // Re-apply highlights in keyword mode
            });
        }
        if (clearButton) {
            clearButton.addEventListener('click', () => {
                 if (filterInput) filterInput.value = '';
                 localStorage.removeItem('gridFilterValue'); // Remove saved filter value
                 filterGridItems(); // Clear filter
                 if(isKeywordAssignmentMode) applyInitialKeywordHighlights(); // Re-apply highlights
            });
        }

        // Initial adjustment of button positions (like the globe)
        adjustButtonPositions();
        // Re-adjust on window resize
        window.addEventListener('resize', adjustButtonPositions);
        // Initial check for versions icon opacity
        checkVersionsIconOpacity();
    }

    // Event listener for DOM content loaded
    document.addEventListener('DOMContentLoaded', async () => {
         loadCustomData(); // Load custom grid data and settings first

         // Check for PIN protection
         storedPin = localStorage.getItem('password_pin');
         const savedPasswordActive = localStorage.getItem('password_active');
         isPasswordActive = savedPasswordActive ? JSON.parse(savedPasswordActive) : false;

         if (isPasswordActive && storedPin) {
             promptForPin(); // If PIN is active, prompt user for it
         } else {
             // If PIN is not active or not set, initialize the app directly
             await initializeApp();
         }

         // Add event listener for beforeunload to perform cleanup and save state
         window.addEventListener('beforeunload', () => {
             // Clear intervals
             if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
             if (locationWatchId !== null) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }

             // Clean up editing state markers/classes
             if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
             if (dragTargetElement) { // Clean up if drag was in progress
                 dragTargetElement.classList.remove('dragging');
                 dragTargetElement.style.position = '';
                 dragTargetElement.style.zIndex = '';
                 dragTargetElement.style.width = '';
                 dragTargetElement.style.height = '';
                 dragTargetElement.style.pointerEvents = '';
             }
              if (dragPlaceholderElement && dragPlaceholderElement.parentNode) { dragPlaceholderElement.parentNode.removeChild(dragPlaceholderElement); }
              const dragHelper = document.querySelector('.drag-helper');
              if (dragHelper && dragHelper.parentNode) { dragHelper.parentNode.removeChild(dragHelper); }
              document.body.style.cursor = 'default';


             // Clear any active modal auto-close timers
             Object.keys(globalModalTimers).forEach(modalId => {
                const timerData = globalModalTimers[modalId];
                if (timerData) {
                     // Pass modalElement and closeButtonElement if available, though clearModalAutoCloseTimer can often find them by ID
                    clearModalAutoCloseTimer(timerData.modalElement, timerData.closeButtonElement, modalId);
                }
             });
             globalModalTimers = {}; // Ensure the tracking object is empty

             // Clear specific modal intervals if they weren't managed by globalModalTimers
             const openReminderModal = document.querySelector('.reminder-modal');
             if (openReminderModal && openReminderModal.autoCloseInterval) { clearInterval(openReminderModal.autoCloseInterval); }
             const openTableModal = document.querySelector('.reminder-table-modal');
             if(openTableModal && openTableModal.autoCloseInterval) { clearInterval(openTableModal.autoCloseInterval); }
             const openPostponeModal = document.getElementById('postpone-options-modal');
             if(openPostponeModal && openPostponeModal.autoPostponeInterval) { clearInterval(openPostponeModal.autoPostponeInterval); }
             const openConfigModal = document.getElementById('config-modal');
             if(openConfigModal && openConfigModal.autoCloseInterval) { clearInterval(openConfigModal.autoCloseInterval); }
             const openHelpModal = document.querySelector('.help-modal, .versions-modal-overlay, #reminders-map-help-modal-instance'); // Generic check
              if (openHelpModal) {
                  const closeBtn = openHelpModal.querySelector('button'); // Assuming close button exists
                  if (closeBtn) clearModalAutoCloseTimer(openHelpModal, closeBtn, openHelpModal.id); // Attempt to clear by ID
              }
             const openSavedLocationsModal = document.querySelector('.saved-locations-modal');
             if (openSavedLocationsModal) {
                  const closeBtn = openSavedLocationsModal.querySelector('#close-saved-locations-modal');
                  if (closeBtn) clearModalAutoCloseTimer(openSavedLocationsModal, closeBtn, openSavedLocationsModal.id);
             }
              const openSavedRoutesModal = document.getElementById('saved-routes-modal');
              if (openSavedRoutesModal) {
                  const closeBtn = openSavedRoutesModal.querySelector('#close-saved-routes-modal');
                  if (closeBtn) clearModalAutoCloseTimer(openSavedRoutesModal, closeBtn, openSavedRoutesModal.id); // Use modal ID or button ID
              }


             // Clean up any active map instances from modals
             if (reminderModalMap) try {reminderModalMap.remove();} catch(e){} reminderModalMap = null; reminderModalMarker = null;
              if (locationPickerMap) try {locationPickerMap.remove();} catch(e){} locationPickerMap = null; locationPickerMarker = null;
              Object.values(previewMaps).forEach(map => {try {map?.remove();} catch(e){}}); previewMaps = {};

             // Clean up the main map instance if it's open
             const openAllLocationsMapModal = document.getElementById('reminders-location-map-modal');
             if (openAllLocationsMapModal && allLocationsMapInstance) {
                // Clear geolocation watch again for certainty
                if (locationWatchId !== null) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
                // Remove LRM controls
                 if (navigationRoutingControl && allLocationsMapInstance.hasControl(navigationRoutingControl)) try { allLocationsMapInstance.removeControl(navigationRoutingControl); } catch(e){} navigationRoutingControl = null;
                 if (routePreviewControl && allLocationsMapInstance.hasControl(routePreviewControl)) try { allLocationsMapInstance.removeControl(routePreviewControl); } catch(e){} routePreviewControl = null;
                 routeLineForProgress = null; totalRouteDistance = 0; userMarkerForRoute = null; simpleWaypointMarkers = []; startRouteMarkerVisual = null; allMapMarkers = [];

                // Remove orientation control
                 if (orientationAltitudeControl && allLocationsMapInstance.hasControl(orientationAltitudeControl)) try { allLocationsMapInstance.removeControl(orientationAltitudeControl); } catch(e){} orientationAltitudeControl = null;

                // Remove user position markers/circles
                 if (initialUserLocationMarker) try { initialUserLocationMarker.remove(); } catch(e){} initialUserLocationMarker = null; initialUserLocationMarkerLat = null; initialUserLocationMarkerLng = null;
                 if (initialUserLocationCircle) try { initialUserLocationCircle.remove(); } catch(e){} initialUserLocationCircle = null;

                // Remove the map instance itself
                try {allLocationsMapInstance.remove();} catch(e){} allLocationsMapInstance = null;
             }
              // Remove the modal overlay if any modal was open
              const modalOverlay = document.querySelector('.modal-overlay');
              if (modalOverlay) modalOverlay.style.display = 'none';


             // Save edit mode state (grid order, custom data) if currently in edit mode
             if (isAssignmentMode || isEditMode || isKeywordAssignmentMode) { saveCustomData(); }

             // Save filter value
             const filterInput = document.getElementById('grid-filter-input');
             if (filterInput && filterInput.value.trim()) {
                  localStorage.setItem('gridFilterValue', filterInput.value);
             } else {
                  localStorage.removeItem('gridFilterValue');
             }
              // Save general settings (dark mode, on/off state)
              saveSettings();

         });
    });

</script>
</body>
</html>