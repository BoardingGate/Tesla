CHECK 46
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <title>BoardingGate</title>
    <link rel="icon" href="https://boardinggate.github.io/Tesla/th.jpeg" type="image/jpeg">
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">                                                                                                                                                                                                                                          import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";   import { getFirestore, doc, setDoc, getDoc, getDocs, deleteDoc, collection, serverTimestamp, where, query, orderBy, limit, addDoc, writeBatch } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js"; console.log("Firebase Init Script: STARTING initialization.");   const firebaseConfig = {apiKey: "AIzaSyCEAWL1Pj1OMBrGnXLOS79W3iDjMkmTQGw",authDomain: "boardinggate-1df74.firebaseapp.com",databaseURL: "https://boardinggate-1df74-default-rtdb.europe-west1.firebaseio.com",projectId: "boardinggate-1df74",storageBucket: "boardinggate-1df74.appspot.com", messagingSenderId: "771541345352",appId: "1:771541345352:web:0447d72b3383875ac5a47d" };    try {    const app = initializeApp(firebaseConfig);     window.db = getFirestore(app);   window.doc = doc;  window.setDoc = setDoc;  window.getDoc = getDoc;  window.collection = collection; window.getDocs = getDocs;  window.deleteDoc = deleteDoc;  window.serverTimestamp = serverTimestamp;  window.where = where; window.query = query; window.orderBy = orderBy;window.limit = limit; window.addDoc = addDoc;  window.writeBatch = writeBatch; console.log("Firebase Init Script: SUCCESS Firestore initialized and functions exposed globally. window.db is:", window.db);  } catch (e) { console.error("Firebase Init Script: ERROR during initialization!", e); }  console.log("Firebase Init Script: END of initialization block.");</script>

<script src="//cdn.jsdelivr.net/npm/eruda"></script>
<script>eruda.init();</script>
   
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://unpkg.com/leaflet-geometryutil@0.10.3/src/leaflet.geometryutil.js"></script>
   
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.css' rel='stylesheet' />
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.js'></script>
    
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>                                                                                                                                                                                                                                               <script async src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCEAWL1PjlOMBrGnXLOS79W3iDJMkmTQGw&v=beta&libraries=places&callback=initMap&loading=async"></script> <script>   function initMap() {} </script>
 </head>
<style>  

body {
    display: flex; flex-direction: column; min-height: 100vh;
    background-color: #ABAB99; margin: 0; overflow-x: hidden;}

body.dark-mode {background-color: #92927E;}

#radar-speed-selection-modal {  z-index: 7500 !important;}
    
main {
    position: relative;
    margin: 0 auto 0.5rem 60px; margin-top: 76px;
    background-color: transparent; border-radius: 0.75rem;
    padding: 16px; min-height: 400px;
    max-width: 984px; width: 100%;
    transition: margin-top 0.5s ease-in-out;}

footer {
    margin: 0.5rem auto; margin-left: 145px;
    text-align: center; max-width: 984px; width: 100%;
    display: block; background-color: #ABAB99;
    transition: margin-top 0.5s ease-in-out;}

body.dark-mode footer {background-color: #92927E;}

.footer-content {
    color: #5C5C47; padding: 0.5rem; margin: 0 auto;
    max-width: 100%; position: relative;}

.footer-subtext {
    font-size: 0.75rem; color: #5C5C47; margin-top: 0.25rem; text-align: center;}

.footer-link-green {color: #5C5C47; text-decoration: none;
    transition: color 0.2s ease;}
.footer-link-green:hover {   color: #5C5C47;}
.footer-line {
    display: flex; justify-content: center; align-items: center;
    gap: 0.5rem; flex-wrap: wrap;}
.hidden, .footer-hidden {    display: none !important;}
.header-container {
    display: flex; align-items: center; justify-content: center;
    gap: 0.5rem; background-color: #ABAB99; padding: 0.5rem;}

body.dark-mode .header-container {  background-color: #92927E;}
.header-logo {
    width: 100px; height: 70px;   transition: filter 0.2s ease;}
body.dark-mode .header-logo {  filter: brightness(85%);}
.title-container {
    background-color: #ABAB99; padding: 0.5rem 1rem;
    border-radius: 0.5rem; display: inline-block;}
body.dark-mode .title-container   background-color: #92927E;}
.header-container h1 {   color: #5C5C47;}

.version-text {
    font-size: 0.75rem; color: #5C5C47;  font-weight: normal;}
#bookmark-grid {
    display: grid; grid-template-columns: repeat(6, minmax(120px, 1fr));
    gap: 15px; background-color: transparent;
    border-radius: 0.75rem; position: relative;
    width: 970px; max-width: 970px;    margin: 0 auto 0 85px;  transition: all 0.3s ease;}
@media (max-width: 1024px) {
    #bookmark-grid {
        width: 100%; margin: 0 auto 0 70px;
        grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));  }}
#bookmark-grid > div {
    height: auto; aspect-ratio: 16 / 9;   transition: all 0.3s ease;}
.bookmark-item {
    width: 100%; height: 100%; position: relative; cursor: pointer;
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    border-radius: 0.5rem;
    box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1);
    transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease;}

.bookmark-item:hover:not(.editing-active *):not(.assignment-active *):not(.dragging *):not(.editing-target *):not(.keyword-assignment-active *) {
    transform: scale(1.05) translateY(-1px);
    box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.6), -6px -6px 12px rgba(255, 255, 255, 0.15);}
.bookmark-item img {
    image-rendering: crisp-edges; width: 36px; height: auto;
    max-width: 40px; border-radius: 0.25rem;}
.bookmark-name {
    font-size: clamp(0.85rem, 1.5vw, 1.15rem); font-weight: bold;
    color: #333; text-align: center; margin-top: 4px;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    max-width: 100%;}
body.dark-mode .bookmark-item {  filter: brightness(60%);}
.empty-slot {
    width: 100%; height: 100%; cursor: default;
    display: flex; justify-content: center; align-items: center;
    border: 1px dashed #ccc; border-radius: 0.5rem;
    background-color: rgba(200, 200, 200, 0.1); color: #aaa;
    transition: background-color 0.2s ease, outline 0.2s ease, box-shadow 0.2s ease;}

.empty-slot span {font-size: 2rem; pointer-events: none;}

body.dark-mode .empty-slot {  border-color: #666; color: #777;
    background-color: rgba(100, 100, 100, 0.2);}
.toggle-image,
.toggle-sign {
    width: 135px; height: 74px; margin-bottom: 2px;
    box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.4);
    border: 1px solid #7c7c68; border-radius: 35px;
    position: fixed; left: 10px; top: 90px;
    z-index: 1000; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    background-color: #ABAB99;
    transition: background-color 0.2s ease, filter 0.2s ease, top 0.3s ease, border 0.2s ease;}
.toggle-sign {
    font-weight: bold; font-size: 1.25rem;    color: #000000; text-align: center;}
.toggle-sign .sign {    font-size: 1.5rem; margin-right: 2px;}
.toggle-sign img,
.toggle-image img {
    max-width: 70%; max-height: 70%;  object-fit: contain;}
.toggle-sign:not(.range-toggle):not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *):hover {
    background-color: #D9A066;}
.toggle-sign.range-toggle:not([data-state="hidden"]):not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *):hover {
    background-color: #D9A066;}
.toggle-image:hover { filter: brightness(80%);}
.toggle-sign.range-toggle[data-state="hidden"] {  background-color: #ABAB99; color: #7F7F7F;}
body.dark-mode .toggle-sign.range-toggle[data-state="hidden"] {
    background-color: #ABAB99; color: #A0A0A0;}
body.dark-mode .toggle-sign:not(.range-toggle):not(#password-toggle-button),
body.dark-mode .toggle-image,
body.dark-mode .toggle-sign.range-toggle:not([data-state="hidden"]) {
    filter: brightness(85%); background-color: #ABAB99;}
body.dark-mode .toggle-sign:not(.range-toggle):hover:not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *),
body.dark-mode .toggle-sign.range-toggle:not([data-state="hidden"]):hover:not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *) {
    background-color: #ABAB99;}
.scroll-toggle-button {
    position: fixed; left: 10px; top: 10px;
    width: 110px !important; height: clamp(75px, 20vw, 130px) !important;
    background-color: #ABAB99; border-radius: 60px;
    display: flex; flex-direction: column; align-items: center; justify-content: space-between;
    padding: clamp(10px, 2vw, 20px); cursor: pointer;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.4) !important;
    border: 1px solid #808080 !important; z-index: 1001;
    transition: background-color 0.2s ease;}
.scroll-toggle-button:hover {   background-color: #668B8B;}
.scroll-toggle-button svg {
    width: clamp(24px, 4vw, 32px); height: clamp(24px, 4vw, 32px);
    stroke: #E6E6DC;}
#config-button, #personal-button, #radar-button,
#home-button, #reload-button, #keyword-assignment-button,
#password-toggle-button, #versions-button, #info-button {
    width: auto !important; height: auto !important;
    background-color: transparent !important; border: none !important;
    box-shadow: none !important; padding: 5px !important;
    position: absolute !important; top: 37px !important;
    z-index: 900 !important; cursor: pointer; border-radius: 50%;
    transition: transform 0.1s ease, background-color 0.2s ease, box-shadow 0.2s ease, border 0.2s ease;}
#config-button { left: 185px !important; }
#personal-button { left: 260px !important; }
#radar-button { left: 330px !important; }
#home-button { left: 400px !important; }
#reload-button { left: 470px !important; }
#keyword-assignment-button { left: 555px !important; }
#password-toggle-button { left: 1080px !important; top: 25px; }
#info-button { left: 1027px !important; max-width: 30px !important; max-height: 30px !important; }
#versions-button { left: 969px !important; max-width: 30px !important; max-height: 30px !important; }
#config-button img {
    max-width: 52px !important; max-height: 52px !important;
    width: 52px; height: 52px; object-fit: contain;
    display: block; filter: none !important;}

#personal-button img, #radar-button img,
#home-button img, #reload-button img,
#keyword-assignment-button img {
    max-width: 46px !important; max-height: 46px !important;
    width: 46px; height: 46px; object-fit: contain;
    display: block; filter: none !important;}

#versions-button img, #info-button img,
#password-toggle-button img {
    max-width: 53px !important; max-height: 37px !important;
    width: 40px; height: 37px; object-fit: contain; display: block;}
#password-toggle-button img {  filter: brightness(85%) !important; top: 25px;}
#versions-button img { transition: opacity 0.5s ease;}
#config-button:hover, #personal-button:hover, #radar-button:hover,
#home-button:hover, #reload-button:hover,
#keyword-assignment-button:hover:not(.active),
#password-toggle-button:hover,
#versions-button:hover:not(.versions-icon-dimmed),
#info-button:hover {
    transform: scale(1.1); background-color: rgba(255, 255, 255, 0.2);}
#personal-button.editing {
    border: 3px solid yellow !important;
    box-shadow: 0 0 10px yellow !important;}
#personal-button.assigning {
    border: 3px solid cyan !important;
    box-shadow: 0 0 10px cyan !important;}
#keyword-assignment-button.active {
    border: 3px solid yellow !important;
    box-shadow: 0 0 10px yellow !important;
    transform: scale(1.05); background-color: transparent !important;}
body.dark-mode #keyword-assignment-button.active {
    border-color: yellow !important;
    box-shadow: 0 0 10px yellow !important;}
.keyword-assignment-active .grid-cell:hover:not(.editing-active *):not(.assignment-active *):not(.dragging *):not(.editing-target *):not(.keyword-assigned-highlight) {
    transform: scale(1.05) translateY(-1px);
    box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.6), -6px -6px 12px rgba(255, 255, 255, 0.15);
    outline: 3px dashed #10B981; cursor: crosshair;}
.keyword-assignment-active .grid-cell.editing-target {
    outline: 3px solid #10B981 !important; outline-offset: 1px;
    box-shadow: 0 0 8px #10B981;}
.keyword-assignment-active .grid-cell.keyword-assigned-highlight {
    outline: 3px solid yellow !important; outline-offset: 1px;
    box-shadow: 0 0 8px yellow; cursor: crosshair;}
#grid-filter-container {
    position: absolute; top: 43px; left: 615px;
    display: flex; align-items: center; z-index: 900;}
#grid-filter-input {
    padding: 8px 12px; border: 1px solid #7c7c68;
    border-radius: 4px; font-size: 1.3rem; font-weight: bold;
    height: 45px; width: 160px; background-color: #f0f0e0;}
body.dark-mode #grid-filter-input {
    background-color: #a0a090; color: #e0e0e0;    border-color: #666;}
#clear-filter-button {
    background: none; border: none; cursor: pointer;
    padding: 0 8px; margin-left: -35px;
    font-size: 1.6rem; color: #555; height: 40px;
    line-height: 40px; z-index: 901; display: none;}
body.dark-mode #clear-filter-button {   color: #bbb;}
body.dark-mode #user-id-display {
    color: #E6E6DC; background-color: rgba(146, 146, 126, 0.7);
    opacity: 0.7; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6);}
.notices-icon-container {
    display: flex; align-items: center; justify-content: center;
    width: 100%; max-width: 984px; margin: 0 auto;
    margin-left: 165px; position: relative;
    transition: margin-top 0.5s ease-in-out;}
.notices-container {
    flex-grow: 1; padding: 0.5rem; border: none;
    border-radius: 0.5rem; overflow: hidden;
    display: flex; align-items: center; justify-content: center;
    gap: 0; margin-left: 2px; height: 3rem;}
.notice-wrapper {
    padding: 0.5rem; height: 1.5rem;
    flex-grow: 1; overflow: hidden; position: relative;
    display: flex; align-items: center; justify-content: center;}
.notice {
    color: #E6E6DC; font-size: 1.3rem; font-weight: bold;
    white-space: nowrap; text-align: center;
    opacity: 0; animation: fadeInOut 14s infinite;}
@keyframes fadeInOut {
    0% { opacity: 1; }
    10% { opacity: 1; }
    90% { opacity: 1; }
    100% { opacity: 0; }}
.notice-off-icon {
    width: auto; height: clamp(4rem, 7vw, 6rem);
    margin-right: 10px; align-self: center;
    cursor: pointer; transition: filter 0.3s ease;}
body.dark-mode .notice-off-icon {  filter: brightness(85%);}
#reminder-button {
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;
    position: fixed; background-color: #ABAB99;}
#reminder-button img {  object-fit: contain;}
#reminder-button .reminder-count {
    position: absolute; top: 6px; left: 8px;
    background-color: #EF4444; color: #FFFFFF;
    border-radius: 55%; padding: 4px 10px;
    font-size: 1.1rem; font-weight: bold; line-height: 1;
    display: flex; align-items: center; justify-content: center;
    z-index: 1500; min-width: 1.9rem;
    max-width: 2.5rem; text-align: center;}
.reminder-count-globe {
    position: fixed; top: 10px; left: 10px;
    background-color: #2563EB; color: white;
    border-radius: 65%; padding: 10px 15px;
    font-size: 1.3rem; font-weight: bold;
    z-index: 1500;
    transition: margin-top 0.5s ease-in-out;}
#unified-reminder-window {
    position: fixed; top: 35px; left: 180px; transform: none;
    background-color: #FFFF99; border-radius: 1.5rem;
    border: 2px solid #ABAB99; box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
    z-index: 7000; max-width: 550px; width: 95%;
    max-height: 85vh; overflow: hidden;
    display: flex; flex-direction: column;
    transition: opacity 0.3s ease-out, transform 0.3s ease-out;}
#unified-reminder-window:not(.visible) {
    opacity: 0; transform: scale(0.9);  pointer-events: none;}
#unified-reminder-window.visible {
    opacity: 1; transform: scale(1);pointer-events: auto;}
.reminder-count-header {
    padding: 0.8rem 1.5rem; text-align: center;
    font-weight: bold; color: #0000FF;
    border-bottom: 1px solid #ABAB99; flex-shrink: 0;
    display: flex; align-items: center; justify-content: space-between;
    flex-wrap: wrap; gap: 0px 10px; position: relative;}
.reminder-title-container {
    display: flex; flex-direction: column; align-items: center; flex-grow: 1;}
.reminder-title-container > span:first-child {   font-size: 1.3rem;}
.reminder-title-container .swipe-hint {   font-size: smaller;}
#reminder-swiper-container {
    display: flex; overflow-x: auto;
    scroll-snap-type: x mandatory; -webkit-overflow-scrolling: touch;
    scroll-behavior: smooth; flex-grow: 1;
    touch-action: pan-x;}
.reminder-slide {
    flex: 0 0 100%; scroll-snap-align: start; padding: 1.5rem;
    box-sizing: border-box; display: flex; flex-direction: row;
    gap: 1rem; overflow-y: auto; align-items: flex-start;
    max-height: calc(85vh - 60px);}
.reminder-slide-content {
    display: flex; flex-direction: column; flex-grow: 1; min-width: 0;}

.reminder-slide .reminder-content-scrollable {
    max-height: 30vh; overflow-y: auto; margin-bottom: 1rem;
    word-wrap: break-word; overflow-wrap: break-word;
    text-align: left; padding-right: 5px; flex-grow: 1;}
.reminder-slide .reminder-text {
    margin: 0 0 0.5rem 0; font-size: 1.6rem;
    font-weight: bold; color: #0000FF;}

.reminder-slide .reminder-details {
    margin: 0.2rem 0; font-size: 1.15rem;
    font-weight: bold; color: #0000FF;}
.reminder-slide .button-group {
    display: flex; flex-direction: column;
    justify-content: center; gap: 0.5rem;
    margin-top: auto; padding-top: 1rem; flex-shrink: 0;}
.reminder-slide button {
    padding: 0.5rem 1rem; border-radius: 0.25rem;
    cursor: pointer; font-size: 0.9rem;
    width: 100%; background-color: #D1D5DB;}
.reminder-slide button.cancel {
    background-color: #EF4444; color: #FFFFFF;
    font-weight: bold; height: 70px;
    font-size: 1.2rem; order: 1;}
.reminder-slide button.modify {
    background-color: #10B981; font-weight: bold;
    height: 60px; font-size: 1.2rem;
    color: #FFFFFF; order: 5;}
.reminder-slide button.postpone {
    background-color: #F59E0B; font-weight: bold;
    height: 60px; font-size: 1.2rem;
    color: #FFFFFF; order: 3;}
.reminder-slide button.adjust-time-0001 {
    background-color: #4F4F4F; color: #FFFFFF;
    font-weight: bold; height: 60px;
    font-size: 1.2rem; order: 2; margin-top: 0.5rem;}
.reminder-slide button.cancel-cyclic {
    background-color: #8B0000; color: #FFFFFF;
    font-weight: bold; height: 60px;
    font-size: 1.2rem; order: 4; margin-top: 0.5rem;}
.reminder-map-preview-container {
    flex-shrink: 0; width: 150px;
    display: flex; align-items: center; justify-content: center;
    align-self: stretch;}
.reminder-map-preview {
    width: 100%; height: 100%;
    min-height: 100px; max-height: 25vh;
    border-radius: 0.5rem;}
#hide-all-reminders-button {
    background: none; border: none; color: #0000FF;
    font-size: 1rem; font-weight: bold; cursor: pointer;
    padding: 0.2rem 0.5rem; position: absolute; right: 1rem;
    top: 50%; transform: translateY(-50%); z-index: 3001;}
#hide-all-reminders-button:hover {  text-decoration: underline;}
.modal-top-buttons {
    display: flex; justify-content: space-between;
    gap: 1rem; margin-bottom: 1.5rem; flex-wrap: wrap;}
.modal-top-buttons button {
    flex: 1 1 auto; min-width: 100px; background-color: #D1D5DB;}
.reminder-modal, .help-modal, .edit-info-modal,
.choice-modal, .edit-modal, .reminder-table-modal,
.postpone-options, .saved-locations-modal,
#reorder-stages-modal, #simulation-modal,
#deviation-modal, #arrival-stats-modal,
#simulation-speed-modal {
    z-index: 2000; background-color: #DAC8A0;
    padding: 1.0rem; border-radius: 0.3rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);}
#arrival-stats-modal .eta-deviation {
    font-size: 2.1em; font-weight: bold;
    margin-left: 8px; vertical-align: middle;}
#arrival-stats-modal .eta-deviation.positive { color: #EF4444; }
#arrival-stats-modal .eta-deviation.negative { color: #013220; }
#deviation-modal {
    position: fixed; top: 5px;        
    left: 5px;  transform: none;  background-color: #E6D6A8;
    padding: 20px; border-radius: 10px;
    box-shadow: 0 0 15px rgba(0,0,0,0.5);z-index: 9000;
    text-align: center;max-width: 450px;}
#deviation-modal p#deviation-modal-message {
    margin-bottom: 15px; font-size: 1.1rem; color: #333;}
#deviation-modal button {
    padding: 10px 15px; margin: 0 5px;
    border-radius: 5px; font-size: 1rem; font-weight: bold;
    cursor: pointer; border: none;}
#deviation-modal button#deviation-accept {
    background-color: #28a745; color: white;}
#deviation-modal button#deviation-delete-stage {
    background-color: #EF4444; color: white;}
#address-suggestions-modal h2 {
    font-size: 1.1rem; font-weight: bold; text-align: center;
    margin-bottom: 0.75rem; color: #333;}
#address-suggestions-list {
    list-style: none; padding: 0; margin: 0 0 0.75rem 0;
    overflow-y: auto; border: 1px solid #B0A898;
    border-radius: 4px; background-color: #D8CEC0;}

#address-suggestions-list li {
    padding: 8px 12px; border-bottom: 1px solid #C8B890;
    cursor: pointer; font-size: 1.1rem; font-weight: bold;
    color: #F5F5DC; background-color: #5C5C47;}
#address-suggestions-list li:last-child {  border-bottom: none;}
#address-suggestions-list li:hover { background-color: #6B6B56;}
#address-suggestions-modal .modal-top-buttons button#close-address-suggestions-modal {
    background-color: #4A5568 !important; color: white !important;
    border: 1px solid #2D3748 !important; font-weight: bold !important;}
body.modal-open {  overflow: hidden;}
#locations-preview-modal .modal-top-buttons {
    flex-shrink: 0; display: flex;
    justify-content: center; margin-top: 0;}
#address-suggestions-modal .modal-top-buttons button#close-address-suggestions-modal:hover {
    background-color: #2D3748 !important;}
#reorder-stages-modal {
    position: fixed !important; top: 30px !important; left: 50% !important;
    transform: translateX(-50%) !important; width: 80vw !important;
    height: 90vh !important; max-width: none !important;
    max-height: none !important; z-index: 8600 !important;
    display: flex; flex-direction: column;
    background-color: #DAC8A0;}
#simulation-modal {
    position: fixed; top: 10px; right: 40px;
    left: auto; transform: none; background-color: #E6D6A8;
    padding: 1.5rem; border-radius: 1rem;
    box-shadow: 0 6px 15px rgba(0,0,0,0.3); z-index: 8800;
    max-width: 450px; width: calc(100% - 80px);
    max-height: calc(100vh - 20px); display: flex;
    flex-direction: column;}

#simulation-speed-modal {
    position: fixed; top: 50px; left: 50%;
    transform: translateX(-50%); width: 90%;
    max-width: 400px; z-index: 9100;
    background-color: #F5E1A9; padding: 1.5rem;
    border-radius: 1rem; box-shadow: 0 6px 15px rgba(0,0,0,0.3);
    text-align: center;}
#simulation-speed-modal h2 {
    font-size: 1.2rem; font-weight: bold;
    margin-bottom: 1rem; color: #333;}
#simulation-speed-modal input {
    width: 100px; padding: 0.5rem; margin-bottom: 1rem;
    font-size: 1.2rem; text-align: center;
    border: 1px solid #ccc; border-radius: 4px;}
#reorder-stages-modal button { background-color: #D1D5DB;}
#reorder-stages-modal #confirm-reorder-stages {
    background-color: #28a745; color: white;}
#reorder-stages-modal #cancel-reorder-stages {
    background-color: #6c757d; color: white;}
#simulation-modal #close-simulation-modal {
    background-color: #2563EB; color: white;
    position: absolute; top: 10px; left: 10px;
    height: 35px; padding: 0.5rem 1rem; font-size: 0.9rem;
    min-height: unset; min-width: unset; width: auto;
    line-height: 1;}

.postpone-options {
    background-color: #F5E1A9 !important; z-index: 7500 !important;
    top: 10px !important; transform: translateX(-50%) !important;}
.versions-modal-overlay {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    display: flex; justify-content: center; align-items: flex-start;
    z-index: 5000; padding-top: 50px;}
.versions-modal-content {
    background-color: #DAC8A0; padding: 1.5rem;
    border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
    width: 85%; max-width: 900px; max-height: 85vh;
    overflow-y: auto; display: flex; flex-direction: column;}
.versions-modal-content h2 {
    font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem;
    color: #111827; text-align: center;}
.versions-modal-content .modal-top-buttons { margin-bottom: 1rem;}
.versions-modal-content pre {
    white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word;
    font-size: 1rem; line-height: 1.4; color: #333;
    margin-bottom: 1.5rem; padding: 0.8rem;
    background-color: #f0f0e0; border-radius: 0.25rem;
    max-height: calc(85vh - 150px); overflow-y: auto;}
.versions-modal-content button {
    display: block; width: 100%; padding: 0.75rem 1rem;
    border-radius: 0.25rem; cursor: pointer; font-size: 1.1rem;
    text-align: center; border: none;
    background-color: #2563EB; color: white;}
.versions-modal-content button:hover {  background-color: #1D4ED8;}
.reminder-modal {
    position: fixed; top: 1%; left: 50%;
    transform: translate(-50%, 0); max-width: 96%; width: 95%;
    max-height: 95vh; overflow-y: auto;
    font-weight: bold; font-size: 1.3rem;}
.reminder-table-modal button.visto-prox {
    background-color: #EF4444; font-size: 0.9rem; color: #FFFFFF;
    border: 1px solid #A00000; font-weight: bold;}
.reminder-table-modal button.visto-prox:hover {  background-color: #D00000;}
.help-modal,
.edit-info-modal {
    position: fixed; top: 1%; left: 50%;
    transform: translate(-50%, 1%); max-width: 910px; width: 98%;
    max-height: 96vh; overflow-y: auto; font-size: 1.10rem;
    z-index: 5500;}
#reminders-map-help-modal-instance {
    position: fixed !important; top: 0 !important; left: 0 !important;
    width: 100vw !important; height: 100vh !important;
    max-width: none !important; max-height: none !important;
    transform: none !important; z-index: 7000 !important;
    border-radius: 0 !important; box-sizing: border-box !important;
    padding: 1rem !important;}
#reminders-map-help-modal-instance > div[style*="overflow-y: auto"] {
    padding: 1.5rem !important; flex-grow: 1;
    max-height: none !important;}
.choice-modal {
    position: fixed; top: 1%; left: 50%;
    transform: translate(-50%, 1%); max-width: 540px; width: 95%;
    max-height: 98vh; overflow-y: auto; font-size: 1.10rem;
    z-index: 5500;}
.reminder-table-modal {
    position: fixed; top: 30px; left: 35px;
    transform: translateY(0); max-width: 99%; width: 1090px;
    max-height: 90vh; overflow-y: auto;
    background-color: #E6D6A8; border-radius: 1.5rem;}
.edit-modal {
    position: fixed; top: 5%; left: 50%;
    transform: translate(-50%, 0); width: 75%; max-width: 900px;
    border: 5px solid #A0522D; background-color: #EADDCA;
    z-index: 6000;}
.modal h2,
.modal h3 {
    font-weight: bold; margin-bottom: 1rem; color: #111827;}
.reminder-modal h2, .help-modal h2, .edit-info-modal h2,
.choice-modal h2, .edit-modal h2, .saved-locations-modal h2,
#reorder-stages-modal h2, #simulation-modal h2, #deviation-modal h2,
#arrival-stats-modal h2, #simulation-speed-modal h2 {
    font-size: 1.5rem;}

.reminder-modal label, .help-modal label, .edit-info-modal label,
.choice-modal label, .edit-modal label, .saved-locations-modal label {
    display: block; margin-bottom: 0.25rem; font-weight: 500;
    color: #374151; font-size: 1.1rem;}
.reminder-modal button, .help-modal button, .edit-info-modal button,
.choice-modal button, .edit-modal button, .reminder-table-modal button,
.versions-modal-content button, .saved-locations-modal button,
#reorder-stages-modal button, #simulation-modal button,
#address-suggestions-modal button, #deviation-modal button,
#arrival-stats-modal button, #simulation-speed-modal button {
    padding: 0.75rem 1rem; border-radius: 0.25rem;
    cursor: pointer; font-size: 1.1rem; flex: 1;
    text-align: center; min-width: 100px; border: none;
    background-color: #D1D5DB; min-height: 60px;}
.reminder-modal .modal-top-buttons button {  height: 70px; min-height: 70px;}
.edit-info-modal #close-edit-info,
.help-modal #close-help,
#reminders-map-help-modal-instance #close-reminders-map-help-instance,
#simulation-modal #close-simulation-modal {
    background-color: #2563EB; color: white;}
.edit-info-modal #close-edit-info:hover,
.help-modal #close-help:hover,
#reminders-map-help-modal-instance #close-reminders-map-help-instance:hover,
#simulation-modal #close-simulation-modal:hover {
    background-color: #1D4ED8;
    height: 20px; }
.reminder-modal textarea#reminder-text {
    width: 100%; padding: 0.5rem; margin-bottom: 0.3rem;
    border: 1px solid #D1D5DB; border-radius: 0.25rem;
    font-size: 1.4rem; font-weight: bold;
    text-transform: uppercase;}
.reminder-modal input#reminder-time { max-width: 120px; width: auto; }
.reminder-modal input#reminder-date { max-width: 160px; width: auto; }
.reminder-modal input#reminder-interval { max-width: 100px; width: auto; }
.reminder-modal input#reminder-radius { max-width: 120px; width: auto; }
.reminder-modal input[type="text"],
.reminder-modal input[type="number"] {
    padding: 0.5rem; margin-bottom: 0.3rem;
    border: 1px solid #D1D5DB; border-radius: 0.25rem;
    font-size: 1.5rem; text-align: center;}
.reminder-modal .form-grid {
    display: grid; grid-template-columns: auto auto auto 1fr;
    gap: 1rem; align-items: end; margin-bottom: 1rem;}
label[for="reminder-interval"] { line-height: 1.2;}
.location-controls-group {
    grid-column: 4 / 5; display: flex;  flex-wrap: wrap; align-items: center;
    justify-content: flex-start; gap: 0.5rem;  margin-top: 0;}
.location-controls-group label { margin-bottom: 0; }
.location-controls-group input[type="checkbox"] { margin-right: 0.2rem; }
.location-controls-group label[for="reminder-radius"] { margin-left: 0; }
#expand-map-button {
    padding: 0.3rem 0.6rem !important; font-size: 1.3rem !important;
    height: auto !important; flex-shrink: 0;
    background-color: #668B8B !important; color: white !important;
    border: none !important; border-radius: 0.25rem !important;
    min-width: unset !important; flex: unset !important;
    margin-left: 0.5rem;}
#expand-map-button:hover {  background-color: #5C5C47 !important;}
#location-map-container {
    grid-column: 1 / -1; width: 100%;
    border: 1px solid #ccc; border-radius: 0.25rem;
    background-color: #eee; position: relative;
    margin-top: 0.5rem; display: none;
    transition: height 0.3s ease-in-out;}
#location-map-container.preview { display: block !important; height: 65px;}

#location-map-container.expanded { display: block !important; height: 360px;}
#reduce-map-button,
#locate-me-button {
    position: absolute; top: 5px; z-index: 1001;
    padding: 0.8rem 1rem; font-size: 1rem; font-weight: bold;
    background-color: rgba(255, 255, 255, 0.9);
    border: 1px solid #777; border-radius: 4px;
    cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.25);
    transition: background-color 0.2s ease;}
#reduce-map-button:hover,
#locate-me-button:hover {
    background-color: rgba(230, 230, 230, 0.95);}
#reduce-map-button { right: 5px; }
#locate-me-button { right: calc(5px + 135px + 15px); }
.reminder-modal .full-width {
    grid-column: 1 / -1;}
.reminder-modal .days-group {
    display: flex; gap: 1rem; flex-wrap: wrap;
    grid-column: 1 / -1; margin-top: 1rem;}
.reminder-modal .days-group label {
    font-size: 1.1rem; flex: 0 0 auto;}
.reminder-modal button[type="submit"] {
    background-color: #2563EB; color: #FFFFFF;
    display: flex; align-items: center; justify-content: center;
    gap: 0.6rem;}

.reminder-modal button[type="submit"] span#countdown-save {
    font-size: 1.6rem; font-weight: bold; justify-content: right;
    color: #e6e6dc;}
.reminder-modal button[type="button"] {
    background-color: #D1D5DB; color: #111827;}
#config-modal #config-close-modal,
#simulation-speed-modal #cancel-simulation-speed,
.postpone-options #cancel-postpone {
    background-color: blue !important; color: white !important;
    border: 1px solid #2D3748 !important; font-weight: bold !important;}
#config-modal #config-close-modal:hover,
#simulation-speed-modal #cancel-simulation-speed:hover,
.postpone-options #cancel-postpone:hover {
    background-color: #2D3748 !important;}
#simulation-speed-modal #confirm-simulation-speed {
    background-color: #28a745 !important; color: white !important;}
.speech-button {
    background-color: #668B8B; color: white;
    border: none; border-radius: 0.25rem;
    padding: 0.5rem; cursor: pointer;
    margin-left: 0.5rem; font-size: 1rem;
    vertical-align: top;}
.speech-button:hover { background-color: #5C5C47;}
.speech-status {
    font-size: 0.85rem; color: #ABAB99;
    margin-top: 0.1rem; min-height: 1em;}
#auto-save-timer {
    color: #1E40AF; grid-column: 1 / -1;  text-align: center;}
.reminder-table-modal td.text-column {text-align: left;}
.reminder-table-modal td.date-column {  white-space: nowrap;}
.reminder-table-modal button.modify {
    background-color: #10B981; font-size: 1rem; color: #FFFFFF;
    height: 60px; border: 1px solid #008000; font-weight: bold;}
.reminder-table-modal button.modify:hover {  background-color: #008000;}
.reminder-table-modal button.delete {
    background-color: #EF4444; font-size: 0.9rem; color: #FFFFFF;
    border: 1px solid #A00000; font-weight: bold;}
.reminder-table-modal button.delete:hover { background-color: #D00000;}
.reminder-table-modal button.postpone {
    background-color: #F59E0B; font-size: 0.9rem; color: #FFFFFF;
    border: 1px solid #D97706; font-weight: bold;}
.reminder-table-modal button.postpone:hover {  background-color: #D97706;}
.reminder-table-modal button.cancel-cyclic-table {
    background-color: #8B0000; font-size: 0.9rem; color: #FFFFFF;
    border: 1px solid #580000; font-weight: bold;}

.reminder-table-modal button.cancel-cyclic-table:hover {
    background-color: #580000;}
.reminder-table-modal #close-reminders-bottom, {
    padding-left: 3rem;
    background-color: #2563EB; color: white;
    padding: 0.75rem 3rem; border-radius: 0.5rem;
    font-size: 1.25rem; font-weight: bold;
    border: 2px solid #1E3A8A; cursor: pointer;
    transition: background-color 0.2s ease;
    display: inline-flex; align-items: center;}

.reminder-table-modal #close-reminders-bottom:hover, {
    background-color: #1D4ED8;}
.choice-modal .personalization-options {
    display: flex; flex-direction: column; gap: 1rem;
    align-items: stretch; margin-bottom: 1.5rem;}
.choice-modal .personalization-options button {
    font-weight: bold; width: 100%;  background-color: #D1D5DB;}

.choice-modal button.choice-edit {  background-color: #ffc107; color: #333;}
.input-with-clear-button {
    position: relative; display: flex;  align-items: center;}
.input-with-clear-button input {
    width: 100%; padding-right: 40px !important;}
.clear-input-btn {
    position: absolute; right: 5px; top: 50%;
    transform: translateY(-69%); background: transparent;
    border: none; font-size: 1.8rem; font-weight: bold;
    color: #666; cursor: pointer; padding: 0 5px;
    line-height: 1; display: none;}
.choice-modal button.choice-assign { background-color: #17a2b8; color: white;}
.choice-modal button.choice-help {background-color: #007bff; color: white;}
.choice-modal button.choice-cancel {  background-color: #6c757d; color: white;}
.choice-modal .footer-buttons {
    display: flex; justify-content: center; gap: 1rem; margin-top: 1rem;}
.choice-modal .footer-buttons button {
    flex: 0 1 auto; min-width: 120px; background-color: #D1D5DB;}
.edit-modal h2 {
    font-size: 1.4rem; margin-bottom: 1rem; color: #333;
    font-weight: bold; text-align: center;}
.edit-modal .modal-top-buttons {  margin-bottom: 1.2rem;}
.edit-modal label {
    display: block; margin-bottom: 0.3rem;
    font-weight: 500; color: #444; font-size: 1rem;}
.edit-modal input[type="text"],
.edit-modal input[type="url"] {
    width: 100%; padding: 0.6rem; margin-bottom: 0.8rem;
    border: 1px solid #BDB7AB; border-radius: 0.25rem;
    font-size: 1rem;}
.edit-modal .input-with-button {
    display: flex; align-items: center;
    gap: 0.5rem; margin-bottom: 0.8rem;}

.edit-modal .input-with-button input {  flex-grow: 1; margin-bottom: 0;}
.edit-modal .search-button {
    padding: 0.4rem 0.6rem; font-size: 0.8rem;
    background-color: #668B8B; color: white;
    border: none; border-radius: 0.25rem;
    cursor: pointer; line-height: 1; height: fit-content;}

.edit-modal .search-button:hover { background-color: #5C5C47;}
.edit-modal button {
    padding: 0.7rem 1rem; font-size: 1.3rem;
    border-radius: 0.25rem; cursor: pointer;
    border: none; flex: 1 1 auto; min-width: 90px;
    background-color: #D1D5DB;}

.edit-modal button.save { background-color: #28a745; color: white; }
.edit-modal button.save:hover { background-color: #218838; }
.edit-modal button.cancel { background-color: #6c757d; color: white; }
.edit-modal button.cancel:hover { background-color: #5a6268; }
.edit-modal button.reset { background-color: #ffc107; color: #333; }
.edit-modal button.reset:hover { background-color: #e0a800; }
.edit-modal button.empty { background-color: #fd7e14; color: white; }
.edit-modal button.empty:hover { background-color: #e66b04; }

.editing-active .bookmark-item:hover,
.editing-active .range-toggle:hover,
.editing-active .empty-slot:hover {
    transform: none; outline: 3px solid yellow;
    box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1);
    cursor: crosshair;}

.editing-active .grid-cell.editing-target,
.editing-active .range-toggle.editing-target {
    outline: 3px solid yellow !important; outline-offset: 1px;
    box-shadow: 0 0 8px yellow;}

.editing-active .grid-cell {
    cursor: grab; user-select: none;
    -webkit-user-select: none; -moz-user-select: none;
    -ms-user-select: none;}
.editing-active .grid-cell:active { cursor: grabbing;}
.grid-cell.dragging {
    opacity: 0.4; border: 2px dashed #aaa; cursor: grabbing;
    transform: scale(0.95); z-index: 10;}

.grid-cell.drag-over {
    border: 3px solid #3498db !important;
    background-color: rgba(52, 152, 219, 0.1);
    box-shadow: inset 0 0 10px rgba(52, 152, 219, 0.3);}
.empty-slot.drag-over {
    border: 3px solid #3498db !important;
    background-color: rgba(52, 152, 219, 0.2);}
.empty-slot.dragging {
    opacity: 0.4; border: 2px dashed #aaa !important;
    cursor: grabbing;}
.assignment-active .range-toggle.assigning-selected {
    outline: 4px solid cyan; box-shadow: 0 0 12px cyan;
    transform: scale(1.03);}
.assignment-active .range-toggle:not(.assigning-selected) {
    opacity: 0.7; cursor: pointer;}

.assignment-active .grid-cell.assigned-to-current {
    outline: 3px solid cyan;
    box-shadow: inset 0 0 8px rgba(0, 255, 255, 0.6);
    background-color: hsla(180, 70%, 80%, 0.3);
    opacity: 1;}

.assignment-active .grid-cell:not(.assigned-to-current) {
    opacity: 0.6; outline: 1px dashed #aaa;}
.assignment-active .grid-cell { cursor: pointer;}

body.dark-mode .assignment-active .grid-cell.assigned-to-current {
    box-shadow: inset 0 0 10px rgba(0, 200, 200, 0.7);
    background-color: hsla(180, 60%, 30%, 0.4);}

body.dark-mode .assignment-active .grid-cell:not(.assigned-to-current) {
    opacity: 0.5; outline-color: #555;}
#pin-modal-overlay {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    display: flex; justify-content: center; align-items: flex-start;
    z-index: 9998;}
#pin-modal-content {
    background-color: #DAC8A0; padding: 2rem;
    border-radius: 0.75rem; box-shadow: 0 5px 20px rgba(0,0,0,0.4);
    text-align: center; border: 1px solid #A0522D;
    margin-top: 50px;}
#pin-modal-content h2 {
    font-size: 1.5rem; font-weight: bold;
    color: #333; margin-bottom: 1rem;}
#pin-modal-content .modal-top-buttons { margin-bottom: 1.5rem;}

#pin-modal-content label {
    display: block; font-size: 1.1rem;
    color: #444; margin-bottom: 0.8rem;}
#pin-input {
    width: 150px; padding: 0.8rem; font-size: 1.8rem;
    text-align: center; border: 2px solid #A0522D;
    border-radius: 0.25rem; margin-bottom: 1.5rem;
    letter-spacing: 0.5em; background-color: #f0f0e0;}

#pin-submit-button {
    padding: 0.8rem 2rem; font-size: 1.2rem;
    background-color: #28a745; color: white;
    border: none; border-radius: 0.25rem;
    cursor: pointer; transition: background-color 0.2s;}
#pin-submit-button:hover {  background-color: #218838;}
#pin-error-message {
    color: #dc3545; font-weight: bold; margin-top: 1rem; min-height: 1.2em;}
#config-modal {
    position: fixed; top: 15px; left: 50%;
    transform: translate(-50%, 0); background-color: #ECEFE8;
    padding: 1.5rem; border-radius: .75rem;
    box-shadow: 0 8px 16px rgba(0,0,0,.25); z-index: 5000;
    max-width: 1000px; width: 95%;
    max-height: calc(83vh + 190px); display: flex;
    flex-direction: column;}
#config-modal .modal-top-buttons {
    display: flex; justify-content: space-between;
    align-items: center; margin-bottom: 1rem;}
#config-modal .modal-top-buttons h2 {  margin-bottom: 0;}
.config-tab-content {
    max-height: calc(83vh + 130px - 190px);}

.config-tab-button {
    padding: .7rem 1.2rem; cursor: pointer;
    border: 1px solid #ccc; border-bottom: none;
    background-color: #e0e0d0; margin-right: .3rem;
    border-radius: .5rem .5rem 0 0; font-size: 1rem;
    font-weight: 500; color: #555; outline: none;
    transition: background-color .2s ease,color .2s ease;}
.config-tab-button:hover {  background-color: #d8d8c0;}
.config-tab-button.active {
    background-color: #ECEFE8; border-color: #ccc;
    border-bottom: 1px solid #ECEFE8; font-weight: bold;
    color: #2F4F4F; position: relative; top: 1px;
    z-index: 2;}
.tab-buttons {
    margin-bottom: -1px; flex-shrink: 0;
    border-bottom: 1px solid #ccc; padding-left: 1rem;
    display: flex; overflow-x: auto;}
.tab-contents {
    flex-grow: 1; overflow-y: auto; position: relative;
    z-index: 1; border-top: none; min-height: 200px;}
.config-tab-content { display: none; }

.config-tab-content.active {  display: block; }   
#config-modal h2 {
    font-size: 1.6rem; margin-bottom: 0; color: #2F4F4F;
    text-align: center; flex-shrink: 0;}
#config-modal h3 {
    font-size: 1.3rem; margin-bottom: .8rem; color: #4682B4;}

#config-modal p,
#config-modal label {
    font-size: 1rem; line-height: 1.5; color: #333;}
#config-modal em { font-size: .85rem;}

#config-modal button:not(.config-tab-button) {
    font-size: 1.05rem; padding: .8rem 1.5rem;
    background-color: #D1D5DB;}

#config-modal textarea {
    font-size: .9rem; height: 110px; width: 100%;
    border: 1px solid #ccc; border-radius: .25rem;
    padding: .5rem; resize: vertical;}
#config-modal input[type=text],
#config-modal input[type=number],
#config-modal input[type=password] {
    font-size: 1rem; padding: .6rem; width: 100%;
    border: 1px solid #ccc; border-radius: .25rem;}
#config-modal .status-message {
    font-size: .9rem; min-height: 1.1em;
    font-weight: 500; text-align: center;
    margin-top: .5rem;}
.user-data-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit,minmax(180px,1fr));
    gap: 1.2rem 1.8rem; align-items: start; margin-bottom: 1rem;}

.user-data-grid label {
    margin-bottom: .3rem; display: block; font-weight: 500;}

.user-data-grid .checkbox-container {
    grid-column: 1 / -1; display: flex; align-items: center;
    gap: .5rem; justify-content: center; margin-top: .5rem;}

.user-data-grid .checkbox-container input {
    width: 1.2rem; height: 1.2rem;}

.user-data-grid .checkbox-container label {  margin-bottom: 0;}
.user-buttons-container {
    display: flex; justify-content: space-around;
    gap: 1.5rem; margin-top: 1.5rem; margin-bottom: 1rem;}
.user-buttons-container button {
    border: none; border-radius: .25rem;  cursor: pointer; flex-grow: 1;}
#config-user-status { min-height: 1.2em;}
.backup-restore-container {  display: flex; gap: 2.5rem; flex-wrap: wrap;}
.backup-restore-container > div { flex: 1; min-width: 250px;}
.backup-restore-container p { margin-bottom: 1.2rem;}

.backup-restore-container textarea { margin-bottom: 1rem; background-color: #f9f9f9;}
.backup-restore-container button {
    margin-bottom: 1rem; border: none;
    border-radius: .25rem; cursor: pointer;width: 100%;}
#config-restore-grid-button {
    background-color: #E65100; color: black; margin-top: 10px;}
#config-restore-grid-button:hover {background-color: #D84315;}
.backup-restore-container .status-message {
    margin-top: .6rem;}
.borrar-container h3 {
    margin-bottom: .8rem;}
.borrar-container p {
    margin-top: .6rem;}
.borrar-container button {
    margin-top: 1.5rem; border: none;
    border-radius: .25rem; cursor: pointer; width: 100%;}
.borrar-container button#config-clear-cache {
    background-color: #EF4444; color: white;}
#config-close-modal-container {
    text-align: center; margin-top: 1rem; flex-shrink: 0;}
#config-close-modal {
    font-size: 1.15rem; padding: .8rem 2.5rem;
    background-color: #4A5568; color: white;
    border: 1px solid #2D3748; font-weight: bold;}

#config-close-modal:hover { background-color: #2D3748;}
.pin-config-section {
    border-top: 1px solid #ccc;  margin-top: 2rem; padding-top: 1.5rem;}

.pin-config-layout {
    display: grid;
    grid-template-columns: minmax(200px, 1fr) minmax(200px, 1fr);
    gap: 1rem 1.5rem; align-items: end;}

.pin-config-layout .pin-input-group {
    grid-column: span 1; display: flex;  flex-direction: column;}

.pin-config-layout .pin-input-group label {  margin-bottom: 0.3rem;}

.pin-config-layout .pin-buttons-container {
    grid-column: 1 / 3; grid-row: 2;
    display: flex; justify-content: flex-start;
    gap: 1rem; margin-top: 0.5rem;}

.pin-config-layout .pin-buttons-container button {
    flex-grow: 0; min-width: 120px;max-width: 180px;}

#tab-content-pin .checkbox-container {
    grid-column: 1 / -1; display: flex; align-items: center;
    gap: .5rem; justify-content: flex-start;
    margin-top: 1.5rem; border-top: 1px solid #ccc;
    padding-top: 1rem;}

#tab-content-pin .checkbox-container input { width: 1.2rem; height: 1.2rem;}

#tab-content-pin .checkbox-container label { margin-bottom: 0;}

.toast-notification {
    position: fixed; top: 180px; right: 15px; transform: none;
    padding: 10px 25px; border-radius: 8px; color: white;
    font-size: 0.9rem; font-weight: bold; z-index: 9999;
    opacity: 0; text-align: center;
    transition: opacity 0.4s ease-in-out, top 0.4s ease-in-out;
    box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    min-width: 200px; max-width: 70%;}
.toast-notification.show { opacity: 1;}
.toast-success { background-color: #28a745; }
.toast-error { background-color: #dc3545; }
.toast-warning { background-color: #ffc107; color: #333; }
.toast-info { background-color: #17a2b8; }
.toast-debug {
    background-color: #663399; color: white; font-size: 0.9rem;
    text-align: left; max-width: 90%; white-space: pre-wrap;
    max-height: 80vh; overflow-y: auto; line-height: 1.2;}
.toast-debug button {
    display: block; margin-top: 10px; padding: 5px 10px;
    background-color: rgba(255,255,255,0.2); color: white;
    border: 1px solid white; border-radius: 3px; cursor: pointer;}
.toast-error.not-found {
    background-color: #a02020; border: 2px solid #ffdddd;
    font-size: 1.2rem; box-shadow: 0 8px 16px rgba(0,0,0,0.4);}
#average-speed-display { color: #CBDDB5 !important; }
#max-speed-display { color: #FFA420 !important; }
#compass-rose-icon {
    width: 57px; height: 58px; display: block;
    margin: 0 auto 2px auto;
    transition: transform 0.3s ease-out;}
#orientation-text {
    display: block; font-size: 1.4em; font-weight: bold;
    line-height: 1.2; margin-bottom: 2px;}
#altitude-display {
    display: block; font-size: 1.2em; line-height: 1.1;font-weight: bold;}
#current-speed-display,
#average-speed-display,
#max-speed-display {
    display: block; font-size: 1.2em; font-weight: bold;
    line-height: 1.2; margin-top: 2px;}
#navigation-graph-card.enlarged {
    position: fixed; background-color: rgba(0, 0, 0, 0.85);
    z-index: 2000; border: 1px solid #888;}
#navigation-graph-card.enlarged #navigation-graph-container {
    flex-grow: 1;}
#enlarge-graph-button {
    position: absolute; top: 5px; right: 5px;
    width: 28px; height: 28px; cursor: pointer;
    z-index: 5; opacity: 0.7; transition: opacity 0.2s;}
#enlarge-graph-button:hover {
    opacity: 1;}
#navigation-graph-title {
    font-size: 1.1em; font-weight: bold; padding: 1px 5px;
    color: #cb9a01; flex-shrink: 0;
    display: flex; justify-content: space-between;
    align-items: center; width: 100%;}
#navigation-graph-container {
    width: 100%; flex-grow: 1;
    position: relative; min-height: 0;}
#navigation-chart {
    display: block; width: 100%; height: 100%;}
#location-map-container:not(.expanded) ,
#location-picker-map-container:not(.expanded)  {
    display: none !important;}
.saved-locations-modal .modal-top-buttons {
    margin-bottom: 1rem;}
.saved-locations-modal .location-slot button.map-button:hover {
    background-color: #5C5C47;}
.saved-locations-modal #close-saved-locations-modal {
    background-color: #D1D5DB; color: #111827;}
#location-picker-map-container {
    height: 300px; border: 1px solid #ccc;
    position: relative; margin-top: 1rem;
    border-radius: 0.25rem; background-color: #eee;
    display: none;}
#location-picker-map-container.expanded {  display: block !important;}
#picker-ok-map-button { top: 5px; right: 5px;}
#location-picker-map-container button {
    padding: 0.5rem 0.8rem; font-size: 0.9rem; font-weight: bold;
    background-color: #007bff; /* CAMBIO: Fondo azul */
    color: white; /* CAMBIO: Letra blanca */
    border: 1px solid #0056b3; /* CAMBIO: Borde azul oscuro */
    border-radius: 4px;
    cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.25);
    position: absolute; z-index: 1001;
    transition: background-color 0.2s ease; /* AADIDO: Transicin suave */}
#location-picker-map-container button:hover {  background-color: #0056b3;}   
#picker-locate-me-button {  top: 5px; right: calc(5px + 90px + 10px);}
#search-row-map-header .reminders-map-button-action { height: 57px;}
#search-row-map-header > #reorder-route-stages-button,
#search-row-map-header > #map-location-search-button,
#search-row-map-header > #clear-map-search-input-button,
#search-row-map-header > #map-location-search-input,
#search-row-map-header > #filter-input,
#search-row-map-header > #navigation-map-help-button {
    height: 57px !important;}
#reminders-location-map-header .button-row.hidden-map-header {
    opacity: 0; visibility: hidden; max-height: 0 !important;
    min-height: 0 !important; overflow: hidden !important;
    padding-top: 0 !important; padding-bottom: 0 !important;
    margin-bottom: 0 !important; border-bottom: none !important;}
#reminders-location-map-header .button-row:first-child {
    margin-bottom: 10px;}
#reminders-location-map-header h2 { display: none;}
#reminders-location-map-header .reminders-map-button-action img,
#reminders-location-map-header .reminders-map-button-action svg {
    width: 100%; height: 100%; object-fit: contain;}
#reminders-location-map-header .reminders-map-button-action:hover {
    opacity: 0.88;}
#toggle-map-header-buttons-panel {
    position: fixed; left: 15px; top: 50%;
    transform: translateY(-50%); width: calc(120px);
    height: calc(120px);
    background-color: rgba(100, 100, 100, 0.45);
    border-radius: 50%; display: flex;
    align-items: center; justify-content: center;
    cursor: pointer; z-index: 1010;
    box-shadow: 1px 1px 3px rgba(0,0,0,0.45);
    touch-action: none;}
#toggle-map-header-buttons-panel img {
    width: 60%; height: 60%; object-fit: contain;}
#load-route-button,
#save-route-button {   background-color: #0000CD !important;}

#navigation-map-help-button {
    margin-right: 10px; margin-left: 10px;
    background-color: #4A5568 !important;
    box-shadow: 2px 2px 5px rgba(0,0,0,0.50);}
#add-reminder-at-location-button {
    background-color: #FFA500 !important; width: 60px;
    height: 60px; padding: 5px; gap: 0;}
#add-reminder-at-location-button.active-reminder-mode {
    background-color: #EF4444 !important;}
#add-reminder-at-location-button svg {
    width: 100%; height: 100%; object-fit: contain;}
.radares-ruta-control {
    display: flex; align-items: center; justify-content: center;
    padding: 0.3rem 0.6rem; background-color: rgba(200,200,180,0.7);
    border-radius: 5px; height: 60px; min-width: 70px;
    box-sizing: border-box; gap: 3px;}
#radares-ruta-checkbox {
    margin-right: 0px; margin-bottom: 0px; transform: scale(1.1);}
.radares-ruta-label-container {
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;}
#radares-ruta-checkbox + .radares-ruta-label-container > label {
    font-weight: bold; font-size: 0.70rem; color: #333;
    cursor: pointer; text-align: center;
    line-height: 1.1; margin-bottom: 1px;}
#radares-ruta-count {
    display: flex; align-items: center; justify-content: center;
    width: 25px; height: 20px; background-color: #6600a1;
    color: white; border-radius: 50%;
    font-size: 0.75rem; font-weight: bold;
    line-height: 1; margin-top: 2px;}
.tareas-ruta-control {
    display: flex; align-items: center; justify-content: center;
    padding: 0.3rem 0.6rem; background-color: rgba(200,200,180,0.7);
    border-radius: 5px; height: 60px; min-width: 70px;
    box-sizing: border-box; gap: 3px;}
#tareas-ruta-checkbox {
    margin-right: 0px; margin-bottom: 0px;
    transform: scale(1.1);}
.tareas-ruta-label-container {
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;}
#tareas-ruta-checkbox + .tareas-ruta-label-container > label {
    font-weight: bold; font-size: 0.70rem; color: #333;
    cursor: pointer; text-align: center;
    line-height: 1.1; margin-bottom: 1px;}
#tareas-ruta-count {
    display: flex; align-items: center; justify-content: center;
    width: 25px; height: 20px; background-color: #008f39;
    color: white; border-radius: 50%;
    font-size: 0.75rem; font-weight: bold;
    line-height: 1; margin-top: 2px;}
#reorder-route-stages-button {
    height: 60px; width: 60px; border: 1px solid #777;
    box-shadow: 2px 3px 5px rgba(0,0,0,0.70);
    padding: 2px; display: inline-flex;
    align-items: center; justify-content: center;
    font-size: 0.9rem; font-weight: bold; color: white;
    border-radius: 4px; cursor: pointer; flex-shrink: 0;
    white-space: nowrap; background-color: white !important;
    margin-right: 4px;}
#reorder-route-stages-button img {
    max-height: 90%; max-width: 90%; object-fit: contain;}
#map-location-search-button {
    height: 60px; width: 60px; border: 1px solid #777;
    box-shadow: 2px 3px 5px rgba(0,0,0,0.70);
    padding: 3px; display: inline-flex;
    align-items: center; justify-content: center;
    font-size: 0.9rem; font-weight: bold; color: white;
    border-radius: 4px; cursor: pointer; flex-shrink: 0;
    white-space: nowrap; background-color: white !important;
    margin-left: 2px;}
#map-location-search-button img {
    max-height: 80%; max-width: 90%; object-fit: contain;}
#map-location-search-input::placeholder,
#::placeholder {    color: #CDCDCD; opacity: 1;}
#map-location-search-input::-webkit-input-placeholder { color: #CDCDCD; }
#map-location-search-input::-moz-placeholder { color: #CDCDCD; opacity: 1; }
#map-location-search-input:-ms-input-placeholder { color: #CDCDCD; }
#map-location-search-input::-ms-input-placeholder { color: #CDCDCD; }
body.dark-mode #map-location-search-input {
    background-color: #a0a090; color: #e0e0e0; border-color: #666;}
body.dark-mode #map-location-search-input::placeholder { color: #A0A0A0;}
#clear-map-search-input-button {
    height: 60px !important; width: 50px !important;
    background-color: #e0e0e0; border: 1px solid #ccc;
    box-shadow: 2px 3px 5px rgba(0,0,0,0.70);
    border-radius: 4px; cursor: pointer; flex-shrink: 0;
    padding: 0; z-index: 1; display: flex;
    align-items: center; justify-content: center;
    margin-left: 2px;}
#clear-map-search-input-button svg {
    width: 60%; height: 60%; stroke: red; stroke-width: 3;}
body.dark-mode #clear-map-search-input-button {
    background-color: #555; border-color: #444;}
body.dark-mode #clear-map-search-input-button svg {  stroke: #ff6666;}
#toggle-simulate-gps-button {
    background-color: #DAA520 !important; width: 60px;
    height: 60px; padding: 5px !important;}
#toggle-simulate-gps-button.active-simulate-gps-mode {
    background-color: #B22222 !important; box-shadow: 0 0 8px #FF4500;}
#toggle-simulate-gps-button img {
    width: 100%; height: 100%; object-fit: contain;}
#simulate-route-button { padding: 5px;}

#simulate-route-button img {
    width: 100%; height: 100%;   object-fit: contain;}
#view-all-locations-map {
    padding: 0.75rem 1.2rem; font-size: 1.1rem;
    font-weight: bold; border-radius: 0.5rem;
    cursor: pointer; border: 2px solid #506C6C;
    color: white; background-color: #668B8B;
    margin-left: 10px; transition: background-color 0.2s ease;
    display: inline-flex; align-items: center;
    justify-content: center; height: auto;
    min-height: 46px; white-space: nowrap;}
#view-all-locations-map:hover {   background-color: #5C7A7A;}
#tab-content-radares .radar-filter-group {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem; margin-bottom: 1rem; align-items: end;}
#tab-content-radares .radar-filter-group label {
    margin-bottom: 0.25rem; font-weight: 500;
    font-size: 0.9rem;}
#tab-content-radares .radar-filter-group input {
    padding: 0.5rem; font-size: 1rem;
    border: 1px solid #ccc; border-radius: 0.25rem;
}
#tab-content-radares .radar-import-options {
    margin-bottom: 1rem; display: flex;
    align-items: center; gap: 0.5rem;}
#tab-content-radares .radar-import-options input[type=checkbox] {
    width: 1.1rem; height: 1.1rem;}
#tab-content-radares .radar-import-options label {
    margin-bottom: 0; font-size: 0.9rem;}
#tab-content-radares .radar-action-buttons {
    display: flex; justify-content: space-around;
    gap: 1rem; margin-top: 1rem; margin-bottom: 1.5rem;}
#tab-content-radares .radar-action-buttons button {
    flex: 1; padding: 0.8rem 1rem; font-size: 1.1rem;
    border-radius: 0.3rem; background-color: #D1D5DB;}
#import-radars-button,
#delete-filtered-radars-button {
    background-color: #F59E0B !important; color: white !important;
    border: 1px solid #D97706 !important;}
#import-radars-button:hover,
#delete-filtered-radars-button:hover { background-color: #D97706 !important;}
#radar-import-progress-container {
    margin-top: 1rem; padding: 0.8rem;
    border: 1px solid #ccc; border-radius: 0.25rem;  background-color: #f9f9f9;}
#radar-import-progress-bar {
    width: 100%; height: 20px; margin-bottom: 0.5rem;}
#radar-import-status {
    font-size: 0.9rem; color: #333;
    min-height: 1.2em; text-align: center;
}
.navigation-waypoint-marker {
    display: flex; align-items: center; justify-content: center;
    border-radius: 50%; color: white; font-weight: bold;
    text-align: center; box-shadow: 0 0 3px rgba(0,0,0,0.5);
    opacity: 0.85;    }
.navigation-waypoint-marker.start-point { background-color: rgba(0, 128, 0, 0.80); }
.navigation-waypoint-marker.finish-point { background-color: rgba(0, 0, 255, 0.80); }
.navigation-waypoint-marker.intermediate-point { background-color: rgba(230, 140, 0, 0.80); }
.waypoint-delete-button {
    position: absolute; background-color: rgba(255, 0, 0, 0.85);
    color: white; border-radius: 50%; text-align: center;
    cursor: pointer; border: 1px solid white; z-index: 10;}
#turn-icon-container-styled {
    position: relative; background-color: white;
    padding: 2px; border-radius: 6px;
    display: flex; align-items: center; justify-content: center;
    width: 60px; height: 60px; box-sizing: border-box;
    z-index: 1; flex-shrink: 0; margin-right: 8px;
    overflow: hidden;}
#simulation-modal .turn-icon-sim .leaflet-routing-icon {
    width: 24px !important; height: 24px !important;
    transform: none !important; display: block; object-fit: contain;
    background-image: url('https://cdnjs.cloudflare.com/ajax/libs/leaflet-routing-machine/3.2.12/leaflet.routing.icons.png');
    background-repeat: no-repeat;}
#navigation-top-info-bar .maneuver-text-container {
    flex-grow: 1; text-align: center;max-width: calc(100% - 60px);}
#navigation-top-info-bar .maneuver-text,
#navigation-top-info-bar .street-name {
    font-weight: bold; font-size: 1.33em; color: white;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    white-space: normal; word-wrap: break-word;
    overflow-wrap: break-word; line-height: 1.2;}
#navigation-top-info-bar .maneuver-text {
    font-size: 1.2em; margin-right: 8px; display: inline;}
#navigation-top-info-bar .street-name { font-size: 0.8em; display: inline;}
#distance-to-turn-formatted {
    text-align: center; font-weight: bold;
    font-size: 1.5em; margin-top: 4px;}
#distance-progress-bar-to-turn-container {
    width: 100%; height: 7px; background-color: #e0e0e0;
    border-radius: 4px; margin-top: 5px; overflow: hidden;}
#distance-progress-bar-to-turn {
    width: 100%; height: 100%;
    background: linear-gradient(to right, #680000 0%, #FF0000 50%, #FA8072 97%);
    border-radius: 4px; transition: width 0.3s linear;}
#route-overall-progress-container {
    width: 100%; height: 18px; background-color: #e0e0e0;
    border-radius: 9px; margin-bottom: 9px;
    position: relative; overflow: visible;}
#route-overall-progress {
    width: 0%; height: 100%; z-index: 3;
    background-color: #4CAF50;
    background: linear-gradient(to right, #006600 30%, #258D19 92%, #b4ff9a 99%);
    border-radius: 9px; transition: width 0.5s linear;
    position: relative;}
.radar-marker-on-progress-bar {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%); width: 0; height: 0;
    z-index: 1; border-left: 7px solid transparent;
    border-right: 7px solid transparent; border-bottom: 10px solid white;}
.radar-marker-on-progress-bar::after {
    content: ''; position: absolute; width: 0; height: 0;
    z-index: 2; border-left: 5px solid transparent;
    border-right: 5px solid transparent; border-bottom: 8px solid #8A36D2;
    top: 1px; left: -5px;}
.task-marker-on-progress-bar {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%); width: 0; height: 0;
    z-index: 1; border-left: 7px solid transparent;
    border-right: 7px solid transparent; border-bottom: 10px solid white;}
.task-marker-on-progress-bar::after {
    content: ''; position: absolute; width: 0; height: 0;
    z-index: 2; border-left: 5px solid transparent;
    border-right: 5px solid transparent; border-bottom: 8px solid #608414;
    top: 1px; left: -5px;}
#route-progress-icon {
    position: absolute; height: 100%; width: auto;
    max-height: 18px; left: 100%; top: 50%;
    transform: translate(-50%, -50%); z-index: 4; display: none;}
#route-progress-text {
    position: absolute; text-align: left; top: 50%; left: 10px;
    transform: translateY(-50%);
    font-family: 'Arial', 'Helvetica Neue', Helvetica, sans-serif;
    font-weight: bold; color: yellow;
    -webkit-text-stroke-width: 2px;
    -webkit-text-stroke-color: #006400;
    paint-order: stroke fill;
    font-size: clamp(0.85em, 3vw, 0.95em);
    line-height: 1; pointer-events: none; z-index: 3;
    background-color: transparent; padding: 2px;
    white-space: nowrap;}
.waypoint-dot-on-progress-bar {
    position: absolute; top: 50%; transform: translateY(-50%);
    width: 13px; height: 13px; background-color: #3498db;
    border-radius: 50%; border: 1px solid white; z-index: 2;}
#navigation-eta-info {
    display: flex; justify-content: space-between;
    margin-top: 6px; font-size: 1em;}
#navigation-eta-info.single-destination {  justify-content: center;}
#navigation-eta-info > div { flex-basis: 48%; text-align: center;}
#final-destination-info.single-destination-layout {
    text-align: center; flex-basis: auto !important;}
#final-destination-info.single-destination-layout strong {
    font-size: 0.7em !important;}
#final-destination-info.single-destination-layout span {
    font-size: 1.1em !important;}
#navigation-eta-info strong {
    display: block; font-size: 0.7em; margin-bottom: 2px;}
#navigation-eta-info span { font-size: 1.1em; font-weight: bold;}
#next-stage-info { display: block;}
#navigation-eta-info #next-stage-distance,
#navigation-eta-info #final-destination-distance { margin-right: 3px;}
#navigation-eta-info #next-stage-time,
#navigation-eta-info #final-destination-time {
    margin-left: 3px; margin-right: 3px;}
#navigation-eta-info #next-stage-eta,
#navigation-eta-info #final-destination-eta {   margin-left: 3px;}
.eta-deviation {
    font-size: 0.9em !important; font-weight: bold;
    margin-left: 6px !important;}
.eta-deviation.positive { color: #FF7C39; }
.eta-deviation.negative { color: #10B981; }
#next-stage-info .eta-deviation {
    font-size: 0.9em !important; font-weight: bold; margin-left: 6px;}
#final-destination-info .eta-deviation {
    font-size: 0.9em !important; font-weight: bold; margin-left: 6px;}
#simulation-modal .modal-top-buttons {  margin-bottom: 1rem;}
#simulation-content-area {
    overflow-y: auto; margin-bottom: 1rem; padding: 0.5rem;
    background-color: #fff; border: 1px solid #ccc;
    border-radius: 0.5rem; min-height: 150px;
    font-size: 0.9rem; line-height: 1.4; flex-grow: 1;}
#simulation-content-area ul { list-style-type: none; padding-left: 0;}
#simulation-content-area li {
    padding: 0.3rem 0; border-bottom: 1px solid #eee;
    display: flex; align-items: center;}
#simulation-content-area li:last-child {  border-bottom: none;}
#simulation-modal .turn-icon-sim {
    margin-right: 8px; display: inline-flex;
    align-items: center; justify-content: center;
    width: 24px; height: 24px;
    flex-shrink: 0; vertical-align: middle;}
#simulation-modal .turn-icon-sim img {
    width: 24px !important; height: 24px !important;
    object-fit: contain;}
.favicon-red {
    filter: hue-rotate(0deg) saturate(200%) brightness(80%);}
.favicon-blue {
    filter: hue-rotate(200deg) saturate(150%) brightness(90%);}
.button-countdown-timer {
    margin-left: 5px; font-weight: normal;font-size: 1em; opacity: 0.9;}
#sortable-stages-list {
    max-height: calc(100% - 130px); overflow-y: auto;
    -webkit-overflow-scrolling: touch; touch-action: pan-y;
    padding: 0; margin: 0; list-style-type: none;
    background-color: #C8BBA0;}
#sortable-stages-list li {
    padding: 15px; min-height: 60px;
    border-bottom: 1px solid #ddd;
    transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    cursor: grab; user-select: none;
    display: flex; align-items: center; gap: 12px;
    border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    margin-bottom: 10px; color: #333;}
#sortable-stages-list li:hover:not(.dragging) {
    background-color: #f0e6c8; color: #FFFF00;
    box-shadow: 0 3px 7px rgba(0,0,0,0.15);}
.drag-handle {
    cursor: grab; padding: 0 10px; align-self: stretch;
    display: flex; align-items: center; justify-content: center;
    margin-right: 8px; touch-action: none;}
.drag-handle img { width: 24px; height: 24px; object-fit: contain;}

#sortable-stages-list li.dragging .drag-handle,
.drag-handle:active {cursor: grabbing;}
#sortable-stages-list li:hover:not(.dragging) {
    background-color: #E0D8C8; color: #FFFF00;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);}
#sortable-stages-list li:hover:not(.dragging) .stage-label-badge { color: white; }
#sortable-stages-list li:hover:not(.dragging) .delete-stage-button { color: #EF4444; }
#sortable-stages-list li:hover:not(.dragging) .delete-stage-button:hover { color: #B91C1C; }
#sortable-stages-list li:hover:not(.dragging) .stage-name-text { color: #FFFF00; }
#sortable-stages-list li:last-child {
    border-bottom: none; margin-bottom: 0;}

#sortable-stages-list li.dragging {
    opacity: 0.7; background-color: #4a4a3b;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}
.stage-label-badge {
    background-color: #555; color: white;
    padding: 4px 8px; border-radius: 4px;
    font-size: 0.85rem; min-width: 25px;
    text-align: center; flex-shrink: 0;
    font-weight: bold;}
.stage-name-text {
    flex-grow: 1; overflow: hidden; text-overflow: ellipsis;
    white-space: nowrap; font-size: 1rem; color: #333;}
.delete-stage-button {
    cursor: pointer; margin-left: auto; padding: 0 10px;
    font-size: 1.8rem; color: #EF4444; font-weight: bold;
    line-height: 1; flex-shrink: 0;}
.delete-stage-button:hover {  color: #B91C1C;}    
#search-row-map-header {
    height: 70px; min-height: 70px; max-height: 70px; margin-bottom: 2px;}   
/* === REGLA FINAL Y DEFINITIVA: OCULTA TODOS LOS CONTROLES SIN EXCEPCIN (CORREGIDA) === */
#reminders-location-map-modal.immersive-mode-active #reminders-location-map-header,
#reminders-location-map-modal.immersive-mode-active #navigation-bottom-progress-bar,
#reminders-location-map-modal.immersive-mode-active #map-info-overlay,
#reminders-location-map-modal.immersive-mode-active .map-control-custom-map-controls, /* Esto oculta el control de Brjula/Grfica */
#reminders-location-map-modal.immersive-mode-active .map-controls-bottom-right { /* Esto oculta el nuevo grupo de /Ajustes */
    display: none !important; opacity: 0;
    visibility: hidden; pointer-events: none;}  
#reminders-location-map-header .reminders-map-button-action {
    padding: 5px; font-size: 0.9rem;
    height: 60px; min-height: 60px; font-weight: bold;
    border-radius: 0.375rem; cursor: pointer;
    border: 1px solid #777; color: white;
    transition: background-color 0.2s ease, opacity 0.2s ease;
    box-shadow: 2px 5px 4px rgba(0,0,0,0.65);
    display: inline-flex; align-items: center;
    justify-content: center; text-align: center;
    flex-shrink: 0; white-space: nowrap;
    background-color: white !important;
    min-width: 60px; width: 60px; margin-bottom: 5px;}
.map-control-custom-map-controls {
    display: flex; flex-direction: row; flex-wrap: nowrap !important;
    align-items: flex-end; gap: 7px; z-index: 1001; min-width: 0;}
#navigation-graph-card {
    width: 395px; height: 160px;
    background-color: rgba(0, 0, 0, 0.60); color: white;
    border-radius: 5px; box-shadow: 0 1px 5px rgba(0,0,0,0.45);
    z-index: auto; box-sizing: border-box;
    display: flex; flex-direction: column; padding: 5px;
    position: relative; transition: all 0.4s ease-in-out;}
#reminders-location-map-header .button-row::-webkit-scrollbar {
    display: none;}
#reminders-location-map-header .button-row > *:not(:last-child) {
    margin-right: 10px;}
@media (min-width: 768px) {
    #intersection-preview-map-window {
        height: 480px;   }}

body.mobile-view #intersection-preview-map-window {
    width: 90vw; height: 50vh; max-width: 500px;
    top: 50%; left: 50%; transform: translate(-50%, -50%);}

body.mobile-view #reminders-location-map-modal {
    display: flex; flex-direction: column; position: fixed;
    top: 0; left: 0; width: 100vw; height: 100dvh;
    padding: 0; border: none; border-radius: 0;
    box-sizing: border-box; z-index: 10000;}

body.mobile-view #reminders-location-map-content-wrapper {
    display: flex; flex-direction: column;
    width: 100%; height: 100%; border-radius: 0;
    overflow: hidden;}

body.mobile-view #reminders-location-map-header {
    flex-shrink: 0; padding: 5px; background-color: #C8C8C0;}
body.mobile-view #reminders-location-map-header .button-row {
    height: auto; min-height: 0; flex-wrap: wrap;
    justify-content: center; gap: 5px; padding: 5px 0;}

body.mobile-view #reminders-location-map-header .reminders-map-button-action,
body.mobile-view #reminders-location-map-header #reorder-route-stages-button {
    height: 48px; min-height: 48px; width: 48px; min-width: 48px;
    max-width: 60px; padding: 2px; font-size: 0.7rem;}
body.mobile-view #reminders-location-map-header #map-location-search-input {
    font-size: 1.1rem; height: 48px;
    flex-grow: 1; min-width: 150px;}
body.mobile-view #reminders-location-map-header #filter-input {
    height: 48px; width: 100px; font-size: 0.9rem;}
body.mobile-view #reminders-location-map-div {
    flex-grow: 1; position: relative;}
body.mobile-view #mapbox-map-actual-container {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;}

body.mobile-view #toggle-map-header-buttons-panel {
    width: 60px; height: 60px; left: 10px;}

body.mobile-view #map-info-overlay {
    max-width: 80%; top: 10px; right: 10px;
    font-size: 0.9em;}
body.mobile-view  {
    flex-direction: column; align-items: flex-start; gap: 5px;}
body.mobile-view .reminder-modal, body.mobile-view .help-modal,
body.mobile-view .edit-info-modal, body.mobile-view .choice-modal,
body.mobile-view .edit-modal, body.mobile-view .reminder-table-modal,
body.mobile-view .postpone-options, body.mobile-view .saved-locations-modal,
body.mobile-view #reorder-stages-modal, body.mobile-view #simulation-modal,
body.mobile-view #locations-preview-modal, body.mobile-view #deviation-modal,
body.mobile-view #arrival-stats-modal, body.mobile-view #simulation-speed-modal,
body.mobile-view #saved-routes-modalsave-route-prompt-modal #cancel-save-route:hover, body.mobile-view #save-route-prompt-modal,
body.mobile-view #pin-modal-overlay,
body.mobile-view #versions-modal-overlay,
body.mobile-view #reminders-map-help-modal-instance,
body.mobile-view #intersection-preview-map-window { z-index: 11000 !important;}

body.mobile-view .route-modal-overlay { z-index: 10001 !important;}
#reminders-map-help-modal-instance { z-index: 10002 !important;}
#map-location-search-input {
    flex-grow: 1; padding: 8px 12px; border: 1px solid #ccc;
    border-radius: 4px; background-color: #fff; min-width: 300px;
    height: 60px; font-weight: bold; text-transform: uppercase;
    font-size: 1rem; box-sizing: border-box;
    margin-right: 0 !important; margin-left: 5px;}
#filter-input {
    max-width: 200px; font-size: 0.9rem; padding: 8px 5px;
    margin-left: 2PX; border: 1px solid #7c7c68;
    border-radius: 4px; font-weight: bold; height: 60px;
    background-color: #f0f0e0; box-sizing: border-box;}
#nav-map-zoomtoggle-button {
    width: 60px; min-width: 60px; height: 60px; padding: 5px;}
#reminders-location-map-header .button-row {
    display: flex; margin-left: 5px; flex-direction: row;
    flex-wrap: nowrap !important; align-items: center;
    width: 100%; height: 70px; min-height: 70px;
    padding-bottom: 5px; box-sizing: content-box;
    overflow-x: auto; overflow-y: hidden;
    -webkit-overflow-scrolling: touch; scrollbar-width: none;
    transition: opacity 0.3s ease, visibility 0.3s ease, max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;}

#alert-modal-overlay {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.75); z-index: 8000;}

#alert-modal-content {
    position: fixed; top: 25px; left: 25px;
    background-color: #E6D6A8; padding: 1rem;
    border-radius: 1rem; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    border: 2px solid #C0B080;}
#alert-columns-container { display: flex; gap: 1rem;}
.alert-column {
    display: flex; flex-direction: column; gap: 0.8rem;}

.alert-option, #alert-cancel-button {
    display: flex; align-items: center; padding: 0.75rem 1.25rem;
    background-color: #F5F5DC; border: 1px solid #A9A18C;
    border-radius: 0.5rem; cursor: pointer;
    transition: background-color 0.2s ease, transform 0.1s ease;
    width: 100%;}
.alert-option:hover {
    background-color: #FFD700; transform: translateY(-2px);}
.alert-option img {
    width: 80px; height: 50px;
    margin-right: 1rem; object-fit: contain;}
.alert-option span {
    font-size: 1.4rem; font-weight: bold; color: #333;}

#alert-cancel-button {
    background-color: #2563EB;
    justify-content: center; margin-top: auto;}

#alert-cancel-button:hover { background-color: #1D4ED8;}
#alert-cancel-button span {
    color: white !important; font-weight: bold !important;}

#accident-alert-button-map {  background-color: white !important;}
#proximity-alert-modal {
    position: fixed; top: 25px; left: 25px;
    background-color: white; border: 2px solid black;
    border-radius: 0.75rem; box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    z-index: 8500; padding: 0.8rem; display: flex;
    align-items: center; gap: 0.8rem; max-width: 450px;}
#proximity-alert-modal img {
    width: 110px; height: 85px; object-fit: contain;}
#proximity-alert-modal .content {
    display: flex; flex-direction: column; gap: 0.5rem;}

#proximity-alert-modal .alert-text {
    font-size: 1.3rem; font-weight: bold; color: #111827;}

#proximity-alert-modal button {
    padding: 0.6rem 1.2rem; font-size: 1rem;
    background-color: #2563EB; color: white;
    font-weight: bold; border: none; border-radius: 0.25rem;
    cursor: pointer; align-self: flex-start; min-width: 120px;}

#flashing-border-overlay {
    position: fixed; top: 0; left: 0;
    width: 100vw; height: 100vh; box-sizing: border-box;
    pointer-events: none; z-index: 8499;
    border: 15px solid transparent;
    animation: flash-yellow-border 1s infinite;}

@keyframes flash-yellow-border {
    0%, 100% { border-color: transparent; }
    50% { border-color: #FFFF00; }}

.traffic-alert-icon-container {
    width: 55px; height: 55px; border-radius: 50%;
    background-color: white; border: 3px solid red;
    box-shadow: 0 2px 5px rgba(0,0,0,0.5); display: flex;
    justify-content: center; align-items: center;
    overflow: hidden;
    transition: width 0.2s ease, height 0.2s ease;}
.traffic-alert-icon-container.small {
    width: 27px; height: 27px; border-width: 2px;}
.traffic-alert-icon-container img {
    width: 85%; height: 85%; object-fit: contain;}
.reminder-slide .radar-icon {
    display: block; margin: 0 auto 0.5rem auto;
    width: 90px; height: 70px; object-fit: contain;}
.filter-modal-overlay {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.7); z-index: 10000;
    display: flex; justify-content: flex-start; align-items: flex-start;
    padding-top: 10px; padding-left: 10px;}

.filter-modal-content {
    background-color: #E6D6A8; padding: 20px;
    border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    width: 90%; max-width: 500px; text-align: center;}
.filter-modal-content h2 {
    font-size: 1.5rem; font-weight: bold;
    color: #333; margin-bottom: 20px;}
.filter-group {  margin-bottom: 25px;}
.filter-group label {
    display: block; font-weight: bold;
    margin-bottom: 15px; font-size: 1.1rem;}

.slider-container {
    position: relative; width: 90%; margin: 0 auto; height: 30px;}
.slider-track,
.slider-range {
    position: absolute; height: 5px;
    border-radius: 3px; top: 12.5px; width: 100%;}

.slider-track {  background-color: #ccc; z-index: 1;}

.slider-range {background-color: #2563EB; z-index: 2;}

.slider-thumb {
    position: absolute; width: 25px; height: 25px;
    background-color: white; border: 2px solid #2563EB;
    border-radius: 50%; top: 2.5px; z-index: 3;
    cursor: pointer; box-shadow: 0 0 5px rgba(0,0,0,0.2);}

.slider-thumb.left { left: 0%; transform: translateX(-50%);}

.slider-thumb.right {  right: 0%; transform: translateX(50%);}

.filter-modal-content button#accept-filters-btn {
    background-color: #2563EB; color: white; font-weight: bold;
    padding: 10px 30px; border-radius: 5px; border: none;
    font-size: 1.1rem; cursor: pointer;
    transition: background-color 0.2s;}

.filter-modal-content button#accept-filters-btn:hover {
    background-color: #1D4ED8;}

.single-slider-container .slider-range {left: 0;}

.single-slider-container .slider-thumb { transform: translateX(-50%);}

.filter-help-text {
    font-size: 0.8rem; color: #555; margin-top: 15px;
    padding-top: 10px; border-top: 1px solid #ccc;
    text-align: left;}

.charging-point-card {
    width: 90px; height: 90px;
    background-color: rgb(30, 144, 255); color: white;
    border: 2px solid white; border-radius: 50%;
    padding: 5px; box-sizing: border-box;
    font-family: sans-serif; text-align: center;
    box-shadow: 0 2px 6px rgba(0,0,0,0.6); cursor: pointer;
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;
    gap: 1px;}

.charging-point-card p,
.charging-point-card span {
    margin: 0; padding: 0; line-height: 1.1;
    white-space: nowrap; overflow: hidden;
    text-overflow: ellipsis;}
.charging-point-card .power,
.charging-point-card .price {
    display: inline-flex; align-items: baseline; gap: 0.2em;}
.charging-point-card .power {
    font-size: 1.1rem; font-weight: bold;
    color: #ffd700; order: 1;}
.charging-point-card .operator {
    font-size: 0.8rem; font-weight: bold; order: 2;
    width: 90%; padding: 0 2px; box-sizing: border-box;}
.charging-point-card .price {
    font-size: 0.9rem; font-weight: bold;
    color: #90ee90; order: 3;}
.charging-point-card .availability {
    font-size: 0.75rem; font-weight: bold;
    color: #e0e0e0; order: 4;}
.charging-point-card .unit-text { font-size: 0.85rem; font-weight: bold;}
.charging-point-icon-simple {
    width: 32px; height: 32px; border-radius: 50%;
    background-color: rgb(30, 144, 255);
    border: 2px solid white; box-shadow: 0 1px 4px rgba(0,0,0,0.5);
    display: flex; align-items: center; justify-content: center;}
.charging-point-icon-simple img {
    width: 75%; height: 75%; object-fit: contain;}
.charging-point-popup .mapboxgl-popup-content-wrapper {
    background-color: #E6D6A8; color: #333;
    border-radius: 8px; border: 1px solid #C0B080;}
.charging-point-popup .mapboxgl-popup-content {
    font-family: sans-serif; font-size: 1rem;
    line-height: 1.4; padding: 10px; width: 300px !important;}
.charging-point-popup h3 {
    font-size: 1.2rem; font-weight: bold;
    margin-bottom: 8px; color: #1E3A8A;}
.charging-point-popup h4 {
    font-size: 1.1rem; font-weight: bold;
    margin-top: 10px; margin-bottom: 5px;
    border-top: 1px solid #ccc; padding-top: 8px;}
.charging-point-popup p {  margin: 4px 0;}
.charging-point-popup .ocm-connection-list {
    list-style: none; padding: 0; margin: 0;}
.charging-point-popup .ocm-connection-list li {
    display: flex; justify-content: space-between; align-items: center;
    padding: 4px 0; border-bottom: 1px solid #D8CEC0;}
.charging-point-popup .ocm-connection-list li:last-child {
    border-bottom: none;}
.charging-point-popup .conn-type {
    font-weight: 500; flex-basis: 45%; white-space: nowrap;
    overflow: hidden; text-overflow: ellipsis;}
.charging-point-popup .conn-power {
    flex-basis: 20%; text-align: center;}
.charging-point-popup .conn-status {
    flex-basis: 35%; text-align: center; color: white;
    padding: 2px 5px; border-radius: 3px;
    font-size: 0.8rem; font-weight: bold;}
.charging-point-popup .popup-buttons {
    display: flex; justify-content: space-around; margin-top: 12px;}
.charging-point-popup button {
    padding: 6px 12px; font-size: 1rem; border: none;
    border-radius: 4px; cursor: pointer; font-weight: bold;}
.charging-point-popup .add-to-route-btn { background-color: #28a745; color: white; }
.charging-point-popup .cancel-btn { background-color: #6c757d; color: white; }
/* === INICIO: ESTILOS PARA EL MODAL DE PDR (OCM) === */
.ocm-modal-overlay {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.60); z-index: 9500;
    display: flex; justify-content: center; align-items: center;
    padding: 15px;}
.ocm-modal-content {
    background-color: #2c2c2e; color: #f0f0f0;
    border-radius: 14px; box-shadow: 0 10px 25px rgba(0,0,0,0.6);
    width: 100%; max-width: 750px; height: 98vh;
    max-height: 850px; display: flex; flex-direction: column;
    overflow: hidden; border: 1px solid #444;}
.ocm-modal-header {
    height: 180px; background-size: cover;
    background-position: center; position: relative;
    display: flex; flex-direction: column;
    justify-content: space-between; padding: 12px;
    color: white; text-shadow: 1px 1px 3px rgba(0,0,0,0.8);}

.ocm-modal-header::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 40%, rgba(0,0,0,0.1) 70%, rgba(0,0,0,0) 100%);}
.ocm-modal-address {
    font-size: 1.25rem; font-weight: bold;
    position: relative; z-index: 1;}

.ocm-modal-operator-wrapper {
    position: relative; z-index: 1; align-self: flex-start;}

.ocm-modal-operator {
    font-size: 1.4rem; font-weight: bold;
    background-color: rgba(0, 0, 0, 0.6);
    padding: 4px 10px; border-radius: 6px;
    display: inline-block; box-shadow: 0 2px 4px rgba(0,0,0,0.4);}

.ocm-modal-tabs {
    display: flex; background-color: #1c1c1e;
    border-bottom: 1px solid #444;}

.ocm-modal-tab {
    flex: 1; padding: 12px; text-align: center;
    font-weight: bold; cursor: pointer;
    border-bottom: 3px solid transparent;
    transition: background-color 0.2s, border-color 0.2s;
    color: #a0a0a0;}
.ocm-modal-tab:hover {   background-color: #3a3a3c;}
.ocm-modal-tab.active {   border-bottom-color: #007aff; color: white;}
.ocm-modal-body {   flex-grow: 1; overflow-y: auto; padding: 15px;}
.ocm-modal-panel { display: none; }
.ocm-modal-panel.active { display: block; }
.ocm-modal-panel h4 {
    font-size: 1.1rem; font-weight: bold; color: #007aff;
    margin-top: 15px; margin-bottom: 8px;
    border-bottom: 1px solid #444; padding-bottom: 5px;}
.ocm-modal-panel h4:first-child {   margin-top: 0;}
.ocm-modal-panel p,
.ocm-modal-panel li {
    font-size: 0.95rem; line-height: 1.5; margin-bottom: 5px;}
.ocm-modal-panel a { color: #0a84ff; text-decoration: none; }
.ocm-modal-panel a:hover { text-decoration: underline; }

.ocm-photo-grid {
    display: grid;  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));  gap: 10px;}

.ocm-photo-grid img {
    width: 100%; height: 120px; object-fit: cover;
    border-radius: 8px; cursor: pointer; transition: transform 0.2s;}
.ocm-photo-grid img:hover {  transform: scale(1.05);}
.ocm-comment-list {   list-style: none; padding: 0;}
.ocm-comment {
    background-color: #3a3a3c; padding: 12px;
    border-radius: 8px; margin-bottom: 10px;}
.ocm-comment-header {
    display: flex; justify-content: space-between;
    font-size: 0.8rem; color: #a0a0a0; margin-bottom: 5px;}
.ocm-comment-header .user {  font-weight: bold;}
.ocm-modal-footer {
    padding: 15px; border-top: 1px solid #444;
    display: flex; gap: 15px;}

.ocm-modal-footer button {
    flex: 1; padding: 12px; font-size: 1.1rem;
    font-weight: bold; border-radius: 8px;
    border: none; cursor: pointer;
    transition: background-color 0.2s, opacity 0.2s;}

#ocm-add-route-btn { background-color: #34c759; color: white; }
#ocm-add-route-btn:hover { background-color: #2fb350; }
#ocm-close-btn { background-color: #5856d6; color: white; }
#ocm-close-btn:hover { background-color: #4f4dbf; }

.ocm-modal-station-name-wrapper {
    align-self: flex-start; width: 100%; text-align: left;}

.ocm-modal-station-name {
    font-size: 1.5rem; font-weight: bold;
    background-color: rgba(0, 0, 0, 0.6); padding: 4px 10px;
    border-radius: 6px; display: inline-block;
    box-shadow: 0 2px 4px rgba(0,0,0,0.4);
    margin-bottom: auto; color: #fdfbd4;}

.ocm-modal-address {
    font-size: 1.1rem; font-weight: bold;
    position: relative; z-index: 1; padding: 5px 5px;
    align-self: flex-start; margin-top: auto;}
.ocm-color-legend-icon {
    width: 24px; height: 24px;
    background-image: url('PNG/pdrs.png');
    background-size: 95%; background-repeat: no-repeat;
    background-position: center; border: 3px solid transparent;
    border-radius: 50%; box-sizing: border-box;
    flex-shrink: 0; box-shadow: 0 0 0 2px white;}

.ocm-color-legend {
    display: flex; justify-content: space-around; align-items: center;
    padding: 10px 0; margin-top: -10px; margin-bottom: 15px;}

.ocm-color-legend-item {
    display: flex; align-items: center; gap: 10px;
    font-size: 0.75rem; color: #333;}

.ocm-modal-info-footer {
    font-size: 0.8rem; color: #555; text-align: left;
    margin-top: 15px; padding-top: 10px;
    border-top: 1px solid #ccc;}

.ocm-modal-info-footer p { margin: 5px 0;}
.ocm-connection-item {
    display: flex; justify-content: space-between; align-items: center;
    padding: 4px 0; border-bottom: 1px solid #3a3a3c;}
.ocm-connection-item:last-child {    border-bottom: none;}
.ocm-connection-type {   flex-basis: 50%; font-weight: 500;}
.ocm-connection-power-status {
    flex-basis: 50%; text-align: right; color: #fdfbd4;  font-weight: bold;}
p.ocm-price-info {
    margin-top: 12px; font-size: 1.1rem;  color: #fdfbd4; text-align: center;}
.ocm-photo-modal-overlay {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.85); z-index: 11000;
    display: flex; justify-content: center; align-items: center;
    padding: 20px;}

.ocm-photo-modal-content {
    position: relative; max-width: 90vw; max-height: 90vh;}

.ocm-photo-modal-content img {
    max-width: 100%; max-height: 100%;
    border-radius: 8px; box-shadow: 0 0 30px rgba(0,0,0,0.5);}

.ocm-photo-modal-close-btn {
    position: absolute; top: -15px; right: -15px;
    width: 35px; height: 35px; background-color: white;
    color: black; border-radius: 50%;
    border: 2px solid #333; font-size: 24px;
    font-weight: bold; line-height: 32px; text-align: center;
    cursor: pointer; box-shadow: 0 4px 8px rgba(0,0,0,0.3);}

.pdr-search-highlight {
    border: 3px solid yellow !important;
    box-shadow: 0 0 10px yellow, 2px 5px 4px rgba(0,0,0,0.65) !important;
    transform: scale(1.05);}
.ocm-external-links-container {
    display: flex; align-items: center; justify-content: space-between;
    margin-top: 15px; padding: 10px;
    background-color: #3a3a3c; border-radius: 8px;}

.ocm-external-links-left-group {   display: flex; align-items: center;}
.ocm-external-links-label {
    font-weight: bold; color: #c7c7cc;
    font-size: 0.9rem; white-space: nowrap;}
.ocm-external-links-note {
    font-size: 0.6rem; color: #8e8e93;
    margin-left: 5rem; white-space: nowrap;}
.ocm-external-links-buttons {  display: flex; gap: 10px;}
.ocm-external-link-btn {
    display: flex; align-items: center; justify-content: center;
    width: 40px; height: 40px; padding: 5px;
    background-color: #f0f0f0; border: none;
    border-radius: 8px; cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;}

.ocm-external-link-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 0 8px rgba(255, 255, 255, 0.7);}

.ocm-external-link-btn img {
    width: 100%; height: 100%; object-fit: contain;}
.btn-modal-cancel {
    background-color: #C0392B; color: white; font-weight: normal;}
#close-saved-routes-modal.btn-modal-action-secondary {
    background-color: #C0392B;}
.btn-modal-action-secondary {
    background-color: red; color: white; font-weight: normal;}
#arrival-stats-modal {
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%); background-color: #2c2c2e;
    color: #f0f0f0; border-radius: 14px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.6);
    width: 99%; max-width: 1050px; max-height: 97vh;
    display: flex; flex-direction: column; overflow: hidden;
    border: 1px solid #444; z-index: 11006;}
.arrival-stats-header {
    height: 150px;
    background-image: url('https://boardinggate.github.io/Tesla/PNG/modal-finish.jpg');
    background-size: cover; background-position: center;
    position: relative; display: flex; flex-direction: column;
    justify-content: space-between; padding: 10px; color: white;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.7); flex-shrink: 0;}
.arrival-stats-header::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.3) 50%, rgba(0,0,0,0) 100%);}
.arrival-stats-header h2 {
    font-size: 1.7rem; font-weight: bold; position: relative;
    z-index: 1; margin: 0; text-shadow: 1px 1px 4px rgba(0,0,0,0.7);}
.arrival-stats-header .destination-name {
    font-size: 1.1rem; font-weight: 500; margin-right: 180px;
    position: relative; z-index: 1; background-color: rgba(0,0,0,0.5);
    padding: 4px 8px; border-radius: 6px; align-self: flex-start;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.6);}
.arrival-stats-body {
    padding: 15px; background-color: #2c2c2e;
    overflow-y: auto; flex-grow: 1;}
.stats-section-header {
    font-size: 1.1rem; font-weight: bold; color: #007aff;
    margin-bottom: 15px; padding-bottom: 8px;
    border-bottom: 1px solid #444;}
.stats-section-header:not(:first-child) {  margin-top: 23px;}
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 13px;}
.stat-card {
    background-color: #3a3a3c; border-radius: 10px;
    padding: 13px; text-align: center;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    gap: 8px; border: 1px solid #4a4a4a;
    min-height: 110px;}
.stat-icon svg {   width: 28px; height: 28px; color: #e0e0e0;}
.stat-label { font-size: 0.9rem; color: #b0b0b0; font-weight: 500;}
.stat-value {
    font-size: 1.5rem; font-weight: bold; color: #f0f0f0;
    line-height: 1.2; text-shadow: 1px 1px 3px rgba(0,0,0,0.5);}
.initial-eta-details {
    grid-column: 1 / -1; background-color: transparent;
    border: 1px dashed #555; padding: 10px;
    font-size: 0.90rem; color: #b0b0b0; text-align: center;
    border-radius: 8px; margin-top: 8px;}
.arrival-stats-footer {
    padding: 8px; border-top: 1px solid #444;
    display: flex; justify-content: center;
    background-color: #1c1c1e; flex-shrink: 0;}
#arrival-stats-modal .eta-deviation.positive { color: #FF6347; }
#arrival-stats-modal .eta-deviation.negative { color: #7CFC00; }
#arrival-stats-modal .stat-value button#show-max-speed-location-button {
    font-size: 0.8rem; padding: 1px 5px; line-height: 1.2;
    height: auto; margin-left: 5px; vertical-align: middle;
    background-color: #D1D5DB; color: blue;
    border: 1px solid #9CA3AF; border-radius: 5px; font-weight: bold;}
.arrival-stats-footer button {
    padding: 12px 10px; font-size: 1.2rem; font-weight: bold;
    border-radius: 8px; border: 1px solid #bbb;
    cursor: pointer; background-color: #FFFFFF;
    color: #1c1c1e; transition: background-color 0.2s;}
.arrival-stats-footer button:hover {
    background-color: #e0e0e0;}
/* === INICIO: CSS PARA EL MODAL DE RECORDATORIOS (DISEO MODERNO v5) === */
.reminder-modal {
    background-color: #2c2c2e; color: #f0f0f0;
    border-radius: 14px; box-shadow: 0 10px 25px rgba(0,0,0,0.6);
    border: 1px solid #444; padding: 0;
    display: flex; flex-direction: column; font-size: 1rem;
    position: fixed; top: 1%; left: 50%;
    transform: translate(-50%, 0); max-width: 96%; width: 95%;
    max-height: 95vh; overflow: hidden;}

.reminder-modal-header {
    height: 60px;
    background-image: url('PNG/recordatorios.jpg');
    background-size: cover; background-position: center;
    position: relative; display: flex; align-items: center;
    justify-content: space-between; padding: 0.5rem 1.5rem;
    border-radius: 14px 14px 0 0; flex-shrink: 0;}

.reminder-modal-header::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.3) 50%, rgba(0,0,0,0) 100%);
    border-radius: 14px 14px 0 0;}

.reminder-modal-title {
    font-size: 1.5rem; font-weight: bold; color: white;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8); z-index: 1;}

.reminder-modal .header-options { z-index: 1; }

.reminder-modal .form-label-exclude {
    display: flex; align-items: center; color: #ccc;
    cursor: pointer; font-size: 0.9rem; font-weight: 500;}

.reminder-modal .form-label-exclude input {
    margin-right: 0.5rem; transform: scale(1.1);}

.reminder-modal-body { padding: 0.5rem 1.5rem; flex-grow: 1; overflow-y: auto;}

.reminder-modal-form {  display: flex; flex-direction: column; gap: 0.1rem;}

.reminder-modal .form-section { display: flex; flex-direction: column; gap: 0.3rem;}

.reminder-modal .input-with-buttons {
    display: flex; align-items: stretch; gap: 0.75rem; margin-top: 0.3rem;}

.reminder-modal #reminder-text {
    flex-grow: 1; background-color: #3a3a3c;
    border: 1px solid #555; color: #f0f0f0;
    border-radius: 8px; padding: 0.75rem;
    font-size: 1.1rem; resize: vertical; min-height: 45px;
    text-transform: uppercase;}

.reminder-modal .clear-button {
    width: 45px; height: 45px; background-color: #48484a;
    border: 1px solid #5f5f61; border-radius: 8px;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; flex-shrink: 0;}

.reminder-modal .clear-button svg { width: 22px; height: 22px; stroke: #ff9500;}

.reminder-modal .parse-status {
    font-size: 0.6rem; color: #8e8e93; text-align: right;
    margin-top: -0.2rem; min-height: 1em;}

.reminder-modal .controls-grid {
    display: grid; grid-template-columns: auto auto auto 1fr;
    align-items: end; gap: 15px 30px; margin-top: 4px;}

.reminder-modal .control-item {
    display: flex; flex-direction: column; gap: 0.2rem;}

.reminder-modal .form-label {
    font-size: 0.85rem; color: #a0a0a0; margin-bottom: 0;}

.reminder-modal input[type="text"],
.reminder-modal input[type="number"] {
    background-color: #3a3a3c; border: 1px solid #555;
    color: #f0f0f0; border-radius: 8px; padding: 0.5rem;
    font-size: 1rem; text-align: center; min-width: 80px;}

.days-group-grid-item {
    display: flex; flex-direction: column; gap: 0.2rem; margin-left: 20px;}

.reminder-modal .days-checkbox-container { display: flex; gap: 0.4rem; flex-wrap: nowrap;}

.reminder-modal .days-group-grid-item label {
    display: flex; align-items: center;
    cursor: pointer; user-select: none;}

.reminder-modal .days-group-grid-item input[type="checkbox"] {
    display: none;}
.reminder-modal .days-group-grid-item span {
    padding: 0.35rem 0.8rem; border: 1px solid #555;
    background-color: #3a3a3c; color: white;
    border-radius: 20px; font-size: 0.9rem;}

.reminder-modal .days-group-grid-item input[type="checkbox"]:checked + span {
    background-color: #007aff; border-color: #007aff;
    font-weight: bold;}

.reminder-modal .location-section {
    background-color: rgba(255, 255, 255, 0.05); padding: 0.7rem;
    border-radius: 8px; border: 1px solid #444; margin-top: 20px;}

.reminder-modal .location-header {
    display: flex; justify-content: space-between;
    align-items: center; gap: 1rem;}
.reminder-modal .form-label-location {
    display: flex; align-items: center; font-size: 1rem;
    font-weight: bold; color: #f0f0f0; cursor: pointer;flex-shrink: 0;}
.reminder-modal .form-label-location input[type="checkbox"] {
    width: 1.2rem; height: 1.2rem; margin-right: 0.6rem;}
.reminder-modal .radius-slider-group {
    display: flex; align-items: center; gap: 0.75rem;
    flex-grow: 1;}
.reminder-modal .radius-slider-group .form-label {
    white-space: nowrap; font-size: 0.8rem;}
.reminder-modal .expand-map-button {
    background-color: #007aff; color: white; border: none;
    border-radius: 8px; padding: 0.4rem 0.8rem;
    font-size: 0.9rem; font-weight: bold; display: inline-flex;
    align-items: center; gap: 0.4rem; cursor: pointer;
    flex-shrink: 0;}
.reminder-modal #location-controls-container { margin-top: 0.8rem;}
.reminder-modal .location-map-container {
    height: 65px; border-radius: 8px; background-color: #1c1c1e;
    border: 1px solid #555; position: relative;}
.reminder-modal .location-map-container.expanded { height: 310px;}
.reminder-modal-footer {
    flex-shrink: 0; padding: 0.8rem 1.5rem;
    border-top: 1px solid #444; background-color: #1c1c1e;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(135px, 1fr));
    gap: 0.75rem; border-radius: 0 0 14px 14px;}

.reminder-modal .action-button {
    padding: 0.8rem; font-size: 1rem; font-weight: bold;
    border-radius: 8px; border: none; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    gap: 0.5rem; min-height: 55px;}

.reminder-modal .action-button.primary { background-color: #007aff; color: white; padding: 0.8rem 2.2rem; }
.reminder-modal .action-button.secondary { background-color: #555; color: white; }
.reminder-modal .action-button.danger { background-color: #ff3b30; color: white; }

.reminder-modal #countdown-save {
    font-size: 1rem; font-weight: normal; opacity: 0.8;
    background-color: rgba(255,255,255,0.2);
    padding: 2px 6px; border-radius: 10px; margin-left: 8px;}

.help-modal {
    background-color: #2c2c2e; color: #f0f0f0;
    border-radius: 14px; box-shadow: 0 10px 25px rgba(0,0,0,0.6);
    border: 1px solid #444; padding: 0; height: 80vh;
    display: flex; flex-direction: column;}

.help-modal .reminder-modal-body {    flex-grow: 1; overflow-y: auto;}

.help-modal h2, .help-modal h3 { color: white; }
.help-modal .reminder-modal-body ul { list-style: none; padding-left: 0; }
.help-modal .reminder-modal-body li { padding-left: 1.2rem; position: relative; }

.help-modal .reminder-modal-body li::before {
    content: ''; color: #007aff; font-weight: bold;
    position: absolute; left: 0; top: 2px;}

.reminder-modal .form-grid,
.reminder-modal .days-group:not(.days-group-grid-item) {  display: none;}
.reminder-modal .full-width { display: contents; }
#arrival-stats-modal .arrival-stats-layout-grid {
    display: grid; grid-template-columns: 2fr 1fr;
    gap: 25px; align-items: start;}
#arrival-stats-modal .main-stats-container,
#arrival-stats-modal .side-stats-container {
    display: flex; flex-direction: column; gap: 20px;}

#arrival-stats-modal .side-stats-container .stats-section-header:not(:first-child) {
    margin-top: 0;}

@media (max-width: 1000px) {
    #arrival-stats-modal .arrival-stats-layout-grid {
        grid-template-columns: 1fr;  }}

.maneuver-highlight, .maneuver-highlight-south {   border-radius: 8px;}

.maneuver-highlight { animation: flash-yellow-halo 1.3s infinite; }
.maneuver-highlight-south { animation: flash-red-halo 1.1s infinite; }

@keyframes flash-yellow-halo {
    0%, 100% { box-shadow: 0 0 0 0 rgba(255, 255, 0, 0); }
    50% { box-shadow: 0 0 21px 9px rgba(255, 255, 0, 1); }}

@keyframes flash-black-halo {
    0%, 100% { box-shadow: 0 0 0 0 rgba(0, 0, 0, 0); }
    50% { box-shadow: 0 0 21px 9px rgba(0, 0, 0, 1); }}

@keyframes flash-red-halo {
    0%, 100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
    50% { box-shadow: 0 0 21px 9px rgba(255, 0, 0, 1); }}
.route-label-marker {
    display: flex; align-items: center; justify-content: center;
    border-radius: 50%; color: white; font-weight: bold;
    font-size: 14px; font-family: Arial, sans-serif;
    text-align: center; box-shadow: 0 0 5px rgba(0,0,0,0.7);
    border: 2px solid white; cursor: pointer;
    transition: transform 0.2s ease; width: 40px; height: 40px;}
.route-label-marker:hover {
    transform: scale(1.1);}
#user-info-header {
    position: absolute !important; top: -30px; left: 1060px;
    transform: translateX(-100%); display: flex;
    align-items: center; gap: 10px; z-index: 800;}

#open-chat-area { cursor: pointer; }
#user-id-display, #user-count-globe, #chat-icon-button {
    position: static; top: auto; right: auto; transform: none;}
#user-id-display {
    font-weight: bold; font-size: 1.1rem; color: #5C5C47;
    padding: 4px 4px; background-color: rgba(171, 171, 153, 0.7);
    border-radius: 1px; white-space: nowrap;
    text-align: right; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4);}

#user-count-globe {
    background-color: #FFA500; color: white;
    border: 2px solid white; border-radius: 50%;
    width: 42px; height: 32px; display: flex;
    align-items: center; justify-content: center;
    font-weight: bold; font-size: 0.9rem; cursor: pointer;
    box-shadow: 1px 1px 3px rgba(0,0,0,0.4);}

#chat-icon-button {
    background-color: #2563EB; color: white;
    border: 2px solid white; border-radius: 50%;
    min-width: 42px; height: 32px; padding: 0 8px;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; box-shadow: 1px 1px 3px rgba(0,0,0,0.4);
    position: relative; font-weight: bold;
    font-size: 0.9rem; line-height: 1;}

/* === INICIO: ESTILOS COMPLETOS PARA EL MODAL DEL CHAT (V5) === */
#chat-modal-overlay {
    position: fixed; inset: 0;
    background-color: rgba(0, 0, 0, 0.85);
    z-index: 9000; display: flex; padding: 0;}
#chat-modal-content {
    background-color: #2c2c2e; color: #f0f0f0;
    border-radius: 0; box-shadow: none; border: none;
    width: 100%; display: flex; flex-direction: row;
    overflow: hidden;}
#chat-messages-container {
    flex-grow: 1; padding: 1rem; overflow-y: auto;
    display: flex; flex-direction: column; gap: 0.75rem;}

#chat-left-column {
    flex-grow: 1; display: flex;
    flex-direction: column; overflow: hidden;}
#chat-right-column {
    flex-shrink: 0; width: 250px;
    background-color: #1c1c1e; border-left: 1px solid #444;
    display: flex; flex-direction: column; overflow: hidden;}

#chat-users-filter-container {
    padding: 0.75rem; background-color: #3a3a3c;
    border-bottom: 1px solid #444; flex-shrink: 0;}

#chat-user-filter-input {
    width: 100%; padding: 0.5rem 0.75rem;
    background-color: #2c2c2e; border: 1px solid #555;
    color: #f0f0f0; border-radius: 6px; font-size: 0.9rem;}

#chat-user-filter-input::placeholder { color: #8e8e93; }
#chat-users-list {
    padding: 0.5rem; overflow-y: auto; flex-grow: 1;}

.chat-user-item {
    padding: 0.5rem; border-bottom: 1px solid #333;
    cursor: pointer; transition: background-color 0.2s}

.chat-user-item:hover { background-color: #3a3a3c; }
.chat-user-name { display: block; font-weight: bold; color: #0a84ff; }
.chat-user-details { display: block; font-size: 0.75rem; color: #a0a0a0; }
.chat-no-users { font-style: italic; color: #8e8e93; text-align: center; margin-top: 1rem; }
#chat-input-area {
    padding: 1rem; border-bottom: 1px solid #444;
    background-color: #1c1c1e; flex-shrink: 0;}

#chat-permission-warning {
    background-color: #b91c1c; color: white;
    padding: 0.5rem; margin-bottom: 0.75rem;
    border-radius: 6px; text-align: center;
    font-size: 0.9rem;}

#chat-message-input {
    width: 100%; background-color: #3a3a3c;
    border: 1px solid #555; color: #f0f0f0;
    border-radius: 8px; padding: 0.75rem; font-size: 1rem;
    resize: none; line-height: 1.4; margin-bottom: 0.75rem;}

#chat-message-input::placeholder { color: #746969; }

#chat-input-footer {
    display: flex; justify-content: space-between; align-items: center;}

#chat-buttons {
    display: flex; gap: 1rem; flex-grow: 1;}

#chat-send-button, #chat-exit-button {
    flex: 1; padding: 0.75rem; font-size: 1.1rem;
    font-weight: bold; border-radius: 8px;
    border: none; cursor: pointer;}

#chat-send-button { background-color: #007aff; color: white; }
#chat-exit-button { background-color: #555; color: white; }
#chat-send-button:disabled { background-color: #444; cursor: not-allowed; }

#chat-char-counter {
    font-size: 0.8rem; color: #8e8e93;
    margin-left: 1rem; flex-shrink: 0;}

.chat-message-bubble {
    max-width: 75%; padding: 0.6rem 0.9rem;
    border-radius: 18px; display: flex; flex-direction: column;}

.chat-message-bubble.sent { align-self: flex-end; border-bottom-right-radius: 4px; }
.chat-message-bubble.received { align-self: flex-start; border-bottom-left-radius: 4px; }
.chat-message-bubble.public-msg { background-color: #2e7d32; }
.chat-message-bubble.private-msg { background-color: #1565c0; }
.chat-message-bubble.private-msg-sent { background-color: #0d47a1; }
.chat-message-bubble.sent.public-msg { background-color: #DF6565 !important; }

.chat-message-sender {
    font-size: 0.9rem; font-weight: bold;
    margin-bottom: 4px; opacity: 0.8;}

.chat-message-content {
    word-wrap: break-word; overflow-wrap: break-word;
    white-space: pre-wrap; line-height: 1.4;}

.chat-message-time {
    font-size: 0.8rem; align-self: flex-end;
    margin-top: 4px; opacity: 0.7; display: flex;
    align-items: center; gap: 8px;}

.chat-system-message {
    text-align: center; font-style: italic;
    color: #8e8e93; padding: 1rem;}

.chat-message-actions {
    display: flex; align-items: center;
    gap: 16px; margin-left: 8px;}

.chat-action-icon {
    width: 30px; height: 30px; cursor: pointer;
    opacity: 0.7; transition: opacity 0.2s;}
.chat-action-icon:hover { opacity: 1; }

/* === INICIO: ESTILOS RESPONSIVE PARA EL CHAT EN MVILES === */
@media (max-width: 768px) {
    #chat-left-column { flex-basis: 70%; min-width: 70%; }
    #chat-right-column { flex-basis: 30%; min-width: 100px; }}
.reminder-modal .button-and-status-wrapper {
    display: flex; flex-direction: column;
    align-items: center; gap: 0.2rem; flex-shrink: 0;}
.reminder-modal .speech-status,
.reminder-modal .parse-status {
    font-size: 0.7rem; color: #8e8e93; text-align: center;
    min-height: 1em; width: 100%; margin-top: 0;}
.mapbox-control {
    display: flex; align-items: center; justify-content: center;
    padding: 0.3rem 0.6rem; background-color: rgba(200,200,180,0.7);
    border-radius: 5px; height: 60px; min-width: 70px;
    box-sizing: border-box; gap: 3px;}
#mapbox-primary-checkbox {
    margin-right: 0px; margin-bottom: 0px; transform: scale(1.1);}
.mapbox-label-container {
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;}
#mapbox-primary-checkbox + .mapbox-label-container > label {
    font-weight: bold; font-size: 0.70rem; color: #333;
    cursor: pointer; text-align: center;
    line-height: 1.1; margin-bottom: 1px;}
/* === INICIO: CSS PARA ICONOS CIRCULARES DE RADAR (ESCALABLES) === */
.radar-speed-circle {
    border-radius: 50%; background-color: red;
    border: 3px solid white; box-sizing: border-box;
    display: flex; align-items: center; justify-content: center;
    color: yellow; font-weight: bold;
    font-family: Arial, sans-serif;
    text-shadow: 1px 2px 2px rgba(0,0,0,0.5);
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.7));}

.radar-alert-circle {
    border-radius: 50%; background-color: red;
    border: 3px solid #e905f3; box-sizing: border-box;
    display: flex; align-items: center; justify-content: center;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.7));}

.radar-alert-circle img {
    width: 70%; height: 70%; object-fit: contain;}

/* === INICIO: ESTILOS PARA ENCUESTAS/VOTACIONES EN EL CHAT (V3) === */
.chat-poll-bubble {
    background-color: #3d3a4b; align-self: stretch;
    max-width: 95%; margin: 30px auto;
    border-radius: 12px; border: 1px solid #5a576b;
    position: relative; padding: 0.75rem 1rem 0.5rem 1rem;}

.poll-sender-info {
    display: flex; align-items: baseline; margin-bottom: 0.5rem; gap: 30px;}

.poll-sender-info .chat-message-sender {  color: #f0f0f0; opacity: 1;}

.poll-time { font-size: 0.75rem; color: #a0a0a0; }
.poll-question { font-size: 1.1rem; font-weight: bold; color: #ffd700; margin-bottom: 0.75rem; }
.poll-options-list { list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 0.5rem; }

.poll-option-item {
    display: flex; flex-direction: column; gap: 0.25rem;}

.poll-option-button {
    display: flex; justify-content: space-between; align-items: center;
    padding: 0.5rem 0.75rem; background-color: #4a475a;
    border: 1px solid #6a677a; border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.1s;
    width: 100%;}

.poll-option-button:hover {
    background-color: #5a576a; transform: translateY(-1px);}

.poll-option-button.voted {
    background-color: #007aff; border-color: #0056b3; font-weight: bold;}

.poll-option-text { color: #f0f0f0; flex-grow: 1; text-align: left; }

.poll-vote-count {
    color: #f0f0f0; font-weight: bold;
    background-color: rgba(0,0,0,0.2);
    padding: 2px 8px; border-radius: 10px;
    min-width: 25px; text-align: center;}

.poll-progress-bar {
    width: 100%; height: 6px; background-color: #2c2a3b;
    border-radius: 3px; overflow: hidden;}

.poll-progress-fill {
    height: 100%; background-color: #007aff;
    border-radius: 3px; transition: width 0.3s ease-in-out;}

.poll-voters-container { padding: 4px 8px; margin-top: 2px; }
.poll-voter-list { list-style: none; padding: 0; margin: 0; display: flex; flex-wrap: wrap; gap: 2px 8px; }

.poll-voter-name {
    font-size: 0.7rem; color: #b0b0b0;
    background-color: rgba(0,0,0,0.15);padding: 1px 5px; border-radius: 4px;}

.poll-moderation-icons {
    position: absolute; top: 6px; right: 8px; display: flex; gap: 25px; background-color: transparent;}

.tareas-ruta-control,
.radares-ruta-control,
.mapbox-control {
    margin-right: 5px !important;}
#free-drive-stats-card {
    max-width: 300px;    width: 100%;   margin-left: auto;
    margin-right: auto;   padding: 8px 12px;
    color: white;  text-align: left;
    background-color: transparent;}

#free-drive-stats-card .fd-title {
    font-size: 0.8em; font-weight: bold;
    color: white;  margin: 0;
    padding: 0; line-height: 1.2;
    text-align: center; text-shadow: 1px 1px 3px rgba(0,0,0,0.9);
    margin-bottom: 5px;}

#free-drive-stats-card .fd-subtitle {
    font-size: 0.5em; color: #cccccc;
    margin-bottom: 1px; text-align: center;}

#free-drive-stats-card .fd-stats-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 4px; align-items: center;}

#free-drive-stats-card .fd-label {
    font-size: 0.65em;color: #dddddd;
    font-weight: bold;
    text-align: center;  font-weight: 500; margin-bottom: 0px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); /* <-- LNEA AADIDA */}    

#free-drive-stats-card .fd-stat-item {
    display: flex; flex-direction: column;
    align-items: center; gap: 0px;}

#free-drive-stats-card .fd-data {
    font-size: 1.1em; font-weight: bold;
    color: #87CEEB;   text-align: center;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.9);}
#location-map-container.expanded .mapboxgl-canvas,
#location-picker-map-container.expanded .mapboxgl-canvas,
#reminders-location-map-div #mapbox-map-actual-container .mapboxgl-canvas {
    cursor: crosshair !important;}
#reminders-location-map-div.simulating-gps-click-mode #mapbox-map-actual-container .mapboxgl-canvas {
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="%23FF0000" stroke="white" stroke-width="1"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>') 14 28, crosshair !important;}
#reminders-location-map-div.navigating #mapbox-map-actual-container .mapboxgl-canvas {
    cursor: default !important;}
#reminders-location-map-div.add-reminder-mode #mapbox-map-actual-container .mapboxgl-canvas {
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="%23008000" stroke="white" stroke-width="1"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle><line x1="12" y1="7" x2="12" y2="13"></line><line x1="9" y1="10" x2="15" y2="10"></line></svg>') 14 28, crosshair !important;}
.mapboxgl-popup {
    max-width: 250px !important;  font-family: sans-serif;font-size: 0.9rem;}
.mapboxgl-popup-content {
    padding: 10px;  z-index: 10001; }
.mapboxgl-popup-close-button {
    font-size: 1.5rem; padding: 0 5px;}
.mapboxgl-marker.dragging {  cursor: grabbing;}

/* === REGLAS NUEVAS Y MODIFICADAS PARA MAPBOX === */
#reminders-location-map-modal {
    position: fixed; top: 0; left: 0;
    width: 100vw; height: 100dvh; /* Usa dvh para compatibilidad mvil */
    background-color: #D8D8D0; z-index: 6500;
    display: flex;
    flex-direction: column;
    padding: 2px; box-sizing: border-box;}

#reminders-location-map-content-wrapper {
    background-color: #F0EFE4; width: 100%;
    border-radius: 0.75rem; box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    display: flex; flex-direction: column;
    flex-grow: 1;
    overflow: hidden;}
#reminders-location-map-header { flex-shrink: 0; }
#reminders-location-map-div { flex-grow: 1;  position: relative; overflow: hidden;}
#mapbox-map-actual-container {  width: 100%;   height: 100%; background-color: #333;}
.mapboxgl-ctrl-top-right .mapboxgl-ctrl {   margin: 10px 10px 0 0;  float: none;}
.mapboxgl-ctrl-bottom-right .mapboxgl-ctrl-attrib,
.mapboxgl-ctrl-logo {   display: none !important;}
.mapboxgl-ctrl-top-left .mapboxgl-ctrl-group {   display: none;}

.map-control-custom-map-controls {
    display: flex;
    flex-direction: row; flex-wrap: nowrap !important;
    align-items: flex-end;
    gap: 7px; z-index: 1001;
    min-width: 0;}
.map-control-custom-map-controls > * {
    flex-shrink: 0 !important;min-width: 0 !important;}

.map-control-orientation-altitude {
    transform: none !important;
    background-color: rgba(0,0,0,0.7);
    color: white;padding: 8px;
    border-radius: 3px; box-shadow: 0 1px 5px rgba(0,0,0,0.40);
    text-align: center;  display: flex; flex-direction: column;
    justify-content: center; box-sizing: border-box;
    cursor: pointer;width: 130px;
    min-width: 130px; flex-shrink: 0; height: 160px; font-weight: bold;}

.vehicle-maneuver-overlay {
    position: absolute;
    top: -25px;    left: 50%;    transform: translateX(-50%);
    width: 40px;   height: 40px;   background-size: contain;
    background-repeat: no-repeat;    background-position: center;
    display: none;}
/* === INICIO: CSS PARA ICONO DE VEHCULO EN MINIMAPA (LEAFLET) === */
.vehicle-icon-minimap {
    width: 48px;    height: 48px;    position: relative;}
.vehicle-icon-minimap img {
    width: 100%;   height: 100%;    object-fit: contain;}
.vehicle-maneuver-overlay-minimap {
    position: absolute;  top: -20px;   left: 50%;
    transform: translateX(-50%); width: 32px;    height: 32px;
    background-size: contain;
    background-repeat: no-repeat; background-position: center;
    display: none;}   
.vehicle-icon-minimap-leaflet-container {   position: relative !important;}
.mapboxgl-canary { background-color: transparent !important;}
.map-combined-control-container .map-layer-selector,
.map-combined-control-container .map-view-selector {
    display: flex;   flex-direction: column; gap: 4px;}
.map-combined-control-container .map-view-selector {
    border-top: 1px solid rgba(255,255,255,0.2);
    margin-top: 6px;    padding-top: 6px;}

.map-combined-control-container {
    background: rgba(44, 44, 46, 0.35);
    color: white;
    padding: 8px 10px;    border-radius: 6px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.2);}   
.map-combined-control-container label {
    display: flex;    align-items: center;      cursor: pointer;
    font-weight: bold;   font-size: 0.9rem;
    white-space: nowrap;
    transition: background-color 0.2s;   border-radius: 4px;
    padding: 8px 8px;     }
    
.map-combined-control-container label:hover {
    background-color: rgba(255,255,255,0.15);}
.map-combined-control-container input[type="radio"] {
    margin-right: 8px;
    vertical-align: middle;    appearance: none;
    -webkit-appearance: none;
    background-color: #333;   border: 1px solid #888;
    width: 16px;   height: 16px;
    border-radius: 50%;   position: relative;
    cursor: pointer;}
.map-combined-control-container input[type="radio"]:checked {
    background-color: #2a82e0; border-color: #fff;}
.map-combined-control-container input[type="radio"]:checked::after {
    content: '';
    display: block;    width: 8px;    height: 8px;    border-radius: 50%;
    background: white;    position: absolute;
    top: 50%;    left: 50%;
    transform: translate(-50%, -50%);}

/* === INICIO: CSS PARA MINIMAPA DE INTERSECCIN (LEAFLET) === */
#intersection-preview-map-window {
    position: absolute; background-color: rgba(0, 0, 0, 0.75);
    border-radius: 7px; z-index: 7000;
    box-shadow: 0 6px 12px rgba(0,0,0,0.5); overflow: hidden;
    animation: flash-black-halo 1.3s infinite;}
#intersection-rotator {
    width: 100%;     height: 100%; transition: transform 0.3s ease-out;}
#intersection-preview-map-container {
    width: 100%;    height: 100%; filter: contrast(110%) brightness(120%) saturate(125%);}     
/* === INICIO: CSS PARA MODALES DE ACCIN DEL MAPA === */
.map-item-modal-overlay {
    position: fixed;    top: 0;    left: 0;
    width: 100%;    height: 100%;
    background-color: rgba(0, 0, 0, 0.4);z-index: 10002;
    display: flex;  justify-content: center;
    align-items: center;}
.map-item-modal-content {
    background-color: #E6D6A8;
    color: #333;   border-radius: 10px;  border: 1px solid #C0B080;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);padding: 15px;
    width: 90%;    max-width: 350px; font-family: sans-serif;}
.map-item-modal-content h3 {
    font-size: 1.2rem;   font-weight: bold;    margin: 0 0 8px 0;
    color: #1E3A8A;  word-wrap: break-word;}
.map-item-modal-content hr {
    border: none;    border-top: 1px solid #C0B080;margin: 10px 0;}
.map-item-modal-content p {margin: 5px 0;    font-size: 0.95rem;}
.map-item-modal-buttons {
    margin-top: 15px; display: flex; flex-wrap: wrap;    gap: 13px;
    justify-content: center;}
.map-item-modal-buttons button {
    padding: 14px 16px;    font-size: 1rem;    border: none;
    border-radius: 4px;    cursor: pointer;   font-weight: bold;
    color: white;    flex-grow: 1;min-width: 100px;}    
#map-info-overlay {
    position: absolute;
    top: 4px;
    right: 4px;
    z-index: 1001;
    background-color: transparent; /* Fondo 100% transparente */
    color: black;                  /* Letra negra */
    font-weight: bold;             /* Letra en negrita */
    text-shadow: 
        -1px -1px 0 #fff,  
         1px -1px 0 #fff,
        -1px  1px 0 #fff,
         1px  1px 0 #fff;
    padding: 4px 8px;
    border-radius: 5px;
    box-shadow: none; /* Quitamos la sombra de la caja */
    max-width: 300px;
    font-size: 0.9em;
    text-align: center;
    display: none;
    transition: opacity 0.3s ease-in-out;
}

#map-info-overlay.error-overlay {
    background-color: rgba(220, 50, 50, 0.75) !important; /* Fondo rojo para errores */
    color: white !important; /* Letra blanca para errores */
    text-shadow: 1px 1px 2px black !important; /* Sombra oscura para letra blanca */
}    
    
#reminders-location-map-modal.map-modal-hidden {
    display: flex;  visibility: hidden;    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease, visibility 0s linear 0.3s;}
#address-suggestions-modal {
    position: fixed; left: 5%; width: 90%; transform: none;
    background-color: #E6D6A8; padding: 1rem;
    border-radius: 0.5rem; box-shadow: 0 4px 10px rgba(0,0,0,0.25);
    z-index: 11005 !important; 
    display: flex; flex-direction: column;
    border: 1px solid #C0B080;}    
.toast-instructional {
    background-color: #CF7C00;     color: white; 
    font-size: 1.3rem;    font-weight: bold;
    border: 2px solid #FFCDD2;
    box-shadow: 0 6px 15px rgba(0,0,0,0.4); max-width: 600px;
    text-align: center;    line-height: 1.4;}  
/* === INICIO: NUEVOS ESTILOS PARA AGRUPAR CONTROLES DEL MAPA === */   
#toggle-progress-bar-lock {
    width: 36px;  height: 36px;
    display: flex; align-items: center;
    justify-content: center;
    background-color: rgba(255, 255, 255, 0.1); border-radius: 50%;
    transition: background-color 0.2s ease; position: absolute;
    top: 3px;  left: 3px; z-index: 2;}
#toggle-progress-bar-lock:hover { background-color: rgba(255, 255, 255, 0.3);}
#toggle-progress-bar-lock img {
    width: 28px;height: 28px;  object-fit: contain;}  
/* === REGLA MODIFICADA: AADIR TRANSICIN A LA BARRA DE PROGRESO === */
#navigation-bottom-progress-bar {
    position: absolute; top: 5px; left: 5px; transform: none;
    width: auto; max-width: 500px; min-width: 480px;
    background-color: rgba(0, 0, 0, 0.6); padding: 8px;
    border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    z-index: 1001; color: white; display: none;
    transition: opacity 0.4s ease-out, visibility 0.4s ease-out, transform 0.4s ease-out; /* TRANSICIN AADIDA/MODIFICADA */}

/* === NUEVA REGLA: PARA DESLIZAR PARCIALMENTE LA BARRA DE PROGRESO === */
#navigation-bottom-progress-bar.progress-bar-partially-hidden {
    transform: translateY(-105px) !important;}    
#navigation-top-info-bar {
    margin-bottom: 8px; font-size: 1.2em;
    display: flex; align-items: center;
    position: relative; cursor: pointer;}
#navigation-bottom-progress-bar hr {
    border: none;  border-top: 1px solid rgba(229, 209, 193, 0.5);
    margin: 10px 0;}
#navigation-top-info-bar .turn-icon-display img {
    width: 95% !important; height: 95% !important;
    background-size: contain; background-position: center;
    display: block; margin: auto; object-fit: contain;}
#navigation-bottom-progress-bar.progress-bar-auto-hidden {
    opacity: 0;    visibility: hidden;    transform: translateY(-100%);
    pointer-events: none;}
.mapboxgl-ctrl-bottom-left .mapboxgl-ctrl {  margin: 0 0 5px 5px; }   
.mapboxgl-ctrl-bottom-right .mapboxgl-ctrl { margin: 0 3px 5px 0; }    
/* === INICIO: CSS PARA MEJORAR SATURACIN Y CONTRASTE DEL MAPA (CON VARIABLES) === */
:root {
    --map-saturation: 1.6; 
    --map-contrast: 1.2;   }
.mapboxgl-canvas {
    filter: saturate(var(--map-saturation)) contrast(var(--map-contrast));}
/* === INICIO: ESTILOS PARA ESTADSTICAS DE ADMIN EN CHAT === */
.chat-admin-stats-header {
    padding: 8px; background-color: #3a3a3c;
    border-bottom: 1px solid #444;
    text-align: center; font-size: 0.9rem;
    font-weight: bold;   color: #ffd700;}
.chat-user-session-stats {
    font-size: 0.75rem;  color: #ffd700;
    margin-left: 8px; font-style: italic;}
#auto-start-nav-modal {
    position: fixed;  bottom: 10px;   left: 10px;
    background-color: #CF7C00;  border: 2px solid white;
    border-radius: 8px;  padding: 15px;
    z-index: 10003; box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    max-width: 320px; color: white;
    font-family: sans-serif;  display: flex;flex-direction: column;
    gap: 10px;}
#auto-start-nav-modal #start-route-now-button {
    padding: 10px 15px;
    font-size: 1.2rem;  font-weight: bold;
    background-color: #28a745; color: white;
    border: 1px solid #FFF;
    border-radius: 5px; cursor: pointer;
    transition: background-color 0.2s ease;}
#auto-start-nav-modal #start-route-now-button:hover {
    background-color: #218838;}
#auto-start-nav-modal .info-text {
    font-size: 0.85rem;line-height: 1.3;   color: #f0f0f0;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);}    
.mapboxgl-ctrl.map-combined-controls-wrapper {
    display: flex;
    flex-direction: row;    align-items: flex-end;  gap: 3px; 
    background-color: transparent !important;
    box-shadow: none !important;}
    
/* === NUEVOS ESTILOS PARA AGRUPAR CONTROLES DEL MAPA === */
.mapboxgl-ctrl.map-combined-controls-wrapper {
    display: flex;
    flex-direction: row;    align-items: flex-end;  gap: 3px; 
    background-color: transparent !important;
    box-shadow: none !important;}
.control-button {
    width: 85px;
    height: 100%; background-color: rgba(42, 130, 224, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.6);  color: white;
    border-radius: 30px;   font-size: 35px;
    text-align: center;  cursor: pointer;  user-select: none;
    -webkit-user-select: none; transition: background-color 0.2s;
    display: flex; align-items: center;justify-content: center; flex-shrink: 0;}
.zoom-control-button {
    height: 100%; 
    aspect-ratio: 1 / 1;  background-color: rgba(42, 130, 224, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.6);  color: white;
    border-radius: 50%;   font-size: 42px; font-height: bold; 
    text-align: center;  cursor: pointer; user-select: none;
    -webkit-user-select: none; transition: background-color 0.2s;
    display: flex; align-items: center;
    justify-content: center;flex-shrink: 0;}    
.zoom-control-button:hover {  background-color: rgba(62, 150, 244, 0.4);}
#zoom-toggle-button img {  width: 30px;height: 30px;  object-fit: contain;}  
#zoom-toggle-button {   background-color: white;}
#zoom-toggle-button:hover {  background-color: #e0e0e0; }    

/* === INICIO: CSS PARA ICONOS DE ALERTA DE TRFICO (CORREGIDO) === */
.traffic-alert-marker {
cursor: pointer;
background-color: white; border-radius: 50%;
border: 3px solid red;
box-shadow: 0 2px 5px rgba(0,0,0,0.5);
display: flex;  justify-content: center;align-items: center;
transition: width 0.2s ease, height 0.2s ease;
width: 80px; height: 80px;}
.traffic-alert-marker img {
width: 90%;height: 90%; object-fit: contain;}    
.traffic-alert-icon-container {
    width: 60px; height: 60px; border-radius: 50%;
    background-color: white; border: 3px solid red;
    box-shadow: 0 2px 5px rgba(0,0,0,0.5); display: flex;
    justify-content: center; align-items: center;
    overflow: hidden; cursor: pointer;
    transition: width 0.2s ease, height 0.2s ease, border-width 0.2s ease;}
.traffic-alert-icon-container.small {
    width: 30px; height: 30px; border-width: 2px;}
.traffic-alert-icon-container img {
    width: 90%; height: 90%; object-fit: contain;}

/* === INICIO: NUEVOS ESTILOS PARA MODAL DE UBICACIONES GUARDADAS (TEMA OSCURO) === */
.saved-locations-modal {
    background-color: #2c2c2e;   color: #f0f0f0;    border-radius: 14px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.6);
    border: 1px solid #444;   padding: 1rem;
    height: calc(100dvh - 30px);   max-height: calc(100dvh - 30px);
    display: flex;   flex-direction: column;}
.saved-locations-modal h2 {
    color: white;font-size: 1.5rem;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    border-bottom: 1px solid #444; padding-bottom: 0.75rem;}
.saved-locations-modal #saved-locations-list {
    flex-grow: 1; overflow-y: auto; margin-bottom: 1rem;
    padding-right: 10px;  background-color: transparent; border: none;}
.saved-locations-modal .location-slot {
    display: flex;  align-items: stretch;  gap: 0.75rem; 
    margin-bottom: 0.75rem;
    border-bottom: 1px solid #3a3a3c;
    padding-bottom: 0.75rem;}
.saved-locations-modal .location-slot:last-child { border-bottom: none;}
.saved-locations-modal .location-slot span:first-child {align-self: center;}
.saved-locations-modal .location-slot input[type="text"] {
    background-color: #3a3a3c;   border: 1px solid #555; color: #f0f0f0;
    border-radius: 8px; font-size: 1.1rem; font-weight: bold;
    min-height: 55px; }
.saved-locations-modal .location-slot button {
    height: auto;   min-height: 55px; border-radius: 8px;border: none;
    font-weight: bold;  font-size: 1rem;
    transition: opacity 0.2s;}
.saved-locations-modal .location-slot button:hover {   opacity: 0.85;}
.saved-locations-modal .location-slot button.map-button {
    background-color: #007aff;   color: white;}
.saved-locations-modal .location-slot button.select-location-button {
    background-color: #34c759;  color: white;}
.saved-locations-modal .location-slot .coords-display {
    color: #a0a0a0; align-self: center; font-size: 0.9rem;}
.saved-locations-modal #save-all-user-locations {
    background-color: #007aff;
    color: white;   font-weight: bold; border-radius: 8px;}
.saved-locations-modal #save-all-user-locations:hover {
    background-color: #0056b3;}
.saved-locations-modal #close-saved-locations-modal {
    background-color: #555;   color: white; font-weight: bold;
    border-radius: 8px;}
.saved-locations-modal #close-saved-locations-modal:hover {
    background-color: #444;}

/* === INICIO: CSS PARA MODALES DE RUTA (TEMA OSCURO MODERNO - VERSIN CORREGIDA Y DEFINITIVA) === */
#saved-routes-modal,
#save-route-prompt-modal { }
.route-modal-overlay {
    position: fixed;    inset: 0;  width: 100vw;   height: 100vh;
    background-color: rgba(0, 0, 0, 0.4);  backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    z-index: 8400;    display: flex;
    justify-content: center;  align-items: center;
    padding: 10px;}
.route-modal-container {
    background-color: #2c2c2e; color: #f0f0f0; border-radius: 14px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);border: 1px solid #444;
    overflow: hidden;  display: flex;   flex-direction: column;
    width: 100%; max-width: 750px;
    max-height: calc(100vh - 30px);}
.route-modal-header {
    height: 120px;
    background-image: url('https://boardinggate.github.io/Tesla/PNG/modalrutas.png');
    background-size: cover;
    background-position: center;  position: relative;
    display: flex;align-items: flex-start;
    padding: 0;}    
.route-modal-header::before {
    content: '';position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 60%);}
.route-modal-title-card {
    background-color: rgba(0, 0, 0, 0.6);
    padding: 5px 14px;border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);  position: relative;
    z-index: 1;  margin: 15px;}
.route-modal-title {
    font-size: 1.6rem;   font-weight: bold; color: white;}
.route-modal-body {
    padding: 15px 20px;
    flex-grow: 1; overflow-y: hidden;
    display: flex;flex-direction: column;}
.route-modal-controls {
    display: flex; gap: 10px;  margin-bottom: 15px;
    align-items: center; position: relative;}
.route-modal-body p {
    font-size: 1rem; color: #b0b0b0;  margin-bottom: 8px; line-height: 1.5;}
.route-modal-body p strong {color: #f0f0f0;  font-weight: bold;}
.route-modal-body .route-label {
    display: block; margin-bottom: 8px;
    font-weight: 500; color: #a0a0a0; font-size: 1rem;}
.route-filter-input {
    flex-grow: 1;  padding: 12px 40px 12px 15px;
    height: 50px;border: 1px solid #555;  border-radius: 8px;
    font-size: 1.1rem; font-weight: 500;
    background-color: #3a3a3c; color: #f0f0f0;
    display: flex;  align-items: center;}
.route-filter-input::placeholder { color: #8e8e93; }
.route-scroll-container {
    flex-grow: 1; overflow-y: auto; padding-right: 5px;}
.routes-section-title {
    font-size: 1.1rem; font-weight: bold;  color: #007aff;
    margin-top: 15px; margin-bottom: 8px; padding-bottom: 5px;
    border-bottom: 1px solid #444;}
.routes-section-title:first-child { margin-top: 0;}
.route-list {  list-style: none;  padding: 0;    margin: 0;}
.route-list-item {
    background-color: #3a3a3c;padding: 10px 15px;
    border: 1px solid #4a4a4a;display: flex;
    justify-content: space-between; align-items: center;
    border-radius: 8px;margin-bottom: 8px;
    transition: background-color 0.2s;}
.route-list-item:hover {   background-color: #4a4a4a;}
.route-list-empty {
    color: #8e8e93; text-align: center; padding: 20px; font-style: italic;}
.route-name {
    flex-grow: 1;cursor: pointer; font-size: 1.1rem;
    font-weight: bold; color: #f0f0f0;}
.route-actions {
    display: flex;gap: 10px;flex-shrink: 0; margin-left: 15px;}
.btn-return, .btn-delete {
    font-size: 0.95rem;  padding: 6px 14px;
    border-radius: 6px; border: none;
    cursor: pointer; font-weight: bold;
    color: white; transition: transform 0.1s ease, opacity 0.2s;}
.btn-return:hover, .btn-delete:hover {
    transform: scale(1.05); opacity: 0.9;}
.btn-return { background-color: #34c759; }
.btn-delete { background-color: #ff3b30; }
.route-modal-footer {
    display: flex; gap: 1rem; padding: 15px 20px;
    border-top: 1px solid #444;   background-color: #1c1c1e;}
.route-modal-footer button {
    flex: 1;  padding: 12px;
    font-size: 1.1rem; font-weight: bold;border-radius: 8px;
    cursor: pointer;  border: none; transition: opacity 0.2s;
    display: flex;  align-items: center;  justify-content: center;}
.route-modal-footer button .button-countdown-timer {
    margin-left: 8px;font-weight: normal;}
.route-modal-footer button:hover {opacity: 0.85;}
.btn-modal-save,
.btn-modal-action-primary { background-color: #007aff;   color: white;}
.btn-modal-cancel,
.btn-modal-action-secondary {background-color: #555; color: white;}
.btn-modal-favorite { background-color: #ff9500;color: white;}
.btn-modal-danger { background-color: #ff3b30;   color: white;}
.route-label-marker {
    display: flex; align-items: center; justify-content: center;
    border-radius: 50%; color: white; font-weight: bold;
    font-size: 14px; font-family: Arial, sans-serif;
    text-align: center; box-shadow: 0 0 5px rgba(0,0,0,0.7);
    border: 2px solid white; cursor: pointer;
    transition: transform 0.2s ease; width: 40px; height: 40px;}
.route-label-marker:hover {    transform: scale(1.1);}

/* =================================================================== */
/* INICIO: NUEVOS ESTILOS PARA MODAL DE LISTA DE RECORDATORIOS (TEMA OSCURO v2) */
/* =================================================================== */
.reminder-table-modal {
    background-color: #2c2c2e; color: #f0f0f0; border-radius: 14px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.6); border: 1px solid #444;
    padding: 0;
    display: flex; flex-direction: column;
    width: 95%; max-width: 1200px;
    height: 95vh; max-height: 95vh;
    left: 50%; top: 50%; transform: translate(-50%, -50%);
    overflow: hidden;}
.reminder-table-header {
    height: 120px;
    background-image: url('https://boardinggate.github.io/Tesla/PNG/modalrutas.png');
    background-size: cover; background-position: center;
    position: relative; flex-shrink: 0;
    display: flex; flex-direction: column;
    justify-content: space-between;
    padding: 1rem 1.5rem;}
.reminder-table-header::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.3) 50%, rgba(0,0,0,0) 100%);}
.reminder-table-modal .reminder-table-top-controls {
    display: flex; justify-content: space-between; align-items: left;
    position: relative; z-index: 1;}
.reminder-table-modal h2 {
    font-size: 2.2rem !important; font-weight: bold !important; color: white !important;
    text-shadow: 2px 2px 5px rgba(0,0,0,0.8);
    position: relative; z-index: 1;
    text-align: left; margin: 0;
    padding-bottom: 0.5rem;}
.reminder-table-modal .reminder-table-top-controls label {
    color: #e0e0e0; font-weight: bold;}
.reminder-table-modal .reminder-table-top-controls button {
    font-weight: bold; border-radius: 8px;
    transition: background-color 0.2s, opacity 0.2s;
    min-height: 50px;}
.reminder-table-modal #view-all-locations-map {   background-color: #007aff; color: white; border: none;}
.reminder-table-modal #view-all-locations-map:hover { background-color: #0056b3;}
.reminder-table-modal #close-reminders-top {  background-color: #555; color: white; border: none;}
.reminder-table-modal #close-reminders-top:hover {  background-color: #444;}

.reminder-table-body-container {
    flex-grow: 1; overflow-y: auto; padding: 0.5rem 1.5rem 1.5rem 1.5rem;}
.reminder-table-modal table {
    border-collapse: separate; border-spacing: 0;}
.reminder-table-modal th {
    background-color: #3a3a3c; color: #f0f0f0; border-color: #444; border-bottom-width: 2px;}
.reminder-table-modal td {
    border: none;  border-bottom: 1px solid #0fd978;  color: #e0e0e0;}
.reminder-table-modal tbody tr:last-child td {  border-bottom: none;}
.reminder-table-modal tbody tr {transition: background-color 0.15s ease;}
.reminder-table-modal tbody tr:hover {background-color: #48484a !important;}
.reminder-table-modal td:first-child { border: none;}
.reminder-table-modal td:first-child button {
    border-radius: 6px;font-weight: bold;
    color: white;   border: none;
    transition: opacity 0.2s;}
.reminder-table-modal td:first-child button:hover {  opacity: 0.85;}
.reminder-table-modal .visto-prox { background-color: #ff3b30; }
.reminder-table-modal .postpone { background-color: #ff9500; }
.reminder-table-modal .cancel-cyclic-table { background-color: #8B0000; }
.reminder-table-modal button.modify { background-color: #34c759; }
.reminder-table-modal .bottom-button-container {
    display: none;}

/* =================================================================== */
/* INICIO: CSS PARA EL MODAL DE INFORMACIN DE PUNTOS DE INTERS (POI) */
.poi-modal-overlay {
    position: fixed; inset: 0;
    background-color: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    z-index: 10005;
    display: flex; justify-content: center; align-items: center;
    padding: 15px;}
.poi-modal-content {
    background-color: #2c2c2e; color: #f0f0f0;
    border-radius: 14px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    border: 1px solid #444;
    width: 100%; max-width: 750px; 
    max-height: 95vh; 
    display: flex; flex-direction: column; overflow: hidden;}    

.poi-modal-header {
    height: 140px;
    background-image: url('https://boardinggate.github.io/Tesla/PNG/modal-poi-header.jpg');
    background-size: cover; background-position: center;
    position: relative;
    display: flex; flex-direction: column; justify-content: flex-end;
    padding: 1rem;
    text-shadow: 1px 1px 4px rgba(0,0,0,0.9);}

.poi-modal-header::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.4) 50%, rgba(0,0,0,0) 100%);}
.poi-modal-title {
    font-size: 1.6rem; font-weight: bold; color: white;
    position: relative; z-index: 1; line-height: 1.2;}
.poi-modal-address {
    font-size: 0.9rem; color: #c7c7cc;
    position: relative; z-index: 1; margin-top: 4px;}
.poi-modal-body {
    padding: 1rem;
    max-height: calc(90vh - 300px); /* Ajusta la altura mxima para el scroll */
    overflow-y: auto;}
.poi-modal-info-section {   margin-bottom: 1rem;}

.poi-modal-info-section h4 {
    font-size: 0.8rem; font-weight: bold; color: #8e8e93;
    text-transform: uppercase; margin-bottom: 0.5rem;
    border-bottom: 1px solid #444; padding-bottom: 0.25rem;}
.poi-modal-info-section p,
.poi-modal-info-section a {
    font-size: 1rem; color: #f0f0f0; margin: 0;  line-height: 1.5;}

.poi-modal-info-section a {
    color: #0a84ff; text-decoration: none;  word-break: break-all;}
.poi-modal-info-section a:hover {text-decoration: underline;}
.poi-modal-footer {
    padding: 1rem; border-top: 1px solid #444;
    background-color: #1c1c1e;  display: grid;
    grid-template-columns: 1fr 1fr; gap: 0.75rem;}
.poi-modal-footer button {
    padding: 12px; font-size: 1rem; font-weight: bold;
    border-radius: 8px; border: none; cursor: pointer;
    transition: opacity 0.2s;}
.poi-modal-footer button:hover {opacity: 0.85;}    

/* --- NUEVOS ESTILOS PARA EL CONTROL DE INCLINACIN (PITCH) --- */
.pitch-control-button {
    background: none;
    border: none;padding: 0;
    cursor: pointer;
    color: white; opacity: 0.8;
    transition: opacity 0.2s, transform 0.1s;}
.pitch-control-button:hover {opacity: 1;}
.pitch-control-button:active { transform: scale(0.9);}
.pitch-control-button svg {
    width: 32px; height: 24px;  stroke-width: 2.5;}

/* === INICIO: NUEVOS ESTILOS PARA EL PANEL EMERGENTE DE AJUSTES === */
.map-settings-popup {
    display: flex; flex-direction: row;   gap: 10px;padding: 10px;
    background: rgba(44, 44, 46, 0.85);  border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);  backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.25);   opacity: 0;
    visibility: hidden; transform: translateY(10px);
    transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;}

.map-settings-popup.visible {
    opacity: 1;visibility: visible; transform: translateY(0);}
.map-settings-popup .map-layer-selector,
.map-settings-popup .map-view-selector {
    display: flex;flex-direction: column;gap: 5px;}
.map-settings-popup .separator {
    width: 1px;background-color: rgba(255, 255, 255, 0.2);  margin: 0 5px;}

.map-settings-popup label {
    display: flex; align-items: center;  padding: 6px 8px; cursor: pointer;
    font-weight: 500;font-size: 0.9rem;white-space: nowrap;
    transition: background-color 0.2s; border-radius: 4px;  color: #e0e0e0;}
.map-settings-popup label:hover {  background-color: rgba(255,255,255,0.15);}
.map-settings-popup input[type="radio"] {
    margin-right: 8px;
    vertical-align: middle;appearance: none;
    -webkit-appearance: none;
    background-color: #333;border: 1px solid #888;
    width: 16px; height: 16px;  border-radius: 50%;
    position: relative; cursor: pointer;}

.map-settings-popup input[type="radio"]:checked {
    background-color: #2a82e0; border-color: #fff;}

.map-settings-popup input[type="radio"]:checked::after {
    content: '';
    display: block;width: 8px; height: 8px; border-radius: 50%;
    background: white; position: absolute;
    top: 50%; left: 50%; transform: translate(-50%, -50%);}

/* === INICIO: NUEVOS ESTILOS PARA TARJETA DE NAVEGACIN MNIMA === */
#mini-nav-info-card {
    position: absolute; top: 10px;   left: 10px;  z-index: 1012;
    background-color: rgba(40, 40, 40, 0.3); 
    color: #E0E0E0;  font-weight: bold;
    font-size: 1.5em;  padding: 4px 10px;
    border-radius: 8px; pointer-events: none;   display: none; 
    text-shadow: 1px 1px 4px black;
    border: 1px solid rgba(255, 255, 255, 0.2);  backdrop-filter: blur(3px);
    -webkit-backdrop-filter: blur(3px);text-align: center;}
#post-arrival-action-modal {
    position: fixed;  bottom: 10px;   left: 10px;
    background-color: #3a3a3c;  border: 2px solid #555;
    border-radius: 8px;  padding: 15px;
    z-index: 10003; box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    max-width: 320px; color: white;
    font-family: sans-serif;  display: flex; flex-direction: column;
    gap: 12px;}
#post-arrival-action-modal .post-arrival-title {
    font-size: 1rem; font-weight: bold; text-align: center;
    color: #f0f0f0; margin-bottom: 5px;}
#post-arrival-action-modal .post-arrival-buttons {
    display: flex; flex-direction: column; gap: 8px;}
#post-arrival-action-modal button {
    padding: 10px 15px; font-size: 1.1rem;  font-weight: bold;
    border: 1px solid #FFF; border-radius: 5px; cursor: pointer;
    transition: background-color 0.2s ease, opacity 0.2s;}
#post-arrival-action-modal #return-trip-button {
    background-color: #34c759; color: white;}
#post-arrival-action-modal #return-trip-button:hover {
    background-color: #2fb350;}
#post-arrival-action-modal #clear-completed-route-button {
    background-color: #ff3b30; color: white;}
#post-arrival-action-modal #clear-completed-route-button:hover {
    background-color: #d93128;}   
#route-modal-save-overlay {
    justify-content: flex-start;   align-items: flex-start;   }    

/* === INICIO: NUEVOS ESTILOS PARA LA BARRA DE CONTROLES HORIZONTAL === */
.mapboxgl-ctrl.map-controls-bottom-right {
    display: flex;flex-direction: column;  align-items: flex-end;
    gap: 8px; background-color: transparent !important;
    box-shadow: none !important;}

#zoom-controls-horizontal {
    display: flex;flex-direction: row;align-items: center;
    gap: 6px;  background-color: rgba(0, 0, 0, 0.3);
    border-radius: 28px;  padding: 3px;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);}

.zoom-control-button {
    width: 60px; height: 60px;
    background-color: rgba(42, 130, 224, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.6);
    color: white;border-radius: 50%;font-size: 28px;
    text-align: center;cursor: pointer; user-select: none;
    -webkit-user-select: none;
    transition: background-color 0.2s;display: flex;
    align-items: center;  justify-content: center;  flex-shrink: 0;}
.zoom-control-button:hover { background-color: rgba(62, 150, 244, 0.4);}
#zoom-level-display {
    color: white; font-size: 1.2rem;font-weight: bold;   padding: 0 8px;
    text-shadow: 1px 1px 2px black; min-width: 40px;
    text-align: center;}
#zoom-auto-button {
    font-size: 1rem; font-weight: bold;  line-height: 1;
    background-color: #6c757d;}
#zoom-auto-button.active {
    background-color: #FFDAB9;  color: #333; border-color: white;}

#zoom-toggle-button img,
#map-settings-toggle-button img,
#map-offset-toggle-button img { /* Aadido #map-offset-toggle-button */
    width: 45px; height: 45px; object-fit: contain;}
#zoom-toggle-button { background-color: white; }
#zoom-toggle-button:hover { background-color: #e0e0e0; }
#map-settings-toggle-button { background-color: rgba(236, 255, 173, 0.7);}
#map-settings-toggle-button:hover { background-color: rgba(201, 204, 200, 0.7);   }

/* === INICIO: NUEVOS ESTILOS PARA EL PANEL EMERGENTE DE AJUSTES (v2 - Botones ms grandes) === */
.map-settings-popup {
    display: flex; flex-direction: row;   gap: 10px;padding: 10px;
    background: rgba(44, 44, 46, 0.85);  border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);  backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.25);   opacity: 0;
    visibility: hidden; transform: translateY(10px);
    transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;}
.map-settings-popup.visible {
    opacity: 1;visibility: visible; transform: translateY(0);}
.map-settings-popup .map-layer-selector,
.map-settings-popup .map-view-selector {
    display: flex;flex-direction: column;gap: 5px;}
.map-settings-popup .separator {
    width: 1px;background-color: rgba(255, 255, 255, 0.2);  margin: 0 5px;}

.map-settings-popup label {
    display: flex; align-items: center;  padding: 8px 10px; cursor: pointer; /* Aumentado de 6px 8px */
    font-weight: 500;font-size: 1rem;white-space: nowrap; /* Aumentado de 0.9rem */
    transition: background-color 0.2s; border-radius: 4px;  color: #e0e0e0;}

.map-settings-popup label:hover {  background-color: rgba(255,255,255,0.15);}

.map-settings-popup input[type="radio"] {
    margin-right: 8px;
    vertical-align: middle;appearance: none;
    -webkit-appearance: none;
    background-color: #333;border: 1px solid #888;
    width: 19px; height: 19px;  border-radius: 50%; /* Aumentado de 16px */
    position: relative; cursor: pointer;}
.map-settings-popup input[type="radio"]:checked {
    background-color: #2a82e0; border-color: #fff;}
.map-settings-popup input[type="radio"]:checked::after {
    content: '';
    display: block;width: 10px; height: 10px; border-radius: 50%; /* Aumentado de 8px */
    background: white; position: absolute;
    top: 50%; left: 50%; transform: translate(-50%, -50%);}
/* === INICIO: NUEVOS ESTILOS PARA EL PANEL DE OFFSET Y PITCH (v4 - Botones ms grandes) === */
#map-offset-toggle-button { background-color: white;}
#map-offset-toggle-button:hover {   background-color: #e0e0e0; }

.map-offset-popup {
    display: flex; flex-direction: row; align-items: center; gap: 0px; padding: 10px;
    background: rgba(44, 44, 46, 0.85);  border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);  backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.25);   opacity: 0;
    visibility: hidden; transform: translateY(10px);
    transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;}
.map-offset-popup.visible {
    opacity: 1;visibility: visible; transform: translateY(0);}
.map-offset-popup .crosshair-container {
    display: grid;
    grid-template-columns: 48px 70px 48px; 
    grid-template-rows: 48px 48px 48px;    
    align-items: center; justify-items: center;}
.map-offset-popup .offset-arrow {
    width: 43px; height: 43px; 
    background-color: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.4);
    border-radius: 50%;cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: background-color 0.2s;}
.map-offset-popup .offset-arrow:hover { background-color: rgba(255, 255, 255, 0.4); }
.map-offset-popup .offset-arrow svg { width: 29px; height: 29px; stroke: white; stroke-width: 2.5; } /* Aumentado de 24px */

.map-offset-popup #offset-arrow-up { grid-column: 2; grid-row: 1; }
.map-offset-popup #offset-arrow-down { grid-column: 2; grid-row: 3; }
.map-offset-popup #offset-arrow-left { grid-column: 1; grid-row: 2; }
.map-offset-popup #offset-arrow-right { grid-column: 3; grid-row: 2; }

.map-offset-popup #minimap-toggle-container {
    grid-column: 2; grid-row: 2;
    display: flex; flex-direction: column; align-items: center;  gap: 4px;}
.map-offset-popup #minimap-toggle-container input {
    width: 20px; height: 20px; margin: 0; }
.map-offset-popup #minimap-toggle-container label {
    font-size: 0.9rem; font-weight: bold; color: white; cursor: pointer; }
.offset-popup-separator {
    width: 1px; align-self: stretch;
    background-color: rgba(255, 255, 255, 0.2); margin: 0 12px;}
.pitch-controls-container {
    display: flex; flex-direction: column;
    justify-content: space-between; align-items: center;
    gap: 10px;  height: 100%;}
.pitch-value-display {
    font-size: 1.1rem;  font-weight: bold; color: white;}
.route-modal-tabs {
    display: flex; background-color: #1c1c1e;
    border-bottom: 1px solid #444;flex-shrink: 0; }
.route-modal-tab {
    flex: 1;  padding: 12px; text-align: center;  font-weight: bold;
    cursor: pointer;
    border: none;    background-color: transparent;  border-bottom: 3px solid transparent;
    transition: background-color 0.2s, border-color 0.2s, color 0.2s;
    color: #a0a0a0;
    font-size: 1rem; }
.route-modal-tab:hover { background-color: #3a3a3c;}
.route-modal-tab.active { border-bottom-color: #007aff;color: white;}
.route-modal-panel { display: none; }
.route-modal-panel.active {display: block; }
/* === INICIO: CORRECCIN COMPLETA PARA PERMITIR ARRASTRE Y ZOOM SOBRE CONTROLES === */
.mapboxgl-ctrl.map-controls-bottom-right {
    pointer-events: none;}
.mapboxgl-ctrl.map-controls-bottom-right > * {  pointer-events: auto;}
#zoom-controls-horizontal { pointer-events: auto; }
#zoom-controls-horizontal > .zoom-control-button { pointer-events: auto; }
.offset-value-display {
    position: absolute;
    font-size: 1.1rem;  font-weight: bold;  color: #f0f0f0; 
    white-space: nowrap;
    background-color: rgba(0,0,0,1);  padding: 2px 6px;  border-radius: 4px;
    pointer-events: none; opacity: 0.9; 
    text-shadow: 1px 1px 2px rgba(0,0,0,1); }
.offset-value-display.vertical {
    top: 0;left: 50%;
    transform: translate(-50%, -142%); }
.offset-value-display.horizontal {
    left: 0; top: 50%;
    transform: translate(-117%, -50%);}
/* CSS Exclusivo para el Modal #locations-preview-modal              */
#locations-preview-modal {
    position: fixed; top: 0; left: 0;  width: 100%; height: 100%;
    background-color: #DAC8A0; z-index: 8500;
    display: flex; flex-direction: column;
    padding: 10px; box-sizing: border-box;}
#locations-preview-map-container {
    flex-grow: 1; border: 1px solid #A09888;
    border-radius: 0.5rem; margin-bottom: 10px;min-height: 200px;}
#locations-preview-modal h2 {
    font-size: 1.2rem; font-weight: bold; text-align: center;
    margin-bottom: 10px; color: #333; flex-shrink: 0;}
#locations-preview-modal .modal-top-buttons {
    flex-shrink: 0; display: flex;
    justify-content: center; margin-top: 0;}
#close-locations-preview {
    padding: 0.8rem 2rem; font-size: 1.2rem; background-color: #4A5568; color: white;
    border: 1px solid #2D3748; border-radius: 8px;
    cursor: pointer; font-weight: bold;width: auto; min-width: 150px;}
#close-locations-preview:hover {  background-color: #2D3748;}
body.mobile-view #locations-preview-modal { z-index: 11000 !important;}
/* --- Estilos del Tema Oscuro (Especficos del Modal) --- */
#locations-preview-modal {
    background-color: #2c2c2e; color: #f0f0f0; border: 1px solid #444;}
#locations-preview-modal h2 {
    color: white;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    border-bottom: 1px solid #444; padding-bottom: 10px;}
#locations-preview-map-container {  border: 1px solid #444;}
#close-locations-preview {
    background-color: #555; color: white; border: none;}
#close-locations-preview:hover {
    background-color: #444;}
#zoom-locate-me-button {
    position: relative; background-color: white;}
#zoom-locate-me-button:hover { background-color: #e0e0e0;}
#zoom-locate-me-button img {
    width: 45px;  height: 45px;   object-fit: contain;}
#zoom-locate-me-button .countdown-overlay {
    position: absolute;  top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    color: #FF3333;  font-size: 1.7rem; font-weight: bold;
    text-shadow: 0 0 3px yellow, 0 0 5px yellow, 0 0 8px gold;
    pointer-events: none;  z-index: 10;}    
    
</style>

</head>
<body class="min-h-screen bg-[#ABAB99] flex flex-col items-center p-6">

    <div class="reminder-count-globe" id="reminder-count-globe" style="display: none;"></div>

    <div id="unified-reminder-window" role="alertdialog" aria-labelledby="reminder-window-title" aria-describedby="reminder-window-desc">
        <div class="reminder-count-header" id="reminder-window-title">
            <div class="reminder-title-container">
                <span style="font-size: 1.3rem;" id="reminder-count-text-container">
                    <span id="current-reminder-index">1</span> de <span id="total-reminder-count">X</span> Recordatorios
                </span>
                <span class="swipe-hint" id="reminder-swipe-hint" style="font-size: smaller;">
                    (deslice lateralmente)
              </span>
            </div>
            <button id="hide-all-reminders-button" title="Posponer 1 minuto todos los recordatorios visibles">OCULTAR</button>
        </div>
        <div id="reminder-swiper-container" aria-live="polite">
        </div>
        <span id="reminder-window-desc" class="hidden">Deslice para ver los recordatorios vencidos. Use los botones para gestionar cada recordatorio.</span>
    </div>

    <div id="grid-filter-container">
        <input type="text" id="grid-filter-input" placeholder="Filtrar grid...">
        <button id="clear-filter-button" title="Limpiar filtro"></button>
    </div>

<main>
    <div id="open-chat-area" style="cursor: pointer;" title="Abrir Chat">
        <div id="user-info-header">
            <span id="user-count-globe"></span>
            <span id="chat-icon-button">
                <span id="chat-message-globe">0</span>
            </span>
            <div id="user-id-display"></div>
        </div>
    </div>
    
    <div id="bookmark-grid">
    </div>
</main>
    
<div class="notices-icon-container">
    <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4194.jpg" alt="Toggle Avisos" class="notice-off-icon" id="notice-toggle-icon">
    <div class="notices-container">
        <div class="notice-wrapper">
            <span class="notice" id="current-notice"></span>
        </div>
    </div>
</div>

<footer>
    <div class="footer-content">
        <div class="header-container">
            <img src="https://boardinggate.github.io/Tesla/PNG/LOGOTESLA.jpg" class="header-logo">
            <div class="title-container">
                <h1 class="text-2xl font-bold inline">
                    <span class="text-2xl">BoardingGate</span>
                    <span class="text-base">Lanzador</span>
                    <span id="version" class="version-text"></span>
                </h1>
            </div>
        </div>
        <div class="footer-line">
          <a href="https://x.com/boardinggate/status/1857325553742721116?s=46" class="footer-link-green" target="_blank" rel="noopener noreferrer">Ahorremos un dinero con mis REFERIDOS</a>
        </div>

        <div class="statcounter-container">
          <div style="display: inline-flex; align-items: center; gap: 10px;">
            <script type="text/javascript">
              var sc_project=13126275;
              var sc_invisible=0;
              var sc_security="0fc568cc";
              var scJsHost = "https://";
              document.write("<sc"+"ript type='text/javascript' src='" +
              scJsHost+
              "statcounter.com/counter/counter.js'>"+"<"+"/script>");
            </script>
            <noscript><div class="statcounter"><a title="Web Analytics"
            href="https://statcounter.com/" target="_blank"><img
            class="statcounter"
            src="https://c.statcounter.com/13126275/0/0fc568cc/0/"
            alt="Web Analytics"
            referrerPolicy="no-referrer-when-downgrade"></a></div></noscript>
            <a href="https://statcounter.com/p13126275/?guest=1" class="footer-subtext">Legionarios de Elon</a>
          </div>
        </div>

        <p class="footer-subtext">La inteligencia tiene ciertos limites. La locura, casi ninguno  </p>
    </div>
</footer>

<!-- =================================================================== -->
<!-- INICIO: MODAL DEL MAPA PERSISTENTE (SOLUCIN A PRDIDA DE EVENTOS) -->
<!-- =================================================================== -->
<div id="reminders-location-map-modal" class="map-modal-hidden">

    <div id="toggle-map-header-buttons-panel">
         <img src="PNG/Coche_Sat.PNG" alt="Toggle Panel Mapa">
    </div>
    <div id="reminders-location-map-content-wrapper">
        <div id="reminders-location-map-header">
             <div class="button-row">
                <button id="close-reminders-location-map" class="reminders-map-button-action" title="Cerrar mapa y navegacin"><img src="PNG/SALIR.PNG" alt="Salir"></button>
                <button id="locate-me-on-reminders-map" class="reminders-map-button-action" title="Mostrar mi posicin actual y activar seguimiento"><img src="PNG/ESTASAQUI.PNG" alt="Ests Aqu"></button>
                <button id="start-navigation-button" class="reminders-map-button-action" title="Iniciar/Terminar Navegacin"><img src="PNG/INICIARNAVEGACION.PNG" alt="Iniciar Navegacin"></button>
                <button id="save-route-button" class="reminders-map-button-action hidden" title="Guardar Ruta Actual"><img src="PNG/GUARDARRUTA.PNG" alt="Guardar Ruta"></button>
                <button id="load-saved-route-button" class="reminders-map-button-action" title="Cargar Ruta Guardada"><img src="PNG/CARGARRUTA.PNG" alt="Cargar Ruta"></button>
                <button id="delete-current-route-button" class="reminders-map-button-action hidden" title="Borrar Ruta Actual del Mapa"><img src="PNG/BORRARRUTA.PNG" alt="Borrar Ruta"></button>
                <button id="add-radar-here" class="reminders-map-button-action" title="Crear RADAR en mi posicin actual (radio 350m)"><img src="PNG/RADARAQUI.PNG" alt="Radar Aqu"></button>
                <button id="accident-alert-button-map" class="reminders-map-button-action" title="Informar de una incidencia de trfico"><img src="https://boardinggate.github.io/Tesla/PNG/AACCIDENTE.png" alt="Informar Incidencia"></button>
                <button id="pdrs-ruta-button" class="reminders-map-button-action" title="Buscar Puntos de Recarga en Ruta"><img src="PNG/pdrs.png" alt="PDRs"></button>
                 <div class="radares-ruta-control">
                    <input type="checkbox" id="radares-ruta-checkbox">
                    <div class="radares-ruta-label-container">
                        <label for="radares-ruta-checkbox">Radares<br>Ruta</label>
                        <span id="radares-ruta-count" class="hidden">0</span>
                    </div>
                </div>
                <div class="tareas-ruta-control">
                    <input type="checkbox" id="tareas-ruta-checkbox">
                    <div class="tareas-ruta-label-container">
                        <label for="tareas-ruta-checkbox">Tareas<br>Ruta</label>
                        <span id="tareas-ruta-count" class="hidden">0</span>
                    </div>
                </div>
                <div class="mapbox-control">
                    <input type="checkbox" id="mapbox-primary-checkbox">
                    <div class="mapbox-label-container">
                        <label for="mapbox-primary-checkbox">Rutas<br>Mapbox</label>
                    </div>
                </div>
                <button id="add-reminder-at-location-button" class="reminders-map-button-action" title="Aadir recordatorio en punto del mapa">
                    <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4197.jpg" alt="Aadir Recordatorio">
                </button>
                 <button id="toggle-simulate-gps-button" class="reminders-map-button-action" title="Activar/Desactivar Simulacin GPS (recorrido o clic)"><img src="PNG/GPS.PNG" alt="Simular Recorrido"></button>
                <button id="simulate-route-button" class="reminders-map-button-action" title="Simular interacciones de ruta"><img src="PNG/SIMULAR.PNG" alt="Simular Ruta"></button>
             </div>
             <div class="button-row" id="search-row-map-header">
                <button id="reorder-route-stages-button" title="Ordenar Etapas de Ruta"><img src="./PNG/MOVER.PNG" alt="Ordenar Etapas"></button>
                <button id="map-location-search-button" class="reminders-map-button-action"><img src="./PNG/ANADIRPUNTO.PNG" alt="Aadir Punto Ruta"></button>
                <button id="clear-map-search-input-button" title="Limpiar bsqueda">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="red" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
                <input type="text" id="map-location-search-input" placeholder="Direccin,sitio,zona /Negocio /Ciudad /CP+Provincia (28001 Madrid /Lidl Lugo)">
                <input type="text" id="filter-input" placeholder="Filtro"> 
                <button id="navigation-map-help-button" class="reminders-map-button-action" title="Ayuda del mapa de navegacin/radares"><img src="PNG/IMG_4326.PNG" alt="Ayuda"></button>
             </div>
        </div>
            <div id="reminders-location-map-div">
                    <div id="mapbox-map-actual-container"></div>
                    <div id="mini-nav-info-card"></div>
                     <div id="map-info-overlay"></div>
                      
             <div id="navigation-bottom-progress-bar" style="display: none;">
                <button id="toggle-progress-bar-lock" title="Bloquear/desbloquear panel de progreso" style="position: absolute; top: 0px; left: 0px; z-index: 2; flex-shrink: 0; background: none; border: none; padding: 0; cursor: pointer;">
                    <img src="PNG/IMG_4281.png" alt="Lock" style="width: 28px; height: 28px;">
                </button>
                <div style="flex-grow: 1; margin-left: 5px;">
                    <div id="navigation-top-info-bar" style="padding-left: 30px;">
                        <div id="turn-icon-container-styled">
                            <span id="turn-icon-display" class="turn-icon-display"></span>
                        </div>
                        <div class="maneuver-text-container">
                           <div>
                               <span id="maneuver-text-display" class="maneuver-text"></span>
                               <span id="street-name-display" class="street-name"></span>
                           </div>
                           <div id="distance-to-turn-formatted"></div>
                        </div>
                    </div>
                    <div id="distance-progress-bar-to-turn-container"> <div id="distance-progress-bar-to-turn"></div> </div>
                    <hr>
                    <div id="route-overall-progress-container">
                         <div id="route-overall-progress">
                             <img id="route-progress-icon" src="PNG/AVANCE.PNG" alt="Avance" style="display:none;">
                             <span id="route-progress-text"></span>
                         </div>
                    </div>
                    <div id="navigation-eta-info">
                        <div id="next-stage-info">
                            <strong id="next-stage-label">Prxima Etapa</strong>
                            <span id="next-stage-distance">-- km</span>  | 
                            <span id="next-stage-time">-- min</span>  |  ETA:
                            <span id="next-stage-eta">--:--</span>
                            <span id="next-stage-eta-deviation" class="eta-deviation"></span>
                        </div>
                        <div id="final-destination-info">
                            <strong> Destino</strong>
                            <span id="final-destination-distance">-- km</span>  | 
                            <span id="final-destination-time">-- min</span>  |  ETA:
                            <span id="final-destination-eta">--:--</span>
                            <span id="final-destination-eta-deviation" class="eta-deviation"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- =================================================================== -->

<div id="pin-modal-overlay" class="hidden">
    <div id="pin-modal-content">
        <h2>Introducir Clave de Acceso</h2>
        <div class="modal-top-buttons" style="justify-content: center;">
            <button id="pin-submit-button">Entrar</button>
        </div>
        <label for="pin-input">Clave (4 cifras):</label>
        <input type="password" id="pin-input" maxlength="4" pattern="\d{4}" inputmode="numeric" required>
        <p id="pin-error-message"></p>
    </div>
</div>

<div id="versions-modal-overlay" class="versions-modal-overlay hidden">
    <div class="versions-modal-content">
        <h2>Histrico de versiones y recomendaciones</h2>
        <div class="modal-top-buttons" style="justify-content: flex-end;">
             <button id="close-versions-modal" style="flex: 0 1 auto; min-width: 120px;">Salir</button>
        </div>
        <pre id="versions-content">Cargando...</pre>
    </div>
</div>

<div id="reorder-stages-modal" class="hidden">
    <h2>Ordenar Etapas de Ruta</h2>
    <div class="modal-top-buttons">
        <button id="confirm-reorder-stages">Aceptar <span class="button-countdown-timer"></span></button>
        <button id="cancel-reorder-stages">Cancelar</button>
    </div>
    <p style="font-size: 0.9rem; color: #555; margin-bottom: 1rem;">Arrastra y suelta las etapas para cambiar su orden. Pulsa el aspa (X) para eliminar una etapa.</p>
    <ul id="sortable-stages-list">
    </ul>
</div>

<div id="scroll-toggle" class="scroll-toggle-button" title="Ir al inicio o fin">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M19 12l-7 7-7-7"/></svg>
</div>


<div id="config-modal" class="hidden">
    <div class="modal-top-buttons">
        <h2>Configuracin y Datos</h2>
        <button id="config-close-modal" style="padding: 0.5rem 1rem; font-size:1rem;">Cerrar</button>
    </div>
    <div class="tab-buttons">
        <button class="config-tab-button active" data-tab-target="#tab-content-usuario">Usuario</button>
        <button class="config-tab-button" data-tab-target="#tab-content-pin">Clave Acceso</button>
        <button class="config-tab-button" data-tab-target="#tab-content-radares">RADARES</button>
        <button class="config-tab-button" data-tab-target="#tab-content-backup-restore">Backup/Restore</button>
        <button class="config-tab-button" data-tab-target="#tab-content-borrar">Borrar Datos</button>
        <button class="config-tab-button" data-tab-target="#tab-content-normas">Normas uso</button>
    </div>
    <div class="tab-contents">
        <div id="tab-content-usuario" class="config-tab-content active">
            <h3>Datos de Usuario y Sincronizacin</h3>
            <p style="font-size:.9rem;color:#555;margin-bottom:1.5rem;text-align:center;">
                Introduce un nombre de usuario nico para guardar y recuperar tus datos en la nube.
            </p>
            <p style="font-size: .95rem; color: #005A9C; margin-bottom: 1.5rem; text-align: left; background-color: #e6f7ff; padding: 10px; border-radius: 5px; border-left: 5px solid #007bff;">
                <strong>Modo Compaero (Mvil):</strong> Para sincronizar datos desde tu mvil, usa tu nombre de usuario seguido de <strong>@MOVIL o MVIL</strong> (ej: `MI_USUARIO@MOVIL`).
                Al iniciar sesin, se cargarn los LTIMOS DATOS que el coche haya GUARDADO EN LA NUBE. Cada cambio que hagas en el mvil (crear rutas, etc.) se guardar automticamente en la nube para que est disponible en el coche al CARGAR. 
                 -----IMPORTANTE!!!!---- SI QUIERES ENVIAR DATOS DESDE EL MVIL RECUERDA ANTES FORZAR UNA RECARGA DE LA PGINA EN EL COCHE (debes tener el check activo de copias automticas) O REALIZAR MANUALMENTE UN BACKUP</p>
            <div class="user-data-grid">
                <div><label for="user-id">* ID Usuario (nico, no se puede cambiar):</label><input type="text" id="user-id" name="userId" required></div>
                <div><label for="tesla-model">Modelo Tesla:</label><input type="text" id="tesla-model" name="teslaModel"></div>
                <div><label for="tesla-year">Ao Modelo:</label><input type="number" id="tesla-year" name="teslaYear" min="2012" max="2099"></div>
                <div><label for="tesla-province">Provincia:</label><input type="text" id="tesla-province" name="teslaProvince"></div>
                <div class="checkbox-container">
                    <input type="checkbox" id="allow-dms" name="allowDMs"><label for="allow-dms">Permitir MDs (va admin)</label>
                    <span id="map-session-status" style="margin-left: 20px; font-size: 0.85em; color: #555;"></span>
                </div>
                
                <div class="checkbox-container" style="border-top: 1px solid #ccc; padding-top: 1rem; margin-top: 1rem;">
                    <input type="checkbox" id="config-auto-backup-on-load" name="autoBackup">
                    <label for="config-auto-backup-on-load">Sincronizar/Hacer copia de seguridad automtica al cargar la pgina (en el coche)</label>
                </div>
            </div>
            <div class="user-buttons-container" style="margin-top:1.5rem;">
                <button id="config-save-user-firebase" style="background-color:#16A34A;color:white;">Validar usuario y/o Sincronizar/Guardar en la nube</button>
            </div>
            <p id="config-user-status" class="status-message"></p>
            </div>
         <div id="tab-content-pin" class="config-tab-content">
             <h3>Clave de Acceso (Local)</h3>
             <div class="pin-buttons-container" style="margin-bottom: 1rem;">
                 <button id="config-save-pin" style="background-color:#2563EB;color:white;">Guardar Clave y Preferencias</button>
                 <button id="config-remove-pin" style="background-color:#dc3545;color:white;">Quitar Clave</button>
             </div>
             <p style="font-size: 0.9rem; color: #555; margin-bottom: 1rem;">Establece una clave de 4 cifras para proteger el acceso inicial a la pgina</p>
             <div class="pin-config-layout">
                 <div class="pin-input-group">
                     <label for="config-pin-set">Establecer/Cambiar Clave:</label>
                     <input type="password" id="config-pin-set" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="4 cifras">
                 </div>
                 <div class="pin-input-group">
                     <label for="config-pin-confirm">Confirmar Clave:</label>
                     <input type="password" id="config-pin-confirm" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="Repetir 4 cifras">
                 </div>
             </div>
             <div class="checkbox-container" style="margin-top: 1.5rem; border-top: 1px solid #ccc; padding-top: 1rem;">
                <input type="checkbox" id="config-direct-to-nav" name="directToNav">
                <label for="config-direct-to-nav">Entrar directamente al Navegador de rutas</label>
            </div>
             <p id="config-pin-status" class="status-message"></p>
         </div>
         <div id="tab-content-radares" class="config-tab-content">
            <h3>Importar / Borrar Radares y Otros POIs</h3>
            <div class="radar-action-buttons" style="margin-bottom: 1rem;">
                <button id="import-radars-button">IMPORTAR RADARES y otros</button>
                <button id="delete-filtered-radars-button">BORRAR CACH (segn filtro)</button>
            </div>
            <p style="font-size:0.85rem; color:#444; margin-bottom:0.5rem;">
                Para <strong>importar</strong>, el filtro de "Palabras Clave" buscar coincidencias (OR) en el nombre del POI (ej: provincia, poblacin, tipo).
                Los filtros de Lat/Lon pueden ser un valor nico (aprox.) o un rango (ej: "<code>40.1 40.5</code>" para buscar entre esas latitudes). Si un filtro est vaco, no se aplica.
            </p>
             <p style="font-size:0.85rem; color:#444; margin-bottom:1rem;">
                 Los POIs importados (RADARES) se guardarn con un radio de <strong>400 metros</strong> y excluidos de la lista por defecto.
             </p>
            <p style="font-size:0.85rem; color:#444; margin-bottom:1.5rem;">
                Para <strong>borrar</strong>: Si NO se especifica NINGN filtro, se borrarn TODOS los recordatorios de tipo "RADAR" o excluidos de lista. Si se especifica algn filtro, se borrarn los que cumplan TODAS las condiciones activas (Palabras Clave OR, Latitud Y Longitud).
            </p>
            <div class="radar-filter-group">
                <div>
                    <label for="radar-filter-lat">Latitud (valor o "min max"):</label>
                    <input type="text" id="radar-filter-lat" placeholder="Ej: 40.123 o 40.0 40.5">
                </div>
                <div>
                    <label for="radar-filter-lon">Longitud (valor o "min max"):</label>
                    <input type="text" id="radar-filter-lon" placeholder="Ej: -3.567 o -4.0 -3.0">
                </div>
                <div style="grid-column: span 2;">
                    <label for="radar-filter-keywords">Palabras Clave (en nombre POI, separadas por espacio, condicin OR):</label>
                    <input type="text" id="radar-filter-keywords" placeholder="Ej: FIJO CAMUFLADO MADRID">
                </div>
            </div>
            <div class="radar-import-options">
                <input type="checkbox" id="import-extra-radars-checkbox">
                <label for="import-extra-radars-checkbox">Importar tambin radares mviles, semforo, etc (usa ficheros KLM adicionales)</label>
            </div>
             <div id="radar-import-progress-container" style="display:none;">
                 <progress id="radar-import-progress-bar" value="0" max="100"></progress>
                 <p id="radar-import-status" class="status-message"></p>
             </div>
         </div>
        <div id="tab-content-backup-restore" class="config-tab-content">
            <h3>Recuperar Backup / Hacer Copia en la Nube</h3>
            <p style="margin-bottom:1.2rem;">
                Para <strong>Recuperar</strong>, introduce tu ID de usuario y pulsa el botn naranja.<br>
                Para <strong>Hacer una Copia de Seguridad</strong>, asegrate de que tu ID est introducido en la pestaa "Usuario" y pulsa el botn verde.
            </p>
            
            <div class="user-data-grid" style="grid-template-columns: 1fr auto; align-items: end; gap: 1rem;">
                <div style="grid-column: 1 / 2;">
                    <label for="restore-user-id">ID Usuario a recuperar:</label>
                    <input type="text" id="restore-user-id" placeholder="Tu apodo nico (el que est en la pestaa usuario)...">
                </div>
                <div style="grid-column: 2 / 3; display: flex; flex-direction: column; gap: 0.5rem;">
                    <button id="config-restore-backup-firebase" style="background-color:#E65100;color:white;width:100%;padding: 0.6rem 1rem;">Recuperar Backup de la nube</button>
                    <button id="config-save-user-firebase-from-backup-tab" style="background-color:#16A34A;color:white;width:100%;padding: 0.6rem 1rem;">Hacer la copia de seguridad en la nube</button>
                </div>
            </div>
            <p id="config-restore-status" class="status-message"></p>
            <hr style="margin: 2rem 0;">
            <h3>Backup/Restore Local (Manual)</h3>
            <p style="font-size:.85rem; color:#555;">Esto es para copias manuales de texto. No interacta con la nube</p>
            <div class="backup-restore-container" style="margin-top:1rem;">
                 <div>
                    <h4>Crear Backup Local</h4>
                     <button id="config-generate-backup" style="background-color:#2563EB;color:white; margin-bottom: 1rem;">Generar Cdigo</button>
                    <textarea id="config-backup-display" readonly style="display:none;"></textarea>
                    <p id="config-backup-status" class="status-message"></p>
                </div>
                <div>
                    <h4>Restaurar Copia Local</h4>
                    <button id="config-restore-backup" style="background-color:#10B981;color:white; margin-bottom: 1rem;">Restaurar</button>
                    <textarea id="config-restore-input" placeholder="Pega el cdigo de backup local aqu..."></textarea>
                </div>
            </div>
        </div>
        
        <div id="tab-content-borrar" class="config-tab-content borrar-container">
            <h3>Borrar Datos Locales</h3>
             <button id="config-restore-grid-button">RESTAURAR EL GRID ORIGINAL DE BOTONES</button>
             <p id="config-restore-grid-status" class="status-message" style="margin-bottom: 1.5rem;"></p>
            <h3 style="border-top: 1px solid #ccc; padding-top: 1.5rem; margin-top:1.5rem;">Accin Irreversible</h3>
            <button id="config-clear-cache" style="margin-bottom: 0.5rem;">Borrar TODO</button>
            <p>Elimina TODOS los datos locales.</p>
            <p><strong style="color:red;">Sin deshacer!</strong> Ten backup.</p>
        </div>
        <div id="tab-content-normas" class="config-tab-content">
             <h3 style="text-align: center; font-size: 1.4rem; color: #c0392b; margin-bottom: 1rem;">Aviso Importante: Uso de la Aplicacin de Navegacin</h3>
             <div style="text-align: left; font-size: 0.95rem; line-height: 1.5; color: #333; max-height: 45vh; overflow-y: auto; padding-right: 10px;">
                 <p>Bienvenido/a a nuestra aplicacin de navegacin de rutas para coche! Hemos diseado esta herramienta con la mejor intencin de ayudarte a planificar tus viajes.</p>
                 <p style="margin-top: 1rem;">Sin embargo, es fundamental que entiendas que el uso de esta aplicacin es <strong>bajo tu propia y exclusiva responsabilidad</strong>. Al utilizar nuestra web, aceptas plenamente las siguientes condiciones:</p>
                 <ul style="list-style-type: disc; margin-left: 20px; margin-top: 1rem; space-y: 0.5rem;">
                     <li><strong>Responsabilidad del usuario:</strong> Eres el nico/a responsable de la toma de decisiones al volante. Nuestra aplicacin es una herramienta de apoyo y nunca debe sustituir tu juicio, la observacin directa de las condiciones de la va, las seales de trfico o la normativa de circulacin vigente.</li>
                     <li><strong>Supervisin constante:</strong> La aplicacin debe ser utilizada siempre bajo tu supervisin activa. La informacin proporcionada (cartografa, trazados, indicaciones, etc.) puede no estar actualizada en tiempo real o contener imprecisiones. Las condiciones de la carretera, el trfico o las regulaciones pueden cambiar sin previo aviso.</li>
                     <li><strong>Conduccin segura:</strong> Prioriza siempre la seguridad. Evita manipular la aplicacin mientras conduces y presta toda tu atencin a la carretera. Detente en un lugar seguro para consultar la ruta si es necesario.</li>
                     <li><strong>Errores y fallos:</strong> Aunque nos esforzamos por ofrecer un servicio fiable, no podemos garantizar que la aplicacin est libre de errores, interrupciones o fallos. No nos hacemos responsables de ningn dao, perjuicio o incidente que pueda derivarse del uso o la imposibilidad de uso de esta aplicacin.</li>
                     <li><strong>Actualizaciones:</strong> Te recomendamos mantener tu navegador y sistema operativo actualizados para el mejor funcionamiento de la aplicacin, aunque no podemos garantizar la compatibilidad total con todos los dispositivos y versiones.</li>
                 </ul>
                 <p style="margin-top: 1rem;">Al continuar utilizando esta aplicacin, confirmas que has ledo, entendido y aceptado este descargo de responsabilidad. Disfruta de tu viaje con precaucin!</p>
             </div>
             <div style="text-align: center; margin-top: 1.5rem;">
                 <button id="accept-terms-button" style="background-color:#28a745; color:white; padding: 0.8rem 2rem; font-size: 1.2rem; border-radius: 0.25rem;">Acepto</button>
             </div>
         </div>
    </div>
</div>   
<div id="simulation-modal" class="hidden">
</div>

<div id="simulation-speed-modal" class="hidden">
</div>

<div id="locations-preview-modal" class="hidden">
    <h2 id="locations-preview-title">Ubicaciones (filtrado segn tabla)</h2>
    <div id="locations-preview-map-container" style="height: calc(100% - 100px); width: 100%;"></div>
    <div class="modal-top-buttons" style="justify-content: center; margin-top: 1rem;">
        <button id="close-locations-preview">Salir</button>
    </div>
</div>

<div id="address-suggestions-modal" class="hidden">
    <h2 id="address-suggestions-title">Sugerencias de Direccin</h2>
    <ul id="address-suggestions-list"></ul>
    <div class="modal-top-buttons" style="justify-content: flex-end; margin-top: 1rem;">
        <button id="close-address-suggestions-modal" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
    </div>
</div>

<div id="deviation-modal" class="hidden">
</div>

<div id="arrival-stats-modal" class="hidden">
</div>

<div id="intersection-preview-map-window" class="hidden">
    <div id="intersection-preview-map-container"></div>
</div>

<div id="alert-modal-overlay" class="hidden">
    <div id="alert-modal-content">
      </div>
</div>

<div id="proximity-alert-modal" class="hidden">
</div>

<div id="flashing-border-overlay" class="hidden"></div>

<div id="chat-modal-overlay" class="hidden">
    <div id="chat-modal-content">
        <div id="chat-left-column">
            
            <div id="chat-input-area">
                <div id="chat-permission-warning" class="hidden"></div>
                <textarea id="chat-message-input" rows="4" maxlength="500" placeholder="Escribe un mensaje... (antecede @usuario para mensaje privado, o pulsa en el lateral. Para referirse simplemente nmbralo). Vida de los mensajes 96 horas. En el coche usa los comandos de voz. Elon cree en la humanidad, the White Monkey y yo tambin, ser educad@s."></textarea>
              
                <div id="chat-input-footer">
                    <div id="chat-buttons">
                        <button id="chat-send-button">Enviar</button>
                        <button id="chat-exit-button">Salir</button>
                    </div>
                    <div id="chat-char-counter">500</div>
                </div>
            </div>
            
            <div id="chat-messages-container"></div>
        </div>

        <div id="chat-right-column">
            <div id="chat-users-filter-container">
                <input type="text" id="chat-user-filter-input" placeholder="Filtrar por cualquier dato...">
            </div>
            <div id="chat-users-list"></div>
        </div>
    </div>
</div>
    
</div>    
<script>

    
//ofu mapbox
                                                                                                    mapboxgl.accessToken = "pk.eyJ1IjoiYm9hcmRpbmdnYXRlMTEiLCJhIjoiY21kOHdtMGU4MDEzaTJpcGh4cng0c3hmMiJ9.hDdGn_5VOMkN_bTuUowtRw";

// ===================================================================
// NOMBRE: findGooglePlaceId (NUEVA VERSIN - Places API v2)
// RESUMEN: Busca un lugar usando texto/coordenadas para obtener su place_id.
// ===================================================================
async function findGooglePlaceId(poiName, lat, lng) {
    if (!window.google || !window.google.maps || !window.google.maps.places) {
        console.error("La librera de Google Places no est cargada.");
        showToast("Error: No se pudo cargar el servicio de lugares.", "error");
        return null;
    }

    const request = {
        textQuery: poiName,
        fields: ['id'], // En la nueva API, el campo se llama 'id'
        locationBias: { center: { lat: lat, lng: lng }, radius: 2000 }, // Radio en metros
    };

    try {
        const { places } = await google.maps.places.Place.searchByText(request);
        
        if (places && places.length > 0) {
            return places[0].id; // El ID del lugar
        } else {
            console.warn("No se encontr un place_id de Google para:", poiName);
            return null;
        }
    } catch (error) {
        console.error("Error en la bsqueda de Google Places:", error);
        return null;
    }
}

// ===================================================================
// NOMBRE: getGooglePlaceDetails (NUEVA VERSIN - Places API v2)
// RESUMEN: Obtiene los detalles completos de un lugar usando su place_id.
// ===================================================================
async function getGooglePlaceDetails(placeId) {
    if (!window.google || !window.google.maps || !window.google.maps.places) {
        console.error("La librera de Google Places no est cargada.");
        showToast("Error: No se pudo cargar el servicio de lugares.", "error");
        return null;
    }
    
    const place = new google.maps.places.Place({ id: placeId });

    const fieldsToRequest = [
        'displayName', 'formattedAddress', 'websiteURI', 'nationalPhoneNumber',
        'regularOpeningHours', 'photos', 'rating', 'userRatingCount', 'googleMapsURI', 'reviews'
    ];
    
    try {
        await place.fetchFields({ fields: fieldsToRequest });
        
        return place;
    } catch (error) {
        console.error("Error al obtener detalles de Google Places:", error);
        return null;
    }
}
// ===================================================================
// NOMBRE: MapLayerAndViewController (VERSIN CORREGIDA Y DEFINITIVA)
// RESUMEN: Gestiona el cambio de estilo de mapa y se asegura de que todas las capas,
//          fuentes e imgenes personalizadas se recarguen y redibujen correctamente.
class MapLayerAndViewController {
    onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.className = 'mapboxgl-ctrl map-combined-control-container';

        this._container.addEventListener('click', e => e.stopPropagation());
        this._container.addEventListener('dblclick', e => e.stopPropagation());

        const layerSelector = document.createElement('div');
        layerSelector.className = 'map-layer-selector';

        const baseMaps = {
            "HBRIDO": "mapbox://styles/mapbox/satellite-streets-v12",
            "SATLITE": "mapbox://styles/mapbox/satellite-v9",
            "CALLES": "mapbox://styles/mapbox/streets-v12"
        };
        
        const legacyNameMap = {
            "Satlite + Calles": "HBRIDO",
            "Satlite Puro": "SATLITE",
            "Mapa Normal": "CALLES"
        };

        let savedLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY);

        if (legacyNameMap[savedLayerName]) {
            savedLayerName = legacyNameMap[savedLayerName];
            localStorage.setItem(ACTIVE_MAP_LAYER_KEY, savedLayerName);
        }

        if (!savedLayerName || !baseMaps[savedLayerName]) {
            savedLayerName = "HBRIDO";
        }
        
        Object.keys(baseMaps).forEach(name => {
            const label = document.createElement('label');
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = 'map-style-selector';
            input.value = baseMaps[name];
            if (name === savedLayerName) {
                input.checked = true;
            }
            input.onchange = () => {
                this._map.setStyle(input.value);
                localStorage.setItem(ACTIVE_MAP_LAYER_KEY, name);
                
                this._map.once('style.load', () => {
                    reAddCustomMapLayersAndSources(this._map).then(() => {
                        plotRemindersOnNavigationMap();
                        displayChargingPointsOnMap();
                        renderWaypointMarkers();
                    });
                    updateRouteAndCarIconStyle();
                });
              };
            label.appendChild(input);
            label.appendChild(document.createTextNode(` ${name}`));
            layerSelector.appendChild(label);
        });

        const viewSelector = document.createElement('div');
        viewSelector.className = 'map-view-selector';
        const viewModes = {
            'NORTE': {pitch: 0, bearing: 0, mode: 'static'},
            'AVANCE': {pitch: 0, bearing: null, mode: 'heading'},
            '3D': {pitch: 56, bearing: null, mode: 'perspective'}
        };

        const savedViewMode = localStorage.getItem(MAP_VIEW_MODE_KEY) || 'static';
        
        Object.keys(viewModes).forEach(name => {
            const label = document.createElement('label');
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = 'map-view-selector';
            input.value = viewModes[name].mode;

            if (viewModes[name].mode === savedViewMode) {
                input.checked = true;
            }

            input.onchange = () => {
                const selectedModeValue = input.value;
                const modeDetails = Object.values(viewModes).find(m => m.mode === selectedModeValue);
                const modeName = Object.keys(viewModes).find(key => viewModes[key].mode === selectedModeValue);

                if (modeDetails) {
                    mapViewMode = modeDetails.mode;
                    localStorage.setItem(MAP_VIEW_MODE_KEY, mapViewMode);
                    markCacheAsDirty();
                    showToast(`Modo Vista: ${modeName}`, 'info');

                    const easeOptions = { };
                    // --- CORRECCIN CLAVE: Usar el pitch guardado para el modo 3D ---
                    if (modeName === '3D') {
                        easeOptions.pitch = mapPitchValue; // Usar el valor persistente
                    } else {
                        easeOptions.pitch = modeDetails.pitch; // Usar 0 para NORTE y AVANCE
                    }

                    if (modeDetails.bearing !== null) {
                        easeOptions.bearing = modeDetails.bearing;
                    } else if (navigationCurrentLocation && navigationCurrentLocation.heading !== null) {
                        easeOptions.bearing = navigationCurrentLocation.heading;
                    }
                    this._map.easeTo(easeOptions);
                    
                    if (navigationCurrentLocation) {
                        updateInitialUserPosition(navigationCurrentLocation, this._map);
                    }
                }
            };
            label.appendChild(input);
            label.appendChild(document.createTextNode(` ${name}`));
            viewSelector.appendChild(label);
        });
        
        this._container.appendChild(layerSelector);
        this._container.appendChild(viewSelector);

        return this._container;
    }

    onRemove() {
        if (this._container && this._container.parentNode) {
            this._container.parentNode.removeChild(this._container);
        }
        this._map = undefined;
    }
}    
// ===================================================================
// NOMBRE: CompassAndStatsControl
// RESUMEN: Control que muestra brjula, altitud y velocidades.
// ===================================================================
class CompassAndStatsControl {
    constructor(options) {
        this.options = options || {};
    }

    onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.className = 'mapboxgl-ctrl map-control-custom-map-controls';
        
        const compassContainer = document.createElement('div');
        compassContainer.className = 'map-control-orientation-altitude';
        compassContainer.innerHTML = `
            <img id="compass-rose-icon" src="PNG/ROSA.PNG" alt="Orientacin">
            <span id="orientation-text">---</span>
            <span id="altitude-display">--- m</span>
            <span id="current-speed-display">--- km/h</span>
            <span id="average-speed-display" class="speed-stats-text">Med: --- km/h</span>
            <span id="max-speed-display" class="speed-stats-text">Mx: --- km/h</span>
        `;
        
        compassContainer.addEventListener('click', (e) => {
            e.stopPropagation();
            this._toggleGraphMode(e);
        });
        compassContainer.title = "Clic para cambiar modo de la grfica";

        const graphCard = document.createElement('div');
        graphCard.className = 'hidden';
        graphCard.id = 'navigation-graph-card';
        graphCard.style.position = 'relative'; 
        graphCard.style.cursor = 'pointer';
        graphCard.addEventListener('click', toggleEnlargedGraph);
        
        const graphTitle = document.createElement('div');
        graphTitle.id = 'navigation-graph-title';
        graphCard.appendChild(graphTitle);

        const enlargeButton = document.createElement('div');
        enlargeButton.id = 'enlarge-graph-button';
        enlargeButton.title = 'Ampliar/Reducir grfica';
        enlargeButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="11" y1="8" x2="11" y2="14"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        `;
        enlargeButton.addEventListener('click', (e) => {
            e.stopPropagation(); 
            toggleEnlargedGraph();
        });
        graphCard.appendChild(enlargeButton);

        const graphCanvasContainer = document.createElement('div');
        graphCanvasContainer.id = 'navigation-graph-container';
        const canvas = document.createElement('canvas');
        canvas.id = 'navigation-chart';
        graphCanvasContainer.appendChild(canvas);
        graphCard.appendChild(graphCanvasContainer);
        
        this._container.appendChild(compassContainer);
        this._container.appendChild(graphCard);
        this._updateGraphTitle();
        return this._container;
    }

    onRemove() {
        if (this._container && this._container.parentNode) {
            this._container.parentNode.removeChild(this._container);
        }
        this._map = undefined;
    }
    
    _toggleGraphMode(e) {
        if (e) e.stopPropagation();
        if (!navigationCurrentRouteData && !isFreeDriveActive) {
            showToast("La grfica estar disponible cuando se calcule una ruta o inicies un viaje libre.", "info");
            return;
        }
        const modes = ['Desviacin ETA', 'Altitud', 'Grfica off'];
        let currentIndex = modes.indexOf(currentGraphMode);
        currentIndex = (currentIndex + 1) % modes.length;
        currentGraphMode = modes[currentIndex];
        localStorage.setItem(GRAPH_STATE_KEY, currentGraphMode); 
        updateNavigationGraphVisibilityAndMode();
        if (currentGraphMode !== 'Grfica off') {
            showToast(`Grfica cambiada a: ${currentGraphMode}`, 'info');
        } else {
            showToast(`Grfica desactivada`, 'info');
        }
    }

    _updateGraphTitle() {
        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            if (currentGraphMode === 'Desviacin ETA') {
                graphTitleElement.textContent = 'Desviacin ETA';
            } else if (currentGraphMode === 'Altitud') {
                graphTitleElement.textContent = 'Desnivel Ruta';
            } else {
                graphTitleElement.textContent = ''; 
            }
        }
    }
    
    updateOrientation(heading) {
        const compassRoseIcon = document.getElementById('compass-rose-icon');
        const orientationText = document.getElementById('orientation-text');
        if (compassRoseIcon && orientationText) {
            if (heading !== null && !isNaN(heading) && heading >= 0 && heading <= 360) {
                compassRoseIcon.style.transform = `rotate(${heading}deg)`;
                currentMapBearing = heading;
                const directions = ["N", "NE", "E", "SE", "S", "SO", "O", "NO", "N"];
                const index = Math.round(heading / 45) % 8;
                orientationText.textContent = `${directions[index]}`;
            } else {
                compassRoseIcon.style.transform = 'rotate(0deg)';
                orientationText.textContent = '---';
                currentMapBearing = 0;
            }
        }
    }

    updateAltitude(altitude) {
        const altitudeDisplay = document.getElementById('altitude-display');
        if (altitudeDisplay) {
            let displayText = '--- m';
            if (altitude !== null && !isNaN(altitude)) {
                displayText = `${altitude.toFixed(0)} m`;
                if (maxAltitudeDuringTrip !== -Infinity && isNavigating) {
                    displayText += ` \u2261 ${maxAltitudeDuringTrip.toFixed(0)} m`;
                }
            } else if (isNavigating && maxAltitudeDuringTrip !== -Infinity) {
                 displayText = `-- m \u2261 ${maxAltitudeDuringTrip.toFixed(0)} m`;
            }
            altitudeDisplay.textContent = displayText;
        }
    }

    updateCurrentSpeed(speedKmh) {
        const speedDisplay = document.getElementById('current-speed-display');
        if (speedDisplay) {
            if (speedKmh !== null && !isNaN(speedKmh)) {
                speedDisplay.textContent = `${speedKmh.toFixed(1)} km/h`;
            } else {
                speedDisplay.textContent = '--- km/h';
            }
        }
    }

    updateAverageSpeed(avgSpeedKmh) {
        const avgSpeedDisplay = document.getElementById('average-speed-display');
        if (avgSpeedDisplay) {
            let displayText = 'Med: --- km/h';
            if (avgSpeedKmh !== null && !isNaN(avgSpeedKmh) && (isNavigating || (isSimulatingGpsLocation && automatedSimulationIntervalId) || isFreeDriveActive)) {
                 displayText = `Med: ${avgSpeedKmh.toFixed(1)} km/h`;
            }
            avgSpeedDisplay.textContent = displayText;
        }
    }

    updateMaxSpeed(currentSpeedKmh, currentCoords) {
        if (typeof currentSpeedKmh === 'number' && currentSpeedKmh > maxSpeedDuringTrip) {
            maxSpeedDuringTrip = currentSpeedKmh;
            if (currentCoords) {
                maxSpeedCoordinates = { lat: currentCoords.latitude, lng: currentCoords.longitude };
            }
        }
        const maxSpeedDisplay = document.getElementById('max-speed-display');
        if (maxSpeedDisplay) {
            let displayText = 'Mx: --- km/h'; 
            if (typeof maxSpeedDuringTrip === 'number' && !isNaN(maxSpeedDuringTrip)) {
                if (maxSpeedDuringTrip > 0) {
                    displayText = `Mx: ${maxSpeedDuringTrip.toFixed(1)} km/h`;
                } else if ((isNavigating || (isSimulatingGpsLocation && automatedSimulationIntervalId) || isFreeDriveActive) && maxSpeedDuringTrip === 0) {
                    displayText = `Mx: 0.0 km/h`;
                }
            }
            maxSpeedDisplay.textContent = displayText;
        }
    }
}
// ===================================================================
// NOMBRE: MapSettingsPanel (NUEVA CLASE)
// RESUMEN: Crea el CONTENIDO del panel emergente de ajustes (capas y vistas).
class MapSettingsPanel {
    constructor(map) {
        this._map = map;
    }

    createPanelContent() {
        const fragment = document.createDocumentFragment();

        // Contenido de la clase MapLayerAndViewController, adaptado
        const layerSelector = document.createElement('div');
        layerSelector.className = 'map-layer-selector';

        const baseMaps = { "HBRIDO": "mapbox://styles/mapbox/satellite-streets-v12", "SATLITE": "mapbox://styles/mapbox/satellite-v9", "CALLES": "mapbox://styles/mapbox/streets-v12" };
        const legacyNameMap = { "Satlite + Calles": "HBRIDO", "Satlite Puro": "SATLITE", "Mapa Normal": "CALLES" };
        let savedLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY);
        if (legacyNameMap[savedLayerName]) { savedLayerName = legacyNameMap[savedLayerName]; localStorage.setItem(ACTIVE_MAP_LAYER_KEY, savedLayerName); }
        if (!savedLayerName || !baseMaps[savedLayerName]) { savedLayerName = "HBRIDO"; }
        
        Object.keys(baseMaps).forEach(name => {
            const label = document.createElement('label');
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = 'map-style-selector';
            input.value = baseMaps[name];
            if (name === savedLayerName) input.checked = true;
            input.onchange = () => {
                this._map.setStyle(input.value);
                localStorage.setItem(ACTIVE_MAP_LAYER_KEY, name);
                this._map.once('style.load', () => {
                    reAddCustomMapLayersAndSources(this._map).then(() => {
                        plotRemindersOnNavigationMap();
                        displayChargingPointsOnMap();
                        renderWaypointMarkers();
                    });
                    updateRouteAndCarIconStyle();
                });
            };
            label.appendChild(input);
            label.appendChild(document.createTextNode(` ${name}`));
            layerSelector.appendChild(label);
        });

        const viewSelector = document.createElement('div');
        viewSelector.className = 'map-view-selector';
        const viewModes = { 'NORTE': {pitch: 0, bearing: 0, mode: 'static'}, 'AVANCE': {pitch: 0, bearing: null, mode: 'heading'}, '3D': {pitch: 56, bearing: null, mode: 'perspective'} };
        const savedViewMode = localStorage.getItem(MAP_VIEW_MODE_KEY) || 'static';
        
        Object.keys(viewModes).forEach(name => {
            const label = document.createElement('label');
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = 'map-view-selector';
            input.value = viewModes[name].mode;
            if (viewModes[name].mode === savedViewMode) input.checked = true;
            input.onchange = () => {
                const selectedModeValue = input.value;
                const modeDetails = Object.values(viewModes).find(m => m.mode === selectedModeValue);
                const modeName = Object.keys(viewModes).find(key => viewModes[key].mode === selectedModeValue);
                if (modeDetails) {
                    mapViewMode = modeDetails.mode;
                    localStorage.setItem(MAP_VIEW_MODE_KEY, mapViewMode);
                    markCacheAsDirty();
                    showToast(`Modo Vista: ${modeName}`, 'info');
                    const easeOptions = { pitch: modeDetails.pitch };
                    if (modeDetails.bearing !== null) easeOptions.bearing = modeDetails.bearing;
                    else if (navigationCurrentLocation && navigationCurrentLocation.heading !== null) easeOptions.bearing = navigationCurrentLocation.heading;
                    this._map.easeTo(easeOptions);
                    if (navigationCurrentLocation) updateInitialUserPosition(navigationCurrentLocation, this._map);
                }
            };
            label.appendChild(input);
            label.appendChild(document.createTextNode(` ${name}`));
            viewSelector.appendChild(label);
        });
        
        const separator = document.createElement('div');
        separator.className = 'separator';

        fragment.appendChild(layerSelector);
        fragment.appendChild(separator);
        fragment.appendChild(viewSelector);

        return fragment;
    }
}
// ===================================================================
// NOMBRE: CustomMapControlsGroup (VERSIN CON RESET DE PITCH)
// RESUMEN: Gestiona la barra horizontal y los paneles emergentes.
class CustomMapControlsGroup {
    onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.className = 'mapboxgl-ctrl map-controls-bottom-right';
        
        this._settingsPopup = document.createElement('div');
        this._settingsPopup.className = 'map-settings-popup';
        const settingsPanel = new MapSettingsPanel(map);
        this._settingsPopup.appendChild(settingsPanel.createPanelContent());
        
        this._offsetPopup = document.createElement('div');
        this._offsetPopup.className = 'map-offset-popup';
        
        this._offsetPopup.innerHTML = `
            <div class="crosshair-container" style="position: relative;">
                <!-- NUEVO: Contenedor para el valor Y (Vertical) -->
                <div id="offset-value-display-y" class="offset-value-display vertical"></div>

                <button id="offset-arrow-up" class="offset-arrow" title="Mover vista hacia arriba">
                    <svg viewBox="0 0 24 24"><path d="M12 19V5M5 12l7-7 7 7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
                <button id="offset-arrow-left" class="offset-arrow" title="Mover vista a la izquierda">
                    <svg viewBox="0 0 24 24"><path d="M19 12H5M12 5l-7 7 7 7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>

                <!-- NUEVO: Contenedor para el valor X (Horizontal) -->
                <div id="offset-value-display-x" class="offset-value-display horizontal"></div>
                
                <div id="minimap-toggle-container">
                    <input type="checkbox" id="minimap-toggle-checkbox">
                    <label for="minimap-toggle-checkbox">Giros</label>
                </div>
                <button id="offset-arrow-right" class="offset-arrow" title="Mover vista a la derecha">
                    <svg viewBox="0 0 24 24"><path d="M5 12h14M12 5l7 7-7 7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
                <button id="offset-arrow-down" class="offset-arrow" title="Mover vista hacia abajo">
                    <svg viewBox="0 0 24 24"><path d="M12 5v14M19 12l-7 7-7-7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
                
            </div>
            <div class="offset-popup-separator"></div>
            <div class="pitch-controls-container">
                <button id="pitch-arrow-up" class="offset-arrow" title="Aumentar inclinacin (pitch)">
                    <svg viewBox="0 0 24 24"><path d="M12 19V5M5 12l7-7 7 7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
                <span id="pitch-value-display" class="pitch-value-display">0</span>
                <button id="pitch-arrow-down" class="offset-arrow" title="Reducir inclinacin (pitch)">
                    <svg viewBox="0 0 24 24"><path d="M12 5v14M19 12l-7 7-7-7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
            </div>
        `;
      
        this.zoomControl = new ZoomControl(this); 
        const zoomControlElement = this.zoomControl.onAdd(map);
        
        this._container.appendChild(this._settingsPopup);
        this._container.appendChild(this._offsetPopup);
        this._container.appendChild(zoomControlElement);
        
        this._popupTimer = null; 
        this._offsetPopupTimer = null;

        this._offsetPopup.querySelector('#offset-arrow-up').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapOffset('y', -1); });
        this._offsetPopup.querySelector('#offset-arrow-down').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapOffset('y', 1); });
        this._offsetPopup.querySelector('#offset-arrow-left').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapOffset('x', -1); });
        this._offsetPopup.querySelector('#offset-arrow-right').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapOffset('x', 1); });
        
        this._offsetPopup.querySelector('#pitch-arrow-up').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapPitch(1); });
        this._offsetPopup.querySelector('#pitch-arrow-down').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapPitch(-1); });
        
        const pitchDisplay = this._offsetPopup.querySelector('#pitch-value-display');
        pitchDisplay.style.cursor = 'pointer';
        pitchDisplay.title = 'Pulsar para restaurar inclinacin por defecto del modo actual';
        pitchDisplay.addEventListener('click', (e) => {
            e.stopPropagation();
            triggerManualMapInteraction();

            let targetPitch = 0;
            let modeName = "Norte/Avance";

            if (mapViewMode === 'perspective') {
                targetPitch = 56;
                modeName = "3D";
            }
            
            mapPitchValue = targetPitch;
            saveSettings();
            this._map.easeTo({ pitch: targetPitch, duration: 500 });

            showToast(`Inclinacin restaurada al valor por defecto del modo ${modeName} (${targetPitch})`, 'info');
        });
        
        const minimapCheckbox = this._offsetPopup.querySelector('#minimap-toggle-checkbox');
        minimapCheckbox.checked = showMinimapPreference;
        minimapCheckbox.addEventListener('change', (e) => {
            e.stopPropagation();
            showMinimapPreference = e.target.checked;
            saveSettings();
            showToast(`Minimapa de maniobras ${showMinimapPreference ? 'ACTIVADO' : 'DESACTIVADO'}`, 'info');
        });

        this._map.on('pitch', () => this.updatePitchDisplay());

        return this._container;
    }

    updateOffsetDisplay() {
        const displayX = this._offsetPopup.querySelector('#offset-value-display-x');
        const displayY = this._offsetPopup.querySelector('#offset-value-display-y');
        if (displayX) {
            displayX.textContent = `X : ${mapOffsetX}%`;
        }
        if (displayY) {
            displayY.textContent = `Y : ${mapOffsetY}%`;
        }
    }

    updatePitchDisplay() {
        const display = this._offsetPopup.querySelector('#pitch-value-display');
        if (display) {
            display.textContent = `${this._map.getPitch().toFixed(0)}`;
        }
    }

    adjustMapOffset(axis, amount) {
        triggerManualMapInteraction(); 
        if (axis === 'y') {
            mapOffsetY = Math.max(-75, Math.min(75, mapOffsetY + amount));
        } else if (axis === 'x') {
            mapOffsetX = Math.max(-75, Math.min(75, mapOffsetX + amount));
        }
        this.updateOffsetDisplay();
        saveSettings();
        if (isNavigating && navigationCurrentLocation && navigationMapInstance) {
            updateInitialUserPosition(navigationCurrentLocation, navigationMapInstance);
        }
    }

    adjustMapPitch(amount) {
        triggerManualMapInteraction(); 
        const currentPitch = this._map.getPitch();
        const newPitch = Math.max(0, Math.min(85, currentPitch + amount));
        mapPitchValue = newPitch; 
        saveSettings();
        this._map.easeTo({ pitch: newPitch, duration: 300 });
       }

    toggleSettingsPopup() {
        if (this._offsetPopup.classList.contains('visible')) this.toggleOffsetPopup();
        if (this._settingsPopup.classList.contains('visible')) {
            this._settingsPopup.classList.remove('visible');
            if (this._popupTimer) { clearTimeout(this._popupTimer); this._popupTimer = null; }
        } else {
            this._settingsPopup.classList.add('visible');
            if (this._popupTimer) clearTimeout(this._popupTimer);
            this._popupTimer = setTimeout(() => { this._settingsPopup.classList.remove('visible'); this._popupTimer = null; }, 80000);
        }
    }

    toggleOffsetPopup() {
        if (this._settingsPopup.classList.contains('visible')) this.toggleSettingsPopup();
        if (this._offsetPopup.classList.contains('visible')) {
            this._offsetPopup.classList.remove('visible');
            if (this._offsetPopupTimer) { clearTimeout(this._offsetPopupTimer); this._offsetPopupTimer = null; }
        } else {
            this.updateOffsetDisplay();
            this.updatePitchDisplay();
            this._offsetPopup.classList.add('visible');
            if (this._offsetPopupTimer) clearTimeout(this._offsetPopupTimer);
            this._offsetPopupTimer = setTimeout(() => { this._offsetPopup.classList.remove('visible'); this._offsetPopupTimer = null; }, 80000);
        }
    }

    onRemove() {
        if (this.zoomControl) this.zoomControl.onRemove();
        if (this._popupTimer) clearTimeout(this._popupTimer);
        if (this._offsetPopupTimer) clearTimeout(this._offsetPopupTimer);
        if (this._container && this._container.parentNode) this._container.parentNode.removeChild(this._container);
        this._map = undefined;
    }
} 
// ===================================================================
// NOMBRE: ZoomControl (VERSIN FINAL Y CORREGIDA)
// RESUMEN: Su botn de zoom ahora llama a la funcin maestra externa `handleZoomToggleButtonClick`.
// ===================================================================
class ZoomControl {
    constructor(parentControl) {
        this.parentControl = parentControl;
    }
    onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.id = 'zoom-controls-horizontal';
        
        const zoomInBtn = document.createElement('div');
        zoomInBtn.className = 'zoom-control-button';
        zoomInBtn.textContent = '+';
        zoomInBtn.title = 'Acercar';

        const zoomOutBtn = document.createElement('div');
        zoomOutBtn.className = 'zoom-control-button';
        zoomOutBtn.textContent = '';
        zoomOutBtn.title = 'Alejar';

        const levelDisplay = document.createElement('div');
        levelDisplay.id = 'zoom-level-display';
        levelDisplay.style.cssText = 'color: white; font-weight: bold; text-shadow: 1px 1px 2px black; min-width: 40px; text-align: center;';
        levelDisplay.textContent = map.getZoom().toFixed(1);

        const autoBtn = document.createElement('div');
        autoBtn.id = 'zoom-auto-button';
        autoBtn.className = 'zoom-control-button';
        
        const locateMeBtn = document.createElement('div');
        locateMeBtn.id = 'zoom-locate-me-button';
        locateMeBtn.className = 'zoom-control-button';
        locateMeBtn.innerHTML = `<img src="PNG/ESTASAQUI.PNG" alt="Localizar">`;
        
        const toggleBtn = document.createElement('div');
        toggleBtn.id = 'zoom-toggle-button';
        toggleBtn.className = 'zoom-control-button';
        toggleBtn.title = 'Alternar entre vista de ruta y coche';
        toggleBtn.innerHTML = `<img src="PNG/ZOOM+.PNG" alt="Toggle Zoom">`;

        const settingsBtn = document.createElement('div');
        settingsBtn.id = 'map-settings-toggle-button';
        settingsBtn.className = 'zoom-control-button';
        settingsBtn.title = 'Ajustes de mapa y vista';
        settingsBtn.innerHTML = `<img src="PNG/GPS.PNG" alt="Ajustes">`;
        
        const offsetBtn = document.createElement('div');
        offsetBtn.id = 'map-offset-toggle-button';
        offsetBtn.className = 'zoom-control-button';
        offsetBtn.title = 'Ajustar posicin del coche en pantalla';
        offsetBtn.innerHTML = `<img src="PNG/picht.png" alt="Offset">`;

        this._container.appendChild(zoomInBtn);
        this._container.appendChild(levelDisplay);
        this._container.appendChild(zoomOutBtn);
        this._container.appendChild(autoBtn);
        this._container.appendChild(locateMeBtn);
        this._container.appendChild(toggleBtn);
        this._container.appendChild(settingsBtn);
        this._container.appendChild(offsetBtn);
        
        map.on('zoom', () => { levelDisplay.textContent = map.getZoom().toFixed(1); });
        
        const ZOOM_INCREMENT = 0.3;
        zoomInBtn.addEventListener('click', (e) => { e.stopPropagation(); map.easeTo({ zoom: map.getZoom() + ZOOM_INCREMENT }); });
        zoomOutBtn.addEventListener('click', (e) => { e.stopPropagation(); map.easeTo({ zoom: map.getZoom() - ZOOM_INCREMENT }); });
        
        const zoomModesCycle = { auto: 'off', off: 'route', route: 'auto' };
        let currentMode = localStorage.getItem(AUTO_ZOOM_MODE_KEY) || 'off';

        const updateAutoButtonVisuals = () => {
            autoBtn.classList.remove('active', 'route-mode');
            if (currentMode === 'auto') {
                autoBtn.textContent = 'AUTO';
                autoBtn.classList.add('active');
                autoBtn.title = 'Zoom automtico por velocidad (Activado)';
            } else if (currentMode === 'route') {
                autoBtn.textContent = 'RUTA';
                autoBtn.classList.add('active', 'route-mode');
                autoBtn.title = 'Vista general de ruta (Zoom fijo a nivel 13)';
            } else { // 'off'
                autoBtn.textContent = 'AUTO';
                autoBtn.title = 'Zoom automtico (Desactivado)';
            }
        };

        autoBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            currentMode = zoomModesCycle[currentMode];
            localStorage.setItem(AUTO_ZOOM_MODE_KEY, currentMode);
            
            updateAutoButtonVisuals();
            
            isManualZoomActive = false;
            if (manualZoomTimeout) clearTimeout(manualZoomTimeout);

            switch (currentMode) {
                case 'auto':
                    handleAutoZoom();
                    break;
                case 'off':
                    break;
                case 'route':
                    map.easeTo({ zoom: 13 });
                    break;
            }
        });
        
        updateAutoButtonVisuals();
        
        toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            handleZoomToggleButtonClick(toggleBtn);
        });
        
        locateMeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            handleLocateMeClick(true);
        });
        
        settingsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.parentControl.toggleSettingsPopup();
        });

        offsetBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.parentControl.toggleOffsetPopup();
        });

        return this._container;
    }
    onRemove() { if (this._container && this._container.parentNode) this._container.parentNode.removeChild(this._container); this._map = undefined; }
}
// ===================================================================
// NOMBRE: CombinedMapControl (NUEVA CLASE)
// RESUMEN: Envuelve los controles de Capas/Vista y Zoom en un nico contenedor para que aparezcan juntos.
class CombinedMapControl {
    onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.className = 'mapboxgl-ctrl map-combined-controls-wrapper';

        this.layerAndViewControl = new MapLayerAndViewController();
        const layerControlElement = this.layerAndViewControl.onAdd(map);
        
        this.zoomControl = new ZoomControl();
        const zoomControlElement = this.zoomControl.onAdd(map);
        
        if (layerControlElement) {
            this._container.appendChild(layerControlElement);
        }
        if (zoomControlElement) {
            this._container.appendChild(zoomControlElement);
        }
        
        return this._container;
    }

    onRemove() {
        if (this.layerAndViewControl) this.layerAndViewControl.onRemove();
        if (this.zoomControl) this.zoomControl.onRemove();
        
        if (this._container && this._container.parentNode) {
            this._container.parentNode.removeChild(this._container);
        }
        this._map = undefined;
    }
}
    
//=======================================================        
    
    const originalToFixed = Number.prototype.toFixed;
    Number.prototype.toFixed = function(digits) {
        if (this === undefined || this === null || isNaN(this)) {
            try {
                throw new Error("Debug toFixed Call");
            } catch (e) {
            }
            return "NaN";
        }
        return originalToFixed.call(this, digits);
    };
 
    const MAP_STYLES = {
        "HBRIDO": "mapbox://styles/mapbox/satellite-streets-v12",
        "SATLITE": "mapbox://styles/mapbox/satellite-v9",
        "CALLES": "mapbox://styles/mapbox/streets-v12"
    };
    const MAP_LEGACY_NAME_MAP = {
        "Satlite + Calles": "HBRIDO",
        "Satlite Puro": "SATLITE",
        "Mapa Normal": "CALLES"
    };
    const MAP_VIEW_MODES = {
        'NORTE': {pitch: 0, bearing: 0, mode: 'static'},
        'AVANCE': {pitch: 0, bearing: null, mode: 'heading'},
        '3D': {pitch: 62, bearing: null, mode: 'perspective'}
    };
    
    let markerAnimationState = {
        animationFrameId: null,
        currentLngLat: null,
        targetLngLat: null,
        currentIconRotation: 0,
        targetIconRotation: 0,
        currentMapBearing: 0,
        targetMapBearing: 0,
        lastTimestamp: null
    };

    let isMobileSession = false;
    let processedRemindersCache = [];
    let isCacheDirty = true;
    let lastMobileSyncCheck = 0;
    let deviationCheckIntervalId = null;

    let zoomToggleMemory = null;
    let locateMeReactivationTimer = null;
    let locateMeCountdownInterval = null;
    let deviationCheckGracePeriodUntil = 0; 
    let wasSimulatingBeforeRecalc = false;
    const MAP_VIEW_OFFSET_X_KEY = 'mapView_offsetX';
    const MAP_VIEW_OFFSET_Y_KEY = 'mapView_offsetY';
    const MAP_VIEW_SHOW_MINIMAP_KEY = 'mapView_showMinimap';
    let mapOffsetX = 0;
    let mapOffsetY = 30;
    let showMinimapPreference = true;
    const MAP_VIEW_PITCH_KEY = 'mapView_pitch';
    let mapPitchValue = 56;

  
    let lastGpsUpdateTime = 0;
    const maneuverTexts = { 'turn-sharp right': 'Giro brusco a la derecha', 'turn-right': 'Gira a la derecha', 'bear-right': 'Mantente a la derecha', 'turn-sharp left': 'Giro brusco a la izquierda', 'turn-left': 'Gira a la izquierda', 'bear-left': 'Mantente a la izquierda', 'turn-': 'Gira', 'straight-straight': 'Sigue recto', 'straight-': 'Sigue recto', 'roundabout-': 'Entra en la rotonda', 'roundabout turn-': 'Toma la salida de la rotonda', 'rotary-': 'Entra en la glorieta', 'roundabout turn-left': 'En la rotonda, toma la salida hacia la izquierda', 'roundabout turn-right': 'En la rotonda, toma la salida hacia la derecha', 'roundabout turn-straight': 'En la rotonda, sigue recto', 'destination-left': 'Has llegado a tu destino  (a la izquierda)', 'destination-right': 'Has llegado a tu destino (a la derecha)', 'destination-': ' tu destino ', 'depart-': 'Inicia la ruta', 'arrive-left': 'Has llegado a tu destino (a la izquierda)', 'arrive-right': 'Has llegado a tu destino  (a la derecha)', 'arrive-': 'Has llegado a tu destino', 'continue-straight': 'Contina recto', 'continue-': 'Contina', 'new name-': 'Contina por', 'fork-right': 'En la bifurcacin, mantente a la derecha', 'fork-left': 'En la bifurcacin, mantente a la izquierda', 'fork-': 'En la bifurcacin', 'merge-left': 'Incorprate por la izquierda', 'merge-right': 'Incorprate por la derecha', 'merge-straight': 'Incorprate', 'merge-': 'Incorprate', 'end of road-left': 'Al final de la va, gira a la izquierda', 'end of road-right': 'Al final de la va, gira a la derecha', 'end of road-': 'Fin de la va', 'u turn-left': 'Haz un cambio de sentido (hacia la izquierda)', 'u turn-right': 'Haz un cambio de sentido (hacia la derecha)', 'u turn-': 'Haz un cambio de sentido', 'use lane-': 'Usa el carril indicado', 'notification-': 'Atencin', 'exit roundabout-': 'Sal de la rotonda', 'exit rotary-': 'Sal de la glorieta', 'off ramp-': 'Va de salida', 'on ramp-': 'Incorporate a la va de Entrada',};
    let distanceToNextManeuverOSRM = Infinity;
    let mapHeaderButtonsVisible = true;
    
    const MAX_SESSIONS_KEY = 'boardinggate_max_map_sessions';
    let autoStartNavModalTimer = null;
    let mapSessionStartTime = null;
    let speedMarkerFeatures = []; 
    let mapPreviousZoomLevelForPDRs = 0;
    const AUTO_ZOOM_MODE_KEY = 'boardinggate_autoZoomMode_v2';
    let isAutoZoomActive = false;
    let isManualZoomActive = false;
    let manualZoomTimeout = null;
    let mapViewMode = 'perspective'; 
    let isSimulatingFreeDrive = false; 
    let isFreeDriveActive = false;
    let isFreeDrivePaused = false;
    let freeDriveStats = null;
    let locationsPreviewMapObjects = [];
    let lastDynamicRadarCheck = 0;
    let isGeolocated = false;
    window.radarsCache = null;
    window.radarsSpatialIndex = null;
    let isRadarCacheInitializing = false;
    let lastDisplayedManeuverIcon = null;
    let chatUpdateInterval = null;
    let selectedStageRoutes = new Map();
    let alternativeRoutesCache = new Map();
    let alternativeRouteLayers = [];
    let realtimeSpeedUpdateInterval = null;
    let tripInitialDurationSec = null;
    let tripInitialDistanceMeters = null;
    let mapHeaderAutohideTimer = null;
    let tripInitialOverallEtaTime = null;
    let currentStageInitialExpectedEtaTime = null;
    let accumulatedDeviationMs = 0;
    let minAverageSpeedInTrip = Infinity;
    let maxAverageSpeedInTrip = -Infinity;

    const OCM_API_KEY = "be9a78f7-0f5e-4f28-b742-4b7ab4b7eb5a";
    const MAPBOX_ACCESS_TOKEN = "pk.eyJ1IjoiYm9hcmRpbmdnYXRlMTEiLCJhIjoiY21kOHdtMGU4MDEzaTJpcGh4cng0c3hmMiJ9.hDdGn_5VOMkN_bTuUowtRw";
    let isGraphingActive = false;
    let pdrSearchState = 'initial'; 
    let lastPdrSearchResults = []; 
    let chargingPointsLayer = null;
    let currentChargingPointsOnRoute = [];
 
    let trafficAlertsCache = [];
    let trafficAlertsMarkers = []; 
    let lastAlertCheckTimestamp = 0;
    const ALERT_CHECK_INTERVAL = 15 * 60 * 1000;
    let currentlyDisplayedProximityAlerts = new Set();
    let alertModalTimer = null;
    let proximityAlertTimer = null;

    let tripStartLocationForStats = null; 
    let stageScrollTimeout;
    let locationsPreviewMap = null;
    let globalModalTimers = {};
    const originalBookmarks = [ { name: "YouTube", url: "https://www.youtube.com" }, { name: "Google", url: "https://www.google.com" }, { name: "GDrive", url: "https://drive.google.com", favicon: "./PNG/IMG_4172.png" }, { name: "GMail", url: "https://mail.google.com/mail/mu/mp/603/#tl/Recibidos", favicon: "./PNG/IMG_4171.png"}, { name: "Google Fotos", url: "https://photos.google.com" }, { name: "iCloud", url: "https://www.icloud.com/"}, { name: "ABRP", url: "https://abetterrouteplanner.com" }, { name: "ElectroMaps", url: "https://map.electromaps.com/es/", favicon: "https://www.google.com/s2/favicons?domain=electromaps.com&sz=64" }, { name: "REVE PdR Espaa", url: "https://www.mapareve.es/mapa-puntos-recarga", favicon: "https://www.google.com/s2/favicons?domain=mapareve.es&sz=64" }, { name: "Ver ubicaciones", url: "map-action:openRemindersMapWithNoRadars", favicon: "https://www.google.com/s2/favicons?domain=google.com/maps&sz=64" }, { name: "Google Maps", url: "https://www.google.com/maps/search/electric+vehicle+charging+stations" }, { name: "WhatsApp", url: "https://web.whatsapp.com/" }, { name: "TESSIE", url: "https://dash.tessie.com/signin", favicon: "https://www.google.com/s2/favicons?domain=tessie.com&sz=64" }, { name: "Mis Updates", url: "https://dash.tessie.com/software", favicon: "https://cdn-icons-png.flaticon.com/512/148/148767.png" }, { name: "Olas Updates", url: "https://es.stats.tessie.com/", favicon: "https://cdn-icons-png.flaticon.com/512/5815/5815902.png" }, { name: "NotaTeslaApp", url: "https://www.notateslaapp.com/software-updates/" }, { name: "ENHAUTO", url: "https://www.enhauto.com" }, { name: "MAREAS", url: "https://www.meteogalicia.gal/web/predicion/mareas-e-luas" }, { name: "ELECTROVERSE", url: "https://electroverse.com/es/map", favicon: "https://www.google.com/s2/favicons?domain=electroverse.com&sz=64" }, { name: "ACCIONA", url: "https://www.google.com/maps/search/recarga+Acciona", favicon: "https://www.google.com/s2/favicons?domain=acciona.com&sz=64" }, { name: "IBERDROLA", url: "https://www.google.com/maps/search/recarga+IBERDROLA", favicon: "https://www.google.com/s2/favicons?domain=iberdrola.com&sz=64" }, { name: "WAYLET Repsol", url: "https://www.google.com/maps/search/recarga+REPSOL+Waylet", favicon: "https://www.google.com/s2/favicons?domain=repsol.com&sz=64" }, { name: "ENDESA xWay", url: "https://www.google.com/maps/search/recarga+ENDESA+XWAY", favicon: "https://www.google.com/s2/favicons?domain=endesa.com&sz=64" }, { name: "ZUNDER", url: "https://www.google.com/maps/search/recarga+ZUNDER", favicon: "https://www.google.com/s2/favicons?domain=zunder.com&sz=64" }, { name: "IONITY", url: "https://www.google.com/maps/search/recarga+IONITY", favicon: "https://www.google.com/s2/favicons?domain=ionity.eu&sz=64" }, { name: "WENEA", url: "https://www.google.com/maps/search/recarga+WENEA", favicon: "https://www.google.com/s2/favicons?domain=wenea.com&sz=64" }, { name: "T.ENERGIES", url: "https://www.google.com/maps/search/recarga+TOTAL+ENERGIES", favicon: "https://www.google.com/s2/favicons?domain=totalenergies.com&sz=64" }, { name: "GALP", url: "https://www.google.com/maps/search/recarga+GALP", favicon: "https://www.google.com/s2/favicons?domain=galp.com&sz=64" }, { name: "MIIO", url: "https://miio.com", favicon: "https://www.google.com/s2/favicons?domain=miio.com&sz=64" }, { name: "EVDC", url: "https://evdc.network", favicon: "https://www.google.com/s2/favicons?domain=evdc.network&sz=64" }, { name: "GROK", url: "https://grok.com/?referrer=website" }, { name: "CHATGPT", url: "https://chat.openai.com" }, { name: "CLAUDE", url: "https://claude.ai/new" }, { name: "GEMINI", url: "https://gemini.google.com" }, { name: "NOTEBOOKLM", url: "https://notebooklm.google.com" }, { name: "Batera", url: "https://docs.google.com/spreadsheets/d/1bLZmgVGTBqg2bS2E45JpORjs9eK2nb05AWXYLLDY-RI/edit?gid=1398548891#gid=1398548891", favicon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='10'/><polyline points='12 6 12 12 16 14'/></svg>" }, { name: "TeslaParaTodos", url: "https://teslaparatodos.com/cine/" }, { name: "BetterTheater", url: "https://abettertheater.com", favicon: "https://www.google.com/s2/favicons?domain=abettertheater.com&sz=64" }, { name: "Filmin", url: "https://www.filmin.es/catalogo/peliculas" }, { name: "Octopus", url: "https://octopusenergy.es/login" }, { name: "App MCE", url: "https://www.oscarabilleira.com/app-mi-coche-electrico/#ayuda" }, { name: "Patrn Luz", url: "https://docs.google.com/spreadsheets/d/1R7UUZ9i4BAYWAGAX6PQT1WGd12GEZ4Ja/edit?usp=sharing&ouid=108345701896498198132&rtpof=true&sd=true" }, { name: "TradingView", url: "https://es.tradingview.com/chart/t5g9UFG0/" }, { name: "Telegram", url: "https://web.telegram.org/a/" }, { name: "Twitter", url: "https://x.com" }, { name: "Maesal Detailer", url: "https://www.maesaldetailer.es/" }, { name: "Superchargers", url: "https://www.tesla.com/es_es/findus?bounds=45.41107111786193%2C19.27853056943938%2C29.703668286784747%2C-16.64676239931062" }, { name: "TESLA web", url: "https://www.tesla.com/es_es" }, { name: "Manual M3", url: "https://www.tesla.com/ownersmanual/model3/es_es/" }, { name: "de Servicio", url: "https://service.tesla.com/docs/Model3/ServiceManual/2024/es-es/" }, { name: "de Despiece", url: "https://epc.tesla.com/es-MX/catalogs/e0e07c3d-272f-4d06-b8b6-9e92f857e5f3" }, { name: "de Usted Mismo", url: "https://www.tesla.com/es_es/support/do-it-yourself-guides" }, { name: "de Filtro Cabina", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-DB0A1E3C-926E-498C-A2FD-A27B8421A471.html" }, { name: "de Mvil remoto", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-53651B16-A2E3-4118-933E-B5F41C74D433.html" }, { name: "Waze (consultas)", url: "https://www.waze.com/es/live-map/", favicon: "https://www.google.com/s2/favicons?domain=waze.com&sz=64" }, { name: "AMAZON", url: "https://www.amazon.es" }, { name: "BIP&DRIVE", url: "https://areaprivada.bipdrive.com/login" }, { name: "ITV Cita", url: "https://www.sycitv.com/es/cita-previa-particulares/", favicon: "https://boardinggate.github.io/Tesla/PNG/itv.png" }, { name: "Deportes", url: "https://www.sofascore.com/es/tenis" }, null, { name: "Jaime Odena", url: "https://www.youtube.com/@Jaimeodena", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Eduardo Arcos", url: "https://www.youtube.com/@earcos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "AutoIngenium", url: "https://www.youtube.com/@AutoIngenium", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Gallego en Munich", url: "https://www.youtube.com/@ungallegoenmunich", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Electromiaumiau", url: "https://www.youtube.com/@electromiaumiau", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Manuel Martos", url: "https://www.youtube.com/@Manuel_Martos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Todos Electricos", url: "https://www.youtube.com/@TodosElectricos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Juan Vidal Haces", url: "https://www.youtube.com/@JuanVidalHaces", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Ruedana", url: "https://www.youtube.com/@ruedana", favicon: "https://www.youtube.com/favicon.ico" }, { name: "STR-600", url: "https://www.youtube.com/@STR-600", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Juanjo T. Aventuras", url: "https://www.youtube.com/@juanjoteslaventuras", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Carlos Cuezva", url: "https://www.youtube.com/@CarlosCuezva", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Javi Manzanoo", url: "https://www.youtube.com/@javimanzanoo", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Crifedi", url: "https://www.youtube.com/@Crifedi", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Tescno Tesla", url: "https://www.youtube.com/@TecnoTesla", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Full Electric Mex", url: "https://www.youtube.com/@FullElectricMexico", favicon: "https://www.youtube.com/favicon.ico" }, null, null, { name: "La iA Jon", url: "https://www.youtube.com/@la_inteligencia_artificial", favicon: "https://www.youtube.com/favicon.ico" }, { name: "JF Ccalero", url: "https://www.youtube.com/@jfcalero", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Visual Politik", url: "https://www.youtube.com/@VisualPolitik", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Fabian Barrio", url: "https://www.youtube.com/@fabiancbarrio", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Loquetudigas", url: "https://www.youtube.com/@Loquetudigas", favicon: "https://www.youtube.com/favicon.ico" }, { name: "David Antunes", url: "https://www.youtube.com/@davidantunesmusic", favicon: "https://www.youtube.com/favicon.ico" }, { name: "TheWildProject", url: "https://www.youtube.com/@TheWildProject", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Estas Tonne", url: "https://www.youtube.com/@Estastonne", favicon: "https://www.youtube.com/favicon.ico" }, { name: "BBC6 Music", url: "https://www.youtube.com/@BBC6Music", favicon: "https://www.youtube.com/favicon.ico" }, null, null ];
    const originalToggleRanges = [ { start: 18, end: 29, name: "ELECTROVERSE", label: "PdR,s" }, { start: 30, end: 41, name: "GROK", label: "iAs" }, { start: 42, end: 59, name: "TradingView", label: "til" }, { start: 60, end: 95, name: "Jaimeodena", label: "Varios" } ];
    const sectionColors = { 18: '#F0E0D3', 30: '#D8D4E0', 42: '#D9E5DB', 60: '#F2ECD0', unassigned: '#C5C8B8', off: '#ABAB99' };
    const darkModeGenericButtonColor = '#ABAB99';
    const DEFAULT_LOCATION_RADIUS = 450;
    let snoozedRouteRadars = new Map();
    const MAP_SEARCH_INPUT_KEY = 'boardinggate_map_search_value';
    let gpsRetryTimeoutId = null;
    let gpsRetryAttempt = 0;
    const MAX_GPS_RETRIES = 10;
    const GPS_RETRY_DELAY_MS = 5000;
    let isMapImmersiveModeActive = false;
    let isArrivalSequenceStarted = false;
    let maxSpeedCoordinates = null;
    let progressiveZoomState = 'none';
    let mapPreviousZoomLevelForProgressive = null;
    let lastProcessedStepIdentifier = null;
    const PROGRESSIVE_ZOOM_START_DISTANCE = 180;
    const PROGRESSIVE_ZOOM_PEAK_DISTANCE = 50;
    const PROGRESSIVE_ZOOM_EXIT_START_DISTANCE = 60;
    const PROGRESSIVE_ZOOM_EXIT_END_DISTANCE = 150;
    let isZoomedForManeuver = false;
    let isFlying = false;
    let navigationTargetZoom = null;
    let currentSmoothedMapCenter = null;
    let lastMobileSyncTimestamp = 0;
    const TOTAL_CELLS = 96; const COLS = 6; const grid = document.getElementById('bookmark-grid');
    let isDarkMode = false; let pressStartTime = null; let reminderPressStartTime = null; let isActive = true; let isFooterVisible = true; let notices = []; let currentNoticeIndex = 0; let fromReminderModal = false;
    let isEditMode = false; let isAssignmentMode = false;
    let isKeywordAssignmentMode = false;
    let currentlyAssigningToggleStart = null;
    let customData = { bookmarks: {}, toggles: {} };
    let cellElements = []; let toggleButtonElements = {}; let currentBookmarks = []; let currentToggleRanges = [];
    let onOffToggle, weatherButton, reminderButton, zoomButton, darkModeToggle, versionsButton, infoButton;
    let radarButton;
    let firstPersonalizationSession = !sessionStorage.getItem('personalizationHelpShown');
    let editingTargetElement = null; let draggedItem = null; let draggedItemIndex = null; let dragOverIndex = null;
    let touchStartX = 0; let touchStartY = 0; let currentTouchTarget = null;
    let isPasswordActive = false; let storedPin = null;
    let reminderCheckIntervalId = null;
    let currentCheckIntervalDuration = 3000;
    let lastUpdatesCheckDate = localStorage.getItem('lastUpdatesCheckDate');
    let currentNotificationSlideIndex = 0;
    let isUnifiedWindowVisibleByLogic = false;
    let reminderModalMap = null;
    let reminderMarker = null;
    let reminderCircle = null;
    let previewMaps = {};
    const MAX_SAVED_LOCATIONS = 15;
    const SAVED_LOCATIONS_KEY = 'boardinggate_saved_locations';
    const MAP_VIEW_MODE_KEY = 'mapViewMode_v1';
    const SHOW_EXCLUDED_REMINDERS_KEY = 'boardinggate_showExcludedRemindersInTable';
    const RADARES_RUTA_CHECKED_KEY = 'boardinggate_radaresRutaCheckboxChecked';
    const TAREAS_RUTA_CHECKED_KEY = 'boardinggate_tareasRutaCheckboxChecked';
    const ACTIVE_MAP_LAYER_KEY = 'boardinggate_activeMapLayer';
    const DIRECT_TO_NAVIGATION_KEY = 'boardinggate_directToNavigation';
    const MAP_ENTRY_OVERRIDE_KEY = 'boardinggate_map_entry_override';
    const TEMP_PREVENT_DIRECT_NAV_KEY = 'tempPreventDirectNavAfterMapExit';
    const GRAPH_STATE_KEY = 'boardinggate_graphState';
    let locationPickerMap = null;
    let locationPickerMarker = null;
    let currentEditingLocationSlotIndex = -1;
    let tempSavedLocations = [];
    let navigationMapInstance = null;
    let isNavigationMapActive = false;
    let initialUserLocationMarker = null;
    let initialUserLocationMarkerLat = null;
    let initialUserLocationMarkerLng = null;
    let navigationCurrentLocation = null;
    let locationWatchId = null;
    let shouldCenterOnUser = false;
    let navigationFollowUser = false;
    let mapPreviousZoomLevel = null;
    const MIN_MANEUVER_ZOOM_LEVEL = 17;
    let currentMapBearing = 0;
    let currentMapRotationAngle = 0;
    let currentMapCenterOffset = { x: 0, y: 0 };
    let targetMapCenterOffset = { x: 0, y: 0 };
    let mapOffsetAnimationId = null;
    let miniMapOffsetActive = { x: 0, y: 0 };
    let lastHeadingForTilt = 0;
    let compassAndModeControl = null;
    let navigationWaypoints = [];
    let navigationRouteLayer = null;
    let navigationCurrentRouteData = null;
    let isNavigating = false;
    let routeStartTime = null;
    let navigationStartTimeForStats = null;
    let totalDistanceTravelledForStats = 0;
    let accumulatedDistanceBeforeCurrentSegment = 0;
    let lastPositionForStats = null;
    let maxDistanceReachedOnRoute = 0; 
    let maxSpeedDuringTrip = 0;
    let maxAltitudeDuringTrip = -Infinity;
    let minAltitudeDuringTrip = Infinity;
    window.lastPositionForSpeedCalc = null;
    window.currentSpeedKmh = 0;
    window.averageSpeedKmh = 0;
    let isSimulatingGpsLocation = false;
    let simulatedGpsLocation = null;
    let automatedSimulationIntervalId = null;
    let simulatedDistanceAlongRoute = 0;
    let simulationSpeedKmph = 85;
    let currentSimulationSpeedKmph = 85; 
    const SIMULATION_TICK_INTERVAL_MS = 300;
    const AUTO_ZOOM_ACTIVE_KEY = 'boardinggate_autoZoomActive';
    let completedSegmentsGeoJSON = { type: 'FeatureCollection', features: [] }; 
    let maxSpeedMarkerObjects = []; 
    let speedMilestoneMarkerObjects = []; 
    let lastSpeedMilestone = 0;
    const SPEED_MILESTONES = [55, 65, 125, 135, 150];
    const OSRM_SERVICE_URL = 'https://router.project-osrm.org/route/v1';
    const SAVED_ROUTES_KEY = 'boardinggate_saved_routes';
    const MAX_SAVED_ROUTES = 100;
    let currentRouteNameForSaving = null;
    let navigationMapClickHandler = null;
    let draggedStageLi = null;
    const DEVIATION_THRESHOLD_METERS = 60;
    const DEVIATION_MIN_TIME_SECONDS = 0.3;
    let deviationStartTime = 0;
    let isRecalculatingRoute = false;
    let deviationModalTimerId = null;
    let isDeviationModalActive = false;
    const WAYPOINT_VISITED_THRESHOLD_METERS = 70;
    let currentLegIndexNav = 0;
    let currentStepIndexNav = 0;
    let lastCarDistanceAlongRouteForNavLogic = 0;
    let lastValidCarDistanceForDisplay = 0;
    let lastProcessedStepManeuverLocation = null;
    let recalculationRetryTimeoutId = null;
    let recalculationAttempts = 0;
    let isAddReminderAtLocationModeActive = false;
    let addReminderAtLocationButton = null;
    let simulationModalTimer = null;
    let autoStartNavTimer = null;
    let mapLayersControl = null;
    let searchToastShown = false;
    let pendingPositionToProcess = null;
    const KML_FILES_LIST_STANDARD = './KLM/KLMFILES.TXT';
    const KML_FILES_LIST_EXTRA = './KLM/KLMFILES2.TXT';
    const KML_BASE_PATH = './KLM/';
    const COORD_EPSILON = 0.00001;
    const RUTA_RADAR_PROXIMITY_THRESHOLD = 75;
    let reminderMapObjects = [];
    let radaresEnRutaActual = [];
    let tareasEnRutaActual = [];
    const STATIC_MODAL_IDS = ['config-modal', 'versions-modal-overlay', 'pin-modal-overlay', 'reorder-stages-modal', 'simulation-modal', 'locations-preview-modal', 'deviation-modal', 'arrival-stats-modal', 'simulation-speed-modal'];
    let activeToasts = [];
    let intersectionPreviewMap = null;
    let intersectionPreviewRouteLayer = null;
    let intersectionPreviewManeuverMarker = null;
    let intersectionPreviewCarMarker = null;
    let intersectionPreviewTimer = null;
    let lastAutoShownManeuverId = null;
    let directToNavOnLoad = false;
    let mapLayersControlLocationsPreview = null;
    let navigationChart = null;
    let currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviacin Ruta';
    let graphPlotState = { lastPlotTime: null, lastPlotCoords: null };
    let graphIntervalDuration = 0; 
    let graphIntervalTimer = null;
    let graphDataPoints = { speed: [], altitude: [] };
    let graphLabels = [];
    let graphExpectedAvgSpeed = 0;
    let isCarStoppedForGraph = false; 
    const GRAPH_PIXELS_PER_DATAPOINT = 2; 
    const GRAPH_BUFFER_PERCENTAGE = 0.15;
    const MAP_FILTER_INPUT_KEY = 'boardinggate_map_filter_value';
    const PROGRESS_BAR_LOCKED_KEY = 'boardinggate_progressBarLocked';
    let isProgressBarLocked = false;
    let progressBarForceShowUntil = 0;
    let lastProcessedStepForLock = null;
  
    const managedKeys = [ 'reminders','darkMode','toggleStates','zoomState','onOffState','noticesActive', 'footerVisible','teslaHtmlLastModified','teslaHtmlLastModifiedTimestamp', 'userData_userId','userData_teslaModel','userData_teslaYear','userData_teslaProvince', 'userData_allowDMs', 'customGridData', 'personalizationHelpShown', 'gridFilterValue',  'password_pin', 'password_active', 'lastUpdatesCheckDate', SAVED_LOCATIONS_KEY,  SHOW_EXCLUDED_REMINDERS_KEY, SAVED_ROUTES_KEY, RADARES_RUTA_CHECKED_KEY,  TAREAS_RUTA_CHECKED_KEY, ACTIVE_MAP_LAYER_KEY, DIRECT_TO_NAVIGATION_KEY, GRAPH_STATE_KEY, 'boardinggate_autoBackupOnLoad', 'userData_backupPassword', MAP_SEARCH_INPUT_KEY, 'mapViewMode_v1', MAP_FILTER_INPUT_KEY, PROGRESS_BAR_LOCKED_KEY,  MAP_VIEW_OFFSET_X_KEY,MAP_VIEW_OFFSET_Y_KEY,  MAP_VIEW_SHOW_MINIMAP_KEY, MAP_VIEW_PITCH_KEY  ];
    const managedDesc = managedKeys.map(k => {
            switch(k){
                case 'reminders':return 'Recordatorios'; case 'darkMode':return 'Modo Oscuro'; case 'toggleStates':return 'Visibilidad Secc.';
                case 'zoomState':return 'Zoom Grid'; case 'onOffState':return 'On/Off Gral'; case 'noticesActive':return 'Avisos/Footer';
                case 'footerVisible':return 'Vis. Footer'; case 'teslaHtmlLastModified':return 'Cache Versin'; case 'teslaHtmlLastModifiedTimestamp':return 'TS Cache';
                case 'userData_userId':return 'ID Usuario'; case 'userData_teslaModel':return 'Modelo'; case 'userData_teslaYear':return 'Ao';
                case 'userData_teslaProvince':return 'Provincia'; case 'userData_allowDMs':return 'Permitir DMs'; case 'customGridData': return 'Grid Pers.';
                case 'personalizationHelpShown': return 'Ayuda Pers. Vista'; case 'gridFilterValue': return 'Filtro Grid';
                case 'password_pin': return 'PIN Acceso'; case 'password_active': return 'PIN Activo'; case 'lastUpdatesCheckDate': return 'Cache Fecha Updates';
                case SAVED_LOCATIONS_KEY: return 'Ubicaciones Guardadas';
                case SHOW_EXCLUDED_REMINDERS_KEY: return 'Mostrar Excluidos Tabla';
                case SAVED_ROUTES_KEY: return 'Rutas Guardadas';
                case RADARES_RUTA_CHECKED_KEY: return 'Check Radares Ruta';
                case TAREAS_RUTA_CHECKED_KEY: return 'Check Tareas Ruta';
                case ACTIVE_MAP_LAYER_KEY: return 'Capa de Mapa Activa';
                case DIRECT_TO_NAVIGATION_KEY: return 'Directo a Navegacin';
                case GRAPH_STATE_KEY: return 'Estado Grfica';
                case MAP_SEARCH_INPUT_KEY: return 'Buscador Mapa (Principal)';
                case MAP_FILTER_INPUT_KEY: return 'Buscador Mapa (Filtro)';
                default:return k;
            }
        }).join(', ');

// ===================================================================
// NOMBRE: updateDynamicRadars (MODIFICADA - Lgica de Navegacin vs. Radio)
// RESUMEN: Carga radares dinmicos segn el contexto (en ruta o en radio).
async function updateDynamicRadars(isInitialLoadCheck = false) {
    const nowDate = new Date();
    const now = nowDate.getTime();
    const timeSinceLastCheck = now - lastDynamicRadarCheck;
    if (isInitialLoadCheck) {
        const hasExistingDynamicRadars = processedRemindersCache.some(r => r.isDynamicRadar === true);
        if (timeSinceLastCheck < 30 * 60 * 1000 && hasExistingDynamicRadars) return;
    }
    lastDynamicRadarCheck = now;
    if (!isInitialLoadCheck) showToast("Actualizando radares dinmicos...", "info", 3000, false, "radar-update");

    if (!window.radarsCache || !window.radarsSpatialIndex) {
        await initializeRadarCache();
        if (!window.radarsCache) {
            showToast("No se pudo inicializar la base de datos de radares.", "error");
            return;
        }
    }
    
    try {
        let newRadars = [];
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]').filter(r => !r.isDynamicRadar);
        
        const routeSource = navigationMapInstance?.getSource('route');
        if (routeSource && routeSource._data && routeSource._data.geometry && routeSource._data.geometry.coordinates.length > 1) {
            const originalCheckboxState = document.getElementById('radares-ruta-checkbox').checked;
            await toggleRadaresRuta(true); // Forzamos la carga de radares en ruta
            newRadars = [...radaresEnRutaActual];
            
            if (!originalCheckboxState) {
                document.getElementById('radares-ruta-checkbox').checked = false;
                eliminarRadaresDeRuta(); // Limpiamos los marcadores visuales si no se quieren ver
            }
        } else {
            let coords = null;
            if (navigationCurrentLocation && (Date.now() - lastGpsUpdateTime < 30000)) {
                coords = navigationCurrentLocation;
            } else {
                coords = await getCurrentLocationAsync();
            }
            if (!coords) throw new Error("Ubicacin del vehculo no disponible.");

            const DYNAMIC_RADAR_SEARCH_RADIUS_KM = 45;
            const candidateRadars = new Set();
            const R = 6371;
            const rad = DYNAMIC_RADAR_SEARCH_RADIUS_KM / R;
            const latRad = coords.latitude * Math.PI / 180;
            const GRID_SIZE = 0.1;

            const latMin = coords.latitude - (rad * 180 / Math.PI);
            const latMax = coords.latitude + (rad * 180 / Math.PI);
            const deltaLon = Math.asin(Math.sin(rad) / Math.cos(latRad));
            const lonMin = coords.longitude - (deltaLon * 180 / Math.PI);
            const lonMax = coords.longitude + (deltaLon * 180 / Math.PI);
            
            const latIndexMin = Math.floor(latMin / GRID_SIZE);
            const latIndexMax = Math.floor(latMax / GRID_SIZE);
            const lonIndexMin = Math.floor(lonMin / GRID_SIZE);
            const lonIndexMax = Math.floor(lonMax / GRID_SIZE);
            
            for (let i = latIndexMin; i <= latIndexMax; i++) {
                for (let j = lonIndexMin; j <= lonIndexMax; j++) {
                    const cellId = `cell_${i}_${j}`;
                    if (window.radarsSpatialIndex[cellId]) {
                        window.radarsSpatialIndex[cellId].forEach(radar => candidateRadars.add(radar));
                    }
                }
            }

            candidateRadars.forEach(radar => {
                const distance = calculateDistance(coords.latitude, coords.longitude, radar.lat, radar.lon);
                if (distance <= (DYNAMIC_RADAR_SEARCH_RADIUS_KM * 1000)) {
                    newRadars.push({
                        id: Date.now() + Math.random() + newRadars.length,
                        text: `<b>RADAR: ${radar.name}</b>`,
                        type: 'simple', time: '00:01',
                        date: `${nowDate.getFullYear()}-${(nowDate.getMonth() + 1).toString().padStart(2, '0')}-${nowDate.getDate().toString().padStart(2, '0')}`,
                        createdAt: nowDate.toISOString(), managedByUser: false,
                        isLocationEnabled: true, locationCoordinates: { latitude: radar.lat, longitude: radar.lon },
                        radiusMeters: 400, excludeFromList: true,
                        isDynamicRadar: true
                    });
                }
            });
        }
        
        reminders.push(...newRadars);
        localStorage.setItem('reminders', JSON.stringify(reminders));
        markRemindersCacheAsDirty();
        
        if (isNavigationMapActive) {
            plotRemindersOnNavigationMap();
        }
        updateReminderCount();
        updateButtonStyles();

    } catch (error) {
        showToast(`Error al actualizar radares: ${error.message}`, "error");
    }
}
// ===================================================================
// NOMBRE: toggleRadaresRuta (VERSIN FINAL ANTI-DUPLICADOS Y CON CONTEO COMPLETO)
// RESUMEN: Activa/desactiva la visualizacin de radares en la ruta, unificando dinmicos y manuales sin duplicados.
async function toggleRadaresRuta(activo) {
    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(activo));

    if (actualWaypoints.length < 2) {
        if (activo) showToast("Ruta invlida o inexistente. No se pueden buscar radares.", "warning");
        eliminarRadaresDeRuta();
        actualizarContadorRadares(0);
        return;
    }
    
    eliminarRadaresDeRuta();
    radaresEnRutaActual = [];

    if (activo && navigationMapInstance && navigationMapInstance.getSource('route') && navigationMapInstance.getSource('route')._data) {
        try {
            if (!window.radarsCache) await initializeRadarCache();
            if (!window.radarsCache) throw new Error("Base de datos de radares no disponible.");

            const routeLineString = turf.lineString(navigationMapInstance.getSource('route')._data.geometry.coordinates);
            
            // --- PASO 1: "Adoptar" todos los radares existentes en la cach que estn en la ruta ---
            processedRemindersCache.forEach(reminder => {
                const isRadarType = (reminder.text.toUpperCase().includes("RADAR") || reminder.excludeFromList);
                if (isRadarType && reminder.isLocationEnabled && reminder.locationCoordinates) {
                    const radarPoint = turf.point([reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]);
                    const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, radarPoint, { units: 'meters' });

                    if (nearestPointOnRoute.properties.dist <= RUTA_RADAR_PROXIMITY_THRESHOLD) {
                        radaresEnRutaActual.push({
                            ...reminder,
                            isFromRuta: true,
                            distanceOnRoute: nearestPointOnRoute.properties.location
                        });
                    }
                }
            });

            // --- PASO 2: Buscar nuevos radares KML que no estn ya en la cach ---
            const intersectingCells = new Set();
            const routeCoords = routeLineString.geometry.coordinates;
            for (let i = 0; i < routeCoords.length; i++) {
                intersectingCells.add(getGridCellId(routeCoords[i][1], routeCoords[i][0]));
            }
            const cellsToSearch = new Set(intersectingCells);
            intersectingCells.forEach(cellId => {
                const [_, latIdx, lonIdx] = cellId.split('_').map(Number);
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        cellsToSearch.add(`cell_${latIdx + i}_${lonIdx + j}`);
                    }
                }
            });

            const candidateRadars = [];
            cellsToSearch.forEach(cellId => {
                if (window.radarsSpatialIndex[cellId]) candidateRadars.push(...window.radarsSpatialIndex[cellId]);
            });
            const uniqueCandidates = [...new Set(candidateRadars)];
            
            let newRadarsAddedToLocalStorage = false;
            let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');

            uniqueCandidates.forEach(radar => {
                const radarPoint = turf.point([radar.lon, radar.lat]);
                const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, radarPoint, { units: 'meters' });

                if (nearestPointOnRoute.properties.dist <= RUTA_RADAR_PROXIMITY_THRESHOLD) {
                    const radarYaExisteEnCache = processedRemindersCache.some(rem => 
                        rem.isLocationEnabled && rem.locationCoordinates &&
                        Math.abs(rem.locationCoordinates.latitude - radar.lat) < COORD_EPSILON &&
                        Math.abs(rem.locationCoordinates.longitude - radar.lon) < COORD_EPSILON
                    );

                    if (!radarYaExisteEnCache) {
                        const now = new Date();
                        const dateStr = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
                        const timeStr = '00:00';
                        
                        // *** INICIO DE LA CORRECCIN: Calcular dueTimeUTC al crear ***
                        const dueTimeObject = new Date(`${dateStr}T${timeStr}:00Z`);
                        const dueTimeUTCValue = isNaN(dueTimeObject.getTime()) ? null : dueTimeObject.getTime();
                        // *** FIN DE LA CORRECCIN ***

                        const radarData = {
                            id: Date.now() + Math.random() + radaresEnRutaActual.length,
                            text: `<b>RADAR RUTA: ${radar.name}</b>`,
                            type: 'simple', time: timeStr,
                            date: dateStr,
                            createdAt: now.toISOString(),
                            managedByUser: false, isLocationEnabled: true,
                            locationCoordinates: { latitude: radar.lat, longitude: radar.lon },
                            radiusMeters: 350, excludeFromList: true,
                            isFromRuta: true,
                            isDynamicRadar: true,
                            distanceOnRoute: nearestPointOnRoute.properties.location,
                            dueTimeUTC: dueTimeUTCValue // <-- AADIR LA PROPIEDAD PRE-CALCULADA
                        };
                        
                        remindersFromStorage.push(radarData);
                        radaresEnRutaActual.push(radarData);
                        newRadarsAddedToLocalStorage = true;

                        const mapObject = plotSingleReminderOnMap(radarData, navigationMapInstance);
                        if (mapObject) reminderMapObjects.push(mapObject);
                    }
                }
            });

            if (newRadarsAddedToLocalStorage) {
                localStorage.setItem('reminders', JSON.stringify(remindersFromStorage));
                markRemindersCacheAsDirty();
            }

        } catch (error) {
            showToast(`Error al procesar radares en ruta: ${error.message}`, "error");
        }
    }

    actualizarContadorRadares(radaresEnRutaActual.length);
    if (navigationCurrentRouteData?.routes?.[0]) {
        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
    if (radaresRutaCheckbox) {
        radaresRutaCheckbox.checked = activo;
    }
}

// ===================================================================
// NOMBRE: checkReminders (VERSIN OPTIMIZADA FINAL)
// RESUMEN: Bucle optimizado que usa la cach, la ubicacin GPS existente y filtra por relevancia de ruta.
async function checkReminders() {
    const now = Date.now();

    // TAREA 1: Sincronizacin Mvil (optimizado)
    if (isMobileSession && (now - lastMobileSyncCheck > 6000)) {
        lastMobileSyncCheck = now;
        const { primaryId } = parseUserId(localStorage.getItem('userData_userId'));
        const autoSyncEnabled = JSON.parse(localStorage.getItem('boardinggate_autoBackupOnLoad') || 'false');
        const backupPassword = localStorage.getItem('userData_backupPassword');

        if (autoSyncEnabled && primaryId && backupPassword) {
            const localTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');
            if (localTimestamp > lastMobileSyncTimestamp) {
                autoSaveFromMobile(primaryId, backupPassword);
                lastMobileSyncTimestamp = localTimestamp;
            }
        }
    }

    // TAREA 2: Carga de Radares Dinmicos
    if (!isNavigating) {
        const timeSinceLastCheck = now - lastDynamicRadarCheck;
        const hasExistingDynamicRadars = processedRemindersCache.some(r => r.isDynamicRadar === true);
        if (timeSinceLastCheck > 30 * 60 * 1000 || !hasExistingDynamicRadars) {
            updateDynamicRadars(true);
        }
    }
    
    // TAREA 4: Gestin de la Cach
    if (isCacheDirty) {
        rebuildProcessedRemindersCache();
        // >>> CORRECCIN CLAVE! <<<
        // Forzamos la salida del bucle actual. La prxima ejecucin de checkReminders
        // (en el siguiente intervalo) ya trabajar con la cach limpia y actualizada.
        return; 
    }
    
    // TAREA 5: Bucle Principal de Comprobacin
    const overdueReminders = [];
    let coords = navigationCurrentLocation;

    if (!coords && (processedRemindersCache.some(r => r.isLocationEnabled) || !isNavigating)) {
        coords = await getCurrentLocationAsync().catch(() => null);
    }
    
    const nowTime = now;
    let isNearActiveLocationPoint = false; 
    let remindersToCheck = [];

    // --- LGICA DE FILTRADO UNIFICADA ---
    if (isNavigating) {
        remindersToCheck = [...tareasEnRutaActual, ...radaresEnRutaActual];
        processedRemindersCache.forEach(reminder => {
            if (!reminder.isLocationEnabled) {
                remindersToCheck.push(reminder);
            }
        });
        remindersToCheck = remindersToCheck.filter((r, index, self) => 
            index === self.findIndex(t => t.id === r.id)
        );
    } else {
        remindersToCheck = processedRemindersCache;
    }
    
    remindersToCheck.forEach(reminder => {
        if (!reminder) return;
        
        if (coords && reminder.isLocationEnabled && reminder.locationCoordinates) {
            const distance = calculateDistance(coords.latitude, coords.longitude, reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude);
            if (distance <= (reminder.radiusMeters || DEFAULT_LOCATION_RADIUS)) {
                isNearActiveLocationPoint = true;
            }
        }

        if (reminder.managedByUser) return;

        let isOverdue = false;
        let locationConditionMet = true;

        const dueTime = reminder.dueTimeUTC;

        if (dueTime && dueTime <= nowTime) {
            if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                if (coords) {
                    const distance = calculateDistance(coords.latitude, coords.longitude, reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude);
                    locationConditionMet = distance <= (reminder.radiusMeters || DEFAULT_LOCATION_RADIUS);
                } else {
                    locationConditionMet = false;
                }
            }
            if (locationConditionMet) {
                isOverdue = true;
            }
        }

        if (isOverdue && !overdueReminders.some(r => r.id === reminder.id)) {
            overdueReminders.push(reminder);
        }
    });
    
    if (overdueReminders.length > 0) {
        displayUnifiedReminderWindow(overdueReminders);
    } else if (isUnifiedWindowVisibleByLogic) {
        hideUnifiedReminderWindow();
    }

    // TAREA 6: Actualizar UI y ajustar intervalo
    updateReminderCount();
    updateButtonStyles();

     let newInterval;
    const speed = window.currentSpeedKmh || 0;
        if (isNearActiveLocationPoint) {
        newInterval = 1000;
    } else if (speed > 115) {
        newInterval = 4000;
    } else if (speed > 90) {
        newInterval = 5000;
    } else if (speed > 65) {
        newInterval = 6000;
    } else if (speed > 40) {
        newInterval = 8000;
    } else if (speed > 5) {
        newInterval = 10000;
    } else {
        newInterval = 13000;
    }

    if (newInterval !== currentCheckIntervalDuration) {
        currentCheckIntervalDuration = newInterval;
        if (reminderCheckIntervalId) clearInterval(reminderCheckIntervalId);
        reminderCheckIntervalId = setInterval(checkReminders, currentCheckIntervalDuration);
    }
}

// ===================================================================
// NOMBRE: toggleTareasRuta (VERSIN OPTIMIZADA Y CORREGIDA PARA MAPBOX)
// RESUMEN: Muestra tareas en la ruta. Optimizado para evitar recalculos innecesarios.
async function toggleTareasRuta(activo) {
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(activo));
    
    if (actualWaypoints.length < 2) {
        if (activo) {
            showToast("Ruta invlida o inexistente. No se pueden buscar tareas en ruta.", "warning");
        }
        eliminarTareasDeBarraProgreso();
        actualizarContadorTareas(0);
        return;
    }
    
    eliminarTareasDeBarraProgreso();
    tareasEnRutaActual = [];

    if (activo && navigationMapInstance) {
        const routeSource = navigationMapInstance.getSource('route');
        if (!routeSource || !routeSource._data || !routeSource._data.geometry || !routeSource._data.geometry.coordinates || routeSource._data.geometry.coordinates.length < 2) {
            if (activo) showToast("Geometra de ruta no disponible para buscar tareas.", "warning");
            actualizarContadorTareas(0);
            return;
        }

        try {
            const routeLineString = turf.lineString(routeSource._data.geometry.coordinates);
            const allReminders = JSON.parse(localStorage.getItem('reminders') || '[]');
            
            const locationReminders = allReminders.filter(r => {
                if (!r.isLocationEnabled || !r.locationCoordinates) {
                    return false; // Debe tener ubicacin
                }
                const isRadarType = r.text.toUpperCase().includes("RADAR") || r.excludeFromList;
                return !isRadarType;
            });
           
            locationReminders.forEach(reminder => {
                const taskPoint = turf.point([reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]);
                const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, taskPoint, { units: 'meters' });
                const radius = reminder.radiusMeters || DEFAULT_LOCATION_RADIUS;
                
                if (nearestPointOnRoute && nearestPointOnRoute.properties.dist !== undefined && nearestPointOnRoute.properties.dist <= radius) {
                    const taskData = {
                        ...reminder,
                        distanceOnRoute: nearestPointOnRoute.properties.location * 1000
                    };
                    tareasEnRutaActual.push(taskData);
                    
                    const isRadarTask = reminder.text.toUpperCase().includes("RADAR");
                    if (isRadarTask) {
                        const existingMapObject = reminderMapObjects.find(obj => obj.reminderId === reminder.id);
                        if (!existingMapObject) {
                           const mapObject = plotSingleReminderOnMap({...reminder, isFromTarea: true}, navigationMapInstance);
                           if (mapObject) reminderMapObjects.push(mapObject);
                        }
                    }
                }
            });
        } catch (error) {
             showToast("Error al procesar tareas en ruta: " + error.message, "error");
        }
    }

    actualizarContadorTareas(tareasEnRutaActual.length);
    if (navigationCurrentRouteData?.routes?.[0]) {
        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
    if (tareasRutaCheckbox) {
        tareasRutaCheckbox.checked = activo;
    }
}





    
    
    
// ===================================================================
// NOMBRE: markRemindersCacheAsDirty (NUEVA FUNCIN)
// RESUMEN: Marca la cach de recordatorios en memoria como "sucia" para forzar su reconstruccin.
function markRemindersCacheAsDirty() {
    isCacheDirty = true;
}

// ===================================================================
// NOMBRE: rebuildProcessedRemindersCache (NUEVA FUNCIN)
// RESUMEN: Procesa y cachea los recordatorios desde localStorage para optimizar las comprobaciones.
function rebuildProcessedRemindersCache() {
    try {
        const allReminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        const now = new Date();
        processedRemindersCache = allReminders.map(reminder => {
            let dueTimeUTC = null;
            if (reminder.date && reminder.time) {
                try {
                    const [year, month, day] = reminder.date.split('-').map(Number);
                    const [hour, minute] = reminder.time.split(':').map(Number);
                    
                    // --- INICIO DE LA CORRECCIN CLAVE: Usar fecha/hora local ---
                    // En lugar de Date.UTC, creamos la fecha directamente en la zona horaria del navegador.
                    // Esto asegura que "16:15" se interprete como "16:15" en tu hora local, no en UTC.
                    const dueDate = new Date(year, month - 1, day, hour, minute);
                    // --- FIN DE LA CORRECCIN CLAVE ---

                    if (!isNaN(dueDate.getTime())) {
                        dueTimeUTC = dueDate.getTime();
                    }
                } catch (e) {
                    // Ignorar fechas invlidas
                }
            }
            return { ...reminder, dueTimeUTC: dueTimeUTC };
        });
        isCacheDirty = false;
        console.log(`[CACHE] Cach de recordatorios reconstruida con ${processedRemindersCache.length} elementos.`);
    } catch (e) {
        console.error("Error al reconstruir la cach de recordatorios:", e);
        processedRemindersCache = [];
    }
}
// ===================================================================
// NOMBRE: startDeviationChecker (NUEVA FUNCIN)
// RESUMEN: Inicia un temporizador dedicado para la comprobacin de desvo de ruta.
function startDeviationChecker() {
    stopDeviationChecker(); // Asegura que no haya intervalos duplicados
    console.log("[DESVO] Iniciando comprobador de desvo cada 5 segundos.");
    deviationCheckIntervalId = setInterval(() => {
        if (!isNavigating || !navigationCurrentLocation || isRecalculatingRoute || isDeviationModalActive || isAddReminderAtLocationModeActive) {
            deviationStartTime = 0;
            return;
        }
        if (Date.now() < deviationCheckGracePeriodUntil) {
            return;
        }
        const currentCoords = navigationCurrentLocation;
        const routeSource = navigationMapInstance?.getSource('route');
        if (routeSource && routeSource._data && typeof turf !== 'undefined') {
            try {
                const routeGeoJSON = routeSource._data;
                const routeLineString = turf.lineString(routeGeoJSON.geometry.coordinates);
                const carPoint = turf.point([currentCoords.longitude, currentCoords.latitude]);
                const distanceToRoute = turf.pointToLineDistance(carPoint, routeLineString, { units: 'meters' });

                if (distanceToRoute > DEVIATION_THRESHOLD_METERS) {
                    if (deviationStartTime === 0) {
                        deviationStartTime = Date.now();
                    } else if ((Date.now() - deviationStartTime) / 1000 > DEVIATION_MIN_TIME_SECONDS) {
                        showDeviationModal();
                        deviationStartTime = 0;
                    }
                } else {
                    deviationStartTime = 0;
                }
            } catch (e) {
                // Error en turf, iniciar contador como fallback
                if (deviationStartTime === 0) deviationStartTime = Date.now();
                else if ((Date.now() - deviationStartTime) / 1000 > DEVIATION_MIN_TIME_SECONDS) {
                    showDeviationModal();
                    deviationStartTime = 0;
                }
            }
        }
    }, 5000); // Frecuencia de 5 segundos
}

// ===================================================================
// NOMBRE: stopDeviationChecker (NUEVA FUNCIN)
// RESUMEN: Detiene el temporizador de comprobacin de desvo.
function stopDeviationChecker() {
    if (deviationCheckIntervalId) {
        console.log("[DESVO] Deteniendo comprobador de desvo.");
        clearInterval(deviationCheckIntervalId);
        deviationCheckIntervalId = null;
        deviationStartTime = 0;
    }
}


// ===================================================================
// NOMBRE: toggleNavigationState (MODIFICADA - Inicia/Detiene el checker de desvo)
// RESUMEN: Inicia/detiene la navegacin y ahora tambin el comprobador de desvo.
async function toggleNavigationState(isRecalculationStop = false) {
    const startNavButton = document.getElementById('start-navigation-button');
    const startNavImg = startNavButton ? startNavButton.querySelector('img') : null;
    const mapContainer = document.getElementById('reminders-location-map-div');
    
    if (isNavigating) {
        if (isSimulatingGpsLocation) {
            stopAutomatedRouteSimulation();
        }
        if (!isRecalculationStop && !isArrivalSequenceStarted) {
            if (!document.getElementById('arrival-stats-modal') || document.getElementById('arrival-stats-modal').classList.contains('hidden')) {
                showArrivalStatsModal();
            }
        }
        isNavigating = false;
        navigationFollowUser = false;
        stopDeviationChecker(); // Detiene el comprobador de desvo
    } else if (isFreeDriveActive) {
        stopFreeDrive();
    } else {
        const hasEnoughWaypointsForRoute = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2;
        const hasRouteData = navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0];
        if (hasEnoughWaypointsForRoute && hasRouteData) {
            isArrivalSequenceStarted = false;
            hideAutoStartNavigationModal();
            clearAlternativeRoutesDisplay();
            clearSpeedMarkers();
            
            const waypointsForRecents = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
            await Promise.all(waypointsForRecents.map(async (wp) => {
                if (!wp.address) {
                    wp.address = await getAddressForWaypoint(wp.lat, wp.lng);
                }
            }));
            const lastWpForName = waypointsForRecents[waypointsForRecents.length - 1];
            const isMultiStageForName = waypointsForRecents.length > 2;
            const suggestedName = await getSuggestedRouteName(lastWpForName.lat, lastWpForName.lng, isMultiStageForName, waypointsForRecents.length);
            const routeForRecents = { name: currentRouteNameForSaving || suggestedName, waypoints: waypointsForRecents };
            addRouteToRecents(routeForRecents);
            clearNavigationGraph();
            navigationWaypoints.forEach(wp => { if(wp) { if (wp.type === 'S' || wp.type === 'S_Recalc') { wp.visited = true; } else { wp.visited = false; } if (wp.marker) wp.marker.setDraggable(false); } });
            
            getCurrentLocation(
                (initialCoords) => { navigationCurrentLocation = initialCoords; updateInitialUserPosition(initialCoords, navigationMapInstance); },
                (errorMsg) => { showToast(`No se pudo obtener tu ubicacin inicial: ${errorMsg}. El mapa se centrar cuando el GPS est listo.`, "warning", 5000); }
            );
            startGpsWatching();
            const loadingToast = document.getElementById("gps-init-toast"); if (loadingToast) loadingToast.remove(); activeToasts = activeToasts.filter(t => t.id !== "gps-init-toast");
            
            isNavigating = true;
            startDeviationChecker(); // Inicia el comprobador de desvo
            mapHeaderButtonsVisible = false;
            toggleMapHeaderRowsVisibility(false);
            
            const routeData = navigationCurrentRouteData.routes[0];
            if (routeData) {
                tripInitialDurationSec = routeData.duration;
                tripInitialDistanceMeters = routeData.distance;
                tripInitialOverallEtaTime = new Date(Date.now() + routeData.duration * 1000);
                if (routeData.legs && routeData.legs.length > 0) {
                    currentStageInitialExpectedEtaTime = new Date(Date.now() + routeData.legs[0].duration * 1000);
                }
            }
            tripStartLocationForStats = navigationCurrentLocation ? { ...navigationCurrentLocation } : null;
            navigationStartTimeForStats = null;
            totalDistanceTravelledForStats = 0;
            maxDistanceReachedOnRoute = 0;
            maxSpeedDuringTrip = 0;
            maxSpeedCoordinates = null;
            maxAltitudeDuringTrip = -Infinity;
            minAltitudeDuringTrip = Infinity;
            lastPositionForStats = navigationCurrentLocation ? {...navigationCurrentLocation} : null;
            accumulatedDeviationMs = 0;
            accumulatedDistanceBeforeCurrentSegment = 0;
            showToast("Navegacin iniciada. Esperando movimiento...", "success");
            currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviacin ETA';
            initializeNavigationGraph();
            const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox'); if (radaresRutaCheckbox && radaresRutaCheckbox.checked) { toggleRadaresRuta(true); }
            const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox'); if (tareasRutaCheckbox && tareasRutaCheckbox.checked) { toggleTareasRuta(true); }
            if (navigationMapInstance) {
                shouldCenterOnUser = true; 
                navigationFollowUser = true;
                const locateMeButton = document.getElementById('locate-me-on-reminders-map');
                if (locateMeButton) {
                    const locateMeImg = locateMeButton.querySelector('img');
                    if (locateMeImg) locateMeImg.src = "PNG/DEJARSEGUIR.PNG";
                    locateMeButton.title = "Dejar de centrar el mapa en mi posicin";
                }
                const startCoords = navigationCurrentLocation 
                    ? [navigationCurrentLocation.longitude, navigationCurrentLocation.latitude] 
                    : [navigationWaypoints[0].lng, navigationWaypoints[0].lat];
                const savedViewMode = localStorage.getItem(MAP_VIEW_MODE_KEY) || 'static';
                const modeDetails = MAP_VIEW_MODES[Object.keys(MAP_VIEW_MODES).find(key => MAP_VIEW_MODES[key].mode === savedViewMode)] || MAP_VIEW_MODES.NORTE;
                let pitchToUse = 0;
                if (modeDetails.mode === 'static') {
                    pitchToUse = 0; 
                } else {
                    pitchToUse = mapPitchValue; 
                }
                const initialFlyToOptions = { center: startCoords, zoom: 17.5, pitch: pitchToUse, essential: true, duration: 1500 };
                mapPreviousZoomLevel = null;
                if ((modeDetails.mode === 'heading' || modeDetails.mode === 'perspective') && navigationCurrentLocation && navigationCurrentLocation.heading !== null) {
                    initialFlyToOptions.bearing = navigationCurrentLocation.heading;
                } else {
                    initialFlyToOptions.bearing = modeDetails.bearing;
                }
                navigationMapInstance.flyTo(initialFlyToOptions);
            }
        } else {
            try {
                const initialCoords = await getCurrentLocationAsync();
                startFreeDrive(initialCoords);
            } catch (error) {
                showToast(`No se pudo obtener la ubicacin para iniciar el modo libre: ${error.message}`, "error");
            }
        }
    }
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    setNavigationMapClickHandler(); 
    actualizarContadorRadares(radaresEnRutaActual.length);
    actualizarContadorTareas(tareasEnRutaActual.length);
}

// ===================================================================
// NOMBRE: saveCustomData (MODIFICADA - Llama a la nueva funcin de cach)
// RESUMEN: Guarda la personalizacin y marca la cach de recordatorios como sucia.
function saveCustomData() {
    try {
        if (customData.bookmarks) {
            Object.keys(customData.bookmarks).forEach(indexKey => {
                const index = parseInt(indexKey);
                const custom = customData.bookmarks[index];
                const original = index < originalBookmarks.length ? originalBookmarks[index] : null;
                const bookmarksAreEqual = (b1, b2) => {
                    if (b1 === null && b2 === null) return true;
                    if (b1 === null || b2 === null) return false;
                    return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null);
                };
                if (bookmarksAreEqual(custom, original)) {
                    delete customData.bookmarks[index];
                }
            });
            if (Object.keys(customData.bookmarks).length === 0) {
                delete customData.bookmarks;
            }
        }
        if (customData.toggles) {
            Object.keys(customData.toggles).forEach(startKey => {
                const customToggle = customData.toggles[startKey];
                const originalRange = originalToggleRanges.find(r => r.start == startKey);
                if (customToggle && customToggle.assignedIndexes && originalRange) {
                    const originalDefaultIndexes = [];
                    for (let i = originalRange.start; i <= originalRange.end; i++) {
                        originalDefaultIndexes.push(i);
                    }
                    if (customToggle.assignedIndexes.length === originalDefaultIndexes.length &&
                        customToggle.assignedIndexes.every((val, idx) => val === originalDefaultIndexes[idx])) {
                        delete customToggle.assignedIndexes;
                    }
                }
                if (customToggle && originalRange && customToggle.label === originalRange.label) {
                    delete customToggle.label;
                }
                if (customData.toggles[startKey] && Object.keys(customData.toggles[startKey]).length === 0) {
                    delete customData.toggles[startKey];
                }
            });
            if (Object.keys(customData.toggles).length === 0) {
                delete customData.toggles;
            }
        }
        localStorage.setItem('customGridData', JSON.stringify(customData));
        markRemindersCacheAsDirty(); // <-- LNEA AADIDA
    } catch (e) {
        showToast("Error al guardar personalizacin", "error");
    }
}

// ===================================================================
// NOMBRE: showAllReminders (MODIFICADA - Llama a la nueva funcin de cach)
// RESUMEN: Muestra la tabla y marca la cach como sucia si se cambia el filtro de excluidos.
function showAllReminders(options = {}) {
     const mapWasOpenBeforeThisTable = isNavigationMapActive;
     if (mapWasOpenBeforeThisTable) {
         sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
         sessionStorage.setItem('mapContext', 'navigation');
     } else {
         sessionStorage.removeItem('boardinggate_map_was_open_before_table');
         sessionStorage.removeItem('mapContext');
     }
     closeOtherModals();
     let allReminders = []; try { allReminders = JSON.parse(localStorage.getItem('reminders') || '[]').map(r => ({ ...r })); } catch(e) { showToast("Error al cargar lista de recordatorios.", "error"); return; }
     const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false; let remindersToDisplay = allReminders;
     if (!showExcluded) { remindersToDisplay = allReminders.filter(r => !r.excludeFromList); }
     remindersToDisplay.sort((a, b) => {
         const nowForSort = new Date(); const nextA = calculateNextOccurrence(a, nowForSort); const nextB = calculateNextOccurrence(b, nowForSort);
         if (nextA && nextB) { const timeDiff = nextA.getTime() - nextB.getTime(); if (timeDiff !== 0) return timeDiff; } else if (nextA) { return -1; } else if (nextB) { return 1; }
         const typeOrder = { 'simple': 1, 'hourly': 2, 'daily': 3, 'weekly': 4, 'interval': 5 }; const typeDiff = (typeOrder[a.type] ?? 99) - (typeOrder[b.type] ?? 99); if (typeDiff !== 0) return typeDiff;
         const createdAtA = a.createdAt ? new Date(a.createdAt).getTime() : 0; const createdAtB = b.createdAt ? new Date(b.createdAt).getTime() : 0; return createdAtA - createdAtB;
     });
     const existingModal = document.querySelector('.reminder-table-modal');
     if (existingModal) { if (existingModal.autoCloseInterval) clearInterval(existingModal.autoCloseInterval); if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal); }
     const modalTable = document.createElement('div');
     modalTable.className = 'reminder-table-modal';
     modalTable.setAttribute('aria-label', 'Tabla recordatorios');
     modalTable.innerHTML = `
        <div class="reminder-table-header">
            <div class="reminder-table-top-controls">
                <div style="display: flex; align-items: center;">
                    <input type="checkbox" id="show-excluded-reminders" ${showExcluded ? 'checked' : ''} style="transform: scale(1.3);">
                    <label for="show-excluded-reminders" style="margin-left: 0.5rem; font-size: 1.1rem;">MOSTRAR RADARES u OTROS</label>
                </div>
                <div style="display: flex; align-items: center;">
                    <button type="button" id="view-all-locations-map">VER UBICACIONES</button>
                    <button type="button" id="close-reminders-top" style="margin-left:10px;">SALIR <span class="button-countdown"></span></button>
                </div>
            </div>
            <h2>Recordatorios</h2>
        </div>
        <div class="reminder-table-body-container">
            <table>
                <thead>
                    <tr>
                        <th style="width:12%;">Acciones</th> <th>Texto</th> <th style="width:8%;">Hora</th>
                        <th style="width:10%;">Fecha Prox.</th> <th style="width:15%;">Das Rep.</th>
                        <th style="width:8%;">Cada x das</th> <th style="width:8%;">Geoloc.</th>
                        <th style="width:10%;">Creado</th>
                    </tr>
                </thead>
                <tbody id="reminder-table-body">
                    ${remindersToDisplay.length === 0 ? `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios ${showExcluded ? ' (incluyendo excluidos)' : ''}.</td></tr>` : remindersToDisplay.map(r => { 
                        const isRadarOrExcluded = r.excludeFromList || r.text.toUpperCase().includes("RADAR");
                        const rowBackgroundColor = isRadarOrExcluded ? 'rgba(52, 199, 89, 0.15)' : 'rgba(88, 86, 214, 0.15)';
                        const nextOccurrenceDate = calculateNextOccurrence(r, new Date()); 
                        const formattedNextDate = nextOccurrenceDate ? formatDateToDDMMMYY(nextOccurrenceDate.toISOString().split('T')[0]) : formatDateToDDMMMYY(r.date); 
                        const timeDisplay = r.time ? r.time : '-'; 
                        const geoIndicator = r.isLocationEnabled ? '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#34c759" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>' : '-'; 
                        const isCyclic = r.type === 'weekly' || r.type === 'interval';
                        const cyclicStyle = isCyclic ? 'style="color: #ffd700; font-weight: bold;"' : '';
                        return `<tr data-id="${r.id}" style="background-color: ${rowBackgroundColor};"> <td> <button class="visto-prox" data-id="${r.id}" title="${isCyclic ? 'Marcar Visto y Avanzar al Prximo Ciclo' : 'Marcar Visto y Borrar'}">Visto/Prox</button> <button class="postpone" data-id="${r.id}" title="Posponer">Posponer</button> ${isCyclic ? `<button class="cancel-cyclic-table" data-id="${r.id}" title="Anular Ciclo Permanente">Anular Ciclo</button>` : ''} </td> <td class="text-column" title="Modificar">${r.text}</td> <td class="time-column">${timeDisplay}</td> <td class="date-column">${formattedNextDate}</td> <td ${cyclicStyle}>${r.type === 'weekly' && r.repeatDays?.length > 0 ? r.repeatDays.map(d => ['Dom','Lun','Mar','Mi','Jue','Vie','Sb'][d]).join(', ') : '-'}</td> <td ${cyclicStyle}>${r.type === 'interval' ? r.intervalDays || '-' : '-'}</td> <td>${geoIndicator}</td> <td class="date-column">${r.createdAt ? formatDateToDDMMMYY(r.createdAt.split('T')[0]) : '-'}</td> </tr>`; 
                    }).join('')}
                    </tbody>
                </table>
        </div>
        <div class="bottom-button-container" style="display:none;">
            <button type="button" id="close-reminders-bottom">SALIR <span class="button-countdown"></span></button>
        </div>
        `;
         const parent = document.body;
         parent.appendChild(modalTable);
         const showExcludedCheckbox = modalTable.querySelector('#show-excluded-reminders');
         if (showExcludedCheckbox) { 
             showExcludedCheckbox.addEventListener('change', () => { 
                 localStorage.setItem(SHOW_EXCLUDED_REMINDERS_KEY, JSON.stringify(showExcludedCheckbox.checked)); 
                 markRemindersCacheAsDirty();
                 if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval); 
                 modalTable.remove(); 
                 showAllReminders(); 
            }); 
        }
         const viewLocationsMapButton = modalTable.querySelector('#view-all-locations-map');
         if (viewLocationsMapButton) {
            viewLocationsMapButton.addEventListener('click', () => {
                if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                if (modalTable.parentNode) modalTable.remove();
                setTimeout(() => {
                    openLocationsPreviewMap();
                }, 50);
            });
        }
         let count = 60; const countdownSpans = modalTable.querySelectorAll('.button-countdown'); countdownSpans.forEach(span => span.textContent = `(${count})`);
         const closeClean = () => { clearInterval(modalTable.autoCloseInterval); modalTable.autoCloseInterval = null; if (modalTable.parentNode) modalTable.parentNode.removeChild(modalTable);
             const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true'; sessionStorage.removeItem('boardinggate_map_was_open_before_table');
             const mapContext = sessionStorage.getItem('mapContext'); sessionStorage.removeItem('mapContext');
             if (fromReminderModal) { fromReminderModal = false; if (mapShouldReopen) { sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true'); sessionStorage.setItem('mapContext', mapContext); } showReminderModal(); }
             else if (mapShouldReopen) { if (mapContext === 'navigation') openNavigationMap(); }
         };
         modalTable.autoCloseInterval = setInterval(() => { count--; countdownSpans.forEach(span => span.textContent = `(${count})`); if (count <= 0) { closeClean(); } }, 1000);
         const resetTimer = () => { if (!modalTable.autoCloseInterval) return; clearInterval(modalTable.autoCloseInterval); count = 60; countdownSpans.forEach(span => span.textContent = `(${count})`); modalTable.autoCloseInterval = setInterval(() => { count--; countdownSpans.forEach(span => span.textContent = `(${count})`); if (count <= 0) { closeClean(); } }, 1000); };
         modalTable.addEventListener('click', resetTimer); modalTable.addEventListener('touchstart', resetTimer, { passive: true }); modalTable.addEventListener('input', resetTimer);
         modalTable.querySelector('#close-reminders-top').addEventListener('click', closeClean);
         modalTable.querySelector('#close-reminders-bottom').addEventListener('click', closeClean);
         setupReminderTableListeners(modalTable);
}

// ===================================================================
// NOMBRE: setupReminderTableListeners (MODIFICADA - Llama a la nueva funcin de cach)
// RESUMEN: Aade listeners y marca la cach como sucia en cada modificacin.
function setupReminderTableListeners(modalTable) {
        modalTable.querySelectorAll('.visto-prox').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#EF4444';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #B91C1C';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true);
                let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderIndex = rems.findIndex(r => r.id === id);
                let needsSave = false;
                const row = newButton.closest('tr');
                if (reminderIndex > -1 && row) {
                     const currentReminder = rems[reminderIndex];
                     if (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval')) {
                        const { newDateISO, newTime } = calculatePostponedDateTime(15);
                        rems[reminderIndex].date = newDateISO;
                        rems[reminderIndex].time = newTime;
                        rems[reminderIndex].managedByUser = false;
                        needsSave = true;
                        const dateCell = row.cells[3]; const timeCell = row.cells[2];
                        if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date);
                        if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                        showToast('Recordatorio con ubicacin pospuesto 15 min', 'info');
                    } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                         let referenceDateForNext = new Date();
                         try {
                             const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                             const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                             const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                             if (!isNaN(reminderDateTime.getTime())) {
                                 referenceDateForNext = new Date(reminderDateTime.getTime() + 60000);
                             }
                         } catch(er) { }
                        const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                        if (nextOcc) {
                            rems[reminderIndex].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                            rems[reminderIndex].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                            rems[reminderIndex].managedByUser = false;
                            needsSave = true;
                            const dateCell = row.cells[3]; const timeCell = row.cells[2];
                            if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date);
                            if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                            showToast('Actualizado al prximo periodo', 'info');
                        } else {
                            rems.splice(reminderIndex, 1); needsSave = true;
                            row.remove(); showToast('Error calculando siguiente ciclo. Eliminado.', 'error');
                        }
                    } else {
                        rems.splice(reminderIndex, 1); needsSave = true;
                        row.remove(); showToast('Recordatorio borrado', 'info');
                    }
                    if (needsSave) {
                        localStorage.setItem('reminders', JSON.stringify(rems)); 
                        markRemindersCacheAsDirty();
                        if (isNavigationMapActive) { plotRemindersOnNavigationMap(); } // <-- CORRECCIN
                    }
                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios.</td></tr>`;
                    }
                } else {
                    showToast('Error: Recordatorio no encontrado para actualizar/borrar.', 'error');
                    if(row) row.remove();
                }
                updateReminderCount(); updateButtonStyles(); checkReminders();
            });
        });
        modalTable.querySelectorAll('.postpone').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#F59E0B';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #B45309';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true);
                const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderToPostpone = reminders.find(r => r.id === id);
                if (reminderToPostpone) {
                    if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                    modalTable.remove();
                    showPostponeOptionsModal(reminderToPostpone, 'table');
                } else {
                    showToast('Error: Recordatorio no encontrado para posponer.', 'error');
                    markReminderAsManaged(id, false);
                }
            });
        });
        modalTable.querySelectorAll('.cancel-cyclic-table').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#8B0000';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #580000';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                if (confirm('Ests seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE?')) {
                    markReminderAsManaged(id, true);
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const initialLength = rems.length;
                    rems = rems.filter(r => r.id !== id);
                    if (rems.length < initialLength) {
                       localStorage.setItem('reminders', JSON.stringify(rems)); 
                       markRemindersCacheAsDirty();
                       if (isNavigationMapActive) { plotRemindersOnNavigationMap(); } // <-- CORRECCIN
                       showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                    } else {
                        showToast('Error: No se encontr el ciclo para anular', 'warning');
                    }
                    const row = newButton.closest('tr');
                    if (row) row.remove();
                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios.</td></tr>`;
                    }
                    updateReminderCount(); updateButtonStyles(); checkReminders();
                }
            });
        });
        const tableBody = modalTable.querySelector('#reminder-table-body');
        if (tableBody) {
            const newTableBody = tableBody.cloneNode(false);
            while(tableBody.firstChild) newTableBody.appendChild(tableBody.firstChild);
            tableBody.parentNode.replaceChild(newTableBody, tableBody);
            newTableBody.addEventListener('click', (e) => {
                if (e.target.closest('td:first-child button')) return;
               const row = e.target.closest('tr[data-id]');
                if (row?.dataset.id) {
                    const id = parseInt(row.dataset.id); if (isNaN(id)) return;
                    markReminderAsManaged(id, true);
                    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const reminderToModify = reminders.find(r => r.id === id);
                    if (reminderToModify) {
                        const mapWasOpenBeforeTable = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                        const mapContextBeforeTable = sessionStorage.getItem('mapContext');
                        if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                        modalTable.remove();
                        if (mapWasOpenBeforeTable) {
                            sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                            if (mapContextBeforeTable) {
                                sessionStorage.setItem('mapContext', mapContextBeforeTable);
                            }
                        }
                        sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                        showReminderModal(reminderToModify);
                    } else {
                        showToast('Error: Recordatorio no encontrado para modificar', 'error');
                        markReminderAsManaged(id, false);
                    }
                }
            });
        }
}


// ===================================================================
// NOMBRE: showReminderModal (MODIFICADA - Llama a la nueva funcin de cach)
// RESUMEN: Muestra el modal de edicin/creacin y marca la cach como sucia al guardar/borrar.
function showReminderModal(reminder = null, options = {}) {
    const mapShouldReopenAfterForm = sessionStorage.getItem('boardinggate_map_should_reopen_after_form') === 'true';
    const mapContextBeforeThisModal = sessionStorage.getItem('mapContext');
    closeOtherModals();
    let autoSaveInterval = null; let parseTimeout = null; let restartTimeout = null; let focusTimeout = null; let countdownSave = 25; let manualTimeInput = false; let lastInputWasSpeech = false;
    let currentReminderLocation = null;
    let locationEnabledByUser = false;
    let mapExpandedManually = false;
    let mapMoveDebounceTimer = null;

    function cleanUpModalTimers(clearAll = true) {
        if (autoSaveInterval) { clearInterval(autoSaveInterval); autoSaveInterval = null; }
        if (clearAll) {
            if (parseTimeout) clearTimeout(parseTimeout);
            if (restartTimeout) clearTimeout(restartTimeout);
            if (focusTimeout) clearTimeout(focusTimeout);
            parseTimeout = null; restartTimeout = null; focusTimeout = null;
        }
    }

    const existingModal = document.querySelector('.reminder-modal');
    if (existingModal) {
        if (typeof existingModal.cleanUpModalTimers === 'function') existingModal.cleanUpModalTimers(true);
        if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal);
    }
    
    let isNew = true;
    let parsed = {
         id: null, text: '', time: null, date: null, repeatDays: [], intervalDays: null, type: 'simple',
         createdAt: new Date().toISOString(), managedByUser: false,
         isLocationEnabled: false, locationCoordinates: null, radiusMeters: DEFAULT_LOCATION_RADIUS,
         excludeFromList: false
    };
    if (reminder && typeof reminder.id === 'number' && reminder.id !== null) {
        const remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
        const foundReminder = remindersFromStorage.find(r => r.id === reminder.id);
        if (foundReminder) {
            parsed = { ...foundReminder };
            isNew = false;
        } else {
            parsed = { ...reminder, id: null, createdAt: new Date().toISOString(), managedByUser: false };
            isNew = true;
            if(reminder.text && reminder.text.toUpperCase().includes("RADAR RUTA:")) {
                 parsed.text = reminder.text.replace("RADAR RUTA:", "RADAR:");
                 parsed.excludeFromList = true;
                 parsed.radiusMeters = 350;
            }
        }
    } else if (reminder) {
        parsed = { ...reminder, id: null, createdAt: new Date().toISOString(), managedByUser: false };
        isNew = true;
         if(reminder.text && reminder.text.toUpperCase().includes("RADAR RUTA:")) {
            parsed.text = reminder.text.replace("RADAR RUTA:", "RADAR:");
            parsed.excludeFromList = true;
            parsed.radiusMeters = 350;
        }
    }
    if (!isNew && !parsed.createdAt) { parsed.createdAt = new Date(0).toISOString(); }
    locationEnabledByUser = parsed.isLocationEnabled;
    currentReminderLocation = parsed.locationCoordinates;
    let fmtDate = '';
    if (parsed.date?.match(/^\d{4}-\d{2}-\d{2}$/)) {
        try {
            const [y,m,d] = parsed.date.split('-');
            const dt=new Date(Date.UTC(y,m-1,d));
            if(!isNaN(dt.getTime())&&dt.getUTCDate()==d&&dt.getUTCMonth()==m-1) {
                fmtDate=`${d.toString().padStart(2,'0')}/${m.toString().padStart(2,'0')}/${y}`;
            }
        } catch(e){}
    }
    const modal = document.createElement('div');
    modal.className = 'reminder-modal';
    modal.setAttribute('aria-label','Formulario recordatorio');
    const titleText = isNew ? 'NUEVO RECORDATORIO' : 'MODIFICAR RECORDATORIO';
    modal.innerHTML = `
        <div class="reminder-modal-header">
            <h2 class="reminder-modal-title">${titleText}</h2>
             <div class="header-options">
                <label for="reminder-exclude-from-list" class="form-label-exclude">
                    <input type="checkbox" id="reminder-exclude-from-list" ${parsed.excludeFromList ? 'checked' : ''}>
                    <span>No listar (Radares, etc.)</span>
                </label>
            </div>
        </div>

        <div class="reminder-modal-body">
            <form id="reminder-form" class="reminder-modal-form">
                
                <div class="form-section">
                    <div class="input-with-buttons">
                        <div class="button-and-status-wrapper">
                            <button type="button" id="clear-fields" class="clear-button" title="Limpiar todo el formulario">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                            </button>
                            <p id="speech-status" class="speech-status"></p>
                            <p id="parse-status" class="parse-status"></p>
                        </div>
                        <textarea id="reminder-text" rows="2" required placeholder="Escriba o dicte aqu...">${parsed.text.replace(/<b>|<\/b>/gi,'')}</textarea>
                    </div>
                </div>
                
                <div class="form-section controls-grid">
                    <div class="control-item">
                        <label for="reminder-time" class="form-label">Hora:</label>
                        <input type="text" id="reminder-time" placeholder="HH:MM" pattern="\\d{2}:\\d{2}" value="${parsed.time||''}">
                    </div>
                    <div class="control-item">
                        <label for="reminder-date" class="form-label">Fecha:</label>
                        <input type="text" id="reminder-date" placeholder="DD/MM/AAAA" pattern="\\d{2}/\\d{2}/\\d{4}" value="${fmtDate}">
                    </div>
                    <div class="control-item">
                        <label for="reminder-interval" class="form-label">Int.(das):</label>
                        <input type="number" id="reminder-interval" min="1" max="9999" value="${parsed.intervalDays||''}">
                    </div>
                     <div class="control-item days-group-grid-item">
                         <label class="form-label">Das Repet.:</label>
                         <div class="days-checkbox-container">
                            ${['Lun','Mar','Mi','Jue','Vie','Sb','Dom'].map((d,i)=>`<label><input type="checkbox" name="repeat" value="${(i+1)%7}" ${parsed.repeatDays?.includes((i+1)%7)?'checked':''}><span>${d}</span></label>`).join('')}
                         </div>
                    </div>
                </div>

                <div class="form-section location-section">
                    <div class="location-header">
                        <label for="location-enabled" class="form-label-location">
                             <input type="checkbox" id="location-enabled" ${parsed.isLocationEnabled ? 'checked' : ''}>
                             <span>RECORDATORIO POR UBICACIN</span>
                        </label>
                         <div id="radius-slider-group" class="radius-slider-group">
                             <label id="radius-range-label" class="form-label">Radio: ${parsed.radiusMeters || 350}m</label>
                             <div class="slider-container single-slider-container">
                                 <div class="slider-track"></div>
                                 <div class="slider-range" id="radius-slider-range"></div>
                                 <div class="slider-thumb" id="radius-thumb"></div>
                             </div>
                         </div>
                        <button type="button" id="expand-map-button" class="expand-map-button">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
                            <span>MAPA</span>
                        </button>
                    </div>
                    <div id="location-controls-container" style="display: ${parsed.isLocationEnabled ? 'block' : 'none'};">
                         <div id="location-map-container" class="location-map-container">
                            <button type="button" id="reduce-map-button" class="hidden">REDUCIR</button>
                            <button type="button" id="locate-me-button" class="hidden">ESTS AQU</button>
                         </div>
                    </div>
                </div>
            </form>
        </div>

        <div class="reminder-modal-footer">
            <button type="submit" id="save-reminder" class="action-button primary">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13H7v8"></polyline><polyline points="7 3 7 8h10"></polyline></svg>
                <span>ACEPTAR</span>
                <span id="countdown-save">${countdownSave}</span>
            </button>
             <button type="button" id="cancel-reminder" class="action-button secondary">Cancelar</button>
             <button type="button" id="delete-reminder" title="Borrar este recordatorio permanentemente" class="action-button danger">Borrar</button>
             <button type="button" id="view-reminders" class="action-button secondary">Ver Lista</button>
             <button type="button" id="manage-saved-locations" class="action-button secondary">Ubicaciones</button>
             <button type="button" id="help-reminder" class="action-button secondary">Ayuda</button>
        </div>
    `;
    
    if (options.onTopOfMap) {
        const mapContainerEl = document.getElementById('reminders-location-map-modal');
        if (mapContainerEl) mapContainerEl.appendChild(modal);
        else document.body.appendChild(modal);
    } else {
        document.body.appendChild(modal);
    }

    modal.cleanUpModalTimers = cleanUpModalTimers;
    
    const mapContainer = modal.querySelector('#location-map-container');
    const reduceMapButton = modal.querySelector('#reduce-map-button');
    const locateMeButton = modal.querySelector('#locate-me-button');
    const expandMapButton = modal.querySelector('#expand-map-button');
    const locationCheckbox = modal.querySelector('#location-enabled');

    function destroyMap() {
        if (reminderModalMap) {
            try { reminderModalMap.remove(); } catch(e) {}
            reminderModalMap = null;
            reminderMarker = null;
        }
        if (mapContainer) {
            mapContainer.style.display = 'none';
            mapContainer.classList.remove('preview', 'expanded');
            const mapDiv = mapContainer.querySelector('#reminder-modal-map-div');
            if (mapDiv) mapDiv.remove();
        }
        if (reduceMapButton) reduceMapButton.classList.add('hidden');
        if (locateMeButton) locateMeButton.classList.add('hidden');
        if (expandMapButton) expandMapButton.style.display = 'block';
    }

    function initializeOrUpdateMap(centerCoords, radius, isInteractive = false) {
        destroyMap(); 

        const effectiveLocationEnabled = locationCheckbox.checked;
        const showMap = effectiveLocationEnabled || isInteractive;
        if (!showMap) return;

        mapContainer.style.display = 'block';
        mapContainer.classList.toggle('preview', !isInteractive && effectiveLocationEnabled && centerCoords);
        mapContainer.classList.toggle('expanded', isInteractive && effectiveLocationEnabled);
        
        expandMapButton.style.display = (isInteractive && effectiveLocationEnabled) ? 'none' : 'block';
        
        const effectiveCoords = centerCoords || { latitude: 40.416775, longitude: -3.703790 };
        const effectiveRadius = parseInt(radius) || DEFAULT_LOCATION_RADIUS;
        const zoomLevel = isInteractive ? 13 : 11;

        const mapDiv = document.createElement('div');
        mapDiv.id = 'reminder-modal-map-div';
        mapDiv.style.width = '100%'; mapDiv.style.height = '100%';
        mapContainer.insertBefore(mapDiv, reduceMapButton);

        reminderModalMap = new mapboxgl.Map({
            container: mapDiv,
            style: 'mapbox://styles/mapbox/satellite-streets-v12',
            center: [effectiveCoords.longitude, effectiveCoords.latitude],
            zoom: zoomLevel,
            interactive: isInteractive && effectiveLocationEnabled
        });
        
        reminderModalMap.on('load', () => {
            updateMarkerAndCircle(effectiveCoords, effectiveRadius);
            
            reminderModalMap.on('click', handleMapClick);
            
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    if (reminderModalMap) {
                        try { reminderModalMap.resize(); } catch (e) {}
                    }
                });
            });
        });
        
        if (reduceMapButton) reduceMapButton.classList.toggle('hidden', !(isInteractive && effectiveLocationEnabled));
        if (locateMeButton) locateMeButton.classList.toggle('hidden', !(isInteractive && effectiveLocationEnabled));
    }
    const parseStatus = modal.querySelector('#parse-status');
    const speechStatus = modal.querySelector('#speech-status');
    let countdownSaveElement = modal.querySelector('#countdown-save');
    const textInput = modal.querySelector('#reminder-text');
    const timeInput = modal.querySelector('#reminder-time');
    const dateInput = modal.querySelector('#reminder-date');
    const intervalInput = modal.querySelector('#reminder-interval');
    const saveButton = modal.querySelector('#save-reminder');
    const clearButton = modal.querySelector('#clear-fields');
    const locationControlsContainer = modal.querySelector('#location-controls-container');
    const manageLocationsBtn = modal.querySelector('#manage-saved-locations');
    const excludeFromListCheckbox = modal.querySelector('#reminder-exclude-from-list');
    const deleteButton = modal.querySelector('#delete-reminder');
    
    const radiusSliderGroup = modal.querySelector('#radius-slider-group');

    function toggleLocationControlsVisibility() {
        const isChecked = locationCheckbox.checked;
        if (locationControlsContainer) {
            locationControlsContainer.style.display = isChecked ? 'block' : 'none';
        }
        if (radiusSliderGroup) {
            radiusSliderGroup.style.display = isChecked ? 'flex' : 'none';
        }
        if(!isChecked) {
           destroyMap();
        }
    }
    
    locationCheckbox.addEventListener('change', toggleLocationControlsVisibility);
    toggleLocationControlsVisibility();

    const radiusSliderContainer = modal.querySelector('#radius-thumb')?.parentElement;
    const radiusThumb = modal.querySelector('#radius-thumb');
    const radiusRange = modal.querySelector('#radius-slider-range');
    const radiusLabel = modal.querySelector('#radius-range-label');
    const minRadius = 1;
    const maxRadius = 5000;
    let currentRadius = parsed.radiusMeters || 350;

    const updateRadiusVisuals = () => {
        if (!radiusThumb || !radiusRange || !radiusLabel) return;
        const minLog = Math.log(minRadius);
        const maxLog = Math.log(maxRadius);
        const percent = (Math.log(currentRadius) - minLog) / (maxLog - minLog);
        
        radiusThumb.style.left = `${percent * 100}%`;
        radiusRange.style.width = `${percent * 100}%`;
        radiusLabel.textContent = `Radio: ${Math.round(currentRadius)}m`;
    };

    if (radiusSliderContainer && radiusThumb) {
        const onRadiusDrag = (e) => {
            const rect = radiusSliderContainer.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let percent = ((clientX - rect.left) / rect.width);
            percent = Math.max(0, Math.min(1, percent));
            const minLog = Math.log(minRadius);
            const maxLog = Math.log(maxRadius);
            let rawRadius = Math.exp(minLog + percent * (maxLog - minLog));
            let step;
            if (rawRadius < 100) step = 5; 
            else if (rawRadius < 500) step = 25; 
            else step = 100;
            currentRadius = Math.round(rawRadius / step) * step;
            currentRadius = Math.max(minRadius, Math.min(maxRadius, currentRadius));
            updateRadiusVisuals();
            // *** INICIO DE LA CORRECCIN 1 ***
            if (reminderModalMap && currentReminderLocation) {
                 updateMarkerAndCircle(currentReminderLocation, Math.round(currentRadius));
            }
            // *** FIN DE LA CORRECCIN 1 ***
            resetAndStartCountdown();
        };
        const startRadiusDrag = (e) => {
            const moveHandler = (moveEvent) => onRadiusDrag(moveEvent);
            const endDrag = () => {
                document.removeEventListener('mousemove', moveHandler);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchmove', moveHandler);
                document.removeEventListener('touchend', endDrag);
            };
            document.addEventListener('mousemove', moveHandler);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchmove', moveHandler);
            document.addEventListener('touchend', endDrag);
        };
        radiusThumb.addEventListener('mousedown', startRadiusDrag);
        radiusThumb.addEventListener('touchstart', startRadiusDrag);
        updateRadiusVisuals();
    }
    
    function handleMapClick(e) {
        const lngLat = e.lngLat;
        currentReminderLocation = { latitude: lngLat.lat, longitude: lngLat.lng };
        updateMarkerAndCircle(currentReminderLocation, Math.round(currentRadius));
        resetAndStartCountdown();
    }
    
    function updateMarkerAndCircle(coords, radius) {
        if (!reminderModalMap || !coords) return;
        const lngLat = [coords.longitude, coords.latitude];
        
        if (!reminderMarker) {
            const vehicleEl = document.createElement('div');
            vehicleEl.innerHTML = `<div style="width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;"><img src="PNG/AVANCE.PNG" style="width: 100%; height: 100%; object-fit: contain;"></div>`;
            reminderMarker = new mapboxgl.Marker({ element: vehicleEl, draggable: true })
                .setLngLat(lngLat)
                .addTo(reminderModalMap);
            reminderMarker.on('dragend', handleMarkerDragEnd);
        } else {
            reminderMarker.setLngLat(lngLat);
        }
        
        const circleId = 'reminder-circle';
        const circlePolygon = turf.circle(lngLat, radius, { steps: 64, units: 'meters' });

        if (reminderModalMap.getSource(circleId)) {
            reminderModalMap.getSource(circleId).setData(circlePolygon);
        } else {
            reminderModalMap.addSource(circleId, { 'type': 'geojson', 'data': circlePolygon });
            
            const isRadarType = textInput.value.toUpperCase().includes("RADAR") || excludeFromListCheckbox.checked;
            
            // *** INICIO DE LA CORRECCIN 2 ***
            const circleFillColor = isRadarType ? 'rgba(255, 255, 0, 0.3)' : 'rgba(37, 99, 235, 0.3)';
            const circleStrokeColor = isRadarType ? '#FFD700' : '#2563EB';

            reminderModalMap.addLayer({
                'id': circleId,
                'type': 'fill',
                'source': circleId,
                'paint': {
                    'fill-color': circleFillColor,
                    'fill-outline-color': circleStrokeColor
                }
            });
            // *** FIN DE LA CORRECCIN 2 ***
        }
    }
    
    function handleMarkerDragEnd(event) {
        const lngLat = event.target.getLngLat();
        currentReminderLocation = { latitude: lngLat.lat, longitude: lngLat.lng };
        updateMarkerAndCircle(currentReminderLocation, Math.round(currentRadius));
        resetAndStartCountdown();
    }
    
    function handleLocationCheckboxChange() {
        const wasEnabled = locationEnabledByUser;
        locationEnabledByUser = locationCheckbox.checked;
        if (locationEnabledByUser) {
            if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && currentReminderLocation) {
                initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false);
            } else if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && !currentReminderLocation) {
                destroyMap();
            }
             if (!currentReminderLocation && !wasEnabled) {
                getCurrentLocation( (coords) => { currentReminderLocation = coords; if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && currentReminderLocation) { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false); } });
            }
        } else {
            destroyMap();
        }
        resetAndStartCountdown();
    }
    
    if (deleteButton) {
        deleteButton.addEventListener('click', () => {
            cleanUpModalTimers(true);
            const mapShouldReopen = mapShouldReopenAfterForm;
            const mapContextToReopen = mapContextBeforeThisModal;
            
            if (!isNew) {
                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const initialLength = reminders.length;
                reminders = reminders.filter(r => r.id !== parsed.id);
                if (reminders.length < initialLength) {
                    localStorage.setItem('reminders', JSON.stringify(reminders));
                    markRemindersCacheAsDirty();
                    if (isNavigationMapActive) {
                        plotRemindersOnNavigationMap(); // <-- CORRECCIN
                    }
                } else { 
                    showToast('Recordatorio no encontrado para borrar.', 'warning');
                }
            }

            destroyMap();
            if (modal.parentNode) modal.parentNode.removeChild(modal);
            updateReminderCount(); 
            updateButtonStyles(); 
            checkReminders();

            if (mapShouldReopen && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !isNavigationMapActive) {
                if (mapContextToReopen === 'navigation') openNavigationMap();
            } else if (mapShouldReopen) {
                 sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
                 if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen);
            }
            sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
        });
    }

    if (manageLocationsBtn) {
        manageLocationsBtn.addEventListener('click', () => {
            showSavedLocationsModal( () => { }, (selectedLocationData) => {
                    if (selectedLocationData && typeof selectedLocationData.lat === 'number' && typeof selectedLocationData.lng === 'number') {
                        currentReminderLocation = { latitude: selectedLocationData.lat, longitude: selectedLocationData.lng };
                        locationCheckbox.checked = true; locationEnabledByUser = true;
                        toggleLocationControlsVisibility();
                        currentRadius = typeof selectedLocationData.radius === 'number' && selectedLocationData.radius > 0 ? selectedLocationData.radius : DEFAULT_LOCATION_RADIUS;
                        updateRadiusVisuals();
                        if (mapContainer.classList.contains('expanded')) { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), true); } 
                        else { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false); }
                        showToast(`Ubicacin "${selectedLocationData.name || 'Seleccionada'}" aplicada.`, "success");
                        resetAndStartCountdown();
                    } else { showToast("Error: Datos de ubicacin seleccionada no vlidos.", "error"); }
                }, { parentContainer: modal } 
            );
        });
    }

    locationCheckbox.addEventListener('change', handleLocationCheckboxChange);
    if (parsed.isLocationEnabled && parsed.locationCoordinates) { initializeOrUpdateMap(parsed.locationCoordinates, parsed.radiusMeters, false); } 
    else if (parsed.isLocationEnabled && !parsed.locationCoordinates) { destroyMap(); } 
    else { destroyMap(); }

    if (expandMapButton) {
        expandMapButton.addEventListener('click', () => {
            if (!locationCheckbox.checked) { locationCheckbox.checked = true; toggleLocationControlsVisibility(); }
            locationEnabledByUser = true; mapExpandedManually = true;
            if (!currentReminderLocation) {
                locateMeButton.disabled = true; locateMeButton.textContent = 'Buscando...';
                getCurrentLocation(
                    (gpsCoords) => {
                        currentReminderLocation = { latitude: gpsCoords.latitude, longitude: gpsCoords.longitude };
                        initializeOrUpdateMap(gpsCoords, Math.round(currentRadius), true);
                        if (reminderModalMap) { reminderModalMap.flyTo({ zoom: 16 }); }
                        locateMeButton.disabled = false; locateMeButton.textContent = 'ESTS AQU';
                    }, (errorMsg) => {
                        initializeOrUpdateMap(null, Math.round(currentRadius), true);
                        if (reminderModalMap) { reminderModalMap.flyTo({ zoom: 6 }); }
                        showToast(`Error GPS: ${errorMsg}. Mapa centrado por defecto`, "warning", 3000);
                        locateMeButton.disabled = false; locateMeButton.textContent = 'ESTS AQU';
                    }
                );
            } else { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), true); }
            resetAndStartCountdown();
            setTimeout(() => { mapExpandedManually = false; }, 100);
        });
    }

    if (reduceMapButton) { reduceMapButton.addEventListener('click', () => { if (locationEnabledByUser && currentReminderLocation) { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false); } else { destroyMap(); } resetAndStartCountdown(); }); }
    if (locateMeButton) {
        locateMeButton.addEventListener('click', () => {
             if (!reminderModalMap || !mapContainer.classList.contains('expanded')) return;
             resetAndStartCountdown(); locateMeButton.disabled = true; locateMeButton.textContent = 'Buscando...';
             getCurrentLocation(
                 (coords) => {
                     currentReminderLocation = { latitude: coords.latitude, longitude: coords.longitude };
                     if (reminderModalMap) { reminderModalMap.flyTo({center: [coords.longitude, coords.latitude], zoom: 16}); updateMarkerAndCircle(coords, Math.round(currentRadius)); }
                     locateMeButton.disabled = false; locateMeButton.textContent = 'ESTS AQU';
                 }, (errorMsg) => { showToast(`Error al localizar: ${errorMsg}`, 'error'); locateMeButton.disabled = false; locateMeButton.textContent = 'ESTS AQU'; }
             );
        });
    }

    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) { } 
    else { speechStatus.textContent = 'Dictado no soportado.'; speechStatus.style.color = '#EF4444'; }

    function startCountdown() { autoSaveInterval = setInterval(() => { if (!document.body.contains(modal)) { clearInterval(autoSaveInterval); autoSaveInterval = null; return; } countdownSave--; if (countdownSaveElement) countdownSaveElement.textContent = countdownSave; if (countdownSave === 23) { if (document.activeElement === textInput) { textInput.value += ' '; textInput.selectionStart = textInput.selectionEnd = textInput.value.length; } } if (countdownSave <= 0) { clearInterval(autoSaveInterval); autoSaveInterval = null; if (saveButton) saveButton.click(); } }, 1000); }
    function resetAndStartCountdown() { countdownSave = 25; if (countdownSaveElement) countdownSaveElement.textContent = countdownSave; if (autoSaveInterval) { clearInterval(autoSaveInterval); autoSaveInterval = null; } startCountdown(); }
    
    timeInput.addEventListener('input', (e) => {
        manualTimeInput = true;
        let v = e.target.value.replace(/\D/g, '');
        let fV = '';
        if (v.length >= 2) fV = v.slice(0, 2);
        if (v.length > 2) fV += ':' + v.slice(2, 4);
        else if (v.length < 2) fV = v;
        e.target.value = fV;
        if (fV.match(/^\d{2}:\d{2}$/)) {
            const [h, m] = fV.split(':').map(Number);
            parseStatus.textContent = (h > 23 || m > 59) ? 'Hora invlida' : '';
            parseStatus.classList.toggle('text-red-600', h > 23 || m > 59);
            parseStatus.classList.remove('text-green-600');
        } else if (fV.length > 0) {
            parseStatus.textContent = 'Formato HH:MM';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        } else {
            parseStatus.textContent = '';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        }
        resetAndStartCountdown();
    });

    dateInput.addEventListener('input', (e) => {
        let v = e.target.value.replace(/\D/g, '');
        let fV = '';
        if (v.length >= 2) fV = v.slice(0, 2);
        if (v.length > 2) fV += '/' + v.slice(2, 4);
        if (v.length > 4) fV += '/' + v.slice(4, 8);
        else if (v.length < 2) fV = v;
        e.target.value = fV;
        if (fV.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
            const [d, m, y] = fV.split('/').map(Number);
            const dt = new Date(Date.UTC(y, m - 1, d));
            const ok = !isNaN(dt.getTime()) && dt.getUTCDate() === d && dt.getUTCMonth() + 1 === m && y >= 2000 && y <= 2099;
            parseStatus.textContent = ok ? '' : 'Fecha invlida';
            parseStatus.classList.toggle('text-red-600', !ok);
            parseStatus.classList.remove('text-green-600');
        } else if (fV.length > 0) {
            parseStatus.textContent = 'Formato DD/MM/AAAA';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        } else {
            parseStatus.textContent = '';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        }
        resetAndStartCountdown();
    });

    intervalInput.addEventListener('input', resetAndStartCountdown);
    modal.querySelectorAll('input[name="repeat"]').forEach(chk => chk.addEventListener('change', resetAndStartCountdown));
    
    if (countdownSaveElement) countdownSaveElement.textContent = countdownSave;

    function startFocusCheck() {
        if (restartTimeout) clearTimeout(restartTimeout);
        restartTimeout = setTimeout(() => {
            if (document.activeElement !== textInput && document.activeElement !== timeInput && document.activeElement !== dateInput && document.activeElement !== intervalInput && !Array.from(modal.querySelectorAll('input[name="repeat"]')).includes(document.activeElement) && document.activeElement !== saveButton && document.activeElement !== modal.querySelector('#cancel-reminder') && document.activeElement !== modal.querySelector('#help-reminder') && document.activeElement !== clearButton && document.activeElement !== modal.querySelector('#view-reminders') && document.activeElement !== locationCheckbox && document.activeElement !== radiusThumb && document.activeElement !== expandMapButton && document.activeElement !== reduceMapButton && document.activeElement !== locateMeButton && !(reminderModalMap && reminderModalMap.getCanvasContainer().contains(document.activeElement))) {
                resetAndStartCountdown();
                restartTimeout = null;
            } else {
                restartTimeout = null;
            }
        }, 500);
    }

    resetAndStartCountdown();
    startFocusCheck();
    modal.addEventListener('input', resetAndStartCountdown);
    modal.addEventListener('click', resetAndStartCountdown);
    modal.addEventListener('touchstart', resetAndStartCountdown, { passive: true });
    modal.addEventListener('focusin', () => {
        resetAndStartCountdown();
        if (focusTimeout) clearTimeout(focusTimeout);
        focusTimeout = null;
    });
    modal.addEventListener('focusout', () => {
        if (!focusTimeout) {
            startFocusCheck();
        }
    });

    textInput.addEventListener('input', (e) => {
        lastInputWasSpeech = false;
        const txt = e.target.value || '';
        parseStatus.textContent = 'Analizando...';
        parseStatus.classList.remove('text-green-600', 'text-red-600');
        if (parseTimeout) clearTimeout(parseTimeout);
        parseTimeout = setTimeout(() => {
            if (!document.body.contains(modal)) return;
            try {
                const uiElements = {
                    timeInput: timeInput,
                    dateInput: dateInput,
                    intervalInput: intervalInput,
                    repeatCheckboxes: modal.querySelectorAll('input[name="repeat"]'),
                    locationCheckbox: locationCheckbox,
                    radiusInput: null,
                    manualTimeInput: manualTimeInput,
                    mapExpandedManually: mapExpandedManually,
                    excludeFromListCheckbox: excludeFromListCheckbox
                };
                if (!manualTimeInput) uiElements.timeInput.value = '';
                uiElements.dateInput.value = '';
                uiElements.intervalInput.value = '';
                uiElements.repeatCheckboxes.forEach(chk => chk.checked = false);
                const pD = parseReminderText(txt, uiElements);
                
                if(pD.radiusMeters) {
                    currentRadius = pD.radiusMeters;
                    updateRadiusVisuals();
                }

                if (isNew && (pD.type === 'weekly' || pD.type === 'interval')) {
                    const tempReminderForCalc = { type: pD.type, time: pD.time, date: pD.date, repeatDays: pD.repeatDays, intervalDays: pD.intervalDays };
                    const nowForCalc = new Date();
                    if (!tempReminderForCalc.date) tempReminderForCalc.date = `${nowForCalc.getFullYear()}-${(nowForCalc.getMonth() + 1).toString().padStart(2, '0')}-${nowForCalc.getDate().toString().padStart(2, '0')}`;
                    if (!tempReminderForCalc.time) tempReminderForCalc.time = '00:01';
                    const firstOcc = calculateNextOccurrence(tempReminderForCalc, new Date());
                    if (firstOcc) {
                        const firstOccISO = `${firstOcc.getUTCFullYear()}-${(firstOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOcc.getUTCDate().toString().padStart(2, '0')}`;
                        const firstOccTime = `${firstOcc.getUTCHours().toString().padStart(2, '0')}:${firstOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                        pD.date = firstOccISO;
                        pD.time = firstOccTime;
                        const datePartsCalc = pD.date.split('-');
                        if (datePartsCalc.length === 3) dateInput.value = `${datePartsCalc[2]}/${datePartsCalc[1]}/${datePartsCalc[0]}`;
                        if (!manualTimeInput) timeInput.value = pD.time;
                    } else {
                        if (!pD.date) { const today = new Date(); pD.date = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}-${today.getDate().toString().padStart(2, '0')}`; }
                        if (!pD.time) pD.time = '00:01';
                        const datePartsFb = pD.date.split('-');
                        if (datePartsFb.length === 3) dateInput.value = `${datePartsFb[2]}/${datePartsFb[1]}/${datePartsFb[0]}`;
                        if (!manualTimeInput) timeInput.value = pD.time;
                    }
                }
                parseStatus.textContent = 'OK';
                parseStatus.classList.add('text-green-600');
                parseStatus.classList.remove('text-red-600');
                toggleLocationControlsVisibility();
                handleLocationCheckboxChange();
            } catch (error) {
                parseStatus.textContent = `Error: ${error.message.substring(0, 100)}`;
                parseStatus.classList.add('text-red-600');
                parseStatus.classList.remove('text-green-600');
            }
            parseTimeout = null;
        }, 1000);
        resetAndStartCountdown();
    });

    saveButton.addEventListener('click', (e) => {
        e.preventDefault();
        const form = modal.querySelector('#reminder-form');
        if (form.checkValidity && !form.checkValidity()) { form.reportValidity(); return; }
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        const mapContextToReopen = mapContextBeforeThisModal;
        const text = textInput.value.trim();
        if (!text) { parseStatus.textContent = 'Texto obligatorio.'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; }
        let time = timeInput.value.trim();
        let dateStr = dateInput.value.trim();
        const repeatDays = Array.from(modal.querySelectorAll('input[name="repeat"]:checked')).map(input => parseInt(input.value));
        const intervalDays = parseInt(intervalInput.value) || null;
        const isLocationChecked = locationCheckbox.checked;
        const radius = Math.round(currentRadius);
        const locationCoords = currentReminderLocation;
        const excludeFromListVal = excludeFromListCheckbox.checked;
        if (isLocationChecked && !locationCoords) { parseStatus.textContent = 'Ubicacin activada pero no fijada en el mapa.'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; }
        let dateISO = null; let finalTime = time; let reminderType = 'simple';
        if (dateStr) { if (dateStr.match(/^\d{2}\/\d{2}\/\d{4}$/)) { const [d, m, y] = dateStr.split('/').map(Number); const tD = new Date(Date.UTC(y, m - 1, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() + 1 === m && y >= 2000 && y <= 2099) { dateISO = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } else { parseStatus.textContent = 'Fecha invlida'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } } else { parseStatus.textContent = 'Formato DD/MM/AAAA'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } }
        if (finalTime && !finalTime.match(/^\d{2}:\d{2}$/)) { parseStatus.textContent = 'Formato HH:MM'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } else if (finalTime) { const [h, m] = finalTime.split(':').map(Number); if (h > 23 || m > 59) { parseStatus.textContent = 'Hora invlida'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } }
        if (intervalDays !== null && intervalDays > 0) { reminderType = 'interval'; if (!dateISO) { const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } if (!finalTime) finalTime = '00:01'; } 
        else if (repeatDays.length > 0) { reminderType = 'weekly'; if (!dateISO) { const tempCalc = { type: 'weekly', time: finalTime || '00:01', date: null, repeatDays: repeatDays, intervalDays: null }; const firstOcc = calculateNextOccurrence(tempCalc, new Date()); if (firstOcc) { dateISO = `${firstOcc.getUTCFullYear()}-${(firstOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOcc.getUTCDate().toString().padStart(2, '0')}`; finalTime = finalTime || `${firstOcc.getUTCHours().toString().padStart(2, '0')}:${firstOcc.getUTCMinutes().toString().padStart(2, '0')}`; } else { const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; if (!finalTime) finalTime = '00:01'; } } else { if (!finalTime) finalTime = '00:01'; } } 
        else if (dateISO && finalTime) { reminderType = 'daily'; } else if (finalTime) { reminderType = 'daily'; const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (dateISO) { reminderType = 'daily'; finalTime = '00:01'; } 
        else { reminderType = 'simple'; const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; finalTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`; }
        const now = new Date(); const finalCreatedAt = isNew ? now.toISOString() : (parsed.createdAt || now.toISOString()); let finalDateISO = dateISO;
        if (isNew && (reminderType === 'weekly' || reminderType === 'interval')) { let needsRecalc = false; if (!dateInput.value.trim()) { needsRecalc = true; } else { try { const [d, m, y] = dateStr.split('/').map(Number); const inputDate = new Date(Date.UTC(y, m - 1, d)); const todayForCompare = new Date(now.getFullYear(), now.getMonth(), now.getDate()); if (inputDate < todayForCompare) { needsRecalc = true; } } catch (e) { needsRecalc = true; } } if (needsRecalc) { const tempCalcForNewCyclic = { type: reminderType, time: finalTime || '00:01', date: null, repeatDays: reminderType === 'weekly' ? repeatDays : [], intervalDays: reminderType === 'interval' ? intervalDays : null }; const firstOccurrence = calculateNextOccurrence(tempCalcForNewCyclic, new Date()); if (firstOccurrence) { finalDateISO = `${firstOccurrence.getUTCFullYear()}-${(firstOccurrence.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOccurrence.getUTCDate().toString().padStart(2, '0')}`; } else { if (!finalDateISO) { finalDateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } } } }
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        const newReminder = { id: isNew ? Date.now() : parsed.id, text: `<b>${text.toUpperCase()}</b>`, type: reminderType, time: finalTime || null, date: finalDateISO, repeatDays: reminderType === 'weekly' ? repeatDays : [], intervalDays: reminderType === 'interval' ? intervalDays : null, createdAt: finalCreatedAt, managedByUser: false, isLocationEnabled: isLocationChecked, locationCoordinates: isLocationChecked ? locationCoords : null, radiusMeters: isLocationChecked ? radius : (parsed.radiusMeters || (text.toUpperCase().startsWith("RADAR") ? 350 : DEFAULT_LOCATION_RADIUS)), excludeFromList: excludeFromListVal, isFromRuta: parsed.isFromRuta || false };
        if (!newReminder.date || !newReminder.time || !newReminder.createdAt) { showToast("Error GRAVE: Fechas/Hora invlidas al guardar", "error"); resetAndStartCountdown(); return; }
        if (options.onTopOfMap) { const mapObjectIndex = reminderMapObjects.findIndex(obj => obj.reminderId === newReminder.id); if (mapObjectIndex !== -1) { const { marker, circleId } = reminderMapObjects[mapObjectIndex]; if (marker) marker.remove(); if (circleId && navigationMapInstance.getLayer(circleId)) navigationMapInstance.removeLayer(circleId); if (circleId && navigationMapInstance.getSource(circleId)) navigationMapInstance.removeSource(circleId); reminderMapObjects.splice(mapObjectIndex, 1); } if(navigationMapInstance) { const newMapObject = plotSingleReminderOnMap(newReminder, navigationMapInstance); if(newMapObject) reminderMapObjects.push(newMapObject); } }
        if (!isNew) { const index = reminders.findIndex(r => r.id === parsed.id); if (index !== -1) { reminders[index] = newReminder; } else { newReminder.id = Date.now() + Math.random(); reminders.push(newReminder); } } else { reminders.push(newReminder); }
        localStorage.setItem('reminders', JSON.stringify(reminders)); 
        markRemindersCacheAsDirty();
        destroyMap();
        if (modal.parentNode) modal.parentNode.removeChild(modal);
        updateReminderCount(); updateButtonStyles(); checkReminders();
        if (!options.onTopOfMap) { const unifiedWindowIsVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible'); if (mapShouldReopen && !unifiedWindowIsVisible && !isNavigationMapActive) { if (mapContextToReopen === 'navigation') openNavigationMap(); } else if (mapShouldReopen && unifiedWindowIsVisible) { sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true'); if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen); } }
        sessionStorage.removeItem('boardinggate_map_should_reopen_after_form'); sessionStorage.removeItem('mapContext');
    });

    modal.querySelector('#cancel-reminder').addEventListener('click', () => {
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        const mapContextToReopen = mapContextBeforeThisModal;
        destroyMap();
        if (modal.parentNode) modal.parentNode.removeChild(modal);
        const unifiedWindowIsVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible');
        if (mapShouldReopen && !unifiedWindowIsVisible && !isNavigationMapActive) { if (mapContextToReopen === 'navigation') openNavigationMap(); }
        sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
        sessionStorage.removeItem('mapContext');
    });

    modal.querySelector('#help-reminder').addEventListener('click', () => { showHelpModal({ parentContainer: modal }); });

    clearButton.addEventListener('click', () => {
        textInput.value=''; timeInput.value=''; dateInput.value='';
        modal.querySelectorAll('input[name="repeat"]').forEach(i=>i.checked=false);
        intervalInput.value=''; locationCheckbox.checked = false; toggleLocationControlsVisibility();
        currentRadius = parsed.radiusMeters || DEFAULT_LOCATION_RADIUS; updateRadiusVisuals();
        currentReminderLocation = null; destroyMap();
        excludeFromListCheckbox.checked = false; parseStatus.textContent=''; speechStatus.textContent=''; manualTimeInput=false;
        resetAndStartCountdown(); textInput.focus();
    });

    modal.querySelector('#view-reminders').addEventListener('click', () => {
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        const mapContextToReopen = mapContextBeforeThisModal;
        destroyMap();
        if (modal.parentNode) modal.parentNode.removeChild(modal);
        fromReminderModal = true;
        if (mapShouldReopen) {
            sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
            if (mapContextToReopen) {
                sessionStorage.setItem('mapContext', mapContextToReopen);
            }
        }
        showAllReminders();
    });
    
    textInput.focus();
}

// ===================================================================
// NOMBRE: markReminderAsManaged (MODIFICADA - Llama a la nueva funcin de cach)
// RESUMEN: Marca un recordatorio como gestionado y marca la cach como sucia.
function markReminderAsManaged(reminderId, managedState = true) {
     if (typeof reminderId !== 'number') { return; } try { let reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); const index = reminders.findIndex(r => r.id === reminderId); if (index !== -1) { if (reminders[index].managedByUser !== managedState) { reminders[index].managedByUser = managedState; localStorage.setItem('reminders', JSON.stringify(reminders)); 
     markRemindersCacheAsDirty(); } } } catch (e) { }
}

    
// ===================================================================
// NOMBRE: addSlideButtonListeners (MODIFICADA - Llama a la nueva funcin de cach)
// RESUMEN: Aade listeners a los botones del slide y marca la cach como sucia en cada modificacin.
function addSlideButtonListeners(slideElement, reminder) {
        const reminderId = reminder.id;
        const cancelButton = slideElement.querySelector('.cancel');
        const adjustTimeButton = slideElement.querySelector('.adjust-time-0001');
        const cancelCyclicButton = slideElement.querySelector('.cancel-cyclic');
        const modifyButton = slideElement.querySelector('.modify');
        const postponeButton = slideElement.querySelector('.postpone');
        const routeRadarVistoButton = slideElement.querySelector('.route-radar-seen');
        const handleInteraction = (actionFn) => {
            markReminderAsManaged(reminderId, true);
            actionFn();
            updateUnifiedWindowUI(processedReminderId);
        };
        let processedReminderId = reminderId;
        if (routeRadarVistoButton) {
            routeRadarVistoButton.addEventListener('click', () => {
                const minutesToSnooze = 5;
                markReminderAsManaged(reminder.id, true);
                
                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const index = reminders.findIndex(r => r.id === reminder.id);

                if (index !== -1) {
                    const { newDateISO, newTime } = calculatePostponedDateTime(minutesToSnooze);
                    
                    // Actualizamos localStorage
                    reminders[index].date = newDateISO;
                    reminders[index].time = newTime;
                    reminders[index].managedByUser = false;
                    localStorage.setItem('reminders', JSON.stringify(reminders));
                    
                    // >>> INICIO DE LA CORRECCIN CLAVE <<<
                    // Buscamos el mismo radar en el array de ruta activo y lo actualizamos en memoria.
                    const radarEnRutaIndex = radaresEnRutaActual.findIndex(r => r.id === reminder.id);
                    if (radarEnRutaIndex !== -1) {
                        const newDueTime = new Date(`${newDateISO}T${newTime}:00Z`).getTime();
                        console.log(`[POSTPONE] Antes: Radar en ruta ID ${reminder.id}, Vence: ${new Date(radaresEnRutaActual[radarEnRutaIndex].dueTimeUTC).toLocaleTimeString()}`);
                        
                        radaresEnRutaActual[radarEnRutaIndex].date = newDateISO;
                        radaresEnRutaActual[radarEnRutaIndex].time = newTime;
                        radaresEnRutaActual[radarEnRutaIndex].dueTimeUTC = newDueTime; // Actualizacin crucial!
                        
                        console.log(`[POSTPONE] Despus: Radar en ruta ID ${reminder.id}, Vence AHORA: ${new Date(radaresEnRutaActual[radarEnRutaIndex].dueTimeUTC).toLocaleTimeString()}`);
                    }
                    // >>> FIN DE LA CORRECCIN CLAVE <<<

                    markRemindersCacheAsDirty();
                    showToast(`Radar pospuesto ${minutesToSnooze} minutos`, 'info');
                } else {
                    showToast("Error: No se pudo encontrar el radar para posponer.", "error");
                }
                
                updateUnifiedWindowUI(reminder.id);
            });
        }
        if (cancelButton) {
            cancelButton.addEventListener('click', () => { 
                if (reminder.isFromRuta === true) { 
                    showToast(`Radar en ruta "${reminder.text.replace(/<[^>]*>/g, '')}" marcado como visto para esta alerta.`, 'info');
                    updateUnifiedWindowUI(reminder.id); 
                    markReminderAsManaged(reminder.id, true); 
                } else { 
                    handleInteraction(() => { 
                        let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                        const index = rems.findIndex(r => r.id === processedReminderId); 
                        if (index === -1) {
                            showToast("Error: No se encontr el recordatorio en localStorage para actualizar.", "error");
                            return;
                        }
                        const currentReminder = rems[index];
                        let needsSave = false;
                        const isRadarTypeStored = currentReminder.text.toUpperCase().includes("RADAR") || currentReminder.excludeFromList;
                        if (isRadarTypeStored) { 
                           const minutesToPostponeRadar = 15;
                           const { newDateISO, newTime } = calculatePostponedDateTime(minutesToPostponeRadar);
                           rems[index].date = newDateISO;
                           rems[index].time = newTime;
                           rems[index].managedByUser = false;
                           needsSave = true;
                           showToast(`Radar guardado pospuesto ${minutesToPostponeRadar} minutos`, 'info');
                        } else if (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval')) {
                           const minutesToPostponeLocation = 15; 
                           const { newDateISO, newTime } = calculatePostponedDateTime(minutesToPostponeLocation);
                           rems[index].date = newDateISO;
                           rems[index].time = newTime;
                           rems[index].managedByUser = false;
                           needsSave = true;
                           showToast(`Recordatorio de ubicacin pospuesto ${minutesToPostponeLocation} minutos`, 'info');
                        } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                            let referenceDateForNext = new Date();
                            try {
                                const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                                const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                                const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                                if (!isNaN(reminderDateTime.getTime())) {
                                    referenceDateForNext = new Date(reminderDateTime.getTime() + 60000); 
                                }
                            } catch(er) {  }
                            const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                            if (nextOcc) {
                                rems[index].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                                rems[index].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                                rems[index].managedByUser = false;
                                needsSave = true;
                                showToast('Recordatorio actualizado al prximo ciclo', 'info');
                            } else {
                                rems.splice(index, 1); needsSave = true;
                                showToast('Error calculando siguiente ciclo. Recordatorio eliminado.', 'error');
                            }
                        } else {
                           rems.splice(index, 1);
                           needsSave = true;
                           showToast('Recordatorio inmediato marcado como visto y eliminado.', 'info');
                        }
                        if (needsSave) {
                            localStorage.setItem('reminders', JSON.stringify(rems));
                            markRemindersCacheAsDirty();
                        }
                    }); 
                } 
            });
        }
        if (adjustTimeButton) {
            adjustTimeButton.addEventListener('click', () => handleInteraction(() => {
                let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                const index = rems.findIndex(r => r.id === processedReminderId);
                if (index === -1) return;
                const currentReminder = rems[index];
                let needsSave = false;
                if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                     let referenceDateForNext = new Date();
                     try {
                         const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                         const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, 0, 1)); 
                         if (!isNaN(reminderDateTime.getTime())) {
                             referenceDateForNext = new Date(reminderDateTime.getTime() + 60000); 
                         }
                     } catch(e) {  }
                    const reminderForCalc = { ...currentReminder, time: '00:01' };
                    const nextOcc = calculateNextOccurrence(reminderForCalc, referenceDateForNext);
                    if (nextOcc) {
                        rems[index].date= `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                        rems[index].time = '00:01';
                        rems[index].managedByUser = false;
                        needsSave = true;
                        showToast('Recordatorio ajustado a 00:01 y actualizado', 'info');
                    } else {
                        rems.splice(index, 1); needsSave = true;
                        showToast('Error calculando siguiente ciclo (ajuste 00:01). Eliminado.', 'error');
                    }
                } else { 
                    rems.splice(index, 1); needsSave = true;
                    showToast('Recordatorio no cclico eliminado (accin "Ajustar 00:01")', 'info');
                }
                if (needsSave) {
                    localStorage.setItem('reminders', JSON.stringify(rems));
                    markRemindersCacheAsDirty();
                }
            }));
        }
        if (cancelCyclicButton) {
            cancelCyclicButton.addEventListener('click', () => handleInteraction(() => {
                if (confirm('Ests seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE?')) {
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const initialLength = rems.length;
                    rems = rems.filter(r => r.id !== processedReminderId);
                    if (rems.length < initialLength) {
                       localStorage.setItem('reminders', JSON.stringify(rems)); 
                       markRemindersCacheAsDirty();
                       showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                    } else {
                        showToast('Error: No se encontr el ciclo para anular.', 'warning');
                    }
                } else {
                    markReminderAsManaged(processedReminderId, false); 
                }
            }));
        }
        if (modifyButton) {
            modifyButton.addEventListener('click', () => {
                markReminderAsManaged(reminder.id, true);
                let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                let reminderToModify = remindersFromStorage.find(r => r.id === reminder.id);
                if (!reminderToModify && reminder.isFromRuta) {
                   reminderToModify = { ...reminder };
                   reminderToModify.isFromRuta = false;
                }
                const mapIsVisible = document.getElementById('reminders-location-map-modal') && !document.getElementById('reminders-location-map-modal').classList.contains('hidden');
                const mapShouldReopenWhenUnifiedCloses = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                const mapContextBeforeUnified = sessionStorage.getItem('mapContext');
                hideUnifiedReminderWindow();
                if (reminderToModify) {
                    if (mapShouldReopenWhenUnifiedCloses) {
                         sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                         if (mapContextBeforeUnified) {
                           sessionStorage.setItem('mapContext', mapContextBeforeUnified);
                         }
                    }
                    showReminderModal(reminderToModify, { onTopOfMap: mapIsVisible });
                }
                else {
                    showToast("Error: no se pudo encontrar el recordatorio para modificar.", "error");
                    updateUnifiedWindowUI(reminder.id);
                    if (mapShouldReopenWhenUnifiedCloses &&
                        sessionStorage.getItem('boardinggate_map_should_reopen_after_form') !== 'true' &&
                        !document.getElementById('reminders-location-map-modal')
                       ) {
                        if (mapContextBeforeUnified === 'navigation') openNavigationMap();
                         sessionStorage.removeItem('mapContext');
                    }
                }
                sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
            });
        }
        if (postponeButton) {
            postponeButton.addEventListener('click', () => {
                markReminderAsManaged(processedReminderId, true); 
                let reminderToPostpone;
                if (reminder.isFromRuta) {
                    showToast(`Radar en ruta "${reminder.text.replace(/<[^>]*>/g, '')}" marcado como visto (accin Posponer).`, 'info');
                    updateUnifiedWindowUI(reminder.id);
                    return; 
                } else {
                    let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                    reminderToPostpone = remindersFromStorage.find(r => r.id === processedReminderId);
                }
                if (reminderToPostpone) {
                    showPostponeOptionsModal(reminderToPostpone, 'unified');
                }
                else {
                    showToast("Error: no se pudo encontrar el recordatorio para posponer", "error");
                    updateUnifiedWindowUI(processedReminderId); 
                }
            });
        }
    }


    
    










    

    
// ===================================================================
// NOMBRE: checkAndIncrementPoiCount (VERSIN CORREGIDA PARA CLIENTE)
// RESUMEN: Verifica el lmite global y actualiza el contador del usuario
//          usando operaciones de lectura y escritura separadas.
// ===================================================================
async function checkAndIncrementPoiCount() {
    const { primaryId: userId } = parseUserId(localStorage.getItem('userData_userId'));
    if (!userId || !window.db) return false;

    const GLOBAL_POI_LIMIT = 7000;

    try {
        // 1. Obtener estadsticas globales para comprobar el lmite total
        const globalStats = await getGlobalPoiStats();
        if (globalStats.totalMonth >= GLOBAL_POI_LIMIT) {
            showToast("Servicio de POI temporalmente inactivo (lmite mensual alcanzado).", "warning");
            return false; // Bloquear si se ha alcanzado el lmite global
        }

        // 2. Si el lmite global est bien, proceder a actualizar el contador del usuario
        const userDocRef = window.doc(window.db, "user_data", userId);
        const userDocSnap = await window.getDoc(userDocRef);
        
        const now = new Date();
        const monthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        let dataToUpdate = {};

        if (!userDocSnap.exists()) {
            // Si el usuario no existe en la BD, se crea con el primer clic
            dataToUpdate = {
                poi_clicks_last_month: monthStr,
                poi_clicks_month: 1
            };
        } else {
            const userData = userDocSnap.data();
            let newMonthCount = 1;
            if (userData.poi_clicks_last_month === monthStr) {
                newMonthCount = (userData.poi_clicks_month || 0) + 1;
            }
            
            dataToUpdate = {
                poi_clicks_last_month: monthStr,
                poi_clicks_month: newMonthCount
            };
        }

        // Realizamos la escritura en la base de datos
        await window.setDoc(userDocRef, dataToUpdate, { merge: true });

        return true; // Permitir la llamada a la API

    } catch (error) {
        console.error("Error al verificar/incrementar el contador de POIs:", error);
        showToast("Error al verificar lmite de POIs. Intntalo de nuevo.", "error");
        return false; // Bloquear por seguridad en caso de error
    }
}    
// ===================================================================
// NOMBRE: createRadarSpeedIcon (VERSIN FINAL DE ESCALADO DIRECTO)
// RESUMEN: Crea un icono de radar que se escala correctamente de pequeo a grande al hacer zoom.
// ===================================================================
function createRadarSpeedIcon(speed, currentZoomLevel = null, isFromTarea = false) {
    const container = document.createElement('div');
    
    // UMBRALES DE ZOOM
    const ZOOM_PEQUENO = 11.5;  // Por debajo de este zoom, el tamao es mnimo
    const ZOOM_GRANDE = 16.5;   // Por encima de este zoom, el tamao es mximo

    // TAMAOS DEL ICONO EN PXELES
    const TAMANO_MINIMO = 18;
    const TAMANO_MAXIMO = 48; // Puedes ajustar este valor si lo quieres ms grande

    let finalSize = TAMANO_MINIMO;
    if (currentZoomLevel !== null) {
        if (currentZoomLevel <= ZOOM_PEQUENO) {
            finalSize = TAMANO_MINIMO;
        } else if (currentZoomLevel >= ZOOM_GRANDE) {
            finalSize = TAMANO_MAXIMO;
        } else {
            // Interpolar linealmente entre los dos umbrales
            const progress = (currentZoomLevel - ZOOM_PEQUENO) / (ZOOM_GRANDE - ZOOM_PEQUENO);
            finalSize = TAMANO_MINIMO + (TAMANO_MAXIMO - TAMANO_MINIMO) * progress;
        }
    }
    
    finalSize = Math.round(finalSize);
    const finalFontSize = Math.round(finalSize * 0.45);
    const finalBorderSize = Math.max(2, Math.round(finalSize * 0.07));

    const validSpeeds = [20, 30, 50, 60, 70, 80, 90, 100, 110, 120];
    const isStandardSpeed = speed !== null && validSpeeds.includes(speed);
    const borderColor = isFromTarea ? '#00FF00' : 'white';

    container.className = 'radar-speed-circle';
    container.style.width = `${finalSize}px`;
    container.style.height = `${finalSize}px`;
    container.style.fontSize = `${finalFontSize}px`;
    container.style.borderWidth = `${finalBorderSize}px`;
    container.style.borderColor = borderColor;
    
    if (isStandardSpeed) {
        container.textContent = speed;
    } else {
        const imageSize = Math.round(finalSize * 0.65);
        container.innerHTML = `<img src="PNG/RADARAQUI.PNG" alt="Radar" style="width:${imageSize}px; height:${imageSize}px; object-fit:contain;">`;
    }
    
    return container;
}

// ===================================================================
// NOMBRE: initializeLocationPickerMap (VERSIN OPTIMIZADA CON REUTILIZACIN)
// RESUMEN: Inicializa el mapa selector de ubicaciones una sola vez y lo reutiliza,
//          movindolo y actualizando su contenido segn sea necesario.
// ===================================================================
function initializeLocationPickerMap(mapContainerId, slotIndex) {
    const container = document.getElementById(mapContainerId);
    if (!container) return; // Salir si el contenedor no existe

    const initialLocation = tempSavedLocations[slotIndex] || {};
    const centerLat = initialLocation.lat || 40.416775;
    const centerLng = initialLocation.lng || -3.703790;
    const initialZoom = (initialLocation.lat && initialLocation.lng) ? 15 : 6;

    if (!locationPickerMap) {
        const mapGarage = document.getElementById('map-garage');
        const mapDiv = document.createElement('div');
        mapDiv.style.width = '100%';
        mapDiv.style.height = '100%';
        mapGarage.appendChild(mapDiv); // Lo guardamos en el "garaje"

        locationPickerMap = new mapboxgl.Map({
            container: mapDiv,
            style: 'mapbox://styles/mapbox/satellite-streets-v12',
            center: [centerLng, centerLat],
            zoom: initialZoom,
            interactive: true
        });

        locationPickerMap.on('load', () => {
            locationPickerMarker = new mapboxgl.Marker({ draggable: true })
                .setLngLat([centerLng, centerLat])
                .addTo(locationPickerMap);

            locationPickerMarker.on('dragend', (event) => {
                const activeSlotIndex = locationPickerMap.activeSlotIndex; // Usamos una propiedad personalizada
                if (typeof activeSlotIndex !== 'number') return;

                const pos = event.target.getLngLat();
                if (!tempSavedLocations[activeSlotIndex]) {
                    tempSavedLocations[activeSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
                }
                tempSavedLocations[activeSlotIndex].lat = pos.lat;
                tempSavedLocations[activeSlotIndex].lng = pos.lng;
            });

            // El listener de 'click' tambin necesita el slot activo.
            locationPickerMap.on('click', (e) => {
                const activeSlotIndex = locationPickerMap.activeSlotIndex;
                if (typeof activeSlotIndex !== 'number') return;
                handlePickerMapClick(e, activeSlotIndex);
            });
        });
    }

    const mapDiv = locationPickerMap.getContainer();
    container.insertBefore(mapDiv, container.firstChild); // Movemos el div del mapa al modal visible.

    locationPickerMap.activeSlotIndex = slotIndex;

    locationPickerMap.flyTo({
        center: [centerLng, centerLat],
        zoom: initialZoom,
        duration: 0 // Sin animacin para que sea instantneo
    });

    if (locationPickerMarker) {
        locationPickerMarker.setLngLat([centerLng, centerLat]);
    }

    setTimeout(() => {
        if (locationPickerMap) {
            try {
                locationPickerMap.resize();
            } catch(e) { console.error("Error al redimensionar mapa reutilizado:", e); }
        }
    }, 50);
}    
// ===================================================================
// NOMBRE: applyMapVisualSettings (NUEVA FUNCIN)
// RESUMEN: Carga los ajustes de saturacin y contraste del mapa desde localStorage y los aplica como variables CSS.
function applyMapVisualSettings() {
    const savedSaturation = localStorage.getItem('boardinggate_map_saturation') || '1.6';
    const savedContrast = localStorage.getItem('boardinggate_map_contrast') || '1.2';
    
    document.documentElement.style.setProperty('--map-saturation', savedSaturation);
    document.documentElement.style.setProperty('--map-contrast', savedContrast);
}
 
// ===================================================================
// NOMBRE: clearSpeedMarkers (NUEVA FUNCIN)
// RESUMEN: Limpia los marcadores de velocidad del mapa y reinicia las variables relacionadas.
function clearSpeedMarkers() {
    speedMarkerFeatures = [];
    lastSpeedMilestone = 0;
    if (navigationMapInstance && navigationMapInstance.getSource('speed-markers-source')) {
        navigationMapInstance.getSource('speed-markers-source').setData({
            type: 'FeatureCollection',
            features: []
        });
    }
} 

// ===================================================================
// NOMBRE: showReminderActionModal (NUEVA FUNCIN)
// RESUMEN: Muestra un modal personalizado para las acciones de un recordatorio/radar.
function showReminderActionModal(reminderId) {
    const rems = JSON.parse(localStorage.getItem('reminders') || '[]');
    const reminder = rems.find(r => r.id === reminderId);
    if (!reminder) return;

    const overlay = document.createElement('div');
    overlay.className = 'map-item-modal-overlay';

    overlay.innerHTML = `
        <div class="map-item-modal-content">
            <h3>${reminder.text.replace(/<b>|<\/b>/gi,'')}</h3>
            <hr>
            ${reminder.time ? `<p><strong>Hora:</strong> ${formatTimeWithPeriod(reminder.time)}</p>` : ''}
            ${reminder.date ? `<p><strong>Fecha:</strong> ${formatDateDetailed(reminder.date)}</p>` : ''}
            <p><strong>Radio:</strong> ${reminder.radiusMeters || DEFAULT_LOCATION_RADIUS}m</p>
            <div class="map-item-modal-buttons">
                <button id="modal-modify-btn" style="background-color: #10B981;">Modificar</button>
                <button id="modal-close-btn" style="background-color: #6c757d;">Cerrar</button>
            </div>
        </div>
    `;

    document.body.appendChild(overlay);

    const closeHandler = () => {
        if (overlay.parentNode) overlay.remove();
    };

    overlay.querySelector('#modal-close-btn').addEventListener('click', closeHandler);
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) closeHandler();
    });

    overlay.querySelector('#modal-modify-btn').addEventListener('click', () => {
        const mapContextBeforeModal = sessionStorage.getItem('mapContext');
        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
        if (mapContextBeforeModal) {
            sessionStorage.setItem('mapContext', mapContextBeforeModal);
        }
        showReminderModal(reminder, { onTopOfMap: true });
        closeHandler();
    });
}   
// ===================================================================
// NOMBRE: handleAutoZoom (MODIFICADA - USA ESTADO DE MODO)
// RESUMEN: Ajusta el zoom, pero solo si el modo 'auto' est activo.
function handleAutoZoom() {
    const currentAutoZoomMode = localStorage.getItem(AUTO_ZOOM_MODE_KEY) || 'off';
    if (currentAutoZoomMode !== 'auto' || isManualZoomActive || !(isNavigating || isFreeDriveActive) || !navigationMapInstance) return;

    if (isZoomedForManeuver) return;

    const speed = window.currentSpeedKmh || 0;
    let targetZoom;

    if (speed < 30) targetZoom = 19;
    else if (speed < 50) targetZoom = 18.5;
    else if (speed < 80) targetZoom = 18;
    else if (speed < 100) targetZoom = 17.5;
    else if (speed < 110) targetZoom = 17.1;
    else if (speed < 120) targetZoom = 16.6;
    else if (speed < 200) targetZoom = 16.3;
    else return; 

    if (Math.abs(navigationMapInstance.getZoom() - targetZoom) > 0.1) {
        navigationMapInstance.easeTo({ zoom: targetZoom, duration: 3000 });
    }
}
    
// ===================================================================
// NOMBRE: handleDragStartReorder
// RESUMEN: Inicia el arrastre de una etapa en la lista de reordenamiento.
function handleDragStartReorder(e) {
    draggedStageLi = e.target.closest('li');
    if (draggedStageLi) {
        setTimeout(() => {
            if(draggedStageLi) draggedStageLi.classList.add('dragging');
        }, 0);
    }
}
    
// ===================================================================
// NOMBRE: vehicleIconElement (const)
// RESUMEN: Define el elemento DOM del vehculo principal con un overlay para maniobras.
    const vehicleIconElement = document.createElement('div');
    vehicleIconElement.className = 'vehicle-icon-mapbox-container';
    vehicleIconElement.innerHTML = `<div class="vehicle-icon-wrapper"><img src="PNG/AVANCE.PNG" alt="Coche"><div class="vehicle-maneuver-overlay"></div></div>`;
        
// ===================================================================
// NOMBRE: vehicleIconMiniMap (const) - (ADAPTADO PARA LEAFLET)
// RESUMEN: Define el icono Leaflet para el vehculo en el minimapa.
    const vehicleIconMiniMap = L.divIcon({
        html: `<div class="vehicle-icon-minimap"><img src="PNG/AVANCE.PNG" alt="Coche Mini"><div class="vehicle-maneuver-overlay-minimap"></div></div>`,
        className: 'vehicle-icon-minimap-leaflet-container',
        iconSize: [48, 48],
        iconAnchor: [24, 24]
    });   

// ===================================================================
// NOMBRE: setupZoomButtons (NUEVA FUNCIN)
// RESUMEN: Inicializa la lgica y los eventos para los botones de zoom.
function setupZoomButtons() {
    const container = document.getElementById('zoom-button-container');
    const zoomInBtn = document.getElementById('zoom-in-button');
    const zoomOutBtn = document.getElementById('zoom-out-button');
    const levelDisplay = document.getElementById('zoom-level-display');
    if (!container || !zoomInBtn || !zoomOutBtn || !levelDisplay || !navigationMapInstance) return;

    const map = navigationMapInstance;

    const updateZoomDisplay = () => {
        levelDisplay.textContent = map.getZoom().toFixed(1);
    };

    map.on('zoom', updateZoomDisplay);
    updateZoomDisplay();

    const handleZoomClick = (zoomFunction) => {
        isManualZoomActive = true;
        if (manualZoomTimeout) {
            clearTimeout(manualZoomTimeout);
            manualZoomTimeout = null;
        }
        
        zoomFunction();

        manualZoomTimeout = setTimeout(() => {
            isManualZoomActive = false;
        }, 30000); 
    };

    zoomInBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        handleZoomClick(() => map.zoomIn());
    });

    zoomOutBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        handleZoomClick(() => map.zoomOut());
    });
}
// ===================================================================
// NOMBRE: startGpsWatching (VERSIN CORREGIDA Y DEFINITIVA 2)
// RESUMEN: Se aade la comprobacin `!isRouteCompleted` para evitar
//          que la navegacin se reinicie automticamente si la ruta ya ha finalizado.
function startGpsWatching() {
    if (gpsRetryTimeoutId) {
        clearTimeout(gpsRetryTimeoutId);
        gpsRetryTimeoutId = null;
    }
    if (locationWatchId !== null) {
        return;
    }
    if (!('geolocation' in navigator) || !('watchPosition' in navigator.geolocation)) {
        showToast("Geolocalizacin no soportada por este navegador.", "error", 5000);
        return;
    }
    if (gpsRetryAttempt >= MAX_GPS_RETRIES) {
        showToast("Error persistente: No se pudo conectar al GPS. Revisa la configuracin del dispositivo.", "error", 0, false, "gps-persistent-error");
        return;
    }
    gpsRetryAttempt++;
    
    if (gpsRetryAttempt > 3) {
        showToast(`Intentando conectar al GPS (Intento ${gpsRetryAttempt}/${MAX_GPS_RETRIES})...`, "info", GPS_RETRY_DELAY_MS, false, "gps-attempt-toast");
    }
    locationWatchId = navigator.geolocation.watchPosition(
        (position) => {
            if (isSimulatingGpsLocation) return;
            const attemptToast = document.getElementById("gps-attempt-toast");
            if (attemptToast) attemptToast.remove();
            activeToasts = activeToasts.filter(t => t.id !== "gps-attempt-toast");
            gpsRetryAttempt = 0;
            const persistentErrorToast = document.getElementById("gps-persistent-error");
            if (persistentErrorToast) persistentErrorToast.remove();
            const coordsForUpdate = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                heading: position.coords.heading,
                speed: position.coords.speed,
                altitude: position.coords.altitude
            };
            navigationCurrentLocation = coordsForUpdate;

            const hasPlottedRoute = navigationCurrentRouteData && navigationWaypoints.length >= 2;
            
            const lastWaypoint = hasPlottedRoute ? navigationWaypoints[navigationWaypoints.length - 1] : null;
            const isRouteCompleted = lastWaypoint && lastWaypoint.visited === true;

            if (!isNavigating && hasPlottedRoute && !isRouteCompleted) {
                const startPoint = navigationWaypoints[0];
                const distanceFromStart = calculateDistance(startPoint.lat, startPoint.lng, coordsForUpdate.latitude, coordsForUpdate.longitude);

                const START_TRIGGER_DISTANCE = 50;  
                const RELEVANCE_DISTANCE = 200; 

                if (distanceFromStart > START_TRIGGER_DISTANCE && distanceFromStart < RELEVANCE_DISTANCE) {
                    toggleNavigationState(); 
                    return;  }
            }
            
            const noRouteLoaded = !hasPlottedRoute;
            if (!isNavigating && !isFreeDriveActive && noRouteLoaded) {
                
                if (lastPositionForStats) {
                    const distanceMoved = calculateDistance(
                        lastPositionForStats.latitude, lastPositionForStats.longitude,
                        coordsForUpdate.latitude, coordsForUpdate.longitude
                    );
                    if (distanceMoved > 20) { 
                        startFreeDrive(coordsForUpdate); 
                        return; 
                    }
                }
                
                lastPositionForStats = { ...coordsForUpdate };
            }
          
            const isTripActive = isNavigating || isFreeDriveActive;
            if (isTripActive && lastPositionForStats) {
                const distanceMovedSinceLastPoint = calculateDistance(lastPositionForStats.latitude, lastPositionForStats.longitude, coordsForUpdate.latitude, coordsForUpdate.longitude);
                
                if (navigationStartTimeForStats === null && distanceMovedSinceLastPoint > 1) {
                    navigationStartTimeForStats = new Date();
                }

                if (navigationStartTimeForStats !== null) {
                    totalDistanceTravelledForStats += distanceMovedSinceLastPoint;
                    
                    const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000;
                    if (timeElapsedS > 0) {
                        window.averageSpeedKmh = (totalDistanceTravelledForStats / timeElapsedS) * 3.6;
                    }
                }
                lastPositionForStats = { ...coordsForUpdate };
            }

            updateInitialUserPosition(coordsForUpdate, navigationMapInstance);

            if (isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0] && coordsForUpdate) {
                const routeForDistCalc = navigationCurrentRouteData.routes[0];
                let carDistTurf = 0;
                if (navigationMapInstance.getSource('route') && navigationMapInstance.getSource('route')._data && typeof turf !== 'undefined') {
                    try {
                        const carPointTurf = turf.point([coordsForUpdate.longitude, coordsForUpdate.latitude]);
                        const routeGeoJSON = navigationMapInstance.getSource('route')._data;
                        const routeLineStringTurf = turf.lineString(routeGeoJSON.geometry.coordinates);
                        const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                        const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                        carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                    } catch (e) { }
                }
                const totalRouteLength = routeForDistCalc.distance;
                if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                    if (carDistTurf > lastCarDistanceAlongRouteForNavLogic - 100) {
                         lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                    }
                } else if (carDistTurf > totalRouteLength + 500) {
                    lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
                }

                checkAndMarkWaypointsAsVisited(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic, coordsForUpdate);
                renderWaypointMarkers();
                
                updateTurnByTurnDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                updateNavigationProgressDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
            } else if (isFreeDriveActive) {
                updateNavigationProgressDisplay(null, 0);
            }
        },
        (error) => {
            showToast(`Error GPS: ${error.message}`, "warning");
            if (locationWatchId !== null) {
                navigator.geolocation.clearWatch(locationWatchId);
                locationWatchId = null;
            }
            gpsRetryTimeoutId = setTimeout(startGpsWatching, GPS_RETRY_DELAY_MS);
        },
        { enableHighAccuracy: true, timeout: 15000, maximumAge: 2000, distanceFilter: 3 }
    );
}

// ===================================================================
// NOMBRE: processSimulatedGpsPosition (VERSIN FINAL CON LGICA DE ESTADSTICAS)
// RESUMEN: Procesa la posicin GPS simulada y actualiza el estado de la navegacin, incluyendo el inicio y la actualizacin de las estadsticas de viaje.
function processSimulatedGpsPosition(forceExactPosition = false) {
    if (!isSimulatingGpsLocation || !simulatedGpsLocation) return;
    navigationCurrentLocation = { ...simulatedGpsLocation };

    const isTripActive = isNavigating || isFreeDriveActive;
    if (isTripActive && lastPositionForStats) {
        const distanceMovedSinceLastPoint = calculateDistance(lastPositionForStats.latitude, lastPositionForStats.longitude, navigationCurrentLocation.latitude, navigationCurrentLocation.longitude);
        
        if (navigationStartTimeForStats === null && distanceMovedSinceLastPoint > 1) {
            navigationStartTimeForStats = new Date();
            showToast("Viaje simulado iniciado. Registrando estadsticas.", "success");
        }

        if (navigationStartTimeForStats !== null) {
            
            const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000;
            if (timeElapsedS > 0) {
                window.averageSpeedKmh = (totalDistanceTravelledForStats / timeElapsedS) * 3.6;
            }
        }
        lastPositionForStats = { ...navigationCurrentLocation };
    }

    updateInitialUserPosition(navigationCurrentLocation, navigationMapInstance);

    if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
        const route = navigationCurrentRouteData.routes[0];
        let carDistTurf = 0;
        const routeSource = navigationMapInstance.getSource('route');

        if (routeSource && routeSource._data && typeof turf !== 'undefined') {
            try {
                const carPointTurf = turf.point([simulatedGpsLocation.longitude, simulatedGpsLocation.latitude]);
                const routeGeoJSON = routeSource._data;
                const routeLineStringTurf = turf.lineString(routeGeoJSON.geometry.coordinates);
                let nearestPointOnLineTurf;
                if (forceExactPosition) {
                     nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                } else {
                    nearestPointOnLineTurf = carPointTurf;
                }
                const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
            } catch (turfError) {
                console.error("Error al calcular la distancia simulada en la ruta:", turfError);
            }
         }
        
        checkAndMarkWaypointsAsVisited(route, carDistTurf, simulatedGpsLocation);
        renderWaypointMarkers();

        lastCarDistanceAlongRouteForNavLogic = carDistTurf;
        updateTurnByTurnDisplay(route, carDistTurf);
        updateNavigationProgressDisplay(route, carDistTurf);
    }
    
    if (!automatedSimulationIntervalId) { 
        showToast(`Posicin GPS simulada: ${simulatedGpsLocation.latitude.toFixed(4)}, ${simulatedGpsLocation.longitude.toFixed(4)}`, "info");
    }
}

    
// NOMBRE: redrawAllHTMLMarkers (VERSIN FINAL Y CORRECTA)
// RESUMEN: Limpia y redibuja los marcadores de Etapas y Recordatorios/Radares.
// ===================================================================
function redrawAllHTMLMarkers() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
        return;
    }

    navigationWaypoints.forEach(wp => {
        if (wp && wp.marker) {
            wp.marker.remove();
            wp.marker = null;
        }
    });

    reminderMapObjects.forEach(obj => {
        if (obj.marker) obj.marker.remove();
    });
    reminderMapObjects = [];

    renderWaypointMarkers();
    plotRemindersOnNavigationMap();
}
 
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// NOMBRE: updateAllIconSizes (VERSIN FINAL CON LGICA DE RECREACIN)
// RESUMEN: Controlador central que decide CUNDO se deben redibujar los iconos.
function updateAllIconSizes() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
        return;
    }

    const currentZoomLevel = navigationMapInstance.getZoom();

    const ZOOM_LEJANO = 10;
    const ZOOM_MEDIO = 14;

    const getZoomRange = (zoom) => {
        if (zoom <= ZOOM_LEJANO) return 'lejano';
        if (zoom <= ZOOM_MEDIO) return 'medio';
        return 'cercano';
    };

    const currentRange = getZoomRange(currentZoomLevel);
    const previousRange = getZoomRange(mapPreviousZoomLevelForPDRs); // Reutilizamos la variable

    if (currentRange !== previousRange) {
        redrawAllHTMLMarkers();
    }

    const PDR_ZOOM_THRESHOLD = 14;
    const crossedThresholdUp = mapPreviousZoomLevelForPDRs <= PDR_ZOOM_THRESHOLD && currentZoomLevel > PDR_ZOOM_THRESHOLD;
    const crossedThresholdDown = mapPreviousZoomLevelForPDRs > PDR_ZOOM_THRESHOLD && currentZoomLevel <= PDR_ZOOM_THRESHOLD;

    if (crossedThresholdUp || crossedThresholdDown) {
        displayChargingPointsOnMap();
    }
    
    mapPreviousZoomLevelForPDRs = currentZoomLevel;
}

// ===================================================================
// NOMBRE: redrawReminderMapObjects (CORREGIDA Y RESTAURADA)
// RESUMEN: Limpia y redibuja todos los recordatorios/radares en el mapa.
function redrawReminderMapObjects() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
        return;
    }

    const remindersToRedraw = reminderMapObjects.map(obj => {
        const rems = JSON.parse(localStorage.getItem('reminders') || '[]');
        let reminderData = rems.find(r => r.id === obj.reminderId);
        if (reminderData) {
            return { ...reminderData, isFromTarea: obj.isFromTarea };
        }
        return null;
    }).filter(Boolean);

    reminderMapObjects.forEach(obj => {
        if (obj.marker) obj.marker.remove();
        if (obj.circleId) {
            if (navigationMapInstance.getLayer(obj.circleId)) navigationMapInstance.removeLayer(obj.circleId);
            if (navigationMapInstance.getSource(obj.circleId)) navigationMapInstance.removeSource(obj.circleId);
        }
    });
    reminderMapObjects = [];

    remindersToRedraw.forEach(reminder => {
        const newMapObject = plotSingleReminderOnMap(reminder, navigationMapInstance);
        if (newMapObject) {
            reminderMapObjects.push(newMapObject);
        }
    });
}

// ===================================================================
// NOMBRE: hidePostArrivalActionModal (NUEVA FUNCIN)
// RESUMEN: Oculta y elimina el modal de acciones post-llegada.
function hidePostArrivalActionModal() {
    const modal = document.getElementById('post-arrival-action-modal');
    if (modal) {
        modal.remove();
    }
}

// ===================================================================
// NOMBRE: showPostArrivalActionModal (NUEVA FUNCIN)
// RESUMEN: Muestra un modal persistente con opciones despus de llegar a un destino.
function showPostArrivalActionModal() {
    hidePostArrivalActionModal(); // Limpia cualquier instancia anterior

    const modal = document.createElement('div');
    modal.id = 'post-arrival-action-modal';
    
    // <<< MODIFICACIN: Se aade el tercer botn "Salir" al innerHTML >>>
    modal.innerHTML = `
        <p class="post-arrival-title">Viaje finalizado</p>
        <div class="post-arrival-buttons">
            <button id="return-trip-button">Cargar Viaje de Vuelta</button>
            <button id="clear-completed-route-button">Borrar Ruta Actual</button>
            <button id="post-arrival-exit-button" style="background-color: #6c757d;">Salir</button>
        </div>
    `;

    document.body.appendChild(modal);

    document.getElementById('return-trip-button').addEventListener('click', () => {
        createAndLoadReturnTrip();
        hidePostArrivalActionModal();
    });

    document.getElementById('clear-completed-route-button').addEventListener('click', () => {
        handleLoadOrDeleteRouteClick(null);
        hidePostArrivalActionModal();
    });

    // <<< NUEVO: Se aade el event listener para el botn "Salir" >>>
    document.getElementById('post-arrival-exit-button').addEventListener('click', () => {
        hidePostArrivalActionModal();
    });
}
    
// ===================================================================
// NOMBRE: createAndLoadReturnTrip (VERSIN FINAL Y ROBUSTA)
// RESUMEN: Se corrige el bug de numeracin y estado persistente.
async function createAndLoadReturnTrip() {
    if (!navigationWaypoints || navigationWaypoints.length < 2) {
        showToast("No hay una ruta completa para invertir.", "warning");
        return;
    }

    showToast("Preparando ruta de vuelta...", "info", 2000);

    try {
        const originalWaypointsForReturn = navigationWaypoints
            .filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart)
            .map(wp => ({ lat: wp.lat, lng: wp.lng, address: wp.address }));

        handleLoadOrDeleteRouteClick(null);

        await new Promise(resolve => setTimeout(resolve, 50));
        
        const currentPos = await getCurrentLocationAsync();
        
        const originalStart = originalWaypointsForReturn.shift(); // Este era 'S', ahora ser el nuevo 'F'.
        if (originalWaypointsForReturn.length > 0) {
            originalWaypointsForReturn.pop(); // Eliminamos el 'F' original.
        }
        const intermediateReversed = originalWaypointsForReturn.reverse();

        let returnWaypointsData = [
            { lat: currentPos.latitude, lng: currentPos.longitude, address: 'Posicin Actual (GPS)' },
            ...intermediateReversed,
            originalStart 
        ];

        const returnRouteObject = {
            name: `VUELTA: ${originalStart.address || 'Ruta Original'}`,
            waypoints: returnWaypointsData
        };

        loadRouteFromObject(returnRouteObject, true);
        addRouteToRecents(returnRouteObject);

    } catch (error) {
        showToast(`Error al crear ruta de vuelta: ${error.message}`, "error");
    }
}

// ===================================================================
// NOMBRE: showarrivalstatsmodal (VERSIN CORREGIDA Y MEJORADA)
// RESUMEN: Al cerrar, en lugar de borrar la ruta, ahora invoca el nuevo
//          modal de acciones post-llegada (Vuelta / Borrar Ruta).
function showArrivalStatsModal(freeDriveStatsData = null) {
    closeOtherModals('arrival-stats-modal');
    document.body.classList.add('modal-open');

    let modal = document.getElementById('arrival-stats-modal');
    if (modal) {
        clearModalAutoCloseTimer(modal, modal.querySelector('#arrival-stats-accept-button'), 'arrival-stats-modal');
        modal.remove();
    }

    modal = document.createElement('div');
    modal.id = 'arrival-stats-modal';
    
    const isFreeDrive = !!freeDriveStatsData;
    
    const destinationName = isFreeDrive ? "Viaje Libre" : (navigationWaypoints[navigationWaypoints.length - 1]?.address || "Destino");
    const startTime = isFreeDrive ? freeDriveStatsData.startTime : (navigationStartTimeForStats ? new Date(navigationStartTimeForStats) : new Date());
    const arrivalTime = new Date();
    const durationMs = arrivalTime - startTime;
    const durationHours = Math.floor(durationMs / (1000 * 60 * 60));
    const durationMinutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
    
    let kmRealizados = isFreeDrive 
        ? (freeDriveStatsData.totalDistance / 1000).toFixed(1)
        : (totalDistanceTravelledForStats / 1000).toFixed(1);
    if (isSimulatingGpsLocation && automatedSimulationIntervalId) {
        kmRealizados = (simulatedDistanceAlongRoute / 1000).toFixed(1);
    }

    const kmEstimadosTexto = (!isFreeDrive && tripInitialDistanceMeters !== null) 
        ? `<br><small style="font-size: 0.7em; color: #b0b0b0;">(Estimados: ${(tripInitialDistanceMeters / 1000).toFixed(1)} km)</small>`
        : '';
    
    const initialDurationTotalMinutes = tripInitialDurationSec ? Math.round(tripInitialDurationSec / 60) : 0;
    const initialDurationHours = Math.floor(initialDurationTotalMinutes / 60);
    const initialDurationMinutes = initialDurationTotalMinutes % 60;
    const tiempoEstimadoTexto = (!isFreeDrive && tripInitialDurationSec !== null)
        ? `<br><small style="font-size: 0.7em; color: #b0b0b0;">(Estimado: ${String(initialDurationHours).padStart(2,'0')}:${String(initialDurationMinutes).padStart(2,'0')})</small>`
        : '';

    const velocidadMedia = window.averageSpeedKmh.toFixed(1);
    const velocidadMediaEstimadaTexto = (!isFreeDrive && graphExpectedAvgSpeed)
        ? `<br><small style="font-size: 0.7em; color: #b0b0b0;">(Estimada: ${graphExpectedAvgSpeed.toFixed(1)} km/h)</small>`
        : '';
    
    const horaLlegadaEstimadaTexto = (!isFreeDrive && tripInitialOverallEtaTime)
        ? `<br><small style="font-size: 0.7em; color: #b0b0b0;">(Estimada: ${tripInitialOverallEtaTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'})})</small>`
        : '';

    const velocidadMaxima = maxSpeedDuringTrip.toFixed(1);
    const altitudMaxima = maxAltitudeDuringTrip !== -Infinity ? `${maxAltitudeDuringTrip.toFixed(0)} m` : 'N/D';
    const altitudMinima = minAltitudeDuringTrip !== Infinity ? `${minAltitudeDuringTrip.toFixed(0)} m` : 'N/D';
    
    let altitudMediaHtml = 'N/D';
    if (graphDataPoints && graphDataPoints.altitude && graphDataPoints.altitude.length > 0) {
        const sum = graphDataPoints.altitude.reduce((a, b) => a + b, 0);
        const avg = sum / graphDataPoints.altitude.length;
        altitudMediaHtml = `${avg.toFixed(0)} m`;
    }

    let deviationHtml = '';
    let initialEtaDetailsHtml = '';
    if (!isFreeDrive) {
        if (tripInitialOverallEtaTime) {
            const finalDeviationMs = arrivalTime.getTime() - tripInitialOverallEtaTime.getTime();
            deviationHtml = formatDeviation(finalDeviationMs);
            if (Math.abs(finalDeviationMs) < 5000) {
                initialEtaDetailsHtml = `Previsin inicial coincidi con la real.`;
            } else {
                const initialEtaTime = tripInitialOverallEtaTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                const initialDurationFormatted = `${String(initialDurationHours).padStart(2,'0')}:${String(initialDurationMinutes).padStart(2,'0')}`;
                const initialAvgSpeed = graphExpectedAvgSpeed ? graphExpectedAvgSpeed.toFixed(1) : '0.0';
                initialEtaDetailsHtml = `<strong>Previsin inicial:</strong> Llegada: ${initialEtaTime} | Tiempo: ${initialDurationFormatted} | Vel. media: ${initialAvgSpeed} Km/h`;
            }
        }
    }
    
    const deviationSectionHtml = isFreeDrive ? '' : `
        <h3 class="stats-section-header">Desviacin ETA</h3>
        <div class="stats-grid">
            <div class="stat-card" style="grid-column: 1 / -1;">
                <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=_gn_lN6WnWZh&format=png&color=FFFFFF" alt="Desviacin ETA"/></div>
                <span class="stat-label">Desviacin sobre ETA (mm:ss)</span>
                <span class="stat-value">${deviationHtml}</span>
            </div>
        </div>
        ${initialEtaDetailsHtml ? `<div class="initial-eta-details">${initialEtaDetailsHtml}</div>` : ''}
    `;

    modal.innerHTML = `
        <div class="arrival-stats-header">
            <h2>${isFreeDrive ? 'RESUMEN DEL VIAJE' : 'HAS LLEGADO!'}</h2>
            <p class="destination-name">${destinationName}</p>
        </div>
        <div class="arrival-stats-body">
            <div class="arrival-stats-layout-grid">
                <div class="main-stats-container">
                    <h3 class="stats-section-header">Tiempos y Duracin</h3>
                    <div class="stats-grid" style="grid-template-columns: repeat(3, 1fr);">
                         <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=25235&format=png&color=FFFFFF" alt="Salida"/></div>
                            <span class="stat-label">Hora Salida</span>
                            <span class="stat-value">${startTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/time.png" alt="Duracin"/></div>
                            <span class="stat-label">Duracin Viaje</span>
                            <span class="stat-value">${String(durationHours).padStart(2,'0')}:${String(durationMinutes).padStart(2,'0')} ${tiempoEstimadoTexto}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/finish-flag.png" alt="Llegada"/></div>
                            <span class="stat-label">Hora Llegada</span>
                            <span class="stat-value">${arrivalTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})} ${horaLlegadaEstimadaTexto}</span>
                        </div>
                    </div>

                    <h3 class="stats-section-header">Distancia y Velocidad</h3>
                    <div class="stats-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=fodDbvH8xepW&format=png&color=ffffff" alt="Distancia"/></div>
                            <span class="stat-label">Km Realizados</span>
                            <span class="stat-value">${kmRealizados} km ${kmEstimadosTexto}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/speedometer.png" alt="Velocidad Media"/></div>
                            <span class="stat-label">Velocidad Media</span>
                            <span class="stat-value">${velocidadMedia} km/h ${velocidadMediaEstimadaTexto}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=c7DeWFZX07r8&format=png&color=ffffff" alt="Velocidad Mxima"/></div>
                            <span class="stat-label">Velocidad Mxima</span>
                            <span class="stat-value">${velocidadMaxima} km/h <button id="show-max-speed-location-button">Dnde?</button></span>
                        </div>
                    </div>
                </div>

                <div class="side-stats-container">
                    ${deviationSectionHtml}
                    <h3 class="stats-section-header">Mtricas de Altitud</h3>
                    <div class="stats-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/mountain.png" alt="Altitud Mxima"/></div>
                            <span class="stat-label">Altitud Mxima</span>
                            <span class="stat-value">${altitudMaxima}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/mountain.png" alt="Altitud Mnima" style="transform: scaleY(-1);"/></div>
                            <span class="stat-label">Altitud Mnima</span>
                            <span class="stat-value">${altitudMinima}</span>
                        </div>
                         <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=113129&format=png&color=ffffff" alt="Altitud Media"/></div>
                            <span class="stat-label">Altitud Media</span>
                            <span class="stat-value">${altitudMediaHtml}</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="arrival-stats-footer">
            <button id="arrival-stats-accept-button">Aceptar <span class="button-countdown-timer"></span></button>
        </div>
    `;

    document.body.appendChild(modal);
    
    const coordsAreValid = maxSpeedCoordinates && typeof maxSpeedCoordinates.lat === 'number' && !isNaN(maxSpeedCoordinates.lat) && typeof maxSpeedCoordinates.lng === 'number' && !isNaN(maxSpeedCoordinates.lng);
    if (coordsAreValid && navigationMapInstance) {
        const maxSpeedFeature = {
            type: 'Feature',
            geometry: {
                type: 'Point',
                coordinates: [maxSpeedCoordinates.lng, maxSpeedCoordinates.lat]
            },
            properties: {
                type: 'maxSpeed',
                speedText: maxSpeedDuringTrip.toFixed(0)
            }
        };
        speedMarkerFeatures.push(maxSpeedFeature);
        if (navigationMapInstance.getSource('speed-markers-source')) {
            navigationMapInstance.getSource('speed-markers-source').setData({
                type: 'FeatureCollection',
                features: speedMarkerFeatures
            });
        }
        modal.querySelector('#show-max-speed-location-button').addEventListener('click', () => {
            closeHandler();
            navigationMapInstance.flyTo({ center: [maxSpeedCoordinates.lng, maxSpeedCoordinates.lat], zoom: 17 });
        });
    }

    const acceptButton = modal.querySelector('#arrival-stats-accept-button');
    const closeHandler = () => {
        document.body.classList.remove('modal-open');
        clearModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal');
        if (modal.parentNode) modal.remove();
        isGraphingActive = false;
        if (graphIntervalTimer) { clearInterval(graphIntervalTimer); graphIntervalTimer = null; }
        
        if (isFreeDrive) {
             isFreeDriveActive = false;
             isFreeDrivePaused = false;
             freeDriveStats = null;
             tripStartLocationForStats = null;
        } else {
            isNavigating = false;
            navigationFollowUser = false;
            showPostArrivalActionModal(); 
          }

        mapHeaderButtonsVisible = true;
        toggleMapHeaderRowsVisibility(true);
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        showMapInfoOverlay(isFreeDrive ? "Viaje libre finalizado" : "HA LLEGADO A: " + destinationName);
    };

    acceptButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal', 150000);
}

// ===================================================================
// NOMBRE: drawRouteOnMap (REESCRITA - IMPLEMENTA EL SWAP SEGURO)
// RESUMEN: Encapsula la lgica completa de pintado: destruye la ruta antigua
//          y crea la nueva, todo dentro de una promesa segura.
// ===================================================================
async function drawRouteOnMap(route) {
    return new Promise((resolve, reject) => {
        if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
            return reject(new Error("El mapa no est listo para dibujar."));
        }

        const geojsonData = (route && route.geometry && route.geometry.coordinates.length >= 2) 
            ? { type: 'Feature', properties: {}, geometry: route.geometry }
            : { type: 'Feature', properties: {}, geometry: { type: 'LineString', coordinates: [] } };

        const cleanupAndReject = (message) => {
            clearTimeout(timeoutId);
            navigationMapInstance.off('sourcedata', onSourceData);
            reject(new Error(message));
        };
        
        const timeoutId = setTimeout(() => {
            cleanupAndReject("Timeout esperando la confirmacin de renderizado del mapa.");
        }, 7000);

        const onSourceData = (e) => {
            if (e.sourceId === 'route' && e.isSourceLoaded) {
                clearTimeout(timeoutId);
                navigationMapInstance.off('sourcedata', onSourceData);
                resolve();
            }
        };
        
        navigationMapInstance.on('sourcedata', onSourceData);

        try {
            if (navigationMapInstance.getLayer('route')) {
                navigationMapInstance.removeLayer('route');
            }
            if (navigationMapInstance.getSource('route')) {
                navigationMapInstance.removeSource('route');
            }

            navigationMapInstance.addSource('route', { type: 'geojson', data: geojsonData });
            navigationMapInstance.addLayer({
                id: 'route',
                type: 'line',
                source: 'route',
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                paint: getRouteStyleProperties()
            });
           } catch (error) {
            cleanupAndReject(`Error al aadir capa/fuente: ${error.message}`);
        }
    });
}

    
// ===================================================================
// NOMBRE: handleAddRadarHereClick
// RESUMEN: Inicia el proceso para aadir un radar, mostrando el modal de seleccin de velocidad.
function handleAddRadarHereClick(button) {
    showRadarSpeedModal((selectedSpeed) => {
        if (selectedSpeed === null) {
            return;
        }

        button.disabled = true;
        const radarImg = button.querySelector('img');
        if (radarImg) radarImg.src = "PNG/RADAR.PNG";

        getCurrentLocation(
            (coords) => {
                const now = new Date();
                let radarText;
                if (selectedSpeed === 'TRAMO') {
                    radarText = `<b>RADAR: DE TRAMO (Aadido por el usuario)</b>`;
                } else {
                    radarText = `<b>RADAR: DE ${selectedSpeed} KM/H (Aadido por el usuario)</b>`;
                }

                const newRadarReminder = {
                    id: Date.now(),
                    text: radarText,
                    type: 'simple',
                    time: `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`,
                    date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                    createdAt: now.toISOString(),
                    managedByUser: false,
                    isLocationEnabled: true,
                    locationCoordinates: { latitude: coords.latitude, longitude: coords.longitude },
                    radiusMeters: 350,
                    excludeFromList: true
                };

                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                reminders.push(newRadarReminder);
                localStorage.setItem('reminders', JSON.stringify(reminders));
                
                showToast(`Radar de ${selectedSpeed === 'TRAMO' ? 'Tramo' : selectedSpeed + ' km/h'} creado en tu ubicacin.`, "success");
                
                updateReminderCount();
                updateButtonStyles();
                
                if (navigationMapInstance) {
                    const newMapObject = plotSingleReminderOnMap(newRadarReminder, navigationMapInstance);
                    if (newMapObject) {
                        reminderMapObjects.push(newMapObject);
                    }
                    navigationMapInstance.flyTo({ center: [coords.longitude, coords.latitude], zoom: 15 });
                }
                
                button.disabled = false;
                if (radarImg) radarImg.src = "PNG/RADARAQUI.PNG";
            },
            (errorMsg) => {
                showToast(`Error al obtener ubicacin para RADAR: ${errorMsg}`, "error");
                button.disabled = false;
                if (radarImg) radarImg.src = "PNG/RADARAQUI.PNG";
            }
        );
    });
}
// ===================================================================
// NOMBRE: proceedWithRecalculation (MODIFICADA - ACTIVA EL TOAST)
// RESUMEN: Gestiona la lgica de reclculo de ruta segn la accin del usuario.
async function proceedWithRecalculation(action) {
    if (!isNavigating || !navigationCurrentLocation) {
        showToast("No se puede recalcular: no se est navegando o la ubicacin es desconocida.", "error");
        return;
    }
    if (action === 'skip_one') {
        // --- CORRECCIN APLICADA AQU: Se aade '&& wp.type !== 'F'' para no omitir nunca el destino final ---
        const nextUnvisitedStageIndex = navigationWaypoints.findIndex(wp => wp && !wp.isInternal && !wp.isRecalculatedStart && !wp.visited && wp.type !== 'S' && wp.type !== 'S_Recalc' && wp.type !== 'F');
        if (nextUnvisitedStageIndex !== -1) {
            navigationWaypoints[nextUnvisitedStageIndex].visited = true;
            showToast(`Omitiendo etapa: ${navigationWaypoints[nextUnvisitedStageIndex].address || 'Siguiente' }`, "info");
        } else {
            showToast("No hay prximas etapas intermedias para omitir. Recalculando a destino.", "info");
        }
    } else if (action === 'skip_multiple') {
        const stagesToSkip = [];
        const currentHeading = navigationCurrentLocation.heading;
        navigationWaypoints.forEach(wp => {
            // Esta condicin ya era correcta, pero la dejamos para asegurar que el destino final NUNCA se omita.
            if (wp.visited || wp.type === 'S' || wp.type === 'S_Recalc' || wp.type === 'F') return;
            const bearingToWp = turf.bearing(
                turf.point([navigationCurrentLocation.longitude, navigationCurrentLocation.latitude]),
                turf.point([wp.lng, wp.lat])
            );
            let angleDiff = Math.abs(currentHeading - (bearingToWp < 0 ? bearingToWp + 360 : bearingToWp));
            if (angleDiff > 180) angleDiff = 360 - angleDiff;
            if (angleDiff > 110) {
                stagesToSkip.push(wp.id);
            }
        });
        if (stagesToSkip.length > 0) {
            navigationWaypoints.forEach(wp => {
                if (stagesToSkip.includes(wp.id)) wp.visited = true;
            });
            showToast(`Saltando ${stagesToSkip.length} etapas que han quedado atrs.`, "info");
        }
    }
    await recalculateAndDrawRoute(true);
}
// ===================================================================
// NOMBRE: checkAndMarkWaypointsAsVisited (VERSIN CON LGICA DE ACUMULACIN CORREGIDA)
// RESUMEN: Corrige el error lgico "off-by-one" que marcaba la primera etapa
//          como visitada. La distancia de cada tramo ahora se usa para evaluar la
//          llegada a la etapa correcta.
// ===================================================================
function checkAndMarkWaypointsAsVisited(route, carDistanceAlongRoute, currentCoords) {
    if (!route || !route.legs || !currentCoords) return;

    let cumulativeDistance = 0; // Distancia acumulada ANTES del tramo actual.
    navigationWaypoints.forEach((wp, index) => {
        if (wp) {
            const isStartPoint = wp.type === 'S' || wp.isRecalculatedStart;
            const isIntermediate = wp.type === 'intermediate';
            const isFinal = wp.type === 'F';

            if (isStartPoint) {
                wp.visited = true;
            } else if (isIntermediate && (index - 1) < route.legs.length) {
                const leg = route.legs[index - 1];
                if (leg) {
                    // <<< CORRECCIN CLAVE >>>
                    // Se calcula la distancia hasta el final de ESTA etapa antes de hacer nada ms.
                    const distanceToEndOfThisLeg = cumulativeDistance + (leg.distance || 0);

                    const tripHasPhysicallyStarted = isNavigating && navigationStartTimeForStats;
                    const hasClearedStartBuffer = carDistanceAlongRoute > 20;

                    // La comprobacin ahora usa la distancia correcta para esta etapa.
                    if (tripHasPhysicallyStarted && hasClearedStartBuffer && carDistanceAlongRoute >= distanceToEndOfThisLeg - WAYPOINT_VISITED_THRESHOLD_METERS) {
                        wp.visited = true;
                    }
                    
                    // Solo DESPUS de la comprobacin, se actualiza la distancia acumulada para la SIGUIENTE etapa.
                    cumulativeDistance = distanceToEndOfThisLeg;
                }
            } else if (isFinal) {
                const finalDestinationCoords = route.legs[route.legs.length - 1].steps.slice(-1)[0].maneuver.location;
                const physicalDistanceToFinal = calculateDistance(currentCoords.latitude, currentCoords.longitude, finalDestinationCoords[1], finalDestinationCoords[0]);
                
                if (physicalDistanceToFinal <= WAYPOINT_VISITED_THRESHOLD_METERS) {
                    wp.visited = true;
                }
            }
        }
    });
}
    

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// NOMBRE: findChargingPointsOnRoute (CORREGIDA - ROBUSTA CONTRA ERUDA)
// RESUMEN: Busca PDRs de OCM y gestiona el estado de la bsqueda.
async function findChargingPointsOnRoute(powerFilters, searchConfig) {
    const pdrButton = document.getElementById('pdrs-ruta-button');
    if (pdrButton) pdrButton.classList.remove('pdr-search-highlight');

    clearChargingPoints();
    lastPdrSearchResults = [];
    
    showToast("Buscando puntos de recarga (OCM)...", "info", 0, false, "pdrs-search");

    const PDR_SEARCH_IN_VIEW_KEY = 'boardinggate_pdrSearchInView';
    const hasRoute = searchConfig.type === 'route';
    const searchInCurrentViewChecked = localStorage.getItem(PDR_SEARCH_IN_VIEW_KEY) === 'true';
    
    let apiUrl;

    if (searchInCurrentViewChecked) {
        const bounds = navigationMapInstance.getBounds();
        apiUrl = `https://api.openchargemap.io/v3/poi/?output=json&key=${OCM_API_KEY}&boundingbox=(${bounds.getSouthWest().lat},${bounds.getSouthWest().lng}),(${bounds.getNorthEast().lat},${bounds.getNorthEast().lng})&maxresults=1500&compact=false&verbose=true`;
        showToast("Buscando en la vista actual del mapa...", "info", 2000);
    } else if (hasRoute) {
        const routeSource = navigationMapInstance.getSource('route');
        if (!routeSource || !routeSource._data || !routeSource._data.geometry || !routeSource._data.geometry.coordinates || routeSource._data.geometry.coordinates.length < 2) {
            showToast("No hay ruta vlida para buscar PDRs sobre ella.", "error");
            const existingToast = document.getElementById("pdrs-search");
            if (existingToast) existingToast.remove();
            return;
        }
        const routeBounds = new mapboxgl.LngLatBounds();
        routeSource._data.geometry.coordinates.forEach(coord => routeBounds.extend(coord));
        apiUrl = `https://api.openchargemap.io/v3/poi/?output=json&key=${OCM_API_KEY}&boundingbox=(${routeBounds.getSouthWest().lat},${routeBounds.getSouthWest().lng}),(${routeBounds.getNorthEast().lat},${routeBounds.getNorthEast().lng})&maxresults=1500&compact=false&verbose=true`;
    } else if (searchConfig.type === 'radius') {
        apiUrl = `https://api.openchargemap.io/v3/poi/?output=json&key=${OCM_API_KEY}&latitude=${searchConfig.center.lat}&longitude=${searchConfig.center.lng}&distance=${searchConfig.radiusKm}&distanceunit=km&maxresults=1000&compact=false&verbose=true`;
    } else {
        showToast("Tipo de bsqueda no vlido.", "error");
        pdrSearchState = 'initial';
        return;
    }
    
    try {
        const response = await fetch(apiUrl);
        if (!response.ok) throw new Error(`Error de red de OCM: ${response.statusText}`);
        const data = await response.json();
        if (!data || !Array.isArray(data)) throw new Error("Respuesta de OCM no vlida.");

        window.lastOcmApiResponse = data;

        const operatorFilterText = (document.getElementById('operator-filter-input')?.value || localStorage.getItem('boardinggate_operator_filter') || '').toLowerCase().trim();
        const operatorFilterWords = operatorFilterText ? operatorFilterText.split(/\s+/).filter(w => w) : [];
        
        const routeLineForDistanceCheck = (searchConfig.type === 'route' && navigationMapInstance.getSource('route') && navigationMapInstance.getSource('route')._data) ? turf.lineString(navigationMapInstance.getSource('route')._data.geometry.coordinates) : null;
        
        let filteredPoints = [];

        data.forEach(point => {
            const formattedPoint = formatOCMPoint(point);
            if (!formattedPoint) return;
            const power = parseFloat(formattedPoint.power);
            if (isNaN(power) || power < powerFilters.min || power > powerFilters.max) return;

            if (operatorFilterWords.length > 0) {
                const pointOperator = (formattedPoint.operator || '').toLowerCase();
                const pointAddress = (formattedPoint.address || '').toLowerCase();
                const operatorMatch = operatorFilterWords.some(word => 
                    pointOperator.includes(word) || pointAddress.includes(word)
                );
                if (!operatorMatch) return;
            }
            
            if (!searchInCurrentViewChecked && hasRoute && routeLineForDistanceCheck) {
                const pointTurf = turf.point([formattedPoint.lon, formattedPoint.lat]);
                const distanceKm = turf.pointToLineDistance(pointTurf, routeLineForDistanceCheck, { units: 'kilometers' });
                if (distanceKm <= searchConfig.distanceFilters.max) {
                    filteredPoints.push(formattedPoint);
                }
            } else { 
                filteredPoints.push(formattedPoint);
            }
        });
        
        lastPdrSearchResults = [...filteredPoints];
        currentChargingPointsOnRoute = [...filteredPoints];

        const cheapestBySegment = {
            '#5e5e5e': { price: Infinity, point: null },
            '#007863': { price: Infinity, point: null },
            'rgb(30, 144, 255)': { price: Infinity, point: null },
            '#de2e03': { price: Infinity, point: null }
        };

        const parsePrice = (priceString) => {
            if (priceString && typeof priceString === 'string') {
                const priceMatch = priceString.match(/(\d[\d,.]*)/);
                if (priceMatch && priceMatch[1]) {
                    const priceNum = parseFloat(priceMatch[1].replace(',', '.'));
                    if (!isNaN(priceNum) && priceNum > 0 && priceNum < 10) {
                        return priceNum;
                    }
                }
            }
            return Infinity;
        };

        currentChargingPointsOnRoute.forEach(point => {
            point.isCheapest = false;
            const power = parseFloat(point.power);
            const segmentColor = getChargingPointColorByPower(power);
            const price = parsePrice(point.price);
            
            if (cheapestBySegment[segmentColor] && price < cheapestBySegment[segmentColor].price) {
                cheapestBySegment[segmentColor].price = price;
                cheapestBySegment[segmentColor].point = point;
            }
        });

        for (const color in cheapestBySegment) {
            const cheapest = cheapestBySegment[color];
            if (cheapest.point) {
                cheapest.point.isCheapest = true;
            }
        }

        const existingToast = document.getElementById("pdrs-search");
        if (existingToast) existingToast.remove();
        showToast(`${currentChargingPointsOnRoute.length} PDRs encontrados.`, "success");
        displayChargingPointsOnMap();

        pdrSearchState = 'results_shown';

    } catch (error) {
        const existingToast = document.getElementById("pdrs-search");
        if (existingToast) existingToast.remove();
        showToast(`Error al buscar PDRs: ${error.message}`, "error");
        pdrSearchState = 'initial';
    }
}


// NOMBRE: updateUserIdDisplay
// RESUMEN: Muestra el ID de usuario en la pantalla si existe.
// ===================================================================
function updateUserIdDisplay() {
    const userIdDisplay = document.getElementById('user-id-display');
    const userId = localStorage.getItem('userData_userId');
    if (userIdDisplay) {
        if (userId) {
            userIdDisplay.textContent = userId.trim();
            userIdDisplay.style.display = 'block';
        } else {
            userIdDisplay.textContent = '';
            userIdDisplay.style.display = 'none';
        }
    }
}

// ===================================================================
// NOMBRE: handleGpsSimulationToggle (MODIFICADA - PARA MAPBOX)
// RESUMEN: Activa/desactiva el modo de simulacin GPS. Si hay una ruta cargada al activar, muestra el modal de seleccin de velocidad y tipo de simulacin.
function handleGpsSimulationToggle() {
    const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
    const mapDiv = document.getElementById('reminders-location-map-div');
    if (isSimulatingGpsLocation) { 
        if (isSimulatingFreeDrive) {
            stopFreeDrive();
            isSimulatingFreeDrive = false; 
        }
        
        stopAutomatedRouteSimulationInternal(); 
        isSimulatingGpsLocation = false;
        reactivateRealGpsAfterSimulation();
        if (mapDiv) mapDiv.classList.remove('simulating-gps-click-mode');
        if (simulateGpsButton) {
            simulateGpsButton.classList.remove('active-simulate-gps-mode'); 
            simulateGpsButton.title = "Activar Simulacin GPS (recorrido automtico o clic manual)";
        }
        if (maxSpeedMarkerObjects && maxSpeedMarkerObjects.length > 0) {
            maxSpeedMarkerObjects.forEach(marker => marker.remove());
            maxSpeedMarkerObjects = [];
        }
        if (speedMilestoneMarkerObjects && speedMilestoneMarkerObjects.length > 0) {
            speedMilestoneMarkerObjects.forEach(marker => marker.remove());
            speedMilestoneMarkerObjects = [];
        }
        showToast("Modo simulacin GPS desactivado. Volviendo a GPS real.", "info");
    } else { 
        if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0] && navigationWaypoints.filter(wp => !wp.isInternal && !wp.isRecalculatedStart).length >= 2) {
            showSimulationSpeedModal(simulationSpeedKmph, (newSpeed) => {
                startAutomatedRouteSimulation(newSpeed); 
                if (mapDiv) mapDiv.classList.remove('simulating-gps-click-mode'); 
            });
        } else {
            isSimulatingGpsLocation = true;
            if (simulateGpsButton) simulateGpsButton.classList.add('active-simulate-gps-mode'); 
            if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode'); 
            showToast("Modo simulacin GPS por clic ACTIVADO. Carga una ruta para recorrido automtico o toca el mapa.", "info", 6000);
        }
    }
    setNavigationMapClickHandler();
}

// ===================================================================
// NOMBRE: deleteFilteredRadars (MODIFICADA)
// RESUMEN: Borra radares y limpia la cach para forzar su reconstruccin.
async function deleteFilteredRadars() {
    window.radarsCache = null;
    window.radarsSpatialIndex = null;
    localStorage.removeItem('radarsCacheData');
    localStorage.removeItem('radarsCacheIndex');
    localStorage.removeItem('radarsCacheVersion');
    
    const latFilterValue = document.getElementById('radar-filter-lat').value.trim();
    const lonFilterValue = document.getElementById('radar-filter-lon').value.trim();
    const keywordsFilterRaw = document.getElementById('radar-filter-keywords').value.trim().toUpperCase();
    const keywordsFilter = keywordsFilterRaw ? keywordsFilterRaw.split(/\s+/).filter(k => k) : [];
    const statusMessage = document.getElementById('radar-import-status');
    const progressContainer = document.getElementById('radar-import-progress-container');
    const noFiltersProvided = !latFilterValue && !lonFilterValue && keywordsFilter.length === 0;
    let confirmationMessage = "";
    if (noFiltersProvided) {
        confirmationMessage = "Ests seguro de que quieres borrar TODOS los recordatorios tipo RADAR/POI (ya que no has especificado ningn filtro)? Esta accin no se puede deshacer.";
    } else {
        confirmationMessage = "Ests seguro de que quieres borrar los recordatorios tipo RADAR/POI que coincidan con los filtros actuales? Esta accin no se puede deshacer.";
    }
    if (!confirm(confirmationMessage)) {
        showToast("Borrado cancelado", "info");
        return;
    }
    progressContainer.style.display = 'block';
    const progressBar = document.getElementById('radar-import-progress-bar');
    if(progressBar) progressBar.style.display = 'none';
    statusMessage.textContent = 'Borrando recordatorios...';
    statusMessage.style.color = '';
    try {
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        let originalLength = reminders.length;
        reminders = reminders.filter(r => {
            const isRadarType = r.isLocationEnabled && (r.text.toUpperCase().includes("RADAR") || r.excludeFromList);
            if (!isRadarType) return true;
            if (noFiltersProvided) {
                return false;
            }
            let matchesKeywords = true;
            if (keywordsFilter.length > 0) {
                matchesKeywords = keywordsFilter.some(kw => r.text.toUpperCase().includes(kw));
            }
            let matchesLat = true;
            if (latFilterValue) {
                if (r.locationCoordinates) {
                    matchesLat = parseCoordinateFilter(latFilterValue, r.locationCoordinates.latitude);
                } else {
                    matchesLat = false;
                }
            }
            let matchesLon = true;
            if (lonFilterValue) {
                if (r.locationCoordinates) {
                    matchesLon = parseCoordinateFilter(lonFilterValue, r.locationCoordinates.longitude);
                } else {
                    matchesLon = false;
                }
            }
            return !(matchesKeywords && matchesLat && matchesLon);
        });
        localStorage.setItem('reminders', JSON.stringify(reminders));
        const numDeleted = originalLength - reminders.length;
        statusMessage.textContent = `Borrado completo. ${numDeleted} recordatorios eliminados.`;
        statusMessage.style.color = '#28a745';
        showToast(`${numDeleted} recordatorios eliminados`, 'success');
        updateReminderCount();
        updateButtonStyles();
        checkReminders();
    } catch (error) {
        statusMessage.textContent = `Error: ${error.message}`;
        statusMessage.style.color = 'red';
        showToast('Error durante el borrado', 'error');
    } finally {
        setTimeout(() => {
            progressContainer.style.display = 'none';
            if(progressBar) progressBar.style.display = 'block';
            statusMessage.style.color = '';
        }, 3000);
    }
}

// ===================================================================
// NOMBRE: handleMapClickToAddReminder (MODIFICADA - PARA MAPBOX)
// RESUMEN: Maneja el clic para aadir un recordatorio en el mapa.
function handleMapClickToAddReminder(e) {
    if (!isAddReminderAtLocationModeActive || !navigationMapInstance) return;
    const latlng = e.lngLat;
    toggleAddReminderAtLocationMode(); 
    const mapContextBeforeModal = sessionStorage.getItem('mapContext');
    sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
    if (mapContextBeforeModal) {
      sessionStorage.setItem('mapContext', mapContextBeforeModal);
    }
    showReminderModal({
        isLocationEnabled: true,
        locationCoordinates: { latitude: latlng.lat, longitude: latlng.lng },
        radiusMeters: DEFAULT_LOCATION_RADIUS,
        text: 'Recordatorio en mapa: ',
        excludeFromList: false
    }, { onTopOfMap: true });
}

// ===================================================================
// NOMBRE: loadSavedSettings (MODIFICADA - CARGA EL PITCH)
// RESUMEN: Carga la configuracin, incluyendo el valor de pitch guardado.
function loadSavedSettings() {
    const savedDarkMode = localStorage.getItem('darkMode');
    isDarkMode = savedDarkMode ? JSON.parse(savedDarkMode) : false;
    if (isDarkMode) document.body.classList.add('dark-mode');
    
    mapOffsetX = parseInt(localStorage.getItem(MAP_VIEW_OFFSET_X_KEY)) || 0;
    mapOffsetY = parseInt(localStorage.getItem(MAP_VIEW_OFFSET_Y_KEY)) || -30;
    const savedMinimapPref = localStorage.getItem(MAP_VIEW_SHOW_MINIMAP_KEY);
    showMinimapPreference = savedMinimapPref === null ? true : JSON.parse(savedMinimapPref);
    // --- LNEA MODIFICADA: Carga el pitch guardado ---
    mapPitchValue = parseInt(localStorage.getItem(MAP_VIEW_PITCH_KEY)) || 56;

    const savedZoomState = localStorage.getItem('zoomState');
    const zoomButtonElem = document.getElementById('zoom-button');
    if (zoomButtonElem) {
        zoomButtonElem.dataset.zoomState = savedZoomState || 'off';
        applyZoom(zoomButtonElem.dataset.zoomState);
    }
    const savedPasswordActive = localStorage.getItem('password_active');
    isPasswordActive = savedPasswordActive ? JSON.parse(savedPasswordActive) : false;
    storedPin = localStorage.getItem('password_pin');
    lastUpdatesCheckDate = localStorage.getItem('lastUpdatesCheckDate');
    const savedNoticesActive = localStorage.getItem('noticesActive');
    const savedFooterVisible = localStorage.getItem('footerVisible');
    isActive = savedNoticesActive ? JSON.parse(savedNoticesActive) : true;
    isFooterVisible = savedFooterVisible ? JSON.parse(savedFooterVisible) : true;
    const noticeContainer = document.querySelector('.notices-container');
    if (noticeContainer) noticeContainer.style.display = isActive ? 'flex' : 'none';
    const footerElement = document.querySelector('footer');
    if (footerElement) footerElement.classList.toggle('footer-hidden', !isFooterVisible);
    const onOffBtn = document.getElementById('on-off-toggle');
    if (onOffBtn) {
        const savedOnOffState = localStorage.getItem('onOffState');
        onOffBtn.dataset.state = savedOnOffState ? savedOnOffState : 'on';
    }
    const toggleStatesFromCache = JSON.parse(localStorage.getItem('toggleStates') || '{}');
    document.querySelectorAll('.range-toggle').forEach(toggle => {
        const start = parseInt(toggle.dataset.rangeStart);
        const savedState = toggleStatesFromCache[start] || 'visible';
        toggle.dataset.state = savedState;
    });
    const mainSearchInputGrid = document.getElementById('grid-filter-input');
    if (mainSearchInputGrid) {
        const savedMainFilter = localStorage.getItem('gridFilterValue');
        if (savedMainFilter !== null) {
            mainSearchInputGrid.value = savedMainFilter;
        } else {
            mainSearchInputGrid.value = '';
        }
    }
    
    const mapFilterInput = document.getElementById('filter-input'); 
    if (mapFilterInput) {
        mapFilterInput.value = localStorage.getItem(MAP_FILTER_INPUT_KEY) || 'Espaa';
    }
    
    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresRutaCheckbox) {
        const savedCheckState = localStorage.getItem(RADARES_RUTA_CHECKED_KEY);
        radaresRutaCheckbox.checked = savedCheckState === 'true';
    }
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasRutaCheckbox) {
        const savedTareasCheckState = localStorage.getItem(TAREAS_RUTA_CHECKED_KEY);
        tareasRutaCheckbox.checked = savedTareasCheckState === 'true';
    }
    currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviacin ETA';
    const userIdInput = document.getElementById('user-id');
    const modelInput = document.getElementById('tesla-model');
    const yearInput = document.getElementById('tesla-year');
    const provinceInput = document.getElementById('tesla-province');
    const dmsCheckbox = document.getElementById('allow-dms');
    const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
    if (userIdInput) userIdInput.value = localStorage.getItem('userData_userId') || '';
    if (modelInput) modelInput.value = localStorage.getItem('userData_teslaModel') || '';
    if (yearInput) yearInput.value = localStorage.getItem('userData_teslaYear') || '';
    if (provinceInput) provinceInput.value = localStorage.getItem('userData_teslaProvince') || '';
   
   const savedAllowDMs = localStorage.getItem('userData_allowDMs');
   if (dmsCheckbox) {
    dmsCheckbox.checked = savedAllowDMs === null ? true : JSON.parse(savedAllowDMs); 
   } 
    
    if (autoBackupCheckbox) {
        const savedAutoBackup = localStorage.getItem('boardinggate_autoBackupOnLoad');
        autoBackupCheckbox.checked = savedAutoBackup === null ? true : JSON.parse(savedAutoBackup);
    }
    const savedLockState = localStorage.getItem(PROGRESS_BAR_LOCKED_KEY);
    isProgressBarLocked = savedLockState === null ? true : JSON.parse(savedLockState);
    actualizarContadorRadares(0);
    actualizarContadorTareas(0);
    updateUserIdDisplay();
    updateReminderCount();
}
    
// ===================================================================
// NOMBRE: showReorderStagesModal (VERSIN FINAL CON CORRECCIN DE ID)
// RESUMEN: Se corrige el bug crtico que truncaba los IDs de las etapas al leerlos
function showReorderStagesModal() {
    if (isNavigating) {
        showToast("No se puede reordenar etapas mientras se navega.", "warning");
        return;
    }
    const actualWaypointsForReorder = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    if (actualWaypointsForReorder.length < 2) {
        showToast("Se necesitan al menos 2 puntos para reordenar", "warning");
        return;
    }

    const modal = document.getElementById('reorder-stages-modal');
    const listElement = modal.querySelector('#sortable-stages-list');

    
    listElement.innerHTML = '';
    
    actualWaypointsForReorder.forEach(async (wp) => {
        const li = document.createElement('li');
        li.dataset.id = wp.id;

        const dragHandle = document.createElement('span');
        dragHandle.className = 'drag-handle';
        dragHandle.innerHTML = '<img src="PNG/MOVER.PNG" alt="Mover etapa">';
        dragHandle.title = 'Arrastrar para reordenar';
        dragHandle.draggable = true;

        const badge = document.createElement('span');
        badge.className = 'stage-label-badge';
        badge.textContent = wp.label;

        const nameSpan = document.createElement('span');
        nameSpan.className = 'stage-name-text';
        nameSpan.textContent = wp.address || `Cargando... (${wp.lat.toFixed(3)}, ${wp.lng.toFixed(3)})`;
        if (!wp.address) {
             wp.address = await getAddressForWaypoint(wp.lat, wp.lng);
             nameSpan.textContent = wp.address;
        }

        const deleteButton = document.createElement('span');
        deleteButton.className = 'delete-stage-button';
        deleteButton.innerHTML = '';
        deleteButton.title = 'Eliminar esta etapa';

        deleteButton.addEventListener('click', (e) => {
            e.stopPropagation();
            const listItem = e.target.closest('li');
            if (listItem) {
                listItem.remove();
            }
        });

        li.appendChild(dragHandle);
        li.appendChild(badge);
        li.appendChild(nameSpan);
        li.appendChild(deleteButton);
        listElement.appendChild(li);
    });

    modal.classList.remove('hidden');
    
    const confirmButton = modal.querySelector('#confirm-reorder-stages');
    const cancelButton = modal.querySelector('#cancel-reorder-stages');
    
    const newConfirmButton = confirmButton.cloneNode(true);
    confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
    const newCancelButton = cancelButton.cloneNode(true);
    cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);
    
    const closeReorderModal = () => {
        clearModalAutoCloseTimer(modal, newConfirmButton, 'reorder-stages-modal');
        modal.classList.add('hidden');
        listElement.removeEventListener('dragstart', handleDragStartReorder);
        listElement.removeEventListener('dragend', handleDragEndReorder);
        listElement.removeEventListener('dragover', handleDragOverReorder);
        listElement.removeEventListener('touchstart', handleStageTouchStart);
        listElement.removeEventListener('touchmove', handleStageTouchMove);
        listElement.removeEventListener('touchend', handleStageTouchEnd);
        listElement.removeEventListener('touchcancel', handleStageTouchEnd);
        document.body.style.overflow = '';
    };

    newConfirmButton.addEventListener('click', async () => {
        const orderedLiElements = Array.from(listElement.children);
        
        const finalWaypointIds = orderedLiElements.map(li => parseFloat(li.dataset.id));
        clearAllWaypointMarkersFromMap();

        if (finalWaypointIds.length < 2) {
            navigationWaypoints = [];
            handleLoadOrDeleteRouteClick(null);
            closeReorderModal();
            return;
        }

        try {
            const waypointMap = new Map(navigationWaypoints.map(wp => [wp.id, wp]));
            
            const userWaypointsInNewOrder = [];
            finalWaypointIds.forEach(id => {
                if (waypointMap.has(id)) {
                    userWaypointsInNewOrder.push(waypointMap.get(id));
                }
            });
            
            const recalcStartPoint = navigationWaypoints.find(wp => wp && wp.isRecalculatedStart);
            navigationWaypoints = recalcStartPoint ? [recalcStartPoint, ...userWaypointsInNewOrder] : [...userWaypointsInNewOrder];
            
            const safeFinalWaypoints = navigationWaypoints.map(wp => ({ id: wp.id, address: wp.address, type: wp.type, label: wp.label, isInternal: wp.isInternal }));
            
            await updateWaypointTypesAndLabels();
            renderWaypointMarkers();
            
            await recalculateAndDrawRoute();

        } catch (error) {
            console.error("[DEBUG] Error capturado en el bloque `try` del modal al intentar recalcular:", error);
        } finally {
            closeReorderModal();
            updateStartNavigationButtonState();
            updateNavigationButtonColor();
        }
    });
    
    newCancelButton.addEventListener('click', () => {
        showToast("Reordenacin cancelada.", "info");
        closeReorderModal();
        if (navigationWaypoints.length >= 2) {
            renderWaypointMarkers();
            recalculateAndDrawRoute().catch(() => {});
        } else {
            handleLoadOrDeleteRouteClick(null);
        }
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
    });

    addModalAutoCloseTimer(modal, newConfirmButton, 'reorder-stages-modal', 60000);
    
    listElement.addEventListener('dragstart', handleDragStartReorder);
    listElement.addEventListener('dragend', handleDragEndReorder);
    listElement.addEventListener('dragover', handleDragOverReorder);
    listElement.addEventListener('touchstart', handleStageTouchStart, { passive: false });
    listElement.addEventListener('touchmove', handleStageTouchMove, { passive: false });
    listElement.addEventListener('touchend', handleStageTouchEnd);
    listElement.addEventListener('touchcancel', handleStageTouchEnd);
}
    
// ===================================================================
// NOMBRE: updateProgressBarLockIcon (NUEVA FUNCIN)
// RESUMEN: Actualiza el icono del candado en la barra de progreso segn su estado.
function updateProgressBarLockIcon() {
    const lockButton = document.getElementById('toggle-progress-bar-lock');
    if (!lockButton) return;
    const img = lockButton.querySelector('img');
    if (img) {
        if (isProgressBarLocked) {
            img.src = "PNG/IMG_4281.png";
            lockButton.title = "Panel de progreso BLOQUEADO. Plsame para activar auto-ocultacin.";
        } else {
            img.src = "PNG/IMG_4280.png";
            lockButton.title = "Panel de progreso DESBLOQUEADO. Se ocultar automticamente. Plsame para bloquearlo.";
        }
    }
}

// ===================================================================
// NOMBRE: Lgica de Pre-carga de GPS
// RESUMEN: Obtiene la ubicacin del GPS al cargar la pgina para acelerar la apertura del mapa.
// ===================================================================

let preloadedGpsPosition = null;

function preloadGpsLocation() {
    if ('geolocation' in navigator) {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                console.log("GPS position pre-loaded successfully for faster map opening.");
                preloadedGpsPosition = {
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy,
                    altitude: position.coords.altitude,
                    heading: position.coords.heading,
                    speed: position.coords.speed
                };
            },
            (error) => {
                // No mostramos un toast aqu para no molestar al usuario si falla en segundo plano.
                console.warn("Could not pre-load GPS position:", error.message);
            },
            { 
                enableHighAccuracy: true, 
                timeout: 15000,      // Damos hasta 15 segundos
                maximumAge: 60000    // Aceptamos una posicin de hasta 1 minuto de antigedad
            }
        );
    }
}    

// ===================================================================
// NOMBRE: openNavigationMap (VERSIN CON ANIMACIN Y LOCALIZACIN RPIDA)
// RESUMEN: Mantiene la animacin del globo, pero usa la posicin GPS precargada
//          para volar a la ubicacin del usuario inmediatamente despus, sin esperas.
// ===================================================================
async function openNavigationMap() {
    const { primaryId: userId } = parseUserId(localStorage.getItem('userData_userId'));
    if (userId && userId.toLowerCase() !== 'boardinggate') {
        const toastId = "map-access-check";
        try {
            const adminDocRef = window.doc(window.db, "user_data", "boardinggate");
            const userDocRef = window.doc(window.db, "user_data", userId);
            
            const [adminSnap, userSnap] = await Promise.all([window.getDoc(adminDocRef), window.getDoc(userDocRef)]);
            
            let maxSessions = Infinity;
            if (adminSnap.exists() && typeof adminSnap.data().max_monthly_sessions === 'number') {
                maxSessions = adminSnap.data().max_monthly_sessions;
            }
            
            let userMonthlyCount = 0;
            if (userSnap.exists()) {
                const userData = userSnap.data();
                const now = new Date();
                const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
                if (userData.map_sessions_last_month === currentMonthStr) {
                    userMonthlyCount = userData.map_sessions_month || 0;
                }
            }

            const existingToast = document.getElementById(toastId);
            if(existingToast) existingToast.remove();
            
            if (userMonthlyCount >= maxSessions) {
                showToast("HA SUPERADO EL NMERO MXIMO DE SESIONES MENSUALES DE MAPA, consulte con el administrador", "error", 10000);
                return; 
            }
        } catch (error) {
            const existingToast = document.getElementById(toastId);
            if(existingToast) existingToast.remove();
            showToast("No se pudo verificar el lmite de sesiones. Acceso permitido.", "warning");
        }
    }

                           
    isGeolocated = false;
    const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'none';
    const footer = document.querySelector('footer'); if (footer) footer.style.display = 'none';
    const noticesContainer = document.querySelector('.notices-icon-container'); if (noticesContainer) noticesContainer.style.display = 'none';
    const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'none');
    document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button, #accident-alert-button').forEach(el => el.style.display = 'none');
    const gridFilter = document.getElementById('grid-filter-container'); if (gridFilter) gridFilter.style.display = 'none';

    isNavigationMapActive = true;
    sessionStorage.setItem('mapContext', 'navigation');
    closeOtherModals('reminders-location-map-modal');
    
    const mapModal = document.getElementById('reminders-location-map-modal');
    if (!mapModal) { console.error("Error crtico: El modal del mapa no se encuentra en el HTML."); isNavigationMapActive = false; return; }
    
    mapModal.classList.remove('map-modal-hidden');
    const mapActualContainer = document.getElementById('mapbox-map-actual-container');
    
    if (navigationMapInstance) {
        handleLoadOrDeleteRouteClick(null);
        setNavigationMapClickHandler();
        setTimeout(() => { if (navigationMapInstance) navigationMapInstance.resize(); }, 100);
        
    } else {
        try {
            const savedLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "HBRIDO";
            const finalLayerName = MAP_LEGACY_NAME_MAP[savedLayerName] || savedLayerName;
            const initialStyle = MAP_STYLES[finalLayerName] || MAP_STYLES["HBRIDO"];
            showToast("INICIALIZANDO MAPA...", "info", 0, false, "map-init-toast");
  
            const startCoordsTexas = { lat: 30.3715, lng: -97.1903 };
            navigationMapInstance = new mapboxgl.Map({
                container: mapActualContainer,
                style: initialStyle, 
                center: [startCoordsTexas.lng, startCoordsTexas.lat],
                zoom: 2.8,
                pitch: 0,
                bearing: 0,
                attributionControl: false, 
                accessToken: mapboxgl.accessToken
            });
            
            setMapImmersiveMode(true);
            
            incrementMapSessionCount();
            mapSessionStartTime = Date.now();
            
            const customControls = new CustomMapControlsGroup();
            navigationMapInstance.addControl(customControls, 'bottom-right');
            
            compassAndModeControl = new CompassAndStatsControl();
            navigationMapInstance.addControl(compassAndModeControl, 'bottom-left');
            
            // ... (el resto de tu cdigo de inicializacin de controles y listeners)
            if (!navigationMapInstance._interactionListenersAttached) {
                const mapCanvas = navigationMapInstance.getCanvasContainer();
                let touchStartPos = null;
                let hasMovedEnoughToDrag = false;
                const DRAG_THRESHOLD = 10;
                const onTouchStart = (e) => {
                    if (e.touches && e.touches.length > 1) return;
                    const touch = e.touches ? e.touches[0] : e;
                    touchStartPos = { x: touch.clientX, y: touch.clientY };
                    hasMovedEnoughToDrag = false;
                };
                const onTouchMove = (e) => {
                    if (hasMovedEnoughToDrag || !touchStartPos) return;
                    if (e.touches && e.touches.length > 1) return;
                    const touch = e.touches ? e.touches[0] : e;
                    const deltaX = Math.abs(touch.clientX - touchStartPos.x);
                    const deltaY = Math.abs(touch.clientY - touchStartPos.y);
                    if (deltaX > DRAG_THRESHOLD || deltaY > DRAG_THRESHOLD) {
                        hasMovedEnoughToDrag = true;
                        handleManualMapInteraction(); 
                    }
                };
                const onTouchEnd = () => {
                    touchStartPos = null;
                    hasMovedEnoughToDrag = false;
                };
                mapCanvas.addEventListener('touchstart', onTouchStart, { passive: true });
                mapCanvas.addEventListener('touchmove', onTouchMove, { passive: true });
                mapCanvas.addEventListener('touchend', onTouchEnd, { passive: true });
                navigationMapInstance.on('pitchend', (e) => {
                    if (e.originalEvent) { 
                        const newPitch = navigationMapInstance.getPitch();
                        if (Math.abs(newPitch - mapPitchValue) > 0.1) {
                            mapPitchValue = newPitch;
                            saveSettings();
                        }
                    }
                });
                navigationMapInstance._interactionListenersAttached = true; 
            }
            // ...
            
            navigationMapInstance.on('error', (e) => {
                if (e.error && e.error.message.includes("Token")) {
                    showToast("Error de Token de Mapbox. Revisa los permisos (scopes) en tu cuenta.", "error", 10000);
                }
            });
            
            navigationMapInstance.on('load', async function() {
                try {
                    const initToast = document.getElementById("map-init-toast");
                    if (initToast) initToast.remove();

                    await loadAndAddMapImages(navigationMapInstance);
                    reAddCustomMapLayersAndSources(navigationMapInstance);
                    
                    processTrafficAlerts();
                    
                    navigationMapInstance.on('pitch', updateLineWidthsOnPitchChange);
                    
                    mapPreviousZoomLevelForPDRs = navigationMapInstance.getZoom();
                    navigationMapInstance.on('zoomend', updateAllIconSizes);
                    navigationMapInstance.on('zoomend', updateTrafficAlertIconSizes);
                    toggleMapHeaderRowsVisibility(mapHeaderButtonsVisible);

                    navigationMapInstance.on('click', async (e) => {
                        // ... (tu cdigo de 'click' existente)
                    });
                    
                    enablePoiInteractivity(navigationMapInstance);
                    setNavigationMapClickHandler();
                    
                    // --- INICIO DE LA LGICA DE ANIMACIN Y LOCALIZACIN ---
                    
                    // 1. Animacin del Globo (siempre se ejecuta)
                    const globeSpinPromise = new Promise(resolve => {
                        const startCoords = { lat: 30.3715, lng: -97.1903 };
                        const endCoords = { lat: 40.3748, lng: -3.7354 };
                        const duration = 2500;
                        const directLngDiff = endCoords.lng - startCoords.lng;
                        const totalLngChange = -(360 - directLngDiff);
                        const totalLatChange = endCoords.lat - startCoords.lat;
                        const startTimestamp = performance.now();

                        function animateSpin(timestamp) {
                            const elapsedTime = timestamp - startTimestamp;
                            let progress = Math.min(elapsedTime / duration, 1);
                            progress = 1 - Math.pow(1 - progress, 3);
                            const currentLng = startCoords.lng + (totalLngChange * progress);
                            const currentLat = startCoords.lat + (totalLatChange * progress);
                            navigationMapInstance.setCenter([currentLng, currentLat]);
                            if (progress < 1) {
                                requestAnimationFrame(animateSpin);
                            } else {
                                navigationMapInstance.setCenter([endCoords.lng, endCoords.lat]);
                                resolve();
                            }
                        }
                        requestAnimationFrame(animateSpin);
                    });

                    // 2. Funcin para obtener GPS con reintentos
                    async function getGpsWithRetries() {
                        // Si ya tenemos la posicin, la devolvemos inmediatamente.
                        if (preloadedGpsPosition) {
                            return preloadedGpsPosition;
                        }
                        
                        // Si no, la buscamos activamente.
                        const toastId = "gps-locate-toast";
                        showToast("LOCALIZANDO VEHCULO...", "info", 0, false, toastId);
                        
                        while (true) {
                            try {
                                const coords = await getCurrentLocationAsync();
                                const loadingToast = document.getElementById(toastId);
                                if (loadingToast) loadingToast.remove();
                                return coords;
                            } catch (error) {
                                showToast(`No se pudo obtener la ubicacin. Reintentando en 3 segundos...`, "warning", 0, false, toastId);
                                await new Promise(resolve => setTimeout(resolve, 3000));
                            }
                        }
                    }

                    // 3. Ejecutamos la animacin Y la bsqueda de GPS en paralelo.
                    const [_, currentPos] = await Promise.all([
                        globeSpinPromise,
                        getGpsWithRetries()
                    ]);
                    
                    // 4. Cuando ambas terminan, volamos a la posicin del coche.
                    setMapImmersiveMode(false);
                    navigationFollowUser = true;
                    shouldCenterOnUser = true;
                    updateLocateMeButtonsUI();
                    toggleMapControls(true);
                    navigationCurrentLocation = currentPos;
                    updateInitialUserPosition(currentPos, navigationMapInstance);
                    
                    if (navigationMapInstance) {
                        navigationMapInstance.flyTo({
                            center: [currentPos.longitude, currentPos.latitude],
                            zoom: 17,
                            bearing: 0,
                            pitch: 50,
                            duration: 2300
                        });
                    }
                    startGpsWatching();
                    
                } catch (loadError) {
                    showToast(`Error crtico al cargar los recursos del mapa: ${loadError.message}`, "error", 10000);
                }
            });
        } catch (initError) {
             if (mapActualContainer) mapActualContainer.innerHTML = `<div style="color:red; text-align:center; padding:20px; background: rgba(0,0,0,0.7); height:100%; display:flex; align-items:center; justify-content:center; flex-direction:column;"><h2>Error al cargar el mapa</h2><p>${initError.message}</p><p style="margin-top:10px; font-size:0.9rem;">Por favor, revisa tu token de Mapbox y sus permisos (scopes).</p></div>`;
             isNavigationMapActive = false;
        }
    }
    
    assignMapButtonListeners();
    const lockButton = document.getElementById('toggle-progress-bar-lock');
    if (lockButton && !lockButton.dataset.listenerAttached) {
        lockButton.addEventListener('click', handleProgressBarLockToggle);
        lockButton.dataset.listenerAttached = 'true';
    }
    updateProgressBarLockIcon();
    
    const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresCheckbox) radaresCheckbox.checked = localStorage.getItem(RADARES_RUTA_CHECKED_KEY) === 'true';
    const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasCheckbox) tareasCheckbox.checked = localStorage.getItem(TAREAS_RUTA_CHECKED_KEY) === 'true';
    const mapboxCheckbox = document.getElementById('mapbox-primary-checkbox');
    if (mapboxCheckbox) mapboxCheckbox.checked = localStorage.getItem('boardinggate_useMapboxAsPrimary') === 'true';
    currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviacin ETA';
    mapViewMode = localStorage.getItem(MAP_VIEW_MODE_KEY) || 'static';
    isAutoZoomActive = localStorage.getItem(AUTO_ZOOM_ACTIVE_KEY) === 'true';
    const autoBtn = document.getElementById('zoom-auto-button');
    if (autoBtn) autoBtn.classList.toggle('active', isAutoZoomActive);
    toggleMapHeaderRowsVisibility(mapHeaderButtonsVisible);
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    toggleMapLocationSearchVisibility(!isNavigating);
}    

// ===================================================================
// NOMBRE: loadRouteFromObject (VERSIN FINAL Y ROBUSTA CONTRA MOVIMIENTO)
// RESUMEN: "Salva" la ubicacin GPS actual ANTES de limpiar, garantizando un reclculo fiable.
async function loadRouteFromObject(routeObject, autoStartNavigation = false) {
    if (!routeObject || !routeObject.waypoints) {
        showToast("Error: El objeto de la ruta es invlido.", "error");
        return;
    }

    if (isFreeDriveActive) {
        isFreeDrivePaused = true;
        isFreeDriveActive = false;
        showToast("Modo Conduccin Libre en pausa.", "info");
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        clearNavigationGraph();
    }

    const startLocation = navigationCurrentLocation ? { ...navigationCurrentLocation } : null;

    resetNavigationState();

    currentRouteNameForSaving = routeObject.name;
    
    // --- INICIO DE LA CORRECCIN CLAVE ---
    // En lugar de copiar todos los waypoints, preparamos la lista para usar solo los destinos.
    const waypointsFromLoadedRoute = routeObject.waypoints;
    // --- FIN DE LA CORRECCIN CLAVE ---

    if (isNavigationMapActive && startLocation) {
      
        const startPoint = {
            id: Date.now() - 1,
            lat: startLocation.latitude,
            lng: startLocation.longitude,
            type: 'S', marker: null,
            label: 'S',
            address: 'Posicin Actual (GPS)',
            visited: true,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false };
        
        navigationWaypoints = [startPoint];
        
        // --- INICIO DE LA MODIFICACIN CLAVE ---
        // Usamos .slice(1) para OMITIR el primer punto (el de partida original) de la ruta guardada.
        waypointsFromLoadedRoute.slice(1).forEach(wpData => {
            if (wpData) {
                navigationWaypoints.push({
                    id: wpData.id || Date.now() + Math.random(),
                    lat: wpData.lat, lng: wpData.lng, type: '', label: '', marker: null,
                    address: wpData.address || '', visited: false, isCriticalForRecalc: true,
                    isInternal: false, isRecalculatedStart: false
                });
            }
        });
        // --- FIN DE LA MODIFICACIN CLAVE ---

    } else {
        const isSingleDestinationRoute = routeObject.waypoints.length === 1;
        
        if (isSingleDestinationRoute && startLocation) {
             const startPoint = {
                id: Date.now() - 1, lat: startLocation.latitude, lng: startLocation.longitude,
                type: 'S', marker: null, label: 'S', address: 'Posicin Actual (GPS)', visited: true,
                isCriticalForRecalc: true, isInternal: false, isRecalculatedStart: false
            };
            navigationWaypoints.push(startPoint);
        }
        
        // --- INICIO DE LA MODIFICACIN CLAVE (PARA EL CASO 'ELSE') ---
        const waypointsToAdd = isSingleDestinationRoute ? waypointsFromLoadedRoute : waypointsFromLoadedRoute.slice(1);
        waypointsToAdd.forEach(wpData => {
            if (wpData) {
                navigationWaypoints.push({
                    id: wpData.id || Date.now() + Math.random(),
                    lat: wpData.lat,
                    lng: wpData.lng,
                    type: '', label: '', marker: null,
                    address: wpData.address || '', visited: false, isCriticalForRecalc: true,
                    isInternal: false, isRecalculatedStart: false
                });
            }
        });
        // --- FIN DE LA MODIFICACIN CLAVE ---
    }

    await updateWaypointTypesAndLabels();
    renderWaypointMarkers();

    if (navigationWaypoints.filter(wp => wp && !wp.isInternal).length >= 2) {
        recalculateAndDrawRoute(false).then(() => {
            if (autoStartNavigation) {
                if (navigationMapInstance && navigationMapInstance.getSource('route') && navigationMapInstance.getSource('route')._data) {
                    const routeGeoJSON = navigationMapInstance.getSource('route')._data;
                    if (routeGeoJSON.geometry && routeGeoJSON.geometry.coordinates.length > 1) {
                        const coordinates = routeGeoJSON.geometry.coordinates;
                        const bounds = new mapboxgl.LngLatBounds();
                        coordinates.forEach(coord => bounds.extend(coord));
                        if (!bounds.isEmpty()) {
                            mapPreviousZoomLevel = navigationMapInstance.getZoom();
                            navigationMapInstance.fitBounds(bounds, { padding: 80, animate: true, duration: 1500 });
                        }
                    }
                }
                const firstDestination = navigationWaypoints.find(wp => wp && !wp.isInternal && wp.type !== 'S' && !wp.visited);
                if (firstDestination) {
                    fetchAndDisplayAlternativeRoutes(firstDestination.id);
                }
                showAutoStartNavigationModal();
            }
        });
    }
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}
    
// ===================================================================
// NOMBRE: fetchAndRenderChatUsers (CON ESTADSTICAS COMPLETAS PARA ADMIN)
// RESUMEN: Muestra la lista de usuarios y, para el admin, estadsticas
async function fetchAndRenderChatUsers() {
    const usersListContainer = document.getElementById('chat-users-list');
    const messageInput = document.getElementById('chat-message-input');
    const filterInput = document.getElementById('chat-user-filter-input');
    
    if (!usersListContainer || !window.db || !messageInput || !filterInput) return;

    if (!filterInput.listenerAdded) {
        filterInput.addEventListener('input', fetchAndRenderChatUsers);
        filterInput.listenerAdded = true;
    }

    const isAdmin = (localStorage.getItem('userData_userId') || '').toLowerCase() === 'boardinggate';

    if (isAdmin) {
        // Obtenemos ambas estadsticas globales en paralelo para mayor eficiencia
        const [sessionStats, poiStats] = await Promise.all([
            getGlobalMapSessionStats(),
            getGlobalPoiStats()
        ]);

        let statsHeader = document.getElementById('chat-admin-stats-header');
        if (!statsHeader) {
            statsHeader = document.createElement('div');
            statsHeader.id = 'chat-admin-stats-header';
            statsHeader.className = 'chat-admin-stats-header';
            const filterContainer = document.getElementById('chat-users-filter-container');
            if (filterContainer) {
                filterContainer.insertAdjacentElement('afterend', statsHeader);
            }
        }
        // Mostramos ambas lneas de estadsticas
        statsHeader.innerHTML = `Sesiones-> Mes: ${sessionStats.totalMonth} | Total: ${sessionStats.totalHistoric}<br>POI Clics (Mes): ${poiStats.totalMonth}`;
        
        let maxSessionsControl = document.getElementById('chat-max-sessions-control');
        if (!maxSessionsControl) {
            maxSessionsControl = document.createElement('div');
            maxSessionsControl.id = 'chat-max-sessions-control';
            maxSessionsControl.style.cssText = 'padding: 8px; background-color: #3a3a3c; border-bottom: 1px solid #444; display: flex; align-items: center; justify-content: center; gap: 10px;';
            maxSessionsControl.innerHTML = `
                <label for="chat-max-sessions-input" style="font-weight: bold; color: #ffd700;">MXIMO SESIONES:</label>
                <input type="number" id="chat-max-sessions-input" style="width: 80px; text-align: center; background-color: #2c2c2e; border: 1px solid #555; color: #f0f0f0; border-radius: 4px;">
            `;
            statsHeader.insertAdjacentElement('afterend', maxSessionsControl);

            const maxSessionsInput = document.getElementById('chat-max-sessions-input');
            
            const localMaxSessions = localStorage.getItem(MAX_SESSIONS_KEY);
            if(localMaxSessions) {
                maxSessionsInput.value = localMaxSessions;
            } else {
                const adminDocRef = window.doc(window.db, "user_data", "boardinggate");
                window.getDoc(adminDocRef).then(docSnap => {
                    if (docSnap.exists() && docSnap.data().max_monthly_sessions) {
                        const maxSessions = docSnap.data().max_monthly_sessions;
                        maxSessionsInput.value = maxSessions;
                        localStorage.setItem(MAX_SESSIONS_KEY, maxSessions);
                    }
                });
            }

            maxSessionsInput.addEventListener('change', async () => {
                const newValue = parseInt(maxSessionsInput.value, 10);
                if (!isNaN(newValue) && newValue >= 0) {
                    localStorage.setItem(MAX_SESSIONS_KEY, newValue);
                    const adminDocRef = window.doc(window.db, "user_data", "boardinggate");
                    try {
                        await window.setDoc(adminDocRef, { max_monthly_sessions: newValue }, { merge: true });
                        showToast(`Lmite mximo de sesiones mensuales actualizado a ${newValue}.`, 'success');
                    } catch (error) {
                        showToast(`Error al guardar el lmite en la nube.`, 'error');
                    }
                }
            });
        }
    } else {
        const statsHeader = document.getElementById('chat-admin-stats-header');
        if (statsHeader) statsHeader.remove();
        const maxSessionsControl = document.getElementById('chat-max-sessions-control');
        if (maxSessionsControl) maxSessionsControl.remove();
    }
    
    try {
        const usersRef = window.collection(window.db, "user_data");
        const q = window.query(usersRef, window.where("rss", "==", true));
        const querySnapshot = await window.getDocs(q);
        
        const filterText = filterInput.value.toLowerCase();
        let usersData = [];

        querySnapshot.forEach(doc => {
            const userData = doc.data();
            const userId = userData.usuario || doc.id;
            usersData.push({ id: userId, ...userData });
        });

        usersData.sort((a, b) => a.id.localeCompare(b.id));

        usersListContainer.innerHTML = ''; 
        let userCount = 0;
        
        const now = new Date();
        const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        usersData.forEach(userData => {
            const userId = userData.id;

            const isBoardingGateAccount = userId.toLowerCase().includes('boardinggate');
            const isMainAdminAccount = userId.toLowerCase() === 'boardinggate';
            if (isBoardingGateAccount && !isMainAdminAccount) {
                return; 
            }

            const userString = `${userId} ${userData.modelo || ''} ${userData.anio || ''} ${userData.provincia || ''}`.toLowerCase();
            if (filterText && !userString.includes(filterText)) {
                return;
            }
            
            const userElement = document.createElement('div');
            userElement.className = 'chat-user-item';
            userElement.style.cursor = 'pointer';
            userElement.title = `Enviar mensaje privado a ${userId}`;

            userElement.addEventListener('click', () => {
                const currentText = messageInput.value;
                if (currentText.startsWith('@')) {
                    const existingMentionEndIndex = currentText.indexOf(' ');
                    if (existingMentionEndIndex !== -1) {
                        messageInput.value = `@${userId} ` + currentText.substring(existingMentionEndIndex + 1);
                    } else {
                        messageInput.value = `@${userId} `;
                    }
                } else {
                    messageInput.value = `@${userId} ` + currentText;
                }
                messageInput.focus();
                messageInput.dispatchEvent(new Event('input'));
            });

            const userName = document.createElement('span');
            userName.className = 'chat-user-name';
            userName.textContent = userId;
            
            const userDetails = document.createElement('span');
            userDetails.className = 'chat-user-details';
            const detailsParts = [];
            if (userData.modelo) detailsParts.push(userData.modelo);
            if (userData.anio) detailsParts.push(userData.anio);
            if (userData.provincia) detailsParts.push(userData.provincia);
            userDetails.textContent = `(${detailsParts.join(', ')})`;

            if (isAdmin) {
                const userMonthSessions = (userData.map_sessions_last_month === currentMonthStr) ? (userData.map_sessions_month || 0) : 0;
                const userTotalSessions = userData.map_sessions_total || 0;
                const userPoiClicks = (userData.poi_clicks_last_month === currentMonthStr) ? (userData.poi_clicks_month || 0) : 0;
                
                const statsSpan = document.createElement('span');
                statsSpan.className = 'chat-user-session-stats';
                statsSpan.textContent = `(Sesiones Mes: ${userMonthSessions} | POI: ${userPoiClicks} | Sesiones Total: ${userTotalSessions})`;
                userDetails.appendChild(statsSpan);
            }
            
            userElement.appendChild(userName);
            userElement.appendChild(userDetails);
            usersListContainer.appendChild(userElement);
            userCount++;
        });

        if (userCount === 0) {
            usersListContainer.innerHTML = '<p class="chat-no-users">No hay usuarios que coincidan con el filtro.</p>';
        }

    } catch (error) {
        console.error("Error al renderizar usuarios del chat:", error);
        usersListContainer.innerHTML = '<p class="chat-no-users">Error al cargar usuarios.</p>';
    }
}

// ===================================================================
// NOMBRE: handleProgressiveManeuverZoom (VERSIN FINAL CON CORRECCIN DE MBITO)
// RESUMEN: Incluye mejoras y correccin del bug de estado. Ahora recibe
//          carDistanceAlongRouteForNavLogic como argumento para funcionar correctamente.
// ===================================================================

// --- INICIO: Funciones de Ayuda para la lgica de zoom ---
const easeInOutQuad = t => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

function findNextValidStep(route, currentLeg, currentStep) {
    let legIndex = currentLeg;
    let stepIndex = currentStep + 1;
    const waypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal);

    while (legIndex < route.legs.length) {
        const leg = route.legs[legIndex];
        if (stepIndex >= leg.steps.length) {
            legIndex++;
            stepIndex = 0;
            continue;
        }
        const candidateStep = leg.steps[stepIndex];
        const isArrival = candidateStep.maneuver.type === 'arrive';
        const arrivalWaypoint = isArrival ? waypoints[legIndex + 1] : null;
        if (isArrival && arrivalWaypoint && arrivalWaypoint.isInternal) {
            stepIndex++;
            continue; 
        }
        return { step: candidateStep, legIndex: legIndex, stepIndex: stepIndex };
    }
    return null;
}
// --- FIN: Funciones de Ayuda ---

// <<< CAMBIO CLAVE AQU: Se aade el nuevo argumento 'carDistanceAlongRouteForNavLogic' >>>
function handleProgressiveManeuverZoom(currentStep, distanceToManeuver, carDistanceAlongRouteForNavLogic) {
    if (isManualZoomActive) return null;

    if (!isNavigating || !navigationMapInstance || !currentStep) {
        if (isZoomedForManeuver) isZoomedForManeuver = false;
        return null;
    }
    
    const route = navigationCurrentRouteData?.routes?.[0];
    if (!route) return null;

    const maxZoomForMap = navigationMapInstance.getMaxZoom() || 19;
    const currentMapLayerName = (localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "satlite + calles").toLowerCase();
    const isSatelliteWithLabels = currentMapLayerName.includes("satlite + calles");
    const MANEUVER_PEAK_ZOOM_LEVEL = isSatelliteWithLabels ? Math.min(17.5, maxZoomForMap) : Math.min(18.5, maxZoomForMap);
    const HOLD_ZOOM_THRESHOLD = 250;
    
    const currentStepIdentifier = `${currentLegIndexNav}_${currentStepIndexNav}`;
    if (lastProcessedStepIdentifier !== null && lastProcessedStepIdentifier !== currentStepIdentifier) {
        if (progressiveZoomState === 'zooming-in' || progressiveZoomState === 'holding') {
            progressiveZoomState = 'zooming-out';
        }
    }
    lastProcessedStepIdentifier = currentStepIdentifier;

    const distanceIntoCurrentStep = currentStep.distance - distanceToManeuver;
    let targetZoom = null;

    switch (progressiveZoomState) {
        case 'zooming-out':
            isZoomedForManeuver = true;
            const nextStepAfterCurrent = findNextValidStep(route, currentLegIndexNav, currentStepIndexNav);
            
            // <<< CAMBIO CLAVE AQU: Se usa el nuevo argumento >>>
            const distanceToNextStep = nextStepAfterCurrent ? calculateDistanceToEndOfStep(route, nextStepAfterCurrent.legIndex, nextStepAfterCurrent.stepIndex) - carDistanceAlongRouteForNavLogic : Infinity;
            
            if (nextStepAfterCurrent && distanceToNextStep < HOLD_ZOOM_THRESHOLD) {
                targetZoom = MANEUVER_PEAK_ZOOM_LEVEL;
            } else {
                if (distanceIntoCurrentStep > PROGRESSIVE_ZOOM_EXIT_END_DISTANCE || mapPreviousZoomLevelForProgressive === null) {
                    targetZoom = mapPreviousZoomLevelForProgressive;
                    progressiveZoomState = 'none';
                    mapPreviousZoomLevelForProgressive = null;
                    isZoomedForManeuver = false;
                } else if (distanceIntoCurrentStep >= PROGRESSIVE_ZOOM_EXIT_START_DISTANCE) {
                    const progress = (distanceIntoCurrentStep - PROGRESSIVE_ZOOM_EXIT_START_DISTANCE) / (PROGRESSIVE_ZOOM_EXIT_END_DISTANCE - PROGRESSIVE_ZOOM_EXIT_START_DISTANCE);
                    targetZoom = MANEUVER_PEAK_ZOOM_LEVEL - (MANEUVER_PEAK_ZOOM_LEVEL - mapPreviousZoomLevelForProgressive) * Math.min(1, progress);
                } else {
                    targetZoom = MANEUVER_PEAK_ZOOM_LEVEL;
                }
            }
            break;

        default:
            if (distanceToManeuver <= PROGRESSIVE_ZOOM_START_DISTANCE && distanceToManeuver > PROGRESSIVE_ZOOM_PEAK_DISTANCE) {
                if (progressiveZoomState !== 'zooming-in' && progressiveZoomState !== 'holding') {
                    mapPreviousZoomLevelForProgressive = navigationMapInstance.getZoom();
                }
                progressiveZoomState = 'zooming-in';
                let progress = (PROGRESSIVE_ZOOM_START_DISTANCE - distanceToManeuver) / (PROGRESSIVE_ZOOM_START_DISTANCE - PROGRESSIVE_ZOOM_PEAK_DISTANCE);
                progress = easeInOutQuad(progress);
                targetZoom = mapPreviousZoomLevelForProgressive + (MANEUVER_PEAK_ZOOM_LEVEL - mapPreviousZoomLevelForProgressive) * progress;
                isZoomedForManeuver = true;
            } else if (distanceToManeuver <= PROGRESSIVE_ZOOM_PEAK_DISTANCE) {
                if (progressiveZoomState !== 'holding' && mapPreviousZoomLevelForProgressive === null) {
                    mapPreviousZoomLevelForProgressive = navigationMapInstance.getZoom();
                }
                progressiveZoomState = 'holding';
                targetZoom = MANEUVER_PEAK_ZOOM_LEVEL;
                isZoomedForManeuver = true;
            } else {
                if (progressiveZoomState !== 'none' && mapPreviousZoomLevelForProgressive !== null) {
                    targetZoom = mapPreviousZoomLevelForProgressive;
                }
                progressiveZoomState = 'none';
                mapPreviousZoomLevelForProgressive = null;
                isZoomedForManeuver = false;
            }
            break;
    }
    return targetZoom;
}    
// ===================================================================
// NOMBRE: clearModalAutoCloseTimer
// RESUMEN: Limpia un temporizador de autocierre de un modal.
function clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId) {
    const timerIdToClear = modalId || (modalElement ? modalElement.dataset.modalTimerId : null);
    if (timerIdToClear && globalModalTimers[timerIdToClear]) {
        clearInterval(globalModalTimers[timerIdToClear].intervalId);
        const timerData = globalModalTimers[timerIdToClear];
        if (timerData.modalElement && timerData.resetHandler) {
            timerData.modalElement.removeEventListener('click', timerData.resetHandler);
            timerData.modalElement.removeEventListener('touchstart', timerData.resetHandler);
            timerData.modalElement.removeEventListener('input', timerData.resetHandler);
            timerData.modalElement.removeEventListener('scroll', timerData.resetHandler);
        }
        if (timerData.countdownSpan && timerData.countdownSpan.parentNode) {
            timerData.countdownSpan.remove();
        }
        delete globalModalTimers[timerIdToClear];
    }
    if(closeButtonElement){
        const orphanSpans = closeButtonElement.querySelectorAll('.button-countdown-timer');
        orphanSpans.forEach(s => s.remove());
    }
     if(modalElement && modalElement.dataset.modalTimerId) {
        delete modalElement.dataset.modalTimerId;
    }
}
    
// ===================================================================
// NOMBRE: eliminarTareasDeBarraProgreso (MODIFICADA - PARA MAPBOX)
// RESUMEN: Limpia tareas de la barra de progreso Y del mapa.
function eliminarTareasDeBarraProgreso() {
    eliminarTareasDeMapa(); 
    tareasEnRutaActual = [];
    actualizarContadorTareas(0);
    if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
        completedSegmentsGeoJSON.features = [];
        if (navigationMapInstance && navigationMapInstance.getSource('completed-segments')) {
            navigationMapInstance.getSource('completed-segments').setData(completedSegmentsGeoJSON);
        }
        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
}

// ===================================================================
// NOMBRE: toggleMapHeaderRowsVisibility (CORREGIDA v2 - ANTI TYPEERROR)
// RESUMEN: Muestra/oculta la cabecera y llama a map.resize() de forma segura.
function toggleMapHeaderRowsVisibility(show) {
    const header = document.getElementById('reminders-location-map-header');
    if (!header) return;

    const togglePanel = document.getElementById('toggle-map-header-buttons-panel');

    const removeCountdownOverlay = () => {
        if (togglePanel) {
            const existingOverlay = togglePanel.querySelector('#map-header-countdown-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
        }
    };

    if (mapHeaderAutohideTimer) {
        clearInterval(mapHeaderAutohideTimer);
        mapHeaderAutohideTimer = null;
    }
    removeCountdownOverlay();

    if (isNavigating && show) {
        mapHeaderButtonsVisible = true;
        header.querySelectorAll('.button-row').forEach(row => {
            row.classList.remove('hidden-map-header');
        });

        if (togglePanel) {
            const countdownOverlay = document.createElement('span');
            countdownOverlay.id = 'map-header-countdown-overlay';
            countdownOverlay.style.cssText = `
                position: absolute;
                top: 50%; left: 50%;
                transform: translate(-50%, -50%);
                font-size: 48px; font-weight: bold;
                color: rgba(189, 150, 24, 0.7);
                z-index: 10; pointer-events: none;
                text-shadow: 2px 2px 3px rgba(0,0,0,0.6);
            `;
            togglePanel.appendChild(countdownOverlay);

            let countdown = 20;
            countdownOverlay.textContent = countdown;

            mapHeaderAutohideTimer = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownOverlay.textContent = countdown;
                } else {
                    clearInterval(mapHeaderAutohideTimer);
                    mapHeaderAutohideTimer = null;
                    removeCountdownOverlay();
                    if (mapHeaderButtonsVisible) {
                       toggleMapHeaderRowsVisibility(false);
                    }
                }
            }, 1000);
        }
    } else {
        mapHeaderButtonsVisible = show;
        header.querySelectorAll('.button-row').forEach(row => {
            row.classList.toggle('hidden-map-header', !show);
        });
    }
    
    if (navigationMapInstance) {
        setTimeout(() => {
            const mapContainer = document.getElementById('mapbox-map-actual-container');
            if (navigationMapInstance && mapContainer && mapContainer.offsetHeight > 0) {
                try {
                    navigationMapInstance.resize();
                } catch(e) {
                    console.error("Error al redimensionar el mapa (dentro del timeout):", e);
                }
            }
        }, 350);
    }
}    


    
// ===================================================================
// NOMBRE: eliminarRadaresDeRuta (MODIFICADA - PARA MAPBOX)
// RESUMEN: Elimina del mapa los radares que se haban aadido dinmicamente a la ruta.
function eliminarRadaresDeRuta() {
    reminderMapObjects = reminderMapObjects.filter(obj => {
        if (obj.isFromRuta) {
            if (obj.marker) obj.marker.remove();
            if (obj.circleId && navigationMapInstance.getLayer(obj.circleId)) {
                navigationMapInstance.removeLayer(obj.circleId);
            }
            if (obj.circleId && navigationMapInstance.getSource(obj.circleId)) {
                navigationMapInstance.removeSource(obj.circleId);
            }
            return false;
        }
        return true;
    });
    radaresEnRutaActual = [];
    actualizarContadorRadares(0);
    if (navigationCurrentRouteData?.routes?.[0]) { 
        completedSegmentsGeoJSON.features = [];
        if (navigationMapInstance && navigationMapInstance.getSource('completed-segments')) {
            navigationMapInstance.getSource('completed-segments').setData(completedSegmentsGeoJSON);
        }
        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
}
// ===================================================================
// NOMBRE: handleZoomToggleButtonClick (VERSIN DE DEPURACIN CON CONSOLE.LOG)
// ===================================================================
function handleZoomToggleButtonClick(button) {
    if (!navigationMapInstance || !button) return;


    const currentState = button.dataset.zoomState || 'waypoints';
    
    if (currentState === 'car') { 
        
        const currentZoom = navigationMapInstance.getZoom();
        zoomToggleMemory = currentZoom;
        triggerManualMapInteraction();
        
        const newState = 'waypoints';
        button.dataset.zoomState = newState;
        const img = button.querySelector('img');
        if (img) img.src = 'PNG/ZOOM+.PNG';
        button.title = "Acercar a la ubicacin del coche";
        const otherButtonId = button.id === 'zoom-toggle-button' ? 'nav-map-zoomtoggle-button' : 'zoom-toggle-button';
        const otherButton = document.getElementById(otherButtonId);
        if (otherButton) {
            otherButton.dataset.zoomState = newState;
            const otherImg = otherButton.querySelector('img');
            if (otherImg) otherImg.src = 'PNG/ZOOM+.PNG';
            otherButton.title = "Acercar a la ubicacin del coche";
        }
        
        const routeSource = navigationMapInstance.getSource('route');
        if (routeSource && routeSource._data && routeSource._data.geometry && routeSource._data.geometry.coordinates.length > 1) {
            const coordinates = routeSource._data.geometry.coordinates;
            const bounds = new mapboxgl.LngLatBounds();
            coordinates.forEach(coord => bounds.extend(coord));
            if (!bounds.isEmpty()) {
                navigationMapInstance.fitBounds(bounds, { padding: 80, animate: true, duration: 1500 });
            }
        } else {
            navigationMapInstance.flyTo({ zoom: 10, duration: 1500 });
        }

    } else { 
        triggerManualMapInteraction();
        
        if (navigationCurrentLocation) {
            const newState = 'car';
            button.dataset.zoomState = newState;
            const img = button.querySelector('img');
            if (img) img.src = 'PNG/ZOOM-.PNG';
            button.title = "Alejar para ver la ruta completa";
            const otherButtonId = button.id === 'zoom-toggle-button' ? 'nav-map-zoomtoggle-button' : 'zoom-toggle-button';
            const otherButton = document.getElementById(otherButtonId);
            if (otherButton) {
                otherButton.dataset.zoomState = newState;
                const otherImg = otherButton.querySelector('img');
                if (otherImg) otherImg.src = 'PNG/ZOOM-.PNG';
                otherButton.title = "Alejar para ver la ruta completa";
            }
                        
            navigationMapInstance.flyTo({ 
                center: [navigationCurrentLocation.longitude, navigationCurrentLocation.latitude], 
                zoom: zoomToggleMemory || 19, 
                duration: 1500 
            });
            
            zoomToggleMemory = null; 
        
        } else {
            showToast("Ubicacin actual no disponible para hacer zoom.", "warning");
        }
        }
}    
// ===================================================================
// NOMBRE: showPDRsFilterModal (MODIFICADA - PARA MAPBOX)
// RESUMEN: Muestra un modal de filtro que se adapta si hay o no una ruta cargada.
function showPDRsFilterModal() {
    const mapContainer = document.getElementById('reminders-location-map-modal');
    if (!mapContainer || !navigationMapInstance) {
        showToast("El mapa de navegacin debe estar abierto para usar los filtros.", "error");
        return;
    }

    const hasRoute = navigationMapInstance.getSource('route') && 
                     navigationMapInstance.getSource('route')._data &&
                     navigationMapInstance.getSource('route')._data.geometry &&
                     navigationMapInstance.getSource('route')._data.geometry.coordinates &&
                     navigationMapInstance.getSource('route')._data.geometry.coordinates.length > 1;

    const PDR_MIN_POWER_KEY = 'boardinggate_pdrFilterMinPower';
    const PDR_MAX_POWER_KEY = 'boardinggate_pdrFilterMaxPower';
    const PDR_DISTANCE_KEY = 'boardinggate_pdrFilterDistance';
    const PDR_RADIUS_KEY = 'boardinggate_pdrFilterRadius';

    const savedMinPower = parseInt(localStorage.getItem(PDR_MIN_POWER_KEY)) || 30;
    const savedMaxPower = parseInt(localStorage.getItem(PDR_MAX_POWER_KEY)) || 600;
    const savedDistance = parseInt(localStorage.getItem(PDR_DISTANCE_KEY)) || 20;
    const savedRadius = parseInt(localStorage.getItem(PDR_RADIUS_KEY)) || 15;
    let distanceControlHtml;
    if (hasRoute) {
        distanceControlHtml = `
            <div id="distance-slider-container" class="filter-group">
                <label id="distance-range-label">Distancia Mxima a la Ruta: ${savedDistance} km</label> 
                <div class="slider-container single-slider-container">
                    <div class="slider-track"></div>
                    <div class="slider-range" id="distance-slider-range"></div>
                    <div class="slider-thumb" id="distance-thumb"></div>
                </div>
            </div>`;
    } else {
        distanceControlHtml = `
            <div id="radius-slider-container" class="filter-group">
                <label id="radius-range-label">Radio de Bsqueda: ${savedRadius} km</label> 
                <div class="slider-container single-slider-container">
                    <div class="slider-track"></div>
                    <div class="slider-range" id="radius-slider-range"></div>
                    <div class="slider-thumb" id="radius-thumb"></div>
                </div>
            </div>`;
    }

    const existingModal = document.getElementById('pdrs-filter-modal-overlay');
    if (existingModal) existingModal.remove();

    const savedOperatorFilter = localStorage.getItem('boardinggate_operator_filter') || '';
    const modalOverlay = document.createElement('div');
    modalOverlay.id = 'pdrs-filter-modal-overlay';
    modalOverlay.className = 'filter-modal-overlay';
    
    modalOverlay.innerHTML = `
        <div class="filter-modal-content" style="background-color: #E6D6A8; color: #333;">
            <h2 style="color: #111;">FILTRO PUNTOS DE CARGA</h2>
            <div class="filter-group">
                <label for="operator-filter-input" style="font-weight:bold;">Filtrar operadores:</label>
                <div style="position: relative; width: 90%; margin: 5px auto 0 auto;">
                    <input type="text" id="operator-filter-input" value="${savedOperatorFilter}" placeholder="Ej: Zunder Iberdrola" style="width: 100%; padding: 8px 30px 8px 8px; font-size: 1rem; border-radius: 4px; border: 1px solid #aaa; background-color: #f0f0e0;">
                    <button id="clear-operator-filter" title="Limpiar filtro de operadores" style="position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 1.5rem; color: #888; cursor: pointer; padding: 0 5px; display: none;"></button>
                </div>
            </div>
            <div class="filter-group">
                <label id="power-range-label" style="font-weight:bold;">Potencia: ${savedMinPower} kW - ${savedMaxPower} kW</label> 
                <div class="slider-container">
                    <div class="slider-track"></div>
                    <div class="slider-range" id="power-slider-range"></div>
                    <div class="slider-thumb left" id="power-thumb-min"></div>
                    <div class="slider-thumb right" id="power-thumb-max"></div>
                </div>
            </div>
            
            <div class="ocm-color-legend">
                <div class="ocm-color-legend-item">
                    <div class="ocm-color-legend-icon" style="border-color: black;"></div>
                    <span>50kW</span>
                </div>
                <div class="ocm-color-legend-item">
                    <div class="ocm-color-legend-icon" style="border-color: green;"></div>
                    <span>100kW</span>
                </div>
                <div class="ocm-color-legend-item">
                    <div class="ocm-color-legend-icon" style="border-color: rgb(30, 144, 255);"></div>
                    <span>250kW</span>
                </div>
                <div class="ocm-color-legend-item">
                    <div class="ocm-color-legend-icon" style="border-color: #de2e03;"></div>
                    <span>>250kW</span>
                </div>
            </div>

            ${distanceControlHtml}
            
            <div class="filter-group" style="text-align: left; margin-top: 20px;">
                <label id="search-in-view-label" style="display: flex; align-items: center; cursor: pointer; font-size: 1.1rem; user-select: none; transition: opacity 0.3s;">
                    <input type="checkbox" id="search-in-view-checkbox" style="width: 1.2rem; height: 1.2rem; margin-right: 10px; flex-shrink: 0;">
                    Buscar en la zona del mapa que ests viendo ahora
                </label>
            </div>

            <button id="accept-filters-btn" style="background-color: #2563EB;">Aceptar</button>

            <div class="ocm-modal-info-footer">
                <p><strong>(*) Cmo buscar:</strong> Si hay una ruta cargada, la bsqueda por defecto es sobre el trazado. Si no hay ruta, en un radio desde el centro. Para buscar siempre en la vista actual, marque la casilla superior.</p>
                <p><strong>(*) Secuencia del botn:</strong> <strong>1 Pulsacin:</strong> Abre filtros. | <strong>2 Pulsacin:</strong> Muestra solo los ms econmicos. | <strong>3 Pulsacin:</strong> Limpia el mapa de PDRs.</p>
                <p style="margin-top:10px; font-style:italic;">Datos proporcionados por <a href="https://openchargemap.org" target="_blank" style="color:#0056b3; text-decoration:underline;">Open Charge Map</a>.</p>
            </div>
        </div>
    `;

    mapContainer.appendChild(modalOverlay);
    
    const PDR_SEARCH_IN_VIEW_KEY = 'boardinggate_pdrSearchInView';
    const searchInViewCheckbox = document.getElementById('search-in-view-checkbox');
    const distanceSliderContainer = document.getElementById('distance-slider-container') || document.getElementById('radius-slider-container');
    
    const updateControlsState = () => {
        if (searchInViewCheckbox.checked) {
            distanceSliderContainer.style.opacity = '0.5';
            distanceSliderContainer.style.pointerEvents = 'none';
        } else {
            distanceSliderContainer.style.opacity = '1';
            distanceSliderContainer.style.pointerEvents = 'auto';
        }
    };
    
    const savedSearchInView = localStorage.getItem(PDR_SEARCH_IN_VIEW_KEY) === 'true';
    searchInViewCheckbox.checked = savedSearchInView;
    searchInViewCheckbox.addEventListener('change', () => {
        localStorage.setItem(PDR_SEARCH_IN_VIEW_KEY, searchInViewCheckbox.checked);
        updateControlsState();
    });
    
    updateControlsState();

    const operatorInput = document.getElementById('operator-filter-input');
    const clearOperatorButton = document.getElementById('clear-operator-filter');
    
    const toggleClearButtonVisibility = () => {
        clearOperatorButton.style.display = operatorInput.value.trim() ? 'block' : 'none';
    };

    operatorInput.addEventListener('input', toggleClearButtonVisibility);
    clearOperatorButton.addEventListener('click', () => {
        operatorInput.value = '';
        toggleClearButtonVisibility();
        operatorInput.focus();
    });
    toggleClearButtonVisibility();

    const setupSlider = (idPrefix, minVal, maxVal, defaultMin, defaultMax, unit, isRange = true) => {
        const thumbMax = document.getElementById(`${idPrefix}-thumb` + (isRange ? '-max' : ''));
        if (!thumbMax) return () => ({ min: 0, max: 0 });
        const container = thumbMax.parentElement;
        const range = document.getElementById(`${idPrefix}-slider-range`);
        const label = document.getElementById(`${idPrefix}-range-label`);
        const thumbMin = isRange ? document.getElementById(`${idPrefix}-thumb-min`) : null;
        let currentMin = defaultMin; 
        let currentMax = defaultMax;

        const updateVisuals = () => {
            const minPercent = isRange ? ((currentMin - minVal) / (maxVal - minVal)) * 100 : 0;
            const maxPercent = ((currentMax - minVal) / (maxVal - minVal)) * 100;
            
            if (isRange && thumbMin) thumbMin.style.left = `${minPercent}%`;
            thumbMax.style.left = `${maxPercent}%`;
            range.style.left = `${minPercent}%`;
            range.style.width = `${maxPercent - minPercent}%`;
            
            if(isRange){
                label.textContent = `Potencia: ${Math.round(currentMin)} ${unit} - ${Math.round(currentMax)} ${unit}`;
            } else {
                label.textContent = `${hasRoute ? 'Distancia Mxima a la Ruta' : 'Radio de Bsqueda'}: ${Math.round(currentMax)} ${unit}`;
            }
        };

        const onDrag = (e, thumb) => {
            const rect = container.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let percent = ((clientX - rect.left) / rect.width) * 100;
            percent = Math.max(0, Math.min(100, percent));
            
            let value = minVal + (percent / 100) * (maxVal - minVal);
            
            if (isRange && thumb === thumbMin) {
                currentMin = Math.min(value, currentMax);
            } else {
                currentMax = isRange ? Math.max(value, currentMin) : value;
            }
            updateVisuals();
        };

        const thumbsToSetup = isRange ? [thumbMin, thumbMax] : [thumbMax];
        thumbsToSetup.forEach(thumb => {
            const startDrag = (e) => {
                const moveHandler = (moveEvent) => onDrag(moveEvent, thumb);
                const endDrag = () => {
                    document.removeEventListener('mousemove', moveHandler);
                    document.removeEventListener('mouseup', endDrag);
                    document.removeEventListener('touchmove', moveHandler);
                    document.removeEventListener('touchend', endDrag);
                };
                document.addEventListener('mousemove', moveHandler);
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchmove', moveHandler);
                document.addEventListener('touchend', endDrag);
            };
            thumb.addEventListener('mousedown', startDrag);
            thumb.addEventListener('touchstart', startDrag);
        });
        
        updateVisuals();
        return () => ({ min: isRange ? currentMin : minVal, max: currentMax });
    };

    const getPowerValues = setupSlider('power', 7, 2000, savedMinPower, savedMaxPower, 'kW', true);
    const getDistanceValues = hasRoute ? setupSlider('distance', 0, 50, 0, savedDistance, 'km', false) : () => ({});
    const getRadiusValues = !hasRoute ? setupSlider('radius', 1, 100, 1, savedRadius, 'km', false) : () => ({});

    const acceptButton = document.getElementById('accept-filters-btn');
    acceptButton.addEventListener('click', () => {
        const operatorFilterValue = document.getElementById('operator-filter-input').value;
        localStorage.setItem('boardinggate_operator_filter', operatorFilterValue);

        const powerFilters = getPowerValues();
        localStorage.setItem(PDR_MIN_POWER_KEY, Math.round(powerFilters.min));
        localStorage.setItem(PDR_MAX_POWER_KEY, Math.round(powerFilters.max));

        let searchConfig;
        if (hasRoute) {
            const distanceFilters = getDistanceValues();
            localStorage.setItem(PDR_DISTANCE_KEY, Math.round(distanceFilters.max));
            searchConfig = { type: 'route', distanceFilters };
        } else {
            const radiusFilters = getRadiusValues();
            localStorage.setItem(PDR_RADIUS_KEY, Math.round(radiusFilters.max));
            searchConfig = { type: 'radius', radiusKm: radiusFilters.max, center: navigationMapInstance.getCenter() };
        }
        
        if (navigationFollowUser) {
            const locateMeButton = document.getElementById('locate-me-on-reminders-map');
            if (locateMeButton) {
                handleLocateMeClick(locateMeButton);
                showToast('Seguimiento pausado por 1 minuto para explorar el mapa.', 'info', 4000);
                if (window.followMeReactivationTimer) {
                    clearTimeout(window.followMeReactivationTimer);
                }
                window.followMeReactivationTimer = setTimeout(() => {
                    if (!navigationFollowUser) {
                        handleLocateMeClick(locateMeButton);
                        showToast('Seguimiento automtico reactivado.', 'info');
                    }
                    window.followMeReactivationTimer = null;
                }, 60000);
            }
        }

        modalOverlay.remove();
        findChargingPointsOnRoute(powerFilters, searchConfig);
    });

    addModalAutoCloseTimer(modalOverlay, acceptButton, 'pdrs-filter-modal', 20000);
}

// ===================================================================
// NOMBRE: handleTouchCancel
// RESUMEN: Maneja la cancelacin de un arrastre tctil.
function handleTouchCancel(e) {    if (!isEditMode) return;     handleTouchEndCleanup(); 
}
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// NOMBRE: openLocationsPreviewMap (VERSIN FINAL CON FILTRO CORREGIDO)
// RESUMEN: Abre un mapa modal satlite y dibuja TODOS los marcadores de forma eficiente, corrigiendo el error de sintaxis en el filtro de la capa de texto.
function openLocationsPreviewMap() {
    closeOtherModals('locations-preview-modal');
    document.body.classList.add('modal-open');

    let modal = document.getElementById('locations-preview-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'locations-preview-modal';
        modal.innerHTML = `
            <h2 id="locations-preview-title">Ubicaciones con Recordatorios</h2>
            <div id="locations-preview-map-container" style="height: calc(100% - 100px); width: 100%;"></div>
            <div class="modal-top-buttons" style="justify-content: center; margin-top: 1rem;">
                <button id="close-locations-preview">Salir</button>
            </div>
        `;
        document.body.appendChild(modal);
    }
    
    modal.classList.remove('hidden');
    const mapContainerEl = modal.querySelector('#locations-preview-map-container');
    const closeButton = modal.querySelector('#close-locations-preview');
    const titleElement = modal.querySelector('#locations-preview-title');
    
    const closeHandler = () => {
        if (locationsPreviewMap) {
            try { locationsPreviewMap.remove(); } catch (e) {}
            locationsPreviewMap = null;
        }
        locationsPreviewMapObjects = [];
        clearModalAutoCloseTimer(modal, closeButton, 'locations-preview-modal');
        modal.classList.add('hidden');
        document.body.classList.remove('modal-open');
    };

    const newCloseButton = closeButton.cloneNode(true);
    closeButton.parentNode.replaceChild(newCloseButton, closeButton);
    newCloseButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(modal, newCloseButton, 'locations-preview-modal', 120000);

    if (locationsPreviewMap) {
        try { locationsPreviewMap.remove(); } catch (e) {}
    }
    
    locationsPreviewMap = new mapboxgl.Map({
        container: mapContainerEl,
        style: 'mapbox://styles/mapbox/satellite-streets-v12', 
        center: [-3.703790, 40.416775],
        zoom: 6,
        attributionControl: true 
    });

    const plotAllLocations = async () => {
        await loadAndAddMapImages(locationsPreviewMap);

        const allReminders = JSON.parse(localStorage.getItem('reminders') || '[]').map(r => ({ ...r }));
        const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
        let locationsToPlot = allReminders.filter(r => {
            const hasLocation = r.isLocationEnabled && r.locationCoordinates?.latitude && r.locationCoordinates?.longitude;
            if (!hasLocation) return false;
            return showExcluded ? true : !r.excludeFromList;
        });

        if (titleElement) {
            titleElement.textContent = `Ubicaciones con Recordatorios ${showExcluded ? '(incl. Radares)' : '(sin Radares)'}`;
        }

        const geojsonFeatures = locationsToPlot.map(reminder => {
            const isRadar = reminder.text.toUpperCase().includes("RADAR") || reminder.excludeFromList;
            const speed = isRadar ? extractSpeedFromRadarText(reminder.text) : null;
            
            const properties = {
                reminderId: reminder.id,
                isRadar: isRadar,
                isFromTarea: reminder.isFromTarea || false,
            };
            if (speed !== null) {
                properties.speed = String(speed);
            }

            return {
                type: 'Feature',
                geometry: {
                    type: 'Point',
                    coordinates: [reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]
                },
                properties: properties
            };
        });

        const geojsonData = {
            type: 'FeatureCollection',
            features: geojsonFeatures
        };

        const sourceId = 'locations-preview-source';
        if (locationsPreviewMap.getSource(sourceId)) {
            locationsPreviewMap.getSource(sourceId).setData(geojsonData);
        } else {
            locationsPreviewMap.addSource(sourceId, { type: 'geojson', data: geojsonData });
        }

        const layers = [
            { id: 'preview-circles', type: 'circle', filter: ['==', 'isRadar', true], paint: {'circle-color': 'red', 'circle-radius': 15, 'circle-stroke-width': 2, 'circle-stroke-color': 'white'} },
            { id: 'preview-speed-text', type: 'symbol', filter: ['all', ['==', 'isRadar', true], ['has', 'speed']], layout: {'text-field': '{speed}', 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 12, 'text-allow-overlap': true}, paint: {'text-color': 'yellow'} },
            { id: 'preview-radar-text', type: 'symbol', filter: ['all', ['==', 'isRadar', true], ['!has', 'speed']], layout: { 'text-field': 'Rdar', 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 10, 'text-allow-overlap': true}, paint: { 'text-color': 'yellow'} },
            { id: 'preview-reminder-icons', type: 'symbol', filter: ['==', 'isRadar', false], layout: {'icon-image': 'reminder-icon', 'icon-size': 0.7, 'icon-allow-overlap': true, 'icon-anchor': 'bottom'} }
        ];

        layers.forEach(layer => {
            if (!locationsPreviewMap.getLayer(layer.id)) {
                locationsPreviewMap.addLayer({ ...layer, source: sourceId });
            }
        });
        
        setTimeout(() => {
            if (!locationsPreviewMap) return; 
            if (geojsonFeatures.length > 0) {
                const bounds = new mapboxgl.LngLatBounds();
                geojsonFeatures.forEach(feature => {
                    bounds.extend(feature.geometry.coordinates);
                });
                if (!bounds.isEmpty()) {
                    try {
                        locationsPreviewMap.fitBounds(bounds, { padding: 50, duration: 0 });
                    } catch(e) {
                        console.error("Error al ejecutar fitBounds en el modal de vista previa:", e);
                    }
                }
            } else {
                showToast(`No hay recordatorios con ubicacin para mostrar segn el filtro actual.`, "info");
            }
        }, 100);

        const interactiveLayers = ['preview-circles', 'preview-reminder-icons'];
        locationsPreviewMap.on('click', interactiveLayers, (e) => {
            if (e.features && e.features.length > 0) {
                const reminderId = e.features[0].properties.reminderId;
                showReminderActionModal(reminderId);
            }
        });

        locationsPreviewMap.on('mouseenter', interactiveLayers, () => { locationsPreviewMap.getCanvas().style.cursor = 'pointer'; });
        locationsPreviewMap.on('mouseleave', interactiveLayers, () => { locationsPreviewMap.getCanvas().style.cursor = ''; });
    };

    if (locationsPreviewMap.isStyleLoaded()) {
        plotAllLocations();
    } else {
        locationsPreviewMap.on('load', plotAllLocations);
    }
}    
// ===================================================================
// NOMBRE: showSavedLocationsModal (VERSIN FINAL CON REUTILIZACIN DE MAPA)
// RESUMEN: Muestra el modal de ubicaciones guardadas. El mapa selector se crea una
//          sola vez y se reutiliza, movindolo desde y hacia un "garaje" oculto
function showSavedLocationsModal(callbackOnClose, callbackOnSelectLocation, options = {}) {

    const existingModal = document.querySelector('.saved-locations-modal');
    if (existingModal) {
        if (locationPickerMap) { 
            // Si el modal se cierra de forma inesperada, devolvemos el mapa al garaje
            const mapGarage = document.getElementById('map-garage');
            const mapContainer = locationPickerMap.getContainer();
            if (mapGarage && mapContainer) mapGarage.appendChild(mapContainer);
        }
        clearModalAutoCloseTimer(existingModal, existingModal.querySelector('#close-saved-locations-modal'), 'saved-locations-modal');
        existingModal.remove();
    }

    tempSavedLocations = getSavedLocations().map(loc => loc ? {...loc} : null);
    const modal = document.createElement('div');
    modal.className = 'saved-locations-modal';
    
    modal.innerHTML = `
        <h2>Gestionar Ubicaciones Guardadas (Mx. ${MAX_SAVED_LOCATIONS})</h2>
        <div class="modal-top-buttons">
            <button id="save-all-user-locations">Guardar Cambios</button>
            <button id="close-saved-locations-modal">Cerrar</button>
        </div>
        <div id="saved-locations-list"> 
            <!-- Los slots de ubicacin se insertarn aqu por JavaScript -->
            <div id="location-picker-map-container">
                <button id="picker-ok-map-button" title="Confirmar esta posicin">OK</button>
                <button id="picker-locate-me-button" title="Ir a mi posicin actual">Mi Ubic.</button>
            </div>
        </div>
    `;
  
    const parent = options.parentContainer || document.body;
    parent.appendChild(modal);
    
    const listElement = modal.querySelector('#saved-locations-list');
    const mapPickerContainer = modal.querySelector('#location-picker-map-container');
    const okMapBtn = modal.querySelector('#picker-ok-map-button');
    const locateMeMapBtn = modal.querySelector('#picker-locate-me-button');
    const saveAllButton = modal.querySelector('#save-all-user-locations');
    const closeButton = modal.querySelector('#close-saved-locations-modal');

    function loadAndDisplaySlots() {
        listElement.querySelectorAll('.location-slot').forEach(el => el.remove());
        
        for (let i = 0; i < MAX_SAVED_LOCATIONS; i++) {
            const location = tempSavedLocations[i];
            const slotDiv = document.createElement('div');
            slotDiv.className = 'location-slot';
            slotDiv.innerHTML = ` <span style="width: 25px; text-align: right; font-weight: bold;">${i + 1}.</span> <input type="text" placeholder="Nombre Ubicacin" value="${location?.name || ''}" data-index="${i}"> <button class="map-button" data-index="${i}" title="Fijar en Mapa"> Mapa</button> <button class="select-location-button" data-index="${i}" title="Seleccionar esta ubicacin para el recordatorio actual">Seleccionar</button> <span class="coords-display">${location?.lat && location?.lng ? `${parseFloat(location.lat).toFixed(4)}, ${parseFloat(location.lng).toFixed(4)}` : 'No fijada'}</span> `;
            
            listElement.insertBefore(slotDiv, mapPickerContainer);
            
            slotDiv.querySelector('input[type="text"]').addEventListener('input', (e) => {
                if (!tempSavedLocations[i]) tempSavedLocations[i] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
                tempSavedLocations[i].name = e.target.value;
            });
            
            slotDiv.querySelector('.map-button').addEventListener('click', () => {
                currentEditingLocationSlotIndex = i;
                mapPickerContainer.classList.add('expanded');
                initializeLocationPickerMap('location-picker-map-container', i); // Llama a la nueva funcin optimizada

                setTimeout(() => {
                    if (listElement) {
                        listElement.scrollTo({ top: listElement.scrollHeight, behavior: 'smooth' });
                    }
                }, 100);
            });
            
            const selectButton = slotDiv.querySelector('.select-location-button');
            selectButton.addEventListener('click', () => {
                const selectedIndex = parseInt(selectButton.dataset.index);
                const selectedLocData = tempSavedLocations[selectedIndex];
                if (selectedLocData && selectedLocData.lat && selectedLocData.lng) {
                    if (callbackOnSelectLocation && typeof callbackOnSelectLocation === 'function') {
                        callbackOnSelectLocation({ name: selectedLocData.name, lat: selectedLocData.lat, lng: selectedLocData.lng, radius: selectedLocData.radius || DEFAULT_LOCATION_RADIUS });
                    }
                    
                    // --- CORRECCIN: Al seleccionar, tambin devolvemos el mapa al garaje ---
                    if (locationPickerMap) {
                        const mapGarage = document.getElementById('map-garage');
                        const mapContainer = locationPickerMap.getContainer();
                        if (mapGarage && mapContainer) mapGarage.appendChild(mapContainer);
                        locationPickerMap.activeSlotIndex = null;
                    }

                    clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
                    modal.remove();
                } else { showToast("Ubicacin no fijada. Fjala en el mapa primero", "warning"); }
            });
        }
    }
    
    loadAndDisplaySlots();

    okMapBtn.addEventListener('click', () => {
        if (locationPickerMarker && currentEditingLocationSlotIndex !== -1) {
            const pos = locationPickerMarker.getLngLat();
            if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
            tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat;
            tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng;
            const slotInput = listElement.querySelector(`.location-slot input[data-index="${currentEditingLocationSlotIndex}"]`); 
            if (slotInput) {
                const coordsDisplay = slotInput.closest('.location-slot').querySelector('.coords-display');
                if (coordsDisplay) { coordsDisplay.textContent = `${pos.lat.toFixed(4)}, ${pos.lng.toFixed(4)}`; }
            }
        }
        mapPickerContainer.classList.remove('expanded');
        
        // --- CORRECCIN: No se destruye el mapa, solo se mueve al garaje ---
        if (locationPickerMap) {
            const mapGarage = document.getElementById('map-garage');
            const mapContainer = locationPickerMap.getContainer();
            if(mapGarage && mapContainer) mapGarage.appendChild(mapContainer);
            locationPickerMap.activeSlotIndex = null;
        }
        
        currentEditingLocationSlotIndex = -1;
    });

    locateMeMapBtn.addEventListener('click', () => {
        if (locationPickerMap) {
            locateMeMapBtn.disabled = true; locateMeMapBtn.textContent = 'Buscando...';
            getCurrentLocation(
                (coords) => {
                    locationPickerMap.flyTo({center: [coords.longitude, coords.latitude], zoom: 16});
                    if (locationPickerMarker) locationPickerMarker.setLngLat([coords.longitude, coords.latitude]);
                    if (currentEditingLocationSlotIndex !== -1) {
                        if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
                        tempSavedLocations[currentEditingLocationSlotIndex].lat = coords.latitude;
                        tempSavedLocations[currentEditingLocationSlotIndex].lng = coords.longitude;
                    }
                    locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.';
                },
                (errorMsg) => { showToast(`Error localizacin: ${errorMsg}`, 'error'); locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.'; }
            );
        }
    });

    saveAllButton.addEventListener('click', () => {
        const locationsToSave = tempSavedLocations.map(loc => {
            if (loc && (!loc.name || loc.name.trim() === '') && (loc.lat === null || loc.lng === null)) { return null; }
            if (loc && (loc.lat !== null && loc.lng !== null) && typeof loc.radius !== 'number') { loc.radius = DEFAULT_LOCATION_RADIUS; }
            return loc;
        }).filter(Boolean); 

        saveLocationsToCache(locationsToSave);
        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        savedRoutes = savedRoutes.filter(r => !r.name.startsWith("UBICACIN: "));

        locationsToSave.forEach(loc => {
            if (loc && loc.name && loc.lat && loc.lng) {
                const routeName = `UBICACIN: ${loc.name.toUpperCase()}`;
                const routeWaypoint = { id: Date.now() + Math.random(), lat: loc.lat, lng: loc.lng, type: 'F', label: 'F', address: loc.name, visited: false, isCriticalForRecalc: true };
                const existingRouteIndex = savedRoutes.findIndex(r => r.name === routeName);
                const routeToSave = { name: routeName, waypoints: [routeWaypoint], createdAt: new Date().toISOString() };
                if (existingRouteIndex !== -1) { savedRoutes[existingRouteIndex] = routeToSave; } else { savedRoutes.push(routeToSave); }
            }
        });
        if (savedRoutes.length > MAX_SAVED_ROUTES) {
             savedRoutes.sort((a,b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
             savedRoutes = savedRoutes.slice(0, MAX_SAVED_ROUTES);
        }
        localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes)); 
        showToast("Ubicaciones guardadas y sincronizadas.", "success"); 
        if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose();
        
        if (locationPickerMap) {
            const mapGarage = document.getElementById('map-garage');
            const mapContainer = locationPickerMap.getContainer();
            if (mapGarage && mapContainer) mapGarage.appendChild(mapContainer);
            locationPickerMap.activeSlotIndex = null;
        }

        clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
        modal.remove();
    });

    const closeHandler = () => {
        clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
        
        if (locationPickerMap) {
            const mapGarage = document.getElementById('map-garage');
            const mapContainer = locationPickerMap.getContainer();
            if (mapGarage && mapContainer) mapGarage.appendChild(mapContainer);
            locationPickerMap.activeSlotIndex = null;
        }

        if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose();
        modal.remove();
    };

    closeButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
}    
// ===================================================================
// NOMBRE: showRadarSpeedModal
// RESUMEN: Muestra un modal para seleccionar la velocidad de un radar a aadir.
function showRadarSpeedModal(callbackOnSelect) {
    closeOtherModals('radar-speed-selection-modal');
    
    const modal = document.createElement('div');
    modal.id = 'radar-speed-selection-modal';
    modal.className = 'reminder-modal';
    
    const speeds = [30, 50, 60, 70, 80, 90, 100, 120, 'TRAMO'];
    
    let buttonsHtml = '';
    speeds.forEach(speed => {
        const isDefault = speed === 50;
        buttonsHtml += `<button class="action-button secondary speed-option ${isDefault ? 'default-selection' : ''}" data-speed="${speed}">${speed}</button>`;
    });

    modal.innerHTML = `
        <style>
            #radar-speed-selection-modal .reminder-modal-body {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                gap: 1.5rem;
            }
            #radar-speed-selection-modal .speed-options-grid {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 1rem;
                width: 100%;
                max-width: 400px;
            }
            #radar-speed-selection-modal .speed-option.selected {
                background-color: #007aff;
                border: 2px solid white;
                transform: scale(1.05);
            }
            #radar-speed-selection-modal .speed-option.default-selection {
                background-color: #F59E0B;
            }
        </style>
        <div class="reminder-modal-header">
            <h2 class="reminder-modal-title">Velocidad del Radar</h2>
        </div>
        <div class="reminder-modal-body">
            <p style="font-size: 1.1rem; text-align: center;">Selecciona la velocidad o se guardar la opcin por defecto en <span id="radar-modal-countdown">4</span>s.</p>
            <div class="speed-options-grid">
                ${buttonsHtml}
            </div>
        </div>
        <div class="reminder-modal-footer" style="justify-content: center;">
             <button id="cancel-radar-add" class="action-button danger">Cancelar</button>
        </div>
    `;

    document.body.appendChild(modal);

    let countdown = 4;
    const countdownElement = modal.querySelector('#radar-modal-countdown');
    
    const closeHandler = () => {
        if (countdownInterval) clearInterval(countdownInterval);
        if (modal.parentNode) modal.remove();
    };

    let countdownInterval = setInterval(() => {
        countdown--;
        if (countdownElement) countdownElement.textContent = countdown;
        if (countdown <= 0) {
            clearInterval(countdownInterval);
            const defaultSpeed = modal.querySelector('.speed-option.default-selection')?.dataset.speed || '50';
            callbackOnSelect(defaultSpeed);
            closeHandler();
        }
    }, 1000);

    modal.querySelectorAll('.speed-option').forEach(button => {
        button.addEventListener('click', () => {
            const selectedSpeed = button.dataset.speed;
            callbackOnSelect(selectedSpeed);
            closeHandler();
        });
    });

    modal.querySelector('#cancel-radar-add').addEventListener('click', () => {
        showToast("Creacin de radar cancelada.", "info");
        callbackOnSelect(null);
        closeHandler();
    });
}

    
// ===================================================================
// NOMBRE: checkForExcessiveRadars
// RESUMEN: Comprueba si el usuario tiene demasiados radares importados y ofrece limpiarlos y hacer backup.
function checkForExcessiveRadars() {
    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    const manualRadarReminders = reminders.filter(r => r && (r.text.toUpperCase().includes('RADAR') || r.excludeFromList === true) && !r.isDynamicRadar);

    if (manualRadarReminders.length > 200) {
        const modalId = 'excessive-radars-modal';
        const existingModal = document.getElementById(modalId);
        if (existingModal) return;

        const modal = document.createElement('div');
        modal.id = modalId;
        modal.className = 'choice-modal';
        modal.innerHTML = `
            <h2>Optimizacin de Radares</h2>
            <p style="margin-bottom: 1rem;">Hemos detectado que tienes <strong>${manualRadarReminders.length} radares</strong> importados manualmente. Un nuevo sistema carga automticamente los radares cercanos (80 km) para mejorar el rendimiento.</p>
            <p style="margin-bottom: 1.5rem; font-weight: bold;">Deseas eliminar los radares importados y activar el nuevo sistema dinmico?</p>
            <div class="modal-top-buttons">
                <button id="confirm-radar-cleanup" class="choice-edit" style="background-color: #28a745; color: white;">S, limpiar y optimizar</button>
                <button id="cancel-radar-cleanup" class="choice-cancel">No, mantener mis radares</button>
            </div>
        `;
        document.body.appendChild(modal);

        const confirmBtn = document.getElementById('confirm-radar-cleanup');
        const cancelBtn = document.getElementById('cancel-radar-cleanup');
        
        const closeHandler = () => {
            clearModalAutoCloseTimer(modal, confirmBtn, modalId);
            if (modal.parentNode) modal.remove();
        };
        
        confirmBtn.addEventListener('click', async () => {
            showToast("Limpiando radares manuales antiguos...", "info", 0, false, "radar-cleanup-toast");
            const remindersToKeep = reminders.filter(r => !((r.text.toUpperCase().includes('RADAR') || r.excludeFromList === true) && !r.isDynamicRadar));
            localStorage.setItem('reminders', JSON.stringify(remindersToKeep));
            
            showToast("Guardando copia de seguridad en la nube...", "info", 0, false, "radar-cleanup-toast");
            await validateAndSaveUserToFirebase(); 
            
            const existingToast = document.getElementById("radar-cleanup-toast");
            if (existingToast) existingToast.remove();
            
            closeHandler();
            updateReminderCount();
            updateButtonStyles();
        });

        cancelBtn.addEventListener('click', () => {
             showToast("Optimizacin cancelada. Puedes limpiar los radares manualmente desde Configuracin > Radares > Borrar.", "info", 8000);
             closeHandler();
        });
        
        addModalAutoCloseTimer(modal, confirmBtn, modalId, 60000);
    }
}    
    
// ===================================================================
// NOMBRE: toggleMapControls
// RESUMEN: Activa o desactiva los controles de planificacin de ruta en el mapa (botones, buscador) y actualiza el estado de geolocalizacin.
function toggleMapControls(enabled) {
    isGeolocated = enabled;
    
    const controls = [
        document.getElementById('map-location-search-input'),
        document.getElementById('map-location-search-button'),
        document.getElementById('clear-map-search-input-button'),
        document.getElementById('load-saved-route-button'),
        document.getElementById('reorder-route-stages-button'),
        document.getElementById('pdrs-ruta-button'),
        document.getElementById('add-reminder-at-location-button')
    ];

    controls.forEach(control => {
        if (control) {
            control.disabled = !enabled;
            control.style.opacity = enabled ? '1' : '0.5';
            control.style.cursor = enabled ? 'pointer' : 'not-allowed';
        }
    });
    
    setNavigationMapClickHandler();
}
    
// ===================================================================
// NOMBRE: getGridCellId
// RESUMEN: Calcula el ID de una celda de la cuadrcula espacial para un punto geogrfico.
function getGridCellId(lat, lon) {
    const GRID_SIZE = 0.1;
    const latIndex = Math.floor(lat / GRID_SIZE);
    const lonIndex = Math.floor(lon / GRID_SIZE);
    return `cell_${latIndex}_${lonIndex}`;
}

// ===================================================================
// NOMBRE: initializeRadarCache (VERSIN CON CACH PERSISTENTE Y CARGA ESTNDAR)
// RESUMEN: Carga solo los radares de KLMFILES.TXT desde localStorage o los reconstruye si es necesario.
async function initializeRadarCache() {
    if (window.radarsCache) return; 
    if (isRadarCacheInitializing) {
        return new Promise(resolve => {
            const interval = setInterval(() => {
                if (!isRadarCacheInitializing) {
                    clearInterval(interval);
                    resolve();
                }
            }, 100);
        });
    }

    isRadarCacheInitializing = true;
    
    try {
        let remoteManifestDate = null;
        try {
            const response = await fetch(KML_FILES_LIST_STANDARD, { method: 'HEAD', cache: 'no-cache' });
            if (response.ok) {
                remoteManifestDate = response.headers.get('Last-Modified');
            }
        } catch (e) {
            console.warn("No se pudo obtener la fecha del manifiesto de radares, se forzar la recarga si no hay cach.");
        }

        const localCacheDate = localStorage.getItem('radarsCacheVersion');
        const cachedRadarsJSON = localStorage.getItem('radarsCacheData');
        const cachedIndexJSON = localStorage.getItem('radarsCacheIndex');

        if (remoteManifestDate && localCacheDate === remoteManifestDate && cachedRadarsJSON && cachedIndexJSON) {
            try {
                window.radarsCache = JSON.parse(cachedRadarsJSON);
                window.radarsSpatialIndex = JSON.parse(cachedIndexJSON);
                return; 
            } catch (e) {
                console.error("Error al parsear la cach de radares local. Se reconstruir.", e);
            }
        }

    
        let filesToProcess = await fetchKMLFilesList(KML_FILES_LIST_STANDARD);

        const processingPromises = filesToProcess.map(kmlFileName => 
            fetchAndParseKML(KML_BASE_PATH + kmlFileName)
                .catch(error => {
                    console.warn(`No se pudo procesar el archivo ${kmlFileName}:`, error);
                    return [];
                })
        );
        
        const results = await Promise.all(processingPromises);
        
        const allRadars = [];
        const spatialIndex = {};

        results.flat().forEach(placemark => {
            const coords = placemark.coordinates;
            if (coords) {
                const [lonStr, latStr] = coords.split(',');
                const lon = parseFloat(lonStr);
                const lat = parseFloat(latStr);
                if (!isNaN(lat) && !isNaN(lon)) {
                    const radarData = { name: placemark.name, lat: lat, lon: lon };
                    allRadars.push(radarData);
                    
                    const cellId = getGridCellId(lat, lon);
                    if (!spatialIndex[cellId]) spatialIndex[cellId] = [];
                    spatialIndex[cellId].push(radarData);
                }
            }
        });
        
        window.radarsCache = allRadars;
        window.radarsSpatialIndex = spatialIndex;

        try {
            localStorage.setItem('radarsCacheData', JSON.stringify(allRadars));
            localStorage.setItem('radarsCacheIndex', JSON.stringify(spatialIndex));
            if (remoteManifestDate) {
                localStorage.setItem('radarsCacheVersion', remoteManifestDate);
            }
        } catch (e) {
            console.error("No se pudo guardar la cach de radares en localStorage:", e);
            showToast("No se pudo guardar la cach de radares. Puede que la optimizacin se repita.", "warning");
        }
        
        const existingToast = document.getElementById("radar-cache-init");
        if (existingToast) existingToast.remove();
       
    } catch (error) {
        showToast("Error crtico al inicializar la cach de radares.", "error");
        window.radarsCache = [];
        window.radarsSpatialIndex = {};
    } finally {
        isRadarCacheInitializing = false;
    }
}

    
// ===================================================================
// NOMBRE: deletePollMessage (NUEVA FUNCIN)
// RESUMEN: Permite al administrador borrar una encuesta permanentemente.
async function deletePollMessage(pollId) {
    if (!pollId) return;

    if (confirm('Ests seguro de que deseas eliminar esta encuesta/votacin permanentemente?')) {
        try {
            const pollRef = window.doc(window.db, 'chatPolls', pollId);
            await window.deleteDoc(pollRef);
            showToast("Encuesta eliminada.", "success");
        } catch (error) {
            showToast("Error al eliminar la encuesta.", "error");
        }
    }
}

// ===================================================================
// NOMBRE: handlePollVote (MODIFICADA V2)
// RESUMEN: Gestiona el voto, actualiza la UI y actualiza el timestamp de la encuesta.
async function handlePollVote(pollId, optionIndex) {
    const currentUserId = localStorage.getItem('userData_userId');
    if (!currentUserId) {
        showToast("Debes configurar un ID de usuario para poder votar.", "warning");
        return;
    }

    const pollRef = window.doc(window.db, 'chatPolls', pollId);

    try {
        const pollSnap = await window.getDoc(pollRef);
        if (!pollSnap.exists()) {
            showToast("Error: La encuesta ya no existe.", "error");
            return;
        }

        const pollData = pollSnap.data();
        const updatedVotes = pollData.votes || {};

        if (updatedVotes[currentUserId] === optionIndex) {
            delete updatedVotes[currentUserId];
        } else {
            updatedVotes[currentUserId] = optionIndex;
        }

        await window.setDoc(pollRef, { 
            votes: updatedVotes,
            timestamp: window.serverTimestamp() 
        }, { merge: true });
        
        const pollElement = document.getElementById(`poll-${pollId}`);
        if (!pollElement) return;

        const totalVotes = Object.keys(updatedVotes).length;

        pollData.options.forEach((option, index) => {
            const optionElement = pollElement.querySelector(`[data-option-index="${index}"]`);
            if (!optionElement) return;

            const voteCount = Object.values(updatedVotes).filter(v => v === index).length;
            const percentage = totalVotes > 0 ? (voteCount / totalVotes) * 100 : 0;
            
            optionElement.querySelector('.poll-vote-count').textContent = voteCount;
            optionElement.querySelector('.poll-progress-fill').style.width = `${percentage}%`;
            
            const button = optionElement.querySelector('.poll-option-button');
            if (updatedVotes[currentUserId] === index) {
                button.classList.add('voted');
            } else {
                button.classList.remove('voted');
            }
            
            const voters = Object.entries(updatedVotes)
                .filter(([_, voteIndex]) => voteIndex === index)
                .map(([userId, _]) => userId);

            const votersList = optionElement.querySelector('.poll-voter-list');
            if (votersList) {
                if (voters.length > 0) {
                    votersList.innerHTML = voters.map(user => `<li class="poll-voter-name">${user}</li>`).join('');
                } else {
                    votersList.innerHTML = '';
                }
            }
        });

    } catch (error) {
        showToast("Error al registrar el voto.", "error");
    }
}

    
// ===================================================================
// NOMBRE: startEditPollQuestion (MODIFICADA)
// RESUMEN: Permite al admin editar la pregunta y actualiza el timestamp de la encuesta.
async function startEditPollQuestion(pollId, currentQuestion) {
    const newQuestion = prompt("Edita la pregunta de la encuesta:", currentQuestion);

    if (newQuestion && newQuestion.trim() !== '' && newQuestion !== currentQuestion) {
        try {
            const pollRef = window.doc(window.db, 'chatPolls', pollId);
            await window.setDoc(pollRef, { 
                question: newQuestion.trim(),
                timestamp: window.serverTimestamp() 
            }, { merge: true });
            showToast("Pregunta de la encuesta actualizada.", "success");
        } catch (error) {
            showToast("Error al actualizar la pregunta.", "error");
        }
    }
}


// ===================================================================
// NOMBRE: incrementMapSessionCount (NUEVA FUNCIN)
// RESUMEN: Incrementa el contador de sesiones de mapa del usuario en Firebase.
async function incrementMapSessionCount() {
    const { primaryId: userId } = parseUserId(localStorage.getItem('userData_userId'));
    if (!userId || !window.db) {
        return;
    }

    try {
        const userDocRef = window.doc(window.db, "user_data", userId);
        const docSnap = await window.getDoc(userDocRef);
        
        const now = new Date();
        const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        let newTotal = 1;
        let newMonthCount = 1;
        
        if (docSnap.exists()) {
            const data = docSnap.data();
            newTotal = (data.map_sessions_total || 0) + 1;
            
            if (data.map_sessions_last_month === currentMonthStr) {
                newMonthCount = (data.map_sessions_month || 0) + 1;
            } else {
                newMonthCount = 1;
            }
        }
        
        const dataToUpdate = {
            map_sessions_total: newTotal,
            map_sessions_month: newMonthCount,
            map_sessions_last_month: currentMonthStr
        };

        await window.setDoc(userDocRef, dataToUpdate, { merge: true });

    } catch (error) {
        console.error("Error al incrementar el contador de sesiones de mapa:", error);
    }
}

// ===================================================================
// NOMBRE: getGlobalMapSessionStats (NUEVA FUNCIN)
// RESUMEN: Calcula las estadsticas globales de sesiones de mapa de todos los usuarios.
async function getGlobalMapSessionStats() {
    if (!window.db) return { totalMonth: 0, totalHistoric: 0 };
    
    let totalMonth = 0;
    let totalHistoric = 0;
    
    try {
        const usersCollectionRef = window.collection(window.db, "user_data");
        const querySnapshot = await window.getDocs(usersCollectionRef);
        
        const now = new Date();
        const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        querySnapshot.forEach(doc => {
            const data = doc.data();
            totalHistoric += (data.map_sessions_total || 0);
            
            if (data.map_sessions_last_month === currentMonthStr) {
                totalMonth += (data.map_sessions_month || 0);
            }
        });

    } catch (error) {
        console.error("Error al obtener estadsticas globales de sesiones de mapa:", error);
    }
    
    return { totalMonth, totalHistoric };
}

// ===================================================================
// NOMBRE: updateTrafficAlertIconSizes (NUEVA FUNCIN)
// RESUMEN: Redimensiona todos los iconos de alerta de trfico en el mapa segn el nivel de zoom actual.
function updateTrafficAlertIconSizes() {
    if (!navigationMapInstance || !trafficAlertsMarkers || trafficAlertsMarkers.length === 0) {
        return;
    }

    const currentZoom = navigationMapInstance.getZoom();
    const ZOOM_THRESHOLD = 14.5;
    const isSmall = currentZoom < ZOOM_THRESHOLD;
    const finalSize = isSmall ? '25px' : '60px';

    trafficAlertsMarkers.forEach(marker => {
        const markerElement = marker.getElement();
        if (markerElement) {
            markerElement.style.width = finalSize;
            markerElement.style.height = finalSize;
        }
    });
}

// ===================================================================
// NOMBRE: displayAlertsOnMap (MODIFICADA - AADE LISTENER DE CLIC)
// RESUMEN: Dibuja las alertas y aade un listener de clic a cada marcador para que sean interactivos.
function displayAlertsOnMap() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
        return;
    }
    
    if (trafficAlertsMarkers && trafficAlertsMarkers.length > 0) {
        trafficAlertsMarkers.forEach(marker => marker.remove());
    }
    trafficAlertsMarkers = [];

    const currentZoom = navigationMapInstance.getZoom();
    const ZOOM_THRESHOLD = 14.5;
    const isSmall = currentZoom < ZOOM_THRESHOLD;
    const finalSize = isSmall ? '25px' : '60px';

    const alertIconsMap = {
        1: 'AACCIDENTE.png', 2: 'AAVERIADO.png', 3: 'AGUARDIA.png',
        4: 'AATASCO.png', 5: 'APELIGRO.png', 6: 'ARESVALAR.png',
        7: 'AOBRAS.png', 8: 'ACERRADA.png'
    };
    
    const alertDetailsMap = {
        1: 'Accidente de trfico', 2: 'Coche averiado', 3: 'Control de trfico / Radar',
        4: 'Atasco', 5: 'Peligro indeterminado', 6: 'Carretera en mal estado',
        7: 'Obras', 8: 'Va / Carretera cerrada'
    };

    trafficAlertsCache.forEach(alert => {
        if (alert.code === 9) return;

        const iconFilename = alertIconsMap[alert.code];
        if (!iconFilename) return;

        const markerElement = document.createElement('div');
        markerElement.className = 'traffic-alert-marker';
        markerElement.style.width = finalSize;
        markerElement.style.height = finalSize;

        const iconImage = document.createElement('img');
        iconImage.src = `PNG/${iconFilename}`;
        iconImage.alt = `Alerta ${alert.code}`;
        markerElement.appendChild(iconImage);

        markerElement.addEventListener('click', (e) => {
            e.stopPropagation();
            const alertText = alertDetailsMap[alert.code] || 'Alerta de trfico';
            showToast(alertText, 'warning', 4000);
        });
        
        const newMarker = new mapboxgl.Marker({
            element: markerElement,
            anchor: 'center'
        })
        .setLngLat([alert.coordinates.lon, alert.coordinates.lat])
        .addTo(navigationMapInstance);

        trafficAlertsMarkers.push(newMarker);
    });
}

// ===================================================================
// NOMBRE: reAddCustomMapLayersAndSources (VERSIN CORREGIDA SIN CAPA DE ALERTAS)
// RESUMEN: Ya no crea la fuente ni la capa para 'traffic-alerts-source', ya que se gestionan como marcadores HTML.
// ===================================================================
async function reAddCustomMapLayersAndSources(mapInstance) {
    if (!mapInstance) return;

    await loadAndAddMapImages(mapInstance);

    const routeGeojsonData = (navigationCurrentRouteData?.routes?.[0]?.geometry)
        ? { type: 'Feature', properties: {}, geometry: navigationCurrentRouteData.routes[0].geometry }
        : { type: 'FeatureCollection', features: [] };


    const pdrFeatures = lastPdrSearchResults.map((point, index) => ({
        type: 'Feature',
        geometry: {
            type: 'Point',
            coordinates: [point.lon, point.lat]
        },
        properties: {
            ocmId: point.ocmId,
            index: index,
            bgColor: getChargingPointColorByPower(parseFloat(point.power)),
            isCheapest: point.isCheapest || false,
            power: point.power,
            operator: point.operator.substring(0, 14),
            price: point.price,
            availability: point.availabilityText
        }
    }));
    const pdrsGeojsonData = {
        type: 'FeatureCollection',
        features: pdrFeatures
    };
    
    // --- CORRECCIN: Eliminadas las referencias a la capa de alertas de trfico ---
    const sourcesAndLayersToRemove = [
        'speed-markers-text', 'speed-markers-circle-bg',
        'pdr-cards-layer-availability', 'pdr-cards-layer-price', 'pdr-cards-layer-operator', 'pdr-cards-layer-power', 'pdr-cards-layer-bg-halo', 'pdr-cards-layer-bg',
        'pdr-simple-text-layer', 'pdr-simple-circle-layer', 'completed-segments-layer', 'route',
        'speed-markers-source', 'pdrs-geojson-source', 'completed-segments', 'route'
    ];
    sourcesAndLayersToRemove.forEach(id => {
        try { if (mapInstance.getLayer(id)) mapInstance.removeLayer(id); if (mapInstance.getSource(id)) mapInstance.removeSource(id); } catch (e) {}
    });

    mapInstance.addSource('route', { type: 'geojson', data: routeGeojsonData });
    mapInstance.addSource('completed-segments', { type: 'geojson', data: completedSegmentsGeoJSON }); mapInstance.addSource('speed-markers-source', { type: 'geojson', data: { type: 'FeatureCollection', features: speedMarkerFeatures } });
    mapInstance.addSource('pdrs-geojson-source', { type: 'geojson', data: pdrsGeojsonData });
    // Ya no se aade la fuente 'traffic-alerts-source'

    mapInstance.addLayer({ id: 'route', type: 'line', source: 'route', layout: { 'line-join': 'round', 'line-cap': 'round' }, paint: getRouteStyleProperties() });
    mapInstance.addLayer({ id: 'completed-segments-layer', type: 'line', source: 'completed-segments', layout: { 'line-join': 'round', 'line-cap': 'round' }, paint: { 'line-color': 'green', 'line-width': (navigationMapInstance && navigationMapInstance.getPitch() > 20) ? 10 : 6, 'line-opacity': 0.8 } });
    
    mapInstance.addLayer({ id: 'speed-markers-circle-bg', type: 'circle', source: 'speed-markers-source', paint: { 'circle-radius': 15, 'circle-color': ['case', ['==', ['get', 'type'], 'maxSpeed'], '#4B0082', '#36454F'], 'circle-stroke-width': 2, 'circle-stroke-color': 'white' } });
    mapInstance.addLayer({ id: 'speed-markers-text', type: 'symbol', source: 'speed-markers-source', layout: { 'text-field': ['get', 'speedText'], 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 11, 'text-allow-overlap': true }, paint: { 'text-color': 'white' } });

    mapInstance.addLayer({ id: 'pdr-simple-circle-layer', type: 'circle', source: 'pdrs-geojson-source', filter: ['<=', ['zoom'], 14], paint: { 'circle-radius': 18, 'circle-color': ['get', 'bgColor'], 'circle-opacity': 1, 'circle-stroke-width': ['case', ['==', ['get', 'isCheapest'], true], 3.5, 2], 'circle-stroke-color': ['case', ['==', ['get', 'isCheapest'], true], '#FFD700', 'white'] } });
    mapInstance.addLayer({ id: 'pdr-simple-text-layer', type: 'symbol', source: 'pdrs-geojson-source', filter: ['<=', ['zoom'], 14], layout: { 'text-field': ['concat', ['get', 'power'], 'kW'], 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 9, 'text-allow-overlap': true }, paint: { 'text-color': 'white', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
    mapInstance.addLayer({ id: 'pdr-cards-layer-bg-halo', type: 'circle', source: 'pdrs-geojson-source', filter: ['all', ['>', ['zoom'], 14], ['==', ['get', 'isCheapest'], true]], paint: { 'circle-radius': 48, 'circle-color': '#FFD700', 'circle-opacity': 0.8, 'circle-blur': 1 } });
    mapInstance.addLayer({ id: 'pdr-cards-layer-bg', type: 'circle', source: 'pdrs-geojson-source', filter: ['>', ['zoom'], 14], paint: { 'circle-radius': 45, 'circle-color': ['get', 'bgColor'], 'circle-opacity': 1, 'circle-stroke-width': 3, 'circle-stroke-color': 'white' } });
    mapInstance.addLayer({ id: 'pdr-cards-layer-power', type: 'symbol', source: 'pdrs-geojson-source', filter: ['>', ['zoom'], 14], layout: { 'text-field': ['concat', ['get', 'power'], ' kW'], 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 14, 'text-offset': [0, -1.5], 'text-allow-overlap': true }, paint: { 'text-color': '#ffd700', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
    mapInstance.addLayer({ id: 'pdr-cards-layer-operator', type: 'symbol', source: 'pdrs-geojson-source', filter: ['>', ['zoom'], 14], layout: { 'text-field': ['get', 'operator'], 'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'], 'text-size': 11, 'text-offset': [0, -0.3], 'text-allow-overlap': true, 'text-max-width': 10 }, paint: { 'text-color': 'white', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
    mapInstance.addLayer({ id: 'pdr-cards-layer-price', type: 'symbol', source: 'pdrs-geojson-source', filter: ['>', ['zoom'], 14], layout: { 'text-field': ['get', 'price'], 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 13, 'text-offset': [0, 1.0], 'text-allow-overlap': true }, paint: { 'text-color': '#90ee90', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
    mapInstance.addLayer({ id: 'pdr-cards-layer-availability', type: 'symbol', source: 'pdrs-geojson-source', filter: ['>', ['zoom'], 14], layout: { 'text-field': ['get', 'availability'], 'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'], 'text-size': 10, 'text-offset': [0, 2.8], 'text-allow-overlap': true }, paint: { 'text-color': '#e0e0e0', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
  
}

// ===================================================================
// NOMBRE: updateLineWidthsOnPitchChange (NUEVA FUNCIN SIMPLE)
// RESUMEN: Ajusta el grosor de las lneas de ruta segn la inclinacin.
function updateLineWidthsOnPitchChange() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) return;

    const isPitched = navigationMapInstance.getPitch() > 20;
    const mainWidth = isPitched ? 16 : 12;
    const altWidth = isPitched ? 12 : 8;
    const completedWidth = isPitched ? 10 : 6;

    try {
        if (navigationMapInstance.getLayer('route')) {
            navigationMapInstance.setPaintProperty('route', 'line-width', mainWidth);
        }
        if (navigationMapInstance.getLayer('completed-segments-layer')) {
            navigationMapInstance.setPaintProperty('completed-segments-layer', 'line-width', completedWidth);
        }
        alternativeRouteLayers.forEach(alt => {
            if (navigationMapInstance.getLayer(alt.layerId)) {
                navigationMapInstance.setPaintProperty(alt.layerId, 'line-width', altWidth);
            }
        });
    } catch (e) { /* Ignorar errores si la capa no existe */ }
}
                                                                                                                                                                                                                                                                                                     
// ===================================================================
// NOMBRE: openChatModal (MODIFICADA)
// RESUMEN: Abre el modal del chat y lo convierte en una funcin asncrona.
async function openChatModal() {
    const modalOverlay = document.getElementById('chat-modal-overlay');
    if (!modalOverlay) return;
    
    document.body.classList.add('chat-open');
    modalOverlay.classList.remove('hidden');

    const sendButton = document.getElementById('chat-send-button');
    const messageInput = document.getElementById('chat-message-input');
    const charCounter = document.getElementById('chat-char-counter');
    const permissionWarning = document.getElementById('chat-permission-warning');
    const messagesContainer = document.getElementById('chat-messages-container');
    
    const originalPlaceholder = "Escribe un mensaje... (antecede @usuario para mensaje privado, o pulsa en el lateral. Para referirse simplemente nmbralo). Vida de los mensajes 96 horas. En el coche usa los comandos de voz. Elon cree en la humanidad, the White Monkey y yo tambin, ser educad@s.";
    const pollPlaceholder = "Para encuestas/votaciones, usa el formato: #COMUNIDAD#Pregunta#Opcin1 $ Opcin2...#";
    messageInput.placeholder = `${originalPlaceholder} ${pollPlaceholder}`;

    const currentUserId = localStorage.getItem('userData_userId');
    const currentUserDmsAllowed = JSON.parse(localStorage.getItem('userData_allowDMs') || 'false');
    
    if (currentUserId === 'BoardingGate' && !sessionStorage.getItem('chatCleanupSessionDone')) {
        sessionStorage.setItem('chatCleanupSessionDone', 'true');
        showToast("Hola Admin. Realizando limpieza de mensajes antiguos...", "info");
        cleanUpOldChatMessages();
    }

    if (!currentUserId) {
        permissionWarning.textContent = "Debes configurar un ID de Usuario para poder chatear.";
        permissionWarning.classList.remove('hidden');
        sendButton.disabled = true;
        messageInput.disabled = true;
    } else if (!currentUserDmsAllowed) {
        permissionWarning.innerHTML = `Si quiere recibir mensajes o poder enviar mensajes tanto pblicos como dirigidos a un usuario concreto debe activar en <strong>Configuracin > Usuario > Permitir MDs (va admin)</strong>`;
        permissionWarning.classList.remove('hidden');
        sendButton.disabled = true;
        messageInput.disabled = true;
    } else {
        permissionWarning.classList.add('hidden');
        sendButton.disabled = false;
        messageInput.disabled = false;
    }
    
    charCounter.textContent = messageInput.maxLength;
    
    if (!messageInput.listenerAdded) {
        messageInput.addEventListener('input', () => {
            const remaining = messageInput.maxLength - messageInput.value.length;
            charCounter.textContent = remaining;
        });
        messageInput.listenerAdded = true;
    }

    const newExitButton = document.getElementById('chat-exit-button').cloneNode(true);
    document.getElementById('chat-exit-button').parentNode.replaceChild(newExitButton, document.getElementById('chat-exit-button'));
    newExitButton.addEventListener('click', closeChatModal);

    const newSendButton = sendButton.cloneNode(true);
    sendButton.parentNode.replaceChild(newSendButton, sendButton);
    newSendButton.addEventListener('click', sendMessage);

    if (!messagesContainer.listenerAdded) {
        messagesContainer.addEventListener('click', (event) => {
            const target = event.target.closest('[data-action]');
            if (!target) return;

            event.stopPropagation();
            const action = target.dataset.action;
            const id = target.dataset.id;
            
            switch (action) {
                case 'vote-poll':
                    const optionIndex = parseInt(target.dataset.optionIndex, 10);
                    handlePollVote(id, optionIndex);
                    break;
                case 'edit-message':
                    const content = target.dataset.content;
                    startEditMessage(id, content);
                    break;
                case 'delete-message':
                    deleteChatMessage(id);
                    break;
                case 'edit-poll':
                    const question = target.dataset.question;
                    startEditPollQuestion(id, question);
                    break;
                case 'delete-poll':
                    deletePollMessage(id);
                    break;
            }
        });
        messagesContainer.listenerAdded = true;
    }

    await fetchAndRenderChatUsers();
    fetchAndRenderChatMessages();
    updateTotalMessageCount();

    if (chatUpdateInterval) clearInterval(chatUpdateInterval);
    chatUpdateInterval = setInterval(() => {
        if (!modalOverlay.classList.contains('hidden')) {
            updateTotalMessageCount();
        }
    }, 15000);
}
    
// ===================================================================
// NOMBRE: fetchAndRenderChatMessages (CORREGIDA V5 - ROBUSTA CON DOM)
// RESUMEN: Construye los elementos del chat de forma segura con el DOM API.
async function fetchAndRenderChatMessages() {
    const messagesContainer = document.getElementById('chat-messages-container');
    if (!messagesContainer || !window.db) return;

    const currentUserId = (localStorage.getItem('userData_userId') || '').trim();
    if (!currentUserId) {
        messagesContainer.innerHTML = '<p class="chat-system-message">Configura tu ID de usuario para ver el chat.</p>';
        return;
    }
    
    const currentUserIdLower = currentUserId.toLowerCase();

    try {
        const oneHundredTwentyHoursAgo = new Date(Date.now() - 120 * 60 * 60 * 1000);
        const messagesQuery = window.query(window.collection(window.db, 'chatMessages'), window.where('timestamp', '>', oneHundredTwentyHoursAgo), window.orderBy('timestamp', 'desc'));
        const pollsQuery = window.query(window.collection(window.db, 'chatPolls'), window.orderBy('timestamp', 'desc'));
        
        const [messagesSnapshot, pollsSnapshot] = await Promise.all([
            window.getDocs(messagesQuery),
            window.getDocs(pollsQuery)
        ]);

        let combinedItems = [];
        messagesSnapshot.forEach(doc => combinedItems.push({ id: doc.id, ...doc.data(), isPoll: false }));
        pollsSnapshot.forEach(doc => combinedItems.push({ id: doc.id, ...doc.data(), isPoll: true }));

        combinedItems.sort((a, b) => (b.timestamp?.toMillis() || 0) - (a.timestamp?.toMillis() || 0));

        messagesContainer.innerHTML = '';
        
        if (combinedItems.length === 0) {
            messagesContainer.innerHTML = '<p class="chat-system-message">No hay mensajes recientes. S el primero en escribir!</p>';
            return;
        }

        combinedItems.forEach(item => {
            if (item.isPoll) {
                messagesContainer.appendChild(renderPollBubble(item, currentUserId));
            } else {
                const isPublic = item.recipientId.toLowerCase() === 'public';
                const isForMe = item.recipientId.toLowerCase() === currentUserIdLower;
                const iSentIt = item.senderId.toLowerCase() === currentUserIdLower;

                if (isPublic || isForMe || iSentIt) {
                    const bubble = document.createElement('div');
                    bubble.className = 'chat-message-bubble';
                    
                    let bubbleClass = '';
                    if (iSentIt && isPublic) { bubble.style.backgroundColor = '#DF6565'; bubbleClass = 'public-msg'; }
                    else if (isForMe && !iSentIt) { bubbleClass = 'private-msg'; }
                    else if (isPublic) { bubbleClass = 'public-msg'; }
                    else if (iSentIt && !isPublic) { bubbleClass = 'private-msg-sent'; }
                    bubble.classList.add(iSentIt ? 'sent' : 'received', bubbleClass);

                    const senderSpan = document.createElement('span');
                    senderSpan.className = 'chat-message-sender';
                    senderSpan.textContent = item.senderId + (item.recipientId.toLowerCase() !== 'public' ? ` a ${item.recipientId}` : '');
                    
                    const contentSpan = document.createElement('span');
                    contentSpan.className = 'chat-message-content';
                    contentSpan.textContent = item.content;
                    
                    const timeSpan = document.createElement('span');
                    timeSpan.className = 'chat-message-time';
                    const timeText = document.createElement('span');
                    timeText.textContent = item.timestamp?.toDate ? `${item.timestamp.toDate().toLocaleDateString([], {day:'2-digit', month:'2-digit'})} - ${item.timestamp.toDate().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}` : '';
                    timeSpan.appendChild(timeText);

                    if (iSentIt || currentUserId === 'BoardingGate') {
                        const actionsContainer = document.createElement('div');
                        actionsContainer.className = 'chat-message-actions';
                        
                        const editIcon = document.createElement('img');
                        editIcon.src = 'https://boardinggate.github.io/Tesla/PNG/editmsg.png';
                        editIcon.className = 'chat-action-icon';
                        editIcon.title = 'Editar mensaje';
                        editIcon.dataset.action = 'edit-message';
                        editIcon.dataset.id = item.id;
                        editIcon.dataset.content = item.content;

                        const deleteIcon = document.createElement('img');
                        deleteIcon.src = 'https://boardinggate.github.io/Tesla/PNG/erasemsg.png';
                        deleteIcon.className = 'chat-action-icon';
                        deleteIcon.title = 'Eliminar mensaje';
                        deleteIcon.dataset.action = 'delete-message';
                        deleteIcon.dataset.id = item.id;

                        actionsContainer.appendChild(editIcon);
                        actionsContainer.appendChild(deleteIcon);
                        timeSpan.appendChild(actionsContainer);
                    }
                    
                    bubble.appendChild(senderSpan);
                    bubble.appendChild(contentSpan);
                    bubble.appendChild(timeSpan);
                    messagesContainer.appendChild(bubble);
                }
            }
        });
        
        messagesContainer.scrollTop = 0;

    } catch (error) {
        messagesContainer.innerHTML = `<p class="chat-system-message">Error al cargar el chat: ${error.message}</p>`;
    }
}
// ===================================================================
// NOMBRE: renderPollBubble (CORREGIDA V5 - ROBUSTA CON DOM)
// RESUMEN: Construye un elemento DOM para la encuesta, evitando errores de sintaxis.
function renderPollBubble(poll, currentUserId) {
    const totalVotes = Object.keys(poll.votes || {}).length;
    
    const pollBubble = document.createElement('div');
    pollBubble.id = `poll-${poll.id}`;
    pollBubble.className = 'chat-message-bubble chat-poll-bubble';

    const senderTime = poll.timestamp?.toDate 
        ? `${poll.timestamp.toDate().toLocaleDateString([], {day: '2-digit', month: '2-digit'})} - ${poll.timestamp.toDate().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`
        : 'enviando...';

    const senderInfo = document.createElement('div');
    senderInfo.className = 'poll-sender-info';
    senderInfo.innerHTML = `<span class="chat-message-sender">${poll.senderId}</span><span class="poll-time">${senderTime}</span>`;
    
    const questionEl = document.createElement('p');
    questionEl.className = 'poll-question';
    questionEl.textContent = poll.question;

    const optionsList = document.createElement('ul');
    optionsList.className = 'poll-options-list';

    poll.options.forEach((option, index) => {
        const voteCount = Object.values(poll.votes || {}).filter(voteIndex => voteIndex === index).length;
        const percentage = totalVotes > 0 ? (voteCount / totalVotes) * 100 : 0;
        const hasVotedThis = (poll.votes || {})[currentUserId] === index;

        const voters = Object.entries(poll.votes || {}).filter(([_, vIndex]) => vIndex === index).map(([userId, _]) => userId);
        
        const listItem = document.createElement('li');
        listItem.className = 'poll-option-item';
        listItem.dataset.optionIndex = index;

        const button = document.createElement('button');
        button.className = `poll-option-button ${hasVotedThis ? 'voted' : ''}`;
        button.dataset.action = 'vote-poll';
        button.dataset.id = poll.id;
        button.dataset.optionIndex = index;
        button.innerHTML = `<div class="poll-option-text">${option}</div><div class="poll-vote-count">${voteCount}</div>`;

        const progressBar = document.createElement('div');
        progressBar.className = 'poll-progress-bar';
        progressBar.innerHTML = `<div class="poll-progress-fill" style="width: ${percentage}%;"></div>`;
        
        const votersContainer = document.createElement('div');
        votersContainer.className = 'poll-voters-container';
        const votersUl = document.createElement('ul');
        votersUl.className = 'poll-voter-list';
        votersUl.innerHTML = voters.map(user => `<li class="poll-voter-name">${user}</li>`).join('');
        votersContainer.appendChild(votersUl);

        listItem.appendChild(button);
        listItem.appendChild(progressBar);
        listItem.appendChild(votersContainer);
        optionsList.appendChild(listItem);
    });

    pollBubble.appendChild(senderInfo);
    pollBubble.appendChild(questionEl);
    pollBubble.appendChild(optionsList);

    if (currentUserId === 'BoardingGate') {
        const moderationIcons = document.createElement('div');
        moderationIcons.className = 'poll-moderation-icons';
        
        const editIcon = document.createElement('img');
        editIcon.src = "https://boardinggate.github.io/Tesla/PNG/editmsg.png";
        editIcon.className = 'chat-action-icon';
        editIcon.title = "Editar pregunta";
        editIcon.dataset.action = "edit-poll";
        editIcon.dataset.id = poll.id;
        editIcon.dataset.question = poll.question;
        
        const deleteIcon = document.createElement('img');
        deleteIcon.src = "https://boardinggate.github.io/Tesla/PNG/erasemsg.png";
        deleteIcon.className = 'chat-action-icon';
        deleteIcon.title = "Eliminar encuesta";
        deleteIcon.dataset.action = "delete-poll";
        deleteIcon.dataset.id = poll.id;
        
        moderationIcons.appendChild(editIcon);
        moderationIcons.appendChild(deleteIcon);
        pollBubble.appendChild(moderationIcons);
    }
    
    return pollBubble;
}
    
// ===================================================================
// NOMBRE: adaptMapboxRouteToOSRMFormat (NUEVA FUNCIN)
// RESUMEN: Convierte la respuesta de la API de Mapbox al formato de OSRM.
function adaptMapboxRouteToOSRMFormat(mapboxRoute) {
    const adaptedLegs = mapboxRoute.legs.map(leg => {
        const adaptedSteps = leg.steps.map(step => {
            return {
                distance: step.distance,
                duration: step.duration,
                geometry: step.geometry,
                maneuver: {
                    bearing_after: step.maneuver.bearing_after,
                    bearing_before: step.maneuver.bearing_before,
                    location: step.maneuver.location,
                    modifier: step.maneuver.modifier,
                    type: step.maneuver.type,
                },
                name: step.name,
            };
        });
        return {
            distance: leg.distance,
            duration: leg.duration,
            steps: adaptedSteps,
            summary: leg.summary,
        };
    });
    return {
        distance: mapboxRoute.distance,
        duration: mapboxRoute.duration,
        geometry: mapboxRoute.geometry,
        legs: adaptedLegs,
    };
}
    

// ===================================================================
// NOMBRE: startEditMessage (NUEVA FUNCIN)
// RESUMEN: Prepara la UI para editar un mensaje existente.
function startEditMessage(messageId, content) {
    const messageInput = document.getElementById('chat-message-input');
    const sendButton = document.getElementById('chat-send-button');

    if (messageInput && sendButton) {
        messageInput.value = content;
        messageInput.dataset.editingMessageId = messageId;
        sendButton.textContent = 'Actualizar';
        messageInput.focus();
        }
}

// ===================================================================
// NOMBRE: deleteChatMessage (NUEVA FUNCIN)
// RESUMEN: Elimina un mensaje del chat y de Firebase previa confirmacin.
async function deleteChatMessage(messageId) {
    if (!messageId) return;

    if (confirm('Ests seguro de que deseas eliminar este mensaje permanentemente?')) {
        try {
            const messageRef = window.doc(window.db, 'chatMessages', messageId);
            await window.deleteDoc(messageRef);
            showToast("Mensaje eliminado.", "success");
            fetchAndRenderChatMessages();
        } catch (error) {
            showToast("Error al eliminar el mensaje.", "error");
        }
    }
}
   
// ===================================================================
// NOMBRE: closeChatModal (MODIFICADA)
// RESUMEN: Cierra el modal y restaura el scroll del body.
function closeChatModal() {
    const modalOverlay = document.getElementById('chat-modal-overlay');
    if (modalOverlay) {
        modalOverlay.classList.add('hidden');
    }
    document.body.classList.remove('chat-open'); 
    if (chatUpdateInterval) {
        clearInterval(chatUpdateInterval);
        chatUpdateInterval = null;
    }
}

// ===================================================================
// NOMBRE: updateTotalMessageCount (MODIFICADA)
// RESUMEN: Actualiza el contador de mensajes en el nuevo globo principal.
async function updateTotalMessageCount() {
    const globeButton = document.getElementById('chat-icon-button');
    const globeCounter = document.getElementById('chat-message-globe');
    if (!globeButton || !globeCounter || !window.db) return;

    try {
        const ninetySixHoursAgo = new Date(Date.now() - 96 * 60 * 60 * 1000);
        const messagesRef = window.collection(window.db, 'chatMessages');
        const q = window.query(messagesRef, window.where('timestamp', '>', ninetySixHoursAgo));
        
        const querySnapshot = await window.getDocs(q);
        const count = querySnapshot.size;

        if (count > 0) {
            globeCounter.textContent = count;
            globeButton.classList.remove('hidden');
        } else {
            globeCounter.textContent = '0';
             
        }
    } catch (error) {
        globeCounter.textContent = 'X';
        globeButton.classList.remove('hidden');
    }
}    

// ===================================================================
// NOMBRE: sendMessage (MODIFICADA V2)
// RESUMEN: Enva mensajes/encuestas y fuerza la actualizacin inmediata del chat.
async function sendMessage() {
    const messageInput = document.getElementById('chat-message-input');
    const sendButton = document.getElementById('chat-send-button');
    const content = messageInput.value.trim();
    const editingId = messageInput.dataset.editingMessageId;

    if (!content) {
        showToast("El mensaje no puede estar vaco.", "warning");
        return;
    }
    
    const currentUserId = localStorage.getItem('userData_userId');
    if (!currentUserId) {
        showToast("Error: No se ha podido identificar al usuario.", "error");
        return;
    }
    
    sendButton.disabled = true;

    try {
        if (content.toUpperCase().startsWith('#COMUNIDAD#')) {
            const parts = content.split('#');
            if (parts.length < 4 || !parts[2] || !parts[3]) {
                throw new Error("Formato de encuesta incorrecto. Use #COMUNIDAD#Pregunta#Opcin1 $ Opcin2 ...");
            }
            
            const question = parts[2].trim();
            const options = parts[3].split('$').map(opt => opt.trim()).filter(Boolean);

            if (options.length < 2 || options.length > 6) {
                throw new Error("Las encuestas deben tener entre 2 y 6 opciones.");
            }
            if (!question) {
                throw new Error("La pregunta de la encuesta no puede estar vaca.");
            }

            const newPoll = {
                senderId: currentUserId,
                question: question,
                options: options,
                timestamp: window.serverTimestamp(),
                votes: {}
            };

            await window.addDoc(window.collection(window.db, 'chatPolls'), newPoll);
            messageInput.value = '';

        } else if (editingId) {
            const messageRef = window.doc(window.db, 'chatMessages', editingId);
            await window.setDoc(messageRef, { content: content }, { merge: true });
            
            messageInput.value = '';
            delete messageInput.dataset.editingMessageId;
            sendButton.textContent = 'Enviar';
            showToast("Mensaje actualizado correctamente.", "success");

        } else {
            if (content.length > 500) {
                showToast("El mensaje excede los 500 caracteres.", "warning");
                sendButton.disabled = false;
                return;
            }
            
            let recipientId = 'public';
            let messageContent = content;
            const mentionMatch = content.match(/^@(\w+)\s/);
            
            if (mentionMatch) {
                const mentionedUser = mentionMatch[1];
                const usersRef = window.collection(window.db, "user_data");
                const q = window.query(usersRef, window.where("rss", "==", true));
                const querySnapshot = await window.getDocs(q);
                let foundRecipientId = null;

                querySnapshot.forEach(doc => {
                    const userData = doc.data();
                    const actualUserId = userData.usuario || doc.id;
                    if (actualUserId.toLowerCase() === mentionedUser.toLowerCase()) {
                        foundRecipientId = actualUserId;
                    }
                });

                if (foundRecipientId) {
                    recipientId = foundRecipientId;
                    messageContent = content.substring(mentionMatch[0].length).trim();
                } else {
                    showToast(`Usuario "@${mentionedUser}" no encontrado o no tiene MDs activados.`, "warning");
                    sendButton.disabled = false;
                    return;
                }
            }

            const newMessage = {
                senderId: currentUserId,
                recipientId: recipientId,
                content: messageContent,
                timestamp: window.serverTimestamp()
            };
            
            await window.addDoc(window.collection(window.db, 'chatMessages'), newMessage);
            messageInput.value = '';
        }
        
        messageInput.dispatchEvent(new Event('input')); 
        fetchAndRenderChatMessages();

    } catch (error) {
        showToast(error.message || (editingId ? "Error al actualizar." : "Error al enviar."), "error");
    } finally {
        sendButton.disabled = false;
    }
}

// ===================================================================
// NOMBRE: handleDragEnd
// RESUMEN: Maneja la finalizacin de una operacin de arrastre.
function handleDragEnd(e) {     if (!isEditMode) return;  handleDragEndCleanup(); 
}
    
// ===================================================================
// NOMBRE: cleanUpOldChatMessages (MODIFICADA)
// RESUMEN: Borra los mensajes (no encuestas) con ms de 120 horas (ejecutado por el admin).
async function cleanUpOldChatMessages() {
    if (!window.db) return;
    const oneHundredTwentyHoursAgo = new Date(Date.now() - 120 * 60 * 60 * 1000);
    const messagesRef = window.collection(window.db, 'chatMessages');
    const q = window.query(messagesRef, window.where('timestamp', '<=', oneHundredTwentyHoursAgo));

    try {
        const querySnapshot = await window.getDocs(q);
        if (querySnapshot.empty) {
            showToast("No hay mensajes antiguos que limpiar.", "info", 2000);
            return;
        }

        const batchPromises = [];
        const batchSize = 499;
        let currentBatch = window.writeBatch(window.db);
        let batchCount = 0;

        querySnapshot.forEach((doc, index) => {
            currentBatch.delete(doc.ref);
            batchCount++;
            if (batchCount === batchSize) {
                batchPromises.push(currentBatch.commit());
                currentBatch = window.writeBatch(window.db);
                batchCount = 0;
            }
        });
        
        if (batchCount > 0) {
            batchPromises.push(currentBatch.commit());
        }

        await Promise.all(batchPromises);
        showToast(`Limpieza completada: ${querySnapshot.size} mensajes eliminados.`, 'success');
        updateTotalMessageCount();

    } catch (error) {
        showToast('Error durante la limpieza de mensajes antiguos.', 'error');
    }
}    
    
// ===================================================================
// NOMBRE: createRouteLabelMarker (NUEVA FUNCIN - SIN L.divIcon)
// RESUMEN: Crea un icono de etiqueta personalizado para las rutas alternativas.
function createRouteLabelMarker(text, color) {
    const iconHtml = `<div class="route-label-marker" style="background-color: ${color};">${text}</div>`;
    const div = document.createElement('div');
    div.innerHTML = iconHtml;
    return div.firstChild; 
}

// ===================================================================
// NOMBRE: showAutoStartNavigationModal (MODIFICADA - VERSIN CON VERIFICACIN DE RUTA)
// RESUMEN: Muestra el modal de inicio. Si la ruta se borra mientras se muestra, el modal se cierra solo.
function showAutoStartNavigationModal() {
    hideAutoStartNavigationModal();

    const progressBar = document.getElementById('navigation-bottom-progress-bar');
    if (progressBar) {
        progressBar.classList.add('progress-bar-partially-hidden');
    }

    const modal = document.createElement('div');
    modal.id = 'auto-start-nav-modal';
    
    let countdown = 20;
    
    modal.innerHTML = `
        <div style="display: flex; gap: 10px; align-items: stretch;">
            <button id="start-route-now-button" style="flex-grow: 1;">INICIAR RUTA (${countdown})</button>
            <button id="cancel-start-nav" style="flex-shrink: 0; padding: 10px 15px; font-size: 1rem; background-color: #6c757d; color: white; border: 1px solid #FFF; border-radius: 5px; cursor: pointer;">Cancelar</button>
        </div>
        <p class="info-text">(*) Si prefiere otra ruta seleccione una de las alternativas mostradas.</p>
    `;

    document.body.appendChild(modal);

    const startButton = document.getElementById('start-route-now-button');
    const cancelButton = document.getElementById('cancel-start-nav');

    const startNavAndClose = () => {
        if (!isNavigating) {
            toggleNavigationState();
        }
    };
    
    startButton.addEventListener('click', startNavAndClose);
    
    cancelButton.addEventListener('click', () => {
        hideAutoStartNavigationModal();
    });

    autoStartNavModalTimer = setInterval(() => {
        const isRouteStillValid = navigationCurrentRouteData && navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2;
        
        if (!isRouteStillValid) {
            hideAutoStartNavigationModal();
            return;
        }
        
        countdown--;
        const btn = document.getElementById('start-route-now-button');
        if (countdown > 0) {
            if (btn) btn.textContent = `INICIAR RUTA (${countdown})`;
        } else {
            if (btn) startNavAndClose(); 
        }
    }, 1000);
}
    
// ===================================================================
// NOMBRE: selectAlternativeRoute (CORRECCIN FINAL)
// RESUMEN: Limpia las alternativas INMEDIATAMENTE, luego recalcula la ruta seleccionada.
async function selectAlternativeRoute(waypointId, routeType) {
    clearAlternativeRoutesDisplay();

    if (!alternativeRoutesCache.has(waypointId)) {
        showToast("Error de cach: No se encontraron datos para la ruta seleccionada.", "error");
        return;
    }

    const routesData = alternativeRoutesCache.get(waypointId);
    const selectedRouteData = routesData[routeType];

    if (!selectedRouteData || !selectedRouteData.geometry || !selectedRouteData.geometry.coordinates) {
        showToast("Error: La ruta alternativa seleccionada no tiene geometra vlida.", "error");
        return;
    }

    selectedStageRoutes.set(waypointId, routeType);

    const endWaypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    if (endWaypointIndex < 1) return;

    let startWaypointIndex = -1;
    for (let i = endWaypointIndex - 1; i >= 0; i--) {
        if (navigationWaypoints[i] && !navigationWaypoints[i].isInternal) {
            startWaypointIndex = i;
            break;
        }
    }
    if (startWaypointIndex === -1) return;

    navigationWaypoints = navigationWaypoints.filter(wp => !(wp.isInternal && wp.parentWaypointId === waypointId));
    
    const geometryPoints = selectedRouteData.geometry.coordinates;
    const totalPoints = geometryPoints.length;
    const maxInternalPoints = 10;
    const step = totalPoints > maxInternalPoints + 2 ? Math.floor((totalPoints - 2) / maxInternalPoints) : 1;
    
    const internalWaypoints = [];
    for (let i = step; i < totalPoints - 1; i += step) {
         const coord = geometryPoints[i];
         internalWaypoints.push({
            id: Date.now() + Math.random() + i,
            lat: coord[1],
            lng: coord[0],
            type: 'internal',
            label: '',
            address: 'Punto de paso interno',
            isInternal: true,
            parentWaypointId: waypointId,
            visited: false,
            isCriticalForRecalc: true
        });
    }

    const newEndIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    navigationWaypoints.splice(newEndIndex, 0, ...internalWaypoints);
    
    await recalculateAndDrawRoute(true);
    
    const routeTypeTranslations = {
        'fastest': 'RPIDA',
        'shortest': 'CORTA',
        'alternative': 'ALTERNATIVA'
    };
    const translatedType = routeTypeTranslations[routeType] || routeType.toUpperCase();
    showToast(`Ruta para esta etapa cambiada a: ${translatedType}.`, "success");
}
    
// ===================================================================
// NOMBRE: drawAlternativeRoutes (MODIFICADA - PARA MAPBOX)
// RESUMEN: Dibuja en el mapa las polilneas y etiquetas de las rutas alternativas.
function drawAlternativeRoutes(waypointId, routesData) {
    clearAlternativeRoutesDisplay(); 
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) return;

    const routeConfigs = [
        { type: 'fastest', data: routesData.fastest, color: '#0066FF', label: 'RAP' }, 
        { type: 'shortest', data: routesData.shortest, color: '#BA6BFF', label: 'COR' }, 
        { type: 'alternative', data: routesData.alternative, color: '#FF5900', label: 'ALT' } 
    ];

    routeConfigs.forEach((config, index) => {
        if (config.data && config.data.geometry) {
            const sourceId = `alt-route-${waypointId}-${config.type}`;
            const layerId = `alt-layer-${waypointId}-${config.type}`;
            const labelMarkerId = `alt-label-${waypointId}-${config.type}`;

            navigationMapInstance.addSource(sourceId, {
                type: 'geojson',
                data: config.data.geometry
            });
            navigationMapInstance.addLayer({
                id: layerId,
                type: 'line',
                source: sourceId,
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                paint: {
                    'line-color': config.color,
                    'line-width': (navigationMapInstance && navigationMapInstance.getPitch() > 20) ? 12 : 8,
                    'line-opacity': 0.8
                }
            });

            const midPoint = turf.along(config.data.geometry, turf.length(config.data.geometry) / 2).geometry.coordinates;
            const labelElement = createRouteLabelMarker(config.label, config.color);
            const labelMarker = new mapboxgl.Marker({ element: labelElement })
                .setLngLat(midPoint)
                .addTo(navigationMapInstance);
            
            labelMarker.getElement().addEventListener('click', (e) => {
                e.stopPropagation(); 
                selectAlternativeRoute(waypointId, config.type);
            });

            alternativeRouteLayers.push({ sourceId, layerId, labelMarker });
        }
    });
}


// ===================================================================
// NOMBRE: clearAlternativeRoutesDisplay (VERSIN FINAL CON REINTENTOS)
// RESUMEN: Inicia el proceso de limpieza de rutas alternativas, delegando
//          la lgica a una funcin auxiliar con reintentos para mxima robustez.
// ===================================================================
function clearAlternativeRoutesDisplay() {
    if (!navigationMapInstance) {
        alternativeRouteLayers = [];
        return;
    }

    // Copiamos los elementos a borrar y reseteamos el array principal inmediatamente.
    // Esto evita que nuevas rutas se aadan mientras limpiamos las antiguas.
    const itemsToClear = [...alternativeRouteLayers];
    alternativeRouteLayers = [];

    // Inicia el primer intento de limpieza.
    attemptClear(itemsToClear, 1);
}

// ===================================================================
// NOMBRE: attemptClear (NUEVA FUNCIN AUXILIAR)
// RESUMEN: Intenta limpiar los elementos de la ruta. Si alguno falla,
//          reintenta la operacin para los elementos fallidos tras una breve espera.
// ===================================================================
function attemptClear(itemsToClear, attemptNumber) {
    const MAX_ATTEMPTS = 5;
    const RETRY_DELAY_MS = 100; // 100 milisegundos

    if (attemptNumber > MAX_ATTEMPTS || itemsToClear.length === 0) {
        if (itemsToClear.length > 0) {
            console.error(`Fallo definitivo al limpiar ${itemsToClear.length} elementos de ruta alternativa tras ${MAX_ATTEMPTS} intentos.`);
        }
        return; // Detenemos la recursin
    }

    const failedItems = [];

    // 1. Borrado robusto de iconos (se hace una sola vez, es muy fiable)
    if (attemptNumber === 1) {
        document.querySelectorAll('.route-label-marker').forEach(el => el.remove());
    }

    // 2. Intento de borrado de trazados (capas y fuentes)
    itemsToClear.forEach(item => {
        let success = true;
        try {
            if (navigationMapInstance.getLayer(item.layerId)) {
                navigationMapInstance.removeLayer(item.layerId);
            }
            if (navigationMapInstance.getSource(item.sourceId)) {
                navigationMapInstance.removeSource(item.sourceId);
            }
            // El marcador ya fue borrado en el primer intento, aqu solo limpiamos referencias
            if (item.labelMarker && typeof item.labelMarker.remove === 'function') {
                item.labelMarker.remove();
            }
        } catch (e) {
            success = false;
            failedItems.push(item); // Si falla, lo aadimos a la lista de reintento
        }
    });

    // 3. Si algn elemento fall, programamos un reintento
    if (failedItems.length > 0) {
        setTimeout(() => {
            attemptClear(failedItems, attemptNumber + 1);
        }, RETRY_DELAY_MS);
    }
}


    
// ===================================================================
// NOMBRE: fetchAndDisplayAlternativeRoutes (NUEVA FUNCIN)
// RESUMEN: Obtiene y muestra las rutas alternativas para una etapa especfica.
async function fetchAndDisplayAlternativeRoutes(waypointId) {
    if (alternativeRoutesCache.has(waypointId)) {
        drawAlternativeRoutes(waypointId, alternativeRoutesCache.get(waypointId));
        return;
    }

    const endWaypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    if (endWaypointIndex < 1) return;

    let startWaypoint = null;
    for (let i = endWaypointIndex - 1; i >= 0; i--) {
        if (navigationWaypoints[i] && !navigationWaypoints[i].isInternal) {
            startWaypoint = navigationWaypoints[i];
            break;
        }
    }
    
    if (!startWaypoint) return;
    const endWaypoint = navigationWaypoints[endWaypointIndex];

    const url = `${OSRM_SERVICE_URL}/driving/${startWaypoint.lng},${startWaypoint.lat};${endWaypoint.lng},${endWaypoint.lat}?alternatives=true&overview=full&geometries=geojson&steps=false`;

    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Respuesta de red no fue OK');
        const data = await response.json();

        if (!data.routes || data.routes.length < 1) {
             showToast("NO HAY RUTAS ALTERNATIVAS", "info");
            return;
        }

        const fastestRoute = data.routes[0];
        const shortestRoute = [...data.routes].sort((a, b) => a.distance - b.distance)[0];
        const alternativeRoute = data.routes.find(r => r !== fastestRoute && r !== shortestRoute) || null;
        
        if (fastestRoute === shortestRoute && !alternativeRoute) {
            showToast("NO HAY RUTAS ALTERNATIVAS", "info");
            return;
        }

        const routesData = {
            fastest: fastestRoute,
            shortest: fastestRoute === shortestRoute ? null : shortestRoute,
            alternative: alternativeRoute
        };

        alternativeRoutesCache.set(waypointId, routesData);
        drawAlternativeRoutes(waypointId, routesData);

    } catch (error) {
        showToast("Error al obtener rutas alternativas", "error");
    }
}
   
// ===================================================================
// NOMBRE: cancelAutoStartNav (NUEVA FUNCIN)
// RESUMEN: Cancela la navegacin automtica iniciada al cargar una ruta.
function cancelAutoStartNav(toastId) {
    if (autoStartNavTimer) {
        clearInterval(autoStartNavTimer);
        autoStartNavTimer = null;
    }
    const toastElement = document.getElementById(toastId);
    if (toastElement) {
        toastElement.remove();
        activeToasts = activeToasts.filter(t => t.id !== toastId);
    }
    }
window.cancelAutoStartNav = cancelAutoStartNav;

 
// ===================================================================
// NOMBRE: showChargingPointModal (MODIFICADA - PARA MAPBOX POPUP)
// RESUMEN: Crea y muestra un modal detallado para un punto de recarga OCM.
function showChargingPointModal(point, index) {
    const existingModal = document.querySelector('.ocm-modal-overlay');
    if (existingModal) existingModal.remove();

    const overlay = document.createElement('div');
    overlay.className = 'ocm-modal-overlay';

    const photoUrl = (point.MediaItems && point.MediaItems.length > 0 && point.MediaItems[0].ItemURL) 
        ? point.MediaItems[0].ItemURL 
        : 'https://boardinggate.github.io/Tesla/PNG/PDREJEMPLO.PNG';
    
    const addressInfo = point.AddressInfo || {};
    const stationName = addressInfo.Title || 'Punto de Recarga';
    
    let addressParts = [];
    if (addressInfo.AddressLine1) addressParts.push(addressInfo.AddressLine1);
    
    const locationName = addressInfo.Town || addressInfo.StateOrProvince;
    if (addressInfo.Postcode && locationName) {
        addressParts.push(`${addressInfo.Postcode} - ${locationName}`);
    } else if (addressInfo.Postcode) {
        addressParts.push(addressInfo.Postcode);
    } else if (locationName) {
        addressParts.push(locationName);
    }
    const addressHtml = addressParts.join('<br>');

    const operatorInfo = point.OperatorInfo || {};

    let detailsHtml = '<h4>Detalles de Ubicacin</h4>';
    detailsHtml += `<p><strong>Direccin Completa:</strong> ${addressInfo.Title}</p>`;
    detailsHtml += `<p><strong>Lat/Lon:</strong> ${addressInfo.Latitude.toFixed(5)}, ${addressInfo.Longitude.toFixed(5)}</p>`;
    
    const lat = addressInfo.Latitude;
    const lon = addressInfo.Longitude;
    const zoom = 17;

    const googleUrl = `https://www.google.com/maps/search/electric+vehicle+charging+stations/@${lat},${lon},${zoom}z`;
    const electroverseUrl = `https://electroverse.com/map?search=${lat}%2C${lon}`;
    const electromapsUrl = `https://map.electromaps.com/es/p/${lat},${lon}`;
    const reveUrl = "https://www.mapareve.es/mapa-puntos-recarga";

    detailsHtml += `
        <div class="ocm-external-links-container">
            <div class="ocm-external-links-left-group">
                <span class="ocm-external-links-label">Abrir en...</span>
                <p class="ocm-external-links-note">
                    <span style="font-size: 0.6rem;">(*) Para volver retroceda en el browser</span>
                </p>
            </div>
            <div class="ocm-external-links-buttons">
                <a href="${googleUrl}" target="_blank" rel="noopener noreferrer" class="ocm-external-link-btn" title="Abrir en Google Maps" onclick="event.stopPropagation();">
                    <img src="https://www.google.com/s2/favicons?domain=maps.google.com&sz=64" alt="Google Maps">
                </a>
                <a href="${reveUrl}" target="_blank" rel="noopener noreferrer" class="ocm-external-link-btn" title="Abrir en REVE (no admite localizacin)" onclick="event.stopPropagation();">
                    <img src="https://www.google.com/s2/favicons?domain=mapareve.es&sz=64" alt="REVE">
                </a>
                <a href="${electroverseUrl}" target="_blank" rel="noopener noreferrer" class="ocm-external-link-btn" title="Abrir en Electroverse" onclick="event.stopPropagation();">
                    <img src="https://www.google.com/s2/favicons?domain=electroverse.com&sz=64" alt="Electroverse">
                </a>
                <a href="${electromapsUrl}" target="_blank" rel="noopener noreferrer" class="ocm-external-link-btn" title="Abrir en Electromaps" onclick="event.stopPropagation();">
                    <img src="https://www.google.com/s2/favicons?domain=electromaps.com&sz=64" alt="Electromaps">
                </a>
                <button class="ocm-external-link-btn" title="Enviar a la app de Tesla" onclick="handleSendToTeslaClick(${lat}, ${lon}, '${stationName.replace(/'/g, "\\'")}'); event.stopPropagation();">
                    <img src="https://boardinggate.github.io/Tesla/PNG/th.jpeg" alt="Enviar a Tesla">
                </button>
            </div>
        </div>
    `;

    detailsHtml += '<h4>Equipamiento / Tarifa</h4>';
    if (point.Connections && point.Connections.length > 0) {
        point.Connections.forEach(conn => {
            const connType = conn.ConnectionType ? conn.ConnectionType.Title.replace(' (Socket)', '').replace(' (Connector)', '') : 'Desconocido';
            const power = conn.PowerKW ? `${conn.PowerKW.toFixed(0)} kW` : '';
            const status = conn.StatusType ? `(${translateOcmTerm(conn.StatusType.Title)})` : '';
            detailsHtml += `
                <div class="ocm-connection-item">
                    <span class="ocm-connection-type"> ${connType}</span>
                    <span class="ocm-connection-power-status">${power} ${status}</span>
                </div>`;
        });
    } else {
        detailsHtml += '<p>No hay informacin de conectores.</p>';
    }
    if (point.UsageCost) detailsHtml += `<p class="ocm-price-info"><strong>${point.UsageCost}</strong></p>`;

    detailsHtml += '<h4>Restricciones de Uso</h4>';
    detailsHtml += `<p><strong>Estado:</strong> ${translateOcmTerm(point.StatusType?.Title)}</p>`;
    detailsHtml += `<p><strong>Uso:</strong> ${translateOcmTerm(point.UsageType?.Title)}</p>`;

    detailsHtml += '<h4>Operador/Red</h4>';
    detailsHtml += `<p><strong>Nombre:</strong> ${operatorInfo.Title || 'No especificado'}</p>`;
    if (operatorInfo.WebsiteURL) detailsHtml += `<p><strong>Web:</strong> <a href="${operatorInfo.WebsiteURL}" target="_blank" rel="noopener noreferrer">${operatorInfo.WebsiteURL}</a></p>`;
    if (operatorInfo.PhonePrimaryContact) detailsHtml += `<p><strong>Telfono:</strong> <a href="tel:${operatorInfo.PhonePrimaryContact}">${operatorInfo.PhonePrimaryContact}</a></p>`;

    let photosHtml = '<div class="ocm-photo-grid">';
    if (point.MediaItems && point.MediaItems.length > 0) {
        point.MediaItems.forEach(item => {
            if (item.ItemURL) {
                 photosHtml += `<img src="${item.ItemURL}" alt="${item.Comment || 'Foto del punto de recarga'}" data-full-url="${item.ItemURL}">`;
            }
        });
    } else {
        photosHtml += '<p>No hay fotografas disponibles para este punto.</p>';
    }
    photosHtml += '</div>';

    let commentsHtml = '<ul class="ocm-comment-list">';
    if (point.UserComments && point.UserComments.length > 0) {
        point.UserComments.forEach(comment => {
            commentsHtml += `
                <li class="ocm-comment">
                    <div class="ocm-comment-header">
                        <span class="user">${comment.UserName || 'Annimo'}</span>
                        <span class="date">${comment.DateCreated ? formatDateToDDMMMYY(comment.DateCreated.split('T')[0]) : ''}</span>
                    </div>
                    <p class="comment-text">${comment.Comment}</p>
                </li>`;
        });
    } else {
        commentsHtml += '<p>No hay comentarios para este punto.</p>';
    }
    commentsHtml += '</ul>';

    overlay.innerHTML = `
        <div class="ocm-modal-content">
            <div class="ocm-modal-header" style="background-image: url('${photoUrl}')">
                <div class="ocm-modal-station-name-wrapper">
                    <span class="ocm-modal-station-name">${stationName}</span>
                </div>
                <div class="ocm-modal-address">${addressHtml}</div>
            </div>
            <div class="ocm-modal-tabs">
                <div class="ocm-modal-tab active" data-panel="details">DETALLES</div>
                <div class="ocm-modal-tab" data-panel="photos">FOTOS (${point.MediaItems?.length || 0})</div>
                <div class="ocm-modal-tab" data-panel="comments">COMENTARIOS (${point.UserComments?.length || 0})</div>
            </div>
            <div class="ocm-modal-body">
                <div id="ocm-panel-details" class="ocm-modal-panel active">${detailsHtml}</div>
                <div id="ocm-panel-photos" class="ocm-modal-panel">${photosHtml}</div>
                <div id="ocm-panel-comments" class="ocm-modal-panel">${commentsHtml}</div>
            </div>
            <div class="ocm-modal-footer">
                <button id="ocm-add-route-btn" data-index="${index}">Aadir a la Ruta</button>
                <button id="ocm-close-btn">Salir</button>
            </div>
        </div>
    `;

    const mapModalContainer = document.getElementById('reminders-location-map-modal');
    if (mapModalContainer) {
        mapModalContainer.appendChild(overlay);
    } else {
        document.body.appendChild(overlay);
    }

    const closeBtn = overlay.querySelector('#ocm-close-btn');
    let modalTimer = null;

    const closeHandler = () => {
        if (modalTimer) clearInterval(modalTimer);
        if (overlay.parentNode) {
            overlay.remove();
        }
    };
    closeBtn.addEventListener('click', closeHandler);
    
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            closeHandler();
        }
    });
    
    overlay.querySelector('#ocm-add-route-btn').addEventListener('click', (e) => {
        const pointIndex = parseInt(e.target.dataset.index);
        addChargingPointToRoute(pointIndex);
        closeHandler();
    });

    overlay.querySelectorAll('.ocm-modal-tab').forEach(tab => {
        tab.addEventListener('click', () => {
            overlay.querySelectorAll('.ocm-modal-tab').forEach(t => t.classList.remove('active'));
            overlay.querySelectorAll('.ocm-modal-panel').forEach(p => p.classList.remove('active'));
            tab.classList.add('active');
            overlay.querySelector(`#ocm-panel-${tab.dataset.panel}`).classList.add('active');
        });
    });

    overlay.querySelectorAll('.ocm-photo-grid img').forEach(img => {
        img.addEventListener('click', () => {
            showPhotoModal(img.dataset.fullUrl);
        });
    });

    let countdown = 70;
    const countdownSpan = document.createElement('span');
    countdownSpan.className = 'button-countdown-timer';
    countdownSpan.textContent = ` (${countdown})`;
    closeBtn.appendChild(countdownSpan);

    modalTimer = setInterval(() => {
        countdown--;
        countdownSpan.textContent = ` (${countdown})`;
        if (countdown <= 0) {
            closeHandler();
        }
    }, 1000);
}

// ===================================================================
// NOMBRE: showShareStageModal (NUEVA FUNCIN)
// RESUMEN: Muestra un modal para que el usuario seleccione qu etapa de una ruta compartir.
function showShareStageModal(routeObject) {
    if (!routeObject || !routeObject.waypoints || routeObject.waypoints.length === 0) {
        showToast("No hay etapas para compartir en esta ruta.", "error");
        return;
    }

    const existingOverlay = document.getElementById('share-stage-modal-overlay');
    if (existingOverlay) existingOverlay.remove();

    const overlay = document.createElement('div');
    overlay.id = 'share-stage-modal-overlay';
    overlay.className = 'route-modal-overlay';

    const modalContent = document.createElement('div');
    modalContent.id = 'share-stage-modal';
    modalContent.className = 'route-modal-container';

    modalContent.innerHTML = `
        <div class="route-modal-header" style="background-image: url('https://boardinggate.github.io/Tesla/PNG/modalrutas.png');">
            <div class="route-modal-title-card">
                <span class="route-modal-title">Compartir Etapa de Ruta</span>
            </div>
        </div>
        <div class="route-modal-body">
            <p style="margin-bottom: 15px; font-weight: 500; color: #333;">Selecciona una etapa para compartir sus coordenadas:</p>
            <div class="route-scroll-container">
                <ul id="share-stage-list" class="route-list"></ul>
            </div>
        </div>
        <div class="route-modal-footer">
            <button id="cancel-share-stage" class="btn-modal-action-secondary">Cancelar</button>
        </div>
    `;

    overlay.appendChild(modalContent);
    document.body.appendChild(overlay);

    const listElement = modalContent.querySelector('#share-stage-list');
    const cancelButton = modalContent.querySelector('#cancel-share-stage');

    const closeShareModal = () => {
        clearModalAutoCloseTimer(overlay, cancelButton, 'share-stage-modal');
        if (overlay.parentNode) overlay.remove();
    };

    routeObject.waypoints.forEach((waypoint, index) => {
        const li = document.createElement('li');
        li.className = 'route-list-item';
        li.style.cursor = 'pointer';

        const stageLabel = waypoint.type === 'S' ? 'Salida' : (waypoint.type === 'F' ? 'Destino' : `Etapa ${waypoint.label}`);
        const addressText = waypoint.address || `(${waypoint.lat.toFixed(4)}, ${waypoint.lng.toFixed(4)})`;

        li.innerHTML = `<span class="route-name" style="color: #105a52;"><strong>${stageLabel}:</strong> ${addressText}</span>`;
        
        li.addEventListener('click', () => {
            handleSendToTeslaClick(waypoint.lat, waypoint.lng, addressText);
            closeShareModal();
        });
        
        listElement.appendChild(li);
    });

    cancelButton.addEventListener('click', closeShareModal);
    addModalAutoCloseTimer(overlay, cancelButton, 'share-stage-modal', 25000);
}

// ===================================================================
// NOMBRE: getChargingPointColorByPower
// RESUMEN: Devuelve un color hexadecimal basado en el rango de potencia del PDR.
function getChargingPointColorByPower(power) {
    if (isNaN(power)) {
        return '#5e5e5e'; }
    if (power >= 0 && power <= 50) {
        return '#0f130c'; 
    } else if (power > 50 && power <= 100) {
        return '#007863'; 
    } else if (power > 100 && power <= 250) {
        return 'rgb(30, 144, 255)'; 
    } else if (power > 250 && power <= 2000) {
        return '#de2e03'; 
    }
    return '#5e5e5e'; 
}  

// ===================================================================
// NOMBRE: showPhotoModal
// RESUMEN: Muestra una imagen en un modal superpuesto.
function showPhotoModal(imageUrl) {
    const existingModal = document.querySelector('.ocm-photo-modal-overlay');
    if (existingModal) existingModal.remove();

    const overlay = document.createElement('div');
    overlay.className = 'ocm-photo-modal-overlay';
    
    overlay.innerHTML = `
        <div class="ocm-photo-modal-content">
            <img src="${imageUrl}" alt="Vista ampliada del punto de recarga">
            <div class="ocm-photo-modal-close-btn" title="Cerrar imagen"></div>
        </div>
    `;

    document.body.appendChild(overlay);

    const close = () => {
        if (overlay.parentNode) {
            overlay.remove();
        }
    };
    overlay.querySelector('.ocm-photo-modal-close-btn').addEventListener('click', close);
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            close();
        }
    });
}
// ===================================================================
// NOMBRE: startFreeDrive (MODIFICADA - LIMPIEZA INICIAL)
// RESUMEN: Inicia el modo de conduccin libre, limpiando marcadores de velocidad anteriores.
function startFreeDrive(initialCoords) {
    if (isFreeDriveActive || isNavigating) return;

    clearSpeedMarkers();
    isFreeDriveActive = true;
    isFreeDrivePaused = false;
    freeDriveStats = {
        startTime: new Date(),
        totalDistance: 0,
        lastPosition: { ...initialCoords },
    };

    navigationStartTimeForStats = new Date();
    totalDistanceTravelledForStats = 0;
    maxSpeedDuringTrip = 0;
    maxSpeedCoordinates = null;
    maxAltitudeDuringTrip = -Infinity;
    minAltitudeDuringTrip = Infinity;
    window.averageSpeedKmh = 0;
    lastPositionForStats = { ...initialCoords };
    
    showToast("Grabacin de viaje en modo libre iniciada.", "success");

    navigationFollowUser = true;
    shouldCenterOnUser = true;
    const locateMeButton = document.getElementById('locate-me-on-reminders-map');
    const locateMeImg = locateMeButton ? locateMeButton.querySelector('img') : null;
    if (locateMeButton && locateMeImg) {
        locateMeImg.src = "PNG/DEJARSEGUIR.PNG";
        locateMeButton.title = "Dejar de centrar el mapa en mi posicin";
    }
    toggleMapHeaderRowsVisibility(false);
    showMapInfoOverlay("Modo FREE DRIVE sin destino conocido");

    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviacin ETA'; 
    initializeNavigationGraph();
}
    
// ===================================================================
// NOMBRE: stopFreeDrive
// RESUMEN: Detiene el modo de conduccin libre y muestra el modal de estadsticas.
function stopFreeDrive() {
    if (!isFreeDriveActive) return;

    const statsToSend = { ...freeDriveStats };
    showArrivalStatsModal(statsToSend);

    isFreeDriveActive = false;
    isFreeDrivePaused = false;
    freeDriveStats = null;
    tripStartLocationForStats = null;

    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    clearNavigationGraph();
    showMapInfoOverlay("Modo FREE DRIVE fin de viaje");
}

// ===================================================================
// NOMBRE: updateNavigationProgressDisplay (VERSIN CON VISIBILIDAD CORREGIDA)
// RESUMEN: Muestra y actualiza la interfaz de progreso de la ruta.
function updateNavigationProgressDisplay(route, carDistanceAlongTheRoute = 0) {
    const progressBarContainer = document.getElementById('navigation-bottom-progress-bar');
    if (!progressBarContainer) return;

    const topInfoBar = document.getElementById('navigation-top-info-bar');
    const overallProgressContainer = document.getElementById('route-overall-progress-container');
    const etaInfoContainer = document.getElementById('navigation-eta-info');
    const distanceBar = document.getElementById('distance-progress-bar-to-turn-container');
    const hrSeparator = progressBarContainer.querySelector('hr');
    let freeDriveCard = document.getElementById('free-drive-stats-card');
    
    if (isFreeDriveActive) {
        progressBarContainer.style.display = 'flex'; // Mostrar la barra
        progressBarContainer.style.minWidth = 'auto';
        progressBarContainer.style.width = 'auto';
        if (topInfoBar) topInfoBar.style.display = 'none';
        if (overallProgressContainer) overallProgressContainer.style.display = 'none';
        if (etaInfoContainer) etaInfoContainer.style.display = 'none';
        if (distanceBar) distanceBar.style.display = 'none';
        if (hrSeparator) hrSeparator.style.display = 'none';
    } else if (route && typeof route.distance === 'number') {
        progressBarContainer.style.display = 'flex'; // Mostrar la barra
        progressBarContainer.style.minWidth = '480px';
        progressBarContainer.style.width = 'auto';
        if (topInfoBar) topInfoBar.style.display = 'flex';
        if (overallProgressContainer) overallProgressContainer.style.display = 'block';
        if (etaInfoContainer) etaInfoContainer.style.display = 'flex';
        if (distanceBar) distanceBar.style.display = 'block';
        if (hrSeparator) hrSeparator.style.display = 'block';
    } else {
        progressBarContainer.style.display = 'none'; // Ocultar si no hay ruta ni free drive
        return;
    }
  
    if (isFreeDriveActive) {
        if (!freeDriveCard) {
            freeDriveCard = document.createElement('div');
            freeDriveCard.id = 'free-drive-stats-card';
            progressBarContainer.appendChild(freeDriveCard);
        }
        freeDriveCard.style.display = 'block';

        const kmRealizadosTexto = `${(totalDistanceTravelledForStats / 1000).toFixed(1)} km`;
        const startTime = freeDriveStats ? freeDriveStats.startTime : new Date();
        const startTimeFormatted = `${startTime.getHours().toString().padStart(2, '0')}:${startTime.getMinutes().toString().padStart(2, '0')}`;
        const durationMs = Date.now() - startTime.getTime();
        const totalTravelSeconds = Math.floor(durationMs / 1000); 
        const travelHours = Math.floor(totalTravelSeconds / 3600);
        const travelMinutes = Math.floor((totalTravelSeconds % 3600) / 60);
        const travelSeconds = totalTravelSeconds % 60;
        const travelTimeFormatted = `${String(travelHours).padStart(2, '0')}:${String(travelMinutes).padStart(2, '0')}:${String(travelSeconds).padStart(2, '0')}`;
       
        freeDriveCard.innerHTML = `
            <div class="free-drive-card-content">
                <div class="fd-title">Modo Free Drive</div>
                <div class="fd-stats-grid">
                    <div class="fd-label">Distancia</div>
                    <div class="fd-label">Inicio</div>
                    <div class="fd-label">Duracin</div>
                    <div class="fd-data">${kmRealizadosTexto}</div>
                    <div class="fd-data">${startTimeFormatted}</div>
                    <div class="fd-data">${travelTimeFormatted}</div>
                </div>
            </div>
        `;
        return;
    }

    if (freeDriveCard) {
        freeDriveCard.style.display = 'none';
    }
    
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    if (!route || typeof route.distance !== 'number' || typeof route.duration !== 'number' || actualWaypoints.length < 2) {
        return;
    }
    const overallProgressFill = document.getElementById('route-overall-progress');
    const routeProgressTextEl = document.getElementById('route-progress-text');
    const routeProgressIconEl = document.getElementById('route-progress-icon');
    const nextStageDistEl = document.getElementById('next-stage-distance');
    const nextStageTimeEl = document.getElementById('next-stage-time');
    const nextStageEtaEl = document.getElementById('next-stage-eta');
    const nextStageDeviationEl = document.getElementById('next-stage-eta-deviation');
    const finalDestDistEl = document.getElementById('final-destination-distance');
    const finalDestTimeEl = document.getElementById('final-destination-time');
    const finalDestEtaEl = document.getElementById('final-destination-eta');
    const finalDestDeviationEl = document.getElementById('final-destination-eta-deviation');
    const nextStageInfoDiv = document.getElementById('next-stage-info');
    const finalDestInfoDiv = document.getElementById('final-destination-info');
    const nextStageLabelEl = document.getElementById('next-stage-label');
    const totalJourneyDistanceForBar = (accumulatedDistanceBeforeCurrentSegment || 0) + route.distance;
    const currentJourneyDistanceForBar = (accumulatedDistanceBeforeCurrentSegment || 0) + carDistanceAlongTheRoute;
    const progressPercent = totalJourneyDistanceForBar > 0 ? (currentJourneyDistanceForBar / totalJourneyDistanceForBar) * 100 : 0;
    overallProgressFill.style.width = `${Math.min(100, progressPercent)}%`;
    if (routeProgressIconEl) {
        if (progressPercent > 0 && progressPercent < 100) {
            routeProgressIconEl.style.display = 'block';
        } else {
            routeProgressIconEl.style.display = 'none';
        }
    }
    if (routeProgressTextEl) {
        let kmRecorridosTexto = "-- km";
        let timeInfoString = ""; 
        if (navigationCurrentRouteData) { 
            if (isNavigating && navigationStartTimeForStats) {
                kmRecorridosTexto = `${(totalDistanceTravelledForStats / 1000).toFixed(1)} km`;
                const startTimeFormatted = `${navigationStartTimeForStats.getHours().toString().padStart(2, '0')}:${navigationStartTimeForStats.getMinutes().toString().padStart(2, '0')}`;
                const nowForTravelTime = new Date();
                const durationMs = nowForTravelTime - navigationStartTimeForStats;
                const totalTravelMinutes = Math.floor(durationMs / (1000 * 60));
                const travelHours = Math.floor(totalTravelMinutes / 60);
                const travelMinutes = totalTravelMinutes % 60;
                const travelTimeFormatted = `${String(travelHours).padStart(2, '0')}:${String(travelMinutes).padStart(2, '0')}`;
                timeInfoString = ` (${startTimeFormatted}  ${travelTimeFormatted})`;
            } else { 
                kmRecorridosTexto = "0.0 km";
                timeInfoString = ` (Stop)`;
            }
        } else { 
            kmRecorridosTexto = "-- km";
            timeInfoString = " (--:--  --:--)";
        }
        routeProgressTextEl.innerHTML = `${kmRecorridosTexto}${timeInfoString}`;
    }
    const remainingDistanceTotal = Math.max(0, route.distance - carDistanceAlongTheRoute);
    const remainingDurationTotal = route.distance > 0 ? route.duration * (remainingDistanceTotal / route.distance) : 0;
    finalDestDistEl.textContent = `${(remainingDistanceTotal / 1000).toFixed(1)} km`;
    const finalDestTotalMinutes = Math.round(remainingDurationTotal / 60);
    const finalDestHours = Math.floor(finalDestTotalMinutes / 60);
    const finalDestMinutes = finalDestTotalMinutes % 60;
    finalDestTimeEl.textContent = `${String(finalDestHours).padStart(2, '0')}:${String(finalDestMinutes).padStart(2, '0')}`;
    const currentFinalEta = new Date(Date.now() + remainingDurationTotal * 1000);
    finalDestEtaEl.textContent = currentFinalEta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    if (tripInitialOverallEtaTime && isNavigating && navigationStartTimeForStats) {
        const finalDeviationMs = currentFinalEta.getTime() - tripInitialOverallEtaTime.getTime();
        finalDestDeviationEl.innerHTML = formatDeviation(finalDeviationMs);
    } else {
        finalDestDeviationEl.innerHTML = "";
    }
    const hasUnvisitedIntermediateStages = actualWaypoints.some(wp => !wp.visited && wp.type === 'intermediate');
    if (hasUnvisitedIntermediateStages) {
        etaInfoContainer.classList.remove('single-destination');
        finalDestInfoDiv.classList.remove('single-destination-layout');
        nextStageInfoDiv.style.display = 'block';
        const totalRealStages = actualWaypoints.length - 1;
        const currentRealStageIndex = actualWaypoints.findIndex(wp => !wp.visited && wp.type !== 'S') -1;
        const nextStageWaypointObject = actualWaypoints.find(wp => !wp.visited && wp.type !== 'S');
        if (nextStageLabelEl && nextStageWaypointObject) {
            let stageDescription = nextStageWaypointObject.address || `Etapa ${nextStageWaypointObject.label}`;
            if (stageDescription.length > 20) {
                stageDescription = stageDescription.substring(0, 20) + '...';
            }
            nextStageLabelEl.textContent = `Etapa ${currentRealStageIndex + 1} de ${totalRealStages}: ${stageDescription}`;
        }
        let cumulativeDistanceToStartOfCurrentLegOSRM = 0;
        if (route.legs) {
            for (let i = 0; i < currentLegIndexNav; i++) {
                if (route.legs[i] && typeof route.legs[i].distance === 'number') {
                    cumulativeDistanceToStartOfCurrentLegOSRM += route.legs[i].distance;
                }
            }
        }
        const legForDisplay = route.legs[currentLegIndexNav];
        if (legForDisplay) {
            const distanceIntoCurrentLegDisplay = Math.max(0, carDistanceAlongTheRoute - cumulativeDistanceToStartOfCurrentLegOSRM);
            const remainingDistanceThisLegDisplay = Math.max(0, (legForDisplay.distance || 0) - distanceIntoCurrentLegDisplay);
            const remainingDurationThisLegDisplay = (legForDisplay.distance > 0 && typeof legForDisplay.duration === 'number') ? legForDisplay.duration * (remainingDistanceThisLegDisplay / legForDisplay.distance) : 0;
            nextStageDistEl.textContent = `${(remainingDistanceThisLegDisplay / 1000).toFixed(1)} km`;
            const nextStageTotalMinutes = Math.round(remainingDurationThisLegDisplay / 60);
            const nextStageHours = Math.floor(nextStageTotalMinutes / 60);
            const nextStageMinutes = nextStageTotalMinutes % 60;
            nextStageTimeEl.textContent = `${String(nextStageHours).padStart(2, '0')}:${String(nextStageMinutes).padStart(2, '0')}`;
            const currentNextStageEta = new Date(Date.now() + remainingDurationThisLegDisplay * 1000);
            nextStageEtaEl.textContent = currentNextStageEta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            if (currentStageInitialExpectedEtaTime && isNavigating && navigationStartTimeForStats) {
               const deviationStageMs = currentNextStageEta.getTime() - currentStageInitialExpectedEtaTime.getTime();
               nextStageDeviationEl.innerHTML = formatDeviation(accumulatedDeviationMs + deviationStageMs);
            } else {
               nextStageDeviationEl.innerHTML = "";
            }
        }
    } else {
        etaInfoContainer.classList.add('single-destination');
        finalDestInfoDiv.classList.add('single-destination-layout');
        nextStageInfoDiv.style.display = 'none';
        if(nextStageDeviationEl) nextStageDeviationEl.innerHTML = "";
    }
    overallProgressContainer.querySelectorAll('.waypoint-dot-on-progress-bar, .radar-marker-on-progress-bar, .task-marker-on-progress-bar').forEach(dot => dot.remove());
    
    if (actualWaypoints.length > 2 && totalJourneyDistanceForBar > 0 && typeof turf !== 'undefined' && navigationMapInstance.getSource('route') && navigationMapInstance.getSource('route')._data) {
        const routeGeoJSON = navigationMapInstance.getSource('route')._data;
        const routeLineString = turf.lineString(routeGeoJSON.geometry.coordinates);
        const startOfRoute = turf.point(routeLineString.geometry.coordinates[0]);
        for (let i = 1; i < actualWaypoints.length - 1; i++) {
            const waypoint = actualWaypoints[i];
            const waypointPoint = turf.point([waypoint.lng, waypoint.lat]);
            const nearestPointOnLine = turf.nearestPointOnLine(routeLineString, waypointPoint, { units: 'meters' });
            const lineSliceToWaypoint = turf.lineSlice(startOfRoute, nearestPointOnLine, routeLineString);
            const distanceToWaypoint = turf.length(lineSliceToWaypoint, { units: 'meters' });
            const totalDistanceWithAccumulated = (accumulatedDistanceBeforeCurrentSegment || 0) + distanceToWaypoint;
            const percent = (totalDistanceWithAccumulated / totalJourneyDistanceForBar) * 100;
            if (percent < 100 && percent > 0) { 
                const dot = document.createElement('div');
                dot.className = 'waypoint-dot-on-progress-bar';
                dot.style.left = `calc(${percent}% - 7px)`;
                dot.title = `Etapa ${waypoint.label}`;
                overallProgressContainer.appendChild(dot);
            }
        }
    }

    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresRutaCheckbox && radaresRutaCheckbox.checked && radaresEnRutaActual.length > 0 && totalJourneyDistanceForBar > 0) {
        radaresEnRutaActual.forEach(radar => {
            if (radar.distanceOnRoute !== undefined) {
                const totalDistanceToRadar = (accumulatedDistanceBeforeCurrentSegment || 0) + radar.distanceOnRoute;
                if(totalDistanceToRadar <= totalJourneyDistanceForBar) {
                    const percent = (totalDistanceToRadar / totalJourneyDistanceForBar) * 100;
                     if (percent >= 0 && percent <= 100) {
                        const radarMarker = document.createElement('div');
                        radarMarker.className = 'radar-marker-on-progress-bar';
                        radarMarker.style.left = `${percent}%`;
                        radarMarker.title = radar.text.replace(/<b>|<\/b>/gi, '');
                        overallProgressContainer.appendChild(radarMarker);
                    }
                }
            }
        });
    }
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasRutaCheckbox && tareasRutaCheckbox.checked && tareasEnRutaActual.length > 0 && totalJourneyDistanceForBar > 0) {
        tareasEnRutaActual.forEach(tarea => {
            if (tarea.distanceOnRoute !== undefined) {
                const totalDistanceToTask = (accumulatedDistanceBeforeCurrentSegment || 0) + tarea.distanceOnRoute;
                if(totalDistanceToTask <= totalJourneyDistanceForBar) {
                    const percent = (totalDistanceToTask / totalJourneyDistanceForBar) * 100;
                    if (percent >= 0 && percent <= 100) {
                        const taskMarker = document.createElement('div');
                        taskMarker.className = 'task-marker-on-progress-bar';
                        taskMarker.style.left = `${percent}%`;
                        taskMarker.title = tarea.text.replace(/<b>|<\/b>/gi, '');
                        overallProgressContainer.appendChild(taskMarker);
                    }
                }
            }
        });
    }
 
    if (isNavigating) {
        const destinationWp = navigationWaypoints[navigationWaypoints.length - 1];
        if (destinationWp && destinationWp.address) {
            const mapOverlay = document.getElementById('map-info-overlay');
            if (mapOverlay && !mapOverlay.textContent.startsWith("HA LLEGADO AL ")) {
                 showDestinationName();
            }
        }
    }
}
    
// ===================================================================
// NOMBRE: getAddressForWaypoint (MODIFICADA)
// RESUMEN: Obtiene la direccin o solo la calle de un punto de ruta.
async function getAddressForWaypoint(lat, lng, streetOnly = false) {
    if (typeof lat !== 'number' || typeof lng !== 'number' || isNaN(lat) || isNaN(lng)) {
        return "Ubicacin Desconocida";
    }
    try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=1&accept-language=es`);
        if (response.ok) {
            const data = await response.json();
            if (streetOnly) {
                return data.address?.road || "Calle desconocida";
            }
            return data.display_name || `(${lat.toFixed(3)}, ${lng.toFixed(3)})`;
        } else {
            return streetOnly ? "Calle desconocida" : `Etapa (${lat.toFixed(3)}, ${lng.toFixed(3)})`;
        }
    } catch (err) {
        return streetOnly ? "Calle desconocida" : `Etapa (${lat.toFixed(3)}, ${lng.toFixed(3)})`;
    }
}


    
// ===================================================================
// NOMBRE: openAlertModal
// RESUMEN: Abre el modal para que el usuario seleccione una incidencia de trfico.
function openAlertModal() {
   
    processTrafficAlerts();
    
    const alertModalOverlay = document.getElementById('alert-modal-overlay');
    const alertModalContent = document.getElementById('alert-modal-content');
    if (!alertModalOverlay || !alertModalContent) return;

    const alertOptions = [
        { code: 1, text: 'ACCIDENTE TRFICO', icon: 'PNG/AACCIDENTE.png' },
        { code: 2, text: 'COCHE AVERIADO', icon: 'PNG/AAVERIADO.png' },
        { code: 3, text: 'CONTROL TRFICO / RADAR', icon: 'PNG/AGUARDIA.png' },
        { code: 4, text: 'ATASCO', icon: 'PNG/AATASCO.png' },
        { code: 5, text: 'PELIGRO INDETERMINADO', icon: 'PNG/APELIGRO.png' },
        { code: 6, text: 'CARRETERA MAL ESTADO', icon: 'PNG/ARESVALAR.png' },
        { code: 7, text: 'OBRAS', icon: 'PNG/AOBRAS.png' },
        { code: 8, text: 'VA / CARRETERA CERRADA', icon: 'PNG/ACERRADA.png' }, 
        { code: 9, text: 'YA NO HAY NADA', icon: 'PNG/AANULAR.png' }           
    ];
    alertModalContent.innerHTML = '<div id="alert-columns-container"></div>';
    const columnsContainer = document.getElementById('alert-columns-container');

    const column1 = document.createElement('div');
    column1.className = 'alert-column';
    const column2 = document.createElement('div');
    column2.className = 'alert-column';

    alertOptions.forEach((option, index) => {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'alert-option';
        optionDiv.onclick = () => sendTrafficAlert(option.code, option.text);
        optionDiv.innerHTML = `<img src="${option.icon}" alt="${option.text}"><span>${option.text}</span>`;

        if (index < 5) {
            column1.appendChild(optionDiv);
        } else {
            column2.appendChild(optionDiv);
        }
    });

    const cancelButton = document.createElement('div');
    cancelButton.id = 'alert-cancel-button';
    cancelButton.innerHTML = '<span>CANCELAR <span id="alert-timer">(10)</span></span>';
    cancelButton.onclick = closeAlertModal;
    column2.appendChild(cancelButton); 

    columnsContainer.appendChild(column1);
    columnsContainer.appendChild(column2);

    alertModalOverlay.classList.remove('hidden');

    let countdown = 10;
    const timerSpan = document.getElementById('alert-timer');
    if (alertModalTimer) clearInterval(alertModalTimer);
    alertModalTimer = setInterval(() => {
        countdown--;
        if (timerSpan) timerSpan.textContent = `(${countdown})`;
        if (countdown <= 0) {
            closeAlertModal();
        }
    }, 1000);
}

// ===================================================================
// NOMBRE: formatOCMPoint
// RESUMEN: Convierte un punto de recarga del formato OCM a un formato interno estandarizado.
function formatOCMPoint(point) {
    if (!point || !point.AddressInfo) {
        return null;
    }

    let maxPower = 0;
    if (point.Connections && Array.isArray(point.Connections)) {
        point.Connections.forEach(conn => {
            if (conn.PowerKW && conn.PowerKW > maxPower) {
                maxPower = conn.PowerKW;
            }
        });
    }

    const totalPoints = point.NumberOfPoints || (point.Connections ? point.Connections.length : 0);
    const availabilityText = `${totalPoints} Poste${totalPoints !== 1 ? 's' : ''}`;

    let priceText = 'N/D';
    if (point.UsageCost) {
        const priceMatch = point.UsageCost.match(/(\d[\d,.]*)/);
        if (priceMatch && priceMatch[1]) {
            let priceNum = parseFloat(priceMatch[1].replace(',', '.'));
            if (!isNaN(priceNum) && priceNum > 0 && priceNum < 10) { 
                 priceText = `${priceNum.toFixed(2)} /kWh`;
            }
        }
    }

    return {
        ocmId: point.ID,
        lat: point.AddressInfo.Latitude,
        lon: point.AddressInfo.Longitude,
        address: point.AddressInfo.Title || 'Direccin no disponible',
        availabilityText: availabilityText,
        price: priceText,
        fullPriceInfo: point.UsageCost || 'N/D',
        power: maxPower > 0 ? maxPower.toFixed(0) : 'N/A',
        operator: point.OperatorInfo ? point.OperatorInfo.Title : 'Desconocido',
        usageType: point.UsageType ? point.UsageType.Title : 'No especificado',
        accessInfo: point.AddressInfo.AccessComments || 'No especificado',
        connections: point.Connections || []
    };
}



    
// ===================================================================
// NOMBRE: closeAlertModal
// RESUMEN: Cierra el modal de seleccin de incidencias y limpia su temporizador.
function closeAlertModal() {
    const alertModalOverlay = document.getElementById('alert-modal-overlay');
    if (alertModalOverlay) {
        alertModalOverlay.classList.add('hidden');
    }
    if (alertModalTimer) {
        clearInterval(alertModalTimer);
        alertModalTimer = null;
    }
}
// ===================================================================
// NOMBRE: sendTrafficAlert (VERSIN FINAL Y CORRECTA)
// RESUMEN: Enva la alerta, la aade a la cach local y redibuja el mapa al instante.
function sendTrafficAlert(alertCode, alertName) {
    const userId = localStorage.getItem('userData_userId');
    if (!userId) {
        showToast("Debes configurar un ID de Usuario para enviar alertas.", "warning");
        closeAlertModal();
        return;
    }
    closeAlertModal();
    const sendData = async (coords) => {
        if (!window.db || !window.doc || !window.setDoc || !window.collection) {
            showToast("Error: Firebase no est inicializado.", "error");
            return;
        }
        const alertData = {
            user: userId,
            code: alertCode,
            latitude: coords.latitude,
            longitude: coords.longitude,
            timestamp: new Date().toISOString()
        };

        try {
            const alertsCollectionRef = window.collection(window.db, "users", "ALERTAS", "events");
            const docId = `${Date.now()}_${userId.replace(/[^a-zA-Z0-9]/g, '_')}`;
            const newAlertRef = window.doc(alertsCollectionRef, docId);
            
            await window.setDoc(newAlertRef, alertData);

            const newAlertForCache = {
                id: docId,
                code: alertData.code,
                coordinates: { lat: alertData.latitude, lon: alertData.longitude }
            };
            
            const existingIndex = trafficAlertsCache.findIndex(a => a.id === newAlertForCache.id);
            if (existingIndex > -1) {
                trafficAlertsCache[existingIndex] = newAlertForCache; // Evita duplicados
            } else {
                trafficAlertsCache.push(newAlertForCache);
            }

            displayAlertsOnMap();
            showToast(`Alerta "${alertName}" enviada y mostrada en el mapa.`, "success");

        } catch (error) {
            showToast(`Error al enviar alerta a Firebase: ${error.message}`, "error");
        }
    };

    if (isSimulatingGpsLocation && simulatedGpsLocation) {
        sendData(simulatedGpsLocation);
    } else {
        getCurrentLocation(
            (realCoords) => { sendData(realCoords); },
            (errorMsg) => { showToast(`No se pudo obtener la ubicacin: ${errorMsg}`, "error"); }
        );
    }
}
    
// ===================================================================
// NOMBRE: processTrafficAlerts
// RESUMEN: Lgica principal que lee, limpia y actualiza las alertas desde Firebase.
async function processTrafficAlerts() {
    if (!window.db || !window.getDocs || !window.deleteDoc || !window.collection) {
        return;
    }
    
    lastAlertCheckTimestamp = Date.now();
    
    try {
        const alertsCollectionRef = window.collection(window.db, "users", "ALERTAS", "events");
        const querySnapshot = await window.getDocs(alertsCollectionRef);
        
        let allAlerts = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        const now = new Date();
        const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
        
        const removals = allAlerts.filter(alert => alert.code === 9);
        let activeAlerts = allAlerts.filter(alert => alert.code !== 9);

        for (const removal of removals) {
            const removalCoords = { lat: removal.latitude, lon: removal.longitude };
            const alertsToDelete = new Set();
            
            activeAlerts.forEach(alert => {
                if(alert.latitude && alert.longitude){
                    const alertCoords = { lat: alert.latitude, lon: alert.longitude };
                    if (calculateDistance(removalCoords.lat, removalCoords.lon, alertCoords.lat, alertCoords.lon) <= 800) {
                        alertsToDelete.add(alert.id);
                    }
                }
            });

            for (const idToDelete of alertsToDelete) {
                const docRef = window.doc(window.db, "users", "ALERTAS", "events", idToDelete);
                await window.deleteDoc(docRef);
            }
            
            const removalDocRef = window.doc(window.db, "users", "ALERTAS", "events", removal.id);
            await window.deleteDoc(removalDocRef);
        }

        activeAlerts = activeAlerts.filter(alert => {
            if (!alert.timestamp || new Date(alert.timestamp) < twentyFourHoursAgo) {
                const docRef = window.doc(window.db, "users", "ALERTAS", "events", alert.id);
                window.deleteDoc(docRef);
                return false;
            }
            return true;
        });
        
        trafficAlertsCache = activeAlerts.filter(alert => alert.latitude && alert.longitude).map(alert => ({
            id: alert.id,
            code: alert.code,
            coordinates: { lat: alert.latitude, lon: alert.longitude }
        }));
        
        displayAlertsOnMap(); 
        checkAlertsProximity();
      
    } catch (error) {
        console.error("Error procesando alertas de trfico: ", error);
    }
}


// ===================================================================
// NOMBRE: eliminarTareasDeMapa (NUEVA FUNCIN)
// RESUMEN: Elimina del mapa los marcadores de tareas/radares personales.
function eliminarTareasDeMapa() {
    reminderMapObjects = reminderMapObjects.filter(obj => {
        if (obj.isFromTarea) {
            if (obj.marker) obj.marker.remove();
            if (obj.circleId && navigationMapInstance.getLayer(obj.circleId)) {
                navigationMapInstance.removeLayer(obj.circleId);
            }
            if (obj.circleId && navigationMapInstance.getSource(obj.circleId)) {
                navigationMapInstance.removeSource(obj.circleId);
            }
            return false;
        }
        return true;
    });
}
// ===================================================================
// NOMBRE: createRadarAlertIcon (CORRECCIN FINAL - ANTI-ERROR)
// RESUMEN: Crea un icono de alerta escalable asegurando que devuelve un elemento DOM.
function createRadarAlertIcon(currentZoomLevel = null, isFromTarea = false) {
    const container = document.createElement('div'); 
    const SCALE_THRESHOLD_ZOOM = 16;
    const MIN_SCALE = 0.35;
    const MIN_ZOOM_FOR_SCALING = 10;
    let scale = 1.0;

    if (currentZoomLevel !== null && currentZoomLevel < SCALE_THRESHOLD_ZOOM) {
        if (currentZoomLevel <= MIN_ZOOM_FOR_SCALING) {
            scale = MIN_SCALE;
        } else {
            const progress = (currentZoomLevel - MIN_ZOOM_FOR_SCALING) / (SCALE_THRESHOLD_ZOOM - MIN_ZOOM_FOR_SCALING);
            scale = MIN_SCALE + (1 - MIN_SCALE) * progress;
        }
    }

    const baseSize = 55;
    const finalSize = Math.round(baseSize * scale);
    const finalBorderSize = Math.max(1, Math.round(3 * scale));
    
    const borderColor = isFromTarea ? '#00FF00' : 'white';

    container.className = 'radar-alert-circle';
    container.style.cssText = `width:${finalSize}px; height:${finalSize}px; border-width:${finalBorderSize}px; border-color:${borderColor};`;
    container.innerHTML = `<img src="PNG/RADAR.PNG" alt="Radar">`;
    
    return container; 
}
    
    
// ===================================================================
// NOMBRE: checkAlertsProximity
// RESUMEN: Comprueba la proximidad del vehculo a las alertas y muestra un aviso si es necesario.
function checkAlertsProximity() {
    if (!navigationCurrentLocation || trafficAlertsCache.length === 0) {
        return;
    }

    const carLat = navigationCurrentLocation.latitude;
    const carLon = navigationCurrentLocation.longitude;
    trafficAlertsCache.forEach(alert => {
        const distance = calculateDistance(carLat, carLon, alert.coordinates.lat, alert.coordinates.lon);
        if (distance <= 500 && !currentlyDisplayedProximityAlerts.has(alert.id)) {
            showProximityAlert(alert);
            currentlyDisplayedProximityAlerts.add(alert.id);
        }
    });
}
// ===================================================================
// NOMBRE: hideProximityAlert
// RESUMEN: Oculta el modal de aviso de proximidad.
function hideProximityAlert(alertId) {
    const proximityModal = document.getElementById('proximity-alert-modal');
    if (proximityModal) proximityModal.classList.add('hidden');
    document.getElementById('flashing-border-overlay').classList.add('hidden');
    
    if (proximityAlertTimer) {
        clearInterval(proximityAlertTimer);
        proximityAlertTimer = null;
    }
}
// ===================================================================
// NOMBRE: forceProcessTrafficAlerts
// RESUMEN: Lanza el proceso de actualizacin de alertas inmediatamente.
function forceProcessTrafficAlerts() {
    console.log("-> Forzando actualizacin inmediata de alertas de trfico...");
    lastAlertCheckTimestamp = Date.now();
    processTrafficAlerts();
}    
// ===================================================================
// NOMBRE: showProximityAlert
// RESUMEN: Muestra el modal de aviso de proximidad a una alerta de trfico.
function showProximityAlert(alert) {
    const proximityModal = document.getElementById('proximity-alert-modal');
    if (!proximityModal) return;

    const alertDetails = [
        null, 
        { text: 'ACCIDENTE TRFICO', icon: 'PNG/AACCIDENTE.png' },
        { text: 'COCHE AVERIADO', icon: 'PNG/AAVERIADO.png' },
        { text: 'CONTROL TRFICO / RADAR', icon: 'PNG/AGUARDIA.png' },
        { text: 'ATASCO', icon: 'PNG/AATASCO.png' },
        { text: 'PELIGRO INDETERMINADO', icon: 'PNG/APELIGRO.png' },
        { text: 'CARRETERA MAL ESTADO', icon: 'PNG/ARESVALAR.png' },
        { text: 'OBRAS', icon: 'PNG/AOBRAS.png' },
        null, 
        { text: 'VA / CARRETERA CERRADA', icon: 'PNG/ACERRADA.png' } 
    ][alert.code];

    if (!alertDetails) return;

    proximityModal.innerHTML = `
        <img src="${alertDetails.icon}" alt="${alertDetails.text}">
        <div class="content">
            <span class="alert-text">${alertDetails.text}</span>
            <button id="proximity-ok-button">ENTERADO <span id="proximity-timer">(10)</span></button>
        </div>
    `;

    document.getElementById('flashing-border-overlay').classList.remove('hidden');
    proximityModal.classList.remove('hidden');

    const okButton = document.getElementById('proximity-ok-button');
    const timerSpan = document.getElementById('proximity-timer');
    let countdown = 15;
    
    if (proximityAlertTimer) clearInterval(proximityAlertTimer);
    proximityAlertTimer = setInterval(() => {
        countdown--;
        if (timerSpan) timerSpan.textContent = `(${countdown})`;
        if (countdown <= 0) {
            hideProximityAlert(alert.id);
        }
    }, 1000);
    
    okButton.onclick = () => hideProximityAlert(alert.id);
}
// ===================================================================
// NOMBRE: loadRouteByName (VERSIN CORREGIDA)
// RESUMEN: Busca una ruta guardada por su nombre y llama a la funcin de carga genrica.
function loadRouteByName(routeName, autoStartNavigation = false) {
    const savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
    const recentRoutes = JSON.parse(localStorage.getItem('boardinggate_recent_routes') || "[]");
    let routeToLoad = savedRoutes.find(r => r.name.toUpperCase() === routeName.toUpperCase());
    if (!routeToLoad) {
        routeToLoad = recentRoutes.find(r => r.name.toUpperCase() === routeName.toUpperCase());
    }
    if (routeToLoad) {
        loadRouteFromObject(routeToLoad, autoStartNavigation);
    } else {
        showToast(`No se pudo cargar la ruta "${routeName}". No encontrada`, "error");
        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox) {
           localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked));
        }
        const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasRutaCheckbox) {
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
        }
    }
}
    
   
// ===================================================================
// NOMBRE: generateBackup
// RESUMEN: Genera un cdigo de backup con todos los datos locales y lo copia al portapapeles.
function generateBackup() {
    const backupData = {};
    managedKeys.forEach(key => {
        const value = localStorage.getItem(key);
        if (value !== null) {
            backupData[key] = value;
        }
    });
    const backupString = JSON.stringify(backupData);
    const backupDisplay = document.getElementById('config-backup-display');
    backupDisplay.value = btoa(unescape(encodeURIComponent(backupString)));
    backupDisplay.style.display = 'block';
    backupDisplay.select();
    try {
        document.execCommand('copy');
        showToast('Backup copiado al portapapeles', 'success');
         document.getElementById('config-backup-status').textContent = 'Copiado! Guarda este cdigo en un lugar seguro.';
         document.getElementById('config-backup-status').style.color = '#28a745';
    } catch (err) {
        showToast('Error al copiar. Por favor, copia manualmente', 'warning');
        document.getElementById('config-backup-status').textContent = 'Copia este cdigo manualmente y gurdalo.';
        document.getElementById('config-backup-status').style.color = '#ffc107';
    }
}

// ===================================================================
// NOMBRE: getManeuverIconFilename
// RESUMEN: Devuelve el nombre del fichero de imagen para una maniobra.
function getManeuverIconFilename(maneuver) {
    if (!maneuver) return 'PNG/continue.png';
    const type = maneuver.type || '';
    const modifier = maneuver.modifier || '';

    if (type.includes('roundabout') && maneuver.exit && maneuver.exit >= 1 && maneuver.exit <= 5 && getManeuverInstructionText(maneuver).toLowerCase().includes("salida")) {
        return `PNG/S${maneuver.exit}.PNG`;
    }
    if (type === 'depart') return 'PNG/depart.png';
    if (type === 'arrive') return 'PNG/arrive.png';
    if (type.includes('roundabout') || type.includes('rotary')) return 'PNG/roundabout.png';
    
    if (modifier.includes('uturn')) return 'PNG/uturn.png';
    if (modifier.includes('sharp right')) return 'PNG/sharp-right.png';
    if (modifier.includes('sharp left')) return 'PNG/sharp-left.png';
    if (modifier.includes('slight right') || modifier.includes('bear right')) return 'PNG/bear-right.png';
    if (modifier.includes('slight left') || modifier.includes('bear left')) return 'PNG/bear-left.png';
    if (modifier.includes('right')) return 'PNG/turn-right.png';
    if (modifier.includes('left')) return 'PNG/turn-left.png';
    if (modifier.includes('ramp')) return 'PNG/ramp.png';
    return 'PNG/continue.png'; 
}
    
// ===================================================================
// NOMBRE: getSuggestedRouteName
// RESUMEN: Sugiere un nombre de ruta por defecto basado en la ubicacin final.
async function getSuggestedRouteName(lat, lng, isMultiStage = false, totalWaypoints = 0) {
    let baseName = `RUTA: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
    try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=1&accept-language=es`);
        if (response.ok) {
            const data = await response.json();
            if (data.address) {
                const road = data.address.road;
                const city = data.address.city || data.address.town || data.address.village || data.address.hamlet;
                if (road && city) baseName = `${road}, ${city}`;
                else if (city) baseName = city;
                else if (road) baseName = road;
            }
        }
    } catch (e) {
    }
    if (isMultiStage) {
        const numStages = Math.max(0, totalWaypoints - 1);
        return `${numStages} ETAPAS: ${baseName}`;
    } else {
        return `  ${baseName}`;
    }
}
    
// ===================================================================
// NOMBRE: initializeConfigModalListeners
// RESUMEN: Asigna los listeners a todos los elementos interactivos del modal de configuracin.
function initializeConfigModalListeners() {
    document.getElementById('config-save-user-firebase')?.addEventListener('click', validateAndSaveUserToFirebase);
    document.getElementById('config-save-user-firebase-from-backup-tab')?.addEventListener('click', validateAndSaveUserToFirebase);
    document.getElementById('config-restore-backup-firebase')?.addEventListener('click', restoreBackupFromFirebase);
    document.getElementById('config-save-pin')?.addEventListener('click', savePinSettings);
    document.getElementById('config-remove-pin')?.addEventListener('click', removePinSettings);
    document.getElementById('config-generate-backup')?.addEventListener('click', generateBackup);
    document.getElementById('config-restore-backup')?.addEventListener('click', restoreBackup);
    document.getElementById('config-restore-grid-button')?.addEventListener('click', restoreOriginalGrid);
    document.getElementById('config-clear-cache')?.addEventListener('click', clearAllLocalData);

    const importBtn = document.getElementById('import-radars-button');
    if (importBtn && !importBtn.dataset.listenerAttached) {
        importBtn.addEventListener('click', importRadars);
        importBtn.dataset.listenerAttached = "true";
    }

    const deleteBtn = document.getElementById('delete-filtered-radars-button');
    if (deleteBtn && !deleteBtn.dataset.listenerAttached) {
        deleteBtn.addEventListener('click', deleteFilteredRadars);
        deleteBtn.dataset.listenerAttached = "true";
    }

    const acceptTermsButton = document.getElementById('accept-terms-button');
    if (acceptTermsButton && !acceptTermsButton.dataset.listenerAttached) {
        acceptTermsButton.addEventListener('click', () => {
            localStorage.setItem('termsAccepted_v1', 'true');
            showToast('Normas aceptadas. Gracias.', 'success');
            const modal = document.getElementById('config-modal');
            if (modal) {
                modal.querySelectorAll('.config-tab-button').forEach(btn => {
                    btn.disabled = false;
                    btn.style.cursor = 'pointer';
                    btn.style.opacity = '1';
                });
                modal.querySelector('.config-tab-button[data-tab-target="#tab-content-normas"]').classList.remove('active');
                modal.querySelector('#tab-content-normas').classList.remove('active');
                modal.querySelector('.config-tab-button[data-tab-target="#tab-content-usuario"]').classList.add('active');
                modal.querySelector('#tab-content-usuario').classList.add('active');
            }
        });
        acceptTermsButton.dataset.listenerAttached = "true";
    }
    
    const directToNavCheckbox = document.getElementById('config-direct-to-nav');
    if (directToNavCheckbox && !directToNavCheckbox.dataset.listenerAttached) {
        directToNavCheckbox.addEventListener('change', () => {
            localStorage.setItem(DIRECT_TO_NAVIGATION_KEY, JSON.stringify(directToNavCheckbox.checked));
            showToast('Preferencia de inicio directo al mapa guardada.', 'success', 2000);
        });
        directToNavCheckbox.dataset.listenerAttached = "true";
    }
    const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
    if (autoBackupCheckbox && !autoBackupCheckbox.dataset.listenerAttached) {
        autoBackupCheckbox.addEventListener('change', () => {
            localStorage.setItem('boardinggate_autoBackupOnLoad', JSON.stringify(autoBackupCheckbox.checked));
            showToast(`Copia de seguridad automtica al inicio: ${autoBackupCheckbox.checked ? 'Activada' : 'Desactivada'}`, 'info', 3000);
        });
        autoBackupCheckbox.dataset.listenerAttached = "true";
    }
}
    
    // ===================================================================
    // NOMBRE: parseUserId
    // RESUMEN: Analiza el ID de usuario para detectar si es un usuario mvil y extrae el ID principal.
    function parseUserId(rawUserId) {
        if (!rawUserId) {
            return { primaryId: null, isMobile: false, originalId: null };
        }
        const mobileRegex = /^(.*?)@(MVIL|MOVIL)$/i;
        const match = rawUserId.trim().match(mobileRegex);
        if (match && match[1]) {
            return {
                primaryId: match[1].trim(),
                isMobile: true,
                originalId: rawUserId.trim()
            };
        } else {
            return {
                primaryId: rawUserId.trim(),
                isMobile: false,
                originalId: rawUserId.trim()
            };
        }
    }
       
    // ===================================================================
    // NOMBRE: markCacheAsDirty
    // RESUMEN: Actualiza un timestamp para marcar que la cach local ha sido modificada.
    function markCacheAsDirty() {
        localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
    }

    // ===================================================================
    // NOMBRE: promptForBackupPassword
    // RESUMEN: Muestra un modal para que el usuario introduzca un PIN de seguridad para backups.
    function promptForBackupPassword(message, onConfirm, onCancel, isSettingPassword = false) {
        const existingModal = document.getElementById('backup-password-modal-overlay');
        if (existingModal) existingModal.remove();
        const modalOverlay = document.createElement('div');
        modalOverlay.id = 'backup-password-modal-overlay';
        modalOverlay.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85); display: flex; justify-content: center;
            align-items: center; z-index: 9999;
        `;
        const modalContent = document.createElement('div');
        modalContent.id = 'backup-password-modal-content';
        modalContent.style.cssText = `
            background-color: #DAC8A0; padding: 2rem; border-radius: 0.75rem;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4); text-align: center; border: 1px solid #A0522D;
            margin-top: -50px;
            max-width: 350px; width: 90%;
        `;
        modalContent.innerHTML = `
            <h2 style="font-size: 1.5rem; font-weight: bold; color: #333; margin-bottom: 1rem;">${message}</h2>
            <input type="password" id="backup-password-input" maxlength="6" pattern="\\d{6}" inputmode="numeric" style="
                width: 150px; padding: 0.8rem; font-size: 1.8rem; text-align: center;
                border: 2px solid #A0522D; border-radius: 0.25rem; margin-bottom: 1.5rem;
                letter-spacing: 0.5em; background-color: #f0f0e0;
            " required>
            ${isSettingPassword ? `
                <label for="backup-password-confirm" style="display: block; font-size: 1.1rem; color: #444; margin-bottom: 0.8rem;">Confirmar PIN:</label>
                <input type="password" id="backup-password-confirm" maxlength="6" pattern="\\d{6}" inputmode="numeric" style="
                    width: 150px; padding: 0.8rem; font-size: 1.8rem; text-align: center;
                    border: 2px solid #A0522D; border-radius: 0.25rem; margin-bottom: 1.5rem;
                    letter-spacing: 0.5em; background-color: #f0f0e0;
                " required>
            ` : ''}
            <p id="backup-password-error" style="color: #dc3545; font-weight: bold; margin-top: -0.5rem; margin-bottom: 1rem; min-height: 1.2em;"></p>
            <div style="display:flex; justify-content: space-around; gap:1rem;">
                <button id="backup-password-submit" style="padding: 0.8rem 1.5rem; font-size: 1.2rem; background-color: #28a745; color: white; border: none; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; flex: 1;">Aceptar</button>
                <button id="backup-password-cancel" style="padding: 0.8rem 1.5rem; font-size: 1.2rem; background-color: #6c757d; color: white; border: none; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; flex: 1;">Cancelar</button>
            </div>
        `;
        document.body.appendChild(modalOverlay);
        modalOverlay.appendChild(modalContent);
        const pinInput = document.getElementById('backup-password-input');
        const pinConfirmInput = document.getElementById('backup-password-confirm');
        const errorEl = document.getElementById('backup-password-error');
        const submitBtn = document.getElementById('backup-password-submit');
        const cancelBtn = document.getElementById('backup-password-cancel');
        pinInput.focus();
        const validateAndSubmit = () => {
            errorEl.textContent = '';
            const pin = pinInput.value;
            if (!/^\d{6}$/.test(pin)) {
                errorEl.textContent = 'El PIN debe ser de 6 dgitos numricos.';
                if (navigator.vibrate) navigator.vibrate(100);
                return;
            }
            if (isSettingPassword) {
                const confirmPin = pinConfirmInput.value;
                if (pin !== confirmPin) {
                    errorEl.textContent = 'Los PINs no coinciden.';
                    if (navigator.vibrate) navigator.vibrate(100);
                    return;
                }
            }
            modalOverlay.remove();
            onConfirm(pin);
        };
        submitBtn.addEventListener('click', validateAndSubmit);
        cancelBtn.addEventListener('click', () => {
            modalOverlay.remove();
            onCancel();
        });
        pinInput.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                if (isSettingPassword && pinConfirmInput) {
                    pinConfirmInput.focus();
                } else {
                    validateAndSubmit();
                }
            }
        });
        if (isSettingPassword && pinConfirmInput) {
            pinConfirmInput.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') {
                    validateAndSubmit();
                }
            });
        }
        addModalAutoCloseTimer(modalOverlay, submitBtn, 'backup-password-modal', isSettingPassword ? 90000 : 30000);
    }
     
// ===================================================================
// NOMBRE: callFirebase (VERSIN CORREGIDA - CON MERGE:TRUE)
// RESUMEN: Encapsula las llamadas a Firestore, ahora usando { merge: true } para evitar borrar campos.
async function callFirebase(action, data) {
    if (!window.db || !window.doc || !window.setDoc || !window.getDoc || !window.collection) {
        console.error("Firebase Firestore SDK functions no estn expuestas globalmente.");
        return { status: "error", message: "Error interno: Funciones de Firebase no estn disponibles." };
    }
    const userId = data.userId;
    if (!userId) {
        return { status: "error", message: "ID de Usuario es obligatorio para las operaciones de Firebase." };
    }
    try {
        const userDocRef = window.doc(window.db, "user_data", userId);
        if (action === 'saveUser') {
            const documentData = {
                usuario: data.usuario,
                modelo: data.modelo || '',
                anio: data.anio || '',
                provincia: data.provincia || '',
                rss: data.rss || false,
                contenidoCacheCompleto: JSON.stringify(data.datosCache),
                fechaBackup: new Date().toISOString(),
                backupPassword: data.backupPassword || null
            };
            
            await window.setDoc(userDocRef, documentData, { merge: true });

            return { status: "success", message: "Datos guardados en Firebase." };
        } else if (action === 'getUserData') {
            const docSnap = await window.getDoc(userDocRef);
            if (docSnap.exists()) {
                const firebaseData = docSnap.data();
                try {
                    firebaseData.contenidoCacheCompleto = JSON.parse(firebaseData.contenidoCacheCompleto);
                } catch (e) {
                    console.error("Error al parsear contenidoCacheCompleto de Firebase:", e);
                }
                return { status: "success", message: "Datos recuperados de Firebase.", data: firebaseData };
            } else {
                return { status: "not_found", message: "No se encontr ningn backup para ese ID de Usuario." };
            }
        } else if (action === 'checkUserExists') {
             const docSnap = await window.getDoc(userDocRef);
             return { status: "success", exists: docSnap.exists() };
        } else {
            return { status: "error", message: "Accin de Firebase no reconocida." };
        }
    } catch (error) {
        console.error("Error en la operacin de Firebase:", error);
        return { status: "error", message: `Error de Firebase: ${error.message}` };
    }
}   
    
    
// ===================================================================
// NOMBRE: validateAndSaveUserToFirebase (VERSIN CORREGIDA - ANTI RACE CONDITION)
// RESUMEN: Valida, pide PIN y guarda. Ahora, antes de guardar, relee los contadores de sesin para evitar conflictos.
async function validateAndSaveUserToFirebase() {
    const statusEl = document.getElementById('config-user-status');
    const userIdInput = document.getElementById('user-id');
    const { primaryId, isMobile, originalId } = parseUserId(userIdInput.value);

    if (primaryId && primaryId.toUpperCase() === 'ALERTAS') {
        statusEl.textContent = 'El nombre de usuario "ALERTAS" est reservado para el sistema. Por favor, elige otro.';
        statusEl.style.color = '#EF4444';
        showToast('Nombre de usuario no permitido', 'error');
        return;
    }

    if (!primaryId) {
        statusEl.textContent = 'El ID de Usuario es obligatorio.';
        statusEl.style.color = '#EF4444';
        return;
    }
    statusEl.textContent = 'Validando y preparando guardado...';
    statusEl.style.color = '#17a2b8';
    const toastId = "firebase-save-toast";
    showToast('Validando en la nube...', 'info', 0, false, toastId);

    const currentLocalUserId = localStorage.getItem('userData_userId');
    const hasChangedUser = originalId.toLowerCase() !== (currentLocalUserId || '').toLowerCase();

    if (hasChangedUser) {
        const checkResult = await callFirebase('checkUserExists', { userId: primaryId });
        if (checkResult.status === 'success' && checkResult.exists) {
            const userWantsToRestore = confirm(`Se ha encontrado una copia de seguridad para el usuario "${primaryId}".\n\nDeseas recuperar esa copia de seguridad?\n\nATENCIN! Si dices que s, se sobreescribirn todos tus datos locales actuales.`);
            if (userWantsToRestore) {
                document.getElementById('restore-user-id').value = originalId;
                await restoreBackupFromFirebase();
                const existingToast = document.getElementById(toastId);
                if (existingToast) existingToast.remove();
                return; 
            } else {
                showToast("Restauracin cancelada. Se guardarn los datos actuales con el nuevo nombre de usuario.", "info");
            }
        }
    }

    const localBackupPassword = localStorage.getItem('userData_backupPassword');
    const completeSaveProcess = async (finalBackupPin) => {
        localStorage.setItem('userData_userId', originalId);
        localStorage.setItem('userData_teslaModel', document.getElementById('tesla-model').value.trim());
        localStorage.setItem('userData_teslaYear', document.getElementById('tesla-year').value.trim());
        localStorage.setItem('userData_teslaProvince', document.getElementById('tesla-province').value.trim());
        localStorage.setItem('userData_allowDMs', JSON.stringify(document.getElementById('allow-dms').checked));
        localStorage.setItem('boardinggate_autoBackupOnLoad', JSON.stringify(document.getElementById('config-auto-backup-on-load').checked));
        localStorage.setItem('userData_backupPassword', finalBackupPin);
        updateUserIdDisplay();
        
        const sessionDataResult = await callFirebase('getUserData', { userId: primaryId });
        const currentSessionData = {
            map_sessions_total: 0,
            map_sessions_month: 0,
            map_sessions_last_month: "0000-00"
        };
        if (sessionDataResult.status === 'success' && sessionDataResult.data) {
            currentSessionData.map_sessions_total = sessionDataResult.data.map_sessions_total || 0;
            currentSessionData.map_sessions_month = sessionDataResult.data.map_sessions_month || 0;
            currentSessionData.map_sessions_last_month = sessionDataResult.data.map_sessions_last_month || "0000-00";
        }
        const cacheData = {};
        managedKeys.forEach(key => {
            const value = localStorage.getItem(key);
            if (value !== null) cacheData[key] = value;
        });
        
        const saveData = {
            userId: primaryId,
            usuario: primaryId,
            modelo: localStorage.getItem('userData_teslaModel') || '',
            anio: localStorage.getItem('userData_teslaYear') || '',
            provincia: localStorage.getItem('userData_teslaProvince') || '',
            rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
            datosCache: cacheData,
            backupPassword: finalBackupPin,
            fechaBackup: new Date().toISOString(),
            // Usamos los contadores recin ledos para evitar el conflicto
            map_sessions_total: currentSessionData.map_sessions_total,
            map_sessions_month: currentSessionData.map_sessions_month,
            map_sessions_last_month: currentSessionData.map_sessions_last_month
        };
        
        const saveResult = await callFirebase('saveUser', saveData);
        
        const existingToast = document.getElementById(toastId);
        if (existingToast) existingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== toastId);
        
        if (saveResult.status === 'success') {
            const successMsg = isMobile ?
                `Datos sincronizados con el usuario "${primaryId}".` :
                "Datos guardados en la nube y localmente.";
            statusEl.textContent = successMsg;
            statusEl.style.color = '#28a745';
            showToast(successMsg, 'success');
            localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
        } else {
            statusEl.textContent = `Error al guardar: ${saveResult.message}. (Datos guardados localmente).`;
            statusEl.style.color = '#EF4444';
            showToast(`Error al guardar: ${saveResult.message}`, 'error');
        }
    };
    if (!hasChangedUser && localBackupPassword) {
        await completeSaveProcess(localBackupPassword);
    } else {
        const checkResult = await callFirebase('checkUserExists', { userId: primaryId });
        if (checkResult.status === 'error') {
            statusEl.textContent = `Error al verificar usuario en la nube: ${checkResult.message}.`;
            statusEl.style.color = '#EF4444';
            return;
        }
        if (checkResult.exists) {
            promptForBackupPassword(
                `Introduce el PIN para "${primaryId}":`,
                async (enteredPin) => {
                    const retrieveResult = await callFirebase('getUserData', { userId: primaryId });
                    if (retrieveResult.status === 'success' && retrieveResult.data && retrieveResult.data.backupPassword === enteredPin) {
                        await completeSaveProcess(enteredPin);
                    } else {
                        statusEl.textContent = 'PIN incorrecto. Guardado cancelado.';
                        statusEl.style.color = '#EF4444';
                        showToast('PIN incorrecto. Acceso denegado.', 'error');
                    }
                },
                () => { statusEl.textContent = 'Guardado cancelado.'; statusEl.style.color = '#6c757d'; }
            );
        } else {
            if (isMobile) {
                statusEl.textContent = `El usuario primario "${primaryId}" no existe. No se puede sincronizar.`;
                statusEl.style.color = '#EF4444';
                return;
            }
            promptForBackupPassword(
                'Nuevo usuario. Establece un PIN de 6 dgitos:',
                (pin) => completeSaveProcess(pin),
                () => { statusEl.textContent = 'Guardado cancelado.'; statusEl.style.color = '#6c757d'; },
                true
            );
        }
    }
}    
// ===================================================================
// NOMBRE: restoreBackupFromFirebase
// RESUMEN: Recupera y aplica un backup de datos desde Firebase, pidiendo PIN para confirmar.
async function restoreBackupFromFirebase(isAutoLoad = false) {
    const statusEl = document.getElementById('config-restore-status');
    const { primaryId, isMobile, originalId } = parseUserId(document.getElementById('restore-user-id').value || localStorage.getItem('userData_userId'));
    if (!primaryId) {
        if (!isAutoLoad) statusEl.textContent = 'Introduce un ID de Usuario para recuperar.';
        if (!isAutoLoad) statusEl.style.color = '#EF4444';
        return;
    }
    if (!isAutoLoad) {
        statusEl.textContent = `Buscando backup para "${primaryId}"...`;
        statusEl.style.color = '#17a2b8';
        showToast(`Recuperando backup de "${primaryId}"...`, 'info', 0, false, "firebase-restore-toast");
    }
    const result = await callFirebase('getUserData', { userId: primaryId });
    if (!isAutoLoad) {
        const existingToast = document.getElementById("firebase-restore-toast");
        if (existingToast) existingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== "firebase-restore-toast");
    }
    if (result.status === 'success' && result.data) {
        const firebaseData = result.data;
        const backupCacheData = firebaseData.contenidoCacheCompleto;
        if (!backupCacheData) {
            if (!isAutoLoad) {
                statusEl.textContent = `El backup para "${primaryId}" no contiene datos de cach.`;
                statusEl.style.color = '#EF4444';
                showToast('Backup incompleto.', 'error');
            }
            return;
        }
        const applyChanges = () => {
            const currentUserIdentity = localStorage.getItem('userData_userId') || originalId;
            for (const key in backupCacheData) {
                if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                    localStorage.setItem(key, backupCacheData[key]);
                }
            }
            localStorage.setItem('userData_userId', currentUserIdentity);
            const newTimestamp = Date.now().toString();
            localStorage.setItem('lastCacheUpdateTimestamp', newTimestamp);
            if (isMobile) {
                lastMobileSyncTimestamp = parseInt(newTimestamp);
            }
            showToast('Restauracin completada. Recargando...', 'success', 3000);
            setTimeout(() => location.reload(), 2500);
        };
        if (isAutoLoad) {
            applyChanges();
        } else {
            promptForBackupPassword(
                `Introduce el PIN para "${primaryId}":`,
                (enteredPin) => {
                    if (enteredPin === firebaseData.backupPassword) {
                        if (confirm(`Backup para "${primaryId}" desbloqueado.\n\nEsts seguro de que quieres restaurar estos datos?\n\nATENCIN! Se sobreescribirn TODOS tus datos locales actuales (grid, recordatorios, etc.). Esta accin NO se puede deshacer.`)) {
                            applyChanges();
                        } else {
                            statusEl.textContent = 'Restauracin cancelada.';
                            statusEl.style.color = '#6c757d';
                            showToast("Restauracin cancelada por el usuario.", "info");
                        }
                    } else {
                        statusEl.textContent = 'PIN incorrecto. Restauracin cancelada.';
                        statusEl.style.color = '#EF4444';
                        showToast('PIN incorrecto.', 'error');
                    }
                },
                () => {
                    statusEl.textContent = 'Restauracin cancelada.';
                    statusEl.style.color = '#6c757d';
                }
            );
        }
    } else if (result.status === 'not_found' && !isAutoLoad) {
        statusEl.textContent = `No se encontr backup para "${primaryId}".`;
        statusEl.style.color = '#EF4444';
        showToast('Backup no encontrado.', 'error not-found');
    } else if (!isAutoLoad) {
        statusEl.textContent = `Error al recuperar: ${result.message}`;
        statusEl.style.color = '#EF4444';
        showToast(`Error de recuperacin: ${result.message}`, 'error');
    }
}
    
    // ===================================================================
    // NOMBRE: getRandomSpeedMultiplierForManeuver
    // RESUMEN: Devuelve un multiplicador aleatorio de velocidad para simular variaciones en las maniobras.
    function getRandomSpeedMultiplierForManeuver(maneuver) {
        const type = maneuver.type || '';
        const modifier = maneuver.modifier || '';
        let min, max;
        if (type === 'roundabout' || type === 'rotary' || modifier.includes('sharp') || modifier.includes('uturn')) {
            min = -0.40;
            max = 0.20;
        } else if (type === 'turn' || type === 'fork' || type === 'merge' || type === 'end of road') {
            min = -0.30;
            max = 0.10;
        } else {
            min = -0.25;
            max = 0.35;
        }
        return Math.random() * (max - min) + min;
    }

// ===================================================================
// NOMBRE: hideIntersectionPreviewMap
// RESUMEN: Oculta el minimapa de previsualizacin de la interseccin.
function hideIntersectionPreviewMap() {
    const card = document.getElementById('intersection-preview-map-window');
    if (card) {
        card.classList.add('hidden');
        const rotator = card.querySelector('#intersection-rotator');
        if (rotator) {
            rotator.style.transform = 'rotate(0deg)';
        }
        miniMapOffsetActive.x = 0;
        targetMapCenterOffset.x -= miniMapOffsetActive.x;
    }
    if (intersectionPreviewTimer) {
        clearTimeout(intersectionPreviewTimer);
        intersectionPreviewTimer = null;
    }
}
// ===================================================================
// NOMBRE: addRouteToRecents (MODIFICADA - LMITE DE 3)
// RESUMEN: Aade una ruta o destino al historial, evitando duplicados por nombre
function addRouteToRecents(routeObject) {
    if (!routeObject || !routeObject.waypoints || routeObject.waypoints.length < 1) {
        return;
    }
    const RECENT_ROUTES_KEY = 'boardinggate_recent_routes';
    const MAX_RECENT_ROUTES = 3; 
    let recentRoutes = [];
    try {
        recentRoutes = JSON.parse(localStorage.getItem(RECENT_ROUTES_KEY)) || [];
    } catch (e) {
        recentRoutes = [];
    }

    const finalAddress = routeObject.waypoints[routeObject.waypoints.length - 1]?.address || 'destino desconocido';
    const simplifiedRoute = {
        name: routeObject.name || `Ruta a ${finalAddress}`,
        waypoints: routeObject.waypoints.map(wp => ({
            lat: wp.lat,
            lng: wp.lng,
            address: wp.address
        })),
        timestamp: new Date().toISOString()
    };

    const uniqueRecentRoutes = recentRoutes.filter(item => item.name !== simplifiedRoute.name);
    
    uniqueRecentRoutes.unshift(simplifiedRoute);
    const finalRecentRoutes = uniqueRecentRoutes.slice(0, MAX_RECENT_ROUTES);
    localStorage.setItem(RECENT_ROUTES_KEY, JSON.stringify(finalRecentRoutes));
}    

// ===================================================================
// NOMBRE: addModalAutoCloseTimer
// RESUMEN: Aade un temporizador de autocierre a un modal.
function addModalAutoCloseTimer(modalElement, closeButtonElement, modalId, duration = 90000) {
    if (!modalElement || !closeButtonElement || !modalId) {
        return;
    }
    modalElement.dataset.modalTimerId = modalId;
    clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId);
    let countdown = duration / 1000;
    const originalButtonText = closeButtonElement.textContent.split(' (')[0];
    const countdownSpanId = `modal-countdown-${modalId}`;
    let countdownSpan = closeButtonElement.querySelector(`.button-countdown-timer`);
    if (!countdownSpan) {
        countdownSpan = document.createElement('span');
        countdownSpan.className = 'button-countdown-timer';
        countdownSpan.style.marginLeft = '5px';
        countdownSpan.style.fontWeight = 'normal';
        closeButtonElement.appendChild(countdownSpan);
    }
    countdownSpan.textContent = ` (${countdown})`;
    const intervalId = setInterval(() => {
        countdown--;
        if (countdownSpan && document.body.contains(countdownSpan)) {
          countdownSpan.textContent = ` (${countdown})`;
        }
        if (countdown <= 0) {
            if (globalModalTimers[modalId]) {
                clearInterval(globalModalTimers[modalId].intervalId);
                delete globalModalTimers[modalId];
            }
            if (closeButtonElement && document.body.contains(closeButtonElement)) {
                closeButtonElement.click();
            } else if (modalElement && modalElement.parentNode) {
                 if (!STATIC_MODAL_IDS.includes(modalElement.id)) {
                    modalElement.parentNode.removeChild(modalElement);
                 } else {
                    modalElement.classList.add('hidden');
                 }
            }
        }
    }, 1000);
    const resetTimerHandler = () => {
        if (!globalModalTimers[modalId] || !globalModalTimers[modalId].intervalId) return;
        clearInterval(globalModalTimers[modalId].intervalId);
        countdown = duration / 1000;
        if (countdownSpan && document.body.contains(countdownSpan)) {
           countdownSpan.textContent = ` (${countdown})`;
        }
        const newIntervalId = setInterval(() => {
            countdown--;
            if (countdownSpan && document.body.contains(countdownSpan)) {
                countdownSpan.textContent = ` (${countdown})`;
            }
            if (countdown <= 0) {
                if (globalModalTimers[modalId]) {
                    clearInterval(globalModalTimers[modalId].intervalId);
                    delete globalModalTimers[modalId];
                }
                if (closeButtonElement && document.body.contains(closeButtonElement)) {
                    closeButtonElement.click();
                } else if (modalElement && modalElement.parentNode) {
                    if (!STATIC_MODAL_IDS.includes(modalElement.id)) {
                       modalElement.parentNode.removeChild(modalElement);
                    } else {
                       modalElement.classList.add('hidden');
                    }
                }
            }
        }, 1000);
        globalModalTimers[modalId].intervalId = newIntervalId;
    };
    modalElement.addEventListener('click', resetTimerHandler);
    modalElement.addEventListener('touchstart', resetTimerHandler, { passive: true });
    modalElement.addEventListener('input', resetTimerHandler);
    modalElement.addEventListener('scroll', resetTimerHandler, { passive: true });
    globalModalTimers[modalId] = {
        intervalId: intervalId,
        resetHandler: resetTimerHandler,
        modalElement: modalElement,
        closeButtonElement: closeButtonElement,
        countdownSpan: countdownSpan
    };
}

    
// ===================================================================
// NOMBRE: restoreBackup
// RESUMEN: Restaura los datos locales desde un cdigo de backup manual.
function restoreBackup() {
    const restoreInput = document.getElementById('config-restore-input');
    const backupStringBase64 = restoreInput.value.trim();
    const statusEl = document.getElementById('config-restore-status');
    statusEl.textContent = '';
    if (!backupStringBase64) {
        statusEl.textContent = 'Pega el cdigo de backup primero.';
        statusEl.style.color = '#EF4444';
        return;
    }
    try {
        const backupString = decodeURIComponent(escape(atob(backupStringBase64)));
        const backupData = JSON.parse(backupString);
        let restoredCount = 0;
        let incompatibleCount = 0;
        if (confirm('Esto sobreescribir tus datos actuales con los del backup. Ests seguro?')) {
            Object.keys(backupData).forEach(key => {
                if (managedKeys.includes(key)) {
                    localStorage.setItem(key, backupData[key]);
                    restoredCount++;
                } else {
                    incompatibleCount++;
                }
            });
            loadCustomData();
            loadSavedSettings();
            updateUserIdDisplay();
            checkReminders();
            statusEl.textContent = `Restauracin completada. ${restoredCount} claves restauradas. ${incompatibleCount} claves ignoradas (incompatibles). La pgina se recargar.`;
            statusEl.style.color = '#28a745';
            showToast('Restauracin completada. Recargando...', 'success');
            setTimeout(() => location.reload(), 2500);
        } else {
             statusEl.textContent = 'Restauracin cancelada.';
             statusEl.style.color = '#6c757d';
        }
    } catch (e) {
        statusEl.textContent = 'Error: Cdigo de backup invlido o corrupto.';
        statusEl.style.color = '#EF4444';
        showToast('Error en el cdigo de backup', 'error');
    }
}  
    
    // ===================================================================
    // NOMBRE: clearNavigationGraph
    // RESUMEN: Limpia y oculta la grfica de navegacin.
    function clearNavigationGraph() {
        if (graphIntervalTimer) {
            clearInterval(graphIntervalTimer);
            graphIntervalTimer = null;
        }
        if (navigationChart) {
            navigationChart.destroy();
            navigationChart = null;
        }
        const graphCard = document.getElementById('navigation-graph-card');
        if (graphCard) {
            graphCard.classList.add('hidden');
        }
        graphDataPoints = { speed: [], altitude: [] };
        graphLabels = [];
    }
    

// ===================================================================
// NOMBRE: updateTurnByTurnDisplay (VERSIN CON TARJETA MNIMA Y ETA INTEGRADO)
// RESUMEN: Actualiza la barra de giro y gestiona la visibilidad
function updateTurnByTurnDisplay(route, carDistanceAlongTheRoute = 0) {
    const topInfoBar = document.getElementById('navigation-top-info-bar');
    const intersectionPreviewWindow = document.getElementById('intersection-preview-map-window');
    const helperLeft = document.getElementById('direction-card-izquierda');
    const helperRight = document.getElementById('direction-card-derecha');
    const progressBar = document.getElementById('navigation-bottom-progress-bar');
    const miniNavCard = document.getElementById('mini-nav-info-card'); 

    if (helperLeft) helperLeft.style.display = 'none';
    if (helperRight) helperRight.style.display = 'none';
    
    if (!route || !topInfoBar || !route.legs || route.legs.length === 0) {
        if (topInfoBar) topInfoBar.style.display = 'none';
        if (miniNavCard) miniNavCard.style.display = 'none'; 
        if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
        return;
    }
    if (!isNavigating && (!navigationCurrentRouteData || navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2)) {
         if (topInfoBar) topInfoBar.style.display = 'none';
         if (miniNavCard) miniNavCard.style.display = 'none'; 
         if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
         return;
    }

    topInfoBar.style.display = 'flex';
    const turnIconContainer = document.getElementById('turn-icon-container-styled');
    const turnIconDisplayEl = document.getElementById('turn-icon-display');
    const maneuverTextEl = document.getElementById('maneuver-text-display');
    const distanceFormattedEl = document.getElementById('distance-to-turn-formatted');
    const streetEl = document.getElementById('street-name-display');
    const progressBarEl = document.getElementById('distance-progress-bar-to-turn');
    
    if (turnIconDisplayEl) {
        turnIconDisplayEl.style.width = '100%';
        turnIconDisplayEl.style.height = '100%';
        turnIconDisplayEl.style.display = 'flex';
        turnIconDisplayEl.style.alignItems = 'center';
        turnIconDisplayEl.style.justifyContent = 'center';
    }

    const carDistance = Math.min(Math.max(0, carDistanceAlongTheRoute), route.distance);
    let distanceCoveredInRoute = 0;
    let currentLegIndex = -1, currentStepIndex = -1;
    let distanceToEndOfCurrentStepForProgress = 0;
    let previousStepForPath = null;
    
    for (let i = 0; i < route.legs.length; i++) {
        const leg = route.legs[i];
        for (let j = 0; j < leg.steps.length; j++) {
            const step = leg.steps[j];
            if (carDistance < distanceCoveredInRoute + step.distance) {
                currentLegIndex = i; currentStepIndex = j;
                distanceToEndOfCurrentStepForProgress = distanceCoveredInRoute + step.distance;
                if (j > 0) { previousStepForPath = leg.steps[j - 1]; } 
                else if (i > 0) { previousStepForPath = route.legs[i-1].steps[route.legs[i-1].steps.length - 1]; }
                break;
            }
            distanceCoveredInRoute += step.distance;
        }
        if (currentLegIndex === -1 && i === route.legs.length -1) {
             currentLegIndex = route.legs.length - 1;
             currentStepIndex = route.legs[currentLegIndex].steps.length - 1;
        } else if (currentLegIndex !== -1) {
            break;
        }
    }
    if (currentLegIndex === -1) {
        currentLegIndex = route.legs.length - 1;
        currentStepIndex = route.legs[currentLegIndex].steps.length - 1;
    }

    currentLegIndexNav = currentLegIndex;
    currentStepIndexNav = currentStepIndex;

    const waypointsForRequest = navigationWaypoints.filter(wp => wp);
    
    let finalStepToShow;
    let tempLegIdx = currentLegIndex;
    let tempStepIdx = currentStepIndex + 1;

    while (true) {
        if (tempLegIdx >= route.legs.length) {
            finalStepToShow = route.legs[route.legs.length - 1].steps[route.legs[route.legs.length - 1].steps.length - 1];
            break;
        }

        let leg = route.legs[tempLegIdx];
        if (tempStepIdx >= leg.steps.length) {
            tempLegIdx++;
            tempStepIdx = 0;
            continue;
        }
        
        const candidateStep = leg.steps[tempStepIdx];
        const isArrival = candidateStep.maneuver.type === 'arrive';
        const isDeparture = candidateStep.maneuver.type === 'depart';
        
        const arrivalWaypoint = isArrival ? waypointsForRequest[tempLegIdx + 1] : null; 
        const departureWaypoint = isDeparture ? waypointsForRequest[tempLegIdx] : null;

        if (isArrival && arrivalWaypoint?.isInternal) {
            tempStepIdx++;
            continue;
        } else if (isDeparture && departureWaypoint?.isInternal) {
            tempStepIdx++;
            continue;
        } else {
            finalStepToShow = candidateStep;
            break;
        }
    }
    let nextStepToDisplay = finalStepToShow;

    const currentStepForProgress = route.legs[currentLegIndex].steps[currentStepIndex];
    const distanceToNextManeuver = Math.max(0, distanceToEndOfCurrentStepForProgress - carDistance);
    const distanceIntoCurrentStep = currentStepForProgress.distance - distanceToNextManeuver;
    navigationTargetZoom = compassAndModeControl ? compassAndModeControl.mapViewMode : 'static';

    const now = Date.now();
    const infoOverlay = document.getElementById('map-info-overlay');

    if (!isProgressBarLocked && !isMapImmersiveModeActive && now > progressBarForceShowUntil) {
        const shouldHide = distanceToNextManeuver > 1000 && distanceIntoCurrentStep > 100;
        progressBar.classList.toggle('progress-bar-auto-hidden', shouldHide);
        if (infoOverlay) {
            infoOverlay.style.display = shouldHide ? 'none' : 'block';
        }
        if (miniNavCard) {
            if (shouldHide) {
                const distanceText = distanceToNextManeuver < 1000 ? `${Math.round(distanceToNextManeuver / 5) * 5} m` : `${(distanceToNextManeuver / 1000).toFixed(1)} km`;
                let etaHtml = '';

                const remainingDistanceTotal = Math.max(0, route.distance - carDistanceAlongTheRoute);
                const remainingDurationTotal = route.distance > 0 ? route.duration * (remainingDistanceTotal / route.distance) : 0;
                const currentFinalEta = new Date(Date.now() + remainingDurationTotal * 1000);

                if (isNavigating && tripInitialOverallEtaTime) {
                    const etaText = currentFinalEta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    const finalDeviationMs = currentFinalEta.getTime() - tripInitialOverallEtaTime.getTime();
                    
                    let deviationHtml = '';
                    if (typeof finalDeviationMs === 'number' && !isNaN(finalDeviationMs) && Math.abs(finalDeviationMs) >= 1000) {
                        const totalSeconds = Math.round(Math.abs(finalDeviationMs) / 1000);
                        const minutes = Math.floor(totalSeconds / 60);
                        const seconds = totalSeconds % 60;
                        const sign = finalDeviationMs > 0 ? '+' : '-';
                        
                        const shadowColor = finalDeviationMs > 0 ? 'red' : 'green';
                        
                        const style = `color: white; text-shadow: 0 0 5px ${shadowColor}, 0 0 7px ${shadowColor};`;
                    
                        const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                        deviationHtml = `<span style="${style}">[${sign}${formattedTime}]</span>`;
                    }
                    etaHtml = `<div style="font-size: 0.68em; margin-top: 2px; text-align: center; ">
                       <span>${etaText}</span>
                       <span style="margin-left: 8px;">${deviationHtml}</span>  </div>`;
                   }

                miniNavCard.innerHTML = `
                    <div>${distanceText}</div>
                    ${etaHtml}
                `;
                miniNavCard.style.display = 'block';
                // --- FIN DE LA MODIFICACIN ---
            } else {
                miniNavCard.style.display = 'none';
            }
        }
    } else {
        progressBar.classList.remove('progress-bar-auto-hidden');
        if (infoOverlay) {
            infoOverlay.style.display = 'block';
        }
        if (miniNavCard) {
            miniNavCard.style.display = 'none';
        }
    }
    
    if (nextStepToDisplay && nextStepToDisplay.maneuver) {
        const isArrivalManeuver = nextStepToDisplay.maneuver.type === 'arrive';
        const isVeryCloseToArrival = distanceToNextManeuver < 50;
        
        let stepForDisplayText;
        if (isArrivalManeuver && !isVeryCloseToArrival) {
            stepForDisplayText = currentStepForProgress;
        } else {
            stepForDisplayText = nextStepToDisplay;
        }
        
        const maneuver = stepForDisplayText.maneuver;
        const type = maneuver.type || '';
        let maneuverText = "";
        let streetNameText = stepForDisplayText.name || '';
        
        if (maneuver.type === 'arrive') {
            const isFinalLeg = currentLegIndex === route.legs.length - 1;

            if (isFinalLeg) {
                maneuverText = "Ha llegado a su destino";
                streetNameText = '';
            } else {
                const totalStages = navigationWaypoints.filter(wp => !wp.isInternal && !wp.isRecalculatedStart).length - 1;
                const stageNumber = currentLegIndex + 1;
                maneuverText = `Ha llegado a la etapa ${stageNumber} de ${totalStages}`;
                streetNameText = '';
            }
        } else {
            maneuverText = getManeuverInstructionText(maneuver);
            if (type === 'depart' || type.includes('roundabout') || type === 'end of road') {
                streetNameText = '';
            }
        }
        
        if (turnIconDisplayEl) {
            const iconFilename = getManeuverIconFilename(maneuver);
            if (iconFilename !== lastDisplayedManeuverIcon) {
                const iconUrl = `https://boardinggate.github.io/Tesla/${iconFilename}`;
                turnIconDisplayEl.innerHTML = `<img src="${iconUrl}" alt="${maneuverText}" style="width: 95%; height: 95%; object-fit: contain; ">`;
                lastDisplayedManeuverIcon = iconFilename;
            }
        }
        
        maneuverTextEl.textContent = maneuverText ? `${maneuverText} ` : '';
        streetEl.textContent = streetNameText;
        
        distanceToNextManeuverOSRM = distanceToNextManeuver;
        distanceFormattedEl.textContent = distanceToNextManeuver < 1000 ? `${Math.round(distanceToNextManeuver / 5) * 5} m` : `${(distanceToNextManeuver / 1000).toFixed(1)} km`;
        const progressPercent = (currentStepForProgress.distance > 0) ? ((currentStepForProgress.distance - distanceToNextManeuver) / currentStepForProgress.distance) * 100 : (distanceToNextManeuver === 0 ? 100 : 0);
        if(progressBarEl) progressBarEl.style.width = `${Math.min(100, Math.max(0, progressPercent))}%`;

        if (isNavigating && previousStepForPath && navigationMapInstance.getSource('completed-segments') && navigationCurrentLocation) {
             if (previousStepForPath.geometry && previousStepForPath.geometry.coordinates) {
                const segmentGeoJSON = turf.lineString(previousStepForPath.geometry.coordinates);
                if (segmentGeoJSON.geometry.coordinates.length >= 2) {
                    const isNewSegment = !lastProcessedStepManeuverLocation || 
                                         lastProcessedStepManeuverLocation[0] !== previousStepForPath.maneuver.location[0] ||
                                         lastProcessedStepManeuverLocation[1] !== previousStepForPath.maneuver.location[1];
                    if (isNewSegment) {
                        completedSegmentsGeoJSON.features.push(segmentGeoJSON);
                        navigationMapInstance.getSource('completed-segments').setData(completedSegmentsGeoJSON);
                        lastProcessedStepManeuverLocation = previousStepForPath.maneuver.location;
                    }
                }
            }
        }
        
        const isRelevantIntersectionManeuver = type !== 'continue' && type !== 'new name' && type !== 'depart' && type !== 'straight';
        if (isNavigating && distanceToNextManeuver < 800 && distanceToNextManeuver >= 100 && isRelevantIntersectionManeuver && (!intersectionPreviewWindow || intersectionPreviewWindow.classList.contains('hidden') || intersectionPreviewWindow.dataset.source !== 'click') && (currentLegIndex + '_' + currentStepIndex) !== lastAutoShownManeuverId) {
            showIntersectionPreviewMap(nextStepToDisplay, route, false, 10000);
            lastAutoShownManeuverId = currentLegIndex + '_' + currentStepIndex;
        } else if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click' && (distanceToNextManeuver >= 800 || distanceToNextManeuver < 100 || !isRelevantIntersectionManeuver)) {
            hideIntersectionPreviewMap();
        }
        
        const heading = navigationCurrentLocation?.heading;
        const isSouthOriented = heading > 135 && heading <= 225;
        const isEastOriented = heading > 45 && heading <= 135;
        const isWestOriented = heading > 225 && heading <= 315;
        const isNearIntersection = distanceToNextManeuver < 180;

        if (turnIconContainer) {
            turnIconContainer.classList.remove('maneuver-highlight', 'maneuver-highlight-south');
            turnIconContainer.style.backgroundColor = 'white';
            if (isNearIntersection && isNavigating) {
                if (isSouthOriented) {
                    turnIconContainer.classList.add('maneuver-highlight-south');
                    turnIconContainer.style.backgroundColor = 'yellow';
                } else if (isEastOriented || isWestOriented) {
                    turnIconContainer.classList.add('maneuver-highlight');
                    turnIconContainer.style.backgroundColor = 'yellow';
                } else {
                    turnIconContainer.classList.add('maneuver-highlight');
                }
            }
        }

    } else {
        if (turnIconDisplayEl) {
            const iconFilename = 'PNG/arrive.png';
            if (iconFilename !== lastDisplayedManeuverIcon) {
                turnIconDisplayEl.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/arrive.png" style="width:95%; height:95%; object-fit:contain;">`;
                lastDisplayedManeuverIcon = iconFilename;
            }
        }
        maneuverTextEl.textContent = '';
        streetEl.textContent = 'Has llegado a tu destino';
        distanceFormattedEl.textContent = '0 m';
        if(progressBarEl) progressBarEl.style.width = '100%';
        distanceToNextManeuverOSRM = Infinity;
        if (miniNavCard) miniNavCard.style.display = 'none';
        if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
        if (turnIconContainer) {
            turnIconContainer.classList.remove('maneuver-highlight', 'maneuver-highlight-south');
            turnIconContainer.style.backgroundColor = 'white';
        }
    }
}
    

// ===================================================================
// NOMBRE: hideNavigationUI
// RESUMEN: Oculta los elementos de la interfaz de usuario de navegacin.
function hideNavigationUI() {
    const topInfoBar = document.getElementById('navigation-top-info-bar');
    const bottomProgressBar = document.getElementById('navigation-bottom-progress-bar');
    const startNavButton = document.getElementById('start-navigation-button');
    const saveRouteButton = document.getElementById('save-route-button');
    const reorderBtn = document.getElementById('reorder-route-stages-button');
    const simulateBtn = document.getElementById('simulate-route-button');
    const toggleSimulateGpsBtn = document.getElementById('toggle-simulate-gps-button');
    const graphCard = document.getElementById('navigation-graph-card');
    const miniNavCard = document.getElementById('mini-nav-info-card');
    if (topInfoBar) topInfoBar.style.display = 'none';
    if (bottomProgressBar) bottomProgressBar.style.display = 'none';
    if (miniNavCard) miniNavCard.style.display = 'none';
    if (saveRouteButton) saveRouteButton.classList.add('hidden');
    if (reorderBtn) reorderBtn.style.display = 'none';
    if (simulateBtn) simulateBtn.style.display = 'none';
    if (graphCard) graphCard.classList.add('hidden');
    hideIntersectionPreviewMap();
}
    
    // ===================================================================
    // NOMBRE: showNavigationUIElementsForPlanning
    // RESUMEN: Muestra los elementos de la UI para la planificacin de rutas.
    function showNavigationUIElementsForPlanning() {
        const topInfoBar = document.getElementById('navigation-top-info-bar');
        const bottomProgressBar = document.getElementById('navigation-bottom-progress-bar');
        if (!navigationCurrentRouteData || !navigationCurrentRouteData.routes || navigationCurrentRouteData.routes.length === 0 || navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
            if (topInfoBar) topInfoBar.style.display = 'none';
            if (bottomProgressBar) bottomProgressBar.style.display = 'none';
            hideMapInfoOverlay();
            hideIntersectionPreviewMap();
        } else {
            if (topInfoBar) topInfoBar.style.display = 'flex';
            if (bottomProgressBar) bottomProgressBar.style.display = 'flex';
            let carDistAlongRoutePlan = 0;
            const currentCarPosForShowUI = navigationCurrentLocation;
            if (currentCarPosForShowUI && navigationMapInstance && navigationCurrentRouteData.routes[0] && typeof turf !== 'undefined') {
                try {
                    const carPointTurf = turf.point([currentCarPosForShowUI.longitude, currentCarPosForShowUI.latitude]);
                    const routeLineStringTurf = turf.lineString(navigationCurrentRouteData.routes[0].geometry.coordinates);
                    const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                    const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                    carDistAlongRoutePlan = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                } catch(e){  }
             }
            updateTurnByTurnDisplay(navigationCurrentRouteData.routes[0], carDistAlongRoutePlan);
            showDestinationName();
        }
    }
     
    // ===================================================================
    // NOMBRE: getManeuverInstructionText
    // RESUMEN: Convierte una maniobra de OSRM en un texto legible.
    function getManeuverInstructionText(maneuver) {
        if (!maneuver) return '';
        const type = maneuver.type || '';
        const modifier = maneuver.modifier || '';
        let exit = maneuver.exit;
        let key = `${type}-${modifier}`;
        let text = maneuverTexts[key];
        if (!text) {
            key = `${type}-`;
            text = maneuverTexts[key];
        }
        if (!text && type === 'turn' && !modifier) {
            text = maneuverTexts['turn-'] || type.replace(/-/g, ' ');
        } else if (!text) {
            text = type.replace(/-/g, ' ');
        }
        const roundaboutExitTypes = ['roundabout turn', 'exit roundabout', 'rotary', 'roundabout'];
        if (roundaboutExitTypes.includes(type) && typeof exit === 'number' && exit > 0) {
             const ordinals = ["", "primera", "segunda", "tercera", "cuarta", "quinta"];
             const ordinalText = (exit >= 1 && exit <= 5) ? ordinals[exit] : `${exit}`;
             text = `Sal en la rotonda en la ${ordinalText} salida`;
        }
        let baseText = text.charAt(0).toUpperCase() + text.slice(1);
        return baseText;
    }  
    
// ===================================================================
// NOMBRE: formatDeviation
// RESUMEN: Formatea la desviacin de tiempo ETA con signo y color.
function formatDeviation(milliseconds) {
    if (typeof milliseconds !== 'number' || isNaN(milliseconds)) {
        return '';
    }
    if (Math.abs(milliseconds) < 1000) {
        return `<span class="eta-deviation">[00:00]</span>`;
    }
    const totalSeconds = Math.round(Math.abs(milliseconds) / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const sign = milliseconds > 0 ? '+' : '-';
    const colorClass = milliseconds > 0 ? 'positive' : 'negative';
    const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    return `<span class="eta-deviation ${colorClass}">[${sign}${formattedTime}]</span>`;
}    
    
    // ===================================================================
    // NOMBRE: parseCoordinateFilter
    // RESUMEN: Parsea y aplica un filtro de coordenadas (valor nico o rango).
   function parseCoordinateFilter(filterValue, coordinate) {
        if (!filterValue) return true;
        const parts = filterValue.trim().split(/\s+/).map(s => parseFloat(s.replace(',','.'))).filter(n => !isNaN(n));
        if (parts.length === 1) {
            return Math.abs(coordinate - parts[0]) < COORD_EPSILON;
        } else if (parts.length === 2) {
            const minVal = Math.min(parts[0], parts[1]);
            const maxVal = Math.max(parts[0], parts[1]);
            return coordinate >= minVal && coordinate <= maxVal;
        } else if (parts.length === 0 && filterValue.trim() !== "") {
            return false;
        }
        return true;
    }
    
// ===================================================================
// NOMBRE: closeOtherModals (VERSIN CORREGIDA Y DEFINITIVA)
// RESUMEN: Se ha eliminado 'address-suggestions-modal' de la lista
//          de modales a cerrar para evitar que se oculte por error.
function closeOtherModals(modalToKeepOpenId = null) {
    const STATIC_MODAL_IDS = ['config-modal', 'versions-modal-overlay', 'pin-modal-overlay', 'reorder-stages-modal', 'simulation-modal', 'locations-preview-modal', 'deviation-modal', 'arrival-stats-modal', 'simulation-speed-modal'];

    STATIC_MODAL_IDS.forEach(id => {
        if (id === modalToKeepOpenId) return;
        const modal = document.getElementById(id);
        if (modal && !modal.classList.contains('hidden')) {
            if (id === 'reorder-stages-modal') {
                const listElement = modal.querySelector('#sortable-stages-list');
                if (listElement) {
                    listElement.removeEventListener('dragstart', handleDragStartReorder);
                    listElement.removeEventListener('dragend', handleDragEndReorder);
                    listElement.removeEventListener('dragover', handleDragOverReorder);
                    listElement.removeEventListener('touchstart', handleStageTouchStart);
                    listElement.removeEventListener('touchmove', handleStageTouchMove);
                    listElement.removeEventListener('touchend', handleStageTouchEnd);
                    listElement.removeEventListener('touchcancel', handleStageTouchEnd);
                }
                if (draggedStageLi) {
                    draggedStageLi.classList.remove('dragging');
                    draggedStageLi = null;
                }
                clearTimeout(stageScrollTimeout);
                document.body.style.overflow = '';
            }
             if (id === 'deviation-modal') {
                if (deviationModalTimerId) clearInterval(deviationModalTimerId);
                deviationModalTimerId = null;
                isDeviationModalActive = false;
            }
             if (id === 'arrival-stats-modal') {
                const acceptButton = modal.querySelector('#arrival-stats-accept-button');
                if (acceptButton) clearModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal');
             }
             if (id === 'simulation-speed-modal') {
                const confirmBtn = modal.querySelector('#confirm-navigation-simulation');
                if(confirmBtn) clearModalAutoCloseTimer(modal, confirmBtn, 'simulation-speed-modal');
             }
            modal.classList.add('hidden');
            const closeBtn = modal.querySelector('button[id^="close-"], button[id*="-close"], #cancel-postpone, #close-saved-routes-modal, #cancel-reorder-stages, #config-close-modal, #close-versions-modal, #pin-submit-button, #close-simulation-modal, #close-locations-preview, #deviation-accept, #arrival-stats-accept-button, #cancel-simulation-speed');
            if (closeBtn) clearModalAutoCloseTimer(modal, closeBtn, id.replace(/-/g, '_') || `modal_timer_${Date.now()}`);
             if (id === 'simulation-modal') {
                 if (simulationModalTimer) {
                     clearTimeout(simulationModalTimer);
                     simulationModalTimer = null;
                 }
                 hideIntersectionPreviewMap();
             }
        }
    });
    document.querySelectorAll(
        '.choice-modal, .edit-modal, .edit-info-modal, .help-modal, .reminder-modal, .reminder-table-modal, #postpone-options-modal, .saved-locations-modal, #reminders-map-help-modal-instance'
    ).forEach(m => {
        if (m.id === modalToKeepOpenId) return;
        if (m.parentNode) {
             const closeBtn = m.querySelector('button[id^="close-"], button[id*="-close"], #cancel-postpone');
             if(closeBtn) clearModalAutoCloseTimer(m, closeBtn, m.id.replace(/-/g, '_') || `modal_timer_${Date.now()}`);
             m.remove();
        }
    });
     if (modalToKeepOpenId !== 'unified-reminder-window') {
        hideUnifiedReminderWindow();
     }
}    
// ===================================================================
// NOMBRE: showConfigModal (MODIFICADA - MUESTRA ESTADO DE SESIN)
// RESUMEN: Muestra el modal de configuracin principal, incluyendo la hora de inicio de la sesin de mapa activa.
function showConfigModal() {
    closeOtherModals('config-modal');
    const modal = document.getElementById('config-modal');
    if (!modal) return;

    const sessionStatusEl = document.getElementById('map-session-status');
    if (sessionStatusEl) {
        if (mapSessionStartTime) {
            const sessionDate = new Date(mapSessionStartTime);
            const formattedTime = sessionDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            sessionStatusEl.textContent = `(Sesin de mapa abierta: ${formattedTime})`;
        } else {
            sessionStatusEl.textContent = '(No hay sesin de mapa activa)';
        }
    }
  
    const termsAccepted = localStorage.getItem('termsAccepted_v1') === 'true';
    const tabButtons = modal.querySelectorAll('.config-tab-button');
    const tabContents = modal.querySelectorAll('.config-tab-content');

    if (!termsAccepted) {
        tabButtons.forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.tabTarget !== '#tab-content-normas') {
                btn.disabled = true; 
                btn.style.cursor = 'not-allowed';
                btn.style.opacity = '0.5';
            }
        });
        tabContents.forEach(content => content.classList.remove('active'));
        
        modal.querySelector('.config-tab-button[data-tab-target="#tab-content-normas"]').classList.add('active');
        modal.querySelector('#tab-content-normas').classList.add('active');
    } else {
        tabButtons.forEach(btn => {
            btn.disabled = false;
            btn.style.cursor = 'pointer';
            btn.style.opacity = '1';
            btn.classList.toggle('active', btn.dataset.tabTarget === '#tab-content-usuario');
        });
        tabContents.forEach(content => {
            content.classList.toggle('active', content.id === 'tab-content-usuario');
        });
    }

    modal.querySelectorAll('.status-message').forEach(msg => msg.textContent = '');
    modal.querySelectorAll('input[type="text"], input[type="number"], textarea').forEach(input => {
        if (!['user-id', 'config-pin-set', 'config-pin-confirm'].includes(input.id)) {
            input.value = '';
        }
    });
    modal.querySelector('#config-pin-set').value = '';
    modal.querySelector('#config-pin-confirm').value = '';
    modal.querySelector('#config-backup-display').value = '';
    modal.querySelector('#config-restore-input').value = '';
    if(modal.querySelector('#config-backup-display')) modal.querySelector('#config-backup-display').style.display = 'none';
    const userIdInput = modal.querySelector('#user-id');
    const storedUserId = localStorage.getItem('userData_userId');
    if (userIdInput) userIdInput.value = storedUserId || '';
    
    const teslaModelInput = modal.querySelector('#tesla-model');
    if (teslaModelInput) teslaModelInput.value = localStorage.getItem('userData_teslaModel') || '';
    const teslaYearInput = modal.querySelector('#tesla-year');
    if (teslaYearInput) teslaYearInput.value = localStorage.getItem('userData_teslaYear') || '';
    const teslaProvinceInput = modal.querySelector('#tesla-province');
    if (teslaProvinceInput) teslaProvinceInput.value = localStorage.getItem('userData_teslaProvince') || '';
    const allowDmsCheckbox = modal.querySelector('#allow-dms');
    if (allowDmsCheckbox) allowDmsCheckbox.checked = JSON.parse(localStorage.getItem('userData_allowDMs')) || false;
    
    const directToNavCheckbox = document.getElementById('config-direct-to-nav');
    if (directToNavCheckbox) directToNavCheckbox.checked = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;

    const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
    if (autoBackupCheckbox) {
        const savedAutoBackup = localStorage.getItem('boardinggate_autoBackupOnLoad');
        autoBackupCheckbox.checked = savedAutoBackup === null ? true : JSON.parse(savedAutoBackup);
    }

    modal.classList.remove('hidden');
    const closeButtonConfig = modal.querySelector('#config-close-modal');
    addModalAutoCloseTimer(modal, closeButtonConfig, 'config-modal', 120000);
}
    
    // ===================================================================
    // NOMBRE: loadNotices
    // RESUMEN: Carga los avisos desde un archivo de texto externo.
    async function loadNotices() { try { const r = await fetch('https://boardinggate.github.io/Tesla/avisos.txt', { cache: 'no-cache' }); if (!r.ok) throw new Error('Fetch failed'); const txt = await r.text(); notices = txt.split('\n').map(l => l.trim()).filter(l => l.length > 0); if (notices.length === 0) notices = ['No hay avisos.']; } catch (e) { notices = ['Error carga avisos.']; } updateNotice(); } 
    
    // ===================================================================
    // NOMBRE: updateNotice
    // RESUMEN: Actualiza el texto del aviso visible en la pantalla.
    function updateNotice() { const noticeElement = document.getElementById('current-notice'); if (!noticeElement || notices.length === 0) { return; } if (!isActive) { noticeElement.textContent = ''; noticeElement.style.animation = 'none'; return; } noticeElement.textContent = notices[currentNoticeIndex]; noticeElement.style.animation = 'none'; void noticeElement.offsetWidth; noticeElement.style.animation = 'fadeInOut 14s infinite'; currentNoticeIndex = (currentNoticeIndex + 1) % notices.length; }
    
    // ===================================================================
    // NOMBRE: toggleNotices
    // RESUMEN: Activa o desactiva la visualizacin de los avisos y el pie de pgina.
    function toggleNotices() { isActive = !isActive; const nC = document.querySelector('.notices-container'); if (nC) nC.style.display = isActive ? 'flex' : 'none'; const fC = document.querySelector('footer'); if (fC) fC.classList.toggle('footer-hidden', !isActive); isFooterVisible = isActive; const nE = document.getElementById('current-notice'); if (nE) { if (!isActive) { nE.textContent = ''; nE.style.animation = 'none'; } else { currentNoticeIndex = 0; updateNotice(); } } saveSettings(); }

    // ===================================================================
    // NOMBRE: startNoticeRotation
    // RESUMEN: Inicia la rotacin peridica de los avisos.
    function startNoticeRotation() { if (notices.length === 0) return; if (isActive) updateNotice(); setInterval(updateNotice, 14000); }
    
    // ===================================================================
    // NOMBRE: adjustButtonPositions
    // RESUMEN: Ajusta dinmicamente la posicin de los botones laterales fijos.
    function adjustButtonPositions() { const scrollToggle = document.getElementById('scroll-toggle'); if (!scrollToggle) { return; }
    const scrollToggleHeight = scrollToggle.offsetHeight; const buttonHeight = 74; const buttonSpacing = 10; const startTop = scrollToggleHeight + 20; const fixedButtons = [ document.getElementById('on-off-toggle'), ...document.querySelectorAll('.range-toggle'), document.getElementById('weather-button'), document.getElementById('reminder-button'), document.getElementById('zoom-button'), document.getElementById('dark-mode-toggle') ].filter(button => button !== null).sort((a, b) => { const startA = parseInt(a.dataset.rangeStart) || Infinity; const startB = parseInt(b.dataset.rangeStart) || Infinity; if (a.id === 'on-off-toggle') return -1; if (b.id === 'on-off-toggle') return 1; if (isFinite(startA) && isFinite(startB)) return startA - startB; if (isFinite(startA)) return -1; if (isFinite(startB)) return 1; const order = ['weather-button', 'reminder-button', 'zoom-button', 'dark-mode-toggle']; return order.indexOf(a.id) - order.indexOf(b.id); }); if (fixedButtons.length < 6) { return; } let currentTop = startTop; fixedButtons.forEach((button) => { button.style.position = 'fixed'; button.style.top = `${currentTop}px`; button.style.left = '10px'; currentTop += buttonHeight + buttonSpacing; }); }
    
    
 
// ===================================================================
// NOMBRE: translatePoiCategory (VERSIN CON TRADUCCIN MANUAL)
// RESUMEN: Traduce y formatea las categoras de POI recibidas en ingls desde la API de Mapbox.
function translatePoiCategory(categories) {
    if (!Array.isArray(categories) || categories.length === 0) {
        return 'General';
    }

    const MAPBOX_CATEGORY_TRANSLATIONS = {
        'restaurant': 'Restaurante',
        'cafe': 'Cafetera',
        'bar': 'Bar',
        'fast_food': 'Comida Rpida',
        'food_court': 'Zona de Restaurantes',
        'gas_station': 'Gasolinera',
        'parking': 'Parking',
        'hotel': 'Hotel',
        'motel': 'Motel',
        'lodging': 'Alojamiento',
        'supermarket': 'Supermercado',
        'grocery': 'Tienda de Alimentacin',
        'convenience': 'Tienda de Conveniencia',
        'shopping': 'Tiendas',
        'mall': 'Centro Comercial',
        'clothing_store': 'Tienda de Ropa',
        'hardware_store': 'Ferretera',
        'home_goods_store': 'Tienda de Hogar',
        'pharmacy': 'Farmacia',
        'hospital': 'Hospital',
        'clinic': 'Clnica',
        'doctor': 'Mdico',
        'dentist': 'Dentista',
        'atm': 'Cajero Automtico',
        'bank': 'Banco',
        'tourist_attraction': 'Atraccin Turstica',
        'landmark': 'Lugar de Inters',
        'museum': 'Museo',
        'park': 'Parque',
        'zoo': 'Zoo',
        'airport': 'Aeropuerto',
        'bus_station': 'Estacin de Autobuses',
        'train_station': 'Estacin de Tren',
        'subway_station': 'Estacin de Metro',
        'car_rental': 'Alquiler de Coches',
        'car_repair': 'Taller Mecnico',
        'car_wash': 'Lavado de Coches',
        'library': 'Biblioteca',
        'school': 'Colegio',
        'university': 'Universidad',
        'post_office': 'Oficina de Correos',
        'police': 'Polica',
        'fire_station': 'Bomberos',
        'cinema': 'Cine',
        'night_club': 'Discoteca',
        'stadium': 'Estadio',
        'gym': 'Gimnasio',
        'golf_course': 'Campo de Golf',
        'beach': 'Playa',
        'campground': 'Camping',
        'marina': 'Puerto Deportivo'
    };

    const translatedCategories = categories.map(englishCategory => {
        const translated = MAPBOX_CATEGORY_TRANSLATIONS[englishCategory];
        if (translated) {
            return translated;
        } else {
            const cleaned = englishCategory.replace(/_/g, ' ');
            return cleaned.charAt(0).toUpperCase() + cleaned.slice(1);
        }
    });

    return translatedCategories.join(', ');
}

// ===================================================================
// NOMBRE: findExistingWaypointAtCoords
// RESUMEN: Busca si ya existe una etapa de ruta en las coordenadas dadas.
function findExistingWaypointAtCoords(lat, lon, toleranceMeters = 10) {
    for (const waypoint of navigationWaypoints) {
        if (waypoint && !waypoint.isInternal) {
            const distance = calculateDistance(lat, lon, waypoint.lat, waypoint.lng);
            if (distance <= toleranceMeters) {
                return waypoint;
            }
        }
    }
    return null;
}
// ===================================================================
// NOMBRE: enablePoiInteractivity (VERSIN SIMPLIFICADA)
// RESUMEN: nicamente cambia el cursor a "puntero" al pasar sobre los POIs.
function enablePoiInteractivity(mapInstance) {
    if (!mapInstance) return;

    const interactiveLayers = [
        'poi-label', 'transit-label', 'airport-label', 'settlement-label', 
        'natural-label', 'water-point-label'
    ];

    mapInstance.on('mouseenter', interactiveLayers, () => {
        mapInstance.getCanvas().style.cursor = 'pointer';
    });
    mapInstance.on('mouseleave', interactiveLayers, () => {
        mapInstance.getCanvas().style.cursor = '';
    });
}
// ===================================================================
// NOMBRE: loadAndAddMapImages (VERSIN ROBUSTA)
// RESUMEN: Carga imgenes y contina aunque alguna falle.
async function loadAndAddMapImages(mapInstance) {
    const imagesToLoad = [
        { name: 'reminder-icon', url: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png' },
        { name: 'radar-generic-icon', url: 'PNG/RADARAQUI.PNG' },
        { name: 'pdr-icon-simple', url: 'PNG/pdrs.png' }
    ];

    const imageLoadPromises = imagesToLoad.map(img => 
        new Promise((resolve) => { // No usamos reject para no detener Promise.all
            if (mapInstance.hasImage(img.name)) {
                resolve();
                return;
            }
            mapInstance.loadImage(img.url, (error, image) => {
                if (error) {
                    console.error(`Error al cargar imagen ${img.name}:`, error);
                    resolve(); // Resuelve igualmente para no bloquear
                    return;
                }
                if (!mapInstance.hasImage(img.name)) {
                    mapInstance.addImage(img.name, image, { sdf: false });
                }
                resolve();
            });
        })
    );
    await Promise.all(imageLoadPromises);
}

// ===================================================================
// NOMBRE: showSaveRoutePromptForSingleWaypoint (VERSIN CORREGIDA Y DEFINITIVA)
// RESUMEN: Muestra el modal de guardado, usando directamente el nombre descriptivo
//          del POI que se le pasa, en lugar de recalcularlo.
// ===================================================================
async function showSaveRoutePromptForSingleWaypoint(waypointObject) {
    // CORRECCIN CLAVE! Usa directamente el nombre del POI pasado en 'waypointObject.address'.
    const defaultName = `UBICACIN: ${waypointObject.address}`.toUpperCase();
    
    const onSaveCallback = (confirmedName) => {
        const routeToSave = {
            name: confirmedName,
            waypoints: [{ ...waypointObject, type: 'F', label: 'F' }],
            createdAt: new Date().toISOString()
        };

        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        const existingRouteIndex = savedRoutes.findIndex(r => r.name.toUpperCase() === confirmedName);

        if (existingRouteIndex !== -1) {
            if (confirm(`Ya existe una ubicacin guardada como "${confirmedName}". Deseas sobreescribirla?`)) {
                savedRoutes[existingRouteIndex] = routeToSave;
            } else {
                showToast("Guardado cancelado", "info");
                return;
            }
        } else {
            savedRoutes.push(routeToSave);
        }

        if (savedRoutes.length > MAX_SAVED_ROUTES) {
            savedRoutes.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
            savedRoutes = savedRoutes.slice(0, MAX_SAVED_ROUTES);
        }
        localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes));
        markCacheAsDirty();
        showToast(`Ubicacin "${confirmedName}" guardada en favoritos.`, "success");
    };

    showSaveRoutePromptModal(defaultName, onSaveCallback);
} 
// ===================================================================
// NOMBRE: getGlobalPoiStats
// RESUMEN: Calcula las estadsticas globales de clics en POIs de todos los usuarios.
async function getGlobalPoiStats() {
    if (!window.db) return { totalMonth: 0 };
    
    let totalMonth = 0;
    
    try {
        const usersCollectionRef = window.collection(window.db, "user_data");
        const querySnapshot = await window.getDocs(usersCollectionRef);
        
        const now = new Date();
        const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        querySnapshot.forEach(doc => {
            const data = doc.data();
            if (data.poi_clicks_last_month === currentMonthStr) {
                totalMonth += (data.poi_clicks_month || 0);
            }
        });

    } catch (error) {
        console.error("Error al obtener estadsticas globales de POIs:", error);
    }
    
    return { totalMonth };
}

// ===================================================================
// NOMBRE: showPoiInfoModal (VERSIN CON GOOGLE PLACES Y FALLBACK IMG CORREGIDO)
// RESUMEN: Muestra un modal enriquecido con datos de Google Places.
async function showPoiInfoModal(feature) {
    const existingModal = document.querySelector('.poi-modal-overlay');
    if (existingModal) existingModal.remove();

    const overlay = document.createElement('div');
    overlay.className = 'poi-modal-overlay';
    
    overlay.innerHTML = `
        <div class="poi-modal-content">
            <div class="poi-modal-body" style="text-align: center; padding: 3rem;">
                <p>Obteniendo informacin del lugar...</p>
            </div>
        </div>
    `;
    document.body.appendChild(overlay);

    try {
        const canProceed = await checkAndIncrementPoiCount();
        if (!canProceed) {
            if (overlay.parentNode) overlay.remove();
            return;
        }

        const mapboxProperties = feature.properties || {};
        const coordinates = feature.geometry.coordinates.slice();
        const mapboxName = mapboxProperties.name || 'Punto de Inters';
        
        const placeId = await findGooglePlaceId(mapboxName, coordinates[1], coordinates[0]);
        
        let name, address, phone, website, imageUrl, saveName, photosHtml = '', commentsHtml = '', detailsHtml = '';
        const lat = coordinates[1];
        const lng = coordinates[0];

        if (placeId) {
            const googleDetails = await getGooglePlaceDetails(placeId);
            
            if (googleDetails) {
                name = googleDetails.displayName || mapboxName;
                address = googleDetails.formattedAddress || `(${lat.toFixed(4)}, ${lng.toFixed(4)})`;
                phone = googleDetails.nationalPhoneNumber;
                website = googleDetails.websiteURI;
                imageUrl = (googleDetails.photos && googleDetails.photos.length > 0) 
                    ? googleDetails.photos[0].getURI({ maxWidth: 600, maxHeight: 400 }) 
                    : 'PNG/modalrutas.png'; // <-- CAMBIO APLICADO AQU
                saveName = name;

                detailsHtml += '<h4>Valoracin</h4>';
                if(googleDetails.rating) {
                    detailsHtml += `<p>${''.repeat(Math.round(googleDetails.rating))}${''.repeat(5 - Math.round(googleDetails.rating))} (${googleDetails.rating} de ${googleDetails.userRatingCount} opiniones)</p>`;
                } else {
                    detailsHtml += '<p>No hay valoraciones disponibles.</p>';
                }
                
                if (googleDetails.regularOpeningHours) {
                    detailsHtml += '<h4>Horario</h4>';
                    googleDetails.regularOpeningHours.weekdayDescriptions.forEach(day => {
                        detailsHtml += `<p>${day}</p>`;
                    });
                }
                
                detailsHtml += '<h4>Contacto</h4>';
                if(phone) detailsHtml += `<p><strong>Telfono:</strong> <a href="tel:${phone}">${phone}</a></p>`;
                if(website) detailsHtml += `<p><strong>Web:</strong> <a href="${website}" target="_blank">${website}</a></p>`;
                if(googleDetails.googleMapsURI) detailsHtml += `<p><strong>En Google Maps:</strong> <a href="${googleDetails.googleMapsURI}" target="_blank">Abrir</a></p>`;

                if (googleDetails.photos && googleDetails.photos.length > 0) {
                    photosHtml = '<div class="ocm-photo-grid">' + googleDetails.photos.slice(0, 6).map(photo => 
                        `<img src="${photo.getURI({ maxWidth: 200, maxHeight: 200 })}" alt="Foto de ${name}" data-full-url="${photo.getURI()}">`
                    ).join('') + '</div>';
                } else { photosHtml = '<p>No hay fotos disponibles.</p>'; }

                if (googleDetails.reviews && googleDetails.reviews.length > 0) {
                    commentsHtml = '<ul class="ocm-comment-list">' + googleDetails.reviews.map(review => {
                        const authorName = review.authorAttribution ? review.authorAttribution.displayName : 'Annimo';
                        const reviewDate = review.publishTime ? new Date(review.publishTime).toLocaleDateString('es-ES', { day: '2-digit', month: 'short', year: 'numeric'}) : '';
                        const reviewText = review.text ? review.text.originalText : 'Sin comentario.';
                        return `
                        <li class="ocm-comment">
                            <div class="ocm-comment-header">
                                <span class="user">${authorName} (${review.rating} )</span>
                                <span class="date">${reviewDate}</span>
                            </div>
                            <p class="comment-text">${reviewText}</p>
                        </li>
                    `}).join('') + '</ul>';
                } else { commentsHtml = '<p>No hay opiniones disponibles.</p>'; }

            } else {
                throw new Error("Google Place Details fall despus de encontrar un ID.");
            }
        } else {
            name = mapboxName;
            address = `(${lat.toFixed(4)}, ${lng.toFixed(4)})`;
            category = translatePoiCategory(mapboxProperties.categories || []);
            imageUrl = 'PNG/modalrutas.png'; // <-- CAMBIO APLICADO AQU
            saveName = name;
            detailsHtml = `<h4>Categora</h4><p>${category}</p><p>No se encontraron detalles adicionales en Google.</p>`;
            photosHtml = '<p>No disponible.</p>';
            commentsHtml = '<p>No disponible.</p>';
        }
        
        const existingWaypoint = findExistingWaypointAtCoords(lat, lng);
        let buttonsHtml = `
            <button id="poi-add-btn" class="btn-modal-action-primary">Aadir a Ruta</button>
            <button id="poi-save-btn" class="btn-modal-favorite">Guardar POI</button>
            <button id="poi-share-btn" class="btn-modal-action-primary">Compartir</button>
        `;
        if (existingWaypoint) {
            buttonsHtml += `<button id="poi-delete-btn" class="btn-modal-danger" data-waypoint-id="${existingWaypoint.id}">Eliminar Etapa</button>`;
        } else {
             buttonsHtml += `<button id="poi-close-btn" class="btn-modal-action-secondary">Cerrar <span class="button-countdown-timer"></span></button>`;
        }
        
        overlay.querySelector('.poi-modal-content').innerHTML = `
            <div class="poi-modal-header" style="background-image: url('${imageUrl}');">
                <h3 class="poi-modal-title">${name}</h3>
                <p class="poi-modal-address">${address}</p>
            </div>
            <div class="ocm-modal-tabs">
                <div class="ocm-modal-tab active" data-panel="details">DETALLES</div>
                <div class="ocm-modal-tab" data-panel="photos">FOTOS</div>
                <div class="ocm-modal-tab" data-panel="comments">OPINIONES</div>
            </div>
            <div class="poi-modal-body">
                <div id="poi-panel-details" class="ocm-modal-panel active">${detailsHtml}</div>
                <div id="poi-panel-photos" class="ocm-modal-panel">${photosHtml}</div>
                <div id="poi-panel-comments" class="ocm-modal-panel">${commentsHtml}</div>
            </div>
            <div class="poi-modal-footer">${buttonsHtml}</div>
        `;
        
        const closeHandler = () => {
            clearModalAutoCloseTimer(overlay, overlay.querySelector('#poi-close-btn, #poi-delete-btn'), 'poi-modal');
            if (overlay.parentNode) overlay.remove();
        };

        const closeBtn = overlay.querySelector('#poi-close-btn');
        if (closeBtn) closeBtn.addEventListener('click', closeHandler);
        
        overlay.querySelector('#poi-add-btn').addEventListener('click', async () => {
            const snapped = await snapCoordsToRoad(lat, lng);
            addWaypoint({ lat: snapped.lat, lng: snapped.lng }, address);
            closeHandler();
        });

        overlay.querySelector('#poi-save-btn').addEventListener('click', () => {
             const waypointForSave = { lat: lat, lng: lng, address: saveName, id: Date.now() };
             showSaveRoutePromptForSingleWaypoint(waypointForSave);
             closeHandler();
        });

        overlay.querySelector('#poi-share-btn').addEventListener('click', () => {
            handleSendToTeslaClick(lat, lng, name);
            closeHandler();
        });
        
        overlay.querySelectorAll('.ocm-modal-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                overlay.querySelectorAll('.ocm-modal-tab, .ocm-modal-panel').forEach(el => el.classList.remove('active'));
                tab.classList.add('active');
                overlay.querySelector(`#poi-panel-${tab.dataset.panel}`).classList.add('active');
            });
        });

        overlay.querySelectorAll('.ocm-photo-grid img').forEach(img => {
            img.addEventListener('click', () => showPhotoModal(img.dataset.fullUrl));
        });

        const deleteBtn = overlay.querySelector('#poi-delete-btn');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', () => {
                handleDeleteWaypointClick(parseInt(deleteBtn.dataset.waypointId));
                closeHandler();
            });
        }
        addModalAutoCloseTimer(overlay, overlay.querySelector('#poi-close-btn, #poi-delete-btn'), 'poi-modal', 45000);

    } catch (error) {
        console.error("Error al mostrar el modal del POI:", error);
        showToast("Error al mostrar informacin del POI.", 'error');
        if (overlay.parentNode) overlay.remove();
    }
}    
    
// ===================================================================
// NOMBRE: updateRouteAndCarIconStyle (MODIFICADA)
// RESUMEN: Ajusta el estilo de la lnea de ruta cuando ya existe, tras un cambio de capa de mapa.
function updateRouteAndCarIconStyle() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) return;

    if (navigationMapInstance.getLayer('route')) {
        const styleProps = getRouteStyleProperties();
        Object.keys(styleProps).forEach(prop => {
            navigationMapInstance.setPaintProperty('route', prop, styleProps[prop]);
        });
    }
}
    
    // ===================================================================
    // NOMBRE: loadCustomData
    // RESUMEN: Carga los datos de personalizacin del grid desde localStorage.
    function loadCustomData() { const savedData = localStorage.getItem('customGridData'); currentBookmarks = []; currentToggleRanges = []; customData = { bookmarks: {}, toggles: {} }; if (savedData) { try { customData = JSON.parse(savedData) || { bookmarks: {}, toggles: {} }; } catch (e) { customData = { bookmarks: {}, toggles: {} }; } } if (!customData.bookmarks) customData.bookmarks = {}; if (!customData.toggles) customData.toggles = {}; currentBookmarks = Array.from({ length: TOTAL_CELLS }).map((_, index) => { if (customData.bookmarks.hasOwnProperty(index)) { return customData.bookmarks[index] ? { ...customData.bookmarks[index] } : null; } else { const original = index < originalBookmarks.length ? originalBookmarks[index] : null; return original ? { ...original } : null; } }); currentToggleRanges = originalToggleRanges.map(originalRange => { const customToggle = customData.toggles[originalRange.start]; const rangeCopy = { ...originalRange }; if (customToggle) { if (typeof customToggle.label === 'string') rangeCopy.label = customToggle.label; if (Array.isArray(customToggle.assignedIndexes)) rangeCopy.assignedIndexes = [...customToggle.assignedIndexes]; } if (!rangeCopy.assignedIndexes) rangeCopy.assignedIndexes = Array.from({ length: rangeCopy.end - originalRange.start + 1 }, (_, i) => originalRange.start + i); return rangeCopy; }); }
     
    // ===================================================================
    // NOMBRE: loadReminders
    // RESUMEN: Carga los recordatorios y actualiza el contador.
    function loadReminders() { updateReminderCount(); }

// ===================================================================
// NOMBRE: actualizarContadorRadares
// RESUMEN: Actualiza el contador numrico de radares en la UI del mapa.
function actualizarContadorRadares(count) {
    const contadorElement = document.getElementById('radares-ruta-count');
    if (contadorElement) {
        contadorElement.textContent = count;
        const checkbox = document.getElementById('radares-ruta-checkbox');
        contadorElement.classList.toggle('hidden', count === 0 && (!checkbox || !checkbox.checked));
    }
}
// ===================================================================
// NOMBRE: actualizarContadorTareas
// RESUMEN: Actualiza el contador numrico de tareas en la UI del mapa.
function actualizarContadorTareas(count) {
    const contadorElement = document.getElementById('tareas-ruta-count');
    if (contadorElement) {
        contadorElement.textContent = count;
        const checkbox = document.getElementById('tareas-ruta-checkbox');
        contadorElement.classList.toggle('hidden', count === 0 && (!checkbox || !checkbox.checked));
    }
}    
// ===================================================================
// NOMBRE: applyZoom (VERSIN CON PROPORCIONALIDAD CORREGIDA)
// RESUMEN: Aplica el zoom. En modo 'on', usa un tamao fijo de 190px por columna, que es proporcionalmente
function applyZoom(state) {
    const originalWidth = 984;
    const zoomedCols = 4;
    const originalCols = 6;
    const gap = 15;
    const zoomButton = document.getElementById('zoom-button');

    if (state === 'on') {
        const zoomedColumnWidth = 224; // Nuevo tamao calculado para ser proporcionalmente ms grande.
        grid.style.gridTemplateColumns = `repeat(${zoomedCols}, ${zoomedColumnWidth}px)`;
        grid.style.gap = `${gap}px`;
        grid.style.maxWidth = `${(zoomedCols * zoomedColumnWidth) + ((zoomedCols - 1) * gap)}px`; 
        
        document.querySelectorAll('.bookmark-item img').forEach(i => { i.style.width = '48px'; i.style.maxWidth = '52px'; });
        document.querySelectorAll('.bookmark-name').forEach(n => { n.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)'; });
        document.querySelectorAll('.small-bookmark img').forEach(i => { i.style.width = '48px'; i.style.maxWidth = '52px'; });
        document.querySelectorAll('.small-bookmark .bookmark-name').forEach(n => { n.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)'; });
        if (zoomButton) zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/zoon+.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`;
    } else {
        grid.style.gridTemplateColumns = `repeat(${originalCols}, minmax(120px, 1fr))`;
        grid.style.gap = `${gap}px`;
        grid.style.maxWidth = `${originalWidth}px`; 
        document.querySelectorAll('.bookmark-item img').forEach(i => { i.style.width = '36px'; i.style.maxWidth = '40px'; });
        document.querySelectorAll('.bookmark-name').forEach(n => { n.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)'; });
        document.querySelectorAll('.small-bookmark img').forEach(i => { i.style.width = '24px'; i.style.maxWidth = '28px'; });
        document.querySelectorAll('.small-bookmark .bookmark-name').forEach(n => { n.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)'; });
        if (zoomButton) zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`;
    }
}    
    
    // ===================================================================
    // NOMBRE: getSectionForIndex
    // RESUMEN: Devuelve la configuracin de la seccin a la que pertenece un ndice del grid.
    function getSectionForIndex(index) { return currentToggleRanges.find(range => range.assignedIndexes.includes(index)); } 
    
    // ===================================================================
    // NOMBRE: getColorForSection
    // RESUMEN: Obtiene el color de fondo para una seccin, considerando el modo oscuro.
    function getColorForSection(sectionStart, state = 'visible') { if (state === 'hidden') { return sectionColors.off; } if (isDarkMode) { return darkModeGenericButtonColor; } else { return sectionColors[sectionStart] || sectionColors.unassigned; } }
     
    // ===================================================================
    // NOMBRE: updateButtonStyles
    // RESUMEN: Actualiza los estilos visuales de todos los botones de la UI.
    function updateButtonStyles() {
        const darkModeToggleElem = document.getElementById('dark-mode-toggle');
        const onOffToggleElem = document.getElementById('on-off-toggle');
        const rangeToggleButtonsElems = document.querySelectorAll('.toggle-sign.range-toggle');
        const reminderButtonElem = document.getElementById('reminder-button');
        if (onOffToggleElem) {
            onOffToggleElem.src = `https://boardinggate.github.io/Tesla/${onOffToggleElem.dataset.state === 'on' ? 'PNG/IMG_4192.jpg' : 'PNG/IMG_4191.jpg'}`;
            onOffToggleElem.alt = `Toggle ${onOffToggleElem.dataset.state === 'on' ? 'On' : 'Off'}`;
            onOffToggleElem.style.backgroundColor = sectionColors.off;
            if (isDarkMode) {
                onOffToggleElem.style.filter = 'brightness(85%)';
                 if (onOffToggleElem.dataset.state === 'on') {
                    onOffToggleElem.style.backgroundColor = darkModeGenericButtonColor;
                 }
            } else {
                onOffToggleElem.style.filter = '';
            }
        }
        if (darkModeToggleElem) {
            darkModeToggleElem.src = `https://boardinggate.github.io/Tesla/PNG/${isDarkMode ? 'oscuro2.png' : 'claro2.png'}`;
            darkModeToggleElem.alt = `Toggle ${isDarkMode ? 'Oscuro' : 'Claro'}`;
            darkModeToggleElem.style.backgroundColor = sectionColors.off;
            if (isDarkMode) darkModeToggleElem.style.filter = 'brightness(85%)'; else darkModeToggleElem.style.filter = '';
        }
        let reminders = [];
        try {
            reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        } catch(e) {
            reminders = [];
        }
        const showExcludedInTable = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
        let remindersForButtonStyleCount = reminders;
        if (!showExcludedInTable) {
            remindersForButtonStyleCount = reminders.filter(r => !r.excludeFromList);
        }
        const totalPendingCount = remindersForButtonStyleCount.length;
        if (reminderButtonElem) {
            reminderButtonElem.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/IMG_4197.jpg" alt="Recordatorio" style="max-width: 70%; max-height: 70%; object-fit: contain;">${totalPendingCount > 0 ? `<span class="reminder-count">${totalPendingCount}</span>` : ''}`;
            reminderButtonElem.style.backgroundColor = sectionColors.off;
            if (isDarkMode) reminderButtonElem.style.filter = 'brightness(85%)'; else reminderButtonElem.style.filter = '';
        }
        rangeToggleButtonsElems.forEach(toggle => {
            const start = parseInt(toggle.dataset.rangeStart);
            const state = toggle.dataset.state || 'visible';
            const rangeConfig = currentToggleRanges.find(r => r.start === start);
            if (rangeConfig) {
                toggle.innerHTML = `<span class="sign">${state === 'visible' ? '-' : '+'}</span>${rangeConfig.label}`;
            }
            toggle.style.backgroundColor = getColorForSection(start, state);
            if (isDarkMode && state === 'visible') {
                toggle.style.filter = 'brightness(85%)';
            } else {
                toggle.style.filter = '';
            }
        });
        updatePasswordToggleIcon();
        const zoomButtonElem = document.getElementById('zoom-button');
        if (zoomButtonElem && zoomButtonElem.dataset.zoomState) {
            applyZoom(zoomButtonElem.dataset.zoomState);
        }
        if (cellElements && cellElements.length > 0) {
            cellElements.forEach((cell, index) => {
                const bookmarkItem = cell.querySelector('.bookmark-item');
                const emptySlot = cell.classList.contains('empty-slot');
                const section = getSectionForIndex(index);
                const color = sectionColors[section ? section.start : null] || sectionColors.unassigned;
                if (bookmarkItem) {
                    bookmarkItem.style.backgroundColor = color;
                } else if (emptySlot) {
                    cell.style.backgroundColor = color;
                }
            });
        }
    }
// ===================================================================
// NOMBRE: showWaypointActionModal (MODIFICADA - NUEVO DISEO Y BOTN)
// RESUMEN: Muestra un modal con el nuevo diseo oscuro para las acciones de una etapa de ruta, incluyendo el nuevo botn "Aadir a Favoritos".
function showWaypointActionModal(waypointId) {
    const wp = navigationWaypoints.find(w => w && w.id === waypointId);
    if (!wp) return;

    const existingOverlay = document.getElementById('route-modal-action-overlay');
    if(existingOverlay) existingOverlay.remove();
    
    const overlay = document.createElement('div');
    overlay.id = 'route-modal-action-overlay';
    overlay.className = 'route-modal-overlay';
    
    let distanceToWaypoint = 0, timeToWaypoint = 0, etaToWaypoint = "--:--";
    const currentActualWaypointsForModal = navigationWaypoints.filter(w => w && !w.isInternal && !w.isRecalculatedStart);
    const actualWaypointIndexInRoute = currentActualWaypointsForModal.findIndex(awp => awp.id === wp.id);
    if (navigationCurrentRouteData?.routes?.[0]) {
        const route = navigationCurrentRouteData.routes[0];
        if (actualWaypointIndexInRoute > 0) {
            for (let i = 0; i < actualWaypointIndexInRoute && i < route.legs.length; i++) {
                distanceToWaypoint += (route.legs[i].distance || 0);
                timeToWaypoint += (route.legs[i].duration || 0);
            }
        }
        if (timeToWaypoint > 0) etaToWaypoint = new Date(Date.now() + timeToWaypoint * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }
    const distanciaTexto = `${(distanceToWaypoint / 1000).toFixed(1)} km`;
    const waypointTotalMinutes = Math.round(timeToWaypoint / 60);
    const tiempoTexto = `${String(Math.floor(waypointTotalMinutes / 60)).padStart(2, '0')}:${String(waypointTotalMinutes % 60).padStart(2, '0')}`;
    
    const alternativesButtonHtml = (wp.type !== 'S' && wp.type !== 'S_Recalc') ? `<button id="modal-alternatives-btn" class="btn-modal-action-primary">Otras Rutas</button>` : '';
    const deleteButtonHtml = (wp.type !== 'S_Recalc') ? `<button id="modal-delete-btn" class="btn-modal-danger">Borrar Punto</button>` : '';
    const favoriteButtonHtml = `<button id="modal-favorite-btn" class="btn-modal-favorite">Aadir a Favoritos</button>`;
    
    overlay.innerHTML = `
        <div id="waypoint-action-modal" class="route-modal-container">
            <div class="route-modal-header">
                <div class="route-modal-title-card">
                    <span class="route-modal-title">Etapa ${wp.label}</span>
                </div>
            </div>
            <div class="route-modal-body">
                <p style="font-size: 1.1rem; color: #f0f0f0; margin-bottom: 15px;"><strong>Destino:</strong> ${wp.address}</p>
                <p><strong>Distancia:</strong> ${distanciaTexto}</p>
                <p><strong>Tiempo:</strong> ${tiempoTexto}</p>
                <p><strong>Llegada (ETA):</strong> ${etaToWaypoint}</p>
            </div>
            <div class="route-modal-footer" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <button id="modal-share-btn" class="btn-modal-action-primary">Compartir</button>
                ${alternativesButtonHtml}
                ${favoriteButtonHtml}
                ${deleteButtonHtml}
                <button id="modal-close-btn" class="btn-modal-action-secondary" style="grid-column: 1 / -1;">Cerrar <span class="button-countdown-timer"></span></button>
            </div>
        </div>
    `;

    document.body.appendChild(overlay);

    const closeHandler = () => {
        clearModalAutoCloseTimer(overlay, overlay.querySelector('#modal-close-btn'), 'waypoint-action-modal');
        if (overlay.parentNode) overlay.remove();
    };

    overlay.querySelector('#modal-close-btn').addEventListener('click', closeHandler);
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) closeHandler();
    });

    overlay.querySelector('#modal-share-btn').addEventListener('click', () => {
        handleSendToTeslaClick(wp.lat, wp.lng, wp.address);
        closeHandler();
    });

    overlay.querySelector('#modal-favorite-btn').addEventListener('click', () => {
        saveSingleWaypointAsFavorite(wp.id);
        closeHandler();
    });

    const alternativesBtn = overlay.querySelector('#modal-alternatives-btn');
    if (alternativesBtn) {
        alternativesBtn.addEventListener('click', () => {
            fetchAndDisplayAlternativeRoutes(wp.id);
            closeHandler();
        });
    }

    const deleteBtn = overlay.querySelector('#modal-delete-btn');
    if (deleteBtn) {
        deleteBtn.addEventListener('click', () => {
            handleDeleteWaypointClick(wp.id);
            closeHandler();
        });
    }

    addModalAutoCloseTimer(overlay, overlay.querySelector('#modal-close-btn'), 'waypoint-action-modal', 20000);
}

// ===================================================================
// NOMBRE: saveSingleWaypointAsFavorite (NUEVA FUNCIN)
// RESUMEN: Inicia el proceso de guardado para un nico punto de ruta como favorito.
function saveSingleWaypointAsFavorite(waypointId) {
    const waypointToSave = navigationWaypoints.find(wp => wp && wp.id === waypointId);
    if (!waypointToSave) {
        showToast("Error: No se pudo encontrar la etapa para guardar.", "error");
        return;
    }
    showSaveRoutePromptForSingleWaypoint(waypointToSave);
}

// ===================================================================
// NOMBRE: saveCurrentRoute (MODIFICADA - REFACTORIZADA CON NUEVO MODAL)
// RESUMEN: Inicia el proceso para guardar la ruta completa, llamando al modal reutilizable de guardado.
async function saveCurrentRoute() {
    const actualWaypointsToSave = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    
    if (actualWaypointsToSave.length < 2) {
        showToast("No hay ruta activa para guardar (se necesitan al menos 2 puntos)", "warning");
        return;
    }

    const isMultiStage = actualWaypointsToSave.length > 2;
    const lastWp = actualWaypointsToSave[actualWaypointsToSave.length - 1];
    const defaultRouteName = await getSuggestedRouteName(lastWp.lat, lastWp.lng, isMultiStage, actualWaypointsToSave.length);
    
    const onSaveCallback = (confirmedName) => {
        let waypointsToSave = actualWaypointsToSave.map(wp => ({
            id: wp.id, lat: wp.lat, lng: wp.lng, label: wp.label, type: wp.type, address: wp.address || '', visited: false, isCriticalForRecalc: true, isInternal: false, isRecalculatedStart: false
        }));

        const routeToSave = {
            name: confirmedName,
            waypoints: waypointsToSave,
            createdAt: new Date().toISOString()
        };

        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        const existingRouteIndex = savedRoutes.findIndex(r => r.name.toUpperCase() === confirmedName);
        if (existingRouteIndex !== -1) {
            if (!confirm(`Ya existe una ruta llamada "${confirmedName}". Sobreescribir?`)) {
                showToast("Guardado cancelado", "info");
                return;
            }
            savedRoutes[existingRouteIndex] = routeToSave;
        } else {
            savedRoutes.push(routeToSave);
        }
        if (savedRoutes.length > MAX_SAVED_ROUTES) {
            savedRoutes.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
            savedRoutes = savedRoutes.slice(0, MAX_SAVED_ROUTES);
        }
        localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes));
        markCacheAsDirty();
        addRouteToRecents(routeToSave);
        showToast(`Ruta "${confirmedName}" guardada.`, "success");
    };

    showSaveRoutePromptModal(defaultRouteName, onSaveCallback);
}

// ===================================================================
// NOMBRE: showSaveRoutePromptModal (NUEVA FUNCIN REUTILIZABLE)
// RESUMEN: Muestra un modal de guardado genrico con el nuevo diseo oscuro.
function showSaveRoutePromptModal(defaultName, onSaveCallback) {
    const existingOverlay = document.getElementById('route-modal-save-overlay');
    if (existingOverlay) existingOverlay.remove();

    const overlay = document.createElement('div');
    overlay.id = 'route-modal-save-overlay';
    overlay.className = 'route-modal-overlay';
    
    const modalContent = document.createElement('div');
    modalContent.id = 'save-route-prompt-modal';
    modalContent.className = 'route-modal-container';
    modalContent.innerHTML = `
        <div class="route-modal-header">
            <div class="route-modal-title-card">
                 <span class="route-modal-title">Guardar Favorito</span>
            </div>
        </div>
        <div class="route-modal-body">
            <label for="route-name-input" class="route-label">Nombre:</label>
            <div class="input-with-clear-button" style="position: relative;">
                <input type="text" id="route-name-input" value="${defaultName.toUpperCase()}" class="route-filter-input" style="padding-right: 40px;">
                <button class="clear-input-btn" title="Limpiar nombre" style="position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: transparent; border: none; font-size: 1.8rem; color: #aaa; cursor: pointer; display: none;"></button>
            </div>
            <p style="font-size: 0.8rem; color: #8e8e93; margin-top: 10px;">
                (*) Las rutas se guardan y recuperan con el trayecto MS RPIDO.
            </p>
        </div>
        <div class="route-modal-footer">
            <button id="confirm-save-route" class="btn-modal-save">Guardar <span class="button-countdown-timer"></span></button>
            <button id="cancel-save-route" class="btn-modal-cancel">Cancelar</button>
        </div>
    `;
    
    overlay.appendChild(modalContent);
    document.body.appendChild(overlay);

    const nameInput = modalContent.querySelector('#route-name-input');
    const confirmButton = modalContent.querySelector('#confirm-save-route');
    const cancelButton = modalContent.querySelector('#cancel-save-route');
    const clearBtn = modalContent.querySelector('.clear-input-btn');
    
    const toggleClearButton = () => { clearBtn.style.display = nameInput.value.trim().length > 0 ? 'block' : 'none'; };
    nameInput.addEventListener('input', toggleClearButton);
    clearBtn.addEventListener('click', () => { nameInput.value = ''; toggleClearButton(); nameInput.focus(); });
    toggleClearButton();

    nameInput.focus();
    const textLength = nameInput.value.length;
    nameInput.setSelectionRange(textLength, textLength);

    const closePrompt = () => {
        clearModalAutoCloseTimer(overlay, confirmButton, 'save-route-prompt-modal');
        if (overlay.parentNode) overlay.remove();
    };

    const saveAction = () => {
        let routeName = nameInput.value.trim().toUpperCase();
        if (!routeName) {
            showToast("El nombre no puede estar vaco", "warning");
            addModalAutoCloseTimer(overlay, confirmButton, 'save-route-prompt-modal', 15000);
            return;
        }
        onSaveCallback(routeName);
        closePrompt();
    };

    confirmButton.addEventListener('click', saveAction);
    cancelButton.addEventListener('click', closePrompt);
    addModalAutoCloseTimer(overlay, confirmButton, 'save-route-prompt-modal', 20000);
}
    
    // ===================================================================
    // NOMBRE: formatVersionDate
    // RESUMEN: Formatea una fecha a un formato de versin especfico (YY.MM.DDHH).
    function formatVersionDate(date) { const y = date.getUTCFullYear().toString().slice(-2); const m = String(date.getUTCMonth() + 1).padStart(2, '0'); const d = String(date.getUTCDate()).padStart(2, '0'); const h = String(date.getUTCHours()).padStart(2, '0'); return `${y}.${m}.${d}${h}`; }
    
    // ===================================================================
    // NOMBRE: getLastModifiedDate
    // RESUMEN: Obtiene la fecha de la ltima modificacin desde un archivo remoto, con cach local.
    async function getLastModifiedDate() {
        const k = 'teslaHtmlLastModified';
        const tk = 'teslaHtmlLastModifiedTimestamp';
        const dur = 86400000;
        const cd = localStorage.getItem(k);
        const ct = localStorage.getItem(tk);
        const now = Date.now();
        if (cd && ct && (now - parseInt(ct)) < dur) {
            return new Date(cd);
        }
        try {
            const r = await fetch('https://boardinggate.github.io/Tesla/version.txt', { cache: 'no-cache' });
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const txt = await r.text();
            const lmd = new Date(txt.trim());
            if (isNaN(lmd.getTime())) throw new Error('Invalid date format');
            localStorage.setItem(k, lmd.toISOString());
            localStorage.setItem(tk, now.toString());
            return lmd;
        } catch (e) {
            if (cd) return new Date(cd);
            return new Date('2024-01-01T00:00:00Z');
        }
    }
    
    
    // ===================================================================
    // NOMBRE: updateVersion
    // RESUMEN: Actualiza el texto de la versin en la UI.
    async function updateVersion() { try { const lmd = await getLastModifiedDate(); const v = formatVersionDate(lmd); const el = document.getElementById('version'); if (el) el.textContent = `versin: ${v}`; } catch (e) { const el = document.getElementById('version'); if (el) el.textContent = 'versin: error'; } }
    
    // ===================================================================
    // NOMBRE: getFaviconUrl
    // RESUMEN: Obtiene la URL del favicon para un marcador, usando un servicio externo como fallback.
    const getFaviconUrl = (bookmarkData) => { try { const urlToParse = bookmarkData?.url || ''; const customFavicon = bookmarkData?.favicon; if (customFavicon && (customFavicon.startsWith('data:image') || customFavicon.startsWith('http') || customFavicon.startsWith('./'))) return customFavicon; if (urlToParse) { const domain = new URL(urlToParse).hostname; return `https://www.google.com/s2/favicons?domain=${domain}&sz=64`; } } catch (e) { } return 'https://via.placeholder.com/64'; };
    
    // ===================================================================
    // NOMBRE: renderGrid
    // RESUMEN: Dibuja o redibuja el grid completo de marcadores.
    function renderGrid() { grid.innerHTML = ''; cellElements = []; Array.from({ length: TOTAL_CELLS }).forEach((_, index) => { const cellContainer = document.createElement('div'); cellContainer.classList.add('grid-cell'); cellContainer.dataset.index = index; const bookmarkData = currentBookmarks[index]; const section = getSectionForIndex(index); const bgColor = sectionColors[section ? section.start : null] || sectionColors.unassigned; if (bookmarkData) { const link = document.createElement('a'); link.className = 'bookmark-item'; link.title = bookmarkData.name; link.style.backgroundColor = bgColor; link.href = bookmarkData.url || "#"; link.dataset.index = index;
        if (isKeywordAssignmentMode || (bookmarkData.name && bookmarkData.name === "Inicio Tesla") || !bookmarkData.url || bookmarkData.url === '#') { } else { link.target = "_blank"; link.rel = "noopener noreferrer"; }
        const img = document.createElement('img'); img.src = getFaviconUrl(bookmarkData); img.alt = `Favicon ${bookmarkData.name}`; img.loading = "lazy"; img.onerror = function() { this.src = 'https://via.placeholder.com/64'; this.onerror = null; }; if (bookmarkData.name === "Mis Updates") img.classList.add('favicon-red'); else if (bookmarkData.name === "Olas Updates") img.classList.add('favicon-blue'); const nameSpan = document.createElement('span'); nameSpan.className = 'bookmark-name'; nameSpan.textContent = bookmarkData.name; link.appendChild(img); link.appendChild(nameSpan); cellContainer.appendChild(link); } else { cellContainer.classList.add('empty-slot'); const addIcon = document.createElement('span'); addIcon.textContent = '+'; cellContainer.appendChild(addIcon); cellContainer.style.backgroundColor = bgColor; }
        cellContainer.addEventListener('click', handleGridCellClick);
        if (isEditMode) {
             cellContainer.draggable = true;
             cellContainer.addEventListener('dragstart', handleDragStart); cellContainer.addEventListener('dragover', handleDragOver);
             cellContainer.addEventListener('dragleave', handleDragLeave);
             cellContainer.addEventListener('drop', handleDrop);
             cellContainer.addEventListener('dragend', handleDragEnd);
             cellContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
             cellContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
             cellContainer.addEventListener('touchend', handleTouchEnd);
             cellContainer.addEventListener('touchcancel', handleTouchCancel);
             cellContainer.classList.add('editable');
        } else {
             cellContainer.draggable = false;
             cellContainer.removeEventListener('dragstart', handleDragStart);
             cellContainer.removeEventListener('dragover', handleDragOver);
             cellContainer.removeEventListener('dragleave', handleDragLeave);
             cellContainer.removeEventListener('drop', handleDrop);
             cellContainer.removeEventListener('dragend', handleDragEnd);
             cellContainer.removeEventListener('touchstart', handleTouchStart);
             cellContainer.removeEventListener('touchmove', handleTouchMove);
             cellContainer.removeEventListener('touchend', handleTouchEnd);
             cellContainer.removeEventListener('touchcancel', handleTouchCancel);
             cellContainer.classList.remove('editable');
        }
        grid.appendChild(cellContainer); cellElements.push(cellContainer); }); }
    
    
    // ===================================================================
    // NOMBRE: renderToggleButtons
    // RESUMEN: Dibuja los botones laterales para ocultar/mostrar secciones del grid.
    function renderToggleButtons() {
        document.querySelectorAll('.range-toggle').forEach(btn => btn.remove());
        toggleButtonElements = {};
        const toggleStatesFromCache = JSON.parse(localStorage.getItem('toggleStates') || '{}');
        currentToggleRanges.forEach((range) => {
            const toggle = document.createElement('span');
            toggle.className = 'toggle-sign range-toggle';
            toggle.dataset.rangeStart = range.start;
            toggle.dataset.rangeEnd = range.end;
            toggle.style.position = 'fixed';
            toggle.style.top = '100px';
            toggle.style.left = '10px';
            const initialState = toggleStatesFromCache[range.start] || 'visible';
            toggle.dataset.state = initialState;
            toggle.addEventListener('click', handleToggleClick);
            document.body.appendChild(toggle);
            toggleButtonElements[range.start] = toggle;
        });
    }
  // ===================================================================
// NOMBRE: createOtherButtons
// RESUMEN: Crea y aade a la UI los botones de accin fijos.
function createOtherButtons() {
    if (!document.getElementById('on-off-toggle')) {
        onOffToggle = document.createElement('img');
        onOffToggle.className = 'toggle-image';
        onOffToggle.id = 'on-off-toggle';
        const savedOnOffState = localStorage.getItem('onOffState');
        onOffToggle.dataset.state = savedOnOffState ? savedOnOffState : 'on';
        document.body.appendChild(onOffToggle);
        onOffToggle.addEventListener('mousedown', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) pressStartTime = Date.now(); });
        onOffToggle.addEventListener('mouseup', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) handleOnOffAction(); });
        onOffToggle.addEventListener('mouseleave', () => { pressStartTime = null; });
        onOffToggle.addEventListener('touchstart', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); pressStartTime = Date.now(); } });
        onOffToggle.addEventListener('touchend', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); handleOnOffAction(); } });
    }
    if (!document.getElementById('weather-button')) { weatherButton = document.createElement('span'); weatherButton.className = 'toggle-sign'; weatherButton.id = 'weather-button'; weatherButton.innerHTML = `<img src="https://www.google.com/s2/favicons?domain=accuweather.com&sz=64" alt="Tiempo" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; document.body.appendChild(weatherButton); weatherButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; window.open('https://www.ventusky.com/?p=40.2;-4.7;5&l=rain-3h', '_blank'); }); }
    if (!document.getElementById('reminder-button')) { reminderButton = document.createElement('span'); reminderButton.className = 'toggle-sign'; reminderButton.id = 'reminder-button'; document.body.appendChild(reminderButton); reminderButton.addEventListener('mousedown', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) reminderPressStartTime = Date.now(); }); reminderButton.addEventListener('mouseup', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) handleReminderLongPress(); }); reminderButton.addEventListener('mouseleave', () => { reminderPressStartTime = null; }); reminderButton.addEventListener('touchstart', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); reminderPressStartTime = Date.now(); } }); reminderButton.addEventListener('touchend', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); handleReminderLongPress(); } }); }
    if (!document.getElementById('zoom-button')) { zoomButton = document.createElement('span'); zoomButton.className = 'toggle-sign'; zoomButton.id = 'zoom-button'; zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; zoomButton.dataset.zoomState = localStorage.getItem('zoomState') || 'off'; document.body.appendChild(zoomButton); zoomButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const cS = zoomButton.dataset.zoomState; const nS = cS === 'off' ? 'on' : 'off'; applyZoom(nS); zoomButton.dataset.zoomState = nS; updateButtonStyles(); saveSettings(); adjustButtonPositions(); }); }
    if (!document.getElementById('dark-mode-toggle')) { darkModeToggle = document.createElement('img'); darkModeToggle.className = 'toggle-image'; darkModeToggle.id = 'dark-mode-toggle'; document.body.appendChild(darkModeToggle); darkModeToggle.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; isDarkMode = !isDarkMode; document.body.classList.toggle('dark-mode', isDarkMode); updateButtonStyles(); saveSettings(); }); }
    if (!document.getElementById('config-button')) {
        const configButton = document.createElement('span');
        configButton.id = 'config-button';
        configButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/config.jpg" alt="Configuracin">`;
        document.body.appendChild(configButton);
        configButton.addEventListener('click', () => {
            if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) {
                const mapIsCurrentlyOpen = isNavigationMapActive;
                const currentMapContext = sessionStorage.getItem('mapContext');
                if (mapIsCurrentlyOpen && currentMapContext) {
                    sessionStorage.setItem('boardinggate_map_should_reopen_after_config', 'true');
                    sessionStorage.setItem('mapContextToReopenAfterConfig', currentMapContext);
                    closeNavigationMap(true);
                }
                showConfigModal();
            }
        });
    }
    if (!document.getElementById('personal-button')) {
        const personalButton = document.createElement('span');
        personalButton.id = 'personal-button';
        personalButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="Personal">`;
        document.body.appendChild(personalButton);
        personalButton.addEventListener('click', handlePersonalizationClick);
    }
    if (!document.getElementById('radar-button')) {
        radarButton = document.createElement('span');
        radarButton.id = 'radar-button';
        radarButton.innerHTML = `<img src="PNG/AVANCE.PNG" alt="Radar/Ubicaciones/Navegacin">`;
        document.body.appendChild(radarButton);
        radarButton.addEventListener('click', () => {
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;

            const userId = localStorage.getItem('userData_userId');
            const allowDMs = JSON.parse(localStorage.getItem('userData_allowDMs') || 'false');

            if (userId && userId.trim() !== '' && allowDMs) {
                openNavigationMap();
            } else {
                const message = "PARA ACCEDER A MAPAS, ES IMPRESCINDIBLE QUE CREE EN CONFIGURACIN UN NOMBRE DE USUARIO NICO (y debe estar activado Permitir MDs tambin)...";
                const duration = 10000; 

                showToast(message, 'error', duration);

                setTimeout(() => {
                    showConfigModal();
                }, duration);
            }
             });
    }
    if (!document.getElementById('home-button')) {
        const homeButton = document.createElement('span');
        homeButton.id = 'home-button';
        homeButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/home.webp" alt="Inicio">`;
        document.body.appendChild(homeButton);
        homeButton.addEventListener('click', (e) => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) { e.preventDefault(); return; } window.history.back(); });
    }
    if (!document.getElementById('reload-button')) {
        const reloadButton = document.createElement('span');
        reloadButton.id = 'reload-button';
        reloadButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/reload.webp" alt="Recargar">`;
        document.body.appendChild(reloadButton);
        reloadButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; location.reload(); });
    }
    if (!document.getElementById('keyword-assignment-button')) {
         const keywordButton = document.createElement('span');
         keywordButton.id = 'keyword-assignment-button';
         keywordButton.title = "Asignar/Quitar palabra clave filtro";
         keywordButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/IMG_4314.PNG" alt="Asignar Keyword">`;
         document.body.appendChild(keywordButton);
         keywordButton.addEventListener('click', () => { toggleKeywordAssignmentMode(!isKeywordAssignmentMode); });
    }
    if (!document.getElementById('password-toggle-button')) {
        const passwordButton = document.createElement('span');
        passwordButton.id = 'password-toggle-button';
        passwordButton.innerHTML = `<img src="" alt="Clave">`;
        document.body.appendChild(passwordButton);
        passwordButton.addEventListener('click', handlePasswordToggleClick);
    }
    if (!document.getElementById('versions-button')) {
         versionsButton = document.createElement('span');
         versionsButton.id = 'versions-button';
         versionsButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/IMG_4309.PNG" alt="Versiones">`;
         document.body.appendChild(versionsButton);
         versionsButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; showVersionsModal(); });
    }
    if (!document.getElementById('info-button')) {
         infoButton = document.createElement('span');
         infoButton.id = 'info-button';
         infoButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/IMG_4326.PNG" alt="Info">`;
         document.body.appendChild(infoButton);
         infoButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; window.open('https://boardinggate.github.io/Tesla/manual.html', '_blank'); });
    }
}  
    
    // ===================================================================
    // NOMBRE: handleGridCellClick
    // RESUMEN: Gestiona los clics en las celdas del grid, segn el modo activo.
    function handleGridCellClick(event) {
        const cellContainer = event.currentTarget; const index = parseInt(cellContainer.dataset.index);
        if (isEditMode) { const link = cellContainer.querySelector('a.bookmark-item'); if (link) event.preventDefault(); showEditModal(index, false); }
        else if (isAssignmentMode) { event.preventDefault(); handleGridCellClickForAssignment(index); }
        else if (isKeywordAssignmentMode) { event.preventDefault(); handleKeywordAssignmentClick(index); }
        else { const link = cellContainer.querySelector('a.bookmark-item'); const bookmarkData = currentBookmarks[index];
            if (!link || !link.href || link.href === '#') {
                event.preventDefault();
                if (bookmarkData && bookmarkData.url && bookmarkData.url.startsWith("map-action:")) {
                    const action = bookmarkData.url.split(":")[1];
                    if (action === "openRemindersMapWithNoRadars") {
                        openLocationsPreviewMap();
                    } else if (action === "openRemindersMap") {
                        openNavigationMap();
                    }
                }
            } else {
                if (!link.target && bookmarkData && bookmarkData.name !== "Inicio Tesla") {
                    link.target = "_blank"; link.rel = "noopener noreferrer";
                }
            }
        }
    }
    
    // ===================================================================
    // NOMBRE: handleToggleClick
    // RESUMEN: Gestiona los clics en los botones laterales de seccin, segn el modo activo.
    function handleToggleClick(event) { const toggle = event.currentTarget; if (isEditMode) { event.preventDefault(); const start = parseInt(toggle.dataset.rangeStart); showEditModal(start, true); } else if (isAssignmentMode) { event.preventDefault(); handleToggleClickForAssignment(toggle); } else if (isKeywordAssignmentMode) { event.preventDefault(); } else { updateToggleState(toggle); } }
    
    
    // ===================================================================
    // NOMBRE: updateToggleState
    // RESUMEN: Cambia el estado (visible/oculto) de un botn de seccin.
    function updateToggleState(toggle) { if (!toggle || isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const start = parseInt(toggle.dataset.rangeStart); if (isNaN(start)) return; const rangeConfig = currentToggleRanges.find(r => r.start === start); if (!rangeConfig) return; const currentState = toggle.dataset.state; const newState = currentState === 'visible' ? 'hidden' : 'visible'; toggle.dataset.state = newState; const savedStates = JSON.parse(localStorage.getItem('toggleStates') || '{}'); savedStates[start] = newState; localStorage.setItem('toggleStates', JSON.stringify(savedStates)); updateButtonStyles(); filterGridItems(); } 
    
    
    // ===================================================================
    // NOMBRE: updateAllToggles
    // RESUMEN: Cambia el estado de todos los toggles a la vez (on/off general).
    function updateAllToggles(newState) { const onOffToggleElem = document.getElementById('on-off-toggle'); if (!onOffToggleElem) return; onOffToggleElem.dataset.state = newState; localStorage.setItem('onOffState', newState); updateButtonStyles(); filterGridItems(); saveSettings(); }
    const scrollToggle = document.getElementById('scroll-toggle'); if (scrollToggle) scrollToggle.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const sP = window.scrollY; const mS = document.body.scrollHeight - window.innerHeight; window.scrollTo({ top: sP < 100 ? mS : 0, behavior: 'smooth' }); });
    
    // ===================================================================
    // NOMBRE: handleOnOffAction
    // RESUMEN: Maneja la accin del botn de on/off general.
    function handleOnOffAction() { if (pressStartTime !== null) { const t = document.getElementById('on-off-toggle'); if (t) { const nS = t.dataset.state === 'on' ? 'off' : 'on'; updateAllToggles(nS); } } pressStartTime = null; } 
    
    // ===================================================================
    // NOMBRE: handleReminderLongPress
    // RESUMEN: Maneja el clic corto/largo en el botn de recordatorios.
    function handleReminderLongPress() { if (reminderPressStartTime === null) return; const dur = Date.now() - reminderPressStartTime; if (dur >= 2000) showAllReminders(); else showReminderModal(); reminderPressStartTime = null; }
    
    // ===================================================================
    // NOMBRE: handlePersonalizationClick
    // RESUMEN: Gestiona el clic en el botn de personalizacin, mostrando el men de opciones.
    function handlePersonalizationClick() {
        const personalButton = document.getElementById('personal-button'); const wasEditing = isEditMode; const wasAssigning = isAssignmentMode; const wasKeywordAssigning = isKeywordAssignmentMode;
        if (wasKeywordAssigning) { toggleKeywordAssignmentMode(false); }
        if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
        if (wasEditing) { toggleEditMode(false); } else if (wasAssigning) { toggleAssignmentMode(false); } else if (!wasKeywordAssigning) { showPersonalizationChoice(); }
    }
    
    // ===================================================================
    // NOMBRE: showPersonalizationChoice
    // RESUMEN: Muestra el modal para elegir el tipo de personalizacin.
    function showPersonalizationChoice() {
        const existingModal = document.querySelector('.choice-modal'); if (existingModal) existingModal.remove();
        const modal = document.createElement('div'); modal.className = 'choice-modal'; modal.setAttribute('aria-label', 'Elegir tipo de personalizacin');
        modal.innerHTML = `
            <h2>Qu quieres personalizar?</h2>
            <div class="modal-top-buttons">
                <button class="choice-cancel">Cancelar</button>
            </div>
            <p class="mb-6">Elige una opcin:</p>
            <div class="personalization-options">
                <button class="choice-edit">URLs / Etiquetas / Reordenar</button>
                <button class="choice-assign">Asignar Botones Ocultacin</button>
                <button class="choice-help">Ver Ayuda</button>
            </div>
        `;
        modal.querySelector('.choice-edit').addEventListener('click', () => { modal.remove(); toggleEditMode(true); });
        modal.querySelector('.choice-assign').addEventListener('click', () => { modal.remove(); toggleAssignmentMode(true); });
        modal.querySelector('.choice-help').addEventListener('click', () => { modal.remove(); showEditInfoModal(); });
        modal.querySelector('.choice-cancel').addEventListener('click', () => { modal.remove(); });
        document.body.appendChild(modal);
        addModalAutoCloseTimer(modal, modal.querySelector('.choice-cancel'), 'choice-modal', 30000);
    }
    
    
    // ===================================================================
    // NOMBRE: toggleEditMode
    // RESUMEN: Activa o desactiva el modo de edicin (URLs, etiquetas, arrastrar).
    function toggleEditMode(activate) {
        const personalButton = document.getElementById('personal-button'); isEditMode = activate; personalButton.classList.toggle('editing', isEditMode); document.body.classList.toggle('editing-active', isEditMode);
        if (isEditMode) {
            if (isAssignmentMode) toggleAssignmentMode(false); if (isKeywordAssignmentMode) toggleKeywordAssignmentMode(false);
            if (firstPersonalizationSession) { showEditInfoModal(); firstPersonalizationSession = false; sessionStorage.setItem('personalizationHelpShown', 'true'); }
            showToast("Modo Edicin (URLs/Etiquetas/Arrastrar) Activado", "info", 4000);
        } else {
            showToast("Modo Edicin Desactivado", "info", 2000);
            cellElements.forEach(cell => cell.classList.remove('dragging', 'drag-over')); draggedItem = null; draggedItemIndex = null; currentTouchTarget = null; dragOverIndex = null;
            if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
        } renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles(); adjustButtonPositions();
        document.querySelectorAll('.range-toggle').forEach(el => { el.classList.toggle('editable', isEditMode); }); filterGridItems();
    }
     
    // ===================================================================
    // NOMBRE: toggleAssignmentMode
    // RESUMEN: Activa o desactiva el modo de asignacin de botones a secciones.
    function toggleAssignmentMode(activate) {
        const personalButton = document.getElementById('personal-button'); isAssignmentMode = activate; personalButton.classList.toggle('assigning', isAssignmentMode); document.body.classList.toggle('assignment-active', isAssignmentMode);
        if (isAssignmentMode) {
            if (isEditMode) toggleEditMode(false); if (isKeywordAssignmentMode) toggleKeywordAssignmentMode(false);
            if (firstPersonalizationSession) { showEditInfoModal(); firstPersonalizationSession = false; sessionStorage.setItem('personalizationHelpShown', 'true'); }
            showToast("Modo Asignacin Botones Activado", "info", 4000);
            const firstToggle = document.querySelector('.range-toggle');
            if (firstToggle) { handleToggleClickForAssignment(firstToggle); } else { currentlyAssigningToggleStart = null; updateGridAssignmentVisuals(); }
        } else {
            showToast("Modo Asignacin Botones Desactivado", "info", 2000); saveCustomData();
            document.querySelectorAll('.range-toggle.assigning-selected').forEach(t => t.classList.remove('assigning-selected'));
            document.querySelectorAll('.grid-cell.assigned-to-current').forEach(c => { c.classList.remove('assigned-to-current'); c.style.opacity = ''; c.style.outline=''; c.style.boxShadow=''; c.style.backgroundColor = ''; });
            document.querySelectorAll('.range-toggle').forEach(t => t.style.opacity = '');
            currentlyAssigningToggleStart = null;
        } renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles(); adjustButtonPositions(); filterGridItems(); 
    }
    
    
    // ===================================================================
    // NOMBRE: toggleKeywordAssignmentMode
    // RESUMEN: Activa o desactiva el modo de asignacin de palabras clave a los nombres de los marcadores.
    function toggleKeywordAssignmentMode(activate) {
         const keywordButton = document.getElementById('keyword-assignment-button'); const filterInput = document.getElementById('grid-filter-input'); isKeywordAssignmentMode = activate;
         if (keywordButton) { keywordButton.classList.toggle('active', isKeywordAssignmentMode); }
        document.body.classList.toggle('keyword-assignment-active', isKeywordAssignmentMode);
         if (isKeywordAssignmentMode) {
              if (isEditMode) toggleEditMode(false); if (isAssignmentMode) toggleAssignmentMode(false);
              const toastMessage = "Modo activo: Escribe palabra(s) en el campo filtro grid (separadas por espacio si son varias). Pulsa ICONO FILTRO para aadir/quitar esa(s) palabra(s) al nombre del botn(es) que vaya seleccionando. Pulsa el icono para salir de este modo.";
              showToast(toastMessage, "info", 15000); filterGridItems(); applyInitialKeywordHighlights();
         } else {
              showToast("Modo Asignacin de Palabras Clave Desactivado", "info", 2000); cellElements.forEach(cell => cell.classList.remove('keyword-assigned-highlight')); filterGridItems();
         }
    }
    
    // ===================================================================
    // NOMBRE: applyInitialKeywordHighlights
    // RESUMEN: Resalta los marcadores que ya contienen la palabra clave del filtro al activar el modo.
    function applyInitialKeywordHighlights() { const filterInput = document.getElementById('grid-filter-input'); const keyword = filterInput.value.trim().replace(/\s+/g, '').toUpperCase(); if (!keyword) return; const keywordTag = `[${keyword}]`; cellElements.forEach((cell, index) => { const bookmark = currentBookmarks[index]; if (bookmark && bookmark.name && bookmark.name.includes(keywordTag)) { cell.classList.add('keyword-assigned-highlight'); } else { cell.classList.remove('keyword-assigned-highlight'); } }); }
    
    // ===================================================================
    // NOMBRE: handleKeywordAssignmentClick
    // RESUMEN: Aade o quita la palabra clave del filtro al nombre de un marcador.
    function handleKeywordAssignmentClick(index) {
        const filterInput = document.getElementById('grid-filter-input'); const keyword = filterInput.value.trim().replace(/\s+/g, '').toUpperCase();
        if (!keyword) { showToast("Escribe una palabra en el campo filtro primero.", "warning"); return; }
        const bookmark = currentBookmarks[index]; const cellElement = cellElements[index];
        if (!bookmark || !cellElement) { showToast(`No hay un marcador en la posicin ${index + 1}.`, "warning"); return; }
        const keywordTag = `[${keyword}]`; const currentName = bookmark.name || ""; const nameSpan = cellElement.querySelector('.bookmark-name');
        let newName = currentName; let actionTaken = '';
        if (currentName.includes(keywordTag)) { newName = currentName.replace(keywordTag, '').replace(/\s{2,}/g, ' ').trim(); cellElement.classList.remove('keyword-assigned-highlight'); actionTaken = 'removed'; }
        else { newName = currentName.trim(); const lastBracketIndex = newName.lastIndexOf(']'); const endsWithBracket = lastBracketIndex !== -1 && lastBracketIndex === newName.length - 1;
            if (endsWithBracket) { newName += '  ' + keywordTag; } else { newName += '          ' + keywordTag; } cellElement.classList.add('keyword-assigned-highlight'); actionTaken = 'added'; }
        bookmark.name = newName; currentBookmarks[index] = { ...bookmark }; if (!customData.bookmarks) customData.bookmarks = {}; customData.bookmarks[index] = { ...bookmark }; saveCustomData();
        if (nameSpan) { nameSpan.textContent = newName; }
        if (actionTaken === 'added') { showToast(`"${keyword}" aadido. Nombre: ${newName}`, "success", 2500); } else if (actionTaken === 'removed') { showToast(`"${keyword}" quitado. Nombre: ${newName}`, "info", 2500); }
    }
    
    // ===================================================================
    // NOMBRE: handleToggleClickForAssignment
    // RESUMEN: Selecciona un botn de seccin para empezar a asignarle marcadores.
    function handleToggleClickForAssignment(toggleElement) { const start = parseInt(toggleElement.dataset.rangeStart); if (isNaN(start)) return; currentlyAssigningToggleStart = start; document.querySelectorAll('.range-toggle').forEach(t => { t.classList.toggle('assigning-selected', t === toggleElement); t.style.opacity = t === toggleElement ? '' : '0.7'; }); updateGridAssignmentVisuals(); showToast(`Asignando botones para: ${toggleElement.textContent.substring(1)}`, "info", 2500); } 
    
    
    // ===================================================================
    // NOMBRE: handleGridCellClickForAssignment
    // RESUMEN: Asigna o desasigna un marcador a la seccin actualmente seleccionada.
    function handleGridCellClickForAssignment(cellIndex) {
        if (currentlyAssigningToggleStart === null) { showToast("Selecciona primero un botn lateral (PdR,s, iAs, etc.)", "warning"); return; }
        const startKey = currentlyAssigningToggleStart.toString(); if (!customData.toggles[startKey]) { const currentRange = currentToggleRanges.find(r => r.start == startKey); customData.toggles[startKey] = { label: currentRange ? currentRange.label : `Rango ${startKey}`, assignedIndexes: currentRange ? [...currentRange.assignedIndexes] : [] }; }
        else if (!customData.toggles[startKey].assignedIndexes) { const currentRange = currentToggleRanges.find(r => r.start == startKey); customData.toggles[startKey].assignedIndexes = currentRange ? [...currentRange.assignedIndexes] : []; }
        const assigned = customData.toggles[startKey].assignedIndexes; const indexInArray = assigned.indexOf(cellIndex);
        if (indexInArray > -1) { assigned.splice(indexInArray, 1); } else { assigned.push(cellIndex); assigned.sort((a, b) => a - b); }
        const currentRangeIndex = currentToggleRanges.findIndex(r => r.start == startKey); if (currentRangeIndex > -1) { currentToggleRanges[currentRangeIndex].assignedIndexes = [...assigned]; }
        updateGridAssignmentVisuals(); saveCustomData(); showToast('Asignacin guardada', 'success', 500);
    }
    
    // ===================================================================
    // NOMBRE: updateGridAssignmentVisuals
    // RESUMEN: Actualiza la apariencia visual del grid durante el modo de asignacin.
    function updateGridAssignmentVisuals() { if (!isAssignmentMode || currentlyAssigningToggleStart === null) { cellElements.forEach(cell => { cell.classList.remove('assigned-to-current'); cell.style.opacity = ''; cell.style.outline = ''; cell.style.boxShadow = ''; }); return; } const startKey = currentlyAssigningToggleStart.toString(); let assignedIndexesForCurrentToggle = []; if (customData.toggles[startKey] && customData.toggles[startKey].assignedIndexes) { assignedIndexesForCurrentToggle = customData.toggles[startKey].assignedIndexes; } else { const currentRange = currentToggleRanges.find(r => r.start == startKey); if (currentRange?.assignedIndexes) { assignedIndexesForCurrentToggle = currentRange.assignedIndexes; } } cellElements.forEach((cell, index) => { const isAssigned = assignedIndexesForCurrentToggle.includes(index); cell.classList.toggle('assigned-to-current', isAssigned); if (isAssigned) { cell.style.opacity = ''; cell.style.outline = '3px solid cyan'; cell.style.boxShadow = document.body.classList.contains('dark-mode') ? 'inset 0 0 10px rgba(0, 200, 200, 0.7)' : 'inset 0 0 8px rgba(0, 255, 255, 0.6)'; } else { cell.style.opacity = document.body.classList.contains('dark-mode') ? '0.5' : '0.6'; cell.style.outline = `1px dashed ${document.body.classList.contains('dark-mode') ? '#555' : '#aaa'}`; cell.style.boxShadow = ''; } }); } 
    
    
    // ===================================================================
    // NOMBRE: showEditInfoModal
    // RESUMEN: Muestra el modal con la ayuda sobre los modos de personalizacin.
    function showEditInfoModal() {
        const existingModal = document.querySelector('.edit-info-modal'); if (existingModal) existingModal.remove();
        const modal = document.createElement('div'); modal.className = 'edit-info-modal'; modal.setAttribute('aria-label', 'Ayuda Personalizacin');
        modal.innerHTML = `
            <h2 class="text-xl font-bold mb-4">Ayuda de Personalizacin</h2>
            <div class="modal-top-buttons" style="justify-content: flex-end;">
                <button type="button" id="close-edit-info" class="px-6 py-2" style="flex: 0 1 auto; min-width: 120px;">Entendido</button>
            </div>
            <p class="mb-3">Al pulsar el botn <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (personalizar) o el icono <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4314.PNG" alt="Key" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (llave) puedes elegir entre varios modos:</p>
            <div class="mb-4 p-3 bg-yellow-100 border border-yellow-300 rounded">
                 <h3 class="font-semibold text-lg mb-2">1. Editar URLs / Etiquetas / Reordenar (Botn Personalizar Amarillo)</h3>
                 <ul class="list-disc pl-5 space-y-1 text-sm">
                    <li><strong>Activar:</strong> Elige "URLs / Etiquetas / Reordenar" en el men inicial. El botn <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> se pondr amarillo.</li>
                    <li><strong>Editar Marcador/Botn Lateral:</strong> Haz clic en un marcador del grid o en un botn lateral (PdR,s, iAs, etc.). Se abrir una ventana para editar su nombre, URL (si es marcador) o etiqueta (si es botn lateral). <strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                    <li><strong>Arrastrar y Soltar:</strong> Mantn pulsado un marcador del grid y arrstralo a otra posicin (incluso vaca) para reordenarlos.</li>
                    <li><strong>Guardar Cambios:</strong> Los cambios en nombre/URL/etiqueta se guardan al pulsar "Guardar" en la ventana de edicin. El reordenamiento se guarda automticamente al soltar.</li>
                    <li><strong>Vaciar Casilla:</strong> En la ventana de edicin de un marcador, pulsa "Vaciar" para eliminarlo.</li>
                    <li><strong>Resetear:</strong> En la ventana de edicin, pulsa "Resetear" para volver a los valores originales (si los tena).</li>
                 </ul>
            </div>
            <div class="mb-4 p-3 bg-cyan-100 border border-cyan-300 rounded">
                <h3 class="font-semibold text-lg mb-2">2. Asignar Botones Ocultacin (Botn Personalizar Cian)</h3>
                <ul class="list-disc pl-5 space-y-1 text-sm">
                    <li><strong>Activar:</strong> Elige "Asignar Botones Ocultacin" en el men inicial. El botn <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> se pondr cian.</li>
                    <li><strong>Seleccionar Botn Lateral:</strong> Haz clic en el botn lateral (PdR,s, iAs, etc.) cuyos marcadores quieres definir. Se resaltar.</li>
                    <li><strong>Asignar/Desasignar Marcadores:</strong> Haz clic en cualquier marcador de la rejilla. Si estaba asignado, se desasignar (atenuado). Si no lo estaba, se asignar (resaltado). <strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                    <li><strong>Cambiar Botn Lateral:</strong> Haz clic en otro botn lateral para asignar sus marcadores.</li>
                    <li><strong>Guardar:</strong> Los cambios se guardan automticamente al salir de este modo (pulsando el botn <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> cian).</li>
                    <li><strong>Visibilidad por defecto:</strong> Marcadores no asignados a <i>ningn</i> botn lateral siempre sern visibles (salvo que el botn general <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4191.jpg" alt="OFF" style="width:20px; height:11px; display:inline; vertical-align:middle;"> est desactivado).</li>
                </ul>
            </div>
            <div class="mb-4 p-3 bg-green-100 border border-green-300 rounded">
            <h3 class="font-semibold text-lg mb-2">3. Asignar Palabra Clave Filtro (Icono Llave Verde)</h3>
            <ul class="list-disc pl-5 space-y-1 text-sm">
                <li><strong>Activar:</strong> Pulsa el icono de la llave <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4314.PNG" alt="Key" style="width:16px; height:16px; display:inline; vertical-align:middle;"> junto al campo de filtro. El icono se pondr verde. Si vuelves a pulsar, se desactivar.</li>
                <li><strong>Escribe la Palabra:</strong> Escribe la palabra que quieres aadir al nombre de los botones en el campo de filtro. Se eliminarn los espacios automticamente.</li>
                <li><strong>Asignar:</strong> Haz clic en el botn del grid al que quieres aadir la palabra clave. La palabra (en corchetes) se aadir a su nombre (si no existe ya).</li>
                <li><strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                <li><strong>Guardar:</strong> Los cambios se guardan automticamente cada vez que asignas una palabra clave a un botn.</li>
                <li><strong>Mostrar Todo:</strong> Al activar este modo, se limpiar el filtro y se mostrarn todos los botones para facilitar la asignacin.</li>
            </ul>
            </div>
            <p class="mb-4"><strong>Salir de Personalizacin:</strong> Pulsa el botn activo <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (amarillo o cian) o el icono de la llave <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4314.PNG" alt="Key" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (verde) para desactivar el modo actual y volver al uso normal.</p>
        `;
        document.body.appendChild(modal);
        const closeEditInfoButton = modal.querySelector('#close-edit-info');
        const closeHandler = () => { clearModalAutoCloseTimer(modal, closeEditInfoButton, 'edit-info-modal'); if (modal.parentNode) modal.parentNode.removeChild(modal); };
        closeEditInfoButton.addEventListener('click', closeHandler); addModalAutoCloseTimer(modal, closeEditInfoButton, 'edit-info-modal');
    }
    
    // ===================================================================
    // NOMBRE: showEditModal
    // RESUMEN: Muestra el modal para editar los detalles de un marcador o de un botn de seccin.
    function showEditModal(targetIndexOrStart, isToggle = false) { if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); } const existingModal = document.querySelector('.edit-modal'); if (existingModal) existingModal.remove(); const modal = document.createElement('div'); modal.className = 'edit-modal'; if (isToggle) { editingTargetElement = toggleButtonElements[targetIndexOrStart]; } else { editingTargetElement = cellElements[targetIndexOrStart]; } if (editingTargetElement) { editingTargetElement.classList.add('editing-target'); } else { } let currentItemData = {}; let originalItemData = {}; let title = ''; let isNewBookmark = false; const targetIndex = isToggle ? -1 : targetIndexOrStart; if (isToggle) { const targetStart = targetIndexOrStart; const currentRange = currentToggleRanges.find(r => r.start === targetStart); const originalRange = originalToggleRanges.find(r => r.start === targetStart); const currentLabel = customData.toggles[targetStart]?.label ?? currentRange?.label ?? ''; currentItemData = { label: currentLabel }; originalItemData = { label: originalRange?.label || '' }; title = `Editar Etiqueta Seccin`;
        modal.innerHTML = `
            <h2>${title}</h2>
            <div class="modal-top-buttons" style="margin-bottom: 1.2rem;">
                <button class="save">Guardar</button>
                <button class="reset">Resetear</button>
                <button class="cancel">Cancelar</button>
            </div>
            <div><label for="edit-label">Etiqueta (mx 7):</label><input type="text" id="edit-label" value="${currentItemData.label}" maxlength="7"></div>
        `;
    } else { const currentBookmark = currentBookmarks[targetIndex]; const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null; currentItemData = currentBookmark ? { ...currentBookmark } : { name: '', url: '', favicon: '' }; originalItemData = originalBookmark ? { ...originalBookmark } : { name: '', url: '', favicon: '' }; isNewBookmark = !currentBookmark; title = currentBookmark ? `Editar Marcador: ${currentItemData?.name || `ndice ${targetIndex}`}` : `Aadir Marcador (Posicin ${targetIndex + 1})`;
        modal.innerHTML = `
            <h2>${title}</h2>
            <div class="modal-top-buttons" style="margin-bottom: 1.2rem;">
                <button class="save">Guardar</button>
                <button class="reset">Resetear</button>
                <button class="empty">Vaciar</button>
                <button class="cancel">Cancelar</button>
            </div>
            <div><label for="edit-name">Nombre:</label><input type="text" id="edit-name" value="${currentItemData.name || ''}"></div>
            <div><label for="edit-url">URL:</label><div class="input-with-button"><input type="url" id="edit-url" value="${currentItemData.url || ''}" placeholder="https://ejemplo.com"><button class="search-button" id="search-url-button" title="Buscar URL en Google (basado en URL/Nombre)"></button></div></div>
            <div><label for="edit-favicon">URL Favicon (Opcional):</label><div class="input-with-button"><input type="text" id="edit-favicon" value="${currentItemData.favicon || ''}" placeholder="Dejar vaco para auto"><button class="search-button" id="search-favicon-button" title="Buscar Favicon en Google Images (basado en Favicon/Nombre)"></button></div></div>
        `;
    } document.body.appendChild(modal); const cleanupEditModal = () => { if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; } if (modal.parentNode) modal.parentNode.removeChild(modal); }; modal.querySelector('.save').addEventListener('click', () => { let dataChanged = false; if (isToggle) { const targetStart = targetIndexOrStart; const newLabel = modal.querySelector('#edit-label').value.trim(); if (!newLabel) { showToast("La etiqueta no puede estar vaca.", "warning"); return; } if (newLabel.length > 7) { showToast("La etiqueta no puede exceder 7 caracteres.", "warning"); return; } const originalLabel = originalToggleRanges.find(r => r.start === targetStart)?.label || ''; if (newLabel !== originalLabel) { if (!customData.toggles[targetStart]) customData.toggles[targetStart] = {}; customData.toggles[targetStart].label = newLabel; dataChanged = true; } else { if (customData.toggles[targetStart] && customData.toggles[targetStart].hasOwnProperty('label')) { delete customData.toggles[targetStart].label; if (Object.keys(customData.toggles[targetStart]).length === 0) delete customData.toggles[targetStart]; dataChanged = true; } } const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetStart); if (rangeIdx > -1) currentToggleRanges[rangeIdx].label = newLabel; } else { const nameInput = modal.querySelector('#edit-name'); const urlInput = modal.querySelector('#edit-url'); const faviconInput = modal.querySelector('#edit-favicon');
                const newName = nameInput.value.trim();
                const newUrl = urlInput.value.trim();
                const newFavicon = faviconInput.value.trim() || null;
                const isEmpty = !newName && !newUrl && !newFavicon;
                const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                if (isEmpty) {
                    if (originalBookmark !== null && originalBookmark !== undefined) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = null;
                        dataChanged = true;
                    } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = null;
                } else {
                    if (!newName || !newUrl) {
                        showToast("Nombre y URL son obligatorios.", "warning");
                        return;
                    }
                    try { new URL(newUrl); } catch (_) {
                        showToast("URL invlida.", "warning");
                        return;
                    }
                    const bookmarkUpdate = { name: newName, url: newUrl, favicon: newFavicon };
                    const originalData = originalBookmark ? { name: originalBookmark.name, url: originalBookmark.url, favicon: originalBookmark.favicon || null } : null;
                    const bookmarksAreEqual = (b1, b2) => { if (b1 === null && b2 === null) return true; if (b1 === null || b2 === null) return false; return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null); };
                    if (!bookmarksAreEqual(bookmarkUpdate, originalData)) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = bookmarkUpdate;
                        dataChanged = true;
                   } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = bookmarkUpdate;
                }
            }
            if (dataChanged) {
                saveCustomData();
                showToast("Cambios guardados", "success");
            } else {
          }
            updateGridItemUI(targetIndexOrStart, isToggle);
            cleanupEditModal();
        });
        modal.querySelector('.reset').addEventListener('click', () => {
            let dataChanged = false;
            if (isToggle) {
                const targetStart = targetIndexOrStart;
                const originalRange = originalToggleRanges.find(r => r.start === targetStart);
                const originalLabel = originalRange?.label || '';
                modal.querySelector('#edit-label').value = originalLabel;
                if (customData.toggles && customData.toggles[targetStart] && customData.toggles[targetStart].hasOwnProperty('label')) {
                    delete customData.toggles[targetStart].label;
                    if (Object.keys(customData.toggles[targetStart]).length === 0) delete customData.toggles[targetStart];
                    dataChanged = true;
                }
                const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetStart);
                if (rangeIdx > -1) currentToggleRanges[rangeIdx].label = originalLabel;
            } else {
                const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                modal.querySelector('#edit-name').value = originalBookmark?.name || '';
                modal.querySelector('#edit-url').value = originalBookmark?.url || '';
                modal.querySelector('#edit-favicon').value = originalBookmark?.favicon || '';
                if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                    delete customData.bookmarks[targetIndex];
                    dataChanged = true;
                }
                currentBookmarks[targetIndex] = originalBookmark ? { ...originalBookmark } : null;
            }
            if (dataChanged) {
                saveCustomData();
                showToast("Valores reseteados al original y guardados", "info");
            } else {
                showToast("Ya estaba con los valores originales", "info");
            }
            updateGridItemUI(targetIndexOrStart, isToggle);
            cleanupEditModal();
        });
        modal.querySelector('.cancel').addEventListener('click', cleanupEditModal);
        if (!isToggle) {
            const emptyBtn = modal.querySelector('.empty');
            if (emptyBtn) {
                emptyBtn.addEventListener('click', () => {
                    modal.querySelector('#edit-name').value = '';
                    modal.querySelector('#edit-url').value = '';
                    modal.querySelector('#edit-favicon').value = '';
                    const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                    let dataChanged = false;
                    if (originalBookmark !== null && originalBookmark !== undefined) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = null;
                        dataChanged = true;
                    } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = null;
                    if(dataChanged) {
                        saveCustomData();
                        showToast("Marcador vaciado y guardado.", "success");
                    } else {
                        oast("Marcador ya estaba vaco.", "info");
                    }
                    updateGridItemUI(targetIndex, false);
                    cleanupEditModal();
                });
            }
            const searchUrlBtn = modal.querySelector('#search-url-button');
            const searchFaviconBtn = modal.querySelector('#search-favicon-button');
            const nameInput = modal.querySelector('#edit-name');
            const urlInputSearch = modal.querySelector('#edit-url');
            const faviconInputSearch = modal.querySelector('#edit-favicon');
            if (searchUrlBtn) {
                searchUrlBtn.addEventListener('click', () => {
                    const urlValue = urlInputSearch.value.trim();
                    const nameValue = nameInput.value.trim();
                    const query = urlValue || nameValue;
                    if (query) { window.open(`https://www.google.com/search?q=${encodeURIComponent(query)}`, '_blank'); }
                    else { showToast("Escribe un Nombre o URL para buscar.", "warning"); }
                });
            }
            if (searchFaviconBtn) {
                searchFaviconBtn.addEventListener('click', () => {
                    const faviconValue = faviconInputSearch.value.trim();
                    const nameValue = nameInput.value.trim();
                    const query = faviconValue || nameValue;
                    if (query) { window.open(`https://www.google.com/search?tbm=isch&q=${encodeURIComponent(`"${query}" favicon logo icon`)}`, '_blank'); }
                    else { showToast("Escribe un Nombre o URL de Favicon para buscar.", "warning"); }
                });
            }
        }
    }
       
    
    // ===================================================================
    // NOMBRE: updateGridItemUI
    // RESUMEN: Redibuja el grid y los botones para reflejar los cambios realizados en la edicin.
    function updateGridItemUI(indexOrStart, isToggle = false) {
        renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles();adjustButtonPositions();
        if (isAssignmentMode) {
            updateGridAssignmentVisuals();
            if (currentlyAssigningToggleStart !== null && toggleButtonElements[currentlyAssigningToggleStart]) {
                toggleButtonElements[currentlyAssigningToggleStart].classList.add('assigning-selected');
                toggleButtonElements[currentlyAssigningToggleStart].style.opacity = '';
            }
        } else if (isKeywordAssignmentMode) { applyInitialKeywordHighlights(); }
    }  
    
    
    // ===================================================================
    // NOMBRE: performInsertAndSave
    // RESUMEN: Realiza la lgica de mover un marcador en el grid y guarda los cambios.
    function performInsertAndSave(sourceIndex, targetIndex) { if (sourceIndex === targetIndex || sourceIndex === null || targetIndex === null) { return false; } const draggedData = currentBookmarks.splice(sourceIndex, 1)[0]; currentBookmarks.splice(targetIndex, 0, draggedData); if (!customData.bookmarks) customData.bookmarks = {}; if (!customData.toggles) customData.toggles = {}; const minIdx = Math.min(sourceIndex, targetIndex); const maxIdx = Math.max(sourceIndex, targetIndex); currentToggleRanges.forEach(range => { if (range.assignedIndexes) {
        range.assignedIndexes = range.assignedIndexes.map(idx => { if (idx === sourceIndex) return targetIndex; else if (idx > sourceIndex && idx <= targetIndex) return idx - 1; else if (idx < sourceIndex && idx >= targetIndex) return idx + 1; else return idx; }).sort((a, b) => a - b); const startKey = range.start.toString(); if (customData.toggles[startKey] && customData.toggles[startKey].hasOwnProperty('assignedIndexes')) { customData.toggles[startKey].assignedIndexes = [...range.assignedIndexes]; } } }); for (let i = minIdx; i <= maxIdx; i++) { const currentItem = currentBookmarks[i]; const originalItem = i < originalBookmarks.length ? originalBookmarks[i] : null; const bookmarksAreEqual = (b1, b2) => { if (b1 === null && b2 === null) return true; if (b1 === null || b2 === null) return false; return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null); }; if (!bookmarksAreEqual(currentItem, originalItem)) { customData.bookmarks[i] = currentItem ? { ...currentItem } : null; } else if (customData.bookmarks.hasOwnProperty(i)) { delete customData.bookmarks[i]; } } saveCustomData(); renderGrid(); loadSavedSettings(); updateButtonStyles(); showToast(`Movido de ${sourceIndex + 1} a ${targetIndex + 1}`, "success", 1500); return true; }
    
    // ===================================================================
    // NOMBRE: handleDragStart
    // RESUMEN: Maneja el inicio del arrastre de un elemento del grid.
    function handleDragStart(e) { if (!isEditMode) return; draggedItem = e.currentTarget; draggedItemIndex = parseInt(draggedItem.dataset.index); e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', draggedItemIndex); setTimeout(() => { if (draggedItem) draggedItem.classList.add('dragging'); }, 0); }
    
    
    // ===================================================================
    // NOMBRE: handleDragOver
    // RESUMEN: Maneja el evento cuando un elemento arrastrado pasa sobre otro.
    function handleDragOver(e) { if (!isEditMode || !draggedItem) return; e.preventDefault(); e.dataTransfer.dropEffect = 'move'; const targetCell = e.target.closest('.grid-cell'); const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetCell && targetIndex !== dragOverIndex) { if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } if (targetIndex !== draggedItemIndex) { targetCell.classList.add('drag-over'); dragOverIndex = targetIndex; } else { dragOverIndex = null; } } else if (!targetCell && dragOverIndex !== null) { if (cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } dragOverIndex = null; } }
    
    // ===================================================================
    // NOMBRE: handleDragLeave
    // RESUMEN: Maneja el evento cuando un elemento arrastrado sale de una celda destino.
    function handleDragLeave(e) { if (!isEditMode || !draggedItem) return; const targetCell = e.target.closest('.grid-cell'); if (targetCell && !targetCell.contains(e.relatedTarget)) { if (parseInt(targetCell.dataset.index) === dragOverIndex) { targetCell.classList.remove('drag-over'); dragOverIndex = null; } } }
    
    // ===================================================================
    // NOMBRE: handleDrop
    // RESUMEN: Maneja el evento de soltar un elemento arrastrado.
    function handleDrop(e) { if (!isEditMode || !draggedItem) return; e.preventDefault(); const targetCell = e.target.closest('.grid-cell'); const sourceIndex = draggedItemIndex; const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetIndex !== null && sourceIndex !== targetIndex) { performInsertAndSave(sourceIndex, targetIndex); } else { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } } handleDragEndCleanup(); }
    
    // ===================================================================
    // NOMBRE: handleDragEndCleanup
    // RESUMEN: Limpia las variables y estilos de la operacin de arrastre.
    function handleDragEndCleanup() { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } draggedItem = null; draggedItemIndex = null; dragOverIndex = null; }
    
    // ===================================================================
    // NOMBRE: handleTouchStart
    // RESUMEN: Maneja el inicio de un toque para el arrastre en dispositivos tctiles.
    function handleTouchStart(e) { if (!isEditMode || e.touches.length !== 1) return; draggedItem = e.currentTarget; draggedItemIndex = parseInt(draggedItem.dataset.index); const touch = e.touches[0]; touchStartX = touch.clientX; touchStartY = touch.clientY; draggedItem.classList.add('dragging'); currentTouchTarget = draggedItem; }
    
    // ===================================================================
    // NOMBRE: handleTouchMove
    // RESUMEN: Maneja el movimiento del dedo durante el arrastre tctil.
    function handleTouchMove(e) { if (!isEditMode || !draggedItem || e.touches.length !== 1) return; e.preventDefault(); const touch = e.touches[0]; const elementOver = document.elementFromPoint(touch.clientX, touch.clientY); const targetCell = elementOver?.closest('.grid-cell'); const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetCell && targetIndex !== dragOverIndex) { if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } if (targetIndex !== draggedItemIndex) { targetCell.classList.add('drag-over'); dragOverIndex = targetIndex; currentTouchTarget = targetCell; } else { dragOverIndex = null; currentTouchTarget = draggedItem; } } else if (!targetCell && dragOverIndex !== null) { if (cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } dragOverIndex = null; currentTouchTarget = null; } }   
      
    // ===================================================================
    // NOMBRE: handleTouchEnd
    // RESUMEN: Maneja la finalizacin de un arrastre tctil.
    function handleTouchEnd(e) { if (!isEditMode || !draggedItem) return; if (dragOverIndex !== null && dragOverIndex !== draggedItemIndex) { performInsertAndSave(draggedItemIndex, dragOverIndex); e.preventDefault(); } else { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } } handleTouchEndCleanup(); }   
    
    // ===================================================================
    // NOMBRE: handleTouchEndCleanup
    // RESUMEN: Limpia las variables y estilos de la operacin de arrastre tctil.
    function handleTouchEndCleanup() { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } draggedItem = null; draggedItemIndex = null; dragOverIndex = null; currentTouchTarget = null; touchStartX = 0; touchStartY = 0; }
    
    // ===================================================================
    // NOMBRE: normalizeText
    // RESUMEN: Normaliza un texto (minsculas, sin acentos) para facilitar comparaciones.
    function normalizeText(text) { if (!text) return ''; return text.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, ''); }
    
    // ===================================================================
    // NOMBRE: filterGridItems
    // RESUMEN: Filtra los elementos del grid segn el texto del filtro y los toggles de seccin.
    function filterGridItems() {
        const filterInput = document.getElementById('grid-filter-input');
        const clearButton = document.getElementById('clear-filter-button');
        if (!filterInput || !clearButton || !cellElements || cellElements.length === 0) { return; }
        if (isKeywordAssignmentMode) {
            cellElements.forEach(cellContainer => { cellContainer.classList.remove('hidden'); });
            clearButton.style.display = filterInput.value.trim() ? 'inline-block' : 'none';
            return;
        }
        const rawFilterText = filterInput.value.trim();
        clearButton.style.display = rawFilterText ? 'inline-block' : 'none';
        const filterWords = rawFilterText.split(/\s+/).filter(word => word.length > 0).map(word => normalizeText(word));
        const onOffToggleElem = document.getElementById('on-off-toggle');
        const masterState = onOffToggleElem ? (onOffToggleElem.dataset.state || 'on') : 'on';
        cellElements.forEach((cellContainer, index) => {
            const isMasterOff = masterState === 'off';
            if (isMasterOff) {
                cellContainer.classList.add('hidden');
                return;
            }
            const bookmark = currentBookmarks[index];
            const bookmarkName = bookmark ? normalizeText(bookmark.name) : '';
            const isEmptySlot = !bookmark;
            let matchesFilter = true;
            if (filterWords.length > 0) {
                if (isEmptySlot) {
                    matchesFilter = false;
                } else {
                    matchesFilter = filterWords.every(word => bookmarkName.includes(word));
                }
            }
            const shouldBeHiddenByFilter = filterWords.length > 0 && !matchesFilter;
            let shouldBeHiddenByToggles = false;
            const containingRange = getSectionForIndex(index);
            if (containingRange) {
                const toggleButton = toggleButtonElements[containingRange.start] || document.querySelector(`.range-toggle[data-range-start="${containingRange.start}"]`);
                if (toggleButton) {
                    const toggleState = toggleButton.dataset.state || 'visible';
                    shouldBeHiddenByToggles = toggleState === 'hidden';
                }
            } else {
                shouldBeHiddenByToggles = false;
            }
            const shouldBeHidden = shouldBeHiddenByToggles || shouldBeHiddenByFilter;
            cellContainer.classList.toggle('hidden', shouldBeHidden);
        });
    }
    
    // ===================================================================
    // NOMBRE: promptForPin
    // RESUMEN: Muestra el modal para introducir el PIN de acceso.
    function promptForPin() { const pinModal = document.getElementById('pin-modal-overlay'); const pinInput = document.getElementById('pin-input'); const pinSubmit = document.getElementById('pin-submit-button'); const pinError = document.getElementById('pin-error-message'); pinModal.classList.remove('hidden');
        pinInput.value = ''; pinError.textContent = ''; pinInput.focus(); const newPinSubmit = pinSubmit.cloneNode(true); pinSubmit.parentNode.replaceChild(newPinSubmit, pinSubmit); newPinSubmit.addEventListener('click', checkPin); pinInput.addEventListener('keyup', (event) => { if (event.key === 'Enter') { checkPin(); } }); }
    
    
    // ===================================================================
    // NOMBRE: checkPin
    // RESUMEN: Verifica el PIN introducido por el usuario.
    function checkPin() { const pinModal = document.getElementById('pin-modal-overlay'); const pinInput = document.getElementById('pin-input'); const pinError = document.getElementById('pin-error-message'); const enteredPin = pinInput.value; if (enteredPin === storedPin) { pinModal.classList.add('hidden'); initializeApp(); } else { pinError.textContent = 'Clave incorrecta.'; pinInput.value = ''; pinInput.focus(); if (navigator.vibrate) navigator.vibrate(100); } }
    
    // ===================================================================
    // NOMBRE: handlePasswordToggleClick
    // RESUMEN: Activa o desactiva la solicitud de PIN al inicio.
    function handlePasswordToggleClick() { if (!storedPin) { showToast('Primero establece una clave en Configuracin -> Usuario.', 'warning'); return; } isPasswordActive = !isPasswordActive; updatePasswordToggleIcon(); saveSettings(); showToast(`Solicitar clave al inicio: ${isPasswordActive ? 'Activado' : 'Desactivado'}`, 'info'); }
    
    
    // ===================================================================
    // NOMBRE: updatePasswordToggleIcon
    // RESUMEN: Actualiza el icono del candado segn si el PIN est activo o no.
    function updatePasswordToggleIcon() { const passwordButton = document.getElementById('password-toggle-button'); if (passwordButton) { const img = passwordButton.querySelector('img'); if(img) { const iconPath = isPasswordActive ? 'PNG/IMG_4281.png' : 'PNG/IMG_4280.png'; img.src = `https://boardinggate.github.io/Tesla/${iconPath}`;
        img.alt = isPasswordActive ? 'Clave Activada' : 'Clave Desactivada'; passwordButton.title = `Clave al inicio: ${isPasswordActive ? 'Activada' : 'Desactivada'}`; } } }
    
    // ===================================================================
    // NOMBRE: savePinSettings
    // RESUMEN: Guarda las nuevas configuraciones de PIN y preferencias de inicio.
    function savePinSettings() {
        const pinSetInput = document.getElementById('config-pin-set');
        const pinConfirmInput = document.getElementById('config-pin-confirm');
        const pinStatus = document.getElementById('config-pin-status');
        const directToNavCheckbox = document.getElementById('config-direct-to-nav');
        const newPin = pinSetInput.value;
        const confirmPin = pinConfirmInput.value;
        pinStatus.textContent = '';
        let keySaved = false;
        let prefSaved = false;
        if (newPin || confirmPin) {
            if (!/^\d{4}$/.test(newPin)) {
                pinStatus.textContent = 'La clave debe tener exactamente 4 cifras.';
                pinStatus.style.color = '#EF4444';
                return;
            }
            if (newPin !== confirmPin) {
                pinStatus.textContent = 'Las claves no coinciden.';
                pinStatus.style.color = '#EF4444';
                return;
            }
            try {
                localStorage.setItem('password_pin', newPin);
                storedPin = newPin;
                if (!localStorage.getItem('password_active') || isPasswordActive) {
                    isPasswordActive = true;
                    localStorage.setItem('password_active', 'true');
                }
                pinStatus.textContent = 'Clave guardada. ';
                pinStatus.style.color = '#28a745';
                pinSetInput.value = '';
                pinConfirmInput.value = '';
                updatePasswordToggleIcon();
                keySaved = true;
            } catch (e) {
                pinStatus.textContent ='Error al guardar la clave.';
                pinStatus.style.color = '#EF4444';
                showToast('Error al guardar la clave.', 'error');
            }
        }
        const directToNavChecked = directToNavCheckbox.checked;
        localStorage.setItem(DIRECT_TO_NAVIGATION_KEY, JSON.stringify(directToNavChecked));
        prefSaved = true;
        if (keySaved && prefSaved) {
            showToast('Clave y preferencia de inicio guardadas.', 'success');
            pinStatus.textContent += (pinStatus.textContent ? "Y " : "") + "Preferencia de inicio guardada.";
             pinStatus.style.color = '#28a745';
        } else if (keySaved) {
            showToast('Clave guardada. Preferencia de inicio tambin actualizada.', 'success');
             pinStatus.textContent += (pinStatus.textContent ? " " : "") + "Preferencia de inicio guardada.";
             pinStatus.style.color = '#28a745';
        } else if (prefSaved) {
            showToast('Preferencia de inicio guardada.', 'success');
            pinStatus.textContent = "Preferencia de inicio guardada.";
            pinStatus.style.color = '#28a745';
        } else if (!newPin && !confirmPin) {
             pinStatus.textContent = "No se realizaron cambios en la clave. Preferencia de inicio no cambi.";
             pinStatus.style.color = '#17a2b8';
        }
        saveSettings();
    }
    
    // ===================================================================
    // NOMBRE: removePinSettings
    // RESUMEN: Elimina la configuracin de PIN de acceso.
    function removePinSettings() { const pinStatus = document.getElementById('config-pin-status'); if (confirm('Ests seguro de que deseas eliminar la clave de acceso? Ya no se solicitar al inicio.')) { try { localStorage.removeItem('password_pin'); localStorage.setItem('password_active', 'false'); storedPin = null; isPasswordActive = false; pinStatus.textContent = 'Clave eliminada.'; pinStatus.style.color = '#17a2b8'; document.getElementById('config-pin-set').value = ''; document.getElementById('config-pin-confirm').value = ''; updatePasswordToggleIcon(); saveSettings(); showToast('Clave eliminada.', 'info'); } catch (e) { pinStatus.textContent = 'Error al eliminar la clave.'; pinStatus.style.color = '#EF4444'; showToast('Error al eliminar la clave.', 'error'); } } }
    
    // ===================================================================
    // NOMBRE: getRemoteUpdatesDate
    // RESUMEN: Obtiene la fecha de la ltima actualizacin de un archivo remoto.
    async function getRemoteUpdatesDate() { try { const response = await fetch('https://boardinggate.github.io/Tesla/updates.txt', { cache: 'no-cache' }); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const text = await response.text(); const firstLine = text.split('\n')[0].trim(); const dateMatch = firstLine.match(/^\d{4}-\d{2}-\d{2}/); if (dateMatch) { const [year, month, day] = dateMatch[0].split('-').map(Number); const remoteDate = new Date(Date.UTC(year, month - 1, day)); if (!isNaN(remoteDate.getTime())) { return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`; } } return null; } catch (e) { return null; } }
    
    
    // ===================================================================
    // NOMBRE: isRemoteDateNewer
    // RESUMEN: Compara si una fecha remota es ms reciente que una fecha en cach.
    function isRemoteDateNewer(remoteDateStr, cachedDateStr) { if (!remoteDateStr) return false; if (!cachedDateStr) return true; try { return remoteDateStr > cachedDateStr; } catch (e) { return false; } }
    
    // ===================================================================
    // NOMBRE: checkVersionsIconOpacity
    // RESUMEN: Ajusta la opacidad del icono de versiones si hay actualizaciones nuevas.
    async function checkVersionsIconOpacity() { const versionsIcon = document.getElementById('versions-button'); const versionsImg = versionsIcon ? versionsIcon.querySelector('img') : null; if (!versionsImg) return;
        let showAsNew = false; const remoteDateStr = await getRemoteUpdatesDate();
        if (remoteDateStr) { showAsNew = isRemoteDateNewer(remoteDateStr, lastUpdatesCheckDate); } versionsImg.style.opacity = showAsNew ? '1.0' : '0.1';
    }
    
    
    // ===================================================================
    // NOMBRE: showVersionsModal
    // RESUMEN: Muestra el modal con el historial de versiones.
    async function showVersionsModal() {
        const versionsModalOverlay = document.getElementById('versions-modal-overlay');
        const versionsContent = document.getElementById('versions-content');
        const closeButton = document.getElementById('close-versions-modal');
        if (!versionsModalOverlay || !versionsContent || !closeButton) return;
        const newCloseButton = closeButton.cloneNode(true);
        closeButton.parentNode.replaceChild(newCloseButton, closeButton);
        const closeHandler = () => {
            versionsModalOverlay.classList.add('hidden');
            clearModalAutoCloseTimer(versionsModalOverlay, newCloseButton, 'versions-modal');
        };
        newCloseButton.addEventListener('click', closeHandler);
        versionsContent.textContent = 'Cargando histrico...';
        versionsModalOverlay.classList.remove('hidden');
        addModalAutoCloseTimer(versionsModalOverlay, newCloseButton, 'versions-modal');
        try {
            const response = await fetch('https://boardinggate.github.io/Tesla/updates.txt', { cache: 'no-cache' });
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const text = await response.text();
            versionsContent.textContent = text;
            const firstLine = text.split('\n')[0].trim();
            const dateMatch = firstLine.match(/^\d{4}-\d{2}-\d{2}/);
            let dateToStore = null;
            if (dateMatch) {
                const [year, month, day] = dateMatch[0].split('-').map(Number);
                const checkDate = new Date(Date.UTC(year, month - 1, day));
                if (!isNaN(checkDate.getTime())) {
                    dateToStore = dateMatch[0];
                }
            }
            if (dateToStore) {
                lastUpdatesCheckDate = dateToStore;
            } else {
                const today = new Date();
                lastUpdatesCheckDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
            }
            saveSettings();
            await checkVersionsIconOpacity();
        } catch (e) {
            versionsContent.textContent = `Error al cargar el histrico:\n${e.message}`;
        }
    }
    
    // ===================================================================
    // NOMBRE: getCurrentLocation
    // RESUMEN: Obtiene la ubicacin actual del dispositivo a travs de la API de Geolocalizacin.
    function getCurrentLocation(callback, errorCallback) {
        if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    callback({
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy,
                        altitude: position.coords.altitude,
                        heading: position.coords.heading,
                        speed: position.coords.speed
                    });
                },
                (error) => {
                    let message = "No se pudo obtener la ubicacin.";
                    switch (error.code) {
                        case error.PERMISSION_DENIED:
                            message = "Permiso de ubicacin denegado.";
                            break;
                        case error.POSITION_UNAVAILABLE:
                            message = "Informacin de ubicacin no disponible.";
                            break;
                        case error.TIMEOUT:
                            message = "Timeout obteniendo ubicacin.";
                            break;
                    }
                    if (errorCallback) errorCallback(message);
                    else showToast(message, "error");
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        } else {
            const message = "Geolocalizacin no soportada por este navegador.";
            if (errorCallback) errorCallback(message);
            else showToast(message, "error");
        }
    }
    
    // ===================================================================
    // NOMBRE: calculateDistance
    // RESUMEN: Calcula la distancia en metros entre dos coordenadas geogrficas.
    function calculateDistance(lat1, lon1, lat2, lon2) {
        if (typeof lat1 !== 'number' || typeof lon1 !== 'number' || typeof lat2 !== 'number' || typeof lon2 !== 'number' || isNaN(lat1) || isNaN(lon1) || isNaN(lat2) || isNaN(lon2)) {
             return Infinity;
        }
        const R = 6371e3; const 1 = lat1 * Math.PI / 180; const 2 = lat2 * Math.PI / 180; const  = (lat2 - lat1) * Math.PI / 180; const  = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin( / 2) * Math.sin( / 2) + Math.cos(1) * Math.cos(2) * Math.sin( / 2) * Math.sin( / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return R * c;
    }
    
    
    
    // ===================================================================
    // NOMBRE: restoreCacheForMobile
    // RESUMEN: Descarga silenciosamente la cach de Firebase al iniciar en mvil.
    async function restoreCacheForMobile() {
        const { primaryId } = parseUserId(localStorage.getItem('userData_userId'));
        if (!primaryId) return;
        const result = await callFirebase('getUserData', { userId: primaryId });
        if (result.status === 'success' && result.data) {
            const backupCacheData = result.data.contenidoCacheCompleto;
            if (backupCacheData) {
                showToast('Sincronizando datos desde la nube...', 'info', 2000);
                const currentUserIdentity = localStorage.getItem('userData_userId');
                for (const key in backupCacheData) {
                    if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                        localStorage.setItem(key, backupCacheData[key]);
                    }
                }
                if (currentUserIdentity) {
                    localStorage.setItem('userData_userId', currentUserIdentity);
                }
                loadCustomData();
                loadSavedSettings();
                updateUserIdDisplay();
                checkReminders();
            }
        }
    }
    
// ===================================================================
// NOMBRE: hideUnifiedReminderWindow
// RESUMEN: Oculta la ventana unificada de recordatorios y limpia sus elementos.
function hideUnifiedReminderWindow() {
    if (realtimeSpeedUpdateInterval) {
        clearInterval(realtimeSpeedUpdateInterval);
        realtimeSpeedUpdateInterval = null;
    }
    const windowElement = document.getElementById('unified-reminder-window');
    if (windowElement && windowElement.classList.contains('visible')) {
        windowElement.classList.remove('visible');
        isUnifiedWindowVisibleByLogic = false;
        const swiperContainer = document.getElementById('reminder-swiper-container');
        Object.values(previewMaps).forEach(map => {
            if (map && typeof map.remove === 'function') {
                map.remove();
            }
        });
        previewMaps = {};
        if (swiperContainer) {
            swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay);
            setTimeout(() => {
                if (swiperContainer && !windowElement.classList.contains('visible')) {
                    swiperContainer.innerHTML = '';
                }
            }, 600);
        }
        const hideAllButton = document.getElementById('hide-all-reminders-button');
        if (hideAllButton) { const newHideAllButton = hideAllButton.cloneNode(true); hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton); }
        const mapShouldReopen = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
        const mapContextToReopen = sessionStorage.getItem('mapContext');
        sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
        if (mapShouldReopen &&
            !document.querySelector('.reminder-modal') &&
            !document.querySelector('.reminder-table-modal') &&
            !document.getElementById('reminders-location-map-modal')
           ) {
             if (mapContextToReopen === 'navigation') openNavigationMap();
              sessionStorage.removeItem('mapContext');
        }
    }
}
    
// ===================================================================
// NOMBRE: postponeAllVisibleReminders
// RESUMEN: Pospone todos los recordatorios actualmente visibles en la ventana unificada.
function postponeAllVisibleReminders() {
    const swiperContainer = document.getElementById('reminder-swiper-container'); if (!swiperContainer) return;
    const visibleSlides = swiperContainer.querySelectorAll('.reminder-slide'); if (visibleSlides.length === 0) return;
    let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    let updated = false;
    const idsToUpdate = [];
    visibleSlides.forEach(slide => {
        const reminderId = parseInt(slide.dataset.id);
        if (isNaN(reminderId)) return;
        idsToUpdate.push(reminderId);
        const index = reminders.findIndex(r => r.id === reminderId);
        if (index !== -1) {
            const { newDateISO, newTime } = calculatePostponedDateTime(1);
            reminders[index].date = newDateISO;
            reminders[index].time = newTime;
            reminders[index].managedByUser = false;
            updated = true;
        }
    });
    if (updated) {
        localStorage.setItem('reminders', JSON.stringify(reminders));
        
        // >>> CORRECCIN CLAVE AADIDA AQU! <<<
        // Marcamos la cach como sucia para que checkReminders la reconstruya.
        markRemindersCacheAsDirty();

        showToast(`${idsToUpdate.length} recordatorio(s) pospuesto(s) 1 minuto`, 'info');
        idsToUpdate.forEach(id => updateUnifiedWindowUI(id)); // Esto es para la UI, no afecta la lgica.
        updateReminderCount();
        updateButtonStyles();
    }
    if (idsToUpdate.length > 0 && document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
       hideUnifiedReminderWindow();
    }
}

    
    // ===================================================================
    // NOMBRE: updateReminderIndexDisplay
    // RESUMEN: Actualiza el contador de ndice del slide actual en la ventana unificada.
    function updateReminderIndexDisplay() {
        const swiperContainer = document.getElementById('reminder-swiper-container');
        const currentIndexSpan = document.getElementById('current-reminder-index');
        if (!swiperContainer || !currentIndexSpan) return;
        const totalSlides = swiperContainer.querySelectorAll('.reminder-slide').length;
        if (totalSlides === 0) {
            currentIndexSpan.textContent = '0';
            return;
        }
        const containerWidth = swiperContainer.offsetWidth;
        if (containerWidth <= 0) {
           return;
        }
        const currentScroll = swiperContainer.scrollLeft;
        const currentIndex = Math.round(currentScroll / containerWidth);
        currentNotificationSlideIndex = currentIndex;
        const displayIndex = Math.max(1, Math.min(currentIndex + 1, totalSlides));
        currentIndexSpan.textContent = displayIndex;
         const currentSlideElement = swiperContainer.querySelectorAll('.reminder-slide')[currentIndex];
         if (currentSlideElement && !isNavigationMapActive) {
            const mapId = currentSlideElement.querySelector('.reminder-map-preview')?.id;
            if (mapId) {
                 const reminderId = parseInt(mapId.replace('map-preview-', ''));
                 if (previewMaps[reminderId]) {
                     setTimeout(() => { if(previewMaps[reminderId]) previewMaps[reminderId].resize(); }, 50);
                 }
            }
         }
    }
    
    // ===================================================================
    // NOMBRE: updateUnifiedWindowUI
    // RESUMEN: Actualiza la UI de la ventana unificada despus de que un recordatorio es gestionado.
    function updateUnifiedWindowUI(processedReminderId) {
        const windowElement = document.getElementById('unified-reminder-window');
        const swiperContainer = document.getElementById('reminder-swiper-container');
        const slideToRemove = swiperContainer ? swiperContainer.querySelector(`.reminder-slide[data-id="${processedReminderId}"]`) : null;
        if (previewMaps[processedReminderId]) {
           if (typeof previewMaps[processedReminderId].remove === 'function') {
               previewMaps[processedReminderId].remove();
           }
           delete previewMaps[processedReminderId];
        }
        if (slideToRemove && slideToRemove.parentNode === swiperContainer) {
            swiperContainer.removeChild(slideToRemove);
        }
        const remainingSlides = swiperContainer ? swiperContainer.querySelectorAll('.reminder-slide') : [];
        const remainingCount = remainingSlides.length;
        if (remainingCount === 0) {
            hideUnifiedReminderWindow();
        }
        else {
            const countHeader = windowElement.querySelector('.reminder-count-header');
            const countSpan = document.getElementById('total-reminder-count');
            const countTextContainer = document.getElementById('reminder-count-text-container');
            const swipeHint = document.getElementById('reminder-swipe-hint');
            countSpan.textContent = remainingCount;
            updateReminderIndexDisplay();
            if (remainingCount > 1) {
                countTextContainer.style.display = 'inline';
                swipeHint.style.display = 'block';
                document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = 'calc(85vh - 60px)');
            } else {
                countTextContainer.style.display = 'none';
                swipeHint.style.display = 'none';
                document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = '85vh');
            }
            const maxScrollIndex = remainingCount - 1;
            if (currentNotificationSlideIndex > maxScrollIndex) {
                 currentNotificationSlideIndex = maxScrollIndex;
                 swiperContainer.scrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
                 updateReminderIndexDisplay();
            }
        }
        updateReminderCount();
        updateButtonStyles();
    }
    
    
    // ===================================================================
    // NOMBRE: updateReminderCount
    // RESUMEN: Actualiza los contadores de recordatorios en la UI.
    function updateReminderCount() {
         let reminders = []; try { reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); } catch (e) { reminders = []; }
         const showExcludedInTable = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false; let remindersForCount = reminders;
         if (!showExcludedInTable) { remindersForCount = reminders.filter(r => !r.excludeFromList); }
         const totalCount = remindersForCount.length; const nonCyclicReminders = remindersForCount.filter(r => r.type !== 'weekly' && r.type !== 'interval'); const nonCyclicCount = nonCyclicReminders.length;
         const countElGlobe = document.getElementById('reminder-count-globe'); if (countElGlobe) { countElGlobe.textContent = nonCyclicCount > 0 ? nonCyclicCount : ''; countElGlobe.style.display = nonCyclicCount > 0 ? 'flex' : 'none'; }
         const reminderButtonElem = document.getElementById('reminder-button'); if (reminderButtonElem) { let countSpanSide = reminderButtonElem.querySelector('.reminder-count'); if (totalCount > 0) { if (!countSpanSide) { countSpanSide = document.createElement('span'); countSpanSide.className = 'reminder-count'; reminderButtonElem.appendChild(countSpanSide); } countSpanSide.textContent = totalCount; } else { if (countSpanSide) { countSpanSide.remove(); } } }
    }
        
 
// ===================================================================
// NOMBRE: formatTimeWithPeriod
// RESUMEN: Formatea una hora (HH:MM) para aadir un perodo del da (Maana, Tarde, etc.).
function formatTimeWithPeriod(timeString) {
     if (!timeString || !timeString.match(/^\d{2}:\d{2}$/)) return '-';
     try {
         const [hourStr, minuteStr] = timeString.split(':');
         const hour = parseInt(hourStr);
         const minute = parseInt(minuteStr);
         if (isNaN(hour) || isNaN(minute) || hour < 0 || hour > 23 || minute < 0 || minute > 59) {
             return timeString;
         }
         let period = '';
         if (hour >= 22 || hour < 5) { period = 'de la Noche'; }
         else if (hour >= 5 && hour < 12) { period = 'de la Maana'; }
         else if (hour >= 12 && hour < 14) { period = 'del Medioda'; }
         else { period = 'de la Tarde'; }
         return `${hourStr}:${minuteStr} (${period})`;
     } catch (e) {
         return timeString;
     }
}

// ===================================================================
// NOMBRE: formatDateDetailed
// RESUMEN: Formatea una fecha (YYYY-MM-DD) a un formato ms legible (DD-Mes-YYYY).
function formatDateDetailed(dateString) {
    if (!dateString || !dateString.match(/^\d{4}-\d{2}-\d{2}$/)) return '-';
    try {
        const [year, month, day] = dateString.split('-').map(Number);
        const date = new Date(Date.UTC(year, month - 1, day));
        if (isNaN(date.getTime())) return dateString;
        const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
        const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
        const monthName = monthNames[date.getUTCMonth()];
        const fullYear = date.getUTCFullYear();
        return `${dayOfMonth}-${monthName}-${fullYear}`;
    } catch (e) {
        return dateString;
    }
}

// ===================================================================
// NOMBRE: extractSpeedFromRadarText (VERSIN ESTRICTA)
// RESUMEN: Extrae un lmite de velocidad vlido (entre 20-130) del texto de un recordatorio.
function extractSpeedFromRadarText(text) {
    if (!text) return null;
    const cleanText = text.replace(/<[^>]*>/g, '').toUpperCase();
    const validSpeeds = [20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130];

    const kmMatch = cleanText.match(/\b(\d{2,3})\s*KM/);
    if (kmMatch && kmMatch[1]) {
        const speed = parseInt(kmMatch[1], 10);
        if (validSpeeds.includes(speed)) return speed;
    }
    
    const codeMatch = cleanText.match(/\b[FCN](\d{2,3})\b/);
    if (codeMatch && codeMatch[1]) {
        const speed = parseInt(codeMatch[1], 10);
        if (validSpeeds.includes(speed)) return speed;
    }
    
    const looseNumbers = cleanText.match(/\b(\d{2,3})\b/g);
    if (looseNumbers) {
        for (const numStr of looseNumbers) {
            const speed = parseInt(numStr, 10);
            if (validSpeeds.includes(speed)) {
                return speed; 
            }
        }
    }

    return null; 
} 
      
// ===================================================================
// NOMBRE: displayUnifiedReminderWindow
// RESUMEN: Muestra y rellena la ventana unificada de recordatorios con los que estn vencidos.
function displayUnifiedReminderWindow(overdueReminders) {
    const windowElement = document.getElementById('unified-reminder-window');
    const swiperContainer = document.getElementById('reminder-swiper-container');
    const countHeader = windowElement.querySelector('.reminder-count-header');
    const countSpan = document.getElementById('total-reminder-count');
    const currentIndexSpan = document.getElementById('current-reminder-index');
    const countTextContainer = document.getElementById('reminder-count-text-container');
    const swipeHint = document.getElementById('reminder-swipe-hint');
    const hideAllButton = document.getElementById('hide-all-reminders-button');
     Object.values(previewMaps).forEach(map => {
       if (map && typeof map.remove === 'function') {
           map.remove();
       }
     });
     previewMaps = {};
    if (realtimeSpeedUpdateInterval) {
        clearInterval(realtimeSpeedUpdateInterval);
        realtimeSpeedUpdateInterval = null;
    }
    if (!windowElement || !swiperContainer || !countHeader || !countSpan || !currentIndexSpan || !countTextContainer || !swipeHint || !hideAllButton) {
        return;
    }
    swiperContainer.innerHTML = '';
    overdueReminders.sort((a, b) => { try { const dateA = new Date(`${a.date}T${a.time}:00Z`); const dateB = new Date(`${b.date}T${b.time}:00Z`); return dateA - dateB; } catch (e) { return 0; } });
    if (!isUnifiedWindowVisibleByLogic) {
        currentNotificationSlideIndex = 0;
    }
    overdueReminders.forEach((reminder, index) => {
        const slide = document.createElement('div');
        slide.className = 'reminder-slide';
        slide.dataset.id = reminder.id;
        slide.setAttribute('role', 'group');
        slide.setAttribute('aria-label', `Recordatorio: ${reminder.text.replace(/<[^>]*>/g, '')}`);
        
        let slideContentHtml = '';
        const isRadarAlert = reminder.text.toUpperCase().includes("RADAR");

        if (isRadarAlert) {
            const radarSpeed = extractSpeedFromRadarText(reminder.text);
            const validSpeeds = [20, 30, 50, 60, 70, 80, 90, 100, 110, 120];
            const isStandardSpeed = radarSpeed !== null && validSpeeds.includes(radarSpeed);

            let speedLimitHtml = '';
            let currentSpeedHtml = '';

            if (isStandardSpeed) {
                speedLimitHtml = `<p class="reminder-text" style="color: red; font-weight: bold; text-transform: uppercase; font-size: 1.8rem; margin-bottom: 0.2rem; text-align: center;">${radarSpeed} Km/h</p>`;
            } else {
                speedLimitHtml = `<p class="reminder-text" style="color: red; font-weight: bold; text-transform: uppercase; font-size: 1.4rem; margin-bottom: 0.2rem; text-align: center;">RADAR DE TRAMO o INDETERMINADO</p>`;
            }

            const carSpeed = Math.round(window.currentSpeedKmh || 0);
            const speedExceeded = isStandardSpeed && carSpeed > radarSpeed;
            
            currentSpeedHtml = `<p id="current-speed-display-${reminder.id}" style="text-align:center; font-size: 1.7rem; font-weight: bold; color: ${speedExceeded ? 'red' : '#333'};">[Velocidad actual: ${carSpeed} Km/h]</p>`;

            slideContentHtml = `
                <div class="reminder-slide-content">
                    <img src="https://boardinggate.github.io/Tesla/PNG/AGUARDIA.png" alt="Icono Radar" class="radar-icon">
                    <div class="reminder-content-scrollable">
                        ${speedLimitHtml}
                        ${currentSpeedHtml}
                        <p class="reminder-text" style="text-align: center; margin-top: 0.5rem; ${isStandardSpeed ? 'font-size: 1rem; color: #444;' : ''}">${reminder.text}</p>
                    </div>
                    <div class="button-group">
                        <button class="route-radar-seen" style="background-color: #2563EB; color: white; font-weight: bold; height: 70px; font-size: 1.2rem;">VISTO (Posponer 5 min)</button>
                        <button class="modify">Modificar</button>
                    </div>
                </div>
            `;
        } else {
            let detailsHtml = '';
            if (reminder.time) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Hora: ${formatTimeWithPeriod(reminder.time)}</p>`;
            if (reminder.date) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Fecha: ${formatDateDetailed(reminder.date)}</p>`;
            if (reminder.type === 'weekly' && reminder.repeatDays?.length > 0) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Repite: ${reminder.repeatDays.map(d => ['Dom', 'Lun', 'Mar', 'Mi', 'Jue', 'Vie', 'Sb'][d]).join(', ')}</p>`;
            if (reminder.type === 'interval' && reminder.intervalDays) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Cada: ${reminder.intervalDays} das</p>`;
            if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Ubicacin: Activada (Radio ${reminder.radiusMeters || DEFAULT_LOCATION_RADIUS}m)</p>`;
            }
            const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval';
            const showAdjustButton = isCyclic && reminder.time !== '00:01';
            const adjustButtonHtml = showAdjustButton ? `<button class="adjust-time-0001">Ajustar Hora 00:01 y Visto</button>` : '';
            const cyclicCancelButtonHtml = isCyclic ? `<button class="cancel-cyclic">Anular Ciclo</button>` : '';
            
            const buttonsHtml = `
                <div class="button-group">
                    <button class="cancel">Visto / Prximo</button>
                    <button class="postpone">Posponer</button>
                    <button class="modify">Modificar</button>
                    ${adjustButtonHtml}
                    ${cyclicCancelButtonHtml}
                </div>`;

            const mapPreviewHtml = (reminder.isLocationEnabled && reminder.locationCoordinates && !isNavigationMapActive) ? `
                <div class="reminder-map-preview-container">
                    <div id="map-preview-${reminder.id}" class="reminder-map-preview"></div>
                </div>
            ` : '';

            slideContentHtml = `
                <div class="reminder-slide-content">
                    <div class="reminder-content-scrollable">
                        <p class="reminder-text">${reminder.text}</p>
                        ${detailsHtml}
                    </div>
                    ${buttonsHtml} 
                </div>
                ${mapPreviewHtml}
            `;
        }
        
        slide.innerHTML = slideContentHtml;

        addSlideButtonListeners(slide, reminder);
        swiperContainer.appendChild(slide);

        if (reminder.isLocationEnabled && reminder.locationCoordinates && !isNavigationMapActive && !isRadarAlert) {
             const mapPreviewElement = slide.querySelector(`#map-preview-${reminder.id}`);
             if (mapPreviewElement) {
                setTimeout(() => {
                    try {
                        if (!document.getElementById(mapPreviewElement.id)) return;
                        if (previewMaps[reminder.id] && typeof previewMaps[reminder.id].remove === 'function') {
                           previewMaps[reminder.id].remove();
                        }
                        const isRadarType = reminder.text.toUpperCase().includes("RADAR") || reminder.excludeFromList;
                        const circleColor = isRadarType ? 'rgba(255, 165, 0, 0.2)' : 'blue';
                        
                        const map = new mapboxgl.Map({
                            container: mapPreviewElement,
                            style: 'mapbox://styles/mapbox/streets-v12',
                            center: [reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude],
                            zoom: 14,
                            interactive: false,
                            attributionControl: false
                        });
                        
                        map.on('load', () => {
                            new mapboxgl.Marker().setLngLat([reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]).addTo(map);

                            const circlePolygon = turf.circle(
                                [reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude], 
                                reminder.radiusMeters || DEFAULT_LOCATION_RADIUS, 
                                { steps: 64, units: 'meters' }
                            );
                            
                            const circleSourceId = `map-preview-circle-${reminder.id}`;
                            map.addSource(circleSourceId, {
                                'type': 'geojson',
                                'data': circlePolygon
                            });
                            map.addLayer({
                                'id': circleSourceId,
                                'type': 'fill',
                                'source': circleSourceId,
                                'paint': {
                                    'fill-color': circleColor,
                                    'fill-opacity': isRadarType ? 0.2 : 0.05
                                }
                            });
                        });

                        map.resize();
                        previewMaps[reminder.id] = map;
                    } catch (mapError) {
                         if (mapPreviewElement) mapPreviewElement.innerHTML = `<p style="font-size:0.8rem; color: red; text-align: center; padding: 5px;">Error al cargar mapa</p>`;
                    }
                }, 100);
             }
        }
    });
    const count = overdueReminders.length;
    countSpan.textContent = count;
    if (count > 0) {
         if (currentNotificationSlideIndex >= count) {
             currentNotificationSlideIndex = 0;
         }
         swiperContainer.scrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
         updateReminderIndexDisplay();
         countHeader.classList.remove('hidden');
         if (count > 1) {
            countTextContainer.style.display = 'inline';
            swipeHint.style.display = 'block';
            document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = 'calc(85vh - 60px)');
         } else {
            countTextContainer.style.display = 'none';
            swipeHint.style.display = 'none';
            document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = '85vh');
         }
          hideAllButton.classList.remove('hidden');
          const newHideAllButton = hideAllButton.cloneNode(true);
          hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton);
          newHideAllButton.addEventListener('click', postponeAllVisibleReminders);
          
          realtimeSpeedUpdateInterval = setInterval(() => {
              if (!windowElement.classList.contains('visible')) {
                  clearInterval(realtimeSpeedUpdateInterval);
                  realtimeSpeedUpdateInterval = null;
                  return;
              }
              const carSpeed = Math.round(window.currentSpeedKmh || 0);
              overdueReminders.forEach(reminder => {
                  if(reminder.text.toUpperCase().includes("RADAR")) {
                      const speedDisplayElement = document.getElementById(`current-speed-display-${reminder.id}`);
                      if (speedDisplayElement) {
                          const radarSpeed = extractSpeedFromRadarText(reminder.text);
                          const speedExceeded = radarSpeed !== null && carSpeed > radarSpeed;
                          speedDisplayElement.textContent = `[Velocidad actual: ${carSpeed} Km/h]`;
                          speedDisplayElement.style.color = speedExceeded ? 'red' : '#333';
                      }
                  }
              });
          }, 500);

    } else {
        countHeader.classList.add('hidden');
        hideAllButton.classList.add('hidden');
        currentNotificationSlideIndex = 0;
    }
    windowElement.classList.add('visible');
    isUnifiedWindowVisibleByLogic = true;
    swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay);
    swiperContainer.addEventListener('scroll', updateReminderIndexDisplay);
}
    
    // ===================================================================
    // NOMBRE: getSavedLocations
    // RESUMEN: Obtiene las ubicaciones guardadas desde localStorage.
    function getSavedLocations() { try { const locations = localStorage.getItem(SAVED_LOCATIONS_KEY); return locations ? JSON.parse(locations) : Array(MAX_SAVED_LOCATIONS).fill(null); } catch (e) { return Array(MAX_SAVED_LOCATIONS).fill(null); } }
    
    // ===================================================================
    // NOMBRE: saveLocationsToCache
    // RESUMEN: Guarda el array de ubicaciones en localStorage.
    function saveLocationsToCache(locationsArray) { try { localStorage.setItem(SAVED_LOCATIONS_KEY, JSON.stringify(locationsArray));} catch (e) { showToast("Error al guardar ubicaciones.", "error"); } }
    
    
// ===================================================================
// NOMBRE: plotIntervalData (CORREGIDA)
// RESUMEN: Aade un nuevo punto de datos a la grfica a intervalos regulares. La condicin de ejecucin se ha modificado para permitir que se ejecute tanto en modo Navegacin como en modo Free Drive.
function plotIntervalData() {
    if (!isGraphingActive || !(isNavigating || isFreeDriveActive) || !navigationChart || !navigationStartTimeForStats || !navigationCurrentLocation) {
        return;
    }

    let currentAverageSpeed = 0;
    const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000;

    if (timeElapsedS > 0 && totalDistanceTravelledForStats > 0) {
        const avgSpeedMs = totalDistanceTravelledForStats / timeElapsedS;
        currentAverageSpeed = avgSpeedMs * 3.6;
    }
    
    if (currentAverageSpeed > 1) { 
        minAverageSpeedInTrip = Math.min(minAverageSpeedInTrip, currentAverageSpeed);
        maxAverageSpeedInTrip = Math.max(maxAverageSpeedInTrip, currentAverageSpeed);
        
        const timeLabel = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        graphLabels.push(timeLabel);
        graphDataPoints.speed.push(currentAverageSpeed);
    }
    
    const currentAltitude = navigationCurrentLocation.altitude || 0;
    
    if (graphDataPoints.altitude.length < graphDataPoints.speed.length) {
        graphDataPoints.altitude.push(currentAltitude);
    }
    
    updateChartData();

    const isCurrentlyStopped = (window.currentSpeedKmh || 0) < 1;
    if (isCurrentlyStopped) {
        if (isCarStoppedForGraph) return; 
        isCarStoppedForGraph = true;
    } else {
        isCarStoppedForGraph = false;
    }
}    

// ===================================================================
// NOMBRE: updateChartData (MODIFICADA - GESTIONA MODO LIBRE)
// RESUMEN: Actualiza los datos y la configuracin de la grfica de navegacin, adaptando el ttulo y contenido para el modo "Free Drive".
function updateChartData() {
    if (!navigationChart) return;
    const graphCard = document.getElementById('navigation-graph-card');
    const isEnlarged = graphCard ? graphCard.classList.contains('enlarged') : false;
    const valueStyle = "font-size: 1.2em; opacity: 1.0; line-height: 1.4; font-weight: bold; text-align: right; padding-right: 22px;";
    const etaColor = "#D29BFD";
    const avgColor = "yellow";
    const maxColor = "#FFA420";
    const minAvgLineColor = '#FFA500';
    const maxAvgLineColor = '#28a745';

    const mainDataset = navigationChart.data.datasets[0];
    const altitudeFillDataset = navigationChart.data.datasets[1];
    const referenceDataset = navigationChart.data.datasets[2];
    const minAvgSpeedDataset = navigationChart.data.datasets[3];
    const maxAvgSpeedDataset = navigationChart.data.datasets[4];
    const accumulatedAvgSpeedDataset = navigationChart.data.datasets[5];

    if (currentGraphMode === 'Desviacin ETA') {
        navigationChart.options.scales.yPrimary.ticks.callback = function(value) { return Math.round(value) + ' km/h'; };
        
        mainDataset.borderColor = 'rgba(129, 216, 208, 0.6)'; 
        mainDataset.backgroundColor = 'rgba(37, 99, 235, 0.25)';
        mainDataset.fill = 'origin';
        mainDataset.pointRadius = 0;

        altitudeFillDataset.hidden = true; 
        altitudeFillDataset.data = []; 
        
        const currentAvgSpeed = window.averageSpeedKmh || 0;
        
        const valuesToShow = [graphExpectedAvgSpeed];
        if (currentAvgSpeed > 1) valuesToShow.push(currentAvgSpeed);
        if (maxAverageSpeedInTrip > -Infinity) valuesToShow.push(maxAverageSpeedInTrip);
        if (minAverageSpeedInTrip < Infinity) valuesToShow.push(minAverageSpeedInTrip);
        
        const maxVisibleValue = Math.max(...valuesToShow);
        const minVisibleValue = Math.min(...valuesToShow);

        const newYMax = maxVisibleValue + 3;
        const newYMin = Math.max(0, minVisibleValue - 3);
        
        navigationChart.options.scales.yPrimary.min = newYMin;
        navigationChart.options.scales.yPrimary.max = newYMax;

        const yAxisRange = newYMax - newYMin;
        const targetTickCount = isEnlarged ? 20 : 10;
        let stepSize = yAxisRange > 0 ? yAxisRange / targetTickCount : 1;
        const niceIntervals = [0.1, 0.2, 0.5, 1, 2, 5];
        let bestFitStep = niceIntervals[niceIntervals.length - 1];
        for (const interval of niceIntervals) {
            if (stepSize <= interval) {
                bestFitStep = interval;
                break;
            }
        }
        navigationChart.options.scales.yPrimary.ticks.stepSize = bestFitStep;

        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            const avgVal = (window.averageSpeedKmh || 0).toFixed(1);
            const maxVal = (maxSpeedDuringTrip || 0).toFixed(1);
            
            if (isFreeDriveActive) {
                graphTitleElement.innerHTML = `
                    <span style="font-size: 0.9em;">VELOCIDAD</span> 
                    <small style="${valueStyle}">
                        <span style="color:${avgColor};">Med: ${avgVal}</span> 
                        <span style="color:${maxColor};">   |  Mx: ${maxVal} Km/h</span>
                    </small>`;
                referenceDataset.hidden = true;
            } else {
                const etaVal = (graphExpectedAvgSpeed || 0).toFixed(1);
                graphTitleElement.innerHTML = `
                    <span style="font-size: 0.9em;">ETA</span> 
                    <small style="${valueStyle}">
                        <span style="color:${etaColor};">ETA: ${etaVal}</span> 
                        <span style="color:${avgColor};">   |  Med: ${avgVal}</span> 
                        <span style="color:${maxColor};">   |  Mx: ${maxVal} Km/h</span>
                    </small>`;
                referenceDataset.hidden = false;
            }
        }
        
        mainDataset.data = graphDataPoints.speed;
        mainDataset.label = 'Velocidad Media Real';
        
        referenceDataset.data = graphLabels.map(() => graphExpectedAvgSpeed);
        referenceDataset.label = 'Media ETA Inicial';
        
        minAvgSpeedDataset.data = graphLabels.map(() => minAverageSpeedInTrip === Infinity ? null : minAverageSpeedInTrip);
        minAvgSpeedDataset.label = 'Media Mnima';
        minAvgSpeedDataset.borderColor = minAvgLineColor;
        
        maxAvgSpeedDataset.data = graphLabels.map(() => maxAverageSpeedInTrip === -Infinity ? null : maxAverageSpeedInTrip);
        maxAvgSpeedDataset.label = 'Media Mxima';
        maxAvgSpeedDataset.borderColor = maxAvgLineColor;

        accumulatedAvgSpeedDataset.data = graphLabels.map(() => window.averageSpeedKmh);
        accumulatedAvgSpeedDataset.hidden = false;

    } else if (currentGraphMode === 'Altitud') {
        accumulatedAvgSpeedDataset.hidden = true;
        accumulatedAvgSpeedDataset.data = [];

        navigationChart.options.scales.yPrimary.ticks.callback = function(value) { return Math.round(value) + ' m'; };
        navigationChart.options.scales.yPrimary.max = undefined;
        navigationChart.options.scales.yPrimary.min = undefined;
        
        mainDataset.borderColor = 'rgba(129, 216, 208, 1)'; 
        mainDataset.backgroundColor = 'transparent';
        mainDataset.fill = 'origin' ;
        mainDataset.pointRadius = 0;

        altitudeFillDataset.data = graphDataPoints.altitude;
        altitudeFillDataset.hidden = false;
        
        const altitudeValues = graphDataPoints.altitude.length > 0 ? graphDataPoints.altitude : [0];
        const minAlt = Math.min(...altitudeValues);
        const maxAlt = Math.max(...altitudeValues);
        const altRange = maxAlt - minAlt;
        const targetTickCountAlt = isEnlarged ? 10 : 5;

        if (altRange > 0) {
            const rawStepAlt = altRange / targetTickCountAlt;
            const niceIntervalsAlt = [2, 5, 10, 20, 50, 100];
            let stepSizeAlt = niceIntervalsAlt[niceIntervalsAlt.length - 1];
            for (const interval of niceIntervalsAlt) { if(rawStepAlt <= interval) { stepSizeAlt = interval; break; } }
            navigationChart.options.scales.yPrimary.ticks.stepSize = stepSizeAlt;
        } else {
             navigationChart.options.scales.yPrimary.ticks.stepSize = undefined;
        }
        
        const altitudePoints = graphDataPoints.altitude;
        const avgAltitudeValue = altitudePoints.length > 0 ? altitudePoints.reduce((a, b) => a + b, 0) / altitudePoints.length : 0;
        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            const maxAltVal = (maxAltitudeDuringTrip !== -Infinity ? maxAltitudeDuringTrip : 0).toFixed(0);
            const avgAltVal = avgAltitudeValue.toFixed(0);
            const minAltVal = (minAltitudeDuringTrip !== Infinity ? minAltitudeDuringTrip : 0).toFixed(0);
            graphTitleElement.innerHTML = `
                <span style="font-size: 0.7em;">DESNIVEL RUTA</span>
                <small style="${valueStyle}">
                    <span style="color:${maxColor};">Mx: ${maxAltVal}</span> 
                    <span style="color:${etaColor};">   |  Med: ${avgAltVal}</span> 
                    <span style="color:${avgColor};">   |  Mn: ${minAltVal}m</span>
                </small>`;
        }
        
        mainDataset.data = graphDataPoints.altitude;
        mainDataset.label = 'Altitud';
        
        referenceDataset.data = graphLabels.map(() => avgAltitudeValue);
        referenceDataset.label = 'Media';
        
        minAvgSpeedDataset.data = graphLabels.map(() => minAltitudeDuringTrip !== Infinity ? minAltitudeDuringTrip : null);
        minAvgSpeedDataset.label = 'Mnima';
        minAvgSpeedDataset.borderColor = '#FFA500';
        
        maxAvgSpeedDataset.data = graphLabels.map(() => maxAltitudeDuringTrip !== -Infinity ? maxAltitudeDuringTrip : null);
        maxAvgSpeedDataset.label = 'Mxima';
        maxAvgSpeedDataset.borderColor = '#28a745';
    }
    navigationChart.data.labels = graphLabels; 
    navigationChart.update('none');
}    
    
// ===================================================================
// NOMBRE: initializeNavigationGraph
// RESUMEN: Inicializa el grfico de Chart.js para la navegacin.
function initializeNavigationGraph() {
    const graphCard = document.getElementById('navigation-graph-card');
    const graphContainer = document.getElementById('navigation-graph-container');
    const graphTitleElement = document.getElementById('navigation-graph-title');
    if (!graphCard || !graphContainer || !graphTitleElement || (!isNavigating && !isFreeDriveActive) || currentGraphMode === 'Grfica off') {
        if (graphCard) graphCard.classList.add('hidden');
        if (navigationChart) { navigationChart.destroy(); navigationChart = null; }
        return;
    }
    graphCard.classList.remove('hidden');
    const compassElement = document.querySelector('.map-control-orientation-altitude');
    graphCard.style.height = compassElement ? (compassElement.offsetHeight + 'px') : '157px';
    isCarStoppedForGraph = false;
    graphDataPoints = { speed: [], altitude: [] };
    graphLabels = [];
    minAverageSpeedInTrip = Infinity;
    maxAverageSpeedInTrip = -Infinity;
    graphPlotState = { 
        lastPlotTime: Date.now(), 
        lastPlotCoords: navigationCurrentLocation ? { ...navigationCurrentLocation } : null 
    };
    if (navigationChart) {
        navigationChart.destroy();
        navigationChart = null;
    }
    isGraphingActive = true;
    const ctx = document.getElementById('navigation-chart')?.getContext('2d');
    if (!ctx || !ctx.canvas) {
        showToast("Error crtico: Canvas para grfica no encontrado.", "error");
        if (graphCard) graphCard.classList.add('hidden');
        return;
    }
    
    const initialRouteDurationSec = navigationCurrentRouteData?.routes?.[0]?.duration || 0;
    const initialRouteDistance = navigationCurrentRouteData?.routes?.[0]?.distance || 0;
    
    const graphWidth = ctx.canvas.clientWidth || 300;
    const pixelsPerPoint = 3;
    const maxPoints = Math.floor(graphWidth / pixelsPerPoint);
    
    if (isNavigating && initialRouteDurationSec > 0 && maxPoints > 0) {
        const idealIntervalMs = (initialRouteDurationSec / maxPoints) * 1000;
        graphIntervalDuration = Math.max(5000, idealIntervalMs); 
    } else if (isFreeDriveActive) {
        graphIntervalDuration = 10000;
    } else {
        graphIntervalDuration = 30000;
    }

    graphExpectedAvgSpeed = (initialRouteDurationSec > 0 && initialRouteDistance > 0) ? (initialRouteDistance / initialRouteDurationSec) * 3.6 : 0;
    
    navigationChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'Velocidad Media Real', data: [],
                    borderColor: 'rgba(75, 192, 192, 0.5)',
                    backgroundColor: 'rgba(75, 192, 192, 0.25)',
                    tension: 0.1, yAxisID: 'yPrimary', 
                    pointRadius: 0, 
                    order: 3, 
                    fill: 'origin'
                },
                {
                    label: 'rea Desnivel', data: [],
                    borderColor: 'rgba(255, 165, 0, 0.5)', 
                    backgroundColor: 'rgba(255, 165, 0, 0.3)', 
                    fill: 'origin',
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: true, order: 4
                },
                {
                    label: 'Media ETA Inicial', data: [], 
                    borderColor: '#dfcae1', 
                    borderWidth: 3,          
                    fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 2
                },
                {
                    label: 'Media Mnima', data: [], borderColor: '#FFA500',
                    borderWidth: 1.5, borderDash: [5, 5], fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 1
                },
                {
                    label: 'Media Mxima', data: [], borderColor: '#28a745',
                    borderWidth: 1.5, borderDash: [5, 5], fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 0
                },
                {
                    label: 'Media Acumulada Real', data: [], 
                    borderColor: '#F9e4b7', 
                    borderWidth: 3,        
                    fill: false,
                    pointRadius: 0, 
                    yAxisID: 'yPrimary', 
                    hidden: false, 
                    order: 2
                }
            ]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            layout: {
                padding: { top: 5, bottom: 2, left: 0, right: 2 }
            },
            scales: {
                x: {
                    type: 'category',
                    ticks: {
                        display: false 
                    },
                    grid: {
                        drawOnChartArea: false
                    }
                },
                yPrimary: {
                    type: 'linear', position: 'left',
                    min: Math.max(0, graphExpectedAvgSpeed - 3),
                    max: graphExpectedAvgSpeed + 3,
                    ticks: { color: 'white', font: { size: 11 }, callback: (v) => Math.round(Number(v)).toString(), stepSize: 0.2 },
                    grid: { color: 'rgba(255,255,255,0.1)' }, title: { display: false }
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: { 
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) { label += ': '; }
                            if (context.parsed.y !== null) {
                                label += context.parsed.y.toFixed(1);
                                if (currentGraphMode === 'Desviacin ETA') label += ' km/h';
                                else if (currentGraphMode === 'Altitud') label += ' m';
                            }
                            return label;
                        }
                    }
                 }
            },
            animation: { duration: 250 }
        }
    });
    startGraphIntervalTimer();
    updateNavigationGraphVisibilityAndMode();
}


// ===================================================================
// NOMBRE: updateInitialUserPosition (VERSIN CON INICIALIZACIN DE ANIMACIN CORREGIDA)
// RESUMEN: Se asegura de que la animacin del marcador tenga un punto de partida.
// ===================================================================
function updateInitialUserPosition(coords, mapInstanceToUse) {
    if (!mapInstanceToUse || !coords || typeof coords.latitude !== 'number' || typeof coords.longitude !== 'number') {
        return;
    }
    lastGpsUpdateTime = Date.now();

    const lngLat = new mapboxgl.LngLat(coords.longitude, coords.latitude);
    initialUserLocationMarkerLat = coords.latitude;
    initialUserLocationMarkerLng = coords.longitude;

    let effectiveHeading = null;
    if (coords.heading !== null && typeof coords.heading === 'number' && coords.heading >= 0) {
        effectiveHeading = coords.heading;
    } else if (window.lastPositionForSpeedCalc && typeof turf !== 'undefined') {
        const lastPoint = turf.point([window.lastPositionForSpeedCalc.longitude, window.lastPositionForSpeedCalc.latitude]);
        const currentPoint = turf.point([coords.longitude, coords.latitude]);
        if (turf.distance(lastPoint, currentPoint, { units: 'meters' }) > 1) {
            const bearing = turf.bearing(lastPoint, currentPoint);
            effectiveHeading = (bearing < 0) ? bearing + 360 : bearing;
        }
    }

    const currentHeading = (effectiveHeading !== null) ? effectiveHeading : (currentMapBearing || 0);

    if (!initialUserLocationMarker) {
        const vehicleIconElement = document.createElement('div');
        vehicleIconElement.style.width = '48px';
        vehicleIconElement.style.height = '48px';
        vehicleIconElement.innerHTML = `<img src="PNG/AVANCE.PNG" alt="Coche" style="width:100%; height:100%; object-fit:contain;">`;

        initialUserLocationMarker = new mapboxgl.Marker({ element: vehicleIconElement, rotationAlignment: 'map', anchor: 'center' })
            .setLngLat(lngLat)
            .addTo(mapInstanceToUse);
    }

    if (!markerAnimationState.currentLngLat) {
        markerAnimationState.currentLngLat = lngLat;
    }
   
    markerAnimationState.targetLngLat = lngLat;
    markerAnimationState.targetIconRotation = currentHeading - 90;
    if (!markerAnimationState.animationFrameId) {
        markerAnimationState.animationFrameId = requestAnimationFrame(animateMarkerAndMap);
    }

    if (compassAndModeControl) {
        compassAndModeControl.updateOrientation(currentHeading);
        compassAndModeControl.updateAltitude(coords.altitude);
        if (window.lastPositionForSpeedCalc && typeof coords.speed === 'number' && coords.speed !== null) {
            const distM = calculateDistance(window.lastPositionForSpeedCalc.latitude, window.lastPositionForSpeedCalc.longitude, coords.latitude, coords.longitude);
            const timeS = (Date.now() - window.lastPositionForSpeedCalc.time) / 1000;
            if (timeS > 0 && distM >= 0) {
                let speedMs = coords.speed;
                if (typeof speedMs !== 'number' || speedMs === null || speedMs < 0) { speedMs = distM / timeS; }
                window.currentSpeedKmh = speedMs * 3.6;
            } else { window.currentSpeedKmh = 0; }
        } else {
            if (typeof coords.speed === 'number' && coords.speed !== null && coords.speed >= 0) { window.currentSpeedKmh = coords.speed * 3.6; } else { window.currentSpeedKmh = 0; }
        }
        window.lastPositionForSpeedCalc = { latitude: coords.latitude, longitude: coords.longitude, time: Date.now() };
        const isTripActive = isNavigating || isFreeDriveActive;
        if (isTripActive) {
            if (window.currentSpeedKmh > maxSpeedDuringTrip) {
                maxSpeedDuringTrip = window.currentSpeedKmh;
                if (coords) { maxSpeedCoordinates = { lat: coords.latitude, lng: coords.longitude }; }
            }
            if (coords.altitude !== null && !isNaN(coords.altitude)) {
                maxAltitudeDuringTrip = Math.max(maxAltitudeDuringTrip, coords.altitude);
                minAltitudeDuringTrip = Math.min(minAltitudeDuringTrip, coords.altitude);
            }
            SPEED_MILESTONES.forEach(milestone => {
                if (window.currentSpeedKmh > milestone && milestone > lastSpeedMilestone) {
                    lastSpeedMilestone = milestone;
                    const newMilestoneFeature = {
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [coords.longitude, coords.latitude]
                        },
                        properties: {
                            type: 'milestone',
                            speedText: String(milestone)
                        }
                    };
                    speedMarkerFeatures.push(newMilestoneFeature);
                    if (navigationMapInstance.getSource('speed-markers-source')) {
                        navigationMapInstance.getSource('speed-markers-source').setData({
                            type: 'FeatureCollection',
                            features: speedMarkerFeatures
                        });
                    }
                }
            });
        }
        compassAndModeControl.updateCurrentSpeed(window.currentSpeedKmh);
        compassAndModeControl.updateAverageSpeed(window.averageSpeedKmh);
        compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip);
    }

    const shouldFollow = (shouldCenterOnUser || navigationFollowUser);

    if (!shouldFollow) {
        return;
    }

    if (!isRecalculatingRoute && navigationMapInstance) {
        const animationDuration = 1000;
        //const targetZoom = handleProgressiveManeuverZoom(navigationCurrentRouteData?.routes?.[0]?.legs?.[currentLegIndexNav]?.steps?.[currentStepIndexNav], distanceToNextManeuverOSRM);
        const targetZoom = handleProgressiveManeuverZoom(navigationCurrentRouteData?.routes?.[0]?.legs?.[currentLegIndexNav]?.steps?.[currentStepIndexNav], distanceToNextManeuverOSRM, lastCarDistanceAlongRouteForNavLogic);
        const viewOptions = {
            center: lngLat,
            duration: animationDuration,
            essential: true
        };

        const mapHeight = navigationMapInstance.getCanvas().clientHeight;
        const mapWidth = navigationMapInstance.getCanvas().clientWidth;
        const verticalPadding = mapHeight * Math.abs(mapOffsetY / 100);
        const horizontalPadding = mapWidth * Math.abs(mapOffsetX / 100);

        viewOptions.padding = {
            top: mapOffsetY > 0 ? verticalPadding : 0,
            bottom: mapOffsetY < 0 ? verticalPadding : 0,
            left: mapOffsetX > 0 ? horizontalPadding : 0,
            right: mapOffsetX < 0 ? horizontalPadding : 0
        };

        if (targetZoom !== null && !isManualZoomActive) {
            viewOptions.zoom = targetZoom;
        }

        if (mapViewMode === 'heading' || mapViewMode === 'perspective') {
            viewOptions.bearing = currentHeading;
        }

        if (mapViewMode === 'perspective') {
            viewOptions.pitch = mapPitchValue;
        } else {
            viewOptions.pitch = 0;
        }

        navigationMapInstance.easeTo(viewOptions);
    }

    handleAutoZoom();
}


// ===================================================================
// NOMBRE: startAutomatedRouteSimulation (VERSIN FINAL CON REINICIO CORRECTO)
// RESUMEN: Inicia o reanuda la simulacin. Gestiona correctamente el
//          reinicio del progreso al reanudar tras un desvo.
// ===================================================================
function startAutomatedRouteSimulation(speedKmph, continueFromCurrentState = false) {
    if (!isSimulatingGpsLocation) {
        isSimulatingGpsLocation = true;
        if (locationWatchId !== null && navigator.geolocation) {
            navigator.geolocation.clearWatch(locationWatchId);
            locationWatchId = null;
        }
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) {
            simulateGpsButton.classList.add('active-simulate-gps-mode');
            simulateGpsButton.title = "Desactivar Simulacin GPS (Volver a GPS Real)";
        }
    }
    
    if (automatedSimulationIntervalId) {
        clearInterval(automatedSimulationIntervalId);
        automatedSimulationIntervalId = null;
    }
    
    simulationSpeedKmph = speedKmph;
    currentSimulationSpeedKmph = speedKmph;
    
    const route = navigationCurrentRouteData?.routes?.[0];
    if (!route) {
        showToast("No hay ruta vlida para iniciar la simulacin.", "error");
        stopAutomatedRouteSimulation();
        return;
    }
    
    // --- INICIO DE LA LGICA DE REINICIO CORREGIDA ---
    if (continueFromCurrentState) {
        // Al REANUDAR, calculamos la distancia inicial en la NUEVA ruta.
        const carPointTurf = turf.point([simulatedGpsLocation.longitude, simulatedGpsLocation.latitude]);
        const routeLineStringTurf = turf.lineString(route.geometry.coordinates);
        const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
        const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
        
        // LA CORRECCIN CLAVE! Asignamos este nuevo valor inicial al progreso.
        simulatedDistanceAlongRoute = turf.length(lineSliceToNearestTurf, { units: 'meters' });
        
        // Mantenemos las estadsticas totales del viaje
        
    } else {
        // Al INICIAR DE CERO, reseteamos todo.
        wasSimulatingBeforeRecalc = false;
        simulatedDistanceAlongRoute = 0;
        navigationStartTimeForStats = null;
        totalDistanceTravelledForStats = 0;
        maxSpeedDuringTrip = 0;
        clearSpeedMarkers();

        const startWaypoint = navigationWaypoints.find(wp => wp.type === 'S' || wp.isRecalculatedStart) || navigationWaypoints[0];
        lastPositionForStats = { latitude: startWaypoint.lat, longitude: startWaypoint.lng };
        
        let initialHeading = 0;
        if (route.geometry.coordinates.length >= 2) {
            initialHeading = turf.bearing(turf.point(route.geometry.coordinates[0]), turf.point(route.geometry.coordinates[1]));
            if (initialHeading < 0) initialHeading += 360;
        }
        simulatedGpsLocation = { latitude: startWaypoint.lat, longitude: startWaypoint.lng, accuracy: 5, heading: initialHeading, altitude: (navigationCurrentLocation?.altitude) ?? 0, speed: 0 };
        maxSpeedCoordinates = { lat: startWaypoint.lat, lng: startWaypoint.lng };
        processSimulatedGpsPosition(true);
        showToast(`Simulacin automtica de ruta iniciada a ${speedKmph.toFixed(0)} km/h.`, "info");
    }
    // --- FIN DE LA LGICA DE REINICIO CORREGIDA ---
    
    lastCarDistanceAlongRouteForNavLogic = simulatedDistanceAlongRoute;
    setNavigationMapClickHandler(); 

    let simulationStepIndex = 0;
    let simulationLegIndex = 0;
    
    let tempDistance = 0;
    for (let i = 0; i < route.legs.length; i++) {
        let legFound = false;
        for (let j = 0; j < route.legs[i].steps.length; j++) {
            tempDistance += route.legs[i].steps[j].distance;
            if (simulatedDistanceAlongRoute < tempDistance) {
                simulationLegIndex = i;
                simulationStepIndex = j;
                legFound = true;
                break;
            }
        }
        if (legFound) break;
    }
    let distanceToEndOfCurrentStep = calculateDistanceToEndOfStep(route, simulationLegIndex, simulationStepIndex);

    automatedSimulationIntervalId = setInterval(() => {
        const currentRouteForInterval = navigationCurrentRouteData?.routes?.[0];
        if (!currentRouteForInterval) {
            stopAutomatedRouteSimulationInternal();
            return;
        }

        const totalRouteDistance = currentRouteForInterval.distance;
        const speedMps = (currentSimulationSpeedKmph * 1000) / 3600;
        const distanceIncrement = speedMps * (SIMULATION_TICK_INTERVAL_MS / 1000);
        simulatedDistanceAlongRoute += distanceIncrement;

        if (navigationStartTimeForStats) {
            totalDistanceTravelledForStats += distanceIncrement;
        }
        
        if (simulatedDistanceAlongRoute > distanceToEndOfCurrentStep) {
            simulationStepIndex++;
            if (currentRouteForInterval.legs[simulationLegIndex] && simulationStepIndex >= currentRouteForInterval.legs[simulationLegIndex].steps.length) {
                simulationStepIndex = 0;
                simulationLegIndex++;
            }
            if (simulationLegIndex < currentRouteForInterval.legs.length && currentRouteForInterval.legs[simulationLegIndex]) {
                const currentStep = currentRouteForInterval.legs[simulationLegIndex].steps[simulationStepIndex];
                if (currentStep) { 
                    const multiplier = getRandomSpeedMultiplierForManeuver(currentStep.maneuver);
                    currentSimulationSpeedKmph = Math.max(20, Math.min(5000, simulationSpeedKmph * (1 + multiplier)));
                    distanceToEndOfCurrentStep = calculateDistanceToEndOfStep(currentRouteForInterval, simulationLegIndex, simulationStepIndex);
                }
            }
        }
      
        if (simulatedDistanceAlongRoute >= totalRouteDistance) {
            stopAutomatedRouteSimulationInternal();
            const endPointCoords = currentRouteForInterval.geometry.coordinates[currentRouteForInterval.geometry.coordinates.length - 1];
            simulatedGpsLocation = {
                ...simulatedGpsLocation,
                latitude: endPointCoords[1],
                longitude: endPointCoords[0],
                speed: 0
            };
            processSimulatedGpsPosition(true);
            showToast("Simulacin de ruta completada. Modo simulacin por clic activo.", "success");
            const mapDiv = document.getElementById('reminders-location-map-div');
            if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode'); 
            if (isNavigating || (!isNavigating && navigationWaypoints.length > 0)) {
                 showArrivalStatsModal();
            }
            setNavigationMapClickHandler();
            return;
        }
        const turfLine = turf.lineString(currentRouteForInterval.geometry.coordinates);
        const pointOnLine = turf.along(turfLine, simulatedDistanceAlongRoute / 1000, { units: 'kilometers' });
        if (pointOnLine?.geometry?.coordinates) {
            const [lng, lat] = pointOnLine.geometry.coordinates;
            let headingSim = 0;
            const lookAheadDistance = Math.min(distanceIncrement * 2, totalRouteDistance - simulatedDistanceAlongRoute);
            if (simulatedDistanceAlongRoute + lookAheadDistance <= totalRouteDistance && lookAheadDistance > 0) {
                const nextPointOnLine = turf.along(turfLine, (simulatedDistanceAlongRoute + lookAheadDistance) / 1000, { units: 'kilometers' });
                if (nextPointOnLine?.geometry?.coordinates) {
                    headingSim = turf.bearing(pointOnLine, nextPointOnLine);
                    if (headingSim < 0) headingSim += 360;
                }
            } else {
                headingSim = simulatedGpsLocation?.heading || 0;
            }
            simulatedGpsLocation = {
                latitude: lat,
                longitude: lng,
                accuracy: 5,
                heading: headingSim,
                altitude: (navigationCurrentLocation?.altitude) ?? 0,
                speed: speedMps
            };
            processSimulatedGpsPosition(false);
        }
    }, SIMULATION_TICK_INTERVAL_MS);
}
// ===================================================================
// NOMBRE: showIntersectionPreviewMap (VERSIN CON POSICIN CORREGIDA)
// RESUMEN: Muestra el minimapa de maniobras alineado en la esquina superior
//          izquierda de la barra de progreso, superponindose a ella.
function showIntersectionPreviewMap(step, route, isSimulationContextOrClick = false, timerDurationMs = null) {
    if (!showMinimapPreference) {
        hideIntersectionPreviewMap();
        return;
    }
  
    const previewWindow = document.getElementById('intersection-preview-map-window');
    const progressBarEl = document.getElementById('navigation-bottom-progress-bar');
    if (!previewWindow || !step || !step.geometry || !route || !navigationMapInstance) {
        hideIntersectionPreviewMap();
        return;
    }
    const DISTANCE_BEFORE_MANEUVER_METERS = 110;
    const DISTANCE_AFTER_MANEUVER_METERS = 90;
    const CAR_POSITION_BEFORE_MANEUVER_METERS = 25;
    if (!previewWindow.querySelector('#intersection-rotator')) {
        previewWindow.innerHTML = `
            <div id="intersection-rotator" style="width: 100%; height: 100%; transition: transform 0.3s ease-out;">
                <div id="intersection-preview-map-container"></div>
            </div>
        `;
    }
    const rotatorDiv = previewWindow.querySelector('#intersection-rotator');
    const mapContainerEl = previewWindow.querySelector('#intersection-preview-map-container');
    const isProgressBarVisible = progressBarEl && progressBarEl.offsetParent !== null;

    if (isProgressBarVisible) {
        const progressBarRect = progressBarEl.getBoundingClientRect();
        previewWindow.style.width = `${progressBarRect.width}px`;

        // --- INICIO DE LA CORRECCIN DEFINITIVA ---
        // Alinear la parte SUPERIOR del mini-mapa con la parte SUPERIOR de la barra de progreso.
        previewWindow.style.top = `${progressBarRect.top}px`;
        previewWindow.style.left = `${progressBarRect.left}px`;
        
        // Resetear otras propiedades de posicionamiento para evitar conflictos.
        previewWindow.style.bottom = 'auto';
        previewWindow.style.transform = 'none';
        // --- FIN DE LA CORRECCIN DEFINITIVA ---

    } else if (isSimulationContextOrClick) {
        previewWindow.style.width = '90%';
        previewWindow.style.maxWidth = '500px';
        previewWindow.style.left = '50%';
        previewWindow.style.top = '50%';
        previewWindow.style.transform = 'translate(-50%, -50%)';
    } else {
        hideIntersectionPreviewMap();
        return;
    }

    previewWindow.classList.remove('hidden');
    previewWindow.dataset.source = isSimulationContextOrClick ? 'click' : 'auto';
    if (intersectionPreviewTimer) clearTimeout(intersectionPreviewTimer);

    try {
        if (intersectionPreviewMap) {
            try {
                intersectionPreviewMap.remove();
            } catch(e) {}
            intersectionPreviewMap = null;
        }

        intersectionPreviewMap = L.map(mapContainerEl, {
            zoomControl: false, dragging: false, touchZoom: false, scrollWheelZoom: false,
            doubleClickZoom: false, boxZoom: false, keyboard: false, attributionControl: false
        });

        if (rotatorDiv) {
            rotatorDiv.style.transition = 'none';
            rotatorDiv.style.transform = 'rotate(0deg)';
        }

        const currentMapLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "HBRIDO";
        const layerNameLower = currentMapLayerName.toLowerCase();
        let tileLayerInstance;

        if (layerNameLower.includes("satlite puro") || layerNameLower.includes("satlite")) {
            tileLayerInstance = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles  Esri' });
        } else if (layerNameLower.includes("hbrido") || layerNameLower.includes("satlite + calles")) {
            const labelsPaneName = 'intersection_labels_pane_unique';
            tileLayerInstance = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles  Esri' });
            if (!intersectionPreviewMap.getPane(labelsPaneName)) {
                intersectionPreviewMap.createPane(labelsPaneName);
                intersectionPreviewMap.getPane(labelsPaneName).style.zIndex = 650;
                intersectionPreviewMap.getPane(labelsPaneName).style.pointerEvents = 'none';
            }
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', { attribution: ' OSM  CARTO', pane: labelsPaneName }).addTo(intersectionPreviewMap);
        } else { 
            tileLayerInstance = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: ' OpenStreetMap' });
        }
        
        tileLayerInstance.addTo(intersectionPreviewMap);

        const maneuverPoint = L.latLng(step.maneuver.location[1], step.maneuver.location[0]);
        const fullRouteLineString = turf.lineString(route.geometry.coordinates);
        const maneuverPointOnRoute = turf.nearestPointOnLine(fullRouteLineString, step.maneuver.location, { units: 'kilometers' });
        const maneuverDistanceKm = maneuverPointOnRoute.properties.location;
        const startSliceDistanceKm = Math.max(0, maneuverDistanceKm - (DISTANCE_BEFORE_MANEUVER_METERS / 1000));
        const endSliceDistanceKm = Math.min(turf.length(fullRouteLineString), maneuverDistanceKm + (DISTANCE_AFTER_MANEUVER_METERS / 1000));
        const startSlicePoint = turf.along(fullRouteLineString, startSliceDistanceKm);
        const endSlicePoint = turf.along(fullRouteLineString, endSliceDistanceKm);
        const routeSlice = turf.lineSlice(startSlicePoint, endSlicePoint, fullRouteLineString);
        const routeSegmentCoords = routeSlice.geometry.coordinates.map(c => [c[1], c[0]]);

        if (!routeSegmentCoords || routeSegmentCoords.length < 2) {
            throw new Error("El segmento de ruta para la vista previa de la interseccin es invlido.");
        }

        intersectionPreviewRouteLayer = L.polyline(routeSegmentCoords, { color: 'orange', weight: 10, opacity: 1 }).addTo(intersectionPreviewMap);
        intersectionPreviewManeuverMarker = L.circleMarker(maneuverPoint, { radius: 5, color: 'white', weight: 1, fillColor: 'blue', fillOpacity: 1, zIndexOffset: 1000 }).addTo(intersectionPreviewMap);
        
        const lineStringToPlaceCar = turf.lineString(routeSegmentCoords.map(c => [c[1], c[0]]));
        const distanceForCarOnSegment = Math.max(0, DISTANCE_BEFORE_MANEUVER_METERS - CAR_POSITION_BEFORE_MANEUVER_METERS);
        const carPositionPointTurf = turf.along(lineStringToPlaceCar, distanceForCarOnSegment, { units: 'meters' });
        const carPositionLatLng = L.latLng(carPositionPointTurf.geometry.coordinates[1], carPositionPointTurf.geometry.coordinates[0]);
        intersectionPreviewCarMarker = L.marker(carPositionLatLng, { icon: vehicleIconMiniMap, zIndexOffset: 1001 }).addTo(intersectionPreviewMap);
        
        const maneuver = step.maneuver;
        const iconFilename = getManeuverIconFilename(maneuver);
        const iconUrl = `https://boardinggate.github.io/Tesla/${iconFilename}`;
        if (intersectionPreviewCarMarker && intersectionPreviewCarMarker.getElement()) {
            const overlayMini = intersectionPreviewCarMarker.getElement().querySelector('.vehicle-maneuver-overlay-minimap');
            if (overlayMini) {
                overlayMini.style.backgroundImage = `url('${iconUrl}')`;
                overlayMini.style.display = 'block';
            }
        }
        
        const bounds = L.latLngBounds(routeSegmentCoords).pad(0.5);

        setTimeout(() => {
            if (intersectionPreviewMap && document.body.contains(mapContainerEl)) {
                intersectionPreviewMap.invalidateSize();
                
                const mapMaxZoom = intersectionPreviewMap.getMaxZoom() || 22;
                const zoomThatFitsBounds = intersectionPreviewMap.getBoundsZoom(bounds);
                const targetZoom = Math.min(mapMaxZoom, zoomThatFitsBounds + 2);
                
                intersectionPreviewMap.setView(bounds.getCenter(), targetZoom, { animate: false });
                
                requestAnimationFrame(() => {
                    let segmentBearing = 0;
                    const lookAheadPointTurf = turf.along(lineStringToPlaceCar, distanceForCarOnSegment + 5, { units: 'meters' });
                    if (lookAheadPointTurf) {
                        segmentBearing = turf.bearing(carPositionPointTurf, lookAheadPointTurf);
                        if (segmentBearing < 0) segmentBearing += 360;
                    } else {
                        segmentBearing = (navigationCurrentLocation && typeof navigationCurrentLocation.heading === 'number') ? navigationCurrentLocation.heading : currentMapBearing;
                    }

                    let mapRotation = 0;
                    if (segmentBearing > 45 && segmentBearing <= 135) {
                        mapRotation = -90;
                    } else if (segmentBearing > 135 && segmentBearing <= 225) {
                        mapRotation = 180;
                    } else if (segmentBearing > 225 && segmentBearing <= 315) {
                        mapRotation = 90;
                    }

                    if (rotatorDiv) {
                        rotatorDiv.style.transition = 'transform 0.3s ease-out';
                        rotatorDiv.style.transform = `rotate(${mapRotation}deg)`;
                    }
                    const finalIconRotation = segmentBearing - 90;
                    if (intersectionPreviewCarMarker && intersectionPreviewCarMarker.getElement()) {
                        const carWrapperMini = intersectionPreviewCarMarker.getElement().querySelector('.vehicle-icon-minimap');
                        if (carWrapperMini) {
                            carWrapperMini.style.transform = `rotate(${finalIconRotation}deg)`;
                        }
                    }
                });
            }
        }, 50);

        if (timerDurationMs && timerDurationMs > 0) {
            intersectionPreviewTimer = setTimeout(hideIntersectionPreviewMap, timerDurationMs);
        }
    } catch (error) {
        console.error("Error al mostrar el mapa de interseccin:", error);
        hideIntersectionPreviewMap();
    }
}    
    
// ===================================================================
// NOMBRE: saveSettings (MODIFICADA - GUARDA NUEVOS AJUSTES)
// RESUMEN: Guarda la configuracin, incluyendo los nuevos ajustes de offset y minimapa.
function saveSettings() {
    localStorage.setItem('darkMode', JSON.stringify(isDarkMode));
    const tS = {};
    document.querySelectorAll('.range-toggle').forEach(t => {
        const start = t.dataset.rangeStart;
        if (start) tS[start] = t.dataset.state;
    });
    localStorage.setItem('toggleStates', JSON.stringify(tS));
    const zoomButton = document.getElementById('zoom-button');
    if (zoomButton) localStorage.setItem('zoomState', zoomButton.dataset.zoomState);
    const onOffBtn = document.getElementById('on-off-toggle');
    if (onOffBtn) localStorage.setItem('onOffState', onOffBtn.dataset.state);
    localStorage.setItem('noticesActive', JSON.stringify(isActive));
    localStorage.setItem('footerVisible', JSON.stringify(isFooterVisible));
    localStorage.setItem('password_active', JSON.stringify(isPasswordActive));
    localStorage.setItem('lastUpdatesCheckDate', lastUpdatesCheckDate);
    localStorage.setItem(GRAPH_STATE_KEY, currentGraphMode);
    localStorage.setItem(MAP_VIEW_OFFSET_X_KEY, mapOffsetX);
    localStorage.setItem(MAP_VIEW_OFFSET_Y_KEY, mapOffsetY);
    localStorage.setItem(MAP_VIEW_SHOW_MINIMAP_KEY, showMinimapPreference);
    // --- LNEA AADIDA: Guarda el pitch ---
    localStorage.setItem(MAP_VIEW_PITCH_KEY, mapPitchValue);
    const radaresCheckboxElement = document.getElementById('radares-ruta-checkbox');
    if (radaresCheckboxElement) {
        localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckboxElement.checked));
    }
    const tareasCheckboxElement = document.getElementById('tareas-ruta-checkbox');
    if (tareasCheckboxElement) { 
        localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckboxElement.checked));
    }
    const mainSearchInputGrid = document.getElementById('main-search-input'); 
    if (mainSearchInputGrid) {
        localStorage.setItem('gridFilterValue', mainSearchInputGrid.value);
    }
    const mapFilterInput = document.getElementById('filter-input'); 
    if (mapFilterInput) {
        localStorage.setItem(MAP_FILTER_INPUT_KEY, mapFilterInput.value);
    }
    if (mapLayersControl && mapLayersControl._map && mapLayersControl._map._layers) {
        const layersArray = Object.values(mapLayersControl._map._layers);
        const baseLayerMapObject = layersArray.find(l => l._map && l.options && !l.options.pane && l.options.attribution);
        if (baseLayerMapObject) {
            const activeLayerEntry = mapLayersControl._layers.find(l => l.layer === baseLayerMapObject);
            if (activeLayerEntry && activeLayerEntry.name) {
                localStorage.setItem(ACTIVE_MAP_LAYER_KEY, activeLayerEntry.name);
            }
        }
    }
}
// ===================================================================
// NOMBRE: handleLoadOrDeleteRouteClick (MODIFICADA - USA RESET CENTRAL)
// RESUMEN: Llama a la funcin de reseteo completa antes de realizar otras acciones.
function handleLoadOrDeleteRouteClick(button) {
    clearAlternativeRoutesDisplay(); 
    resetNavigationState();

    if (isSimulatingGpsLocation) {
        stopAutomatedRouteSimulation();
    }
    
    if (isFreeDrivePaused) {
        handleFreeDriveCancellation();
    }

    clearAllWaypointMarkersFromMap();
    if (navigationMapInstance && navigationMapInstance.getSource('route')) {
        navigationMapInstance.getSource('route').setData({ type: 'FeatureCollection', features: [] });
    }
    if (navigationMapInstance && navigationMapInstance.getSource('completed-segments')) {
        navigationMapInstance.getSource('completed-segments').setData({ type: 'FeatureCollection', features: [] });
    }
    
    if (button) {
       }
    
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}
// ===================================================================
// NOMBRE: showLoadRouteModal (MODIFICADA - NUEVO DISEO CON RECIENTES)
// RESUMEN: Muestra el modal de carga con una seccin superior para rutas/destinos recientes,
function showLoadRouteModal() {
    resetNavigationState();

    const existingOverlay = document.getElementById('route-modal-load-overlay');
    if (existingOverlay) existingOverlay.remove();

    const overlay = document.createElement('div');
    overlay.id = 'route-modal-load-overlay';
    overlay.className = 'route-modal-overlay';

    const modalContent = document.createElement('div');
    modalContent.id = 'saved-routes-modal';
    modalContent.className = 'route-modal-container';

    modalContent.innerHTML = `
        <div class="route-modal-header">
             <div class="route-modal-title-card">
                 <span class="route-modal-title">Cargar Destinos o Rutas</span>
             </div>
        </div>
        <div class="route-modal-body">
            <div class="route-modal-controls">
                <input type="text" id="filter-saved-routes" class="route-filter-input" placeholder="FILTRAR DESTINOS Y RUTAS...">
                <button id="clear-filter-button" class="clear-input-btn" title="Limpiar filtro" style="display: none;"></button>
            </div>
            
            <!-- NUEVO: Seccin de Recientes/Favoritos fuera de las pestaas -->
            <h3 class="routes-section-title">Recientes</h3>
            <div id="recents-container" class="route-scroll-container" style="max-height: 180px; flex-grow: 0; margin-bottom: 15px;">
                <ul id="recent-items-list" class="route-list"></ul>
            </div>
            
            <div class="route-modal-tabs">
                <button class="route-modal-tab active" data-tab="destinos">DESTINOS GUARDADOS</button>
                <button class="route-modal-tab" data-tab="rutas">RUTAS GUARDADAS</button>
            </div>

            <div id="routes-container" class="route-scroll-container">
                <div class="route-modal-panel active" id="panel-destinos">
                    <ul id="saved-destinations-list" class="route-list"></ul>
                </div>
                <div class="route-modal-panel" id="panel-rutas">
                    <ul id="saved-routes-list" class="route-list"></ul>
                </div>
            </div>
        </div>
        <div class="route-modal-footer">
            <button id="close-saved-routes-modal" class="btn-modal-action-secondary" style="flex: 1;">Cerrar <span class="button-countdown-timer"></span></button>
        </div>
    `;
    
    overlay.appendChild(modalContent);
    document.body.appendChild(overlay);

    const closeButton = modalContent.querySelector('#close-saved-routes-modal');
    const filterInput = modalContent.querySelector('#filter-saved-routes');
    const clearFilterBtn = modalContent.querySelector('#clear-filter-button');
    const tabs = modalContent.querySelectorAll('.route-modal-tab');
    const panels = modalContent.querySelectorAll('.route-modal-panel');

    const closeHandler = () => {
        clearModalAutoCloseTimer(overlay, closeButton, 'saved-routes-modal');
        if (overlay.parentNode) overlay.remove();
    };
    closeButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(overlay, closeButton, 'saved-routes-modal', 45000);

    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            tabs.forEach(t => t.classList.remove('active'));
            panels.forEach(p => p.classList.remove('active'));
            tab.classList.add('active');
            document.getElementById(`panel-${tab.dataset.tab}`).classList.add('active');
        });
    });
    
    const renderRouteListItem = (route, listElement, isRecent) => {
        const li = document.createElement('li');
        li.className = 'route-list-item';
        const showReturnButton = route.waypoints.length > 1;
        const buttonType = isRecent ? 'Quitar' : 'Borrar';

        li.innerHTML = `
            <span class="route-name">${route.name}</span>
            <div class="route-actions">
                ${showReturnButton ? '<button class="btn-return" title="Cargar ruta en sentido inverso">Vuelta</button>' : ''}
                <button class="btn-share" style="background-color: #007aff;" title="Compartir coordenadas">Compartir</button> 
                <button class="btn-delete" title="${isRecent ? 'Quitar del historial' : 'Borrar permanentemente'}">${buttonType}</button>
            </div>
        `;
        
        li.querySelector('.route-name').addEventListener('click', () => {
            loadRouteByName(route.name, true);
            addRouteToRecents(route);
            closeHandler();
        });

        li.querySelector('.btn-share').addEventListener('click', (e) => {
             e.stopPropagation();
             if (route.waypoints.length === 1) {
                 const dest = route.waypoints[0];
                 handleSendToTeslaClick(dest.lat, dest.lng, dest.address);
             } else {
                 closeHandler();
                 showShareStageModal(route);
             }
        });

        if (showReturnButton) {
            li.querySelector('.btn-return').addEventListener('click', (e) => {
                e.stopPropagation();
                getCurrentLocation(
                    async (currentPos) => {
                        const originalWaypoints = [...route.waypoints];
                        const originalStart = originalWaypoints.shift();
                        if (originalWaypoints.length > 0) { originalWaypoints.pop(); }
                        const intermediateReversed = originalWaypoints.reverse();
                        let returnWaypoints = [{ lat: currentPos.latitude, lng: currentPos.longitude, address: 'Posicin Actual (GPS)'}, ...intermediateReversed, originalStart];
                        const returnRouteObject = { name: `VUELTA: ${route.name}`, waypoints: returnWaypoints };
                        loadRouteFromObject(returnRouteObject, true);
                        addRouteToRecents(returnRouteObject);
                        closeHandler();
                    },
                    (errorMsg) => { showToast(`Error al obtener ubicacin: ${errorMsg}`, "error"); }
                );
            });
        }
        
        li.querySelector('.btn-delete').addEventListener('click', (e) => {
            e.stopPropagation();
            if (isRecent) {
                let recentRoutes = JSON.parse(localStorage.getItem('boardinggate_recent_routes') || "[]");
                recentRoutes = recentRoutes.filter(r => r.name !== route.name);
                localStorage.setItem('boardinggate_recent_routes', JSON.stringify(recentRoutes));
            } else {
                let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
                savedRoutes = savedRoutes.filter(r => r.name !== route.name);
                localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes));
                markCacheAsDirty();
                showToast(`"${route.name}" borrado`, "info");
            }
            displayRoutes(); 
        });
        listElement.appendChild(li);
    };
    
    const displayRoutes = () => {
        const filterText = filterInput.value.toUpperCase().trim();
        clearFilterBtn.style.display = filterText ? 'block' : 'none';

        let recentRoutes = JSON.parse(localStorage.getItem('boardinggate_recent_routes') || "[]");
        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        savedRoutes.sort((a, b) => new Date(b.createdAt || 0).getTime() - new Date(a.createdAt || 0).getTime());

        const recentItemsList = document.getElementById('recent-items-list');
        const recentsTitle = recentItemsList.parentElement.previousElementSibling;
        recentItemsList.innerHTML = '';
        const filteredRecents = recentRoutes.filter(r => r.name.toUpperCase().includes(filterText));
        if (filteredRecents.length > 0) {
            recentsTitle.style.display = 'block';
            filteredRecents.forEach(route => renderRouteListItem(route, recentItemsList, true));
        } else {
            recentsTitle.style.display = 'none';
        }
        
        const recentRouteNames = recentRoutes.map(r => r.name);

        const savedDestinationsList = document.getElementById('saved-destinations-list');
        savedDestinationsList.innerHTML = '';
        const savedDestinations = savedRoutes.filter(r => 
            r.waypoints.length === 1 && 
            !recentRouteNames.includes(r.name) && 
            r.name.toUpperCase().includes(filterText)
        );
        if (savedDestinations.length > 0) {
            savedDestinations.forEach(route => renderRouteListItem(route, savedDestinationsList, false));
        } else {
            savedDestinationsList.innerHTML = `<li class="route-list-empty">No hay destinos guardados que coincidan.</li>`;
        }

        const savedRoutesList = document.getElementById('saved-routes-list');
        savedRoutesList.innerHTML = '';
        const savedMultiStage = savedRoutes.filter(r => 
            r.waypoints.length > 1 && 
            !recentRouteNames.includes(r.name) && 
            r.name.toUpperCase().includes(filterText)
        );
        if (savedMultiStage.length > 0) {
            savedMultiStage.forEach(route => renderRouteListItem(route, savedRoutesList, false));
        } else {
            savedRoutesList.innerHTML = `<li class="route-list-empty">No hay rutas guardadas que coincidan.</li>`;
        }
    };

    filterInput.addEventListener('input', displayRoutes);
    clearFilterBtn.addEventListener('click', () => { filterInput.value = ''; displayRoutes(); });
    displayRoutes();
}

// ===================================================================
// NOMBRE: closeNavigationMap (MODIFICADA - USA RESET CENTRAL)
// RESUMEN: Llama a la funcin de reseteo al cerrar el mapa para asegurar limpieza.
function closeNavigationMap(force = false) {
    hideAddressSuggestionsModal();
    resetNavigationState(); // Llamada a la nueva funcin de reseteo
    
    if (manualZoomTimeout) { clearTimeout(manualZoomTimeout); manualZoomTimeout = null; }
    isManualZoomActive = false;
    isAutoZoomActive = false;
    if (markerAnimationState.animationFrameId) { cancelAnimationFrame(markerAnimationState.animationFrameId); markerAnimationState.animationFrameId = null; }
    isGeolocated = false;

    const wasInDirectToMapModeSession = sessionStorage.getItem('isInDirectToMapMode') === 'true';
    const userPrefersDirectToNav = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
    if (wasInDirectToMapModeSession && userPrefersDirectToNav && !force) {
        sessionStorage.removeItem('isInDirectToMapMode');
        sessionStorage.setItem(TEMP_PREVENT_DIRECT_NAV_KEY, 'true');
        location.reload();
        return;
    }
    directToNavOnLoad = false;
    sessionStorage.removeItem('isInDirectToMapMode');
    isNavigationMapActive = false;
    sessionStorage.removeItem('mapContext');
    if (locationWatchId !== null && navigator.geolocation) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
    if (gpsRetryTimeoutId) { clearTimeout(gpsRetryTimeoutId); gpsRetryTimeoutId = null; }
    gpsRetryAttempt = 0;
    
    const mapModalElement = document.getElementById('reminders-location-map-modal');
    if (mapModalElement) {
        mapModalElement.classList.add('map-modal-hidden');
    }
    
    const simModal = document.getElementById('simulation-modal');
    if (simModal && !simModal.classList.contains('hidden')) {
        if (simulationModalTimer) clearTimeout(simulationModalTimer);
        const simCloseBtn = simModal.querySelector('#close-simulation-modal');
        if (simCloseBtn) clearModalAutoCloseTimer(simModal, simCloseBtn, 'simulation-modal');
        simModal.classList.add('hidden');
        hideIntersectionPreviewMap();
    }

    sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
    hideUnifiedReminderWindow();
    
    if (!directToNavOnLoad) {
        const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'block';
        const footer = document.querySelector('footer'); if (footer) footer.style.display = 'block';
        const noticesContainer = document.querySelector('.notices-icon-container'); if (noticesContainer) noticesContainer.style.display = 'flex';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'flex');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'block');
        const gridFilter = document.getElementById('grid-filter-container'); if (gridFilter) gridFilter.style.display = 'flex';
        renderGrid();
        renderToggleButtons();
        updateButtonStyles();
        filterGridItems();
        setTimeout(adjustButtonPositions, 100);
    }
}
// ===================================================================
// NOMBRE: updateStartNavigationButtonState (CORRECCIN FINAL: SIMULADOR SIEMPRE VISIBLE)
// RESUMEN: Actualiza la visibilidad de los botones de navegacin. Iniciar y Simular GPS ahora siempre estn visibles.
function updateStartNavigationButtonState() {
    const startNavButton = document.getElementById('start-navigation-button');
    const saveRouteButton = document.getElementById('save-route-button');
    const reorderBtn = document.getElementById('reorder-route-stages-button');
    const startNavImg = startNavButton ? startNavButton.querySelector('img') : null;
    const simulateBtn = document.getElementById('simulate-route-button');
    const deleteRouteBtn = document.getElementById('delete-current-route-button');
    const loadRouteBtn = document.getElementById('load-saved-route-button'); 
    const toggleSimulateGpsBtn = document.getElementById('toggle-simulate-gps-button');
    const graphCard = document.getElementById('navigation-graph-card');

    if (!startNavButton || !saveRouteButton || !reorderBtn || !simulateBtn || !loadRouteBtn || !deleteRouteBtn || !toggleSimulateGpsBtn || !graphCard) return;
    
    const hasEnoughWaypointsForRoute = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2;
    const hasRouteData = navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0];
    const canDisplayRoute = hasEnoughWaypointsForRoute && hasRouteData;

    // <<< CORRECCIN DEFINITIVA: Los botones de Iniciar Navegacin y Simular GPS siempre estn visibles >>>
    startNavButton.classList.remove('hidden');
    if (toggleSimulateGpsBtn) toggleSimulateGpsBtn.style.display = 'inline-flex';

    // Se actualiza el icono de Iniciar/Terminar segn el estado
    if (isNavigating || isFreeDriveActive) {
        if(startNavImg) startNavImg.src = "PNG/TERMINARNAVEGACION.PNG";
    } else {
        if(startNavImg) startNavImg.src = "PNG/INICIARNAVEGACION.PNG";
    }
    saveRouteButton.classList.toggle('hidden', !(!isNavigating && canDisplayRoute));
    if (reorderBtn) reorderBtn.style.display = (!isNavigating && canDisplayRoute) ? 'inline-flex' : 'none';
    const canSimulate = (canDisplayRoute || (isNavigating && hasRouteData));
    if(simulateBtn) simulateBtn.style.display = canSimulate ? 'inline-flex' : 'none';
    
    if (deleteRouteBtn) {
        deleteRouteBtn.classList.remove('hidden');
    }
    if (loadRouteBtn) {
        loadRouteBtn.classList.remove('hidden');
    }
    const hasGraphData = graphDataPoints && (graphDataPoints.speed.length > 0 || graphDataPoints.altitude.length > 0);
    graphCard.classList.toggle('hidden', !hasGraphData || currentGraphMode === 'Grfica off');
    
    if (!hasEnoughWaypointsForRoute && !isNavigating && !isFreeDriveActive) {
         if (navigationMapInstance && navigationMapInstance.getLayer('route')) {
             navigationMapInstance.removeLayer('route');
             navigationMapInstance.removeSource('route');
         }
         navigationRouteLayer = null;
         completedSegmentsGeoJSON.features = [];
         if (navigationMapInstance && navigationMapInstance.getSource('completed-segments')) {
             navigationMapInstance.getSource('completed-segments').setData(completedSegmentsGeoJSON);
         }
         navigationCurrentRouteData = null;
         hideNavigationUI();
         hideMapInfoOverlay();
    }
    updateNavigationGraphVisibilityAndMode();
}
    
// ===================================================================
// NOMBRE: updateNavigationGraphVisibilityAndMode
// RESUMEN: Actualiza la visibilidad y modo de la grfica de navegacin.
function updateNavigationGraphVisibilityAndMode() {
    const graphCard = document.getElementById('navigation-graph-card');
    const graphContainer = document.getElementById('navigation-graph-container');
    const graphTitleElement = document.getElementById('navigation-graph-title');
    const compassControl = document.querySelector('.map-control-orientation-altitude');
    if (!graphCard || !graphContainer || !graphTitleElement) {
        return;
    }
    if (compassAndModeControl) {
        compassAndModeControl._updateGraphTitle();
    }
    const isEnlarged = graphCard.classList.contains('enlarged');
    if ((navigationCurrentRouteData || isFreeDriveActive) && currentGraphMode !== 'Grfica off') {
        graphCard.classList.remove('hidden');
        if (!isEnlarged) {
            const compassHeight = compassControl ? compassControl.offsetHeight : 0;
            graphCard.style.height = compassHeight > 0 ? `${compassHeight}px` : '157px';
        }
        if (navigationChart) {
            updateChartData(); 
        } else if (isNavigating || isFreeDriveActive) {
            initializeNavigationGraph();
        }
    } else {
        graphCard.classList.add('hidden');
    }
}    
    
// ===================================================================
// NOMBRE: handlePickerMapClick (NUEVA FUNCIN - PARA MAPBOX)
// RESUMEN: Maneja el clic en el mapa selector de ubicaciones para fijar coordenadas.
function handlePickerMapClick(e, slotIndex) {
    const lngLat = e.lngLat;
    if (locationPickerMarker) {
        locationPickerMarker.setLngLat(lngLat);
    }
    if (!tempSavedLocations[slotIndex]) tempSavedLocations[slotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
    tempSavedLocations[slotIndex].lat = lngLat.lat;
    tempSavedLocations[slotIndex].lng = lngLat.lng;
}
    
    // ===================================================================
    // NOMBRE: updateNavigationButtonColor
    // RESUMEN: Actualiza el color del botn de inicio de navegacin segn el estado.
    function updateNavigationButtonColor() {
        const startNavButton = document.getElementById('start-navigation-button');
        if (startNavButton) {
            if (isNavigating) {
                startNavButton.style.setProperty('background-color', '#000000', 'important');
            } else {
                startNavButton.style.backgroundColor = 'white';
                startNavButton.style.boxShadow = '2px 3px 5px rgba(0,0,0,0.60)';
            }
        }
    }
    
// ===================================================================
// NOMBRE: showToast (MODIFICADA - AADIDO BOTN INTERACTIVO)
function showToast(message, type = 'info', duration = 3000, isErrorNotFound = false, toastId = null) {
    const uniqueToastId = toastId || 'toast-notification-element' + (type === 'debug' ? '-debug' : '') + `-${Date.now()}`;
    
    let currentTopOffset = 180;
    const toastSpacing = 10;
    
    if (type !== 'instructional') {
        activeToasts.forEach(activeToast => {
            const toastElement = document.getElementById(activeToast.id);
            if (toastElement) {
                 currentTopOffset += toastElement.offsetHeight + toastSpacing;
            }
        });
    }

    const existingToast = document.getElementById(uniqueToastId);
    if (existingToast && !toastId) {
        existingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
    } else if (existingToast && toastId) {
         existingToast.remove();
         activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
         currentTopOffset = 180;
         activeToasts.forEach(activeToast => {
            const toastElement = document.getElementById(activeToast.id);
            if (toastElement) {
                currentTopOffset += toastElement.offsetHeight + toastSpacing;
            }
         });
    }
    const toast = document.createElement('div');
    toast.id = uniqueToastId;
    toast.className = `toast-notification toast-${type}`;
    if (isErrorNotFound && type === 'error') {
        toast.classList.add('not-found');
    }
    const messageSpan = document.createElement('span');
    messageSpan.innerHTML = message.replace(/\n/g, '<br>');
    toast.appendChild(messageSpan);
    if (type === 'debug') {
        toast.style.top = 'auto';
        toast.style.bottom = '20px';
        toast.style.right = '20px';
        toast.style.left = 'auto';
        toast.style.transform = 'none';
        toast.style.maxWidth = 'calc(100% - 40px)';
        const closeButtonToast = document.createElement('button');
        closeButtonToast.textContent = 'Cerrar Info Debug';
        closeButtonToast.style.cssText = "display: block; margin-top: 10px; padding: 5px 10px; background-color: rgba(255,255,255,0.2); color: white; border: 1px solid white; border-radius: 3px; cursor: pointer;";
        closeButtonToast.onclick = () => {
            if (toast.parentNode) toast.parentNode.removeChild(toast);
             activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
        };
        toast.appendChild(closeButtonToast);
    }

    if (type === 'instructional') {
        const buttonContainer = document.createElement('div');
        buttonContainer.style.marginTop = '10px';
        const enteradoButton = document.createElement('button');
        enteradoButton.textContent = 'ENTERADO';
        enteradoButton.style.cssText = `
            background-color: rgba(0,0,0,0.3); color: white; border: 1px solid white; 
            padding: 5px 10px; border-radius: 5px; font-weight: bold; cursor: pointer;
        `;
        
        const closeToast = () => {
            if (toast.classList.contains('show')) {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => {
                    if (toast.parentNode) toast.parentNode.removeChild(toast);
                    activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
                }, { once: true });
            } else {
                if (toast.parentNode) toast.parentNode.removeChild(toast);
                activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
            }
        };

        enteradoButton.addEventListener('click', closeToast);
        buttonContainer.appendChild(enteradoButton);
        toast.appendChild(buttonContainer);
        
        toast.style.top = '25px';
        toast.style.right = '15px';
        
    } else {
        toast.style.top = `${currentTopOffset}px`;
    }

    document.body.appendChild(toast);
    activeToasts.push({ id: uniqueToastId, element: toast });
    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            toast.classList.add('show');
        });
    });
    if (duration > 0 && type !== 'debug') {
        setTimeout(() => {
            const toastElement = document.getElementById(uniqueToastId);
            if (toastElement && toastElement.classList.contains('show')) {
                toastElement.classList.remove('show');
                toastElement.addEventListener('transitionend', () => {
                     if (toastElement.parentNode) { toastElement.parentNode.removeChild(toastElement); }
                     activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
                }, { once: true });
            } else if (toastElement) {
                 if (toastElement.parentNode) { toastElement.parentNode.removeChild(toastElement); }
                 activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
            }
        }, duration);
    }
}    
// ===================================================================
// NOMBRE: toggleEnlargedGraph
// RESUMEN: Ampla o reduce la grfica de navegacin.
function toggleEnlargedGraph() {
    const graphCard = document.getElementById('navigation-graph-card');
    const enlargeButton = document.getElementById('enlarge-graph-button');
    const compassControlContainer = document.querySelector('.map-control-orientation-altitude');
    const mapModal = document.getElementById('reminders-location-map-modal');
    if (!graphCard || !enlargeButton || !compassControlContainer || !mapModal) return;
    const isCurrentlyEnlarged = graphCard.classList.contains('enlarged');
    if (!isCurrentlyEnlarged) {
        graphCard.classList.add('enlarged');
        const compassRect = compassControlContainer.getBoundingClientRect();
        const fixedWidth = 995; 
        const fixedHeight = 600; 
        const newLeft = compassRect.left;
        const distanceFromBottom = window.innerHeight - compassRect.bottom;
        const newBottom = distanceFromBottom;
        graphCard.style.left = `${newLeft}px`;
        graphCard.style.bottom = `${newBottom}px`;
        graphCard.style.width = `${fixedWidth}px`;
        graphCard.style.height = `${fixedHeight}px`;
        enlargeButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        `;
        enlargeButton.title = 'Reducir grfica';
    } else {
        graphCard.classList.remove('enlarged');
        graphCard.style.left = '';
        graphCard.style.bottom = '';
        graphCard.style.width = '';
        graphCard.style.height = '';
        graphCard.style.top = '';
        graphCard.style.right = '';
        graphCard.style.transform = '';
        enlargeButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="11" y1="8" x2="11" y2="14"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        `;
        enlargeButton.title = 'Ampliar grfica';
    }
    if (navigationChart) {
        updateChartData(); 
        setTimeout(() => {
            navigationChart.resize();
        }, 200);
    }
    updateNavigationGraphVisibilityAndMode();    
}

// ===================================================================
// NOMBRE: setMapImmersiveMode (NUEVA FUNCIN)
// RESUMEN: Activa o desactiva el modo inmersivo del mapa de forma explcita.
function setMapImmersiveMode(activate) {
    if (isMapImmersiveModeActive === activate) return;

    isMapImmersiveModeActive = activate;
    const mapModal = document.getElementById('reminders-location-map-modal');
    if (mapModal) {
        mapModal.classList.toggle('immersive-mode-active', isMapImmersiveModeActive);
        
        if (!isMapImmersiveModeActive) {
            progressBarForceShowUntil = Date.now() + 20000;
            const progressBar = document.getElementById('navigation-bottom-progress-bar');
            if (progressBar) {
                progressBar.classList.remove('progress-bar-auto-hidden');
            }
        }
        
        if (navigationMapInstance) {
            setTimeout(() => {
                try {
                    navigationMapInstance.resize();
                } catch(e) { console.error("Error al redimensionar mapa en setMapImmersiveMode:", e); }
            }, 350);
        }
    }
}
// ===================================================================
// NOMBRE: hideAutoStartNavigationModal (MODIFICADA)
// RESUMEN: Oculta el modal de inicio y restaura la posicin de la barra de progreso.
function hideAutoStartNavigationModal() {
    if (autoStartNavModalTimer) {
        clearInterval(autoStartNavModalTimer);
        autoStartNavModalTimer = null;
    }
    const modal = document.getElementById('auto-start-nav-modal');
    if (modal) {
        modal.remove();
    }
    
    const progressBar = document.getElementById('navigation-bottom-progress-bar');
    if (progressBar) {
        progressBar.classList.remove('progress-bar-partially-hidden');
    }
}    

// ===================================================================
// NOMBRE: toggleMapImmersiveMode (CORREGIDA - USA RESIZE)
// RESUMEN: Activa o desactiva el modo inmersivo del mapa para ocultar los controles.
function toggleMapImmersiveMode() {
    isMapImmersiveModeActive = !isMapImmersiveModeActive;
    const mapModal = document.getElementById('reminders-location-map-modal');
    if (mapModal) {
        mapModal.classList.toggle('immersive-mode-active', isMapImmersiveModeActive);
        
        if (!isMapImmersiveModeActive) {
            progressBarForceShowUntil = Date.now() + 20000;
            const progressBar = document.getElementById('navigation-bottom-progress-bar');
            if (progressBar) {
                progressBar.classList.remove('progress-bar-auto-hidden');
            }
        }
        
        if (navigationMapInstance) {
            setTimeout(() => {
                try {
                    navigationMapInstance.resize();
                } catch(e) { console.error("Error al redimensionar mapa en toggleMapImmersiveMode:", e); }
            }, 350);
        }
    }
    showToast(isMapImmersiveModeActive ? 'Modo Inmersivo Activado' : 'Modo Inmersivo Desactivado', 'info');
}
        
// ===================================================================
// NOMBRE: reactivateRealGpsAfterSimulation (MODIFICADA - PARA MAPBOX)
// RESUMEN: Reactiva el seguimiento del GPS real despus de una simulacin.
function reactivateRealGpsAfterSimulation() {
    if (locationWatchId === null && 'geolocation' in navigator && 'watchPosition' in navigator.geolocation) {
        locationWatchId = navigator.geolocation.watchPosition(
            (position) => {
                if (isSimulatingGpsLocation) return;
                const coordsForUpdate = {
                     latitude: position.coords.latitude, longitude: position.coords.longitude,
                     accuracy: position.coords.accuracy, heading: position.coords.heading,
                     altitude: position.coords.altitude, speed: position.coords.speed
                };
                navigationCurrentLocation = coordsForUpdate;
                updateInitialUserPosition(coordsForUpdate, navigationMapInstance);
                 if(isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
                    const routeForDistCalc = navigationCurrentRouteData.routes[0];
                    let carDistTurf = 0;
                    if (routeForDistCalc.geometry && typeof turf !== 'undefined') {
                        try {
                            const carPointTurf = turf.point([coordsForUpdate.longitude, coordsForUpdate.latitude]);
                            const routeLineStringTurf = turf.lineString(routeForDistCalc.geometry.coordinates);
                            const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                            const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                            carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                        } catch(e){
                        }
                    }
                    const totalRouteLength = routeForDistCalc.distance;
                     if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                        if (carDistTurf < lastCarDistanceAlongRouteForNavLogic - 100 && lastCarDistanceAlongRouteForNavLogic > 100) {
                        } else {
                            lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                        }
                    } else if (carDistTurf > totalRouteLength + 500) {
                        lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
                    }
                    updateTurnByTurnDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                    updateNavigationProgressDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                }
            },
            (error) => {
                showToast(`Error al reactivar GPS: ${error.message}`, "warning");
            },
            { enableHighAccuracy: true, timeout: 15000, maximumAge: 3000, distanceFilter: 3 }
        );
        getCurrentLocation(coords => {
            if (!isSimulatingGpsLocation) {
                navigationCurrentLocation = coords;
                updateInitialUserPosition(coords, navigationMapInstance);
                if (isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
                    const routeForDistCalc = navigationCurrentRouteData.routes[0];
                    let carDistTurf = 0;
                     if (routeForDistCalc.geometry && typeof turf !== 'undefined') {
                        try {
                            const carPointTurf = turf.point([coords.longitude, coords.latitude]);
                            const routeLineStringTurf = turf.lineString(routeForDistCalc.geometry.coordinates);
                            const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                            const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                            carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                        } catch(e){
                        }
                     }
                    const totalRouteLength = routeForDistCalc.distance;
                     if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                        if (carDistTurf < lastCarDistanceAlongRouteForNavLogic - 100 && lastCarDistanceAlongRouteForNavLogic > 100) {
                        }
                        lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                    } else if (carDistTurf > totalRouteLength + 500) {
                        lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
                    }
                    updateTurnByTurnDisplay(routeForDistCalc, carDistTurf);
                    updateNavigationProgressDisplay(routeForDistCalc, carDistTurf);
                }
            }
        });
    }
}
// ===================================================================
// NOMBRE: animateMarkerAndMap (VERSIN CORREGIDA - YA NO CONTROLA EL MAPA)
// RESUMEN: Bucle de animacin que mueve y rota suavemente el ICONO del coche.
// ===================================================================
function animateMarkerAndMap(timestamp) {
    if (!markerAnimationState.lastTimestamp) {
        markerAnimationState.lastTimestamp = timestamp;
        markerAnimationState.animationFrameId = requestAnimationFrame(animateMarkerAndMap);
        return;
    }

    const deltaTime = timestamp - markerAnimationState.lastTimestamp;
    markerAnimationState.lastTimestamp = timestamp;

    const LERP_RATE = 0.005; 
    const ROTATION_LERP_RATE = 0.006;
    const lerpFactor = 1.0 - Math.exp(-deltaTime * LERP_RATE);
    const rotationLerpFactor = 1.0 - Math.exp(-deltaTime * ROTATION_LERP_RATE);

    if (markerAnimationState.currentLngLat && markerAnimationState.targetLngLat) {
        markerAnimationState.currentLngLat.lng += (markerAnimationState.targetLngLat.lng - markerAnimationState.currentLngLat.lng) * lerpFactor;
        markerAnimationState.currentLngLat.lat += (markerAnimationState.targetLngLat.lat - markerAnimationState.currentLngLat.lat) * lerpFactor;
        if (initialUserLocationMarker) {
            initialUserLocationMarker.setLngLat(markerAnimationState.currentLngLat);
        }
    }

    // Rotar el icono del marcador
    let deltaIconRotation = markerAnimationState.targetIconRotation - markerAnimationState.currentIconRotation;
    if (deltaIconRotation > 180) deltaIconRotation -= 360;
    if (deltaIconRotation < -180) deltaIconRotation += 360;
    markerAnimationState.currentIconRotation += deltaIconRotation * rotationLerpFactor;
    if (initialUserLocationMarker) {
        initialUserLocationMarker.setRotation(markerAnimationState.currentIconRotation);
    }
    
    markerAnimationState.animationFrameId = requestAnimationFrame(animateMarkerAndMap);
}    
    
// ===================================================================
// NOMBRE: getRouteStyleProperties (VERSIN CORREGIDA)
// RESUMEN: Devuelve el estilo correcto para la ruta (amarillo para satlite/hbrido, azul para calles).
function getRouteStyleProperties() {
    let activeLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "HBRIDO";
    const isStreetsView = activeLayerName === 'CALLES';
    
    return {
        'line-color': isStreetsView ? 'blue' : 'yellow',        
        'line-width': (navigationMapInstance && navigationMapInstance.getPitch() > 20) ? 16 : 12,
        'line-opacity': isStreetsView ? 0.6 : 0.8
    };
}
    
// ===================================================================
// NOMBRE: parseReminderText
// RESUMEN: Parsea el texto de un recordatorio para extraer fecha, hora, repeticin, etc.
function parseReminderText(text, elementsToUpdate = null) {
    const result = { text: `<b>${text.trim().toUpperCase()}</b>`, time: null, date: null, repeatDays: [], intervalDays: null, type: null, isLocationEnabled: false, locationCoordinates: null, radiusMeters: 350, excludeFromList: false };
    let norm = text.toUpperCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    const numW = { 'UNA': 1, 'UNO': 1, 'DOS': 2, 'TRES': 3, 'CUATRO': 4, 'CINCO': 5, 'SEIS': 6, 'SIETE': 7, 'OCHO': 8, 'NUEVE': 9, 'DIEZ': 10, 'ONCE': 11, 'DOCE': 12, 'TRECE': 13, 'CATORCE': 14, 'QUINCE': 15, 'DIECISEIS': 16, 'DIECISIETE': 17, 'DIECIOCHO': 18, 'DIECINUEVE': 19, 'VEINTE': 20, 'VEINTIUNO': 21, 'VEINTIDOS': 22, 'VEINTITRES': 23, 'VEINTICUATRO': 24, 'VEINTICINCO': 25, 'VEINTISEIS': 26, 'VEINTISIETE': 27, 'VEINTIOCHO': 28, 'VEINTINUEVE': 29, 'TREINTA': 30, 'TREINTAYUNO': 31 }; const tRgx = /\b(\d{1,2}):(\d{2})\b/; const ttRgx = /.*\bA\s*LAS?\s*(\d+|\w+)\s*(?:Y\s*(CUARTO|MEDIA|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA)|MENOS\s*(CUARTO|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA))?\s*(DE\s*LA\s*(MANANA|TARDE|NOCHE))?/i; const tM = norm.match(tRgx); if (tM) { let h = parseInt(tM[1]); let m = parseInt(tM[2]); if (h >= 0 && h <= 23 && m >= 0 && m <= 59) result.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`; } else { const ttM = norm.match(ttRgx); if (ttM) { let h = numW[ttM[1].toUpperCase()] || parseInt(ttM[1]); if (!isNaN(h)) { const minTxt = ttM[2]?.toUpperCase() || ''; const minus = ttM[3]?.toUpperCase() || ''; const period = ttM[5]?.toUpperCase() || null; let m = 0; if (minTxt) m = minTxt === 'CUARTO' ? 15 : minTxt === 'MEDIA' ? 30 : numW[minTxt] || parseInt(minTxt) || 0; else if (minus) { m = minus === 'CUARTO' ? 15 : numW[minus] || parseInt(minus) || 0; h = (h - 1 + 24) % 24; m = (60 - m + 60) % 60; } if (period) { if (period === 'TARDE' && h >= 1 && h <= 11) h += 12; if (period === 'NOCHE' && h >= 1 && h <= 11) h += 12; if (period === 'MANANA' && h === 12) h = 0; if (period === 'TARDE' && h === 12) h = 12; if (period === 'NOCHE' && h === 12) h = 0; } else if (h >= 1 && h <= 5) h += 12; if (h >= 0 && h <= 23 && m >= 0 && m <= 59) result.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`; } } } const daysMap = { 'LUNES': 1, 'MARTES': 2, 'MIERCOLES': 3, 'MIRCOLES': 3, 'JUEVES': 4, 'VIERNES': 5, 'SABADO': 6, 'SBADO': 6, 'DOMINGO': 0 }; const wRgx = /(TODOS\s+LOS|LOS|CADA)?\s*(LUNES|MARTES|MIERCOLES|MIRCOLES|JUEVES|VIERNES|SABADO|SBADO|DOMINGO)/g; let wM; while ((wM = wRgx.exec(norm)) !== null) { const day = daysMap[wM[2]]; if (day !== undefined && !result.repeatDays.includes(day)) result.repeatDays.push(day); }
    const now = new Date(); const manDRgx = /(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{2}|\d{4})\b/; const manDM = norm.match(manDRgx);
    if (manDM && !result.date) { let d = parseInt(manDM[1]); let m = parseInt(manDM[2]); let y = parseInt(manDM[3]); if (y >= 0 && y <= 99) y += 2000; if (d >= 1 && d <= 31 && m >= 1 && m <= 12 && y >= 2000 && y <= 2099) { const tD = new Date(Date.UTC(y, m - 1, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() + 1 === m && tD.getUTCFullYear() === y) { result.date = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } } }
    const todayRgx = /\bHOY\b/; const tomRgx = /\bMANANA\b/; const dayAftRgx = /\bPASADO\s*MANANA\b/;
    if (!result.date) { if (norm.match(todayRgx)) { result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (norm.match(dayAftRgx)) { const tD = new Date(now); tD.setDate(now.getDate() + 2); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } else if (norm.match(tomRgx)) { const tD = new Date(now); tD.setDate(now.getDate() + 1); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } }
    const dndRgx = /(?:EL\s*(PROXIMO)?\s*)?(LUNES|MARTES|MIERCOLES|MIRCOLES|JUEVES|VIERNES|SABADO|SBADO|DOMINGO)/i; const dndM = norm.match(dndRgx);
    if (dndM && !result.date) { const tDN = dndM[2].toUpperCase(); const tD = daysMap[tDN]; if (tD !== undefined) { const curD = now.getDay(); let dU = (tD - curD + 7) % 7; if (dU === 0) dU = 7; if (dndM[1]?.toUpperCase() === 'PROXIMO') dU += 7; const target = new Date(now); target.setDate(now.getDate() + dU); result.date = `${target.getFullYear()}-${(target.getMonth() + 1).toString().padStart(2, '0')}-${target.getDate().toString().padStart(2, '0')}`; } }
    const didRgx = /DENTRO\s*DE\s*(\d+)\s*DIAS?/; const didM = norm.match(didRgx);
    if (didM && !result.date) { const d = parseInt(didM[1]); if (!isNaN(d) && d > 0) { const tD = new Date(now); tD.setDate(now.getDate() + d); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } }
    const dsdRgx = /\bEL\s*DIA\s*(\d{1,2})\b/; const dsdM = norm.match(dsdRgx);
    if (dsdM && !result.date) { const d = parseInt(dsdM[1]); if (!isNaN(d) && d >= 1 && d <= 31) { let tM = now.getMonth(); let tY = now.getFullYear(); if (d < now.getDate()) { tM++; if (tM > 11) { tM = 0; tY++; } } const tD = new Date(Date.UTC(tY, tM, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() === tM) { result.date = `${tY}-${(tM + 1).toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } } }
    const intRgx = /CADA\s*(\d+)\s*DIAS?/; const intM = norm.match(intRgx);
    if (intM) { result.intervalDays = parseInt(intM[1]); if (!result.date) { result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } }
    const timRgx = /(ALARMA|AVISO|AVISAR|AVISARME|AVSAME|TEMPORIZADOR|TIMER|RECORDAR|RECORDARME|RECURDAME)\b.*?\b(\d+|\w+)\s*(MINUTOS?|HORAS?|MINS?|HRS?)/i; const timM = norm.match(timRgx);
    if (timM) { const valStr = timM[2]; const unit = timM[3]?.toUpperCase(); let val = numW[valStr.toUpperCase()] || parseInt(valStr); if (!isNaN(val) && val > 0 && unit) { let tmc = 0; if (unit.startsWith('HORA') || unit.startsWith('HR')) { tmc = val * 60; } else if (unit.startsWith('MINUTO') || unit.startsWith('MIN')) { tmc = val; }
            if (tmc > 0) { const endT = new Date(Date.now() + tmc * 60000); result.date = `${endT.getFullYear()}-${(endT.getMonth() + 1).toString().padStart(2, '0')}-${endT.getDate().toString().padStart(2, '0')}`; result.time = `${endT.getHours().toString().padStart(2, '0')}:${endT.getMinutes().toString().padStart(2, '0')}`; result.repeatDays = []; result.intervalDays = null; result.type = 'simple'; } } }
    
    const locationPhrases = ["EN EL LUGAR", "EN EL SITIO", "EN LA UBICACION", "EN LA LOCALIZACION"];
    if (locationPhrases.some(phrase => norm.includes(phrase)) || norm.includes("RADAR")) {
        result.isLocationEnabled = true;
    }
    
    const radiusRgx = /(?:RADIO|MARGEN)\s*DE\s*(\d+)\s*METROS?/i; const radiusMatch = norm.match(radiusRgx);
    if (radiusMatch && radiusMatch[1]) { const parsedRadius = parseInt(radiusMatch[1]); if (!isNaN(parsedRadius) && parsedRadius > 0) { result.radiusMeters = parsedRadius; result.isLocationEnabled = true; } }
    const excludePhrases = ["NO LISTAR", "NO MOSTRAR EN LISTA", "EXCLUIR LISTA", "OCULTAR LISTA", "RADAR"]; if (excludePhrases.some(phrase => norm.includes(phrase))) { result.excludeFromList = true; }
    if (norm.toUpperCase().startsWith("<b>RADAR") && result.radiusMeters === 350 && !radiusMatch) {
        result.radiusMeters = 350;
    } else if (result.radiusMeters === 350 && !norm.toUpperCase().startsWith("<b>RADAR") && !radiusMatch && !excludePhrases.some(phrase => norm.includes(phrase))) {
        result.radiusMeters = 350;
    }
    if (result.type === null) {
        if (result.intervalDays !== null && result.date) { result.type = 'interval'; } else if (result.repeatDays.length > 0 && result.time) { result.type = 'weekly'; } else if (result.date && result.time) { result.type = 'daily'; } else if (result.time) { result.type = 'daily'; if (!result.date) result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (result.date) { result.type = 'daily'; } else { result.type = 'simple'; } }
    if (!result.time && (result.type === 'daily' || result.type === 'weekly' || result.type === 'interval' )) { result.time = '00:01'; }
    if (elementsToUpdate) {
         if (elementsToUpdate.locationCheckbox) { const shouldBeChecked = result.isLocationEnabled; if (elementsToUpdate.locationCheckbox.checked !== shouldBeChecked && !elementsToUpdate.mapExpandedManually) { elementsToUpdate.locationCheckbox.checked = shouldBeChecked; } }
         if (elementsToUpdate.radiusInput) { elementsToUpdate.radiusInput.value = result.radiusMeters; }
         if (!elementsToUpdate.manualTimeInput && elementsToUpdate.timeInput && result.time) { elementsToUpdate.timeInput.value = result.time; }
         if (elementsToUpdate.dateInput && result.date) { const dateParts = result.date.split('-');
         if(dateParts.length === 3) { elementsToUpdate.dateInput.value = `${dateParts[2]}/${dateParts[1]}/${dateParts[0]}`; } else { elementsToUpdate.dateInput.value = ''; } } else if (elementsToUpdate.dateInput) { elementsToUpdate.dateInput.value = ''; }
         if (elementsToUpdate.intervalInput) { elementsToUpdate.intervalInput.value = result.intervalDays || ''; }
         if (elementsToUpdate.repeatCheckboxes && result.repeatDays && result.repeatDays.length > 0) { elementsToUpdate.repeatCheckboxes.forEach(input => { input.checked = result.repeatDays.includes(parseInt(input.value)); }); } else if (elementsToUpdate.repeatCheckboxes) { elementsToUpdate.repeatCheckboxes.forEach(input => { input.checked = false; }); }
         if (elementsToUpdate.excludeFromListCheckbox) { elementsToUpdate.excludeFromListCheckbox.checked = result.excludeFromList; }
    } return result;
}

// ===================================================================
// NOMBRE: displayAddressSuggestionsModal (VERSIN FINAL Y CORRECTA)
// RESUMEN: La correccin clave es que ahora elimina la clase '.hidden'
function displayAddressSuggestionsModal(suggestions) {
    const searchInput = document.getElementById('map-location-search-input');
    if (!searchInput) return;

    const modalId = 'address-suggestions-modal';
    let modal = document.getElementById(modalId);
    
    if (!modal) {
        modal = document.createElement('div');
        modal.id = modalId;
        modal.className = 'address-suggestions-modal';
        modal.style.zIndex = '11005 !important'; 
        modal.innerHTML = `
            <h2 id="address-suggestions-title"></h2>
            <ul id="address-suggestions-list"></ul>
            <div class="modal-top-buttons" style="justify-content: flex-end; margin-top: 1rem;">
                <button id="close-address-suggestions-modal" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
            </div>
        `;
        document.body.appendChild(modal); 
        const closeButton = modal.querySelector('#close-address-suggestions-modal');
        closeButton.addEventListener('click', hideAddressSuggestionsModal);
    }
    
    const titleElement = modal.querySelector('#address-suggestions-title');
    const listElement = modal.querySelector('#address-suggestions-list');
    const closeButton = modal.querySelector('#close-address-suggestions-modal');
    
    clearModalAutoCloseTimer(modal, closeButton, 'address-suggestions-modal');

    if (suggestions.length === 0) {
        titleElement.textContent = "No se encontraron coincidencias";
        listElement.innerHTML = '<li style="cursor: default; background-color: #a09888; color: #444;">Prueba con trminos ms generales.</li>';
        modal.classList.remove('hidden'); 

        addModalAutoCloseTimer(modal, closeButton, 'address-suggestions-modal', 5000); 
        return;
    }
    
    titleElement.textContent = `${suggestions.length} coincidencia${suggestions.length !== 1 ? 's' : ''} encontrada${suggestions.length !== 1 ? 's' : ''}`;
    listElement.innerHTML = '';
    suggestions.forEach(suggestion => {
        const li = document.createElement('li');
        li.textContent = suggestion.display_name;
        li.dataset.lat = suggestion.lat;
        li.dataset.lon = suggestion.lon;
        
        li.addEventListener('click', async () => {
            const lat = parseFloat(li.dataset.lat);
            const lon = parseFloat(li.dataset.lon);
            const displayName = li.textContent;
            
            if (isNaN(lat) || isNaN(lon)) {
                showToast("Error: Coordenadas de sugerencia no vlidas.", "error");
                return;
            }

            hideAddressSuggestionsModal();
            showToast("Ajustando a la carretera ms cercana...", "info", 3000);
            
            const snappedLatLng = await snapCoordsToRoad(lat, lon);
            await addWaypoint(snappedLatLng, displayName);

            if (navigationMapInstance) navigationMapInstance.flyTo({ center: [lon, lat], zoom: 15 });
            if (searchInput) {
                searchInput.value = '';
                searchInput.dispatchEvent(new Event('input'));
            }
            showToast("Ubicacin aadida a la ruta", "success");
        });
      
        listElement.appendChild(li);
    });
    
    const searchInputRect = searchInput.getBoundingClientRect();
    modal.style.top = `${searchInputRect.bottom + 5}px`;
    const viewportHeight = window.innerHeight;
    const modalTop = searchInputRect.bottom + 5;
    const availableHeight = viewportHeight - modalTop - 20;
    modal.style.maxHeight = `${availableHeight}px`;
    const titleHeight = titleElement.offsetHeight;
    const buttonsHeight = modal.querySelector('.modal-top-buttons').offsetHeight;
    const listMaxHeight = availableHeight - titleHeight - buttonsHeight - 30;
    listElement.style.maxHeight = `${Math.max(100, listMaxHeight)}px`;
    
    modal.classList.remove('hidden');
    
    addModalAutoCloseTimer(modal, closeButton, 'address-suggestions-modal', 30000);
}

// ===================================================================
// NOMBRE: stopAutomatedRouteSimulationInternal (NUEVA FUNCIN - CORRECCIN)
// RESUMEN: Detiene el intervalo de la simulacin automtica y limpia su ID. Es la funcin auxiliar que faltaba.
function stopAutomatedRouteSimulationInternal() {
    if (automatedSimulationIntervalId) {
        clearInterval(automatedSimulationIntervalId);
        automatedSimulationIntervalId = null;
    }
}
                  
// ===================================================================
// NOMBRE: fetchRouteData (MODIFICADA - DEVUELVE EL SERVICIO USADO)
// RESUMEN: Pide siempre UNA SOLA ruta por defecto y ahora devuelve el
async function fetchRouteData(coordsString, startHeading = null) {
    const MAPBOX_PRIMARY_KEY = 'boardinggate_useMapboxAsPrimary';
    const useMapboxAsPrimary = localStorage.getItem(MAPBOX_PRIMARY_KEY) === 'true'; // Corregido: Era `!== 'true'`
  
    const osrmService = {
        name: 'OSRM',
        buildUrl: (coords) => {
            return `${OSRM_SERVICE_URL}/driving/${coords}?overview=full&geometries=geojson&steps=true&alternatives=false&annotations=true`;
        },
        processResponse: async (response) => {
            if (!response.ok) {
                let errorData = { message: `OSRM HTTP error ${response.status}` };
                try { errorData = await response.json(); } catch (e) {}
                throw new Error(errorData.code || errorData.message || response.statusText);
            }
            const data = await response.json();
            if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) {
                throw new Error(data.message || "No se encontraron rutas en OSRM.");
            }
            return { routeData: data, serviceUsed: 'OSRM' }; // Devuelve el servicio usado
        }
    };

    const mapboxService = {
        name: 'Mapbox',
        buildUrl: (coords) => {
            return `https://api.mapbox.com/directions/v5/mapbox/driving/${coords}?alternatives=false&geometries=geojson&overview=full&steps=true&access_token=${MAPBOX_ACCESS_TOKEN}`;
        },
        processResponse: async (response) => {
            if (!response.ok) {
                let errorData = { message: `Mapbox HTTP error ${response.status}` };
                try { errorData = await response.json(); } catch (e) {}
                throw new Error(errorData.message || response.statusText);
            }
            const data = await response.json();
            if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) {
                throw new Error(data.message || "No se encontraron rutas en Mapbox.");
            }
            const adaptedRoute = adaptMapboxRouteToOSRMFormat(data.routes[0]);
            const adaptedWaypoints = data.waypoints.map(wp => ({
                distance: wp.distance,
                hint: wp.hint,
                location: wp.location,
                name: wp.name,
            }));
            const finalData = {
                code: 'Ok',
                routes: [adaptedRoute],
                waypoints: adaptedWaypoints
            };
            return { routeData: finalData, serviceUsed: 'Mapbox' }; // Devuelve el servicio usado
        }
    };

    const buildUrlWithCorrectBearings = (service, coords) => {
        let baseUrl = service.buildUrl(coords).split('?')[0];
        let params = new URLSearchParams(service.buildUrl(coords).split('?')[1] || '');

        if (startHeading !== null && !isNaN(startHeading)) {
            const waypointCount = (coords.match(/;/g) || []).length + 1;
            let bearingsString = `${Math.round(startHeading)},45`;
            if (waypointCount > 1) {
                bearingsString += ';'.repeat(waypointCount - 1);
            }
            params.set('bearings', bearingsString);
        } else {
            params.delete('bearings'); 
        }
        
        return `${baseUrl}?${params.toString()}`;
    };

    const primaryService = useMapboxAsPrimary ? mapboxService : osrmService;
    const fallbackService = useMapboxAsPrimary ? osrmService : mapboxService;

    try {
        const primaryUrl = buildUrlWithCorrectBearings(primaryService, coordsString);
        const primaryResponse = await fetch(primaryUrl);
        return await primaryService.processResponse(primaryResponse);
    } catch (primaryError) {
        showToast(`Servicio principal (${primaryService.name}) fall. Intentando con respaldo (${fallbackService.name})...`, "warning", 4000);
        
        try {
            const fallbackUrl = buildUrlWithCorrectBearings(fallbackService, coordsString);
            const fallbackResponse = await fetch(fallbackUrl);
            const fallbackData = await fallbackService.processResponse(fallbackResponse);
            fallbackData.serviceUsed += ' (Respaldo)';
            return fallbackData;
        } catch (fallbackError) {
            return { error: fallbackError, failedServices: `${primaryService.name} (Fallo), ${fallbackService.name} (Fallo)` };
        }
    }
}  



    
// ===================================================================
// NOMBRE: handleSimulateGpsPositionClick (MODIFICADA - PARA MAPBOX)
// RESUMEN: Maneja el clic en el mapa durante la simulacin GPS manual.
function handleSimulateGpsPositionClick(e, forceExactPosition = false) {
    if (!isSimulatingGpsLocation || !navigationMapInstance) return;

    navigationFollowUser = true;
    shouldCenterOnUser = true;
    clearLocateMeReactivationTimer(); updateLocateMeButtonsUI(); 

    
    if (automatedSimulationIntervalId) {
        wasSimulatingBeforeRecalc = true;
        stopAutomatedRouteSimulationInternal();
        showToast("Simulacin automtica pausada. Forzando desvo...", "info");
    }
    let lngLatToUse = [e.lngLat.lng, e.lngLat.lat]; 
    
    if (!forceExactPosition && navigationMapInstance.getSource('route') && typeof turf !== 'undefined' && navigationMapInstance.getSource('route')._data) {
        const routeGeoJSON = navigationMapInstance.getSource('route')._data;
        if (routeGeoJSON && routeGeoJSON.type === 'Feature' && routeGeoJSON.geometry && routeGeoJSON.geometry.coordinates) {
            const routeLineString = turf.lineString(routeGeoJSON.geometry.coordinates);
            const clickPoint = turf.point(lngLatToUse);
            const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, clickPoint, { units: 'meters' });
            
            if (nearestPointOnRoute && nearestPointOnRoute.properties.dist !== undefined && nearestPointOnRoute.properties.dist < 50) { 
                lngLatToUse = nearestPointOnRoute.geometry.coordinates;
            }
        }
    }

    simulatedGpsLocation = {
        latitude: lngLatToUse[1],
        longitude: lngLatToUse[0],
        accuracy: 10,
        heading: navigationCurrentLocation ? navigationCurrentLocation.heading : 0,
        altitude: navigationCurrentLocation ? navigationCurrentLocation.altitude : 0,
        speed: 0
    };
    processSimulatedGpsPosition(true); 
    setNavigationMapClickHandler(); 
}        

// ===================================================================
// NOMBRE: setNavigationMapClickHandler (VERSIN SIMPLIFICADA)
// RESUMEN: nicamente gestiona el estado visual del mapa (clases y cursor) segn el modo actual.
// ===================================================================
function setNavigationMapClickHandler() {
    const mapDiv = document.getElementById('reminders-location-map-div');
    if (!navigationMapInstance || !mapDiv) return;

    // Limpia todos los estados visuales
    mapDiv.classList.remove('add-reminder-mode', 'simulating-gps-click-mode', 'navigating');
    const canvas = navigationMapInstance.getCanvas();
    if(canvas) canvas.style.cursor = ''; // Restaura cursor por defecto

    // Aplica el estado visual correcto segn el modo
    if (isAddReminderAtLocationModeActive) {
        mapDiv.classList.add('add-reminder-mode');
        // El cursor se gestiona con CSS a travs de la clase .add-reminder-mode
    } else if (isSimulatingGpsLocation) {
        mapDiv.classList.add('simulating-gps-click-mode');
        // El cursor se gestiona con CSS a travs de la clase .simulating-gps-click-mode
    } else if (isNavigating) {
        mapDiv.classList.add('navigating');
        if(canvas) canvas.style.cursor = 'default';
    } else {
        // Modo de planificacin por defecto
        if(canvas) canvas.style.cursor = 'crosshair';
    }
} 
// ===================================================================
// NOMBRE: showSimulationSpeedModal (MODIFICADA - AADIDO TEXTO DE AYUDA PARA DESVOS)
// RESUMEN: Muestra un modal para que el usuario introduzca la velocidad de simulacin y elija el modo, incluyendo ahora una nota sobre cmo simular desvos.
function showSimulationSpeedModal(defaultSpeed, callback) {
    closeOtherModals('simulation-speed-modal');
    let modal = document.getElementById('simulation-speed-modal');
    if (modal) modal.remove();
    modal = document.createElement('div');
    modal.id = 'simulation-speed-modal';
    modal.innerHTML = `
        <h2>Velocidad y Modo de Simulacin</h2>
        <div class="filter-group" style="margin-bottom: 20px;">
            <label id="speed-range-label">Velocidad: ${defaultSpeed} km/h</label>
            <div class="slider-container single-slider-container" style="height: 25px;">
                <div class="slider-track"></div>
                <div class="slider-range" id="speed-slider-range"></div>
                <div class="slider-thumb" id="speed-thumb" style="left: 0%;"></div>
            </div>
        </div>
        <div class="modal-top-buttons" style="flex-direction: column; gap: 10px;">
            <button id="confirm-navigation-simulation" style="background-color: #28a745; color: white;">Simular Navegacin Normal <span class="button-countdown-timer"></span></button>
            <button id="confirm-freedrive-simulation" style="background-color: #34D399; color: #111827; font-weight: bold;">Recorrer en Modo Free Drive</button>
            <button id="cancel-simulation-speed" style="background-color: #6c757d; color: white;">Cancelar</button>
        </div>
        <!-- AADIDO: Prrafo de ayuda para simular desvos -->
        <p style="font-size: 0.85rem; color: #444; margin-top: 1.5rem; text-align: left; font-style: italic; border-top: 1px solid #ccc; padding-top: 10px;">
            (*) Para simular DESVIOS, carga una ruta, luego pulsa simulacin y cuando quieras pincha en el mapa para probar un desvio desde ese punto</p>
    `;
    document.body.appendChild(modal);

    const speedSliderContainer = modal.querySelector('#speed-thumb').parentElement;
    const speedThumb = modal.querySelector('#speed-thumb');
    const speedRange = modal.querySelector('#speed-slider-range');
    const speedLabel = modal.querySelector('#speed-range-label');
    const minSpeed = 1;
    const maxSpeed = 5000;
    let currentSpeed = defaultSpeed || 90;

    const updateSpeedVisuals = () => {
        const minLog = Math.log(minSpeed);
        const maxLog = Math.log(maxSpeed);
        const percent = (Math.log(currentSpeed) - minLog) / (maxLog - minLog);
        
        speedThumb.style.left = `${percent * 100}%`;
        speedRange.style.width = `${percent * 100}%`;
        speedLabel.textContent = `Velocidad: ${Math.round(currentSpeed)} km/h`;
    };

    const onSpeedDrag = (e) => {
        const rect = speedSliderContainer.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        let percent = (clientX - rect.left) / rect.width;
        percent = Math.max(0, Math.min(1, percent));
        
        const minLog = Math.log(minSpeed);
        const maxLog = Math.log(maxSpeed);
        currentSpeed = Math.exp(minLog + percent * (maxLog - minLog));
        
        updateSpeedVisuals();
    };

    const startSpeedDrag = (e) => {
        const moveHandler = (moveEvent) => onSpeedDrag(moveEvent);
        const endDrag = () => {
            document.removeEventListener('mousemove', moveHandler);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchmove', moveHandler);
            document.removeEventListener('touchend', endDrag);
        };
        document.addEventListener('mousemove', moveHandler);
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchmove', moveHandler);
        document.addEventListener('touchend', endDrag);
    };
    
    speedThumb.addEventListener('mousedown', startSpeedDrag);
    speedThumb.addEventListener('touchstart', startSpeedDrag);
    updateSpeedVisuals();
    
    const confirmNavBtn = modal.querySelector('#confirm-navigation-simulation');
    const confirmFreeDriveBtn = modal.querySelector('#confirm-freedrive-simulation');
    const cancelBtn = modal.querySelector('#cancel-simulation-speed');
    
    const closeHandler = () => {
        clearModalAutoCloseTimer(modal, confirmNavBtn, 'simulation-speed-modal');
        if (modal.parentNode) modal.remove();
    };

    confirmNavBtn.addEventListener('click', () => {
        isSimulatingFreeDrive = false; 
        callback(Math.round(currentSpeed));
        closeHandler();
    });

    confirmFreeDriveBtn.addEventListener('click', () => {
        isSimulatingFreeDrive = true; 
        callback(Math.round(currentSpeed));
        closeHandler();
    });

    cancelBtn.addEventListener('click', () => {
        showToast("Inicio de simulacin cancelado", "info");
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) simulateGpsButton.classList.remove('active-simulate-gps-mode');
        isSimulatingGpsLocation = false;
        reactivateRealGpsAfterSimulation();
        setNavigationMapClickHandler();
        closeHandler();
    });

    addModalAutoCloseTimer(modal, confirmNavBtn, 'simulation-speed-modal', 30000);
}    

// ===================================================================
// NOMBRE: showHelpModal
// RESUMEN: Muestra el modal de ayuda con ejemplos de uso para crear recordatorios.
function showHelpModal(options = {}) {
    const modal = document.createElement('div');
    modal.className = 'help-modal reminder-modal'; 
    modal.setAttribute('aria-label', 'Ayuda recordatorios');
    
    modal.innerHTML = `
        <div class="reminder-modal-header">
            <h2 class="reminder-modal-title">Ayuda de Recordatorios</h2>
        </div>
        <div class="reminder-modal-body">
            <p class="mb-4">Ejemplos de comandos de voz o texto:</p>
            <ul class="list-disc pl-6 mb-4 space-y-2">
                <li><strong>Texto:</strong> "Recordar cita", "Llamar mam"</li>
                <li><strong>Hora:</strong> "A LAS DIEZ Y CUARTO"  10:15, "A LAS CINCO Y MEDIA TARDE"  17:30</li>
                <li><strong>Fecha:</strong> "HOY", "MAANA", "DENTRO DE 15 DAS", "EL DA 22", "PRXIMO LUNES", "25/05/2025"</li>
                <li><strong>Repeticin:</strong> "CADA LUNES", "TODOS LOS VIERNES Y SBADOS"</li>
                <li><strong>Intervalo:</strong> "CADA 7 DAS"</li>
                <li><strong>Alarma:</strong> "ALARMA EN 30 MINUTOS", "RECORDAR EN 2 HORAS".</li>
                <li><strong>Excluir/Radar:</strong> Aadir "NO LISTAR", "EXCLUIR LISTA" o "RADAR" para ocultarlo de la lista general y que aparezca con chincheta morada en el mapa.</li>
            </ul>
            <p class="mb-4">Nota: Combina hora, fecha, das, etc. Las palabras Alarma, Aviso, Recordar, Timer... crean alarmas de tiempo exacto.</p>
            
            <h3 class="font-bold text-lg mt-6 mb-2 text-[#007aff]">Recordatorios por Ubicacin</h3>
            <ul class="list-disc pl-6 mb-4 space-y-2">
                <li><strong>Activar:</strong> Marca la casilla "RECORDATORIO POR UBICACIN" o usa frases como "EN EL LUGAR", "EN EL SITIO".</li>
                <li><strong>Fijar Punto:</strong> Pulsa "VER/EDITAR POSICIN EN MAPA" para ampliarlo y haz clic donde quieras fijar el punto. Usa "ESTS AQU" para centrar en tu posicin.</li>
                <li><strong>Radio:</strong> Ajusta el radio con el slider o con frases como "RADIO DE 200 METROS".</li>
                <li><strong>Guardar/Usar Ubicaciones:</strong> Usa el botn "Ubicaciones" para guardar y seleccionar tus lugares frecuentes.</li>
                <li><strong>Navegacin:</strong> Para planificar rutas, usa el icono <img src="RADAR.PNG" alt="Radar Icon" style="width:1em; height:1em; vertical-align:middle; display:inline;"> en la barra superior. Consulta su ayuda especfica <img src="./PNG/IMG_4326.PNG" alt="Ayuda" style="height:1.2em; display:inline; vertical-align:middle;">.</li>
            </ul>
        </div>
        <div class="reminder-modal-footer">
            <button type="button" id="close-help" class="action-button primary" style="grid-column: 1 / -1;">Entendido</button>
        </div>
    `;
    const parent = options.parentContainer || document.body;
    parent.appendChild(modal);
    const closeHelpButton = modal.querySelector('#close-help');
    const closeHandler = () => { clearModalAutoCloseTimer(modal, closeHelpButton, 'help-modal'); if (modal.parentNode) modal.parentNode.removeChild(modal); };
    closeHelpButton.addEventListener('click', closeHandler); 
    addModalAutoCloseTimer(modal, closeHelpButton, 'help-modal');
}

    // ===================================================================
    // NOMBRE: stopAutomatedRouteSimulation
    // RESUMEN: Detiene completamente el modo de simulacin y vuelve al GPS real.
    function stopAutomatedRouteSimulation() {
        stopAutomatedRouteSimulationInternal();
        isSimulatingGpsLocation = false;
        const mapDiv = document.getElementById('reminders-location-map-div');
        if (mapDiv) {
            mapDiv.classList.remove('simulating-gps-click-mode');
        }
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) {
            simulateGpsButton.classList.remove('active-simulate-gps-mode');
            simulateGpsButton.title = "Activar Simulacin GPS (recorrido automtico o clic manual)";
        }
        startGpsWatching();
        setNavigationMapClickHandler();
    }
    
    
    // ===================================================================
    // NOMBRE: toggleAddReminderAtLocationMode
    // RESUMEN: Activa/desactiva el modo para aadir un recordatorio haciendo clic en el mapa.
    function toggleAddReminderAtLocationMode() {
        isAddReminderAtLocationModeActive = !isAddReminderAtLocationModeActive;
        const mapDiv = document.getElementById('reminders-location-map-div');
        const button = document.getElementById('add-reminder-at-location-button');
        if (button) {
            if (isAddReminderAtLocationModeActive) {
                button.classList.add('active-reminder-mode');
                if (mapDiv) mapDiv.classList.add('add-reminder-mode');
                showToast("Modo 'Aadir Recordatorio en Mapa' ACTIVADO. Pulsa en el mapa para crear un recordatorio.", "info", 5000);
            } else {
                button.classList.remove('active-reminder-mode');
                if (mapDiv) mapDiv.classList.remove('add-reminder-mode');
                showToast("Modo 'Aadir Recordatorio en Mapa' DESACTIVADO.", "info");
            }
        }
        setNavigationMapClickHandler();
    }
    

// ===================================================================
// NOMBRE: handlePdrSearchButtonClick
// RESUMEN: Gestiona el ciclo de bsqueda de PDRs (Buscar > Filtrar > Limpiar).
function handlePdrSearchButtonClick() {
    const pdrButton = document.getElementById('pdrs-ruta-button');

    switch (pdrSearchState) {
        case 'initial': 
            if (pdrButton) pdrButton.classList.remove('pdr-search-highlight');
            showPDRsFilterModal();
            break;
            
        case 'results_shown': 
            if (lastPdrSearchResults.length > 0) {
                if (pdrButton) pdrButton.classList.add('pdr-search-highlight');
                filterForCheapestPDRs();
                pdrSearchState = 'cheapest_shown';
            } else {
                showToast("No hay PDRs en el mapa para filtrar. Realice una nueva bsqueda.", "info");
                pdrSearchState = 'initial'; 
                showPDRsFilterModal();
            }
            break;

        case 'cheapest_shown': 
            if (pdrButton) pdrButton.classList.remove('pdr-search-highlight');
            clearChargingPoints();
            showToast("Puntos de recarga eliminados del mapa.", "info");
            pdrSearchState = 'initial'; 
            break;
    }
}

// ===================================================================
// NOMBRE: filterForCheapestPDRs (VERSIN CON FILTRADO CORRECTO)
// RESUMEN: Filtra para mostrar solo los PDRs ms baratos y actualiza la lista principal de resultados.
function filterForCheapestPDRs() {
    if (lastPdrSearchResults.length === 0) {
        showToast("No hay resultados previos para filtrar. Realiza una nueva bsqueda.", "info");
        pdrSearchState = 'initial';
        return;
    }
    showToast("Mostrando solo los PDRs ms econmicos por rango de potencia...", "info");

    const cheapestBySegment = {
        '#0f130c': { price: Infinity, point: null }, 
        '#007863': { price: Infinity, point: null }, 
        'rgb(30, 144, 255)': { price: Infinity, point: null }, 
        '#de2e03': { price: Infinity, point: null },
        '#5e5e5e': { price: Infinity, point: null } // Aadir color para potencia desconocida
    };

    const parsePrice = (priceString) => {
        if (priceString && typeof priceString === 'string') {
            const priceMatch = priceString.match(/(\d[\d,.]*)/);
            if (priceMatch && priceMatch[1]) {
                const priceNum = parseFloat(priceMatch[1].replace(',', '.'));
                if (!isNaN(priceNum) && priceNum >= 0 && priceNum < 10) { // Permitir precio 0
                    return priceNum;
                }
            }
        }
        return Infinity;
    };

    lastPdrSearchResults.forEach(point => {
        const power = parseFloat(point.power);
        const segmentColor = getChargingPointColorByPower(power);
        const price = parsePrice(point.price);
        
        if (cheapestBySegment[segmentColor] && price < cheapestBySegment[segmentColor].price) {
            cheapestBySegment[segmentColor].price = price;
            cheapestBySegment[segmentColor].point = point;
        }
    });
    
    const cheapestPoints = Object.values(cheapestBySegment)
        .map(item => item.point)
        .filter(p => p !== null);
     cheapestPoints.forEach(p => { p.isCheapest = true; });
    lastPdrSearchResults = cheapestPoints;
    displayChargingPointsOnMap();
}

// ===================================================================
// NOMBRE: addChargingPointToRoute (VERSIN CORREGIDA)
// RESUMEN: Aade un PDR como etapa. Si no hay ruta, crea una nueva. Si se navega, preserva estadsticas.
async function addChargingPointToRoute(pointIndex) {
    const point = currentChargingPointsOnRoute[pointIndex];
    if (!point) return;

    const noRouteLoaded = navigationWaypoints.length === 0;

    if (noRouteLoaded) {
        if (!navigationCurrentLocation) {
            showToast("No se puede aadir el punto de carga sin una ubicacin GPS inicial.", "error");
            return;
        }

        const startPoint = {
            id: Date.now() - 1,
            lat: navigationCurrentLocation.latitude,
            lng: navigationCurrentLocation.longitude,
            type: 'S',
            marker: null,
            label: 'S',
            address: 'Posicin Actual (GPS)',
            visited: true,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false
        };

        const newWaypoint = {
            id: Date.now(),
            lat: point.lat,
            lng: point.lon,
            type: '',
            marker: null,
            label: '',
            address: point.address || 'Punto de Recarga',
            visited: false,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false
        };

        navigationWaypoints.push(startPoint, newWaypoint);
        showToast("Ruta creada desde tu posicin hasta el punto de recarga.", "success");

    } else {
        let lastVisitedIndex = -1;
        navigationWaypoints.forEach((wp, index) => {
            if (wp.visited) {
                lastVisitedIndex = index;
            }
        });
        const insertIndex = lastVisitedIndex + 1;
        
        const newWaypoint = {
            id: Date.now(),
            lat: point.lat,
            lng: point.lon,
            type: '', 
            marker: null,
            label: '',
            address: point.address || 'Punto de Recarga',
            visited: false,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false
        };

        navigationWaypoints.splice(insertIndex, 0, newWaypoint);
        showToast(`'${newWaypoint.address}' aadido como etapa. Recalculando...`, "success");
    }
    
    updateWaypointTypesAndLabels();
    renderWaypointMarkers();

    try {
        await recalculateAndDrawRoute(true);
        
        clearChargingPoints();

        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
            toggleRadaresRuta(true);
        }
    } catch (e) {
        showToast("Error recalculando la ruta tras aadir el punto de recarga.", "error");
    }

    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}

    // ===================================================================
    // NOMBRE: calculateDistanceToEndOfStep
    // RESUMEN: Calcula la distancia acumulada hasta el final de un paso especfico de la ruta.
    function calculateDistanceToEndOfStep(route, targetLegIndex, targetStepIndex) {
        let totalDistance = 0;
        if (!route || !route.legs) return 0;
        for (let legIdx = 0; legIdx <= targetLegIndex; legIdx++) {
            const leg = route.legs[legIdx];
            if (!leg || !leg.steps) continue;
            const limitStepIndex = (legIdx === targetLegIndex) ? targetStepIndex : leg.steps.length - 1;
            for (let stepIdx = 0; stepIdx <= limitStepIndex; stepIdx++) {
                const step = leg.steps[stepIdx];
                if (step && typeof step.distance === 'number') {
                    totalDistance += step.distance;
                }
            }
        }
        return totalDistance;
    }

// ===================================================================
// NOMBRE: plotRemindersOnNavigationMap (NUEVA VERSIN GEOJSON)
// RESUMEN: Carga todos los recordatorios a una nica fuente GeoJSON para un renderizado eficiente.
function plotRemindersOnNavigationMap() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) return;

    // --- LIMPIEZA TOTAL PREVIA ---
    // 1. Eliminar todos los marcadores HTML de recordatorios existentes.
    // Esto es crucial y garantiza que los iconos borrados desaparezcan.
    reminderMapObjects.forEach(obj => {
        if (obj.marker) {
            try {
                obj.marker.remove();
            } catch (e) { /* Ignorar si ya fue removido */ }
        }
    });
    reminderMapObjects = []; // Reseteamos el array de control

    // 2. Eliminar capas y fuentes GeoJSON de recordatorios anteriores.
    // Esto previene la acumulacin de datos fantasma en el mapa.
    const layersAndSourcesToRemove = ['reminders-icons-layer', 'reminders-geojson-source'];
    layersAndSourcesToRemove.forEach(id => {
        try {
            if (navigationMapInstance.getLayer(id)) navigationMapInstance.removeLayer(id);
            if (navigationMapInstance.getSource(id)) navigationMapInstance.removeSource(id);
        } catch (e) {
            // Silenciar errores si la capa/fuente no existe, es normal en la primera ejecucin.
        }
    });

    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    const remindersWithLocation = reminders.filter(r => r.isLocationEnabled && r.locationCoordinates?.latitude && r.locationCoordinates?.longitude && !r.isFromRuta);

    // Separamos los radares de los recordatorios normales
    const radarReminders = remindersWithLocation.filter(r => r.text.toUpperCase().includes("RADAR") || r.excludeFromList);
    const normalReminders = remindersWithLocation.filter(r => !(r.text.toUpperCase().includes("RADAR") || r.excludeFromList));

    // --- DIBUJADO DE RECORDATORIOS NORMALES (CON ICONOS GEOJSON) ---
    const normalReminderFeatures = normalReminders.map(reminder => ({
        type: 'Feature',
        geometry: {
            type: 'Point',
            coordinates: [reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]
        },
        properties: {
            reminderId: reminder.id
        }
    }));

    navigationMapInstance.addSource('reminders-geojson-source', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: normalReminderFeatures }
    });

    navigationMapInstance.addLayer({
        id: 'reminders-icons-layer',
        type: 'symbol',
        source: 'reminders-geojson-source',
        layout: {
            'icon-image': 'reminder-icon',
            'icon-size': ['interpolate', ['linear'], ['zoom'], 10, 0.4, 14, 0.6, 17, 0.8],
            'icon-allow-overlap': true,
            'icon-anchor': 'bottom'
        }
    });

    // Hacemos los iconos de recordatorios normales "clicables"
    navigationMapInstance.on('click', 'reminders-icons-layer', (e) => {
        if (e.features && e.features.length > 0) {
            const reminderId = e.features[0].properties.reminderId;
            showReminderActionModal(reminderId);
        }
    });
    navigationMapInstance.on('mouseenter', 'reminders-icons-layer', () => { navigationMapInstance.getCanvas().style.cursor = 'pointer'; });
    navigationMapInstance.on('mouseleave', 'reminders-icons-layer', () => { navigationMapInstance.getCanvas().style.cursor = ''; });

    // --- DIBUJADO DE RADARES (CON MARCADORES HTML) ---
    // Usamos marcadores HTML para los radares porque sus iconos son ms complejos (con texto).
    radarReminders.forEach(reminder => {
        const speedLimit = extractSpeedFromRadarText(reminder.text);
        const isFromPersonalTask = reminder.isFromTarea === true;
        const markerElement = createRadarSpeedIcon(speedLimit, navigationMapInstance.getZoom(), isFromPersonalTask);
        
        const marker = new mapboxgl.Marker({ element: markerElement, anchor: 'center' })
            .setLngLat([reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude])
            .addTo(navigationMapInstance);
        
        marker.getElement().addEventListener('click', (e) => {
            e.stopPropagation();
            showReminderActionModal(reminder.id);
        });

        // Guardamos la referencia para poder limpiarla despus
        reminderMapObjects.push({
            reminderId: reminder.id,
            marker: marker
        });
    });
}
    
// ===================================================================
// NOMBRE: updateLocateMeButtonsUI (NUEVA FUNCIN)
// RESUMEN: Sincroniza la apariencia (icono y ttulo) de ambos botones de localizacin.
function updateLocateMeButtonsUI() {
    const topButton = document.getElementById('locate-me-on-reminders-map');
    const bottomButton = document.getElementById('zoom-locate-me-button');
    const buttons = [topButton, bottomButton].filter(Boolean);

    buttons.forEach(button => {
        const img = button.querySelector('img');
        if (!img) return;

        if (navigationFollowUser) {
            img.src = "PNG/DEJARSEGUIR.PNG";
            button.title = "Dejar de centrar el mapa en mi posicin";
            const countdownOverlay = bottomButton?.querySelector('.countdown-overlay');
            if (countdownOverlay) {
                countdownOverlay.remove();
            }
        } else {
            img.src = "PNG/ESTASAQUI.PNG";
            button.title = "Mostrar mi posicin actual y activar seguimiento";
        }
    });
}

// ===================================================================
// NOMBRE: clearLocateMeReactivationTimer (NUEVA FUNCIN)
// RESUMEN: Limpia los temporizadores de reactivacin y el contador visual.
function clearLocateMeReactivationTimer() {
    if (window.followMeReactivationTimer) {
        clearTimeout(window.followMeReactivationTimer);
        window.followMeReactivationTimer = null;
    }
    if (manualZoomTimeout) {
        clearTimeout(manualZoomTimeout);
        manualZoomTimeout = null;
    }
    if (locateMeCountdownInterval) {
        clearInterval(locateMeCountdownInterval);
        locateMeCountdownInterval = null;
    }
    const bottomButton = document.getElementById('zoom-locate-me-button');
    const countdownOverlay = bottomButton?.querySelector('.countdown-overlay');
    if (countdownOverlay) {
        countdownOverlay.remove();
    }
}

// ===================================================================
// NOMBRE: startLocateMeReactivationTimer (NUEVA FUNCIN)
// RESUMEN: Inicia el temporizador de 30s y el contador visual para reactivar el seguimiento.
function startLocateMeReactivationTimer() {
    clearLocateMeReactivationTimer();

    window.followMeReactivationTimer = setTimeout(() => {
        const mapModal = document.getElementById('reminders-location-map-modal');
        if (!navigationFollowUser && mapModal && !mapModal.classList.contains('map-modal-hidden')) {
            handleLocateMeClick();
            showToast("Seguimiento automtico reactivado.", "info");
        }
        clearLocateMeReactivationTimer();
    }, 30000);
    
    manualZoomTimeout = window.followMeReactivationTimer;

    let countdown = 30;
    const bottomButton = document.getElementById('zoom-locate-me-button');
    if (!bottomButton) return;

    let countdownOverlay = bottomButton.querySelector('.countdown-overlay');
    if (!countdownOverlay) {
        countdownOverlay = document.createElement('div');
        countdownOverlay.className = 'countdown-overlay';
        bottomButton.appendChild(countdownOverlay);
    }
    countdownOverlay.textContent = countdown;

    locateMeCountdownInterval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
            countdownOverlay.textContent = countdown;
        } else {
            clearLocateMeReactivationTimer();
        }
    }, 1000);
}
// ===================================================================
// NOMBRE: triggerManualMapInteraction (VERSIN FINAL CON LGICA DE MODOS)
// RESUMEN: Desactiva temporalmente el seguimiento. Si el modo es 'RUTA', lo cambia a 'OFF'.
//          Si el modo es 'AUTO', solo lo anula temporalmente sin cambiar el estado.
function triggerManualMapInteraction() {
    isManualZoomActive = true;
    navigationFollowUser = false;
    shouldCenterOnUser = false;

    clearLocateMeReactivationTimer();

    const currentAutoZoomMode = localStorage.getItem(AUTO_ZOOM_MODE_KEY) || 'off';
    const autoBtn = document.getElementById('zoom-auto-button');

    if (currentAutoZoomMode === 'route') {
        localStorage.setItem(AUTO_ZOOM_MODE_KEY, 'off');
        showToast("Modo 'Ruta' desactivado por interaccin manual.", "info");

        if (autoBtn) {
            autoBtn.textContent = 'AUTO';
            autoBtn.classList.remove('active', 'route-mode');
            autoBtn.title = 'Zoom automtico (Desactivado)';
        }
    }
  
    startLocateMeReactivationTimer();
    updateLocateMeButtonsUI();
}

// ===================================================================
// NOMBRE: handleManualMapInteraction (VERSIN CON DETECCIN DE INTENCIN)
// RESUMEN: Desactiva el seguimiento SOLO cuando detecta un gesto de arrastre o
function handleManualMapInteraction() {
    if (!navigationFollowUser) {
        startLocateMeReactivationTimer();
        return;
    }

    isManualZoomActive = true;
    navigationFollowUser = false;
    shouldCenterOnUser = false;
    mapPreviousZoomLevel = navigationMapInstance.getZoom();
    
    updateLocateMeButtonsUI();
    startLocateMeReactivationTimer();
}
    
 // ===================================================================
// NOMBRE: assignMapButtonListeners (VERSIN FINAL CON REASIGNACIN SEGURA)
// RESUMEN: Asigna listeners a los botones del modal. Clona y reemplaza elementos clave como el input de bsqueda para eliminar listeners antiguos y aadir los nuevos, garantizando la interactividad al reabrir el mapa.
function assignMapButtonListeners() {
    const header = document.getElementById('reminders-location-map-header');
    const togglePanelButton = document.getElementById('toggle-map-header-buttons-panel');
    const mapLocationSearchInput = document.getElementById('map-location-search-input');
    const mapFilterInput = document.getElementById('filter-input');
    
    if (!header || !togglePanelButton || !mapLocationSearchInput || !mapFilterInput) return;

    const reassignElement = (element) => {
        const newElement = element.cloneNode(true);
        element.parentNode.replaceChild(newElement, element);
        return newElement;
    };
    
    const newTogglePanelButton = reassignElement(togglePanelButton);
    let swipeStartX = 0, swipeStartY = 0, isSwiping = false, pressTimer = null;
    const handleGestureStart = (e) => { isSwiping = false; swipeStartX = e.touches ? e.touches[0].clientX : e.clientX; swipeStartY = e.touches ? e.touches[0].clientY : e.clientY; clearTimeout(pressTimer); pressTimer = setTimeout(() => { openAlertModal(); swipeStartX = 0; swipeStartY = 0; }, 800); if(e.type === 'touchstart') e.preventDefault(); };
    const handleGestureMove = (e) => { if (swipeStartX === 0) return; const moveX = e.touches ? e.touches[0].clientX : e.clientX; const moveY = e.touches ? e.touches[0].clientY : e.clientY; if (Math.abs(moveX - swipeStartX) > 10 || Math.abs(moveY - swipeStartY) > 10) { isSwiping = true; clearTimeout(pressTimer); } };
    const handleGestureEnd = (e) => { clearTimeout(pressTimer); if (swipeStartX === 0) return; const endX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX; const endY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY; const deltaX = endX - swipeStartX; const deltaY = endY - swipeStartY; const swipeThreshold = 50; if (!isSwiping) { toggleMapHeaderRowsVisibility(!mapHeaderButtonsVisible); } else { if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > swipeThreshold) { if (deltaY < 0) { toggleNavigationState(); } else { loadRouteByName("TRABAJO", true); } } else if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > swipeThreshold) { if (deltaX < 0) { toggleMapImmersiveMode(); } else { loadRouteByName("CASA", true); } } } swipeStartX = 0; swipeStartY = 0; isSwiping = false; };
    newTogglePanelButton.addEventListener('mousedown', handleGestureStart);
    newTogglePanelButton.addEventListener('mousemove', handleGestureMove);
    newTogglePanelButton.addEventListener('mouseup', handleGestureEnd);
    newTogglePanelButton.addEventListener('mouseleave', handleGestureEnd);
    newTogglePanelButton.addEventListener('touchstart', handleGestureStart, { passive: false });
    newTogglePanelButton.addEventListener('touchmove', handleGestureMove, { passive: false });
    newTogglePanelButton.addEventListener('touchend', handleGestureEnd);
    
    if (!header._delegateAttached) {
        header.addEventListener('click', (event) => {
            const button = event.target.closest('button');
            if (!button || button.disabled) return;
            event.stopPropagation();
            
            switch (button.id) {
                 case 'close-reminders-location-map': closeNavigationMap(false); break;
                 case 'locate-me-on-reminders-map': handleLocateMeClick(true); break;
                 case 'nav-map-zoomtoggle-button': handleZoomToggleButtonClick(button); break;
                 case 'start-navigation-button': toggleNavigationState(); break;
                 case 'save-route-button': saveCurrentRoute(); break;
                 case 'delete-current-route-button': handleLoadOrDeleteRouteClick(button); break;
                 case 'load-saved-route-button': showLoadRouteModal(); break;
                 case 'add-radar-here': handleAddRadarHereClick(button); break;
                 case 'accident-alert-button-map': openAlertModal(); break;
                 case 'pdrs-ruta-button': handlePdrSearchButtonClick(); break;
                 case 'add-reminder-at-location-button': toggleAddReminderAtLocationMode(); break;
                 case 'toggle-simulate-gps-button': handleGpsSimulationToggle(); break;
                 case 'simulate-route-button': showSimulationModal(); break;
                 case 'reorder-route-stages-button': showReorderStagesModal(); break;
                 case 'navigation-map-help-button': showNavigationMapHelpModal(); break;
                 case 'map-location-search-button':
                    const currentSearchInput = document.getElementById('map-location-search-input');
                    const currentFilterInput = document.getElementById('filter-input');
                    const mainTerm = currentSearchInput?.value.trim() || '';
                    if (!mainTerm) { showToast("El campo de bsqueda principal no puede estar vaco.", "warning"); return; }
                    const filterTerm = currentFilterInput?.value.trim() || '';
                    let combinedSearchTerm = mainTerm;
                    if (filterTerm) { combinedSearchTerm += ' ' + filterTerm; }
                    searchAndAddWaypoint(combinedSearchTerm);
                    break;
                 case 'clear-map-search-input-button':
                    const currentSearchInputToClear = document.getElementById('map-location-search-input');
                    if (currentSearchInputToClear) { currentSearchInputToClear.value = ''; }
                    currentSearchInputToClear?.dispatchEvent(new Event('input'));
                    currentSearchInputToClear?.focus();
                    hideAddressSuggestionsModal();
                    break;
            }
        });
        header._delegateAttached = true;
    }

    const newMapLocationSearchInput = reassignElement(mapLocationSearchInput);
    const newMapFilterInput = reassignElement(mapFilterInput);

    let searchDebounceTimer;
    const handleSearchInput = () => {
        const hasMainText = newMapLocationSearchInput.value.trim() !== '';
        const searchBtn = document.getElementById('map-location-search-button');
        const clearBtn = document.getElementById('clear-map-search-input-button');
        if(searchBtn) searchBtn.style.display = hasMainText ? 'inline-flex' : 'none';
        if(clearBtn) clearBtn.style.display = hasMainText ? 'inline-flex' : 'none';
        
        clearTimeout(searchDebounceTimer);
        const mainTerm = newMapLocationSearchInput.value.trim();
        if (mainTerm) {
            const filterTerm = newMapFilterInput.value.trim();
            let combinedSearchTerm = mainTerm;
            if (filterTerm) { combinedSearchTerm += ' ' + filterTerm; }
            searchDebounceTimer = setTimeout(() => fetchAddressSuggestions(combinedSearchTerm), 300);
        } else {
            hideAddressSuggestionsModal();
        }
        localStorage.setItem(MAP_FILTER_INPUT_KEY, newMapFilterInput.value);
    };

    newMapLocationSearchInput.addEventListener('input', handleSearchInput);
    newMapFilterInput.addEventListener('input', handleSearchInput);

    newMapLocationSearchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            const mainTerm = newMapLocationSearchInput.value.trim();
            if (!mainTerm) { showToast("El campo de bsqueda principal no puede estar vaco.", "warning"); return; }
            const filterTerm = newMapFilterInput.value.trim() || '';
            let combinedSearchTerm = mainTerm;
            if (filterTerm) { combinedSearchTerm += ' ' + filterTerm; }
            hideAddressSuggestionsModal();
            searchAndAddWaypoint(combinedSearchTerm);
        }
    });

    const radaresCheckbox = reassignElement(document.getElementById('radares-ruta-checkbox'));
    radaresCheckbox.addEventListener('change', (e) => toggleRadaresRuta(e.target.checked));
    
    const tareasCheckbox = reassignElement(document.getElementById('tareas-ruta-checkbox'));
    tareasCheckbox.addEventListener('change', (e) => toggleTareasRuta(e.target.checked));
    
    const mapboxCheckbox = reassignElement(document.getElementById('mapbox-primary-checkbox'));
    mapboxCheckbox.addEventListener('change', (e) => {
        localStorage.setItem('boardinggate_useMapboxAsPrimary', e.target.checked);
        markCacheAsDirty();
        const serviceName = e.target.checked ? 'Mapbox' : 'OSRM';
        showToast(`Servicio primario cambiado a ${serviceName}. Recalculando ruta...`, 'success');
        if (navigationWaypoints.length >= 2) { recalculateAndDrawRoute(true); }
    });
    
    newMapLocationSearchInput.value = '';
    newMapFilterInput.value = localStorage.getItem(MAP_FILTER_INPUT_KEY) || 'Espaa';
}
// ===================================================================
// NOMBRE: getCurrentLocationAsync (NUEVA FUNCIN ASNCRONA)
// RESUMEN: Envuelve getCurrentLocation en una Promise para poder usar async/await.
function getCurrentLocationAsync() {
    return new Promise((resolve, reject) => {
        getCurrentLocation(
            (coords) => resolve(coords),
            (errorMsg) => reject(new Error(errorMsg))
        );
    });
}

    
// ===================================================================
// NOMBRE: displayChargingPointsOnMap (VERSIN GEOJSON CON DISPONIBILIDAD)
// RESUMEN: Carga los PDRs a una fuente GeoJSON para un renderizado nativo y eficiente.
function displayChargingPointsOnMap() {
    if (!navigationMapInstance || !navigationMapInstance.getSource('pdrs-geojson-source')) return;
    
    const geojsonFeatures = lastPdrSearchResults.map((point, index) => {
        const operatorText = point.operator.length > 15 ? point.operator.substring(0, 14) + '...' : point.operator;
        
        return {
            type: 'Feature',
            geometry: {
                type: 'Point',
                coordinates: [point.lon, point.lat]
            },
            properties: {
                ocmId: point.ocmId,
                index: index,
                bgColor: getChargingPointColorByPower(parseFloat(point.power)),
                isCheapest: point.isCheapest || false,
                power: point.power,
                operator: operatorText,
                price: point.price,
                availability: point.availabilityText
            }
        };
    });

    const geojsonData = {
        type: 'FeatureCollection',
        features: geojsonFeatures
    };
    
    navigationMapInstance.getSource('pdrs-geojson-source').setData(geojsonData);
    chargingPointsLayer = 'pdrs-geojson-source';
}

// ===================================================================
// NOMBRE: plotSingleReminderOnMap (VERSIN FINAL CON MODAL PERSONALIZADO)
// RESUMEN: Dibuja un recordatorio y, al hacer clic, abre un modal de acciones personalizado.
function plotSingleReminderOnMap(reminder, mapInstance) {
    if (!mapInstance || !reminder.isLocationEnabled || !reminder.locationCoordinates) return null;

    let mapObject = null;

    const plot = () => {
        const lngLat = [reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude];
        const isRadarType = reminder.text.toUpperCase().includes("RADAR") || reminder.excludeFromList;
        const currentZoomLevel = mapInstance.getZoom();

        let markerElement;
        let anchorPoint;

        if (isRadarType) {
            const speedLimit = extractSpeedFromRadarText(reminder.text);
            const isFromPersonalTask = reminder.isFromTarea === true;
            markerElement = createRadarSpeedIcon(speedLimit, currentZoomLevel, isFromPersonalTask);
            anchorPoint = 'center';
        } else {
            markerElement = document.createElement('img');
            markerElement.src = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png';
            markerElement.style.width = '25px';
            markerElement.style.height = '41px';
            markerElement.style.cursor = 'pointer';
            anchorPoint = 'bottom';
        }

        const marker = new mapboxgl.Marker({element: markerElement, anchor: anchorPoint})
            .setLngLat(lngLat)
            .addTo(mapInstance);

        // --- INICIO DE LA CORRECCIN ---
        // Se ha eliminado toda la lgica que creaba la fuente y la capa del crculo (circleId).
        // Ahora solo se crea el marcador.
        // --- FIN DE LA CORRECCIN ---
        
        marker.getElement().addEventListener('click', (e) => {
            e.stopPropagation();
            showReminderActionModal(reminder.id);
        });

        mapObject = {
            reminderId: reminder.id,
            marker: marker,
            circleId: null, // Se establece explcitamente a null
            isFromRuta: reminder.isFromRuta || false,
            isFromTarea: reminder.isFromTarea || false,
            circleRadius: reminder.radiusMeters || DEFAULT_LOCATION_RADIUS
        };
    };
    if (mapInstance.isStyleLoaded()) {
        plot();
    } else {
        mapInstance.once('style.load', plot);
    }
    return mapObject;
}    

// ===================================================================
// NOMBRE: renderWaypointMarkers (VERSIN FINAL CON CORRECCIN DE OFFSET DE ARRASTRE)
// RESUMEN: Corrige el desplazamiento visual durante el arrastre al tener en cuenta la
function renderWaypointMarkers() {
    if (!navigationMapInstance) return;

    navigationWaypoints.forEach(wp => {
        if (wp && wp.marker) {
            try { wp.marker.remove(); } catch (e) {}
            wp.marker = null;
        }
    });

    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    
    actualWaypoints.forEach(wp => {
        if (!wp || typeof wp.lat !== 'number' || typeof wp.lng !== 'number') return;
        
        const waypointIconElement = createWaypointMarkerIcon(wp.label, wp.type, wp.visited, wp.id);
        
        waypointIconElement.dataset.waypointId = wp.id;
        
        wp.marker = new mapboxgl.Marker({
            element: waypointIconElement,
            draggable: false, 
            anchor: 'center'
        }).setLngLat([wp.lng, wp.lat]).addTo(navigationMapInstance);
        
        const markerElement = wp.marker.getElement();

        let isDragging = false;
        let hasMovedEnough = false;
        let startPos = { x: 0, y: 0 };

        const onPointerDown = (e) => {
            if (isNavigating) return;
            e.stopPropagation();
            
            isDragging = false;
            hasMovedEnough = false;
            const point = e.touches ? e.touches[0] : e;
            startPos = { x: point.clientX, y: point.clientY };

            document.addEventListener('mousemove', onPointerMove);
            document.addEventListener('mouseup', onPointerUp);
            document.addEventListener('touchmove', onPointerMove, { passive: false });
            document.addEventListener('touchend', onPointerUp);
        };

        const onPointerMove = (e) => {
            if (e.type === 'touchmove') e.preventDefault();
            
            const point = e.touches ? e.touches[0] : e;
            const deltaX = Math.abs(point.clientX - startPos.x);
            const deltaY = Math.abs(point.clientY - startPos.y);

            if (!hasMovedEnough && (deltaX > 5 || deltaY > 5)) {
                hasMovedEnough = true;
                navigationMapInstance.getCanvas().style.cursor = 'grabbing';
                markerElement.style.cursor = 'grabbing';
            }

            if (hasMovedEnough) {
                isDragging = true;
                const mapContainer = document.getElementById('mapbox-map-actual-container');
                const mapRect = mapContainer.getBoundingClientRect();
                const relativeX = point.clientX - mapRect.left;
                const relativeY = point.clientY - mapRect.top;

                const coords = navigationMapInstance.unproject([relativeX, relativeY]);
                wp.marker.setLngLat(coords);
            }
        };

        const onPointerUp = async (e) => {
            document.removeEventListener('mousemove', onPointerMove);
            document.removeEventListener('mouseup', onPointerUp);
            document.removeEventListener('touchmove', onPointerMove);
            document.removeEventListener('touchend', onPointerUp);
            
            navigationMapInstance.getCanvas().style.cursor = '';
            markerElement.style.cursor = 'pointer';

            if (isDragging) {
                const point = e.changedTouches ? e.changedTouches[0] : e;
                const mapContainer = document.getElementById('mapbox-map-actual-container');
                const mapRect = mapContainer.getBoundingClientRect();
                const relativeX = point.clientX - mapRect.left;
                const relativeY = point.clientY - mapRect.top;
                const finalCoords = navigationMapInstance.unproject([relativeX, relativeY]);
                // *** FIN DE LA CORRECCIN DE OFFSET ***
                
                const waypointIndex = navigationWaypoints.findIndex(w => w.id === wp.id);
                if (waypointIndex !== -1) {
                    navigationWaypoints[waypointIndex].lat = finalCoords.lat;
                    navigationWaypoints[waypointIndex].lng = finalCoords.lng;
                    navigationWaypoints[waypointIndex].address = await getAddressForWaypoint(finalCoords.lat, finalCoords.lng);
                    
                    await recalculateAndDrawRoute();
                    renderWaypointMarkers();
                }
            } else {
                showWaypointActionModal(wp.id);
            }
            
            isDragging = false;
            hasMovedEnough = false;
        };

        markerElement.addEventListener('mousedown', onPointerDown);
        markerElement.addEventListener('touchstart', onPointerDown, { passive: false });
    });
}
// ===================================================================
// NOMBRE: handleProgressBarLockToggle (CORREGIDA)
// RESUMEN: Cambia el estado del candado, lo guarda y actualiza la UI,
//          marcando la cach como modificada para que persista en la nube.
// ===================================================================
function handleProgressBarLockToggle() {
    isProgressBarLocked = !isProgressBarLocked;
    saveSettings(); // <-- ESTA LNEA ES LA CORRECCIN. Llama a la funcin que guarda y marca los datos para sincronizar.
    updateProgressBarLockIcon();
    showToast(`Panel de progreso ${isProgressBarLocked ? 'BLOQUEADO' : 'DESBLOQUEADO'}`, 'info');
    
    const progressBar = document.getElementById('navigation-bottom-progress-bar');
    if (isProgressBarLocked) {
        progressBar.classList.remove('progress-bar-auto-hidden');
    } else {
        if (navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
            updateTurnByTurnDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
        }
    }
}
// ===================================================================
// NOMBRE: showNavigationMapHelpModal (VERSIN FINAL Y MEJORADA)
// RESUMEN: Muestra un modal de ayuda completo y detallado para el mapa de navegacin.
function showNavigationMapHelpModal() {
    const existingHelpModal = document.getElementById('reminders-map-help-modal-instance');
    if (existingHelpModal) {
        clearModalAutoCloseTimer(existingHelpModal, existingHelpModal.querySelector('#close-reminders-map-help-instance'), 'reminders-map-help-modal-instance');
        existingHelpModal.remove();
    }

    const helpModal = document.createElement('div');
    helpModal.id = 'reminders-map-help-modal-instance';
    helpModal.className = 'help-modal';
    helpModal.setAttribute('aria-label', 'Ayuda Mapa de Navegacin/Radares');
    
    helpModal.innerHTML = `
        <style>
            #reminders-map-help-modal-instance h3 { color: #87CEEB; margin-top: 1.2rem; margin-bottom: 0.5rem; border-bottom: 1px solid #444; padding-bottom: 4px;}
            #reminders-map-help-modal-instance ul { list-style-position: inside; padding-left: 0.5rem; }
            #reminders-map-help-modal-instance li { margin-bottom: 0.5rem; }
            #reminders-map-help-modal-instance .icon-in-text { height: 1.4em; display: inline; vertical-align: middle; margin: 0 4px; padding: 2px; border-radius: 4px; background: rgba(255,255,255,0.1);}
            #reminders-map-help-modal-instance .icon-in-text.circle { border-radius: 50%; }
            /* Estilos para los sliders (CORREGIDOS) */
            .visual-settings-container { background-color: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin-top: 10px;}
            .slider-control { display: flex; align-items: center; gap: 15px; margin-bottom: 10px; }
            .slider-control label { flex-basis: 120px; text-align: right; font-weight: bold; color: #a0a0a0; } /* Color de etiqueta mejorado */
            .slider-control input[type="range"] { flex-grow: 1; accent-color: #87CEEB; }
            .slider-control .value-display { flex-basis: 50px; font-weight: bold; color: #f0f0f0; } /* Color de valor mejorado */
            .reset-visuals-btn { background-color: #ox2bc7; color: black; padding: 4px 4px; border:none; border-radius: 5px; cursor: pointer; margin-top: 5px; }
        </style>

        <h2 class="text-xl font-bold mb-4">Ayuda del Mapa de Navegacin</h2>
        <div class="modal-top-buttons" style="justify-content: flex-end;">
            <button type="button" id="close-reminders-map-help-instance" style="flex: 0 1 auto; min-width: 120px;">Entendido</button>
        </div>
        <div style="max-height: 70vh; overflow-y: auto; padding-right: 15px;">
            
            <h3><img src="https://boardinggate.github.io/Tesla/PNG/personal.png" class="icon-in-text"> Ajustes Visuales del Mapa</h3>
            <div class="visual-settings-container">
                <div class="slider-control">
                    <label for="map-saturation-slider">Saturacin:</label>
                    <input type="range" id="map-saturation-slider" min="0.5" max="2" step="0.05">
                    <span id="map-saturation-value" class="value-display">120%</span>
                </div>
                <div class="slider-control">
                    <label for="map-contrast-slider">Contraste:</label>
                    <input type="range" id="map-contrast-slider" min="0.5" max="2" step="0.05">
                    <span id="map-contrast-value" class="value-display">110%</span>
                </div>
                <button id="map-visuals-reset-btn" class="reset-visuals-btn">Restaurar por defecto</button>
            </div>

            <h3><img src="https://boardinggate.github.io/Tesla/PNG/config.jpg" class="icon-in-text"> Controles Principales</h3>
            <ul class="list-disc space-y-2">
                <li><strong>Botn Flotante <img src="PNG/Coche_Sat.PNG" class="icon-in-text circle">:</strong> Es tu navaja suiza. Realiza diferentes acciones segn el gesto:
                    <ul style="padding-left: 20px; margin-top: 5px;">
                        <li><strong>Clic Corto:</strong> Muestra u oculta la barra de botones superior.</li>
                        <li><strong>Pulsacin Larga (1 seg):</strong> Abre el men para reportar <strong>Alertas de Trfico</strong>.</li>
                        <li><strong>Deslizar ARRIBA:</strong> Inicia <img src="PNG/INICIARNAVEGACION.PNG" class="icon-in-text"> o detiene <img src="PNG/TERMINARNAVEGACION.PNG" class="icon-in-text"> la navegacin.</li>
                        <li><strong>Deslizar a la IZQUIERDA:</strong> Activa/desactiva el modo inmersivo (pantalla completa).</li>
                        <li><strong>Deslizar a la DERECHA / ABAJO:</strong> Carga y navega automticamente a tus rutas guardadas "CASA" o "TRABAJO".</li>
                    </ul>
                </li>
                <li><strong>Salir del Mapa <img src="PNG/SALIR.PNG" class="icon-in-text">:</strong> Cierra la vista de navegacin y vuelve al lanzador principal.</li>
                <li><strong>Localizacin <img src="PNG/ESTASAQUI.PNG" class="icon-in-text">:</strong> Centra el mapa en tu posicin actual. Si lo pulsas de nuevo (<img src="PNG/DEJARSEGUIR.PNG" class="icon-in-text">), desactivas el seguimiento automtico.</li>
                <li><strong>Zoom <img src="PNG/ZOOM+.PNG" class="icon-in-text"> / <img src="PNG/ZOOM-.PNG" class="icon-in-text">:</strong> Alterna entre una vista general de toda la ruta y un zoom cercano a tu vehculo.</li>
            </ul>

            <h3><img src="./PNG/ANADIRPUNTO.PNG" class="icon-in-text"> Planificacin de Ruta</h3>
            <ul class="list-disc space-y-2">
                <li><strong>Aadir Puntos:</strong> Simplemente <strong>pulsa en cualquier lugar del mapa</strong> para aadir una etapa. Tambin puedes usar el <strong>buscador de texto</strong> para encontrar direcciones o lugares y aadirlos con el botn <img src="./PNG/ANADIRPUNTO.PNG" class="icon-in-text">.</li>
                <li><strong>Eliminar Puntos:</strong> Pulsa la <strong>'X' roja</strong> sobre cualquier marcador de etapa.</li>
                <li><strong>Reordenar Etapas <img src="./PNG/MOVER.PNG" class="icon-in-text">:</strong> Abre un men para arrastrar y cambiar el orden de las etapas de tu ruta.</li>
                <li><strong>Guardar y Cargar Rutas <img src="PNG/GUARDARRUTA.PNG" class="icon-in-text"> <img src="PNG/CARGARRUTA.PNG" class="icon-in-text">:</strong> Guarda la ruta actual para usarla en el futuro o carga una ya existente.</li>
            </ul>

            <h3><img src="https://boardinggate.github.io/Tesla/th.jpeg" class="icon-in-text circle"> Durante la Navegacin</h3>
            <ul class="list-disc space-y-2">
                <li><strong>Rutas Alternativas:</strong>
                    <ul>
                        <li><strong>Pulsacin Larga</strong> sobre un marcador de etapa (1, 2, F...) para ver al instante las rutas alternativas (Rpida, Corta, Alternativa) para ese tramo.</li>
                        <li>Tambin puedes hacer un <strong>clic corto</strong> en el marcador, y en la tarjeta que se abre, pulsar el botn <strong>"OTRAS RUTAS"</strong>.</li>
                    </ul>
                </li>
                <li><strong>Puntos de Recarga (PDRs) <img src="PNG/pdrs.png" class="icon-in-text">:</strong>
                    <ul>
                        <li><strong>1 Pulsacin:</strong> Abre un modal para filtrar PDRs por potencia, distancia a la ruta y operadores.</li>
                        <li><strong>2 Pulsacin:</strong> Muestra en el mapa solo el PDR ms econmico de cada rango de potencia (resaltado con un halo amarillo).</li>
                        <li><strong>3 Pulsacin:</strong> Limpia todos los PDRs del mapa.</li>
                    </ul>
                </li>
                 <li><strong>Radares y Tareas en Ruta:</strong> Activa los checkboxes <img src="https://i.imgur.com/r33g3oY.png" class="icon-in-text"> para ver en el mapa y en la barra de progreso los radares o tus tareas personales que se encuentren en el trazado actual.</li>
                 <li><strong>Simulacin <img src="./PNG/GPS.PNG" class="icon-in-text">:</strong> Activa este modo para que el coche recorra la ruta automticamente o para fijar tu posicin GPS manualmente haciendo clic en el mapa.</li>
            </ul>
        </div>
    `;

    const mapModal = document.getElementById('reminders-location-map-modal');
    if (mapModal) {
        mapModal.style.zIndex = 6400;
    }

    document.body.appendChild(helpModal); 
    
    const saturationSlider = helpModal.querySelector('#map-saturation-slider');
    const contrastSlider = helpModal.querySelector('#map-contrast-slider');
    const saturationValue = helpModal.querySelector('#map-saturation-value');
    const contrastValue = helpModal.querySelector('#map-contrast-value');
    const resetButton = helpModal.querySelector('#map-visuals-reset-btn');

    const updateLabels = () => {
        saturationValue.textContent = `${Math.round(saturationSlider.value * 100)}%`;
        contrastValue.textContent = `${Math.round(contrastSlider.value * 100)}%`;
    };

    saturationSlider.value = getComputedStyle(document.documentElement).getPropertyValue('--map-saturation').trim() || '1.2';
    contrastSlider.value = getComputedStyle(document.documentElement).getPropertyValue('--map-contrast').trim() || '1.1';
    updateLabels();
    saturationSlider.addEventListener('input', () => {
        const val = saturationSlider.value;
        document.documentElement.style.setProperty('--map-saturation', val);
        localStorage.setItem('boardinggate_map_saturation', val);
        updateLabels();
    });

    contrastSlider.addEventListener('input', () => {
        const val = contrastSlider.value;
        document.documentElement.style.setProperty('--map-contrast', val);
        localStorage.setItem('boardinggate_map_contrast', val);
        updateLabels();
    });

    resetButton.addEventListener('click', () => {
        saturationSlider.value = '1.2';
        contrastSlider.value = '1.1';
        saturationSlider.dispatchEvent(new Event('input'));
        contrastSlider.dispatchEvent(new Event('input'));
        showToast('Ajustes visuales restaurados a los valores por defecto.', 'info');
    });

    const closeButtonHelp = helpModal.querySelector('#close-reminders-map-help-instance');
    
    const closeHandlerHelp = () => { 
        clearModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance'); 
        if (helpModal.parentNode) {
            helpModal.parentNode.removeChild(helpModal); 
        }
        if (mapModal) {
            mapModal.style.zIndex = '';
        }
    };
    
    closeButtonHelp.addEventListener('click', closeHandlerHelp); 
    addModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance', 90000);
}
    
    // ===================================================================
    // NOMBRE: formatPhotonFeatureName
    // RESUMEN: Formatea el nombre de una ubicacin obtenida del servicio Photon.
    function formatPhotonFeatureName(feature) {
        if (!feature || !feature.properties) return "Ubicacin desconocida";
        const props = feature.properties;
        let nameParts = [];
        if (props.name) nameParts.push(props.name);
        if (props.street) { let streetPart = props.street; if (props.housenumber) streetPart += ` ${props.housenumber}`; nameParts.push(streetPart); }
        if (props.postcode) nameParts.push(props.postcode);
        if (props.city && (!props.name || props.name.toLowerCase() !== props.city.toLowerCase())) nameParts.push(props.city);
        else if (props.county && (!props.name || props.name.toLowerCase() !== props.county.toLowerCase())) nameParts.push(props.county);
        else if (props.state && (!props.name || props.name.toLowerCase() !== props.state.toLowerCase())) nameParts.push(props.state);
        if (props.country && nameParts.length > 0 && props.country.toLowerCase() !== nameParts[nameParts.length - 1].toLowerCase()) nameParts.push(props.country);
        else if (props.country && nameParts.length === 0) nameParts = [props.country];
        let formattedName = nameParts.filter((value, index, self) => self.map(v => v.toLowerCase()).indexOf(value.toLowerCase()) === index).join(', ');
        if (!formattedName && feature.geometry && feature.geometry.coordinates) { formattedName = `(${feature.geometry.coordinates[1].toFixed(4)}, ${feature.geometry.coordinates[0].toFixed(4)})`; }
        return formattedName || "Ubicacin desconocida";
    }

// ===================================================================
// NOMBRE: addWaypoint (MODIFICADA - GESTIONA MODO LIBRE)
// RESUMEN: Aade un punto de ruta y pausa el modo "Free Drive" si est activo.
async function addWaypoint(latlng, displayName = null) {
    if (isNavigating) return;
    
    if (navigationFollowUser) {
        navigationFollowUser = false;
        const locateMeButton = document.getElementById('locate-me-on-reminders-map');
        const locateMeImg = locateMeButton ? locateMeButton.querySelector('img') : null;
        if (locateMeButton && locateMeImg) {
            locateMeImg.src = "PNG/ESTASAQUI.PNG";
            locateMeButton.title = "Mostrar mi posicin actual y activar seguimiento";
        }
        showToast("Seguimiento pausado para aadir puntos.", "info");
    }

    if (isFreeDriveActive) {
        isFreeDrivePaused = true;
        isFreeDriveActive = false;
        showToast("Modo Conduccin Libre en pausa.", "info");
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        clearNavigationGraph();
    }
    
    let address = displayName;
    if (!address) {
        address = await getAddressForWaypoint(latlng.lat, latlng.lng);
    }

    const newWaypoint = {
        id: Date.now(),
        lat: latlng.lat,
        lng: latlng.lng,
        type: '',
        marker: null,
        label: '',
        address: address,
        visited: false,
        isCriticalForRecalc: true,
        isInternal: false,
        isRecalculatedStart: false
    };

    if (navigationWaypoints.length === 0 && navigationCurrentLocation) {
        const startPoint = {
            id: Date.now() - 1,
            lat: navigationCurrentLocation.latitude,
            lng: navigationCurrentLocation.longitude,
            type: 'S',
            marker: null,
            label: 'S',
            address: 'Posicin Actual (GPS)',
            visited: true,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false
        };
        navigationWaypoints.push(startPoint);
    }

    navigationWaypoints.push(newWaypoint);
    await updateWaypointTypesAndLabels();
    renderWaypointMarkers();

    if (navigationWaypoints.filter(wp => wp && !wp.isInternal).length >= 2) {
        if (navigationWaypoints.filter(wp => wp && !wp.isInternal).length === 2) {
            showToast("Para ELIMINAR ETAPA, COMPARTIR o buscar RUTAS ALTERNATIVAS, haga una pulsacin LARGA sobre el icono de la etapa, o ARRSTRELA para RESITUARLA", "instructional", 4000);
        }
        recalculateAndDrawRoute();
    }
    
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}

// ===================================================================
// NOMBRE: fetchAddressSuggestions (VERSIN CORREGIDA CON MANEJO DE "NO RESULTADOS")
// RESUMEN: En lugar de ocultar el modal cuando no hay resultados, lo mantiene
//          abierto y le pasa un array vaco para que muestre un mensaje.
async function fetchAddressSuggestions(query) {
    if (!query || query.length < 3) {
        hideAddressSuggestionsModal();
        return;
    }
    try {
        let queryToSearch = query.replace(/,/g, '');
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(queryToSearch)}&limit=60&accept-language=es&addressdetails=1`;
        
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Error de red: ${response.status}`);
        
        const data = await response.json();

        if (data && data.length > 0) {
            const results = data.reduce((acc, item) => {
                if (item && typeof item.lat === 'string' && item.lat.trim() !== '' && typeof item.lon === 'string' && item.lon.trim() !== '') {
                    acc.push({
                        display_name: item.display_name || "Ubicacin desconocida",
                        lat: parseFloat(item.lat),
                        lon: parseFloat(item.lon)
                    });
                }
                return acc;
            }, []);
            if (results.length === 0) {
                 displayAddressSuggestionsModal([]);
            } else {
                 displayAddressSuggestionsModal(results.slice(0, 60));
            }

        } else {
            displayAddressSuggestionsModal([]);
        }
    } catch (error) {
        showToast(`Error buscando sugerencias: ${error.message}`, "error");
        hideAddressSuggestionsModal();
    }
}   
// ===================================================================
// NOMBRE: snapCoordsToRoad (NUEVA FUNCIN)
// RESUMEN: Toma coordenadas y devuelve las coordenadas del punto ms cercano en la red de carreteras.
async function snapCoordsToRoad(lat, lon) {
    try {
        const nearestUrl = `${OSRM_SERVICE_URL}/nearest/v1/driving/${lon},${lat}?number=1`;
        const nearestResponse = await fetch(nearestUrl);
        if (!nearestResponse.ok) {
            console.warn(`OSRM /nearest fall, se usarn coordenadas originales.`);
            return { lat: lat, lng: lon };
        }
        const nearestData = await nearestResponse.json();
        if (nearestData.code === "Ok" && nearestData.waypoints && nearestData.waypoints.length > 0) {
            const snappedCoords = nearestData.waypoints[0].location;
            return { lat: snappedCoords[1], lng: snappedCoords[0] };
        } else {
            console.warn("OSRM /nearest no encontr un punto vlido, se usarn coordenadas originales.");
            return { lat: lat, lng: lon };
        }
    } catch (error) {
        console.error("Error en snapCoordsToRoad:", error);
        return { lat: lat, lng: lon }; 
    }
}

// ===================================================================
// NOMBRE: searchAndAddWaypoint (MODIFICADA - SIN L.latLng)
// RESUMEN: Busca una direccin, la transforma en coordenadas, las ajusta a la carretera y la aade como waypoint.
async function searchAndAddWaypoint(addressQuery = null) {
    const searchInput = document.getElementById('map-location-search-input');
    const address = addressQuery || searchInput.value.trim();
    if (!address) {
        showToast("Por favor, introduce una direccin para buscar", "warning");
        return;
    }

    const searchButton = document.getElementById('map-location-search-button');
    if (searchButton) {
        searchButton.disabled = true;
        searchButton.innerHTML = `<img src="PNG/BUSCANDO.PNG" alt="Buscando...">`;
    }

    try {
        showToast("Buscando direccin...", "info", 3000);
        const searchUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address.replace(/,/g, ''))}&limit=1&accept-language=es&addressdetails=1`;
        
        const searchResponse = await fetch(searchUrl);
        if (!searchResponse.ok) throw new Error(`Error de red en Nominatim: ${searchResponse.status}`);
        
        const searchData = await searchResponse.json();
        if (!searchData || searchData.length === 0) throw new Error("Direccin no encontrada");
        
        const result = searchData[0];
        const initialLat = parseFloat(result.lat);
        const initialLon = parseFloat(result.lon);
        const displayName = result.display_name || `Ubicacin (${initialLat.toFixed(3)}, ${initialLon.toFixed(3)})`;
        if (isNaN(initialLat) || isNaN(initialLon)) throw new Error("Coordenadas no vlidas de Nominatim");

        showToast("Ajustando a la carretera ms cercana...", "info", 3000);
        const snappedLatLng = await snapCoordsToRoad(initialLat, initialLon);
        
        await addWaypoint(snappedLatLng, displayName);
        
        if (navigationMapInstance) navigationMapInstance.flyTo({ center: [initialLon, initialLat], zoom: 15 });
        if (searchInput) {
            searchInput.value = '';
            searchInput.dispatchEvent(new Event('input'));
        }
        showToast("Ubicacin aadida a la ruta", "success");

    } catch (error) {
        showToast(`Error al buscar direccin: ${error.message}`, "error", 4000, true);
    } finally {
        if (searchButton) {
            searchButton.disabled = false;
            searchButton.innerHTML = `<img src="PNG/ANADIRPUNTO.PNG" alt="Aadir Punto Ruta">`;
            if (searchInput && searchInput.value.trim() === '') {
                searchButton.style.display = 'none';
                const clearMapSearchBtn = document.getElementById('clear-map-search-input-button');
                if (clearMapSearchBtn) clearMapSearchBtn.style.display = 'none';
            }
        }
    }
}    
    
    // ===================================================================
    // NOMBRE: hideAddressSuggestionsModal
    // RESUMEN: Oculta el modal de sugerencias de direcciones.
    function hideAddressSuggestionsModal() {
        const modal = document.getElementById('address-suggestions-modal');
        if (modal && !modal.classList.contains('hidden')) {
            clearModalAutoCloseTimer(modal, modal.querySelector('#close-address-suggestions-modal'), 'address-suggestions-modal');
            modal.classList.add('hidden');
        }
    } 
    // ===================================================================
    // NOMBRE: toggleMapLocationSearchVisibility
    // RESUMEN: Muestra u oculta la fila de bsqueda del mapa.
    function toggleMapLocationSearchVisibility(show) {
        const searchRow = document.getElementById('search-row-map-header');
        const reorderButton = document.getElementById('reorder-route-stages-button');
        if (show) {
            if (searchRow) searchRow.style.display = 'flex';
            if (reorderButton && navigationWaypoints.length >= 2) reorderButton.style.display = 'inline-flex';
            else if (reorderButton) reorderButton.style.display = 'none';
        } else {
            if (searchRow) searchRow.style.display = 'none';
            if (reorderButton) reorderButton.style.display = 'none';
        }
    } 
// ===================================================================
// NOMBRE: updateWaypointTypesAndLabels (VERSIN CORREGIDA Y DEFINITIVA 2)
// RESUMEN: Actualiza los tipos y etiquetas, esperando a que todas las operaciones asncronas finalicen.
async function updateWaypointTypesAndLabels() {
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    if (actualWaypoints.length === 0) return;

    await Promise.all(actualWaypoints.map(async (wp, index) => {
        if (!wp) return;

        if (actualWaypoints.length === 1) {
            wp.type = 'S';
            wp.label = 'S';
        } else if (index === 0) {
            wp.type = 'S';
            wp.label = 'S';
        } else if (index === actualWaypoints.length - 1) {
            wp.type = 'F';
            wp.label = 'F';
        } else {
            wp.type = 'intermediate';
            wp.label = String(index);
        }

        if (!wp.address) {
            if (typeof wp.lat === 'number' && typeof wp.lng === 'number') {
                wp.address = await getAddressForWaypoint(wp.lat, wp.lng);
            } else {
                wp.address = "Coordenadas no disponibles para direccin";
            }
        }
    }));

    navigationWaypoints.forEach(wp => {
        if(wp && (wp.isInternal || wp.isRecalculatedStart)) {
            wp.label = '';
        }
    });
} 

// ===================================================================
// NOMBRE: getRouteForSingleLeg (MODIFICADA - SIN L.latLng)
// RESUMEN: Obtiene la distancia y duracin de un solo tramo de ruta.
async function getRouteForSingleLeg(lon1, lat1, lon2, lat2) {
    const url = `${OSRM_SERVICE_URL}/driving/${lon1},${lat1};${lon2},${lat2}?overview=false&alternatives=false&steps=false&annotations=false`;
    try {
        const response = await fetch(url);
        if (!response.ok) {
            return { distance: 0, duration: 0 };
        }
        const data = await response.json();
        if (data.routes && data.routes.length > 0 && data.routes[0]) {
            return {
                distance: data.routes[0].distance || 0,
                duration: data.routes[0].duration || 0
            };
        }
        return { distance: 0, duration: 0 };
    } catch (error) {
        return { distance: 0, duration: 0 };
    }
}    

// ===================================================================
// NOMBRE: clearAllWaypointMarkersFromMap (MODIFICADA - PARA MAPBOX)
// RESUMEN: Elimina todos los marcadores de puntos de ruta del mapa.
function clearAllWaypointMarkersFromMap() {
    navigationWaypoints.forEach(wp => {
        if (wp && wp.marker) {
            wp.marker.remove();
            wp.marker = null;
        }
    });
}

// ===================================================================
// NOMBRE: handleSendToTeslaClick
// RESUMEN: Abre el dilogo nativo para compartir un destino a la app de Tesla.
async function handleSendToTeslaClick(lat, lng, name) {
    if (!navigator.share) {
        showToast("Tu navegador no soporta la funcin de compartir.", "warning");
        return;
    }

    try {
        const shareData = {
            title: `Destino: ${name}`,
            text: `Enviar "${name}" a la app de Tesla para iniciar la navegacin.`,
            url: `https://maps.google.com/?q=${lat},${lng}`
        };

        await navigator.share(shareData);
        showToast("Selecciona la app de Tesla para enviar el destino.", "info");

    } catch (err) {
        if (err.name !== 'AbortError') {
            showToast(`Error al compartir: ${err.message}`, "error");
        }
    }
}
// ===================================================================
// NOMBRE: clearAllRouteVisualsFromMap (NUEVA FUNCIN MAESTRA)
// RESUMEN: Realiza una limpieza completa y garantizada de TODOS los
//          elementos visuales de la ruta (marcadores, etiquetas, lneas)
//          inspeccionando el estado real del mapa, no los arrays.
// ===================================================================
function clearAllRouteVisualsFromMap() {
    if (!navigationMapInstance) return;

    // 1. Eliminar marcadores HTML (Etapas y Etiquetas de Alternativas)
    // Este mtodo es robusto porque busca los elementos directamente en el DOM del mapa.
    document.querySelectorAll('.navigation-waypoint-marker').forEach(el => el.remove());
    document.querySelectorAll('.route-label-marker').forEach(el => el.remove());

    // 2. Eliminar capas y fuentes de Mapbox
    if (navigationMapInstance.isStyleLoaded()) {
        const style = navigationMapInstance.getStyle();

        // Eliminar capas (ruta principal y alternativas)
        if (style && style.layers) {
            style.layers.forEach(layer => {
                if (layer.id === 'route' || layer.id.startsWith('alt-layer-')) {
                    try {
                        if (navigationMapInstance.getLayer(layer.id)) {
                            navigationMapInstance.removeLayer(layer.id);
                        }
                    } catch (e) {
                        console.warn(`Error al eliminar capa ${layer.id}: ${e.message}`);
                    }
                }
            });
        }

        // Eliminar fuentes de datos (ruta principal y alternativas)
        if (style && style.sources) {
            Object.keys(style.sources).forEach(sourceId => {
                if (sourceId === 'route' || sourceId.startsWith('alt-route-')) {
                    try {
                        if (navigationMapInstance.getSource(sourceId)) {
                            navigationMapInstance.removeSource(sourceId);
                        }
                    } catch (e) {
                        console.warn(`Error al eliminar fuente ${sourceId}: ${e.message}`);
                    }
                }
            });
        }
    }
    
    // 3. Reseteo final de variables de estado de capas
    navigationRouteLayer = null;
    alternativeRouteLayers = [];
}


// ===================================================================
// NOMBRE: resetNavigationState (MODIFICADA - USA LA NUEVA LIMPIEZA MAESTRA)
// RESUMEN: Reinicia a su estado original TODAS las variables relacionadas
//          con la navegacin, llamando primero a la limpieza visual garantizada.
// ===================================================================
function resetNavigationState() {
    // --- PASO 1: LIMPIEZA VISUAL COMPLETA Y GARANTIZADA ---
    clearAllRouteVisualsFromMap();

    // --- PASO 2: LIMPIEZA DEL ESTADO DE LA APLICACIN ---
    const autoStartModal = document.getElementById('auto-start-nav-modal');
    if (autoStartModal) {
        hideAutoStartNavigationModal();
        showToast("Inicio automtico cancelado: La ruta ha sido modificada/borrada.", "info");
    }

    // Estado de la ruta y navegacin
    navigationWaypoints = [];
    navigationCurrentRouteData = null;
    isNavigating = false;
    currentRouteNameForSaving = null;
    
    // Progreso y Turn-by-Turn
    lastCarDistanceAlongRouteForNavLogic = 0;
    lastValidCarDistanceForDisplay = 0;
    currentLegIndexNav = 0;
    currentStepIndexNav = 0;
    completedSegmentsGeoJSON.features = [];
    lastDisplayedManeuverIcon = null;
    lastProcessedStepIdentifier = null;
    lastProcessedStepForLock = null;

    // Estadsticas del viaje
    tripInitialOverallEtaTime = null;
    currentStageInitialExpectedEtaTime = null;
    accumulatedDeviationMs = 0;
    accumulatedDistanceBeforeCurrentSegment = 0;
    navigationStartTimeForStats = null;
    totalDistanceTravelledForStats = 0;
    lastPositionForStats = null;
    maxSpeedDuringTrip = 0;
    maxSpeedCoordinates = null;
    maxAltitudeDuringTrip = -Infinity;
    minAltitudeDuringTrip = Infinity;
    window.averageSpeedKmh = 0;

    // POIs en ruta y cach
    radaresEnRutaActual = [];
    tareasEnRutaActual = [];
    alternativeRoutesCache.clear();
    selectedStageRoutes.clear();

    // Estado de la UI
    isArrivalSequenceStarted = false;
    hideNavigationUI();
    hideMapInfoOverlay();
    clearNavigationGraph();
    clearSpeedMarkers();
    
    // Limpia los contadores visuales
    actualizarContadorRadares(0);
    actualizarContadorTareas(0);
}

// ===================================================================
// NOMBRE: handleDeleteWaypointClick (MODIFICADA - CIERRA MODAL DE INICIO)
// RESUMEN: Elimina una etapa Y SUS PUNTOS INTERNOS ASOCIADOS.
async function handleDeleteWaypointClick(waypointId) {
    if (isNavigating) {
        showToast("No se pueden borrar puntos mientras se navega.", "warning");
        return;
    }
    clearAlternativeRoutesDisplay();
    alternativeRoutesCache.clear();

    const waypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    if (waypointIndex === -1) return;
    
    navigationWaypoints = navigationWaypoints.filter(wp => !(wp.isInternal && wp.parentWaypointId === waypointId));
    
    const finalWaypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    if (finalWaypointIndex !== -1) {
        const waypointToDelete = navigationWaypoints[finalWaypointIndex];
        if (waypointToDelete.marker && navigationMapInstance) {
            waypointToDelete.marker.remove();
            waypointToDelete.marker = null;
        }
        navigationWaypoints.splice(finalWaypointIndex, 1);
    }
 
    if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) { 
        const autoStartModal = document.getElementById('auto-start-nav-modal');
        if (autoStartModal) {
            hideAutoStartNavigationModal();
            showToast("Inicio automtico cancelado: La ruta ya no es vlida.", "info");
        }
        
        clearAllWaypointMarkersFromMap(); 
        navigationWaypoints = [];
        if (navigationMapInstance && navigationMapInstance.getLayer('route')) {
            navigationMapInstance.removeLayer('route');
            navigationMapInstance.removeSource('route');
            navigationRouteLayer = null;
        }
        completedSegmentsGeoJSON.features = [];
        if (navigationMapInstance && navigationMapInstance.getSource('completed-segments')) {
            navigationMapInstance.getSource('completed-segments').setData(completedSegmentsGeoJSON);
        }

        navigationCurrentRouteData = null;
        hideNavigationUI();
        hideMapInfoOverlay();
        eliminarRadaresDeRuta();
        actualizarContadorRadares(0);
        eliminarTareasDeBarraProgreso();
        actualizarContadorTareas(0);
        const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresCheckbox) {
             localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckbox.checked)); 
        }
        const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasCheckbox) {
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckbox.checked));
        }
    } else {
        await updateWaypointTypesAndLabels();
        renderWaypointMarkers();
        if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
            if (navigationMapInstance && navigationMapInstance.getLayer('route')) { navigationMapInstance.removeLayer('route'); navigationMapInstance.removeSource('route'); }
            navigationRouteLayer = null;
            completedSegmentsGeoJSON.features = [];
            if (navigationMapInstance && navigationMapInstance.getSource('completed-segments')) {
                navigationMapInstance.getSource('completed-segments').setData(completedSegmentsGeoJSON);
            }
            navigationCurrentRouteData = null;
            hideMapInfoOverlay();
            eliminarRadaresDeRuta();
            actualizarContadorRadares(0);
            eliminarTareasDeBarraProgreso();
            actualizarContadorTareas(0);
            const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
            if (radaresCheckbox) {
                localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckbox.checked));
            }
            const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
            if (tareasCheckbox) {
                localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckbox.checked));
            }
        } else {
            recalculateAndDrawRoute().then(() => {
                const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
                if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                    toggleRadaresRuta(true);
                }
                const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
                if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                    toggleTareasRuta(true);
                }
            });
        }
        showToast("Etapa eliminada.", "info");
    }
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}    

// =============================
// NOMBRE: translateOcmTerm
// RESUMEN: Traduce trminos comunes de OCM del ingls al castellano.
function translateOcmTerm(term) {
    if (!term) return 'No especificado';
     const translations = {
        'Parking': 'Parking de pago',
        'Operational': 'Operativo',
        'Non-Operational': 'No operativo',
        'Not Operational': 'No operativo',   
        'Partly-Operational': 'Parcialmente operativo',
        'Planned For Future Date': 'Planificado',
        'Decommissioned': 'Fuera de servicio',
        'Public - Membership Required': 'Pblico - Requiere Membresa',
        'Public - Pay At Location': 'Pblico - Pago en el sitio',
        'Public': 'Pblico',
        'Privately Owned - For Staff, Visitors or Customers': 'Privado - Para personal o clientes',
        'Private - For Staff, Visitors or Customers': 'Privado - Para personal o clientes',
        'Private - Restricted Access': 'Privado - Acceso restringido'
    };
    return translations[term] || term;
}   

// ===================================================================
// NOMBRE: clearChargingPoints (CORREGIDA - PARA MAPBOX GEOJSON)
// RESUMEN: Elimina del mapa los puntos de recarga vaciando la fuente de datos.
function clearChargingPoints() {
    currentChargingPointsOnRoute = [];
    lastPdrSearchResults = [];
    
    if (navigationMapInstance && navigationMapInstance.getSource('pdrs-geojson-source')) {
        navigationMapInstance.getSource('pdrs-geojson-source').setData({
            type: 'FeatureCollection',
            features: []
        });
    }

    const pdrButton = document.getElementById('pdrs-ruta-button');
    if (pdrButton) pdrButton.classList.remove('pdr-search-highlight');
    pdrSearchState = 'initial'; 
}    
    
// ===================================================================
// NOMBRE: handleFreeDriveCancellation
// RESUMEN: Gestiona la reanudacin del modo libre cuando se cancela una planificacin de ruta.
function handleFreeDriveCancellation() {
    if (isFreeDrivePaused) {
        isFreeDriveActive = true;
        isFreeDrivePaused = false;
        
        if (freeDriveStats && !freeDriveStats.startTime) {
            freeDriveStats.startTime = new Date();
        }

        showToast("Planificacin de ruta cancelada. Reanudando registro de Conduccin Libre.", "info");
        
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        initializeNavigationGraph();
    }
}    

// ===================================================================
// NOMBRE: restoreOriginalGrid
// RESUMEN: Restaura el grid de marcadores a su estado original de fbrica.
function restoreOriginalGrid() {
    if (confirm('Restaurar el grid de botones a su estado original? Perders tu personalizacin del grid (URLs, nombres, orden).')) {
        localStorage.removeItem('customGridData');
        localStorage.removeItem('gridFilterValue');
        loadCustomData();
        renderGrid();
        renderToggleButtons();
        loadSavedSettings();
        updateButtonStyles();
        filterGridItems();
        document.getElementById('config-restore-grid-status').textContent = 'Grid restaurado al original. Recargando...';
        document.getElementById('config-restore-grid-status').style.color = '#28a745';
        showToast('Grid restaurado. Recargando...', 'success');
        setTimeout(() => location.reload(), 1500);
    }
}

// ===================================================================
// NOMBRE: clearAllLocalData
// RESUMEN: Borra todos los datos guardados en el almacenamiento local del navegador.
function clearAllLocalData() {
    if (confirm('ATENCIN! Esto borrar TODOS los datos locales (marcadores personalizados, recordatorios, configuracin de usuario, PIN, etc.). Esta accin NO SE PUEDE DESHACER. Ests seguro?')) {
        if (confirm('DE VERDAD, ESTS COMPLETAMENTE SEGURO? SE BORRAR TODO.')) {
            managedKeys.forEach(key => localStorage.removeItem(key));
            localStorage.removeItem('personalizationHelpShown');
            localStorage.removeItem('gridFilterValue');
            showToast('Todos los datos locales borrados. Recargando...', 'success');
            setTimeout(() => location.reload(), 1500);
        } else {
            showToast('Borrado cancelado', 'info');
        }
    } else {
        showToast('Borrado cancelado', 'info');
    }
}

// ===================================================================
// NOMBRE: fetchKMLFilesList
// RESUMEN: Obtiene la lista de archivos KML a procesar desde una URL.
async function fetchKMLFilesList(listUrl) {
    try {
        const response = await fetch(listUrl, { cache: 'no-cache' });
        if (!response.ok) throw new Error(`Error HTTP ${response.status} obteniendo lista KML: ${listUrl}`);
        const text = await response.text();
        return text.split('\n').map(f => f.trim()).filter(f => f.length > 0 && f.toLowerCase().endsWith('.kml'));
    } catch (error) {
        showToast(`Error cargando lista ${listUrl.split('/').pop()}`, 'error');
        return [];
    }
}

// ===================================================================
// NOMBRE: fetchAndParseKML
// RESUMEN: Descarga y decodifica un archivo KML.
async function fetchAndParseKML(kmlFileUrl) {
    try {
        const response = await fetch(kmlFileUrl, { cache: 'no-cache' });
        if (!response.ok) throw new Error(`Error HTTP ${response.status} obteniendo KML: ${kmlFileUrl}`);
        const buffer = await response.arrayBuffer();
        const decoder = new TextDecoder('iso-8859-1');
        const kmlText = decoder.decode(buffer);
        return parseKML(kmlText);
    } catch (error) {
        throw error;
    }
}

// ===================================================================
// NOMBRE: parseKML
// RESUMEN: Parsea el texto de un archivo KML para extraer los Placemarks.
function parseKML(kmlText) {
    const placemarks = [];
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(kmlText, "application/xml");
    const parserErrorNode = xmlDoc.querySelector("parsererror");
    if (parserErrorNode) {
        let errorMessage = "Error de parseo XML desconocido.";
        if (parserErrorNode.textContent) {
            const match = parserErrorNode.textContent.match(/error on line \d+ at column \d+: ([^\n]+)/);
            if (match && match[1]) {
                errorMessage = match[1];
            } else {
                errorMessage = parserErrorNode.textContent.split('\n')[0] || parserErrorNode.textContent;
            }
        } else if (parserErrorNode.innerText) {
             errorMessage = parserErrorNode.innerText.split('\n')[0] || parserErrorNode.innerText;
        }
        throw new Error("KML parsing error: " + errorMessage);
    }
    const KML_NS_GOOGLE = "http://earth.google.com/kml/2.0";
    const KML_NS_OGC = "http://www.opengis.net/kml/2.2";
    let placemarkNodes = xmlDoc.getElementsByTagNameNS(KML_NS_GOOGLE, 'Placemark');
    if (placemarkNodes.length === 0) {
        placemarkNodes = xmlDoc.getElementsByTagNameNS(KML_NS_OGC, 'Placemark');
    }
     if (placemarkNodes.length === 0) {
        placemarkNodes = xmlDoc.getElementsByTagName('Placemark');
    }
    for (let i = 0; i < placemarkNodes.length; i++) {
        const node = placemarkNodes[i];
        let nameNode, coordinatesNode;
        nameNode = node.getElementsByTagNameNS(KML_NS_GOOGLE, 'name')[0] || node.getElementsByTagNameNS(KML_NS_OGC, 'name')[0] || node.getElementsByTagName('name')[0];
        coordinatesNode = node.getElementsByTagNameNS(KML_NS_GOOGLE, 'coordinates')[0] || node.getElementsByTagNameNS(KML_NS_OGC, 'coordinates')[0] || node.getElementsByTagName('coordinates')[0];
        if (nameNode && coordinatesNode) {
            const name = nameNode.textContent.trim();
            const coordinatesRaw = coordinatesNode.textContent.trim();
            const coordPartsMatch = coordinatesRaw.match(/^(-?\d+\.?\d*)[,\s]+(-?\d+\.?\d*)/);
            if (name && coordPartsMatch && coordPartsMatch.length >= 3) {
                const lonStr = coordPartsMatch[1];
                const latStr = coordPartsMatch[2];
                const coordinates = `${lonStr},${latStr}`;
                const lon = parseFloat(lonStr);
                const lat = parseFloat(latStr);
                if (!isNaN(lon) && !isNaN(lat)) {
                    if (name.startsWith("Radares BBS www.laradiobbs.net") && lon === 0 && lat === 0) {
                        continue;
                    }
                    placemarks.push({ name, coordinates });
                }
            }
        }
    }
    return placemarks;
}


// ===================================================================
// NOMBRE: importRadars (MODIFICADA)
// RESUMEN: Importa radares y limpia la cach para forzar su reconstruccin.
async function importRadars() {
    window.radarsCache = null;
    window.radarsSpatialIndex = null;
    localStorage.removeItem('radarsCacheData');
    localStorage.removeItem('radarsCacheIndex');
    localStorage.removeItem('radarsCacheVersion');

    const latFilterValue = document.getElementById('radar-filter-lat').value.trim();
    const lonFilterValue = document.getElementById('radar-filter-lon').value.trim();
    const keywordsFilterRaw = document.getElementById('radar-filter-keywords').value.trim().toUpperCase();
    const keywordsFilter = keywordsFilterRaw ? keywordsFilterRaw.split(/\s+/).filter(k => k) : [];
    const importExtra = document.getElementById('import-extra-radars-checkbox').checked;
    const statusMessage = document.getElementById('radar-import-status');
    const progressContainer = document.getElementById('radar-import-progress-container');
    
    progressContainer.style.display = 'block';
    const progressBar = document.getElementById('radar-import-progress-bar');
    if(progressBar) progressBar.style.display = 'none';

    statusMessage.textContent = 'Iniciando importacin...';
    statusMessage.style.color = '';
    try {
        let filesToProcess = await fetchKMLFilesList(KML_FILES_LIST_STANDARD);
        if (importExtra) {
            const extraFiles = await fetchKMLFilesList(KML_FILES_LIST_EXTRA);
            filesToProcess = filesToProcess.concat(extraFiles.filter(f => !filesToProcess.includes(f)));
        }
        if (filesToProcess.length === 0) {
            statusMessage.textContent = 'No se encontraron listas de archivos KML para procesar.';
            showToast('No hay archivos KML en las listas.', 'warning');
            setTimeout(() => { progressContainer.style.display = 'none'; }, 3000);
            return;
        }
        
        statusMessage.textContent = `Procesando ${filesToProcess.length} archivos KML...`;
        
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        let newRadarsCount = 0;

        const processingPromises = filesToProcess.map(kmlFileName =>
            fetchAndParseKML(KML_BASE_PATH + kmlFileName).catch(e => {
                console.warn(`Error procesando ${kmlFileName}, se omitir.`, e);
                return [];
            })
        );
        
        const results = await Promise.all(processingPromises);
        
        results.flat().forEach(placemark => {
            const name = placemark.name.toUpperCase();
            const coords = placemark.coordinates;
            const matchesKeywords = keywordsFilter.length === 0 || keywordsFilter.some(kw => name.includes(kw));
            if (coords && matchesKeywords) {
                const [lonStr, latStr] = coords.split(',');
                const lon = parseFloat(lonStr);
                const lat = parseFloat(latStr);
                if (isNaN(lat) || isNaN(lon)) return;
                
                const matchesLat = parseCoordinateFilter(latFilterValue, lat);
                const matchesLon = parseCoordinateFilter(lonFilterValue, lon);

                if (matchesLat && matchesLon) {
                    const existingRadar = reminders.find(r =>
                        r.isLocationEnabled && r.locationCoordinates &&
                        Math.abs(r.locationCoordinates.latitude - lat) < COORD_EPSILON &&
                        Math.abs(r.locationCoordinates.longitude - lon) < COORD_EPSILON &&
                        (r.text.toUpperCase().includes("RADAR") || r.excludeFromList)
                    );
                    if (!existingRadar) {
                        const now = new Date();
                        const newRadar = {
                            id: Date.now() + Math.random() + newRadarsCount,
                            text: `<b>RADAR: ${placemark.name}</b>`,
                            type: 'simple', time: '00:01',
                            date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                            createdAt: now.toISOString(), managedByUser: false,
                            isLocationEnabled: true, locationCoordinates: { latitude: lat, longitude: lon },
                            radiusMeters: 400, excludeFromList: true
                        };
                        reminders.push(newRadar);
                        newRadarsCount++;
                    }
                }
            }
        });
        
        localStorage.setItem('reminders', JSON.stringify(reminders));
        statusMessage.textContent = `Importacin completa. ${newRadarsCount} nuevos radares/POIs aadidos.`;
        statusMessage.style.color = '#28a745';
        showToast(`${newRadarsCount} nuevos radares/POIs aadidos.`, 'success');
        updateReminderCount();
        updateButtonStyles();
        checkReminders();
    } catch (error) {
        statusMessage.textContent = `Error general: ${error.message}`;
        statusMessage.style.color = 'red';
        showToast('Error durante la importacin.', 'error');
    } finally {
         setTimeout(() => {
            progressContainer.style.display = 'none';
            if(progressBar) progressBar.style.display = 'block';
            statusMessage.style.color = '';
        }, 5000);
    }
}

    
// ===================================================================
// NOMBRE: showSimulationModal (RESTAURADA)
// RESUMEN: Muestra un modal con la lista de maniobras de la ruta actual. No inicia ninguna simulacin.
async function showSimulationModal() {
    const canSimulate = (navigationWaypoints.filter(wp => !wp.isInternal && !wp.isRecalculatedStart).length >= 2 && navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) ||
                    (isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]);
    if (!canSimulate) {
        showToast("Se necesitan al menos 2 puntos y una ruta calculada para mostrar las maniobras.", "warning");
        return;
    }
    const route = navigationCurrentRouteData.routes[0];
    if (!route || !route.legs || route.legs.length === 0) {
        showToast("Datos de ruta incompletos para mostrar maniobras.", "error");
        return;
    }
    closeOtherModals('simulation-modal');
    
    let modal = document.getElementById('simulation-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'simulation-modal';
        document.body.appendChild(modal);
    }
    modal.innerHTML = `
        <h2 style="font-size: 1.3rem; font-weight: bold; text-align: center; margin-bottom: 1rem; color: #333;">Maniobras de la Ruta</h2>
        <div class="modal-top-buttons" style="justify-content: flex-start; margin-bottom: 1rem;">
            <button id="close-simulation-modal" style="flex: 0 0 auto; width: auto; min-width: unset;">Salir <span class="button-countdown-timer"></span></button>
        </div>
        <div id="simulation-content-area"><p>Cargando maniobras...</p></div>
    `;
    modal.classList.remove('hidden');

    const closeButton = modal.querySelector('#close-simulation-modal');
    const closeSimulationModalHandler = () => {
        if (simulationModalTimer) clearTimeout(simulationModalTimer);
        clearModalAutoCloseTimer(modal, closeButton, 'simulation-modal');
        modal.classList.add('hidden');
        hideIntersectionPreviewMap();
    };
    closeButton.addEventListener('click', closeSimulationModalHandler);
    addModalAutoCloseTimer(modal, closeButton, 'simulation-modal', 50000);

    const carDist = lastCarDistanceAlongRouteForNavLogic;
    let simulationList = document.createElement('ul');
    let stepsShown = 0;
    let actualStageCounter = 1;
    
    const waypointsForRequest = navigationWaypoints.filter(wp => wp);
    
    for (let legIdx = 0; legIdx < route.legs.length; legIdx++) {
        const leg = route.legs[legIdx];
        if (!leg || !leg.steps) continue;
        
        const legDestinationWaypoint = waypointsForRequest[legIdx + 1];
        if (legDestinationWaypoint && !legDestinationWaypoint.isInternal) {
             const stageAddress = legDestinationWaypoint.address || `Etapa ${legDestinationWaypoint.label}`;
             const stageDistance = leg.distance ? (leg.distance / 1000).toFixed(1) + " km" : "Dist. desc.";
             const headerLi = document.createElement('li');
             headerLi.style.cssText = "background-color: #e0e0e0; font-weight: bold; padding: 5px; margin-top:5px;";
             headerLi.textContent = `ETAPA ${actualStageCounter}: ${stageAddress} (Total ${stageDistance})`;
             simulationList.appendChild(headerLi);
             actualStageCounter++;
        }
        
        for (let stepIdx = 0; stepIdx < leg.steps.length; stepIdx++) {
            const step = leg.steps[stepIdx];
            if (!step || !step.maneuver) continue;

            const isArrivalAtInternal = step.maneuver.type === 'arrive' && waypointsForRequest[legIdx + 1]?.isInternal;
            const isDepartureFromInternal = step.maneuver.type === 'depart' && stepIdx === 0 && legIdx > 0 && waypointsForRequest[legIdx]?.isInternal;
            if (isArrivalAtInternal || isDepartureFromInternal) continue;
            
            const distanceToEndOfThisStep = calculateDistanceToEndOfStep(route, legIdx, stepIdx);
            if (distanceToEndOfThisStep < carDist) continue;
            const distanceToThisStepManeuver = Math.max(0, distanceToEndOfThisStep - carDist);
            
            const maneuver = step.maneuver;
            const type = maneuver.type || '';
            
            const maneuverText = getManeuverInstructionText(maneuver);
            let streetNameText = step.name || '';
            if (type === 'arrive' || type === 'depart' || type === 'end of road' || type === 'roundabout' || type === 'rotary') {
                streetNameText = '';
            } else if (streetNameText.toLowerCase() === 'contina' && maneuverText.toLowerCase() !== 'contina') {
                streetNameText = '';
            }
            
            let distanceFormatted = (distanceToThisStepManeuver >= 1000) ? `${(distanceToThisStepManeuver / 1000).toFixed(1)} km` : `${Math.round(distanceToThisStepManeuver)} m`;
            
            const li = document.createElement('li');
            li.dataset.legIndex = legIdx;
            li.dataset.stepIndex = stepIdx;
            li.style.cursor = 'pointer';
            
            const iconContainer = document.createElement('span');
            iconContainer.className = 'turn-icon-sim';
            
            const textContainer = document.createElement('span');
            textContainer.innerHTML = `${maneuverText}${streetNameText ? ` <strong>${streetNameText}</strong>` : ''} (${distanceFormatted})`;
            
            li.appendChild(iconContainer);
            li.appendChild(textContainer);
            simulationList.appendChild(li);

            const iconFilename = getManeuverIconFilename(maneuver);
            const iconUrl = `https://boardinggate.github.io/Tesla/${iconFilename}`;
            iconContainer.innerHTML = `<img src="${iconUrl}" alt="Maniobra" style="width:24px; height:24px; object-fit:contain;">`;
            
            stepsShown++;
        }
    }
    
    const contentArea = modal.querySelector('#simulation-content-area');
    if (stepsShown > 0) {
        contentArea.innerHTML = '';
        contentArea.appendChild(simulationList);
        contentArea.removeEventListener('click', handleSimulationItemClick);
        contentArea.addEventListener('click', handleSimulationItemClick);
    } else {
        contentArea.innerHTML = "<p>No hay ms interacciones futuras en la ruta o ests muy cerca del final.</p>";
    }
}

// ===================================================================
// NOMBRE: handleSimulationItemClick (VERSIN CORREGIDA)
// RESUMEN: Maneja el clic en un elemento de la lista de maniobras para mostrar el detalle del mapa.
function handleSimulationItemClick(event) {
    const listItem = event.target.closest('li[data-leg-index][data-step-index]');
    if (!listItem) {
        return;
    }
    if (!navigationCurrentRouteData || !navigationCurrentRouteData.routes || navigationCurrentRouteData.routes.length === 0) {
        return;
    }
    const legIndex = parseInt(listItem.dataset.legIndex);
    const stepIndex = parseInt(listItem.dataset.stepIndex);
    const route = navigationCurrentRouteData.routes[0];
    if (route.legs && legIndex < route.legs.length && route.legs[legIndex].steps && stepIndex < route.legs[legIndex].steps.length) {
        const step = route.legs[legIndex].steps[stepIndex];
        showIntersectionPreviewMap(step, route, true, 5000);
    } else {
        hideIntersectionPreviewMap();
    }
}


// ===================================================================
// NOMBRE: hideMapInfoOverlay
// RESUMEN: Oculta el mensaje de informacin del mapa.
function hideMapInfoOverlay() {
    const overlay = document.getElementById('map-info-overlay');
    if (overlay) {
        overlay.textContent = '';
        overlay.style.display = 'none';
    }
}
  

// ===================================================================
// NOMBRE: showMapInfoOverlay (VERSIN CORREGIDA Y MEJORADA)
// RESUMEN: Muestra un mensaje y solo aade una clase de error si es necesario, sin tocar el fondo por defecto.
function showMapInfoOverlay(message, isError = false) {
    const overlay = document.getElementById('map-info-overlay');
    if (overlay) {
        let finalMessage = message;
        if (message.startsWith(" ")) {
            const destName = message.substring(" ".length).trim().replace(/<br>/gi, ' ');
            finalMessage = " " + (destName.length > 55 ? destName.substring(0, 52) + "..." : destName);
        } else if (message.startsWith("ETAPA ")) {
            const stageInfo = message.substring("ETAPA ".length).trim().replace(/<br>/gi, ' ');
            finalMessage = "ETAPA " + (stageInfo.length > 55 ? stageInfo.substring(0, 52) + "..." : stageInfo);
        } else if (message.startsWith("HA LLEGADO AL ")) {
            const destinationName = message.substring("HA LLEGADO AL : ".length).trim().replace(/<br>/gi, ' ');
            finalMessage = "HA LLEGADO A: " + (destinationName.length > 55 ? destinationName.substring(0, 52) + "..." : destinationName);
        }
        
        overlay.innerHTML = `<span>${finalMessage}</span>`;
        
        if (!isNavigating) {
            overlay.style.display = 'block';
        }
        
        overlay.classList.toggle('error-overlay', isError);
    }
}    

// ===================================================================
// NOMBRE: showDestinationName
// RESUMEN: Muestra el nombre del destino o de la siguiente etapa en el overlay del mapa.
function showDestinationName() {
    if (!navigationWaypoints || navigationWaypoints.length === 0) {
        hideMapInfoOverlay();
        return;
    }
    let message = "";
    let nextUnvisitedStageWp = null;
    if (isNavigating) {
        const totalEtapas = navigationCurrentRouteData?.routes?.[0]?.legs?.length || 0;
        const etapaActualUsuario = currentLegIndexNav + 1;
        for(let i = currentLegIndexNav; i < navigationWaypoints.length; i++) {
            const waypointToCheck = navigationWaypoints[i];
            if (waypointToCheck && !waypointToCheck.isInternal && !waypointToCheck.visited && waypointToCheck.type !== 'S' && waypointToCheck.type !== 'S_Recalc') {
                nextUnvisitedStageWp = waypointToCheck;
                break;
            }
        }
         if (!nextUnvisitedStageWp && navigationWaypoints.length > 0) {
            const lastWaypoint = navigationWaypoints[navigationWaypoints.length -1];
            if (lastWaypoint.type === 'F' && !lastWaypoint.visited) {
                 nextUnvisitedStageWp = lastWaypoint;
            }
        }
        if (nextUnvisitedStageWp) {
            if (nextUnvisitedStageWp.type === 'F') {
                message = ` ${nextUnvisitedStageWp.address || ' Final'}`;
            } else if (nextUnvisitedStageWp.type === 'intermediate' && totalEtapas > 1) {
                message = `ETAPA ${etapaActualUsuario} de ${totalEtapas}: ${nextUnvisitedStageWp.address || `Etapa ${nextUnvisitedStageWp.label}`}`;
            } else {
                 message = ` ${nextUnvisitedStageWp.address || 'Siguiente Punto'}`;
            }
        } else {
            const finalDestination = navigationWaypoints[navigationWaypoints.length - 1];
            if (finalDestination && !finalDestination.isInternal) {
                 message = ` ${finalDestination.address || ' Final'}`;
            } else {
                 message = "RUTA NO DEFINIDA";
            }
        }
    } else {
        const finalDestination = navigationWaypoints[navigationWaypoints.length - 1];
        if (finalDestination && !finalDestination.isInternal) {
             message = ` ${finalDestination.address || ' Final'}`;
        } else {
             message = "RUTA NO DEFINIDA";
        }
    }
    showMapInfoOverlay(message);
}

    

// ===================================================================
// NOMBRE: clearModalAutoCloseTimer
// RESUMEN: Limpia un temporizador de autocierre de un modal.
function clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId) {
    const timerIdToClear = modalId || (modalElement ? modalElement.dataset.modalTimerId : null);
    if (timerIdToClear && globalModalTimers[timerIdToClear]) {
        clearInterval(globalModalTimers[timerIdToClear].intervalId);
        const timerData = globalModalTimers[timerIdToClear];
        if (timerData.modalElement && timerData.resetHandler) {
            timerData.modalElement.removeEventListener('click', timerData.resetHandler);
            timerData.modalElement.removeEventListener('touchstart', timerData.resetHandler);
            timerData.modalElement.removeEventListener('input', timerData.resetHandler);
            timerData.modalElement.removeEventListener('scroll', timerData.resetHandler);
        }
        if (timerData.countdownSpan && timerData.countdownSpan.parentNode) {
            timerData.countdownSpan.remove();
        }
        delete globalModalTimers[timerIdToClear];
    }
    if(closeButtonElement){
        const orphanSpans = closeButtonElement.querySelectorAll('.button-countdown-timer');
        orphanSpans.forEach(s => s.remove());
    }
     if(modalElement && modalElement.dataset.modalTimerId) {
        delete modalElement.dataset.modalTimerId;
    }
}

// ===================================================================
// NOMBRE: formatDateToDDMMMYY
// RESUMEN: Formatea una fecha (YYYY-MM-DD) a un formato legible (DD Mes Abreviado YY).
function formatDateToDDMMMYY(dateString) {
     if (!dateString) return '-';
     try {
         const [year, month, day] = dateString.split('-').map(Number);
         const date = new Date(Date.UTC(year, month - 1, day));
         if (isNaN(date.getTime())) return '-';
         const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
         const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
         const monthName = monthNames[date.getUTCMonth()];
         const yearShort = String(date.getUTCFullYear()).slice(-2);
         return `${dayOfMonth} ${monthName} ${yearShort}`;
     } catch (e) {
         return '-';
     }
}

// ===================================================================
// NOMBRE: calculateNextOccurrence
// RESUMEN: Calcula la prxima fecha de vencimiento de un recordatorio cclico.
function calculateNextOccurrence(reminder, referenceDate) {
      if (!reminder || !reminder.type || !reminder.time || !reminder.date) { return null; } try {
          let [year, month, day] = reminder.date.split('-').map(Number); let [hour, minute] = reminder.time.split(':').map(Number);
          let baseDate = new Date(Date.UTC(year, month - 1, day, hour, minute)); if (isNaN(baseDate.getTime())) { return null; }
          const refDateUTC = new Date(referenceDate.getTime()); if (baseDate > refDateUTC) return baseDate;
          if (reminder.type === 'simple') { return null; }
          if (reminder.type === 'daily' || reminder.type === 'hourly') { let next = new Date(baseDate); while (next <= refDateUTC) { next.setUTCDate(next.getUTCDate() + 1); } return next; }
          if (reminder.type === 'weekly' && reminder.repeatDays && reminder.repeatDays.length > 0) {
              let next = new Date(refDateUTC); next.setUTCHours(hour, minute, 0, 0);
              if (next <= refDateUTC || !reminder.repeatDays.includes(next.getUTCDay())) { next.setUTCDate(next.getUTCDate() + 1); }
              for (let i = 0; i < 7; i++) { if (reminder.repeatDays.includes(next.getUTCDay())) { return next; } next.setUTCDate(next.getUTCDate() + 1); } return null;
          }
          if (reminder.type === 'interval' && reminder.intervalDays && reminder.intervalDays > 0) { let next = new Date(baseDate); while (next <= refDateUTC) { next.setUTCDate(next.getUTCDate() + reminder.intervalDays); } return next; }
          return null; } catch (e) { return null; }
 }

// ===================================================================
// NOMBRE: calculatePostponedDateTime
// RESUMEN: Calcula la fecha y hora para posponer un recordatorio.
function calculatePostponedDateTime(mins) {
      const now = new Date(); const postponedDate = new Date(now.getTime() + mins * 60000);
      const newDateISO = `${postponedDate.getFullYear()}-${(postponedDate.getMonth() + 1).toString().padStart(2, '0')}-${postponedDate.getDate().toString().padStart(2, '0')}`;
      const newTime = `${postponedDate.getHours().toString().padStart(2, '0')}:${postponedDate.getMinutes().toString().padStart(2, '0')}`; return { newDateISO, newTime };
     }
       
// ===================================================================
// NOMBRE: showPostponeOptionsModal(reminder
// RESUMEN: Muestra un modal con opciones para posponer un recordatorio.
function showPostponeOptionsModal(reminder, source = 'unified') {
         const existingModal = document.getElementById('postpone-options-modal'); if (existingModal) { if (existingModal.autoPostponeInterval) clearInterval(existingModal.autoPostponeInterval); if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal); }
         const modal = document.createElement('div'); modal.id = 'postpone-options-modal'; modal.className = 'postpone-options';
         modal.style.cssText = `position:fixed; top:10px; left:50%; transform:translateX(-50%); width:90%; max-width:480px; max-height:calc(100vh - 20px); overflow-y:auto; background-color:#F5E1A9; padding:1.5rem; border-radius:1rem; box-shadow:0 10px 25px rgba(0,0,0,0.2); z-index:7500; `;
         modal.setAttribute('aria-label', 'Posponer recordatorio');
         let countdown = 10; const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval'; const defaultMinutes = 15;
         let buttonHtml = ` <button data-minutes="15" class="postpone-option">15 Minutos</button> <button data-minutes="60" class="postpone-option">1 Hora</button> <button data-minutes="180" class="postpone-option">3 Horas</button> `;
         if (!isCyclic) { buttonHtml += ` <button data-minutes="1440" class="postpone-option">1 Da</button> <button data-minutes="4320" class="postpone-option">3 Das</button> `; }
         modal.innerHTML = `
            <style>
                .postpone-options .reminder-text { color:#333; font-size:1.2rem; margin-bottom:.5rem; word-wrap:break-word; }
                .postpone-options .reminder-details { color:#555; font-size:1rem; margin-bottom:1.5rem; }
                .postpone-options .button-group { display:flex; flex-direction:column; gap:1rem; align-items:stretch; }
                .postpone-options button.postpone-option { font-size:1.3rem; font-weight:bold; padding:.8rem 1rem; background-color:#F59E0B; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                .postpone-options button.postpone-option:hover { background-color:#D97706; }
                #postpone-countdown { text-align:center; margin-top:1.8rem; font-size:1.1rem; font-weight:500; color:#444; }
                #postpone-timer-value { font-weight:bold; font-size:1.2rem; }
                #cancel-postpone { margin-top:1.2rem; width:100%; padding:.7rem 1rem; font-size:1.1rem; background-color:#EF4444; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                #cancel-postpone:hover { background-color:#DC2626; }
            </style>
            <div class="modal-top-buttons" style="justify-content: flex-end; margin-bottom: 1rem;">
                 <button id="cancel-postpone" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
            </div>
            <p class="reminder-text">Posponer: ${reminder.text.replace(/<[^>]*>/g, '')}</p>
            <p class="reminder-details">Selecciona tiempo:</p>
            <div class="button-group">
                ${buttonHtml}
            </div>
            <p id="postpone-countdown">Automtico en <span id="postpone-timer-value">${countdown}</span>s (${defaultMinutes} min)</p>
         `;
         document.body.appendChild(modal);
         const countdownDisplay = modal.querySelector('#postpone-timer-value');
         const handlePostpone = (minutes) => {
             if (modal.autoPostponeInterval) clearInterval(modal.autoPostponeInterval); modal.autoPostponeInterval = null;
             updateUnifiedWindowUI(reminder.id);
             let reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); const index = reminders.findIndex(r => r.id === reminder.id);
             if (index === -1) { showToast("Error: Recordatorio no encontrado", "error"); checkReminders(); if (modal.parentNode) document.body.removeChild(modal); return; }
             const { newDateISO, newTime } = calculatePostponedDateTime(minutes); reminders[index].date = newDateISO; reminders[index].time = newTime; reminders[index].managedByUser = false;
             if (!isCyclic) { reminders[index].type = 'daily'; reminders[index].repeatDays = []; reminders[index].intervalDays = null; }
             localStorage.setItem('reminders', JSON.stringify(reminders)); updateReminderCount(); updateButtonStyles(); 
             const durationText = minutes >= 1440 ? `${minutes / 1440} da(s)` : (minutes >= 60 ? `${minutes / 60} hora(s)` : `${minutes} minutos`);
             showToast(`Pospuesto ${durationText}`, 'info');
             if (modal.parentNode) document.body.removeChild(modal);
             if (source === 'table') { setTimeout(showAllReminders, 100); }
             else { const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                 const mapContextToReopen = sessionStorage.getItem('mapContext');
                 if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) { sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); if (!document.getElementById('reminders-location-map-modal')) { if (mapContextToReopen === 'navigation') openNavigationMap(); sessionStorage.removeItem('mapContext');} } } };
         modal.autoPostponeInterval = setInterval(() => { countdown--; if (countdownDisplay) countdownDisplay.textContent = countdown; if (countdown <= 0) { handlePostpone(defaultMinutes); } }, 1000);
         modal.querySelectorAll('.postpone-option').forEach(button => { button.addEventListener('click', () => { const minutes = parseInt(button.dataset.minutes); if (!isNaN(minutes)) { handlePostpone(minutes); } }); });
         modal.querySelector('#cancel-postpone').addEventListener('click', () => {
             clearInterval(modal.autoPostponeInterval); modal.autoPostponeInterval = null; markReminderAsManaged(reminder.id, false); if (modal.parentNode) document.body.removeChild(modal);
             if (source === 'table') { setTimeout(showAllReminders, 100); }
             else { const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                  const mapContextToReopen = sessionStorage.getItem('mapContext');
                 if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) { sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); if (!document.getElementById('reminders-location-map-modal')) { if (mapContextToReopen === 'navigation') openNavigationMap(); sessionStorage.removeItem('mapContext');} } } showToast('Posposicin cancelada', 'info'); });
     }
    
  
// ===================================================================
// NOMBRE: handleDragEndReorder
// RESUMEN: Maneja la finalizacin de una operacin de arrastre en la lista de etapas.
function handleDragEndReorder(e) {
    if (draggedStageLi) {
        draggedStageLi.classList.remove('dragging');
    }
    draggedStageLi = null;
}

// ===================================================================
// NOMBRE: handleDragOverReorder
// RESUMEN: Maneja el evento de pasar por encima al arrastrar en la lista de etapas.
function handleDragOverReorder(e) {
    e.preventDefault();
    if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
    const listElement = document.getElementById('sortable-stages-list');
    if (!listElement || !draggedStageLi) return;
    const afterElement = getDragAfterElement(listElement, e.clientY);
    const currentLi = e.target.closest('li');
    if (draggedStageLi && currentLi && draggedStageLi !== currentLi) {
        if (afterElement == null) {
            listElement.appendChild(draggedStageLi);
        } else {
            listElement.insertBefore(draggedStageLi, afterElement);
        }
    } else if (draggedStageLi && !currentLi && afterElement == null) {
         listElement.appendChild(draggedStageLi);
    } else if (draggedStageLi && !currentLi && afterElement) {
         listElement.insertBefore(draggedStageLi, afterElement);
    }
}

// ===================================================================
// NOMBRE: handleStageTouchStart
// RESUMEN: Maneja el inicio de un toque en una etapa para reordenar.
function handleStageTouchStart(e) {
    if (e.touches.length === 1 && e.target.closest('.drag-handle')) {
        draggedStageLi = e.target.closest('li');
        if (!draggedStageLi) return;
        const touch = e.touches[0];
        stageTouchStartX = touch.clientX;
        stageTouchStartY = touch.clientY;
        clearTimeout(stageScrollTimeout);
        stageScrollTimeout = setTimeout(() => {
            if (draggedStageLi) {
                draggedStageLi.classList.add('dragging');
                document.body.style.overflow = 'hidden';
            }
        }, 150);
    }
}

// ===================================================================
// NOMBRE: createWaypointMarkerIcon (MODIFICADA CON TAMAO DE FUENTE DINMICO Y COLOR DE VISITADO)
// RESUMEN: Crea el elemento DOM para un marcador de etapa, con tamao de fuente escalable y color gris para visitados.
function createWaypointMarkerIcon(label, type, visited, id, currentZoomLevel = null) {
    const el = document.createElement('div');
    el.className = 'navigation-waypoint-marker';
    
    let color;
    if (visited) {
        color = 'rgba(85, 85, 85, 0.8)'; 
    } else if (type === 'S' || type === 'S_Recalc') {
        color = 'rgba(0, 128, 0, 0.80)'; 
    } else if (type === 'F') {
        color = 'rgba(0, 0, 255, 0.80)'; 
    } else {
        color = 'rgba(230, 140, 0, 0.80)'; 
    }
    
    const ZOOM_PEQUENO = 12;
    const ZOOM_GRANDE = 17;
    const FONT_MINIMO = 15; 
    const FONT_MAXIMO = 19; 
    
    let finalFontSize = FONT_MAXIMO;
    if (currentZoomLevel !== null) {
        if (currentZoomLevel <= ZOOM_PEQUENO) {
            finalFontSize = FONT_MINIMO;
        } else if (currentZoomLevel >= ZOOM_GRANDE) {
            finalFontSize = FONT_MAXIMO;
        } else {
            const progress = (currentZoomLevel - ZOOM_PEQUENO) / (ZOOM_GRANDE - ZOOM_PEQUENO);
            finalFontSize = FONT_MINIMO + (FONT_MAXIMO - FONT_MINIMO) * progress;
        }
    }
    
    el.style.backgroundColor = color;
    el.style.width = '45px';
    el.style.height = '45px';
    el.style.border = `2px solid ${visited ? '#555' : 'white'}`;
    el.style.opacity = visited ? '0.7' : '1';
    el.textContent = label;
    el.style.fontSize = `${Math.round(finalFontSize)}px`;
    el.style.cursor = 'pointer';
    
    return el;
}
    
// ===================================================================
// NOMBRE: handleStageTouchMove
// RESUMEN: Maneja el movimiento de un toque en una etapa para reordenar.
function handleStageTouchMove(e) {
    if (!draggedStageLi || e.touches.length !== 1) return;
    e.preventDefault();
    clearTimeout(stageScrollTimeout);
    if (!draggedStageLi.classList.contains('dragging')) {
        draggedStageLi.classList.add('dragging');
         document.body.style.overflow = 'hidden';
    }
    const touch = e.touches[0];
    const listElement = document.getElementById('sortable-stages-list');
    if (!listElement) return;
    const afterElement = getDragAfterElement(listElement, touch.clientY);
     if (afterElement == null) {
        listElement.appendChild(draggedStageLi);
    } else {
        listElement.insertBefore(draggedStageLi, afterElement);
    }
}
  
// ===================================================================
// NOMBRE: handleStageTouchEnd
// RESUMEN: Maneja el final de un toque en una etapa para reordenar.
function handleStageTouchEnd(e) {
    clearTimeout(stageScrollTimeout);
    if (draggedStageLi) {
        draggedStageLi.classList.remove('dragging');
        draggedStageLi = null;
    }
    document.body.style.overflow = '';
}

// ===================================================================
// NOMBRE: getDragAfterElement
// RESUMEN: Encuentra el elemento despus del cual se debe soltar el elemento arrastrado.
function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('li:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

// ===================================================================
// NOMBRE: startGraphIntervalTimer (CORREGIDA)
function startGraphIntervalTimer() {
    if (graphIntervalTimer) clearInterval(graphIntervalTimer);
    if ((isNavigating || isFreeDriveActive) && currentGraphMode !== 'Grfica off' && graphIntervalDuration > 0) { 
        graphIntervalTimer = setInterval(plotIntervalData, graphIntervalDuration);
    }
}

// ===================================================================
// NOMBRE: initializeApp (VERSIN FINAL CON LLAMADA A FUNCIN CORREGIDA)
// RESUMEN: Llama a la nueva funcin `uploadDirtyCacheOnLoad_Car` y establece el timestamp inicial para la sincronizacin mvil.
async function initializeApp() {
    loadCustomData();
    loadSavedSettings();
    applyMapVisualSettings();
    isMobileSession = parseUserId(localStorage.getItem('userData_userId')).isMobile; // <-- AADE ESTA LNEA AQU
    
    if (isMobileSession) {
        document.body.classList.add('mobile-view');
        await restoreCacheForMobile();
    } else {
        await uploadDirtyCacheOnLoad_Car();
    }

    // Establecemos el timestamp de la ltima sincronizacin al cargar la pgina.
    lastMobileSyncTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');
    
    checkForExcessiveRadars();
    
    const termsAccepted = localStorage.getItem('termsAccepted_v1') === 'true';
    const shouldDirectToNav = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
    const tempPreventDirectNav = sessionStorage.getItem(TEMP_PREVENT_DIRECT_NAV_KEY);
    
    if (shouldDirectToNav && !tempPreventDirectNav && termsAccepted) {
        sessionStorage.setItem('isInDirectToMapMode', 'true');
        directToNavOnLoad = true;
        const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'none';
        const footerContent = document.querySelector('footer'); if (footerContent) footerContent.style.display = 'none';
        const noticesIconContainer = document.querySelector('.notices-icon-container'); if (noticesIconContainer) noticesIconContainer.style.display = 'none';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'none');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'none');
        document.getElementById('grid-filter-container').style.display = 'none';
        createOtherButtons();
        renderToggleButtons();
        openNavigationMap();
    } else {
        sessionStorage.removeItem('isInDirectToMapMode');
        directToNavOnLoad = false;
        const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'block';
        const footerContent = document.querySelector('footer'); if (footerContent) footerContent.style.display = 'block';
        const noticesIconContainer = document.querySelector('.notices-icon-container'); if (noticesIconContainer) noticesIconContainer.style.display = 'flex';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'flex');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'block');
        document.getElementById('grid-filter-container').style.display = 'flex';
        renderGrid();
        createOtherButtons();
        renderToggleButtons();
        updateButtonStyles();
        filterGridItems();
    }

    initializeConfigModalListeners();
    try { await updateVersion(); } catch (e) { }
    try { await loadNotices(); startNoticeRotation(); } catch (e) { }
    if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
    
    checkReminders(); 

    currentCheckIntervalDuration = 3000;
    reminderCheckIntervalId = setInterval(checkReminders, currentCheckIntervalDuration);
    
    if (!termsAccepted) {
        showConfigModal();
    }

    const noticeToggleIcon = document.getElementById('notice-toggle-icon');
    if (noticeToggleIcon) noticeToggleIcon.addEventListener('click', toggleNotices);
    const countEl = document.getElementById('reminder-count-globe');
    if (countEl) {
         const openTable = (e) => {
             if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
             e.preventDefault(); e.stopPropagation();
             showAllReminders();
         };
         countEl.addEventListener('click', openTable);
         countEl.style.cursor = 'pointer';
    }
    const filterInput = document.getElementById('grid-filter-input');
    const clearButton = document.getElementById('clear-filter-button');
    if (filterInput) {
        const savedFilter = localStorage.getItem('gridFilterValue');
        if (savedFilter !== null) filterInput.value = savedFilter;
        filterInput.addEventListener('input', () => {
             localStorage.setItem('gridFilterValue', filterInput.value);
             filterGridItems();
             if(isKeywordAssignmentMode) applyInitialKeywordHighlights();
        });
    }
    if (clearButton) {
        clearButton.addEventListener('click', () => {
             if (filterInput) filterInput.value = '';
             localStorage.removeItem('gridFilterValue');
             filterGridItems();
             if(isKeywordAssignmentMode) applyInitialKeywordHighlights();
        });
    }
    adjustButtonPositions();
    window.addEventListener('resize', adjustButtonPositions);
    
    const openChatArea = document.getElementById('open-chat-area');
    if (openChatArea) {
        openChatArea.addEventListener('click', openChatModal);
    }
    updateTotalMessageCount(); 
    
    const userCountGlobe = document.getElementById('user-count-globe');
    if (userCountGlobe) {
        userCountGlobe.addEventListener('click', () => {
            showToast('Usuarios activos', 'info');
        });
        if (window.db && window.getDocs && window.collection) {
            const usersCollectionRef = window.collection(window.db, "user_data");
            window.getDocs(usersCollectionRef).then(snapshot => {
                userCountGlobe.textContent = snapshot.size;
            }).catch(error => {
                userCountGlobe.textContent = 'X';
            });
        }
    }

    await checkVersionsIconOpacity();

    document.body.addEventListener('click', function(event) {
        const target = event.target;
        const targetId = target.id || (target.closest('[id]') ? target.closest('[id]').id : null);
        if (targetId === 'config-close-modal') {
            const termsAcceptedForClose = localStorage.getItem('termsAccepted_v1') === 'true';
            if (!termsAcceptedForClose) {
                showToast('Debes aceptar las normas de uso para continuar.', 'warning');
                return;
            }
            const modal = document.getElementById('config-modal');
            if (modal && !modal.classList.contains('hidden')) {
                clearModalAutoCloseTimer(modal, target, 'config-modal');
                modal.classList.add('hidden');
                 const mapWasOpenBeforeConfig = sessionStorage.getItem('boardinggate_map_should_reopen_after_config') === 'true';
                 const mapContextToReopen = sessionStorage.getItem('mapContextToReopenAfterConfig');
                 sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');
                 sessionStorage.removeItem('mapContextToReopenAfterConfig');
                 if (mapWasOpenBeforeConfig && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !document.getElementById('reminders-location-map-modal')) {
                    if (mapContextToReopen === 'navigation') {
                        setTimeout(() => openNavigationMap(), 50);
                    }
                }
            }
        }
        if (target.matches('.config-tab-button')) {
            const modal = document.getElementById('config-modal');
            if(modal && modal.classList.contains('hidden') === false) {
                const tabTarget = target.dataset.tabTarget;
                modal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                modal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (modal.querySelector(tabTarget)) {
                    modal.querySelector(tabTarget).classList.add('active');
                }
            }
        }
        if (targetId === 'close-reminders-top' || targetId === 'close-reminders-bottom') {
            const modalTable = document.querySelector('.reminder-table-modal');
            if (modalTable) {
                if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                modalTable.remove();
                const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                const mapContext = sessionStorage.getItem('mapContext');
                sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                sessionStorage.removeItem('mapContext');
                if (fromReminderModal) {
                    fromReminderModal = false;
                    if (mapShouldReopen) {
                        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                        sessionStorage.setItem('mapContext', mapContext);
                    }
                    showReminderModal();
                } else if (mapShouldReopen) {
                     if (mapContext === 'navigation') openNavigationMap();
                }
            }
        }
        if (targetId === 'view-all-locations-map') {
            const modalTable = document.querySelector('.reminder-table-modal');
             if (modalTable && modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
             if (modalTable) modalTable.remove();
            setTimeout(() => {
                openLocationsPreviewMap();
            }, 50);
        }
         if (targetId === 'close-locations-preview') {
            const previewModal = document.getElementById('locations-preview-modal');
            if (previewModal) {
                if (locationsPreviewMap) {
                    try { locationsPreviewMap.remove(); } catch (e) {}
                    locationsPreviewMap = null;
                }
                if (mapLayersControlLocationsPreview) {
                    try {mapLayersControlLocationsPreview.remove();} catch(e){}
                    mapLayersControlLocationsPreview = null;
                }
                clearModalAutoCloseTimer(previewModal, target, 'locations-preview-modal');
                previewModal.classList.add('hidden');
            }
        }
        if (targetId === 'close-address-suggestions-modal') {
            hideAddressSuggestionsModal();
        }
    });
    const configModal = document.getElementById('config-modal');
    if (configModal) {
        configModal.addEventListener('click', function(event) {
            const target = event.target;
            if (target.matches('.config-tab-button')) {
                const tabTarget = target.dataset.tabTarget;
                configModal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                configModal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (configModal.querySelector(tabTarget)) {
                    configModal.querySelector(tabTarget).classList.add('active');
                }
            }
        });
    }
    const bookmarkGrid = document.getElementById('bookmark-grid');
    if (bookmarkGrid) {
        bookmarkGrid.addEventListener('click', function(event) {
            const link = event.target.closest('a.bookmark-item');
            if (link && link.href && link.href.startsWith("map-action:")) {
                event.preventDefault();
                const action = link.href.split(":")[1];
                if (action === "openRemindersMapWithNoRadars") {
                    closeOtherModals();
                    setTimeout(() => {
                        const existingPreviewModal = document.getElementById('locations-preview-modal');
                        if (existingPreviewModal && !existingPreviewModal.classList.contains('hidden')) {
                            showToast("El mapa de ubicaciones (sin radar) ya est abierto", "info");
                        } else {
                           openLocationsPreviewMap();
                        }
                    }, 50);
                } else if (action === "openRemindersMap") {
                    closeOtherModals();
                    setTimeout(() => {
                        const mapModalElement = document.getElementById('reminders-location-map-modal');
                        if (mapModalElement && !mapModalElement.classList.contains('hidden')) {
                            showToast("El mapa de navegacin/ubicaciones ya est abierto", "info");
                            if (navigationMapInstance) {
                                requestAnimationFrame(() => {
                                    requestAnimationFrame(() => {
                                        if (navigationMapInstance) {
                                            try {
                                                 navigationMapInstance.resize();
                                             } catch (e) {  }
                                        }
                                    });
                                });
                            }
                        } else {
                           openNavigationMap();
                        }
                    }, 50);
                }
            }
        });
    }
    
    const accidentAlertButton = document.getElementById('accident-alert-button');
    if (accidentAlertButton) {
        accidentAlertButton.addEventListener('click', () => {
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
            openAlertModal();
        });
    }
}
// ===================================================================
// NOMBRE: showDeviationModal (VERSIN FINAL CON LGICA DUAL Y TEMPORIZADOR)
// RESUMEN: Muestra un modal diferente si la ruta es simple o multietapa.
//          Para rutas multietapa, incluye un temporizador de 10s que
//          selecciona "Ir a Destino Final" como accin por defecto.
// ===================================================================
function showDeviationModal() {
    if (isDeviationModalActive) return;
    console.log("[MODAL DESVO] Mostrando modal de opciones de desvo...");
    closeOtherModals('deviation-modal');
    isDeviationModalActive = true;
    let modal = document.getElementById('deviation-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'deviation-modal';
        document.body.appendChild(modal);
    }

    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    const unvisitedSelectableStages = actualWaypoints.filter(wp => !wp.visited && wp.type !== 'S' && wp.type !== 'S_Recalc' && wp.type !== 'F');
    const iconHtml = `<img src="PNG/APELIGRO.png" alt="Icono de Peligro" style="width: 115px; height: 70px; margin: 0 auto 10px auto; display: block;">`;

    // Lgica dual: Comprobar si hay etapas intermedias sin visitar
    if (unvisitedSelectableStages.length === 0) {
        // ESCENARIO 1: RUTA SIMPLE (o solo queda el destino final)
        console.log("[MODAL DESVO] Ruta simple detectada. Mostrando modal informativo y comenzando reclculo automtico.");
        modal.innerHTML = `
            <style>
                #deviation-modal h2 { font-size: 1.5rem; margin-bottom: 10px; color: #333; }
                #deviation-modal p { font-size: 1.1rem; line-height: 1.4; margin-bottom: 15px; font-weight: bold; }
                #deviation-status-spinner { border: 4px solid rgba(0, 0, 0, 0.1); border-left-color: #28a745; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 0 auto; }
                @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
            </style>
            <h2>Desvo Detectado</h2>
            ${iconHtml}
            <p id="deviation-modal-message">Recalculando nueva ruta...</p>
            <div id="deviation-status-spinner"></div>
        `;
        modal.classList.remove('hidden');
        recalculateAndDrawRoute(true); // Inicia el bucle de reclculo automtico

    } else {
        // ESCENARIO 2: RUTA MULTIETAPA con opciones para el usuario y temporizador
        console.log("[MODAL DESVO] Ruta multietapa detectada. Mostrando modal interactivo con temporizador.");
        const finalDestination = actualWaypoints[actualWaypoints.length - 1];
        const stageButtonsHtml = unvisitedSelectableStages.map(wp => {
            const addressSummary = wp.address ? (wp.address.split(',')[0].trim()) : `Etapa ${wp.label}`;
            return `<button class="deviation-stage-button" data-waypoint-id="${wp.id}">ETAPA ${wp.label}: ${addressSummary}</button>`;
        }).join('');

        modal.innerHTML = `
            <style>
                 #deviation-modal h2 { font-size: 1.5rem; margin-bottom: 10px; color: #333; flex-shrink: 0; }
                 #deviation-modal p { font-size: 1rem; line-height: 1.4; margin-bottom: 15px; flex-shrink: 0; font-weight: bold; }
                 #deviation-modal .deviation-options-container { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; }
                 #deviation-modal .stage-list-scroll-container { overflow-y: auto; display: flex; flex-direction: column; gap: 10px; padding: 10px; margin: 5px 0; border-top: 2px solid #C0B080; border-bottom: 2px solid #C0B080; background-color: rgba(0,0,0,0.05); border-radius: 6px; }
                 #deviation-modal #scroll-hint-text { font-size: 0.85rem; font-style: italic; color: #555; margin-top: 5px; margin-bottom: -5px; display: none; }
                 #deviation-modal button { padding: 12px 15px; border: none; border-radius: 5px; font-size: 1.1rem; font-weight: bold; cursor: pointer; transition: background-color 0.2s ease; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-shrink: 0; }
                 #deviation-modal #deviation-go-to-final { background-color: #28a745; color: white; margin-bottom: 5px; }
                 #deviation-modal .deviation-stage-button { background-color: #007bff; color: white; }
                 #deviation-modal #deviation-cancel { background-color: #6c757d; color: white; margin-top: 5px; }
            </style>
            <h2>Desvo Detectado</h2>
            ${iconHtml}
            <p>Elige tu prximo destino o se seleccionar el destino final automticamente.</p>
            <div class="deviation-options-container">
                <button id="deviation-go-to-final">Ir a Destino Final (${finalDestination.address.split(',')[0].trim()}) <span class="button-countdown-timer"></span></button>
                <p id="scroll-hint-text"></p>
                <div class="stage-list-scroll-container">
                    ${stageButtonsHtml}
                </div>
                <button id="deviation-cancel">Cancelar (Seguir Desviado)</button>
            </div>
        `;
        modal.classList.remove('hidden');

        const goToFinalButton = document.getElementById('deviation-go-to-final');

        const clearDefaultActionTimer = () => {
            clearModalAutoCloseTimer(modal, goToFinalButton, 'deviation-modal-default-action');
        };

        goToFinalButton.addEventListener('click', (e) => {
            e.stopPropagation();
            clearDefaultActionTimer();
            handleFinalDestinationSelection();
        });

        document.querySelectorAll('.deviation-stage-button').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                clearDefaultActionTimer();
                const waypointId = parseInt(e.currentTarget.dataset.waypointId);
                handleStageSelectionFromDeviationModal(waypointId);
            });
        });

        document.getElementById('deviation-cancel').addEventListener('click', (e) => {
            e.stopPropagation();
            clearDefaultActionTimer();
            closeModalAndProceed();
        });
        
        // Iniciar el temporizador de 10 segundos como accin por defecto
        addModalAutoCloseTimer(modal, goToFinalButton, 'deviation-modal-default-action', 10000);

        const scrollContainer = modal.querySelector('.stage-list-scroll-container');
        const scrollHint = modal.querySelector('#scroll-hint-text');
        requestAnimationFrame(() => {
            if (scrollContainer.scrollHeight > scrollContainer.clientHeight) {
                scrollHint.textContent = `(Deslice para ver las ${unvisitedSelectableStages.length} etapas restantes)`;
                scrollHint.style.display = 'block';
            }
        });
    }
}

// ===================================================================
// NOMBRE: handleFinalDestinationSelection (NUEVA FUNCIN)
// RESUMEN: Maneja la lgica cuando el usuario elige ir al destino final.
// ===================================================================
async function handleFinalDestinationSelection() {
    const finalDestination = navigationWaypoints.find(wp => wp.type === 'F');
    const startPoint = navigationWaypoints.find(wp => wp.isRecalculatedStart || wp.type === 'S');

    if (!finalDestination || !startPoint) {
        showToast("Error: No se pudo determinar el inicio o el fin de la ruta.", "error");
        closeModalAndProceed();
        return;
    }

    navigationWaypoints = [startPoint, finalDestination];
    closeModalAndProceed();
    
    try {
        await recalculateAndDrawRoute(true, true);
        renderWaypointMarkers();
        deviationCheckGracePeriodUntil = Date.now() + 5000;
    } catch (error) {
        showToast("Error al recalcular la ruta hacia el destino final.", "error");
    }
}

// ===================================================================
// NOMBRE: handleStageSelectionFromDeviationModal (NUEVA FUNCIN)
// RESUMEN: Maneja la lgica cuando el usuario elige una etapa intermedia.
// ===================================================================
async function handleStageSelectionFromDeviationModal(selectedWaypointId) {
    const selectedIndex = navigationWaypoints.findIndex(wp => wp.id === selectedWaypointId);
    const startPoint = navigationWaypoints.find(wp => wp.isRecalculatedStart || wp.type === 'S');

    if (selectedIndex === -1 || !startPoint) {
        showToast("Error: No se encontr la etapa o el punto de inicio.", "error");
        closeModalAndProceed();
        return;
    }

    const newWaypoints = [startPoint];
    for (let i = selectedIndex; i < navigationWaypoints.length; i++) {
        const wp = navigationWaypoints[i];
        if (wp && !wp.isInternal && !wp.isRecalculatedStart) {
            newWaypoints.push(wp);
        }
    }
    
    navigationWaypoints = newWaypoints;
    closeModalAndProceed();
    
    try {
        await recalculateAndDrawRoute(true, true);
        renderWaypointMarkers();
        deviationCheckGracePeriodUntil = Date.now() + 5000;
    } catch (error) {
        showToast("Error al recalcular la ruta hacia la etapa seleccionada.", "error");
    }
}
    

// ===================================================================
// NOMBRE: OFFFrecalculateAndDrawRoute (VERSIN DEFINITIVA CON GESTIN DE ESTADO ATMICA)
// RESUMEN: Lgica de reclculo final que garantiza que todas las variables
async function OFFrecalculateAndDrawRoute(preserveAccumulatedStats = false, isUserAction = false) {
    const RETRY_CADENCE_MS = 3000;
    const MAX_RETRIES = 5; // Lmite para evitar bucles infinitos
    let attempt = 1;

    // Bucle de reintento para mxima robustez ante fallos de red o del servidor
    while (attempt <= MAX_RETRIES) {
        // Solo continuamos el bucle si el modal de desvo sigue activo, o si es el primer intento
        if (!isDeviationModalActive && attempt > 1) break;
        
        console.log(`[RECALC] Intento #${attempt} de ${MAX_RETRIES}...`);
        isRecalculatingRoute = true;
        const wasNavigatingBeforeRecalc = isNavigating;

        try {
            const completedDistance = preserveAccumulatedStats ? totalDistanceTravelledForStats : 0;

            let waypointsForAPI = [];
            let currentHeading = null;
            
            // --- INICIO DE LA MODIFICACIN CLAVE: DIFERENCIAR PLANIFICACIN Y NAVEGACIN ---
            
            // Si NO estamos navegando (es decir, estamos en modo planificacin),
            // la ruta SIEMPRE debe calcularse desde el primer waypoint de la lista,
            // ignorando la posicin GPS actual. Esto corrige el bug al aadir mltiples etapas.
            if (!isNavigating) {
                console.log("[RECALC] Modo Planificacin: Calculando ruta desde la lista de waypoints definida.");
                waypointsForAPI = [...navigationWaypoints];
                currentHeading = null; // No usamos el rumbo del coche para la planificacin
            } else { 
                // La lgica original para cuando S estamos navegando (recalculando por desvo)
                console.log("[RECALC] Modo Navegacin Activa: Recalculando desde la posicin GPS actual.");
                if (navigationCurrentLocation) {
                    currentHeading = navigationCurrentLocation.heading;
                    waypointsForAPI.push({ lat: navigationCurrentLocation.latitude, lng: navigationCurrentLocation.longitude, isRecalculatedStart: true });
                    waypointsForAPI.push(...navigationWaypoints.filter(wp => !wp.visited));
                } else {
                    // Fallback si perdemos el GPS durante la navegacin: usamos la lista tal cual
                    waypointsForAPI = [...navigationWaypoints];
                }
            }
            // --- FIN DE LA MODIFICACIN CLAVE ---

            const validWaypoints = waypointsForAPI.filter(wp => wp && typeof wp.lat === 'number' && typeof wp.lng === 'number');
            if (validWaypoints.length < 2) { 
                isRecalculatingRoute = false; 
                return; // No hay suficientes puntos para una ruta
            };

            const coordsString = validWaypoints.map(wp => `${wp.lng},${wp.lat}`).join(';');
            
            const result = await fetchRouteData(coordsString, currentHeading);
            if (result.error) throw result.error;

            const newRouteData = result.routeData;
            const newRemainingRoute = newRouteData.routes[0];

            // --- INICIO DE LA SOLUCIN: Guardia de Calidad Contextual v2 ---
            // Comprueba si la ruta devuelta tiene una distancia sospechosamente corta.
            if (newRemainingRoute && newRemainingRoute.distance < 10) { // Umbral de 10m por flexibilidad
                
                // ANTES de rechazarla, verificamos si es una llegada legtima.
                const startPointOfRecalc = validWaypoints[0]; // Nuestra posicin GPS actual
                const endPointOfRecalc = validWaypoints[validWaypoints.length - 1]; // El destino de este clculo
                
                // Calculamos la distancia fsica (en lnea recta) al destino.
                const physicalDistanceToDestination = calculateDistance(
                    startPointOfRecalc.lat, 
                    startPointOfRecalc.lng, 
                    endPointOfRecalc.lat, 
                    endPointOfRecalc.lng
                );

                // SOLO si la ruta es "cero" PERO estamos lejos del destino, es un error.
                if (physicalDistanceToDestination > WAYPOINT_VISITED_THRESHOLD_METERS) { // 70 metros
                    console.warn(`[GUARDIA DE CALIDAD] Ruta de distancia cero (${newRemainingRoute.distance.toFixed(1)}m) recibida, pero la distancia fsica al destino es de ${physicalDistanceToDestination.toFixed(1)}m. Forzando reintento.`);
                    throw new Error("Ruta invlida (distancia cero) recibida del servidor.");
                }
                // Si no se cumple la condicin, significa que la distancia es cero porque
                // realmente hemos llegado, por lo que permitimos que la ruta contine.
            }
            // --- FIN DE LA SOLUCIN ---

            await drawRouteOnMap(newRemainingRoute);
            
            navigationCurrentRouteData = newRouteData;
            
            if (preserveAccumulatedStats) {
                accumulatedDistanceBeforeCurrentSegment = completedDistance;
            }

            tripInitialOverallEtaTime = new Date(Date.now() + newRemainingRoute.duration * 1000);
            if (newRemainingRoute.legs && newRemainingRoute.legs.length > 0) {
                currentStageInitialExpectedEtaTime = new Date(Date.now() + newRemainingRoute.legs[0].duration * 1000);
            } else {
                currentStageInitialExpectedEtaTime = null;
            }

            renderWaypointMarkers();
            updateNavigationProgressDisplay(newRemainingRoute, 0);
            updateTurnByTurnDisplay(newRemainingRoute, 0);
            showDestinationName();
            toggleRadaresRuta(document.getElementById('radares-ruta-checkbox').checked);
            toggleTareasRuta(document.getElementById('tareas-ruta-checkbox').checked);
            updateStartNavigationButtonState();
            updateNavigationButtonColor();

            showToast("Ruta recalculada con xito!", "success");
            closeModalAndProceed();
            return; // Salimos de la funcin con xito
            
        } catch (error) {
            console.error(`[RECALC] Fallo en intento #${attempt}:`, error);
            if (attempt === MAX_RETRIES) {
                showToast("Fallo al recalcular la ruta tras varios intentos. Comprueba tu conexin.", "error");
                closeModalAndProceed(); // Cerrar el modal para no bloquear al usuario
            } else {
                showToast(`Error al recalcular (${attempt}/${MAX_RETRIES}). Reintentando...`, "warning");
                await new Promise(resolve => setTimeout(resolve, RETRY_CADENCE_MS));
            }
        } finally {
            isRecalculatingRoute = false; // Se resetea en cada intento
            isNavigating = wasNavigatingBeforeRecalc;
            attempt++;
        }
    }
    console.log("[RECALC] Bucle de reclculo finalizado sin xito.");
}    




// ===================================================================
// NOMBRE: recalculateAndDrawRoute (VERSIN DEFINITIVA CON GESTIN DE ESTADO ATMICA)
// RESUMEN: Lgica de reclculo final que garantiza que todas las variables
async function recalculateAndDrawRoute(preserveAccumulatedStats = false, isUserAction = false) {
    const RETRY_CADENCE_MS = 3000;
    const MAX_RETRIES = 5; // Lmite para evitar bucles infinitos
    let attempt = 1;

    // Bucle de reintento para mxima robustez ante fallos de red o del servidor
    while (attempt <= MAX_RETRIES) {
        // Solo continuamos el bucle si el modal de desvo sigue activo, o si es el primer intento
        if (!isDeviationModalActive && attempt > 1) break;
        
        console.log(`[RECALC] Intento #${attempt} de ${MAX_RETRIES}...`);
        isRecalculatingRoute = true;
        const wasNavigatingBeforeRecalc = isNavigating;

        try {
            // <<< INICIO DE LA CORRECCIN CLAVE: USO DIRECTO DE LA VARIABLE DE ESTADO >>>
            // En lugar de recalcular, usamos directamente la distancia total que ya hemos registrado.
            // Esta es la "fuente de verdad" del progreso del viaje.
            const completedDistance = preserveAccumulatedStats ? totalDistanceTravelledForStats : 0;
            // <<< FIN DE LA CORRECCIN CLAVE >>>

            let waypointsForAPI = [];
            let currentHeading = null;
            
            // --- Lgica de planificacin vs. navegacin (sin cambios) ---
            if (!isNavigating) {
                console.log("[RECALC] Modo Planificacin: Calculando ruta desde la lista de waypoints definida.");
                waypointsForAPI = [...navigationWaypoints];
                currentHeading = null;
            } else { 
                console.log("[RECALC] Modo Navegacin Activa: Recalculando desde la posicin GPS actual.");
                if (navigationCurrentLocation) {
                    currentHeading = navigationCurrentLocation.heading;
                    waypointsForAPI.push({ lat: navigationCurrentLocation.latitude, lng: navigationCurrentLocation.longitude, isRecalculatedStart: true });
                    waypointsForAPI.push(...navigationWaypoints.filter(wp => !wp.visited));
                } else {
                    waypointsForAPI = [...navigationWaypoints];
                }
            }
            // --- Fin de la lgica ---

            const validWaypoints = waypointsForAPI.filter(wp => wp && typeof wp.lat === 'number' && typeof wp.lng === 'number');
            if (validWaypoints.length < 2) { 
                isRecalculatingRoute = false; 
                return;
            };

            const coordsString = validWaypoints.map(wp => `${wp.lng},${wp.lat}`).join(';');
            
            const result = await fetchRouteData(coordsString, currentHeading);
            if (result.error) throw result.error;

            const newRouteData = result.routeData;
            const newRemainingRoute = newRouteData.routes[0];

            // --- Guardia de Calidad (sin cambios) ---
            if (newRemainingRoute && newRemainingRoute.distance < 10) { 
                const startPointOfRecalc = validWaypoints[0];
                const endPointOfRecalc = validWaypoints[validWaypoints.length - 1];
                const physicalDistanceToDestination = calculateDistance(
                    startPointOfRecalc.lat, 
                    startPointOfRecalc.lng, 
                    endPointOfRecalc.lat, 
                    endPointOfRecalc.lng
                );
                if (physicalDistanceToDestination > WAYPOINT_VISITED_THRESHOLD_METERS) {
                    console.warn(`[GUARDIA DE CALIDAD] Ruta de distancia cero (${newRemainingRoute.distance.toFixed(1)}m) recibida, pero la distancia fsica al destino es de ${physicalDistanceToDestination.toFixed(1)}m. Forzando reintento.`);
                    throw new Error("Ruta invlida (distancia cero) recibida del servidor.");
                }
            }
            // --- Fin de la Guardia de Calidad ---

            await drawRouteOnMap(newRemainingRoute);
            
            navigationCurrentRouteData = newRouteData;
            
            // <<< INICIO DE LA CORRECCIN CLAVE: REINICIO ATMICO DEL ESTADO >>>
            // Despus de obtener la nueva ruta (sin importar el proveedor),
            // forzamos un reinicio limpio de las variables que dependen de la
            // estructura interna de la ruta.
            
            if (preserveAccumulatedStats) {
                // Preservamos el progreso real del viaje.
                accumulatedDistanceBeforeCurrentSegment = completedDistance;
            } else {
                // Si no se preservan (inicio de nueva ruta), se resetean.
                accumulatedDistanceBeforeCurrentSegment = 0;
            }

            // Reseteamos los "punteros" que leen la estructura de la ruta.
            // Ahora leern desde el principio del "nuevo libro".
            currentLegIndexNav = 0;
            currentStepIndexNav = 0;
            lastProcessedStepIdentifier = null;
            lastProcessedStepForLock = null;
            lastDisplayedManeuverIcon = null;

            // La "promesa" del ETA de la siguiente etapa se recalcula basndose
            // en los datos frescos de la nueva ruta. El ETA final no se toca aqu.
            if (newRemainingRoute.legs && newRemainingRoute.legs.length > 0) {
                currentStageInitialExpectedEtaTime = new Date(Date.now() + newRemainingRoute.legs[0].duration * 1000);
            } else {
                currentStageInitialExpectedEtaTime = null;
            }
            // <<< FIN DE LA CORRECCIN CLAVE >>>
            
            renderWaypointMarkers();
            updateNavigationProgressDisplay(newRemainingRoute, 0); // Se llama con progreso 0 en el *nuevo* tramo
            updateTurnByTurnDisplay(newRemainingRoute, 0); // Igual aqu
            showDestinationName();
            toggleRadaresRuta(document.getElementById('radares-ruta-checkbox').checked);
            toggleTareasRuta(document.getElementById('tareas-ruta-checkbox').checked);
            updateStartNavigationButtonState();
            updateNavigationButtonColor();

            showToast("Ruta recalculada con xito!", "success");
            closeModalAndProceed();
            return; // Salimos de la funcin con xito
            
        } catch (error) {
            console.error(`[RECALC] Fallo en intento #${attempt}:`, error);
            if (attempt === MAX_RETRIES) {
                showToast("Fallo al recalcular la ruta tras varios intentos. Comprueba tu conexin.", "error");
                closeModalAndProceed();
            } else {
                showToast(`Error al recalcular (${attempt}/${MAX_RETRIES}). Reintentando...`, "warning");
                await new Promise(resolve => setTimeout(resolve, RETRY_CADENCE_MS));
            }
        } finally {
            isRecalculatingRoute = false;
            isNavigating = wasNavigatingBeforeRecalc;
            attempt++;
        }
    }
    console.log("[RECALC] Bucle de reclculo finalizado sin xito.");
}




    
// ===================================================================
// NOMBRE: closeModalAndProceed (MODIFICADA)
// RESUMEN: Cierra el modal de desvo y llama a la reanudacin de simulacin.
// ===================================================================
function closeModalAndProceed() {
    isDeviationModalActive = false;
    deviationStartTime = 0;
    const modal = document.getElementById('deviation-modal');
    if (modal) {
        modal.classList.add('hidden');
    }

    if (wasSimulatingBeforeRecalc) {
        wasSimulatingBeforeRecalc = false; // Se resetea la bandera
//      simulatedDistanceAlongRoute = 0; 
        showToast("Desvo recalculado. Reanudando simulacin...", "info");
        setTimeout(() => {
            // CAMBIO CLAVE! Pasamos 'true' para indicar que es una reanudacin.
            startAutomatedRouteSimulation(currentSimulationSpeedKmph, true); 
        }, 100);
    }
}

// ===================================================================
// NOMBRE: handleLocateMeClick (VERSIN CORREGIDA SIN INTERFERENCIAS)
// RESUMEN: Gestiona el clic en "Ests Aqu" sin tocar ninguna variable de memoria de zoom.
// ===================================================================
function handleLocateMeClick(isExplicitAction = false) {
    if (!navigationMapInstance) return;

    clearLocateMeReactivationTimer();
    isManualZoomActive = false;
    
    navigationFollowUser = !navigationFollowUser;
    shouldCenterOnUser = navigationFollowUser;

    if (navigationFollowUser) {
    
        if (navigationCurrentLocation) {
            const viewOptions = {
                center: [navigationCurrentLocation.longitude, navigationCurrentLocation.latitude],
                zoom: 17, // Este botn siempre usar un zoom fijo de 17.
                essential: true
            };

            const mode = mapViewMode || 'static';
            if(mode === 'heading' || mode === 'perspective') {
                viewOptions.bearing = navigationCurrentLocation.heading || 0;
            }
            if(mode === 'perspective') {
                viewOptions.pitch = mapPitchValue;
            } else {
                viewOptions.pitch = 0;
            }
            navigationMapInstance.flyTo(viewOptions);

        } else {
            getCurrentLocation(coords => {
                if (navigationMapInstance) {
                     navigationMapInstance.flyTo({ center: [coords.longitude, coords.latitude], zoom: 17 });
                }
                updateInitialUserPosition(coords, navigationMapInstance);
            }, () => showToast("No se pudo obtener tu ubicacin.", "warning"));
        }
    } else {
        
        mapPreviousZoomLevel = navigationMapInstance.getZoom();
        
        if (!isExplicitAction) {
            startLocateMeReactivationTimer();
        }
    }
    
    updateLocateMeButtonsUI();
    updateStartNavigationButtonState();
}    

    
// ===================================================================
// NOMBRE: preflightSync (NUEVA FUNCIN)
// RESUMEN: Se ejecuta ANTES de que se cargue la app. Comprueba si hay datos ms nuevos en la nube
async function preflightSync() {
    const autoSyncEnabled = JSON.parse(localStorage.getItem('boardinggate_autoBackupOnLoad') || 'false');
    const { primaryId, isMobile } = parseUserId(localStorage.getItem('userData_userId'));
    const backupPassword = localStorage.getItem('userData_backupPassword');

    if (!autoSyncEnabled || !primaryId || isMobile || !backupPassword) {
        return;
    }

    try {
        const result = await callFirebase('getUserData', { userId: primaryId });

        if (result.status === 'success' && result.data) {
            const cloudTimestamp = new Date(result.data.fechaBackup || 0).getTime();
            const localTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');

            if (cloudTimestamp > localTimestamp + 10000) { // 10s de margen
                const backupCacheData = result.data.contenidoCacheCompleto;
                if (backupCacheData) {
                    showToast('Sincronizando datos desde la nube...', 'info', 3000);

                    const currentUserIdentity = localStorage.getItem('userData_userId') || primaryId;
                    for (const key in backupCacheData) {
                        if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                            localStorage.setItem(key, backupCacheData[key]);
                        }
                    }
                    if (currentUserIdentity) {
                        localStorage.setItem('userData_userId', currentUserIdentity);
                    }
                    localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
                } else {
                 }
            } else {
                 }
        } else {
             }
    } catch (error) {
        }
   }

// ===================================================================
// NOMBRE: uploadDirtyCacheOnLoad_Car (MODIFICADA)
// RESUMEN: Funcin especfica para el COCHE. Al cargar, si los datos locales son ms nuevos, los sube a la nube.
async function uploadDirtyCacheOnLoad_Car() {
    const autoSyncEnabled = JSON.parse(localStorage.getItem('boardinggate_autoBackupOnLoad') || 'false');
    const { primaryId, isMobile } = parseUserId(localStorage.getItem('userData_userId'));
    const backupPassword = localStorage.getItem('userData_backupPassword');

    if (!autoSyncEnabled || !primaryId || isMobile || !backupPassword) {
        return;
    }

    console.log(`Sync on Load: Checking if local data for ${primaryId} needs to be uploaded.`);
    const result = await callFirebase('getUserData', { userId: primaryId });

    if (result.status === 'success' && result.data) {
        const cloudTimestamp = new Date(result.data.fechaBackup || 0).getTime();
        const localTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');

        if (localTimestamp > cloudTimestamp + 10000) { // Si local es ms nuevo, subimos
            showToast(`Subiendo cambios locales de ${primaryId} a la nube...`, 'info', 4000);
            await autoSaveFromMobile(primaryId, backupPassword); // Reutilizamos la funcin de guardado
        }
    } else if (result.status === 'not_found') { // Si no hay nada en la nube, subimos lo local
        showToast(`Creando primer backup en la nube para ${primaryId}...`, 'info', 4000);
        await autoSaveFromMobile(primaryId, backupPassword);
    }
}

// ===================================================================
// NOMBRE: autoSaveFromMobile
// RESUMEN: Realiza un guardado automtico en Firebase, llamado por checkReminders para usuarios mviles.
async function autoSaveFromMobile(primaryId, backupPassword) {
    const cacheData = {};
    managedKeys.forEach(key => {
        const value = localStorage.getItem(key);
        if (value !== null) cacheData[key] = value;
    });
    const saveData = {
        userId: primaryId,
        usuario: primaryId,
        modelo: localStorage.getItem('userData_teslaModel') || '',
        anio: localStorage.getItem('userData_teslaYear') || '',
        provincia: localStorage.getItem('userData_teslaProvince') || '',
        rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
        datosCache: cacheData,
        backupPassword: backupPassword,
        fechaBackup: new Date().toISOString()
    };
    const saveResult = await callFirebase('saveUser', saveData);
    const toast = document.getElementById('mobile-autosave');
    if(toast) toast.remove();
    if (saveResult.status === 'success') {
        showToast('Cambios sincronizados con la nube.', 'success');
        // Actualizamos el timestamp de la ltima sincronizacin para que no vuelva a guardar inmediatamente
        lastMobileSyncTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0'); 
    } else {
        showToast(`Error al sincronizar: ${saveResult.message}`, 'error');
    }
}

// ===================================================================
// NOMBRE: DOMContentLoaded (MODIFICADO)
// RESUMEN: Punto de entrada principal. Ahora espera a la sincronizacin pre-vuelo ANTES de inicializar la app.
document.addEventListener('DOMContentLoaded', async () => {
     // 1. precargar ubicacion coche y Realiza la comprobacin y posible descarga de datos antes de hacer nada ms.
    preloadGpsLocation(); 
    await preflightSync();
     
     // 2. Una vez que el localStorage est actualizado, procede con la lgica de renderizado normal.
     storedPin = localStorage.getItem('password_pin');
     const savedPasswordActive = localStorage.getItem('password_active');
     isPasswordActive = savedPasswordActive ? JSON.parse(savedPasswordActive) : false;
     const initialDirectToNavPref = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
     const tempPreventDirectNav = sessionStorage.getItem(TEMP_PREVENT_DIRECT_NAV_KEY);

     if (isPasswordActive && storedPin && !(initialDirectToNavPref && !tempPreventDirectNav)) {
         promptForPin();
     } else {
         await initializeApp();
     }

    assignMapButtonListeners();
    document.body.addEventListener('click', function(event) {
        const target = event.target;
        const targetId = target.id || (target.closest('[id]') ? target.closest('[id]').id : null);

        if (targetId === 'config-close-modal') {
            const termsAcceptedForClose = localStorage.getItem('termsAccepted_v1') === 'true';
            if (!termsAcceptedForClose) {
                showToast('Debes aceptar las normas de uso para continuar.', 'warning');
                return;
            }
            const modal = document.getElementById('config-modal');
            if (modal && !modal.classList.contains('hidden')) {
                clearModalAutoCloseTimer(modal, target, 'config-modal');
                modal.classList.add('hidden');
                 const mapWasOpenBeforeConfig = sessionStorage.getItem('boardinggate_map_should_reopen_after_config') === 'true';
                 const mapContextToReopen = sessionStorage.getItem('mapContextToReopenAfterConfig');
                 sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');
                 sessionStorage.removeItem('mapContextToReopenAfterConfig');
                 if (mapWasOpenBeforeConfig && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !document.getElementById('reminders-location-map-modal')) {
                    if (mapContextToReopen === 'navigation') {
                        setTimeout(() => openNavigationMap(), 50);
                    }
                }
            }
        }
        if (target.matches('.config-tab-button')) {
            const modal = document.getElementById('config-modal');
            if(modal && modal.classList.contains('hidden') === false) {
                const tabTarget = target.dataset.tabTarget;
                modal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                modal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (modal.querySelector(tabTarget)) {
                    modal.querySelector(tabTarget).classList.add('active');
                }
            }
        }
        if (targetId === 'close-reminders-top' || targetId === 'close-reminders-bottom') {
            const modalTable = document.querySelector('.reminder-table-modal');
            if (modalTable) {
                if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                modalTable.remove();
                const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                const mapContext = sessionStorage.getItem('mapContext');
                sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                sessionStorage.removeItem('mapContext');
                if (fromReminderModal) {
                    fromReminderModal = false;
                    if (mapShouldReopen) {
                        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                        sessionStorage.setItem('mapContext', mapContext);
                    }
                    showReminderModal();
                } else if (mapShouldReopen) {
                     if (mapContext === 'navigation') openNavigationMap();
                }
            }
        }
        if (targetId === 'view-all-locations-map') {
            const modalTable = document.querySelector('.reminder-table-modal');
             if (modalTable && modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
             if (modalTable) modalTable.remove();
            setTimeout(() => {
                openLocationsPreviewMap();
            }, 50);
        }
         if (targetId === 'close-locations-preview') {
            const previewModal = document.getElementById('locations-preview-modal');
            if (previewModal) {
                if (locationsPreviewMap) {
                    try { locationsPreviewMap.remove(); } catch (e) {}
                    locationsPreviewMap = null;
                }
                if (mapLayersControlLocationsPreview) {
                    try {mapLayersControlLocationsPreview.remove();} catch(e){}
                    mapLayersControlLocationsPreview = null;
                }
                clearModalAutoCloseTimer(previewModal, target, 'locations-preview-modal');
                previewModal.classList.add('hidden');
            }
        }
        if (targetId === 'close-address-suggestions-modal') {
            hideAddressSuggestionsModal();
        }
    });
   const configModal = document.getElementById('config-modal');
    if (configModal) {
        configModal.addEventListener('click', function(event) {
            const target = event.target;
            if (target.matches('.config-tab-button')) {
                const tabTarget = target.dataset.tabTarget;
                configModal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                configModal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (configModal.querySelector(tabTarget)) {
                    configModal.querySelector(tabTarget).classList.add('active');
                }
            }
        });
    }
    const bookmarkGrid = document.getElementById('bookmark-grid');
    if (bookmarkGrid) {
        bookmarkGrid.addEventListener('click', function(event) {
            const link = event.target.closest('a.bookmark-item');
            if (link && link.href && link.href.startsWith("map-action:")) {
                event.preventDefault();
                const action = link.href.split(":")[1];
                if (action === "openRemindersMapWithNoRadars") {
                    closeOtherModals();
                    setTimeout(() => {
                        const existingPreviewModal = document.getElementById('locations-preview-modal');
                        if (existingPreviewModal && !existingPreviewModal.classList.contains('hidden')) {
                            showToast("El mapa de ubicaciones (sin radar) ya est abierto", "info");
                        } else {
                           openLocationsPreviewMap();
                        }
                    }, 50);
                } else if (action === "openRemindersMap") {
                    closeOtherModals();
                    setTimeout(() => {
                        const mapModalElement = document.getElementById('reminders-location-map-modal');
                        if (mapModalElement && !mapModalElement.classList.contains('hidden')) {
                            showToast("El mapa de navegacin/ubicaciones ya est abierto", "info");
                            if (navigationMapInstance) {
                                requestAnimationFrame(() => {
                                    requestAnimationFrame(() => {
                                        if (navigationMapInstance) {
                                            try {
                                                 navigationMapInstance.resize();
                                             } catch (e) {  }
                                        }
                                    });
                                });
                            }
                        } else {
                           openNavigationMap();
                        }
                    }, 50);
                }
            }
        });
    }
    
    const accidentAlertButton = document.getElementById('accident-alert-button');
    if (accidentAlertButton) {
        accidentAlertButton.addEventListener('click', () => {
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
            openAlertModal();
        });
    }

     window.addEventListener('beforeunload', () => {
         if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
         if (locationWatchId !== null && navigator.geolocation) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
         if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
         const openReminderModal = document.querySelector('.reminder-modal');
         if (openReminderModal && typeof openReminderModal.cleanUpModalTimers === 'function') { openReminderModal.cleanUpModalTimers(true); }
         Object.keys(globalModalTimers).forEach(modalId => {
            const timerData = globalModalTimers[modalId];
            if (timerData) {
                clearModalAutoCloseTimer(timerData.modalElement, timerData.closeButtonElement, modalId);
            }
         });
         globalModalTimers = {};
         const openTableModal = document.querySelector('.reminder-table-modal');
         if(openTableModal && openTableModal.autoCloseInterval) { clearInterval(openTableModal.autoCloseInterval); }
         const openPostponeModal = document.getElementById('postpone-options-modal');
         if(openPostponeModal && openPostponeModal.autoPostponeInterval) { clearInterval(openPostponeModal.autoPostponeInterval); }
         const openSavedLocationsModal = document.querySelector('.saved-locations-modal');
         if (openSavedLocationsModal && locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
         const simModalUnload = document.getElementById('simulation-modal');
         if (simModalUnload && simulationModalTimer) clearTimeout(simulationModalTimer);
         if (autoStartNavTimer) clearTimeout(autoStartNavTimer);
         if (isNavigationMapActive || navigationMapInstance) {
            closeNavigationMap(true);
         }
         if (locationsPreviewMap) {
             try { locationsPreviewMap.remove(); } catch(e){}
             locationsPreviewMap = null;
         }
         if (isAssignmentMode || isEditMode || isKeywordAssignmentMode) { saveCustomData(); }
         const filterInput = document.getElementById('grid-filter-input');
         if (filterInput && filterInput.value.trim()) {
              localStorage.setItem('gridFilterValue', filterInput.value);
         } else {
              localStorage.removeItem('gridFilterValue');
         }
          saveSettings();
          if (reminderModalMap) try {reminderModalMap.remove();} catch(e){}
          Object.values(previewMaps).forEach(map => {try {map?.remove();} catch(e){}});
          if (intersectionPreviewMap) try {intersectionPreviewMap.remove();} catch(e){}
          if (navigationChart) navigationChart.destroy();
          if (graphIntervalTimer) clearInterval(graphIntervalTimer);
     });
});

</script> 
<div id="map-garage" style="display: none;"></div>            
</body>
</html>
