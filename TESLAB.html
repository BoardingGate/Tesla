J40
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
        <!-- Metadatos Esenciales para SEO -->
    <meta name="description" content="BoardingGate Lanzador para Tesla: un dashboard y lanzador de aplicaciones web optimizado para la pantalla de tu Tesla. Accede a mapas avanzados, navegación con radares, recordatorios por ubicación, YouTube, y tus webs favoritas.">
    <meta name="keywords" content="Tesla, lanzador, dashboard, navegador, mapas, radares, BoardingGate, Tesla apps, Tesla Model 3, Tesla Model Y, Tesla web browser, YouTube Tesla, navegación Tesla">
    <meta name="author" content="BoardingGate">
    <meta name="robots" content="index, follow">

    <!-- Open Graph (para compartir en redes sociales como Facebook, WhatsApp, etc.) -->
    <meta property="og:title" content="BoardingGate: Navegador avanzado y Favoritos web para Tesla">
    <meta property="og:description" content="Un dashboard optimizado para la pantalla de tu Tesla. Accede a mapas, navegación con radares, recordatorios, y tus webs favoritas.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://boardinggate.github.io/Tesla/TESLAB%20(1).html">
    <meta property="og:image" content="https://boardinggate.github.io/Tesla/th.jpeg">
    <meta property="og:image:alt" content="Logo de BoardingGate para Tesla">
    <meta property="og:locale" content="es_ES">

    <!-- Twitter Card (para compartir en Twitter/X) -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@boardinggate">
    <meta name="twitter:creator" content="@boardinggate">
    <meta name="twitter:title" content="BoardingGate: Navegador avanzado y Favoritos web para Tesla">
    <meta name="twitter:description" content="Un dashboard optimizado para la pantalla de tu Tesla. Accede a mapas, navegación con radares, recordatorios, y tus webs favoritas.">
    <meta name="twitter:image" content="https://boardinggate.github.io/Tesla/th.jpeg">
    <meta name="twitter:image:alt" content="Logo de BoardingGate para Tesla">

    <!-- Metadatos Adicionales -->
    <meta name="theme-color" content="#ABAB99">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="BoardingGate">
    <link rel="apple-touch-icon" href="https://boardinggate.github.io/Tesla/th.jpeg"> 
    
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <title>BoardingGate: Navegador avanzado y Favoritos web para Tesla</title>
    <link rel="icon" href="https://boardinggate.github.io/Tesla/th.jpeg" type="image/jpeg">
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">                                                                                                                                                                                                                                          import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";   import { getFirestore, doc, setDoc, getDoc, getDocs, deleteDoc, collection, serverTimestamp, where, query, orderBy, limit, addDoc, writeBatch, startAfter } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js"; console.log("Firebase Init Script: STARTING initialization.");   const firebaseConfig = {apiKey: "AIzaSyCEAWL1Pj1OMBrGnXLOS79W3iDjMkmTQGw",authDomain: "boardinggate-1df74.firebaseapp.com",databaseURL: "https://boardinggate-1df74-default-rtdb.europe-west1.firebaseio.com",projectId: "boardinggate-1df74",storageBucket: "boardinggate-1df74.appspot.com", messagingSenderId: "771541345352",appId: "1:771541345352:web:0447d72b3383875ac5a47d" };    try {    const app = initializeApp(firebaseConfig);     window.db = getFirestore(app);   window.doc = doc;  window.setDoc = setDoc;  window.getDoc = getDoc;  window.collection = collection; window.getDocs = getDocs;  window.deleteDoc = deleteDoc;  window.serverTimestamp = serverTimestamp;  window.where = where; window.query = query; window.orderBy = orderBy;window.limit = limit; window.addDoc = addDoc;  window.writeBatch = writeBatch; window.startAfter = startAfter; console.log("Firebase Init Script: SUCCESS Firestore initialized and functions exposed globally. window.db is:", window.db);  } catch (e) { console.error("Firebase Init Script: ERROR during initialization!", e); }  console.log("Firebase Init Script: END of initialization block.");</script>
    
<script src="//cdn.jsdelivr.net/npm/eruda"></script>
<script>eruda.init();</script> 
    
    <link rel="stylesheet" href="tesla.css">
     
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.css' rel='stylesheet' />
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.js'></script>
    
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>                                                                                                                                                                                                                                               <script async src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCEAWL1PjlOMBrGnXLOS79W3iDJMkmTQGw&v=beta&libraries=places&callback=initMap&loading=async"></script> <script>   function initMap() {} </script>
</head>

<style>
  
</style>
    
</head>
<body class="min-h-screen bg-[#ABAB99] flex flex-col items-center p-6">

    <div class="reminder-count-globe" id="reminder-count-globe" style="display: none;"></div>

    <div id="unified-reminder-window" role="alertdialog" aria-labelledby="reminder-window-title" aria-describedby="reminder-window-desc">
        <div class="reminder-count-header" id="reminder-window-title">
            <div class="reminder-title-container">
                <span style="font-size: 1.3rem;" id="reminder-count-text-container">
                    <span id="current-reminder-index">1</span> de <span id="total-reminder-count">X</span> Recordatorios
                </span>
                <span class="swipe-hint" id="reminder-swipe-hint" style="font-size: smaller;">
                    (deslice lateralmente)
              </span>
            </div>
            <button id="hide-all-reminders-button" title="Posponer 1 minuto todos los recordatorios visibles">OCULTAR</button>
        </div>
        <div id="reminder-swiper-container" aria-live="polite">
        </div>
        <span id="reminder-window-desc" class="hidden">Deslice para ver los recordatorios vencidos. Use los botones para gestionar cada recordatorio.</span>
    </div>

    <div id="grid-filter-container">
        <input type="text" id="grid-filter-input" placeholder="Filtrar grid...">
        <button id="clear-filter-button" title="Limpiar filtro">×</button>
    </div>

<main>
    <div id="open-chat-area" style="cursor: pointer;" title="Abrir Chat">
        <div id="user-info-header">
            <span id="user-count-globe"></span>
            <span id="chat-icon-button">
                <span id="chat-message-globe">0</span>
            </span>
            <div id="user-id-display"></div>
        </div>
    </div>
    
    <div id="bookmark-grid">
    </div>
</main>
    
<div class="notices-icon-container">
    <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4194.jpg" alt="Toggle Avisos" class="notice-off-icon" id="notice-toggle-icon">
    <div class="notices-container">
        <div class="notice-wrapper">
            <span class="notice" id="current-notice"></span>
        </div>
    </div>
</div>

<footer>
    <div class="footer-content">
        <div class="header-container">
            <img src="https://boardinggate.github.io/Tesla/PNG/LOGOTESLA.jpg" class="header-logo">
            <div class="title-container">
                <h1 class="text-2xl font-bold inline">
                    <span class="text-2xl">BoardingGate</span>
                    <span class="text-base">Lanzador</span>
                    <span id="version" class="version-text"></span>
                </h1>
            </div>
        </div>
        <div class="footer-line">
          <a href="https://x.com/boardinggate/status/1857325553742721116?s=46" class="footer-link-green" target="_blank" rel="noopener noreferrer">Ahorremos un dinero con mis REFERIDOS</a>
        </div>

        <div class="statcounter-container">
          <div style="display: inline-flex; align-items: center; gap: 10px;">
            <script type="text/javascript">
              var sc_project=13126275;
              var sc_invisible=0;
              var sc_security="0fc568cc";
              var scJsHost = "https://";
              document.write("<sc"+"ript type='text/javascript' src='" +
              scJsHost+
              "statcounter.com/counter/counter.js'>"+"<"+"/script>");
            </script>
            <noscript><div class="statcounter"><a title="Web Analytics"
            href="https://statcounter.com/" target="_blank"><img
            class="statcounter"
            src="https://c.statcounter.com/13126275/0/0fc568cc/0/"
            alt="Web Analytics"
            referrerPolicy="no-referrer-when-downgrade"></a></div></noscript>
            <a href="https://statcounter.com/p13126275/?guest=1" class="footer-subtext">Legionarios de Elon</a>
          </div>
        </div>

        <p class="footer-subtext">La inteligencia tiene ciertos limites. La locura, casi ninguno 🫶 🤟</p>
    </div>
</footer>

<div id="reminders-location-map-modal" class="map-modal-hidden">

    <div id="toggle-map-header-buttons-panel">
         <img src="PNG/Coche_Sat.PNG" alt="Toggle Panel Mapa">
    </div>
    <div id="reminders-location-map-content-wrapper">
        <div id="reminders-location-map-header">
             <div class="button-row">
                <button id="close-reminders-location-map" class="reminders-map-button-action" title="Cerrar mapa y navegación"><img src="PNG/SALIR.PNG" alt="Salir"></button>
                <button id="locate-me-on-reminders-map" class="reminders-map-button-action" title="Mostrar mi posición actual y activar seguimiento"><img src="PNG/ESTASAQUI.PNG" alt="Estás Aquí"></button>
                <button id="start-navigation-button" class="reminders-map-button-action" title="Iniciar/Terminar Navegación"><img src="PNG/INICIARNAVEGACION.PNG" alt="Iniciar Navegación"></button>
                <button id="save-route-button" class="reminders-map-button-action hidden" title="Guardar Ruta Actual"><img src="PNG/GUARDARRUTA.PNG" alt="Guardar Ruta"></button>
                <button id="load-saved-route-button" class="reminders-map-button-action" title="Cargar Ruta Guardada"><img src="PNG/CARGARRUTA.PNG" alt="Cargar Ruta"></button>
                <button id="delete-current-route-button" class="reminders-map-button-action hidden" title="Borrar Ruta Actual del Mapa"><img src="PNG/BORRARRUTA.PNG" alt="Borrar Ruta"></button>
                <button id="add-radar-here" class="reminders-map-button-action" title="Crear RADAR en mi posición actual (radio 350m)"><img src="PNG/RADARAQUI.PNG" alt="Radar Aquí"></button>
                <button id="accident-alert-button-map" class="reminders-map-button-action" title="Informar de una incidencia de tráfico"><img src="https://boardinggate.github.io/Tesla/PNG/AACCIDENTE.png" alt="Informar Incidencia"></button>
                <button id="pdrs-ruta-button" class="reminders-map-button-action" title="Buscar Puntos de Recarga en Ruta"><img src="PNG/pdrs.png" alt="PDRs"></button>
                 <div class="radares-ruta-control">
                    <input type="checkbox" id="radares-ruta-checkbox">
                    <div class="radares-ruta-label-container">
                        <label for="radares-ruta-checkbox">Radares<br>Ruta</label>
                        <span id="radares-ruta-count" class="hidden">0</span>
                    </div>
                </div>
                <div class="tareas-ruta-control">
                    <input type="checkbox" id="tareas-ruta-checkbox">
                    <div class="tareas-ruta-label-container">
                        <label for="tareas-ruta-checkbox">Tareas<br>Ruta</label>
                        <span id="tareas-ruta-count" class="hidden">0</span>
                    </div>
                </div>
                <div class="mapbox-control">
                    <input type="checkbox" id="mapbox-primary-checkbox">
                    <div class="mapbox-label-container">
                        <label for="mapbox-primary-checkbox">Rutas<br>OSMR</label>
                    </div>
                </div>
                <button id="add-reminder-at-location-button" class="reminders-map-button-action" title="Añadir recordatorio en punto del mapa">
                    <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4197.jpg" alt="Añadir Recordatorio">
                </button>
                 <button id="toggle-simulate-gps-button" class="reminders-map-button-action" title="Activar/Desactivar Simulación GPS (recorrido o clic)"><img src="PNG/GPS.PNG" alt="Simular Recorrido"></button>
                <button id="simulate-route-button" class="reminders-map-button-action" title="Simular interacciones de ruta"><img src="PNG/SIMULAR.PNG" alt="Simular Ruta"></button>
             </div>
             <div class="button-row" id="search-row-map-header">
                <button id="reorder-route-stages-button" title="Ordenar Etapas de Ruta"><img src="./PNG/MOVER.PNG" alt="Ordenar Etapas"></button>
                <button id="map-location-search-button" class="reminders-map-button-action"><img src="./PNG/ANADIRPUNTO.PNG" alt="Añadir Punto Ruta"></button>
                <button id="clear-map-search-input-button" title="Limpiar búsqueda">X</button>
                </button>
                <input type="text" id="map-location-search-input" placeholder="Dirección,sitio,zona /Negocio /Ciudad /CP+Provincia (28001 Madrid /Lidl Lugo)">
                <input type="text" id="filter-input" placeholder="Filtro"> 
                <button id="navigation-map-help-button" class="reminders-map-button-action" title="Ayuda del mapa de navegación/radares"><img src="PNG/IMG_4326.PNG" alt="Ayuda"></button>
             </div>
        </div>
            <div id="reminders-location-map-div">
                    <div id="mapbox-map-actual-container"></div>
                    <div id="mini-nav-info-card"></div>
                     <div id="map-info-overlay"></div>
                      
             <div id="navigation-bottom-progress-bar" style="display: none;">
                <button id="toggle-progress-bar-lock" title="Bloquear/desbloquear panel de progreso" style="position: absolute; top: 0px; left: 0px; z-index: 2; flex-shrink: 0; background: none; border: none; padding: 0; cursor: pointer;">
                    <img src="PNG/IMG_4281.png" alt="Lock" style="width: 28px; height: 28px;">
                </button>
                <div style="flex-grow: 1; margin-left: 5px;">
                    <div id="navigation-top-info-bar" style="padding-left: 30px;">
                        <div id="turn-icon-container-styled">
                            <span id="turn-icon-display" class="turn-icon-display"></span>
                        </div>
                        <div class="maneuver-text-container">
                           <div>
                               <span id="maneuver-text-display" class="maneuver-text"></span>
                               <span id="street-name-display" class="street-name"></span>
                           </div>
                           <div id="distance-to-turn-formatted"></div>
                        </div>
                    </div>
                    <div id="distance-progress-bar-to-turn-container"> <div id="distance-progress-bar-to-turn"></div> </div>
                    <hr>
                    <div id="route-overall-progress-container">
                         <div id="route-overall-progress">
                             <img id="route-progress-icon" src="PNG/AVANCE.PNG" alt="Avance" style="display:none;">
                             <span id="route-progress-text"></span>
                         </div>
                    </div>
                    <div id="navigation-eta-info">
                        <div id="next-stage-info">
                            <strong id="next-stage-label">Próxima Etapa</strong>
                            <span id="next-stage-distance">-- km</span>   |  
                            <span id="next-stage-time">-- min</span>   |   ETA:
                            <span id="next-stage-eta">--:--</span>
                            <span id="next-stage-eta-deviation" class="eta-deviation"></span>
                        </div>
                        <div id="final-destination-info">
                            <strong> Destino</strong>
                            <span id="final-destination-distance">-- km</span>   |  
                            <span id="final-destination-time">-- min</span>   |   ETA:
                            <span id="final-destination-eta">--:--</span>
                            <span id="final-destination-eta-deviation" class="eta-deviation"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="pin-modal-overlay" class="hidden">
    <div id="pin-modal-content">
        <h2>Introducir Clave de Acceso</h2>
        <div class="modal-top-buttons" style="justify-content: center;">
            <button id="pin-submit-button">Entrar</button>
        </div>
        <label for="pin-input">Clave (4 cifras):</label>
        <input type="password" id="pin-input" maxlength="4" pattern="\d{4}" inputmode="numeric" required>
        <p id="pin-error-message"></p>
    </div>
</div>

<div id="versions-modal-overlay" class="versions-modal-overlay hidden">
    <div class="versions-modal-content">
        <h2>Histórico de versiones y recomendaciones</h2>
        <div class="modal-top-buttons" style="justify-content: flex-end;">
             <button id="close-versions-modal" style="flex: 0 1 auto; min-width: 120px;">Salir</button>
        </div>
        <pre id="versions-content">Cargando...</pre>
    </div>
</div>

<div id="reorder-stages-modal" class="hidden">
    <h2>Ordenar Etapas de Ruta</h2>
    <div class="modal-top-buttons">
        <button id="confirm-reorder-stages">Aceptar <span class="button-countdown-timer unified-countdown-style"></span></button>
        <button id="cancel-reorder-stages">Cancelar</button>
    </div>
    <p style="font-size: 0.9rem; color: #555; margin-bottom: 1rem;">Arrastra y suelta las etapas para cambiar su orden. Pulsa el aspa (X) para eliminar una etapa.</p>
    <ul id="sortable-stages-list">
    </ul>
</div>

<div id="scroll-toggle" class="scroll-toggle-button" title="Ir al inicio o fin">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M19 12l-7 7-7-7"/></svg>
</div>


<div id="config-modal" class="hidden">
    <div class="modal-top-buttons">
        <h2>Configuración y Datos</h2>
        <button id="config-close-modal" style="padding: 0.5rem 1rem; font-size:1rem;">Cerrar</button>
    </div>
    <div class="tab-buttons">
        <button class="config-tab-button active" data-tab-target="#tab-content-usuario">Usuario</button>
        <button class="config-tab-button" data-tab-target="#tab-content-pin">Clave Acceso</button>
        <button class="config-tab-button" data-tab-target="#tab-content-radares">RADARES</button>
        <button class="config-tab-button" data-tab-target="#tab-content-backup-restore">Backup/Restore</button>
        <button class="config-tab-button" data-tab-target="#tab-content-borrar">Borrar Datos</button>
        <button class="config-tab-button" data-tab-target="#tab-content-normas">Normas uso</button>
    </div>
    <div class="tab-contents">
        <div id="tab-content-usuario" class="config-tab-content active">
            <h3>Datos de Usuario y Sincronización</h3>
            <p style="font-size:.9rem;color:#555;margin-bottom:1.5rem;text-align:center;">
                Introduce un nombre de usuario único para guardar y recuperar tus datos en la nube.
            </p>
            <p style="font-size: .95rem; color: #005A9C; margin-bottom: 1.5rem; text-align: left; background-color: #e6f7ff; padding: 10px; border-radius: 5px; border-left: 5px solid #007bff;">
                <strong>Modo Compañero (Móvil):</strong> Para sincronizar datos desde tu móvil, usa tu nombre de usuario seguido de <strong>@MOVIL o MÓVIL</strong> (ej: `MI_USUARIO@MOVIL`).
                Al iniciar sesión, se cargarán los ÚLTIMOS DATOS que el coche haya GUARDADO EN LA NUBE. Cada cambio que hagas en el móvil (crear rutas, etc.) se guardará automáticamente en la nube para que esté disponible en el coche al CARGAR. 
                 -----IMPORTANTE!!!!---- SI QUIERES ENVIAR DATOS DESDE EL MÓVIL RECUERDA ANTES FORZAR UNA RECARGA DE LA PÁGINA EN EL COCHE (debes tener el check activo de copias automáticas) O REALIZAR MANUALMENTE UN BACKUP</p>
            <div class="user-data-grid">
                <div><label for="user-id">* ID Usuario (Único, no se puede cambiar):</label><input type="text" id="user-id" name="userId" required></div>
                <div><label for="tesla-model">Modelo Tesla:</label><input type="text" id="tesla-model" name="teslaModel"></div>
                <div><label for="tesla-year">Año Modelo:</label><input type="number" id="tesla-year" name="teslaYear" min="2012" max="2099"></div>
                <div><label for="tesla-province">Provincia:</label><input type="text" id="tesla-province" name="teslaProvince"></div>
                <div class="checkbox-container">
                    <input type="checkbox" id="allow-dms" name="allowDMs"><label for="allow-dms">Permitir MDs (vía admin)</label>
                    <span id="map-session-status" style="margin-left: 20px; font-size: 0.85em; color: #555;"></span>
                </div>
                
                <div class="checkbox-container" style="border-top: 1px solid #ccc; padding-top: 1rem; margin-top: 1rem;">
                    <input type="checkbox" id="config-auto-backup-on-load" name="autoBackup">
                    <label for="config-auto-backup-on-load">Sincronizar/Hacer copia de seguridad automática al cargar la página (en el coche)</label>
                </div>
            </div>
            <div class="user-buttons-container" style="margin-top:1.5rem;">
                <button id="config-save-user-firebase" style="background-color:#16A34A;color:white;">Validar usuario y/o Sincronizar/Guardar en la nube</button>
            </div>
            <p id="config-user-status" class="status-message"></p>
            </div>
         <div id="tab-content-pin" class="config-tab-content">
             <h3>Clave de Acceso (Local)</h3>
             <div class="pin-buttons-container" style="margin-bottom: 1rem;">
                 <button id="config-save-pin" style="background-color:#2563EB;color:white;">Guardar Clave y Preferencias</button>
                 <button id="config-remove-pin" style="background-color:#dc3545;color:white;">Quitar Clave</button>
             </div>
             <p style="font-size: 0.9rem; color: #555; margin-bottom: 1rem;">Establece una clave de 4 cifras para proteger el acceso inicial a la página</p>
             <div class="pin-config-layout">
                 <div class="pin-input-group">
                     <label for="config-pin-set">Establecer/Cambiar Clave:</label>
                     <input type="password" id="config-pin-set" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="4 cifras">
                 </div>
                 <div class="pin-input-group">
                     <label for="config-pin-confirm">Confirmar Clave:</label>
                     <input type="password" id="config-pin-confirm" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="Repetir 4 cifras">
                 </div>
             </div>
             <div class="checkbox-container" style="margin-top: 1.5rem; border-top: 1px solid #ccc; padding-top: 1rem;">
                <input type="checkbox" id="config-direct-to-nav" name="directToNav">
                <label for="config-direct-to-nav">Entrar directamente al Navegador de rutas</label>
            </div>
            
             <p id="config-pin-status" class="status-message"></p>
         </div>
         <div id="tab-content-radares" class="config-tab-content">
            <h3>Importar / Borrar Radares y Otros POIs</h3>
            <div class="radar-action-buttons" style="margin-bottom: 1rem;">
                <button id="import-radars-button">IMPORTAR RADARES y otros</button>
                <button id="delete-filtered-radars-button">BORRAR CACHÉ (según filtro)</button>
            </div>
            <p style="font-size:0.85rem; color:#444; margin-bottom:0.5rem;">
                Para <strong>importar</strong>, el filtro de "Palabras Clave" buscará coincidencias (OR) en el nombre del POI (ej: provincia, población, tipo).
                Los filtros de Lat/Lon pueden ser un valor único (aprox.) o un rango (ej: "<code>40.1 40.5</code>" para buscar entre esas latitudes). Si un filtro está vacío, no se aplica.
            </p>
             <p style="font-size:0.85rem; color:#444; margin-bottom:1rem;">
                 Los POIs importados (RADARES) se guardarán con un radio de <strong>400 metros</strong> y excluidos de la lista por defecto.
             </p>
            <p style="font-size:0.85rem; color:#444; margin-bottom:1.5rem;">
                Para <strong>borrar</strong>: Si NO se especifica NINGÚN filtro, se borrarán TODOS los recordatorios de tipo "RADAR" o excluidos de lista. Si se especifica algún filtro, se borrarán los que cumplan TODAS las condiciones activas (Palabras Clave OR, Latitud Y Longitud).
            </p>
            <div class="radar-filter-group">
                <div>
                    <label for="radar-filter-lat">Latitud (valor o "min max"):</label>
                    <input type="text" id="radar-filter-lat" placeholder="Ej: 40.123 o 40.0 40.5">
                </div>
                <div>
                    <label for="radar-filter-lon">Longitud (valor o "min max"):</label>
                    <input type="text" id="radar-filter-lon" placeholder="Ej: -3.567 o -4.0 -3.0">
                </div>
                <div style="grid-column: span 2;">
                    <label for="radar-filter-keywords">Palabras Clave (en nombre POI, separadas por espacio, condición OR):</label>
                    <input type="text" id="radar-filter-keywords" placeholder="Ej: FIJO CAMUFLADO MADRID">
                </div>
            </div>
            <div class="radar-import-options">
                <input type="checkbox" id="import-extra-radars-checkbox">
                <label for="import-extra-radars-checkbox">Importar también radares móviles, semáforo, etc (usa ficheros KLM adicionales)</label>
            </div>
             <div id="radar-import-progress-container" style="display:none;">
                 <progress id="radar-import-progress-bar" value="0" max="100"></progress>
                 <p id="radar-import-status" class="status-message"></p>
             </div>
         </div>
        <div id="tab-content-backup-restore" class="config-tab-content">
            <h3>Recuperar Backup / Hacer Copia en la Nube</h3>
            <p style="margin-bottom:1.2rem;">
                Para <strong>Recuperar</strong>, introduce tu ID de usuario y pulsa el botón naranja.<br>
                Para <strong>Hacer una Copia de Seguridad</strong>, asegúrate de que tu ID está introducido en la pestaña "Usuario" y pulsa el botón verde.
            </p>
            
            <div class="user-data-grid" style="grid-template-columns: 1fr auto; align-items: end; gap: 1rem;">
                <div style="grid-column: 1 / 2;">
                    <label for="restore-user-id">ID Usuario a recuperar:</label>
                    <input type="text" id="restore-user-id" placeholder="Tu apodo único (el que está en la pestaña usuario)...">
                </div>
                <div style="grid-column: 2 / 3; display: flex; flex-direction: column; gap: 0.5rem;">
                    <button id="config-restore-backup-firebase" style="background-color:#E65100;color:white;width:100%;padding: 0.6rem 1rem;">Recuperar Backup de la nube</button>
                    <button id="config-save-user-firebase-from-backup-tab" style="background-color:#16A34A;color:white;width:100%;padding: 0.6rem 1rem;">Hacer la copia de seguridad en la nube</button>
                </div>
            </div>
            <p id="config-restore-status" class="status-message"></p>
            <hr style="margin: 2rem 0;">
            <h3>Backup/Restore Local (Manual)</h3>
            <p style="font-size:.85rem; color:#555;">Esto es para copias manuales de texto. No interactúa con la nube</p>
            <div class="backup-restore-container" style="margin-top:1rem;">
                 <div>
                    <h4>Crear Backup Local</h4>
                     <button id="config-generate-backup" style="background-color:#2563EB;color:white; margin-bottom: 1rem;">Generar Código</button>
                    <textarea id="config-backup-display" readonly style="display:none;"></textarea>
                    <p id="config-backup-status" class="status-message"></p>
                </div>
                <div>
                    <h4>Restaurar Copia Local</h4>
                    <button id="config-restore-backup" style="background-color:#10B981;color:white; margin-bottom: 1rem;">Restaurar</button>
                    <textarea id="config-restore-input" placeholder="Pega el código de backup local aquí..."></textarea>
                </div>
            </div>
        </div>
        
        <div id="tab-content-borrar" class="config-tab-content borrar-container">
            <h3>Borrar Datos Locales</h3>
             <button id="config-restore-grid-button">RESTAURAR EL GRID ORIGINAL DE BOTONES</button>
             <p id="config-restore-grid-status" class="status-message" style="margin-bottom: 1.5rem;"></p>
            <h3 style="border-top: 1px solid #ccc; padding-top: 1.5rem; margin-top:1.5rem;">Acción Irreversible</h3>
            <button id="config-clear-cache" style="margin-bottom: 0.5rem;">Borrar TODO</button>
            <p>Elimina TODOS los datos locales.</p>
            <p><strong style="color:red;">¡Sin deshacer!</strong> Ten backup.</p>
        </div>
        <div id="tab-content-normas" class="config-tab-content">
             <h3 style="text-align: center; font-size: 1.4rem; color: #c0392b; margin-bottom: 1rem;">Aviso Importante: Uso de la Aplicación de Navegación</h3>
             <div style="text-align: left; font-size: 0.95rem; line-height: 1.5; color: #333; max-height: 45vh; overflow-y: auto; padding-right: 10px;">
                 <p>¡Bienvenido/a a nuestra aplicación de navegación de rutas para coche! Hemos diseñado esta herramienta con la mejor intención de ayudarte a planificar tus viajes.</p>
                 <p style="margin-top: 1rem;">Sin embargo, es fundamental que entiendas que el uso de esta aplicación es <strong>bajo tu propia y exclusiva responsabilidad</strong>. Al utilizar nuestra web, aceptas plenamente las siguientes condiciones:</p>
                 <ul style="list-style-type: disc; margin-left: 20px; margin-top: 1rem; space-y: 0.5rem;">
                     <li><strong>Responsabilidad del usuario:</strong> Eres el único/a responsable de la toma de decisiones al volante. Nuestra aplicación es una herramienta de apoyo y nunca debe sustituir tu juicio, la observación directa de las condiciones de la vía, las señales de tráfico o la normativa de circulación vigente.</li>
                     <li><strong>Supervisión constante:</strong> La aplicación debe ser utilizada siempre bajo tu supervisión activa. La información proporcionada (cartografía, trazados, indicaciones, etc.) puede no estar actualizada en tiempo real o contener imprecisiones. Las condiciones de la carretera, el tráfico o las regulaciones pueden cambiar sin previo aviso.</li>
                     <li><strong>Conducción segura:</strong> Prioriza siempre la seguridad. Evita manipular la aplicación mientras conduces y presta toda tu atención a la carretera. Detente en un lugar seguro para consultar la ruta si es necesario.</li>
                     <li><strong>Errores y fallos:</strong> Aunque nos esforzamos por ofrecer un servicio fiable, no podemos garantizar que la aplicación esté libre de errores, interrupciones o fallos. No nos hacemos responsables de ningún daño, perjuicio o incidente que pueda derivarse del uso o la imposibilidad de uso de esta aplicación.</li>
                     <li><strong>Actualizaciones:</strong> Te recomendamos mantener tu navegador y sistema operativo actualizados para el mejor funcionamiento de la aplicación, aunque no podemos garantizar la compatibilidad total con todos los dispositivos y versiones.</li>
                 </ul>
                 <p style="margin-top: 1rem;">Al continuar utilizando esta aplicación, confirmas que has leído, entendido y aceptado este descargo de responsabilidad. ¡Disfruta de tu viaje con precaución!</p>
             </div>
             <div style="text-align: center; margin-top: 1.5rem;">
                 <button id="accept-terms-button" style="background-color:#28a745; color:white; padding: 0.8rem 2rem; font-size: 1.2rem; border-radius: 0.25rem;">Acepto</button>
             </div>
         </div>
    </div>
</div>   
<div id="simulation-modal" class="hidden">
</div>

<div id="simulation-speed-modal" class="hidden">
</div>

<div id="locations-preview-modal" class="hidden">
    <h2 id="locations-preview-title">Ubicaciones (filtrado según tabla)</h2>
    <div id="locations-preview-map-container" style="height: calc(100% - 100px); width: 100%;"></div>
    <div class="modal-top-buttons" style="justify-content: center; margin-top: 1rem;">
        <button id="close-locations-preview">Salir</button>
    </div>
</div>

<div id="address-suggestions-modal" class="hidden">
    <h2 id="address-suggestions-title">Sugerencias de Dirección</h2>
    <ul id="address-suggestions-list"></ul>
    <div class="modal-top-buttons" style="justify-content: flex-end; margin-top: 1rem;">
        <button id="close-address-suggestions-modal" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
    </div>
</div>

<div id="deviation-modal" class="hidden">
</div>

<div id="arrival-stats-modal" class="hidden">
</div>

<div id="intersection-preview-map-window" class="hidden">
    <div id="intersection-preview-map-container"></div>
</div>

<div id="alert-modal-overlay" class="hidden">
    <div id="alert-modal-content">
      </div>
</div>

<div id="proximity-alert-modal" class="hidden">
</div>

<div id="flashing-border-overlay" class="hidden"></div>

<div id="chat-modal-overlay" class="hidden">
    <div id="chat-modal-content">
        <div id="chat-left-column">
            
            <div id="chat-input-area">
                <div id="chat-permission-warning" class="hidden"></div>
                <textarea id="chat-message-input" rows="4" maxlength="500" placeholder="Escribe un mensaje... (antecede @usuario para mensaje privado, o pulsa en el lateral. Para referirse simplemente nómbralo). Vida de los mensajes 96 horas. En el coche usa los comandos de voz. Elon cree en la humanidad, the White Monkey y yo también, ser educad@s."></textarea>
              
                <div id="chat-input-footer">
                    <div id="chat-buttons">
                        <button id="chat-send-button">Enviar</button>
                        <button id="chat-exit-button">Salir</button>
                    </div>
                    <div id="chat-char-counter">500</div>
                </div>
            </div>
            
            <div id="chat-messages-container"></div>
        </div>

        <div id="chat-right-column">
            <div id="chat-users-filter-container">
                <input type="text" id="chat-user-filter-input" placeholder="Filtrar por cualquier dato...">
            </div>
            <div id="chat-users-list"></div>
        </div>
    </div>
</div>
    
</div>    
    
<script>

    
//ofu mapbox
                                                                                                    mapboxgl.accessToken = "pk.eyJ1IjoiYm9hcmRpbmdnYXRlMTEiLCJhIjoiY21kOHdtMGU4MDEzaTJpcGh4cng0c3hmMiJ9.hDdGn_5VOMkN_bTuUowtRw";

    
//=======================================================        
    
    const originalToFixed = Number.prototype.toFixed;
    Number.prototype.toFixed = function(digits) {
        if (this === undefined || this === null || isNaN(this)) {
            try {
                throw new Error("Debug toFixed Call");
            } catch (e) {
            }
            return "NaN";
        }
        return originalToFixed.call(this, digits);
    };
 
    const MAP_STYLES = {
        "HÍBRIDO": "mapbox://styles/mapbox/satellite-streets-v12",
        "SATÉLITE": "mapbox://styles/mapbox/satellite-v9",
        "CALLES": "mapbox://styles/mapbox/standard"
    };
    const MAP_LEGACY_NAME_MAP = {
        "Satélite + Calles": "HÍBRIDO",
        "Satélite Puro": "SATÉLITE",
        "Mapa Normal": "CALLES"
    };
    
    const MAP_VIEW_MODES = {
        'NORTE': { pitch: 0, bearing: 0, mode: 'static', terrain: false },
        'AVANCE': { pitch: 0, bearing: null, mode: 'heading', terrain: false },
        '3D': { pitch: 62, bearing: null, mode: 'perspective', terrain: false },
        '3D RELIEVE': { pitch: 68, bearing: null, mode: 'relief', terrain: true }
    };
 
    let lerpRatePosition = 0.004;
    let lerpRateRotation = 0.001;
    let lerpRateZoom = 0.001;

    let markerAnimationState = {
    animationFrameId: null,
    currentLngLat: null,
    targetLngLat: null,
    currentIconRotation: 0,
    targetIconRotation: 0,
    currentMapCenter: null,   
    currentMapBearing: 0,
    targetMapBearing: 0,
    currentMapZoom: 16,      
    targetMapZoom: 16,
    currentMapPitch: 0,      
    targetMapPitch: 0,
    currentMapOffsetX: 0,
    targetMapOffsetX: 0,
    currentMapOffsetY: 0,
    targetMapOffsetY: 0,
    lastTimestamp: null,
    lastCameraTimestamp: null  
    };
    
    let nextManeuverStepForPreview = null;
    let isMobileSession = false;
    let processedRemindersCache = [];
    let isCacheDirty = true;
    let deviationCheckIntervalId = null;

    let zoomToggleMemory = null;
    let locateMeReactivationTimer = null;
    let locateMeCountdownInterval = null;
    let deviationCheckGracePeriodUntil = 0; 
    let wasSimulatingBeforeRecalc = false;
    const MAP_VIEW_OFFSET_X_KEY = 'mapView_offsetX';
    const MAP_VIEW_OFFSET_Y_KEY = 'mapView_offsetY';
    const MAP_VIEW_SHOW_MINIMAP_KEY = 'mapView_showMinimap';
    let mapOffsetX = 0;
    let mapOffsetY = 30;
    let showMinimapPreference = true;
    const MAP_VIEW_PITCH_KEY = 'mapView_pitch';
    let mapPitchValue = 62;

    let lastGpsUpdateTime = 0;
    const maneuverTexts = { 'turn-sharp right': 'Giro brusco a la derecha', 'turn-right': 'Gira a la derecha', 'bear-right': 'Mantente a la derecha', 'turn-sharp left': 'Giro brusco a la izquierda', 'turn-left': 'Gira a la izquierda', 'bear-left': 'Mantente a la izquierda', 'turn-': 'Gira', 'straight-straight': 'Sigue recto', 'straight-': 'Sigue recto', 'roundabout-': 'Entra en la rotonda', 'roundabout turn-': 'Toma la salida de la rotonda', 'rotary-': 'Entra en la glorieta', 'roundabout turn-left': 'En la rotonda, toma la salida hacia la izquierda', 'roundabout turn-right': 'En la rotonda, toma la salida hacia la derecha', 'roundabout turn-straight': 'En la rotonda, sigue recto', 'destination-left': 'Has llegado a tu destino  (a la izquierda)', 'destination-right': 'Has llegado a tu destino (a la derecha)', 'destination-': ' tu destino ', 'depart-': 'Inicia la ruta', 'arrive-left': 'Has llegado a tu destino (a la izquierda)', 'arrive-right': 'Has llegado a tu destino  (a la derecha)', 'arrive-': 'Has llegado a tu destino', 'continue-straight': 'Continúa recto', 'continue-': 'Continúa', 'new name-': 'Continúa por', 'fork-right': 'En la bifurcación, mantente a la derecha', 'fork-left': 'En la bifurcación, mantente a la izquierda', 'fork-': 'En la bifurcación', 'merge-left': 'Incorpórate por la izquierda', 'merge-right': 'Incorpórate por la derecha', 'merge-straight': 'Incorpórate', 'merge-': 'Incorpórate', 'end of road-left': 'Al final de la vía, gira a la izquierda', 'end of road-right': 'Al final de la vía, gira a la derecha', 'end of road-': 'Fin de la vía', 'u turn-left': 'Haz un cambio de sentido (hacia la izquierda)', 'u turn-right': 'Haz un cambio de sentido (hacia la derecha)', 'u turn-': 'Haz un cambio de sentido', 'use lane-': 'Usa el carril indicado', 'notification-': 'Atención', 'exit roundabout-': 'Sal de la rotonda', 'exit rotary-': 'Sal de la glorieta', 'off ramp-': 'Vía de salida', 'on ramp-': 'Incorporate a la vía de Entrada',};
    let distanceToNextManeuverOSRM = Infinity;
    let mapHeaderButtonsVisible = true;
    
    const MAX_SESSIONS_KEY = 'boardinggate_max_map_sessions';
    let autoStartNavModalTimer = null;
    let mapSessionStartTime = null;
    let speedMarkerFeatures = []; 
    let mapPreviousZoomLevelForPDRs = 0;
    const AUTO_ZOOM_MODE_KEY = 'boardinggate_autoZoomMode_v2';
    let isManualZoomActive = false;
    let manualZoomTimeout = null;
    let mapViewMode = 'relief'; 
    let isSimulatingFreeDrive = false; 
    let isFreeDriveActive = false;
    let isFreeDrivePaused = false;
    let freeDriveStats = null;
    let lastDynamicRadarCheck = 0;
    window.radarsCache = null;
    window.radarsSpatialIndex = null;
    let isRadarCacheInitializing = false;
    let lastDisplayedManeuverIcon = null;
    let selectedStageRoutes = new Map();
    let alternativeRoutesCache = new Map();
    let alternativeRouteLayers = [];
    let realtimeSpeedUpdateInterval = null;
    let tripInitialDurationSec = null;
    let tripInitialDistanceMeters = null;
    let mapHeaderAutohideTimer = null;
    let tripInitialOverallEtaTime = null;
    let currentStageInitialExpectedEtaTime = null;
    let accumulatedDeviationMs = 0;
    let minAverageSpeedInTrip = Infinity;
    let maxAverageSpeedInTrip = -Infinity;

    const OCM_API_KEY = "be9a78f7-0f5e-4f28-b742-4b7ab4b7eb5a";
    const MAPBOX_ACCESS_TOKEN = "pk.eyJ1IjoiYm9hcmRpbmdnYXRlMTEiLCJhIjoiY21kOHdtMGU4MDEzaTJpcGh4cng0c3hmMiJ9.hDdGn_5VOMkN_bTuUowtRw";
    let isGraphingActive = false;
    let pdrSearchState = 'initial'; 
    let lastPdrSearchResults = []; 
    let currentChargingPointsOnRoute = [];
 

    let tripStartLocationForStats = null; 
    let stageScrollTimeout;
    let locationsPreviewMap = null;
    let globalModalTimers = {};
    const originalBookmarks = [ { name: "YouTube", url: "https://www.youtube.com" }, { name: "Google", url: "https://www.google.com" }, { name: "GDrive", url: "https://drive.google.com", favicon: "./PNG/IMG_4172.png" }, { name: "GMail", url: "https://mail.google.com/mail/mu/mp/603/#tl/Recibidos", favicon: "./PNG/IMG_4171.png"}, { name: "Google Fotos", url: "https://photos.google.com" }, { name: "iCloud", url: "https://www.icloud.com/"}, { name: "ABRP", url: "https://abetterrouteplanner.com" }, { name: "ElectroMaps", url: "https://map.electromaps.com/es/", favicon: "https://www.google.com/s2/favicons?domain=electromaps.com&sz=64" }, { name: "REVE PdR España", url: "https://www.mapareve.es/mapa-puntos-recarga", favicon: "https://www.google.com/s2/favicons?domain=mapareve.es&sz=64" }, { name: "Ver ubicaciones", url: "map-action:openRemindersMapWithNoRadars", favicon: "https://www.google.com/s2/favicons?domain=google.com/maps&sz=64" }, { name: "Google Maps", url: "https://www.google.com/maps/search/electric+vehicle+charging+stations" }, { name: "WhatsApp", url: "https://web.whatsapp.com/" }, { name: "TESSIE", url: "https://dash.tessie.com/signin", favicon: "https://www.google.com/s2/favicons?domain=tessie.com&sz=64" }, { name: "Mis Updates", url: "https://dash.tessie.com/software", favicon: "https://cdn-icons-png.flaticon.com/512/148/148767.png" }, { name: "Olas Updates", url: "https://es.stats.tessie.com/", favicon: "https://cdn-icons-png.flaticon.com/512/5815/5815902.png" }, { name: "NotaTeslaApp", url: "https://www.notateslaapp.com/software-updates/" }, { name: "ENHAUTO", url: "https://www.enhauto.com" }, { name: "MAREAS", url: "https://www.meteogalicia.gal/web/predicion/mareas-e-luas" }, { name: "ELECTROVERSE", url: "https://electroverse.com/es/map", favicon: "https://www.google.com/s2/favicons?domain=electroverse.com&sz=64" }, { name: "ACCIONA", url: "https://www.google.com/maps/search/recarga+Acciona", favicon: "https://www.google.com/s2/favicons?domain=acciona.com&sz=64" }, { name: "IBERDROLA", url: "https://www.google.com/maps/search/recarga+IBERDROLA", favicon: "https://www.google.com/s2/favicons?domain=iberdrola.com&sz=64" }, { name: "WAYLET Repsol", url: "https://www.google.com/maps/search/recarga+REPSOL+Waylet", favicon: "https://www.google.com/s2/favicons?domain=repsol.com&sz=64" }, { name: "ENDESA xWay", url: "https://www.google.com/maps/search/recarga+ENDESA+XWAY", favicon: "https://www.google.com/s2/favicons?domain=endesa.com&sz=64" }, { name: "ZUNDER", url: "https://www.google.com/maps/search/recarga+ZUNDER", favicon: "https://www.google.com/s2/favicons?domain=zunder.com&sz=64" }, { name: "IONITY", url: "https://www.google.com/maps/search/recarga+IONITY", favicon: "https://www.google.com/s2/favicons?domain=ionity.eu&sz=64" }, { name: "WENEA", url: "https://www.google.com/maps/search/recarga+WENEA", favicon: "https://www.google.com/s2/favicons?domain=wenea.com&sz=64" }, { name: "T.ENERGIES", url: "https://www.google.com/maps/search/recarga+TOTAL+ENERGIES", favicon: "https://www.google.com/s2/favicons?domain=totalenergies.com&sz=64" }, { name: "GALP", url: "https://www.google.com/maps/search/recarga+GALP", favicon: "https://www.google.com/s2/favicons?domain=galp.com&sz=64" }, { name: "MIIO", url: "https://miio.com", favicon: "https://www.google.com/s2/favicons?domain=miio.com&sz=64" }, { name: "EVDC", url: "https://evdc.network", favicon: "https://www.google.com/s2/favicons?domain=evdc.network&sz=64" }, { name: "GROK", url: "https://grok.com/?referrer=website" }, { name: "CHATGPT", url: "https://chat.openai.com" }, { name: "CLAUDE", url: "https://claude.ai/new" }, { name: "GEMINI", url: "https://gemini.google.com" }, { name: "NOTEBOOKLM", url: "https://notebooklm.google.com" }, { name: "Batería", url: "https://docs.google.com/spreadsheets/d/1bLZmgVGTBqg2bS2E45JpORjs9eK2nb05AWXYLLDY-RI/edit?gid=1398548891#gid=1398548891", favicon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='10'/><polyline points='12 6 12 12 16 14'/></svg>" }, { name: "TeslaParaTodos", url: "https://teslaparatodos.com/cine/" }, { name: "BetterTheater", url: "https://abettertheater.com", favicon: "https://www.google.com/s2/favicons?domain=abettertheater.com&sz=64" }, { name: "Filmin", url: "https://www.filmin.es/catalogo/peliculas" }, { name: "Octopus", url: "https://octopusenergy.es/login" }, { name: "App MCE", url: "https://www.oscarabilleira.com/app-mi-coche-electrico/#ayuda" }, { name: "Patrón Luz", url: "https://docs.google.com/spreadsheets/d/1R7UUZ9i4BAYWAGAX6PQT1WGd12GEZ4Ja/edit?usp=sharing&ouid=108345701896498198132&rtpof=true&sd=true" }, { name: "TradingView", url: "https://es.tradingview.com/chart/t5g9UFG0/" }, { name: "Telegram", url: "https://web.telegram.org/a/" }, { name: "Twitter", url: "https://x.com" }, { name: "Maesal Detailer", url: "https://www.maesaldetailer.es/" }, { name: "Superchargers", url: "https://www.tesla.com/es_es/findus?bounds=45.41107111786193%2C19.27853056943938%2C29.703668286784747%2C-16.64676239931062" }, { name: "TESLA web", url: "https://www.tesla.com/es_es" }, { name: "Manual M3", url: "https://www.tesla.com/ownersmanual/model3/es_es/" }, { name: "de Servicio", url: "https://service.tesla.com/docs/Model3/ServiceManual/2024/es-es/" }, { name: "de Despiece", url: "https://epc.tesla.com/es-MX/catalogs/e0e07c3d-272f-4d06-b8b6-9e92f857e5f3" }, { name: "de Usted Mismo", url: "https://www.tesla.com/es_es/support/do-it-yourself-guides" }, { name: "de Filtro Cabina", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-DB0A1E3C-926E-498C-A2FD-A27B8421A471.html" }, { name: "de Móvil remoto", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-53651B16-A2E3-4118-933E-B5F41C74D433.html" }, { name: "Waze (consultas)", url: "https://www.waze.com/es/live-map/", favicon: "https://www.google.com/s2/favicons?domain=waze.com&sz=64" }, { name: "AMAZON", url: "https://www.amazon.es" }, { name: "BIP&DRIVE", url: "https://areaprivada.bipdrive.com/login" }, { name: "ITV Cita", url: "https://www.sycitv.com/es/cita-previa-particulares/", favicon: "https://boardinggate.github.io/Tesla/PNG/itv.png" }, { name: "Deportes", url: "https://www.sofascore.com/es/tenis" }, null, { name: "Jaime Odena", url: "https://www.youtube.com/@Jaimeodena", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Eduardo Arcos", url: "https://www.youtube.com/@earcos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "AutoIngenium", url: "https://www.youtube.com/@AutoIngenium", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Gallego en Munich", url: "https://www.youtube.com/@ungallegoenmunich", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Electromiaumiau", url: "https://www.youtube.com/@electromiaumiau", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Manuel Martos", url: "https://www.youtube.com/@Manuel_Martos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Todos Electricos", url: "https://www.youtube.com/@TodosElectricos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Juan Vidal Haces", url: "https://www.youtube.com/@JuanVidalHaces", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Ruedana", url: "https://www.youtube.com/@ruedana", favicon: "https://www.youtube.com/favicon.ico" }, { name: "STR-600", url: "https://www.youtube.com/@STR-600", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Juanjo T. Aventuras", url: "https://www.youtube.com/@juanjoteslaventuras", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Carlos Cuezva", url: "https://www.youtube.com/@CarlosCuezva", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Javi Manzanoo", url: "https://www.youtube.com/@javimanzanoo", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Crifedi", url: "https://www.youtube.com/@Crifedi", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Tescno Tesla", url: "https://www.youtube.com/@TecnoTesla", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Full Electric Mex", url: "https://www.youtube.com/@FullElectricMexico", favicon: "https://www.youtube.com/favicon.ico" }, null, null, { name: "La iA Jon", url: "https://www.youtube.com/@la_inteligencia_artificial", favicon: "https://www.youtube.com/favicon.ico" }, { name: "JF Ccalero", url: "https://www.youtube.com/@jfcalero", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Visual Politik", url: "https://www.youtube.com/@VisualPolitik", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Fabian Barrio", url: "https://www.youtube.com/@fabiancbarrio", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Loquetudigas", url: "https://www.youtube.com/@Loquetudigas", favicon: "https://www.youtube.com/favicon.ico" }, { name: "David Antunes", url: "https://www.youtube.com/@davidantunesmusic", favicon: "https://www.youtube.com/favicon.ico" }, { name: "TheWildProject", url: "https://www.youtube.com/@TheWildProject", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Estas Tonne", url: "https://www.youtube.com/@Estastonne", favicon: "https://www.youtube.com/favicon.ico" }, { name: "BBC6 Music", url: "https://www.youtube.com/@BBC6Music", favicon: "https://www.youtube.com/favicon.ico" }, null, null ];
    const originalToggleRanges = [ { start: 18, end: 29, name: "ELECTROVERSE", label: "PdR,s" }, { start: 30, end: 41, name: "GROK", label: "iAs" }, { start: 42, end: 59, name: "TradingView", label: "Útil" }, { start: 60, end: 95, name: "Jaimeodena", label: "Varios" } ];
    const sectionColors = { 18: '#F0E0D3', 30: '#D8D4E0', 42: '#D9E5DB', 60: '#F2ECD0', unassigned: '#C5C8B8', off: '#ABAB99' };
    const darkModeGenericButtonColor = '#ABAB99';
    const DEFAULT_LOCATION_RADIUS = 450;
    const MAP_SEARCH_INPUT_KEY = 'boardinggate_map_search_value';
    let gpsRetryTimeoutId = null;
    let gpsRetryAttempt = 0;
    const MAX_GPS_RETRIES = 10;
    const GPS_RETRY_DELAY_MS = 5000;
    let isMapImmersiveModeActive = false;
    let isArrivalSequenceStarted = false;
    let maxSpeedCoordinates = null;
    let progressiveZoomState = 'none';
    let mapPreviousZoomLevelForProgressive = null;
    let lastProcessedStepIdentifier = null;
    const PROGRESSIVE_ZOOM_START_DISTANCE = 180;
    const PROGRESSIVE_ZOOM_PEAK_DISTANCE = 50;
    const PROGRESSIVE_ZOOM_EXIT_START_DISTANCE = 60;
    const PROGRESSIVE_ZOOM_EXIT_END_DISTANCE = 150;
    let isZoomedForManeuver = false;
    let navigationTargetZoom = null;
    let currentSmoothedMapCenter = null;
    let lastMobileSyncTimestamp = 0;
    const TOTAL_CELLS = 96; const COLS = 6; const grid = document.getElementById('bookmark-grid');
    let isDarkMode = false; let pressStartTime = null; let reminderPressStartTime = null; let isActive = true; let isFooterVisible = true; let notices = []; let currentNoticeIndex = 0; let fromReminderModal = false;
    let isEditMode = false; let isAssignmentMode = false;
    let isKeywordAssignmentMode = false;
    let currentlyAssigningToggleStart = null;
    let customData = { bookmarks: {}, toggles: {} };
    let cellElements = []; let toggleButtonElements = {}; let currentBookmarks = []; let currentToggleRanges = [];
    let onOffToggle, weatherButton, reminderButton, zoomButton, darkModeToggle, versionsButton, infoButton;
    let radarButton;
    let firstPersonalizationSession = !sessionStorage.getItem('personalizationHelpShown');
    let editingTargetElement = null; let draggedItem = null; let draggedItemIndex = null; let dragOverIndex = null;
    let touchStartX = 0; let touchStartY = 0; let currentTouchTarget = null;
    let isPasswordActive = false; let storedPin = null;
    
    let reminderCheckIntervalId = null;
    let remindersSpatialIndex = {}; // Índice espacial para búsquedas rápidas por ubicación.
    let nonLocationRemindersCache = []; // Caché separada para recordatorios solo de tiempo.
    let nextEventHorizon = { 
        timestamp: Infinity, 
        type: null,          
        targetId: null       
    };
    let checkRemindersMode = 'active'; // Puede ser 'active' o 'idle'.
    let currentCheckIntervalDuration = 3000;

    let lastUpdatesCheckDate = localStorage.getItem('lastUpdatesCheckDate');
    let currentNotificationSlideIndex = 0;
    let isUnifiedWindowVisibleByLogic = false;
    let reminderModalMap = null;
    let reminderMarker = null;
    let reminderCircle = null;
    let previewMaps = {};
    const MAX_SAVED_LOCATIONS = 15;
    const SAVED_LOCATIONS_KEY = 'boardinggate_saved_locations';
    const MAP_VIEW_MODE_KEY = 'mapViewMode_v1';
    const SHOW_EXCLUDED_REMINDERS_KEY = 'boardinggate_showExcludedRemindersInTable';
    const RADARES_RUTA_CHECKED_KEY = 'boardinggate_radaresRutaCheckboxChecked';
    const TAREAS_RUTA_CHECKED_KEY = 'boardinggate_tareasRutaCheckboxChecked';
    const ACTIVE_MAP_LAYER_KEY = 'boardinggate_activeMapLayer';
    const DIRECT_TO_NAVIGATION_KEY = 'boardinggate_directToNavigation';
    const MAP_ENTRY_OVERRIDE_KEY = 'boardinggate_map_entry_override';
    const TEMP_PREVENT_DIRECT_NAV_KEY = 'tempPreventDirectNavAfterMapExit';
    const GRAPH_STATE_KEY = 'boardinggate_graphState';
    let locationPickerMap = null;
    let locationPickerMarker = null;
    let currentEditingLocationSlotIndex = -1;
    let tempSavedLocations = [];
    let navigationMapInstance = null;
    let isNavigationMapActive = false;
    let initialUserLocationMarker = null;
    let initialUserLocationMarkerLat = null;
    let initialUserLocationMarkerLng = null;
    let navigationCurrentLocation = null;
    let locationWatchId = null;
    let shouldCenterOnUser = false;
    let navigationFollowUser = false;
    const MIN_MANEUVER_ZOOM_LEVEL = 17;
    let currentMapBearing = 0;
    let currentMapRotationAngle = 0;
    let currentMapCenterOffset = { x: 0, y: 0 };
    let targetMapCenterOffset = { x: 0, y: 0 };
    let miniMapOffsetActive = { x: 0, y: 0 };
    let lastHeadingForTilt = 0;
    let compassAndModeControl = null;
    let navigationWaypoints = [];
    let navigationRouteLayer = null;
    let navigationCurrentRouteData = null;
    let isNavigating = false;
    let routeStartTime = null;
    let navigationStartTimeForStats = null;
    let totalDistanceTravelledForStats = 0;
    let accumulatedDistanceBeforeCurrentSegment = 0;
    let lastPositionForStats = null;
    let maxDistanceReachedOnRoute = 0; 
    let maxSpeedDuringTrip = 0;
    let maxAltitudeDuringTrip = -Infinity;
    let minAltitudeDuringTrip = Infinity;
    window.lastPositionForSpeedCalc = null;
    window.currentSpeedKmh = 0;
    window.averageSpeedKmh = 0;
    let isSimulatingGpsLocation = false;
    let simulatedGpsLocation = null;
    let automatedSimulationIntervalId = null;
    let simulatedDistanceAlongRoute = 0;
    let simulationSpeedKmph = 85;
    let currentSimulationSpeedKmph = 85; 
    const SIMULATION_TICK_INTERVAL_MS = 110;
    const AUTO_ZOOM_ACTIVE_KEY = 'boardinggate_autoZoomActive';
    
    const OSRM_SERVICE_URL = 'https://router.project-osrm.org/route/v1';
    const SAVED_ROUTES_KEY = 'boardinggate_saved_routes';
    const MAX_SAVED_ROUTES = 100;
    let currentRouteNameForSaving = null;
    let navigationMapClickHandler = null;
    let draggedStageLi = null;
    const DEVIATION_THRESHOLD_METERS = 35;
    const DEVIATION_MIN_TIME_SECONDS = 0.1;
    let deviationStartTime = 0;
    let isRecalculatingRoute = false;
    let deviationModalTimerId = null;
    let isDeviationModalActive = false;
    const WAYPOINT_VISITED_THRESHOLD_METERS = 70;
    let currentLegIndexNav = 0;
    let currentStepIndexNav = 0;
    let lastCarDistanceAlongRouteForNavLogic = 0;
    let lastValidCarDistanceForDisplay = 0;
    let lastProcessedStepManeuverLocation = null;
    let recalculationRetryTimeoutId = null;
    let recalculationAttempts = 0;
    let isAddReminderAtLocationModeActive = false;
    let addReminderAtLocationButton = null;
    let simulationModalTimer = null;
    let autoStartNavTimer = null;
    let mapLayersControl = null;
    let searchToastShown = false;
    let pendingPositionToProcess = null;
    const KML_FILES_LIST_STANDARD = './KLM/KLMFILES.TXT';
    const KML_FILES_LIST_EXTRA = './KLM/KLMFILES2.TXT';
    const KML_BASE_PATH = './KLM/';
    const COORD_EPSILON = 0.00001;
    const RUTA_RADAR_PROXIMITY_THRESHOLD = 75;
    let reminderMapObjects = [];
    let radaresEnRutaActual = [];
    let tareasEnRutaActual = [];
    const STATIC_MODAL_IDS = ['config-modal', 'versions-modal-overlay', 'pin-modal-overlay', 'reorder-stages-modal', 'simulation-modal', 'locations-preview-modal', 'deviation-modal', 'arrival-stats-modal', 'simulation-speed-modal'];
    let activeToasts = [];
    let intersectionPreviewMap = null;
    let intersectionPreviewRouteLayer = null;
    let intersectionPreviewManeuverMarker = null;
    let intersectionPreviewCarMarker = null;
    let intersectionPreviewTimer = null;
    let lastAutoShownManeuverId = null;
    let directToNavOnLoad = false;
    let mapLayersControlLocationsPreview = null;
    let navigationChart = null;
    let currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviación Ruta';
    let graphPlotState = { lastPlotTime: null, lastPlotCoords: null };
    let graphIntervalDuration = 0; 
    let graphIntervalTimer = null;
    let graphDataPoints = { speed: [], altitude: [] };
    let graphLabels = [];
    let graphExpectedAvgSpeed = 0;
    let maxGraphPoints = 150;
    let isCarStoppedForGraph = false; 
    const GRAPH_PIXELS_PER_DATAPOINT = 2; 
    const GRAPH_BUFFER_PERCENTAGE = 0.15;
    const MAP_FILTER_INPUT_KEY = 'boardinggate_map_filter_value';
    const PROGRESS_BAR_LOCKED_KEY = 'boardinggate_progressBarLocked';
    let isProgressBarLocked = false;
    let progressBarForceShowUntil = 0;
    let lastProcessedStepForLock = null;
    const ARRIVAL_MODAL_THRESHOLD_METERS = 20
    window.mapCustomControlsInstance = null;
    window.offsetXBeforeManeuver = null;
    window.offsetYBeforeManeuver = null;
    window.maneuverHorizontalTarget = 0;


    const _turfLastPoint = turf.point([0, 0]);
    const _turfCurrentPoint = turf.point([0, 0]);
    
    const PERFORMANCE_RATIO_ROUTE_KEY = 'perf_ratio_route';
    const PERFORMANCE_RATIO_ALERTS_KEY = 'perf_ratio_alerts';
    const PERFORMANCE_RATIO_STATS_KEY = 'perf_ratio_stats';
    const PERFORMANCE_RATIO_GRAPH_KEY = 'perf_ratio_graph';
    const PERFORMANCE_RATIO_CRITICAL_KEY = 'perf_ratio_critical';
    
    let performanceRatios = {
    criticalUpdate: 3,
    routeProgress: 30,
    trafficAlerts: 300,
    tripStats: 32,
    performanceGraph: 70};
    
    let gpsTickCounter = 0;
    let gpsHzMonitor = {
        ticks: 0,
        interval: null
    };

    let trafficAlertsCache = [];
    let lastAlertCheckTimestamp = 0;
    const ALERT_CHECK_INTERVAL = 15 * 60 * 1000;
    let currentlyDisplayedProximityAlerts = new Set();
    let alertModalTimer = null;
    let proximityAlertTimer = null;

    let trafficAlertsSpatialIndex = {};
    let alertRefreshInterval = null; 
    let lastAlertCleanupTimestamp = 0; 

    const LERP_RATE_POS_KEY = 'boardinggate_lerp_rate_position';
    const LERP_RATE_ROT_KEY = 'boardinggate_lerp_rate_rotation';
    const LERP_RATE_ZOOM_KEY = 'boardinggate_lerp_rate_zoom';

    let chatUpdateInterval = null;
    let lastVisibleUserDoc = null; 
    let lastVisibleMessageDoc = null; 
    let isFetchingUsers = false; 
    let isFetchingMessages = false; 
   
    const vehicleIconElement = document.createElement('div');
    vehicleIconElement.className = 'vehicle-icon-mapbox-container';
    vehicleIconElement.innerHTML = `<div class="vehicle-icon-wrapper"><img src="PNG/AVANCE.PNG" alt="Coche"><div class="vehicle-maneuver-overlay"></div></div>`;

    let eventosEnRuta = []; 
    let proximoEventoEnRutaIndex = 0; 
    const GPS_BASE_FREQUENCY_HZ = 10; 

    let lastMapUpdateTime = 0;
    let MAP_UPDATE_INTERVAL_MS = 22; 
    let lastGarbageCollectionYield = 0;
    const PERFORMANCE_CAMERA_FPS_KEY = 'boardinggate_camera_fps'; 

    let originalTripEtaTime = null;   
    let isFlying = false;
    let originalMapUpdateIntervalMs = 25; 

    const MAP_TERRAIN_EXAGGERATION_KEY = 'boardinggate_mapTerrainExaggeration'; 
    let mapTerrainExaggeration = 0.8; 
    
    const navigationTasks = {
        CRITICAL_VISUALS: {
            id: 'CRITICAL_VISUALS',
            handler: (coords, map) => {
                updateVehicleMarker(coords, map);
                if (!markerAnimationState.animationFrameId) {
                    markerAnimationState.animationFrameId = requestAnimationFrame(animateMarkerAndMap);
                }
            },
            getFrequency: () => (performanceRatios.criticalUpdate / GPS_BASE_FREQUENCY_HZ) * 1000,
            priority: 1,
            lastRun: 0
        },
        ROUTE_PROGRESS: {
            id: 'ROUTE_PROGRESS',
            handler: (coords, map) => { if (isNavigating) processRouteProgress(coords, map); },
            getFrequency: () => {
                const baseIntervalMs = (performanceRatios.routeProgress / GPS_BASE_FREQUENCY_HZ) * 1000;
                
                if (distanceToNextManeuverOSRM < 310) {
                    return baseIntervalMs / 4;
                } else {
                    return baseIntervalMs;
                }
            },
            priority: 2,
            lastRun: 0
        },
        TRIP_STATS: {
            id: 'TRIP_STATS',
            handler: (coords, map) => updateTripStatistics(coords),
            getFrequency: () => {
                const baseIntervalMs = (performanceRatios.tripStats / GPS_BASE_FREQUENCY_HZ) * 1000;
                
                if (distanceToNextManeuverOSRM < 310) {
                    return baseIntervalMs / 2;
                } else {
                    return baseIntervalMs;
                }
            },
            priority: 3,
            lastRun: 0
        },
        PERFORMANCE_GRAPH: {
            id: 'PERFORMANCE_GRAPH',
            handler: (coords, map) => plotIntervalData(),
            getFrequency: () => (performanceRatios.performanceGraph / GPS_BASE_FREQUENCY_HZ) * 1000,
            priority: 4,
            lastRun: 0
        },
        TRAFFIC_ALERTS: {
            id: 'TRAFFIC_ALERTS',
            handler: (coords, map) => checkAlertsProximity(),
            getFrequency: () => (performanceRatios.trafficAlerts / GPS_BASE_FREQUENCY_HZ) * 1000,
            priority: 5,
            lastRun: 0
        }
    };

     const TASKS_BY_PRIORITY = Object.values(navigationTasks)
        .sort((a, b) => a.priority - b.priority);
   
    const managedKeys = [ 
        'reminders','darkMode','toggleStates','zoomState','onOffState','noticesActive', 
        'footerVisible','teslaHtmlLastModified','teslaHtmlLastModifiedTimestamp', 
        'userData_userId','userData_teslaModel','userData_teslaYear','userData_teslaProvince', 
        'userData_allowDMs', 'customGridData', 'personalizationHelpShown', 'gridFilterValue',  
        'password_pin', 'password_active', 'lastUpdatesCheckDate', SAVED_LOCATIONS_KEY,  
        SHOW_EXCLUDED_REMINDERS_KEY, SAVED_ROUTES_KEY, 'boardinggate_recent_routes', 
        RADARES_RUTA_CHECKED_KEY,  TAREAS_RUTA_CHECKED_KEY, ACTIVE_MAP_LAYER_KEY, 
        DIRECT_TO_NAVIGATION_KEY, GRAPH_STATE_KEY, 'boardinggate_autoBackupOnLoad', 
        'userData_backupPassword', MAP_SEARCH_INPUT_KEY, 'mapViewMode_v1', MAP_FILTER_INPUT_KEY, 
        PROGRESS_BAR_LOCKED_KEY,  MAP_VIEW_OFFSET_X_KEY,MAP_VIEW_OFFSET_Y_KEY,  
        MAP_VIEW_SHOW_MINIMAP_KEY, MAP_VIEW_PITCH_KEY, PERFORMANCE_RATIO_CRITICAL_KEY, 
        PERFORMANCE_RATIO_ROUTE_KEY, PERFORMANCE_RATIO_ALERTS_KEY, 
        PERFORMANCE_RATIO_STATS_KEY, PERFORMANCE_RATIO_GRAPH_KEY,
        'boardinggate_map_saturation', 'boardinggate_map_contrast', 
        LERP_RATE_POS_KEY, LERP_RATE_ROT_KEY, LERP_RATE_ZOOM_KEY, PERFORMANCE_CAMERA_FPS_KEY, MAP_TERRAIN_EXAGGERATION_KEY
     ];

    
    const managedDesc = managedKeys.map(k => {
        switch(k){
            case 'reminders':return 'Recordatorios'; case 'darkMode':return 'Modo Oscuro'; case 'toggleStates':return 'Visibilidad Secc.';
            case 'zoomState':return 'Zoom Grid'; case 'onOffState':return 'On/Off Gral'; case 'noticesActive':return 'Avisos/Footer';
            case 'footerVisible':return 'Vis. Footer'; case 'teslaHtmlLastModified':return 'Cache Versión'; case 'teslaHtmlLastModifiedTimestamp':return 'TS Cache';
            case 'userData_userId':return 'ID Usuario'; case 'userData_teslaModel':return 'Modelo'; case 'userData_teslaYear':return 'Año';
            case 'userData_teslaProvince':return 'Provincia'; case 'userData_allowDMs':return 'Permitir DMs'; case 'customGridData': return 'Grid Pers.';
            case 'personalizationHelpShown': return 'Ayuda Pers. Vista'; case 'gridFilterValue': return 'Filtro Grid';
            case 'password_pin': return 'PIN Acceso'; case 'password_active': return 'PIN Activo'; case 'lastUpdatesCheckDate': return 'Cache Fecha Updates';
            case SAVED_LOCATIONS_KEY: return 'Ubicaciones Guardadas';
            case SHOW_EXCLUDED_REMINDERS_KEY: return 'Mostrar Excluidos Tabla';
            case SAVED_ROUTES_KEY: return 'Rutas Guardadas';
            case 'boardinggate_recent_routes': return 'Rutas Recientes';
            case RADARES_RUTA_CHECKED_KEY: return 'Check Radares Ruta';
            case TAREAS_RUTA_CHECKED_KEY: return 'Check Tareas Ruta';
            case ACTIVE_MAP_LAYER_KEY: return 'Capa de Mapa Activa';
            case DIRECT_TO_NAVIGATION_KEY: return 'Directo a Navegación';
            case GRAPH_STATE_KEY: return 'Estado Gráfica';
            case MAP_SEARCH_INPUT_KEY: return 'Buscador Mapa (Principal)';
            case MAP_FILTER_INPUT_KEY: return 'Buscador Mapa (Filtro)';
            case PERFORMANCE_RATIO_CRITICAL_KEY: return 'Ratio Críticos';
            case PERFORMANCE_RATIO_ROUTE_KEY: return 'Ratio Progreso Ruta';
            case PERFORMANCE_RATIO_ALERTS_KEY: return 'Ratio Alertas';
            case PERFORMANCE_RATIO_STATS_KEY: return 'Ratio Estadísticas';
            case PERFORMANCE_RATIO_GRAPH_KEY: return 'Ratio Gráfica';
            case 'boardinggate_map_saturation': return 'Saturación Mapa';
            case 'boardinggate_map_contrast': return 'Contraste Mapa';
            case LERP_RATE_POS_KEY: return 'Suavizado Posición';
            case LERP_RATE_ROT_KEY: return 'Suavizado Rotación';
            case LERP_RATE_ZOOM_KEY: return 'Suavizado Zoom';
            case PERFORMANCE_CAMERA_FPS_KEY: return 'FPS Animación Cámara';  
            case MAP_TERRAIN_EXAGGERATION_KEY: return 'Exageración 3D';  
            default:return k;
        }
    }).join(', ');   


// ===================================================================
// FUNCIÓN A CAMBIAR: Clase MapLayerAndViewController 
// ===================================================================
class MapLayerAndViewController {
    onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.className = 'mapboxgl-ctrl map-combined-control-container';

        this._container.addEventListener('click', e => e.stopPropagation());
        this._container.addEventListener('dblclick', e => e.stopPropagation());

        const layerSelector = document.createElement('div');
        layerSelector.className = 'map-layer-selector';

        const baseMaps = {
            "HÍBRIDO": "mapbox://styles/mapbox/satellite-streets-v12",
            "SATÉLITE": "mapbox://styles/mapbox/satellite-v9",
            "CALLES": "mapbox://styles/mapbox/standard"
        };
        
        const legacyNameMap = {
            "Satélite + Calles": "HÍBRIDO",
            "Satélite Puro": "SATÉLITE",
            "Mapa Normal": "CALLES"
        };

        let savedLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY);

        if (legacyNameMap[savedLayerName]) {
            savedLayerName = legacyNameMap[savedLayerName];
            localStorage.setItem(ACTIVE_MAP_LAYER_KEY, savedLayerName);
            markCacheAsDirty(); 
        }

        if (!savedLayerName || !baseMaps[savedLayerName]) {
            savedLayerName = "HÍBRIDO";
        }
        
        Object.keys(baseMaps).forEach(name => {
            const label = document.createElement('label');
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = 'map-style-selector';
            input.value = baseMaps[name];
            if (name === savedLayerName) {
                input.checked = true;
            }
            
            input.onchange = () => {
                this._map.setStyle(input.value);
                localStorage.setItem(ACTIVE_MAP_LAYER_KEY, name);
                markCacheAsDirty(); 
                      
                this._map.once('style.load', () => {
                    this._map.once('idle', async () => {
                        await loadAndAddMapImages(this._map);
                        await reAddCustomMapLayersAndSources(this._map);

                        // ¡CLAVE! Al cambiar el estilo, se debe reconfigurar el terreno y la atmósfera.
                        await configureMapAtmosphere();

                        // Se mantiene el resto de la lógica para mover la cámara a la posición correcta.
                        const currentModeKey = localStorage.getItem(MAP_VIEW_MODE_KEY) || 'relief';
                        const viewSelectorContainer = this._container.querySelector('.map-view-selector');
                        if (viewSelectorContainer) {
                            const activeRadioButton = viewSelectorContainer.querySelector(`input[name="map-view-selector"][value="${currentModeKey}"]`);
                            if (activeRadioButton && typeof activeRadioButton.onchange === 'function') {
                                activeRadioButton.onchange();
                            }
                        }
                        
                        plotRemindersOnNavigationMap();
                        displayChargingPointsOnMap();
                        displayAlertsOnMap();
                        renderWaypointMarkers();
                        updateRouteAndCarIconStyle();
                    });
                });
            };
            label.appendChild(input);
            label.appendChild(document.createTextNode(` ${name}`));
            layerSelector.appendChild(label);
        });

        const viewSelector = document.createElement('div');
        viewSelector.className = 'map-view-selector';
        
        const viewModes = {
            'NORTE': { pitch: 0, bearing: 0, mode: 'static', terrain: false },
            'AVANCE': { pitch: 0, bearing: null, mode: 'heading', terrain: false },
            '3D': { pitch: 62, bearing: null, mode: 'perspective', terrain: false },
            '3D RELIEVE': { pitch: 68, bearing: null, mode: 'relief', terrain: true }
        };

        const savedViewMode = localStorage.getItem(MAP_VIEW_MODE_KEY) || 'relief';
        
        Object.keys(viewModes).forEach(name => {
            const label = document.createElement('label');
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = 'map-view-selector';
            const modeDetails = viewModes[name];
            input.value = modeDetails.mode;

            if (modeDetails.mode === savedViewMode) {
                input.checked = true;
            }

           input.onchange = async () => {
                if (!input.checked) return;

                const selectedModeValue = input.value;
                const newModeDetails = Object.values(viewModes).find(m => m.mode === selectedModeValue);
                const newModeName = Object.keys(viewModes).find(key => viewModes[key].mode === selectedModeValue);

                if (newModeDetails) {
                    // 1. Actualizamos el estado global del modo de vista.
                    mapViewMode = newModeDetails.mode;
                    localStorage.setItem(MAP_VIEW_MODE_KEY, mapViewMode);
                    markCacheAsDirty();
                    showToast(`Modo Vista: ${newModeName}`, 'info');

                    // 2. Llamamos a la función maestra para que gestione terreno y niebla.
                    await configureMapAtmosphere();
                    
                    // 3. Movemos la cámara a la posición correcta para el nuevo modo.
                    const easeOptions = {};
                    if (newModeDetails.mode === 'perspective' || newModeDetails.mode === 'relief') {
                        easeOptions.pitch = mapPitchValue; 
                    } else {
                        easeOptions.pitch = newModeDetails.pitch;
                    }
                    if (newModeDetails.bearing !== null) {
                        easeOptions.bearing = newModeDetails.bearing;
                    } else if (navigationCurrentLocation && navigationCurrentLocation.heading !== null) {
                        easeOptions.bearing = navigationCurrentLocation.heading;
                    }
                    this._map.easeTo(easeOptions);
                    
                    // 4. Actualizamos la posición del coche por si acaso.
                    if (navigationCurrentLocation) {
                        updateInitialUserPosition(navigationCurrentLocation, this._map);
                    }
                }
            };
           
            label.appendChild(input);
            label.appendChild(document.createTextNode(` ${name}`));
            viewSelector.appendChild(label);
        });
        
        this._container.appendChild(layerSelector);
        this._container.appendChild(viewSelector);

        return this._container;
    }

    onRemove() {
        if (this._container && this._container.parentNode) {
            this._container.parentNode.removeChild(this._container);
        }
        this._map = undefined;
    }
}
    
// ===================================================================
// NOMBRE: CompassAndStatsControl 
// RESUMEN: Control que muestra brújula, altitud y velocidades.
class CompassAndStatsControl {
    constructor(options) {
        this.options = options || {};
        this.lastAppliedHeading = null;
        this.lastAppliedOrientationText = null;
        this.lastAppliedAltitudeText = null;
        this.lastAppliedCurrentSpeedText = null;
        this.lastAppliedAverageSpeedText = null;
        this.lastAppliedMaxSpeedText = null;
    }

    onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.className = 'mapboxgl-ctrl map-control-custom-map-controls';
        
        const compassContainer = document.createElement('div');
        compassContainer.className = 'map-control-orientation-altitude';
        compassContainer.innerHTML = `
            <img id="compass-rose-icon" src="PNG/ROSA.PNG" alt="Orientación">
            <span id="orientation-text">---</span>
            <span id="altitude-display">--- m</span>
            <span id="current-speed-display">--- km/h</span>
            <span id="average-speed-display" class="speed-stats-text">Med: --- km/h</span>
            <span id="max-speed-display" class="speed-stats-text">Máx: --- km/h</span>
        `;
        
        compassContainer.addEventListener('click', (e) => {
            e.stopPropagation();
            this._toggleGraphMode(e);
        });
        compassContainer.title = "Clic para cambiar modo de la gráfica";

        const graphCard = document.createElement('div');
        graphCard.className = 'hidden';
        graphCard.id = 'navigation-graph-card';
        graphCard.style.position = 'relative'; 
        graphCard.style.cursor = 'pointer';
        graphCard.addEventListener('click', toggleEnlargedGraph);
        
        const graphTitle = document.createElement('div');
        graphTitle.id = 'navigation-graph-title';
        graphCard.appendChild(graphTitle);

        const enlargeButton = document.createElement('div');
        enlargeButton.id = 'enlarge-graph-button';
        enlargeButton.title = 'Ampliar/Reducir gráfica';
        enlargeButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="11" y1="8" x2="11" y2="14"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        `;
        enlargeButton.addEventListener('click', (e) => {
            e.stopPropagation(); 
            toggleEnlargedGraph();
        });
        graphCard.appendChild(enlargeButton);

        const graphCanvasContainer = document.createElement('div');
        graphCanvasContainer.id = 'navigation-graph-container';
        const canvas = document.createElement('canvas');
        canvas.id = 'navigation-chart';
        graphCanvasContainer.appendChild(canvas);
        graphCard.appendChild(graphCanvasContainer);
        
        this._container.appendChild(compassContainer);
        this._container.appendChild(graphCard);
        this._updateGraphTitle();
        return this._container;
    }

    onRemove() {
        if (this._container && this._container.parentNode) {
            this._container.parentNode.removeChild(this._container);
        }
        this._map = undefined;
    }
    
    _toggleGraphMode(e) {
        if (e) e.stopPropagation();
        if (!navigationCurrentRouteData && !isFreeDriveActive) {
            showToast("La gráfica estará disponible cuando se calcule una ruta o inicies un viaje libre.", "info");
            return;
        }
        const modes = ['Desviación ETA', 'Altitud', 'Gráfica off'];
        let currentIndex = modes.indexOf(currentGraphMode);
        currentIndex = (currentIndex + 1) % modes.length;
        currentGraphMode = modes[currentIndex];
        localStorage.setItem(GRAPH_STATE_KEY, currentGraphMode); 
        updateNavigationGraphVisibilityAndMode();
        if (currentGraphMode !== 'Gráfica off') {
            showToast(`Gráfica cambiada a: ${currentGraphMode}`, 'info');
        } else {
            showToast(`Gráfica desactivada`, 'info');
        }
    }

    _updateGraphTitle() {
        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            if (currentGraphMode === 'Desviación ETA') {
                graphTitleElement.textContent = 'Desviación ETA';
            } else if (currentGraphMode === 'Altitud') {
                graphTitleElement.textContent = 'Desnivel Ruta';
            } else {
                graphTitleElement.textContent = ''; 
            }
        }
    }
    
    updateOrientation(heading) {
        const compassRoseIcon = document.getElementById('compass-rose-icon');
        const orientationText = document.getElementById('orientation-text');
        if (!compassRoseIcon || !orientationText) return;

        if (heading !== null && !isNaN(heading) && heading >= 0 && heading <= 360) {
            const roundedHeading = Math.round(heading);
            
            // OPTIMIZACIÓN 1: Solo aplicar la rotación del icono si el grado redondeado ha cambiado.
            if (this.lastAppliedHeading !== roundedHeading) {
                compassRoseIcon.style.transform = `rotate(-${roundedHeading}deg)`;
                this.lastAppliedHeading = roundedHeading;
            }
            
            currentMapBearing = heading;
            
            const directions = ["N", "NnE", "NE", "EnE", "E", "EsE", "SE", "SsE", "S", "SsO", "SO", "OsO", "O", "OnO", "NO", "NnO", "N"];
            const index = Math.round(heading / 22.5) % 16;
            const newOrientationText = `${directions[index]} (${roundedHeading}°)`;
            
            // OPTIMIZACIÓN 2: Solo actualizar el texto del DOM si ha cambiado.
            if (this.lastAppliedOrientationText !== newOrientationText) {
                orientationText.textContent = newOrientationText;
                this.lastAppliedOrientationText = newOrientationText;
            }
        } else {
            // OPTIMIZACIÓN 3: Asegurarse de que el reseteo solo ocurra una vez.
            if (this.lastAppliedHeading !== 0) {
                compassRoseIcon.style.transform = 'rotate(0deg)';
                this.lastAppliedHeading = 0;
            }
            if (this.lastAppliedOrientationText !== '---') {
                orientationText.textContent = '---';
                this.lastAppliedOrientationText = '---';
            }
            currentMapBearing = 0;
        }
    }
    
    updateAltitude(altitude) {
        const altitudeDisplay = document.getElementById('altitude-display');
        if (!altitudeDisplay) return;

        let newDisplayText = '--- m';
        if (altitude !== null && !isNaN(altitude)) {
            newDisplayText = `${altitude.toFixed(0)} m`;
            if (maxAltitudeDuringTrip !== -Infinity && isNavigating) {
                newDisplayText += ` \u2261 ${maxAltitudeDuringTrip.toFixed(0)} m`;
            }
        } else if (isNavigating && maxAltitudeDuringTrip !== -Infinity) {
             newDisplayText = `-- m \u2261 ${maxAltitudeDuringTrip.toFixed(0)} m`;
        }

        // OPTIMIZACIÓN: Solo actualizar el DOM si el texto ha cambiado.
        if (this.lastAppliedAltitudeText !== newDisplayText) {
            altitudeDisplay.textContent = newDisplayText;
            this.lastAppliedAltitudeText = newDisplayText;
        }
    }

    updateCurrentSpeed(speedKmh) {
        const speedDisplay = document.getElementById('current-speed-display');
        if (!speedDisplay) return;

        let newDisplayText = '--- km/h';
        if (speedKmh !== null && !isNaN(speedKmh)) {
            newDisplayText = `${speedKmh.toFixed(1)} km/h`;
        }

        // OPTIMIZACIÓN: Solo actualizar el DOM si el texto ha cambiado.
        if (this.lastAppliedCurrentSpeedText !== newDisplayText) {
            speedDisplay.textContent = newDisplayText;
            this.lastAppliedCurrentSpeedText = newDisplayText;
        }
    }

    updateAverageSpeed(avgSpeedKmh) {
        const avgSpeedDisplay = document.getElementById('average-speed-display');
        if (!avgSpeedDisplay) return;

        let newDisplayText = 'Med: --- km/h';
        if (avgSpeedKmh !== null && !isNaN(avgSpeedKmh) && (isNavigating || (isSimulatingGpsLocation && automatedSimulationIntervalId) || isFreeDriveActive)) {
             newDisplayText = `Med: ${avgSpeedKmh.toFixed(1)} km/h`;
        }
        
        // OPTIMIZACIÓN: Solo actualizar el DOM si el texto ha cambiado.
        if (this.lastAppliedAverageSpeedText !== newDisplayText) {
            avgSpeedDisplay.textContent = newDisplayText;
            this.lastAppliedAverageSpeedText = newDisplayText;
        }
    }

    updateMaxSpeed(currentSpeedKmh, currentCoords) {
        if (typeof currentSpeedKmh === 'number' && currentSpeedKmh > maxSpeedDuringTrip) {
            maxSpeedDuringTrip = currentSpeedKmh;
            if (currentCoords) {
                maxSpeedCoordinates = { lat: currentCoords.latitude, lng: currentCoords.longitude };
            }
        }
        const maxSpeedDisplay = document.getElementById('max-speed-display');
        if (!maxSpeedDisplay) return;
        
        let newDisplayText = 'Máx: --- km/h'; 
        if (typeof maxSpeedDuringTrip === 'number' && !isNaN(maxSpeedDuringTrip)) {
            if (maxSpeedDuringTrip > 0) {
                newDisplayText = `Máx: ${maxSpeedDuringTrip.toFixed(1)} km/h`;
            } else if ((isNavigating || (isSimulatingGpsLocation && automatedSimulationIntervalId) || isFreeDriveActive) && maxSpeedDuringTrip === 0) {
                newDisplayText = `Máx: 0.0 km/h`;
            }
        }
        
        // OPTIMIZACIÓN: Solo actualizar el DOM si el texto ha cambiado.
        if (this.lastAppliedMaxSpeedText !== newDisplayText) {
            maxSpeedDisplay.textContent = newDisplayText;
            this.lastAppliedMaxSpeedText = newDisplayText;
        }
    }
}
    
// ===================================================================
// NOMBRE: CustomMapControlsGroup (VERSIÓN CON RESET DE PITCH)
// RESUMEN: Gestiona la barra horizontal y los paneles emergentes.
class CustomMapControlsGroup {
    onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.className = 'mapboxgl-ctrl map-controls-bottom-right';
        
        this._settingsPopup = document.createElement('div');
        this._settingsPopup.className = 'map-settings-popup';
        const settingsPanel = new MapSettingsPanel(map);
        this._settingsPopup.appendChild(settingsPanel.createPanelContent());
        
        this._offsetPopup = document.createElement('div');
        this._offsetPopup.className = 'map-offset-popup';
        
        this._offsetPopup.innerHTML = `
            <div class="crosshair-container" style="position: relative;">
                <div id="offset-value-display-y" class="offset-value-display vertical"></div>

                <button id="offset-arrow-up" class="offset-arrow" title="Mover vista hacia arriba">
                    <svg viewBox="0 0 24 24"><path d="M12 19V5M5 12l7-7 7 7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
                <button id="offset-arrow-left" class="offset-arrow" title="Mover vista a la izquierda">
                    <svg viewBox="0 0 24 24"><path d="M19 12H5M12 5l-7 7 7 7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>

                <!-- NUEVO: Contenedor para el valor X (Horizontal) -->
                <div id="offset-value-display-x" class="offset-value-display horizontal"></div>
                
                <div id="minimap-toggle-container">
                    <input type="checkbox" id="minimap-toggle-checkbox">
                    <label for="minimap-toggle-checkbox">Giros</label>
                </div>
                <button id="offset-arrow-right" class="offset-arrow" title="Mover vista a la derecha">
                    <svg viewBox="0 0 24 24"><path d="M5 12h14M12 5l7 7-7 7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
                <button id="offset-arrow-down" class="offset-arrow" title="Mover vista hacia abajo">
                    <svg viewBox="0 0 24 24"><path d="M12 5v14M19 12l-7 7-7-7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
                
            </div>
            <div class="offset-popup-separator"></div>
            <div class="pitch-controls-container">
                <button id="pitch-arrow-up" class="offset-arrow" title="Aumentar inclinación (pitch)">
                    <svg viewBox="0 0 24 24"><path d="M12 19V5M5 12l7-7 7 7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
                <span id="pitch-value-display" class="pitch-value-display">0°</span>
                <button id="pitch-arrow-down" class="offset-arrow" title="Reducir inclinación (pitch)">
                    <svg viewBox="0 0 24 24"><path d="M12 5v14M19 12l-7 7-7-7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
            </div>
        `;
      
        this.zoomControl = new ZoomControl(this); 
        const zoomControlElement = this.zoomControl.onAdd(map);
        
        this._container.appendChild(this._settingsPopup);
        this._container.appendChild(this._offsetPopup);
        this._container.appendChild(zoomControlElement);
        
        this._popupTimer = null; 
        this._offsetPopupTimer = null;

        this._offsetPopup.querySelector('#offset-arrow-up').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapOffset('y', -1); });
        this._offsetPopup.querySelector('#offset-arrow-down').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapOffset('y', 1); });
        this._offsetPopup.querySelector('#offset-arrow-left').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapOffset('x', 1); });
        this._offsetPopup.querySelector('#offset-arrow-right').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapOffset('x', -1); });
        
        this._offsetPopup.querySelector('#pitch-arrow-up').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapPitch(1); });
        this._offsetPopup.querySelector('#pitch-arrow-down').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapPitch(-1); });
        
        const pitchDisplay = this._offsetPopup.querySelector('#pitch-value-display');
        pitchDisplay.style.cursor = 'pointer';
        pitchDisplay.title = 'Pulsar para restaurar inclinación por defecto del modo actual';
        pitchDisplay.addEventListener('click', (e) => {
            e.stopPropagation();
            triggerManualMapInteraction();

            const viewModes = {
                'NORTE': { pitch: 0, bearing: 0, mode: 'static', terrain: false },
                'AVANCE': { pitch: 0, bearing: null, mode: 'heading', terrain: false },
                '3D': { pitch: 62, bearing: null, mode: 'perspective', terrain: false },
                '3D RELIEVE': { pitch: 68, bearing: null, mode: 'relief', terrain: true }
            };

            const currentModeDetails = Object.values(viewModes).find(m => m.mode === mapViewMode);
            const currentModeName = Object.keys(viewModes).find(key => viewModes[key].mode === mapViewMode);

            let targetPitch = 0; 
            if (currentModeDetails) {
                targetPitch = currentModeDetails.pitch;
            }

            mapPitchValue = targetPitch; 
            localStorage.setItem(MAP_VIEW_PITCH_KEY, mapPitchValue); 
            markCacheAsDirty();

            this._map.easeTo({ pitch: targetPitch, duration: 500 });
            showToast(`Pitch restaurado al valor por defecto de ${currentModeName} (${targetPitch}°)`, 'info');
         });
        
        const minimapCheckbox = this._offsetPopup.querySelector('#minimap-toggle-checkbox');
        minimapCheckbox.checked = showMinimapPreference;
        minimapCheckbox.addEventListener('change', (e) => {
            e.stopPropagation();
            showMinimapPreference = e.target.checked;
            saveSettings();
            showToast(`Minimapa de maniobras ${showMinimapPreference ? 'ACTIVADO' : 'DESACTIVADO'}`, 'info');
        });

        this._map.on('pitch', () => this.updatePitchDisplay());

        return this._container;
    }

    updateOffsetDisplay(x = mapOffsetX, y = mapOffsetY) {
        const displayX = this._offsetPopup.querySelector('#offset-value-display-x');
        const displayY = this._offsetPopup.querySelector('#offset-value-display-y');
        if (displayX) {
            displayX.textContent = `X : ${Math.round(x)}%`;
        }
        if (displayY) {
            displayY.textContent = `Y : ${Math.round(y)}%`;
        }
    }
   
    updatePitchDisplay() {
        const display = this._offsetPopup.querySelector('#pitch-value-display');
        if (display) {
            display.textContent = `${this._map.getPitch().toFixed(0)}°`;
        }
    }

    adjustMapOffset(axis, amount) {
        triggerManualMapInteraction(); 
        if (axis === 'y') {
            mapOffsetY = Math.max(-75, Math.min(75, mapOffsetY + amount));
        } else if (axis === 'x') {
            mapOffsetX = Math.max(-75, Math.min(75, mapOffsetX + amount));
        }
        this.updateOffsetDisplay();
        saveSettings();
        if (isNavigating && navigationCurrentLocation && navigationMapInstance) {
            updateInitialUserPosition(navigationCurrentLocation, navigationMapInstance);
        }
    }

    adjustMapPitch(amount) {
        triggerManualMapInteraction(); 
        const currentPitch = this._map.getPitch();
        const newPitch = Math.max(0, Math.min(85, currentPitch + amount));
        mapPitchValue = newPitch; 
        saveSettings();
        this._map.easeTo({ pitch: newPitch, duration: 300 });
       }

    toggleSettingsPopup() {
        if (this._offsetPopup.classList.contains('visible')) this.toggleOffsetPopup();
        if (this._settingsPopup.classList.contains('visible')) {
            this._settingsPopup.classList.remove('visible');
            if (this._popupTimer) { clearTimeout(this._popupTimer); this._popupTimer = null; }
        } else {
            this._settingsPopup.classList.add('visible');
            if (this._popupTimer) clearTimeout(this._popupTimer);
            this._popupTimer = setTimeout(() => { this._settingsPopup.classList.remove('visible'); this._popupTimer = null; }, 80000);
        }
    }

    toggleOffsetPopup() {
        if (this._settingsPopup.classList.contains('visible')) this.toggleSettingsPopup();
        if (this._offsetPopup.classList.contains('visible')) {
            this._offsetPopup.classList.remove('visible');
            if (this._offsetPopupTimer) { clearTimeout(this._offsetPopupTimer); this._offsetPopupTimer = null; }
        } else {
            this.updateOffsetDisplay();
            this.updatePitchDisplay();
            this._offsetPopup.classList.add('visible');
            if (this._offsetPopupTimer) clearTimeout(this._offsetPopupTimer);
            this._offsetPopupTimer = setTimeout(() => { this._offsetPopup.classList.remove('visible'); this._offsetPopupTimer = null; }, 80000);
        }
    }

    onRemove() {
        if (this.zoomControl) this.zoomControl.onRemove();
        if (this._popupTimer) clearTimeout(this._popupTimer);
        if (this._offsetPopupTimer) clearTimeout(this._offsetPopupTimer);
        if (this._container && this._container.parentNode) this._container.parentNode.removeChild(this._container);
        this._map = undefined;
    }
} 
    
// ===================================================================
// NOMBRE: ZoomControl (VERSIÓN FINAL Y CORREGIDA)
// RESUMEN: Su botón de zoom ahora llama a la función maestra externa `handleZoomToggleButtonClick`.
class ZoomControl {
    constructor(parentControl) {
        this.parentControl = parentControl;
    }
    onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.id = 'zoom-controls-horizontal';
        
        const zoomInBtn = document.createElement('div');
        zoomInBtn.className = 'zoom-control-button';
        zoomInBtn.textContent = '+';
        zoomInBtn.title = 'Acercar';

        const zoomOutBtn = document.createElement('div');
        zoomOutBtn.className = 'zoom-control-button';
        zoomOutBtn.textContent = '−';
        zoomOutBtn.title = 'Alejar';

        const levelDisplay = document.createElement('div');
        levelDisplay.id = 'zoom-level-display';
        levelDisplay.style.cssText = 'color: white; font-weight: bold; text-shadow: 1px 1px 2px black; min-width: 40px; text-align: center;';
        levelDisplay.textContent = map.getZoom().toFixed(1);

        const autoBtn = document.createElement('div');
        autoBtn.id = 'zoom-auto-button';
        autoBtn.className = 'zoom-control-button';
        
        const locateMeBtn = document.createElement('div');
        locateMeBtn.id = 'zoom-locate-me-button';
        locateMeBtn.className = 'zoom-control-button';
        locateMeBtn.innerHTML = `<img src="PNG/ESTASAQUI.PNG" alt="Localizar">`;
        
        const toggleBtn = document.createElement('div');
        toggleBtn.id = 'zoom-toggle-button';
        toggleBtn.className = 'zoom-control-button';
        toggleBtn.title = 'Alternar entre vista de ruta y coche';
        toggleBtn.innerHTML = `<img src="PNG/ZOOM+.PNG" alt="Toggle Zoom">`;

        const settingsBtn = document.createElement('div');
        settingsBtn.id = 'map-settings-toggle-button';
        settingsBtn.className = 'zoom-control-button';
        settingsBtn.title = 'Ajustes de mapa y vista';
        settingsBtn.innerHTML = `<img src="PNG/GPS.PNG" alt="Ajustes">`;
        
        const offsetBtn = document.createElement('div');
        offsetBtn.id = 'map-offset-toggle-button';
        offsetBtn.className = 'zoom-control-button';
        offsetBtn.title = 'Ajustar posición del coche en pantalla';
        offsetBtn.innerHTML = `<img src="PNG/picht.png" alt="Offset">`;

        this._container.appendChild(zoomInBtn);
        this._container.appendChild(levelDisplay);
        this._container.appendChild(zoomOutBtn);
        this._container.appendChild(autoBtn);
        this._container.appendChild(locateMeBtn);
        this._container.appendChild(toggleBtn);
        this._container.appendChild(settingsBtn);
        this._container.appendChild(offsetBtn);
        
        map.on('zoom', () => { levelDisplay.textContent = map.getZoom().toFixed(1); });
        
        const ZOOM_INCREMENT = 0.3;
        zoomInBtn.addEventListener('click', (e) => { e.stopPropagation(); map.easeTo({ zoom: map.getZoom() + ZOOM_INCREMENT }); });
        zoomOutBtn.addEventListener('click', (e) => { e.stopPropagation(); map.easeTo({ zoom: map.getZoom() - ZOOM_INCREMENT }); });
        
        const zoomModesCycle = { auto: 'off', off: 'route', route: 'auto' };
        let currentMode = localStorage.getItem(AUTO_ZOOM_MODE_KEY) || 'off';

        const updateAutoButtonVisuals = () => {
            autoBtn.classList.remove('active', 'route-mode');
            if (currentMode === 'auto') {
                autoBtn.textContent = 'AUTO';
                autoBtn.classList.add('active');
                autoBtn.title = 'Zoom automático por velocidad (Activado)';
            } else if (currentMode === 'route') {
                autoBtn.textContent = 'RUTA';
                autoBtn.classList.add('active', 'route-mode');
                autoBtn.title = 'Vista general de ruta (Zoom fijo a nivel 13)';
            } else { // 'off'
                autoBtn.textContent = 'AUTO';
                autoBtn.title = 'Zoom automático (Desactivado)';
            }
        };

        autoBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            currentMode = zoomModesCycle[currentMode];
            localStorage.setItem(AUTO_ZOOM_MODE_KEY, currentMode);
            
            updateAutoButtonVisuals();
            markCacheAsDirty(); 
               
            isManualZoomActive = false;
            if (manualZoomTimeout) clearTimeout(manualZoomTimeout);

            switch (currentMode) {
                case 'auto':
                    handleAutoZoom();
                    break;
                case 'off':
                    break;
                case 'route':
                    map.easeTo({ zoom: 13 });
                    break;
            }
        });
        
        updateAutoButtonVisuals();
        
        toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            handleZoomToggleButtonClick(toggleBtn);
        });
        
        locateMeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            handleLocateMeClick(true);
        });
        
        settingsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.parentControl.toggleSettingsPopup();
        });

        offsetBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.parentControl.toggleOffsetPopup();
        });

        return this._container;
    }
    onRemove() { if (this._container && this._container.parentNode) this._container.parentNode.removeChild(this._container); this._map = undefined; }
}
// ===================================================================
// NOMBRE: CombinedMapControl (NUEVA CLASE)
// RESUMEN: Envuelve los controles de Capas/Vista y Zoom en un único contenedor para que aparezcan juntos.
class CombinedMapControl {
    onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.className = 'mapboxgl-ctrl map-combined-controls-wrapper';

        this.layerAndViewControl = new MapLayerAndViewController();
        const layerControlElement = this.layerAndViewControl.onAdd(map);
        
        this.zoomControl = new ZoomControl();
        const zoomControlElement = this.zoomControl.onAdd(map);
        
        if (layerControlElement) {
            this._container.appendChild(layerControlElement);
        }
        if (zoomControlElement) {
            this._container.appendChild(zoomControlElement);
        }
        
        return this._container;
    }

    onRemove() {
        if (this.layerAndViewControl) this.layerAndViewControl.onRemove();
        if (this.zoomControl) this.zoomControl.onRemove();
        
        if (this._container && this._container.parentNode) {
            this._container.parentNode.removeChild(this._container);
        }
        this._map = undefined;
    }
}
    
// ===================================================================
// NOMBRE: findGooglePlaceId 
// RESUMEN: Busca un lugar usando texto/coordenadas para obtener su place_id.
// ===================================================================
async function findGooglePlaceId(poiName, lat, lng) {
    if (!window.google || !window.google.maps || !window.google.maps.places) {
        console.error("La librería de Google Places no está cargada.");
        showToast("Error: No se pudo cargar el servicio de lugares.", "error");
        return null;
    }

    const request = {
        textQuery: poiName,
        fields: ['id'], 
        locationBias: { center: { lat: lat, lng: lng }, radius: 2000 }, // Radio en metros
    };

    try {
        const { places } = await google.maps.places.Place.searchByText(request);
        
        if (places && places.length > 0) {
            return places[0].id; 
        } else {
            console.warn("No se encontró un place_id de Google para:", poiName);
            return null;
        }
    } catch (error) {
        console.error("Error en la búsqueda de Google Places:", error);
        return null;
    }
}

// ===================================================================
// NOMBRE: getGooglePlaceDetails 
// RESUMEN: Obtiene los detalles completos de un lugar usando su place_id.
// ===================================================================
async function getGooglePlaceDetails(placeId) {
    if (!window.google || !window.google.maps || !window.google.maps.places) {
        console.error("La librería de Google Places no está cargada.");
        showToast("Error: No se pudo cargar el servicio de lugares.", "error");
        return null;
    }
    
    const place = new google.maps.places.Place({ id: placeId });

    const fieldsToRequest = [
        'displayName', 'formattedAddress', 'websiteURI', 'nationalPhoneNumber',
        'regularOpeningHours', 'photos', 'rating', 'userRatingCount', 'googleMapsURI', 'reviews'
    ];
    
    try {
        await place.fetchFields({ fields: fieldsToRequest });
        
        return place;
    } catch (error) {
        console.error("Error al obtener detalles de Google Places:", error);
        return null;
    }
}


// ===================================================================
// FUNCIÓN 2 (VERSIÓN FINAL): Clase 
// ===================================================================
class MapSettingsPanel {
    constructor(map) {
        this._map = map;
    }

    createPanelContent() {
        const fragment = document.createDocumentFragment();

        const layerSelector = document.createElement('div');
        layerSelector.className = 'map-layer-selector';

        const baseMaps = { "HÍBRIDO": "mapbox://styles/mapbox/satellite-streets-v12", "SATÉLITE": "mapbox://styles/mapbox/satellite-v9", "CALLES": "mapbox://styles/mapbox/standard" };
        const legacyNameMap = { "Satélite + Calles": "HÍBRIDO", "Satélite Puro": "SATÉLITE", "Mapa Normal": "CALLES" };
        let savedLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY);
        if (legacyNameMap[savedLayerName]) { savedLayerName = legacyNameMap[savedLayerName]; localStorage.setItem(ACTIVE_MAP_LAYER_KEY, savedLayerName); }
        if (!savedLayerName || !baseMaps[savedLayerName]) { savedLayerName = "HÍBRIDO"; }
        
        Object.keys(baseMaps).forEach(name => {
            const label = document.createElement('label');
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = 'map-style-selector';
            input.value = baseMaps[name];
            if (name === savedLayerName) input.checked = true;
            input.onchange = () => {
                this._map.setStyle(input.value);
                localStorage.setItem(ACTIVE_MAP_LAYER_KEY, name);
           
                this._map.once('style.load', () => {
                    this._map.once('idle', async () => {
                        await loadAndAddMapImages(this._map);
                        await reAddCustomMapLayersAndSources(this._map);

                        // ¡CLAVE! Al cambiar el estilo, se debe reconfigurar el terreno y la atmósfera.
                        await configureMapAtmosphere();
                        
                        // Se mantiene el resto de la lógica para mover la cámara a la posición correcta.
                        const currentModeKey = localStorage.getItem(MAP_VIEW_MODE_KEY) || 'relief';
                        const viewModes = {
                            'NORTE': { pitch: 0, bearing: 0, mode: 'static', terrain: false },
                            'AVANCE': { pitch: 0, bearing: null, mode: 'heading', terrain: false },
                            '3D': { pitch: 62, bearing: null, mode: 'perspective', terrain: false },
                            '3D RELIEVE': { pitch: 68, bearing: null, mode: 'relief', terrain: true }
                        };
                        const currentModeDetails = Object.values(viewModes).find(m => m.mode === currentModeKey);
                        if (currentModeDetails) {
                            const cameraOptions = {};
                            if (currentModeDetails.mode === 'perspective' || currentModeDetails.mode === 'relief') {
                                cameraOptions.pitch = mapPitchValue;
                            } else {
                                cameraOptions.pitch = currentModeDetails.pitch;
                            }
                            if (currentModeDetails.bearing !== null) {
                                cameraOptions.bearing = currentModeDetails.bearing;
                            } else if (navigationCurrentLocation && navigationCurrentLocation.heading !== null) {
                                cameraOptions.bearing = navigationCurrentLocation.heading;
                            }
                            this._map.easeTo({ ...cameraOptions, duration: 0 });
                        }
                        
                        plotRemindersOnNavigationMap();
                        displayChargingPointsOnMap();
                        displayAlertsOnMap();
                        renderWaypointMarkers();
                        updateRouteAndCarIconStyle();
                    });
                });
            };
            label.appendChild(input);
            label.appendChild(document.createTextNode(` ${name}`));
            layerSelector.appendChild(label);
        });

        const viewSelector = document.createElement('div');
        viewSelector.className = 'map-view-selector';

        const viewModes = {
            'NORTE': { pitch: 0, bearing: 0, mode: 'static', terrain: false },
            'AVANCE': { pitch: 0, bearing: null, mode: 'heading', terrain: false },
            '3D': { pitch: 62, bearing: null, mode: 'perspective', terrain: false },
            '3D RELIEVE': { pitch: 68, bearing: null, mode: 'relief', terrain: true }
        };

        const savedViewMode = localStorage.getItem(MAP_VIEW_MODE_KEY) || 'relief';
        
        Object.keys(viewModes).forEach(name => {
            const label = document.createElement('label');
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = 'map-view-selector';
            const modeDetails = viewModes[name];
            input.value = modeDetails.mode;
            if (modeDetails.mode === savedViewMode) input.checked = true;
            
            input.onchange = async () => {
                if (!input.checked) return;

                const selectedModeValue = input.value;
                const newModeDetails = Object.values(viewModes).find(m => m.mode === selectedModeValue);
                const newModeName = Object.keys(viewModes).find(key => viewModes[key].mode === selectedModeValue);

                if (newModeDetails) {
                    // 1. Actualizamos el estado global del modo de vista.
                    mapViewMode = newModeDetails.mode;
                    localStorage.setItem(MAP_VIEW_MODE_KEY, mapViewMode);
                    markCacheAsDirty();
                    showToast(`Modo Vista: ${newModeName}`, 'info');
                   
                    // 2. Llamamos a la función maestra para que gestione terreno y niebla.
                    await configureMapAtmosphere();
                    
                    // 3. Movemos la cámara a la posición correcta para el nuevo modo.
                    const easeOptions = {
                        bearing: newModeDetails.bearing
                    };
                    if (navigationCurrentLocation && newModeDetails.bearing === null && navigationCurrentLocation.heading !== null) {
                        easeOptions.bearing = navigationCurrentLocation.heading;
                    }
                    if (newModeDetails.mode === 'perspective' || newModeDetails.mode === 'relief') {
                        easeOptions.pitch = mapPitchValue;
                    } else {
                        easeOptions.pitch = newModeDetails.pitch;
                    }
                    this._map.easeTo(easeOptions);
                    
                    // 4. Actualizamos la posición del coche por si acaso.
                    if (navigationCurrentLocation) {
                        updateInitialUserPosition(navigationCurrentLocation, this._map);
                    }
                }
            };
            label.appendChild(input);
            label.appendChild(document.createTextNode(` ${name}`));
            viewSelector.appendChild(label);
        });
        
        const separator = document.createElement('div');
        separator.className = 'separator';

        fragment.appendChild(layerSelector);
        fragment.appendChild(separator);
        fragment.appendChild(viewSelector);

        return fragment;
    }
}    
    
// ===================================================================
// NOMBRE: initializeApp 
// RESUMEN: Llama a la nueva función `uploadDirtyCacheOnLoad_Car` y establece el timestamp inicial para la sincronización móvil.
async function initializeApp() {
    const recoveryExecuted = await checkForAndExecuteCrashRecovery();

    loadCustomData();
    loadSavedSettings();
    applyMapVisualSettings();
    applyMainUISettings();
  
    isMobileSession = parseUserId(localStorage.getItem('userData_userId')).isMobile; 
    
    if (isMobileSession) {
        document.body.classList.add('mobile-view');
        await restoreCacheForMobile();
    } else {
        await uploadDirtyCacheOnLoad_Car();
    }

    lastMobileSyncTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');
    
    checkForExcessiveRadars();
    
    const termsAccepted = localStorage.getItem('termsAccepted_v1') === 'true';
    const shouldDirectToNav = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
    const tempPreventDirectNav = sessionStorage.getItem(TEMP_PREVENT_DIRECT_NAV_KEY);
    
    if ((shouldDirectToNav && !tempPreventDirectNav && termsAccepted) || recoveryExecuted) {
        if(!recoveryExecuted) sessionStorage.setItem('isInDirectToMapMode', 'true');
        directToNavOnLoad = true;
        const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'none';
        const footerContent = document.querySelector('footer'); if (footerContent) footerContent.style.display = 'none';
        const noticesIconContainer = document.querySelector('.notices-icon-container'); if (noticesIconContainer) noticesIconContainer.style.display = 'none';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'none');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'none');
        document.getElementById('grid-filter-container').style.display = 'none';
        
        if (!recoveryExecuted) {
            openNavigationMap();
        }
    } else {
        sessionStorage.removeItem('isInDirectToMapMode');
        directToNavOnLoad = false;
        const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'block';
        const footerContent = document.querySelector('footer'); if (footerContent) footerContent.style.display = 'block';
        const noticesIconContainer = document.querySelector('.notices-icon-container'); if (noticesIconContainer) noticesIconContainer.style.display = 'flex';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'flex');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'block');
        document.getElementById('grid-filter-container').style.display = 'flex';
    }

    initializeConfigModalListeners();
    try { await updateVersion(); } catch (e) { }
    try { await loadNotices(); startNoticeRotation(); } catch (e) { }
    if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
    
    
    if (!termsAccepted) {
        showConfigModal();
    }

    const noticeToggleIcon = document.getElementById('notice-toggle-icon');
    if (noticeToggleIcon) noticeToggleIcon.addEventListener('click', toggleNotices);
    const countEl = document.getElementById('reminder-count-globe');
    if (countEl) {
         const openTable = (e) => {
             if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
             e.preventDefault(); e.stopPropagation();
             showAllReminders();
         };
         countEl.addEventListener('click', openTable);
         countEl.style.cursor = 'pointer';
    }
    const filterInput = document.getElementById('grid-filter-input');
    const clearButton = document.getElementById('clear-filter-button');
    if (filterInput) {
        const savedFilter = localStorage.getItem('gridFilterValue');
        if (savedFilter !== null) filterInput.value = savedFilter;
        filterInput.addEventListener('input', () => {
             localStorage.setItem('gridFilterValue', filterInput.value);
             filterGridItems();
             if(isKeywordAssignmentMode) applyInitialKeywordHighlights();
        });
    }
    if (clearButton) {
        clearButton.addEventListener('click', () => {
             if (filterInput) filterInput.value = '';
             localStorage.removeItem('gridFilterValue');
             markCacheAsDirty(); 
             filterGridItems();
             if(isKeywordAssignmentMode) applyInitialKeywordHighlights();
        });
    }
    
    const openChatArea = document.getElementById('open-chat-area');
    if (openChatArea) {
        openChatArea.addEventListener('click', openChatModal);
    }
    updateTotalMessageCount(); 
    
    const userCountGlobe = document.getElementById('user-count-globe');
    if (userCountGlobe) {
        userCountGlobe.addEventListener('click', () => {
            showToast('Usuarios activos', 'info');
        });
        if (window.db && window.getDocs && window.collection) {
            const usersCollectionRef = window.collection(window.db, "user_data");
            window.getDocs(usersCollectionRef).then(snapshot => {
                userCountGlobe.textContent = snapshot.size;
            }).catch(error => {
                userCountGlobe.textContent = 'X';
            });
        }
    }

    await checkVersionsIconOpacity();

    document.body.addEventListener('click', function(event) {
        const target = event.target;
        const targetId = target.id || (target.closest('[id]') ? target.closest('[id]').id : null);
        if (targetId === 'config-close-modal') {
            const termsAcceptedForClose = localStorage.getItem('termsAccepted_v1') === 'true';
            if (!termsAcceptedForClose) {
                showToast('Debes aceptar las normas de uso para continuar.', 'warning');
                return;
            }
            const modal = document.getElementById('config-modal');
            if (modal && !modal.classList.contains('hidden')) {
                clearModalAutoCloseTimer(modal, target, 'config-modal');
                modal.classList.add('hidden');
                 const mapWasOpenBeforeConfig = sessionStorage.getItem('boardinggate_map_should_reopen_after_config') === 'true';
                 const mapContextToReopen = sessionStorage.getItem('mapContextToReopenAfterConfig');
                 sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');
                 sessionStorage.removeItem('mapContextToReopenAfterConfig');
                 if (mapWasOpenBeforeConfig && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !document.getElementById('reminders-location-map-modal')) {
                    if (mapContextToReopen === 'navigation') {
                        setTimeout(() => openNavigationMap(), 50);
                    }
                }
            }
        }
        if (target.matches('.config-tab-button')) {
            const modal = document.getElementById('config-modal');
            if(modal && modal.classList.contains('hidden') === false) {
                const tabTarget = target.dataset.tabTarget;
                modal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                modal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (modal.querySelector(tabTarget)) {
                    modal.querySelector(tabTarget).classList.add('active');
                }
            }
        }
        if (targetId === 'close-reminders-top' || targetId === 'close-reminders-bottom') {
            const modalTable = document.querySelector('.reminder-table-modal');
            if (modalTable) {
                if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                modalTable.remove();
                const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                const mapContext = sessionStorage.getItem('mapContext');
                sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                sessionStorage.removeItem('mapContext');
                if (fromReminderModal) {
                    fromReminderModal = false;
                    if (mapShouldReopen) {
                        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                        sessionStorage.setItem('mapContext', mapContext);
                    }
                    showReminderModal();
                } else if (mapShouldReopen) {
                     if (mapContext === 'navigation') openNavigationMap();
                }
            }
        }
        if (targetId === 'view-all-locations-map') {
            const modalTable = document.querySelector('.reminder-table-modal');
             if (modalTable && modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
             if (modalTable) modalTable.remove();
            setTimeout(() => {
                openLocationsPreviewMap();
            }, 50);
        }
         if (targetId === 'close-locations-preview') {
            const previewModal = document.getElementById('locations-preview-modal');
            if (previewModal) {
                if (locationsPreviewMap) {
                    try { locationsPreviewMap.remove(); } catch (e) {}
                    locationsPreviewMap = null;
                }
                if (mapLayersControlLocationsPreview) {
                    try {mapLayersControlLocationsPreview.remove();} catch(e){}
                    mapLayersControlLocationsPreview = null;
                }
                clearModalAutoCloseTimer(previewModal, target, 'locations-preview-modal');
                previewModal.classList.add('hidden');
            }
        }
        if (targetId === 'close-address-suggestions-modal') {
            hideAddressSuggestionsModal();
        }
    });
   const configModal = document.getElementById('config-modal');
    if (configModal) {
        configModal.addEventListener('click', function(event) {
            const target = event.target;
            if (target.matches('.config-tab-button')) {
                const tabTarget = target.dataset.tabTarget;
                configModal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                configModal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (configModal.querySelector(tabTarget)) {
                    configModal.querySelector(tabTarget).classList.add('active');
                }
            }
        });
    }
    const bookmarkGrid = document.getElementById('bookmark-grid');
    if (bookmarkGrid) {
        bookmarkGrid.addEventListener('click', function(event) {
            const link = event.target.closest('a.bookmark-item');
            if (link && link.href && link.href.startsWith("map-action:")) {
                event.preventDefault();
                const action = link.href.split(":")[1];
                if (action === "openRemindersMapWithNoRadars") {
                    closeOtherModals();
                    setTimeout(() => {
                        const existingPreviewModal = document.getElementById('locations-preview-modal');
                        if (existingPreviewModal && !existingPreviewModal.classList.contains('hidden')) {
                            showToast("El mapa de ubicaciones (sin radar) ya está abierto", "info");
                        } else {
                           openLocationsPreviewMap();
                        }
                    }, 50);
                } else if (action === "openRemindersMap") {
                    closeOtherModals();
                    setTimeout(() => {
                        const mapModalElement = document.getElementById('reminders-location-map-modal');
                        if (mapModalElement && !mapModalElement.classList.contains('hidden')) {
                            showToast("El mapa de navegación/ubicaciones ya está abierto", "info");
                            if (navigationMapInstance) {
                                requestAnimationFrame(() => {
                                    requestAnimationFrame(() => {
                                        if (navigationMapInstance) {
                                            try {
                                                 navigationMapInstance.resize();
                                             } catch (e) {  }
                                        }
                                    });
                                });
                            }
                        } else {
                           openNavigationMap();
                        }
                    }, 50);
                }
            }
        });
    }
    
    const accidentAlertButton = document.getElementById('accident-alert-button');
    if (accidentAlertButton) {
        accidentAlertButton.addEventListener('click', () => {
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
            openAlertModal();
        });
    }

     window.addEventListener('beforeunload', () => {
         if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
         if (locationWatchId !== null && navigator.geolocation) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
         if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
         const openReminderModal = document.querySelector('.reminder-modal');
         if (openReminderModal && typeof openReminderModal.cleanUpModalTimers === 'function') { openReminderModal.cleanUpModalTimers(true); }
         Object.keys(globalModalTimers).forEach(modalId => {
            const timerData = globalModalTimers[modalId];
            if (timerData) {
                clearModalAutoCloseTimer(timerData.modalElement, timerData.closeButtonElement, modalId);
            }
         });
         globalModalTimers = {};
         const openTableModal = document.querySelector('.reminder-table-modal');
         if(openTableModal && openTableModal.autoCloseInterval) { clearInterval(openTableModal.autoCloseInterval); }
         const openPostponeModal = document.getElementById('postpone-options-modal');
         if(openPostponeModal && openPostponeModal.autoPostponeInterval) { clearInterval(openPostponeModal.autoPostponeInterval); }
         const openSavedLocationsModal = document.querySelector('.saved-locations-modal');
         if (openSavedLocationsModal && locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
         const simModalUnload = document.getElementById('simulation-modal');
         if (simModalUnload && simulationModalTimer) clearTimeout(simulationModalTimer);
         if (autoStartNavTimer) clearTimeout(autoStartNavTimer);
         if (isNavigationMapActive || navigationMapInstance) {
            closeNavigationMap(true);
         }
         if (locationsPreviewMap) {
             try { locationsPreviewMap.remove(); } catch(e){}
             locationsPreviewMap = null;
         }
         if (isAssignmentMode || isEditMode || isKeywordAssignmentMode) { saveCustomData(); }
         const filterInput = document.getElementById('grid-filter-input');
         if (filterInput && filterInput.value.trim()) {
              localStorage.setItem('gridFilterValue', filterInput.value);
         } else {
              localStorage.removeItem('gridFilterValue');
         }
          saveSettings();
          if (reminderModalMap) try {reminderModalMap.remove();} catch(e){}
          Object.values(previewMaps).forEach(map => {try {map?.remove();} catch(e){}});
          if (intersectionPreviewMap) try {intersectionPreviewMap.remove();} catch(e){}
          if (navigationChart) navigationChart.destroy();
          if (graphIntervalTimer) clearInterval(graphIntervalTimer);
     });
}    

// ===================================================================
// NOMBRE: checkAndMarkWaypointsAsVisited 
// RESUMEN: Marca la etapa como visitada a 70m y muestra el modal de llegada solo a 20m.
function checkAndMarkWaypointsAsVisited(route, carDistanceAlongRoute, currentCoords) {
    if (!route || !route.legs || !currentCoords) return;

    let cumulativeDistance = 0;
    navigationWaypoints.forEach((wp, index) => {
        if (wp) {
            const isStartPoint = wp.type === 'S' || wp.isRecalculatedStart;
            const isIntermediate = wp.type === 'intermediate';
            const isFinal = wp.type === 'F';

            if (isStartPoint) {
                wp.visited = true;
            } else if (isIntermediate && (index - 1) < route.legs.length) {
                const leg = route.legs[index - 1];
                if (leg) {
                    const distanceToEndOfThisLeg = cumulativeDistance + (leg.distance || 0);
                    const tripHasPhysicallyStarted = isNavigating && navigationStartTimeForStats;
                    const hasClearedStartBuffer = carDistanceAlongRoute > 20;

                    if (tripHasPhysicallyStarted && hasClearedStartBuffer && carDistanceAlongRoute >= distanceToEndOfThisLeg - WAYPOINT_VISITED_THRESHOLD_METERS) {
                        wp.visited = true;
                    }
                    cumulativeDistance = distanceToEndOfThisLeg;
                }
            } else if (isFinal) {
                const finalDestinationCoords = route.legs[route.legs.length - 1].steps.slice(-1)[0].maneuver.location;
                const physicalDistanceToFinal = calculateDistance(currentCoords.latitude, currentCoords.longitude, finalDestinationCoords[1], finalDestinationCoords[0]);

                if (physicalDistanceToFinal <= WAYPOINT_VISITED_THRESHOLD_METERS) {
                    wp.visited = true;
                }

                if (physicalDistanceToFinal <= ARRIVAL_MODAL_THRESHOLD_METERS && !isArrivalSequenceStarted) {
                    triggerArrivalSequence();
                }
            }
        }
    });
}

// ===================================================================
// NOMBRE: loadAndCacheLerpSettings 
// RESUMEN: Lee los valores de suavizado desde localStorage y los guarda
function loadAndCacheLerpSettings() {
    lerpRatePosition = parseFloat(localStorage.getItem(LERP_RATE_POS_KEY)) || 0.004;
    lerpRateRotation = parseFloat(localStorage.getItem(LERP_RATE_ROT_KEY)) || 0.001;
    lerpRateZoom = parseFloat(localStorage.getItem(LERP_RATE_ZOOM_KEY)) || 0.001;
}

// ===================================================================
// NOMBRE: saveSettings 
// ===================================================================
function saveSettings() {
    localStorage.setItem('darkMode', JSON.stringify(isDarkMode));
    const tS = {};
    document.querySelectorAll('.range-toggle').forEach(t => {
        const start = t.dataset.rangeStart;
        if (start) tS[start] = t.dataset.state;
    });
    localStorage.setItem('toggleStates', JSON.stringify(tS));
    const zoomButton = document.getElementById('zoom-button');
    if (zoomButton) localStorage.setItem('zoomState', zoomButton.dataset.zoomState);
    const onOffBtn = document.getElementById('on-off-toggle');
    if (onOffBtn) localStorage.setItem('onOffState', onOffBtn.dataset.state);
    localStorage.setItem('noticesActive', JSON.stringify(isActive));
    localStorage.setItem('footerVisible', JSON.stringify(isFooterVisible));
    localStorage.setItem('password_active', JSON.stringify(isPasswordActive));
    localStorage.setItem('lastUpdatesCheckDate', lastUpdatesCheckDate);
    localStorage.setItem(GRAPH_STATE_KEY, currentGraphMode);
    localStorage.setItem(MAP_VIEW_OFFSET_X_KEY, mapOffsetX);
    localStorage.setItem(MAP_VIEW_OFFSET_Y_KEY, mapOffsetY);
    localStorage.setItem(MAP_VIEW_SHOW_MINIMAP_KEY, showMinimapPreference);
    localStorage.setItem(MAP_VIEW_PITCH_KEY, mapPitchValue);
    
    localStorage.setItem('boardinggate_map_saturation', document.documentElement.style.getPropertyValue('--map-saturation').trim() || '1.6');
    localStorage.setItem('boardinggate_map_contrast', document.documentElement.style.getPropertyValue('--map-contrast').trim() || '1.2');
    localStorage.setItem(LERP_RATE_POS_KEY, localStorage.getItem(LERP_RATE_POS_KEY) || '0.004');
    localStorage.setItem(LERP_RATE_ROT_KEY, localStorage.getItem(LERP_RATE_ROT_KEY) || '0.001');
    localStorage.setItem(LERP_RATE_ZOOM_KEY, localStorage.getItem(LERP_RATE_ZOOM_KEY) || '0.001');
    localStorage.setItem(MAP_TERRAIN_EXAGGERATION_KEY, mapTerrainExaggeration); 

    const radaresCheckboxElement = document.getElementById('radares-ruta-checkbox');
    if (radaresCheckboxElement) {
        localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckboxElement.checked));
    }
    const tareasCheckboxElement = document.getElementById('tareas-ruta-checkbox');
    if (tareasCheckboxElement) { 
        localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckboxElement.checked));
    }
    const mainSearchInputGrid = document.getElementById('main-search-input'); 
    if (mainSearchInputGrid) {
        localStorage.setItem('gridFilterValue', mainSearchInputGrid.value);
    }
    const mapFilterInput = document.getElementById('filter-input'); 
    if (mapFilterInput) {
        localStorage.setItem(MAP_FILTER_INPUT_KEY, mapFilterInput.value);
    }
    if (mapLayersControl && mapLayersControl._map && mapLayersControl._map._layers) {
        const layersArray = Object.values(mapLayersControl._map._layers);
        const baseLayerMapObject = layersArray.find(l => l._map && l.options && !l.options.pane && l.options.attribution);
        if (baseLayerMapObject) {
            const activeLayerEntry = mapLayersControl._layers.find(l => l.layer === baseLayerMapObject);
            if (activeLayerEntry && activeLayerEntry.name) {
                localStorage.setItem(ACTIVE_MAP_LAYER_KEY, activeLayerEntry.name);
            }
        }
    }
    markCacheAsDirty(); 
}

// ===================================================================
// NOMBRE: loadSavedSettings 
function loadSavedSettings() {
    const savedDarkMode = localStorage.getItem('darkMode');
    isDarkMode = savedDarkMode ? JSON.parse(savedDarkMode) : false;
    if (isDarkMode) document.body.classList.add('dark-mode');
    
    mapOffsetX = parseInt(localStorage.getItem(MAP_VIEW_OFFSET_X_KEY)) || 0;
    mapOffsetY = parseInt(localStorage.getItem(MAP_VIEW_OFFSET_Y_KEY)) || -30;
    const savedMinimapPref = localStorage.getItem(MAP_VIEW_SHOW_MINIMAP_KEY);
    showMinimapPreference = savedMinimapPref === null ? true : JSON.parse(savedMinimapPref);
    mapPitchValue = parseInt(localStorage.getItem(MAP_VIEW_PITCH_KEY)) || 62;
    mapTerrainExaggeration = parseFloat(localStorage.getItem(MAP_TERRAIN_EXAGGERATION_KEY)) || 0.6; // <-- AÑADIR ESTA LÍNEA
    
    performanceRatios.criticalUpdate = parseInt(localStorage.getItem(PERFORMANCE_RATIO_CRITICAL_KEY)) || 3;
    performanceRatios.routeProgress = parseInt(localStorage.getItem(PERFORMANCE_RATIO_ROUTE_KEY)) || 30;
    performanceRatios.trafficAlerts = parseInt(localStorage.getItem(PERFORMANCE_RATIO_ALERTS_KEY)) || 300;
    performanceRatios.tripStats = parseInt(localStorage.getItem(PERFORMANCE_RATIO_STATS_KEY)) || 32;
    performanceRatios.performanceGraph = parseInt(localStorage.getItem(PERFORMANCE_RATIO_GRAPH_KEY)) || 70;

    const savedCameraFps = parseInt(localStorage.getItem(PERFORMANCE_CAMERA_FPS_KEY)) || 45;
    MAP_UPDATE_INTERVAL_MS = 1000 / savedCameraFps;
    
    loadAndCacheLerpSettings();
 
    if (!localStorage.getItem('boardinggate_map_saturation')) localStorage.setItem('boardinggate_map_saturation', '1.6');
    if (!localStorage.getItem('boardinggate_map_contrast')) localStorage.setItem('boardinggate_map_contrast', '1.2');
    
    const savedZoomState = localStorage.getItem('zoomState');
    const zoomButtonElem = document.getElementById('zoom-button');
    if (zoomButtonElem) {
        zoomButtonElem.dataset.zoomState = savedZoomState || 'off';
        applyZoom(zoomButtonElem.dataset.zoomState);
    }
    const savedPasswordActive = localStorage.getItem('password_active');
    isPasswordActive = savedPasswordActive ? JSON.parse(savedPasswordActive) : false;
    storedPin = localStorage.getItem('password_pin');
    lastUpdatesCheckDate = localStorage.getItem('lastUpdatesCheckDate');
    mapViewMode = localStorage.getItem(MAP_VIEW_MODE_KEY) || 'relief';
    const savedNoticesActive = localStorage.getItem('noticesActive');
    const savedFooterVisible = localStorage.getItem('footerVisible');
    isActive = savedNoticesActive ? JSON.parse(savedNoticesActive) : true;
    isFooterVisible = savedFooterVisible ? JSON.parse(savedFooterVisible) : true;
    const noticeContainer = document.querySelector('.notices-container');
    if (noticeContainer) noticeContainer.style.display = isActive ? 'flex' : 'none';
    const footerElement = document.querySelector('footer');
    if (footerElement) footerElement.classList.toggle('footer-hidden', !isFooterVisible);
    const onOffBtn = document.getElementById('on-off-toggle');
    if (onOffBtn) {
        const savedOnOffState = localStorage.getItem('onOffState');
        onOffBtn.dataset.state = savedOnOffState ? savedOnOffState : 'on';
    }
    const toggleStatesFromCache = JSON.parse(localStorage.getItem('toggleStates') || '{}');
    document.querySelectorAll('.range-toggle').forEach(toggle => {
        const start = parseInt(toggle.dataset.rangeStart);
        const savedState = toggleStatesFromCache[start] || 'visible';
        toggle.dataset.state = savedState;
    });
    const mainSearchInputGrid = document.getElementById('grid-filter-input');
    if (mainSearchInputGrid) {
        const savedMainFilter = localStorage.getItem('gridFilterValue');
        if (savedMainFilter !== null) {
            mainSearchInputGrid.value = savedMainFilter;
        } else {
            mainSearchInputGrid.value = '';
        }
    }
    
    const mapFilterInput = document.getElementById('filter-input'); 
    if (mapFilterInput) {
        mapFilterInput.value = localStorage.getItem(MAP_FILTER_INPUT_KEY) || 'España';
    }
    
    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresRutaCheckbox) {
        const savedCheckState = localStorage.getItem(RADARES_RUTA_CHECKED_KEY);
        radaresRutaCheckbox.checked = savedCheckState === 'true';
    }
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasRutaCheckbox) {
        const savedTareasCheckState = localStorage.getItem(TAREAS_RUTA_CHECKED_KEY);
        tareasRutaCheckbox.checked = savedTareasCheckState === 'true';
    }
    currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviación ETA';
    const userIdInput = document.getElementById('user-id');
    const modelInput = document.getElementById('tesla-model');
    const yearInput = document.getElementById('tesla-year');
    const provinceInput = document.getElementById('tesla-province');
    const dmsCheckbox = document.getElementById('allow-dms');
    const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
    if (userIdInput) userIdInput.value = localStorage.getItem('userData_userId') || '';
    if (modelInput) modelInput.value = localStorage.getItem('userData_teslaModel') || '';
    if (yearInput) yearInput.value = localStorage.getItem('userData_teslaYear') || '';
    if (provinceInput) provinceInput.value = localStorage.getItem('userData_teslaProvince') || '';
   
   const savedAllowDMs = localStorage.getItem('userData_allowDMs');
   if (dmsCheckbox) {
    dmsCheckbox.checked = savedAllowDMs === null ? true : JSON.parse(savedAllowDMs); 
   } 
    
    if (autoBackupCheckbox) {
        const savedAutoBackup = localStorage.getItem('boardinggate_autoBackupOnLoad');
        autoBackupCheckbox.checked = savedAutoBackup === null ? true : JSON.parse(savedAutoBackup);
    }
    const savedLockState = localStorage.getItem(PROGRESS_BAR_LOCKED_KEY);
    isProgressBarLocked = savedLockState === null ? true : JSON.parse(savedLockState);
    actualizarContadorRadares(0);
    actualizarContadorTareas(0);
    updateUserIdDisplay();
    updateReminderCount();
}    
    
// ===================================================================
// NOMBRE: sanitizeWaypointsForStorage 
// RESUMEN: Crea una copia "limpia" de un array de waypoints, eliminando propiedades
function sanitizeWaypointsForStorage(waypoints) {
    if (!Array.isArray(waypoints)) return [];
    return waypoints.map(wp => {
        if (!wp) return null;
        return {
            id: wp.id,
            lat: wp.lat,
            lng: wp.lng,
            address: wp.address,
            type: wp.type,
            label: wp.label,
            visited: wp.visited,
            isInternal: wp.isInternal,
            isRecalculatedStart: wp.isRecalculatedStart,
            isCriticalForRecalc: wp.isCriticalForRecalc
        };
    }).filter(Boolean); 
}

// ===================================================================
// NOMBRE: showNavigationMapHelpModal
// RESUMEN: Muestra un modal de ayuda completo con todos los controles de
function showNavigationMapHelpModal() {
    const existingHelpModal = document.getElementById('reminders-map-help-modal-instance');
    if (existingHelpModal) {
        clearModalAutoCloseTimer(existingHelpModal, existingHelpModal.querySelector('#close-reminders-map-help-instance'), 'reminders-map-help-modal-instance');
        existingHelpModal.remove();
    }

    const helpModal = document.createElement('div');
    helpModal.id = 'reminders-map-help-modal-instance';
    helpModal.className = 'help-modal';
    helpModal.setAttribute('aria-label', 'Ayuda Mapa de Navegación/Radares');
    
    const LERP_RATE_POS_KEY = 'boardinggate_lerp_rate_position';
    const LERP_RATE_ROT_KEY = 'boardinggate_lerp_rate_rotation';
    const LERP_RATE_ZOOM_KEY = 'boardinggate_lerp_rate_zoom';

    const currentLerpPosition = localStorage.getItem(LERP_RATE_POS_KEY) || '0.004';
    const currentLerpRotation = localStorage.getItem(LERP_RATE_ROT_KEY) || '0.001';
    const currentLerpZoom = localStorage.getItem(LERP_RATE_ZOOM_KEY) || '0.001';
    
    helpModal.innerHTML = `
        <style>
            #reminders-map-help-modal-instance h3 { color: #87CEEB; margin-top: 1.2rem; margin-bottom: 0.5rem; border-bottom: 1px solid #444; padding-bottom: 4px;}
            #reminders-map-help-modal-instance ul { list-style-position: inside; padding-left: 0.5rem; }
            #reminders-map-help-modal-instance li { margin-bottom: 0.5rem; }
            #reminders-map-help-modal-instance .icon-in-text { height: 1.4em; display: inline; vertical-align: middle; margin: 0 4px; padding: 2px; border-radius: 4px; background: rgba(255,255,255,0.1);}
            #reminders-map-help-modal-instance .icon-in-text.circle { border-radius: 50%; }
            .visual-settings-container { background-color: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin-top: 10px; flex-grow: 1;}
            .slider-control { display: flex; align-items: center; gap: 15px; margin-bottom: 10px; }
            .slider-control label { flex-basis: 120px; text-align: right; font-weight: bold; color: #a0a0a0; }
            .slider-control .value-display { flex-basis: 120px; font-weight: bold; color: #f0f0f0; text-align: left; }
            .reset-visuals-btn { background-color: #0838a3; color: white; padding: 4px 8px; border:none; border-radius: 5px; cursor: pointer; margin-top: 5px; }
            .slider-input-wrapper { display: flex; align-items: center; gap: 8px; flex-grow: 1; }
            .slider-input-wrapper input[type="range"] { flex-grow: 1; }
            .slider-btn {
                flex-shrink: 0; width: 28px; height: 28px;
                background-color: #0838a3; color: white;
                border: 1px solid #777; border-radius: 50%;
                cursor: pointer; font-size: 20px; font-weight: bold;
                line-height: 26px; text-align: center;
                padding: 0; user-select: none;
            }
            .slider-btn:active { background-color: #777; transform: scale(0.95); }
            .lerp-help-text { font-size: 0.8rem; color: #b0b0b0; margin-top: 10px; text-align: center; font-style: italic; }
            .two-column-layout { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem; }
            .two-column-layout > div { display: flex; flex-direction: column; }
        </style>

        <h2 class="text-xl font-bold mb-4">Ayuda del Mapa de Navegación</h2>
        <div class="modal-top-buttons" style="justify-content: flex-end;">
            <button type="button" id="close-reminders-map-help-instance" style="flex: 0 1 auto; min-width: 120px;">Entendido</button>
        </div>
        <div style="max-height: 70vh; overflow-y: auto; padding-right: 15px;">
            
            <h3><img src="https://boardinggate.github.io/Tesla/PNG/personal.png" class="icon-in-text"> Ajustes Visuales y Suavizado</h3>
            <div class="two-column-layout">
                <div>
                    <div class="visual-settings-container">
                        <div class="slider-control">
                            <label for="map-saturation-slider">Saturación:</label>
                            <input type="range" id="map-saturation-slider" min="0.5" max="2" step="0.01">
                            <span id="map-saturation-value" class="value-display"></span>
                        </div>
                        <div class="slider-control">
                            <label for="map-contrast-slider">Contraste:</label>
                            <input type="range" id="map-contrast-slider" min="0.5" max="2" step="0.01">
                            <span id="map-contrast-value" class="value-display"></span>
                        </div>
                        <div class="slider-control">
                            <label for="map-exaggeration-slider">Exageración desnivel 3D:</label>
                            <input type="range" id="map-exaggeration-slider" min="0" max="3" step="0.01">
                            <span id="map-exaggeration-value" class="value-display"></span>
                        </div>
                        <button id="map-visuals-reset-btn" class="reset-visuals-btn">Restaurar por defecto</button>
                        <div class="visual-settings-container" style="margin-top: 10px; padding: 10px; text-align: left;">
                             <label for="direct-to-nav-checkbox-map-help" style="display: flex; align-items: center; cursor: pointer; font-size: 1rem; user-select: none;">
                                 <input type="checkbox" id="direct-to-nav-checkbox-map-help" style="width: 1.2rem; height: 1.2rem; margin-right: 10px; flex-shrink: 0;">
                                 <span style="font-weight: bold; color: #a0a0a0;">Entrar directamente al Navegador</span>
                             </label>
                        </div>
                    </div>
                </div>
                <div>
                    <div class="visual-settings-container">
                        <div class="slider-control">
                            <label for="lerp-position-slider" title="SUAVIZADO LERP MOVIMIENTO LATERAL MAPA:">Movimiento Lateral:</label>
                            <input type="range" id="lerp-position-slider" min="0.0001" max="0.02" step="0.0001" value="${currentLerpPosition}">
                            <span id="lerp-position-value" class="value-display">${parseFloat(currentLerpPosition).toFixed(4)}</span>
                        </div>
                        <div class="slider-control">
                            <label for="lerp-rotation-slider" title="SUAVIZADO LERP PARA ROTACIONES:">Rotaciones:</label>
                            <input type="range" id="lerp-rotation-slider" min="0.0001" max="0.02" step="0.0001" value="${currentLerpRotation}">
                            <span id="lerp-rotation-value" class="value-display">${parseFloat(currentLerpRotation).toFixed(4)}</span>
                        </div>
                        <div class="slider-control">
                            <label for="lerp-zoom-slider" title="SUAVIZADO LERP INCLINACIÓN">Zoom e Inclinación:</label>
                            <input type="range" id="lerp-zoom-slider" min="0.0001" max="0.02" step="0.0001" value="${currentLerpZoom}">
                            <span id="lerp-zoom-value" class="value-display">${parseFloat(currentLerpZoom).toFixed(4)}</span>
                        </div>
                        <button id="lerp-reset-btn" class="reset-visuals-btn">Restaurar por defecto</button>
                        <p class="lerp-help-text">(*) Valor Mayor = Movimientos más bruscos y rápidos. Valor Menor = Más suaves y lentos.</p>
                    </div>
                </div>
            </div>

            <h3><img src="https://boardinggate.github.io/Tesla/PNG/config.jpg" class="icon-in-text"> Ajuste de Rendimiento (Navegación)</h3>
            <div class="visual-settings-container">
                <p style="font-size: 0.9rem; margin-bottom: 15px;">Ajusta la frecuencia de actualización para optimizar el rendimiento. Un número más alto significa que la tarea se ejecuta con menos frecuencia (mejor rendimiento, menos actualizaciones). Un número más bajo es más "en tiempo real" pero consume más recursos.</p>
                <div class="slider-control">
                    <label for="gps-hz-display" style="color: #f0f0f0;">GPS Ticks/seg:</label>
                    <span id="gps-hz-display" class="value-display" style="text-align: left;">Calculando...</span>
                </div>
                <div class="slider-control">
                    <label for="camera-fps-slider">Animación Cámara FPS:</label>
                    <div class="slider-input-wrapper">
                        <button type="button" class="slider-btn minus" data-target="camera-fps-slider">-</button>
                        <button type="button" class="slider-btn plus" data-target="camera-fps-slider">+</button>
                        <input type="range" id="camera-fps-slider" min="1" max="60" step="1">
                    </div>
                    <span id="camera-fps-value" class="value-display"></span>
                </div>
                <div class="slider-control">
                    <label for="ratio-critical-update-slider">Procesos Críticos:</label>
                    <div class="slider-input-wrapper">
                        <button type="button" class="slider-btn minus" data-target="ratio-critical-update-slider">-</button>
                        <button type="button" class="slider-btn plus" data-target="ratio-critical-update-slider">+</button>
                        <input type="range" id="ratio-critical-update-slider" min="1" max="100" step="1">
                    </div>
                    <span id="ratio-critical-update-value" class="value-display"></span>
                </div>
                <div class="slider-control">
                    <label for="ratio-route-progress-slider">Progreso Ruta:</label>
                     <div class="slider-input-wrapper">
                        <button type="button" class="slider-btn minus" data-target="ratio-route-progress-slider">-</button>
                        <button type="button" class="slider-btn plus" data-target="ratio-route-progress-slider">+</button>
                        <input type="range" id="ratio-route-progress-slider" min="1" max="200" step="1">
                    </div>
                    <span id="ratio-route-progress-value" class="value-display"></span>
                </div>
                <div class="slider-control">
                    <label for="ratio-traffic-alerts-slider">Alertas Tráfico:</label>
                    <div class="slider-input-wrapper">
                        <button type="button" class="slider-btn minus" data-target="ratio-traffic-alerts-slider">-</button>
                        <button type="button" class="slider-btn plus" data-target="ratio-traffic-alerts-slider">+</button>
                        <input type="range" id="ratio-traffic-alerts-slider" min="1" max="1000" step="1">
                    </div>
                    <span id="ratio-traffic-alerts-value" class="value-display"></span>
                </div>
                <div class="slider-control">
                    <label for="ratio-trip-stats-slider">Estadísticas:</label>
                    <div class="slider-input-wrapper">
                        <button type="button" class="slider-btn minus" data-target="ratio-trip-stats-slider">-</button>
                        <button type="button" class="slider-btn plus" data-target="ratio-trip-stats-slider">+</button>
                        <input type="range" id="ratio-trip-stats-slider" min="1" max="1000" step="1">
                    </div>
                    <span id="ratio-trip-stats-value" class="value-display"></span>
                </div>
                <div class="slider-control">
                    <label for="ratio-performance-graph-slider">Gráfica:</label>
                    <div class="slider-input-wrapper">
                        <button type="button" class="slider-btn minus" data-target="ratio-performance-graph-slider">-</button>
                        <button type="button" class="slider-btn plus" data-target="ratio-performance-graph-slider">+</button>
                        <input type="range" id="ratio-performance-graph-slider" min="1" max="1000" step="1">
                    </div>
                    <span id="ratio-performance-graph-value" class="value-display"></span>
                </div>
                <button id="perf-ratios-reset-btn" class="reset-visuals-btn">Restaurar por defecto</button>
                <div class="visual-settings-container" style="margin-top: 10px; text-align: left;">
                    <label for="monitor-resources-checkbox-map" style="display: flex; align-items: center; cursor: pointer; font-size: 1rem; user-select: none;">
                        <input type="checkbox" id="monitor-resources-checkbox-map" style="width: 1.2rem; height: 1.2rem; margin-right: 10px; flex-shrink: 0;">
                        <span style="font-weight: bold; color: #a0a0a0;">Activar Monitor de Recursos (Memoria/FPS)</span>
                    </label>
                    <p style="font-size: 0.8rem; margin-left: 32px; color: #ff9500;">No dejar activado permanentemente, consume recursos adicionales.</p>
                </div>
            </div>

            <h3><img src="https://boardinggate.github.io/Tesla/PNG/config.jpg" class="icon-in-text"> Controles Principales</h3>
            <ul class="list-disc space-y-2">
                 <li><strong>Botón Flotante <img src="PNG/Coche_Sat.PNG" class="icon-in-text circle">:</strong> Es tu navaja suiza. Realiza diferentes acciones según el gesto:
                    <ul style="padding-left: 20px; margin-top: 5px;">
                        <li><strong>Clic Corto:</strong> Muestra u oculta la barra de botones superior.</li>
                        <li><strong>Pulsación Larga (1 seg):</strong> Abre el menú para reportar <strong>Alertas de Tráfico</strong>.</li>
                        <li><strong>Deslizar ARRIBA:</strong> Inicia <img src="PNG/INICIARNAVEGACION.PNG" class="icon-in-text"> o detiene <img src="PNG/TERMINARNAVEGACION.PNG" class="icon-in-text"> la navegación.</li>
                        <li><strong>Deslizar a la IZQUIERDA:</strong> Activa/desactiva el modo inmersivo (pantalla completa).</li>
                        <li><strong>Deslizar a la DERECHA / ABAJO:</strong> Carga y navega automáticamente a tus rutas guardadas "CASA" o "TRABAJO".</li>
                    </ul>
                </li>
                <li><strong>Salir del Mapa <img src="PNG/SALIR.PNG" class="icon-in-text">:</strong> Cierra la vista de navegación y vuelve al lanzador principal.</li>
                <li><strong>Localización <img src="PNG/ESTASAQUI.PNG" class="icon-in-text">:</strong> Centra el mapa en tu posición actual. Si lo pulsas de nuevo (<img src="PNG/DEJARSEGUIR.PNG" class="icon-in-text">), desactivas el seguimiento automático.</li>
                <li><strong>Zoom <img src="PNG/ZOOM+.PNG" class="icon-in-text"> / <img src="PNG/ZOOM-.PNG" class="icon-in-text">:</strong> Alterna entre una vista general de toda la ruta y un zoom cercano a tu vehículo.</li>
            </ul>

            <h3><img src="./PNG/ANADIRPUNTO.PNG" class="icon-in-text"> Planificación de Ruta</h3>
            <ul class="list-disc space-y-2">
                <li><strong>Añadir Puntos:</strong> Simplemente <strong>pulsa en cualquier lugar del mapa</strong> para añadir una etapa. También puedes usar el <strong>buscador de texto</strong> para encontrar direcciones o lugares y añadirlos con el botón <img src="./PNG/ANADIRPUNTO.PNG" class="icon-in-text">.</li>
                <li><strong>Eliminar Puntos:</strong> Pulsa la <strong>'X' roja</strong> sobre cualquier marcador de etapa.</li>
                <li><strong>Reordenar Etapas <img src="./PNG/MOVER.PNG" class="icon-in-text">:</strong> Abre un menú para arrastrar y cambiar el orden de las etapas de tu ruta.</li>
                <li><strong>Guardar y Cargar Rutas <img src="PNG/GUARDARRUTA.PNG" class="icon-in-text"> <img src="PNG/CARGARRUTA.PNG" class="icon-in-text">:</strong> Guarda la ruta actual para usarla en el futuro o carga una ya existente.</li>
            </ul>

            <h3><img src="https://boardinggate.github.io/Tesla/th.jpeg" class="icon-in-text circle"> Durante la Navegación</h3>
            <ul class="list-disc space-y-2">
                <li><strong>Rutas Alternativas:</strong>
                    <ul>
                        <li><strong>Pulsación Larga</strong> sobre un marcador de etapa (1, 2, F...) para ver al instante las rutas alternativas (Rápida, Corta, Alternativa) para ese tramo.</li>
                        <li>También puedes hacer un <strong>clic corto</strong> en el marcador, y en la tarjeta que se abre, pulsar el botón <strong>"OTRAS RUTAS"</strong>.</li>
                    </ul>
                </li>
                <li><strong>Puntos de Recarga (PDRs) <img src="PNG/pdrs.png" class="icon-in-text">:</strong>
                    <ul>
                        <li><strong>1ª Pulsación:</strong> Abre un modal para filtrar PDRs por potencia, distancia a la ruta y operadores.</li>
                        <li><strong>2ª Pulsación:</strong> Muestra en el mapa solo el PDR más económico de cada rango de potencia (resaltado con un halo amarillo).</li>
                        <li><strong>3ª Pulsación:</strong> Limpia todos los PDRs del mapa.</li>
                    </ul>
                </li>
                 <li><strong>Radares y Tareas en Ruta:</strong> Activa los checkboxes <img src="https://i.imgur.com/r33g3oY.png" class="icon-in-text"> para ver en el mapa y en la barra de progreso los radares o tus tareas personales que se encuentren en el trazado actual.</li>
                 <li><strong>Simulación <img src="./PNG/GPS.PNG" class="icon-in-text">:</strong> Activa este modo para que el coche recorra la ruta automáticamente o para fijar tu posición GPS manualmente haciendo clic en el mapa.</li>
            </ul>
        </div>
    `;

    const mapModal = document.getElementById('reminders-location-map-modal');
    if (mapModal) {
        mapModal.style.zIndex = 6400;
    }
 
    document.body.appendChild(helpModal); 
    
    const directToNavCheckboxMapHelp = helpModal.querySelector('#direct-to-nav-checkbox-map-help');
    if (directToNavCheckboxMapHelp) {
        directToNavCheckboxMapHelp.checked = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
        directToNavCheckboxMapHelp.addEventListener('change', () => {
            const isChecked = directToNavCheckboxMapHelp.checked;
            localStorage.setItem(DIRECT_TO_NAVIGATION_KEY, JSON.stringify(isChecked));
            markCacheAsDirty();
            showToast(`Inicio directo al navegador ${isChecked ? 'ACTIVADO' : 'DESACTIVADO'}.`, 'info');
        });
    }
    
    const setupLerpSlider = (sliderId, valueId, storageKey, defaultValue) => {
        const slider = helpModal.querySelector(`#${sliderId}`);
        const valueDisplay = helpModal.querySelector(`#${valueId}`);
        if (!slider || !valueDisplay) return;

        slider.addEventListener('input', () => {
            const val = slider.value;
            valueDisplay.textContent = parseFloat(val).toFixed(4);
            localStorage.setItem(storageKey, val);
            loadAndCacheLerpSettings();
            markCacheAsDirty();
         });
    };

    setupLerpSlider('lerp-position-slider', 'lerp-position-value', LERP_RATE_POS_KEY, '0.004');
    setupLerpSlider('lerp-rotation-slider', 'lerp-rotation-value', LERP_RATE_ROT_KEY, '0.0017');
    setupLerpSlider('lerp-zoom-slider', 'lerp-zoom-value', LERP_RATE_ZOOM_KEY, '0.001');

    const lerpResetBtn = helpModal.querySelector('#lerp-reset-btn');
    lerpResetBtn.addEventListener('click', () => {
        const defaults = {
            'lerp-position-slider': '0.004',
            'lerp-rotation-slider': '0.0017',
            'lerp-zoom-slider': '0.001'
        };
        for (const sliderId in defaults) {
            const slider = helpModal.querySelector(`#${sliderId}`);
            if (slider) {
                slider.value = defaults[sliderId];
                slider.dispatchEvent(new Event('input'));
            }
        }
     });

    const monitorCheckboxMap = helpModal.querySelector('#monitor-resources-checkbox-map');
    if (monitorCheckboxMap) {
        monitorCheckboxMap.checked = isMonitoring;
        monitorCheckboxMap.addEventListener('change', () => {
            if (monitorCheckboxMap.checked) {
                startResourceMonitor();
                showToast('Monitor de recursos ACTIVADO.', 'info');
            } else {
                stopResourceMonitor();
                showToast('Monitor de recursos DESACTIVADO.', 'info');
            }
        });
    }

    helpModal.addEventListener('click', (e) => {
        if (e.target.classList.contains('slider-btn')) {
            e.preventDefault(); 
            const targetSliderId = e.target.dataset.target;
            const slider = helpModal.querySelector(`#${targetSliderId}`);
            if (slider) {
                if (e.target.classList.contains('minus')) {
                    slider.stepDown();
                } else {
                    slider.stepUp();
                }
                slider.dispatchEvent(new Event('input'));
            }
        }
    });

    const gpsHzDisplay = helpModal.querySelector('#gps-hz-display');
    let baseFrequency = 0;
    
    const cameraFpsSlider = helpModal.querySelector('#camera-fps-slider');
    const cameraFpsValue = helpModal.querySelector('#camera-fps-value');
    if (cameraFpsSlider && cameraFpsValue) {
        const savedFps = parseInt(localStorage.getItem(PERFORMANCE_CAMERA_FPS_KEY)) || 40;
        cameraFpsSlider.value = savedFps;
        cameraFpsValue.textContent = `${savedFps} FPS`;

        cameraFpsSlider.addEventListener('input', () => {
            const fps = parseInt(cameraFpsSlider.value);
            cameraFpsValue.textContent = `${fps} FPS`;
            MAP_UPDATE_INTERVAL_MS = 1000 / fps;
            localStorage.setItem(PERFORMANCE_CAMERA_FPS_KEY, fps);
            markCacheAsDirty();
        });
    }

    const sliders = [
        { id: 'ratio-critical-update-slider', valueId: 'ratio-critical-update-value', key: PERFORMANCE_RATIO_CRITICAL_KEY, default: 3, name: 'criticalUpdate' },
        { id: 'ratio-route-progress-slider', valueId: 'ratio-route-progress-value', key: PERFORMANCE_RATIO_ROUTE_KEY, default: 30, name: 'routeProgress' },
        { id: 'ratio-traffic-alerts-slider', valueId: 'ratio-traffic-alerts-value', key: PERFORMANCE_RATIO_ALERTS_KEY, default: 300, name: 'trafficAlerts' },
        { id: 'ratio-trip-stats-slider', valueId: 'ratio-trip-stats-value', key: PERFORMANCE_RATIO_STATS_KEY, default: 32, name: 'tripStats' },
        { id: 'ratio-performance-graph-slider', valueId: 'ratio-performance-graph-value', key: PERFORMANCE_RATIO_GRAPH_KEY, default: 70, name: 'performanceGraph' }
    ];

    const updateAllIntervalDisplays = () => {
        if (baseFrequency > 0) {
            sliders.forEach(sliderConfig => {
                const slider = helpModal.querySelector(`#${sliderConfig.id}`);
                const valueDisplay = helpModal.querySelector(`#${sliderConfig.valueId}`);
                if (slider && valueDisplay) {
                    const ratio = parseInt(slider.value);
                    const intervalMs = Math.round((ratio / baseFrequency) * 1000);
                    valueDisplay.textContent = `${ratio} (~${intervalMs} ms)`;
                }
            });
        } else {
            sliders.forEach(sliderConfig => {
                const slider = helpModal.querySelector(`#${sliderConfig.id}`);
                const valueDisplay = helpModal.querySelector(`#${sliderConfig.valueId}`);
                if (slider && valueDisplay) {
                    valueDisplay.textContent = `${slider.value} (~? ms)`;
                }
            });
        }
    };

    const setupRatioSlider = (config) => {
        const slider = helpModal.querySelector(`#${config.id}`);
        const valueDisplay = helpModal.querySelector(`#${config.valueId}`);
        if (!slider || !valueDisplay) return;

        slider.value = localStorage.getItem(config.key) || config.default;
        performanceRatios[config.name] = parseInt(slider.value);
        
        slider.addEventListener('input', () => {
            const val = slider.value;
            localStorage.setItem(config.key, val);
            markCacheAsDirty(); 
            performanceRatios[config.name] = parseInt(val);
            updateAllIntervalDisplays();
        });
    };
    
    sliders.forEach(setupRatioSlider);
    
    if (gpsHzDisplay) {
        if (gpsHzMonitor.interval) clearInterval(gpsHzMonitor.interval);
        gpsHzMonitor.interval = setInterval(() => {
            if (document.body.contains(gpsHzDisplay)) {
                if (isSimulatingGpsLocation) {
                    baseFrequency = (1000 / SIMULATION_TICK_INTERVAL_MS);
                    gpsHzDisplay.textContent = `SIM (~${baseFrequency.toFixed(1)})`;
                } else {
                    baseFrequency = gpsHzMonitor.ticks;
                    gpsHzDisplay.textContent = `${baseFrequency.toFixed(1)}`;
                    gpsHzMonitor.ticks = 0;
                }
                updateAllIntervalDisplays();
            } else {
                clearInterval(gpsHzMonitor.interval);
                gpsHzMonitor.interval = null;
            }
        }, 1000);
    }

    const perfResetBtn = helpModal.querySelector('#perf-ratios-reset-btn');
    perfResetBtn.addEventListener('click', () => {
        sliders.forEach(config => {
            const slider = document.getElementById(config.id);
            slider.value = config.default;
            slider.dispatchEvent(new Event('input'));
        });
        if (cameraFpsSlider) cameraFpsSlider.value = 45;
        if (cameraFpsSlider) cameraFpsSlider.dispatchEvent(new Event('input'));
        showToast('Ratios de rendimiento restaurados.', 'info');
    });

    const saturationSlider = helpModal.querySelector('#map-saturation-slider');
    const contrastSlider = helpModal.querySelector('#map-contrast-slider');
    const exaggerationSlider = helpModal.querySelector('#map-exaggeration-slider'); // <-- NUEVO
    const saturationValue = helpModal.querySelector('#map-saturation-value');
    const contrastValue = helpModal.querySelector('#map-contrast-value');
    const exaggerationValue = helpModal.querySelector('#map-exaggeration-value'); // <-- NUEVO
    const resetButton = helpModal.querySelector('#map-visuals-reset-btn');

    const updateVisualLabels = () => {
        saturationValue.textContent = `${Math.round(saturationSlider.value * 100)}%`;
        contrastValue.textContent = `${Math.round(contrastSlider.value * 100)}%`;
        exaggerationValue.textContent = `${parseFloat(exaggerationSlider.value).toFixed(2)}x`; // <-- NUEVO
    };

    saturationSlider.value = getComputedStyle(document.documentElement).getPropertyValue('--map-saturation').trim() || '1.6';
    contrastSlider.value = getComputedStyle(document.documentElement).getPropertyValue('--map-contrast').trim() || '1.15';
    exaggerationSlider.value = mapTerrainExaggeration; 

    updateVisualLabels();

    saturationSlider.addEventListener('input', () => {
        const val = saturationSlider.value;
        document.documentElement.style.setProperty('--map-saturation', val);
        localStorage.setItem('boardinggate_map_saturation', val);
        markCacheAsDirty();
        updateVisualLabels();
    });

    contrastSlider.addEventListener('input', () => {
        const val = contrastSlider.value;
        document.documentElement.style.setProperty('--map-contrast', val);
        localStorage.setItem('boardinggate_map_contrast', val);
        updateVisualLabels();
        markCacheAsDirty();
    });
    
    exaggerationSlider.addEventListener('input', async () => {
        const val = parseFloat(exaggerationSlider.value);
        mapTerrainExaggeration = val;
        saveSettings(); 
        await configureMapAtmosphere(); // Aplica el cambio en tiempo real
        updateVisualLabels();
    });
   
    resetButton.addEventListener('click', () => {
        saturationSlider.value = '1.6';
        contrastSlider.value = '1.2';
        exaggerationSlider.value = '0.8'; 
        saturationSlider.dispatchEvent(new Event('input'));
        contrastSlider.dispatchEvent(new Event('input'));
        exaggerationSlider.dispatchEvent(new Event('input')); // <-- NUEVO
        showToast('Ajustes visuales restaurados a los valores por defecto.', 'info');
    });

    const closeButtonHelp = helpModal.querySelector('#close-reminders-map-help-instance');
    const closeHandlerHelp = () => { 
        if(gpsHzMonitor.interval) clearInterval(gpsHzMonitor.interval);
        gpsHzMonitor.interval = null;
        clearModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance'); 
        if (helpModal.parentNode) {
            helpModal.parentNode.removeChild(helpModal); 
        }
        if (mapModal) {
            mapModal.style.zIndex = '';
        }
    };
    
    closeButtonHelp.addEventListener('click', closeHandlerHelp); 
    addModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance', 90000);
}
    
// ===================================================================
// NOMBRE: updateDynamicRadars 
// RESUMEN: Carga radares dinámicos en un radio cuando no se navega. SE HA ELIMINADO LA LÓGICA DE RUTA PARA EVITAR BUCLES.
async function updateDynamicRadars(isInitialLoadCheck = false) {
    const nowDate = new Date();
    const now = nowDate.getTime();
    const timeSinceLastCheck = now - lastDynamicRadarCheck;
    if (isInitialLoadCheck) {
        const hasExistingDynamicRadars = processedRemindersCache.some(r => r.isDynamicRadar === true);
        if (timeSinceLastCheck < 30 * 60 * 1000 && hasExistingDynamicRadars) return;
    }
    lastDynamicRadarCheck = now;
    if (!isInitialLoadCheck) showToast("Actualizando radares dinámicos...", "info", 3000, false, "radar-update");

    if (!window.radarsCache || !window.radarsSpatialIndex) {
        await initializeRadarCache();
        if (!window.radarsCache) {
            showToast("No se pudo inicializar la base de datos de radares.", "error");
            return;
        }
    }
    
    try {
        let newRadars = [];
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]').filter(r => !r.isDynamicRadar);
        
        const routeSource = navigationMapInstance?.getSource('route');
        if (routeSource && routeSource._data && routeSource._data.geometry && routeSource._data.geometry.coordinates.length > 1) {
            return; 
        } 
        
        let coords = null;
        if (navigationCurrentLocation && (Date.now() - lastGpsUpdateTime < 30000)) {
            coords = navigationCurrentLocation;
        } else {
            coords = await getCurrentLocationAsync();
        }
        if (!coords) throw new Error("Ubicación del vehículo no disponible.");

        const DYNAMIC_RADAR_SEARCH_RADIUS_KM = 45;
        const candidateRadars = new Set();
        const R = 6371;
        const rad = DYNAMIC_RADAR_SEARCH_RADIUS_KM / R;
        const latRad = coords.latitude * Math.PI / 180;
        const GRID_SIZE = 0.1;

        const latMin = coords.latitude - (rad * 180 / Math.PI);
        const latMax = coords.latitude + (rad * 180 / Math.PI);
        const deltaLon = Math.asin(Math.sin(rad) / Math.cos(latRad));
        const lonMin = coords.longitude - (deltaLon * 180 / Math.PI);
        const lonMax = coords.longitude + (deltaLon * 180 / Math.PI);
        
        const latIndexMin = Math.floor(latMin / GRID_SIZE);
        const latIndexMax = Math.floor(latMax / GRID_SIZE);
        const lonIndexMin = Math.floor(lonMin / GRID_SIZE);
        const lonIndexMax = Math.floor(lonMax / GRID_SIZE);
        
        for (let i = latIndexMin; i <= latIndexMax; i++) {
            for (let j = lonIndexMin; j <= lonIndexMax; j++) {
                const cellId = `cell_${i}_${j}`;
                if (window.radarsSpatialIndex[cellId]) {
                    window.radarsSpatialIndex[cellId].forEach(radar => candidateRadars.add(radar));
                }
            }
        }

        candidateRadars.forEach(radar => {
            const distance = calculateDistance(coords.latitude, coords.longitude, radar.lat, radar.lon);
            if (distance <= (DYNAMIC_RADAR_SEARCH_RADIUS_KM * 1000)) {
                newRadars.push({
                    id: Date.now() + Math.random() + newRadars.length,
                    text: `<b>RADAR: ${radar.name}</b>`,
                    type: 'simple', time: '00:01',
                    date: `${nowDate.getFullYear()}-${(nowDate.getMonth() + 1).toString().padStart(2, '0')}-${nowDate.getDate().toString().padStart(2, '0')}`,
                    createdAt: nowDate.toISOString(), managedByUser: false,
                    isLocationEnabled: true, locationCoordinates: { latitude: radar.lat, longitude: radar.lon },
                    radiusMeters: 400, excludeFromList: true,
                    isDynamicRadar: true
                });
            }
        });
        
        reminders.push(...newRadars);
        localStorage.setItem('reminders', JSON.stringify(reminders));
        markCacheAsDirty();
        
        if (isNavigationMapActive) {
            plotRemindersOnNavigationMap();
        }
        updateReminderCount();
        updateButtonStyles();
     
    } catch (error) {
    }
}    

    
// ===================================================================
// NOMBRE: applyMainUISettings 
// RESUMEN: Aplica todas las configuraciones visuales de la interfaz principal (toggles, filtros, etc.).
function applyMainUISettings() {
    renderGrid();
    createOtherButtons();
    renderToggleButtons();
    updateButtonStyles();
    filterGridItems();
    setTimeout(adjustButtonPositions, 100);
}    


// ===================================================================
// NOMBRE: toggleRadaresRuta 
// ===================================================================
async function toggleRadaresRuta(activo) {
    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(activo));

    radaresEnRutaActual = [];

    if (activo) {
        const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
        if (actualWaypoints.length < 2) {
            actualizarYOrdenarEventosEnRuta();
            plotRemindersOnNavigationMap(); // Aseguramos que se limpie el mapa si no hay ruta
            return;
        }
        
        if (navigationMapInstance && navigationMapInstance.getSource('route') && navigationMapInstance.getSource('route')._data) {
            try {
                if (!window.radarsCache) await initializeRadarCache();
                if (!window.radarsCache) throw new Error("Base de datos de radares no disponible.");

                const routeLineString = turf.lineString(navigationMapInstance.getSource('route')._data.geometry.coordinates);
                
                processedRemindersCache.forEach(reminder => {
                    const isRadarType = (reminder.text.toUpperCase().includes("RADAR") || reminder.excludeFromList);
                    if (isRadarType && reminder.isLocationEnabled && reminder.locationCoordinates) {
                        const radarPoint = turf.point([reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]);
                        const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, radarPoint, { units: 'meters' });

                        if (nearestPointOnRoute.properties.dist <= RUTA_RADAR_PROXIMITY_THRESHOLD) {
                            radaresEnRutaActual.push({
                                ...reminder, isFromRuta: true, distanceOnRoute: nearestPointOnRoute.properties.location
                            });
                        }
                    }
                });

                const intersectingCells = new Set();
                const routeCoords = routeLineString.geometry.coordinates;
                for (let i = 0; i < routeCoords.length; i++) {
                    intersectingCells.add(getGridCellId(routeCoords[i][1], routeCoords[i][0]));
                }
                const cellsToSearch = new Set(intersectingCells);
                intersectingCells.forEach(cellId => {
                    const [_, latIdx, lonIdx] = cellId.split('_').map(Number);
                    for (let i = -1; i <= 1; i++) { for (let j = -1; j <= 1; j++) { cellsToSearch.add(`cell_${latIdx + i}_${lonIdx + j}`); } }
                });

                const candidateRadars = [];
                cellsToSearch.forEach(cellId => { if (window.radarsSpatialIndex[cellId]) candidateRadars.push(...window.radarsSpatialIndex[cellId]); });
                const uniqueCandidates = [...new Set(candidateRadars)];
                
                uniqueCandidates.forEach(radar => {
                    const radarPoint = turf.point([radar.lon, radar.lat]);
                    const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, radarPoint, { units: 'meters' });

                    if (nearestPointOnRoute.properties.dist <= RUTA_RADAR_PROXIMITY_THRESHOLD) {
                        const radarYaExiste = radaresEnRutaActual.some(rem => 
                            rem.locationCoordinates &&
                            Math.abs(rem.locationCoordinates.latitude - radar.lat) < COORD_EPSILON &&
                            Math.abs(rem.locationCoordinates.longitude - radar.lon) < COORD_EPSILON
                        );
                        if (!radarYaExiste) {
                            const now = new Date();
                            const radarData = {
                                id: Date.now() + Math.random() + radaresEnRutaActual.length,
                                text: `<b>RADAR RUTA: ${radar.name}</b>`, type: 'simple', time: '00:01',
                                date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                                createdAt: now.toISOString(), managedByUser: false, isLocationEnabled: true,
                                locationCoordinates: { latitude: radar.lat, longitude: radar.lon },
                                radiusMeters: 350, excludeFromList: true, isFromRuta: true,
                                distanceOnRoute: nearestPointOnRoute.properties.location
                            };
                            radaresEnRutaActual.push(radarData);
                        }
                    }
                });
            } catch (error) {
                showToast(`Error al procesar radares en ruta: ${error.message}`, "error");
            }
        }
    }
    
    actualizarYOrdenarEventosEnRuta();
    plotRemindersOnNavigationMap(); 
}
    

// ===================================================================
// NOMBRE: toggleTareasRuta 
// ===================================================================
async function toggleTareasRuta(activo) {
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(activo));
    
    tareasEnRutaActual = [];

    if (activo) {
        const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
        if (actualWaypoints.length < 2) {
            actualizarYOrdenarEventosEnRuta();
            plotRemindersOnNavigationMap(); // Aseguramos que se limpie el mapa si no hay ruta
            return;
        }

        if (navigationMapInstance) {
            const routeSource = navigationMapInstance.getSource('route');
            if (!routeSource || !routeSource._data || !routeSource._data.geometry || routeSource._data.geometry.coordinates.length < 2) {
                if (activo) showToast("Geometría de ruta no disponible para buscar tareas.", "warning");
                actualizarYOrdenarEventosEnRuta();
                plotRemindersOnNavigationMap();
                return;
            }

            try {
                const routeLineString = turf.lineString(routeSource._data.geometry.coordinates);
                const locationReminders = processedRemindersCache.filter(r => {
                    if (!r.isLocationEnabled || !r.locationCoordinates) return false;
                    const isRadarType = r.text.toUpperCase().includes("RADAR") || r.excludeFromList;
                    return !isRadarType;
                });
            
                locationReminders.forEach(reminder => {
                    const taskPoint = turf.point([reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]);
                    const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, taskPoint, { units: 'meters' });
                    const radius = reminder.radiusMeters || DEFAULT_LOCATION_RADIUS;
                    
                    if (nearestPointOnRoute && nearestPointOnRoute.properties.dist !== undefined && nearestPointOnRoute.properties.dist <= radius) {
                        const taskData = { ...reminder, isFromTarea: true, distanceOnRoute: nearestPointOnRoute.properties.location };
                        tareasEnRutaActual.push(taskData);
                    }
                });
            } catch (error) {
                 showToast("Error al procesar tareas en ruta: " + error.message, "error");
            }
        }
    }

    actualizarYOrdenarEventosEnRuta();
    plotRemindersOnNavigationMap();
}   
    
// ===================================================================
// NOMBRE: actualizarYOrdenarEventosEnRuta
// RESUMEN: Unifica los arrays de radares y tareas en una sola lista,
function actualizarYOrdenarEventosEnRuta() {
    eventosEnRuta = [];
    proximoEventoEnRutaIndex = 0;
    
    const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresCheckbox && radaresCheckbox.checked) {
        radaresEnRutaActual.forEach(radar => {
            eventosEnRuta.push({ ...radar, tipoEvento: 'radar' });
        });
    }

    const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasCheckbox && tareasCheckbox.checked) {
        tareasEnRutaActual.forEach(tarea => {
            eventosEnRuta.push({ ...tarea, tipoEvento: 'task' });
        });
    }

    eventosEnRuta.sort((a, b) => a.distanceOnRoute - b.distanceOnRoute);
    
    actualizarContadorRadares(radaresCheckbox && radaresCheckbox.checked ? radaresEnRutaActual.length : 0);
    actualizarContadorTareas(tareasCheckbox && tareasCheckbox.checked ? tareasEnRutaActual.length : 0);
    
    drawStaticMarkersOnProgressBar();
    
    console.log(`[VIGÍA DE RUTA] Lista de eventos en ruta actualizada. Total: ${eventosEnRuta.length}. Próximo índice: ${proximoEventoEnRutaIndex}.`);
}    

// ===================================================================
// NOMBRE: checkReminders (CON LOGGING DE INTERVALO SINCRONIZADO)
// ===================================================================
async function checkReminders() {
    if (reminderCheckIntervalId) {
        clearInterval(reminderCheckIntervalId);
        reminderCheckIntervalId = null;
    }

    const now = Date.now();
 
    if (isCacheDirty) {
        rebuildProcessedRemindersCache();
        updateReminderCount();
        updateButtonStyles();
    }
    
    const overdueReminders = [];
    let coords = navigationCurrentLocation;
    if (!coords && processedRemindersCache.some(r => r.isLocationEnabled)) {
        coords = await getCurrentLocationAsync().catch(() => null);
    }
    
    let isNearActiveLocationPoint = false;
    let hasPendingOverdueEvents = false;
    let culpritFound = false;

    processedRemindersCache.forEach(reminder => {
        if (reminder.managedByUser) return;
        const timeConditionMet = reminder.dueTimeUTC && reminder.dueTimeUTC <= now;
        const isTimeOnlyEvent = !reminder.isLocationEnabled;
        if (timeConditionMet && isTimeOnlyEvent) {
            hasPendingOverdueEvents = true;
            if (!culpritFound) {
                culpritFound = true;
            }
        }
        let locationConditionMet = false;
        if (reminder.isLocationEnabled && reminder.locationCoordinates && coords) {
            const distance = calculateDistance(coords.latitude, coords.longitude, reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude);
            if (distance <= (reminder.radiusMeters || DEFAULT_LOCATION_RADIUS)) {
                locationConditionMet = true;
                if (timeConditionMet) { isNearActiveLocationPoint = true; }
            }
        }
        let shouldNotifyNow = false;
        if (reminder.isLocationEnabled) {
            if (timeConditionMet && locationConditionMet) shouldNotifyNow = true;
        } else {
            if (timeConditionMet) shouldNotifyNow = true;
        }
        if (shouldNotifyNow) { overdueReminders.push(reminder); }
    });
    
    if (overdueReminders.length > 0) {
        displayUnifiedReminderWindow(overdueReminders);
    } else if (isUnifiedWindowVisibleByLogic) {
        hideUnifiedReminderWindow();
    }
    
    let newInterval;
    let reason = "";
    
    if (isNavigating) {
        newInterval = 20000;
        reason = "Navegación activa";
    } else if (hasPendingOverdueEvents) {
        newInterval = 1500; 
        reason = "MODO ALERTA (hay eventos DE TIEMPO vencidos)";
    } else if (isNearActiveLocationPoint) {
        newInterval = 1500;
        reason = "MODO PROXIMIDAD (cerca de un punto ACTIVO)";
    } else {
        recalculateNextEventHorizon();
        const timeToWake = nextEventHorizon.timestamp - now;
        newInterval = timeToWake <= 0 ? 3000 : Math.max(3000, Math.min(30000, timeToWake / 2));
        reason = `MODO EFICIENTE (próximo despertar en ${Math.round(timeToWake/1000)}s)`;
    }
    
    const secondsToNextCheck = newInterval / 1000;
    console.log(`%c[INTERVALO] Próximo chequeo en ${secondsToNextCheck} segundos. Razón: ${reason}.`, 'color: #BA55D3;');
    
    reminderCheckIntervalId = setInterval(checkReminders, newInterval);
}    
// ===================================================================
// NOMBRE: recalculateNextEventHorizon (CON LOGGING SIMPLIFICADO Y ROBUSTO)
// ===================================================================
function recalculateNextEventHorizon() {
    const now = Date.now();
    let nextTemporalEvent = { timestamp: Infinity, id: null, text: 'Ninguno' };
    let nextLocationEvent = { timestamp: Infinity, id: null, text: 'Ninguno' };
    
    // 1. Encontrar próximo evento de TIEMPO
    processedRemindersCache.forEach(reminder => {
        if (!reminder.managedByUser && reminder.dueTimeUTC && reminder.dueTimeUTC > now && reminder.dueTimeUTC < nextTemporalEvent.timestamp) {
            nextTemporalEvent = { timestamp: reminder.dueTimeUTC, id: reminder.id, text: reminder.text };
        }
    });

    // 2. Encontrar próximo evento de UBICACIÓN
    const coords = navigationCurrentLocation;
    if (coords) {
        const candidateReminders = new Set();
        const centerCellId = getGridCellId(coords.latitude, coords.longitude);
        const [_, centerLatIndex, centerLonIndex] = centerCellId.split('_').map(Number);
        for (let i = -1; i <= 1; i++) { for (let j = -1; j <= 1; j++) { const cellId = `cell_${centerLatIndex + i}_${centerLonIndex + j}`; if (remindersSpatialIndex[cellId]) { remindersSpatialIndex[cellId].forEach(r => candidateReminders.add(r)); } } }
        let closestVigia = { distance: Infinity, reminder: null };
        candidateReminders.forEach(reminder => {
            if (!reminder.managedByUser && reminder.isLocationEnabled && reminder.locationCoordinates && reminder.dueTimeUTC <= now) {
                const distance = calculateDistance(coords.latitude, coords.longitude, reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude);
                if (distance < closestVigia.distance) { closestVigia = { distance: distance, reminder: reminder }; }
            }
        });

        if (closestVigia.reminder) {
            let speedKmh;
            if (isNavigating || isFreeDriveActive) {
                const tripDurationMinutes = navigationStartTimeForStats ? (now - navigationStartTimeForStats.getTime()) / 60000 : 0;
                if (tripDurationMinutes < 5) {
                    speedKmh = 90; 
                } else {
                    const MINIMUM_AVERAGE_SPEED_FOR_CALC = 60;
                    speedKmh = Math.max(window.averageSpeedKmh, MINIMUM_AVERAGE_SPEED_FOR_CALC);
                }
            } else {
                speedKmh = (window.currentSpeedKmh || 0) > 10 ? window.currentSpeedKmh : 90;
            }
            
            const speedMps = speedKmh * 1000 / 3600;
            const distanceToActivationZone = Math.max(0, closestVigia.distance - (closestVigia.reminder.radiusMeters || DEFAULT_LOCATION_RADIUS));
            const etaSeconds = speedMps > 0 ? distanceToActivationZone / speedMps : Infinity;
            const MARGEN_SEGURIDAD_MS = 60 * 1000; 
            const wakeUpTimestamp = now + (etaSeconds * 1000) - MARGEN_SEGURIDAD_MS;
            
            nextLocationEvent = {
                timestamp: Math.max(now, wakeUpTimestamp),
                id: closestVigia.reminder.id,
                text: closestVigia.reminder.text
            };
        }
    }

    if (nextTemporalEvent.timestamp < nextLocationEvent.timestamp) {
        nextEventHorizon = { timestamp: nextTemporalEvent.timestamp, type: 'time', targetId: nextTemporalEvent.id };
        const secondsToWake = Math.round((nextEventHorizon.timestamp - now) / 1000);
        const eventText = nextTemporalEvent.text.replace(/<[^>]*>/g, '').substring(0, 50);
        console.log(`[HORIZONTE] Próximo evento: TIEMPO. Despertar en ${secondsToWake}s para: "${eventText}"`);
    } else if (nextLocationEvent.id) {
        nextEventHorizon = { timestamp: nextLocationEvent.timestamp, type: 'location', targetId: nextLocationEvent.id };
        const secondsToWake = Math.round((nextEventHorizon.timestamp - now) / 1000);
        const eventText = nextLocationEvent.text.replace(/<[^>]*>/g, '').substring(0, 50);
        console.log(`[HORIZONTE] Próximo evento: UBICACION. Despertar en ${secondsToWake}s para: "${eventText}"`);
    } else {
        nextEventHorizon = { timestamp: Infinity, type: null, targetId: null };
        console.log('[HORIZONTE] No hay eventos futuros programados.');
    }
}
    
// ===================================================================
// NOMBRE: rebuildProcessedRemindersCache (CORREGIDO - GESTIÓN DE ZONA HORARIA)
// RESUMEN: Parsea las fechas y horas en la zona horaria local del navegador,
function rebuildProcessedRemindersCache() {
    try {
        const allReminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        
        processedRemindersCache = [];
        remindersSpatialIndex = {};
        nonLocationRemindersCache = [];

        allReminders.forEach(reminder => {
            let dueTimeUTC = null;
            if (reminder.date && reminder.time) {
                try {
                    const [year, month, day] = reminder.date.split('-').map(Number);
                    const [hour, minute] = reminder.time.split(':').map(Number);
                    
                    const dueDate = new Date(year, month - 1, day, hour, minute);
                 
                    if (!isNaN(dueDate.getTime())) {
                        dueTimeUTC = dueDate.getTime(); }
                } catch (e) {
                    console.warn(`Fecha/hora inválida para recordatorio ID ${reminder.id}:`, reminder.date, reminder.time);
                }
            }

            const processedReminder = { ...reminder, dueTimeUTC: dueTimeUTC };
            processedRemindersCache.push(processedReminder);

            if (processedReminder.isLocationEnabled && processedReminder.locationCoordinates) {
                const { latitude, longitude } = processedReminder.locationCoordinates;
                if (typeof latitude === 'number' && typeof longitude === 'number') {
                    const cellId = getGridCellId(latitude, longitude);
                    if (!remindersSpatialIndex[cellId]) {
                        remindersSpatialIndex[cellId] = [];
                    }
                    remindersSpatialIndex[cellId].push(processedReminder);
                }
            } else {
                nonLocationRemindersCache.push(processedReminder);
            }
        });

        isCacheDirty = false;
        console.log(`[CACHE] Caché reconstruida: ${processedRemindersCache.length} en total, ${nonLocationRemindersCache.length} solo de tiempo, ${Object.keys(remindersSpatialIndex).length} celdas espaciales.`);
        
        recalculateNextEventHorizon();
        
    } catch (e) {
        console.error("Error al reconstruir la caché de recordatorios:", e);
        processedRemindersCache = [];
        remindersSpatialIndex = {};
        nonLocationRemindersCache = [];
    }
}
    
// ===================================================================
// NOMBRE: stopDeviationChecker (VERSIÓN CORREGIDA PARA setInterval)
// RESUMEN: Detiene el temporizador de comprobación de desvío.
function stopDeviationChecker() {
    if (deviationCheckIntervalId) {
        clearInterval(deviationCheckIntervalId); // <-- CAMBIO CLAVE: Usamos clearInterval
        deviationCheckIntervalId = null;
        deviationStartTime = 0;
    }
}

// ===================================================================
// NOMBRE: startDeviationChecker (VERSIÓN SIMPLIFICADA Y ROBUSTA)
// RESUMEN: Inicia un temporizador FIJO que comprueba el desvío de ruta cada 5 segundos.
// ===================================================================
function startDeviationChecker() {
    stopDeviationChecker(); // Siempre nos aseguramos de limpiar cualquier temporizador anterior.

    const CHECK_INTERVAL_MS = 5000; // Intervalo fijo de 5 segundos.

    deviationCheckIntervalId = setInterval(() => {
        if (isArrivalSequenceStarted) {
            stopDeviationChecker();
            return;
        }

        if (Date.now() < deviationCheckGracePeriodUntil) {
            return;
        }

        if (!isNavigating || !navigationCurrentLocation || isRecalculatingRoute || isDeviationModalActive || isAddReminderAtLocationModeActive) {
            deviationStartTime = 0; // Reseteamos el contador de tiempo de desvío
            return;
        }

        const route = navigationCurrentRouteData?.routes?.[0];
        if (!route || !route.legs || !route.legs[currentLegIndexNav] || !route.legs[currentLegIndexNav].steps[currentStepIndexNav] || typeof turf === 'undefined') {
            return; // Salimos si no hay datos de ruta válidos.
        }
        
        let distanceToRoute = 0;
        try {
            const carPoint = turf.point([navigationCurrentLocation.longitude, navigationCurrentLocation.latitude]);
            
            const searchWindowCoords = [];
            const stepsToInclude = 5;
            let legIdx = currentLegIndexNav;
            let stepIdx = currentStepIndexNav;
            
            for (let i = 0; i < stepsToInclude && legIdx < route.legs.length; i++) {
                const currentLeg = route.legs[legIdx];
                if (stepIdx < currentLeg.steps.length) {
                    const currentStep = currentLeg.steps[stepIdx];
                    if (currentStep.geometry && currentStep.geometry.coordinates) {
                        if (searchWindowCoords.length > 0) {
                            searchWindowCoords.push(...currentStep.geometry.coordinates.slice(1));
                        } else {
                            searchWindowCoords.push(...currentStep.geometry.coordinates);
                        }
                    }
                    stepIdx++;
                } else {
                    legIdx++;
                    stepIdx = 0;
                    i--; 
                }
            }

            if (searchWindowCoords.length < 2) {
                distanceToRoute = 0;
            } else {
                const routeWindowLineString = turf.lineString(searchWindowCoords);
                distanceToRoute = turf.pointToLineDistance(carPoint, routeWindowLineString, { units: 'meters' });
            }

        } catch (e) {
             distanceToRoute = DEVIATION_THRESHOLD_METERS + 1; // Forzar desvío si hay error
        }

        if (distanceToRoute > DEVIATION_THRESHOLD_METERS) {
            if (deviationStartTime === 0) {
                deviationStartTime = Date.now();
            } else if ((Date.now() - deviationStartTime) / 1000 > DEVIATION_MIN_TIME_SECONDS) {
                showDeviationModal();
                deviationStartTime = 0; // Reseteamos para la próxima vez.
            }
        } else {
            deviationStartTime = 0;
        }
    }, CHECK_INTERVAL_MS);
}
    
// ===================================================================
// NOMBRE: saveCustomData 
// RESUMEN: Guarda la personalización y marca la caché de recordatorios como sucia.
function saveCustomData() {
    try {
        if (customData.bookmarks) {
            Object.keys(customData.bookmarks).forEach(indexKey => {
                const index = parseInt(indexKey);
                const custom = customData.bookmarks[index];
                const original = index < originalBookmarks.length ? originalBookmarks[index] : null;
                const bookmarksAreEqual = (b1, b2) => {
                    if (b1 === null && b2 === null) return true;
                    if (b1 === null || b2 === null) return false;
                    return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null);
                };
                if (bookmarksAreEqual(custom, original)) {
                    delete customData.bookmarks[index];
                }
            });
            if (Object.keys(customData.bookmarks).length === 0) {
                delete customData.bookmarks;
            }
        }
        if (customData.toggles) {
            Object.keys(customData.toggles).forEach(startKey => {
                const customToggle = customData.toggles[startKey];
                const originalRange = originalToggleRanges.find(r => r.start == startKey);
                if (customToggle && customToggle.assignedIndexes && originalRange) {
                    const originalDefaultIndexes = [];
                    for (let i = originalRange.start; i <= originalRange.end; i++) {
                        originalDefaultIndexes.push(i);
                    }
                    if (customToggle.assignedIndexes.length === originalDefaultIndexes.length &&
                        customToggle.assignedIndexes.every((val, idx) => val === originalDefaultIndexes[idx])) {
                        delete customToggle.assignedIndexes;
                    }
                }
                if (customToggle && originalRange && customToggle.label === originalRange.label) {
                    delete customToggle.label;
                }
                if (customData.toggles[startKey] && Object.keys(customData.toggles[startKey]).length === 0) {
                    delete customData.toggles[startKey];
                }
            });
            if (Object.keys(customData.toggles).length === 0) {
                delete customData.toggles;
            }
        }
        localStorage.setItem('customGridData', JSON.stringify(customData));
        markCacheAsDirty(); 
    } catch (e) {
        showToast("Error al guardar personalización", "error");
    }
}

// ===================================================================
// NOMBRE: showIntersectionPreviewMap (VERSIÓN FINAL Y FIABLE)
// RESUMEN: Vuelve al patrón fiable de crear/destruir el mapa del minimapa,
// ===================================================================
function showIntersectionPreviewMap(step, route, isSimulationContextOrClick = false, timerDurationMs = null) {
    const savedMinimapPref = localStorage.getItem(MAP_VIEW_SHOW_MINIMAP_KEY);
    const showMinimapPreference = savedMinimapPref === null ? true : JSON.parse(savedMinimapPref);
    if (!showMinimapPreference) {
        hideIntersectionPreviewMap();
        return;
    }
  
    const previewWindow = document.getElementById('intersection-preview-map-window');
    if (!previewWindow || !step || !step.geometry || !route || !navigationMapInstance) {
        hideIntersectionPreviewMap();
        return;
    }
    
    if (!previewWindow.querySelector('#intersection-preview-map-container')) {
        previewWindow.innerHTML = `<div id="intersection-preview-map-container"></div>`;
    }
    const mapContainerEl = previewWindow.querySelector('#intersection-preview-map-container');
    const progressBarEl = document.getElementById('navigation-bottom-progress-bar');
    const isProgressBarVisible = progressBarEl && progressBarEl.offsetParent !== null;

    if (isProgressBarVisible) {
        const progressBarRect = progressBarEl.getBoundingClientRect();
        previewWindow.style.width = `${progressBarRect.width}px`;
        previewWindow.style.top = `${progressBarRect.top}px`;
        previewWindow.style.left = `${progressBarRect.left}px`;
        previewWindow.style.bottom = 'auto';
        previewWindow.style.transform = 'none';
    } else if (isSimulationContextOrClick) {
        previewWindow.style.width = '90%'; previewWindow.style.maxWidth = '500px';
        previewWindow.style.left = '50%'; previewWindow.style.top = '50%';
        previewWindow.style.transform = 'translate(-50%, -50%)';
    } else {
        hideIntersectionPreviewMap();
        return;
    }
    
    previewWindow.classList.add('rendering'); 
    previewWindow.classList.remove('hidden');
    
    previewWindow.dataset.source = isSimulationContextOrClick ? 'click' : 'auto';
    if (intersectionPreviewTimer) clearTimeout(intersectionPreviewTimer);

    try {
        if (intersectionPreviewMap) {
            try { intersectionPreviewMap.remove(); } catch(e) {}
            intersectionPreviewMap = null;
        }

        const savedLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "HÍBRIDO";
        const finalLayerName = MAP_LEGACY_NAME_MAP[savedLayerName] || savedLayerName;
        const currentMapStyle = MAP_STYLES[finalLayerName] || MAP_STYLES["HÍBRIDO"];
        
        const fullRouteLineString = turf.lineString(route.geometry.coordinates);
        const maneuverPointOnRoute = turf.nearestPointOnLine(fullRouteLineString, step.maneuver.location, { units: 'kilometers' });
        const maneuverDistanceKm = maneuverPointOnRoute.properties.location;
        const startSliceDistanceKm = Math.max(0, maneuverDistanceKm - (75 / 1000));
        const endSliceDistanceKm = Math.min(turf.length(fullRouteLineString), maneuverDistanceKm + (90 / 1000));
        const startSlicePoint = turf.along(fullRouteLineString, startSliceDistanceKm);
        const endSlicePoint = turf.along(fullRouteLineString, endSliceDistanceKm);
        const routeSlice = turf.lineSlice(startSlicePoint, endSlicePoint, fullRouteLineString);
        
        const bounds = new mapboxgl.LngLatBounds();
        routeSlice.geometry.coordinates.forEach(coord => bounds.extend(coord));

        const lookAheadPointTurf = turf.along(routeSlice, Math.min(5, turf.length(routeSlice, {units: 'meters'})), { units: 'meters' });
        const segmentBearing = turf.bearing(startSlicePoint, lookAheadPointTurf);
        
        intersectionPreviewMap = new mapboxgl.Map({
            container: mapContainerEl,
            style: currentMapStyle,
            interactive: false,
            attributionControl: false
        });

        intersectionPreviewMap.on('load', () => {
            if (!routeSlice || !routeSlice.geometry || routeSlice.geometry.coordinates.length < 2) {
                hideIntersectionPreviewMap(); 
                return;
            }

            intersectionPreviewMap.addSource('intersection-route', { type: 'geojson', data: routeSlice.geometry });
            intersectionPreviewMap.addLayer({
                id: 'intersection-route-layer', type: 'line', source: 'intersection-route',
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                paint: { 'line-color': '#ACD10F', 'line-width': 13 }
            });
            
            const carPositionPointTurf = turf.along(routeSlice, 30, { units: 'meters' });
            const vehicleEl = document.createElement('div');
            vehicleEl.className = 'vehicle-icon-minimap';
            vehicleEl.innerHTML = `<img src="PNG/AVANCE.PNG" alt="Coche Mini">`;
            
            new mapboxgl.Marker({ element: vehicleEl, anchor: 'center', rotationAlignment: 'viewport', rotation: -90 })
                .setLngLat(carPositionPointTurf.geometry.coordinates)
                .addTo(intersectionPreviewMap);

            const maneuver = step.maneuver;
            const iconFilename = getManeuverIconFilename(maneuver);
            const maneuverIconEl = document.createElement('div');
            maneuverIconEl.style.cssText = `width: 49px; height: 49px; background-image: url('https://boardinggate.github.io/Tesla/${iconFilename}'); background-size: contain; background-repeat: no-repeat; background-position: center;`;
            
            const maneuverPointTurf = turf.point(step.maneuver.location);
            const lineStringToManeuver = turf.lineSlice(turf.point(routeSlice.geometry.coordinates[0]), maneuverPointTurf, routeSlice);
            const iconPositionPointTurf = turf.along(routeSlice, Math.max(0, turf.length(lineStringToManeuver, { units: 'meters' }) - 15), { units: 'meters' });
            
            new mapboxgl.Marker({ element: maneuverIconEl, anchor: 'center' })
                .setLngLat(iconPositionPointTurf.geometry.coordinates)
                .addTo(intersectionPreviewMap);
            
            requestAnimationFrame(() => {
                if (intersectionPreviewMap && document.body.contains(mapContainerEl)) {
                    intersectionPreviewMap.resize();
                    if (routeSlice.geometry.coordinates.length > 1 && !bounds.isEmpty()) {
                        intersectionPreviewMap.fitBounds(bounds, {
                            padding: 25, maxZoom: 19, bearing: segmentBearing, pitch: 50, animate: false
                        });
                    } else {
                        intersectionPreviewMap.flyTo({
                            center: step.maneuver.location, zoom: 18,
                            bearing: segmentBearing, pitch: 50, animate: false
                        });
                    }
                    
                    intersectionPreviewMap.once('idle', () => {
                        if (previewWindow) previewWindow.classList.remove('rendering');
                    });
                }
            });
        });
        
        if (timerDurationMs && timerDurationMs > 0) {
            intersectionPreviewTimer = setTimeout(hideIntersectionPreviewMap, timerDurationMs);
        }
    } catch (error) {
        console.error("Error al mostrar el minimapa de intersección:", error);
        hideIntersectionPreviewMap();
    }
}

// ===================================================================
// NOMBRE: hideIntersectionPreviewMap (VERSIÓN FINAL)
function hideIntersectionPreviewMap() {
    const card = document.getElementById('intersection-preview-map-window');
    if (card) {
        card.classList.add('hidden');
    }
    if (intersectionPreviewTimer) {
        clearTimeout(intersectionPreviewTimer);
        intersectionPreviewTimer = null;
    }
    if (intersectionPreviewMap) {
        try {
            intersectionPreviewMap.remove();
        } catch(e) {}
        intersectionPreviewMap = null;
    }
}

    
// ===================================================================
// NOMBRE: showAllReminders 
// RESUMEN: Muestra la tabla y marca la caché como sucia si se cambia el filtro de excluidos.
function showAllReminders(options = {}) {
     const mapWasOpenBeforeThisTable = isNavigationMapActive;
     if (mapWasOpenBeforeThisTable) {
         sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
         sessionStorage.setItem('mapContext', 'navigation');
     } else {
         sessionStorage.removeItem('boardinggate_map_was_open_before_table');
         sessionStorage.removeItem('mapContext');
     }
     closeOtherModals();
     let allReminders = []; try { allReminders = JSON.parse(localStorage.getItem('reminders') || '[]').map(r => ({ ...r })); } catch(e) { showToast("Error al cargar lista de recordatorios.", "error"); return; }
     const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false; let remindersToDisplay = allReminders;
     if (!showExcluded) { remindersToDisplay = allReminders.filter(r => !r.excludeFromList); }
     remindersToDisplay.sort((a, b) => {
         const nowForSort = new Date(); const nextA = calculateNextOccurrence(a, nowForSort); const nextB = calculateNextOccurrence(b, nowForSort);
         if (nextA && nextB) { const timeDiff = nextA.getTime() - nextB.getTime(); if (timeDiff !== 0) return timeDiff; } else if (nextA) { return -1; } else if (nextB) { return 1; }
         const typeOrder = { 'simple': 1, 'hourly': 2, 'daily': 3, 'weekly': 4, 'interval': 5 }; const typeDiff = (typeOrder[a.type] ?? 99) - (typeOrder[b.type] ?? 99); if (typeDiff !== 0) return typeDiff;
         const createdAtA = a.createdAt ? new Date(a.createdAt).getTime() : 0; const createdAtB = b.createdAt ? new Date(b.createdAt).getTime() : 0; return createdAtA - createdAtB;
     });
     const existingModal = document.querySelector('.reminder-table-modal');
     if (existingModal) { if (existingModal.autoCloseInterval) clearInterval(existingModal.autoCloseInterval); if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal); }
     const modalTable = document.createElement('div');
     modalTable.className = 'reminder-table-modal';
     modalTable.setAttribute('aria-label', 'Tabla recordatorios');
     modalTable.innerHTML = `
        <div class="reminder-table-header">
            <div class="reminder-table-top-controls">
                <div style="display: flex; align-items: center;">
                    <input type="checkbox" id="show-excluded-reminders" ${showExcluded ? 'checked' : ''} style="transform: scale(1.3);">
                    <label for="show-excluded-reminders" style="margin-left: 0.5rem; font-size: 1.1rem;">MOSTRAR RADARES u OTROS</label>
                </div>
                <div style="display: flex; align-items: center;">
                    <button type="button" id="view-all-locations-map">VER UBICACIONES</button>
                    <button type="button" id="close-reminders-top" style="margin-left:10px;">SALIR <span class="button-countdown"></span></button>
                </div>
            </div>
            <h2>Recordatorios</h2>
        </div>
        <div class="reminder-table-body-container">
            <table>
                <thead>
                    <tr>
                        <th style="width:12%;">Acciones</th> <th>Texto</th> <th style="width:8%;">Hora</th>
                        <th style="width:10%;">Fecha Prox.</th> <th style="width:15%;">Días Rep.</th>
                        <th style="width:8%;">Cada x días</th> <th style="width:8%;">Geoloc.</th>
                        <th style="width:10%;">Creado</th>
                    </tr>
                </thead>
                <tbody id="reminder-table-body">
                    ${remindersToDisplay.length === 0 ? `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios ${showExcluded ? ' (incluyendo excluidos)' : ''}.</td></tr>` : remindersToDisplay.map(r => { 
                        const isRadarOrExcluded = r.excludeFromList || r.text.toUpperCase().includes("RADAR");
                        const rowBackgroundColor = isRadarOrExcluded ? 'rgba(52, 199, 89, 0.15)' : 'rgba(88, 86, 214, 0.15)';
                        const nextOccurrenceDate = calculateNextOccurrence(r, new Date()); 
                        const formattedNextDate = nextOccurrenceDate ? formatDateToDDMMMYY(nextOccurrenceDate.toISOString().split('T')[0]) : formatDateToDDMMMYY(r.date); 
                        const timeDisplay = r.time ? r.time : '-'; 
                        const geoIndicator = r.isLocationEnabled ? '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#34c759" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>' : '-'; 
                        const isCyclic = r.type === 'weekly' || r.type === 'interval';
                        const cyclicStyle = isCyclic ? 'style="color: #ffd700; font-weight: bold;"' : '';
                        return `<tr data-id="${r.id}" style="background-color: ${rowBackgroundColor};"> <td> <button class="visto-prox" data-id="${r.id}" title="${isCyclic ? 'Marcar Visto y Avanzar al Próximo Ciclo' : 'Marcar Visto y Borrar'}">Visto/Prox</button> <button class="postpone" data-id="${r.id}" title="Posponer">Posponer</button> ${isCyclic ? `<button class="cancel-cyclic-table" data-id="${r.id}" title="Anular Ciclo Permanente">Anular Ciclo</button>` : ''} </td> <td class="text-column" title="Modificar">${r.text}</td> <td class="time-column">${timeDisplay}</td> <td class="date-column">${formattedNextDate}</td> <td ${cyclicStyle}>${r.type === 'weekly' && r.repeatDays?.length > 0 ? r.repeatDays.map(d => ['Dom','Lun','Mar','Mié','Jue','Vie','Sáb'][d]).join(', ') : '-'}</td> <td ${cyclicStyle}>${r.type === 'interval' ? r.intervalDays || '-' : '-'}</td> <td>${geoIndicator}</td> <td class="date-column">${r.createdAt ? formatDateToDDMMMYY(r.createdAt.split('T')[0]) : '-'}</td> </tr>`; 
                    }).join('')}
                    </tbody>
                </table>
        </div>
        <div class="bottom-button-container" style="display:none;">
            <button type="button" id="close-reminders-bottom">SALIR <span class="button-countdown-timer unified-countdown-style"></span></button>
        </div>
        `;
         const parent = document.body;
         parent.appendChild(modalTable);
         const showExcludedCheckbox = modalTable.querySelector('#show-excluded-reminders');
         if (showExcludedCheckbox) { 
             showExcludedCheckbox.addEventListener('change', () => { 
                 localStorage.setItem(SHOW_EXCLUDED_REMINDERS_KEY, JSON.stringify(showExcludedCheckbox.checked)); 
                 markCacheAsDirty();
                 if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval); 
                 modalTable.remove(); 
                 showAllReminders(); 
            }); 
        }
         const viewLocationsMapButton = modalTable.querySelector('#view-all-locations-map');
         if (viewLocationsMapButton) {
            viewLocationsMapButton.addEventListener('click', () => {
                if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                if (modalTable.parentNode) modalTable.remove();
                setTimeout(() => {
                    openLocationsPreviewMap();
                }, 50);
            });
        }
         let count = 60; const countdownSpans = modalTable.querySelectorAll('.button-countdown'); countdownSpans.forEach(span => span.textContent = `${count}`);
         const closeClean = () => { clearInterval(modalTable.autoCloseInterval); modalTable.autoCloseInterval = null; if (modalTable.parentNode) modalTable.parentNode.removeChild(modalTable);
             const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true'; sessionStorage.removeItem('boardinggate_map_was_open_before_table');
             const mapContext = sessionStorage.getItem('mapContext'); sessionStorage.removeItem('mapContext');
             if (fromReminderModal) { fromReminderModal = false; if (mapShouldReopen) { sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true'); sessionStorage.setItem('mapContext', mapContext); } showReminderModal(); }
             else if (mapShouldReopen) { if (mapContext === 'navigation') openNavigationMap(); }
         };
         modalTable.autoCloseInterval = setInterval(() => { count--; countdownSpans.forEach(span => span.textContent = `(${count})`); if (count <= 0) { closeClean(); } }, 1000);
         const resetTimer = () => { if (!modalTable.autoCloseInterval) return; clearInterval(modalTable.autoCloseInterval); count = 60; countdownSpans.forEach(span => span.textContent = `${count}`); modalTable.autoCloseInterval = setInterval(() => { count--; countdownSpans.forEach(span => span.textContent = `${count}`); if (count <= 0) { closeClean(); } }, 1000); };
         modalTable.addEventListener('click', resetTimer); modalTable.addEventListener('touchstart', resetTimer, { passive: true }); modalTable.addEventListener('input', resetTimer);
         modalTable.querySelector('#close-reminders-top').addEventListener('click', closeClean);
         modalTable.querySelector('#close-reminders-bottom').addEventListener('click', closeClean);
         setupReminderTableListeners(modalTable);
}

// ===================================================================
// NOMBRE: setupReminderTableListeners 
// RESUMEN: Añade listeners y marca la caché como sucia en cada modificación.
function setupReminderTableListeners(modalTable) {
        modalTable.querySelectorAll('.visto-prox').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#EF4444';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #B91C1C';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true);
                let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderIndex = rems.findIndex(r => r.id === id);
                let needsSave = false;
                const row = newButton.closest('tr');
                if (reminderIndex > -1 && row) {
                     const currentReminder = rems[reminderIndex];
                     if (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval')) {
                        const { newDateISO, newTime } = calculatePostponedDateTime(15);
                        rems[reminderIndex].date = newDateISO;
                        rems[reminderIndex].time = newTime;
                        rems[reminderIndex].managedByUser = false;
                        needsSave = true;
                        const dateCell = row.cells[3]; const timeCell = row.cells[2];
                        if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date);
                        if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                        showToast('Recordatorio con ubicación pospuesto 15 min', 'info');
                    } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                         let referenceDateForNext = new Date();
                         try {
                             const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                             const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                             const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                             if (!isNaN(reminderDateTime.getTime())) {
                                 referenceDateForNext = new Date(reminderDateTime.getTime() + 60000);
                             }
                         } catch(er) { }
                        const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                        if (nextOcc) {
                            rems[reminderIndex].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                            rems[reminderIndex].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                            rems[reminderIndex].managedByUser = false;
                            needsSave = true;
                            const dateCell = row.cells[3]; const timeCell = row.cells[2];
                            if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date);
                            if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                            showToast('Actualizado al próximo periodo', 'info');
                        } else {
                            rems.splice(reminderIndex, 1); needsSave = true;
                            row.remove(); showToast('Error calculando siguiente ciclo. Eliminado.', 'error');
                        }
                    } else {
                        rems.splice(reminderIndex, 1); needsSave = true;
                        row.remove(); showToast('Recordatorio borrado', 'info');
                    }
                    if (needsSave) {
                        localStorage.setItem('reminders', JSON.stringify(rems)); 
                        markCacheAsDirty();
                        if (isNavigationMapActive) { plotRemindersOnNavigationMap(); } // <-- CORRECCIÓN
                    }
                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios.</td></tr>`;
                    }
                } else {
                    showToast('Error: Recordatorio no encontrado para actualizar/borrar.', 'error');
                    if(row) row.remove();
                }
                updateReminderCount(); updateButtonStyles(); markCacheAsDirty();
            });
        });
        modalTable.querySelectorAll('.postpone').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#F59E0B';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #B45309';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true);
                const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderToPostpone = reminders.find(r => r.id === id);
                if (reminderToPostpone) {
                    if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                    modalTable.remove();
                    showPostponeOptionsModal(reminderToPostpone, 'table');
                } else {
                    showToast('Error: Recordatorio no encontrado para posponer.', 'error');
                    markReminderAsManaged(id, false);
                }
            });
        });
        modalTable.querySelectorAll('.cancel-cyclic-table').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#8B0000';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #580000';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                if (confirm('¿Estás seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE?')) {
                    markReminderAsManaged(id, true);
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const initialLength = rems.length;
                    rems = rems.filter(r => r.id !== id);
                    if (rems.length < initialLength) {
                       localStorage.setItem('reminders', JSON.stringify(rems)); 
                       markCacheAsDirty();
                       if (isNavigationMapActive) { plotRemindersOnNavigationMap(); } // <-- CORRECCIÓN
                       showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                    } else {
                        showToast('Error: No se encontró el ciclo para anular', 'warning');
                    }
                    const row = newButton.closest('tr');
                    if (row) row.remove();
                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios.</td></tr>`;
                    }
                    updateReminderCount(); updateButtonStyles();
                }
            });
        });
        const tableBody = modalTable.querySelector('#reminder-table-body');
        if (tableBody) {
            const newTableBody = tableBody.cloneNode(false);
            while(tableBody.firstChild) newTableBody.appendChild(tableBody.firstChild);
            tableBody.parentNode.replaceChild(newTableBody, tableBody);
            newTableBody.addEventListener('click', (e) => {
                if (e.target.closest('td:first-child button')) return;
               const row = e.target.closest('tr[data-id]');
                if (row?.dataset.id) {
                    const id = parseInt(row.dataset.id); if (isNaN(id)) return;
                    markReminderAsManaged(id, true);
                    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const reminderToModify = reminders.find(r => r.id === id);
                    if (reminderToModify) {
                        const mapWasOpenBeforeTable = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                        const mapContextBeforeTable = sessionStorage.getItem('mapContext');
                        if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                        modalTable.remove();
                        if (mapWasOpenBeforeTable) {
                            sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                            if (mapContextBeforeTable) {
                                sessionStorage.setItem('mapContext', mapContextBeforeTable);
                            }
                        }
                        sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                        showReminderModal(reminderToModify);
                    } else {
                        showToast('Error: Recordatorio no encontrado para modificar', 'error');
                        markReminderAsManaged(id, false);
                    }
                }
            });
        }
}

// ===================================================================
// NOMBRE: showReminderModal 
// RESUMEN: Muestra el modal de edición/creación y marca la caché como sucia al guardar/borrar.
function showReminderModal(reminder = null, options = {}) {
    const mapShouldReopenAfterForm = sessionStorage.getItem('boardinggate_map_should_reopen_after_form') === 'true';
    const mapContextBeforeThisModal = sessionStorage.getItem('mapContext');
    closeOtherModals();
    let autoSaveInterval = null; let parseTimeout = null; let restartTimeout = null; let focusTimeout = null; let countdownSave = 25; let manualTimeInput = false; let lastInputWasSpeech = false;
    let currentReminderLocation = null;
    let locationEnabledByUser = false;
    let mapExpandedManually = false;
    let mapMoveDebounceTimer = null;

    function cleanUpModalTimers(clearAll = true) {
        if (autoSaveInterval) { clearInterval(autoSaveInterval); autoSaveInterval = null; }
        if (clearAll) {
            if (parseTimeout) clearTimeout(parseTimeout);
            if (restartTimeout) clearTimeout(restartTimeout);
            if (focusTimeout) clearTimeout(focusTimeout);
            parseTimeout = null; restartTimeout = null; focusTimeout = null;
        }
    }

    const existingModal = document.querySelector('.reminder-modal');
    if (existingModal) {
        if (typeof existingModal.cleanUpModalTimers === 'function') existingModal.cleanUpModalTimers(true);
        if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal);
    }
    
    let isNew = true;
    let parsed = {
         id: null, text: '', time: null, date: null, repeatDays: [], intervalDays: null, type: 'simple',
         createdAt: new Date().toISOString(), managedByUser: false,
         isLocationEnabled: false, locationCoordinates: null, radiusMeters: DEFAULT_LOCATION_RADIUS,
         excludeFromList: false
    };
    if (reminder && typeof reminder.id === 'number' && reminder.id !== null) {
        const remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
        const foundReminder = remindersFromStorage.find(r => r.id === reminder.id);
        if (foundReminder) {
            parsed = { ...foundReminder };
            isNew = false;
        } else {
            parsed = { ...reminder, id: null, createdAt: new Date().toISOString(), managedByUser: false };
            isNew = true;
            if(reminder.text && reminder.text.toUpperCase().includes("RADAR RUTA:")) {
                 parsed.text = reminder.text.replace("RADAR RUTA:", "RADAR:");
                 parsed.excludeFromList = true;
                 parsed.radiusMeters = 350;
            }
        }
    } else if (reminder) {
        parsed = { ...reminder, id: null, createdAt: new Date().toISOString(), managedByUser: false };
        isNew = true;
         if(reminder.text && reminder.text.toUpperCase().includes("RADAR RUTA:")) {
            parsed.text = reminder.text.replace("RADAR RUTA:", "RADAR:");
            parsed.excludeFromList = true;
            parsed.radiusMeters = 350;
        }
    }
    if (!isNew && !parsed.createdAt) { parsed.createdAt = new Date(0).toISOString(); }
    locationEnabledByUser = parsed.isLocationEnabled;
    currentReminderLocation = parsed.locationCoordinates;
    let fmtDate = '';
    if (parsed.date?.match(/^\d{4}-\d{2}-\d{2}$/)) {
        try {
            const [y,m,d] = parsed.date.split('-');
            const dt=new Date(Date.UTC(y,m-1,d));
            if(!isNaN(dt.getTime())&&dt.getUTCDate()==d&&dt.getUTCMonth()==m-1) {
                fmtDate=`${d.toString().padStart(2,'0')}/${m.toString().padStart(2,'0')}/${y}`;
            }
        } catch(e){}
    }
    const modal = document.createElement('div');
    modal.className = 'reminder-modal';
    modal.setAttribute('aria-label','Formulario recordatorio');
    const titleText = isNew ? 'NUEVO RECORDATORIO' : 'MODIFICAR RECORDATORIO';
    modal.innerHTML = `
        <div class="reminder-modal-header">
            <h2 class="reminder-modal-title">${titleText}</h2>
             <div class="header-options">
                <label for="reminder-exclude-from-list" class="form-label-exclude">
                    <input type="checkbox" id="reminder-exclude-from-list" ${parsed.excludeFromList ? 'checked' : ''}>
                    <span>No listar (Radares, etc.)</span>
                </label>
            </div>
        </div>

        <div class="reminder-modal-body">
            <form id="reminder-form" class="reminder-modal-form">
                
                <div class="form-section">
                    <div class="input-with-buttons">
                        <div class="button-and-status-wrapper">
                            <button type="button" id="clear-fields" class="clear-button" title="Limpiar todo el formulario">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                            </button>
                            <p id="speech-status" class="speech-status"></p>
                            <p id="parse-status" class="parse-status"></p>
                        </div>
                        <textarea id="reminder-text" rows="2" required placeholder="Escriba o dicte aquí...">${parsed.text.replace(/<b>|<\/b>/gi,'')}</textarea>
                    </div>
                </div>
                
                <div class="form-section controls-grid">
                    <div class="control-item">
                        <label for="reminder-time" class="form-label">Hora:</label>
                        <input type="text" id="reminder-time" placeholder="HH:MM" pattern="\\d{2}:\\d{2}" value="${parsed.time||''}">
                    </div>
                    <div class="control-item">
                        <label for="reminder-date" class="form-label">Fecha:</label>
                        <input type="text" id="reminder-date" placeholder="DD/MM/AAAA" pattern="\\d{2}/\\d{2}/\\d{4}" value="${fmtDate}">
                    </div>
                    <div class="control-item">
                        <label for="reminder-interval" class="form-label">Int.(días):</label>
                        <input type="number" id="reminder-interval" min="1" max="9999" value="${parsed.intervalDays||''}">
                    </div>
                     <div class="control-item days-group-grid-item">
                         <label class="form-label">Días Repet.:</label>
                         <div class="days-checkbox-container">
                            ${['Lun','Mar','Mié','Jue','Vie','Sáb','Dom'].map((d,i)=>`<label><input type="checkbox" name="repeat" value="${(i+1)%7}" ${parsed.repeatDays?.includes((i+1)%7)?'checked':''}><span>${d}</span></label>`).join('')}
                         </div>
                    </div>
                </div>

                <div class="form-section location-section">
                    <div class="location-header">
                        <label for="location-enabled" class="form-label-location">
                             <input type="checkbox" id="location-enabled" ${parsed.isLocationEnabled ? 'checked' : ''}>
                             <span>RECORDATORIO POR UBICACIÓN</span>
                        </label>
                         <div id="radius-slider-group" class="radius-slider-group">
                             <div class="radius-control-wrapper">
                                <button type="button" class="slider-btn minus" id="radius-minus-btn">-</button>
                                <button type="button" class="slider-btn plus" id="radius-plus-btn">+</button>
                                <label id="radius-range-label" class="form-label">Radio: ${parsed.radiusMeters || 350}m</label>
                             </div>
                             <div class="slider-container single-slider-container">
                                 <div class="slider-track"></div>
                                 <div class="slider-range" id="radius-slider-range"></div>
                                 <div class="slider-thumb" id="radius-thumb"></div>
                             </div>
                         </div>
                        <button type="button" id="expand-map-button" class="expand-map-button">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
                            <span>MAPA</span>
                        </button>
                    </div>
                    <div id="location-controls-container" style="display: ${parsed.isLocationEnabled ? 'block' : 'none'};">
                         <div id="location-map-container" class="location-map-container">
                            <button type="button" id="reduce-map-button" class="hidden">REDUCIR</button>
                            <button type="button" id="locate-me-button" class="hidden">ESTÁS AQUÍ</button>
                         </div>
                    </div>
                </div>
            </form>
        </div>

        <div class="reminder-modal-footer">
            <button type="submit" id="save-reminder" class="action-button primary">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13H7v8"></polyline><polyline points="7 3 7 8h10"></polyline></svg>
                <span>ACEPTAR</span>
                <span id="countdown-save" class="unified-countdown-style">${countdownSave}</span>
            </button>
             <button type="button" id="cancel-reminder" class="action-button secondary">Cancelar</button>
             <button type="button" id="delete-reminder" title="Borrar este recordatorio permanentemente" class="action-button danger">Borrar</button>
             <button type="button" id="view-reminders" class="action-button secondary">Ver Lista</button>
             <button type="button" id="manage-saved-locations" class="action-button secondary">Ubicaciones</button>
             <button type="button" id="help-reminder" class="action-button secondary">Ayuda</button>
        </div>
    `;
    
    if (options.onTopOfMap) {
        const mapContainerEl = document.getElementById('reminders-location-map-modal');
        if (mapContainerEl) mapContainerEl.appendChild(modal);
        else document.body.appendChild(modal);
    } else {
        document.body.appendChild(modal);
    }

    modal.cleanUpModalTimers = cleanUpModalTimers;
    
    const mapContainer = modal.querySelector('#location-map-container');
    const reduceMapButton = modal.querySelector('#reduce-map-button');
    const locateMeButton = modal.querySelector('#locate-me-button');
    const expandMapButton = modal.querySelector('#expand-map-button');
    const locationCheckbox = modal.querySelector('#location-enabled');

    function destroyMap() {
        if (reminderModalMap) {
            try { reminderModalMap.remove(); } catch(e) {}
            reminderModalMap = null;
            reminderMarker = null;
        }
        if (mapContainer) {
            mapContainer.style.display = 'none';
            mapContainer.classList.remove('preview', 'expanded');
            const mapDiv = mapContainer.querySelector('#reminder-modal-map-div');
            if (mapDiv) mapDiv.remove();
        }
        if (reduceMapButton) reduceMapButton.classList.add('hidden');
        if (locateMeButton) locateMeButton.classList.add('hidden');
        if (expandMapButton) expandMapButton.style.display = 'block';
    }

    function initializeOrUpdateMap(centerCoords, radius, isInteractive = false) {
        destroyMap(); 

        const effectiveLocationEnabled = locationCheckbox.checked;
        const showMap = effectiveLocationEnabled || isInteractive;
        if (!showMap) return;

        mapContainer.style.display = 'block';
        mapContainer.classList.toggle('preview', !isInteractive && effectiveLocationEnabled && centerCoords);
        mapContainer.classList.toggle('expanded', isInteractive && effectiveLocationEnabled);
        
        expandMapButton.style.display = (isInteractive && effectiveLocationEnabled) ? 'none' : 'block';
        
        const effectiveCoords = centerCoords || { latitude: 40.416775, longitude: -3.703790 };
        const effectiveRadius = parseInt(radius) || DEFAULT_LOCATION_RADIUS;
        const zoomLevel = isInteractive ? 13 : 11;

        const mapDiv = document.createElement('div');
        mapDiv.id = 'reminder-modal-map-div';
        mapDiv.style.width = '100%'; mapDiv.style.height = '100%';
        mapContainer.insertBefore(mapDiv, reduceMapButton);

        reminderModalMap = new mapboxgl.Map({
            container: mapDiv,
            style: 'mapbox://styles/mapbox/satellite-streets-v12',
            center: [effectiveCoords.longitude, effectiveCoords.latitude],
            zoom: zoomLevel,
            interactive: isInteractive && effectiveLocationEnabled
        });
        
        reminderModalMap.on('load', () => {
            updateMarkerAndCircle(effectiveCoords, effectiveRadius);
            
            reminderModalMap.on('click', handleMapClick);
            
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    if (reminderModalMap) {
                        try { reminderModalMap.resize(); } catch (e) {}
                    }
                });
            });
        });
        
        if (reduceMapButton) reduceMapButton.classList.toggle('hidden', !(isInteractive && effectiveLocationEnabled));
        if (locateMeButton) locateMeButton.classList.toggle('hidden', !(isInteractive && effectiveLocationEnabled));
    }
    const parseStatus = modal.querySelector('#parse-status');
    const speechStatus = modal.querySelector('#speech-status');
    let countdownSaveElement = modal.querySelector('#countdown-save');
    const textInput = modal.querySelector('#reminder-text');
    const timeInput = modal.querySelector('#reminder-time');
    const dateInput = modal.querySelector('#reminder-date');
    const intervalInput = modal.querySelector('#reminder-interval');
    const saveButton = modal.querySelector('#save-reminder');
    const clearButton = modal.querySelector('#clear-fields');
    const locationControlsContainer = modal.querySelector('#location-controls-container');
    const manageLocationsBtn = modal.querySelector('#manage-saved-locations');
    const excludeFromListCheckbox = modal.querySelector('#reminder-exclude-from-list');
    const deleteButton = modal.querySelector('#delete-reminder');
    
    const radiusSliderGroup = modal.querySelector('#radius-slider-group');

    function toggleLocationControlsVisibility() {
        const isChecked = locationCheckbox.checked;
        if (locationControlsContainer) {
            locationControlsContainer.style.display = isChecked ? 'block' : 'none';
        }
        if (radiusSliderGroup) {
            radiusSliderGroup.style.display = isChecked ? 'flex' : 'none';
        }
        if(!isChecked) {
           destroyMap();
        }
    }
    
    locationCheckbox.addEventListener('change', toggleLocationControlsVisibility);
    toggleLocationControlsVisibility();

    const radiusSliderContainer = modal.querySelector('#radius-thumb')?.parentElement;
    const radiusThumb = modal.querySelector('#radius-thumb');
    const radiusRange = modal.querySelector('#radius-slider-range');
    const radiusLabel = modal.querySelector('#radius-range-label');
    const minRadius = 1;
    const maxRadius = 5000;
    let currentRadius = parsed.radiusMeters || 350;
    
    const radiusMinusBtn = modal.querySelector('#radius-minus-btn');
    const radiusPlusBtn = modal.querySelector('#radius-plus-btn');

    const adjustRadius = (direction) => {
        let step;
        if (currentRadius < 100) step = 5; 
        else if (currentRadius < 500) step = 25; 
        else step = 100;

        if (direction === 'plus') {
            currentRadius += step;
        } else {
            currentRadius -= step;
        }

        currentRadius = Math.max(minRadius, Math.min(maxRadius, currentRadius));
        updateRadiusVisuals();
        if (reminderModalMap && currentReminderLocation) {
            updateMarkerAndCircle(currentReminderLocation, Math.round(currentRadius));
        }
        resetAndStartCountdown();
    };

    if (radiusPlusBtn) radiusPlusBtn.addEventListener('click', () => adjustRadius('plus'));
    if (radiusMinusBtn) radiusMinusBtn.addEventListener('click', () => adjustRadius('minus'));


    const updateRadiusVisuals = () => {
        if (!radiusThumb || !radiusRange || !radiusLabel) return;
        const minLog = Math.log(minRadius);
        const maxLog = Math.log(maxRadius);
        const percent = (Math.log(currentRadius) - minLog) / (maxLog - minLog);
        
        radiusThumb.style.left = `${percent * 100}%`;
        radiusRange.style.width = `${percent * 100}%`;
        radiusLabel.textContent = `Radio: ${Math.round(currentRadius)}m`;
    };

    if (radiusSliderContainer && radiusThumb) {
        const onRadiusDrag = (e) => {
            const rect = radiusSliderContainer.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let percent = ((clientX - rect.left) / rect.width);
            percent = Math.max(0, Math.min(1, percent));
            const minLog = Math.log(minRadius);
            const maxLog = Math.log(maxRadius);
            let rawRadius = Math.exp(minLog + percent * (maxLog - minLog));
            let step;
            if (rawRadius < 100) step = 5; 
            else if (rawRadius < 500) step = 25; 
            else step = 100;
            currentRadius = Math.round(rawRadius / step) * step;
            currentRadius = Math.max(minRadius, Math.min(maxRadius, currentRadius));
            updateRadiusVisuals();
            if (reminderModalMap && currentReminderLocation) {
                 updateMarkerAndCircle(currentReminderLocation, Math.round(currentRadius));
            }
            resetAndStartCountdown();
        };
        const startRadiusDrag = (e) => {
            const moveHandler = (moveEvent) => onRadiusDrag(moveEvent);
            const endDrag = () => {
                document.removeEventListener('mousemove', moveHandler);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchmove', moveHandler);
                document.removeEventListener('touchend', endDrag);
            };
            document.addEventListener('mousemove', moveHandler);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchmove', moveHandler);
            document.addEventListener('touchend', endDrag);
        };
        radiusThumb.addEventListener('mousedown', startRadiusDrag);
        radiusThumb.addEventListener('touchstart', startRadiusDrag);
        updateRadiusVisuals();
    }
    
    function handleMapClick(e) {
        const lngLat = e.lngLat;
        currentReminderLocation = { latitude: lngLat.lat, longitude: lngLat.lng };
        updateMarkerAndCircle(currentReminderLocation, Math.round(currentRadius));
        resetAndStartCountdown();
    }
    
    function updateMarkerAndCircle(coords, radius) {
        if (!reminderModalMap || !coords) return;
        const lngLat = [coords.longitude, coords.latitude];
        
        if (!reminderMarker) {
            const vehicleEl = document.createElement('div');
            vehicleEl.innerHTML = `<div style="width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;"><img src="PNG/AVANCE.PNG" style="width: 100%; height: 100%; object-fit: contain;"></div>`;
            reminderMarker = new mapboxgl.Marker({ element: vehicleEl, draggable: true })
                .setLngLat(lngLat)
                .addTo(reminderModalMap);
            reminderMarker.on('dragend', handleMarkerDragEnd);
        } else {
            reminderMarker.setLngLat(lngLat);
        }
        
        const circleId = 'reminder-circle';
        const circlePolygon = turf.circle(lngLat, radius, { steps: 64, units: 'meters' });

        if (reminderModalMap.getSource(circleId)) {
            reminderModalMap.getSource(circleId).setData(circlePolygon);
        } else {
            reminderModalMap.addSource(circleId, { 'type': 'geojson', 'data': circlePolygon });
            
            const isRadarType = textInput.value.toUpperCase().includes("RADAR") || excludeFromListCheckbox.checked;
            
            const circleFillColor = isRadarType ? 'rgba(255, 255, 0, 0.3)' : 'rgba(37, 99, 235, 0.3)';
            const circleStrokeColor = isRadarType ? '#FFD700' : '#2563EB';

            reminderModalMap.addLayer({
                'id': circleId,
                'type': 'fill',
                'source': circleId,
                'paint': {
                    'fill-color': circleFillColor,
                    'fill-outline-color': circleStrokeColor
                }
            });
        }
    }
    
    function handleMarkerDragEnd(event) {
        const lngLat = event.target.getLngLat();
        currentReminderLocation = { latitude: lngLat.lat, longitude: lngLat.lng };
        updateMarkerAndCircle(currentReminderLocation, Math.round(currentRadius));
        resetAndStartCountdown();
    }
    
    function handleLocationCheckboxChange() {
        const wasEnabled = locationEnabledByUser;
        locationEnabledByUser = locationCheckbox.checked;
        if (locationEnabledByUser) {
            if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && currentReminderLocation) {
                initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false);
            } else if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && !currentReminderLocation) {
                destroyMap();
            }
             if (!currentReminderLocation && !wasEnabled) {
                getCurrentLocation( (coords) => { currentReminderLocation = coords; if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && currentReminderLocation) { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false); } });
            }
        } else {
            destroyMap();
        }
        resetAndStartCountdown();
    }
    
    if (deleteButton) {
        deleteButton.addEventListener('click', () => {
            cleanUpModalTimers(true);
            const mapShouldReopen = mapShouldReopenAfterForm;
            const mapContextToReopen = mapContextBeforeThisModal;
            
            if (!isNew) {
                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const initialLength = reminders.length;
                reminders = reminders.filter(r => r.id !== parsed.id);
                if (reminders.length < initialLength) {
                    localStorage.setItem('reminders', JSON.stringify(reminders));
                    markCacheAsDirty();
                    if (isNavigationMapActive) {
                        plotRemindersOnNavigationMap();
                    }
                } else { 
                    showToast('Recordatorio no encontrado para borrar.', 'warning');
                }
            }

            destroyMap();
            if (modal.parentNode) modal.parentNode.removeChild(modal);
            updateReminderCount(); 
            updateButtonStyles(); 
            

            if (mapShouldReopen && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !isNavigationMapActive) {
                if (mapContextToReopen === 'navigation') openNavigationMap();
            } else if (mapShouldReopen) {
                 sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
                 if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen);
            }
            sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
        });
    }

    if (manageLocationsBtn) {
        manageLocationsBtn.addEventListener('click', () => {
            showSavedLocationsModal( () => { }, (selectedLocationData) => {
                    if (selectedLocationData && typeof selectedLocationData.lat === 'number' && typeof selectedLocationData.lng === 'number') {
                        currentReminderLocation = { latitude: selectedLocationData.lat, longitude: selectedLocationData.lng };
                        locationCheckbox.checked = true; locationEnabledByUser = true;
                        toggleLocationControlsVisibility();
                        currentRadius = typeof selectedLocationData.radius === 'number' && selectedLocationData.radius > 0 ? selectedLocationData.radius : DEFAULT_LOCATION_RADIUS;
                        updateRadiusVisuals();
                        if (mapContainer.classList.contains('expanded')) { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), true); } 
                        else { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false); }
                        showToast(`Ubicación "${selectedLocationData.name || 'Seleccionada'}" aplicada.`, "success");
                        resetAndStartCountdown();
                    } else { showToast("Error: Datos de ubicación seleccionada no válidos.", "error"); }
                }, { parentContainer: modal } 
            );
        });
    }

    locationCheckbox.addEventListener('change', handleLocationCheckboxChange);
    if (parsed.isLocationEnabled && parsed.locationCoordinates) { initializeOrUpdateMap(parsed.locationCoordinates, parsed.radiusMeters, false); } 
    else if (parsed.isLocationEnabled && !parsed.locationCoordinates) { destroyMap(); } 
    else { destroyMap(); }

    if (expandMapButton) {
        expandMapButton.addEventListener('click', () => {
            if (!locationCheckbox.checked) { locationCheckbox.checked = true; toggleLocationControlsVisibility(); }
            locationEnabledByUser = true; mapExpandedManually = true;
            if (!currentReminderLocation) {
                locateMeButton.disabled = true; locateMeButton.textContent = 'Buscando...';
                getCurrentLocation(
                    (gpsCoords) => {
                        currentReminderLocation = { latitude: gpsCoords.latitude, longitude: gpsCoords.longitude };
                        initializeOrUpdateMap(gpsCoords, Math.round(currentRadius), true);
                        if (reminderModalMap) { reminderModalMap.flyTo({ zoom: 16 }); }
                        locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ';
                    }, (errorMsg) => {
                        initializeOrUpdateMap(null, Math.round(currentRadius), true);
                        if (reminderModalMap) { reminderModalMap.flyTo({ zoom: 6 }); }
                        showToast(`Error GPS: ${errorMsg}. Mapa centrado por defecto`, "warning", 3000);
                        locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ';
                    }
                );
            } else { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), true); }
            resetAndStartCountdown();
            setTimeout(() => { mapExpandedManually = false; }, 100);
        });
    }

    if (reduceMapButton) { reduceMapButton.addEventListener('click', () => { if (locationEnabledByUser && currentReminderLocation) { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false); } else { destroyMap(); } resetAndStartCountdown(); }); }
    if (locateMeButton) {
        locateMeButton.addEventListener('click', () => {
             if (!reminderModalMap || !mapContainer.classList.contains('expanded')) return;
             resetAndStartCountdown(); locateMeButton.disabled = true; locateMeButton.textContent = 'Buscando...';
             getCurrentLocation(
                 (coords) => {
                     currentReminderLocation = { latitude: coords.latitude, longitude: coords.longitude };
                     if (reminderModalMap) { reminderModalMap.flyTo({center: [coords.longitude, coords.latitude], zoom: 16}); updateMarkerAndCircle(coords, Math.round(currentRadius)); }
                     locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ';
                 }, (errorMsg) => { showToast(`Error al localizar: ${errorMsg}`, 'error'); locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ'; }
             );
        });
    }

    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) { } 
    else { speechStatus.textContent = 'Dictado no soportado.'; speechStatus.style.color = '#EF4444'; }

    function startCountdown() { autoSaveInterval = setInterval(() => { if (!document.body.contains(modal)) { clearInterval(autoSaveInterval); autoSaveInterval = null; return; } countdownSave--; if (countdownSaveElement) countdownSaveElement.textContent = countdownSave; if (countdownSave === 23) { if (document.activeElement === textInput) { textInput.value += ' '; textInput.selectionStart = textInput.selectionEnd = textInput.value.length; } } if (countdownSave <= 0) { clearInterval(autoSaveInterval); autoSaveInterval = null; if (saveButton) saveButton.click(); } }, 1000); }
    function resetAndStartCountdown() { countdownSave = 25; if (countdownSaveElement) countdownSaveElement.textContent = countdownSave; if (autoSaveInterval) { clearInterval(autoSaveInterval); autoSaveInterval = null; } startCountdown(); }
    
    timeInput.addEventListener('input', (e) => {
        manualTimeInput = true;
        let v = e.target.value.replace(/\D/g, '');
        let fV = '';
        if (v.length >= 2) fV = v.slice(0, 2);
        if (v.length > 2) fV += ':' + v.slice(2, 4);
        else if (v.length < 2) fV = v;
        e.target.value = fV;
        if (fV.match(/^\d{2}:\d{2}$/)) {
            const [h, m] = fV.split(':').map(Number);
            parseStatus.textContent = (h > 23 || m > 59) ? 'Hora inválida' : '';
            parseStatus.classList.toggle('text-red-600', h > 23 || m > 59);
            parseStatus.classList.remove('text-green-600');
        } else if (fV.length > 0) {
            parseStatus.textContent = 'Formato HH:MM';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        } else {
            parseStatus.textContent = '';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        }
        resetAndStartCountdown();
    });

    dateInput.addEventListener('input', (e) => {
        let v = e.target.value.replace(/\D/g, '');
        let fV = '';
        if (v.length >= 2) fV = v.slice(0, 2);
        if (v.length > 2) fV += '/' + v.slice(2, 4);
        if (v.length > 4) fV += '/' + v.slice(4, 8);
        else if (v.length < 2) fV = v;
        e.target.value = fV;
        if (fV.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
            const [d, m, y] = fV.split('/').map(Number);
            const dt = new Date(Date.UTC(y, m - 1, d));
            const ok = !isNaN(dt.getTime()) && dt.getUTCDate() === d && dt.getUTCMonth() + 1 === m && y >= 2000 && y <= 2099;
            parseStatus.textContent = ok ? '' : 'Fecha inválida';
            parseStatus.classList.toggle('text-red-600', !ok);
            parseStatus.classList.remove('text-green-600');
        } else if (fV.length > 0) {
            parseStatus.textContent = 'Formato DD/MM/AAAA';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        } else {
            parseStatus.textContent = '';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        }
        resetAndStartCountdown();
    });

    intervalInput.addEventListener('input', resetAndStartCountdown);
    modal.querySelectorAll('input[name="repeat"]').forEach(chk => chk.addEventListener('change', resetAndStartCountdown));
    
    if (countdownSaveElement) countdownSaveElement.textContent = countdownSave;

    function startFocusCheck() {
        if (restartTimeout) clearTimeout(restartTimeout);
        restartTimeout = setTimeout(() => {
            if (document.activeElement !== textInput && document.activeElement !== timeInput && document.activeElement !== dateInput && document.activeElement !== intervalInput && !Array.from(modal.querySelectorAll('input[name="repeat"]')).includes(document.activeElement) && document.activeElement !== saveButton && document.activeElement !== modal.querySelector('#cancel-reminder') && document.activeElement !== modal.querySelector('#help-reminder') && document.activeElement !== clearButton && document.activeElement !== modal.querySelector('#view-reminders') && document.activeElement !== locationCheckbox && document.activeElement !== radiusThumb && document.activeElement !== expandMapButton && document.activeElement !== reduceMapButton && document.activeElement !== locateMeButton && !(reminderModalMap && reminderModalMap.getCanvasContainer().contains(document.activeElement))) {
                resetAndStartCountdown();
                restartTimeout = null;
            } else {
                restartTimeout = null;
            }
        }, 500);
    }

    resetAndStartCountdown();
    startFocusCheck();
    modal.addEventListener('input', resetAndStartCountdown);
    modal.addEventListener('click', resetAndStartCountdown);
    modal.addEventListener('touchstart', resetAndStartCountdown, { passive: true });
    modal.addEventListener('focusin', () => {
        resetAndStartCountdown();
        if (focusTimeout) clearTimeout(focusTimeout);
        focusTimeout = null;
    });
    modal.addEventListener('focusout', () => {
        if (!focusTimeout) {
            startFocusCheck();
        }
    });

    textInput.addEventListener('input', (e) => {
        lastInputWasSpeech = false;
        const txt = e.target.value || '';
        parseStatus.textContent = 'Analizando...';
        parseStatus.classList.remove('text-green-600', 'text-red-600');
        if (parseTimeout) clearTimeout(parseTimeout);
        parseTimeout = setTimeout(() => {
            if (!document.body.contains(modal)) return;
            try {
                const uiElements = {
                    timeInput: timeInput,
                    dateInput: dateInput,
                    intervalInput: intervalInput,
                    repeatCheckboxes: modal.querySelectorAll('input[name="repeat"]'),
                    locationCheckbox: locationCheckbox,
                    radiusInput: null,
                    manualTimeInput: manualTimeInput,
                    mapExpandedManually: mapExpandedManually,
                    excludeFromListCheckbox: excludeFromListCheckbox
                };
                if (!manualTimeInput) uiElements.timeInput.value = '';
                uiElements.dateInput.value = '';
                uiElements.intervalInput.value = '';
                uiElements.repeatCheckboxes.forEach(chk => chk.checked = false);
                const pD = parseReminderText(txt, uiElements);
                
                if(pD.radiusMeters) {
                    currentRadius = pD.radiusMeters;
                    updateRadiusVisuals();
                }

                if (isNew && (pD.type === 'weekly' || pD.type === 'interval')) {
                    const tempReminderForCalc = { type: pD.type, time: pD.time, date: pD.date, repeatDays: pD.repeatDays, intervalDays: pD.intervalDays };
                    const nowForCalc = new Date();
                    if (!tempReminderForCalc.date) tempReminderForCalc.date = `${nowForCalc.getFullYear()}-${(nowForCalc.getMonth() + 1).toString().padStart(2, '0')}-${nowForCalc.getDate().toString().padStart(2, '0')}`;
                    if (!tempReminderForCalc.time) tempReminderForCalc.time = '00:01';
                    const firstOcc = calculateNextOccurrence(tempReminderForCalc, new Date());
                    if (firstOcc) {
                        const firstOccISO = `${firstOcc.getUTCFullYear()}-${(firstOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOcc.getUTCDate().toString().padStart(2, '0')}`;
                        const firstOccTime = `${firstOcc.getUTCHours().toString().padStart(2, '0')}:${firstOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                        pD.date = firstOccISO;
                        pD.time = firstOccTime;
                        const datePartsCalc = pD.date.split('-');
                        if (datePartsCalc.length === 3) dateInput.value = `${datePartsCalc[2]}/${datePartsCalc[1]}/${datePartsCalc[0]}`;
                        if (!manualTimeInput) timeInput.value = pD.time;
                    } else {
                        if (!pD.date) { const today = new Date(); pD.date = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}-${today.getDate().toString().padStart(2, '0')}`; }
                        if (!pD.time) pD.time = '00:01';
                        const datePartsFb = pD.date.split('-');
                        if (datePartsFb.length === 3) dateInput.value = `${datePartsFb[2]}/${datePartsFb[1]}/${datePartsFb[0]}`;
                        if (!manualTimeInput) timeInput.value = pD.time;
                    }
                }
                parseStatus.textContent = 'OK';
                parseStatus.classList.add('text-green-600');
                parseStatus.classList.remove('text-red-600');
                toggleLocationControlsVisibility();
                handleLocationCheckboxChange();
            } catch (error) {
                parseStatus.textContent = `Error: ${error.message.substring(0, 100)}`;
                parseStatus.classList.add('text-red-600');
                parseStatus.classList.remove('text-green-600');
            }
            parseTimeout = null;
        }, 1000);
        resetAndStartCountdown();
    });

    saveButton.addEventListener('click', (e) => {
        e.preventDefault();
        const form = modal.querySelector('#reminder-form');
        if (form.checkValidity && !form.checkValidity()) { form.reportValidity(); return; }
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        const mapContextToReopen = mapContextBeforeThisModal;
        const text = textInput.value.trim();
        if (!text) { parseStatus.textContent = 'Texto obligatorio.'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; }
        let time = timeInput.value.trim();
        let dateStr = dateInput.value.trim();
        const repeatDays = Array.from(modal.querySelectorAll('input[name="repeat"]:checked')).map(input => parseInt(input.value));
        const intervalDays = parseInt(intervalInput.value) || null;
        const isLocationChecked = locationCheckbox.checked;
        const radius = Math.round(currentRadius);
        const locationCoords = currentReminderLocation;
        const excludeFromListVal = excludeFromListCheckbox.checked;
        if (isLocationChecked && !locationCoords) { parseStatus.textContent = 'Ubicación activada pero no fijada en el mapa.'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; }
        let dateISO = null; let finalTime = time; let reminderType = 'simple';
        if (dateStr) { if (dateStr.match(/^\d{2}\/\d{2}\/\d{4}$/)) { const [d, m, y] = dateStr.split('/').map(Number); const tD = new Date(Date.UTC(y, m - 1, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() + 1 === m && y >= 2000 && y <= 2099) { dateISO = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } else { parseStatus.textContent = 'Fecha inválida'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } } else { parseStatus.textContent = 'Formato DD/MM/AAAA'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } }
        if (finalTime && !finalTime.match(/^\d{2}:\d{2}$/)) { parseStatus.textContent = 'Formato HH:MM'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } else if (finalTime) { const [h, m] = finalTime.split(':').map(Number); if (h > 23 || m > 59) { parseStatus.textContent = 'Hora inválida'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } }
        if (intervalDays !== null && intervalDays > 0) { reminderType = 'interval'; if (!dateISO) { const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } if (!finalTime) finalTime = '00:01'; } 
        else if (repeatDays.length > 0) { reminderType = 'weekly'; if (!dateISO) { const tempCalc = { type: 'weekly', time: finalTime || '00:01', date: null, repeatDays: repeatDays, intervalDays: null }; const firstOcc = calculateNextOccurrence(tempCalc, new Date()); if (firstOcc) { dateISO = `${firstOcc.getUTCFullYear()}-${(firstOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOcc.getUTCDate().toString().padStart(2, '0')}`; finalTime = finalTime || `${firstOcc.getUTCHours().toString().padStart(2, '0')}:${firstOcc.getUTCMinutes().toString().padStart(2, '0')}`; } else { const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; if (!finalTime) finalTime = '00:01'; } } else { if (!finalTime) finalTime = '00:01'; } } 
        else if (dateISO && finalTime) { reminderType = 'daily'; } else if (finalTime) { reminderType = 'daily'; const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (dateISO) { reminderType = 'daily'; finalTime = '00:01'; } 
        else { reminderType = 'simple'; const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; finalTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`; }
        const now = new Date(); const finalCreatedAt = isNew ? now.toISOString() : (parsed.createdAt || now.toISOString()); let finalDateISO = dateISO;
        if (isNew && (reminderType === 'weekly' || reminderType === 'interval')) { let needsRecalc = false; if (!dateInput.value.trim()) { needsRecalc = true; } else { try { const [d, m, y] = dateStr.split('/').map(Number); const inputDate = new Date(Date.UTC(y, m - 1, d)); const todayForCompare = new Date(now.getFullYear(), now.getMonth(), now.getDate()); if (inputDate < todayForCompare) { needsRecalc = true; } } catch (e) { needsRecalc = true; } } if (needsRecalc) { const tempCalcForNewCyclic = { type: reminderType, time: finalTime || '00:01', date: null, repeatDays: reminderType === 'weekly' ? repeatDays : [], intervalDays: reminderType === 'interval' ? intervalDays : null }; const firstOccurrence = calculateNextOccurrence(tempCalcForNewCyclic, new Date()); if (firstOccurrence) { finalDateISO = `${firstOccurrence.getUTCFullYear()}-${(firstOccurrence.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOccurrence.getUTCDate().toString().padStart(2, '0')}`; } else { if (!finalDateISO) { finalDateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } } } }
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        const newReminder = { id: isNew ? Date.now() : parsed.id, text: `<b>${text.toUpperCase()}</b>`, type: reminderType, time: finalTime || null, date: finalDateISO, repeatDays: reminderType === 'weekly' ? repeatDays : [], intervalDays: reminderType === 'interval' ? intervalDays : null, createdAt: finalCreatedAt, managedByUser: false, isLocationEnabled: isLocationChecked, locationCoordinates: isLocationChecked ? locationCoords : null, radiusMeters: isLocationChecked ? radius : (parsed.radiusMeters || (text.toUpperCase().startsWith("RADAR") ? 350 : DEFAULT_LOCATION_RADIUS)), excludeFromList: excludeFromListVal, isFromRuta: parsed.isFromRuta || false };
        if (!newReminder.date || !newReminder.time || !newReminder.createdAt) { showToast("Error GRAVE: Fechas/Hora inválidas al guardar", "error"); resetAndStartCountdown(); return; }
        if (options.onTopOfMap) { const mapObjectIndex = reminderMapObjects.findIndex(obj => obj.reminderId === newReminder.id); if (mapObjectIndex !== -1) { const { marker, circleId } = reminderMapObjects[mapObjectIndex]; if (marker) marker.remove(); if (circleId && navigationMapInstance.getLayer(circleId)) navigationMapInstance.removeLayer(circleId); if (circleId && navigationMapInstance.getSource(circleId)) navigationMapInstance.removeSource(circleId); reminderMapObjects.splice(mapObjectIndex, 1); } if(navigationMapInstance) { const newMapObject = plotSingleReminderOnMap(newReminder, navigationMapInstance); if(newMapObject) reminderMapObjects.push(newMapObject); } }
        if (!isNew) { const index = reminders.findIndex(r => r.id === parsed.id); if (index !== -1) { reminders[index] = newReminder; } else { newReminder.id = Date.now() + Math.random(); reminders.push(newReminder); } } else { reminders.push(newReminder); }
        localStorage.setItem('reminders', JSON.stringify(reminders)); 
        markCacheAsDirty();
        destroyMap();
        if (modal.parentNode) modal.parentNode.removeChild(modal);
        updateReminderCount(); updateButtonStyles(); 
        if (!options.onTopOfMap) { const unifiedWindowIsVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible'); if (mapShouldReopen && !unifiedWindowIsVisible && !isNavigationMapActive) { if (mapContextToReopen === 'navigation') openNavigationMap(); } else if (mapShouldReopen && unifiedWindowIsVisible) { sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true'); if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen); } }
        sessionStorage.removeItem('boardinggate_map_should_reopen_after_form'); sessionStorage.removeItem('mapContext');
    });

    modal.querySelector('#cancel-reminder').addEventListener('click', () => {
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        const mapContextToReopen = mapContextBeforeThisModal;
        destroyMap();
        if (modal.parentNode) modal.parentNode.removeChild(modal);
        const unifiedWindowIsVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible');
        if (mapShouldReopen && !unifiedWindowIsVisible && !isNavigationMapActive) { if (mapContextToReopen === 'navigation') openNavigationMap(); }
        sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
        sessionStorage.removeItem('mapContext');
    });

    modal.querySelector('#help-reminder').addEventListener('click', () => { showHelpModal({ parentContainer: modal }); });

    clearButton.addEventListener('click', () => {
        textInput.value=''; timeInput.value=''; dateInput.value='';
        modal.querySelectorAll('input[name="repeat"]').forEach(i=>i.checked=false);
        intervalInput.value=''; locationCheckbox.checked = false; toggleLocationControlsVisibility();
        currentRadius = parsed.radiusMeters || DEFAULT_LOCATION_RADIUS; updateRadiusVisuals();
        currentReminderLocation = null; destroyMap();
        excludeFromListCheckbox.checked = false; parseStatus.textContent=''; speechStatus.textContent=''; manualTimeInput=false;
        resetAndStartCountdown(); textInput.focus();
    });

    modal.querySelector('#view-reminders').addEventListener('click', () => {
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        const mapContextToReopen = mapContextBeforeThisModal;
        destroyMap();
        if (modal.parentNode) modal.parentNode.removeChild(modal);
        fromReminderModal = true;
        if (mapShouldReopen) {
            sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
            if (mapContextToReopen) {
                sessionStorage.setItem('mapContext', mapContextToReopen);
            }
        }
        showAllReminders();
    });
    
    textInput.focus();
}

// ===================================================================
// NOMBRE: markReminderAsManaged 
// RESUMEN: Marca un recordatorio como gestionado y marca la caché como sucia.
function markReminderAsManaged(reminderId, managedState = true) {
     if (typeof reminderId !== 'number') { return; } try { let reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); const index = reminders.findIndex(r => r.id === reminderId); if (index !== -1) { if (reminders[index].managedByUser !== managedState) { reminders[index].managedByUser = managedState; localStorage.setItem('reminders', JSON.stringify(reminders)); 
     markCacheAsDirty(); } } } catch (e) { }
}

    
// ===================================================================
// NOMBRE: clearRecoveryFlag 
    function clearRecoveryFlag() {
    localStorage.removeItem('boardinggate_nav_recovery_flag');
}
    
// ===================================================================
// NOMBRE: addSlideButtonListeners 
// RESUMEN: Añade listeners a los botones del slide y marca la caché como sucia en cada modificación.
function addSlideButtonListeners(slideElement, reminder) {
        const reminderId = reminder.id;
        const cancelButton = slideElement.querySelector('.cancel');
        const adjustTimeButton = slideElement.querySelector('.adjust-time-0001');
        const cancelCyclicButton = slideElement.querySelector('.cancel-cyclic');
        const modifyButton = slideElement.querySelector('.modify');
        const postponeButton = slideElement.querySelector('.postpone');
        const routeRadarVistoButton = slideElement.querySelector('.route-radar-seen');
        const handleInteraction = (actionFn) => {
            markReminderAsManaged(reminderId, true);
            actionFn();
            updateUnifiedWindowUI(processedReminderId);
        };
        let processedReminderId = reminderId;
        if (routeRadarVistoButton) {
            routeRadarVistoButton.addEventListener('click', () => {
                const minutesToSnooze = 5;
                markReminderAsManaged(reminder.id, true);
                
                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const index = reminders.findIndex(r => r.id === reminder.id);

                if (index !== -1) {
                    const { newDateISO, newTime } = calculatePostponedDateTime(minutesToSnooze);
                    
                    reminders[index].date = newDateISO;
                    reminders[index].time = newTime;
                    reminders[index].managedByUser = false;
                    localStorage.setItem('reminders', JSON.stringify(reminders));
                    
                    const radarEnRutaIndex = radaresEnRutaActual.findIndex(r => r.id === reminder.id);
                    if (radarEnRutaIndex !== -1) {
                        const newDueTime = new Date(`${newDateISO}T${newTime}:00Z`).getTime();
                        radaresEnRutaActual[radarEnRutaIndex].date = newDateISO;
                        radaresEnRutaActual[radarEnRutaIndex].time = newTime;
                        radaresEnRutaActual[radarEnRutaIndex].dueTimeUTC = newDueTime;
                    }

                    markCacheAsDirty();
                    actualizarYOrdenarEventosEnRuta();
                } else {
                    showToast("Error: No se pudo encontrar el radar para posponer.", "error");
                }
                
                updateUnifiedWindowUI(reminder.id);
            });
        }
        if (cancelButton) {
            cancelButton.addEventListener('click', () => { 
                handleInteraction(() => { 
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const index = rems.findIndex(r => r.id === processedReminderId); 
                    if (index === -1) {
                        if (reminder.isFromRuta === true) {
                            const eventoIndex = eventosEnRuta.findIndex(e => e.id === processedReminderId);
                            if (eventoIndex !== -1) {
                                eventosEnRuta[eventoIndex].managedByUser = true;
                            }
                            showToast(`Alerta de ruta marcada como vista.`, 'info');
                            return; // Salimos aquí para no ejecutar la lógica de abajo
                        } else {
                            showToast("Error: No se encontró el recordatorio para actualizar.", "error");
                            return;
                        }
                    }

                    const currentReminder = rems[index];
                    let needsSave = false;
                    const isRadarTypeStored = currentReminder.text.toUpperCase().includes("RADAR") || currentReminder.excludeFromList;
                    
                    if (isRadarTypeStored || (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval'))) { 
                       const minutesToPostpone = 15;
                       const { newDateISO, newTime } = calculatePostponedDateTime(minutesToPostpone);
                       rems[index].date = newDateISO;
                       rems[index].time = newTime;
                       rems[index].managedByUser = false;
                       needsSave = true;
                       showToast(`Recordatorio pospuesto ${minutesToPostpone} minutos`, 'info');
                    } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                        let referenceDateForNext = new Date();
                        try {
                            const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                            const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                            const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                            if (!isNaN(reminderDateTime.getTime())) {
                                referenceDateForNext = new Date(reminderDateTime.getTime() + 60000); 
                            }
                        } catch(er) {  }
                        const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                        if (nextOcc) {
                            rems[index].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                            rems[index].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                            rems[index].managedByUser = false;
                            needsSave = true;
                        } else {
                            rems.splice(index, 1); needsSave = true;
                            showToast('Error calculando siguiente ciclo. Recordatorio eliminado.', 'error');
                        }
                    } else {
                       rems.splice(index, 1);
                       needsSave = true;
                    }
                    
                    if (needsSave) {
                        localStorage.setItem('reminders', JSON.stringify(rems));
                        markCacheAsDirty();
                        actualizarYOrdenarEventosEnRuta();
                    }
                }); 
            });
        }
        if (adjustTimeButton) {
            adjustTimeButton.addEventListener('click', () => handleInteraction(() => {
                let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                const index = rems.findIndex(r => r.id === processedReminderId);
                if (index === -1) return;
                const currentReminder = rems[index];
                let needsSave = false;
                if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                     let referenceDateForNext = new Date();
                     try {
                         const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                         const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, 0, 1)); 
                         if (!isNaN(reminderDateTime.getTime())) {
                             referenceDateForNext = new Date(reminderDateTime.getTime() + 60000); 
                         }
                     } catch(e) {  }
                    const reminderForCalc = { ...currentReminder, time: '00:01' };
                    const nextOcc = calculateNextOccurrence(reminderForCalc, referenceDateForNext);
                    if (nextOcc) {
                        rems[index].date= `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                        rems[index].time = '00:01';
                        rems[index].managedByUser = false;
                        needsSave = true;
                    } else {
                        rems.splice(index, 1); needsSave = true;
                        showToast('Error calculando siguiente ciclo (ajuste 00:01). Eliminado.', 'error');
                    }
                } else { 
                    rems.splice(index, 1); needsSave = true;
                }
                if (needsSave) {
                    localStorage.setItem('reminders', JSON.stringify(rems));
                    markCacheAsDirty();
                    actualizarYOrdenarEventosEnRuta();
                }
            }));
        }
        if (cancelCyclicButton) {
            cancelCyclicButton.addEventListener('click', () => handleInteraction(() => {
                if (confirm('¿Estás seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE?')) {
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const initialLength = rems.length;
                    rems = rems.filter(r => r.id !== processedReminderId);
                    if (rems.length < initialLength) {
                       localStorage.setItem('reminders', JSON.stringify(rems)); 
                       markCacheAsDirty();
                       actualizarYOrdenarEventosEnRuta();
                       showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                    } else {
                        showToast('Error: No se encontró el ciclo para anular.', 'warning');
                    }
                } else {
                    markReminderAsManaged(processedReminderId, false); 
                }
            }));
        }
        if (modifyButton) {
            modifyButton.addEventListener('click', () => {
                markReminderAsManaged(reminder.id, true);
                let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                let reminderToModify = remindersFromStorage.find(r => r.id === reminder.id);
                if (!reminderToModify && reminder.isFromRuta) {
                   reminderToModify = { ...reminder };
                   reminderToModify.isFromRuta = false;
                }
                const mapIsVisible = document.getElementById('reminders-location-map-modal') && !document.getElementById('reminders-location-map-modal').classList.contains('hidden');
                const mapShouldReopenWhenUnifiedCloses = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                const mapContextBeforeUnified = sessionStorage.getItem('mapContext');
                hideUnifiedReminderWindow();
                if (reminderToModify) {
                    if (mapShouldReopenWhenUnifiedCloses) {
                         sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                         if (mapContextBeforeUnified) {
                           sessionStorage.setItem('mapContext', mapContextBeforeUnified);
                         }
                    }
                    showReminderModal(reminderToModify, { onTopOfMap: mapIsVisible });
                }
                else {
                    showToast("Error: no se pudo encontrar el recordatorio para modificar.", "error");
                    updateUnifiedWindowUI(reminder.id);
                    if (mapShouldReopenWhenUnifiedCloses &&
                        sessionStorage.getItem('boardinggate_map_should_reopen_after_form') !== 'true' &&
                        !document.getElementById('reminders-location-map-modal')
                       ) {
                        if (mapContextBeforeUnified === 'navigation') openNavigationMap();
                         sessionStorage.removeItem('mapContext');
                    }
                }
                sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
            });
        }
        if (postponeButton) {
            postponeButton.addEventListener('click', () => {
                markReminderAsManaged(processedReminderId, true); 
                let reminderToPostpone;
                if (reminder.isFromRuta) {
                    const eventoIndex = eventosEnRuta.findIndex(e => e.id === processedReminderId);
                    if (eventoIndex !== -1) {
                        eventosEnRuta[eventoIndex].managedByUser = true;
                    }
                    updateUnifiedWindowUI(reminder.id);
                    return; 
                } else {
                    let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                    reminderToPostpone = remindersFromStorage.find(r => r.id === processedReminderId);
                }
                if (reminderToPostpone) {
                    showPostponeOptionsModal(reminderToPostpone, 'unified');
                }
                else {
                    showToast("Error: no se pudo encontrar el recordatorio para posponer", "error");
                    updateUnifiedWindowUI(processedReminderId); 
                }
            });
        }
    }    

 
// ===================================================================
// NOMBRE: precalculateRouteStepDistances (MODIFICADA PARA INCLUIR TURF.JS)
// RESUMEN: Procesa la ruta una sola vez para crear el objeto Turf LineString y las distancias acumuladas.
function precalculateRouteStepDistances(routeData) {
    if (!routeData || !routeData.routes || !routeData.routes[0]) {
        console.warn("[PRE-CALC] No se pudo pre-calcular: el objeto de la ruta es inválido.");
        if(routeData && routeData.routes && routeData.routes[0]) {
            delete routeData.routes[0].totalPrecalculatedDistance;
        }
        window.optimizationHasFailed = true; 
        return;
    }
    
    try {
        const route = routeData.routes[0];
        
        if (route.geometry && typeof turf !== 'undefined') {
            route._turfLineString = turf.lineString(route.geometry.coordinates);
        }
        let cumulativeDistance = 0;
        if (route.legs) {
            route.legs.forEach(leg => {
                if (leg.steps) {
                    leg.steps.forEach(step => {
                        step.cumulativeDistance = cumulativeDistance;
                        cumulativeDistance += (step.distance || 0);
                    });
                }
            });
        }
        route.totalPrecalculatedDistance = cumulativeDistance;
        window.optimizationHasFailed = false; // Marcamos como exitoso
        console.log("[PRE-CALC] Distancias de la ruta pre-calculadas con éxito.");

    } catch (error) {
        console.error("[PRE-CALC] Error durante el pre-cálculo de distancias:", error);
        if(routeData && routeData.routes && routeData.routes[0]) {
            delete routeData.routes[0].totalPrecalculatedDistance;
        }
        window.optimizationHasFailed = true;
    }
}    
    
    
// ===================================================================
// NOMBRE: recalculateAndDrawRoute 
// RESUMEN: Encapsula todo el proceso de recálculo en una operación atómica
async function recalculateAndDrawRoute(preserveAccumulatedStats = false) {
    const RETRY_CADENCE_MS = 3000;
    const MAX_RETRIES = 5;
    let attempt = 1;

    while (attempt <= MAX_RETRIES) {
        isRecalculatingRoute = true;
        clearAlternativeRoutesDisplay(); 
        alternativeRoutesCache.clear();
        selectedStageRoutes.clear();
        
        const toastId = `recalc-toast-${Date.now()}`;
        showToast(`Calculando ruta... (Intento ${attempt}/${MAX_RETRIES})`, "info", 0, false, toastId);

        const wasNavigatingBeforeRecalc = isNavigating;

        try {
            let waypointsForAPI = [];
            let currentHeading = null;
            
            if (!isNavigating) {
                waypointsForAPI = [...navigationWaypoints];
                currentHeading = null;
            } else { 
                if (navigationCurrentLocation) {
                    currentHeading = navigationCurrentLocation.heading;
                    waypointsForAPI.push({ lat: navigationCurrentLocation.latitude, lng: navigationCurrentLocation.longitude, isRecalculatedStart: true });
                    waypointsForAPI.push(...navigationWaypoints.filter(wp => !wp.visited));
                } else {
                    waypointsForAPI = [...navigationWaypoints];
                }
            }
            
            const validWaypoints = waypointsForAPI.filter(wp => wp && typeof wp.lat === 'number' && typeof wp.lng === 'number');
            if (validWaypoints.length < 2) { 
                return; // Salir silenciosamente si no hay ruta que trazar
            };

            const coordsString = validWaypoints.map(wp => `${wp.lng},${wp.lat}`).join(';');
            const result = await fetchRouteData(coordsString, currentHeading);
            if (result.error) throw result.error;

            const newRouteData = result.routeData;
            const newRemainingRoute = newRouteData.routes[0];

            navigationCurrentRouteData = newRouteData;
            precalculateRouteStepDistances(navigationCurrentRouteData);
            
            await drawRouteOnMap(newRemainingRoute);
            
            if (preserveAccumulatedStats) {
                accumulatedDistanceBeforeCurrentSegment = totalDistanceTravelledForStats;
            } else {
                accumulatedDistanceBeforeCurrentSegment = 0;
            }
            
            lastCarDistanceAlongRouteForNavLogic = 0;
            currentLegIndexNav = 0;
            currentStepIndexNav = 0;
            lastProcessedStepIdentifier = null;
            lastProcessedStepForLock = null;
            lastDisplayedManeuverIcon = null;

            tripInitialOverallEtaTime = new Date(Date.now() + newRemainingRoute.duration * 1000);
            if (newRemainingRoute.legs && newRemainingRoute.legs.length > 0) {
                currentStageInitialExpectedEtaTime = new Date(Date.now() + newRemainingRoute.legs[0].duration * 1000);
            } else {
                currentStageInitialExpectedEtaTime = null;
            }
            
            renderWaypointMarkers();
            updateNavigationProgressDisplay(newRemainingRoute, 0); 
            drawStaticMarkersOnProgressBar();
            updateTurnByTurnDisplay(newRemainingRoute, 0);
            showDestinationName();
            toggleRadaresRuta(document.getElementById('radares-ruta-checkbox').checked);
            toggleTareasRuta(document.getElementById('tareas-ruta-checkbox').checked);
            updateStartNavigationButtonState();
            updateNavigationButtonColor();

            if (isDeviationModalActive) {
                deviationCheckGracePeriodUntil = Date.now() + 7000;
            }

            closeModalAndProceed();
            
            return;
            
        } catch (error) {
            console.error(`[RECALC] Fallo en intento #${attempt}:`, error);
            if (attempt === MAX_RETRIES) {
                showToast("Fallo al recalcular la ruta tras varios intentos. Comprueba tu conexión.", "error");
                closeModalAndProceed();
                throw new Error("Fallo al recalcular la ruta tras múltiples intentos.");
            } else {
                await new Promise(resolve => setTimeout(resolve, RETRY_CADENCE_MS));
            }
        } finally {
            const existingToast = document.getElementById(toastId);
            if (existingToast) existingToast.remove();
            activeToasts = activeToasts.filter(t => t.id !== toastId);

            isRecalculatingRoute = false;
            isNavigating = wasNavigatingBeforeRecalc; 
            
            if (attempt > MAX_RETRIES) { 
                 updateStartNavigationButtonState();
                 updateNavigationButtonColor();
            }
        }
        attempt++; 
    }
}    
    
// ===================================================================
// NOMBRE: checkAndIncrementPoiCount 
// RESUMEN: Verifica el límite global y actualiza el contador del usuario
async function checkAndIncrementPoiCount() {
    const { primaryId: userId } = parseUserId(localStorage.getItem('userData_userId'));
    if (!userId || !window.db) return false;

    const GLOBAL_POI_LIMIT = 7000;

    try {
        const globalStats = await getGlobalPoiStats();
        if (globalStats.totalMonth >= GLOBAL_POI_LIMIT) {
            showToast("Servicio de POI temporalmente inactivo (límite mensual alcanzado).", "warning");
            return false; // Bloquear si se ha alcanzado el límite global
        }

        const userDocRef = window.doc(window.db, "user_data", userId);
        const userDocSnap = await window.getDoc(userDocRef);
        
        const now = new Date();
        const monthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        let dataToUpdate = {};

        if (!userDocSnap.exists()) {
            dataToUpdate = {
                poi_clicks_last_month: monthStr,
                poi_clicks_month: 1
            };
        } else {
            const userData = userDocSnap.data();
            let newMonthCount = 1;
            if (userData.poi_clicks_last_month === monthStr) {
                newMonthCount = (userData.poi_clicks_month || 0) + 1;
            }
            
            dataToUpdate = {
                poi_clicks_last_month: monthStr,
                poi_clicks_month: newMonthCount
            };
        }

        await window.setDoc(userDocRef, dataToUpdate, { merge: true });

        return true; // Permitir la llamada a la API

    } catch (error) {
        console.error("Error al verificar/incrementar el contador de POIs:", error);
        showToast("Error al verificar límite de POIs. Inténtalo de nuevo.", "error");
        return false; 
    }
}    

// ===================================================================
// NOMBRE: initializeLocationPickerMap (VERSIÓN OPTIMIZADA CON REUTILIZACIÓN)
// RESUMEN: Inicializa el mapa selector de ubicaciones una sola vez y lo reutiliza,
function initializeLocationPickerMap(mapContainerId, slotIndex) {
    const container = document.getElementById(mapContainerId);
    if (!container) return;

    const initialLocation = tempSavedLocations[slotIndex] || {};
    const centerLat = initialLocation.lat || 40.416775;
    const centerLng = initialLocation.lng || -3.703790;
    const initialZoom = (initialLocation.lat && initialLocation.lng) ? 15 : 6;

    if (!locationPickerMap) {
        const mapGarage = document.getElementById('map-garage');
        const mapDiv = document.createElement('div');
        mapDiv.style.width = '100%';
        mapDiv.style.height = '100%';
        mapGarage.appendChild(mapDiv); 

        locationPickerMap = new mapboxgl.Map({
            container: mapDiv,
            style: 'mapbox://styles/mapbox/satellite-streets-v12',
            center: [centerLng, centerLat],
            zoom: initialZoom,
            interactive: true
        });

        locationPickerMap.on('load', () => {
            locationPickerMarker = new mapboxgl.Marker({ draggable: true })
                .setLngLat([centerLng, centerLat])
                .addTo(locationPickerMap);

            locationPickerMarker.on('dragend', (event) => {
                const activeSlotIndex = locationPickerMap.activeSlotIndex; // Usamos una propiedad personalizada
                if (typeof activeSlotIndex !== 'number') return;

                const pos = event.target.getLngLat();
                if (!tempSavedLocations[activeSlotIndex]) {
                    tempSavedLocations[activeSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
                }
                tempSavedLocations[activeSlotIndex].lat = pos.lat;
                tempSavedLocations[activeSlotIndex].lng = pos.lng;
            });

            locationPickerMap.on('click', (e) => {
                const activeSlotIndex = locationPickerMap.activeSlotIndex;
                if (typeof activeSlotIndex !== 'number') return;
                handlePickerMapClick(e, activeSlotIndex);
            });
        });
    }

    const mapDiv = locationPickerMap.getContainer();
    container.insertBefore(mapDiv, container.firstChild); 

    locationPickerMap.activeSlotIndex = slotIndex;

    locationPickerMap.flyTo({
        center: [centerLng, centerLat],
        zoom: initialZoom,
        duration: 0 
    });

    if (locationPickerMarker) {
        locationPickerMarker.setLngLat([centerLng, centerLat]);
    }

    setTimeout(() => {
        if (locationPickerMap) {
            try {
                locationPickerMap.resize();
            } catch(e) { console.error("Error al redimensionar mapa reutilizado:", e); }
        }
    }, 50);
}    
// ===================================================================
// NOMBRE: applyMapVisualSettings 
// RESUMEN: Carga los ajustes de saturación y contraste del mapa desde localStorage y los aplica como variables CSS.
function applyMapVisualSettings() {
    const savedSaturation = localStorage.getItem('boardinggate_map_saturation') || '1.6';
    const savedContrast = localStorage.getItem('boardinggate_map_contrast') || '1.2';
    
    document.documentElement.style.setProperty('--map-saturation', savedSaturation);
    document.documentElement.style.setProperty('--map-contrast', savedContrast);
}
 
// ===================================================================
// NOMBRE: showReminderActionModal 
// RESUMEN: Muestra un modal personalizado para las acciones de un recordatorio/radar.
function showReminderActionModal(reminderId) {
    const rems = JSON.parse(localStorage.getItem('reminders') || '[]');
    const reminder = rems.find(r => r.id === reminderId);
    if (!reminder) return;

    const overlay = document.createElement('div');
    overlay.className = 'map-item-modal-overlay';

    overlay.innerHTML = `
        <div class="map-item-modal-content">
            <h3>${reminder.text.replace(/<b>|<\/b>/gi,'')}</h3>
            <hr>
            ${reminder.time ? `<p><strong>Hora:</strong> ${formatTimeWithPeriod(reminder.time)}</p>` : ''}
            ${reminder.date ? `<p><strong>Fecha:</strong> ${formatDateDetailed(reminder.date)}</p>` : ''}
            <p><strong>Radio:</strong> ${reminder.radiusMeters || DEFAULT_LOCATION_RADIUS}m</p>
            <div class="map-item-modal-buttons">
                <button id="modal-modify-btn" style="background-color: #10B981;">Modificar</button>
                <button id="modal-close-btn" style="background-color: #6c757d;">Cerrar</button>
            </div>
        </div>
    `;

    document.body.appendChild(overlay);

    const closeHandler = () => {
        if (overlay.parentNode) overlay.remove();
    };

    overlay.querySelector('#modal-close-btn').addEventListener('click', closeHandler);
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) closeHandler();
    });

    overlay.querySelector('#modal-modify-btn').addEventListener('click', () => {
        const mapContextBeforeModal = sessionStorage.getItem('mapContext');
        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
        if (mapContextBeforeModal) {
            sessionStorage.setItem('mapContext', mapContextBeforeModal);
        }
        showReminderModal(reminder, { onTopOfMap: true });
        closeHandler();
    });
}   




// ===================================================================
// NOMBRE: handleAutoZoom 
// RESUMEN: Ajusta el zoom según la velocidad, devolviendo el nivel de zoom objetivo.
function handleAutoZoom() {
    const currentAutoZoomMode = localStorage.getItem(AUTO_ZOOM_MODE_KEY) || 'off';
    if (currentAutoZoomMode !== 'auto' || isManualZoomActive || !(isNavigating || isFreeDriveActive) || !navigationMapInstance) {
        return null;
    }

    if (isZoomedForManeuver) return null;

    const speed = window.currentSpeedKmh || 0;
    let targetZoom;

    if (speed < 30) targetZoom = 19;
    else if (speed < 50) targetZoom = 18.5;
    else if (speed < 80) targetZoom = 18;
    else if (speed < 100) targetZoom = 17.5;
    else if (speed < 110) targetZoom = 17.1;
    else if (speed < 120) targetZoom = 16.6;
    else if (speed < 200) targetZoom = 16.3;
    else return null; 

    if (Math.abs(navigationMapInstance.getZoom() - targetZoom) > 0.1) {
        return targetZoom;
    }
    return null; 
}
    
// ===================================================================
// NOMBRE: handleDragStartReorder
// RESUMEN: Inicia el arrastre de una etapa en la lista de reordenamiento.
function handleDragStartReorder(e) {
    draggedStageLi = e.target.closest('li');
    if (draggedStageLi) {
        setTimeout(() => {
            if(draggedStageLi) draggedStageLi.classList.add('dragging');
        }, 0);
    }
}
            
// ===================================================================
// NOMBRE: setupZoomButtons 
// RESUMEN: Inicializa la lógica y los eventos para los botones de zoom.
function setupZoomButtons() {
    const container = document.getElementById('zoom-button-container');
    const zoomInBtn = document.getElementById('zoom-in-button');
    const zoomOutBtn = document.getElementById('zoom-out-button');
    const levelDisplay = document.getElementById('zoom-level-display');
    if (!container || !zoomInBtn || !zoomOutBtn || !levelDisplay || !navigationMapInstance) return;

    const map = navigationMapInstance;

    const updateZoomDisplay = () => {
        levelDisplay.textContent = map.getZoom().toFixed(1);
    };

    map.on('zoom', updateZoomDisplay);
    updateZoomDisplay();

    const handleZoomClick = (zoomFunction) => {
        isManualZoomActive = true;
        if (manualZoomTimeout) {
            clearTimeout(manualZoomTimeout);
            manualZoomTimeout = null;
        }
        
        zoomFunction();

        manualZoomTimeout = setTimeout(() => {
            isManualZoomActive = false;
        }, 30000); 
    };

    zoomInBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        handleZoomClick(() => map.zoomIn());
    });

    zoomOutBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        handleZoomClick(() => map.zoomOut());
    });
}


// ===================================================================
// NOMBRE: updateInitialUserPosition 
// RESUMEN: Orquestador principal del GPS. Llama a las funciones
function updateInitialUserPosition(coords, mapInstanceToUse) {
    if (isRecalculatingRoute || !mapInstanceToUse || !coords) return;

    const now = performance.now();
    navigationCurrentLocation = { ...coords };
    
    for (const task of TASKS_BY_PRIORITY) { 
        if (now - task.lastRun >= task.getFrequency()) {
            task.handler(coords, mapInstanceToUse);
            task.lastRun = now;
            
            if (task.id !== 'CRITICAL_VISUALS') {
                break;
            }
        }
    }
    
    const criticalTask = navigationTasks.CRITICAL_VISUALS;
    if (now - criticalTask.lastRun >= criticalTask.getFrequency()) {
         criticalTask.handler(coords, mapInstanceToUse);
         criticalTask.lastRun = now;
    }
}

    
// ===================================================================
// NOMBRE: updateVehicleMarker 
// RESUMEN: Establece los objetivos del icono y LUEGO llama a updateMapCamera.
function updateVehicleMarker(coords, mapInstanceToUse) {
    lastGpsUpdateTime = Date.now();
    const lngLat = new mapboxgl.LngLat(coords.longitude, coords.latitude);
    initialUserLocationMarkerLat = coords.latitude;
    initialUserLocationMarkerLng = coords.longitude;

    let validatedHeading = null;
    
    if (coords.heading !== null && typeof coords.heading === 'number' && !isNaN(coords.heading) && coords.heading >= 0) {
        validatedHeading = coords.heading;
    } else if (window.lastPositionForSpeedCalc && typeof turf !== 'undefined' && (window.currentSpeedKmh || 0) > 5) {
        _turfLastPoint.geometry.coordinates[0] = window.lastPositionForSpeedCalc.longitude;
        _turfLastPoint.geometry.coordinates[1] = window.lastPositionForSpeedCalc.latitude;
        _turfCurrentPoint.geometry.coordinates[0] = coords.longitude;
        _turfCurrentPoint.geometry.coordinates[1] = coords.latitude;
        if (turf.distance(_turfLastPoint, _turfCurrentPoint, { units: 'meters' }) > 1) {
            const bearing = turf.bearing(_turfLastPoint, _turfCurrentPoint);
            validatedHeading = (bearing < 0) ? bearing + 360 : bearing;
        }
    }
    
    if (validatedHeading === null) {
        validatedHeading = (markerAnimationState.currentIconRotation + 90 + 360) % 360; 
    }

    if (!initialUserLocationMarker) {
        initialUserLocationMarker = new mapboxgl.Marker({ element: vehicleIconElement, rotationAlignment: 'map', anchor: 'center' })
            .setLngLat(lngLat)
            .addTo(mapInstanceToUse);
        markerAnimationState.currentIconRotation = validatedHeading - 90;
    }
    
    if (!markerAnimationState.currentLngLat) {
        markerAnimationState.currentLngLat = lngLat;
    }
   
    markerAnimationState.targetLngLat = lngLat;
    markerAnimationState.targetIconRotation = validatedHeading - 90; 

    updateMapCamera(coords, mapInstanceToUse);
    
    if (compassAndModeControl) {
        compassAndModeControl.updateOrientation(validatedHeading);
    }
}


// ===================================================================
// NOMBRE: updateMapCamera 
// RESUMEN: Calcula todos los objetivos de la cámara, incluyendo los offsets
function updateMapCamera(coords, mapInstanceToUse) {
    if (!shouldCenterOnUser && !navigationFollowUser) {
        return;
    }

    const cameraAdjustments = handleProgressiveManeuverZoom(
        navigationCurrentRouteData?.routes?.[0]?.legs?.[currentLegIndexNav]?.steps?.[currentStepIndexNav],
        distanceToNextManeuverOSRM,
        lastCarDistanceAlongRouteForNavLogic
    );

    let targetZoom = cameraAdjustments?.zoom ?? null;
    if (targetZoom === null && !isManualZoomActive) {
        targetZoom = handleAutoZoom();
    }
    
    if (targetZoom !== null) {
        markerAnimationState.targetMapZoom = targetZoom;
    } else {
        markerAnimationState.targetMapZoom = navigationMapInstance.getZoom();
    }
    
    const targetPitch = cameraAdjustments?.pitch ?? ((mapViewMode === 'perspective' || mapViewMode === 'relief') ? mapPitchValue : 0);
    
    const targetOffsetX = cameraAdjustments?.offsetX ?? mapOffsetX;
    const targetOffsetY = cameraAdjustments?.offsetY ?? mapOffsetY;

    markerAnimationState.targetMapPitch = targetPitch;
    markerAnimationState.targetMapOffsetX = targetOffsetX;
    markerAnimationState.targetMapOffsetY = targetOffsetY;

    let targetBearing = markerAnimationState.currentMapBearing; 
    if (mapViewMode === 'heading' || mapViewMode === 'perspective' || mapViewMode === 'relief') {
        let validatedHeading = null;
        if (coords.heading !== null && typeof coords.heading === 'number' && !isNaN(coords.heading) && coords.heading >= 0) {
            validatedHeading = coords.heading;
        } else if (window.lastPositionForSpeedCalc && typeof turf !== 'undefined' && (window.currentSpeedKmh || 0) > 5) {
            _turfLastPoint.geometry.coordinates[0] = window.lastPositionForSpeedCalc.longitude;
            _turfLastPoint.geometry.coordinates[1] = window.lastPositionForSpeedCalc.latitude;
            _turfCurrentPoint.geometry.coordinates[0] = coords.longitude;
            _turfCurrentPoint.geometry.coordinates[1] = coords.latitude;
            if (turf.distance(_turfLastPoint, _turfCurrentPoint, { units: 'meters' }) > 1) {
                const bearing = turf.bearing(_turfLastPoint, _turfCurrentPoint);
                validatedHeading = (bearing < 0) ? bearing + 360 : bearing;
            }
        }
        if (validatedHeading !== null) {
            targetBearing = validatedHeading;
        }
    } else if (mapViewMode === 'static') {
        targetBearing = 0;
    }
    markerAnimationState.targetMapBearing = targetBearing;
}    
    
    
// NOMBRE: updateTripStatistics 
// RESUMEN: Gestiona los cálculos y la actualización de la UI de estadísticas de viaje.
// ===================================================================
function updateTripStatistics(coords) {
    if (compassAndModeControl) {
        compassAndModeControl.updateAltitude(coords.altitude);

        if (window.lastPositionForSpeedCalc && typeof coords.speed === 'number' && coords.speed !== null) {
            const distM = calculateDistance(window.lastPositionForSpeedCalc.latitude, window.lastPositionForSpeedCalc.longitude, coords.latitude, coords.longitude);
            const timeS = (Date.now() - window.lastPositionForSpeedCalc.time) / 1000;
            if (timeS > 0 && distM >= 0) {
                let speedMs = coords.speed;
                if (typeof speedMs !== 'number' || speedMs === null || speedMs < 0) { speedMs = distM / timeS; }
                window.currentSpeedKmh = speedMs * 3.6;
            } else { window.currentSpeedKmh = 0; }
        } else {
            if (typeof coords.speed === 'number' && coords.speed !== null && coords.speed >= 0) { window.currentSpeedKmh = coords.speed * 3.6; } else { window.currentSpeedKmh = 0; }
        }
        window.lastPositionForSpeedCalc = { latitude: coords.latitude, longitude: coords.longitude, time: Date.now() };

        const isTripActive = isNavigating || isFreeDriveActive;
        if (isTripActive) {
             if (navigationStartTimeForStats === null && window.currentSpeedKmh > 1) {
                navigationStartTimeForStats = new Date();
             }
             if (lastPositionForStats && navigationStartTimeForStats) {
                const distanceMoved = calculateDistance(lastPositionForStats.latitude, lastPositionForStats.longitude, coords.latitude, coords.longitude);
                totalDistanceTravelledForStats += distanceMoved;
                const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000;
                if (timeElapsedS > 0) {
                    window.averageSpeedKmh = (totalDistanceTravelledForStats / timeElapsedS) * 3.6;
                }
             }
            lastPositionForStats = { ...coords };
            
            if (window.currentSpeedKmh > maxSpeedDuringTrip) {
                maxSpeedDuringTrip = window.currentSpeedKmh;
              if (coords) { maxSpeedCoordinates = { lat: coords.latitude, lng: coords.longitude }; }
            }
            if (coords.altitude !== null && !isNaN(coords.altitude)) {
                maxAltitudeDuringTrip = Math.max(maxAltitudeDuringTrip, coords.altitude);
                minAltitudeDuringTrip = Math.min(minAltitudeDuringTrip, coords.altitude);
            }
        }
        compassAndModeControl.updateCurrentSpeed(window.currentSpeedKmh);
        compassAndModeControl.updateAverageSpeed(window.averageSpeedKmh);
        compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip);
    }
}

// ===================================================================
// NOMBRE: processRouteProgress (VERSIÓN FINAL CON AVISO BASADO ÚNICAMENTE EN RADIO)
// RESUMEN: Elimina el umbral de pre-vigilancia. La alerta se activa
function processRouteProgress(coords, mapInstanceToUse) {
    if (!isNavigating || !navigationCurrentRouteData?.routes?.[0]?._turfLineString || !coords) {
        return;
    }
    const route = navigationCurrentRouteData.routes[0];
    const fullRouteLineString = route._turfLineString; 
    
    let carDistCalculated = 0;

    try {
        _turfCurrentPoint.geometry.coordinates[0] = coords.longitude;
        _turfCurrentPoint.geometry.coordinates[1] = coords.latitude;
        const nearestPointOnRoute = turf.nearestPointOnLine(fullRouteLineString, _turfCurrentPoint, { units: 'meters' });
        carDistCalculated = nearestPointOnRoute.properties.location;
    } catch (e) {
        try { // Fallback
            _turfCurrentPoint.geometry.coordinates[0] = coords.longitude;
            _turfCurrentPoint.geometry.coordinates[1] = coords.latitude;
            const carPointTurf = _turfCurrentPoint;
            const routeLineStringTurf = fullRouteLineString;
            const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
            const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
            carDistCalculated = turf.length(lineSliceToNearestTurf, { units: 'meters' });
        } catch (turfError) {
            carDistCalculated = lastCarDistanceAlongRouteForNavLogic;
        }
    }
    
    const totalRouteLength = route.distance;
    if (carDistCalculated >= 0 && carDistCalculated <= totalRouteLength + 500) {
        if (carDistCalculated > lastCarDistanceAlongRouteForNavLogic - 100) {
             lastCarDistanceAlongRouteForNavLogic = carDistCalculated;
        }
    } else if (carDistCalculated > totalRouteLength + 500) {
        lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
    }

    // --- INICIO DE LA LÓGICA DE VIGÍA DE RUTA SIMPLIFICADA Y CORREGIDA ---
    if (eventosEnRuta.length > 0 && proximoEventoEnRutaIndex < eventosEnRuta.length) {
        const proximoEvento = eventosEnRuta[proximoEventoEnRutaIndex];
        const distanciaAlEvento = proximoEvento.distanceOnRoute - lastCarDistanceAlongRouteForNavLogic;
        
        // Obtenemos el radio específico del evento. Si no tiene, usamos uno por defecto.
        const radioDelEvento = proximoEvento.radiusMeters || DEFAULT_LOCATION_RADIUS;

        // 1. CONDICIÓN ÚNICA Y DIRECTA: ¿Hemos entrado en el radio de acción del evento?
        if (distanciaAlEvento <= radioDelEvento) {
            
            const dueTime = proximoEvento.dueTimeUTC;
            const now = Date.now();
            
            // 2. ¿El evento está activo y no ha sido visto ya?
            if ((!dueTime || dueTime <= now) && !proximoEvento.managedByUser) {
                displayUnifiedReminderWindow([proximoEvento]);
            }
        }
        
        // 3. ¿Hemos SUPERADO la ubicación del evento para pasar al siguiente?
        // Se mantiene la lógica de avanzar el puntero solo cuando la distancia es negativa.
        if (distanciaAlEvento < 0) {
            proximoEventoEnRutaIndex++; 
        }
    }
   
    checkAndMarkWaypointsAsVisited(route, lastCarDistanceAlongRouteForNavLogic, coords);
    renderWaypointMarkers();
    updateTurnByTurnDisplay(route, lastCarDistanceAlongRouteForNavLogic);
    updateNavigationProgressDisplay(route, lastCarDistanceAlongRouteForNavLogic);
}

// ===================================================================
// NOMBRE: startGpsWatching (VERSIÓN COMPLETA Y CORRECTA)
// RESUMEN: Inicia el seguimiento GPS. Incluye tanto la lógica de inicio automático
function startGpsWatching() {
    if (gpsRetryTimeoutId) {
        clearTimeout(gpsRetryTimeoutId);
        gpsRetryTimeoutId = null;
    }
    if (locationWatchId !== null) {
        return;
    }

    if (gpsRetryAttempt >= MAX_GPS_RETRIES) {
        showToast("Error persistente: No se pudo conectar al GPS. Revisa los permisos del dispositivo.", "error", 0, false, "gps-persistent-error");
        return;
    }
    gpsRetryAttempt++;
    
    locationWatchId = navigator.geolocation.watchPosition(
        (position) => {
            gpsHzMonitor.ticks++; 
            
            if (isSimulatingGpsLocation) return;

            const persistentErrorToast = document.getElementById("gps-persistent-error");
            if (persistentErrorToast) persistentErrorToast.remove();
            gpsRetryAttempt = 0;
            
            const coordsForUpdate = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                heading: position.coords.heading,
                speed: position.coords.speed,
                altitude: position.coords.altitude
            };

            updateInitialUserPosition(coordsForUpdate, navigationMapInstance);

            if (!isNavigating && navigationWaypoints.length >= 2) {
                const isRouteDataFullyAvailable = navigationCurrentRouteData &&
                                                navigationCurrentRouteData.routes &&
                                                navigationCurrentRouteData.routes[0] &&
                                                navigationCurrentRouteData.routes[0].geometry &&
                                                navigationCurrentRouteData.routes[0].geometry.coordinates.length > 1;

                if (isRouteDataFullyAvailable) {
                    const startPoint = navigationWaypoints[0];
                    const distanceFromStart = calculateDistance(startPoint.lat, startPoint.lng, coordsForUpdate.latitude, coordsForUpdate.longitude);
                    const START_TRIGGER_DISTANCE = 50;  
                    const RELEVANCE_DISTANCE = 200; 

                    const isRouteCompleted = navigationWaypoints[navigationWaypoints.length - 1]?.visited === true;

                    if (!isRouteCompleted && distanceFromStart > START_TRIGGER_DISTANCE && distanceFromStart < RELEVANCE_DISTANCE) {
                        toggleNavigationState(); 
                        return; 
                    }
                }
            }
            
            if (!isNavigating && !isFreeDriveActive && navigationWaypoints.length === 0) {
                
                const speedKmh = position.coords.speed ? (position.coords.speed * 3.6) : 0;
                const SPEED_TRIGGER_KMH = 20;

                if (speedKmh > SPEED_TRIGGER_KMH) {
                    startFreeDrive(coordsForUpdate);
                    return; 
                }
            }
           },
        (error) => {
            if (locationWatchId !== null) {
                navigator.geolocation.clearWatch(locationWatchId);
                locationWatchId = null;
            }
            gpsRetryTimeoutId = setTimeout(startGpsWatching, GPS_RETRY_DELAY_MS);
        },
        { enableHighAccuracy: true, timeout: 15000, maximumAge: 2000, distanceFilter: 3 }
    );
}
    
    
// ===================================================================
// NOMBRE: processSimulatedGpsPosition 
// RESUMEN: Procesa la posición GPS simulada, actualiza las estadísticas
function processSimulatedGpsPosition(forceExactPosition = false) {
    if (!isSimulatingGpsLocation || !simulatedGpsLocation) return;
    navigationCurrentLocation = { ...simulatedGpsLocation };

    const isTripActive = isNavigating || isFreeDriveActive;
    if (isTripActive && lastPositionForStats) {
        const distanceMovedSinceLastPoint = calculateDistance(lastPositionForStats.latitude, lastPositionForStats.longitude, navigationCurrentLocation.latitude, navigationCurrentLocation.longitude);
        
        if (navigationStartTimeForStats === null && distanceMovedSinceLastPoint > 1) {
            navigationStartTimeForStats = new Date();
            showToast("Viaje simulado iniciado. Registrando estadísticas.", "success");
        }

        if (navigationStartTimeForStats !== null) {
            totalDistanceTravelledForStats += distanceMovedSinceLastPoint;
            const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000;
            if (timeElapsedS > 0) {
                window.averageSpeedKmh = (totalDistanceTravelledForStats / timeElapsedS) * 3.6;
            }
        }
        lastPositionForStats = { ...navigationCurrentLocation };
    }
    
    updateInitialUserPosition(navigationCurrentLocation, navigationMapInstance);

    if (!automatedSimulationIntervalId) { 
        showToast(`Posición GPS simulada: ${simulatedGpsLocation.latitude.toFixed(4)}, ${simulatedGpsLocation.longitude.toFixed(4)}`, "info");
    }
}
    
// NOMBRE: redrawAllHTMLMarkers 
// RESUMEN: Limpia y redibuja los marcadores de Etapas y Recordatorios/Radares.
// ===================================================================
function redrawAllHTMLMarkers() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
        return;
    }

    navigationWaypoints.forEach(wp => {
        if (wp && wp.marker) {
            wp.marker.remove();
            wp.marker = null;
        }
    });

    reminderMapObjects.forEach(obj => {
        if (obj.marker) obj.marker.remove();
    });
    reminderMapObjects = [];

    renderWaypointMarkers();
    plotRemindersOnNavigationMap();
}
 
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// NOMBRE: updateAllIconSizes 
// RESUMEN: Controlador central que decide CUÁNDO se deben redibujar los iconos.
function updateAllIconSizes() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
        return;
    }

    const currentZoomLevel = navigationMapInstance.getZoom();

    const ZOOM_LEJANO = 10;
    const ZOOM_MEDIO = 14;

    const getZoomRange = (zoom) => {
        if (zoom <= ZOOM_LEJANO) return 'lejano';
        if (zoom <= ZOOM_MEDIO) return 'medio';
        return 'cercano';
    };

    const currentRange = getZoomRange(currentZoomLevel);
    const previousRange = getZoomRange(mapPreviousZoomLevelForPDRs); // Reutilizamos la variable

    if (currentRange !== previousRange) {
        redrawAllHTMLMarkers();
    }

    const PDR_ZOOM_THRESHOLD = 14;
    const crossedThresholdUp = mapPreviousZoomLevelForPDRs <= PDR_ZOOM_THRESHOLD && currentZoomLevel > PDR_ZOOM_THRESHOLD;
    const crossedThresholdDown = mapPreviousZoomLevelForPDRs > PDR_ZOOM_THRESHOLD && currentZoomLevel <= PDR_ZOOM_THRESHOLD;

    if (crossedThresholdUp || crossedThresholdDown) {
        displayChargingPointsOnMap();
    }
    
    mapPreviousZoomLevelForPDRs = currentZoomLevel;
}

// ===================================================================
function plotSingleReminderOnMap(reminder, mapInstance) {
    plotRemindersOnNavigationMap();
    return null; // Ya no devuelve un objeto de mapa individual.
}
    
// ===================================================================
// NOMBRE: hidePostArrivalActionModal 
// RESUMEN: Oculta y elimina el modal de acciones post-llegada.
function hidePostArrivalActionModal() {
    const modal = document.getElementById('post-arrival-action-modal');
    if (modal) {
        modal.remove();
    }
}

// ===================================================================
// NOMBRE: showPostArrivalActionModal 
// RESUMEN: Muestra un modal persistente con opciones después de llegar a un destino.
function showPostArrivalActionModal() {
    hidePostArrivalActionModal(); 

    const modal = document.createElement('div');
    modal.id = 'post-arrival-action-modal';
    
    modal.innerHTML = `
        <p class="post-arrival-title">Viaje finalizado</p>
        <div class="post-arrival-buttons">
            <button id="return-trip-button">Cargar Viaje de Vuelta</button>
            <button id="clear-completed-route-button">Borrar Ruta Actual</button>
            <button id="post-arrival-exit-button" style="background-color: #6c757d;">Salir</button>
        </div>
    `;

    document.body.appendChild(modal);

    document.getElementById('return-trip-button').addEventListener('click', () => {
        createAndLoadReturnTrip();
        hidePostArrivalActionModal();
    });

    document.getElementById('clear-completed-route-button').addEventListener('click', () => {
        handleLoadOrDeleteRouteClick(null);
        hidePostArrivalActionModal();
    });

    document.getElementById('post-arrival-exit-button').addEventListener('click', () => {
        hidePostArrivalActionModal();
    });
}
    
// ===================================================================
// NOMBRE: createAndLoadReturnTrip 
// RESUMEN: Se corrige el bug de numeración y estado persistente.
async function createAndLoadReturnTrip() {
    if (!navigationWaypoints || navigationWaypoints.length < 2) {
        showToast("No hay una ruta completa para invertir.", "warning");
        return;
    }

    showToast("Preparando ruta de vuelta...", "info", 2000);

    try {
        const originalWaypointsForReturn = navigationWaypoints
            .filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart)
            .map(wp => ({ lat: wp.lat, lng: wp.lng, address: wp.address }));

        handleLoadOrDeleteRouteClick(null);

        await new Promise(resolve => setTimeout(resolve, 50));
        
        const currentPos = await getCurrentLocationAsync();
        
        const originalStart = originalWaypointsForReturn.shift(); // Este era 'S', ahora será el nuevo 'F'.
        if (originalWaypointsForReturn.length > 0) {
            originalWaypointsForReturn.pop(); // Eliminamos el 'F' original.
        }
        const intermediateReversed = originalWaypointsForReturn.reverse();

        let returnWaypointsData = [
            { lat: currentPos.latitude, lng: currentPos.longitude, address: 'Posición Actual (GPS)' },
            ...intermediateReversed,
            originalStart 
        ];

        const returnRouteObject = {
            name: `VUELTA: ${originalStart.address || 'Ruta Original'}`,
            waypoints: returnWaypointsData
        };

        loadRouteFromObject(returnRouteObject, true);
        addRouteToRecents(returnRouteObject);

    } catch (error) {
        showToast(`Error al crear ruta de vuelta: ${error.message}`, "error");
    }
}

 // ===================================================================
// NOMBRE: showArrivalStatsModal 
// RESUMEN: Al finalizar el viaje, añade el marcador de velocidad máxima y
function showArrivalStatsModal(freeDriveStatsData = null) {
    clearRecoveryFlag();
    closeOtherModals('arrival-stats-modal');
    document.body.classList.add('modal-open');

    let modal = document.getElementById('arrival-stats-modal');
    if (modal) {
        clearModalAutoCloseTimer(modal, modal.querySelector('#arrival-stats-accept-button'), 'arrival-stats-modal');
        modal.remove();
    }

    modal = document.createElement('div');
    modal.id = 'arrival-stats-modal';
    
    const isFreeDrive = !!freeDriveStatsData;
    
    const destinationName = isFreeDrive ? "Viaje Libre" : (navigationWaypoints[navigationWaypoints.length - 1]?.address || "Destino");
    const startTime = isFreeDrive ? freeDriveStatsData.startTime : (navigationStartTimeForStats ? new Date(navigationStartTimeForStats) : new Date());
    const arrivalTime = new Date();
    const durationMs = arrivalTime - startTime;
    const durationHours = Math.floor(durationMs / (1000 * 60 * 60));
    const durationMinutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
    
    let kmRealizados = isFreeDrive 
        ? (freeDriveStatsData.totalDistance / 1000).toFixed(1)
        : (totalDistanceTravelledForStats / 1000).toFixed(1);
    if (isSimulatingGpsLocation && automatedSimulationIntervalId) {
        kmRealizados = (simulatedDistanceAlongRoute / 1000).toFixed(1);
    }

    const kmEstimadosTexto = (!isFreeDrive && tripInitialDistanceMeters !== null) 
        ? `<br><small style="font-size: 0.7em; color: #b0b0b0;">(Estimados: ${(tripInitialDistanceMeters / 1000).toFixed(1)} km)</small>`
        : '';
    
    const initialDurationTotalMinutes = tripInitialDurationSec ? Math.round(tripInitialDurationSec / 60) : 0;
    const initialDurationHours = Math.floor(initialDurationTotalMinutes / 60);
    const initialDurationMinutes = initialDurationTotalMinutes % 60;
    const tiempoEstimadoTexto = (!isFreeDrive && tripInitialDurationSec !== null)
        ? `<br><small style="font-size: 0.7em; color: #b0b0b0;">(Estimado: ${String(initialDurationHours).padStart(2,'0')}:${String(initialDurationMinutes).padStart(2,'0')})</small>`
        : '';

    const velocidadMedia = window.averageSpeedKmh.toFixed(1);
    const velocidadMediaEstimadaTexto = (!isFreeDrive && graphExpectedAvgSpeed)
        ? `<br><small style="font-size: 0.7em; color: #b0b0b0;">(Estimada: ${graphExpectedAvgSpeed.toFixed(1)} km/h)</small>`
        : '';
    
    const horaLlegadaEstimadaTexto = (!isFreeDrive && originalTripEtaTime)
        ? `<br><small style="font-size: 0.7em; color: #b0b0b0;">(Estimada: ${originalTripEtaTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'})})</small>`
        : '';

    const velocidadMaxima = maxSpeedDuringTrip.toFixed(1);
    const altitudMaxima = maxAltitudeDuringTrip !== -Infinity ? `${maxAltitudeDuringTrip.toFixed(0)} m` : 'N/D';
    const altitudMinima = minAltitudeDuringTrip !== Infinity ? `${minAltitudeDuringTrip.toFixed(0)} m` : 'N/D';
    
    let altitudMediaHtml = 'N/D';
    if (graphDataPoints && graphDataPoints.altitude && graphDataPoints.altitude.length > 0) {
        const sum = graphDataPoints.altitude.reduce((a, b) => a + b, 0);
        const avg = sum / graphDataPoints.altitude.length;
        altitudMediaHtml = `${avg.toFixed(0)} m`;
    }

    let deviationHtml = '';
    let initialEtaDetailsHtml = '';
    if (!isFreeDrive) {
        if (originalTripEtaTime) {
            const finalDeviationMs = arrivalTime.getTime() - originalTripEtaTime.getTime();
            deviationHtml = formatDeviation(finalDeviationMs);
            if (Math.abs(finalDeviationMs) < 5000) {
                initialEtaDetailsHtml = `Previsión inicial coincidió con la real.`;
            } else {
                const initialEtaTime = originalTripEtaTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                const initialDurationFormatted = `${String(initialDurationHours).padStart(2,'0')}:${String(initialDurationMinutes).padStart(2,'0')}`;
                const initialAvgSpeed = graphExpectedAvgSpeed ? graphExpectedAvgSpeed.toFixed(1) : '0.0';
                initialEtaDetailsHtml = `<strong>Previsión inicial:</strong> Llegada: ${initialEtaTime} | Tiempo: ${initialDurationFormatted} | Vel. media: ${initialAvgSpeed} Km/h`;
            }
        }
    }
    
    const deviationSectionHtml = isFreeDrive ? '' : `
        <h3 class="stats-section-header">Desviación ETA</h3>
        <div class="stats-grid">
            <div class="stat-card" style="grid-column: 1 / -1;">
                <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=_gn_lN6WnWZh&format=png&color=FFFFFF" alt="Desviación ETA"/></div>
                <span class="stat-label">Desviación sobre ETA (mm:ss)</span>
                <span class="stat-value">${deviationHtml}</span>
            </div>
        </div>
        ${initialEtaDetailsHtml ? `<div class="initial-eta-details">${initialEtaDetailsHtml}</div>` : ''}
    `;

    modal.innerHTML = `
        <div class="arrival-stats-header">
            <h2>${isFreeDrive ? 'RESUMEN DEL VIAJE' : '¡HAS LLEGADO!'}</h2>
            <p class="destination-name">${destinationName}</p>
        </div>
        <div class="arrival-stats-body">
            <div class="arrival-stats-layout-grid">
                <div class="main-stats-container">
                    <h3 class="stats-section-header">Tiempos y Duración</h3>
                    <div class="stats-grid" style="grid-template-columns: repeat(3, 1fr);">
                         <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=25235&format=png&color=FFFFFF" alt="Salida"/></div>
                            <span class="stat-label">Hora Salida</span>
                            <span class="stat-value">${startTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/time.png" alt="Duración"/></div>
                            <span class="stat-label">Duración Viaje</span>
                            <span class="stat-value">${String(durationHours).padStart(2,'0')}:${String(durationMinutes).padStart(2,'0')} ${tiempoEstimadoTexto}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/finish-flag.png" alt="Llegada"/></div>
                            <span class="stat-label">Hora Llegada</span>
                            <span class="stat-value">${arrivalTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})} ${horaLlegadaEstimadaTexto}</span>
                        </div>
                    </div>

                    <h3 class="stats-section-header">Distancia y Velocidad</h3>
                    <div class="stats-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=fodDbvH8xepW&format=png&color=ffffff" alt="Distancia"/></div>
                            <span class="stat-label">Km Realizados</span>
                            <span class="stat-value">${kmRealizados} km ${kmEstimadosTexto}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/speedometer.png" alt="Velocidad Media"/></div>
                            <span class="stat-label">Velocidad Media</span>
                            <span class="stat-value">${velocidadMedia} km/h ${velocidadMediaEstimadaTexto}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=c7DeWFZX07r8&format=png&color=ffffff" alt="Velocidad Máxima"/></div>
                            <span class="stat-label">Velocidad Máxima</span>
                            <span class="stat-value">${velocidadMaxima} km/h <button id="show-max-speed-location-button">¿Dónde?</button></span>
                        </div>
                    </div>
                </div>

                <div class="side-stats-container">
                    ${deviationSectionHtml}
                    <h3 class="stats-section-header">Métricas de Altitud</h3>
                    <div class="stats-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/mountain.png" alt="Altitud Máxima"/></div>
                            <span class="stat-label">Altitud Máxima</span>
                            <span class="stat-value">${altitudMaxima}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/mountain.png" alt="Altitud Mínima" style="transform: scaleY(-1);"/></div>
                            <span class="stat-label">Altitud Mínima</span>
                            <span class="stat-value">${altitudMinima}</span>
                        </div>
                         <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=113129&format=png&color=ffffff" alt="Altitud Media"/></div>
                            <span class="stat-label">Altitud Media</span>
                            <span class="stat-value">${altitudMediaHtml}</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="arrival-stats-footer">
            <button id="arrival-stats-accept-button">Aceptar <span class="button-countdown-timer unified-countdown-style"></span></button>
        </div>
    `;

    document.body.appendChild(modal);
    
    const coordsAreValid = maxSpeedCoordinates && typeof maxSpeedCoordinates.lat === 'number' && !isNaN(maxSpeedCoordinates.lat) && typeof maxSpeedCoordinates.lng === 'number' && !isNaN(maxSpeedCoordinates.lng);
    if (coordsAreValid && navigationMapInstance) {
        const maxSpeedFeature = {
            type: 'Feature',
            geometry: {
                type: 'Point',
                coordinates: [maxSpeedCoordinates.lng, maxSpeedCoordinates.lat]
            },
            properties: {
                type: 'maxSpeed',
                speedText: maxSpeedDuringTrip.toFixed(0)
            }
        };
        speedMarkerFeatures.push(maxSpeedFeature);
        if (navigationMapInstance.getSource('speed-markers-source')) {
            navigationMapInstance.getSource('speed-markers-source').setData({
                type: 'FeatureCollection',
                features: speedMarkerFeatures
            });

            try {
                if (navigationMapInstance.getLayer('speed-markers-circle-bg')) {
                    navigationMapInstance.moveLayer('speed-markers-circle-bg');
                }
                if (navigationMapInstance.getLayer('speed-markers-text')) {
                    navigationMapInstance.moveLayer('speed-markers-text');
                }
            } catch (e) {
            }
        }

        modal.querySelector('#show-max-speed-location-button').addEventListener('click', () => {
            closeHandler();
            navigationMapInstance.flyTo({ center: [maxSpeedCoordinates.lng, maxSpeedCoordinates.lat], zoom: 17 });
        });
    }

    const acceptButton = modal.querySelector('#arrival-stats-accept-button');
    const closeHandler = () => {
        document.body.classList.remove('modal-open');
        clearModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal');
        if (modal.parentNode) modal.remove();
        isGraphingActive = false;
        if (graphIntervalTimer) { clearInterval(graphIntervalTimer); graphIntervalTimer = null; }
        
        if (isFreeDrive) {
             isFreeDriveActive = false;
             isFreeDrivePaused = false;
             freeDriveStats = null;
             tripStartLocationForStats = null;
        } else {
            isNavigating = false;
            navigationFollowUser = false;
            showPostArrivalActionModal(); 
          }

        mapHeaderButtonsVisible = true;
        toggleMapHeaderRowsVisibility(true);
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        showMapInfoOverlay(isFreeDrive ? "Viaje libre finalizado" : "HA LLEGADO A: " + destinationName);
    };

    acceptButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal', 150000);
}   

// ===================================================================
// NOMBRE: drawRouteOnMap 
// RESUMEN: Encapsula la lógica completa de pintado: destruye la ruta antigua
async function drawRouteOnMap(route) {
    return new Promise((resolve, reject) => {
        if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
            return reject(new Error("El mapa no está listo para dibujar."));
        }

        const geojsonData = (route && route.geometry && route.geometry.coordinates.length >= 2) 
            ? { type: 'Feature', properties: {}, geometry: route.geometry }
            : { type: 'Feature', properties: {}, geometry: { type: 'LineString', coordinates: [] } };

        const cleanupAndReject = (message) => {
            clearTimeout(timeoutId);
            navigationMapInstance.off('sourcedata', onSourceData);
            reject(new Error(message));
        };
        
        const timeoutId = setTimeout(() => {
            cleanupAndReject("Timeout esperando la confirmación de renderizado del mapa.");
        }, 7000);

        const onSourceData = (e) => {
            if (e.sourceId === 'route' && e.isSourceLoaded) {
                clearTimeout(timeoutId);
                navigationMapInstance.off('sourcedata', onSourceData);
                resolve();
            }
        };
        
        navigationMapInstance.on('sourcedata', onSourceData);

        try {
            if (navigationMapInstance.getLayer('route')) {
                navigationMapInstance.removeLayer('route');
            }
            if (navigationMapInstance.getSource('route')) {
                navigationMapInstance.removeSource('route');
            }

            navigationMapInstance.addSource('route', { type: 'geojson', data: geojsonData });
            navigationMapInstance.addLayer({
                id: 'route',
                type: 'line',
                source: 'route',
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                paint: getRouteStyleProperties()
            });
           } catch (error) {
            cleanupAndReject(`Error al añadir capa/fuente: ${error.message}`);
        }
    });
}

// ===================================================================
// NOMBRE: handleAddRadarHereClick 
// RESUMEN: Crea el radar en localStorage y luego redibuja la capa completa.
// ===================================================================
function handleAddRadarHereClick(button) {
    showRadarSpeedModal((selectedSpeed) => {
        if (selectedSpeed === null) {
            return;
        }

        button.disabled = true;
        const radarImg = button.querySelector('img');
        if (radarImg) radarImg.src = "PNG/RADAR.PNG";

        getCurrentLocation(
            (coords) => {
                const now = new Date();
                let radarText;
                if (selectedSpeed === 'TRAMO') {
                    radarText = `<b>RADAR: DE TRAMO (Añadido por el usuario)</b>`;
                } else {
                    radarText = `<b>RADAR: DE ${selectedSpeed} KM/H (Añadido por el usuario)</b>`;
                }

                const newRadarReminder = {
                    id: Date.now(),
                    text: radarText,
                    type: 'simple',
                    time: `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`,
                    date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                    createdAt: now.toISOString(),
                    managedByUser: false,
                    isLocationEnabled: true,
                    locationCoordinates: { latitude: coords.latitude, longitude: coords.longitude },
                    radiusMeters: 350,
                    excludeFromList: true
                };

                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                reminders.push(newRadarReminder);
                localStorage.setItem('reminders', JSON.stringify(reminders));
                
                showToast(`Radar de ${selectedSpeed === 'TRAMO' ? 'Tramo' : selectedSpeed + ' km/h'} creado en tu ubicación.`, "success");
                
                updateReminderCount();
                updateButtonStyles();
                markCacheAsDirty();
                
                if (navigationMapInstance) {
                    plotRemindersOnNavigationMap();
                    navigationMapInstance.flyTo({ center: [coords.longitude, coords.latitude], zoom: 15 });
                }
                
                button.disabled = false;
                if (radarImg) radarImg.src = "PNG/RADARAQUI.PNG";
            },
            (errorMsg) => {
                showToast(`Error al obtener ubicación para RADAR: ${errorMsg}`, "error");
                button.disabled = false;
                if (radarImg) radarImg.src = "PNG/RADARAQUI.PNG";
            }
        );
    });
}
    
// ===================================================================
// NOMBRE: proceedWithRecalculation 
// RESUMEN: Gestiona la lógica de recálculo de ruta según la acción del usuario.
async function proceedWithRecalculation(action) {
    if (!isNavigating || !navigationCurrentLocation) {
        showToast("No se puede recalcular: no se está navegando o la ubicación es desconocida.", "error");
        return;
    }
    if (action === 'skip_one') {
        const nextUnvisitedStageIndex = navigationWaypoints.findIndex(wp => wp && !wp.isInternal && !wp.isRecalculatedStart && !wp.visited && wp.type !== 'S' && wp.type !== 'S_Recalc' && wp.type !== 'F');
        if (nextUnvisitedStageIndex !== -1) {
            navigationWaypoints[nextUnvisitedStageIndex].visited = true;
            showToast(`Omitiendo etapa: ${navigationWaypoints[nextUnvisitedStageIndex].address || 'Siguiente' }`, "info");
        } else {
            showToast("No hay próximas etapas intermedias para omitir. Recalculando a destino.", "info");
        }
    } else if (action === 'skip_multiple') {
        const stagesToSkip = [];
        const currentHeading = navigationCurrentLocation.heading;
        navigationWaypoints.forEach(wp => {
            if (wp.visited || wp.type === 'S' || wp.type === 'S_Recalc' || wp.type === 'F') return;
            const bearingToWp = turf.bearing(
                turf.point([navigationCurrentLocation.longitude, navigationCurrentLocation.latitude]),
                turf.point([wp.lng, wp.lat])
            );
            let angleDiff = Math.abs(currentHeading - (bearingToWp < 0 ? bearingToWp + 360 : bearingToWp));
            if (angleDiff > 180) angleDiff = 360 - angleDiff;
            if (angleDiff > 110) {
                stagesToSkip.push(wp.id);
            }
        });
        if (stagesToSkip.length > 0) {
            navigationWaypoints.forEach(wp => {
                if (stagesToSkip.includes(wp.id)) wp.visited = true;
            });
            showToast(`Saltando ${stagesToSkip.length} etapas que han quedado atrás.`, "info");
        }
    }
    await recalculateAndDrawRoute(true);
}

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// NOMBRE: findChargingPointsOnRoute 
// RESUMEN: Busca PDRs de OCM y gestiona el estado de la búsqueda.
async function findChargingPointsOnRoute(powerFilters, searchConfig) {
    const pdrButton = document.getElementById('pdrs-ruta-button');
    if (pdrButton) pdrButton.classList.remove('pdr-search-highlight');

    clearChargingPoints();
    lastPdrSearchResults = [];
    
    showToast("Buscando puntos de recarga (OCM)...", "info", 0, false, "pdrs-search");

    const PDR_SEARCH_IN_VIEW_KEY = 'boardinggate_pdrSearchInView';
    const hasRoute = searchConfig.type === 'route';
    const searchInCurrentViewChecked = localStorage.getItem(PDR_SEARCH_IN_VIEW_KEY) === 'true';
    
    let apiUrl;

    if (searchInCurrentViewChecked) {
        const bounds = navigationMapInstance.getBounds();
        apiUrl = `https://api.openchargemap.io/v3/poi/?output=json&key=${OCM_API_KEY}&boundingbox=(${bounds.getSouthWest().lat},${bounds.getSouthWest().lng}),(${bounds.getNorthEast().lat},${bounds.getNorthEast().lng})&maxresults=1500&compact=false&verbose=true`;
        showToast("Buscando en la vista actual del mapa...", "info", 2000);
    } else if (hasRoute) {
        const routeSource = navigationMapInstance.getSource('route');
        if (!routeSource || !routeSource._data || !routeSource._data.geometry || !routeSource._data.geometry.coordinates || routeSource._data.geometry.coordinates.length < 2) {
            showToast("No hay ruta válida para buscar PDRs sobre ella.", "error");
            const existingToast = document.getElementById("pdrs-search");
            if (existingToast) existingToast.remove();
            return;
        }
        const routeBounds = new mapboxgl.LngLatBounds();
        routeSource._data.geometry.coordinates.forEach(coord => routeBounds.extend(coord));
        apiUrl = `https://api.openchargemap.io/v3/poi/?output=json&key=${OCM_API_KEY}&boundingbox=(${routeBounds.getSouthWest().lat},${routeBounds.getSouthWest().lng}),(${routeBounds.getNorthEast().lat},${routeBounds.getNorthEast().lng})&maxresults=1500&compact=false&verbose=true`;
    } else if (searchConfig.type === 'radius') {
        apiUrl = `https://api.openchargemap.io/v3/poi/?output=json&key=${OCM_API_KEY}&latitude=${searchConfig.center.lat}&longitude=${searchConfig.center.lng}&distance=${searchConfig.radiusKm}&distanceunit=km&maxresults=1000&compact=false&verbose=true`;
    } else {
        showToast("Tipo de búsqueda no válido.", "error");
        pdrSearchState = 'initial';
        return;
    }
    
    try {
        const response = await fetch(apiUrl);
        if (!response.ok) throw new Error(`Error de red de OCM: ${response.statusText}`);
        const data = await response.json();
        if (!data || !Array.isArray(data)) throw new Error("Respuesta de OCM no válida.");

        window.lastOcmApiResponse = data;

        const operatorFilterText = (document.getElementById('operator-filter-input')?.value || localStorage.getItem('boardinggate_operator_filter') || '').toLowerCase().trim();
        const operatorFilterWords = operatorFilterText ? operatorFilterText.split(/\s+/).filter(w => w) : [];
        
        const routeLineForDistanceCheck = (searchConfig.type === 'route' && navigationMapInstance.getSource('route') && navigationMapInstance.getSource('route')._data) ? turf.lineString(navigationMapInstance.getSource('route')._data.geometry.coordinates) : null;
        
        let filteredPoints = [];

        data.forEach(point => {
            const formattedPoint = formatOCMPoint(point);
            if (!formattedPoint) return;
            const power = parseFloat(formattedPoint.power);
            if (isNaN(power) || power < powerFilters.min || power > powerFilters.max) return;

            if (operatorFilterWords.length > 0) {
                const pointOperator = (formattedPoint.operator || '').toLowerCase();
                const pointAddress = (formattedPoint.address || '').toLowerCase();
                const operatorMatch = operatorFilterWords.some(word => 
                    pointOperator.includes(word) || pointAddress.includes(word)
                );
                if (!operatorMatch) return;
            }
            
            if (!searchInCurrentViewChecked && hasRoute && routeLineForDistanceCheck) {
                const pointTurf = turf.point([formattedPoint.lon, formattedPoint.lat]);
                const distanceKm = turf.pointToLineDistance(pointTurf, routeLineForDistanceCheck, { units: 'kilometers' });
                if (distanceKm <= searchConfig.distanceFilters.max) {
                    filteredPoints.push(formattedPoint);
                }
            } else { 
                filteredPoints.push(formattedPoint);
            }
        });
        
        lastPdrSearchResults = [...filteredPoints];
        currentChargingPointsOnRoute = [...filteredPoints];

        const cheapestBySegment = {
            '#5e5e5e': { price: Infinity, point: null },
            '#007863': { price: Infinity, point: null },
            'rgb(30, 144, 255)': { price: Infinity, point: null },
            '#de2e03': { price: Infinity, point: null }
        };

        const parsePrice = (priceString) => {
            if (priceString && typeof priceString === 'string') {
                const priceMatch = priceString.match(/(\d[\d,.]*)/);
                if (priceMatch && priceMatch[1]) {
                    const priceNum = parseFloat(priceMatch[1].replace(',', '.'));
                    if (!isNaN(priceNum) && priceNum > 0 && priceNum < 10) {
                        return priceNum;
                    }
                }
            }
            return Infinity;
        };

        currentChargingPointsOnRoute.forEach(point => {
            point.isCheapest = false;
            const power = parseFloat(point.power);
            const segmentColor = getChargingPointColorByPower(power);
            const price = parsePrice(point.price);
            
            if (cheapestBySegment[segmentColor] && price < cheapestBySegment[segmentColor].price) {
                cheapestBySegment[segmentColor].price = price;
                cheapestBySegment[segmentColor].point = point;
            }
        });

        for (const color in cheapestBySegment) {
            const cheapest = cheapestBySegment[color];
            if (cheapest.point) {
                cheapest.point.isCheapest = true;
            }
        }

        const existingToast = document.getElementById("pdrs-search");
        if (existingToast) existingToast.remove();
        showToast(`${currentChargingPointsOnRoute.length} PDRs encontrados.`, "success");
        displayChargingPointsOnMap();

        pdrSearchState = 'results_shown';

    } catch (error) {
        const existingToast = document.getElementById("pdrs-search");
        if (existingToast) existingToast.remove();
        showToast(`Error al buscar PDRs: ${error.message}`, "error");
        pdrSearchState = 'initial';
    }
}


// NOMBRE: updateUserIdDisplay
// RESUMEN: Muestra el ID de usuario en la pantalla si existe.
// ===================================================================
function updateUserIdDisplay() {
    const userIdDisplay = document.getElementById('user-id-display');
    const userId = localStorage.getItem('userData_userId');
    if (userIdDisplay) {
        if (userId) {
            userIdDisplay.textContent = userId.trim();
            userIdDisplay.style.display = 'block';
        } else {
            userIdDisplay.textContent = '';
            userIdDisplay.style.display = 'none';
        }
    }
}

// ===================================================================
// NOMBRE: handleGpsSimulationToggle 
// RESUMEN: Activa/desactiva el modo de simulación GPS. Si hay una ruta cargada al activar, muestra el modal de selección de velocidad y tipo de simulación.
function handleGpsSimulationToggle() {
    const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
    const mapDiv = document.getElementById('reminders-location-map-div');
    if (isSimulatingGpsLocation) { 
        if (isSimulatingFreeDrive) {
            stopFreeDrive();
            isSimulatingFreeDrive = false; 
        }
        
        stopAutomatedRouteSimulationInternal(); 
        isSimulatingGpsLocation = false;
        reactivateRealGpsAfterSimulation();
        if (mapDiv) mapDiv.classList.remove('simulating-gps-click-mode');
        if (simulateGpsButton) {
            simulateGpsButton.classList.remove('active-simulate-gps-mode'); 
            simulateGpsButton.title = "Activar Simulación GPS (recorrido automático o clic manual)";
        }
      
        showToast("Modo simulación GPS desactivado. Volviendo a GPS real.", "info");
    } else { 
        if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0] && navigationWaypoints.filter(wp => !wp.isInternal && !wp.isRecalculatedStart).length >= 2) {
            showSimulationSpeedModal(simulationSpeedKmph, (newSpeed) => {
                startAutomatedRouteSimulation(newSpeed); 
                if (mapDiv) mapDiv.classList.remove('simulating-gps-click-mode'); 
            });
        } else {
            isSimulatingGpsLocation = true;
            if (simulateGpsButton) simulateGpsButton.classList.add('active-simulate-gps-mode'); 
            if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode'); 
            showToast("Modo simulación GPS por clic ACTIVADO. Carga una ruta para recorrido automático o toca el mapa.", "info", 6000);
        }
    }
    setNavigationMapClickHandler();
}

// ===================================================================
// NOMBRE: deleteFilteredRadars 
// RESUMEN: Borra radares y limpia la caché para forzar su reconstrucción.
async function deleteFilteredRadars() {
    window.radarsCache = null;
    window.radarsSpatialIndex = null;
    localStorage.removeItem('radarsCacheData');
    localStorage.removeItem('radarsCacheIndex');
    localStorage.removeItem('radarsCacheVersion');
    
    const latFilterValue = document.getElementById('radar-filter-lat').value.trim();
    const lonFilterValue = document.getElementById('radar-filter-lon').value.trim();
    const keywordsFilterRaw = document.getElementById('radar-filter-keywords').value.trim().toUpperCase();
    const keywordsFilter = keywordsFilterRaw ? keywordsFilterRaw.split(/\s+/).filter(k => k) : [];
    const statusMessage = document.getElementById('radar-import-status');
    const progressContainer = document.getElementById('radar-import-progress-container');
    const noFiltersProvided = !latFilterValue && !lonFilterValue && keywordsFilter.length === 0;
    let confirmationMessage = "";
    if (noFiltersProvided) {
        confirmationMessage = "¿Estás seguro de que quieres borrar TODOS los recordatorios tipo RADAR/POI (ya que no has especificado ningún filtro)? Esta acción no se puede deshacer.";
    } else {
        confirmationMessage = "¿Estás seguro de que quieres borrar los recordatorios tipo RADAR/POI que coincidan con los filtros actuales? Esta acción no se puede deshacer.";
    }
    if (!confirm(confirmationMessage)) {
        showToast("Borrado cancelado", "info");
        return;
    }
    progressContainer.style.display = 'block';
    const progressBar = document.getElementById('radar-import-progress-bar');
    if(progressBar) progressBar.style.display = 'none';
    statusMessage.textContent = 'Borrando recordatorios...';
    statusMessage.style.color = '';
    try {
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        let originalLength = reminders.length;
        reminders = reminders.filter(r => {
            const isRadarType = r.isLocationEnabled && (r.text.toUpperCase().includes("RADAR") || r.excludeFromList);
            if (!isRadarType) return true;
            if (noFiltersProvided) {
                return false;
            }
            let matchesKeywords = true;
            if (keywordsFilter.length > 0) {
                matchesKeywords = keywordsFilter.some(kw => r.text.toUpperCase().includes(kw));
            }
            let matchesLat = true;
            if (latFilterValue) {
                if (r.locationCoordinates) {
                    matchesLat = parseCoordinateFilter(latFilterValue, r.locationCoordinates.latitude);
                } else {
                    matchesLat = false;
                }
            }
            let matchesLon = true;
            if (lonFilterValue) {
                if (r.locationCoordinates) {
                    matchesLon = parseCoordinateFilter(lonFilterValue, r.locationCoordinates.longitude);
                } else {
                    matchesLon = false;
                }
            }
            return !(matchesKeywords && matchesLat && matchesLon);
        });
        localStorage.setItem('reminders', JSON.stringify(reminders));
        const numDeleted = originalLength - reminders.length;
        statusMessage.textContent = `Borrado completo. ${numDeleted} recordatorios eliminados.`;
        statusMessage.style.color = '#28a745';
        showToast(`${numDeleted} recordatorios eliminados`, 'success');
        updateReminderCount();
        updateButtonStyles();
        markCacheAsDirty();
    } catch (error) {
        statusMessage.textContent = `Error: ${error.message}`;
        statusMessage.style.color = 'red';
        showToast('Error durante el borrado', 'error');
    } finally {
        setTimeout(() => {
            progressContainer.style.display = 'none';
            if(progressBar) progressBar.style.display = 'block';
            statusMessage.style.color = '';
        }, 3000);
    }
}

// ===================================================================
// NOMBRE: handleMapClickToAddReminder 
// RESUMEN: Maneja el clic para añadir un recordatorio en el mapa.
function handleMapClickToAddReminder(e) {
    if (!isAddReminderAtLocationModeActive || !navigationMapInstance) return;
    const latlng = e.lngLat;
    toggleAddReminderAtLocationMode(); 
    const mapContextBeforeModal = sessionStorage.getItem('mapContext');
    sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
    if (mapContextBeforeModal) {
      sessionStorage.setItem('mapContext', mapContextBeforeModal);
    }
    showReminderModal({
        isLocationEnabled: true,
        locationCoordinates: { latitude: latlng.lat, longitude: latlng.lng },
        radiusMeters: DEFAULT_LOCATION_RADIUS,
        text: 'Recordatorio en mapa: ',
        excludeFromList: false
    }, { onTopOfMap: true });
}

    
// ===================================================================
// NOMBRE: showReorderStagesModal 
// RESUMEN: Se corrige el bug crítico que truncaba los IDs de las etapas al leerlos
function showReorderStagesModal() {
    if (isNavigating) {
        showToast("No se puede reordenar etapas mientras se navega.", "warning");
        return;
    }
    const actualWaypointsForReorder = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    if (actualWaypointsForReorder.length < 2) {
        showToast("Se necesitan al menos 2 puntos para reordenar", "warning");
        return;
    }

    const modal = document.getElementById('reorder-stages-modal');
    const listElement = modal.querySelector('#sortable-stages-list');

    
    listElement.innerHTML = '';
    
    actualWaypointsForReorder.forEach(async (wp) => {
        const li = document.createElement('li');
        li.dataset.id = wp.id;

        const dragHandle = document.createElement('span');
        dragHandle.className = 'drag-handle';
        dragHandle.innerHTML = '<img src="PNG/MOVER.PNG" alt="Mover etapa">';
        dragHandle.title = 'Arrastrar para reordenar';
        dragHandle.draggable = true;

        const badge = document.createElement('span');
        badge.className = 'stage-label-badge';
        badge.textContent = wp.label;

        const nameSpan = document.createElement('span');
        nameSpan.className = 'stage-name-text';
        nameSpan.textContent = wp.address || `Cargando... (${wp.lat.toFixed(3)}, ${wp.lng.toFixed(3)})`;
        if (!wp.address) {
             wp.address = await getAddressForWaypoint(wp.lat, wp.lng);
             nameSpan.textContent = wp.address;
        }

        const deleteButton = document.createElement('span');
        deleteButton.className = 'delete-stage-button';
        deleteButton.innerHTML = '×';
        deleteButton.title = 'Eliminar esta etapa';

        deleteButton.addEventListener('click', (e) => {
            e.stopPropagation();
            const listItem = e.target.closest('li');
            if (listItem) {
                listItem.remove();
            }
        });

        li.appendChild(dragHandle);
        li.appendChild(badge);
        li.appendChild(nameSpan);
        li.appendChild(deleteButton);
        listElement.appendChild(li);
    });

    modal.classList.remove('hidden');
    
    const confirmButton = modal.querySelector('#confirm-reorder-stages');
    const cancelButton = modal.querySelector('#cancel-reorder-stages');
    
    const newConfirmButton = confirmButton.cloneNode(true);
    confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
    const newCancelButton = cancelButton.cloneNode(true);
    cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);
    
    const closeReorderModal = () => {
        clearModalAutoCloseTimer(modal, newConfirmButton, 'reorder-stages-modal');
        modal.classList.add('hidden');
        listElement.removeEventListener('dragstart', handleDragStartReorder);
        listElement.removeEventListener('dragend', handleDragEndReorder);
        listElement.removeEventListener('dragover', handleDragOverReorder);
        listElement.removeEventListener('touchstart', handleStageTouchStart);
        listElement.removeEventListener('touchmove', handleStageTouchMove);
        listElement.removeEventListener('touchend', handleStageTouchEnd);
        listElement.removeEventListener('touchcancel', handleStageTouchEnd);
        document.body.style.overflow = '';
    };

    newConfirmButton.addEventListener('click', async () => {
        const orderedLiElements = Array.from(listElement.children);
        
        const finalWaypointIds = orderedLiElements.map(li => parseFloat(li.dataset.id));
        clearAllWaypointMarkersFromMap();

        if (finalWaypointIds.length < 2) {
            navigationWaypoints = [];
            handleLoadOrDeleteRouteClick(null);
            closeReorderModal();
            return;
        }

        try {
            const waypointMap = new Map(navigationWaypoints.map(wp => [wp.id, wp]));
            
            const userWaypointsInNewOrder = [];
            finalWaypointIds.forEach(id => {
                if (waypointMap.has(id)) {
                    userWaypointsInNewOrder.push(waypointMap.get(id));
                }
            });
            
            const recalcStartPoint = navigationWaypoints.find(wp => wp && wp.isRecalculatedStart);
            navigationWaypoints = recalcStartPoint ? [recalcStartPoint, ...userWaypointsInNewOrder] : [...userWaypointsInNewOrder];
            
            const safeFinalWaypoints = navigationWaypoints.map(wp => ({ id: wp.id, address: wp.address, type: wp.type, label: wp.label, isInternal: wp.isInternal }));
            
            await updateWaypointTypesAndLabels();
            renderWaypointMarkers();
            
            await recalculateAndDrawRoute();

        } catch (error) {
            console.error("[DEBUG] Error capturado en el bloque `try` del modal al intentar recalcular:", error);
        } finally {
            closeReorderModal();
            updateStartNavigationButtonState();
            updateNavigationButtonColor();
        }
    });
    
    newCancelButton.addEventListener('click', () => {
        showToast("Reordenación cancelada.", "info");
        closeReorderModal();
        if (navigationWaypoints.length >= 2) {
            renderWaypointMarkers();
            recalculateAndDrawRoute().catch(() => {});
        } else {
            handleLoadOrDeleteRouteClick(null);
        }
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
    });

    addModalAutoCloseTimer(modal, newConfirmButton, 'reorder-stages-modal', 60000);
    
    listElement.addEventListener('dragstart', handleDragStartReorder);
    listElement.addEventListener('dragend', handleDragEndReorder);
    listElement.addEventListener('dragover', handleDragOverReorder);
    listElement.addEventListener('touchstart', handleStageTouchStart, { passive: false });
    listElement.addEventListener('touchmove', handleStageTouchMove, { passive: false });
    listElement.addEventListener('touchend', handleStageTouchEnd);
    listElement.addEventListener('touchcancel', handleStageTouchEnd);
}
    
// ===================================================================
// NOMBRE: updateProgressBarLockIcon 
// RESUMEN: Actualiza el icono del candado en la barra de progreso según su estado.
function updateProgressBarLockIcon() {
    const lockButton = document.getElementById('toggle-progress-bar-lock');
    if (!lockButton) return;
    const img = lockButton.querySelector('img');
    if (img) {
        if (isProgressBarLocked) {
            img.src = "PNG/IMG_4281.png";
            lockButton.title = "Panel de progreso BLOQUEADO. Púlsame para activar auto-ocultación.";
        } else {
            img.src = "PNG/IMG_4280.png";
            lockButton.title = "Panel de progreso DESBLOQUEADO. Se ocultará automáticamente. Púlsame para bloquearlo.";
        }
    }
}

// ===================================================================
// NOMBRE: Lógica de Pre-carga de GPS
// RESUMEN: Obtiene la ubicación del GPS al cargar la página para acelerar la apertura del mapa.
// ===================================================================
let preloadedGpsPosition = null;

function preloadGpsLocation() {
    if ('geolocation' in navigator) {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                console.log("GPS position pre-loaded successfully for faster map opening.");
                preloadedGpsPosition = {
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy,
                    altitude: position.coords.altitude,
                    heading: position.coords.heading,
                    speed: position.coords.speed
                };
            },
            (error) => {
                console.warn("Could not pre-load GPS position:", error.message);
            },
            { 
                enableHighAccuracy: true, 
                timeout: 15000,      
                maximumAge: 60000    
            }
        );
    }
}    

// ===================================================================
// NOMBRE: getGpsWithRetries 
// RESUMEN: Lógica de fallback que busca el GPS con reintentos y muestra un toast.
// ===================================================================
async function getGpsWithRetries() {
    const toastId = "gps-locate-toast";
    showToast("LOCALIZANDO VEHÍCULO...", "info", 0, false, toastId);
    
    let retries = 0;
    const MAX_RETRIES = 10; // Límite de 10 reintentos para no entrar en un bucle infinito

    while (retries < MAX_RETRIES) {
        try {
            const coords = await getCurrentLocationAsync();
            const loadingToast = document.getElementById(toastId);
            if (loadingToast) loadingToast.remove();
            return coords;
        } catch (error) {
            retries++;
            const message = `No se pudo obtener la ubicación. Reintentando en 3s... (${retries}/${MAX_RETRIES})`;
            showToast(message, "warning", 0, false, toastId);
            await new Promise(resolve => setTimeout(resolve, 3000));
        }
    }

    const loadingToast = document.getElementById(toastId);
    if (loadingToast) loadingToast.remove();
    showToast("Fallo al obtener la ubicación tras varios intentos. Revise los permisos.", "error");
    throw new Error("Fallo al obtener la ubicación GPS tras múltiples reintentos.");
}

// ===================================================================
// NOMBRE: getInitialGpsPositionForMap
// RESUMEN: Devuelve la ubicación GPS precargada si existe, o inicia una nueva búsqueda si no.
async function getInitialGpsPositionForMap() {
    if (preloadedGpsPosition) {
        console.log("Using pre-loaded GPS position for faster map display.");
        const positionToReturn = { ...preloadedGpsPosition }; // Crea una copia
        preloadedGpsPosition = null; // Anula la variable para que solo se use una vez
        return positionToReturn;
    } else {
        return getGpsWithRetries();
    }
}




    
 // ===================================================================
// NOMBRE: updateTurnByTurnDisplay (VERSIÓN FINAL Y COMPLETA)
// RESUMEN: Utiliza la función formatDeviation que devuelve HTML para asegurar
//          que la mini-tarjeta se muestre correctamente.
// ===================================================================
function updateTurnByTurnDisplay(route, carDistanceAlongTheRoute = 0) {
    const topInfoBar = document.getElementById('navigation-top-info-bar');
    const intersectionPreviewWindow = document.getElementById('intersection-preview-map-window');
    const miniNavCard = document.getElementById('mini-nav-info-card'); 

    if (!route || !topInfoBar || !route.legs || route.legs.length === 0) {
        if (topInfoBar) topInfoBar.style.display = 'none';
        if (miniNavCard) miniNavCard.style.display = 'none'; 
        if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
        nextManeuverStepForPreview = null;
        return;
    }
    if (!isNavigating && (!navigationCurrentRouteData || navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2)) {
         if (topInfoBar) topInfoBar.style.display = 'none';
         if (miniNavCard) miniNavCard.style.display = 'none'; 
         if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
         nextManeuverStepForPreview = null;
         return;
    }

    const carDistance = Math.min(Math.max(0, carDistanceAlongTheRoute), route.distance);
    
    let currentLegIndex = -1, currentStepIndex = -1;
    let distanceToEndOfCurrentStepForProgress = 0;
    
    let searchLegIndex = currentLegIndexNav;
    let searchStepIndex = currentStepIndexNav;

    if (searchLegIndex >= route.legs.length || 
        !route.legs[searchLegIndex] || 
        searchStepIndex >= route.legs[searchLegIndex].steps.length ||
        (route.legs[searchLegIndex].steps[searchStepIndex].cumulativeDistance || 0) > carDistance) {
        searchLegIndex = 0;
        searchStepIndex = 0;
    }

    let stepFound = false;
    for (let i = searchLegIndex; i < route.legs.length; i++) {
        const leg = route.legs[i];
        if (!leg || !leg.steps) continue;
        const startStepSearch = (i === searchLegIndex) ? searchStepIndex : 0;
        for (let j = startStepSearch; j < leg.steps.length; j++) {
            const step = leg.steps[j];
            if (step && typeof step.cumulativeDistance === 'number' && (step.cumulativeDistance + (step.distance || 0)) > carDistance) {
                currentLegIndex = i;
                currentStepIndex = j;
                stepFound = true;
                break;
            }
        }
        if (stepFound) break;
    }

    if (currentLegIndex === -1) {
        currentLegIndex = route.legs.length - 1;
        if (route.legs[currentLegIndex] && route.legs[currentLegIndex].steps) {
            currentStepIndex = route.legs[currentLegIndex].steps.length - 1;
        } else {
            return;
        }
    }
    
    const currentStepForProgress = route.legs[currentLegIndex].steps[currentStepIndex];
    distanceToEndOfCurrentStepForProgress = currentStepForProgress.cumulativeDistance + (currentStepForProgress.distance || 0); 
    
    currentLegIndexNav = currentLegIndex;
    currentStepIndexNav = currentStepIndex;

    const waypointsForRequest = navigationWaypoints.filter(wp => wp);
    
    let finalStepToShow;
    let tempLegIdx = currentLegIndex;
    let tempStepIdx = currentStepIndex + 1;

    while (true) {
        if (tempLegIdx >= route.legs.length) {
            finalStepToShow = route.legs[route.legs.length - 1].steps[route.legs[route.legs.length - 1].steps.length - 1];
            break;
        }
        let leg = route.legs[tempLegIdx];
        if (tempStepIdx >= leg.steps.length) {
            tempLegIdx++;
            tempStepIdx = 0;
            continue;
        }
        const candidateStep = leg.steps[tempStepIdx];
        const isArrival = candidateStep.maneuver.type === 'arrive';
        const isDeparture = candidateStep.maneuver.type === 'depart';
        const arrivalWaypoint = isArrival ? waypointsForRequest[tempLegIdx + 1] : null; 
        const departureWaypoint = isDeparture ? waypointsForRequest[tempLegIdx] : null;

        if ((isArrival && arrivalWaypoint?.isInternal) || (isDeparture && departureWaypoint?.isInternal)) {
            tempStepIdx++;
            continue;
        } else {
            finalStepToShow = candidateStep;
            break;
        }
    }
    let nextStepToDisplay = finalStepToShow;
    nextManeuverStepForPreview = nextStepToDisplay;

    const distanceToNextManeuver = Math.max(0, distanceToEndOfCurrentStepForProgress - carDistance);
    const distanceIntoCurrentStep = currentStepForProgress.distance - distanceToNextManeuver;
    const now = Date.now();
    const infoOverlay = document.getElementById('map-info-overlay');
    const progressBar = document.getElementById('navigation-bottom-progress-bar');
    
    if (!isProgressBarLocked && !isMapImmersiveModeActive && now > progressBarForceShowUntil) {
        const shouldHide = distanceToNextManeuver > 1000 && distanceIntoCurrentStep > 100;
        progressBar.classList.toggle('progress-bar-auto-hidden', shouldHide);
        if (infoOverlay) {
            infoOverlay.style.display = shouldHide ? 'none' : 'block';
        }
        if (miniNavCard) {
            if (shouldHide) {
                const distanceText = distanceToNextManeuver < 1000 ? `${Math.round(distanceToNextManeuver / 5) * 5} m` : `${(distanceToNextManeuver / 1000).toFixed(1)} km`;
                let etaHtml = '';
                const remainingDistanceTotal = Math.max(0, route.distance - carDistanceAlongTheRoute);
                const remainingDurationTotal = route.distance > 0 ? route.duration * (remainingDistanceTotal / route.distance) : 0;
                const currentFinalEta = new Date(Date.now() + remainingDurationTotal * 1000);

                if (isNavigating && tripInitialOverallEtaTime) {
                    const etaText = currentFinalEta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    const finalDeviationMs = currentFinalEta.getTime() - tripInitialOverallEtaTime.getTime();
                    const deviationHtml = formatDeviationForMiniCard(finalDeviationMs);
                    etaHtml = `<div style="font-size: 0.80em; margin-top: 2px; text-align: center; "><span>${etaText}</span><span style="margin-left: 8px;">${deviationHtml}</span></div>`;
                }
                const newMiniCardHtml = `<div>${distanceText}</div>${etaHtml}`;
                if (miniNavCard.innerHTML !== newMiniCardHtml) {
                    miniNavCard.innerHTML = newMiniCardHtml;
                }
                miniNavCard.style.display = 'block';
            } else {
                miniNavCard.style.display = 'none';
            }
        }
    } else {
        progressBar.classList.remove('progress-bar-auto-hidden');
        if (infoOverlay) {
            infoOverlay.style.display = 'block';
        }
        if (miniNavCard) {
            miniNavCard.style.display = 'none';
        }
    }
    
    const turnIconDisplayEl = document.getElementById('turn-icon-display');
    const maneuverTextEl = document.getElementById('maneuver-text-display');
    const distanceFormattedEl = document.getElementById('distance-to-turn-formatted');
    const streetEl = document.getElementById('street-name-display');
    const progressBarEl = document.getElementById('distance-progress-bar-to-turn');

    if (nextStepToDisplay && nextStepToDisplay.maneuver) {
        const maneuver = nextStepToDisplay.maneuver;
        const type = maneuver.type || '';
        const maneuverText = getManeuverInstructionText(maneuver);
        const streetNameText = (type === 'depart' || type.includes('roundabout') || type === 'end of road') ? '' : (nextStepToDisplay.name || '');
        
        if (turnIconDisplayEl) {
            const iconFilename = getManeuverIconFilename(maneuver);
            if (iconFilename !== lastDisplayedManeuverIcon) {
                turnIconDisplayEl.innerHTML = `<img src="https://boardinggate.github.io/Tesla/${iconFilename}" alt="${maneuverText}" style="width: 95%; height: 95%; object-fit: contain;">`;
                lastDisplayedManeuverIcon = iconFilename;
            }
        }
        
        const newManeuverText = maneuverText ? `${maneuverText} ` : '';
        if (maneuverTextEl.textContent !== newManeuverText) {
            maneuverTextEl.textContent = newManeuverText;
        }
        if (streetEl.textContent !== streetNameText) {
            streetEl.textContent = streetNameText;
        }
        
        distanceToNextManeuverOSRM = distanceToNextManeuver;
        const newDistanceText = distanceToNextManeuver < 1000 ? `${Math.round(distanceToNextManeuver / 5) * 5} m` : `${(distanceToNextManeuver / 1000).toFixed(1)} km`;
        if (distanceFormattedEl.textContent !== newDistanceText) {
            distanceFormattedEl.textContent = newDistanceText;
        }

        const progressPercent = (currentStepForProgress.distance > 0) ? ((currentStepForProgress.distance - distanceToNextManeuver) / currentStepForProgress.distance) * 100 : (distanceToNextManeuver === 0 ? 100 : 0);
        const newWidthPercent = `${Math.min(100, Math.max(0, progressPercent))}%`;
        if (progressBarEl && progressBarEl.style.width !== newWidthPercent) {
            progressBarEl.style.width = newWidthPercent;
        }

        const isRelevantIntersectionManeuver = type !== 'continue' && type !== 'new name' && type !== 'depart' && type !== 'straight';
        if (isNavigating && distanceToNextManeuver < 800 && distanceToNextManeuver >= 100 && isRelevantIntersectionManeuver && (!intersectionPreviewWindow || intersectionPreviewWindow.classList.contains('hidden') || intersectionPreviewWindow.dataset.source !== 'click') && (currentLegIndex + '_' + currentStepIndex) !== lastAutoShownManeuverId) {
            showIntersectionPreviewMap(nextStepToDisplay, route, false, 10000);
            lastAutoShownManeuverId = currentLegIndex + '_' + currentStepIndex;
        } else if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click' && (distanceToNextManeuver >= 800 || distanceToNextManeuver < 100 || !isRelevantIntersectionManeuver)) {
            hideIntersectionPreviewMap();
        }

    } else {
        if (turnIconDisplayEl) {
            const iconFilename = 'PNG/arrive.png';
            if (iconFilename !== lastDisplayedManeuverIcon) {
                turnIconDisplayEl.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/arrive.png" style="width:95%; height:95%; object-fit:contain;">`;
                lastDisplayedManeuverIcon = iconFilename;
            }
        }
        if (maneuverTextEl.textContent !== '') maneuverTextEl.textContent = '';
        if (streetEl.textContent !== 'Has llegado a tu destino') streetEl.textContent = 'Has llegado a tu destino';
        if (distanceFormattedEl.textContent !== '0 m') distanceFormattedEl.textContent = '0 m';
        if (progressBarEl && progressBarEl.style.width !== '100%') progressBarEl.style.width = '100%';
        
        distanceToNextManeuverOSRM = Infinity;
        nextManeuverStepForPreview = null;
        if (miniNavCard) miniNavCard.style.display = 'none';
        if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
    }
}   

// ===================================================================
// NOMBRE: updateNavigationProgressDisplay
// RESUMEN: Incluye la optimización de caché de UI para la tarjeta del
function updateNavigationProgressDisplay(route, carDistanceAlongTheRoute = 0) {
    const progressBarContainer = document.getElementById('navigation-bottom-progress-bar');
    if (!progressBarContainer) return;

    const topInfoBar = document.getElementById('navigation-top-info-bar');
    const overallProgressContainer = document.getElementById('route-overall-progress-container');
    const etaInfoContainer = document.getElementById('navigation-eta-info');
    const distanceBar = document.getElementById('distance-progress-bar-to-turn-container');
    const hrSeparator = progressBarContainer.querySelector('hr');
    let freeDriveCard = document.getElementById('free-drive-stats-card');
    
    if (isFreeDriveActive) {
        progressBarContainer.style.display = 'flex';
        progressBarContainer.style.minWidth = 'auto';
        progressBarContainer.style.width = 'auto';
        if (topInfoBar) topInfoBar.style.display = 'none';
        if (overallProgressContainer) overallProgressContainer.style.display = 'none';
        if (etaInfoContainer) etaInfoContainer.style.display = 'none';
        if (distanceBar) distanceBar.style.display = 'none';
        if (hrSeparator) hrSeparator.style.display = 'none';
    } else if (route && typeof route.distance === 'number') {
        progressBarContainer.style.display = 'flex';
        progressBarContainer.style.minWidth = '480px';
        progressBarContainer.style.width = 'auto';
        if (topInfoBar) topInfoBar.style.display = 'flex';
        if (overallProgressContainer) overallProgressContainer.style.display = 'block';
        if (etaInfoContainer) etaInfoContainer.style.display = 'flex';
        if (distanceBar) distanceBar.style.display = 'block';
        if (hrSeparator) hrSeparator.style.display = 'block';
    } else {
        progressBarContainer.style.display = 'none';
        return;
    }
  
    if (isFreeDriveActive) {
        if (!freeDriveCard) {
            freeDriveCard = document.createElement('div');
            freeDriveCard.id = 'free-drive-stats-card';
            progressBarContainer.appendChild(freeDriveCard);
        }
        freeDriveCard.style.display = 'block';

        const kmRealizadosTexto = `${(totalDistanceTravelledForStats / 1000).toFixed(1)} km`;
        const startTime = freeDriveStats ? freeDriveStats.startTime : new Date();
        const startTimeFormatted = `${startTime.getHours().toString().padStart(2, '0')}:${startTime.getMinutes().toString().padStart(2, '0')}`;
        const durationMs = Date.now() - startTime.getTime();
        const totalTravelSeconds = Math.floor(durationMs / 1000); 
        const travelHours = Math.floor(totalTravelSeconds / 3600);
        const travelMinutes = Math.floor((totalTravelSeconds % 3600) / 60);
        const travelSeconds = totalTravelSeconds % 60;
        const travelTimeFormatted = `${String(travelHours).padStart(2, '0')}:${String(travelMinutes).padStart(2, '0')}:${String(travelSeconds).padStart(2, '0')}`;
       
        const newFreeDriveHTML = `
            <div class="free-drive-card-content">
                <div class="fd-title">Modo Free Drive</div>
                <div class="fd-stats-grid">
                    <div class="fd-label">Distancia</div>
                    <div class="fd-label">Inicio</div>
                    <div class="fd-label">Duración</div>
                    <div class="fd-data">${kmRealizadosTexto}</div>
                    <div class="fd-data">${startTimeFormatted}</div>
                    <div class="fd-data">${travelTimeFormatted}</div>
                </div>
            </div>
        `;
        if (freeDriveCard.innerHTML !== newFreeDriveHTML) {
            freeDriveCard.innerHTML = newFreeDriveHTML;
        }
        return;
    }

    if (freeDriveCard) {
        freeDriveCard.style.display = 'none';
    }
    
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    if (!route || typeof route.distance !== 'number' || typeof route.duration !== 'number' || actualWaypoints.length < 2) {
        return;
    }
    const overallProgressFill = document.getElementById('route-overall-progress');
    const routeProgressTextEl = document.getElementById('route-progress-text');
    const routeProgressIconEl = document.getElementById('route-progress-icon');
    const nextStageDistEl = document.getElementById('next-stage-distance');
    const nextStageTimeEl = document.getElementById('next-stage-time');
    const nextStageEtaEl = document.getElementById('next-stage-eta');
    const nextStageDeviationEl = document.getElementById('next-stage-eta-deviation');
    const finalDestDistEl = document.getElementById('final-destination-distance');
    const finalDestTimeEl = document.getElementById('final-destination-time');
    const finalDestEtaEl = document.getElementById('final-destination-eta');
    const finalDestDeviationEl = document.getElementById('final-destination-eta-deviation');
    const nextStageInfoDiv = document.getElementById('next-stage-info');
    const finalDestInfoDiv = document.getElementById('final-destination-info');
    const nextStageLabelEl = document.getElementById('next-stage-label');
    const totalJourneyDistanceForBar = (accumulatedDistanceBeforeCurrentSegment || 0) + route.distance;
    const currentJourneyDistanceForBar = (accumulatedDistanceBeforeCurrentSegment || 0) + carDistanceAlongTheRoute;
    const progressPercent = totalJourneyDistanceForBar > 0 ? (currentJourneyDistanceForBar / totalJourneyDistanceForBar) * 100 : 0;
    
    const newOverallWidth = `${Math.min(100, progressPercent)}%`;
    if (overallProgressFill.style.width !== newOverallWidth) {
        overallProgressFill.style.width = newOverallWidth;
    }
    if (routeProgressIconEl) {
        const shouldDisplayIcon = progressPercent > 0 && progressPercent < 100;
        if ((routeProgressIconEl.style.display === 'none') === shouldDisplayIcon) {
            routeProgressIconEl.style.display = shouldDisplayIcon ? 'block' : 'none';
        }
    }
    if (routeProgressTextEl) {
        let kmRecorridosTexto = isNavigating && navigationStartTimeForStats ? `${(totalDistanceTravelledForStats / 1000).toFixed(1)} km` : "0.0 km";
        let timeInfoString = isNavigating && navigationStartTimeForStats ? ` (${navigationStartTimeForStats.getHours().toString().padStart(2, '0')}:${navigationStartTimeForStats.getMinutes().toString().padStart(2, '0')} • ${String(Math.floor((Date.now() - navigationStartTimeForStats) / 3600000)).padStart(2, '0')}:${String(Math.floor(((Date.now() - navigationStartTimeForStats) % 3600000) / 60000)).padStart(2, '0')})` : ` (Stop)`;
        
        const newProgressTextHtml = `${kmRecorridosTexto}${timeInfoString}`;
        if (routeProgressTextEl.innerHTML !== newProgressTextHtml) {
            routeProgressTextEl.innerHTML = newProgressTextHtml;
        }
    }
    const remainingDistanceTotal = Math.max(0, route.distance - carDistanceAlongTheRoute);
    const remainingDurationTotal = route.distance > 0 ? route.duration * (remainingDistanceTotal / route.distance) : 0;
    
    const finalDistText = `${(remainingDistanceTotal / 1000).toFixed(1)} km`;
    if (finalDestDistEl.textContent !== finalDistText) finalDestDistEl.textContent = finalDistText;

    const finalDestTotalMinutes = Math.round(remainingDurationTotal / 60);
    const finalTimeText = `${String(Math.floor(finalDestTotalMinutes / 60)).padStart(2, '0')}:${String(finalDestTotalMinutes % 60).padStart(2, '0')}`;
    if (finalDestTimeEl.textContent !== finalTimeText) finalDestTimeEl.textContent = finalTimeText;

    const currentFinalEta = new Date(Date.now() + remainingDurationTotal * 1000);
    const finalEtaText = currentFinalEta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    if (finalDestEtaEl.textContent !== finalEtaText) finalDestEtaEl.textContent = finalEtaText;

    let finalDeviationHtml = "";
    if (tripInitialOverallEtaTime && isNavigating && navigationStartTimeForStats) {
        const finalDeviationMs = currentFinalEta.getTime() - tripInitialOverallEtaTime.getTime();
        finalDeviationHtml = formatDeviation(finalDeviationMs);
    }
    
    if (finalDestDeviationEl.innerHTML !== finalDeviationHtml) {
        finalDestDeviationEl.innerHTML = finalDeviationHtml;
    }
    
    const hasUnvisitedIntermediateStages = actualWaypoints.some(wp => !wp.visited && wp.type === 'intermediate');
    if (hasUnvisitedIntermediateStages) {
        etaInfoContainer.classList.remove('single-destination');
        finalDestInfoDiv.classList.remove('single-destination-layout');
        nextStageInfoDiv.style.display = 'block';
        const totalRealStages = actualWaypoints.length - 1;
        const currentRealStageIndex = actualWaypoints.findIndex(wp => !wp.visited && wp.type !== 'S') -1;
        const nextStageWaypointObject = actualWaypoints.find(wp => !wp.visited && wp.type !== 'S');
        if (nextStageLabelEl && nextStageWaypointObject) {
            let stageDescription = nextStageWaypointObject.address || `Etapa ${nextStageWaypointObject.label}`;
            if (stageDescription.length > 20) {
                stageDescription = stageDescription.substring(0, 20) + '...';
            }
            const newLabelText = `Etapa ${currentRealStageIndex + 1} de ${totalRealStages}: ${stageDescription}`;
            if (nextStageLabelEl.textContent !== newLabelText) {
                nextStageLabelEl.textContent = newLabelText;
            }
        }
        let cumulativeDistanceToStartOfCurrentLegOSRM = 0;
        if (route.legs) {
            for (let i = 0; i < currentLegIndexNav; i++) {
                if (route.legs[i] && typeof route.legs[i].distance === 'number') {
                    cumulativeDistanceToStartOfCurrentLegOSRM += route.legs[i].distance;
                }
            }
        }
        const legForDisplay = route.legs[currentLegIndexNav];
        if (legForDisplay) {
            const distanceIntoCurrentLegDisplay = Math.max(0, carDistanceAlongTheRoute - cumulativeDistanceToStartOfCurrentLegOSRM);
            const remainingDistanceThisLegDisplay = Math.max(0, (legForDisplay.distance || 0) - distanceIntoCurrentLegDisplay);
            const remainingDurationThisLegDisplay = (legForDisplay.distance > 0 && typeof legForDisplay.duration === 'number') ? legForDisplay.duration * (remainingDistanceThisLegDisplay / legForDisplay.distance) : 0;
            const currentNextStageEta = new Date(Date.now() + remainingDurationThisLegDisplay * 1000);
            
            const nextDistText = `${(remainingDistanceThisLegDisplay / 1000).toFixed(1)} km`;
            if (nextStageDistEl.textContent !== nextDistText) nextStageDistEl.textContent = nextDistText;

            const nextStageTotalMinutes = Math.round(remainingDurationThisLegDisplay / 60);
            const nextTimeText = `${String(Math.floor(nextStageTotalMinutes / 60)).padStart(2, '0')}:${String(nextStageTotalMinutes % 60).padStart(2, '0')}`;
            if (nextStageTimeEl.textContent !== nextTimeText) nextStageTimeEl.textContent = nextTimeText;
            
            const nextEtaText = currentNextStageEta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            if (nextStageEtaEl.textContent !== nextEtaText) nextStageEtaEl.textContent = nextEtaText;
            
            let nextStageDeviationHtml = "";
            if (currentStageInitialExpectedEtaTime && isNavigating && navigationStartTimeForStats) {
               const deviationStageMs = currentNextStageEta.getTime() - currentStageInitialExpectedEtaTime.getTime();
               nextStageDeviationHtml = formatDeviation(accumulatedDeviationMs + deviationStageMs);
            }
            if (nextStageDeviationEl.innerHTML !== nextStageDeviationHtml) {
                nextStageDeviationEl.innerHTML = nextStageDeviationHtml;
            }
        }
    } else {
        etaInfoContainer.classList.add('single-destination');
        finalDestInfoDiv.classList.add('single-destination-layout');
        nextStageInfoDiv.style.display = 'none';
        if(nextStageDeviationEl && nextStageDeviationEl.innerHTML !== "") nextStageDeviationEl.innerHTML = "";
    }
   
    if (isNavigating) {
        const destinationWp = navigationWaypoints[navigationWaypoints.length - 1];
        if (destinationWp && destinationWp.address) {
            const mapOverlay = document.getElementById('map-info-overlay');
            if (mapOverlay && !mapOverlay.textContent.startsWith("HA LLEGADO AL ")) {
                 showDestinationName();
            }
        }
    }
}
  
// ===================================================================
// NOMBRE: toggleNavigationState 
// RESUMEN: Añade el parámetro 'isRecovery' para evitar resetear las estadísticas en una sesión restaurada.
async function toggleNavigationState(isRecalculationStop = false, isRecovery = false) {
    const startNavButton = document.getElementById('start-navigation-button');
    const startNavImg = startNavButton ? startNavButton.querySelector('img') : null;
    const mapContainer = document.getElementById('reminders-location-map-div');
    
    if (isNavigating) {
        clearRecoveryFlag();
        if (isSimulatingGpsLocation) {
            stopAutomatedRouteSimulation();
        }
        if (!isRecalculationStop && !isArrivalSequenceStarted) {
            if (!document.getElementById('arrival-stats-modal') || document.getElementById('arrival-stats-modal').classList.contains('hidden')) {
                showArrivalStatsModal();
            }
        }
        isNavigating = false;
        navigationFollowUser = false;
        ; 
    } else if (isFreeDriveActive) {
        stopFreeDrive();
    } else {
        const hasEnoughWaypointsForRoute = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2;
        const hasRouteData = navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0];
        if (hasEnoughWaypointsForRoute && hasRouteData) {
            isArrivalSequenceStarted = false;
            hideAutoStartNavigationModal();
            clearAlternativeRoutesDisplay();
            
            const waypointsForRecents = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
            await Promise.all(waypointsForRecents.map(async (wp) => {
                if (!wp.address) {
                    wp.address = await getAddressForWaypoint(wp.lat, wp.lng);
                }
            }));
            const lastWpForName = waypointsForRecents[waypointsForRecents.length - 1];
            const isMultiStageForName = waypointsForRecents.length > 2;
            const suggestedName = await getSuggestedRouteName(lastWpForName.lat, lastWpForName.lng, isMultiStageForName, waypointsForRecents.length);
            
            let routeForStorage;
            const finalWaypoint = waypointsForRecents[waypointsForRecents.length - 1];

            if (currentRouteNameForSaving && currentRouteNameForSaving.startsWith("UBICACIÓN: ") && finalWaypoint) {
                routeForStorage = {
                    name: currentRouteNameForSaving,
                    waypoints: sanitizeWaypointsForStorage([finalWaypoint])
                };
            } else {
                routeForStorage = { 
                    name: currentRouteNameForSaving || suggestedName, 
                    waypoints: sanitizeWaypointsForStorage(waypointsForRecents)
                };
            }
            addRouteToRecents(routeForStorage);
            
            if (!isRecovery) {
                const recoveryData = { 
                    isActive: true, 
                    route: routeForStorage,
                    tripStartTime: Date.now(),
                    originalTripEtaTime: originalTripEtaTime ? originalTripEtaTime.getTime() : null,
                    stats: {
                        totalDistance: totalDistanceTravelledForStats,
                        maxSpeed: maxSpeedDuringTrip,
                        maxAltitude: maxAltitudeDuringTrip,
                        minAltitude: minAltitudeDuringTrip
                    }
                };
                localStorage.setItem('boardinggate_nav_recovery_flag', JSON.stringify(recoveryData));
            }
        
            clearNavigationGraph();
            navigationWaypoints.forEach(wp => { if(wp) { if (wp.type === 'S' || wp.type === 'S_Recalc') { wp.visited = true; } else { wp.visited = false; } if (wp.marker) wp.marker.setDraggable(false); } });
            
            getCurrentLocation(
                (initialCoords) => { navigationCurrentLocation = initialCoords; updateInitialUserPosition(initialCoords, navigationMapInstance); },
                (errorMsg) => { showToast(`No se pudo obtener tu ubicación inicial: ${errorMsg}. El mapa se centrará cuando el GPS esté listo.`, "warning", 5000); }
            );
            startGpsWatching();
            const loadingToast = document.getElementById("gps-init-toast"); if (loadingToast) loadingToast.remove(); activeToasts = activeToasts.filter(t => t.id !== "gps-init-toast");
            
            isNavigating = true;
            startDeviationChecker(); 
            mapHeaderButtonsVisible = false;
            toggleMapHeaderRowsVisibility(false);
            
            const routeData = navigationCurrentRouteData.routes[0];
            if (routeData) {
                tripInitialDurationSec = routeData.duration;
                tripInitialDistanceMeters = routeData.distance;
                tripInitialOverallEtaTime = new Date(Date.now() + routeData.duration * 1000);
                if (routeData.legs && routeData.legs.length > 0) {
                    currentStageInitialExpectedEtaTime = new Date(Date.now() + routeData.legs[0].duration * 1000);
                }
                if (!isRecovery) {
                    originalTripEtaTime = tripInitialOverallEtaTime; 
                }
            }

            if (!isRecovery) {
                tripStartLocationForStats = navigationCurrentLocation ? { ...navigationCurrentLocation } : null;
                navigationStartTimeForStats = new Date();
                totalDistanceTravelledForStats = 0;
                maxDistanceReachedOnRoute = 0;
                speedMarkerFeatures = []; 
                maxSpeedDuringTrip = 0;
                maxSpeedCoordinates = null;
                maxAltitudeDuringTrip = -Infinity;
                minAltitudeDuringTrip = Infinity;
                lastPositionForStats = navigationCurrentLocation ? {...navigationCurrentLocation} : null;
                accumulatedDeviationMs = 0;
                accumulatedDistanceBeforeCurrentSegment = 0;
            }
            
            const toastMessage = isRecovery ? "Navegación reanudada." : "Navegación iniciada. Esperando movimiento...";
            showToast(toastMessage, "success");

            currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviación ETA';
            initializeNavigationGraph();
            const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox'); if (radaresRutaCheckbox && radaresRutaCheckbox.checked) { toggleRadaresRuta(true); }
            const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox'); if (tareasRutaCheckbox && tareasRutaCheckbox.checked) { toggleTareasRuta(true); }
            if (navigationMapInstance) {
                shouldCenterOnUser = true; 
                navigationFollowUser = true;
                const locateMeButton = document.getElementById('locate-me-on-reminders-map');
                if (locateMeButton) {
                    const locateMeImg = locateMeButton.querySelector('img');
                    if (locateMeImg) locateMeImg.src = "PNG/DEJARSEGUIR.PNG";
                    locateMeButton.title = "Dejar de centrar el mapa en mi posición";
                }
                const startCoords = navigationCurrentLocation 
                    ? [navigationCurrentLocation.longitude, navigationCurrentLocation.latitude] 
                    : [navigationWaypoints[0].lng, navigationWaypoints[0].lat];
                const savedViewMode = localStorage.getItem(MAP_VIEW_MODE_KEY) || 'static';
                const modeDetails = MAP_VIEW_MODES[Object.keys(MAP_VIEW_MODES).find(key => MAP_VIEW_MODES[key].mode === savedViewMode)] || MAP_VIEW_MODES.NORTE;
                let pitchToUse = 0;
                if (modeDetails.mode === 'static') {
                    pitchToUse = 0; 
                } else {
                    pitchToUse = mapPitchValue; 
                }
                const initialFlyToOptions = { center: startCoords, zoom: 17.5, pitch: pitchToUse, essential: true, duration: 1500 };
                if ((modeDetails.mode === 'heading' || modeDetails.mode === 'perspective') && navigationCurrentLocation && navigationCurrentLocation.heading !== null) {
                    initialFlyToOptions.bearing = navigationCurrentLocation.heading;
                } else {
                    initialFlyToOptions.bearing = modeDetails.bearing;
                }
                navigationMapInstance.flyTo(initialFlyToOptions);
            }
        } else {
            try {
                const initialCoords = await getCurrentLocationAsync();
                startFreeDrive(initialCoords);
            } catch (error) {
                showToast(`No se pudo obtener la ubicación para iniciar el modo libre: ${error.message}`, "error");
            }
        }
    }
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    setNavigationMapClickHandler(); 
    actualizarContadorRadares(radaresEnRutaActual.length);
    actualizarContadorTareas(tareasEnRutaActual.length);
}

// ===================================================================
// NOMBRE: checkForAndExecuteCrashRecovery (VERSIÓN MODIFICADA)
// RESUMEN: Lee la bandera de recuperación y ahora también el `tripStartTime`, pasándolo a la función de carga.
async function checkForAndExecuteCrashRecovery() {
    const recoveryFlagJSON = localStorage.getItem('boardinggate_nav_recovery_flag');
    if (!recoveryFlagJSON) {
        return false; }
    
    try {
        const recoveryData = JSON.parse(recoveryFlagJSON);
        if (recoveryData && recoveryData.isActive && recoveryData.route) {
            showToast("ESPERE UN MOMENTO POR FAVOR, Recuperando sesión de navegación anterior...", "error", 11000);

            const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'none';
            const footer = document.querySelector('footer'); if (footer) footer.style.display = 'none';
            const noticesContainer = document.querySelector('.notices-icon-container'); if (noticesContainer) noticesContainer.style.display = 'none';
            const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'none');
            document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button, #accident-alert-button').forEach(el => el.style.display = 'none');
            const gridFilter = document.getElementById('grid-filter-container'); if (gridFilter) gridFilter.style.display = 'none';
            
            try {
                await openNavigationMap(true); 
                
                await loadRouteFromObject(recoveryData.route, true, true, recoveryData);

                return true;  
            } catch (recoveryError) {
                showToast("La recuperación automática falló. Cargando la app normalmente.", "error", 6000);
                clearRecoveryFlag();
                setTimeout(() => location.reload(), 2000);
                return true; }
        }
    } catch (e) {
    } finally {
        clearRecoveryFlag(); 
    }
    clearRecoveryFlag(); 
     
    return false; 
}  

// ===================================================================
// NOMBRE: loadRouteFromObject 
// RESUMEN: Acepta recoveryInfo y pasa la bandera 'isRecovery' a toggleNavigationState.
// ===================================================================
async function loadRouteFromObject(routeObject, autoStartNavigation = false, forceImmediateStart = false, recoveryInfo = null) {
    if (isRecalculatingRoute) {
        showToast("Procesando otra ruta, por favor espere.", "warning");
        return;
    }
    
    if (!routeObject || !routeObject.waypoints || routeObject.waypoints.length === 0) {
        showToast("Error: El objeto de la ruta es inválido.", "error");
        return;
    }

    isRecalculatingRoute = true;
    try {
        if (isFreeDriveActive) {
            isFreeDrivePaused = true;
            isFreeDriveActive = false;
            showToast("Modo Conducción Libre en pausa.", "info");
            updateStartNavigationButtonState();
            updateNavigationButtonColor();
            clearNavigationGraph();
        }

        const startLocation = navigationCurrentLocation ? { ...navigationCurrentLocation } : null;
        resetNavigationState();
        currentRouteNameForSaving = routeObject.name;
        const waypointsFromLoadedRoute = routeObject.waypoints;
        
        if (waypointsFromLoadedRoute.length === 1) {
            if (startLocation) {
                const startPoint = { id: Date.now() - 1, lat: startLocation.latitude, lng: startLocation.longitude, type: 'S', marker: null, label: 'S', address: 'Posición Actual (GPS)', visited: true, isCriticalForRecalc: true, isInternal: false, isRecalculatedStart: false };
                const destinationWp = sanitizeWaypointsForStorage(waypointsFromLoadedRoute)[0];
                navigationWaypoints = [startPoint, destinationWp];
            } else {
                showToast("Señal GPS no disponible. No se puede iniciar ruta a un único destino.", "error");
                return;
            }
        } else {
            if (startLocation) {
                const startPoint = { id: Date.now() - 1, lat: startLocation.latitude, lng: startLocation.longitude, type: 'S', marker: null, label: 'S', address: 'Posición Actual (GPS)', visited: true, isCriticalForRecalc: true, isInternal: false, isRecalculatedStart: false };
                navigationWaypoints = [startPoint, ...sanitizeWaypointsForStorage(waypointsFromLoadedRoute.slice(1))];
            } else {
                showToast("Señal GPS no disponible. Cargando ruta original...", "warning");
                navigationWaypoints = sanitizeWaypointsForStorage(waypointsFromLoadedRoute);
            }
        }
        
        await updateWaypointTypesAndLabels();
        renderWaypointMarkers();

        if (navigationWaypoints.filter(wp => wp && !wp.isInternal).length >= 2) {
            await new Promise(resolve => {
                navigationMapInstance.once('idle', async () => {
                    try {
                        await recalculateAndDrawRoute(false);
                        
                        if (recoveryInfo) {
                            await restoreTripProgress(recoveryInfo);
                        }
                        
                        if (autoStartNavigation) {
                            if (forceImmediateStart) {
                                toggleNavigationState(false, !!recoveryInfo); 
                            } else {
                                const routeGeoJSON = navigationMapInstance.getSource('route')._data;
                                if (routeGeoJSON.geometry && routeGeoJSON.geometry.coordinates.length > 1) {
                                    const bounds = new mapboxgl.LngLatBounds();
                                    routeGeoJSON.geometry.coordinates.forEach(coord => bounds.extend(coord));
                                    if (!bounds.isEmpty()) {
                                        navigationMapInstance.fitBounds(bounds, { padding: 80, animate: true, duration: 1500 });
                                    }
                                }
                                const firstDestination = navigationWaypoints.find(wp => wp && !wp.isInternal && wp.type !== 'S' && !wp.visited);
                                if (firstDestination) { fetchAndDisplayAlternativeRoutes(firstDestination.id); }
                                showAutoStartNavigationModal();
                            }
                        }
                    } catch (error) {
                        showToast("No se pudo trazar la ruta. Comprueba la conexión o intenta mover un punto.", "error", 8000);
                        const fallbackCoords = navigationWaypoints.map(wp => [wp.lng, wp.lat]);
                        await drawRouteOnMap({ geometry: { type: 'LineString', coordinates: fallbackCoords } });
                    } finally {
                        resolve();
                    }
                });
            });
        }
    } catch (error) {
        console.error("Error al cargar la ruta desde el objeto:", error);
    } finally {
        isRecalculatingRoute = false;
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
    }
}    

// ===================================================================
// NOMBRE: restoreTripProgress (NUEVA FUNCIÓN)
// RESUMEN: Restaura el estado de un viaje (distancia, tiempo, stats) tras una recuperación.
async function restoreTripProgress(recoveryInfo) {
    if (!navigationCurrentRouteData?.routes?.[0] || !recoveryInfo || !recoveryInfo.tripStartTime) {
        return;
    }

    try {
        const route = navigationCurrentRouteData.routes[0];
        const currentCoords = await getCurrentLocationAsync();

        navigationStartTimeForStats = new Date(recoveryInfo.tripStartTime);
        
        if (recoveryInfo.originalTripEtaTime) {
            originalTripEtaTime = new Date(recoveryInfo.originalTripEtaTime);
        }
        
        if (recoveryInfo.stats) {
            totalDistanceTravelledForStats = recoveryInfo.stats.totalDistance || 0;
            maxSpeedDuringTrip = recoveryInfo.stats.maxSpeed || 0;
            maxAltitudeDuringTrip = recoveryInfo.stats.maxAltitude || -Infinity;
            minAltitudeDuringTrip = recoveryInfo.stats.minAltitude || Infinity;
        }

        const carPoint = turf.point([currentCoords.longitude, currentCoords.latitude]);
        const routeLine = turf.lineString(route.geometry.coordinates);
        const nearestPointOnRoute = turf.nearestPointOnLine(routeLine, carPoint, { units: 'meters' });
        const carDistanceAlongRoute = nearestPointOnRoute.properties.location;
        
        lastPositionForStats = { ...currentCoords };
        
        const timeElapsedS = (Date.now() - recoveryInfo.tripStartTime) / 1000;
        if (timeElapsedS > 0 && totalDistanceTravelledForStats > 0) {
            window.averageSpeedKmh = (totalDistanceTravelledForStats / timeElapsedS) * 3.6;
        }

        lastCarDistanceAlongRouteForNavLogic = carDistanceAlongRoute;
        
        let cumulativeDistance = 0;
        let legFound = false;
        for (let i = 0; i < route.legs.length; i++) {
            const leg = route.legs[i];
            if (!leg || !leg.steps) continue;
            const legTotalDistance = leg.distance || leg.steps.reduce((sum, step) => sum + (step.distance || 0), 0);
            
            if (carDistanceAlongRoute <= cumulativeDistance + legTotalDistance) {
                currentLegIndexNav = i;
                let legDistanceTraveled = 0;
                for (let j = 0; j < leg.steps.length; j++) {
                    const step = leg.steps[j];
                    const stepDistance = step.distance || 0;
                    if (carDistanceAlongRoute <= cumulativeDistance + legDistanceTraveled + stepDistance) {
                        currentStepIndexNav = j;
                        legFound = true;
                        break;
                    }
                    legDistanceTraveled += stepDistance;
                }
                if (legFound) break;
            }
            cumulativeDistance += legTotalDistance;
        }

        updateNavigationProgressDisplay(route, carDistanceAlongRoute);
        updateTurnByTurnDisplay(route, carDistanceAlongRoute);

    } catch (error) {
        showToast(`Error al restaurar progreso: ${error.message}. Se continuará desde el inicio.`, "error");
        navigationStartTimeForStats = new Date();
        totalDistanceTravelledForStats = 0;
    }
}
    
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// NOMBRE: fetchAndRenderChatUsers 
// RESUMEN: Carga TODOS los usuarios y los ordena/filtra en el cliente para evitar errores de índice.
async function fetchAndRenderChatUsers() {
    const usersListContainer = document.getElementById('chat-users-list');
    const messageInput = document.getElementById('chat-message-input');
    const filterInput = document.getElementById('chat-user-filter-input');
    
    if (!usersListContainer || !window.db || !messageInput || !filterInput || isFetchingUsers) return;

    if (!filterInput.listenerAdded) {
        filterInput.addEventListener('input', () => {
            fetchAndRenderChatUsers(); 
        });
        filterInput.listenerAdded = true;
    }
    
    isFetchingUsers = true;
    
    usersListContainer.innerHTML = '';

    const isAdmin = (localStorage.getItem('userData_userId') || '').toLowerCase() === 'boardinggate';

    if (isAdmin) {
        const [sessionStats, poiStats] = await Promise.all([
            getGlobalMapSessionStats(),
            getGlobalPoiStats()
        ]);

        let statsHeader = document.getElementById('chat-admin-stats-header');
        if (!statsHeader) {
            statsHeader = document.createElement('div');
            statsHeader.id = 'chat-admin-stats-header';
            statsHeader.className = 'chat-admin-stats-header';
            const filterContainer = document.getElementById('chat-users-filter-container');
            if (filterContainer) {
                filterContainer.insertAdjacentElement('afterend', statsHeader);
            }
        }
        statsHeader.innerHTML = `Sesiones-> Mes: ${sessionStats.totalMonth} | Total: ${sessionStats.totalHistoric}<br>POI Clics (Mes): ${poiStats.totalMonth}`;
        
        let maxSessionsControl = document.getElementById('chat-max-sessions-control');
        if (!maxSessionsControl) {
            maxSessionsControl = document.createElement('div');
            maxSessionsControl.id = 'chat-max-sessions-control';
            maxSessionsControl.style.cssText = 'padding: 8px; background-color: #3a3a3c; border-bottom: 1px solid #444; display: flex; align-items: center; justify-content: center; gap: 10px;';
            maxSessionsControl.innerHTML = `
                <label for="chat-max-sessions-input" style="font-weight: bold; color: #ffd700;">MÁXIMO SESIONES:</label>
                <input type="number" id="chat-max-sessions-input" style="width: 80px; text-align: center; background-color: #2c2c2e; border: 1px solid #555; color: #f0f0f0; border-radius: 4px;">
            `;
            statsHeader.insertAdjacentElement('afterend', maxSessionsControl);

            const maxSessionsInput = document.getElementById('chat-max-sessions-input');
            const localMaxSessions = localStorage.getItem(MAX_SESSIONS_KEY);
            if(localMaxSessions) {
                maxSessionsInput.value = localMaxSessions;
            } else {
                const adminDocRef = window.doc(window.db, "user_data", "boardinggate");
                window.getDoc(adminDocRef).then(docSnap => {
                    if (docSnap.exists() && docSnap.data().max_monthly_sessions) {
                        const maxSessions = docSnap.data().max_monthly_sessions;
                        maxSessionsInput.value = maxSessions;
                        localStorage.setItem(MAX_SESSIONS_KEY, maxSessions);
                    }
                });
            }

            maxSessionsInput.addEventListener('change', async () => {
                const newValue = parseInt(maxSessionsInput.value, 10);
                if (!isNaN(newValue) && newValue >= 0) {
                    localStorage.setItem(MAX_SESSIONS_KEY, newValue);
                    const adminDocRef = window.doc(window.db, "user_data", "boardinggate");
                    try {
                        await window.setDoc(adminDocRef, { max_monthly_sessions: newValue }, { merge: true });
                        showToast(`Límite máximo de sesiones mensuales actualizado a ${newValue}.`, 'success');
                    } catch (error) {
                        showToast(`Error al guardar el límite en la nube.`, 'error');
                    }
                }
            });
        }
    }

    try {
        const usersRef = window.collection(window.db, "user_data");
        
        const q = window.query(usersRef, window.where("rss", "==", true));

        const querySnapshot = await window.getDocs(q);
        const docs = querySnapshot.docs;
        
        let allUsersData = [];
        docs.forEach(doc => {
            const userData = doc.data();
            const userId = userData.usuario || doc.id; // Salvaguarda por si 'usuario' no existe
            allUsersData.push({ id: userId, ...userData });
        });
        
        allUsersData.sort((a, b) => a.id.localeCompare(b.id));

        const filterText = filterInput.value.toLowerCase().trim();
        const filteredUsers = filterText 
            ? allUsersData.filter(userData => {
                const userString = `${userData.id} ${userData.modelo || ''} ${userData.anio || ''} ${userData.provincia || ''}`.toLowerCase();
                return userString.includes(filterText);
              })
            : allUsersData;

        
        const now = new Date();
        const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        if (filteredUsers.length === 0) {
            usersListContainer.innerHTML = '<p class="chat-no-users">No hay usuarios que coincidan con el filtro.</p>';
        } else {
            filteredUsers.forEach(userData => {
                const userId = userData.id;
                const isBoardingGateAccount = userId.toLowerCase().includes('boardinggate');
                const isMainAdminAccount = userId.toLowerCase() === 'boardinggate';
                if (isBoardingGateAccount && !isMainAdminAccount) {
                    return; 
                }

                const userElement = document.createElement('div');
                userElement.className = 'chat-user-item';
                userElement.style.cursor = 'pointer';
                userElement.title = `Enviar mensaje privado a ${userId}`;
                userElement.addEventListener('click', () => {
                    const currentText = messageInput.value;
                    if (currentText.startsWith('@')) {
                        const existingMentionEndIndex = currentText.indexOf(' ');
                        if (existingMentionEndIndex !== -1) {
                            messageInput.value = `@${userId} ` + currentText.substring(existingMentionEndIndex + 1);
                        } else {
                            messageInput.value = `@${userId} `;
                        }
                    } else {
                        messageInput.value = `@${userId} ` + currentText;
                    }
                    messageInput.focus();
                    messageInput.dispatchEvent(new Event('input'));
                });

                const userName = document.createElement('span');
                userName.className = 'chat-user-name';
                userName.textContent = userId;
                
                const userDetails = document.createElement('span');
                userDetails.className = 'chat-user-details';
                const detailsParts = [];
                if (userData.modelo) detailsParts.push(userData.modelo);
                if (userData.anio) detailsParts.push(userData.anio);
                if (userData.provincia) detailsParts.push(userData.provincia);
                userDetails.textContent = `(${detailsParts.join(', ')})`;

                if (isAdmin) {
                    const userMonthSessions = (userData.map_sessions_last_month === currentMonthStr) ? (userData.map_sessions_month || 0) : 0;
                    const userTotalSessions = userData.map_sessions_total || 0;
                    const userPoiClicks = (userData.poi_clicks_last_month === currentMonthStr) ? (userData.poi_clicks_month || 0) : 0;
                    
                    const statsSpan = document.createElement('span');
                    statsSpan.className = 'chat-user-session-stats';
                    statsSpan.textContent = `(Sesiones Mes: ${userMonthSessions} | POI: ${userPoiClicks} | Sesiones Total: ${userTotalSessions})`;
                    userDetails.appendChild(statsSpan);
                }
                
                userElement.appendChild(userName);
                userElement.appendChild(userDetails);
                usersListContainer.appendChild(userElement);
            });
        }

    } catch (error) {
        console.error("Error al renderizar usuarios del chat:", error);
        usersListContainer.innerHTML = '<p class="chat-no-users">Error al cargar usuarios.</p>';
    } finally {
        isFetchingUsers = false;
    }
}
    
// ===================================================================
// NOMBRE: fetchAndRenderChatMessages 
// RESUMEN: Carga mensajes y encuestas en lotes de 100 y gestiona el scroll infinito.
async function fetchAndRenderChatMessages(loadMore = false) {
    const messagesContainer = document.getElementById('chat-messages-container');
    if (!messagesContainer || !window.db || isFetchingMessages) return;

    const currentUserId = (localStorage.getItem('userData_userId') || '').trim();
    if (!currentUserId) {
        messagesContainer.innerHTML = '<p class="chat-system-message">Configura tu ID de usuario para ver el chat.</p>';
        return;
    }

    if (loadMore && !lastVisibleMessageDoc) {
        return; // No hay más mensajes que cargar
    }

    isFetchingMessages = true;
    const currentUserIdLower = currentUserId.toLowerCase();

    try {
        const PAGE_SIZE = 100;
        const oneHundredTwentyHoursAgo = new Date(Date.now() - 120 * 60 * 60 * 1000);
        
        let messagesQuery;
        const messagesRef = window.collection(window.db, 'chatMessages');
        
        if (lastVisibleMessageDoc) {
            messagesQuery = window.query(messagesRef, window.where('timestamp', '>', oneHundredTwentyHoursAgo), window.orderBy('timestamp', 'desc'), window.startAfter(lastVisibleMessageDoc), window.limit(PAGE_SIZE));
        } else {
            messagesQuery = window.query(messagesRef, window.where('timestamp', '>', oneHundredTwentyHoursAgo), window.orderBy('timestamp', 'desc'), window.limit(PAGE_SIZE));
        }
        
        const pollsQuery = window.query(window.collection(window.db, 'chatPolls'), window.orderBy('timestamp', 'desc'));
        
        const [messagesSnapshot, pollsSnapshot] = await Promise.all([
            window.getDocs(messagesQuery),
            loadMore ? Promise.resolve({ docs: [] }) : window.getDocs(pollsQuery)
        ]);

        const messageDocs = messagesSnapshot.docs;
        if (messageDocs.length > 0) {
            lastVisibleMessageDoc = messageDocs[messageDocs.length - 1];
        } else {
            lastVisibleMessageDoc = null; 
        }

        let combinedItems = [];
        messageDocs.forEach(doc => combinedItems.push({ id: doc.id, ...doc.data(), isPoll: false }));
        
        if (!loadMore) {
            pollsSnapshot.forEach(doc => combinedItems.push({ id: doc.id, ...doc.data(), isPoll: true }));
        }

        if (!loadMore) {
            combinedItems.sort((a, b) => (b.timestamp?.toMillis() || 0) - (a.timestamp?.toMillis() || 0));
        }
        
        if (combinedItems.length === 0 && !loadMore) {
            messagesContainer.innerHTML = '<p class="chat-system-message">No hay mensajes recientes. ¡Sé el primero en escribir!</p>';
            isFetchingMessages = false;
            return;
        }

        combinedItems.forEach(item => {
            if (item.isPoll) {
                messagesContainer.appendChild(renderPollBubble(item, currentUserId));
            } else {
                const isPublic = item.recipientId.toLowerCase() === 'public';
                const isForMe = item.recipientId.toLowerCase() === currentUserIdLower;
                const iSentIt = item.senderId.toLowerCase() === currentUserIdLower;

                if (isPublic || isForMe || iSentIt) {
                    const bubble = document.createElement('div');
                    bubble.className = 'chat-message-bubble';
                    
                    let bubbleClass = '';
                    if (iSentIt && isPublic) { bubble.style.backgroundColor = '#DF6565'; bubbleClass = 'public-msg'; }
                    else if (isForMe && !iSentIt) { bubbleClass = 'private-msg'; }
                    else if (isPublic) { bubbleClass = 'public-msg'; }
                    else if (iSentIt && !isPublic) { bubbleClass = 'private-msg-sent'; }
                    bubble.classList.add(iSentIt ? 'sent' : 'received', bubbleClass);

                    const senderSpan = document.createElement('span');
                    senderSpan.className = 'chat-message-sender';
                    senderSpan.textContent = item.senderId + (item.recipientId.toLowerCase() !== 'public' ? ` a ${item.recipientId}` : '');
                    
                    const contentSpan = document.createElement('span');
                    contentSpan.className = 'chat-message-content';
                    contentSpan.textContent = item.content;
                    
                    const timeSpan = document.createElement('span');
                    timeSpan.className = 'chat-message-time';
                    const timeText = document.createElement('span');
                    timeText.textContent = item.timestamp?.toDate ? `${item.timestamp.toDate().toLocaleDateString([], {day:'2-digit', month:'2-digit'})} - ${item.timestamp.toDate().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}` : '';
                    timeSpan.appendChild(timeText);

                    if (iSentIt || currentUserId === 'BoardingGate') {
                        const actionsContainer = document.createElement('div');
                        actionsContainer.className = 'chat-message-actions';
                        
                        const editIcon = document.createElement('img');
                        editIcon.src = 'https://boardinggate.github.io/Tesla/PNG/editmsg.png';
                        editIcon.className = 'chat-action-icon';
                        editIcon.title = 'Editar mensaje';
                        editIcon.dataset.action = 'edit-message';
                        editIcon.dataset.id = item.id;
                        editIcon.dataset.content = item.content;

                        const deleteIcon = document.createElement('img');
                        deleteIcon.src = 'https://boardinggate.github.io/Tesla/PNG/erasemsg.png';
                        deleteIcon.className = 'chat-action-icon';
                        deleteIcon.title = 'Eliminar mensaje';
                        deleteIcon.dataset.action = 'delete-message';
                        deleteIcon.dataset.id = item.id;

                        actionsContainer.appendChild(editIcon);
                        actionsContainer.appendChild(deleteIcon);
                        timeSpan.appendChild(actionsContainer);
                    }
                    
                    bubble.appendChild(senderSpan);
                    bubble.appendChild(contentSpan);
                    bubble.appendChild(timeSpan);
                    messagesContainer.appendChild(bubble);
                }
            }
        });
        
        if (!loadMore) {
            messagesContainer.scrollTop = 0;
        }

    } catch (error) {
        messagesContainer.innerHTML = `<p class="chat-system-message">Error al cargar el chat: ${error.message}</p>`;
    } finally {
        isFetchingMessages = false;
    }
}    
    
// ===================================================================
// NOMBRE: handleProgressiveManeuverZoom (VERSIÓN FINAL CON CORRECCIÓN DE ÁMBITO)
// RESUMEN: Incluye mejoras y corrección del bug de estado. Ahora recibe
const easeInOutQuad = t => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
function findNextValidStep(route, currentLeg, currentStep) {
    let legIndex = currentLeg;
    let stepIndex = currentStep + 1;
    const waypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal);

    while (legIndex < route.legs.length) {
        const leg = route.legs[legIndex];
        if (stepIndex >= leg.steps.length) {
            legIndex++;
            stepIndex = 0;
            continue;
        }
        const candidateStep = leg.steps[stepIndex];
        const isArrival = candidateStep.maneuver.type === 'arrive';
        const arrivalWaypoint = isArrival ? waypoints[legIndex + 1] : null;
        if (isArrival && arrivalWaypoint && arrivalWaypoint.isInternal) {
            stepIndex++;
            continue; 
        }
        return { step: candidateStep, legIndex: legIndex, stepIndex: stepIndex };
    }
    return null;
}

// ===================================================================
// NOMBRE: handleProgressiveManeuverZoom (VERSIÓN DEFINITIVA CON BEARING_BEFORE)
function handleProgressiveManeuverZoom(currentStep, distanceToManeuver, carDistanceAlongRouteForNavLogic) {
    if (isManualZoomActive) return null;

    if (!isNavigating || !navigationMapInstance || !currentStep) {
        if (isZoomedForManeuver) isZoomedForManeuver = false;
        return null;
    }
    
    const route = navigationCurrentRouteData?.routes?.[0];
    if (!route || !route.geometry || !route.geometry.coordinates || route.geometry.coordinates.length < 2) {
        return null;
    }
    
    const ANIMATION_START_DISTANCE = 210;
    const OFFSET_PEAK_DISTANCE = 120;
    const ZOOM_PEAK_DISTANCE = 50;
    const PROGRESSIVE_ZOOM_EXIT_START_DISTANCE = 40;
    const PROGRESSIVE_ZOOM_EXIT_END_DISTANCE = 160;
    const HOLD_ZOOM_THRESHOLD = 250;
    const maxZoomForMap = navigationMapInstance.getMaxZoom() || 19;
    const currentMapLayerName = (localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "HÍBRIDO").toLowerCase();
    const isSatelliteWithLabels = currentMapLayerName.includes("satélite") && currentMapLayerName.includes("calles");
    const MANEUVER_PEAK_ZOOM_LEVEL = isSatelliteWithLabels ? Math.min(17.5, maxZoomForMap) : Math.min(18.5, maxZoomForMap);
    
    const currentStepIdentifier = `${currentLegIndexNav}_${currentStepIndexNav}`;
    if (lastProcessedStepIdentifier !== null && lastProcessedStepIdentifier !== currentStepIdentifier) {
        if (progressiveZoomState === 'zooming-in' || progressiveZoomState === 'holding') {
            progressiveZoomState = 'zooming-out';
        }
    }
    lastProcessedStepIdentifier = currentStepIdentifier;

    const distanceIntoCurrentStep = currentStep.distance - distanceToManeuver;
    let targetZoom = null, targetPitch = null, targetOffsetX = null, targetOffsetY = null;

    switch (progressiveZoomState) {
        case 'zooming-out':
            isZoomedForManeuver = true;
            const nextStepAfterCurrent = findNextValidStep(route, currentLegIndexNav, currentStepIndexNav);
            const distanceToNextStep = nextStepAfterCurrent ? calculateDistanceToEndOfStep(route, nextStepAfterCurrent.legIndex, nextStepAfterCurrent.stepIndex) - carDistanceAlongRouteForNavLogic : Infinity;
            
            if (nextStepAfterCurrent && distanceToNextStep < HOLD_ZOOM_THRESHOLD) {
                targetZoom = MANEUVER_PEAK_ZOOM_LEVEL;
                if (mapViewMode === 'perspective' || mapViewMode === 'relief') targetPitch = window.pitchBeforeManeuver * 0.75; else targetPitch = 45;
                targetOffsetY = 35;
                targetOffsetX = window.offsetXBeforeManeuver;
                
            } else {
                if (distanceIntoCurrentStep > PROGRESSIVE_ZOOM_EXIT_END_DISTANCE || mapPreviousZoomLevelForProgressive === null) {
                    targetZoom = mapPreviousZoomLevelForProgressive;
                    targetPitch = window.pitchBeforeManeuver;
                    targetOffsetY = window.offsetYBeforeManeuver;
                    targetOffsetX = window.offsetXBeforeManeuver;
                    progressiveZoomState = 'none';
                    isZoomedForManeuver = false;
                    
                    MAP_UPDATE_INTERVAL_MS = originalMapUpdateIntervalMs;
               
                } else if (distanceIntoCurrentStep >= PROGRESSIVE_ZOOM_EXIT_START_DISTANCE) {
                    const progress = (distanceIntoCurrentStep - PROGRESSIVE_ZOOM_EXIT_START_DISTANCE) / (PROGRESSIVE_ZOOM_EXIT_END_DISTANCE - PROGRESSIVE_ZOOM_EXIT_START_DISTANCE);
                    const offsetReturnProgress = Math.min(1, progress * 1.5);
                    targetZoom = MANEUVER_PEAK_ZOOM_LEVEL - (MANEUVER_PEAK_ZOOM_LEVEL - mapPreviousZoomLevelForProgressive) * Math.min(1, progress);

                    let maneuverMinPitch;
                    if (mapViewMode === 'perspective' || mapViewMode === 'relief') {
                        maneuverMinPitch = window.pitchBeforeManeuver * 0.75;
                    } else {
                        maneuverMinPitch = 35;
                    }
                    targetPitch = maneuverMinPitch + (window.pitchBeforeManeuver - maneuverMinPitch) * progress;

                    targetOffsetY = 35 + (window.offsetYBeforeManeuver - 35) * offsetReturnProgress;
                    targetOffsetX = (window.offsetXBeforeManeuver + window.maneuverHorizontalTarget) - (window.maneuverHorizontalTarget * offsetReturnProgress);
                } else {
                    targetZoom = MANEUVER_PEAK_ZOOM_LEVEL;
                    if (mapViewMode === 'perspective' || mapViewMode === 'relief') targetPitch = window.pitchBeforeManeuver * 0.75; else targetPitch = 45;
                    targetOffsetY = 35;
                    targetOffsetX = window.offsetXBeforeManeuver + window.maneuverHorizontalTarget;
                }
            }
            break;

        default: 
            if (distanceToManeuver <= ANIMATION_START_DISTANCE) {
                if (progressiveZoomState === 'none') {
                    originalMapUpdateIntervalMs = MAP_UPDATE_INTERVAL_MS;
                    MAP_UPDATE_INTERVAL_MS = 1000 / 60; // Forzamos ~60 FPS
             
                    mapPreviousZoomLevelForProgressive = navigationMapInstance.getZoom();
                    window.pitchBeforeManeuver = navigationMapInstance.getPitch();
                    window.offsetXBeforeManeuver = mapOffsetX;
                    window.offsetYBeforeManeuver = mapOffsetY;
                    
                    let dynamicHorizontalTarget = 0;
                    const maneuver = currentStep.maneuver;
                    
                    const bearingBefore = maneuver.bearing_before;
                    const bearingAfter = maneuver.bearing_after;
                    
                    if (typeof bearingBefore === 'number' && typeof bearingAfter === 'number') {
                        
                        let angleDiff = bearingAfter - bearingBefore;

                        if (angleDiff > 180) angleDiff -= 360;
                        if (angleDiff < -180) angleDiff += 360;

                        const GIRO_SUAVE_UMBRAL = 30;
                        const GIRO_NORMAL_UMBRAL = 75;

                        if (angleDiff > GIRO_NORMAL_UMBRAL) { 
                            dynamicHorizontalTarget = 45;
                        } else if (angleDiff > GIRO_SUAVE_UMBRAL) {
                            dynamicHorizontalTarget = 40;
                        } else if (angleDiff > 15) {
                            dynamicHorizontalTarget = 30;
                        } else if (angleDiff < -GIRO_NORMAL_UMBRAL) {
                            dynamicHorizontalTarget = -45;
                        } else if (angleDiff < -GIRO_SUAVE_UMBRAL) {
                            dynamicHorizontalTarget = -40;
                        } else if (angleDiff < -15) {
                            dynamicHorizontalTarget = -30;
                        }
                    }
                    
                    window.maneuverHorizontalTarget = dynamicHorizontalTarget;
                    progressiveZoomState = 'zooming-in';
                    isZoomedForManeuver = true;
                }
                
                let offsetProgress = 0;
                if (distanceToManeuver <= OFFSET_PEAK_DISTANCE) offsetProgress = 1;
                else if (distanceToManeuver < ANIMATION_START_DISTANCE) offsetProgress = (ANIMATION_START_DISTANCE - distanceToManeuver) / (ANIMATION_START_DISTANCE - OFFSET_PEAK_DISTANCE);

                let zoomProgress = 0;
                if (distanceToManeuver <= ZOOM_PEAK_DISTANCE) zoomProgress = 1;
                else if (distanceToManeuver < ANIMATION_START_DISTANCE) zoomProgress = (ANIMATION_START_DISTANCE - distanceToManeuver) / (ANIMATION_START_DISTANCE - ZOOM_PEAK_DISTANCE);
                
                const easedZoomProgress = easeInOutQuad(Math.max(0, Math.min(1, zoomProgress)));
                targetZoom = mapPreviousZoomLevelForProgressive + (MANEUVER_PEAK_ZOOM_LEVEL - mapPreviousZoomLevelForProgressive) * easedZoomProgress;
                
                if (mapViewMode === 'perspective' || mapViewMode === 'relief') {
                    const pitchReduction = window.pitchBeforeManeuver * 0.25;
                    targetPitch = window.pitchBeforeManeuver - (pitchReduction * easedZoomProgress);
                } else {
                    targetPitch = window.pitchBeforeManeuver + (45 - window.pitchBeforeManeuver) * easedZoomProgress;
                }
                
                targetOffsetY = window.offsetYBeforeManeuver + (35 - window.offsetYBeforeManeuver) * easeInOutQuad(Math.min(1, offsetProgress));
                targetOffsetX = window.offsetXBeforeManeuver + (window.maneuverHorizontalTarget * easeInOutQuad(Math.min(1, offsetProgress)));

            } else {
                if (progressiveZoomState !== 'none') {
                    targetZoom = mapPreviousZoomLevelForProgressive;
                    targetPitch = window.pitchBeforeManeuver;
                    targetOffsetY = window.offsetYBeforeManeuver;
                    targetOffsetX = window.offsetXBeforeManeuver;
                }
                progressiveZoomState = 'none';
                isZoomedForManeuver = false;

                MAP_UPDATE_INTERVAL_MS = originalMapUpdateIntervalMs;
              }
            break;
    }

    if (targetZoom !== null || targetPitch !== null || targetOffsetX !== null || targetOffsetY !== null) {
        return { 
            zoom: targetZoom, 
            pitch: targetPitch, 
            offsetX: targetOffsetX !== null ? Math.max(-75, Math.min(75, targetOffsetX)) : null,
            offsetY: targetOffsetY !== null ? Math.max(-75, Math.min(75, targetOffsetY)) : null
        };
    }
    return null;
}
    
    
// ===================================================================
// NOMBRE: eliminarTareasDeBarraProgreso
// RESUMEN: Limpia tareas de la barra de progreso Y del mapa.
function eliminarTareasDeBarraProgreso() {
    eliminarTareasDeMapa(); 
    tareasEnRutaActual = [];
    actualizarContadorTareas(0);
    if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
      
        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
}

// ===================================================================
// NOMBRE: toggleMapHeaderRowsVisibility 
// RESUMEN: Muestra/oculta la cabecera y llama a map.resize() de forma segura.
function toggleMapHeaderRowsVisibility(show) {
    const header = document.getElementById('reminders-location-map-header');
    if (!header) return;

    const togglePanel = document.getElementById('toggle-map-header-buttons-panel');

    const removeCountdownOverlay = () => {
        if (togglePanel) {
            const existingOverlay = togglePanel.querySelector('#map-header-countdown-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
        }
    };

    if (mapHeaderAutohideTimer) {
        clearInterval(mapHeaderAutohideTimer);
        mapHeaderAutohideTimer = null;
    }
    removeCountdownOverlay();

    if (isNavigating && show) {
        mapHeaderButtonsVisible = true;
        header.querySelectorAll('.button-row').forEach(row => {
            row.classList.remove('hidden-map-header');
        });

        if (togglePanel) {
            const countdownOverlay = document.createElement('span');
            countdownOverlay.id = 'map-header-countdown-overlay';
            countdownOverlay.style.cssText = `
                position: absolute;
                top: 50%; left: 50%;
                transform: translate(-50%, -50%);
                font-size: 48px; font-weight: bold;
                color: rgba(189, 150, 24, 0.7);
                z-index: 10; pointer-events: none;
                text-shadow: 2px 2px 3px rgba(0,0,0,0.6);
            `;
            togglePanel.appendChild(countdownOverlay);

            let countdown = 20;
            countdownOverlay.textContent = countdown;

            mapHeaderAutohideTimer = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownOverlay.textContent = countdown;
                } else {
                    clearInterval(mapHeaderAutohideTimer);
                    mapHeaderAutohideTimer = null;
                    removeCountdownOverlay();
                    if (mapHeaderButtonsVisible) {
                       toggleMapHeaderRowsVisibility(false);
                    }
                }
            }, 1000);
        }
    } else {
        mapHeaderButtonsVisible = show;
        header.querySelectorAll('.button-row').forEach(row => {
            row.classList.toggle('hidden-map-header', !show);
        });
    }
    
    if (navigationMapInstance) {
        setTimeout(() => {
            const mapContainer = document.getElementById('mapbox-map-actual-container');
            if (navigationMapInstance && mapContainer && mapContainer.offsetHeight > 0) {
                try {
                    navigationMapInstance.resize();
                } catch(e) {
                    console.error("Error al redimensionar el mapa (dentro del timeout):", e);
                }
            }
        }, 350);
    }
}    
    
// ===================================================================
// NOMBRE: eliminarRadaresDeRuta 
// RESUMEN: Elimina del mapa los radares que se habían añadido dinámicamente a la ruta.
function eliminarRadaresDeRuta() {
    reminderMapObjects = reminderMapObjects.filter(obj => {
        if (obj.isFromRuta) {
            if (obj.marker) obj.marker.remove();
            if (obj.circleId && navigationMapInstance.getLayer(obj.circleId)) {
                navigationMapInstance.removeLayer(obj.circleId);
            }
            if (obj.circleId && navigationMapInstance.getSource(obj.circleId)) {
                navigationMapInstance.removeSource(obj.circleId);
            }
            return false;
        }
        return true;
    });
    radaresEnRutaActual = [];
    actualizarContadorRadares(0);
    if (navigationCurrentRouteData?.routes?.[0]) { 
      
        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
}

// ===================================================================
// NOMBRE: handleZoomToggleButtonClick 
// RESUMEN: Se corrige la lógica para que la acción de "acercar al coche" no solo
function handleZoomToggleButtonClick(button) {
    if (!navigationMapInstance || !button) return;

    const currentState = button.dataset.zoomState || 'waypoints';
    
    if (currentState === 'car') { 
        const currentZoom = navigationMapInstance.getZoom();
        zoomToggleMemory = currentZoom;
        triggerManualMapInteraction(); // CORRECTO: Desactiva el seguimiento para dar control manual
        
        const newState = 'waypoints';
        button.dataset.zoomState = newState;
        const img = button.querySelector('img');
        if (img) img.src = 'PNG/ZOOM+.PNG';
        button.title = "Acercar a la ubicación del coche";
        const otherButtonId = button.id === 'zoom-toggle-button' ? 'nav-map-zoomtoggle-button' : 'zoom-toggle-button';
        const otherButton = document.getElementById(otherButtonId);
        if (otherButton) {
            otherButton.dataset.zoomState = newState;
            const otherImg = otherButton.querySelector('img');
            if (otherImg) otherImg.src = 'PNG/ZOOM+.PNG';
            otherButton.title = "Acercar a la ubicación del coche";
        }
        
        const routeSource = navigationMapInstance.getSource('route');
        if (routeSource && routeSource._data && routeSource._data.geometry && routeSource._data.geometry.coordinates.length > 1) {
            const coordinates = routeSource._data.geometry.coordinates;
            const bounds = new mapboxgl.LngLatBounds();
            coordinates.forEach(coord => bounds.extend(coord));
            if (!bounds.isEmpty()) {
                navigationMapInstance.fitBounds(bounds, { padding: 80, animate: true, duration: 1500 });
            }
        } else {
            navigationMapInstance.flyTo({ zoom: 10, duration: 1500 });
        }

    } else { 
        if (navigationCurrentLocation) {
            navigationFollowUser = true;
            shouldCenterOnUser = true;
            clearLocateMeReactivationTimer(); // Cancela cualquier temporizador de 30s pendiente
            updateLocateMeButtonsUI(); // Actualiza el icono del botón de localización para mostrar que está activo
            
            const newState = 'car';
            button.dataset.zoomState = newState;
            const img = button.querySelector('img');
            if (img) img.src = 'PNG/ZOOM-.PNG';
            button.title = "Alejar para ver la ruta completa";
            const otherButtonId = button.id === 'zoom-toggle-button' ? 'nav-map-zoomtoggle-button' : 'zoom-toggle-button';
            const otherButton = document.getElementById(otherButtonId);
            if (otherButton) {
                otherButton.dataset.zoomState = newState;
                const otherImg = otherButton.querySelector('img');
                if (otherImg) otherImg.src = 'PNG/ZOOM-.PNG';
                otherButton.title = "Alejar para ver la ruta completa";
            }
                        
            const animationOptions = { 
                center: [navigationCurrentLocation.longitude, navigationCurrentLocation.latitude], 
                zoom: zoomToggleMemory || 16, 
                duration: 1400 
            };
            
            if (mapViewMode === 'perspective') {
                animationOptions.pitch = mapPitchValue;
            } else {
                animationOptions.pitch = 0;
            }

            navigationMapInstance.easeTo(animationOptions);
            
            zoomToggleMemory = null; 
        
        } else {
            showToast("Ubicación actual no disponible para hacer zoom.", "warning");
        }
    }
}    
// ===================================================================
// NOMBRE: showPDRsFilterModal (MODIFICADA - PARA MAPBOX)
// RESUMEN: Muestra un modal de filtro que se adapta si hay o no una ruta cargada.
function showPDRsFilterModal() {
    const mapContainer = document.getElementById('reminders-location-map-modal');
    if (!mapContainer || !navigationMapInstance) {
        showToast("El mapa de navegación debe estar abierto para usar los filtros.", "error");
        return;
    }

    const hasRoute = navigationMapInstance.getSource('route') && 
                     navigationMapInstance.getSource('route')._data &&
                     navigationMapInstance.getSource('route')._data.geometry &&
                     navigationMapInstance.getSource('route')._data.geometry.coordinates &&
                     navigationMapInstance.getSource('route')._data.geometry.coordinates.length > 1;

    const PDR_MIN_POWER_KEY = 'boardinggate_pdrFilterMinPower';
    const PDR_MAX_POWER_KEY = 'boardinggate_pdrFilterMaxPower';
    const PDR_DISTANCE_KEY = 'boardinggate_pdrFilterDistance';
    const PDR_RADIUS_KEY = 'boardinggate_pdrFilterRadius';

    const savedMinPower = parseInt(localStorage.getItem(PDR_MIN_POWER_KEY)) || 30;
    const savedMaxPower = parseInt(localStorage.getItem(PDR_MAX_POWER_KEY)) || 600;
    const savedDistance = parseInt(localStorage.getItem(PDR_DISTANCE_KEY)) || 20;
    const savedRadius = parseInt(localStorage.getItem(PDR_RADIUS_KEY)) || 15;
    let distanceControlHtml;
    if (hasRoute) {
        distanceControlHtml = `
            <div id="distance-slider-container" class="filter-group">
                <label id="distance-range-label">Distancia Máxima a la Ruta: ${savedDistance} km</label> 
                <div class="slider-container single-slider-container">
                    <div class="slider-track"></div>
                    <div class="slider-range" id="distance-slider-range"></div>
                    <div class="slider-thumb" id="distance-thumb"></div>
                </div>
            </div>`;
    } else {
        distanceControlHtml = `
            <div id="radius-slider-container" class="filter-group">
                <label id="radius-range-label">Radio de Búsqueda: ${savedRadius} km</label> 
                <div class="slider-container single-slider-container">
                    <div class="slider-track"></div>
                    <div class="slider-range" id="radius-slider-range"></div>
                    <div class="slider-thumb" id="radius-thumb"></div>
                </div>
            </div>`;
    }

    const existingModal = document.getElementById('pdrs-filter-modal-overlay');
    if (existingModal) existingModal.remove();

    const savedOperatorFilter = localStorage.getItem('boardinggate_operator_filter') || '';
    const modalOverlay = document.createElement('div');
    modalOverlay.id = 'pdrs-filter-modal-overlay';
    modalOverlay.className = 'filter-modal-overlay';
    
    modalOverlay.innerHTML = `
        <div class="filter-modal-content">
            <h2>FILTRO PUNTOS DE CARGA</h2>
            <div class="filter-group">
                <label for="operator-filter-input">Filtrar operadores:</label>
                <div style="position: relative; width: 90%; margin: 5px auto 0 auto;">
                    <input type="text" id="operator-filter-input" value="${savedOperatorFilter}" placeholder="Ej: Zunder Iberdrola">
                    <button id="clear-operator-filter" title="Limpiar filtro de operadores" style="display: none;">×</button>
                </div>
            </div>
            <div class="filter-group">
                <label id="power-range-label">Potencia: ${savedMinPower} kW - ${savedMaxPower} kW</label> 
                <div class="slider-container">
                    <div class="slider-track"></div>
                    <div class="slider-range" id="power-slider-range"></div>
                    <div class="slider-thumb left" id="power-thumb-min"></div>
                    <div class="slider-thumb right" id="power-thumb-max"></div>
                </div>
            </div>
            
            <div class="ocm-color-legend">
                <div class="ocm-color-legend-item">
                    <div class="ocm-color-legend-icon" style="border-color: #0f130c;"></div>
                    <span>≤50kW</span>
                </div>
                <div class="ocm-color-legend-item">
                    <div class="ocm-color-legend-icon" style="border-color: #007863;"></div>
                    <span>≤100kW</span>
                </div>
                <div class="ocm-color-legend-item">
                    <div class="ocm-color-legend-icon" style="border-color: rgb(30, 144, 255);"></div>
                    <span>≤250kW</span>
                </div>
                <div class="ocm-color-legend-item">
                    <div class="ocm-color-legend-icon" style="border-color: #de2e03;"></div>
                    <span>>250kW</span>
                </div>
            </div>

            ${distanceControlHtml}
            
            <div class="filter-group" style="text-align: left; margin-top: 20px;">
                <label id="search-in-view-label">
                    <input type="checkbox" id="search-in-view-checkbox">
                    Buscar en la zona del mapa que estés viendo ahora
                </label>
            </div>

            <button id="accept-filters-btn">Aceptar <span class="button-countdown-timer unified-countdown-style"></span></button>

            <div class="ocm-modal-info-footer">
                <p><strong>(*) Cómo buscar:</strong> Si hay una ruta cargada, la búsqueda por defecto es sobre el trazado. Si no hay ruta, en un radio desde el centro. Para buscar siempre en la vista actual, marque la casilla superior.</p>
                <p><strong>(*) Secuencia del botón:</strong> 1ª Pulsación: Abre filtros. | 2ª Pulsación: Muestra solo los más económicos. | 3ª Pulsación: Limpia el mapa de PDRs.</p>
                <p style="margin-top:10px; font-style:italic;">Datos proporcionados por <a href="https://openchargemap.org" target="_blank">Open Charge Map</a>.</p>
            </div>
        </div>
    `;

    mapContainer.appendChild(modalOverlay);
    
    const PDR_SEARCH_IN_VIEW_KEY = 'boardinggate_pdrSearchInView';
    const searchInViewCheckbox = document.getElementById('search-in-view-checkbox');
    const distanceSliderContainer = document.getElementById('distance-slider-container') || document.getElementById('radius-slider-container');
    
    const updateControlsState = () => {
        if (searchInViewCheckbox.checked) {
            distanceSliderContainer.style.opacity = '0.5';
            distanceSliderContainer.style.pointerEvents = 'none';
        } else {
            distanceSliderContainer.style.opacity = '1';
            distanceSliderContainer.style.pointerEvents = 'auto';
        }
    };
    
    const savedSearchInView = localStorage.getItem(PDR_SEARCH_IN_VIEW_KEY) === 'true';
    searchInViewCheckbox.checked = savedSearchInView;
    searchInViewCheckbox.addEventListener('change', () => {
        localStorage.setItem(PDR_SEARCH_IN_VIEW_KEY, searchInViewCheckbox.checked);
        updateControlsState();
        markCacheAsDirty(); 
    });
    
    updateControlsState();

    const operatorInput = document.getElementById('operator-filter-input');
    const clearOperatorButton = document.getElementById('clear-operator-filter');
    
    const toggleClearButtonVisibility = () => {
        clearOperatorButton.style.display = operatorInput.value.trim() ? 'block' : 'none';
    };

    operatorInput.addEventListener('input', toggleClearButtonVisibility);
    clearOperatorButton.addEventListener('click', () => {
        operatorInput.value = '';
        toggleClearButtonVisibility();
        operatorInput.focus();
    });
    toggleClearButtonVisibility();

    const setupSlider = (idPrefix, minVal, maxVal, defaultMin, defaultMax, unit, isRange = true) => {
        const thumbMax = document.getElementById(`${idPrefix}-thumb` + (isRange ? '-max' : ''));
        if (!thumbMax) return () => ({ min: 0, max: 0 });
        const container = thumbMax.parentElement;
        const range = document.getElementById(`${idPrefix}-slider-range`);
        const label = document.getElementById(`${idPrefix}-range-label`);
        const thumbMin = isRange ? document.getElementById(`${idPrefix}-thumb-min`) : null;
        let currentMin = defaultMin; 
        let currentMax = defaultMax;

        const updateVisuals = () => {
            const minPercent = isRange ? ((currentMin - minVal) / (maxVal - minVal)) * 100 : 0;
            const maxPercent = ((currentMax - minVal) / (maxVal - minVal)) * 100;
            
            if (isRange && thumbMin) thumbMin.style.left = `${minPercent}%`;
            thumbMax.style.left = `${maxPercent}%`;
            range.style.left = `${minPercent}%`;
            range.style.width = `${maxPercent - minPercent}%`;
            
            if(isRange){
                label.textContent = `Potencia: ${Math.round(currentMin)} ${unit} - ${Math.round(currentMax)} ${unit}`;
            } else {
                label.textContent = `${hasRoute ? 'Distancia Máxima a la Ruta' : 'Radio de Búsqueda'}: ${Math.round(currentMax)} ${unit}`;
            }
        };

        const onDrag = (e, thumb) => {
            const rect = container.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let percent = ((clientX - rect.left) / rect.width) * 100;
            percent = Math.max(0, Math.min(100, percent));
            
            let value = minVal + (percent / 100) * (maxVal - minVal);
            
            if (isRange && thumb === thumbMin) {
                currentMin = Math.min(value, currentMax);
            } else {
                currentMax = isRange ? Math.max(value, currentMin) : value;
            }
            updateVisuals();
        };

        const thumbsToSetup = isRange ? [thumbMin, thumbMax] : [thumbMax];
        thumbsToSetup.forEach(thumb => {
            const startDrag = (e) => {
                const moveHandler = (moveEvent) => onDrag(moveEvent, thumb);
                const endDrag = () => {
                    document.removeEventListener('mousemove', moveHandler);
                    document.removeEventListener('mouseup', endDrag);
                    document.removeEventListener('touchmove', moveHandler);
                    document.removeEventListener('touchend', endDrag);
                };
                document.addEventListener('mousemove', moveHandler);
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchmove', moveHandler);
                document.addEventListener('touchend', endDrag);
            };
            thumb.addEventListener('mousedown', startDrag);
            thumb.addEventListener('touchstart', startDrag);
        });
        
        updateVisuals();
        return () => ({ min: isRange ? currentMin : minVal, max: currentMax });
    };

    const getPowerValues = setupSlider('power', 7, 2000, savedMinPower, savedMaxPower, 'kW', true);
    const getDistanceValues = hasRoute ? setupSlider('distance', 0, 50, 0, savedDistance, 'km', false) : () => ({});
    const getRadiusValues = !hasRoute ? setupSlider('radius', 1, 100, 1, savedRadius, 'km', false) : () => ({});

    const acceptButton = document.getElementById('accept-filters-btn');
    acceptButton.addEventListener('click', () => {
        const operatorFilterValue = document.getElementById('operator-filter-input').value;
        localStorage.setItem('boardinggate_operator_filter', operatorFilterValue);

        const powerFilters = getPowerValues();
        localStorage.setItem(PDR_MIN_POWER_KEY, Math.round(powerFilters.min));
        localStorage.setItem(PDR_MAX_POWER_KEY, Math.round(powerFilters.max));

        let searchConfig;
        if (hasRoute) {
            const distanceFilters = getDistanceValues();
            localStorage.setItem(PDR_DISTANCE_KEY, Math.round(distanceFilters.max));
            searchConfig = { type: 'route', distanceFilters };
        } else {
            const radiusFilters = getRadiusValues();
            localStorage.setItem(PDR_RADIUS_KEY, Math.round(radiusFilters.max));
            searchConfig = { type: 'radius', radiusKm: radiusFilters.max, center: navigationMapInstance.getCenter() };
        }
        markCacheAsDirty(); 
        
        if (navigationFollowUser) {
            const locateMeButton = document.getElementById('locate-me-on-reminders-map');
            if (locateMeButton) {
                handleLocateMeClick(locateMeButton);
                showToast('Seguimiento pausado por 1 minuto para explorar el mapa.', 'info', 4000);
                if (window.followMeReactivationTimer) {
                    clearTimeout(window.followMeReactivationTimer);
                }
                window.followMeReactivationTimer = setTimeout(() => {
                    if (!navigationFollowUser) {
                        handleLocateMeClick(locateMeButton);
                        showToast('Seguimiento automático reactivado.', 'info');
                    }
                    window.followMeReactivationTimer = null;
                }, 60000);
            }
        }

        modalOverlay.remove();
        findChargingPointsOnRoute(powerFilters, searchConfig);
    });

    addModalAutoCloseTimer(modalOverlay, acceptButton, 'pdrs-filter-modal', 20000);
}
// ===================================================================
// NOMBRE: handleTouchCancel
// RESUMEN: Maneja la cancelación de un arrastre táctil.
function handleTouchCancel(e) {    if (!isEditMode) return;     handleTouchEndCleanup(); 
}
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// NOMBRE: openLocationsPreviewMap 
// RESUMEN: Abre un mapa modal satélite y dibuja TODOS los marcadores de forma eficiente, corrigiendo el error de sintaxis en el filtro de la capa de texto.
function openLocationsPreviewMap() {
    closeOtherModals('locations-preview-modal');
    document.body.classList.add('modal-open');

    let modal = document.getElementById('locations-preview-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'locations-preview-modal';
        modal.innerHTML = `
            <h2 id="locations-preview-title">Ubicaciones con Recordatorios</h2>
            <div id="locations-preview-map-container" style="height: calc(100% - 100px); width: 100%;"></div>
            <div class="modal-top-buttons" style="justify-content: center; margin-top: 1rem;">
                <button id="close-locations-preview">Salir</button>
            </div>
        `;
        document.body.appendChild(modal);
    }
    
    modal.classList.remove('hidden');
    const mapContainerEl = modal.querySelector('#locations-preview-map-container');
    const closeButton = modal.querySelector('#close-locations-preview');
    const titleElement = modal.querySelector('#locations-preview-title');
    
    const closeHandler = () => {
        if (locationsPreviewMap) {
            try { locationsPreviewMap.remove(); } catch (e) {}
            locationsPreviewMap = null;
        }
        clearModalAutoCloseTimer(modal, closeButton, 'locations-preview-modal');
        modal.classList.add('hidden');
        document.body.classList.remove('modal-open');
    };

    const newCloseButton = closeButton.cloneNode(true);
    closeButton.parentNode.replaceChild(newCloseButton, closeButton);
    newCloseButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(modal, newCloseButton, 'locations-preview-modal', 120000);

    if (locationsPreviewMap) {
        try { locationsPreviewMap.remove(); } catch (e) {}
    }
    
    locationsPreviewMap = new mapboxgl.Map({
        container: mapContainerEl,
        style: 'mapbox://styles/mapbox/satellite-streets-v12', 
        center: [-3.703790, 40.416775],
        zoom: 6,
        attributionControl: true 
    });

    const plotAllLocations = async () => {
        await loadAndAddMapImages(locationsPreviewMap);

        const allReminders = JSON.parse(localStorage.getItem('reminders') || '[]').map(r => ({ ...r }));
        const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
        let locationsToPlot = allReminders.filter(r => {
            const hasLocation = r.isLocationEnabled && r.locationCoordinates?.latitude && r.locationCoordinates?.longitude;
            if (!hasLocation) return false;
            return showExcluded ? true : !r.excludeFromList;
        });

        if (titleElement) {
            titleElement.textContent = `Ubicaciones con Recordatorios ${showExcluded ? '(incl. Radares)' : '(sin Radares)'}`;
        }

        const geojsonFeatures = locationsToPlot.map(reminder => {
            const isRadar = reminder.text.toUpperCase().includes("RADAR") || reminder.excludeFromList;
            const speed = isRadar ? extractSpeedFromRadarText(reminder.text) : null;
            
            const properties = {
                reminderId: reminder.id,
                isRadar: isRadar,
                isFromTarea: reminder.isFromTarea || false,
            };
            if (speed !== null) {
                properties.speed = String(speed);
            }

            return {
                type: 'Feature',
                geometry: {
                    type: 'Point',
                    coordinates: [reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]
                },
                properties: properties
            };
        });

        const geojsonData = {
            type: 'FeatureCollection',
            features: geojsonFeatures
        };

        const sourceId = 'locations-preview-source';
        if (locationsPreviewMap.getSource(sourceId)) {
            locationsPreviewMap.getSource(sourceId).setData(geojsonData);
        } else {
            locationsPreviewMap.addSource(sourceId, { type: 'geojson', data: geojsonData });
        }

        const layers = [
            { id: 'preview-circles', type: 'circle', filter: ['==', 'isRadar', true], paint: {'circle-color': 'red', 'circle-radius': 15, 'circle-stroke-width': 2, 'circle-stroke-color': 'white'} },
            { id: 'preview-speed-text', type: 'symbol', filter: ['all', ['==', 'isRadar', true], ['has', 'speed']], layout: {'text-field': '{speed}', 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 12, 'text-allow-overlap': true}, paint: {'text-color': 'yellow'} },
            { id: 'preview-radar-text', type: 'symbol', filter: ['all', ['==', 'isRadar', true], ['!has', 'speed']], layout: { 'text-field': 'Rdar', 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 10, 'text-allow-overlap': true}, paint: { 'text-color': 'yellow'} },
            { id: 'preview-reminder-icons', type: 'symbol', filter: ['==', 'isRadar', false], layout: {'icon-image': 'reminder-icon', 'icon-size': 0.7, 'icon-allow-overlap': true, 'icon-anchor': 'bottom'} }
        ];

        layers.forEach(layer => {
            if (!locationsPreviewMap.getLayer(layer.id)) {
                locationsPreviewMap.addLayer({ ...layer, source: sourceId });
            }
        });
        
        setTimeout(() => {
            if (!locationsPreviewMap) return; 
            if (geojsonFeatures.length > 0) {
                const bounds = new mapboxgl.LngLatBounds();
                geojsonFeatures.forEach(feature => {
                    bounds.extend(feature.geometry.coordinates);
                });
                if (!bounds.isEmpty()) {
                    try {
                        locationsPreviewMap.fitBounds(bounds, { padding: 50, duration: 0 });
                    } catch(e) {
                        console.error("Error al ejecutar fitBounds en el modal de vista previa:", e);
                    }
                }
            } else {
                showToast(`No hay recordatorios con ubicación para mostrar según el filtro actual.`, "info");
            }
        }, 100);

        const interactiveLayers = ['preview-circles', 'preview-reminder-icons'];
        locationsPreviewMap.on('click', interactiveLayers, (e) => {
            if (e.features && e.features.length > 0) {
                const reminderId = e.features[0].properties.reminderId;
                showReminderActionModal(reminderId);
            }
        });

        locationsPreviewMap.on('mouseenter', interactiveLayers, () => { locationsPreviewMap.getCanvas().style.cursor = 'pointer'; });
        locationsPreviewMap.on('mouseleave', interactiveLayers, () => { locationsPreviewMap.getCanvas().style.cursor = ''; });
    };

    if (locationsPreviewMap.isStyleLoaded()) {
        plotAllLocations();
    } else {
        locationsPreviewMap.on('load', plotAllLocations);
    }
}    
// ===================================================================
// NOMBRE: showSavedLocationsModal (VERSIÓN FINAL CON REUTILIZACIÓN DE MAPA)
// RESUMEN: Muestra el modal de ubicaciones guardadas. El mapa selector se crea una
//          sola vez y se reutiliza, moviéndolo desde y hacia un "garaje" oculto
function showSavedLocationsModal(callbackOnClose, callbackOnSelectLocation, options = {}) {

    const existingModal = document.querySelector('.saved-locations-modal');
    if (existingModal) {
        if (locationPickerMap) { 
            const mapGarage = document.getElementById('map-garage');
            const mapContainer = locationPickerMap.getContainer();
            if (mapGarage && mapContainer) mapGarage.appendChild(mapContainer);
        }
        clearModalAutoCloseTimer(existingModal, existingModal.querySelector('#close-saved-locations-modal'), 'saved-locations-modal');
        existingModal.remove();
    }

    tempSavedLocations = getSavedLocations().map(loc => loc ? {...loc} : null);
    const modal = document.createElement('div');
    modal.className = 'saved-locations-modal';
    
    modal.innerHTML = `
        <h2>Gestionar Ubicaciones Guardadas (Máx. ${MAX_SAVED_LOCATIONS})</h2>
        <div class="modal-top-buttons">
            <button id="save-all-user-locations">Guardar Cambios</button>
            <button id="close-saved-locations-modal">Cerrar</button>
        </div>
        <div id="saved-locations-list"> 
            <!-- Los slots de ubicación se insertarán aquí por JavaScript -->
            <div id="location-picker-map-container">
                <button id="picker-ok-map-button" title="Confirmar esta posición">OK</button>
                <button id="picker-locate-me-button" title="Ir a mi posición actual">Mi Ubic.</button>
            </div>
        </div>
    `;
  
    const parent = options.parentContainer || document.body;
    parent.appendChild(modal);
    
    const listElement = modal.querySelector('#saved-locations-list');
    const mapPickerContainer = modal.querySelector('#location-picker-map-container');
    const okMapBtn = modal.querySelector('#picker-ok-map-button');
    const locateMeMapBtn = modal.querySelector('#picker-locate-me-button');
    const saveAllButton = modal.querySelector('#save-all-user-locations');
    const closeButton = modal.querySelector('#close-saved-locations-modal');

    function loadAndDisplaySlots() {
        listElement.querySelectorAll('.location-slot').forEach(el => el.remove());
        
        for (let i = 0; i < MAX_SAVED_LOCATIONS; i++) {
            const location = tempSavedLocations[i];
            const slotDiv = document.createElement('div');
            slotDiv.className = 'location-slot';
            slotDiv.innerHTML = ` <span style="width: 25px; text-align: right; font-weight: bold;">${i + 1}.</span> <input type="text" placeholder="Nombre Ubicación" value="${location?.name || ''}" data-index="${i}"> <button class="map-button" data-index="${i}" title="Fijar en Mapa">📍 Mapa</button> <button class="select-location-button" data-index="${i}" title="Seleccionar esta ubicación para el recordatorio actual">Seleccionar</button> <span class="coords-display">${location?.lat && location?.lng ? `${parseFloat(location.lat).toFixed(4)}, ${parseFloat(location.lng).toFixed(4)}` : 'No fijada'}</span> `;
            
            listElement.insertBefore(slotDiv, mapPickerContainer);
            
            slotDiv.querySelector('input[type="text"]').addEventListener('input', (e) => {
                if (!tempSavedLocations[i]) tempSavedLocations[i] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
                tempSavedLocations[i].name = e.target.value;
            });
            
            slotDiv.querySelector('.map-button').addEventListener('click', () => {
                currentEditingLocationSlotIndex = i;
                mapPickerContainer.classList.add('expanded');
                initializeLocationPickerMap('location-picker-map-container', i); // Llama a la nueva función optimizada

                setTimeout(() => {
                    if (listElement) {
                        listElement.scrollTo({ top: listElement.scrollHeight, behavior: 'smooth' });
                    }
                }, 100);
            });
            
            const selectButton = slotDiv.querySelector('.select-location-button');
            selectButton.addEventListener('click', () => {
                const selectedIndex = parseInt(selectButton.dataset.index);
                const selectedLocData = tempSavedLocations[selectedIndex];
                if (selectedLocData && selectedLocData.lat && selectedLocData.lng) {
                    if (callbackOnSelectLocation && typeof callbackOnSelectLocation === 'function') {
                        callbackOnSelectLocation({ name: selectedLocData.name, lat: selectedLocData.lat, lng: selectedLocData.lng, radius: selectedLocData.radius || DEFAULT_LOCATION_RADIUS });
                    }
                    
                    if (locationPickerMap) {
                        const mapGarage = document.getElementById('map-garage');
                        const mapContainer = locationPickerMap.getContainer();
                        if (mapGarage && mapContainer) mapGarage.appendChild(mapContainer);
                        locationPickerMap.activeSlotIndex = null;
                    }

                    clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
                    modal.remove();
                } else { showToast("Ubicación no fijada. Fíjala en el mapa primero", "warning"); }
            });
        }
    }
    
    loadAndDisplaySlots();

    okMapBtn.addEventListener('click', () => {
        if (locationPickerMarker && currentEditingLocationSlotIndex !== -1) {
            const pos = locationPickerMarker.getLngLat();
            if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
            tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat;
            tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng;
            const slotInput = listElement.querySelector(`.location-slot input[data-index="${currentEditingLocationSlotIndex}"]`); 
            if (slotInput) {
                const coordsDisplay = slotInput.closest('.location-slot').querySelector('.coords-display');
                if (coordsDisplay) { coordsDisplay.textContent = `${pos.lat.toFixed(4)}, ${pos.lng.toFixed(4)}`; }
            }
        }
        mapPickerContainer.classList.remove('expanded');
        
        if (locationPickerMap) {
            const mapGarage = document.getElementById('map-garage');
            const mapContainer = locationPickerMap.getContainer();
            if(mapGarage && mapContainer) mapGarage.appendChild(mapContainer);
            locationPickerMap.activeSlotIndex = null;
        }
        
        currentEditingLocationSlotIndex = -1;
    });

    locateMeMapBtn.addEventListener('click', () => {
        if (locationPickerMap) {
            locateMeMapBtn.disabled = true; locateMeMapBtn.textContent = 'Buscando...';
            getCurrentLocation(
                (coords) => {
                    locationPickerMap.flyTo({center: [coords.longitude, coords.latitude], zoom: 16});
                    if (locationPickerMarker) locationPickerMarker.setLngLat([coords.longitude, coords.latitude]);
                    if (currentEditingLocationSlotIndex !== -1) {
                        if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
                        tempSavedLocations[currentEditingLocationSlotIndex].lat = coords.latitude;
                        tempSavedLocations[currentEditingLocationSlotIndex].lng = coords.longitude;
                    }
                    locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.';
                },
                (errorMsg) => { showToast(`Error localización: ${errorMsg}`, 'error'); locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.'; }
            );
        }
    });

    saveAllButton.addEventListener('click', () => {
        const locationsToSave = tempSavedLocations.map(loc => {
            if (loc && (!loc.name || loc.name.trim() === '') && (loc.lat === null || loc.lng === null)) { return null; }
            if (loc && (loc.lat !== null && loc.lng !== null) && typeof loc.radius !== 'number') { loc.radius = DEFAULT_LOCATION_RADIUS; }
            return loc;
        }).filter(Boolean); 

        saveLocationsToCache(locationsToSave);
        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        savedRoutes = savedRoutes.filter(r => !r.name.startsWith("UBICACIÓN: "));

        locationsToSave.forEach(loc => {
            if (loc && loc.name && loc.lat && loc.lng) {
                const routeName = `UBICACIÓN: ${loc.name.toUpperCase()}`;
                const routeWaypoint = { id: Date.now() + Math.random(), lat: loc.lat, lng: loc.lng, type: 'F', label: 'F', address: loc.name, visited: false, isCriticalForRecalc: true };
                const existingRouteIndex = savedRoutes.findIndex(r => r.name === routeName);
                const routeToSave = { name: routeName, waypoints: [routeWaypoint], createdAt: new Date().toISOString() };
                if (existingRouteIndex !== -1) { savedRoutes[existingRouteIndex] = routeToSave; } else { savedRoutes.push(routeToSave); }
            }
        });
        if (savedRoutes.length > MAX_SAVED_ROUTES) {
             savedRoutes.sort((a,b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
             savedRoutes = savedRoutes.slice(0, MAX_SAVED_ROUTES);
        }
        localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes)); 
        showToast("Ubicaciones guardadas y sincronizadas.", "success"); 
        if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose();
        
        if (locationPickerMap) {
            const mapGarage = document.getElementById('map-garage');
            const mapContainer = locationPickerMap.getContainer();
            if (mapGarage && mapContainer) mapGarage.appendChild(mapContainer);
            locationPickerMap.activeSlotIndex = null;
        }

        clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
        modal.remove();
    });

    const closeHandler = () => {
        clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
        
        if (locationPickerMap) {
            const mapGarage = document.getElementById('map-garage');
            const mapContainer = locationPickerMap.getContainer();
            if (mapGarage && mapContainer) mapGarage.appendChild(mapContainer);
            locationPickerMap.activeSlotIndex = null;
        }

        if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose();
        modal.remove();
    };

    closeButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
}    
// ===================================================================
// NOMBRE: showRadarSpeedModal
// RESUMEN: Muestra un modal para seleccionar la velocidad de un radar a añadir.
function showRadarSpeedModal(callbackOnSelect) {
    closeOtherModals('radar-speed-selection-modal');
    
    const modal = document.createElement('div');
    modal.id = 'radar-speed-selection-modal';
    modal.className = 'reminder-modal';
    
    const speeds = [30, 50, 60, 70, 80, 90, 100, 120, 'TRAMO'];
    
    let buttonsHtml = '';
    speeds.forEach(speed => {
        const isDefault = speed === 50;
        buttonsHtml += `<button class="action-button secondary speed-option ${isDefault ? 'default-selection' : ''}" data-speed="${speed}">${speed}</button>`;
    });

    modal.innerHTML = `
        <style>
            #radar-speed-selection-modal .reminder-modal-body {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                gap: 1.5rem;
            }
            #radar-speed-selection-modal .speed-options-grid {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 1rem;
                width: 100%;
                max-width: 400px;
            }
            #radar-speed-selection-modal .speed-option.selected {
                background-color: #007aff;
                border: 2px solid white;
                transform: scale(1.05);
            }
            #radar-speed-selection-modal .speed-option.default-selection {
                background-color: #F59E0B;
            }
        </style>
        <div class="reminder-modal-header">
            <h2 class="reminder-modal-title">Velocidad del Radar</h2>
        </div>
        <div class="reminder-modal-body">
            <p style="font-size: 1.1rem; text-align: center;">Selecciona la velocidad o se guardará la opción por defecto en <span id="radar-modal-countdown">4</span>s.</p>
            <div class="speed-options-grid">
                ${buttonsHtml}
            </div>
        </div>
        <div class="reminder-modal-footer" style="justify-content: center;">
             <button id="cancel-radar-add" class="action-button danger">Cancelar</button>
        </div>
    `;

    document.body.appendChild(modal);

    let countdown = 4;
    const countdownElement = modal.querySelector('#radar-modal-countdown');
    
    const closeHandler = () => {
        if (countdownInterval) clearInterval(countdownInterval);
        if (modal.parentNode) modal.remove();
    };

    let countdownInterval = setInterval(() => {
        countdown--;
        if (countdownElement) countdownElement.textContent = countdown;
        if (countdown <= 0) {
            clearInterval(countdownInterval);
            const defaultSpeed = modal.querySelector('.speed-option.default-selection')?.dataset.speed || '50';
            callbackOnSelect(defaultSpeed);
            closeHandler();
        }
    }, 1000);

    modal.querySelectorAll('.speed-option').forEach(button => {
        button.addEventListener('click', () => {
            const selectedSpeed = button.dataset.speed;
            callbackOnSelect(selectedSpeed);
            closeHandler();
        });
    });

    modal.querySelector('#cancel-radar-add').addEventListener('click', () => {
        showToast("Creación de radar cancelada.", "info");
        callbackOnSelect(null);
        closeHandler();
    });
}

// ===================================================================
// NOMBRE: checkForExcessiveRadars (MODIFICADA - PRESERVA RADARES MANUALES)
// RESUMEN: Comprueba si el usuario tiene demasiados radares importados. Al limpiar,
function checkForExcessiveRadars() {
    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    const manualRadarReminders = reminders.filter(r => r && (r.text.toUpperCase().includes('RADAR') || r.excludeFromList === true) && !r.isDynamicRadar);

    if (manualRadarReminders.length > 200) {
        const modalId = 'excessive-radars-modal';
        const existingModal = document.getElementById(modalId);
        if (existingModal) return;

        const modal = document.createElement('div');
        modal.id = modalId;
        modal.className = 'choice-modal';
        modal.innerHTML = `
            <h2>Optimización de Radares</h2>
            <p style="margin-bottom: 1rem;">Hemos detectado que tienes <strong>${manualRadarReminders.length} radares</strong> importados. Un nuevo sistema carga automáticamente los radares cercanos para mejorar el rendimiento.</p>
            <p style="margin-bottom: 1.5rem; font-weight: bold;">¿Deseas eliminar los radares importados (excepto los creados manualmente con radio de 350m) y activar el nuevo sistema dinámico?</p>
            <div class="modal-top-buttons">
                <button id="confirm-radar-cleanup" class="choice-edit" style="background-color: #28a745; color: white;">Sí, limpiar y optimizar</button>
                <button id="cancel-radar-cleanup" class="choice-cancel">No, mantener mis radares</button>
            </div>
        `;
        document.body.appendChild(modal);

        const confirmBtn = document.getElementById('confirm-radar-cleanup');
        const cancelBtn = document.getElementById('cancel-radar-cleanup');
        
        const closeHandler = () => {
            clearModalAutoCloseTimer(modal, confirmBtn, modalId);
            if (modal.parentNode) modal.remove();
        };
        
        confirmBtn.addEventListener('click', async () => {
            showToast("Limpiando radares manuales antiguos...", "info", 0, false, "radar-cleanup-toast");
            
            const remindersToKeep = reminders.filter(r => {
                const isCandidateForDeletion = (r.text.toUpperCase().includes('RADAR') || r.excludeFromList === true) && !r.isDynamicRadar;
                
                if (!isCandidateForDeletion) {
                    return true;
                }
                
                if (r.radiusMeters === 350) {
                    return true;
                }
                
                return false;
            });
         
            localStorage.setItem('reminders', JSON.stringify(remindersToKeep));
            
            showToast("Guardando copia de seguridad en la nube...", "info", 0, false, "radar-cleanup-toast");
            await validateAndSaveUserToFirebase(); 
            
            const existingToast = document.getElementById("radar-cleanup-toast");
            if (existingToast) existingToast.remove();
            
            closeHandler();
            updateReminderCount();
            updateButtonStyles();
        });

        cancelBtn.addEventListener('click', () => {
             showToast("Optimización cancelada. Puedes limpiar los radares manualmente desde Configuración > Radares > Borrar.", "info", 8000);
             closeHandler();
        });
        
        addModalAutoCloseTimer(modal, confirmBtn, modalId, 60000);
    }
}    
    
// ===================================================================
// NOMBRE: toggleMapControls
// RESUMEN: Activa o desactiva los controles de planificación de ruta en el mapa (botones, buscador) y actualiza el estado de geolocalización.
function toggleMapControls(enabled) {
    
    const controls = [
        document.getElementById('map-location-search-input'),
        document.getElementById('map-location-search-button'),
        document.getElementById('clear-map-search-input-button'),
        document.getElementById('load-saved-route-button'),
        document.getElementById('reorder-route-stages-button'),
        document.getElementById('pdrs-ruta-button'),
        document.getElementById('add-reminder-at-location-button')
    ];

    controls.forEach(control => {
        if (control) {
            control.disabled = !enabled;
            control.style.opacity = enabled ? '1' : '0.5';
            control.style.cursor = enabled ? 'pointer' : 'not-allowed';
        }
    });
    
    setNavigationMapClickHandler();
}
    
// ===================================================================
// NOMBRE: getGridCellId
// RESUMEN: Calcula el ID de una celda de la cuadrícula espacial para un punto geográfico.
function getGridCellId(lat, lon) {
    const GRID_SIZE = 0.1;
    const latIndex = Math.floor(lat / GRID_SIZE);
    const lonIndex = Math.floor(lon / GRID_SIZE);
    return `cell_${latIndex}_${lonIndex}`;
}

// ===================================================================
// NOMBRE: initializeRadarCache 
// RESUMEN: Carga solo los radares de KLMFILES.TXT desde localStorage o los reconstruye si es necesario.
async function initializeRadarCache() {
    if (window.radarsCache) return; 
    if (isRadarCacheInitializing) {
        return new Promise(resolve => {
            const interval = setInterval(() => {
                if (!isRadarCacheInitializing) {
                    clearInterval(interval);
                    resolve();
                }
            }, 100);
        });
    }

    isRadarCacheInitializing = true;
    
    try {
        let remoteManifestDate = null;
        try {
            const response = await fetch(KML_FILES_LIST_STANDARD, { method: 'HEAD', cache: 'no-cache' });
            if (response.ok) {
                remoteManifestDate = response.headers.get('Last-Modified');
            }
        } catch (e) {
            console.warn("No se pudo obtener la fecha del manifiesto de radares, se forzará la recarga si no hay caché.");
        }

        const localCacheDate = localStorage.getItem('radarsCacheVersion');
        const cachedRadarsJSON = localStorage.getItem('radarsCacheData');
        const cachedIndexJSON = localStorage.getItem('radarsCacheIndex');

        if (remoteManifestDate && localCacheDate === remoteManifestDate && cachedRadarsJSON && cachedIndexJSON) {
            try {
                window.radarsCache = JSON.parse(cachedRadarsJSON);
                window.radarsSpatialIndex = JSON.parse(cachedIndexJSON);
                return; 
            } catch (e) {
                console.error("Error al parsear la caché de radares local. Se reconstruirá.", e);
            }
        }

    
        let filesToProcess = await fetchKMLFilesList(KML_FILES_LIST_STANDARD);

        const processingPromises = filesToProcess.map(kmlFileName => 
            fetchAndParseKML(KML_BASE_PATH + kmlFileName)
                .catch(error => {
                    console.warn(`No se pudo procesar el archivo ${kmlFileName}:`, error);
                    return [];
                })
        );
        
        const results = await Promise.all(processingPromises);
        
        const allRadars = [];
        const spatialIndex = {};

        results.flat().forEach(placemark => {
            const coords = placemark.coordinates;
            if (coords) {
                const [lonStr, latStr] = coords.split(',');
                const lon = parseFloat(lonStr);
                const lat = parseFloat(latStr);
                if (!isNaN(lat) && !isNaN(lon)) {
                    const radarData = { name: placemark.name, lat: lat, lon: lon };
                    allRadars.push(radarData);
                    
                    const cellId = getGridCellId(lat, lon);
                    if (!spatialIndex[cellId]) spatialIndex[cellId] = [];
                    spatialIndex[cellId].push(radarData);
                }
            }
        });
        
        window.radarsCache = allRadars;
        window.radarsSpatialIndex = spatialIndex;

        try {
            localStorage.setItem('radarsCacheData', JSON.stringify(allRadars));
            localStorage.setItem('radarsCacheIndex', JSON.stringify(spatialIndex));
            if (remoteManifestDate) {
                localStorage.setItem('radarsCacheVersion', remoteManifestDate);
            }
        } catch (e) {
            console.error("No se pudo guardar la caché de radares en localStorage:", e);
            showToast("No se pudo guardar la caché de radares. Puede que la optimización se repita.", "warning");
        }
        
        const existingToast = document.getElementById("radar-cache-init");
        if (existingToast) existingToast.remove();
       
    } catch (error) {
        showToast("Error crítico al inicializar la caché de radares.", "error");
        window.radarsCache = [];
        window.radarsSpatialIndex = {};
    } finally {
        isRadarCacheInitializing = false;
    }
}

    
// ===================================================================
// NOMBRE: deletePollMessage 
// RESUMEN: Permite al administrador borrar una encuesta permanentemente.
async function deletePollMessage(pollId) {
    if (!pollId) return;

    if (confirm('¿Estás seguro de que deseas eliminar esta encuesta/votación permanentemente?')) {
        try {
            const pollRef = window.doc(window.db, 'chatPolls', pollId);
            await window.deleteDoc(pollRef);
            showToast("Encuesta eliminada.", "success");
        } catch (error) {
            showToast("Error al eliminar la encuesta.", "error");
        }
    }
}

// ===================================================================
// NOMBRE: handlePollVote 
// RESUMEN: Gestiona el voto, actualiza la UI y actualiza el timestamp de la encuesta.
async function handlePollVote(pollId, optionIndex) {
    const currentUserId = localStorage.getItem('userData_userId');
    if (!currentUserId) {
        showToast("Debes configurar un ID de usuario para poder votar.", "warning");
        return;
    }

    const pollRef = window.doc(window.db, 'chatPolls', pollId);

    try {
        const pollSnap = await window.getDoc(pollRef);
        if (!pollSnap.exists()) {
            showToast("Error: La encuesta ya no existe.", "error");
            return;
        }

        const pollData = pollSnap.data();
        const updatedVotes = pollData.votes || {};

        if (updatedVotes[currentUserId] === optionIndex) {
            delete updatedVotes[currentUserId];
        } else {
            updatedVotes[currentUserId] = optionIndex;
        }

        await window.setDoc(pollRef, { 
            votes: updatedVotes,
            timestamp: window.serverTimestamp() 
        }, { merge: true });
        
        const pollElement = document.getElementById(`poll-${pollId}`);
        if (!pollElement) return;

        const totalVotes = Object.keys(updatedVotes).length;

        pollData.options.forEach((option, index) => {
            const optionElement = pollElement.querySelector(`[data-option-index="${index}"]`);
            if (!optionElement) return;

            const voteCount = Object.values(updatedVotes).filter(v => v === index).length;
            const percentage = totalVotes > 0 ? (voteCount / totalVotes) * 100 : 0;
            
            optionElement.querySelector('.poll-vote-count').textContent = voteCount;
            optionElement.querySelector('.poll-progress-fill').style.width = `${percentage}%`;
            
            const button = optionElement.querySelector('.poll-option-button');
            if (updatedVotes[currentUserId] === index) {
                button.classList.add('voted');
            } else {
                button.classList.remove('voted');
            }
            
            const voters = Object.entries(updatedVotes)
                .filter(([_, voteIndex]) => voteIndex === index)
                .map(([userId, _]) => userId);

            const votersList = optionElement.querySelector('.poll-voter-list');
            if (votersList) {
                if (voters.length > 0) {
                    votersList.innerHTML = voters.map(user => `<li class="poll-voter-name">${user}</li>`).join('');
                } else {
                    votersList.innerHTML = '';
                }
            }
        });

    } catch (error) {
        showToast("Error al registrar el voto.", "error");
    }
}

    
// ===================================================================
// NOMBRE: startEditPollQuestion 
// RESUMEN: Permite al admin editar la pregunta y actualiza el timestamp de la encuesta.
async function startEditPollQuestion(pollId, currentQuestion) {
    const newQuestion = prompt("Edita la pregunta de la encuesta:", currentQuestion);

    if (newQuestion && newQuestion.trim() !== '' && newQuestion !== currentQuestion) {
        try {
            const pollRef = window.doc(window.db, 'chatPolls', pollId);
            await window.setDoc(pollRef, { 
                question: newQuestion.trim(),
                timestamp: window.serverTimestamp() 
            }, { merge: true });
            showToast("Pregunta de la encuesta actualizada.", "success");
        } catch (error) {
            showToast("Error al actualizar la pregunta.", "error");
        }
    }
}

// ===================================================================
// NOMBRE: incrementMapSessionCount 
// RESUMEN: Incrementa el contador de sesiones de mapa del usuario en Firebase.
async function incrementMapSessionCount() {
    const { primaryId: userId } = parseUserId(localStorage.getItem('userData_userId'));
    if (!userId || !window.db) {
        return;
    }

    try {
        const userDocRef = window.doc(window.db, "user_data", userId);
        const docSnap = await window.getDoc(userDocRef);
        
        const now = new Date();
        const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        let newTotal = 1;
        let newMonthCount = 1;
        
        if (docSnap.exists()) {
            const data = docSnap.data();
            newTotal = (data.map_sessions_total || 0) + 1;
            
            if (data.map_sessions_last_month === currentMonthStr) {
                newMonthCount = (data.map_sessions_month || 0) + 1;
            } else {
                newMonthCount = 1;
            }
        }
        
        const dataToUpdate = {
            map_sessions_total: newTotal,
            map_sessions_month: newMonthCount,
            map_sessions_last_month: currentMonthStr
        };

        await window.setDoc(userDocRef, dataToUpdate, { merge: true });

    } catch (error) {
        console.error("Error al incrementar el contador de sesiones de mapa:", error);
    }
}

// ===================================================================
// NOMBRE: getGlobalMapSessionStats 
// RESUMEN: Calcula las estadísticas globales de sesiones de mapa de todos los usuarios.
async function getGlobalMapSessionStats() {
    if (!window.db) return { totalMonth: 0, totalHistoric: 0 };
    
    let totalMonth = 0;
    let totalHistoric = 0;
    
    try {
        const usersCollectionRef = window.collection(window.db, "user_data");
        const querySnapshot = await window.getDocs(usersCollectionRef);
        
        const now = new Date();
        const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        querySnapshot.forEach(doc => {
            const data = doc.data();
            totalHistoric += (data.map_sessions_total || 0);
            
            if (data.map_sessions_last_month === currentMonthStr) {
                totalMonth += (data.map_sessions_month || 0);
            }
        });

    } catch (error) {
        console.error("Error al obtener estadísticas globales de sesiones de mapa:", error);
    }
    
    return { totalMonth, totalHistoric };
}

// ===================================================================
// NOMBRE: displayAlertsOnMap 
// RESUMEN: Dibuja las alertas y añade un listener de clic a cada marcador para que sean interactivos.
function displayAlertsOnMap() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
        return;
    }
    
    const alertFeatures = trafficAlertsCache.map(alert => {
        if (alert.code === 9) return null;
        return {
            type: 'Feature',
            geometry: {
                type: 'Point',
                coordinates: [alert.coordinates.lon, alert.coordinates.lat]
            },
            properties: {
                code: alert.code,
                id: alert.id
            }
        };
    }).filter(Boolean);

    const geojsonData = {
        type: 'FeatureCollection',
        features: alertFeatures
    };

    const sourceId = 'traffic-alerts-source';
    const source = navigationMapInstance.getSource(sourceId);
    if (source) {
        source.setData(geojsonData);
    } else {
        navigationMapInstance.addSource(sourceId, {
            type: 'geojson',
            data: geojsonData
        });
    }

    const layerId = 'traffic-alerts-layer';
    if (!navigationMapInstance.getLayer(layerId)) {
        navigationMapInstance.addLayer({
            id: layerId,
            type: 'symbol',
            source: sourceId,
            layout: {
                'icon-image': [
                    'match',
                    ['get', 'code'],
                    1, 'alert-1',
                    2, 'alert-2',
                    3, 'alert-3',
                    4, 'alert-4',
                    5, 'alert-5',
                    6, 'alert-6',
                    7, 'alert-7',
                    8, 'alert-8',
                    'alert-5' // Icono por defecto (peligro)
                ],
                'icon-size': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    12, 0.30,  // A zoom 12 y menos, el icono tendrá ~50px de ancho
                    16, 0.50    // A zoom 16 y más, el icono tendrá ~100px de ancho
                ],
                'icon-allow-overlap': true,
                'icon-anchor': 'center'
            }
        });

        navigationMapInstance.on('mouseenter', layerId, () => { if(navigationMapInstance) navigationMapInstance.getCanvas().style.cursor = 'pointer'; });
        navigationMapInstance.on('mouseleave', layerId, () => { if(navigationMapInstance) navigationMapInstance.getCanvas().style.cursor = ''; });
    }
}
    
// ===================================================================
// NOMBRE: reAddCustomMapLayersAndSources 
// RESUMEN: Garantiza el orden de renderizado creando una capa de anclaje
async function reAddCustomMapLayersAndSources(mapInstance) {
    if (!mapInstance || !mapInstance.isStyleLoaded()) return;

    const routeGeojsonData = (navigationCurrentRouteData?.routes?.[0]?.geometry)
        ? { type: 'Feature', properties: {}, geometry: navigationCurrentRouteData.routes[0].geometry }
        : { type: 'FeatureCollection', features: [] };
    
    const speedMarkersGeojsonData = {
        type: 'FeatureCollection',
        features: speedMarkerFeatures || []
    };

    const layersToRemove = ['speed-markers-text', 'speed-markers-circle-bg', 'route', 'custom-layers-anchor'];
    const sourcesToRemove = ['speed-markers-source', 'route'];

    layersToRemove.forEach(id => { try { if (mapInstance.getLayer(id)) mapInstance.removeLayer(id); } catch (e) {} });
    sourcesToRemove.forEach(id => { try { if (mapInstance.getSource(id)) mapInstance.removeSource(id); } catch (e) {} });

    try {
        mapInstance.addSource('route', { type: 'geojson', data: routeGeojsonData });
        mapInstance.addSource('speed-markers-source', {  type: 'geojson', data: speedMarkersGeojsonData });
     
        mapInstance.addLayer({
            id: 'custom-layers-anchor',
            type: 'background',  paint: {
                'background-opacity': 0 }
        });

        mapInstance.addLayer({ 
            id: 'route', 
            type: 'line', 
            source: 'route', 
            layout: { 'line-join': 'round', 'line-cap': 'round' }, 
            paint: getRouteStyleProperties() 
        }, 'custom-layers-anchor'); 
        mapInstance.addLayer({ 
            id: 'speed-markers-circle-bg', 
            type: 'circle', 
            source: 'speed-markers-source', 
            paint: { 'circle-radius': 30, 'circle-color': '#FF2E08', 'circle-stroke-width': 6, 'circle-stroke-color': 'white' } 
        }, 'custom-layers-anchor'); 
        mapInstance.addLayer({ 
            id: 'speed-markers-text', 
            type: 'symbol', 
            source: 'speed-markers-source', 
            layout: { 'text-field': ['get', 'speedText'], 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 20, 'text-allow-overlap': true }, 
            paint: { 'text-color': 'white' } 
        }, 'custom-layers-anchor'); 
    } catch (e) {
        console.error("Error al re-añadir capas de ruta/velocidad:", e);
    }
}
    
// ===================================================================
// NOMBRE: updateLineWidthsOnPitchChange 
// RESUMEN: Ajusta el grosor de las líneas de ruta según la inclinación.
function updateLineWidthsOnPitchChange() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) return;

    const isPitched = navigationMapInstance.getPitch() > 20;
    const mainWidth = isPitched ? 16 : 12;
    const altWidth = isPitched ? 12 : 8;
    const completedWidth = isPitched ? 10 : 6;

    try {
        if (navigationMapInstance.getLayer('route')) {
            navigationMapInstance.setPaintProperty('route', 'line-width', mainWidth);
        }
        if (navigationMapInstance.getLayer('completed-segments-layer')) {
            navigationMapInstance.setPaintProperty('completed-segments-layer', 'line-width', completedWidth);
        }
        alternativeRouteLayers.forEach(alt => {
            if (navigationMapInstance.getLayer(alt.layerId)) {
                navigationMapInstance.setPaintProperty(alt.layerId, 'line-width', altWidth);
            }
        });
    } catch (e) { /* Ignorar errores si la capa no existe */ }
}

// ===================================================================
// NOMBRE: openChatModal 
// RESUMEN: Abre el modal, resetea la paginación e inicia la carga inicial.
async function openChatModal() {
    const modalOverlay = document.getElementById('chat-modal-overlay');
    if (!modalOverlay) return;
    
    // Resetea el estado de paginación para una carga limpia
    lastVisibleUserDoc = null;
    lastVisibleMessageDoc = null;
    isFetchingUsers = false;
    isFetchingMessages = false;
    
    document.body.classList.add('chat-open');
    modalOverlay.classList.remove('hidden');

    const sendButton = document.getElementById('chat-send-button');
    const messageInput = document.getElementById('chat-message-input');
    const charCounter = document.getElementById('chat-char-counter');
    const permissionWarning = document.getElementById('chat-permission-warning');
    const messagesContainer = document.getElementById('chat-messages-container');
    const usersListContainer = document.getElementById('chat-users-list');
    
    // La limpieza se delega a las funciones de renderizado para evitar conflictos
    
    const originalPlaceholder = "Escribe un mensaje... (antecede @usuario para mensaje privado, o pulsa en el lateral. Para referirse simplemente nómbralo). Vida de los mensajes 96 horas. En el coche usa los comandos de voz. Elon cree en la humanidad, the White Monkey y yo también, ser educad@s.";
    const pollPlaceholder = "Para encuestas/votaciones, usa el formato: #COMUNIDAD#Pregunta#Opción1 $ Opción2...#";
    messageInput.placeholder = `${originalPlaceholder} ${pollPlaceholder}`;

    const currentUserId = localStorage.getItem('userData_userId');
    const currentUserDmsAllowed = JSON.parse(localStorage.getItem('userData_allowDMs') || 'false');
    
    if (currentUserId === 'BoardingGate' && !sessionStorage.getItem('chatCleanupSessionDone')) {
        sessionStorage.setItem('chatCleanupSessionDone', 'true');
        showToast("Hola Admin. Realizando limpieza de mensajes antiguos...", "info");
        cleanUpOldChatMessages();
    }

    if (!currentUserId) {
        permissionWarning.textContent = "Debes configurar un ID de Usuario para poder chatear.";
        permissionWarning.classList.remove('hidden');
        sendButton.disabled = true;
        messageInput.disabled = true;
    } else if (!currentUserDmsAllowed) {
        permissionWarning.innerHTML = `Si quiere recibir mensajes o poder enviar mensajes tanto públicos como dirigidos a un usuario concreto debe activar en <strong>Configuración > Usuario > Permitir MDs (vía admin)</strong>`;
        permissionWarning.classList.remove('hidden');
        sendButton.disabled = true;
        messageInput.disabled = true;
    } else {
        permissionWarning.classList.add('hidden');
        sendButton.disabled = false;
        messageInput.disabled = false;
    }
    
    charCounter.textContent = messageInput.maxLength;
    
    if (!messageInput.listenerAdded) {
        messageInput.addEventListener('input', () => {
            const remaining = messageInput.maxLength - messageInput.value.length;
            charCounter.textContent = remaining;
        });
        messageInput.listenerAdded = true;
    }

    const newExitButton = document.getElementById('chat-exit-button').cloneNode(true);
    document.getElementById('chat-exit-button').parentNode.replaceChild(newExitButton, document.getElementById('chat-exit-button'));
    newExitButton.addEventListener('click', closeChatModal);

    const newSendButton = sendButton.cloneNode(true);
    sendButton.parentNode.replaceChild(newSendButton, sendButton);
    newSendButton.addEventListener('click', sendMessage);

    if (!messagesContainer.listenerAdded) {
        messagesContainer.addEventListener('click', (event) => {
            const target = event.target.closest('[data-action]');
            if (!target) return;

            event.stopPropagation();
            const action = target.dataset.action;
            const id = target.dataset.id;
            
            switch (action) {
                case 'vote-poll':
                    const optionIndex = parseInt(target.dataset.optionIndex, 10);
                    handlePollVote(id, optionIndex);
                    break;
                case 'edit-message':
                    const content = target.dataset.content;
                    startEditMessage(id, content);
                    break;
                case 'delete-message':
                    deleteChatMessage(id);
                    break;
                case 'edit-poll':
                    const question = target.dataset.question;
                    startEditPollQuestion(id, question);
                    break;
                case 'delete-poll':
                    deletePollMessage(id);
                    break;
            }
        });
        messagesContainer.addEventListener('scroll', () => {
            if (messagesContainer.scrollTop + messagesContainer.clientHeight >= messagesContainer.scrollHeight - 100) {
                fetchAndRenderChatMessages(true); // Cargar más
            }
        });
        messagesContainer.listenerAdded = true;
    }

    if (!usersListContainer.listenerAdded) {
        usersListContainer.addEventListener('scroll', () => {
            if (usersListContainer.scrollTop + usersListContainer.clientHeight >= usersListContainer.scrollHeight - 100) {
                fetchAndRenderChatUsers(true); 
            }
        });
        usersListContainer.listenerAdded = true;
    }

    await fetchAndRenderChatUsers(false); 
    await fetchAndRenderChatMessages(false); 
    updateTotalMessageCount();

    if (chatUpdateInterval) clearInterval(chatUpdateInterval);
    chatUpdateInterval = setInterval(() => {
        if (!modalOverlay.classList.contains('hidden')) {
            updateTotalMessageCount();
        }
    }, 15000);
}
    
// ===================================================================
// NOMBRE: fetchAndRenderChatMessages 
// RESUMEN: Carga mensajes y encuestas en lotes de 100 y gestiona el scroll infinito.
async function fetchAndRenderChatMessages(loadMore = false) {
    const messagesContainer = document.getElementById('chat-messages-container');
    if (!messagesContainer || !window.db || isFetchingMessages) return;

    const currentUserId = (localStorage.getItem('userData_userId') || '').trim();
    if (!currentUserId) {
        messagesContainer.innerHTML = '<p class="chat-system-message">Configura tu ID de usuario para ver el chat.</p>';
        return;
    }

    if (!loadMore) {
        messagesContainer.innerHTML = '';
    }
  
    if (loadMore && !lastVisibleMessageDoc) {
        return; 
    }

    isFetchingMessages = true;
    const currentUserIdLower = currentUserId.toLowerCase();

    try {
        const PAGE_SIZE = 100;
        const oneHundredTwentyHoursAgo = new Date(Date.now() - 120 * 60 * 60 * 1000);
        
        let messagesQuery;
        const messagesRef = window.collection(window.db, 'chatMessages');
        
        if (lastVisibleMessageDoc) {
            messagesQuery = window.query(messagesRef, window.where('timestamp', '>', oneHundredTwentyHoursAgo), window.orderBy('timestamp', 'desc'), window.startAfter(lastVisibleMessageDoc), window.limit(PAGE_SIZE));
        } else {
            messagesQuery = window.query(messagesRef, window.where('timestamp', '>', oneHundredTwentyHoursAgo), window.orderBy('timestamp', 'desc'), window.limit(PAGE_SIZE));
        }
        
        const pollsQuery = window.query(window.collection(window.db, 'chatPolls'), window.orderBy('timestamp', 'desc'));
        
        const [messagesSnapshot, pollsSnapshot] = await Promise.all([
            window.getDocs(messagesQuery),
            loadMore ? Promise.resolve({ docs: [] }) : window.getDocs(pollsQuery)
        ]);

        const messageDocs = messagesSnapshot.docs;
        if (messageDocs.length > 0) {
            lastVisibleMessageDoc = messageDocs[messageDocs.length - 1];
        } else {
            lastVisibleMessageDoc = null; 
        }

        let combinedItems = [];
        messageDocs.forEach(doc => combinedItems.push({ id: doc.id, ...doc.data(), isPoll: false }));
        
        if (!loadMore) {
            pollsSnapshot.forEach(doc => combinedItems.push({ id: doc.id, ...doc.data(), isPoll: true }));
        }

        if (!loadMore) {
            combinedItems.sort((a, b) => (b.timestamp?.toMillis() || 0) - (a.timestamp?.toMillis() || 0));
        }
        
        if (combinedItems.length === 0 && !loadMore) {
            messagesContainer.innerHTML = '<p class="chat-system-message">No hay mensajes recientes. ¡Sé el primero en escribir!</p>';
            isFetchingMessages = false;
            return;
        }

        combinedItems.forEach(item => {
            if (item.isPoll) {
                messagesContainer.appendChild(renderPollBubble(item, currentUserId));
            } else {
                const isPublic = item.recipientId.toLowerCase() === 'public';
                const isForMe = item.recipientId.toLowerCase() === currentUserIdLower;
                const iSentIt = item.senderId.toLowerCase() === currentUserIdLower;

                if (isPublic || isForMe || iSentIt) {
                    const bubble = document.createElement('div');
                    bubble.className = 'chat-message-bubble';
                    
                    let bubbleClass = '';
                    if (iSentIt && isPublic) { bubble.style.backgroundColor = '#DF6565'; bubbleClass = 'public-msg'; }
                    else if (isForMe && !iSentIt) { bubbleClass = 'private-msg'; }
                    else if (isPublic) { bubbleClass = 'public-msg'; }
                    else if (iSentIt && !isPublic) { bubbleClass = 'private-msg-sent'; }
                    bubble.classList.add(iSentIt ? 'sent' : 'received', bubbleClass);

                    const senderSpan = document.createElement('span');
                    senderSpan.className = 'chat-message-sender';
                    senderSpan.textContent = item.senderId + (item.recipientId.toLowerCase() !== 'public' ? ` a ${item.recipientId}` : '');
                    
                    const contentSpan = document.createElement('span');
                    contentSpan.className = 'chat-message-content';
                    contentSpan.textContent = item.content;
                    
                    const timeSpan = document.createElement('span');
                    timeSpan.className = 'chat-message-time';
                    const timeText = document.createElement('span');
                    timeText.textContent = item.timestamp?.toDate ? `${item.timestamp.toDate().toLocaleDateString([], {day:'2-digit', month:'2-digit'})} - ${item.timestamp.toDate().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}` : '';
                    timeSpan.appendChild(timeText);

                    if (iSentIt || currentUserId === 'BoardingGate') {
                        const actionsContainer = document.createElement('div');
                        actionsContainer.className = 'chat-message-actions';
                        
                        const editIcon = document.createElement('img');
                        editIcon.src = 'https://boardinggate.github.io/Tesla/PNG/editmsg.png';
                        editIcon.className = 'chat-action-icon';
                        editIcon.title = 'Editar mensaje';
                        editIcon.dataset.action = 'edit-message';
                        editIcon.dataset.id = item.id;
                        editIcon.dataset.content = item.content;

                        const deleteIcon = document.createElement('img');
                        deleteIcon.src = 'https://boardinggate.github.io/Tesla/PNG/erasemsg.png';
                        deleteIcon.className = 'chat-action-icon';
                        deleteIcon.title = 'Eliminar mensaje';
                        deleteIcon.dataset.action = 'delete-message';
                        deleteIcon.dataset.id = item.id;

                        actionsContainer.appendChild(editIcon);
                        actionsContainer.appendChild(deleteIcon);
                        timeSpan.appendChild(actionsContainer);
                    }
                    
                    bubble.appendChild(senderSpan);
                    bubble.appendChild(contentSpan);
                    bubble.appendChild(timeSpan);
                    messagesContainer.appendChild(bubble);
                }
            }
        });
        
        if (!loadMore) {
            messagesContainer.scrollTop = 0;
        }

    } catch (error) {
        messagesContainer.innerHTML = `<p class="chat-system-message">Error al cargar el chat: ${error.message}</p>`;
    } finally {
        isFetchingMessages = false;
    }
}
    
// ===================================================================
// NOMBRE: renderPollBubble 
// RESUMEN: Construye un elemento DOM para la encuesta, evitando errores de sintaxis.
function renderPollBubble(poll, currentUserId) {
    const totalVotes = Object.keys(poll.votes || {}).length;
    
    const pollBubble = document.createElement('div');
    pollBubble.id = `poll-${poll.id}`;
    pollBubble.className = 'chat-message-bubble chat-poll-bubble';

    const senderTime = poll.timestamp?.toDate 
        ? `${poll.timestamp.toDate().toLocaleDateString([], {day: '2-digit', month: '2-digit'})} - ${poll.timestamp.toDate().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`
        : 'enviando...';

    const senderInfo = document.createElement('div');
    senderInfo.className = 'poll-sender-info';
    senderInfo.innerHTML = `<span class="chat-message-sender">${poll.senderId}</span><span class="poll-time">${senderTime}</span>`;
    
    const questionEl = document.createElement('p');
    questionEl.className = 'poll-question';
    questionEl.textContent = poll.question;

    const optionsList = document.createElement('ul');
    optionsList.className = 'poll-options-list';

    poll.options.forEach((option, index) => {
        const voteCount = Object.values(poll.votes || {}).filter(voteIndex => voteIndex === index).length;
        const percentage = totalVotes > 0 ? (voteCount / totalVotes) * 100 : 0;
        const hasVotedThis = (poll.votes || {})[currentUserId] === index;

        const voters = Object.entries(poll.votes || {}).filter(([_, vIndex]) => vIndex === index).map(([userId, _]) => userId);
        
        const listItem = document.createElement('li');
        listItem.className = 'poll-option-item';
        listItem.dataset.optionIndex = index;

        const button = document.createElement('button');
        button.className = `poll-option-button ${hasVotedThis ? 'voted' : ''}`;
        button.dataset.action = 'vote-poll';
        button.dataset.id = poll.id;
        button.dataset.optionIndex = index;
        button.innerHTML = `<div class="poll-option-text">${option}</div><div class="poll-vote-count">${voteCount}</div>`;

        const progressBar = document.createElement('div');
        progressBar.className = 'poll-progress-bar';
        progressBar.innerHTML = `<div class="poll-progress-fill" style="width: ${percentage}%;"></div>`;
        
        const votersContainer = document.createElement('div');
        votersContainer.className = 'poll-voters-container';
        const votersUl = document.createElement('ul');
        votersUl.className = 'poll-voter-list';
        votersUl.innerHTML = voters.map(user => `<li class="poll-voter-name">${user}</li>`).join('');
        votersContainer.appendChild(votersUl);

        listItem.appendChild(button);
        listItem.appendChild(progressBar);
        listItem.appendChild(votersContainer);
        optionsList.appendChild(listItem);
    });

    pollBubble.appendChild(senderInfo);
    pollBubble.appendChild(questionEl);
    pollBubble.appendChild(optionsList);

    if (currentUserId === 'BoardingGate') {
        const moderationIcons = document.createElement('div');
        moderationIcons.className = 'poll-moderation-icons';
        
        const editIcon = document.createElement('img');
        editIcon.src = "https://boardinggate.github.io/Tesla/PNG/editmsg.png";
        editIcon.className = 'chat-action-icon';
        editIcon.title = "Editar pregunta";
        editIcon.dataset.action = "edit-poll";
        editIcon.dataset.id = poll.id;
        editIcon.dataset.question = poll.question;
        
        const deleteIcon = document.createElement('img');
        deleteIcon.src = "https://boardinggate.github.io/Tesla/PNG/erasemsg.png";
        deleteIcon.className = 'chat-action-icon';
        deleteIcon.title = "Eliminar encuesta";
        deleteIcon.dataset.action = "delete-poll";
        deleteIcon.dataset.id = poll.id;
        
        moderationIcons.appendChild(editIcon);
        moderationIcons.appendChild(deleteIcon);
        pollBubble.appendChild(moderationIcons);
    }
    
    return pollBubble;
}
    
// ===================================================================
// NOMBRE: adaptMapboxRouteToOSRMFormat (NUEVA FUNCIÓN)
// RESUMEN: Convierte la respuesta de la API de Mapbox al formato de OSRM.
function adaptMapboxRouteToOSRMFormat(mapboxRoute) {
    const adaptedLegs = mapboxRoute.legs.map(leg => {
        const adaptedSteps = leg.steps.map(step => {
            return {
                distance: step.distance,
                duration: step.duration,
                geometry: step.geometry,
                maneuver: {
                    bearing_after: step.maneuver.bearing_after,
                    bearing_before: step.maneuver.bearing_before,
                    location: step.maneuver.location,
                    modifier: step.maneuver.modifier,
                    type: step.maneuver.type,
                },
                name: step.name,
            };
        });
        return {
            distance: leg.distance,
            duration: leg.duration,
            steps: adaptedSteps,
            summary: leg.summary,
        };
    });
    return {
        distance: mapboxRoute.distance,
        duration: mapboxRoute.duration,
        geometry: mapboxRoute.geometry,
        legs: adaptedLegs,
    };
}
    

// ===================================================================
// NOMBRE: startEditMessage 
// RESUMEN: Prepara la UI para editar un mensaje existente.
function startEditMessage(messageId, content) {
    const messageInput = document.getElementById('chat-message-input');
    const sendButton = document.getElementById('chat-send-button');

    if (messageInput && sendButton) {
        messageInput.value = content;
        messageInput.dataset.editingMessageId = messageId;
        sendButton.textContent = 'Actualizar';
        messageInput.focus();
        }
}

// ===================================================================
// NOMBRE: deleteChatMessage 
// RESUMEN: Elimina un mensaje del chat y de Firebase previa confirmación.
async function deleteChatMessage(messageId) {
    if (!messageId) return;

    if (confirm('¿Estás seguro de que deseas eliminar este mensaje permanentemente?')) {
        try {
            const messageRef = window.doc(window.db, 'chatMessages', messageId);
            await window.deleteDoc(messageRef);
            
            openChatModal(); 

        } catch (error) {
        }
    }
}   
// ===================================================================
// NOMBRE: closeChatModal 
// RESUMEN: Cierra el modal, detiene timers y limpia el contenido para liberar memoria.
function closeChatModal() {
    const modalOverlay = document.getElementById('chat-modal-overlay');
    if (modalOverlay) {
        modalOverlay.classList.add('hidden');
    }
    document.body.classList.remove('chat-open'); 
    if (chatUpdateInterval) {
        clearInterval(chatUpdateInterval);
        chatUpdateInterval = null;
    }
    
    const messagesContainer = document.getElementById('chat-messages-container');
    const usersListContainer = document.getElementById('chat-users-list');

    if (messagesContainer) {
        messagesContainer.innerHTML = ''; 
    }
    if (usersListContainer) {
        usersListContainer.innerHTML = ''; 
    }
    
    lastVisibleUserDoc = null;
    lastVisibleMessageDoc = null;
    isFetchingUsers = false;
    isFetchingMessages = false;
}

// ===================================================================
// NOMBRE: updateTotalMessageCount 
// RESUMEN: Actualiza el contador de mensajes en el nuevo globo principal.
async function updateTotalMessageCount() {
    const globeButton = document.getElementById('chat-icon-button');
    const globeCounter = document.getElementById('chat-message-globe');
    if (!globeButton || !globeCounter || !window.db) return;

    try {
        const ninetySixHoursAgo = new Date(Date.now() - 96 * 60 * 60 * 1000);
        const messagesRef = window.collection(window.db, 'chatMessages');
        const q = window.query(messagesRef, window.where('timestamp', '>', ninetySixHoursAgo));
        
        const querySnapshot = await window.getDocs(q);
        const count = querySnapshot.size;

        if (count > 0) {
            globeCounter.textContent = count;
            globeButton.classList.remove('hidden');
        } else {
            globeCounter.textContent = '0';
             
        }
    } catch (error) {
        globeCounter.textContent = 'X';
        globeButton.classList.remove('hidden');
    }
}    

// ===================================================================
// NOMBRE: sendMessage 
// RESUMEN: Envía mensajes/encuestas y fuerza la actualización inmediata del chat.
async function sendMessage() {
    const messageInput = document.getElementById('chat-message-input');
    const sendButton = document.getElementById('chat-send-button');
    const content = messageInput.value.trim();
    const editingId = messageInput.dataset.editingMessageId;

    if (!content) {
        showToast("El mensaje no puede estar vacío.", "warning");
        return;
    }
    
    const currentUserId = localStorage.getItem('userData_userId');
    if (!currentUserId) {
        showToast("Error: No se ha podido identificar al usuario.", "error");
        return;
    }
    
    sendButton.disabled = true;

    try {
        if (content.toUpperCase().startsWith('#COMUNIDAD#')) {
            const parts = content.split('#');
            if (parts.length < 4 || !parts[2] || !parts[3]) {
                throw new Error("Formato de encuesta incorrecto. Use #COMUNIDAD#Pregunta#Opción1 $ Opción2 ...");
            }
            
            const question = parts[2].trim();
            const options = parts[3].split('$').map(opt => opt.trim()).filter(Boolean);

            if (options.length < 2 || options.length > 6) {
                throw new Error("Las encuestas deben tener entre 2 y 6 opciones.");
            }
            if (!question) {
                throw new Error("La pregunta de la encuesta no puede estar vacía.");
            }

            const newPoll = {
                senderId: currentUserId,
                question: question,
                options: options,
                timestamp: window.serverTimestamp(),
                votes: {}
            };

            await window.addDoc(window.collection(window.db, 'chatPolls'), newPoll);
            messageInput.value = '';

        } else if (editingId) {
            const messageRef = window.doc(window.db, 'chatMessages', editingId);
            await window.setDoc(messageRef, { content: content }, { merge: true });
            
            messageInput.value = '';
            delete messageInput.dataset.editingMessageId;
            sendButton.textContent = 'Enviar';
            showToast("Mensaje actualizado correctamente.", "success");

        } else {
            if (content.length > 500) {
                showToast("El mensaje excede los 500 caracteres.", "warning");
                sendButton.disabled = false;
                return;
            }
            
            let recipientId = 'public';
            let messageContent = content;
            const mentionMatch = content.match(/^@(\w+)\s/);
            
            if (mentionMatch) {
                const mentionedUser = mentionMatch[1];
                const usersRef = window.collection(window.db, "user_data");
                const q = window.query(usersRef, window.where("rss", "==", true));
                const querySnapshot = await window.getDocs(q);
                let foundRecipientId = null;

                querySnapshot.forEach(doc => {
                    const userData = doc.data();
                    const actualUserId = userData.usuario || doc.id;
                    if (actualUserId.toLowerCase() === mentionedUser.toLowerCase()) {
                        foundRecipientId = actualUserId;
                    }
                });

                if (foundRecipientId) {
                    recipientId = foundRecipientId;
                    messageContent = content.substring(mentionMatch[0].length).trim();
                } else {
                    showToast(`Usuario "@${mentionedUser}" no encontrado o no tiene MDs activados.`, "warning");
                    sendButton.disabled = false;
                    return;
                }
            }

            const newMessage = {
                senderId: currentUserId,
                recipientId: recipientId,
                content: messageContent,
                timestamp: window.serverTimestamp()
            };
            
            await window.addDoc(window.collection(window.db, 'chatMessages'), newMessage);
            messageInput.value = '';
        }
        
        messageInput.dispatchEvent(new Event('input')); 
        lastVisibleMessageDoc = null; // <-- Resetea la paginación para la recarga
        await fetchAndRenderChatMessages(false); // <-- Vuelve a llamar al renderizado

    } catch (error) {
        showToast(error.message || (editingId ? "Error al actualizar." : "Error al enviar."), "error");
    } finally {
        sendButton.disabled = false;
    }
}    



    
// ===================================================================
// NOMBRE: handleDragEnd
// RESUMEN: Maneja la finalización de una operación de arrastre.
function handleDragEnd(e) {     if (!isEditMode) return;  handleDragEndCleanup(); 
}
    
// ===================================================================
// NOMBRE: cleanUpOldChatMessages 
// RESUMEN: Borra los mensajes (no encuestas) con más de 120 horas (ejecutado por el admin).
async function cleanUpOldChatMessages() {
    if (!window.db) return;
    const oneHundredTwentyHoursAgo = new Date(Date.now() - 120 * 60 * 60 * 1000);
    const messagesRef = window.collection(window.db, 'chatMessages');
    const q = window.query(messagesRef, window.where('timestamp', '<=', oneHundredTwentyHoursAgo));

    try {
        const querySnapshot = await window.getDocs(q);
        if (querySnapshot.empty) {
            showToast("No hay mensajes antiguos que limpiar.", "info", 2000);
            return;
        }

        const batchPromises = [];
        const batchSize = 499;
        let currentBatch = window.writeBatch(window.db);
        let batchCount = 0;

        querySnapshot.forEach((doc, index) => {
            currentBatch.delete(doc.ref);
            batchCount++;
            if (batchCount === batchSize) {
                batchPromises.push(currentBatch.commit());
                currentBatch = window.writeBatch(window.db);
                batchCount = 0;
            }
        });
        
        if (batchCount > 0) {
            batchPromises.push(currentBatch.commit());
        }

        await Promise.all(batchPromises);
        showToast(`Limpieza completada: ${querySnapshot.size} mensajes eliminados.`, 'success');
        updateTotalMessageCount();

    } catch (error) {
        showToast('Error durante la limpieza de mensajes antiguos.', 'error');
    }
}    
    
// ===================================================================
// NOMBRE: createRouteLabelMarker 
// RESUMEN: Crea un icono de etiqueta personalizado para las rutas alternativas.
function createRouteLabelMarker(text, color) {
    const iconHtml = `<div class="route-label-marker" style="background-color: ${color};">${text}</div>`;
    const div = document.createElement('div');
    div.innerHTML = iconHtml;
    return div.firstChild; 
}

// ===================================================================
// NOMBRE: showAutoStartNavigationModal 
// RESUMEN: Llama a toggleNavigationState con 'isRecovery' como false.
function showAutoStartNavigationModal() {
    hideAutoStartNavigationModal();

    const progressBar = document.getElementById('navigation-bottom-progress-bar');
    if (progressBar) {
        progressBar.classList.add('progress-bar-partially-hidden');
    }

    const modal = document.createElement('div');
    modal.id = 'auto-start-nav-modal';
    
    let countdown = 20;
    
    modal.innerHTML = `
        <p class="auto-start-title">Ruta Calculada</p>
        <div id="start-nav-buttons-container">
            <button id="start-route-now-button">
                INICIAR RUTA <span class="button-countdown-timer unified-countdown-style">${countdown}</span>
            </button>
            <button id="start-and-add-reminder-button">
                Cargar al llegar
            </button>
            <button id="cancel-start-nav">Cancelar</button>
        </div>
        <p class="info-text">(*) Si prefiere otra ruta seleccione una de las alternativas mostradas.</p>
    `;

    document.body.appendChild(modal);

    const startButton = document.getElementById('start-route-now-button');
    const cancelButton = document.getElementById('cancel-start-nav');
    const startWithReminderButton = document.getElementById('start-and-add-reminder-button');

    const startNavAndClose = () => {
        hideAutoStartNavigationModal();
        if (!isNavigating) {
            toggleNavigationState(false, false);
        }
    };
    
    startButton.addEventListener('click', startNavAndClose);
    
    cancelButton.addEventListener('click', () => {
        hideAutoStartNavigationModal();
    });

    startWithReminderButton.addEventListener('click', () => {
        const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
        if (actualWaypoints.length < 2) {
            showToast("No hay un destino válido para crear el recordatorio.", "error");
            return;
        }
        const finalDestination = actualWaypoints[actualWaypoints.length - 1];

        const now = new Date();
        const newReminder = {
            id: Date.now(),
            text: '<b>CARGAR EL VEHICULO</b>',
            type: 'simple',
            time: '00:01',
            date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
            createdAt: now.toISOString(),
            managedByUser: false,
            isLocationEnabled: true,
            locationCoordinates: { latitude: finalDestination.lat, longitude: finalDestination.lng },
            radiusMeters: DEFAULT_LOCATION_RADIUS,
            excludeFromList: false
        };

        try {
            let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
            reminders.push(newReminder);
            localStorage.setItem('reminders', JSON.stringify(reminders));
            
            markCacheAsDirty();
            updateReminderCount();
            updateButtonStyles();
      
        } catch (e) {
            showToast("Error al guardar el recordatorio de carga.", "error");
        }

        startNavAndClose();
    });

    autoStartNavModalTimer = setInterval(() => {
        const isRouteStillValid = navigationCurrentRouteData && navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2;
        
        if (!isRouteStillValid) {
            hideAutoStartNavigationModal();
            return;
        }
        
        countdown--;
        
        const countdownSpan = document.querySelector('#auto-start-nav-modal .unified-countdown-style');
        
        if (countdown > 0) {
            if (countdownSpan) {
                countdownSpan.textContent = `${countdown}`;
            }
        } else {
            const btn = document.getElementById('start-route-now-button');
            if (btn) {
                startNavAndClose(); 
            }
        }
    }, 1000);
}    
    
// ===================================================================
// NOMBRE: selectAlternativeRoute 
// RESUMEN: Limpia las alternativas INMEDIATAMENTE, luego recalcula la ruta seleccionada.
async function selectAlternativeRoute(waypointId, routeType) {
    clearAlternativeRoutesDisplay();

    if (!alternativeRoutesCache.has(waypointId)) {
        showToast("Error de caché: No se encontraron datos para la ruta seleccionada.", "error");
        return;
    }

    const routesData = alternativeRoutesCache.get(waypointId);
    const selectedRouteData = routesData[routeType];

    if (!selectedRouteData || !selectedRouteData.geometry || !selectedRouteData.geometry.coordinates) {
        showToast("Error: La ruta alternativa seleccionada no tiene geometría válida.", "error");
        return;
    }

    selectedStageRoutes.set(waypointId, routeType);

    const endWaypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    if (endWaypointIndex < 1) return;

    let startWaypointIndex = -1;
    for (let i = endWaypointIndex - 1; i >= 0; i--) {
        if (navigationWaypoints[i] && !navigationWaypoints[i].isInternal) {
            startWaypointIndex = i;
            break;
        }
    }
    if (startWaypointIndex === -1) return;

    navigationWaypoints = navigationWaypoints.filter(wp => !(wp.isInternal && wp.parentWaypointId === waypointId));
    
    const geometryPoints = selectedRouteData.geometry.coordinates;
    const totalPoints = geometryPoints.length;
    const maxInternalPoints = 10;
    const step = totalPoints > maxInternalPoints + 2 ? Math.floor((totalPoints - 2) / maxInternalPoints) : 1;
    
    const internalWaypoints = [];
    for (let i = step; i < totalPoints - 1; i += step) {
         const coord = geometryPoints[i];
         internalWaypoints.push({
            id: Date.now() + Math.random() + i,
            lat: coord[1],
            lng: coord[0],
            type: 'internal',
            label: '',
            address: 'Punto de paso interno',
            isInternal: true,
            parentWaypointId: waypointId,
            visited: false,
            isCriticalForRecalc: true
        });
    }

    const newEndIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    navigationWaypoints.splice(newEndIndex, 0, ...internalWaypoints);
    
    await recalculateAndDrawRoute(true);
    
    const routeTypeTranslations = {
        'fastest': 'RÁPIDA',
        'shortest': 'CORTA',
        'alternative': 'ALTERNATIVA'
    };
    const translatedType = routeTypeTranslations[routeType] || routeType.toUpperCase();
    showToast(`Ruta para esta etapa cambiada a: ${translatedType}.`, "success");
}
    
// ===================================================================
// NOMBRE: drawAlternativeRoutes 
// RESUMEN: Dibuja en el mapa las polilíneas y etiquetas de las rutas alternativas.
function drawAlternativeRoutes(waypointId, routesData) {
    clearAlternativeRoutesDisplay(); 
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) return;

    const routeConfigs = [
        { type: 'fastest', data: routesData.fastest, color: '#0066FF', label: 'RAP' }, 
        { type: 'shortest', data: routesData.shortest, color: '#BA6BFF', label: 'COR' }, 
        { type: 'alternative', data: routesData.alternative, color: '#FF5900', label: 'ALT' } 
    ];

    routeConfigs.forEach((config, index) => {
        if (config.data && config.data.geometry) {
            const sourceId = `alt-route-${waypointId}-${config.type}`;
            const layerId = `alt-layer-${waypointId}-${config.type}`;
            const labelMarkerId = `alt-label-${waypointId}-${config.type}`;

            navigationMapInstance.addSource(sourceId, {
                type: 'geojson',
                data: config.data.geometry
            });
            navigationMapInstance.addLayer({
                id: layerId,
                type: 'line',
                source: sourceId,
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                paint: {
                    'line-color': config.color,
                    'line-width': (navigationMapInstance && navigationMapInstance.getPitch() > 20) ? 12 : 8,
                    'line-opacity': 0.8
                }
            });

            const midPoint = turf.along(config.data.geometry, turf.length(config.data.geometry) / 2).geometry.coordinates;
            const labelElement = createRouteLabelMarker(config.label, config.color);
            const labelMarker = new mapboxgl.Marker({ element: labelElement })
                .setLngLat(midPoint)
                .addTo(navigationMapInstance);
            
            labelMarker.getElement().addEventListener('click', (e) => {
                e.stopPropagation(); 
                selectAlternativeRoute(waypointId, config.type);
            });

            alternativeRouteLayers.push({ sourceId, layerId, labelMarker });
        }
    });
}

// ===================================================================
// NOMBRE: clearAlternativeRoutesDisplay 
// RESUMEN: Inicia el proceso de limpieza de rutas alternativas, delegando
function clearAlternativeRoutesDisplay() {
    if (!navigationMapInstance) {
        alternativeRouteLayers = [];
        return;
    }

    const itemsToClear = [...alternativeRouteLayers];
    alternativeRouteLayers = [];

    attemptClear(itemsToClear, 1);
}

// ===================================================================
// NOMBRE: attemptClear
// RESUMEN: Intenta limpiar los elementos de la ruta. Si alguno falla,
function attemptClear(itemsToClear, attemptNumber) {
    const MAX_ATTEMPTS = 5;
    const RETRY_DELAY_MS = 150; 

    if (attemptNumber > MAX_ATTEMPTS || itemsToClear.length === 0) {
        if (itemsToClear.length > 0) {
            console.error(`Fallo definitivo al limpiar ${itemsToClear.length} elementos de ruta alternativa tras ${MAX_ATTEMPTS} intentos.`);
        }
        return; // Detenemos la recursión
    }

    const failedItems = [];

    if (attemptNumber === 1) {
        document.querySelectorAll('.route-label-marker').forEach(el => el.remove());
    }

    itemsToClear.forEach(item => {
        let success = true;
        try {
            if (navigationMapInstance.getLayer(item.layerId)) {
                navigationMapInstance.removeLayer(item.layerId);
            }
            if (navigationMapInstance.getSource(item.sourceId)) {
                navigationMapInstance.removeSource(item.sourceId);
            }
            if (item.labelMarker && typeof item.labelMarker.remove === 'function') {
                item.labelMarker.remove();
            }
        } catch (e) {
            success = false;
            failedItems.push(item); // Si falla, lo añadimos a la lista de reintento
        }
    });

    if (failedItems.length > 0) {
        setTimeout(() => {
            attemptClear(failedItems, attemptNumber + 1);
        }, RETRY_DELAY_MS);
    }
}
    
// ===================================================================
// NOMBRE: fetchAndDisplayAlternativeRoutes 
// RESUMEN: Obtiene y muestra las rutas alternativas para una etapa específica.
async function fetchAndDisplayAlternativeRoutes(waypointId) {
    if (alternativeRoutesCache.has(waypointId)) {
        drawAlternativeRoutes(waypointId, alternativeRoutesCache.get(waypointId));
        return;
    }

    const endWaypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    if (endWaypointIndex < 1) return;

    let startWaypoint = null;
    for (let i = endWaypointIndex - 1; i >= 0; i--) {
        if (navigationWaypoints[i] && !navigationWaypoints[i].isInternal) {
            startWaypoint = navigationWaypoints[i];
            break;
        }
    }
    
    if (!startWaypoint) return;
    const endWaypoint = navigationWaypoints[endWaypointIndex];

    const url = `${OSRM_SERVICE_URL}/driving/${startWaypoint.lng},${startWaypoint.lat};${endWaypoint.lng},${endWaypoint.lat}?alternatives=true&overview=full&geometries=geojson&steps=false`;

    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Respuesta de red no fue OK');
        const data = await response.json();

        if (!data.routes || data.routes.length < 1) {
             showToast("NO HAY RUTAS ALTERNATIVAS", "info");
            return;
        }

        const fastestRoute = data.routes[0];
        const shortestRoute = [...data.routes].sort((a, b) => a.distance - b.distance)[0];
        const alternativeRoute = data.routes.find(r => r !== fastestRoute && r !== shortestRoute) || null;
        
        if (fastestRoute === shortestRoute && !alternativeRoute) {
            showToast("NO HAY RUTAS ALTERNATIVAS", "info");
            return;
        }

        const routesData = {
            fastest: fastestRoute,
            shortest: fastestRoute === shortestRoute ? null : shortestRoute,
            alternative: alternativeRoute
        };

        alternativeRoutesCache.set(waypointId, routesData);
        drawAlternativeRoutes(waypointId, routesData);

    } catch (error) {
        showToast("Error al obtener rutas alternativas", "error");
    }
}
   
// ===================================================================
// NOMBRE: cancelAutoStartNav 
// RESUMEN: Cancela la navegación automática iniciada al cargar una ruta.
function cancelAutoStartNav(toastId) {
    if (autoStartNavTimer) {
        clearInterval(autoStartNavTimer);
        autoStartNavTimer = null;
    }
    const toastElement = document.getElementById(toastId);
    if (toastElement) {
        toastElement.remove();
        activeToasts = activeToasts.filter(t => t.id !== toastId);
    }
    }
window.cancelAutoStartNav = cancelAutoStartNav;

// ===================================================================
// NOMBRE: showChargingPointModal (MODIFICADA - PARA MAPBOX POPUP)
// RESUMEN: Crea y muestra un modal detallado para un punto de recarga OCM.
function showChargingPointModal(point, index) {
    const existingModal = document.querySelector('.ocm-modal-overlay');
    if (existingModal) existingModal.remove();

    const overlay = document.createElement('div');
    overlay.className = 'ocm-modal-overlay';

    const photoUrl = (point.MediaItems && point.MediaItems.length > 0 && point.MediaItems[0].ItemURL) 
        ? point.MediaItems[0].ItemURL 
        : 'https://boardinggate.github.io/Tesla/PNG/PDREJEMPLO.PNG';
    
    const addressInfo = point.AddressInfo || {};
    const stationName = addressInfo.Title || 'Punto de Recarga';
    
    let addressParts = [];
    if (addressInfo.AddressLine1) addressParts.push(addressInfo.AddressLine1);
    
    const locationName = addressInfo.Town || addressInfo.StateOrProvince;
    if (addressInfo.Postcode && locationName) {
        addressParts.push(`${addressInfo.Postcode} - ${locationName}`);
    } else if (addressInfo.Postcode) {
        addressParts.push(addressInfo.Postcode);
    } else if (locationName) {
        addressParts.push(locationName);
    }
    const addressHtml = addressParts.join('<br>');

    const operatorInfo = point.OperatorInfo || {};

    let detailsHtml = '<h4>Detalles de Ubicación</h4>';
    detailsHtml += `<p><strong>Dirección Completa:</strong> ${addressInfo.Title}</p>`;
    detailsHtml += `<p><strong>Lat/Lon:</strong> ${addressInfo.Latitude.toFixed(5)}, ${addressInfo.Longitude.toFixed(5)}</p>`;
    
    const lat = addressInfo.Latitude;
    const lon = addressInfo.Longitude;
    const zoom = 17;

    const googleUrl = `https://www.google.com/maps/search/electric+vehicle+charging+stations/@${lat},${lon},${zoom}z`;
    const electroverseUrl = `https://electroverse.com/map?search=${lat}%2C${lon}`;
    const electromapsUrl = `https://map.electromaps.com/es/p/${lat},${lon}`;
    const reveUrl = "https://www.mapareve.es/mapa-puntos-recarga";

    detailsHtml += `
        <div class="ocm-external-links-container">
            <div class="ocm-external-links-left-group">
                <span class="ocm-external-links-label">Abrir en...</span>
                <p class="ocm-external-links-note">
                    <span style="font-size: 0.6rem;">(*) Para volver retroceda en el browser</span>
                </p>
            </div>
            <div class="ocm-external-links-buttons">
                <a href="${googleUrl}" target="_blank" rel="noopener noreferrer" class="ocm-external-link-btn" title="Abrir en Google Maps" onclick="event.stopPropagation();">
                    <img src="https://www.google.com/s2/favicons?domain=maps.google.com&sz=64" alt="Google Maps">
                </a>
                <a href="${reveUrl}" target="_blank" rel="noopener noreferrer" class="ocm-external-link-btn" title="Abrir en REVE (no admite localización)" onclick="event.stopPropagation();">
                    <img src="https://www.google.com/s2/favicons?domain=mapareve.es&sz=64" alt="REVE">
                </a>
                <a href="${electroverseUrl}" target="_blank" rel="noopener noreferrer" class="ocm-external-link-btn" title="Abrir en Electroverse" onclick="event.stopPropagation();">
                    <img src="https://www.google.com/s2/favicons?domain=electroverse.com&sz=64" alt="Electroverse">
                </a>
                <a href="${electromapsUrl}" target="_blank" rel="noopener noreferrer" class="ocm-external-link-btn" title="Abrir en Electromaps" onclick="event.stopPropagation();">
                    <img src="https://www.google.com/s2/favicons?domain=electromaps.com&sz=64" alt="Electromaps">
                </a>
                <button class="ocm-external-link-btn" title="Enviar a la app de Tesla" onclick="handleSendToTeslaClick(${lat}, ${lon}, '${stationName.replace(/'/g, "\\'")}'); event.stopPropagation();">
                    <img src="https://boardinggate.github.io/Tesla/PNG/th.jpeg" alt="Enviar a Tesla">
                </button>
            </div>
        </div>
    `;

    detailsHtml += '<h4>Equipamiento / Tarifa</h4>';
    if (point.Connections && point.Connections.length > 0) {
        point.Connections.forEach(conn => {
            const connType = conn.ConnectionType ? conn.ConnectionType.Title.replace(' (Socket)', '').replace(' (Connector)', '') : 'Desconocido';
            const power = conn.PowerKW ? `${conn.PowerKW.toFixed(0)} kW` : '';
            const status = conn.StatusType ? `(${translateOcmTerm(conn.StatusType.Title)})` : '';
            detailsHtml += `
                <div class="ocm-connection-item">
                    <span class="ocm-connection-type">• ${connType}</span>
                    <span class="ocm-connection-power-status">${power} ${status}</span>
                </div>`;
        });
    } else {
        detailsHtml += '<p>No hay información de conectores.</p>';
    }
    if (point.UsageCost) detailsHtml += `<p class="ocm-price-info"><strong>${point.UsageCost}</strong></p>`;

    detailsHtml += '<h4>Restricciones de Uso</h4>';
    detailsHtml += `<p><strong>Estado:</strong> ${translateOcmTerm(point.StatusType?.Title)}</p>`;
    detailsHtml += `<p><strong>Uso:</strong> ${translateOcmTerm(point.UsageType?.Title)}</p>`;

    detailsHtml += '<h4>Operador/Red</h4>';
    detailsHtml += `<p><strong>Nombre:</strong> ${operatorInfo.Title || 'No especificado'}</p>`;
    if (operatorInfo.WebsiteURL) detailsHtml += `<p><strong>Web:</strong> <a href="${operatorInfo.WebsiteURL}" target="_blank" rel="noopener noreferrer">${operatorInfo.WebsiteURL}</a></p>`;
    if (operatorInfo.PhonePrimaryContact) detailsHtml += `<p><strong>Teléfono:</strong> <a href="tel:${operatorInfo.PhonePrimaryContact}">${operatorInfo.PhonePrimaryContact}</a></p>`;

    let photosHtml = '<div class="ocm-photo-grid">';
    if (point.MediaItems && point.MediaItems.length > 0) {
        point.MediaItems.forEach(item => {
            if (item.ItemURL) {
                 photosHtml += `<img src="${item.ItemURL}" alt="${item.Comment || 'Foto del punto de recarga'}" data-full-url="${item.ItemURL}">`;
            }
        });
    } else {
        photosHtml += '<p>No hay fotografías disponibles para este punto.</p>';
    }
    photosHtml += '</div>';

    let commentsHtml = '<ul class="ocm-comment-list">';
    if (point.UserComments && point.UserComments.length > 0) {
        point.UserComments.forEach(comment => {
            commentsHtml += `
                <li class="ocm-comment">
                    <div class="ocm-comment-header">
                        <span class="user">${comment.UserName || 'Anónimo'}</span>
                        <span class="date">${comment.DateCreated ? formatDateToDDMMMYY(comment.DateCreated.split('T')[0]) : ''}</span>
                    </div>
                    <p class="comment-text">${comment.Comment}</p>
                </li>`;
        });
    } else {
        commentsHtml += '<p>No hay comentarios para este punto.</p>';
    }
    commentsHtml += '</ul>';

    overlay.innerHTML = `
        <div class="ocm-modal-content">
            <div class="ocm-modal-header" style="background-image: url('${photoUrl}')">
                <div class="ocm-modal-station-name-wrapper">
                    <span class="ocm-modal-station-name">${stationName}</span>
                </div>
                <div class="ocm-modal-address">${addressHtml}</div>
            </div>
            <div class="ocm-modal-tabs">
                <div class="ocm-modal-tab active" data-panel="details">DETALLES</div>
                <div class="ocm-modal-tab" data-panel="photos">FOTOS (${point.MediaItems?.length || 0})</div>
                <div class="ocm-modal-tab" data-panel="comments">COMENTARIOS (${point.UserComments?.length || 0})</div>
            </div>
            <div class="ocm-modal-body">
                <div id="ocm-panel-details" class="ocm-modal-panel active">${detailsHtml}</div>
                <div id="ocm-panel-photos" class="ocm-modal-panel">${photosHtml}</div>
                <div id="ocm-panel-comments" class="ocm-modal-panel">${commentsHtml}</div>
            </div>
            <div class="ocm-modal-footer">
                <button id="ocm-add-route-btn" data-index="${index}">Añadir a la Ruta</button>
                <button id="ocm-close-btn">Salir</button>
            </div>
        </div>
    `;

    const mapModalContainer = document.getElementById('reminders-location-map-modal');
    if (mapModalContainer) {
        mapModalContainer.appendChild(overlay);
    } else {
        document.body.appendChild(overlay);
    }

    const closeBtn = overlay.querySelector('#ocm-close-btn');
    let modalTimer = null;

    const closeHandler = () => {
        if (modalTimer) clearInterval(modalTimer);
        if (overlay.parentNode) {
            overlay.remove();
        }
    };
    closeBtn.addEventListener('click', closeHandler);
    
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            closeHandler();
        }
    });
    
    overlay.querySelector('#ocm-add-route-btn').addEventListener('click', (e) => {
        const pointIndex = parseInt(e.target.dataset.index);
        addChargingPointToRoute(pointIndex);
        closeHandler();
    });

    overlay.querySelectorAll('.ocm-modal-tab').forEach(tab => {
        tab.addEventListener('click', () => {
            overlay.querySelectorAll('.ocm-modal-tab').forEach(t => t.classList.remove('active'));
            overlay.querySelectorAll('.ocm-modal-panel').forEach(p => p.classList.remove('active'));
            tab.classList.add('active');
            overlay.querySelector(`#ocm-panel-${tab.dataset.panel}`).classList.add('active');
        });
    });

    overlay.querySelectorAll('.ocm-photo-grid img').forEach(img => {
        img.addEventListener('click', () => {
            showPhotoModal(img.dataset.fullUrl);
        });
    });

    let countdown = 70;
    
    const countdownSpan = document.createElement('span');
    countdownSpan.className = 'button-countdown-timer unified-countdown-style';
    countdownSpan.textContent = ` ${countdown}`;
    closeBtn.appendChild(countdownSpan);

    modalTimer = setInterval(() => {
        countdown--;
        countdownSpan.textContent = ` ${countdown}`;
        if (countdown <= 0) {
            closeHandler();
        }
    }, 1000);
}

// ===================================================================
// NOMBRE: showShareStageModal (NUEVA FUNCIÓN)
// RESUMEN: Muestra un modal para que el usuario seleccione qué etapa de una ruta compartir.
function showShareStageModal(routeObject) {
    if (!routeObject || !routeObject.waypoints || routeObject.waypoints.length === 0) {
        showToast("No hay etapas para compartir en esta ruta.", "error");
        return;
    }

    const existingOverlay = document.getElementById('share-stage-modal-overlay');
    if (existingOverlay) existingOverlay.remove();

    const overlay = document.createElement('div');
    overlay.id = 'share-stage-modal-overlay';
    overlay.className = 'route-modal-overlay';

    const modalContent = document.createElement('div');
    modalContent.id = 'share-stage-modal';
    modalContent.className = 'route-modal-container';

    modalContent.innerHTML = `
        <div class="route-modal-header" style="background-image: url('https://boardinggate.github.io/Tesla/PNG/modalrutas.png');">
            <div class="route-modal-title-card">
                <span class="route-modal-title">Compartir Etapa de Ruta</span>
            </div>
        </div>
        <div class="route-modal-body">
            <p style="margin-bottom: 15px; font-weight: 500; color: #333;">Selecciona una etapa para compartir sus coordenadas:</p>
            <div class="route-scroll-container">
                <ul id="share-stage-list" class="route-list"></ul>
            </div>
        </div>
        <div class="route-modal-footer">
            <button id="cancel-share-stage" class="btn-modal-action-secondary">Cancelar</button>
        </div>
    `;

    overlay.appendChild(modalContent);
    document.body.appendChild(overlay);

    const listElement = modalContent.querySelector('#share-stage-list');
    const cancelButton = modalContent.querySelector('#cancel-share-stage');

    const closeShareModal = () => {
        clearModalAutoCloseTimer(overlay, cancelButton, 'share-stage-modal');
        if (overlay.parentNode) overlay.remove();
    };

    routeObject.waypoints.forEach((waypoint, index) => {
        const li = document.createElement('li');
        li.className = 'route-list-item';
        li.style.cursor = 'pointer';

        const stageLabel = waypoint.type === 'S' ? 'Salida' : (waypoint.type === 'F' ? 'Destino' : `Etapa ${waypoint.label}`);
        const addressText = waypoint.address || `(${waypoint.lat.toFixed(4)}, ${waypoint.lng.toFixed(4)})`;

        li.innerHTML = `<span class="route-name" style="color: #105a52;"><strong>${stageLabel}:</strong> ${addressText}</span>`;
        
        li.addEventListener('click', () => {
            handleSendToTeslaClick(waypoint.lat, waypoint.lng, addressText);
            closeShareModal();
        });
        
        listElement.appendChild(li);
    });

    cancelButton.addEventListener('click', closeShareModal);
    addModalAutoCloseTimer(overlay, cancelButton, 'share-stage-modal', 25000);
}

// ===================================================================
// NOMBRE: getChargingPointColorByPower
// RESUMEN: Devuelve un color hexadecimal basado en el rango de potencia del PDR.
function getChargingPointColorByPower(power) {
    if (isNaN(power)) {
        return '#5e5e5e'; }
    if (power >= 0 && power <= 50) {
        return '#0f130c'; 
    } else if (power > 50 && power <= 100) {
        return '#007863'; 
    } else if (power > 100 && power <= 250) {
        return 'rgb(30, 144, 255)'; 
    } else if (power > 250 && power <= 2000) {
        return '#de2e03'; 
    }
    return '#5e5e5e'; 
}  

// ===================================================================
// NOMBRE: showPhotoModal
// RESUMEN: Muestra una imagen en un modal superpuesto.
function showPhotoModal(imageUrl) {
    const existingModal = document.querySelector('.ocm-photo-modal-overlay');
    if (existingModal) existingModal.remove();

    const overlay = document.createElement('div');
    overlay.className = 'ocm-photo-modal-overlay';
    
    overlay.innerHTML = `
        <div class="ocm-photo-modal-content">
            <img src="${imageUrl}" alt="Vista ampliada del punto de recarga">
            <div class="ocm-photo-modal-close-btn" title="Cerrar imagen">×</div>
        </div>
    `;

    document.body.appendChild(overlay);

    const close = () => {
        if (overlay.parentNode) {
            overlay.remove();
        }
    };
    overlay.querySelector('.ocm-photo-modal-close-btn').addEventListener('click', close);
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            close();
        }
    });
}
// ===================================================================
// NOMBRE: startFreeDrive 
// RESUMEN: Inicia el modo de conducción libre, limpiando marcadores de velocidad anteriores.
function startFreeDrive(initialCoords) {
    if (isFreeDriveActive || isNavigating) return;

    isFreeDriveActive = true;
    isFreeDrivePaused = false;
    freeDriveStats = {
        startTime: new Date(),
        totalDistance: 0,
        lastPosition: { ...initialCoords },
    };

    navigationStartTimeForStats = new Date();
    totalDistanceTravelledForStats = 0;
    maxSpeedDuringTrip = 0;
    speedMarkerFeatures = []; 
    maxSpeedCoordinates = null;
    maxAltitudeDuringTrip = -Infinity;
    minAltitudeDuringTrip = Infinity;
    window.averageSpeedKmh = 0;
    lastPositionForStats = { ...initialCoords };
    
    showToast("Grabación de viaje en modo libre iniciada.", "success");

    navigationFollowUser = true;
    shouldCenterOnUser = true;
    const locateMeButton = document.getElementById('locate-me-on-reminders-map');
    const locateMeImg = locateMeButton ? locateMeButton.querySelector('img') : null;
    if (locateMeButton && locateMeImg) {
        locateMeImg.src = "PNG/DEJARSEGUIR.PNG";
        locateMeButton.title = "Dejar de centrar el mapa en mi posición";
    }
    toggleMapHeaderRowsVisibility(false);
    showMapInfoOverlay("Modo FREE DRIVE sin destino conocido");

    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviación ETA'; 
    initializeNavigationGraph();
    updateNavigationProgressDisplay();
}

// ===================================================================
// NOMBRE: stopFreeDrive
// RESUMEN: Detiene el modo de conducción libre y muestra el modal de estadísticas.
function stopFreeDrive() {
    if (!isFreeDriveActive) return;
    clearRecoveryFlag();
    const statsToSend = { ...freeDriveStats };
    showArrivalStatsModal(statsToSend);

    isFreeDriveActive = false;
    isFreeDrivePaused = false;
    freeDriveStats = null;
    tripStartLocationForStats = null;

    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    clearNavigationGraph();
    showMapInfoOverlay("Modo FREE DRIVE fin de viaje");
}    
   
// ===================================================================
// NOMBRE: drawStaticMarkersOnProgressBar 
// RESUMEN: Dibuja los elementos estáticos (etapas, radares, tareas) en la barra de progreso.
function drawStaticMarkersOnProgressBar() {
    const overallProgressContainer = document.getElementById('route-overall-progress-container');
    if (!overallProgressContainer || !navigationCurrentRouteData?.routes?.[0]) {
        return;
    }

    const route = navigationCurrentRouteData.routes[0];
    const totalJourneyDistanceForBar = (accumulatedDistanceBeforeCurrentSegment || 0) + route.distance;

    // 1. Limpia solo los marcadores, no toda la barra
    overallProgressContainer.querySelectorAll('.waypoint-dot-on-progress-bar, .radar-marker-on-progress-bar, .task-marker-on-progress-bar').forEach(dot => dot.remove());
    
    // 2. Dibuja los puntos de etapa (Waypoints)
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    if (actualWaypoints.length > 2 && totalJourneyDistanceForBar > 0 && typeof turf !== 'undefined' && navigationMapInstance.getSource('route') && navigationMapInstance.getSource('route')._data) {
        const routeGeoJSON = navigationMapInstance.getSource('route')._data;
        const routeLineString = turf.lineString(routeGeoJSON.geometry.coordinates);
        const startOfRoute = turf.point(routeLineString.geometry.coordinates[0]);

        for (let i = 1; i < actualWaypoints.length - 1; i++) {
            const waypoint = actualWaypoints[i];
            const waypointPoint = turf.point([waypoint.lng, waypoint.lat]);
            const nearestPointOnLine = turf.nearestPointOnLine(routeLineString, waypointPoint, { units: 'meters' });
            const lineSliceToWaypoint = turf.lineSlice(startOfRoute, nearestPointOnLine, routeLineString);
            const distanceToWaypoint = turf.length(lineSliceToWaypoint, { units: 'meters' });
            const totalDistanceWithAccumulated = (accumulatedDistanceBeforeCurrentSegment || 0) + distanceToWaypoint;
            const percent = (totalDistanceWithAccumulated / totalJourneyDistanceForBar) * 100;
            if (percent < 100 && percent > 0) {
                const dot = document.createElement('div');
                dot.className = 'waypoint-dot-on-progress-bar';
                dot.style.left = `calc(${percent}% - 7px)`;
                dot.title = `Etapa ${waypoint.label}`;
                overallProgressContainer.appendChild(dot);
            }
        }
    }

    // 3. Dibuja los Radares en Ruta (si están activos)
    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresRutaCheckbox && radaresRutaCheckbox.checked && radaresEnRutaActual.length > 0 && totalJourneyDistanceForBar > 0) {
        radaresEnRutaActual.forEach(radar => {
            if (radar.distanceOnRoute !== undefined) {
                const totalDistanceToRadar = (accumulatedDistanceBeforeCurrentSegment || 0) + radar.distanceOnRoute;
                if(totalDistanceToRadar <= totalJourneyDistanceForBar) {
                    const percent = (totalDistanceToRadar / totalJourneyDistanceForBar) * 100;
                    if (percent >= 0 && percent <= 100) {
                        const radarMarker = document.createElement('div');
                        radarMarker.className = 'radar-marker-on-progress-bar';
                        radarMarker.style.left = `${percent}%`;
                        radarMarker.title = radar.text.replace(/<b>|<\/b>/gi, '');
                        overallProgressContainer.appendChild(radarMarker);
                    }
                }
            }
        });
    }

    // 4. Dibuja las Tareas en Ruta (si están activas)
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasRutaCheckbox && tareasRutaCheckbox.checked && tareasEnRutaActual.length > 0 && totalJourneyDistanceForBar > 0) {
        tareasEnRutaActual.forEach(tarea => {
            if (tarea.distanceOnRoute !== undefined) {
                const totalDistanceToTask = (accumulatedDistanceBeforeCurrentSegment || 0) + tarea.distanceOnRoute;
                if(totalDistanceToTask <= totalJourneyDistanceForBar) {
                    const percent = (totalDistanceToTask / totalJourneyDistanceForBar) * 100;
                    if (percent >= 0 && percent <= 100) {
                        const taskMarker = document.createElement('div');
                        taskMarker.className = 'task-marker-on-progress-bar';
                        taskMarker.style.left = `${percent}%`;
                        taskMarker.title = tarea.text.replace(/<b>|<\/b>/gi, '');
                        overallProgressContainer.appendChild(taskMarker);
                    }
                }
            }
        });
    }
}


    
// ===================================================================
// NOMBRE: getAddressForWaypoint 
// RESUMEN: Obtiene la dirección o solo la calle de un punto de ruta.
async function getAddressForWaypoint(lat, lng, streetOnly = false) {
    if (typeof lat !== 'number' || typeof lng !== 'number' || isNaN(lat) || isNaN(lng)) {
        return "Ubicación Desconocida";
    }
    try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=1&accept-language=es`);
        if (response.ok) {
            const data = await response.json();
            if (streetOnly) {
                return data.address?.road || "Calle desconocida";
            }
            return data.display_name || `(${lat.toFixed(3)}, ${lng.toFixed(3)})`;
        } else {
            return streetOnly ? "Calle desconocida" : `Etapa (${lat.toFixed(3)}, ${lng.toFixed(3)})`;
        }
    } catch (err) {
        return streetOnly ? "Calle desconocida" : `Etapa (${lat.toFixed(3)}, ${lng.toFixed(3)})`;
    }
}


    
// ===================================================================
// NOMBRE: openAlertModal
// RESUMEN: Abre el modal para que el usuario seleccione una incidencia de tráfico.
function openAlertModal() {
   
    processTrafficAlerts();
    
    const alertModalOverlay = document.getElementById('alert-modal-overlay');
    const alertModalContent = document.getElementById('alert-modal-content');
    if (!alertModalOverlay || !alertModalContent) return;

    const alertOptions = [
        { code: 1, text: 'ACCIDENTE TRÁFICO', icon: 'PNG/AACCIDENTE.png' },
        { code: 2, text: 'COCHE AVERIADO', icon: 'PNG/AAVERIADO.png' },
        { code: 3, text: 'CONTROL TRÁFICO / RADAR', icon: 'PNG/AGUARDIA22.png' },
        { code: 4, text: 'ATASCO', icon: 'PNG/AATASCO.png' },
        { code: 5, text: 'PELIGRO INDETERMINADO', icon: 'PNG/APELIGRO.png' },
        { code: 6, text: 'CARRETERA MAL ESTADO', icon: 'PNG/ARESVALAR.png' },
        { code: 7, text: 'OBRAS', icon: 'PNG/AOBRAS.png' },
        { code: 8, text: 'VÍA / CARRETERA CERRADA', icon: 'PNG/ACERRADA.png' }, 
        { code: 9, text: 'YA NO HAY NADA', icon: 'PNG/AANULAR.png' }           
    ];
    alertModalContent.innerHTML = '<div id="alert-columns-container"></div>';
    const columnsContainer = document.getElementById('alert-columns-container');

    const column1 = document.createElement('div');
    column1.className = 'alert-column';
    const column2 = document.createElement('div');
    column2.className = 'alert-column';

    alertOptions.forEach((option, index) => {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'alert-option';
        optionDiv.onclick = () => sendTrafficAlert(option.code, option.text);
        optionDiv.innerHTML = `<img src="${option.icon}" alt="${option.text}"><span>${option.text}</span>`;

        if (index < 5) {
            column1.appendChild(optionDiv);
        } else {
            column2.appendChild(optionDiv);
        }
    });

    const cancelButton = document.createElement('div');
    cancelButton.id = 'alert-cancel-button';
    cancelButton.innerHTML = '<span>CANCELAR <span id="alert-timer">(10)</span></span>';
    cancelButton.onclick = closeAlertModal;
    column2.appendChild(cancelButton); 

    columnsContainer.appendChild(column1);
    columnsContainer.appendChild(column2);

    alertModalOverlay.classList.remove('hidden');

    let countdown = 10;
    const timerSpan = document.getElementById('alert-timer');
    if (alertModalTimer) clearInterval(alertModalTimer);
    alertModalTimer = setInterval(() => {
        countdown--;
        if (timerSpan) timerSpan.textContent = `${countdown}`;
        if (countdown <= 0) {
            closeAlertModal();
        }
    }, 1000);
}

// ===================================================================
// NOMBRE: formatOCMPoint
// RESUMEN: Convierte un punto de recarga del formato OCM a un formato interno estandarizado.
function formatOCMPoint(point) {
    if (!point || !point.AddressInfo) {
        return null;
    }

    let maxPower = 0;
    if (point.Connections && Array.isArray(point.Connections)) {
        point.Connections.forEach(conn => {
            if (conn.PowerKW && conn.PowerKW > maxPower) {
                maxPower = conn.PowerKW;
            }
        });
    }

    const totalPoints = point.NumberOfPoints || (point.Connections ? point.Connections.length : 0);
    const availabilityText = `${totalPoints} Poste${totalPoints !== 1 ? 's' : ''}`;

    let priceText = 'N/D';
    if (point.UsageCost) {
        const priceMatch = point.UsageCost.match(/(\d[\d,.]*)/);
        if (priceMatch && priceMatch[1]) {
            let priceNum = parseFloat(priceMatch[1].replace(',', '.'));
            if (!isNaN(priceNum) && priceNum > 0 && priceNum < 10) { 
                 priceText = `${priceNum.toFixed(2)} €/kWh`;
            }
        }
    }

    return {
        ocmId: point.ID,
        lat: point.AddressInfo.Latitude,
        lon: point.AddressInfo.Longitude,
        address: point.AddressInfo.Title || 'Dirección no disponible',
        availabilityText: availabilityText,
        price: priceText,
        fullPriceInfo: point.UsageCost || 'N/D',
        power: maxPower > 0 ? maxPower.toFixed(0) : 'N/A',
        operator: point.OperatorInfo ? point.OperatorInfo.Title : 'Desconocido',
        usageType: point.UsageType ? point.UsageType.Title : 'No especificado',
        accessInfo: point.AddressInfo.AccessComments || 'No especificado',
        connections: point.Connections || []
    };
}
    
// ===================================================================
// NOMBRE: closeAlertModal
// RESUMEN: Cierra el modal de selección de incidencias y limpia su temporizador.
function closeAlertModal() {
    const alertModalOverlay = document.getElementById('alert-modal-overlay');
    if (alertModalOverlay) {
        alertModalOverlay.classList.add('hidden');
    }
    if (alertModalTimer) {
        clearInterval(alertModalTimer);
        alertModalTimer = null;
    }
}

// ===================================================================
// NOMBRE: sendTrafficAlert 
// RESUMEN: Envía la alerta, la añade a la caché local y redibuja el mapa al instante.
function sendTrafficAlert(alertCode, alertName) {
    const userId = localStorage.getItem('userData_userId');
    if (!userId) {
        showToast("Debes configurar un ID de Usuario para enviar alertas.", "warning");
        closeAlertModal();
        return;
    }
    closeAlertModal();
    const sendData = async (coords) => {
        if (!window.db || !window.doc || !window.setDoc || !window.collection) {
            showToast("Error: Firebase no está inicializado.", "error");
            return;
        }
        const alertData = {
            user: userId,
            code: alertCode,
            latitude: coords.latitude,
            longitude: coords.longitude,
            timestamp: new Date().toISOString()
        };

        try {
            const alertsCollectionRef = window.collection(window.db, "users", "ALERTAS", "events");
            const docId = `${Date.now()}_${userId.replace(/[^a-zA-Z0-9]/g, '_')}`;
            const newAlertRef = window.doc(alertsCollectionRef, docId);
            
            await window.setDoc(newAlertRef, alertData);

            const newAlertForCache = {
                id: docId,
                code: alertData.code,
                coordinates: { lat: alertData.latitude, lon: alertData.longitude }
            };
            
            const existingIndex = trafficAlertsCache.findIndex(a => a.id === newAlertForCache.id);
            if (existingIndex > -1) {
                trafficAlertsCache[existingIndex] = newAlertForCache; // Evita duplicados
            } else {
                trafficAlertsCache.push(newAlertForCache);
            }

            displayAlertsOnMap(); // Fuerza el redibujado inmediato del mapa con la nueva alerta.
            
            showToast(`Alerta "${alertName}" enviada y mostrada en el mapa.`, "success");

        } catch (error) {
            showToast(`Error al enviar alerta a Firebase: ${error.message}`, "error");
        }
    };

    if (isSimulatingGpsLocation && simulatedGpsLocation) {
        sendData(simulatedGpsLocation);
    } else {
        getCurrentLocation(
            (realCoords) => { sendData(realCoords); },
            (errorMsg) => { showToast(`No se pudo obtener la ubicación: ${errorMsg}`, "error"); }
        );
    }
}    
    
// ===================================================================
// NOMBRE: processTrafficAlerts 
// RESUMEN: Lógica principal que lee, limpia, actualiza las alertas desde Firebase y construye el índice.
async function processTrafficAlerts() {
    if (!window.db || !window.getDocs || !window.deleteDoc || !window.collection) {
        console.warn("Funciones de Firebase no disponibles, no se pueden procesar alertas.");
        return;
    }
    
    lastAlertCheckTimestamp = Date.now();
    
    try {
        const alertsCollectionRef = window.collection(window.db, "users", "ALERTAS", "events");
        const querySnapshot = await window.getDocs(alertsCollectionRef);
        
        let allAlerts = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        const now = new Date();
        const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
        
        const removals = allAlerts.filter(alert => alert.code === 9);
        let activeAlerts = allAlerts.filter(alert => alert.code !== 9);

        for (const removal of removals) {
            const removalCoords = { lat: removal.latitude, lon: removal.longitude };
            const alertsToDelete = new Set();
            
            activeAlerts.forEach(alert => {
                if(alert.latitude && alert.longitude){
                    const alertCoords = { lat: alert.latitude, lon: alert.longitude };
                    if (calculateDistance(removalCoords.lat, removalCoords.lon, alertCoords.lat, alertCoords.lon) <= 800) {
                        alertsToDelete.add(alert.id);
                    }
                }
            });

            for (const idToDelete of alertsToDelete) {
                const docRef = window.doc(window.db, "users", "ALERTAS", "events", idToDelete);
                await window.deleteDoc(docRef);
            }
            
            const removalDocRef = window.doc(window.db, "users", "ALERTAS", "events", removal.id);
            await window.deleteDoc(removalDocRef);
        }

        activeAlerts = activeAlerts.filter(alert => {
            if (!alert.timestamp || new Date(alert.timestamp) < twentyFourHoursAgo) {
                const docRef = window.doc(window.db, "users", "ALERTAS", "events", alert.id);
                window.deleteDoc(docRef); // Borrado asíncrono, no esperamos
                return false;
            }
            return true;
        });
        
        trafficAlertsCache = activeAlerts.filter(alert => alert.latitude && alert.longitude).map(alert => ({
            id: alert.id,
            code: alert.code,
            coordinates: { lat: alert.latitude, lon: alert.longitude }
        }));
        
        trafficAlertsSpatialIndex = {};
        trafficAlertsCache.forEach(alert => {
            if (alert.coordinates && alert.coordinates.lat && alert.coordinates.lon) {
                const cellId = getGridCellId(alert.coordinates.lat, alert.coordinates.lon);
                if (!trafficAlertsSpatialIndex[cellId]) {
                    trafficAlertsSpatialIndex[cellId] = [];
                }
                trafficAlertsSpatialIndex[cellId].push(alert);
            }
        });
   
        displayAlertsOnMap(); 
        checkAlertsProximity();
      
    } catch (error) {
        console.error("Error procesando alertas de tráfico: ", error);
    }
}

// ===================================================================
// NOMBRE: eliminarTareasDeMapa 
// RESUMEN: Elimina del mapa los marcadores de tareas/radares personales.
function eliminarTareasDeMapa() {
    reminderMapObjects = reminderMapObjects.filter(obj => {
        if (obj.isFromTarea) {
            if (obj.marker) obj.marker.remove();
            if (obj.circleId && navigationMapInstance.getLayer(obj.circleId)) {
                navigationMapInstance.removeLayer(obj.circleId);
            }
            if (obj.circleId && navigationMapInstance.getSource(obj.circleId)) {
                navigationMapInstance.removeSource(obj.circleId);
            }
            return false;
        }
        return true;
    });
}
// ===================================================================
// NOMBRE: createRadarAlertIcon 
// RESUMEN: Crea un icono de alerta escalable asegurando que devuelve un elemento DOM.
function createRadarAlertIcon(currentZoomLevel = null, isFromTarea = false) {
    const container = document.createElement('div'); 
    const SCALE_THRESHOLD_ZOOM = 16;
    const MIN_SCALE = 0.35;
    const MIN_ZOOM_FOR_SCALING = 10;
    let scale = 1.0;

    if (currentZoomLevel !== null && currentZoomLevel < SCALE_THRESHOLD_ZOOM) {
        if (currentZoomLevel <= MIN_ZOOM_FOR_SCALING) {
            scale = MIN_SCALE;
        } else {
            const progress = (currentZoomLevel - MIN_ZOOM_FOR_SCALING) / (SCALE_THRESHOLD_ZOOM - MIN_ZOOM_FOR_SCALING);
            scale = MIN_SCALE + (1 - MIN_SCALE) * progress;
        }
    }

    const baseSize = 55;
    const finalSize = Math.round(baseSize * scale);
    const finalBorderSize = Math.max(1, Math.round(3 * scale));
    
    const borderColor = isFromTarea ? '#00FF00' : 'white';

    container.className = 'radar-alert-circle';
    container.style.cssText = `width:${finalSize}px; height:${finalSize}px; border-width:${finalBorderSize}px; border-color:${borderColor};`;
    container.innerHTML = `<img src="PNG/radar.png" alt="Radar">`;
    
    return container; 
}
    
// ===================================================================
// NOMBRE: checkAlertsProximity 
// RESUMEN: Comprueba la proximidad usando el índice espacial y limpia alertas ya vistas y lejanas.
// ===================================================================
function checkAlertsProximity() {
    if (!navigationCurrentLocation || Object.keys(trafficAlertsSpatialIndex).length === 0) {
        return;
    }

    const carLat = navigationCurrentLocation.latitude;
    const carLon = navigationCurrentLocation.longitude;

    const centerCellId = getGridCellId(carLat, carLon);
    const [_, centerLatIndex, centerLonIndex] = centerCellId.split('_').map(Number);
    const candidateAlerts = new Set(); 

    for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
            const cellId = `cell_${centerLatIndex + i}_${centerLonIndex + j}`;
            if (trafficAlertsSpatialIndex[cellId]) {
                trafficAlertsSpatialIndex[cellId].forEach(alert => candidateAlerts.add(alert));
            }
        }
    }

    candidateAlerts.forEach(alert => {
        const distance = calculateDistance(carLat, carLon, alert.coordinates.lat, alert.coordinates.lon);
        if (distance <= 500 && !currentlyDisplayedProximityAlerts.has(alert.id)) {
            showProximityAlert(alert);
            currentlyDisplayedProximityAlerts.add(alert.id);
        }
    });

    const now = Date.now();
    if (now - lastAlertCleanupTimestamp > 30000) {
        lastAlertCleanupTimestamp = now;

        if (currentlyDisplayedProximityAlerts.size > 0) {
            const CLEANUP_DISTANCE_THRESHOLD_METERS = 2000; // 2 km

            const alertsToCheckForCleanup = new Set(currentlyDisplayedProximityAlerts);

            alertsToCheckForCleanup.forEach(alertId => {
                const alertData = trafficAlertsCache.find(a => a.id === alertId);
                if (alertData) {
                    const distanceToOldAlert = calculateDistance(carLat, carLon, alertData.coordinates.lat, alertData.coordinates.lon);
                    if (distanceToOldAlert > CLEANUP_DISTANCE_THRESHOLD_METERS) {
                        currentlyDisplayedProximityAlerts.delete(alertId);
                    }
                } else {
                    currentlyDisplayedProximityAlerts.delete(alertId);
                }
            });
        }
    }
}

    
// ===================================================================
// NOMBRE: hideProximityAlert
// RESUMEN: Oculta el modal de aviso de proximidad.
function hideProximityAlert(alertId) {
    const proximityModal = document.getElementById('proximity-alert-modal');
    if (proximityModal) proximityModal.classList.add('hidden');
    document.getElementById('flashing-border-overlay').classList.add('hidden');
    
    if (proximityAlertTimer) {
        clearInterval(proximityAlertTimer);
        proximityAlertTimer = null;
    }
}
// ===================================================================
// NOMBRE: forceProcessTrafficAlerts
// RESUMEN: Lanza el proceso de actualización de alertas inmediatamente.
function forceProcessTrafficAlerts() {
    console.log("-> Forzando actualización inmediata de alertas de tráfico...");
    lastAlertCheckTimestamp = Date.now();
    processTrafficAlerts();
}    
// ===================================================================
// NOMBRE: showProximityAlert
// RESUMEN: Muestra el modal de aviso de proximidad a una alerta de tráfico.
function showProximityAlert(alert) {
    const proximityModal = document.getElementById('proximity-alert-modal');
    if (!proximityModal) return;

    const alertDetails = [
        null, 
        { text: 'ACCIDENTE TRÁFICO', icon: 'PNG/AACCIDENTE.png' },
        { text: 'COCHE AVERIADO', icon: 'PNG/AAVERIADO.png' },
        { text: 'CONTROL TRÁFICO / RADAR', icon: 'PNG/AGUARDIA22.png' },
        { text: 'ATASCO', icon: 'PNG/AATASCO.png' },
        { text: 'PELIGRO INDETERMINADO', icon: 'PNG/APELIGRO.png' },
        { text: 'CARRETERA MAL ESTADO', icon: 'PNG/ARESVALAR.png' },
        { text: 'OBRAS', icon: 'PNG/AOBRAS.png' },
        null, 
        { text: 'VÍA / CARRETERA CERRADA', icon: 'PNG/ACERRADA.png' } 
    ][alert.code];

    if (!alertDetails) return;

    proximityModal.innerHTML = `
        <img src="${alertDetails.icon}" alt="${alertDetails.text}">
        <div class="content">
            <span class="alert-text">${alertDetails.text}</span>
            <button id="proximity-ok-button">ENTERADO <span id="proximity-timer">(10)</span></button>
        </div>
    `;

    document.getElementById('flashing-border-overlay').classList.remove('hidden');
    proximityModal.classList.remove('hidden');

    const okButton = document.getElementById('proximity-ok-button');
    const timerSpan = document.getElementById('proximity-timer');
    let countdown = 15;
    
    if (proximityAlertTimer) clearInterval(proximityAlertTimer);
    proximityAlertTimer = setInterval(() => {
        countdown--;
        if (timerSpan) timerSpan.textContent = `${countdown}`;
        if (countdown <= 0) {
            hideProximityAlert(alert.id);
        }
    }, 1000);
    
    okButton.onclick = () => hideProximityAlert(alert.id);
}
// ===================================================================
// NOMBRE: loadRouteByName 
// RESUMEN: Busca una ruta guardada por su nombre y llama a la función de carga genérica.
function loadRouteByName(routeName, autoStartNavigation = false) {
    const savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
    const recentRoutes = JSON.parse(localStorage.getItem('boardinggate_recent_routes') || "[]");
    let routeToLoad = savedRoutes.find(r => r.name.toUpperCase() === routeName.toUpperCase());
    if (!routeToLoad) {
        routeToLoad = recentRoutes.find(r => r.name.toUpperCase() === routeName.toUpperCase());
    }
    if (routeToLoad) {
        loadRouteFromObject(routeToLoad, autoStartNavigation);
    } else {
        showToast(`No se pudo cargar la ruta "${routeName}". No encontrada`, "error");
        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox) {
           localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked));
        }
        const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasRutaCheckbox) {
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
        }
    }
}
       
// ===================================================================
// NOMBRE: generateBackup
// RESUMEN: Genera un código de backup con todos los datos locales y lo copia al portapapeles.
function generateBackup() {
    const backupData = {};
    managedKeys.forEach(key => {
        const value = localStorage.getItem(key);
        if (value !== null) {
            backupData[key] = value;
        }
    });
    const backupString = JSON.stringify(backupData);
    const backupDisplay = document.getElementById('config-backup-display');
    backupDisplay.value = btoa(unescape(encodeURIComponent(backupString)));
    backupDisplay.style.display = 'block';
    backupDisplay.select();
    try {
        document.execCommand('copy');
        showToast('Backup copiado al portapapeles', 'success');
         document.getElementById('config-backup-status').textContent = '¡Copiado! Guarda este código en un lugar seguro.';
         document.getElementById('config-backup-status').style.color = '#28a745';
    } catch (err) {
        showToast('Error al copiar. Por favor, copia manualmente', 'warning');
        document.getElementById('config-backup-status').textContent = 'Copia este código manualmente y guárdalo.';
        document.getElementById('config-backup-status').style.color = '#ffc107';
    }
}

// ===================================================================
// NOMBRE: getManeuverIconFilename
// RESUMEN: Devuelve el nombre del fichero de imagen para una maniobra.
function getManeuverIconFilename(maneuver) {
    if (!maneuver) return 'PNG/continue.png';
    const type = maneuver.type || '';
    const modifier = maneuver.modifier || '';

    if (type.includes('roundabout') && maneuver.exit && maneuver.exit >= 1 && maneuver.exit <= 5 && getManeuverInstructionText(maneuver).toLowerCase().includes("salida")) {
        return `PNG/S${maneuver.exit}.PNG`;
    }
    if (type === 'depart') return 'PNG/depart.png';
    if (type === 'arrive') return 'PNG/arrive.png';
    if (type.includes('roundabout') || type.includes('rotary')) return 'PNG/roundabout.png';
    
    if (modifier.includes('uturn')) return 'PNG/uturn.png';
    if (modifier.includes('sharp right')) return 'PNG/sharp-right.png';
    if (modifier.includes('sharp left')) return 'PNG/sharp-left.png';
    if (modifier.includes('slight right') || modifier.includes('bear right')) return 'PNG/bear-right.png';
    if (modifier.includes('slight left') || modifier.includes('bear left')) return 'PNG/bear-left.png';
    if (modifier.includes('right')) return 'PNG/turn-right.png';
    if (modifier.includes('left')) return 'PNG/turn-left.png';
    if (modifier.includes('ramp')) return 'PNG/ramp.png';
    return 'PNG/continue.png'; 
}
    
// ===================================================================
// NOMBRE: getSuggestedRouteName
// RESUMEN: Sugiere un nombre de ruta por defecto basado en la ubicación final.
async function getSuggestedRouteName(lat, lng, isMultiStage = false, totalWaypoints = 0) {
    let baseName = `RUTA: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
    try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=1&accept-language=es`);
        if (response.ok) {
            const data = await response.json();
            if (data.address) {
                const road = data.address.road;
                const city = data.address.city || data.address.town || data.address.village || data.address.hamlet;
                if (road && city) baseName = `${road}, ${city}`;
                else if (city) baseName = city;
                else if (road) baseName = road;
            }
        }
    } catch (e) {
    }
    if (isMultiStage) {
        const numStages = Math.max(0, totalWaypoints - 1);
        return `${numStages} ETAPAS: ${baseName}`;
    } else {
        return `  ${baseName}`;
    }
}

function initializeConfigModalListeners() {
    document.getElementById('config-save-user-firebase')?.addEventListener('click', validateAndSaveUserToFirebase);
    document.getElementById('config-save-user-firebase-from-backup-tab')?.addEventListener('click', validateAndSaveUserToFirebase);
    document.getElementById('config-restore-backup-firebase')?.addEventListener('click', restoreBackupFromFirebase);
    document.getElementById('config-save-pin')?.addEventListener('click', savePinSettings);
    document.getElementById('config-remove-pin')?.addEventListener('click', removePinSettings);
    document.getElementById('config-generate-backup')?.addEventListener('click', generateBackup);
    document.getElementById('config-restore-backup')?.addEventListener('click', restoreBackup);
    document.getElementById('config-restore-grid-button')?.addEventListener('click', restoreOriginalGrid);
    document.getElementById('config-clear-cache')?.addEventListener('click', clearAllLocalData);

    const importBtn = document.getElementById('import-radars-button');
    if (importBtn && !importBtn.dataset.listenerAttached) {
        importBtn.addEventListener('click', importRadars);
        importBtn.dataset.listenerAttached = "true";
    }

    const deleteBtn = document.getElementById('delete-filtered-radars-button');
    if (deleteBtn && !deleteBtn.dataset.listenerAttached) {
        deleteBtn.addEventListener('click', deleteFilteredRadars);
        deleteBtn.dataset.listenerAttached = "true";
    }

    const acceptTermsButton = document.getElementById('accept-terms-button');
    if (acceptTermsButton && !acceptTermsButton.dataset.listenerAttached) {
        acceptTermsButton.addEventListener('click', () => {
            localStorage.setItem('termsAccepted_v1', 'true');
            showToast('Normas aceptadas. Gracias.', 'success');
            const modal = document.getElementById('config-modal');
            markCacheAsDirty(); 
        
            if (modal) {
                modal.querySelectorAll('.config-tab-button').forEach(btn => {
                    btn.disabled = false;
                    btn.style.cursor = 'pointer';
                    btn.style.opacity = '1';
                });
                modal.querySelector('.config-tab-button[data-tab-target="#tab-content-normas"]').classList.remove('active');
                modal.querySelector('#tab-content-normas').classList.remove('active');
                modal.querySelector('.config-tab-button[data-tab-target="#tab-content-usuario"]').classList.add('active');
                modal.querySelector('#tab-content-usuario').classList.add('active');
            }
        });
        acceptTermsButton.dataset.listenerAttached = "true";
    }
    
    const directToNavCheckbox = document.getElementById('config-direct-to-nav');
    if (directToNavCheckbox && !directToNavCheckbox.dataset.listenerAttached) {
        directToNavCheckbox.addEventListener('change', () => {
            localStorage.setItem(DIRECT_TO_NAVIGATION_KEY, JSON.stringify(directToNavCheckbox.checked));
            showToast('Preferencia de inicio directo al mapa guardada.', 'success', 2000);
        });
        directToNavCheckbox.dataset.listenerAttached = "true";
    }
    const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
    if (autoBackupCheckbox && !autoBackupCheckbox.dataset.listenerAttached) {
        autoBackupCheckbox.addEventListener('change', () => {
            localStorage.setItem('boardinggate_autoBackupOnLoad', JSON.stringify(autoBackupCheckbox.checked));
            showToast(`Copia de seguridad automática al inicio: ${autoBackupCheckbox.checked ? 'Activada' : 'Desactivada'}`, 'info', 3000);
        });
        autoBackupCheckbox.dataset.listenerAttached = "true";
    } 
}    
    
    // ===================================================================
    // NOMBRE: parseUserId
    // RESUMEN: Analiza el ID de usuario para detectar si es un usuario móvil y extrae el ID principal.
    function parseUserId(rawUserId) {
        if (!rawUserId) {
            return { primaryId: null, isMobile: false, originalId: null };
        }
        const mobileRegex = /^(.*?)@(MÓVIL|MOVIL)$/i;
        const match = rawUserId.trim().match(mobileRegex);
        if (match && match[1]) {
            return {
                primaryId: match[1].trim(),
                isMobile: true,
                originalId: rawUserId.trim()
            };
        } else {
            return {
                primaryId: rawUserId.trim(),
                isMobile: false,
                originalId: rawUserId.trim()
            };
        }
    }
       
    // ===================================================================
    // NOMBRE: markCacheAsDirty
    // RESUMEN: Actualiza un timestamp para marcar que la caché local ha sido modificada.
    function markCacheAsDirty() {
    isCacheDirty = true; // Para la reconstrucción inmediata de la caché en memoria
    localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString()); // Para la lógica de sincronización con la nube
    }

    // ===================================================================
    // NOMBRE: promptForBackupPassword
    // RESUMEN: Muestra un modal para que el usuario introduzca un PIN de seguridad para backups.
    function promptForBackupPassword(message, onConfirm, onCancel, isSettingPassword = false) {
        const existingModal = document.getElementById('backup-password-modal-overlay');
        if (existingModal) existingModal.remove();
        const modalOverlay = document.createElement('div');
        modalOverlay.id = 'backup-password-modal-overlay';
        modalOverlay.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85); display: flex; justify-content: center;
            align-items: center; z-index: 9999;
        `;
        const modalContent = document.createElement('div');
        modalContent.id = 'backup-password-modal-content';
        modalContent.style.cssText = `
            background-color: #DAC8A0; padding: 2rem; border-radius: 0.75rem;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4); text-align: center; border: 1px solid #A0522D;
            margin-top: -50px;
            max-width: 350px; width: 90%;
        `;
        modalContent.innerHTML = `
            <h2 style="font-size: 1.5rem; font-weight: bold; color: #333; margin-bottom: 1rem;">${message}</h2>
            <input type="password" id="backup-password-input" maxlength="6" pattern="\\d{6}" inputmode="numeric" style="
                width: 150px; padding: 0.8rem; font-size: 1.8rem; text-align: center;
                border: 2px solid #A0522D; border-radius: 0.25rem; margin-bottom: 1.5rem;
                letter-spacing: 0.5em; background-color: #f0f0e0;
            " required>
            ${isSettingPassword ? `
                <label for="backup-password-confirm" style="display: block; font-size: 1.1rem; color: #444; margin-bottom: 0.8rem;">Confirmar PIN:</label>
                <input type="password" id="backup-password-confirm" maxlength="6" pattern="\\d{6}" inputmode="numeric" style="
                    width: 150px; padding: 0.8rem; font-size: 1.8rem; text-align: center;
                    border: 2px solid #A0522D; border-radius: 0.25rem; margin-bottom: 1.5rem;
                    letter-spacing: 0.5em; background-color: #f0f0e0;
                " required>
            ` : ''}
            <p id="backup-password-error" style="color: #dc3545; font-weight: bold; margin-top: -0.5rem; margin-bottom: 1rem; min-height: 1.2em;"></p>
            <div style="display:flex; justify-content: space-around; gap:1rem;">
                <button id="backup-password-submit" style="padding: 0.8rem 1.5rem; font-size: 1.2rem; background-color: #28a745; color: white; border: none; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; flex: 1;">Aceptar</button>
                <button id="backup-password-cancel" style="padding: 0.8rem 1.5rem; font-size: 1.2rem; background-color: #6c757d; color: white; border: none; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; flex: 1;">Cancelar</button>
            </div>
        `;
        document.body.appendChild(modalOverlay);
        modalOverlay.appendChild(modalContent);
        const pinInput = document.getElementById('backup-password-input');
        const pinConfirmInput = document.getElementById('backup-password-confirm');
        const errorEl = document.getElementById('backup-password-error');
        const submitBtn = document.getElementById('backup-password-submit');
        const cancelBtn = document.getElementById('backup-password-cancel');
        pinInput.focus();
        const validateAndSubmit = () => {
            errorEl.textContent = '';
            const pin = pinInput.value;
            if (!/^\d{6}$/.test(pin)) {
                errorEl.textContent = 'El PIN debe ser de 6 dígitos numéricos.';
                if (navigator.vibrate) navigator.vibrate(100);
                return;
            }
            if (isSettingPassword) {
                const confirmPin = pinConfirmInput.value;
                if (pin !== confirmPin) {
                    errorEl.textContent = 'Los PINs no coinciden.';
                    if (navigator.vibrate) navigator.vibrate(100);
                    return;
                }
            }
            modalOverlay.remove();
            onConfirm(pin);
        };
        submitBtn.addEventListener('click', validateAndSubmit);
        cancelBtn.addEventListener('click', () => {
            modalOverlay.remove();
            onCancel();
        });
        pinInput.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                if (isSettingPassword && pinConfirmInput) {
                    pinConfirmInput.focus();
                } else {
                    validateAndSubmit();
                }
            }
        });
        if (isSettingPassword && pinConfirmInput) {
            pinConfirmInput.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') {
                    validateAndSubmit();
                }
            });
        }
        addModalAutoCloseTimer(modalOverlay, submitBtn, 'backup-password-modal', isSettingPassword ? 90000 : 30000);
    }
     
// ===================================================================
// NOMBRE: callFirebase 
// RESUMEN: Encapsula las llamadas a Firestore, ahora usando { merge: true } para evitar borrar campos.
async function callFirebase(action, data) {
    if (!window.db || !window.doc || !window.setDoc || !window.getDoc || !window.collection) {
        console.error("Firebase Firestore SDK functions no están expuestas globalmente.");
        return { status: "error", message: "Error interno: Funciones de Firebase no están disponibles." };
    }
    const userId = data.userId;
    if (!userId) {
        return { status: "error", message: "ID de Usuario es obligatorio para las operaciones de Firebase." };
    }
    try {
        const userDocRef = window.doc(window.db, "user_data", userId);
        if (action === 'saveUser') {
            const documentData = {
                usuario: data.usuario,
                modelo: data.modelo || '',
                anio: data.anio || '',
                provincia: data.provincia || '',
                rss: data.rss || false,
                contenidoCacheCompleto: JSON.stringify(data.datosCache),
                fechaBackup: new Date().toISOString(),
                backupPassword: data.backupPassword || null
            };
            
            await window.setDoc(userDocRef, documentData, { merge: true });

            return { status: "success", message: "Datos guardados en Firebase." };
        } else if (action === 'getUserData') {
            const docSnap = await window.getDoc(userDocRef);
            if (docSnap.exists()) {
                const firebaseData = docSnap.data();
                try {
                    firebaseData.contenidoCacheCompleto = JSON.parse(firebaseData.contenidoCacheCompleto);
                } catch (e) {
                    console.error("Error al parsear contenidoCacheCompleto de Firebase:", e);
                }
                return { status: "success", message: "Datos recuperados de Firebase.", data: firebaseData };
            } else {
                return { status: "not_found", message: "No se encontró ningún backup para ese ID de Usuario." };
            }
        } else if (action === 'checkUserExists') {
             const docSnap = await window.getDoc(userDocRef);
             return { status: "success", exists: docSnap.exists() };
        } else {
            return { status: "error", message: "Acción de Firebase no reconocida." };
        }
    } catch (error) {
        console.error("Error en la operación de Firebase:", error);
        return { status: "error", message: `Error de Firebase: ${error.message}` };
    }
}       
    
// ===================================================================
// NOMBRE: validateAndSaveUserToFirebase 
// RESUMEN: Valida, pide PIN y guarda. Ahora, antes de guardar, relee los contadores de sesión para evitar conflictos.
async function validateAndSaveUserToFirebase() {
    const statusEl = document.getElementById('config-user-status');
    const userIdInput = document.getElementById('user-id');
    const { primaryId, isMobile, originalId } = parseUserId(userIdInput.value);

    if (primaryId && primaryId.toUpperCase() === 'ALERTAS') {
        statusEl.textContent = 'El nombre de usuario "ALERTAS" está reservado para el sistema. Por favor, elige otro.';
        statusEl.style.color = '#EF4444';
        showToast('Nombre de usuario no permitido', 'error');
        return;
    }

    if (!primaryId) {
        statusEl.textContent = 'El ID de Usuario es obligatorio.';
        statusEl.style.color = '#EF4444';
        return;
    }
    statusEl.textContent = 'Validando y preparando guardado...';
    statusEl.style.color = '#17a2b8';
    const toastId = "firebase-save-toast";
    showToast('Validando en la nube...', 'info', 0, false, toastId);

    const currentLocalUserId = localStorage.getItem('userData_userId');
    const hasChangedUser = originalId.toLowerCase() !== (currentLocalUserId || '').toLowerCase();

    if (hasChangedUser) {
        const checkResult = await callFirebase('checkUserExists', { userId: primaryId });
        if (checkResult.status === 'success' && checkResult.exists) {
            const userWantsToRestore = confirm(`Se ha encontrado una copia de seguridad para el usuario "${primaryId}".\n\n¿Deseas recuperar esa copia de seguridad?\n\n¡ATENCIÓN! Si dices que sí, se sobreescribirán todos tus datos locales actuales.`);
            if (userWantsToRestore) {
                document.getElementById('restore-user-id').value = originalId;
                await restoreBackupFromFirebase();
                const existingToast = document.getElementById(toastId);
                if (existingToast) existingToast.remove();
                return; 
            } else {
                showToast("Restauración cancelada. Se guardarán los datos actuales con el nuevo nombre de usuario.", "info");
            }
        }
    }

    const localBackupPassword = localStorage.getItem('userData_backupPassword');
    const completeSaveProcess = async (finalBackupPin) => {
        localStorage.setItem('userData_userId', originalId);
        localStorage.setItem('userData_teslaModel', document.getElementById('tesla-model').value.trim());
        localStorage.setItem('userData_teslaYear', document.getElementById('tesla-year').value.trim());
        localStorage.setItem('userData_teslaProvince', document.getElementById('tesla-province').value.trim());
        localStorage.setItem('userData_allowDMs', JSON.stringify(document.getElementById('allow-dms').checked));
        localStorage.setItem('boardinggate_autoBackupOnLoad', JSON.stringify(document.getElementById('config-auto-backup-on-load').checked));
        localStorage.setItem('userData_backupPassword', finalBackupPin);
        updateUserIdDisplay();
        
        const sessionDataResult = await callFirebase('getUserData', { userId: primaryId });
        const currentSessionData = {
            map_sessions_total: 0,
            map_sessions_month: 0,
            map_sessions_last_month: "0000-00"
        };
        if (sessionDataResult.status === 'success' && sessionDataResult.data) {
            currentSessionData.map_sessions_total = sessionDataResult.data.map_sessions_total || 0;
            currentSessionData.map_sessions_month = sessionDataResult.data.map_sessions_month || 0;
            currentSessionData.map_sessions_last_month = sessionDataResult.data.map_sessions_last_month || "0000-00";
        }
        const cacheData = {};
        managedKeys.forEach(key => {
            const value = localStorage.getItem(key);
            if (value !== null) cacheData[key] = value;
        });
        
        const saveData = {
            userId: primaryId,
            usuario: primaryId,
            modelo: localStorage.getItem('userData_teslaModel') || '',
            anio: localStorage.getItem('userData_teslaYear') || '',
            provincia: localStorage.getItem('userData_teslaProvince') || '',
            rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
            datosCache: cacheData,
            backupPassword: finalBackupPin,
            fechaBackup: new Date().toISOString(),
            // Usamos los contadores recién leídos para evitar el conflicto
            map_sessions_total: currentSessionData.map_sessions_total,
            map_sessions_month: currentSessionData.map_sessions_month,
            map_sessions_last_month: currentSessionData.map_sessions_last_month
        };
        
        const saveResult = await callFirebase('saveUser', saveData);
        
        const existingToast = document.getElementById(toastId);
        if (existingToast) existingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== toastId);
        
        if (saveResult.status === 'success') {
            const successMsg = isMobile ?
                `Datos sincronizados con el usuario "${primaryId}".` :
                "Datos guardados en la nube y localmente.";
            statusEl.textContent = successMsg;
            statusEl.style.color = '#28a745';
            showToast(successMsg, 'success');
            localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
        } else {
            statusEl.textContent = `Error al guardar: ${saveResult.message}. (Datos guardados localmente).`;
            statusEl.style.color = '#EF4444';
            showToast(`Error al guardar: ${saveResult.message}`, 'error');
        }
    };
    if (!hasChangedUser && localBackupPassword) {
        await completeSaveProcess(localBackupPassword);
    } else {
        const checkResult = await callFirebase('checkUserExists', { userId: primaryId });
        if (checkResult.status === 'error') {
            statusEl.textContent = `Error al verificar usuario en la nube: ${checkResult.message}.`;
            statusEl.style.color = '#EF4444';
            return;
        }
        if (checkResult.exists) {
            promptForBackupPassword(
                `Introduce el PIN para "${primaryId}":`,
                async (enteredPin) => {
                    const retrieveResult = await callFirebase('getUserData', { userId: primaryId });
                    if (retrieveResult.status === 'success' && retrieveResult.data && retrieveResult.data.backupPassword === enteredPin) {
                        await completeSaveProcess(enteredPin);
                    } else {
                        statusEl.textContent = 'PIN incorrecto. Guardado cancelado.';
                        statusEl.style.color = '#EF4444';
                        showToast('PIN incorrecto. Acceso denegado.', 'error');
                    }
                },
                () => { statusEl.textContent = 'Guardado cancelado.'; statusEl.style.color = '#6c757d'; }
            );
        } else {
            if (isMobile) {
                statusEl.textContent = `El usuario primario "${primaryId}" no existe. No se puede sincronizar.`;
                statusEl.style.color = '#EF4444';
                return;
            }
            promptForBackupPassword(
                'Nuevo usuario. Establece un PIN de 6 dígitos:',
                (pin) => completeSaveProcess(pin),
                () => { statusEl.textContent = 'Guardado cancelado.'; statusEl.style.color = '#6c757d'; },
                true
            );
        }
    }
}    
// ===================================================================
// NOMBRE: restoreBackupFromFirebase
// RESUMEN: Recupera y aplica un backup de datos desde Firebase, pidiendo PIN para confirmar.
async function restoreBackupFromFirebase(isAutoLoad = false) {
    const statusEl = document.getElementById('config-restore-status');
    const { primaryId, isMobile, originalId } = parseUserId(document.getElementById('restore-user-id').value || localStorage.getItem('userData_userId'));
    if (!primaryId) {
        if (!isAutoLoad) statusEl.textContent = 'Introduce un ID de Usuario para recuperar.';
        if (!isAutoLoad) statusEl.style.color = '#EF4444';
        return;
    }
    if (!isAutoLoad) {
        statusEl.textContent = `Buscando backup para "${primaryId}"...`;
        statusEl.style.color = '#17a2b8';
        showToast(`Recuperando backup de "${primaryId}"...`, 'info', 0, false, "firebase-restore-toast");
    }
    const result = await callFirebase('getUserData', { userId: primaryId });
    if (!isAutoLoad) {
        const existingToast = document.getElementById("firebase-restore-toast");
        if (existingToast) existingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== "firebase-restore-toast");
    }
    if (result.status === 'success' && result.data) {
        const firebaseData = result.data;
        const backupCacheData = firebaseData.contenidoCacheCompleto;
        if (!backupCacheData) {
            if (!isAutoLoad) {
                statusEl.textContent = `El backup para "${primaryId}" no contiene datos de caché.`;
                statusEl.style.color = '#EF4444';
                showToast('Backup incompleto.', 'error');
            }
            return;
        }
        const applyChanges = () => {
            const currentUserIdentity = localStorage.getItem('userData_userId') || originalId;
            for (const key in backupCacheData) {
                if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                    localStorage.setItem(key, backupCacheData[key]);
                }
            }
            localStorage.setItem('userData_userId', currentUserIdentity);
            const newTimestamp = Date.now().toString();
            localStorage.setItem('lastCacheUpdateTimestamp', newTimestamp);
            if (isMobile) {
                lastMobileSyncTimestamp = parseInt(newTimestamp);
            }
            showToast('Restauración completada. Recargando...', 'success', 3000);
            setTimeout(() => location.reload(), 2500);
        };
        if (isAutoLoad) {
            applyChanges();
        } else {
            promptForBackupPassword(
                `Introduce el PIN para "${primaryId}":`,
                (enteredPin) => {
                    if (enteredPin === firebaseData.backupPassword) {
                        if (confirm(`Backup para "${primaryId}" desbloqueado.\n\n¿Estás seguro de que quieres restaurar estos datos?\n\n¡ATENCIÓN! Se sobreescribirán TODOS tus datos locales actuales (grid, recordatorios, etc.). Esta acción NO se puede deshacer.`)) {
                            applyChanges();
                        } else {
                            statusEl.textContent = 'Restauración cancelada.';
                            statusEl.style.color = '#6c757d';
                            showToast("Restauración cancelada por el usuario.", "info");
                        }
                    } else {
                        statusEl.textContent = 'PIN incorrecto. Restauración cancelada.';
                        statusEl.style.color = '#EF4444';
                        showToast('PIN incorrecto.', 'error');
                    }
                },
                () => {
                    statusEl.textContent = 'Restauración cancelada.';
                    statusEl.style.color = '#6c757d';
                }
            );
        }
    } else if (result.status === 'not_found' && !isAutoLoad) {
        statusEl.textContent = `No se encontró backup para "${primaryId}".`;
        statusEl.style.color = '#EF4444';
        showToast('Backup no encontrado.', 'error not-found');
    } else if (!isAutoLoad) {
        statusEl.textContent = `Error al recuperar: ${result.message}`;
        statusEl.style.color = '#EF4444';
        showToast(`Error de recuperación: ${result.message}`, 'error');
    }
}
    
    // ===================================================================
    // NOMBRE: getRandomSpeedMultiplierForManeuver
    // RESUMEN: Devuelve un multiplicador aleatorio de velocidad para simular variaciones en las maniobras.
    function getRandomSpeedMultiplierForManeuver(maneuver) {
        const type = maneuver.type || '';
        const modifier = maneuver.modifier || '';
        let min, max;
        if (type === 'roundabout' || type === 'rotary' || modifier.includes('sharp') || modifier.includes('uturn')) {
            min = -0.40;
            max = 0.20;
        } else if (type === 'turn' || type === 'fork' || type === 'merge' || type === 'end of road') {
            min = -0.30;
            max = 0.10;
        } else {
            min = -0.25;
            max = 0.35;
        }
        return Math.random() * (max - min) + min;
    }


    
// ===================================================================
// NOMBRE: addRouteToRecents 
// RESUMEN: Añade una ruta o destino al historial, evitando duplicados por nombre
function addRouteToRecents(routeObject) {
    if (!routeObject || !routeObject.waypoints || routeObject.waypoints.length < 1) {
        return;
    }
    const RECENT_ROUTES_KEY = 'boardinggate_recent_routes';
    const MAX_RECENT_ROUTES = 3; 
    let recentRoutes = [];
    try {
        recentRoutes = JSON.parse(localStorage.getItem(RECENT_ROUTES_KEY)) || [];
    } catch (e) {
        recentRoutes = [];
    }

    let simplifiedRoute;
    const waypointsForCheck = routeObject.waypoints;
    const isSingleDestination = waypointsForCheck.length === 1 || (waypointsForCheck.length === 2 && (waypointsForCheck[0].type === 'S' || waypointsForCheck[0].isRecalculatedStart));

    if (isSingleDestination) {
        const finalWaypoint = waypointsForCheck[waypointsForCheck.length - 1];
        simplifiedRoute = {
            name: routeObject.name,
            waypoints: sanitizeWaypointsForStorage([finalWaypoint]), // Guardamos solo el destino
            timestamp: new Date().toISOString()
        };
    } else {
        simplifiedRoute = {
            name: routeObject.name,
            waypoints: sanitizeWaypointsForStorage(waypointsForCheck), // Guardamos la ruta completa
            timestamp: new Date().toISOString()
        };
    }
    
    const uniqueRecentRoutes = recentRoutes.filter(item => item.name !== simplifiedRoute.name);
    
    uniqueRecentRoutes.unshift(simplifiedRoute);
    const finalRecentRoutes = uniqueRecentRoutes.slice(0, MAX_RECENT_ROUTES);
    localStorage.setItem(RECENT_ROUTES_KEY, JSON.stringify(finalRecentRoutes));
    markCacheAsDirty(); 
}
    
// ===================================================================
// NOMBRE: addModalAutoCloseTimer
// RESUMEN: Añade un temporizador de autocierre a un modal.
function addModalAutoCloseTimer(modalElement, closeButtonElement, modalId, duration = 90000) {
    if (!modalElement || !closeButtonElement || !modalId) {
        return;
    }
    modalElement.dataset.modalTimerId = modalId;
    clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId);
    let countdown = duration / 1000;
    const originalButtonText = closeButtonElement.textContent.split(' (')[0];
    const countdownSpanId = `modal-countdown-${modalId}`;
    let countdownSpan = closeButtonElement.querySelector(`.button-countdown-timer`);
    if (!countdownSpan) {
        countdownSpan = document.createElement('span');
        countdownSpan.className = 'button-countdown-timer';
        countdownSpan.style.marginLeft = '5px';
        countdownSpan.style.fontWeight = 'normal';
        closeButtonElement.appendChild(countdownSpan);
    }
    countdownSpan.textContent = ` ${countdown}`;
    const intervalId = setInterval(() => {
        countdown--;
        if (countdownSpan && document.body.contains(countdownSpan)) {
          countdownSpan.textContent = ` ${countdown}`;
        }
        if (countdown <= 0) {
            if (globalModalTimers[modalId]) {
                clearInterval(globalModalTimers[modalId].intervalId);
                delete globalModalTimers[modalId];
            }
            if (closeButtonElement && document.body.contains(closeButtonElement)) {
                closeButtonElement.click();
            } else if (modalElement && modalElement.parentNode) {
                 if (!STATIC_MODAL_IDS.includes(modalElement.id)) {
                    modalElement.parentNode.removeChild(modalElement);
                 } else {
                    modalElement.classList.add('hidden');
                 }
            }
        }
    }, 1000);
    const resetTimerHandler = () => {
        if (!globalModalTimers[modalId] || !globalModalTimers[modalId].intervalId) return;
        clearInterval(globalModalTimers[modalId].intervalId);
        countdown = duration / 1000;
        if (countdownSpan && document.body.contains(countdownSpan)) {
           countdownSpan.textContent = ` ${countdown}`;
        }
        const newIntervalId = setInterval(() => {
            countdown--;
            if (countdownSpan && document.body.contains(countdownSpan)) {
                countdownSpan.textContent = ` ${countdown}`;
            }
            if (countdown <= 0) {
                if (globalModalTimers[modalId]) {
                    clearInterval(globalModalTimers[modalId].intervalId);
                    delete globalModalTimers[modalId];
                }
                if (closeButtonElement && document.body.contains(closeButtonElement)) {
                    closeButtonElement.click();
                } else if (modalElement && modalElement.parentNode) {
                    if (!STATIC_MODAL_IDS.includes(modalElement.id)) {
                       modalElement.parentNode.removeChild(modalElement);
                    } else {
                       modalElement.classList.add('hidden');
                    }
                }
            }
        }, 1000);
        globalModalTimers[modalId].intervalId = newIntervalId;
    };
    modalElement.addEventListener('click', resetTimerHandler);
    modalElement.addEventListener('touchstart', resetTimerHandler, { passive: true });
    modalElement.addEventListener('input', resetTimerHandler);
    modalElement.addEventListener('scroll', resetTimerHandler, { passive: true });
    globalModalTimers[modalId] = {
        intervalId: intervalId,
        resetHandler: resetTimerHandler,
        modalElement: modalElement,
        closeButtonElement: closeButtonElement,
        countdownSpan: countdownSpan
    };
}

    
// ===================================================================
// NOMBRE: restoreBackup
// RESUMEN: Restaura los datos locales desde un código de backup manual.
function restoreBackup() {
    const restoreInput = document.getElementById('config-restore-input');
    const backupStringBase64 = restoreInput.value.trim();
    const statusEl = document.getElementById('config-restore-status');
    statusEl.textContent = '';
    if (!backupStringBase64) {
        statusEl.textContent = 'Pega el código de backup primero.';
        statusEl.style.color = '#EF4444';
        return;
    }
    try {
        const backupString = decodeURIComponent(escape(atob(backupStringBase64)));
        const backupData = JSON.parse(backupString);
        let restoredCount = 0;
        let incompatibleCount = 0;
        if (confirm('Esto sobreescribirá tus datos actuales con los del backup. ¿Estás seguro?')) {
            Object.keys(backupData).forEach(key => {
                if (managedKeys.includes(key)) {
                    localStorage.setItem(key, backupData[key]);
                    restoredCount++;
                } else {
                    incompatibleCount++;
                }
            });
            loadCustomData();
            loadSavedSettings();
            updateUserIdDisplay();
    
            markCacheAsDirty(); 
            statusEl.textContent = `Restauración completada. ${restoredCount} claves restauradas. ${incompatibleCount} claves ignoradas (incompatibles). La página se recargará.`;
            statusEl.style.color = '#28a745';
            showToast('Restauración completada. Recargando...', 'success');
            setTimeout(() => location.reload(), 2500);
        } else {
             statusEl.textContent = 'Restauración cancelada.';
             statusEl.style.color = '#6c757d';
        }
    } catch (e) {
        statusEl.textContent = 'Error: Código de backup inválido o corrupto.';
        statusEl.style.color = '#EF4444';
        showToast('Error en el código de backup', 'error');
    }
}  
    
    // ===================================================================
    // NOMBRE: clearNavigationGraph
    // RESUMEN: Limpia y oculta la gráfica de navegación.
    function clearNavigationGraph() {
        if (graphIntervalTimer) {
            clearInterval(graphIntervalTimer);
            graphIntervalTimer = null;
        }
        if (navigationChart) {
            navigationChart.destroy();
            navigationChart = null;
        }
        const graphCard = document.getElementById('navigation-graph-card');
        if (graphCard) {
            graphCard.classList.add('hidden');
        }
        graphDataPoints = { speed: [], altitude: [] };
        graphLabels = [];
    }


// ===================================================================
// NOMBRE: hideNavigationUI
// RESUMEN: Oculta los elementos de la interfaz de usuario de navegación.
function hideNavigationUI() {
    const topInfoBar = document.getElementById('navigation-top-info-bar');
    const bottomProgressBar = document.getElementById('navigation-bottom-progress-bar');
    const startNavButton = document.getElementById('start-navigation-button');
    const saveRouteButton = document.getElementById('save-route-button');
    const reorderBtn = document.getElementById('reorder-route-stages-button');
    const simulateBtn = document.getElementById('simulate-route-button');
    const toggleSimulateGpsBtn = document.getElementById('toggle-simulate-gps-button');
    const graphCard = document.getElementById('navigation-graph-card');
    const miniNavCard = document.getElementById('mini-nav-info-card');
    if (topInfoBar) topInfoBar.style.display = 'none';
    if (bottomProgressBar) bottomProgressBar.style.display = 'none';
    if (miniNavCard) miniNavCard.style.display = 'none';
    if (saveRouteButton) saveRouteButton.classList.add('hidden');
    if (reorderBtn) reorderBtn.style.display = 'none';
    if (simulateBtn) simulateBtn.style.display = 'none';
    if (graphCard) graphCard.classList.add('hidden');
    hideIntersectionPreviewMap();
}
    
    // ===================================================================
    // NOMBRE: showNavigationUIElementsForPlanning
    // RESUMEN: Muestra los elementos de la UI para la planificación de rutas.
    function showNavigationUIElementsForPlanning() {
        const topInfoBar = document.getElementById('navigation-top-info-bar');
        const bottomProgressBar = document.getElementById('navigation-bottom-progress-bar');
        if (!navigationCurrentRouteData || !navigationCurrentRouteData.routes || navigationCurrentRouteData.routes.length === 0 || navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
            if (topInfoBar) topInfoBar.style.display = 'none';
            if (bottomProgressBar) bottomProgressBar.style.display = 'none';
            hideMapInfoOverlay();
            hideIntersectionPreviewMap();
        } else {
            if (topInfoBar) topInfoBar.style.display = 'flex';
            if (bottomProgressBar) bottomProgressBar.style.display = 'flex';
            let carDistAlongRoutePlan = 0;
            const currentCarPosForShowUI = navigationCurrentLocation;
            if (currentCarPosForShowUI && navigationMapInstance && navigationCurrentRouteData.routes[0] && typeof turf !== 'undefined') {
                try {
                    const carPointTurf = turf.point([currentCarPosForShowUI.longitude, currentCarPosForShowUI.latitude]);
                    const routeLineStringTurf = turf.lineString(navigationCurrentRouteData.routes[0].geometry.coordinates);
                    const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                    const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                    carDistAlongRoutePlan = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                } catch(e){  }
             }
            updateTurnByTurnDisplay(navigationCurrentRouteData.routes[0], carDistAlongRoutePlan);
            showDestinationName();
        }
    }
     
    // ===================================================================
    // NOMBRE: getManeuverInstructionText
    // RESUMEN: Convierte una maniobra de OSRM en un texto legible.
    function getManeuverInstructionText(maneuver) {
        if (!maneuver) return '';
        const type = maneuver.type || '';
        const modifier = maneuver.modifier || '';
        let exit = maneuver.exit;
        let key = `${type}-${modifier}`;
        let text = maneuverTexts[key];
        if (!text) {
            key = `${type}-`;
            text = maneuverTexts[key];
        }
        if (!text && type === 'turn' && !modifier) {
            text = maneuverTexts['turn-'] || type.replace(/-/g, ' ');
        } else if (!text) {
            text = type.replace(/-/g, ' ');
        }
        const roundaboutExitTypes = ['roundabout turn', 'exit roundabout', 'rotary', 'roundabout'];
        if (roundaboutExitTypes.includes(type) && typeof exit === 'number' && exit > 0) {
             const ordinals = ["", "primera", "segunda", "tercera", "cuarta", "quinta"];
             const ordinalText = (exit >= 1 && exit <= 5) ? ordinals[exit] : `${exit}ª`;
             text = `Sal en la rotonda en la ${ordinalText} salida`;
        }
        let baseText = text.charAt(0).toUpperCase() + text.slice(1);
        return baseText;
    }  
// ===================================================================
// NOMBRE: formatDeviationForMiniCard (VERSIÓN FINAL CON COLOR DE TEXTO)
// RESUMEN: Formatea la desviación con el color del texto rojo/verde, borde negro y sombra.
// ===================================================================
function formatDeviationForMiniCard(milliseconds) {
    if (typeof milliseconds !== 'number' || isNaN(milliseconds) || Math.abs(milliseconds) < 1000) {
        const style = `
            color: white; 
            text-shadow: 
                -1px -1px 0 #878683, 1px -1px 0 #545252, 
                -1px 1px 0 #878683, 1px 1px 0 #545252;`;
        return `<span class="eta-deviation" style="${style}">[ 00:00 ]</span>`;
    }
    
    const totalSeconds = Math.round(Math.abs(milliseconds) / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const sign = milliseconds > 0 ? '+' : '-';
    
    const textColor = milliseconds > 0 ? '#e08555' : '#10B981';
    
    const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

    const style = `
        color: ${textColor}; 
        text-shadow: 
        1px 1px 0 #000,
        2px 2px 4px rgba(0, 0, 0, 0.5);`;
  
    return `<span class="eta-deviation" style="${style}">[ ${sign}${formattedTime} ]</span>`;
}

// ===================================================================
// NOMBRE: formatDeviation 
// RESUMEN: Formatea la desviación de tiempo ETA, devolviendo directamente
function formatDeviation(milliseconds) {
    if (typeof milliseconds !== 'number' || isNaN(milliseconds)) {
        return '';
    }
    if (Math.abs(milliseconds) < 1000) {
        return `<span class="eta-deviation">[00:00]</span>`;
    }
    const totalSeconds = Math.round(Math.abs(milliseconds) / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const sign = milliseconds > 0 ? '+' : '-';
    const colorClass = milliseconds > 0 ? 'positive' : 'negative';
    const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    return `<span class="eta-deviation ${colorClass}">[${sign}${formattedTime}]</span>`;
}    
    
    // ===================================================================
    // NOMBRE: parseCoordinateFilter
    // RESUMEN: Parsea y aplica un filtro de coordenadas (valor único o rango).
   function parseCoordinateFilter(filterValue, coordinate) {
        if (!filterValue) return true;
        const parts = filterValue.trim().split(/\s+/).map(s => parseFloat(s.replace(',','.'))).filter(n => !isNaN(n));
        if (parts.length === 1) {
            return Math.abs(coordinate - parts[0]) < COORD_EPSILON;
        } else if (parts.length === 2) {
            const minVal = Math.min(parts[0], parts[1]);
            const maxVal = Math.max(parts[0], parts[1]);
            return coordinate >= minVal && coordinate <= maxVal;
        } else if (parts.length === 0 && filterValue.trim() !== "") {
            return false;
        }
        return true;
    }
    
// ===================================================================
// NOMBRE: closeOtherModals 
// RESUMEN: Se ha eliminado 'address-suggestions-modal' de la lista
function closeOtherModals(modalToKeepOpenId = null) {
    const STATIC_MODAL_IDS = ['config-modal', 'versions-modal-overlay', 'pin-modal-overlay', 'reorder-stages-modal', 'simulation-modal', 'locations-preview-modal', 'deviation-modal', 'arrival-stats-modal', 'simulation-speed-modal'];

    STATIC_MODAL_IDS.forEach(id => {
        if (id === modalToKeepOpenId) return;
        const modal = document.getElementById(id);
        if (modal && !modal.classList.contains('hidden')) {
            if (id === 'reorder-stages-modal') {
                const listElement = modal.querySelector('#sortable-stages-list');
                if (listElement) {
                    listElement.removeEventListener('dragstart', handleDragStartReorder);
                    listElement.removeEventListener('dragend', handleDragEndReorder);
                    listElement.removeEventListener('dragover', handleDragOverReorder);
                    listElement.removeEventListener('touchstart', handleStageTouchStart);
                    listElement.removeEventListener('touchmove', handleStageTouchMove);
                    listElement.removeEventListener('touchend', handleStageTouchEnd);
                    listElement.removeEventListener('touchcancel', handleStageTouchEnd);
                }
                if (draggedStageLi) {
                    draggedStageLi.classList.remove('dragging');
                    draggedStageLi = null;
                }
                clearTimeout(stageScrollTimeout);
                document.body.style.overflow = '';
            }
             if (id === 'deviation-modal') {
                if (deviationModalTimerId) clearInterval(deviationModalTimerId);
                deviationModalTimerId = null;
                isDeviationModalActive = false;
            }
             if (id === 'arrival-stats-modal') {
                const acceptButton = modal.querySelector('#arrival-stats-accept-button');
                if (acceptButton) clearModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal');
             }
             if (id === 'simulation-speed-modal') {
                const confirmBtn = modal.querySelector('#confirm-navigation-simulation');
                if(confirmBtn) clearModalAutoCloseTimer(modal, confirmBtn, 'simulation-speed-modal');
             }
            modal.classList.add('hidden');
            const closeBtn = modal.querySelector('button[id^="close-"], button[id*="-close"], #cancel-postpone, #close-saved-routes-modal, #cancel-reorder-stages, #config-close-modal, #close-versions-modal, #pin-submit-button, #close-simulation-modal, #close-locations-preview, #deviation-accept, #arrival-stats-accept-button, #cancel-simulation-speed');
            if (closeBtn) clearModalAutoCloseTimer(modal, closeBtn, id.replace(/-/g, '_') || `modal_timer_${Date.now()}`);
             if (id === 'simulation-modal') {
                 if (simulationModalTimer) {
                     clearTimeout(simulationModalTimer);
                     simulationModalTimer = null;
                 }
                 hideIntersectionPreviewMap();
             }
        }
    });
    document.querySelectorAll(
        '.choice-modal, .edit-modal, .edit-info-modal, .help-modal, .reminder-modal, .reminder-table-modal, #postpone-options-modal, .saved-locations-modal, #reminders-map-help-modal-instance'
    ).forEach(m => {
        if (m.id === modalToKeepOpenId) return;
        if (m.parentNode) {
             const closeBtn = m.querySelector('button[id^="close-"], button[id*="-close"], #cancel-postpone');
             if(closeBtn) clearModalAutoCloseTimer(m, closeBtn, m.id.replace(/-/g, '_') || `modal_timer_${Date.now()}`);
             m.remove();
        }
    });
     if (modalToKeepOpenId !== 'unified-reminder-window') {
        hideUnifiedReminderWindow();
     }
}    
// ===================================================================
// NOMBRE: showConfigModal 
// RESUMEN: Muestra el modal de configuración principal, incluyendo la hora de inicio de la sesión de mapa activa.
function showConfigModal() {
    closeOtherModals('config-modal');
    const modal = document.getElementById('config-modal');
    if (!modal) return;

    const sessionStatusEl = document.getElementById('map-session-status');
    if (sessionStatusEl) {
        if (mapSessionStartTime) {
            const sessionDate = new Date(mapSessionStartTime);
            const formattedTime = sessionDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            sessionStatusEl.textContent = `(Sesión de mapa abierta: ${formattedTime})`;
        } else {
            sessionStatusEl.textContent = '(No hay sesión de mapa activa)';
        }
    }
  
    const termsAccepted = localStorage.getItem('termsAccepted_v1') === 'true';
    const tabButtons = modal.querySelectorAll('.config-tab-button');
    const tabContents = modal.querySelectorAll('.config-tab-content');

    if (!termsAccepted) {
        tabButtons.forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.tabTarget !== '#tab-content-normas') {
                btn.disabled = true; 
                btn.style.cursor = 'not-allowed';
                btn.style.opacity = '0.5';
            }
        });
        tabContents.forEach(content => content.classList.remove('active'));
        
        modal.querySelector('.config-tab-button[data-tab-target="#tab-content-normas"]').classList.add('active');
        modal.querySelector('#tab-content-normas').classList.add('active');
    } else {
        tabButtons.forEach(btn => {
            btn.disabled = false;
            btn.style.cursor = 'pointer';
            btn.style.opacity = '1';
            btn.classList.toggle('active', btn.dataset.tabTarget === '#tab-content-usuario');
        });
        tabContents.forEach(content => {
            content.classList.toggle('active', content.id === 'tab-content-usuario');
        });
    }

    modal.querySelectorAll('.status-message').forEach(msg => msg.textContent = '');
    modal.querySelectorAll('input[type="text"], input[type="number"], textarea').forEach(input => {
        if (!['user-id', 'config-pin-set', 'config-pin-confirm'].includes(input.id)) {
            input.value = '';
        }
    });
    modal.querySelector('#config-pin-set').value = '';
    modal.querySelector('#config-pin-confirm').value = '';
    modal.querySelector('#config-backup-display').value = '';
    modal.querySelector('#config-restore-input').value = '';
    if(modal.querySelector('#config-backup-display')) modal.querySelector('#config-backup-display').style.display = 'none';
    const userIdInput = modal.querySelector('#user-id');
    const storedUserId = localStorage.getItem('userData_userId');
    if (userIdInput) userIdInput.value = storedUserId || '';
    
    const teslaModelInput = modal.querySelector('#tesla-model');
    if (teslaModelInput) teslaModelInput.value = localStorage.getItem('userData_teslaModel') || '';
    const teslaYearInput = modal.querySelector('#tesla-year');
    if (teslaYearInput) teslaYearInput.value = localStorage.getItem('userData_teslaYear') || '';
    const teslaProvinceInput = modal.querySelector('#tesla-province');
    if (teslaProvinceInput) teslaProvinceInput.value = localStorage.getItem('userData_teslaProvince') || '';
    const allowDmsCheckbox = modal.querySelector('#allow-dms');
    if (allowDmsCheckbox) allowDmsCheckbox.checked = JSON.parse(localStorage.getItem('userData_allowDMs')) || false;
    
    const directToNavCheckbox = document.getElementById('config-direct-to-nav');
    if (directToNavCheckbox) directToNavCheckbox.checked = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;

    const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
    if (autoBackupCheckbox) {
        const savedAutoBackup = localStorage.getItem('boardinggate_autoBackupOnLoad');
        autoBackupCheckbox.checked = savedAutoBackup === null ? true : JSON.parse(savedAutoBackup);
    }

    modal.classList.remove('hidden');
    const closeButtonConfig = modal.querySelector('#config-close-modal');
    addModalAutoCloseTimer(modal, closeButtonConfig, 'config-modal', 120000);
}
    
    // ===================================================================
    async function loadNotices() { try { const r = await fetch('https://boardinggate.github.io/Tesla/avisos.txt', { cache: 'no-cache' }); if (!r.ok) throw new Error('Fetch failed'); const txt = await r.text(); notices = txt.split('\n').map(l => l.trim()).filter(l => l.length > 0); if (notices.length === 0) notices = ['No hay avisos.']; } catch (e) { notices = ['Error carga avisos.']; } updateNotice(); } 
    
    // ===================================================================
    function updateNotice() { const noticeElement = document.getElementById('current-notice'); if (!noticeElement || notices.length === 0) { return; } if (!isActive) { noticeElement.textContent = ''; noticeElement.style.animation = 'none'; return; } noticeElement.textContent = notices[currentNoticeIndex]; noticeElement.style.animation = 'none'; void noticeElement.offsetWidth; noticeElement.style.animation = 'fadeInOut 14s infinite'; currentNoticeIndex = (currentNoticeIndex + 1) % notices.length; }
    
    // ===================================================================
    function toggleNotices() { isActive = !isActive; const nC = document.querySelector('.notices-container'); if (nC) nC.style.display = isActive ? 'flex' : 'none'; const fC = document.querySelector('footer'); if (fC) fC.classList.toggle('footer-hidden', !isActive); isFooterVisible = isActive; const nE = document.getElementById('current-notice'); if (nE) { if (!isActive) { nE.textContent = ''; nE.style.animation = 'none'; } else { currentNoticeIndex = 0; updateNotice(); } } saveSettings(); }

    // ===================================================================
    function startNoticeRotation() { if (notices.length === 0) return; if (isActive) updateNotice(); setInterval(updateNotice, 14000); }
    
    // ===================================================================
    function adjustButtonPositions() { const scrollToggle = document.getElementById('scroll-toggle'); if (!scrollToggle) { return; }
    const scrollToggleHeight = scrollToggle.offsetHeight; const buttonHeight = 74; const buttonSpacing = 10; const startTop = scrollToggleHeight + 20; const fixedButtons = [ document.getElementById('on-off-toggle'), ...document.querySelectorAll('.range-toggle'), document.getElementById('weather-button'), document.getElementById('reminder-button'), document.getElementById('zoom-button'), document.getElementById('dark-mode-toggle') ].filter(button => button !== null).sort((a, b) => { const startA = parseInt(a.dataset.rangeStart) || Infinity; const startB = parseInt(b.dataset.rangeStart) || Infinity; if (a.id === 'on-off-toggle') return -1; if (b.id === 'on-off-toggle') return 1; if (isFinite(startA) && isFinite(startB)) return startA - startB; if (isFinite(startA)) return -1; if (isFinite(startB)) return 1; const order = ['weather-button', 'reminder-button', 'zoom-button', 'dark-mode-toggle']; return order.indexOf(a.id) - order.indexOf(b.id); }); if (fixedButtons.length < 6) { return; } let currentTop = startTop; fixedButtons.forEach((button) => { button.style.position = 'fixed'; button.style.top = `${currentTop}px`; button.style.left = '10px'; currentTop += buttonHeight + buttonSpacing; }); }
    
    
 
// ===================================================================
// NOMBRE: translatePoiCategory (VERSIÓN CON TRADUCCIÓN MANUAL)
// RESUMEN: Traduce y formatea las categorías de POI recibidas en inglés desde la API de Mapbox.
function translatePoiCategory(categories) {
    if (!Array.isArray(categories) || categories.length === 0) {
        return 'General';
    }

    const MAPBOX_CATEGORY_TRANSLATIONS = {
        'restaurant': 'Restaurante',
        'cafe': 'Cafetería',
        'bar': 'Bar',
        'fast_food': 'Comida Rápida',
        'food_court': 'Zona de Restaurantes',
        'gas_station': 'Gasolinera',
        'parking': 'Parking',
        'hotel': 'Hotel',
        'motel': 'Motel',
        'lodging': 'Alojamiento',
        'supermarket': 'Supermercado',
        'grocery': 'Tienda de Alimentación',
        'convenience': 'Tienda de Conveniencia',
        'shopping': 'Tiendas',
        'mall': 'Centro Comercial',
        'clothing_store': 'Tienda de Ropa',
        'hardware_store': 'Ferretería',
        'home_goods_store': 'Tienda de Hogar',
        'pharmacy': 'Farmacia',
        'hospital': 'Hospital',
        'clinic': 'Clínica',
        'doctor': 'Médico',
        'dentist': 'Dentista',
        'atm': 'Cajero Automático',
        'bank': 'Banco',
        'tourist_attraction': 'Atracción Turística',
        'landmark': 'Lugar de Interés',
        'museum': 'Museo',
        'park': 'Parque',
        'zoo': 'Zoo',
        'airport': 'Aeropuerto',
        'bus_station': 'Estación de Autobuses',
        'train_station': 'Estación de Tren',
        'subway_station': 'Estación de Metro',
        'car_rental': 'Alquiler de Coches',
        'car_repair': 'Taller Mecánico',
        'car_wash': 'Lavado de Coches',
        'library': 'Biblioteca',
        'school': 'Colegio',
        'university': 'Universidad',
        'post_office': 'Oficina de Correos',
        'police': 'Policía',
        'fire_station': 'Bomberos',
        'cinema': 'Cine',
        'night_club': 'Discoteca',
        'stadium': 'Estadio',
        'gym': 'Gimnasio',
        'golf_course': 'Campo de Golf',
        'beach': 'Playa',
        'campground': 'Camping',
        'marina': 'Puerto Deportivo'
    };

    const translatedCategories = categories.map(englishCategory => {
        const translated = MAPBOX_CATEGORY_TRANSLATIONS[englishCategory];
        if (translated) {
            return translated;
        } else {
            const cleaned = englishCategory.replace(/_/g, ' ');
            return cleaned.charAt(0).toUpperCase() + cleaned.slice(1);
        }
    });

    return translatedCategories.join(', ');
}

// ===================================================================
// NOMBRE: findExistingWaypointAtCoords
// RESUMEN: Busca si ya existe una etapa de ruta en las coordenadas dadas.
function findExistingWaypointAtCoords(lat, lon, toleranceMeters = 10) {
    for (const waypoint of navigationWaypoints) {
        if (waypoint && !waypoint.isInternal) {
            const distance = calculateDistance(lat, lon, waypoint.lat, waypoint.lng);
            if (distance <= toleranceMeters) {
                return waypoint;
            }
        }
    }
    return null;
}
    
// ===================================================================
// NOMBRE: enablePoiInteractivity (VERSIÓN SIMPLIFICADA)
// RESUMEN: Únicamente cambia el cursor a "puntero" al pasar sobre los POIs.
function enablePoiInteractivity(mapInstance) {
    if (!mapInstance) return;

    const interactiveLayers = [
        'poi-label', 'transit-label', 'airport-label', 'settlement-label', 
        'natural-label', 'water-point-label'
    ];

    mapInstance.on('mouseenter', interactiveLayers, () => {
        mapInstance.getCanvas().style.cursor = 'pointer';
    });
    mapInstance.on('mouseleave', interactiveLayers, () => {
        mapInstance.getCanvas().style.cursor = '';
    });
}

// ===================================================================
// NOMBRE: loadAndAddMapImages 
// RESUMEN: Carga imágenes y continúa aunque alguna falle.
async function loadAndAddMapImages(mapInstance) {
    const imagesToLoad = [
        { name: 'reminder-icon', url: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png' },
        { name: 'radar-generic-icon', url: 'PNG/RADARAQUI.PNG' },
        { name: 'pdr-icon-simple', url: 'PNG/pdrs.png' },
        // === NUEVO ICONO AÑADIDO ===
        { name: 'radar-no-speed-icon', url: 'PNG/radar.png' }, 
        // ============================
        { name: 'alert-1', url: 'PNG/AACCIDENTE.png' },
        { name: 'alert-2', url: 'PNG/AAVERIADO.png' },
        { name: 'alert-3', url: 'PNG/AGUARDIA22.png' },
        { name: 'alert-4', url: 'PNG/AATASCO.png' },
        { name: 'alert-5', url: 'PNG/APELIGRO.png' },
        { name: 'alert-6', url: 'PNG/ARESVALAR.png' },
        { name: 'alert-7', url: 'PNG/AOBRAS.png' },
        { name: 'alert-8', url: 'PNG/ACERRADA.png' }
    ];

    const imageLoadPromises = imagesToLoad.map(img => 
        new Promise((resolve) => { 
            if (mapInstance.hasImage(img.name)) {
                resolve();
                return;
            }
            mapInstance.loadImage(img.url, (error, image) => {
                if (error) {
                    console.error(`Error al cargar imagen ${img.name}:`, error);
                    resolve(); 
                    return;
                }
                if (!mapInstance.hasImage(img.name)) {
                    mapInstance.addImage(img.name, image, { sdf: false });
                }
                resolve();
            });
        })
    );
    await Promise.all(imageLoadPromises);
}
        
// ===================================================================
// NOMBRE: showSaveRoutePromptForSingleWaypoint (VERSIÓN CORREGIDA Y DEFINITIVA)
// RESUMEN: Muestra el modal de guardado, usando directamente el nombre descriptivo
async function showSaveRoutePromptForSingleWaypoint(waypointObject) {
    const defaultName = `UBICACIÓN: ${waypointObject.address}`.toUpperCase();
    
    const onSaveCallback = (confirmedName) => {
        const routeToSave = {
            name: confirmedName,
            waypoints: [{ ...waypointObject, type: 'F', label: 'F' }],
            createdAt: new Date().toISOString()
        };

        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        const existingRouteIndex = savedRoutes.findIndex(r => r.name.toUpperCase() === confirmedName);

        if (existingRouteIndex !== -1) {
            if (confirm(`Ya existe una ubicación guardada como "${confirmedName}". ¿Deseas sobreescribirla?`)) {
                savedRoutes[existingRouteIndex] = routeToSave;
            } else {
                showToast("Guardado cancelado", "info");
                return;
            }
        } else {
            savedRoutes.push(routeToSave);
        }

        if (savedRoutes.length > MAX_SAVED_ROUTES) {
            savedRoutes.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
            savedRoutes = savedRoutes.slice(0, MAX_SAVED_ROUTES);
        }
        localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes));
        markCacheAsDirty();
        showToast(`Ubicación "${confirmedName}" guardada en favoritos.`, "success");
    };

    showSaveRoutePromptModal(defaultName, onSaveCallback);
} 
// ===================================================================
// NOMBRE: getGlobalPoiStats
// RESUMEN: Calcula las estadísticas globales de clics en POIs de todos los usuarios.
async function getGlobalPoiStats() {
    if (!window.db) return { totalMonth: 0 };
    
    let totalMonth = 0;
    
    try {
        const usersCollectionRef = window.collection(window.db, "user_data");
        const querySnapshot = await window.getDocs(usersCollectionRef);
        
        const now = new Date();
        const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        querySnapshot.forEach(doc => {
            const data = doc.data();
            if (data.poi_clicks_last_month === currentMonthStr) {
                totalMonth += (data.poi_clicks_month || 0);
            }
        });

    } catch (error) {
        console.error("Error al obtener estadísticas globales de POIs:", error);
    } 
    return { totalMonth };
}

// ===================================================================
// NOMBRE: showPoiInfoModal 
// RESUMEN: Muestra un modal enriquecido con datos de Google Places.
async function showPoiInfoModal(feature) {
    const existingModal = document.querySelector('.poi-modal-overlay');
    if (existingModal) existingModal.remove();

    const overlay = document.createElement('div');
    overlay.className = 'poi-modal-overlay';
    
    overlay.innerHTML = `
        <div class="poi-modal-content">
            <div class="poi-modal-body" style="text-align: center; padding: 3rem;">
                <p>Obteniendo información del lugar...</p>
            </div>
        </div>
    `;
    document.body.appendChild(overlay);

    try {
        const canProceed = await checkAndIncrementPoiCount();
        if (!canProceed) {
            if (overlay.parentNode) overlay.remove();
            return;
        }

        const mapboxProperties = feature.properties || {};
        const coordinates = feature.geometry.coordinates.slice();
        const mapboxName = mapboxProperties.name || 'Punto de Interés';
        
        const placeId = await findGooglePlaceId(mapboxName, coordinates[1], coordinates[0]);
        
        let name, address, phone, website, imageUrl, saveName, photosHtml = '', commentsHtml = '', detailsHtml = '';
        const lat = coordinates[1];
        const lng = coordinates[0];

        if (placeId) {
            const googleDetails = await getGooglePlaceDetails(placeId);
            
            if (googleDetails) {
                name = googleDetails.displayName || mapboxName;
                address = googleDetails.formattedAddress || `(${lat.toFixed(4)}, ${lng.toFixed(4)})`;
                phone = googleDetails.nationalPhoneNumber;
                website = googleDetails.websiteURI;
                imageUrl = (googleDetails.photos && googleDetails.photos.length > 0) 
                    ? googleDetails.photos[0].getURI({ maxWidth: 600, maxHeight: 400 }) 
                    : 'PNG/modalrutas.png'; // <-- CAMBIO APLICADO AQUÍ
                saveName = name;

                detailsHtml += '<h4>Valoración</h4>';
                if(googleDetails.rating) {
                    detailsHtml += `<p>${'★'.repeat(Math.round(googleDetails.rating))}${'☆'.repeat(5 - Math.round(googleDetails.rating))} (${googleDetails.rating} de ${googleDetails.userRatingCount} opiniones)</p>`;
                } else {
                    detailsHtml += '<p>No hay valoraciones disponibles.</p>';
                }
                
                if (googleDetails.regularOpeningHours) {
                    detailsHtml += '<h4>Horario</h4>';
                    googleDetails.regularOpeningHours.weekdayDescriptions.forEach(day => {
                        detailsHtml += `<p>${day}</p>`;
                    });
                }
                
                detailsHtml += '<h4>Contacto</h4>';
                if(phone) detailsHtml += `<p><strong>Teléfono:</strong> <a href="tel:${phone}">${phone}</a></p>`;
                if(website) detailsHtml += `<p><strong>Web:</strong> <a href="${website}" target="_blank">${website}</a></p>`;
                if(googleDetails.googleMapsURI) detailsHtml += `<p><strong>En Google Maps:</strong> <a href="${googleDetails.googleMapsURI}" target="_blank">Abrir</a></p>`;

                if (googleDetails.photos && googleDetails.photos.length > 0) {
                    photosHtml = '<div class="ocm-photo-grid">' + googleDetails.photos.slice(0, 6).map(photo => 
                        `<img src="${photo.getURI({ maxWidth: 200, maxHeight: 200 })}" alt="Foto de ${name}" data-full-url="${photo.getURI()}">`
                    ).join('') + '</div>';
                } else { photosHtml = '<p>No hay fotos disponibles.</p>'; }

                if (googleDetails.reviews && googleDetails.reviews.length > 0) {
                    commentsHtml = '<ul class="ocm-comment-list">' + googleDetails.reviews.map(review => {
                        const authorName = review.authorAttribution ? review.authorAttribution.displayName : 'Anónimo';
                        const reviewDate = review.publishTime ? new Date(review.publishTime).toLocaleDateString('es-ES', { day: '2-digit', month: 'short', year: 'numeric'}) : '';
                        const reviewText = review.text ? review.text.originalText : 'Sin comentario.';
                        return `
                        <li class="ocm-comment">
                            <div class="ocm-comment-header">
                                <span class="user">${authorName} (${review.rating} ★)</span>
                                <span class="date">${reviewDate}</span>
                            </div>
                            <p class="comment-text">${reviewText}</p>
                        </li>
                    `}).join('') + '</ul>';
                } else { commentsHtml = '<p>No hay opiniones disponibles.</p>'; }

            } else {
                throw new Error("Google Place Details falló después de encontrar un ID.");
            }
        } else {
            name = mapboxName;
            address = `(${lat.toFixed(4)}, ${lng.toFixed(4)})`;
            category = translatePoiCategory(mapboxProperties.categories || []);
            imageUrl = 'PNG/modalrutas.png'; // <-- CAMBIO APLICADO AQUÍ
            saveName = name;
            detailsHtml = `<h4>Categoría</h4><p>${category}</p><p>No se encontraron detalles adicionales en Google.</p>`;
            photosHtml = '<p>No disponible.</p>';
            commentsHtml = '<p>No disponible.</p>';
        }
        
        const existingWaypoint = findExistingWaypointAtCoords(lat, lng);
        let buttonsHtml = `
            <button id="poi-add-btn" class="btn-modal-action-primary">Añadir a Ruta</button>
            <button id="poi-save-btn" class="btn-modal-favorite">Guardar POI</button>
            <button id="poi-share-btn" class="btn-modal-action-primary">Compartir</button>
        `;
        if (existingWaypoint) {
            buttonsHtml += `<button id="poi-delete-btn" class="btn-modal-danger" data-waypoint-id="${existingWaypoint.id}">Eliminar Etapa</button>`;
        } else {
             buttonsHtml += `<button id="poi-close-btn" class="btn-modal-action-secondary">Cerrar <span class="button-countdown-timer unified-countdown-style"></span></button>`;
        }
        
        overlay.querySelector('.poi-modal-content').innerHTML = `
            <div class="poi-modal-header" style="background-image: url('${imageUrl}');">
                <h3 class="poi-modal-title">${name}</h3>
                <p class="poi-modal-address">${address}</p>
            </div>
            <div class="ocm-modal-tabs">
                <div class="ocm-modal-tab active" data-panel="details">DETALLES</div>
                <div class="ocm-modal-tab" data-panel="photos">FOTOS</div>
                <div class="ocm-modal-tab" data-panel="comments">OPINIONES</div>
            </div>
            <div class="poi-modal-body">
                <div id="poi-panel-details" class="ocm-modal-panel active">${detailsHtml}</div>
                <div id="poi-panel-photos" class="ocm-modal-panel">${photosHtml}</div>
                <div id="poi-panel-comments" class="ocm-modal-panel">${commentsHtml}</div>
            </div>
            <div class="poi-modal-footer">${buttonsHtml}</div>
        `;
        
        const closeHandler = () => {
            clearModalAutoCloseTimer(overlay, overlay.querySelector('#poi-close-btn, #poi-delete-btn'), 'poi-modal');
            if (overlay.parentNode) overlay.remove();
        };

        const closeBtn = overlay.querySelector('#poi-close-btn');
        if (closeBtn) closeBtn.addEventListener('click', closeHandler);
        
        overlay.querySelector('#poi-add-btn').addEventListener('click', async () => {
            const snapped = await snapCoordsToRoad(lat, lng);
            addWaypoint({ lat: snapped.lat, lng: snapped.lng }, address);
            closeHandler();
        });

        overlay.querySelector('#poi-save-btn').addEventListener('click', () => {
             const waypointForSave = { lat: lat, lng: lng, address: saveName, id: Date.now() };
             showSaveRoutePromptForSingleWaypoint(waypointForSave);
             closeHandler();
        });

        overlay.querySelector('#poi-share-btn').addEventListener('click', () => {
            handleSendToTeslaClick(lat, lng, name);
            closeHandler();
        });
        
        overlay.querySelectorAll('.ocm-modal-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                overlay.querySelectorAll('.ocm-modal-tab, .ocm-modal-panel').forEach(el => el.classList.remove('active'));
                tab.classList.add('active');
                overlay.querySelector(`#poi-panel-${tab.dataset.panel}`).classList.add('active');
            });
        });

        overlay.querySelectorAll('.ocm-photo-grid img').forEach(img => {
            img.addEventListener('click', () => showPhotoModal(img.dataset.fullUrl));
        });

        const deleteBtn = overlay.querySelector('#poi-delete-btn');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', () => {
                handleDeleteWaypointClick(parseInt(deleteBtn.dataset.waypointId));
                closeHandler();
            });
        }
        addModalAutoCloseTimer(overlay, overlay.querySelector('#poi-close-btn, #poi-delete-btn'), 'poi-modal', 45000);

    } catch (error) {
        console.error("Error al mostrar el modal del POI:", error);
        showToast("Error al mostrar información del POI.", 'error');
        if (overlay.parentNode) overlay.remove();
    }
}    
    
// ===================================================================
// NOMBRE: updateRouteAndCarIconStyle (MODIFICADA)
// RESUMEN: Ajusta el estilo de la línea de ruta cuando ya existe, tras un cambio de capa de mapa.
function updateRouteAndCarIconStyle() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) return;

    if (navigationMapInstance.getLayer('route')) {
        const styleProps = getRouteStyleProperties();
        Object.keys(styleProps).forEach(prop => {
            navigationMapInstance.setPaintProperty('route', prop, styleProps[prop]);
        });
    }
}
    
// ===================================================================
function loadCustomData() { const savedData = localStorage.getItem('customGridData'); currentBookmarks = []; currentToggleRanges = []; customData = { bookmarks: {}, toggles: {} }; if (savedData) { try { customData = JSON.parse(savedData) || { bookmarks: {}, toggles: {} }; } catch (e) { customData = { bookmarks: {}, toggles: {} }; } } if (!customData.bookmarks) customData.bookmarks = {}; if (!customData.toggles) customData.toggles = {}; currentBookmarks = Array.from({ length: TOTAL_CELLS }).map((_, index) => { if (customData.bookmarks.hasOwnProperty(index)) { return customData.bookmarks[index] ? { ...customData.bookmarks[index] } : null; } else { const original = index < originalBookmarks.length ? originalBookmarks[index] : null; return original ? { ...original } : null; } }); currentToggleRanges = originalToggleRanges.map(originalRange => { const customToggle = customData.toggles[originalRange.start]; const rangeCopy = { ...originalRange }; if (customToggle) { if (typeof customToggle.label === 'string') rangeCopy.label = customToggle.label; if (Array.isArray(customToggle.assignedIndexes)) rangeCopy.assignedIndexes = [...customToggle.assignedIndexes]; } if (!rangeCopy.assignedIndexes) rangeCopy.assignedIndexes = Array.from({ length: rangeCopy.end - originalRange.start + 1 }, (_, i) => originalRange.start + i); return rangeCopy; }); }
     
// ===================================================================
function loadReminders() { updateReminderCount(); }

// ===================================================================
// NOMBRE: actualizarContadorRadares
// RESUMEN: Actualiza el contador numérico de radares en la UI del mapa.
function actualizarContadorRadares(count) {
    const contadorElement = document.getElementById('radares-ruta-count');
    if (contadorElement) {
        contadorElement.textContent = count;
        const checkbox = document.getElementById('radares-ruta-checkbox');
        contadorElement.classList.toggle('hidden', count === 0 && (!checkbox || !checkbox.checked));
    }
}
// ===================================================================
// NOMBRE: actualizarContadorTareas
// RESUMEN: Actualiza el contador numérico de tareas en la UI del mapa.
function actualizarContadorTareas(count) {
    const contadorElement = document.getElementById('tareas-ruta-count');
    if (contadorElement) {
        contadorElement.textContent = count;
        const checkbox = document.getElementById('tareas-ruta-checkbox');
        contadorElement.classList.toggle('hidden', count === 0 && (!checkbox || !checkbox.checked));
    }
}    
// ===================================================================
// NOMBRE: applyZoom (VERSIÓN CON PROPORCIONALIDAD CORREGIDA)
// RESUMEN: Aplica el zoom. En modo 'on', usa un tamaño fijo de 190px por columna, que es proporcionalmente
function applyZoom(state) {
    const originalWidth = 984;
    const zoomedCols = 4;
    const originalCols = 6;
    const gap = 15;
    const zoomButton = document.getElementById('zoom-button');

    if (state === 'on') {
        const zoomedColumnWidth = 224; // Nuevo tamaño calculado para ser proporcionalmente más grande.
        grid.style.gridTemplateColumns = `repeat(${zoomedCols}, ${zoomedColumnWidth}px)`;
        grid.style.gap = `${gap}px`;
        grid.style.maxWidth = `${(zoomedCols * zoomedColumnWidth) + ((zoomedCols - 1) * gap)}px`; 
        
        document.querySelectorAll('.bookmark-item img').forEach(i => { i.style.width = '48px'; i.style.maxWidth = '52px'; });
        document.querySelectorAll('.bookmark-name').forEach(n => { n.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)'; });
        document.querySelectorAll('.small-bookmark img').forEach(i => { i.style.width = '48px'; i.style.maxWidth = '52px'; });
        document.querySelectorAll('.small-bookmark .bookmark-name').forEach(n => { n.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)'; });
        if (zoomButton) zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/zoon+.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`;
    } else {
        grid.style.gridTemplateColumns = `repeat(${originalCols}, minmax(120px, 1fr))`;
        grid.style.gap = `${gap}px`;
        grid.style.maxWidth = `${originalWidth}px`; 
        document.querySelectorAll('.bookmark-item img').forEach(i => { i.style.width = '36px'; i.style.maxWidth = '40px'; });
        document.querySelectorAll('.bookmark-name').forEach(n => { n.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)'; });
        document.querySelectorAll('.small-bookmark img').forEach(i => { i.style.width = '24px'; i.style.maxWidth = '28px'; });
        document.querySelectorAll('.small-bookmark .bookmark-name').forEach(n => { n.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)'; });
        if (zoomButton) zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`;
    }
}    
    
    // ===================================================================
    function getSectionForIndex(index) { return currentToggleRanges.find(range => range.assignedIndexes.includes(index)); } 
    
    // ===================================================================
    function getColorForSection(sectionStart, state = 'visible') { if (state === 'hidden') { return sectionColors.off; } if (isDarkMode) { return darkModeGenericButtonColor; } else { return sectionColors[sectionStart] || sectionColors.unassigned; } }
     
    // ===================================================================
    // NOMBRE: updateButtonStyles
    // RESUMEN: Actualiza los estilos visuales de todos los botones de la UI.
    function updateButtonStyles() {
        const darkModeToggleElem = document.getElementById('dark-mode-toggle');
        const onOffToggleElem = document.getElementById('on-off-toggle');
        const rangeToggleButtonsElems = document.querySelectorAll('.toggle-sign.range-toggle');
        const reminderButtonElem = document.getElementById('reminder-button');
        if (onOffToggleElem) {
            onOffToggleElem.src = `https://boardinggate.github.io/Tesla/${onOffToggleElem.dataset.state === 'on' ? 'PNG/IMG_4192.jpg' : 'PNG/IMG_4191.jpg'}`;
            onOffToggleElem.alt = `Toggle ${onOffToggleElem.dataset.state === 'on' ? 'On' : 'Off'}`;
            onOffToggleElem.style.backgroundColor = sectionColors.off;
            if (isDarkMode) {
                onOffToggleElem.style.filter = 'brightness(85%)';
                 if (onOffToggleElem.dataset.state === 'on') {
                    onOffToggleElem.style.backgroundColor = darkModeGenericButtonColor;
                 }
            } else {
                onOffToggleElem.style.filter = '';
            }
        }
        if (darkModeToggleElem) {
            darkModeToggleElem.src = `https://boardinggate.github.io/Tesla/PNG/${isDarkMode ? 'oscuro2.png' : 'claro2.png'}`;
            darkModeToggleElem.alt = `Toggle ${isDarkMode ? 'Oscuro' : 'Claro'}`;
            darkModeToggleElem.style.backgroundColor = sectionColors.off;
            if (isDarkMode) darkModeToggleElem.style.filter = 'brightness(85%)'; else darkModeToggleElem.style.filter = '';
        }
        let reminders = [];
        try {
            reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        } catch(e) {
            reminders = [];
        }
        const showExcludedInTable = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
        let remindersForButtonStyleCount = reminders;
        if (!showExcludedInTable) {
            remindersForButtonStyleCount = reminders.filter(r => !r.excludeFromList);
        }
        const totalPendingCount = remindersForButtonStyleCount.length;
        if (reminderButtonElem) {
            reminderButtonElem.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/IMG_4197.jpg" alt="Recordatorio" style="max-width: 70%; max-height: 70%; object-fit: contain;">${totalPendingCount > 0 ? `<span class="reminder-count">${totalPendingCount}</span>` : ''}`;
            reminderButtonElem.style.backgroundColor = sectionColors.off;
            if (isDarkMode) reminderButtonElem.style.filter = 'brightness(85%)'; else reminderButtonElem.style.filter = '';
        }
        rangeToggleButtonsElems.forEach(toggle => {
            const start = parseInt(toggle.dataset.rangeStart);
            const state = toggle.dataset.state || 'visible';
            const rangeConfig = currentToggleRanges.find(r => r.start === start);
            if (rangeConfig) {
                toggle.innerHTML = `<span class="sign">${state === 'visible' ? '-' : '+'}</span>${rangeConfig.label}`;
            }
            toggle.style.backgroundColor = getColorForSection(start, state);
            if (isDarkMode && state === 'visible') {
                toggle.style.filter = 'brightness(85%)';
            } else {
                toggle.style.filter = '';
            }
        });
        updatePasswordToggleIcon();
        const zoomButtonElem = document.getElementById('zoom-button');
        if (zoomButtonElem && zoomButtonElem.dataset.zoomState) {
            applyZoom(zoomButtonElem.dataset.zoomState);
        }
        if (cellElements && cellElements.length > 0) {
            cellElements.forEach((cell, index) => {
                const bookmarkItem = cell.querySelector('.bookmark-item');
                const emptySlot = cell.classList.contains('empty-slot');
                const section = getSectionForIndex(index);
                const color = sectionColors[section ? section.start : null] || sectionColors.unassigned;
                if (bookmarkItem) {
                    bookmarkItem.style.backgroundColor = color;
                } else if (emptySlot) {
                    cell.style.backgroundColor = color;
                }
            });
        }
    }
// ===================================================================
// NOMBRE: showWaypointActionModal 
// RESUMEN: Muestra un modal con el nuevo diseño oscuro para las acciones de una etapa de ruta, incluyendo el nuevo botón "Añadir a Favoritos".
function showWaypointActionModal(waypointId) {
    const wp = navigationWaypoints.find(w => w && w.id === waypointId);
    if (!wp) return;

    const existingOverlay = document.getElementById('route-modal-action-overlay');
    if(existingOverlay) existingOverlay.remove();
    
    const overlay = document.createElement('div');
    overlay.id = 'route-modal-action-overlay';
    overlay.className = 'route-modal-overlay';
    
    let distanceToWaypoint = 0, timeToWaypoint = 0, etaToWaypoint = "--:--";
    const currentActualWaypointsForModal = navigationWaypoints.filter(w => w && !w.isInternal && !w.isRecalculatedStart);
    const actualWaypointIndexInRoute = currentActualWaypointsForModal.findIndex(awp => awp.id === wp.id);
    if (navigationCurrentRouteData?.routes?.[0]) {
        const route = navigationCurrentRouteData.routes[0];
        if (actualWaypointIndexInRoute > 0) {
            for (let i = 0; i < actualWaypointIndexInRoute && i < route.legs.length; i++) {
                distanceToWaypoint += (route.legs[i].distance || 0);
                timeToWaypoint += (route.legs[i].duration || 0);
            }
        }
        if (timeToWaypoint > 0) etaToWaypoint = new Date(Date.now() + timeToWaypoint * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }
    const distanciaTexto = `${(distanceToWaypoint / 1000).toFixed(1)} km`;
    const waypointTotalMinutes = Math.round(timeToWaypoint / 60);
    const tiempoTexto = `${String(Math.floor(waypointTotalMinutes / 60)).padStart(2, '0')}:${String(waypointTotalMinutes % 60).padStart(2, '0')}`;
    
    const alternativesButtonHtml = (wp.type !== 'S' && wp.type !== 'S_Recalc') ? `<button id="modal-alternatives-btn" class="btn-modal-action-primary">Otras Rutas</button>` : '';
    const deleteButtonHtml = (wp.type !== 'S_Recalc') ? `<button id="modal-delete-btn" class="btn-modal-danger">Borrar Punto</button>` : '';
    const favoriteButtonHtml = `<button id="modal-favorite-btn" class="btn-modal-favorite">Añadir a Favoritos</button>`;
    
    overlay.innerHTML = `
        <div id="waypoint-action-modal" class="route-modal-container">
            <div class="route-modal-header">
                <div class="route-modal-title-card">
                    <span class="route-modal-title">Etapa ${wp.label}</span>
                </div>
            </div>
            <div class="route-modal-body">
                <p style="font-size: 1.1rem; color: #f0f0f0; margin-bottom: 15px;"><strong>Destino:</strong> ${wp.address}</p>
                <p><strong>Distancia:</strong> ${distanciaTexto}</p>
                <p><strong>Tiempo:</strong> ${tiempoTexto}</p>
                <p><strong>Llegada (ETA):</strong> ${etaToWaypoint}</p>
            </div>
            <div class="route-modal-footer" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <button id="modal-share-btn" class="btn-modal-action-primary">Compartir</button>
                ${alternativesButtonHtml}
                ${favoriteButtonHtml}
                ${deleteButtonHtml}
                <button id="modal-close-btn" class="btn-modal-action-secondary" style="grid-column: 1 / -1;">Cerrar <span class="button-countdown-timer unified-countdown-style"></span></button>
            </div>
        </div>
    `;

    document.body.appendChild(overlay);

    const closeHandler = () => {
        clearModalAutoCloseTimer(overlay, overlay.querySelector('#modal-close-btn'), 'waypoint-action-modal');
        if (overlay.parentNode) overlay.remove();
    };

    overlay.querySelector('#modal-close-btn').addEventListener('click', closeHandler);
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) closeHandler();
    });

    overlay.querySelector('#modal-share-btn').addEventListener('click', () => {
        handleSendToTeslaClick(wp.lat, wp.lng, wp.address);
        closeHandler();
    });

    overlay.querySelector('#modal-favorite-btn').addEventListener('click', () => {
        saveSingleWaypointAsFavorite(wp.id);
        closeHandler();
    });

    const alternativesBtn = overlay.querySelector('#modal-alternatives-btn');
    if (alternativesBtn) {
        alternativesBtn.addEventListener('click', () => {
            fetchAndDisplayAlternativeRoutes(wp.id);
            closeHandler();
        });
    }

    const deleteBtn = overlay.querySelector('#modal-delete-btn');
    if (deleteBtn) {
        deleteBtn.addEventListener('click', () => {
            handleDeleteWaypointClick(wp.id);
            closeHandler();
        });
    }

    addModalAutoCloseTimer(overlay, overlay.querySelector('#modal-close-btn'), 'waypoint-action-modal', 20000);
}

// ===================================================================
// NOMBRE: saveSingleWaypointAsFavorite 
// RESUMEN: Inicia el proceso de guardado para un único punto de ruta como favorito.
function saveSingleWaypointAsFavorite(waypointId) {
    const waypointToSave = navigationWaypoints.find(wp => wp && wp.id === waypointId);
    if (!waypointToSave) {
        showToast("Error: No se pudo encontrar la etapa para guardar.", "error");
        return;
    }
    showSaveRoutePromptForSingleWaypoint(waypointToSave);
}

// ===================================================================
// NOMBRE: saveCurrentRoute 
// RESUMEN: Inicia el proceso para guardar la ruta completa, llamando al modal reutilizable de guardado.
async function saveCurrentRoute() {
    const actualWaypointsToSave = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    
    if (actualWaypointsToSave.length < 2) {
        showToast("No hay ruta activa para guardar (se necesitan al menos 2 puntos)", "warning");
        return;
    }

    const isMultiStage = actualWaypointsToSave.length > 2;
    const lastWp = actualWaypointsToSave[actualWaypointsToSave.length - 1];
    const defaultRouteName = await getSuggestedRouteName(lastWp.lat, lastWp.lng, isMultiStage, actualWaypointsToSave.length);
    
    const onSaveCallback = (confirmedName) => {
        let waypointsToSave = sanitizeWaypointsForStorage(actualWaypointsToSave);
   
        const routeToSave = {
            name: confirmedName,
            waypoints: waypointsToSave,
            createdAt: new Date().toISOString()
        };

        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        const existingRouteIndex = savedRoutes.findIndex(r => r.name.toUpperCase() === confirmedName);
        if (existingRouteIndex !== -1) {
            if (!confirm(`Ya existe una ruta llamada "${confirmedName}". ¿Sobreescribir?`)) {
                showToast("Guardado cancelado", "info");
                return;
            }
            savedRoutes[existingRouteIndex] = routeToSave;
        } else {
            savedRoutes.push(routeToSave);
        }
        if (savedRoutes.length > MAX_SAVED_ROUTES) {
            savedRoutes.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
            savedRoutes = savedRoutes.slice(0, MAX_SAVED_ROUTES);
        }
        localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes));
        markCacheAsDirty();
        addRouteToRecents(routeToSave);
        showToast(`Ruta "${confirmedName}" guardada.`, "success");
    };

    showSaveRoutePromptModal(defaultRouteName, onSaveCallback);
}
    
// ===================================================================
// NOMBRE: showSaveRoutePromptModal 
// RESUMEN: Muestra un modal de guardado genérico con el nuevo diseño oscuro.
function showSaveRoutePromptModal(defaultName, onSaveCallback) {
    const existingOverlay = document.getElementById('route-modal-save-overlay');
    if (existingOverlay) existingOverlay.remove();

    const overlay = document.createElement('div');
    overlay.id = 'route-modal-save-overlay';
    overlay.className = 'route-modal-overlay';
    
    const modalContent = document.createElement('div');
    modalContent.id = 'save-route-prompt-modal';
    modalContent.className = 'route-modal-container';
    modalContent.innerHTML = `
        <div class="route-modal-header">
            <div class="route-modal-title-card">
                 <span class="route-modal-title">Guardar Favorito</span>
            </div>
        </div>
        <div class="route-modal-body">
            <label for="route-name-input" class="route-label">Nombre:</label>
            <div class="input-with-clear-button" style="position: relative;">
                <input type="text" id="route-name-input" value="${defaultName.toUpperCase()}" class="route-filter-input" style="padding-right: 40px;">
                <button class="clear-input-btn" title="Limpiar nombre" style="position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: transparent; border: none; font-size: 1.8rem; color: #aaa; cursor: pointer; display: none;">×</button>
            </div>
            <p style="font-size: 0.8rem; color: #8e8e93; margin-top: 10px;">
                (*) Las rutas se guardan y recuperan con el trayecto MÁS RÁPIDO.
            </p>
        </div>
        <div class="route-modal-footer">
            <button id="confirm-save-route" class="btn-modal-save">Guardar <span class="button-countdown-timer unified-countdown-style"></span></button>
            <button id="cancel-save-route" class="btn-modal-cancel">Cancelar</button>
        </div>
    `;
    
    overlay.appendChild(modalContent);
    document.body.appendChild(overlay);

    const nameInput = modalContent.querySelector('#route-name-input');
    const confirmButton = modalContent.querySelector('#confirm-save-route');
    const cancelButton = modalContent.querySelector('#cancel-save-route');
    const clearBtn = modalContent.querySelector('.clear-input-btn');
    
    const toggleClearButton = () => { clearBtn.style.display = nameInput.value.trim().length > 0 ? 'block' : 'none'; };
    nameInput.addEventListener('input', toggleClearButton);
    clearBtn.addEventListener('click', () => { nameInput.value = ''; toggleClearButton(); nameInput.focus(); });
    toggleClearButton();

    nameInput.focus();
    const textLength = nameInput.value.length;
    nameInput.setSelectionRange(textLength, textLength);

    const closePrompt = () => {
        clearModalAutoCloseTimer(overlay, confirmButton, 'save-route-prompt-modal');
        if (overlay.parentNode) overlay.remove();
    };

    const saveAction = () => {
        let routeName = nameInput.value.trim().toUpperCase();
        if (!routeName) {
            showToast("El nombre no puede estar vacío", "warning");
            addModalAutoCloseTimer(overlay, confirmButton, 'save-route-prompt-modal', 15000);
            return;
        }
        onSaveCallback(routeName);
        closePrompt();
    };

    confirmButton.addEventListener('click', saveAction);
    cancelButton.addEventListener('click', closePrompt);
    addModalAutoCloseTimer(overlay, confirmButton, 'save-route-prompt-modal', 20000);
}    
    
    // ===================================================================
    function formatVersionDate(date) { const y = date.getUTCFullYear().toString().slice(-2); const m = String(date.getUTCMonth() + 1).padStart(2, '0'); const d = String(date.getUTCDate()).padStart(2, '0'); const h = String(date.getUTCHours()).padStart(2, '0'); return `${y}.${m}.${d}${h}`; }
    
    // ===================================================================
    // NOMBRE: getLastModifiedDate
    // RESUMEN: Obtiene la fecha de la última modificación desde un archivo remoto, con caché local.
    async function getLastModifiedDate() {
        const k = 'teslaHtmlLastModified';
        const tk = 'teslaHtmlLastModifiedTimestamp';
        const dur = 86400000;
        const cd = localStorage.getItem(k);
        const ct = localStorage.getItem(tk);
        const now = Date.now();
        if (cd && ct && (now - parseInt(ct)) < dur) {
            return new Date(cd);
        }
        try {
            const r = await fetch('https://boardinggate.github.io/Tesla/version.txt', { cache: 'no-cache' });
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const txt = await r.text();
            const lmd = new Date(txt.trim());
            if (isNaN(lmd.getTime())) throw new Error('Invalid date format');
            localStorage.setItem(k, lmd.toISOString());
            localStorage.setItem(tk, now.toString());
            return lmd;
        } catch (e) {
            if (cd) return new Date(cd);
            return new Date('2024-01-01T00:00:00Z');
        }
    }
    
    
    // ===================================================================
    async function updateVersion() { try { const lmd = await getLastModifiedDate(); const v = formatVersionDate(lmd); const el = document.getElementById('version'); if (el) el.textContent = `versión: ${v}`; } catch (e) { const el = document.getElementById('version'); if (el) el.textContent = 'versión: error'; } }
    
    // ===================================================================
    const getFaviconUrl = (bookmarkData) => { try { const urlToParse = bookmarkData?.url || ''; const customFavicon = bookmarkData?.favicon; if (customFavicon && (customFavicon.startsWith('data:image') || customFavicon.startsWith('http') || customFavicon.startsWith('./'))) return customFavicon; if (urlToParse) { const domain = new URL(urlToParse).hostname; return `https://www.google.com/s2/favicons?domain=${domain}&sz=64`; } } catch (e) { } return 'https://via.placeholder.com/64'; };
    
    // ===================================================================
    // NOMBRE: renderGrid
    // RESUMEN: Dibuja o redibuja el grid completo de marcadores.
    function renderGrid() { grid.innerHTML = ''; cellElements = []; Array.from({ length: TOTAL_CELLS }).forEach((_, index) => { const cellContainer = document.createElement('div'); cellContainer.classList.add('grid-cell'); cellContainer.dataset.index = index; const bookmarkData = currentBookmarks[index]; const section = getSectionForIndex(index); const bgColor = sectionColors[section ? section.start : null] || sectionColors.unassigned; if (bookmarkData) { const link = document.createElement('a'); link.className = 'bookmark-item'; link.title = bookmarkData.name; link.style.backgroundColor = bgColor; link.href = bookmarkData.url || "#"; link.dataset.index = index;
        if (isKeywordAssignmentMode || (bookmarkData.name && bookmarkData.name === "Inicio Tesla") || !bookmarkData.url || bookmarkData.url === '#') { } else { link.target = "_blank"; link.rel = "noopener noreferrer"; }
        const img = document.createElement('img'); img.src = getFaviconUrl(bookmarkData); img.alt = `Favicon ${bookmarkData.name}`; img.loading = "lazy"; img.onerror = function() { this.src = 'https://via.placeholder.com/64'; this.onerror = null; }; if (bookmarkData.name === "Mis Updates") img.classList.add('favicon-red'); else if (bookmarkData.name === "Olas Updates") img.classList.add('favicon-blue'); const nameSpan = document.createElement('span'); nameSpan.className = 'bookmark-name'; nameSpan.textContent = bookmarkData.name; link.appendChild(img); link.appendChild(nameSpan); cellContainer.appendChild(link); } else { cellContainer.classList.add('empty-slot'); const addIcon = document.createElement('span'); addIcon.textContent = '+'; cellContainer.appendChild(addIcon); cellContainer.style.backgroundColor = bgColor; }
        cellContainer.addEventListener('click', handleGridCellClick);
        if (isEditMode) {
             cellContainer.draggable = true;
             cellContainer.addEventListener('dragstart', handleDragStart); cellContainer.addEventListener('dragover', handleDragOver);
             cellContainer.addEventListener('dragleave', handleDragLeave);
             cellContainer.addEventListener('drop', handleDrop);
             cellContainer.addEventListener('dragend', handleDragEnd);
             cellContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
             cellContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
             cellContainer.addEventListener('touchend', handleTouchEnd);
             cellContainer.addEventListener('touchcancel', handleTouchCancel);
             cellContainer.classList.add('editable');
        } else {
             cellContainer.draggable = false;
             cellContainer.removeEventListener('dragstart', handleDragStart);
             cellContainer.removeEventListener('dragover', handleDragOver);
             cellContainer.removeEventListener('dragleave', handleDragLeave);
             cellContainer.removeEventListener('drop', handleDrop);
             cellContainer.removeEventListener('dragend', handleDragEnd);
             cellContainer.removeEventListener('touchstart', handleTouchStart);
             cellContainer.removeEventListener('touchmove', handleTouchMove);
             cellContainer.removeEventListener('touchend', handleTouchEnd);
             cellContainer.removeEventListener('touchcancel', handleTouchCancel);
             cellContainer.classList.remove('editable');
        }
        grid.appendChild(cellContainer); cellElements.push(cellContainer); }); }
    
    
    // ===================================================================
    // NOMBRE: renderToggleButtons
    // RESUMEN: Dibuja los botones laterales para ocultar/mostrar secciones del grid.
    function renderToggleButtons() {
        document.querySelectorAll('.range-toggle').forEach(btn => btn.remove());
        toggleButtonElements = {};
        const toggleStatesFromCache = JSON.parse(localStorage.getItem('toggleStates') || '{}');
        currentToggleRanges.forEach((range) => {
            const toggle = document.createElement('span');
            toggle.className = 'toggle-sign range-toggle';
            toggle.dataset.rangeStart = range.start;
            toggle.dataset.rangeEnd = range.end;
            toggle.style.position = 'fixed';
            toggle.style.top = '100px';
            toggle.style.left = '10px';
            const initialState = toggleStatesFromCache[range.start] || 'visible';
            toggle.dataset.state = initialState;
            toggle.addEventListener('click', handleToggleClick);
            document.body.appendChild(toggle);
            toggleButtonElements[range.start] = toggle;
        });
    }
  // ===================================================================
// NOMBRE: createOtherButtons
// RESUMEN: Crea y añade a la UI los botones de acción fijos.
function createOtherButtons() {
    if (!document.getElementById('on-off-toggle')) {
        onOffToggle = document.createElement('img');
        onOffToggle.className = 'toggle-image';
        onOffToggle.id = 'on-off-toggle';
        const savedOnOffState = localStorage.getItem('onOffState');
        onOffToggle.dataset.state = savedOnOffState ? savedOnOffState : 'on';
        document.body.appendChild(onOffToggle);
        onOffToggle.addEventListener('mousedown', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) pressStartTime = Date.now(); });
        onOffToggle.addEventListener('mouseup', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) handleOnOffAction(); });
        onOffToggle.addEventListener('mouseleave', () => { pressStartTime = null; });
        onOffToggle.addEventListener('touchstart', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); pressStartTime = Date.now(); } });
        onOffToggle.addEventListener('touchend', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); handleOnOffAction(); } });
    }
    if (!document.getElementById('weather-button')) { weatherButton = document.createElement('span'); weatherButton.className = 'toggle-sign'; weatherButton.id = 'weather-button'; weatherButton.innerHTML = `<img src="https://www.google.com/s2/favicons?domain=accuweather.com&sz=64" alt="Tiempo" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; document.body.appendChild(weatherButton); weatherButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; window.open('https://www.ventusky.com/?p=40.2;-4.7;5&l=rain-3h', '_blank'); }); }
    if (!document.getElementById('reminder-button')) { reminderButton = document.createElement('span'); reminderButton.className = 'toggle-sign'; reminderButton.id = 'reminder-button'; document.body.appendChild(reminderButton); reminderButton.addEventListener('mousedown', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) reminderPressStartTime = Date.now(); }); reminderButton.addEventListener('mouseup', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) handleReminderLongPress(); }); reminderButton.addEventListener('mouseleave', () => { reminderPressStartTime = null; }); reminderButton.addEventListener('touchstart', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); reminderPressStartTime = Date.now(); } }); reminderButton.addEventListener('touchend', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); handleReminderLongPress(); } }); }
    if (!document.getElementById('zoom-button')) { zoomButton = document.createElement('span'); zoomButton.className = 'toggle-sign'; zoomButton.id = 'zoom-button'; zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; zoomButton.dataset.zoomState = localStorage.getItem('zoomState') || 'off'; document.body.appendChild(zoomButton); zoomButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const cS = zoomButton.dataset.zoomState; const nS = cS === 'off' ? 'on' : 'off'; applyZoom(nS); zoomButton.dataset.zoomState = nS; updateButtonStyles(); saveSettings(); adjustButtonPositions(); }); }
    if (!document.getElementById('dark-mode-toggle')) { darkModeToggle = document.createElement('img'); darkModeToggle.className = 'toggle-image'; darkModeToggle.id = 'dark-mode-toggle'; document.body.appendChild(darkModeToggle); darkModeToggle.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; isDarkMode = !isDarkMode; document.body.classList.toggle('dark-mode', isDarkMode); updateButtonStyles(); saveSettings(); }); }
    if (!document.getElementById('config-button')) {
        const configButton = document.createElement('span');
        configButton.id = 'config-button';
        configButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/config.jpg" alt="Configuración">`;
        document.body.appendChild(configButton);
        configButton.addEventListener('click', () => {
            if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) {
                const mapIsCurrentlyOpen = isNavigationMapActive;
                const currentMapContext = sessionStorage.getItem('mapContext');
                if (mapIsCurrentlyOpen && currentMapContext) {
                    sessionStorage.setItem('boardinggate_map_should_reopen_after_config', 'true');
                    sessionStorage.setItem('mapContextToReopenAfterConfig', currentMapContext);
                    closeNavigationMap(true);
                }
                showConfigModal();
            }
        });
    }
    if (!document.getElementById('personal-button')) {
        const personalButton = document.createElement('span');
        personalButton.id = 'personal-button';
        personalButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="Personal">`;
        document.body.appendChild(personalButton);
        personalButton.addEventListener('click', handlePersonalizationClick);
    }
    if (!document.getElementById('radar-button')) {
        radarButton = document.createElement('span');
        radarButton.id = 'radar-button';
        radarButton.innerHTML = `<img src="PNG/AVANCE.PNG" alt="Radar/Ubicaciones/Navegación">`;
        document.body.appendChild(radarButton);
        radarButton.addEventListener('click', () => {
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;

            const userId = localStorage.getItem('userData_userId');
            const allowDMs = JSON.parse(localStorage.getItem('userData_allowDMs') || 'false');

            if (userId && userId.trim() !== '' && allowDMs) {
                openNavigationMap();
            } else {
                const message = "PARA ACCEDER A MAPAS, ES IMPRESCINDIBLE QUE CREE EN CONFIGURACIÓN UN NOMBRE DE USUARIO ÚNICO (y debe estar activado Permitir MDs también)...";
                const duration = 10000; 

                showToast(message, 'error', duration);

                setTimeout(() => {
                    showConfigModal();
                }, duration);
            }
             });
    }
    if (!document.getElementById('home-button')) {
        const homeButton = document.createElement('span');
        homeButton.id = 'home-button';
        homeButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/home.webp" alt="Inicio">`;
        document.body.appendChild(homeButton);
        homeButton.addEventListener('click', (e) => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) { e.preventDefault(); return; } window.history.back(); });
    }
    if (!document.getElementById('reload-button')) {
        const reloadButton = document.createElement('span');
        reloadButton.id = 'reload-button';
        reloadButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/reload.webp" alt="Recargar">`;
        document.body.appendChild(reloadButton);
        reloadButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; location.reload(); });
    }
    if (!document.getElementById('keyword-assignment-button')) {
         const keywordButton = document.createElement('span');
         keywordButton.id = 'keyword-assignment-button';
         keywordButton.title = "Asignar/Quitar palabra clave filtro";
         keywordButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/IMG_4314.PNG" alt="Asignar Keyword">`;
         document.body.appendChild(keywordButton);
         keywordButton.addEventListener('click', () => { toggleKeywordAssignmentMode(!isKeywordAssignmentMode); });
    }
    if (!document.getElementById('password-toggle-button')) {
        const passwordButton = document.createElement('span');
        passwordButton.id = 'password-toggle-button';
        passwordButton.innerHTML = `<img src="" alt="Clave">`;
        document.body.appendChild(passwordButton);
        passwordButton.addEventListener('click', handlePasswordToggleClick);
    }
    if (!document.getElementById('versions-button')) {
         versionsButton = document.createElement('span');
         versionsButton.id = 'versions-button';
         versionsButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/IMG_4309.PNG" alt="Versiones">`;
         document.body.appendChild(versionsButton);
         versionsButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; showVersionsModal(); });
    }
    if (!document.getElementById('info-button')) {
         infoButton = document.createElement('span');
         infoButton.id = 'info-button';
         infoButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/IMG_4326.PNG" alt="Info">`;
         document.body.appendChild(infoButton);
         infoButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; window.open('https://boardinggate.github.io/Tesla/manual.html', '_blank'); });
    }
}  
    
    // ===================================================================
    // NOMBRE: handleGridCellClick
    // RESUMEN: Gestiona los clics en las celdas del grid, según el modo activo.
    function handleGridCellClick(event) {
        const cellContainer = event.currentTarget; const index = parseInt(cellContainer.dataset.index);
        if (isEditMode) { const link = cellContainer.querySelector('a.bookmark-item'); if (link) event.preventDefault(); showEditModal(index, false); }
        else if (isAssignmentMode) { event.preventDefault(); handleGridCellClickForAssignment(index); }
        else if (isKeywordAssignmentMode) { event.preventDefault(); handleKeywordAssignmentClick(index); }
        else { const link = cellContainer.querySelector('a.bookmark-item'); const bookmarkData = currentBookmarks[index];
            if (!link || !link.href || link.href === '#') {
                event.preventDefault();
                if (bookmarkData && bookmarkData.url && bookmarkData.url.startsWith("map-action:")) {
                    const action = bookmarkData.url.split(":")[1];
                    if (action === "openRemindersMapWithNoRadars") {
                        openLocationsPreviewMap();
                    } else if (action === "openRemindersMap") {
                        openNavigationMap();
                    }
                }
            } else {
                if (!link.target && bookmarkData && bookmarkData.name !== "Inicio Tesla") {
                    link.target = "_blank"; link.rel = "noopener noreferrer";
                }
            }
        }
    }
    
    // ===================================================================
    function handleToggleClick(event) { const toggle = event.currentTarget; if (isEditMode) { event.preventDefault(); const start = parseInt(toggle.dataset.rangeStart); showEditModal(start, true); } else if (isAssignmentMode) { event.preventDefault(); handleToggleClickForAssignment(toggle); } else if (isKeywordAssignmentMode) { event.preventDefault(); } else { updateToggleState(toggle); } }
    
    
    // ===================================================================
    function updateToggleState(toggle) { if (!toggle || isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const start = parseInt(toggle.dataset.rangeStart); if (isNaN(start)) return; const rangeConfig = currentToggleRanges.find(r => r.start === start); if (!rangeConfig) return; const currentState = toggle.dataset.state; const newState = currentState === 'visible' ? 'hidden' : 'visible'; toggle.dataset.state = newState; const savedStates = JSON.parse(localStorage.getItem('toggleStates') || '{}'); savedStates[start] = newState; localStorage.setItem('toggleStates', JSON.stringify(savedStates)); updateButtonStyles(); filterGridItems(); } 
    
    
    // ===================================================================
    function updateAllToggles(newState) { const onOffToggleElem = document.getElementById('on-off-toggle'); if (!onOffToggleElem) return; onOffToggleElem.dataset.state = newState; localStorage.setItem('onOffState', newState); updateButtonStyles(); filterGridItems(); saveSettings(); }
    const scrollToggle = document.getElementById('scroll-toggle'); if (scrollToggle) scrollToggle.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const sP = window.scrollY; const mS = document.body.scrollHeight - window.innerHeight; window.scrollTo({ top: sP < 100 ? mS : 0, behavior: 'smooth' }); });
    
    // ===================================================================
    function handleOnOffAction() { if (pressStartTime !== null) { const t = document.getElementById('on-off-toggle'); if (t) { const nS = t.dataset.state === 'on' ? 'off' : 'on'; updateAllToggles(nS); } } pressStartTime = null; } 
    
    // ===================================================================
    function handleReminderLongPress() { if (reminderPressStartTime === null) return; const dur = Date.now() - reminderPressStartTime; if (dur >= 2000) showAllReminders(); else showReminderModal(); reminderPressStartTime = null; }
    
    // ===================================================================
    // NOMBRE: handlePersonalizationClick
    // RESUMEN: Gestiona el clic en el botón de personalización, mostrando el menú de opciones.
    function handlePersonalizationClick() {
        const personalButton = document.getElementById('personal-button'); const wasEditing = isEditMode; const wasAssigning = isAssignmentMode; const wasKeywordAssigning = isKeywordAssignmentMode;
        if (wasKeywordAssigning) { toggleKeywordAssignmentMode(false); }
        if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
        if (wasEditing) { toggleEditMode(false); } else if (wasAssigning) { toggleAssignmentMode(false); } else if (!wasKeywordAssigning) { showPersonalizationChoice(); }
    }
    
    // ===================================================================
    // NOMBRE: showPersonalizationChoice
    // RESUMEN: Muestra el modal para elegir el tipo de personalización.
    function showPersonalizationChoice() {
        const existingModal = document.querySelector('.choice-modal'); if (existingModal) existingModal.remove();
        const modal = document.createElement('div'); modal.className = 'choice-modal'; modal.setAttribute('aria-label', 'Elegir tipo de personalización');
        modal.innerHTML = `
            <h2>¿Qué quieres personalizar?</h2>
            <div class="modal-top-buttons">
                <button class="choice-cancel">Cancelar</button>
            </div>
            <p class="mb-6">Elige una opción:</p>
            <div class="personalization-options">
                <button class="choice-edit">URLs / Etiquetas / Reordenar</button>
                <button class="choice-assign">Asignar Botones Ocultación</button>
                <button class="choice-help">Ver Ayuda</button>
            </div>
        `;
        modal.querySelector('.choice-edit').addEventListener('click', () => { modal.remove(); toggleEditMode(true); });
        modal.querySelector('.choice-assign').addEventListener('click', () => { modal.remove(); toggleAssignmentMode(true); });
        modal.querySelector('.choice-help').addEventListener('click', () => { modal.remove(); showEditInfoModal(); });
        modal.querySelector('.choice-cancel').addEventListener('click', () => { modal.remove(); });
        document.body.appendChild(modal);
        addModalAutoCloseTimer(modal, modal.querySelector('.choice-cancel'), 'choice-modal', 30000);
    }
    
    
    // ===================================================================
    // NOMBRE: toggleEditMode
    // RESUMEN: Activa o desactiva el modo de edición (URLs, etiquetas, arrastrar).
    function toggleEditMode(activate) {
        const personalButton = document.getElementById('personal-button'); isEditMode = activate; personalButton.classList.toggle('editing', isEditMode); document.body.classList.toggle('editing-active', isEditMode);
        if (isEditMode) {
            if (isAssignmentMode) toggleAssignmentMode(false); if (isKeywordAssignmentMode) toggleKeywordAssignmentMode(false);
            if (firstPersonalizationSession) { showEditInfoModal(); firstPersonalizationSession = false; sessionStorage.setItem('personalizationHelpShown', 'true'); }
            markCacheAsDirty(); 
            showToast("Modo Edición (URLs/Etiquetas/Arrastrar) Activado", "info", 4000);
        } else {
            showToast("Modo Edición Desactivado", "info", 2000);
            cellElements.forEach(cell => cell.classList.remove('dragging', 'drag-over')); draggedItem = null; draggedItemIndex = null; currentTouchTarget = null; dragOverIndex = null;
            if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
        } renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles(); adjustButtonPositions();
        document.querySelectorAll('.range-toggle').forEach(el => { el.classList.toggle('editable', isEditMode); }); filterGridItems();
    }
     
    // ===================================================================
    // NOMBRE: toggleAssignmentMode
    // RESUMEN: Activa o desactiva el modo de asignación de botones a secciones.
    function toggleAssignmentMode(activate) {
        const personalButton = document.getElementById('personal-button'); isAssignmentMode = activate; personalButton.classList.toggle('assigning', isAssignmentMode); document.body.classList.toggle('assignment-active', isAssignmentMode);
        if (isAssignmentMode) {
            if (isEditMode) toggleEditMode(false); if (isKeywordAssignmentMode) toggleKeywordAssignmentMode(false);
            if (firstPersonalizationSession) { showEditInfoModal(); firstPersonalizationSession = false; sessionStorage.setItem('personalizationHelpShown', 'true'); }
            showToast("Modo Asignación Botones Activado", "info", 4000);
            const firstToggle = document.querySelector('.range-toggle');
            toggleEditMode(activate)
            if (firstToggle) { handleToggleClickForAssignment(firstToggle); } else { currentlyAssigningToggleStart = null; updateGridAssignmentVisuals(); }
        } else {
            showToast("Modo Asignación Botones Desactivado", "info", 2000); saveCustomData();
            document.querySelectorAll('.range-toggle.assigning-selected').forEach(t => t.classList.remove('assigning-selected'));
            document.querySelectorAll('.grid-cell.assigned-to-current').forEach(c => { c.classList.remove('assigned-to-current'); c.style.opacity = ''; c.style.outline=''; c.style.boxShadow=''; c.style.backgroundColor = ''; });
            document.querySelectorAll('.range-toggle').forEach(t => t.style.opacity = '');
            currentlyAssigningToggleStart = null;
        } renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles(); adjustButtonPositions(); filterGridItems(); 
    }
    
    
    // ===================================================================
    // NOMBRE: toggleKeywordAssignmentMode
    // RESUMEN: Activa o desactiva el modo de asignación de palabras clave a los nombres de los marcadores.
    function toggleKeywordAssignmentMode(activate) {
         const keywordButton = document.getElementById('keyword-assignment-button'); const filterInput = document.getElementById('grid-filter-input'); isKeywordAssignmentMode = activate;
         if (keywordButton) { keywordButton.classList.toggle('active', isKeywordAssignmentMode); }
        document.body.classList.toggle('keyword-assignment-active', isKeywordAssignmentMode);
         if (isKeywordAssignmentMode) {
              if (isEditMode) toggleEditMode(false); if (isAssignmentMode) toggleAssignmentMode(false);
              const toastMessage = "Modo activo: Escribe palabra(s) en el campo filtro grid (separadas por espacio si son varias). Pulsa ICONO FILTRO para añadir/quitar esa(s) palabra(s) al nombre del botón(es) que vaya seleccionando. Pulsa el icono para salir de este modo.";
              showToast(toastMessage, "info", 15000); filterGridItems(); applyInitialKeywordHighlights();
         } else {
              showToast("Modo Asignación de Palabras Clave Desactivado", "info", 2000); cellElements.forEach(cell => cell.classList.remove('keyword-assigned-highlight')); filterGridItems();
         }
    }
    
    // ===================================================================
    function applyInitialKeywordHighlights() { const filterInput = document.getElementById('grid-filter-input'); const keyword = filterInput.value.trim().replace(/\s+/g, '').toUpperCase(); if (!keyword) return; const keywordTag = `[${keyword}]`; cellElements.forEach((cell, index) => { const bookmark = currentBookmarks[index]; if (bookmark && bookmark.name && bookmark.name.includes(keywordTag)) { cell.classList.add('keyword-assigned-highlight'); } else { cell.classList.remove('keyword-assigned-highlight'); } }); }
    
    // ===================================================================
    function handleToggleClickForAssignment(toggleElement) { const start = parseInt(toggleElement.dataset.rangeStart); if (isNaN(start)) return; currentlyAssigningToggleStart = start; document.querySelectorAll('.range-toggle').forEach(t => { t.classList.toggle('assigning-selected', t === toggleElement); t.style.opacity = t === toggleElement ? '' : '0.7'; }); updateGridAssignmentVisuals(); showToast(`Asignando botones para: ${toggleElement.textContent.substring(1)}`, "info", 2500); } 

    
    // ===================================================================
    // NOMBRE: handleKeywordAssignmentClick
    // RESUMEN: Añade o quita la palabra clave del filtro al nombre de un marcador.
    function handleKeywordAssignmentClick(index) {
        const filterInput = document.getElementById('grid-filter-input'); const keyword = filterInput.value.trim().replace(/\s+/g, '').toUpperCase();
        if (!keyword) { showToast("Escribe una palabra en el campo filtro primero.", "warning"); return; }
        const bookmark = currentBookmarks[index]; const cellElement = cellElements[index];
        if (!bookmark || !cellElement) { showToast(`No hay un marcador en la posición ${index + 1}.`, "warning"); return; }
        const keywordTag = `[${keyword}]`; const currentName = bookmark.name || ""; const nameSpan = cellElement.querySelector('.bookmark-name');
        let newName = currentName; let actionTaken = '';
        if (currentName.includes(keywordTag)) { newName = currentName.replace(keywordTag, '').replace(/\s{2,}/g, ' ').trim(); cellElement.classList.remove('keyword-assigned-highlight'); actionTaken = 'removed'; }
        else { newName = currentName.trim(); const lastBracketIndex = newName.lastIndexOf(']'); const endsWithBracket = lastBracketIndex !== -1 && lastBracketIndex === newName.length - 1;
            if (endsWithBracket) { newName += '  ' + keywordTag; } else { newName += '          ' + keywordTag; } cellElement.classList.add('keyword-assigned-highlight'); actionTaken = 'added'; }
        bookmark.name = newName; currentBookmarks[index] = { ...bookmark }; if (!customData.bookmarks) customData.bookmarks = {}; customData.bookmarks[index] = { ...bookmark }; saveCustomData();
        if (nameSpan) { nameSpan.textContent = newName; }
        if (actionTaken === 'added') { showToast(`"${keyword}" añadido. Nombre: ${newName}`, "success", 2500); } else if (actionTaken === 'removed') { showToast(`"${keyword}" quitado. Nombre: ${newName}`, "info", 2500); }
    }
        
    
    // ===================================================================
    // NOMBRE: handleGridCellClickForAssignment
    // RESUMEN: Asigna o desasigna un marcador a la sección actualmente seleccionada.
    function handleGridCellClickForAssignment(cellIndex) {
        if (currentlyAssigningToggleStart === null) { showToast("Selecciona primero un botón lateral (PdR,s, iAs, etc.)", "warning"); return; }
        const startKey = currentlyAssigningToggleStart.toString(); if (!customData.toggles[startKey]) { const currentRange = currentToggleRanges.find(r => r.start == startKey); customData.toggles[startKey] = { label: currentRange ? currentRange.label : `Rango ${startKey}`, assignedIndexes: currentRange ? [...currentRange.assignedIndexes] : [] }; }
        else if (!customData.toggles[startKey].assignedIndexes) { const currentRange = currentToggleRanges.find(r => r.start == startKey); customData.toggles[startKey].assignedIndexes = currentRange ? [...currentRange.assignedIndexes] : []; }
        const assigned = customData.toggles[startKey].assignedIndexes; const indexInArray = assigned.indexOf(cellIndex);
        if (indexInArray > -1) { assigned.splice(indexInArray, 1); } else { assigned.push(cellIndex); assigned.sort((a, b) => a - b); }
        const currentRangeIndex = currentToggleRanges.findIndex(r => r.start == startKey); if (currentRangeIndex > -1) { currentToggleRanges[currentRangeIndex].assignedIndexes = [...assigned]; }
        updateGridAssignmentVisuals(); saveCustomData(); showToast('Asignación guardada', 'success', 500);
    }
    
    // ===================================================================
    // NOMBRE: updateGridAssignmentVisuals
    // RESUMEN: Actualiza la apariencia visual del grid durante el modo de asignación.
    function updateGridAssignmentVisuals() { if (!isAssignmentMode || currentlyAssigningToggleStart === null) { cellElements.forEach(cell => { cell.classList.remove('assigned-to-current'); cell.style.opacity = ''; cell.style.outline = ''; cell.style.boxShadow = ''; }); return; } const startKey = currentlyAssigningToggleStart.toString(); let assignedIndexesForCurrentToggle = []; if (customData.toggles[startKey] && customData.toggles[startKey].assignedIndexes) { assignedIndexesForCurrentToggle = customData.toggles[startKey].assignedIndexes; } else { const currentRange = currentToggleRanges.find(r => r.start == startKey); if (currentRange?.assignedIndexes) { assignedIndexesForCurrentToggle = currentRange.assignedIndexes; } } cellElements.forEach((cell, index) => { const isAssigned = assignedIndexesForCurrentToggle.includes(index); cell.classList.toggle('assigned-to-current', isAssigned); if (isAssigned) { cell.style.opacity = ''; cell.style.outline = '3px solid cyan'; cell.style.boxShadow = document.body.classList.contains('dark-mode') ? 'inset 0 0 10px rgba(0, 200, 200, 0.7)' : 'inset 0 0 8px rgba(0, 255, 255, 0.6)'; } else { cell.style.opacity = document.body.classList.contains('dark-mode') ? '0.5' : '0.6'; cell.style.outline = `1px dashed ${document.body.classList.contains('dark-mode') ? '#555' : '#aaa'}`; cell.style.boxShadow = ''; } }); } 
    
    
    // ===================================================================
    // NOMBRE: showEditInfoModal
    // RESUMEN: Muestra el modal con la ayuda sobre los modos de personalización.
    function showEditInfoModal() {
        const existingModal = document.querySelector('.edit-info-modal'); if (existingModal) existingModal.remove();
        const modal = document.createElement('div'); modal.className = 'edit-info-modal'; modal.setAttribute('aria-label', 'Ayuda Personalización');
        modal.innerHTML = `
            <h2 class="text-xl font-bold mb-4">Ayuda de Personalización</h2>
            <div class="modal-top-buttons" style="justify-content: flex-end;">
                <button type="button" id="close-edit-info" class="px-6 py-2" style="flex: 0 1 auto; min-width: 120px;">Entendido</button>
            </div>
            <p class="mb-3">Al pulsar el botón <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (personalizar) o el icono <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4314.PNG" alt="Key" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (llave) puedes elegir entre varios modos:</p>
            <div class="mb-4 p-3 bg-yellow-100 border border-yellow-300 rounded">
                 <h3 class="font-semibold text-lg mb-2">1. Editar URLs / Etiquetas / Reordenar (Botón Personalizar Amarillo)</h3>
                 <ul class="list-disc pl-5 space-y-1 text-sm">
                    <li><strong>Activar:</strong> Elige "URLs / Etiquetas / Reordenar" en el menú inicial. El botón <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> se pondrá amarillo.</li>
                    <li><strong>Editar Marcador/Botón Lateral:</strong> Haz clic en un marcador del grid o en un botón lateral (PdR,s, iAs, etc.). Se abrirá una ventana para editar su nombre, URL (si es marcador) o etiqueta (si es botón lateral). <strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                    <li><strong>Arrastrar y Soltar:</strong> Mantén pulsado un marcador del grid y arrástralo a otra posición (incluso vacía) para reordenarlos.</li>
                    <li><strong>Guardar Cambios:</strong> Los cambios en nombre/URL/etiqueta se guardan al pulsar "Guardar" en la ventana de edición. El reordenamiento se guarda automáticamente al soltar.</li>
                    <li><strong>Vaciar Casilla:</strong> En la ventana de edición de un marcador, pulsa "Vaciar" para eliminarlo.</li>
                    <li><strong>Resetear:</strong> En la ventana de edición, pulsa "Resetear" para volver a los valores originales (si los tenía).</li>
                 </ul>
            </div>
            <div class="mb-4 p-3 bg-cyan-100 border border-cyan-300 rounded">
                <h3 class="font-semibold text-lg mb-2">2. Asignar Botones Ocultación (Botón Personalizar Cian)</h3>
                <ul class="list-disc pl-5 space-y-1 text-sm">
                    <li><strong>Activar:</strong> Elige "Asignar Botones Ocultación" en el menú inicial. El botón <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> se pondrá cian.</li>
                    <li><strong>Seleccionar Botón Lateral:</strong> Haz clic en el botón lateral (PdR,s, iAs, etc.) cuyos marcadores quieres definir. Se resaltará.</li>
                    <li><strong>Asignar/Desasignar Marcadores:</strong> Haz clic en cualquier marcador de la rejilla. Si estaba asignado, se desasignará (atenuado). Si no lo estaba, se asignará (resaltado). <strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                    <li><strong>Cambiar Botón Lateral:</strong> Haz clic en otro botón lateral para asignar sus marcadores.</li>
                    <li><strong>Guardar:</strong> Los cambios se guardan automáticamente al salir de este modo (pulsando el botón <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> cian).</li>
                    <li><strong>Visibilidad por defecto:</strong> Marcadores no asignados a <i>ningún</i> botón lateral siempre serán visibles (salvo que el botón general <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4191.jpg" alt="OFF" style="width:20px; height:11px; display:inline; vertical-align:middle;"> esté desactivado).</li>
                </ul>
            </div>
            <div class="mb-4 p-3 bg-green-100 border border-green-300 rounded">
            <h3 class="font-semibold text-lg mb-2">3. Asignar Palabra Clave Filtro (Icono Llave Verde)</h3>
            <ul class="list-disc pl-5 space-y-1 text-sm">
                <li><strong>Activar:</strong> Pulsa el icono de la llave <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4314.PNG" alt="Key" style="width:16px; height:16px; display:inline; vertical-align:middle;"> junto al campo de filtro. El icono se pondrá verde. Si vuelves a pulsar, se desactivará.</li>
                <li><strong>Escribe la Palabra:</strong> Escribe la palabra que quieres añadir al nombre de los botones en el campo de filtro. Se eliminarán los espacios automáticamente.</li>
                <li><strong>Asignar:</strong> Haz clic en el botón del grid al que quieres añadir la palabra clave. La palabra (en corchetes) se añadirá a su nombre (si no existe ya).</li>
                <li><strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                <li><strong>Guardar:</strong> Los cambios se guardan automáticamente cada vez que asignas una palabra clave a un botón.</li>
                <li><strong>Mostrar Todo:</strong> Al activar este modo, se limpiará el filtro y se mostrarán todos los botones para facilitar la asignación.</li>
            </ul>
            </div>
            <p class="mb-4"><strong>Salir de Personalización:</strong> Pulsa el botón activo <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (amarillo o cian) o el icono de la llave <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4314.PNG" alt="Key" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (verde) para desactivar el modo actual y volver al uso normal.</p>
        `;
        document.body.appendChild(modal);
        const closeEditInfoButton = modal.querySelector('#close-edit-info');
        const closeHandler = () => { clearModalAutoCloseTimer(modal, closeEditInfoButton, 'edit-info-modal'); if (modal.parentNode) modal.parentNode.removeChild(modal); };
        closeEditInfoButton.addEventListener('click', closeHandler); addModalAutoCloseTimer(modal, closeEditInfoButton, 'edit-info-modal');
    }
    
    // ===================================================================
    // NOMBRE: showEditModal
    // RESUMEN: Muestra el modal para editar los detalles de un marcador o de un botón de sección.
    function showEditModal(targetIndexOrStart, isToggle = false) { if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); } const existingModal = document.querySelector('.edit-modal'); if (existingModal) existingModal.remove(); const modal = document.createElement('div'); modal.className = 'edit-modal'; if (isToggle) { editingTargetElement = toggleButtonElements[targetIndexOrStart]; } else { editingTargetElement = cellElements[targetIndexOrStart]; } if (editingTargetElement) { editingTargetElement.classList.add('editing-target'); } else { } let currentItemData = {}; let originalItemData = {}; let title = ''; let isNewBookmark = false; const targetIndex = isToggle ? -1 : targetIndexOrStart; if (isToggle) { const targetStart = targetIndexOrStart; const currentRange = currentToggleRanges.find(r => r.start === targetStart); const originalRange = originalToggleRanges.find(r => r.start === targetStart); const currentLabel = customData.toggles[targetStart]?.label ?? currentRange?.label ?? ''; currentItemData = { label: currentLabel }; originalItemData = { label: originalRange?.label || '' }; title = `Editar Etiqueta Sección`;
        modal.innerHTML = `
            <h2>${title}</h2>
            <div class="modal-top-buttons" style="margin-bottom: 1.2rem;">
                <button class="save">Guardar</button>
                <button class="reset">Resetear</button>
                <button class="cancel">Cancelar</button>
            </div>
            <div><label for="edit-label">Etiqueta (máx 7):</label><input type="text" id="edit-label" value="${currentItemData.label}" maxlength="7"></div>
        `;
    } else { const currentBookmark = currentBookmarks[targetIndex]; const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null; currentItemData = currentBookmark ? { ...currentBookmark } : { name: '', url: '', favicon: '' }; originalItemData = originalBookmark ? { ...originalBookmark } : { name: '', url: '', favicon: '' }; isNewBookmark = !currentBookmark; title = currentBookmark ? `Editar Marcador: ${currentItemData?.name || `Índice ${targetIndex}`}` : `Añadir Marcador (Posición ${targetIndex + 1})`;
        modal.innerHTML = `
            <h2>${title}</h2>
            <div class="modal-top-buttons" style="margin-bottom: 1.2rem;">
                <button class="save">Guardar</button>
                <button class="reset">Resetear</button>
                <button class="empty">Vaciar</button>
                <button class="cancel">Cancelar</button>
            </div>
            <div><label for="edit-name">Nombre:</label><input type="text" id="edit-name" value="${currentItemData.name || ''}"></div>
            <div><label for="edit-url">URL:</label><div class="input-with-button"><input type="url" id="edit-url" value="${currentItemData.url || ''}" placeholder="https://ejemplo.com"><button class="search-button" id="search-url-button" title="Buscar URL en Google (basado en URL/Nombre)">🔍</button></div></div>
            <div><label for="edit-favicon">URL Favicon (Opcional):</label><div class="input-with-button"><input type="text" id="edit-favicon" value="${currentItemData.favicon || ''}" placeholder="Dejar vacío para auto"><button class="search-button" id="search-favicon-button" title="Buscar Favicon en Google Images (basado en Favicon/Nombre)">🖼️</button></div></div>
        `;
    } document.body.appendChild(modal); const cleanupEditModal = () => { if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; } if (modal.parentNode) modal.parentNode.removeChild(modal); }; modal.querySelector('.save').addEventListener('click', () => { let dataChanged = false; if (isToggle) { const targetStart = targetIndexOrStart; const newLabel = modal.querySelector('#edit-label').value.trim(); if (!newLabel) { showToast("La etiqueta no puede estar vacía.", "warning"); return; } if (newLabel.length > 7) { showToast("La etiqueta no puede exceder 7 caracteres.", "warning"); return; } const originalLabel = originalToggleRanges.find(r => r.start === targetStart)?.label || ''; if (newLabel !== originalLabel) { if (!customData.toggles[targetStart]) customData.toggles[targetStart] = {}; customData.toggles[targetStart].label = newLabel; dataChanged = true; } else { if (customData.toggles[targetStart] && customData.toggles[targetStart].hasOwnProperty('label')) { delete customData.toggles[targetStart].label; if (Object.keys(customData.toggles[targetStart]).length === 0) delete customData.toggles[targetStart]; dataChanged = true; } } const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetStart); if (rangeIdx > -1) currentToggleRanges[rangeIdx].label = newLabel; } else { const nameInput = modal.querySelector('#edit-name'); const urlInput = modal.querySelector('#edit-url'); const faviconInput = modal.querySelector('#edit-favicon');
                const newName = nameInput.value.trim();
                const newUrl = urlInput.value.trim();
                const newFavicon = faviconInput.value.trim() || null;
                const isEmpty = !newName && !newUrl && !newFavicon;
                const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                if (isEmpty) {
                    if (originalBookmark !== null && originalBookmark !== undefined) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = null;
                        dataChanged = true;
                    } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = null;
                } else {
                    if (!newName || !newUrl) {
                        showToast("Nombre y URL son obligatorios.", "warning");
                        return;
                    }
                    try { new URL(newUrl); } catch (_) {
                        showToast("URL inválida.", "warning");
                        return;
                    }
                    const bookmarkUpdate = { name: newName, url: newUrl, favicon: newFavicon };
                    const originalData = originalBookmark ? { name: originalBookmark.name, url: originalBookmark.url, favicon: originalBookmark.favicon || null } : null;
                    const bookmarksAreEqual = (b1, b2) => { if (b1 === null && b2 === null) return true; if (b1 === null || b2 === null) return false; return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null); };
                    if (!bookmarksAreEqual(bookmarkUpdate, originalData)) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = bookmarkUpdate;
                        dataChanged = true;
                   } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = bookmarkUpdate;
                }
            }
            if (dataChanged) {
                saveCustomData();
                showToast("Cambios guardados", "success");
            } else {
          }
            updateGridItemUI(targetIndexOrStart, isToggle);
            cleanupEditModal();
        });
        modal.querySelector('.reset').addEventListener('click', () => {
            let dataChanged = false;
            if (isToggle) {
                const targetStart = targetIndexOrStart;
                const originalRange = originalToggleRanges.find(r => r.start === targetStart);
                const originalLabel = originalRange?.label || '';
                modal.querySelector('#edit-label').value = originalLabel;
                if (customData.toggles && customData.toggles[targetStart] && customData.toggles[targetStart].hasOwnProperty('label')) {
                    delete customData.toggles[targetStart].label;
                    if (Object.keys(customData.toggles[targetStart]).length === 0) delete customData.toggles[targetStart];
                    dataChanged = true;
                }
                const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetStart);
                if (rangeIdx > -1) currentToggleRanges[rangeIdx].label = originalLabel;
            } else {
                const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                modal.querySelector('#edit-name').value = originalBookmark?.name || '';
                modal.querySelector('#edit-url').value = originalBookmark?.url || '';
                modal.querySelector('#edit-favicon').value = originalBookmark?.favicon || '';
                if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                    delete customData.bookmarks[targetIndex];
                    dataChanged = true;
                }
                currentBookmarks[targetIndex] = originalBookmark ? { ...originalBookmark } : null;
            }
            if (dataChanged) {
                saveCustomData();
                showToast("Valores reseteados al original y guardados", "info");
            } else {
                showToast("Ya estaba con los valores originales", "info");
            }
            updateGridItemUI(targetIndexOrStart, isToggle);
            cleanupEditModal();
        });
        modal.querySelector('.cancel').addEventListener('click', cleanupEditModal);
        if (!isToggle) {
            const emptyBtn = modal.querySelector('.empty');
            if (emptyBtn) {
                emptyBtn.addEventListener('click', () => {
                    modal.querySelector('#edit-name').value = '';
                    modal.querySelector('#edit-url').value = '';
                    modal.querySelector('#edit-favicon').value = '';
                    const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                    let dataChanged = false;
                    if (originalBookmark !== null && originalBookmark !== undefined) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = null;
                        dataChanged = true;
                    } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = null;
                    if(dataChanged) {
                        saveCustomData();
                        showToast("Marcador vaciado y guardado.", "success");
                    } else {
                        oast("Marcador ya estaba vacío.", "info");
                    }
                    updateGridItemUI(targetIndex, false);
                    cleanupEditModal();
                });
            }
            const searchUrlBtn = modal.querySelector('#search-url-button');
            const searchFaviconBtn = modal.querySelector('#search-favicon-button');
            const nameInput = modal.querySelector('#edit-name');
            const urlInputSearch = modal.querySelector('#edit-url');
            const faviconInputSearch = modal.querySelector('#edit-favicon');
            if (searchUrlBtn) {
                searchUrlBtn.addEventListener('click', () => {
                    const urlValue = urlInputSearch.value.trim();
                    const nameValue = nameInput.value.trim();
                    const query = urlValue || nameValue;
                    if (query) { window.open(`https://www.google.com/search?q=${encodeURIComponent(query)}`, '_blank'); }
                    else { showToast("Escribe un Nombre o URL para buscar.", "warning"); }
                });
            }
            if (searchFaviconBtn) {
                searchFaviconBtn.addEventListener('click', () => {
                    const faviconValue = faviconInputSearch.value.trim();
                    const nameValue = nameInput.value.trim();
                    const query = faviconValue || nameValue;
                    if (query) { window.open(`https://www.google.com/search?tbm=isch&q=${encodeURIComponent(`"${query}" favicon logo icon`)}`, '_blank'); }
                    else { showToast("Escribe un Nombre o URL de Favicon para buscar.", "warning"); }
                });
            }
        }
    }
        
    // ===================================================================
    // NOMBRE: updateGridItemUI
    // RESUMEN: Redibuja el grid y los botones para reflejar los cambios realizados en la edición.
    function updateGridItemUI(indexOrStart, isToggle = false) {
        renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles();adjustButtonPositions();
        if (isAssignmentMode) {
            updateGridAssignmentVisuals();
            if (currentlyAssigningToggleStart !== null && toggleButtonElements[currentlyAssigningToggleStart]) {
                toggleButtonElements[currentlyAssigningToggleStart].classList.add('assigning-selected');
                toggleButtonElements[currentlyAssigningToggleStart].style.opacity = '';
            }
        } else if (isKeywordAssignmentMode) { applyInitialKeywordHighlights(); }
    }  
     
    // ===================================================================
    function performInsertAndSave(sourceIndex, targetIndex) { if (sourceIndex === targetIndex || sourceIndex === null || targetIndex === null) { return false; } const draggedData = currentBookmarks.splice(sourceIndex, 1)[0]; currentBookmarks.splice(targetIndex, 0, draggedData); if (!customData.bookmarks) customData.bookmarks = {}; if (!customData.toggles) customData.toggles = {}; const minIdx = Math.min(sourceIndex, targetIndex); const maxIdx = Math.max(sourceIndex, targetIndex); currentToggleRanges.forEach(range => { if (range.assignedIndexes) {
        range.assignedIndexes = range.assignedIndexes.map(idx => { if (idx === sourceIndex) return targetIndex; else if (idx > sourceIndex && idx <= targetIndex) return idx - 1; else if (idx < sourceIndex && idx >= targetIndex) return idx + 1; else return idx; }).sort((a, b) => a - b); const startKey = range.start.toString(); if (customData.toggles[startKey] && customData.toggles[startKey].hasOwnProperty('assignedIndexes')) { customData.toggles[startKey].assignedIndexes = [...range.assignedIndexes]; } } }); for (let i = minIdx; i <= maxIdx; i++) { const currentItem = currentBookmarks[i]; const originalItem = i < originalBookmarks.length ? originalBookmarks[i] : null; const bookmarksAreEqual = (b1, b2) => { if (b1 === null && b2 === null) return true; if (b1 === null || b2 === null) return false; return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null); }; if (!bookmarksAreEqual(currentItem, originalItem)) { customData.bookmarks[i] = currentItem ? { ...currentItem } : null; } else if (customData.bookmarks.hasOwnProperty(i)) { delete customData.bookmarks[i]; } } saveCustomData(); renderGrid(); loadSavedSettings(); updateButtonStyles(); showToast(`Movido de ${sourceIndex + 1} a ${targetIndex + 1}`, "success", 1500); return true; }
    
    // ===================================================================
    function handleDragStart(e) { if (!isEditMode) return; draggedItem = e.currentTarget; draggedItemIndex = parseInt(draggedItem.dataset.index); e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', draggedItemIndex); setTimeout(() => { if (draggedItem) draggedItem.classList.add('dragging'); }, 0); }
    
    // ===================================================================
    function handleDragOver(e) { if (!isEditMode || !draggedItem) return; e.preventDefault(); e.dataTransfer.dropEffect = 'move'; const targetCell = e.target.closest('.grid-cell'); const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetCell && targetIndex !== dragOverIndex) { if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } if (targetIndex !== draggedItemIndex) { targetCell.classList.add('drag-over'); dragOverIndex = targetIndex; } else { dragOverIndex = null; } } else if (!targetCell && dragOverIndex !== null) { if (cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } dragOverIndex = null; } }
    
    // ===================================================================
    function handleDragLeave(e) { if (!isEditMode || !draggedItem) return; const targetCell = e.target.closest('.grid-cell'); if (targetCell && !targetCell.contains(e.relatedTarget)) { if (parseInt(targetCell.dataset.index) === dragOverIndex) { targetCell.classList.remove('drag-over'); dragOverIndex = null; } } }
    
    // ===================================================================
    function handleDrop(e) { if (!isEditMode || !draggedItem) return; e.preventDefault(); const targetCell = e.target.closest('.grid-cell'); const sourceIndex = draggedItemIndex; const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetIndex !== null && sourceIndex !== targetIndex) { performInsertAndSave(sourceIndex, targetIndex); } else { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } } handleDragEndCleanup(); }
    
    // ===================================================================
    function handleDragEndCleanup() { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } draggedItem = null; draggedItemIndex = null; dragOverIndex = null; }
    
    // ===================================================================
    function handleTouchStart(e) { if (!isEditMode || e.touches.length !== 1) return; draggedItem = e.currentTarget; draggedItemIndex = parseInt(draggedItem.dataset.index); const touch = e.touches[0]; touchStartX = touch.clientX; touchStartY = touch.clientY; draggedItem.classList.add('dragging'); currentTouchTarget = draggedItem; }
    
    // ===================================================================
    function handleTouchMove(e) { if (!isEditMode || !draggedItem || e.touches.length !== 1) return; e.preventDefault(); const touch = e.touches[0]; const elementOver = document.elementFromPoint(touch.clientX, touch.clientY); const targetCell = elementOver?.closest('.grid-cell'); const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetCell && targetIndex !== dragOverIndex) { if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } if (targetIndex !== draggedItemIndex) { targetCell.classList.add('drag-over'); dragOverIndex = targetIndex; currentTouchTarget = targetCell; } else { dragOverIndex = null; currentTouchTarget = draggedItem; } } else if (!targetCell && dragOverIndex !== null) { if (cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } dragOverIndex = null; currentTouchTarget = null; } }   
      
    // ===================================================================
    function handleTouchEnd(e) { if (!isEditMode || !draggedItem) return; if (dragOverIndex !== null && dragOverIndex !== draggedItemIndex) { performInsertAndSave(draggedItemIndex, dragOverIndex); e.preventDefault(); } else { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } } handleTouchEndCleanup(); }   
    
    // ===================================================================
    // NOMBRE: handleTouchEndCleanup
    // RESUMEN: Limpia las variables y estilos de la operación de arrastre táctil.
    function handleTouchEndCleanup() { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } draggedItem = null; draggedItemIndex = null; dragOverIndex = null; currentTouchTarget = null; touchStartX = 0; touchStartY = 0; }
    
    // ===================================================================
    // NOMBRE: normalizeText
    // RESUMEN: Normaliza un texto (minúsculas, sin acentos) para facilitar comparaciones.
    function normalizeText(text) { if (!text) return ''; return text.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, ''); }
    
    // ===================================================================
    // NOMBRE: filterGridItems
    // RESUMEN: Filtra los elementos del grid según el texto del filtro y los toggles de sección.
    function filterGridItems() {
        const filterInput = document.getElementById('grid-filter-input');
        const clearButton = document.getElementById('clear-filter-button');
        if (!filterInput || !clearButton || !cellElements || cellElements.length === 0) { return; }
        if (isKeywordAssignmentMode) {
            cellElements.forEach(cellContainer => { cellContainer.classList.remove('hidden'); });
            clearButton.style.display = filterInput.value.trim() ? 'inline-block' : 'none';
            return;
        }
        const rawFilterText = filterInput.value.trim();
        clearButton.style.display = rawFilterText ? 'inline-block' : 'none';
        const filterWords = rawFilterText.split(/\s+/).filter(word => word.length > 0).map(word => normalizeText(word));
        const onOffToggleElem = document.getElementById('on-off-toggle');
        const masterState = onOffToggleElem ? (onOffToggleElem.dataset.state || 'on') : 'on';
        cellElements.forEach((cellContainer, index) => {
            const isMasterOff = masterState === 'off';
            if (isMasterOff) {
                cellContainer.classList.add('hidden');
                return;
            }
            const bookmark = currentBookmarks[index];
            const bookmarkName = bookmark ? normalizeText(bookmark.name) : '';
            const isEmptySlot = !bookmark;
            let matchesFilter = true;
            if (filterWords.length > 0) {
                if (isEmptySlot) {
                    matchesFilter = false;
                } else {
                    matchesFilter = filterWords.every(word => bookmarkName.includes(word));
                }
            }
            const shouldBeHiddenByFilter = filterWords.length > 0 && !matchesFilter;
            let shouldBeHiddenByToggles = false;
            const containingRange = getSectionForIndex(index);
            if (containingRange) {
                const toggleButton = toggleButtonElements[containingRange.start] || document.querySelector(`.range-toggle[data-range-start="${containingRange.start}"]`);
                if (toggleButton) {
                    const toggleState = toggleButton.dataset.state || 'visible';
                    shouldBeHiddenByToggles = toggleState === 'hidden';
                }
            } else {
                shouldBeHiddenByToggles = false;
            }
            const shouldBeHidden = shouldBeHiddenByToggles || shouldBeHiddenByFilter;
            cellContainer.classList.toggle('hidden', shouldBeHidden);
        });
    }
    
    // ===================================================================
    // NOMBRE: promptForPin
    // RESUMEN: Muestra el modal para introducir el PIN de acceso.
    function promptForPin() { const pinModal = document.getElementById('pin-modal-overlay'); const pinInput = document.getElementById('pin-input'); const pinSubmit = document.getElementById('pin-submit-button'); const pinError = document.getElementById('pin-error-message'); pinModal.classList.remove('hidden');
        pinInput.value = ''; pinError.textContent = ''; pinInput.focus(); const newPinSubmit = pinSubmit.cloneNode(true); pinSubmit.parentNode.replaceChild(newPinSubmit, pinSubmit); newPinSubmit.addEventListener('click', checkPin); pinInput.addEventListener('keyup', (event) => { if (event.key === 'Enter') { checkPin(); } }); }
    
    
    // ===================================================================
    // NOMBRE: checkPin
    // RESUMEN: Verifica el PIN introducido por el usuario.
    function checkPin() { const pinModal = document.getElementById('pin-modal-overlay'); const pinInput = document.getElementById('pin-input'); const pinError = document.getElementById('pin-error-message'); const enteredPin = pinInput.value; if (enteredPin === storedPin) { pinModal.classList.add('hidden'); initializeApp(); } else { pinError.textContent = 'Clave incorrecta.'; pinInput.value = ''; pinInput.focus(); if (navigator.vibrate) navigator.vibrate(100); } }
    
    // ===================================================================
    // NOMBRE: handlePasswordToggleClick
    // RESUMEN: Activa o desactiva la solicitud de PIN al inicio.
    function handlePasswordToggleClick() { if (!storedPin) { showToast('Primero establece una clave en Configuración -> Usuario.', 'warning'); return; } isPasswordActive = !isPasswordActive; updatePasswordToggleIcon(); saveSettings(); showToast(`Solicitar clave al inicio: ${isPasswordActive ? 'Activado' : 'Desactivado'}`, 'info'); }
    
    
    // ===================================================================
    // NOMBRE: updatePasswordToggleIcon
    // RESUMEN: Actualiza el icono del candado según si el PIN está activo o no.
    function updatePasswordToggleIcon() { const passwordButton = document.getElementById('password-toggle-button'); if (passwordButton) { const img = passwordButton.querySelector('img'); if(img) { const iconPath = isPasswordActive ? 'PNG/IMG_4281.png' : 'PNG/IMG_4280.png'; img.src = `https://boardinggate.github.io/Tesla/${iconPath}`;
        img.alt = isPasswordActive ? 'Clave Activada' : 'Clave Desactivada'; passwordButton.title = `Clave al inicio: ${isPasswordActive ? 'Activada' : 'Desactivada'}`; } } }
    
    // ===================================================================
    // NOMBRE: savePinSettings
    // RESUMEN: Guarda las nuevas configuraciones de PIN y preferencias de inicio.
    function savePinSettings() {
        const pinSetInput = document.getElementById('config-pin-set');
        const pinConfirmInput = document.getElementById('config-pin-confirm');
        const pinStatus = document.getElementById('config-pin-status');
        const directToNavCheckbox = document.getElementById('config-direct-to-nav');
        const newPin = pinSetInput.value;
        const confirmPin = pinConfirmInput.value;
        pinStatus.textContent = '';
        let keySaved = false;
        let prefSaved = false;
        if (newPin || confirmPin) {
            if (!/^\d{4}$/.test(newPin)) {
                pinStatus.textContent = 'La clave debe tener exactamente 4 cifras.';
                pinStatus.style.color = '#EF4444';
                return;
            }
            if (newPin !== confirmPin) {
                pinStatus.textContent = 'Las claves no coinciden.';
                pinStatus.style.color = '#EF4444';
                return;
            }
            try {
                localStorage.setItem('password_pin', newPin);
                storedPin = newPin;
                if (!localStorage.getItem('password_active') || isPasswordActive) {
                    isPasswordActive = true;
                    localStorage.setItem('password_active', 'true');
                }
                pinStatus.textContent = 'Clave guardada. ';
                pinStatus.style.color = '#28a745';
                pinSetInput.value = '';
                pinConfirmInput.value = '';
                updatePasswordToggleIcon();
                keySaved = true;
            } catch (e) {
                pinStatus.textContent ='Error al guardar la clave.';
                pinStatus.style.color = '#EF4444';
                showToast('Error al guardar la clave.', 'error');
            }
        }
        const directToNavChecked = directToNavCheckbox.checked;
        localStorage.setItem(DIRECT_TO_NAVIGATION_KEY, JSON.stringify(directToNavChecked));
        prefSaved = true;
        if (keySaved && prefSaved) {
            showToast('Clave y preferencia de inicio guardadas.', 'success');
            pinStatus.textContent += (pinStatus.textContent ? "Y " : "") + "Preferencia de inicio guardada.";
             pinStatus.style.color = '#28a745';
        } else if (keySaved) {
            showToast('Clave guardada. Preferencia de inicio también actualizada.', 'success');
             pinStatus.textContent += (pinStatus.textContent ? " " : "") + "Preferencia de inicio guardada.";
             pinStatus.style.color = '#28a745';
        } else if (prefSaved) {
            showToast('Preferencia de inicio guardada.', 'success');
            pinStatus.textContent = "Preferencia de inicio guardada.";
            pinStatus.style.color = '#28a745';
        } else if (!newPin && !confirmPin) {
             pinStatus.textContent = "No se realizaron cambios en la clave. Preferencia de inicio no cambió.";
             pinStatus.style.color = '#17a2b8';
        }
        saveSettings();
    }
    
    // ===================================================================
    // NOMBRE: removePinSettings
    // RESUMEN: Elimina la configuración de PIN de acceso.
    function removePinSettings() { const pinStatus = document.getElementById('config-pin-status'); if (confirm('¿Estás seguro de que deseas eliminar la clave de acceso? Ya no se solicitará al inicio.')) { try { localStorage.removeItem('password_pin'); localStorage.setItem('password_active', 'false'); storedPin = null; isPasswordActive = false; pinStatus.textContent = 'Clave eliminada.'; pinStatus.style.color = '#17a2b8'; document.getElementById('config-pin-set').value = ''; document.getElementById('config-pin-confirm').value = ''; updatePasswordToggleIcon(); saveSettings(); showToast('Clave eliminada.', 'info'); } catch (e) { pinStatus.textContent = 'Error al eliminar la clave.'; pinStatus.style.color = '#EF4444'; showToast('Error al eliminar la clave.', 'error'); } } }
    
    // ===================================================================
    // NOMBRE: getRemoteUpdatesDate
    // RESUMEN: Obtiene la fecha de la última actualización de un archivo remoto.
    async function getRemoteUpdatesDate() { try { const response = await fetch('https://boardinggate.github.io/Tesla/updates.txt', { cache: 'no-cache' }); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const text = await response.text(); const firstLine = text.split('\n')[0].trim(); const dateMatch = firstLine.match(/^\d{4}-\d{2}-\d{2}/); if (dateMatch) { const [year, month, day] = dateMatch[0].split('-').map(Number); const remoteDate = new Date(Date.UTC(year, month - 1, day)); if (!isNaN(remoteDate.getTime())) { return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`; } } return null; } catch (e) { return null; } }
    
    
    // ===================================================================
    // NOMBRE: isRemoteDateNewer
    // RESUMEN: Compara si una fecha remota es más reciente que una fecha en caché.
    function isRemoteDateNewer(remoteDateStr, cachedDateStr) { if (!remoteDateStr) return false; if (!cachedDateStr) return true; try { return remoteDateStr > cachedDateStr; } catch (e) { return false; } }
    
    // ===================================================================
    // NOMBRE: checkVersionsIconOpacity
    // RESUMEN: Ajusta la opacidad del icono de versiones si hay actualizaciones nuevas.
    async function checkVersionsIconOpacity() { const versionsIcon = document.getElementById('versions-button'); const versionsImg = versionsIcon ? versionsIcon.querySelector('img') : null; if (!versionsImg) return;
        let showAsNew = false; const remoteDateStr = await getRemoteUpdatesDate();
        if (remoteDateStr) { showAsNew = isRemoteDateNewer(remoteDateStr, lastUpdatesCheckDate); } versionsImg.style.opacity = showAsNew ? '1.0' : '0.1';
    }
    
// ===================================================================
// NOMBRE: showVersionsModal (VERSIÓN CON LIMPIEZA DE MEMORIA)
// RESUMEN: Muestra el modal con el historial de versiones y limpia el contenido al cerrar.
// ===================================================================
async function showVersionsModal() {
    const versionsModalOverlay = document.getElementById('versions-modal-overlay');
    const versionsContent = document.getElementById('versions-content');
    const closeButton = document.getElementById('close-versions-modal');
    if (!versionsModalOverlay || !versionsContent || !closeButton) return;

    const newCloseButton = closeButton.cloneNode(true);
    closeButton.parentNode.replaceChild(newCloseButton, closeButton);

    const closeHandler = () => {
        versionsModalOverlay.classList.add('hidden');
        clearModalAutoCloseTimer(versionsModalOverlay, newCloseButton, 'versions-modal');
        
        versionsContent.textContent = ''; // Vaciamos el contenido para que el recolector de basura actúe
    };

    newCloseButton.addEventListener('click', closeHandler);

    versionsContent.textContent = 'Cargando histórico...';
    versionsModalOverlay.classList.remove('hidden');
    addModalAutoCloseTimer(versionsModalOverlay, newCloseButton, 'versions-modal');

    try {
        const response = await fetch('https://boardinggate.github.io/Tesla/updates.txt', { cache: 'no-cache' });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const text = await response.text();
        versionsContent.textContent = text;
        
        const firstLine = text.split('\n')[0].trim();
        const dateMatch = firstLine.match(/^\d{4}-\d{2}-\d{2}/);
        let dateToStore = null;
        if (dateMatch) {
            const [year, month, day] = dateMatch[0].split('-').map(Number);
            const checkDate = new Date(Date.UTC(year, month - 1, day));
            if (!isNaN(checkDate.getTime())) {
                dateToStore = dateMatch[0];
            }
        }

        if (dateToStore) {
            lastUpdatesCheckDate = dateToStore;
        } else {
            const today = new Date();
            lastUpdatesCheckDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
        }
        
        saveSettings();
        await checkVersionsIconOpacity();
    } catch (e) {
        versionsContent.textContent = `Error al cargar el histórico:\n${e.message}`;
    }
}    
    
    // ===================================================================
    // NOMBRE: getCurrentLocation
    // RESUMEN: Obtiene la ubicación actual del dispositivo a través de la API de Geolocalización.
    function getCurrentLocation(callback, errorCallback) {
        if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    callback({
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy,
                        altitude: position.coords.altitude,
                        heading: position.coords.heading,
                        speed: position.coords.speed
                    });
                },
                (error) => {
                    let message = "No se pudo obtener la ubicación.";
                    switch (error.code) {
                        case error.PERMISSION_DENIED:
                            message = "Permiso de ubicación denegado.";
                            break;
                        case error.POSITION_UNAVAILABLE:
                            message = "Información de ubicación no disponible.";
                            break;
                        case error.TIMEOUT:
                            message = "Timeout obteniendo ubicación.";
                            break;
                    }
                    if (errorCallback) errorCallback(message);
                    else showToast(message, "error");
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        } else {
            const message = "Geolocalización no soportada por este navegador.";
            if (errorCallback) errorCallback(message);
            else showToast(message, "error");
        }
    }
    
    // ===================================================================
    // NOMBRE: calculateDistance
    // RESUMEN: Calcula la distancia en metros entre dos coordenadas geográficas.
    function calculateDistance(lat1, lon1, lat2, lon2) {
        if (typeof lat1 !== 'number' || typeof lon1 !== 'number' || typeof lat2 !== 'number' || typeof lon2 !== 'number' || isNaN(lat1) || isNaN(lon1) || isNaN(lat2) || isNaN(lon2)) {
             return Infinity;
        }
        const R = 6371e3; 
        const φ1 = lat1 * Math.PI / 180; 
        const φ2 = lat2 * Math.PI / 180; 
        const Δφ = (lat2 - lat1) * Math.PI / 180; 
        const Δλ = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return R * c;
    }
    
    // ===================================================================
    // NOMBRE: restoreCacheForMobile
    // RESUMEN: Descarga silenciosamente la caché de Firebase al iniciar en móvil.
    async function restoreCacheForMobile() {
        const { primaryId } = parseUserId(localStorage.getItem('userData_userId'));
        if (!primaryId) return;
        const result = await callFirebase('getUserData', { userId: primaryId });
        if (result.status === 'success' && result.data) {
            const backupCacheData = result.data.contenidoCacheCompleto;
            if (backupCacheData) {
                showToast('Sincronizando datos desde la nube...', 'info', 2000);
                const currentUserIdentity = localStorage.getItem('userData_userId');
                for (const key in backupCacheData) {
                    if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                        localStorage.setItem(key, backupCacheData[key]);
                    }
                }
                if (currentUserIdentity) {
                    localStorage.setItem('userData_userId', currentUserIdentity);
                }
                loadCustomData();
                loadSavedSettings();
                updateUserIdDisplay();
                markCacheAsDirty();
            }
        }
    }
    
// ===================================================================
// NOMBRE: hideUnifiedReminderWindow
// RESUMEN: Oculta la ventana unificada de recordatorios y limpia sus elementos.
function hideUnifiedReminderWindow() {
    if (realtimeSpeedUpdateInterval) {
        clearInterval(realtimeSpeedUpdateInterval);
        realtimeSpeedUpdateInterval = null;
    }
    const windowElement = document.getElementById('unified-reminder-window');
    if (windowElement && windowElement.classList.contains('visible')) {
        windowElement.classList.remove('visible');
        isUnifiedWindowVisibleByLogic = false;
        const swiperContainer = document.getElementById('reminder-swiper-container');
        Object.values(previewMaps).forEach(map => {
            if (map && typeof map.remove === 'function') {
                map.remove();
            }
        });
        previewMaps = {};
        if (swiperContainer) {
            swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay);
            setTimeout(() => {
                if (swiperContainer && !windowElement.classList.contains('visible')) {
                    swiperContainer.innerHTML = '';
                }
            }, 600);
        }
        const hideAllButton = document.getElementById('hide-all-reminders-button');
        if (hideAllButton) { const newHideAllButton = hideAllButton.cloneNode(true); hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton); }
        const mapShouldReopen = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
        const mapContextToReopen = sessionStorage.getItem('mapContext');
        sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
        if (mapShouldReopen &&
            !document.querySelector('.reminder-modal') &&
            !document.querySelector('.reminder-table-modal') &&
            !document.getElementById('reminders-location-map-modal')
           ) {
             if (mapContextToReopen === 'navigation') openNavigationMap();
              sessionStorage.removeItem('mapContext');
        }
    }
}
    
// ===================================================================
// NOMBRE: postponeAllVisibleReminders
// RESUMEN: Pospone todos los recordatorios actualmente visibles en la ventana unificada.
function postponeAllVisibleReminders() {
    const swiperContainer = document.getElementById('reminder-swiper-container'); if (!swiperContainer) return;
    const visibleSlides = swiperContainer.querySelectorAll('.reminder-slide'); if (visibleSlides.length === 0) return;
    let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    let updated = false;
    const idsToUpdate = [];
    visibleSlides.forEach(slide => {
        const reminderId = parseInt(slide.dataset.id);
        if (isNaN(reminderId)) return;
        idsToUpdate.push(reminderId);
        const index = reminders.findIndex(r => r.id === reminderId);
        if (index !== -1) {
            const { newDateISO, newTime } = calculatePostponedDateTime(1);
            reminders[index].date = newDateISO;
            reminders[index].time = newTime;
            reminders[index].managedByUser = false;
            updated = true;
        }
    });
    if (updated) {
        localStorage.setItem('reminders', JSON.stringify(reminders));
        
        markCacheAsDirty();
        showToast(`${idsToUpdate.length} recordatorio(s) pospuesto(s) 1 minuto`, 'info');
        idsToUpdate.forEach(id => updateUnifiedWindowUI(id)); // Esto es para la UI, no afecta la lógica.
        updateReminderCount();
        updateButtonStyles();
    }
    if (idsToUpdate.length > 0 && document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
       hideUnifiedReminderWindow();
    }
}

    
    // ===================================================================
    // NOMBRE: updateReminderIndexDisplay
    // RESUMEN: Actualiza el contador de índice del slide actual en la ventana unificada.
    function updateReminderIndexDisplay() {
        const swiperContainer = document.getElementById('reminder-swiper-container');
        const currentIndexSpan = document.getElementById('current-reminder-index');
        if (!swiperContainer || !currentIndexSpan) return;
        const totalSlides = swiperContainer.querySelectorAll('.reminder-slide').length;
        if (totalSlides === 0) {
            currentIndexSpan.textContent = '0';
            return;
        }
        const containerWidth = swiperContainer.offsetWidth;
        if (containerWidth <= 0) {
           return;
        }
        const currentScroll = swiperContainer.scrollLeft;
        const currentIndex = Math.round(currentScroll / containerWidth);
        currentNotificationSlideIndex = currentIndex;
        const displayIndex = Math.max(1, Math.min(currentIndex + 1, totalSlides));
        currentIndexSpan.textContent = displayIndex;
         const currentSlideElement = swiperContainer.querySelectorAll('.reminder-slide')[currentIndex];
         if (currentSlideElement && !isNavigationMapActive) {
            const mapId = currentSlideElement.querySelector('.reminder-map-preview')?.id;
            if (mapId) {
                 const reminderId = parseInt(mapId.replace('map-preview-', ''));
                 if (previewMaps[reminderId]) {
                     setTimeout(() => { if(previewMaps[reminderId]) previewMaps[reminderId].resize(); }, 50);
                 }
            }
         }
    }
    
    // ===================================================================
    // NOMBRE: updateUnifiedWindowUI
    // RESUMEN: Actualiza la UI de la ventana unificada después de que un recordatorio es gestionado.
    function updateUnifiedWindowUI(processedReminderId) {
        const windowElement = document.getElementById('unified-reminder-window');
        const swiperContainer = document.getElementById('reminder-swiper-container');
        const slideToRemove = swiperContainer ? swiperContainer.querySelector(`.reminder-slide[data-id="${processedReminderId}"]`) : null;
        if (previewMaps[processedReminderId]) {
           if (typeof previewMaps[processedReminderId].remove === 'function') {
               previewMaps[processedReminderId].remove();
           }
           delete previewMaps[processedReminderId];
        }
        if (slideToRemove && slideToRemove.parentNode === swiperContainer) {
            swiperContainer.removeChild(slideToRemove);
        }
        const remainingSlides = swiperContainer ? swiperContainer.querySelectorAll('.reminder-slide') : [];
        const remainingCount = remainingSlides.length;
        if (remainingCount === 0) {
            hideUnifiedReminderWindow();
        }
        else {
            const countHeader = windowElement.querySelector('.reminder-count-header');
            const countSpan = document.getElementById('total-reminder-count');
            const countTextContainer = document.getElementById('reminder-count-text-container');
            const swipeHint = document.getElementById('reminder-swipe-hint');
            countSpan.textContent = remainingCount;
            updateReminderIndexDisplay();
            if (remainingCount > 1) {
                countTextContainer.style.display = 'inline';
                swipeHint.style.display = 'block';
                document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = 'calc(85vh - 60px)');
            } else {
                countTextContainer.style.display = 'none';
                swipeHint.style.display = 'none';
                document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = '85vh');
            }
            const maxScrollIndex = remainingCount - 1;
            if (currentNotificationSlideIndex > maxScrollIndex) {
                 currentNotificationSlideIndex = maxScrollIndex;
                 swiperContainer.scrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
                 updateReminderIndexDisplay();
            }
        }
        updateReminderCount();
        updateButtonStyles();
    }
    
    
    // ===================================================================
    // NOMBRE: updateReminderCount
    // RESUMEN: Actualiza los contadores de recordatorios en la UI.
    function updateReminderCount() {
         let reminders = []; try { reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); } catch (e) { reminders = []; }
         const showExcludedInTable = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false; let remindersForCount = reminders;
         if (!showExcludedInTable) { remindersForCount = reminders.filter(r => !r.excludeFromList); }
         const totalCount = remindersForCount.length; const nonCyclicReminders = remindersForCount.filter(r => r.type !== 'weekly' && r.type !== 'interval'); const nonCyclicCount = nonCyclicReminders.length;
         const countElGlobe = document.getElementById('reminder-count-globe'); if (countElGlobe) { countElGlobe.textContent = nonCyclicCount > 0 ? nonCyclicCount : ''; countElGlobe.style.display = nonCyclicCount > 0 ? 'flex' : 'none'; }
         const reminderButtonElem = document.getElementById('reminder-button'); if (reminderButtonElem) { let countSpanSide = reminderButtonElem.querySelector('.reminder-count'); if (totalCount > 0) { if (!countSpanSide) { countSpanSide = document.createElement('span'); countSpanSide.className = 'reminder-count'; reminderButtonElem.appendChild(countSpanSide); } countSpanSide.textContent = totalCount; } else { if (countSpanSide) { countSpanSide.remove(); } } }
    }
        
 
// ===================================================================
// NOMBRE: formatTimeWithPeriod
// RESUMEN: Formatea una hora (HH:MM) para añadir un período del día (Mañana, Tarde, etc.).
function formatTimeWithPeriod(timeString) {
     if (!timeString || !timeString.match(/^\d{2}:\d{2}$/)) return '-';
     try {
         const [hourStr, minuteStr] = timeString.split(':');
         const hour = parseInt(hourStr);
         const minute = parseInt(minuteStr);
         if (isNaN(hour) || isNaN(minute) || hour < 0 || hour > 23 || minute < 0 || minute > 59) {
             return timeString;
         }
         let period = '';
         if (hour >= 22 || hour < 5) { period = 'de la Noche'; }
         else if (hour >= 5 && hour < 12) { period = 'de la Mañana'; }
         else if (hour >= 12 && hour < 14) { period = 'del Mediodía'; }
         else { period = 'de la Tarde'; }
         return `${hourStr}:${minuteStr} (${period})`;
     } catch (e) {
         return timeString;
     }
}

// ===================================================================
// NOMBRE: formatDateDetailed
// RESUMEN: Formatea una fecha (YYYY-MM-DD) a un formato más legible (DD-Mes-YYYY).
function formatDateDetailed(dateString) {
    if (!dateString || !dateString.match(/^\d{4}-\d{2}-\d{2}$/)) return '-';
    try {
        const [year, month, day] = dateString.split('-').map(Number);
        const date = new Date(Date.UTC(year, month - 1, day));
        if (isNaN(date.getTime())) return dateString;
        const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
        const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
        const monthName = monthNames[date.getUTCMonth()];
        const fullYear = date.getUTCFullYear();
        return `${dayOfMonth}-${monthName}-${fullYear}`;
    } catch (e) {
        return dateString;
    }
}

// ===================================================================
// NOMBRE: extractSpeedFromRadarText (VERSIÓN ESTRICTA)
// RESUMEN: Extrae un límite de velocidad válido (entre 20-130) del texto de un recordatorio.
function extractSpeedFromRadarText(text) {
    if (!text) return null;
    const cleanText = text.replace(/<[^>]*>/g, '').toUpperCase();
    const validSpeeds = [20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130];

    const kmMatch = cleanText.match(/\b(\d{2,3})\s*KM/);
    if (kmMatch && kmMatch[1]) {
        const speed = parseInt(kmMatch[1], 10);
        if (validSpeeds.includes(speed)) return speed;
    }
    
    const codeMatch = cleanText.match(/\b[FCN](\d{2,3})\b/);
    if (codeMatch && codeMatch[1]) {
        const speed = parseInt(codeMatch[1], 10);
        if (validSpeeds.includes(speed)) return speed;
    }
    
    const looseNumbers = cleanText.match(/\b(\d{2,3})\b/g);
    if (looseNumbers) {
        for (const numStr of looseNumbers) {
            const speed = parseInt(numStr, 10);
            if (validSpeeds.includes(speed)) {
                return speed; 
            }
        }
    }

    return null; 
} 
      
// ===================================================================
// NOMBRE: displayUnifiedReminderWindow
// RESUMEN: Muestra y rellena la ventana unificada de recordatorios con los que están vencidos.
function displayUnifiedReminderWindow(overdueReminders) {
    const windowElement = document.getElementById('unified-reminder-window');
    const swiperContainer = document.getElementById('reminder-swiper-container');
    const countHeader = windowElement.querySelector('.reminder-count-header');
    const countSpan = document.getElementById('total-reminder-count');
    const currentIndexSpan = document.getElementById('current-reminder-index');
    const countTextContainer = document.getElementById('reminder-count-text-container');
    const swipeHint = document.getElementById('reminder-swipe-hint');
    const hideAllButton = document.getElementById('hide-all-reminders-button');
     Object.values(previewMaps).forEach(map => {
       if (map && typeof map.remove === 'function') {
           map.remove();
       }
     });
     previewMaps = {};
    if (realtimeSpeedUpdateInterval) {
        clearInterval(realtimeSpeedUpdateInterval);
        realtimeSpeedUpdateInterval = null;
    }
    if (!windowElement || !swiperContainer || !countHeader || !countSpan || !currentIndexSpan || !countTextContainer || !swipeHint || !hideAllButton) {
        return;
    }
    swiperContainer.innerHTML = '';
    overdueReminders.sort((a, b) => { try { const dateA = new Date(`${a.date}T${a.time}:00Z`); const dateB = new Date(`${b.date}T${b.time}:00Z`); return dateA - dateB; } catch (e) { return 0; } });
    if (!isUnifiedWindowVisibleByLogic) {
        currentNotificationSlideIndex = 0;
    }
    overdueReminders.forEach((reminder, index) => {
        const slide = document.createElement('div');
        slide.className = 'reminder-slide';
        slide.dataset.id = reminder.id;
        slide.setAttribute('role', 'group');
        slide.setAttribute('aria-label', `Recordatorio: ${reminder.text.replace(/<[^>]*>/g, '')}`);
        
        let slideContentHtml = '';
        const isRadarAlert = reminder.text.toUpperCase().includes("RADAR");

        if (isRadarAlert) {
            const radarSpeed = extractSpeedFromRadarText(reminder.text);
            const validSpeeds = [20, 30, 50, 60, 70, 80, 90, 100, 110, 120];
            const isStandardSpeed = radarSpeed !== null && validSpeeds.includes(radarSpeed);

            let speedLimitHtml = '';
            let currentSpeedHtml = '';

            if (isStandardSpeed) {
                speedLimitHtml = `<p class="reminder-text" style="color: red; font-weight: bold; text-transform: uppercase; font-size: 1.8rem; margin-bottom: 0.2rem; text-align: center;">${radarSpeed} Km/h</p>`;
            } else {
                speedLimitHtml = `<p class="reminder-text" style="color: red; font-weight: bold; text-transform: uppercase; font-size: 1.4rem; margin-bottom: 0.2rem; text-align: center;">RADAR DE TRAMO o INDETERMINADO</p>`;
            }

            const carSpeed = Math.round(window.currentSpeedKmh || 0);
            const speedExceeded = isStandardSpeed && carSpeed > radarSpeed;
            
            currentSpeedHtml = `<p id="current-speed-display-${reminder.id}" style="text-align:center; font-size: 1.7rem; font-weight: bold; color: ${speedExceeded ? 'red' : '#333'};">[Velocidad actual: ${carSpeed} Km/h]</p>`;

            slideContentHtml = `
                <div class="reminder-slide-content">
                    <img src="https://boardinggate.github.io/Tesla/PNG/AGUARDIA.png" alt="Icono Radar" class="radar-icon">
                    <div class="reminder-content-scrollable">
                        ${speedLimitHtml}
                        ${currentSpeedHtml}
                        <p class="reminder-text" style="text-align: center; margin-top: 0.5rem; ${isStandardSpeed ? 'font-size: 1rem; color: #444;' : ''}">${reminder.text}</p>
                    </div>
                    <div class="button-group">
                        <button class="route-radar-seen" style="background-color: #2563EB; color: white; font-weight: bold; height: 70px; font-size: 1.2rem;">VISTO (Posponer 5 min)</button>
                        <button class="modify">Modificar</button>
                    </div>
                </div>
            `;
        } else {
            let detailsHtml = '';
            if (reminder.time) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Hora: ${formatTimeWithPeriod(reminder.time)}</p>`;
            if (reminder.date) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Fecha: ${formatDateDetailed(reminder.date)}</p>`;
            if (reminder.type === 'weekly' && reminder.repeatDays?.length > 0) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Repite: ${reminder.repeatDays.map(d => ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'][d]).join(', ')}</p>`;
            if (reminder.type === 'interval' && reminder.intervalDays) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Cada: ${reminder.intervalDays} días</p>`;
            if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Ubicación: Activada (Radio ${reminder.radiusMeters || DEFAULT_LOCATION_RADIUS}m)</p>`;
            }
            const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval';
            const showAdjustButton = isCyclic && reminder.time !== '00:01';
            const adjustButtonHtml = showAdjustButton ? `<button class="adjust-time-0001">Ajustar Hora 00:01 y Visto</button>` : '';
            const cyclicCancelButtonHtml = isCyclic ? `<button class="cancel-cyclic">Anular Ciclo</button>` : '';
            
            const buttonsHtml = `
                <div class="button-group">
                    <button class="cancel">Visto / Próximo</button>
                    <button class="postpone">Posponer</button>
                    <button class="modify">Modificar</button>
                    ${adjustButtonHtml}
                    ${cyclicCancelButtonHtml}
                </div>`;

            const mapPreviewHtml = (reminder.isLocationEnabled && reminder.locationCoordinates && !isNavigationMapActive) ? `
                <div class="reminder-map-preview-container">
                    <div id="map-preview-${reminder.id}" class="reminder-map-preview"></div>
                </div>
            ` : '';

            slideContentHtml = `
                <div class="reminder-slide-content">
                    <div class="reminder-content-scrollable">
                        <p class="reminder-text">${reminder.text}</p>
                        ${detailsHtml}
                    </div>
                    ${buttonsHtml} 
                </div>
                ${mapPreviewHtml}
            `;
        }
        
        slide.innerHTML = slideContentHtml;

        addSlideButtonListeners(slide, reminder);
        swiperContainer.appendChild(slide);

        if (reminder.isLocationEnabled && reminder.locationCoordinates && !isNavigationMapActive && !isRadarAlert) {
             const mapPreviewElement = slide.querySelector(`#map-preview-${reminder.id}`);
             if (mapPreviewElement) {
                setTimeout(() => {
                    try {
                        if (!document.getElementById(mapPreviewElement.id)) return;
                        if (previewMaps[reminder.id] && typeof previewMaps[reminder.id].remove === 'function') {
                           previewMaps[reminder.id].remove();
                        }
                        const isRadarType = reminder.text.toUpperCase().includes("RADAR") || reminder.excludeFromList;
                        const circleColor = isRadarType ? 'rgba(255, 165, 0, 0.2)' : 'blue';
                        
                        const map = new mapboxgl.Map({
                            container: mapPreviewElement,
                            style: 'mapbox://styles/mapbox/standard',
                            center: [reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude],
                            zoom: 14,
                            interactive: false,
                            attributionControl: false
                        });
                        
                        map.on('load', () => {
                            new mapboxgl.Marker().setLngLat([reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]).addTo(map);

                            const circlePolygon = turf.circle(
                                [reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude], 
                                reminder.radiusMeters || DEFAULT_LOCATION_RADIUS, 
                                { steps: 64, units: 'meters' }
                            );
                            
                            const circleSourceId = `map-preview-circle-${reminder.id}`;
                            map.addSource(circleSourceId, {
                                'type': 'geojson',
                                'data': circlePolygon
                            });
                            map.addLayer({
                                'id': circleSourceId,
                                'type': 'fill',
                                'source': circleSourceId,
                                'paint': {
                                    'fill-color': circleColor,
                                    'fill-opacity': isRadarType ? 0.2 : 0.05
                                }
                            });
                        });

                        map.resize();
                        previewMaps[reminder.id] = map;
                    } catch (mapError) {
                         if (mapPreviewElement) mapPreviewElement.innerHTML = `<p style="font-size:0.8rem; color: red; text-align: center; padding: 5px;">Error al cargar mapa</p>`;
                    }
                }, 100);
             }
        }
    });
    const count = overdueReminders.length;
    countSpan.textContent = count;
    if (count > 0) {
         if (currentNotificationSlideIndex >= count) {
             currentNotificationSlideIndex = 0;
         }
         swiperContainer.scrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
         updateReminderIndexDisplay();
         countHeader.classList.remove('hidden');
         if (count > 1) {
            countTextContainer.style.display = 'inline';
            swipeHint.style.display = 'block';
            document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = 'calc(85vh - 60px)');
         } else {
            countTextContainer.style.display = 'none';
            swipeHint.style.display = 'none';
            document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = '85vh');
         }
          hideAllButton.classList.remove('hidden');
          const newHideAllButton = hideAllButton.cloneNode(true);
          hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton);
          newHideAllButton.addEventListener('click', postponeAllVisibleReminders);
          
          realtimeSpeedUpdateInterval = setInterval(() => {
              if (!windowElement.classList.contains('visible')) {
                  clearInterval(realtimeSpeedUpdateInterval);
                  realtimeSpeedUpdateInterval = null;
                  return;
              }
              const carSpeed = Math.round(window.currentSpeedKmh || 0);
              overdueReminders.forEach(reminder => {
                  if(reminder.text.toUpperCase().includes("RADAR")) {
                      const speedDisplayElement = document.getElementById(`current-speed-display-${reminder.id}`);
                      if (speedDisplayElement) {
                          const radarSpeed = extractSpeedFromRadarText(reminder.text);
                          const speedExceeded = radarSpeed !== null && carSpeed > radarSpeed;
                          speedDisplayElement.textContent = `[Velocidad actual: ${carSpeed} Km/h]`;
                          speedDisplayElement.style.color = speedExceeded ? 'red' : '#333';
                      }
                  }
              });
          }, 500);

    } else {
        countHeader.classList.add('hidden');
        hideAllButton.classList.add('hidden');
        currentNotificationSlideIndex = 0;
    }
    windowElement.classList.add('visible');
    isUnifiedWindowVisibleByLogic = true;
    swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay);
    swiperContainer.addEventListener('scroll', updateReminderIndexDisplay);
}
    
    // ===================================================================
    // NOMBRE: getSavedLocations
    // RESUMEN: Obtiene las ubicaciones guardadas desde localStorage.
    function getSavedLocations() { try { const locations = localStorage.getItem(SAVED_LOCATIONS_KEY); return locations ? JSON.parse(locations) : Array(MAX_SAVED_LOCATIONS).fill(null); } catch (e) { return Array(MAX_SAVED_LOCATIONS).fill(null); } }
    
    // ===================================================================
    // NOMBRE: saveLocationsToCache
    // RESUMEN: Guarda el array de ubicaciones en localStorage.
    function saveLocationsToCache(locationsArray) { try { localStorage.setItem(SAVED_LOCATIONS_KEY, JSON.stringify(locationsArray));} catch (e) { showToast("Error al guardar ubicaciones.", "error"); } }
    
// ===================================================================
// NOMBRE: plotIntervalData 
// RESUMEN: Añade un nuevo punto de datos a la gráfica a intervalos regulares. La condición de ejecución se ha modificado para permitir que se ejecute tanto en modo Navegación como en modo Free Drive.
function plotIntervalData() {
    if (!isGraphingActive || !(isNavigating || isFreeDriveActive) || !navigationChart || !navigationStartTimeForStats || !navigationCurrentLocation) {
        return;
    }

    let currentAverageSpeed = 0;
    const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000;

    if (timeElapsedS > 0 && totalDistanceTravelledForStats > 0) {
        const avgSpeedMs = totalDistanceTravelledForStats / timeElapsedS;
        currentAverageSpeed = avgSpeedMs * 3.6;
    }
    
    if (currentAverageSpeed > 1) { 
        minAverageSpeedInTrip = Math.min(minAverageSpeedInTrip, currentAverageSpeed);
        maxAverageSpeedInTrip = Math.max(maxAverageSpeedInTrip, currentAverageSpeed);
        
        // AÑADIDO: Lógica de la ventana deslizante para limitar el tamaño de los arrays y evitar fugas de memoria.
        while (graphLabels.length >= maxGraphPoints) {
            graphLabels.shift();
            graphDataPoints.speed.shift();
            graphDataPoints.altitude.shift();
        }

        const timeLabel = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        graphLabels.push(timeLabel);
        graphDataPoints.speed.push(currentAverageSpeed);
    }
    
    const currentAltitude = navigationCurrentLocation.altitude || 0;
    
    // MODIFICADO: Asegurarse de que el array de altitud no crezca más que el de velocidad
    if (graphDataPoints.altitude.length < graphDataPoints.speed.length) {
        graphDataPoints.altitude.push(currentAltitude);
    }
    
    updateChartData();

    const isCurrentlyStopped = (window.currentSpeedKmh || 0) < 1;
    if (isCurrentlyStopped) {
        if (isCarStoppedForGraph) return; 
        isCarStoppedForGraph = true;
    } else {
        isCarStoppedForGraph = false;
    }
}    

// ===================================================================
// NOMBRE: updateChartData 
// RESUMEN: Actualiza los datos y la configuración de la gráfica de navegación, adaptando el título y contenido para el modo "Free Drive".
function updateChartData() {
    if (!navigationChart) return;
    const graphCard = document.getElementById('navigation-graph-card');
    const isEnlarged = graphCard ? graphCard.classList.contains('enlarged') : false;
    const valueStyle = "font-size: 1.2em; opacity: 1.0; line-height: 1.4; font-weight: bold; text-align: right; padding-right: 22px;";
    const etaColor = "#D29BFD";
    const avgColor = "yellow";
    const maxColor = "#FFA420";
    const minAvgLineColor = '#FFA500';
    const maxAvgLineColor = '#28a745';

    const mainDataset = navigationChart.data.datasets[0];
    const altitudeFillDataset = navigationChart.data.datasets[1];
    const referenceDataset = navigationChart.data.datasets[2];
    const minAvgSpeedDataset = navigationChart.data.datasets[3];
    const maxAvgSpeedDataset = navigationChart.data.datasets[4];
    const accumulatedAvgSpeedDataset = navigationChart.data.datasets[5];

    if (currentGraphMode === 'Desviación ETA') {
        navigationChart.options.scales.yPrimary.ticks.callback = function(value) { return Math.round(value) + ' km/h'; };
        
        mainDataset.borderColor = 'rgba(129, 216, 208, 0.6)'; 
        mainDataset.backgroundColor = 'rgba(37, 99, 235, 0.25)';
        mainDataset.fill = 'origin';
        mainDataset.pointRadius = 0;

        altitudeFillDataset.hidden = true; 
        altitudeFillDataset.data = []; 
        
        const currentAvgSpeed = window.averageSpeedKmh || 0;
        
        const valuesToShow = [graphExpectedAvgSpeed];
        if (currentAvgSpeed > 1) valuesToShow.push(currentAvgSpeed);
        if (maxAverageSpeedInTrip > -Infinity) valuesToShow.push(maxAverageSpeedInTrip);
        if (minAverageSpeedInTrip < Infinity) valuesToShow.push(minAverageSpeedInTrip);
        
        const maxVisibleValue = Math.max(...valuesToShow);
        const minVisibleValue = Math.min(...valuesToShow);

        const newYMax = maxVisibleValue + 3;
        const newYMin = Math.max(0, minVisibleValue - 3);
        
        navigationChart.options.scales.yPrimary.min = newYMin;
        navigationChart.options.scales.yPrimary.max = newYMax;

        const yAxisRange = newYMax - newYMin;
        const targetTickCount = isEnlarged ? 20 : 10;
        let stepSize = yAxisRange > 0 ? yAxisRange / targetTickCount : 1;
        const niceIntervals = [0.1, 0.2, 0.5, 1, 2, 5];
        let bestFitStep = niceIntervals[niceIntervals.length - 1];
        for (const interval of niceIntervals) {
            if (stepSize <= interval) {
                bestFitStep = interval;
                break;
            }
        }
        navigationChart.options.scales.yPrimary.ticks.stepSize = bestFitStep;

        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            const avgVal = (window.averageSpeedKmh || 0).toFixed(1);
            const maxVal = (maxSpeedDuringTrip || 0).toFixed(1);
            
            if (isFreeDriveActive) {
                graphTitleElement.innerHTML = `
                    <span style="font-size: 0.9em;">VELOCIDAD</span> 
                    <small style="${valueStyle}">
                        <span style="color:${avgColor};">Med: ${avgVal}</span> 
                        <span style="color:${maxColor};">   |  Máx: ${maxVal} Km/h</span>
                    </small>`;
                referenceDataset.hidden = true;
            } else {
                const etaVal = (graphExpectedAvgSpeed || 0).toFixed(1);
                graphTitleElement.innerHTML = `
                    <span style="font-size: 0.9em;">ETA</span> 
                    <small style="${valueStyle}">
                        <span style="color:${etaColor};">ETA: ${etaVal}</span> 
                        <span style="color:${avgColor};">   |  Med: ${avgVal}</span> 
                        <span style="color:${maxColor};">   |  Máx: ${maxVal} Km/h</span>
                    </small>`;
                referenceDataset.hidden = false;
            }
        }
        
        mainDataset.data = graphDataPoints.speed;
        mainDataset.label = 'Velocidad Media Real';
        
        referenceDataset.data = graphLabels.map(() => graphExpectedAvgSpeed);
        referenceDataset.label = 'Media ETA Inicial';
        
        minAvgSpeedDataset.data = graphLabels.map(() => minAverageSpeedInTrip === Infinity ? null : minAverageSpeedInTrip);
        minAvgSpeedDataset.label = 'Media Mínima';
        minAvgSpeedDataset.borderColor = minAvgLineColor;
        
        maxAvgSpeedDataset.data = graphLabels.map(() => maxAverageSpeedInTrip === -Infinity ? null : maxAverageSpeedInTrip);
        maxAvgSpeedDataset.label = 'Media Máxima';
        maxAvgSpeedDataset.borderColor = maxAvgLineColor;

        accumulatedAvgSpeedDataset.data = graphLabels.map(() => window.averageSpeedKmh);
        accumulatedAvgSpeedDataset.hidden = false;

    } else if (currentGraphMode === 'Altitud') {
        accumulatedAvgSpeedDataset.hidden = true;
        accumulatedAvgSpeedDataset.data = [];

        navigationChart.options.scales.yPrimary.ticks.callback = function(value) { return Math.round(value) + ' m'; };
        navigationChart.options.scales.yPrimary.max = undefined;
        navigationChart.options.scales.yPrimary.min = undefined;
        
        mainDataset.borderColor = 'rgba(129, 216, 208, 1)'; 
        mainDataset.backgroundColor = 'transparent';
        mainDataset.fill = 'origin' ;
        mainDataset.pointRadius = 0;

        altitudeFillDataset.data = graphDataPoints.altitude;
        altitudeFillDataset.hidden = false;
        
        const altitudeValues = graphDataPoints.altitude.length > 0 ? graphDataPoints.altitude : [0];
        const minAlt = Math.min(...altitudeValues);
        const maxAlt = Math.max(...altitudeValues);
        const altRange = maxAlt - minAlt;
        const targetTickCountAlt = isEnlarged ? 10 : 5;

        if (altRange > 0) {
            const rawStepAlt = altRange / targetTickCountAlt;
            const niceIntervalsAlt = [2, 5, 10, 20, 50, 100];
            let stepSizeAlt = niceIntervalsAlt[niceIntervalsAlt.length - 1];
            for (const interval of niceIntervalsAlt) { if(rawStepAlt <= interval) { stepSizeAlt = interval; break; } }
            navigationChart.options.scales.yPrimary.ticks.stepSize = stepSizeAlt;
        } else {
             navigationChart.options.scales.yPrimary.ticks.stepSize = undefined;
        }
        
        const altitudePoints = graphDataPoints.altitude;
        const avgAltitudeValue = altitudePoints.length > 0 ? altitudePoints.reduce((a, b) => a + b, 0) / altitudePoints.length : 0;
        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            const maxAltVal = (maxAltitudeDuringTrip !== -Infinity ? maxAltitudeDuringTrip : 0).toFixed(0);
            const avgAltVal = avgAltitudeValue.toFixed(0);
            const minAltVal = (minAltitudeDuringTrip !== Infinity ? minAltitudeDuringTrip : 0).toFixed(0);
            graphTitleElement.innerHTML = `
                <span style="font-size: 0.7em;">DESNIVEL RUTA</span>
                <small style="${valueStyle}">
                    <span style="color:${maxColor};">Máx: ${maxAltVal}</span> 
                    <span style="color:${etaColor};">   |  Med: ${avgAltVal}</span> 
                    <span style="color:${avgColor};">   |  Mín: ${minAltVal}m</span>
                </small>`;
        }
        
        mainDataset.data = graphDataPoints.altitude;
        mainDataset.label = 'Altitud';
        
        referenceDataset.data = graphLabels.map(() => avgAltitudeValue);
        referenceDataset.label = 'Media';
        
        minAvgSpeedDataset.data = graphLabels.map(() => minAltitudeDuringTrip !== Infinity ? minAltitudeDuringTrip : null);
        minAvgSpeedDataset.label = 'Mínima';
        minAvgSpeedDataset.borderColor = '#FFA500';
        
        maxAvgSpeedDataset.data = graphLabels.map(() => maxAltitudeDuringTrip !== -Infinity ? maxAltitudeDuringTrip : null);
        maxAvgSpeedDataset.label = 'Máxima';
        maxAvgSpeedDataset.borderColor = '#28a745';
    }
    navigationChart.data.labels = graphLabels; 
    navigationChart.update('none');
}    
// ===================================================================
// NOMBRE: initializeNavigationGraph
// RESUMEN: Inicializa el gráfico de Chart.js para la navegación.
function initializeNavigationGraph() {
    const graphCard = document.getElementById('navigation-graph-card');
    const graphContainer = document.getElementById('navigation-graph-container');
    const graphTitleElement = document.getElementById('navigation-graph-title');
    if (!graphCard || !graphContainer || !graphTitleElement || (!isNavigating && !isFreeDriveActive) || currentGraphMode === 'Gráfica off') {
        if (graphCard) graphCard.classList.add('hidden');
        if (navigationChart) { navigationChart.destroy(); navigationChart = null; }
        return;
    }
    graphCard.classList.remove('hidden');
    const compassElement = document.querySelector('.map-control-orientation-altitude');
    graphCard.style.height = compassElement ? (compassElement.offsetHeight + 'px') : '157px';
    isCarStoppedForGraph = false;
    graphDataPoints = { speed: [], altitude: [] };
    graphLabels = [];
    minAverageSpeedInTrip = Infinity;
    maxAverageSpeedInTrip = -Infinity;
    graphPlotState = { 
        lastPlotTime: Date.now(), 
        lastPlotCoords: navigationCurrentLocation ? { ...navigationCurrentLocation } : null 
    };
    if (navigationChart) {
        navigationChart.destroy();
        navigationChart = null;
    }
    isGraphingActive = true;
    const ctx = document.getElementById('navigation-chart')?.getContext('2d');
    if (!ctx || !ctx.canvas) {
        showToast("Error crítico: Canvas para gráfica no encontrado.", "error");
        if (graphCard) graphCard.classList.add('hidden');
        return;
    }
    
    const initialRouteDurationSec = navigationCurrentRouteData?.routes?.[0]?.duration || 0;
    const initialRouteDistance = navigationCurrentRouteData?.routes?.[0]?.distance || 0;
    
    const graphWidth = ctx.canvas.clientWidth || 300;
    const pixelsPerPoint = 3;
    // MODIFICADO: Se actualiza la variable global en lugar de una local.
    maxGraphPoints = Math.floor(graphWidth / pixelsPerPoint) || 150;
    
    if (isNavigating && initialRouteDurationSec > 0 && maxGraphPoints > 0) {
        const idealIntervalMs = (initialRouteDurationSec / maxGraphPoints) * 1000;
        graphIntervalDuration = Math.max(5000, idealIntervalMs); 
    } else if (isFreeDriveActive) {
        graphIntervalDuration = 10000;
    } else {
        graphIntervalDuration = 30000;
    }

    graphExpectedAvgSpeed = (initialRouteDurationSec > 0 && initialRouteDistance > 0) ? (initialRouteDistance / initialRouteDurationSec) * 3.6 : 0;
    
    navigationChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'Velocidad Media Real', data: [],
                    borderColor: 'rgba(75, 192, 192, 0.5)',
                    backgroundColor: 'rgba(75, 192, 192, 0.25)',
                    tension: 0.1, yAxisID: 'yPrimary', 
                    pointRadius: 0, 
                    order: 3, 
                    fill: 'origin'
                },
                {
                    label: 'Área Desnivel', data: [],
                    borderColor: 'rgba(255, 165, 0, 0.5)', 
                    backgroundColor: 'rgba(255, 165, 0, 0.3)', 
                    fill: 'origin',
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: true, order: 4
                },
                {
                    label: 'Media ETA Inicial', data: [], 
                    borderColor: '#dfcae1', 
                    borderWidth: 3,          
                    fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 2
                },
                {
                    label: 'Media Mínima', data: [], borderColor: '#FFA500',
                    borderWidth: 1.5, borderDash: [5, 5], fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 1
                },
                {
                    label: 'Media Máxima', data: [], borderColor: '#28a745',
                    borderWidth: 1.5, borderDash: [5, 5], fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 0
                },
                {
                    label: 'Media Acumulada Real', data: [], 
                    borderColor: '#F9e4b7', 
                    borderWidth: 3,        
                    fill: false,
                    pointRadius: 0, 
                    yAxisID: 'yPrimary', 
                    hidden: false, 
                    order: 2
                }
            ]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            layout: {
                padding: { top: 5, bottom: 2, left: 0, right: 2 }
            },
            scales: {
                x: {
                    type: 'category',
                    ticks: {
                        display: false 
                    },
                    grid: {
                        drawOnChartArea: false
                    }
                },
                yPrimary: {
                    type: 'linear', position: 'left',
                    min: Math.max(0, graphExpectedAvgSpeed - 3),
                    max: graphExpectedAvgSpeed + 3,
                    ticks: { color: 'white', font: { size: 11 }, callback: (v) => Math.round(Number(v)).toString(), stepSize: 0.2 },
                    grid: { color: 'rgba(255,255,255,0.1)' }, title: { display: false }
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: { 
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) { label += ': '; }
                            if (context.parsed.y !== null) {
                                label += context.parsed.y.toFixed(1);
                                if (currentGraphMode === 'Desviación ETA') label += ' km/h';
                                else if (currentGraphMode === 'Altitud') label += ' m';
                            }
                            return label;
                        }
                    }
                 }
            },
            animation: { duration: 250 }
        }
    });
    startGraphIntervalTimer();
    updateNavigationGraphVisibilityAndMode();
}
    

// ===================================================================
// NOMBRE: startAutomatedRouteSimulation (VERSIÓN FINAL CON REINICIO CORRECTO)
// RESUMEN: Inicia o reanuda la simulación. Gestiona correctamente el
//          reinicio del progreso al reanudar tras un desvío.
// ===================================================================
function startAutomatedRouteSimulation(speedKmph, continueFromCurrentState = false) {
    if (!isSimulatingGpsLocation) {
        isSimulatingGpsLocation = true;
        if (locationWatchId !== null && navigator.geolocation) {
            navigator.geolocation.clearWatch(locationWatchId);
            locationWatchId = null;
        }
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) {
            simulateGpsButton.classList.add('active-simulate-gps-mode');
            simulateGpsButton.title = "Desactivar Simulación GPS (Volver a GPS Real)";
        }
    }
    
    if (automatedSimulationIntervalId) {
        clearInterval(automatedSimulationIntervalId);
        automatedSimulationIntervalId = null;
    }
    
    simulationSpeedKmph = speedKmph;
    currentSimulationSpeedKmph = speedKmph;
    
    const route = navigationCurrentRouteData?.routes?.[0];
    if (!route) {
        showToast("No hay ruta válida para iniciar la simulación.", "error");
        stopAutomatedRouteSimulation();
        return;
    }
    
    if (continueFromCurrentState) {
        const carPointTurf = turf.point([simulatedGpsLocation.longitude, simulatedGpsLocation.latitude]);
        const routeLineStringTurf = turf.lineString(route.geometry.coordinates);
        const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
        const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
        
        simulatedDistanceAlongRoute = turf.length(lineSliceToNearestTurf, { units: 'meters' });
        
    } else {
        wasSimulatingBeforeRecalc = false;
        simulatedDistanceAlongRoute = 0;
        navigationStartTimeForStats = null;
        totalDistanceTravelledForStats = 0;
        maxSpeedDuringTrip = 0;

        const startWaypoint = navigationWaypoints.find(wp => wp.type === 'S' || wp.isRecalculatedStart) || navigationWaypoints[0];
        lastPositionForStats = { latitude: startWaypoint.lat, longitude: startWaypoint.lng };
        
        let initialHeading = 0;
        if (route.geometry.coordinates.length >= 2) {
            initialHeading = turf.bearing(turf.point(route.geometry.coordinates[0]), turf.point(route.geometry.coordinates[1]));
            if (initialHeading < 0) initialHeading += 360;
        }
        simulatedGpsLocation = { latitude: startWaypoint.lat, longitude: startWaypoint.lng, accuracy: 5, heading: initialHeading, altitude: (navigationCurrentLocation?.altitude) ?? 0, speed: 0 };
        maxSpeedCoordinates = { lat: startWaypoint.lat, lng: startWaypoint.lng };
        processSimulatedGpsPosition(true);
        showToast(`Simulación automática de ruta iniciada a ${speedKmph.toFixed(0)} km/h.`, "info");
    }
    
    lastCarDistanceAlongRouteForNavLogic = simulatedDistanceAlongRoute;
    setNavigationMapClickHandler(); 

    let simulationStepIndex = 0;
    let simulationLegIndex = 0;
    
    let tempDistance = 0;
    for (let i = 0; i < route.legs.length; i++) {
        let legFound = false;
        for (let j = 0; j < route.legs[i].steps.length; j++) {
            tempDistance += route.legs[i].steps[j].distance;
            if (simulatedDistanceAlongRoute < tempDistance) {
                simulationLegIndex = i;
                simulationStepIndex = j;
                legFound = true;
                break;
            }
        }
        if (legFound) break;
    }
    let distanceToEndOfCurrentStep = calculateDistanceToEndOfStep(route, simulationLegIndex, simulationStepIndex);

    automatedSimulationIntervalId = setInterval(() => {
        const currentRouteForInterval = navigationCurrentRouteData?.routes?.[0];
        if (!currentRouteForInterval) {
            stopAutomatedRouteSimulationInternal();
            return;
        }

        const totalRouteDistance = currentRouteForInterval.distance;
        const speedMps = (currentSimulationSpeedKmph * 1000) / 3600;
        const distanceIncrement = speedMps * (SIMULATION_TICK_INTERVAL_MS / 1000);
        simulatedDistanceAlongRoute += distanceIncrement;

        if (navigationStartTimeForStats) {
            totalDistanceTravelledForStats += distanceIncrement;
        }
        
        if (simulatedDistanceAlongRoute > distanceToEndOfCurrentStep) {
            simulationStepIndex++;
            if (currentRouteForInterval.legs[simulationLegIndex] && simulationStepIndex >= currentRouteForInterval.legs[simulationLegIndex].steps.length) {
                simulationStepIndex = 0;
                simulationLegIndex++;
            }
            if (simulationLegIndex < currentRouteForInterval.legs.length && currentRouteForInterval.legs[simulationLegIndex]) {
                const currentStep = currentRouteForInterval.legs[simulationLegIndex].steps[simulationStepIndex];
                if (currentStep) { 
                    const multiplier = getRandomSpeedMultiplierForManeuver(currentStep.maneuver);
                    currentSimulationSpeedKmph = Math.max(20, Math.min(5000, simulationSpeedKmph * (1 + multiplier)));
                    distanceToEndOfCurrentStep = calculateDistanceToEndOfStep(currentRouteForInterval, simulationLegIndex, simulationStepIndex);
                }
            }
        }
      
        if (simulatedDistanceAlongRoute >= totalRouteDistance) {
            stopAutomatedRouteSimulationInternal();
            const endPointCoords = currentRouteForInterval.geometry.coordinates[currentRouteForInterval.geometry.coordinates.length - 1];
            simulatedGpsLocation = {
                ...simulatedGpsLocation,
                latitude: endPointCoords[1],
                longitude: endPointCoords[0],
                speed: 0
            };
            processSimulatedGpsPosition(true);
            showToast("Simulación de ruta completada. Modo simulación por clic activo.", "success");
            const mapDiv = document.getElementById('reminders-location-map-div');
            if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode'); 
            if (isNavigating || (!isNavigating && navigationWaypoints.length > 0)) {
                 showArrivalStatsModal();
            }
            setNavigationMapClickHandler();
            return;
        }
        const turfLine = turf.lineString(currentRouteForInterval.geometry.coordinates);
        const pointOnLine = turf.along(turfLine, simulatedDistanceAlongRoute / 1000, { units: 'kilometers' });
        if (pointOnLine?.geometry?.coordinates) {
            const [lng, lat] = pointOnLine.geometry.coordinates;
            let headingSim = 0;
            const lookAheadDistance = Math.min(distanceIncrement * 2, totalRouteDistance - simulatedDistanceAlongRoute);
            if (simulatedDistanceAlongRoute + lookAheadDistance <= totalRouteDistance && lookAheadDistance > 0) {
                const nextPointOnLine = turf.along(turfLine, (simulatedDistanceAlongRoute + lookAheadDistance) / 1000, { units: 'kilometers' });
                if (nextPointOnLine?.geometry?.coordinates) {
                    headingSim = turf.bearing(pointOnLine, nextPointOnLine);
                    if (headingSim < 0) headingSim += 360;
                }
            } else {
                headingSim = simulatedGpsLocation?.heading || 0;
            }
            simulatedGpsLocation = {
                latitude: lat,
                longitude: lng,
                accuracy: 5,
                heading: headingSim,
                altitude: (navigationCurrentLocation?.altitude) ?? 0,
                speed: speedMps
            };
            processSimulatedGpsPosition(false);
        }
    }, SIMULATION_TICK_INTERVAL_MS);
}


// ===================================================================
// NOMBRE: handleLoadOrDeleteRouteClick 
// RESUMEN: Llama a la función de reseteo completa antes de realizar otras acciones.
function handleLoadOrDeleteRouteClick(button) {
    clearRecoveryFlag();
    clearAlternativeRoutesDisplay(); 
    resetNavigationState();

    if (isSimulatingGpsLocation) {
        stopAutomatedRouteSimulation();
    }
    
    if (isFreeDrivePaused) {
        handleFreeDriveCancellation();
    }

    clearAllWaypointMarkersFromMap();
    if (navigationMapInstance && navigationMapInstance.getSource('route')) {
        navigationMapInstance.getSource('route').setData({ type: 'FeatureCollection', features: [] });
    }
    
    if (button) {
       }
    
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}    

// ===================================================================
// NOMBRE: showLoadRouteModal 
// RESUMEN: Muestra el modal de carga con una sección superior para rutas/destinos recientes,
function showLoadRouteModal() {
    resetNavigationState();

    const existingOverlay = document.getElementById('route-modal-load-overlay');
    if (existingOverlay) existingOverlay.remove();

    const overlay = document.createElement('div');
    overlay.id = 'route-modal-load-overlay';
    overlay.className = 'route-modal-overlay';

    const modalContent = document.createElement('div');
    modalContent.id = 'saved-routes-modal';
    modalContent.className = 'route-modal-container';

    modalContent.innerHTML = `
        <div class="route-modal-header">
             <div class="route-modal-title-card">
                 <span class="route-modal-title">Cargar Destinos o Rutas</span>
             </div>
        </div>
        <div class="route-modal-body">
            <div class="route-modal-controls">
                <input type="text" id="filter-saved-routes" class="route-filter-input" placeholder="FILTRAR DESTINOS Y RUTAS...">
                <button id="clear-filter-button" class="clear-input-btn" title="Limpiar filtro" style="display: none;">×</button>
            </div>
            
            <h3 class="routes-section-title">Recientes</h3>
            <div id="recents-container" class="route-scroll-container" style="max-height: 180px; flex-grow: 0; margin-bottom: 15px;">
                <ul id="recent-items-list" class="route-list"></ul>
            </div>
            
            <div class="route-modal-tabs">
                <button class="route-modal-tab active" data-tab="destinos">DESTINOS GUARDADOS</button>
                <button class="route-modal-tab" data-tab="rutas">RUTAS GUARDADAS</button>
            </div>

            <div id="routes-container" class="route-scroll-container">
                <div class="route-modal-panel active" id="panel-destinos">
                    <ul id="saved-destinations-list" class="route-list"></ul>
                </div>
                <div class="route-modal-panel" id="panel-rutas">
                    <ul id="saved-routes-list" class="route-list"></ul>
                </div>
            </div>
        </div>
        <div class="route-modal-footer">
            <button id="close-saved-routes-modal" class="btn-modal-action-secondary" style="flex: 1;">Cerrar <span class="button-countdown-timer unified-countdown-style"></span></button>
        </div>
    `;
    
    overlay.appendChild(modalContent);
    document.body.appendChild(overlay);

    const closeButton = modalContent.querySelector('#close-saved-routes-modal');
    const filterInput = modalContent.querySelector('#filter-saved-routes');
    const clearFilterBtn = modalContent.querySelector('#clear-filter-button');
    const tabs = modalContent.querySelectorAll('.route-modal-tab');
    const panels = modalContent.querySelectorAll('.route-modal-panel');

    const closeHandler = () => {
        clearModalAutoCloseTimer(overlay, closeButton, 'saved-routes-modal');
        if (overlay.parentNode) overlay.remove();
    };
    closeButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(overlay, closeButton, 'saved-routes-modal', 45000);

    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            tabs.forEach(t => t.classList.remove('active'));
            panels.forEach(p => p.classList.remove('active'));
            tab.classList.add('active');
            document.getElementById(`panel-${tab.dataset.tab}`).classList.add('active');
        });
    });
    
    const renderRouteListItem = (route, listElement, isRecent) => {
        const li = document.createElement('li');
        li.className = 'route-list-item';
        const showReturnButton = route.waypoints.length > 1;
        const buttonType = isRecent ? 'Quitar' : 'Borrar';

        li.innerHTML = `
            <span class="route-name">${route.name}</span>
            <div class="route-actions">
                ${showReturnButton ? '<button class="btn-return" title="Cargar ruta en sentido inverso">Vuelta</button>' : ''}
                <button class="btn-share" title="Compartir coordenadas">Compartir</button> 
                <button class="btn-delete" title="${isRecent ? 'Quitar del historial' : 'Borrar permanentemente'}">${buttonType}</button>
            </div>
        `;
        
        li.querySelector('.route-name').addEventListener('click', () => {
            loadRouteByName(route.name, true);
            addRouteToRecents(route);
            closeHandler();
        });

        li.querySelector('.btn-share').addEventListener('click', (e) => {
             e.stopPropagation();
             if (route.waypoints.length === 1) {
                 const dest = route.waypoints[0];
                 handleSendToTeslaClick(dest.lat, dest.lng, dest.address);
             } else {
                 closeHandler();
                 showShareStageModal(route);
             }
        });

        if (showReturnButton) {
            li.querySelector('.btn-return').addEventListener('click', (e) => {
                e.stopPropagation();
                getCurrentLocation(
                    async (currentPos) => {
                        const originalWaypoints = [...route.waypoints];
                        const originalStart = originalWaypoints.shift();
                        if (originalWaypoints.length > 0) { originalWaypoints.pop(); }
                        const intermediateReversed = originalWaypoints.reverse();
                        let returnWaypoints = [{ lat: currentPos.latitude, lng: currentPos.longitude, address: 'Posición Actual (GPS)'}, ...intermediateReversed, originalStart];
                        const returnRouteObject = { name: `VUELTA: ${route.name}`, waypoints: returnWaypoints };
                        loadRouteFromObject(returnRouteObject, true);
                        addRouteToRecents(returnRouteObject);
                        closeHandler();
                    },
                    (errorMsg) => { showToast(`Error al obtener ubicación: ${errorMsg}`, "error"); }
                );
            });
        }
        
        li.querySelector('.btn-delete').addEventListener('click', (e) => {
            e.stopPropagation();
            if (isRecent) {
                let recentRoutes = JSON.parse(localStorage.getItem('boardinggate_recent_routes') || "[]");
                recentRoutes = recentRoutes.filter(r => r.name !== route.name);
                localStorage.setItem('boardinggate_recent_routes', JSON.stringify(recentRoutes));
            } else {
                let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
                savedRoutes = savedRoutes.filter(r => r.name !== route.name);
                localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes));
                markCacheAsDirty();
                showToast(`"${route.name}" borrado`, "info");
            }
            displayRoutes(); 
        });
        listElement.appendChild(li);
    };
    
    const displayRoutes = () => {
        const filterText = filterInput.value.toUpperCase().trim();
        clearFilterBtn.style.display = filterText ? 'block' : 'none';

        let recentRoutes = JSON.parse(localStorage.getItem('boardinggate_recent_routes') || "[]");
        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        savedRoutes.sort((a, b) => new Date(b.createdAt || 0).getTime() - new Date(a.createdAt || 0).getTime());

        const recentItemsList = document.getElementById('recent-items-list');
        const recentsTitle = recentItemsList.parentElement.previousElementSibling;
        recentItemsList.innerHTML = '';
        const filteredRecents = recentRoutes.filter(r => r.name.toUpperCase().includes(filterText));
        if (filteredRecents.length > 0) {
            recentsTitle.style.display = 'block';
            filteredRecents.forEach(route => renderRouteListItem(route, recentItemsList, true));
        } else {
            recentsTitle.style.display = 'none';
        }
        
        const recentRouteNames = recentRoutes.map(r => r.name);
        
        const savedDestinationsList = document.getElementById('saved-destinations-list');
        savedDestinationsList.innerHTML = '';
        
        const savedDestinations = savedRoutes.filter(r => {
            const isSingleDestination = r.waypoints.length === 1 || (r.waypoints.length === 2 && (r.waypoints[0].type === 'S' || r.waypoints[0].isRecalculatedStart));
            return isSingleDestination && !recentRouteNames.includes(r.name) && r.name.toUpperCase().includes(filterText);
        });
   
        if (savedDestinations.length > 0) {
            savedDestinations.forEach(route => renderRouteListItem(route, savedDestinationsList, false));
        } else {
            savedDestinationsList.innerHTML = `<li class="route-list-empty">No hay destinos guardados que coincidan.</li>`;
        }

        const savedRoutesList = document.getElementById('saved-routes-list');
        savedRoutesList.innerHTML = '';
        
        const savedMultiStage = savedRoutes.filter(r => {
            const isMultiStageRoute = r.waypoints.length > 2;
            return isMultiStageRoute && !recentRouteNames.includes(r.name) && r.name.toUpperCase().includes(filterText);
        });
        
        if (savedMultiStage.length > 0) {
            savedMultiStage.forEach(route => renderRouteListItem(route, savedRoutesList, false));
        } else {
            savedRoutesList.innerHTML = `<li class="route-list-empty">No hay rutas guardadas que coincidan.</li>`;
        }
    };

    filterInput.addEventListener('input', displayRoutes);
    clearFilterBtn.addEventListener('click', () => { filterInput.value = ''; displayRoutes(); });
    displayRoutes();
}    

// ===================================================================
// NOMBRE: closeNavigationMap (MODIFICADA - USA RESET CENTRAL)
// RESUMEN: Llama a la función de reseteo al cerrar el mapa para asegurar limpieza.
function closeNavigationMap(force = false) {
    clearRecoveryFlag();
    hideAddressSuggestionsModal();
    resetNavigationState(); 

    if (alertRefreshInterval) {
        clearInterval(alertRefreshInterval);
        alertRefreshInterval = null;
    }
    if (gpsHzMonitor.interval) {
        clearInterval(gpsHzMonitor.interval);
        gpsHzMonitor.interval = null;
    }
    
    if (manualZoomTimeout) { clearTimeout(manualZoomTimeout); manualZoomTimeout = null; }
    isManualZoomActive = false;
    if (markerAnimationState.animationFrameId) { cancelAnimationFrame(markerAnimationState.animationFrameId); markerAnimationState.animationFrameId = null; }
 
    const wasInDirectToMapModeSession = sessionStorage.getItem('isInDirectToMapMode') === 'true';
    const userPrefersDirectToNav = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
    if (wasInDirectToMapModeSession && userPrefersDirectToNav && !force) {
        sessionStorage.removeItem('isInDirectToMapMode');
        sessionStorage.setItem(TEMP_PREVENT_DIRECT_NAV_KEY, 'true');
        location.reload();
        return;
    }
    
    isNavigationMapActive = false;
    sessionStorage.removeItem('mapContext');
    if (locationWatchId !== null && navigator.geolocation) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
    if (gpsRetryTimeoutId) { clearTimeout(gpsRetryTimeoutId); gpsRetryTimeoutId = null; }
    gpsRetryAttempt = 0;
    
    const mapModalElement = document.getElementById('reminders-location-map-modal');
    if (mapModalElement) {
        mapModalElement.classList.add('map-modal-hidden');
    }
    
    const simModal = document.getElementById('simulation-modal');
    if (simModal && !simModal.classList.contains('hidden')) {
        if (simulationModalTimer) clearTimeout(simulationModalTimer);
        const simCloseBtn = simModal.querySelector('#close-simulation-modal');
        if (simCloseBtn) clearModalAutoCloseTimer(simModal, simCloseBtn, 'simulation-modal');
        simModal.classList.add('hidden');
        hideIntersectionPreviewMap();
    }

    sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
    hideUnifiedReminderWindow();
    
    if (directToNavOnLoad) {
        loadCustomData();
        loadSavedSettings();
        applyMainUISettings();
        directToNavOnLoad = false;
    }
 
    const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'block';
    const footer = document.querySelector('footer'); if (footer) footer.style.display = 'block';
    const noticesContainer = document.querySelector('.notices-icon-container'); if (noticesContainer) noticesContainer.style.display = 'flex';
    const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'flex');
    document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'block');
    const gridFilter = document.getElementById('grid-filter-container'); if (gridFilter) gridFilter.style.display = 'flex';
}
    
// ===================================================================
// NOMBRE: updateStartNavigationButtonState 
// RESUMEN: Actualiza la visibilidad de los botones de navegación. Iniciar y Simular GPS ahora siempre están visibles.
function updateStartNavigationButtonState() {
    const startNavButton = document.getElementById('start-navigation-button');
    const saveRouteButton = document.getElementById('save-route-button');
    const reorderBtn = document.getElementById('reorder-route-stages-button');
    const startNavImg = startNavButton ? startNavButton.querySelector('img') : null;
    const simulateBtn = document.getElementById('simulate-route-button');
    const deleteRouteBtn = document.getElementById('delete-current-route-button');
    const loadRouteBtn = document.getElementById('load-saved-route-button'); 
    const toggleSimulateGpsBtn = document.getElementById('toggle-simulate-gps-button');
    const graphCard = document.getElementById('navigation-graph-card');

    if (!startNavButton || !saveRouteButton || !reorderBtn || !simulateBtn || !loadRouteBtn || !deleteRouteBtn || !toggleSimulateGpsBtn || !graphCard) return;
    
    const hasEnoughWaypointsForRoute = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2;
    const hasRouteData = navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0];
    const canDisplayRoute = hasEnoughWaypointsForRoute && hasRouteData;

    startNavButton.classList.remove('hidden');
    if (toggleSimulateGpsBtn) toggleSimulateGpsBtn.style.display = 'inline-flex';

    if (isNavigating || isFreeDriveActive) {
        if(startNavImg) startNavImg.src = "PNG/TERMINARNAVEGACION.PNG";
    } else {
        if(startNavImg) startNavImg.src = "PNG/INICIARNAVEGACION.PNG";
    }
    saveRouteButton.classList.toggle('hidden', !(!isNavigating && canDisplayRoute));
    if (reorderBtn) reorderBtn.style.display = (!isNavigating && canDisplayRoute) ? 'inline-flex' : 'none';
    const canSimulate = (canDisplayRoute || (isNavigating && hasRouteData));
    if(simulateBtn) simulateBtn.style.display = canSimulate ? 'inline-flex' : 'none';
    
    if (deleteRouteBtn) {
        deleteRouteBtn.classList.remove('hidden');
    }
    if (loadRouteBtn) {
        loadRouteBtn.classList.remove('hidden');
    }
    const hasGraphData = graphDataPoints && (graphDataPoints.speed.length > 0 || graphDataPoints.altitude.length > 0);
    graphCard.classList.toggle('hidden', !hasGraphData || currentGraphMode === 'Gráfica off');
    
    if (!hasEnoughWaypointsForRoute && !isNavigating && !isFreeDriveActive) {
         if (navigationMapInstance && navigationMapInstance.getLayer('route')) {
             navigationMapInstance.removeLayer('route');
             navigationMapInstance.removeSource('route');
         }
         navigationRouteLayer = null;
         navigationCurrentRouteData = null;
         hideNavigationUI();
         hideMapInfoOverlay();
    }
    updateNavigationGraphVisibilityAndMode();
}
    
// ===================================================================
// NOMBRE: updateNavigationGraphVisibilityAndMode
// RESUMEN: Actualiza la visibilidad y modo de la gráfica de navegación.
function updateNavigationGraphVisibilityAndMode() {
    const graphCard = document.getElementById('navigation-graph-card');
    const graphContainer = document.getElementById('navigation-graph-container');
    const graphTitleElement = document.getElementById('navigation-graph-title');
    const compassControl = document.querySelector('.map-control-orientation-altitude');
    if (!graphCard || !graphContainer || !graphTitleElement) {
        return;
    }
    if (compassAndModeControl) {
        compassAndModeControl._updateGraphTitle();
    }
    const isEnlarged = graphCard.classList.contains('enlarged');
    if ((navigationCurrentRouteData || isFreeDriveActive) && currentGraphMode !== 'Gráfica off') {
        graphCard.classList.remove('hidden');
        if (!isEnlarged) {
            const compassHeight = compassControl ? compassControl.offsetHeight : 0;
            graphCard.style.height = compassHeight > 0 ? `${compassHeight}px` : '157px';
        }
        if (navigationChart) {
            updateChartData(); 
        } else if (isNavigating || isFreeDriveActive) {
            initializeNavigationGraph();
        }
    } else {
        graphCard.classList.add('hidden');
    }
}    
    
// ===================================================================
// NOMBRE: handlePickerMapClick 
// RESUMEN: Maneja el clic en el mapa selector de ubicaciones para fijar coordenadas.
function handlePickerMapClick(e, slotIndex) {
    const lngLat = e.lngLat;
    if (locationPickerMarker) {
        locationPickerMarker.setLngLat(lngLat);
    }
    if (!tempSavedLocations[slotIndex]) tempSavedLocations[slotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
    tempSavedLocations[slotIndex].lat = lngLat.lat;
    tempSavedLocations[slotIndex].lng = lngLat.lng;
}
    
    // ===================================================================
    // NOMBRE: updateNavigationButtonColor
    // RESUMEN: Actualiza el color del botón de inicio de navegación según el estado.
    function updateNavigationButtonColor() {
        const startNavButton = document.getElementById('start-navigation-button');
        if (startNavButton) {
            if (isNavigating) {
                startNavButton.style.setProperty('background-color', '#000000', 'important');
            } else {
                startNavButton.style.backgroundColor = 'white';
                startNavButton.style.boxShadow = '2px 3px 5px rgba(0,0,0,0.60)';
            }
        }
    }
    
// ===================================================================
// NOMBRE: showToast (MODIFICADA - AÑADIDO BOTÓN INTERACTIVO)
function showToast(message, type = 'info', duration = 3000, isErrorNotFound = false, toastId = null) {
    const uniqueToastId = toastId || 'toast-notification-element' + (type === 'debug' ? '-debug' : '') + `-${Date.now()}`;
    
    let currentTopOffset = 180;
    const toastSpacing = 10;
    
    if (type !== 'instructional') {
        activeToasts.forEach(activeToast => {
            const toastElement = document.getElementById(activeToast.id);
            if (toastElement) {
                 currentTopOffset += toastElement.offsetHeight + toastSpacing;
            }
        });
    }

    const existingToast = document.getElementById(uniqueToastId);
    if (existingToast && !toastId) {
        existingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
    } else if (existingToast && toastId) {
         existingToast.remove();
         activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
         currentTopOffset = 180;
         activeToasts.forEach(activeToast => {
            const toastElement = document.getElementById(activeToast.id);
            if (toastElement) {
                currentTopOffset += toastElement.offsetHeight + toastSpacing;
            }
         });
    }
    const toast = document.createElement('div');
    toast.id = uniqueToastId;
    toast.className = `toast-notification toast-${type}`;
    if (isErrorNotFound && type === 'error') {
        toast.classList.add('not-found');
    }
    const messageSpan = document.createElement('span');
    messageSpan.innerHTML = message.replace(/\n/g, '<br>');
    toast.appendChild(messageSpan);
    if (type === 'debug') {
        toast.style.top = 'auto';
        toast.style.bottom = '20px';
        toast.style.right = '20px';
        toast.style.left = 'auto';
        toast.style.transform = 'none';
        toast.style.maxWidth = 'calc(100% - 40px)';
        const closeButtonToast = document.createElement('button');
        closeButtonToast.textContent = 'Cerrar Info Debug';
        closeButtonToast.style.cssText = "display: block; margin-top: 10px; padding: 5px 10px; background-color: rgba(255,255,255,0.2); color: white; border: 1px solid white; border-radius: 3px; cursor: pointer;";
        closeButtonToast.onclick = () => {
            if (toast.parentNode) toast.parentNode.removeChild(toast);
             activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
        };
        toast.appendChild(closeButtonToast);
    }

    if (type === 'instructional') {
        const buttonContainer = document.createElement('div');
        buttonContainer.style.marginTop = '10px';
        const enteradoButton = document.createElement('button');
        enteradoButton.textContent = 'ENTERADO';
        enteradoButton.style.cssText = `
            background-color: rgba(0,0,0,0.3); color: white; border: 1px solid white; 
            padding: 5px 10px; border-radius: 5px; font-weight: bold; cursor: pointer;
        `;
        
        const closeToast = () => {
            if (toast.classList.contains('show')) {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => {
                    if (toast.parentNode) toast.parentNode.removeChild(toast);
                    activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
                }, { once: true });
            } else {
                if (toast.parentNode) toast.parentNode.removeChild(toast);
                activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
            }
        };

        enteradoButton.addEventListener('click', closeToast);
        buttonContainer.appendChild(enteradoButton);
        toast.appendChild(buttonContainer);
        
        toast.style.top = '25px';
        toast.style.right = '15px';
        
    } else {
        toast.style.top = `${currentTopOffset}px`;
    }

    document.body.appendChild(toast);
    activeToasts.push({ id: uniqueToastId, element: toast });
    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            toast.classList.add('show');
        });
    });
    if (duration > 0 && type !== 'debug') {
        setTimeout(() => {
            const toastElement = document.getElementById(uniqueToastId);
            if (toastElement && toastElement.classList.contains('show')) {
                toastElement.classList.remove('show');
                toastElement.addEventListener('transitionend', () => {
                     if (toastElement.parentNode) { toastElement.parentNode.removeChild(toastElement); }
                     activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
                }, { once: true });
            } else if (toastElement) {
                 if (toastElement.parentNode) { toastElement.parentNode.removeChild(toastElement); }
                 activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
            }
        }, duration);
    }
}    
// ===================================================================
// NOMBRE: toggleEnlargedGraph
// RESUMEN: Amplía o reduce la gráfica de navegación.
function toggleEnlargedGraph() {
    const graphCard = document.getElementById('navigation-graph-card');
    const enlargeButton = document.getElementById('enlarge-graph-button');
    const compassControlContainer = document.querySelector('.map-control-orientation-altitude');
    const mapModal = document.getElementById('reminders-location-map-modal');
    if (!graphCard || !enlargeButton || !compassControlContainer || !mapModal) return;
    const isCurrentlyEnlarged = graphCard.classList.contains('enlarged');
    if (!isCurrentlyEnlarged) {
        graphCard.classList.add('enlarged');
        const compassRect = compassControlContainer.getBoundingClientRect();
        const fixedWidth = 995; 
        const fixedHeight = 600; 
        const newLeft = compassRect.left;
        const distanceFromBottom = window.innerHeight - compassRect.bottom;
        const newBottom = distanceFromBottom;
        graphCard.style.left = `${newLeft}px`;
        graphCard.style.bottom = `${newBottom}px`;
        graphCard.style.width = `${fixedWidth}px`;
        graphCard.style.height = `${fixedHeight}px`;
        enlargeButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        `;
        enlargeButton.title = 'Reducir gráfica';
    } else {
        graphCard.classList.remove('enlarged');
        graphCard.style.left = '';
        graphCard.style.bottom = '';
        graphCard.style.width = '';
        graphCard.style.height = '';
        graphCard.style.top = '';
        graphCard.style.right = '';
        graphCard.style.transform = '';
        enlargeButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="11" y1="8" x2="11" y2="14"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        `;
        enlargeButton.title = 'Ampliar gráfica';
    }
    if (navigationChart) {
        updateChartData(); 
        setTimeout(() => {
            navigationChart.resize();
        }, 200);
    }
    updateNavigationGraphVisibilityAndMode();    
}

// ===================================================================
// NOMBRE: setMapImmersiveMode (NUEVA FUNCIÓN)
// RESUMEN: Activa o desactiva el modo inmersivo del mapa de forma explícita.
function setMapImmersiveMode(activate) {
    if (isMapImmersiveModeActive === activate) return;

    isMapImmersiveModeActive = activate;
    const mapModal = document.getElementById('reminders-location-map-modal');
    if (mapModal) {
        mapModal.classList.toggle('immersive-mode-active', isMapImmersiveModeActive);
        
        if (!isMapImmersiveModeActive) {
            progressBarForceShowUntil = Date.now() + 20000;
            const progressBar = document.getElementById('navigation-bottom-progress-bar');
            if (progressBar) {
                progressBar.classList.remove('progress-bar-auto-hidden');
            }
        }
        
        if (navigationMapInstance) {
            setTimeout(() => {
                try {
                    navigationMapInstance.resize();
                } catch(e) { console.error("Error al redimensionar mapa en setMapImmersiveMode:", e); }
            }, 350);
        }
    }
}


/**============================================================
 * Pausa la ejecución durante un número determinado de milisegundos.
 * @param {number} ms - El tiempo de espera en milisegundos.
 * @returns {Promise<void>}
 */
function wait(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}    
// VERSIÓN PROPUESTA (Gestiona terreno y niebla de forma segura y atómica)
async function configureMapAtmosphere() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
        return; // Salida segura si el mapa no está listo.
    }

    const currentMode = mapViewMode || localStorage.getItem(MAP_VIEW_MODE_KEY) || 'relief';

    if (currentMode === 'relief' || currentMode === 'perspective') {
        
        if (!navigationMapInstance.getSource('mapbox-dem')) {
            navigationMapInstance.addSource('mapbox-dem', {
                'type': 'raster-dem',
                'url': 'mapbox://mapbox.terrain-rgb',
                'tileSize': 512,
                'maxzoom': 14
            });

            await new Promise(resolve => {
                const onSourceData = (e) => {
                    if (e.sourceId === 'mapbox-dem' && e.isSourceLoaded) {
                        navigationMapInstance.off('sourcedata', onSourceData);
                        resolve();
                    }
                };
                navigationMapInstance.on('sourcedata', onSourceData);
            });
        }
        
        await wait(500);

        const exaggeration = (currentMode === 'relief') ? mapTerrainExaggeration : 0.0;
        navigationMapInstance.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': exaggeration });
        
        navigationMapInstance.setFog({
            'range': [0.9, 10], 'color': '#d8e2e8', 'horizon-blend': 0.1,
            'high-color': '#58636B', 'space-color': '#B3E3FF', 'star-intensity': 0.15
        });

    } else {
        navigationMapInstance.setTerrain(null);
        navigationMapInstance.setFog(null);
    }
}

/**
 * Espera de forma activa hasta que el estilo del mapa esté completamente cargado.
 * @param {mapboxgl.Map} mapInstance - La instancia del mapa.
 * @returns {Promise<void>} - Resuelve cuando el estilo está cargado, o rechaza si hay timeout.
 */
async function waitForMapStyleLoad(mapInstance) {
    let attempts = 0;
    const maxAttempts = 50; // 50 intentos * 100ms = 5 segundos de timeout
    const interval = 200;

    while (!mapInstance.isStyleLoaded() && attempts < maxAttempts) {
        await wait(interval);
        attempts++;
    }

    if (!mapInstance.isStyleLoaded()) {
        throw new Error("El estilo del mapa no se cargó después de varios intentos.");
    }
}    
// ===================================================================
// NOMBRE: configureMapAtmosphere (VERSIÓN FINAL CON VERIFICADOR)
// RESUMEN: Gestiona el terreno y la niebla, esperando activamente a que el mapa esté listo.
// ===================================================================
async function configureMapAtmosphere() {
    console.log(`[ATMOSPHERE DEBUG] 💡 Función iniciada. Modo de vista actual: '${mapViewMode}'`);

    if (!navigationMapInstance) {
        console.error("[ATMOSPHERE DEBUG] ❌ ERROR: La instancia del mapa no existe al iniciar la función.");
        return;
    }

    try {
        // ¡CLAVE! Esperamos activamente a que el mapa esté listo.
        await waitForMapStyleLoad(navigationMapInstance);
        console.log("[ATMOSPHERE DEBUG] ✅ Verificación superada: El mapa está listo y el estilo cargado.");

        const currentMode = mapViewMode || localStorage.getItem(MAP_VIEW_MODE_KEY) || 'relief';

        if (currentMode === 'relief' || currentMode === 'perspective') {
            console.log(`[ATMOSPHERE DEBUG] ▶️ Entrando en la ruta 3D para el modo: '${currentMode}'`);

            if (!navigationMapInstance.getSource('mapbox-dem')) {
                console.log("[ATMOSPHERE DEBUG] ℹ️ La fuente 'mapbox-dem' no existe. Añadiéndola ahora...");
                navigationMapInstance.addSource('mapbox-dem', {
                    'type': 'raster-dem',
                    'url': 'mapbox://mapbox.terrain-rgb',
                    'tileSize': 512,
                    'maxzoom': 14
                });
                await new Promise(resolve => {
                    const onSourceData = (e) => {
                        if (e.sourceId === 'mapbox-dem' && e.isSourceLoaded) {
                            navigationMapInstance.off('sourcedata', onSourceData);
                            resolve();
                        }
                    };
                    navigationMapInstance.on('sourcedata', onSourceData);
                });
                console.log("[ATMOSPHERE DEBUG] ✅ ¡ÉXITO! La fuente DEM se ha cargado correctamente.");
            } else {
                console.log("[ATMOSPHERE DEBUG] ℹ️ La fuente 'mapbox-dem' ya existía.");
            }
            
            await wait(500); // Aumentamos la pausa para dar más margen al navegador del coche.

            const exaggeration = (currentMode === 'relief') ? mapTerrainExaggeration : 0.0;
            console.log(`[ATMOSPHERE DEBUG] ⛰️ Llamando a setTerrain con exageración: ${exaggeration}`);
            navigationMapInstance.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': exaggeration });
            
            console.log("[ATMOSPHERE DEBUG] 🌫️ Llamando a setFog.");
            navigationMapInstance.setFog({
                'range': [0.9, 10], 'color': '#d8e2e8', 'horizon-blend': 0.1,
                'high-color': '#58636B', 'space-color': '#B3E3FF', 'star-intensity': 0.15
            });

        } else {
            console.log(`[ATMOSPHERE DEBUG] ▶️ Entrando en la ruta 2D. Limpiando terreno y niebla.`);
            navigationMapInstance.setTerrain(null);
            navigationMapInstance.setFog(null);
        }
        console.log("[ATMOSPHERE DEBUG] ✅ Función completada.");

    } catch (error) {
        console.error("[ATMOSPHERE DEBUG] ❌ ERROR CRÍTICO durante la configuración de la atmósfera:", error);
    }
}
    
// ===================================================================
// NOMBRE: hideAutoStartNavigationModal (MODIFICADA)
// RESUMEN: Oculta el modal de inicio y restaura la posición de la barra de progreso.
function hideAutoStartNavigationModal() {
    if (autoStartNavModalTimer) {
        clearInterval(autoStartNavModalTimer);
        autoStartNavModalTimer = null;
    }
    const modal = document.getElementById('auto-start-nav-modal');
    if (modal) {
        modal.remove();
    }
    
    const progressBar = document.getElementById('navigation-bottom-progress-bar');
    if (progressBar) {
        progressBar.classList.remove('progress-bar-partially-hidden');
    }
}    

// ===================================================================
// NOMBRE: toggleMapImmersiveMode (CORREGIDA - USA RESIZE)
// RESUMEN: Activa o desactiva el modo inmersivo del mapa para ocultar los controles.
function toggleMapImmersiveMode() {
    isMapImmersiveModeActive = !isMapImmersiveModeActive;
    const mapModal = document.getElementById('reminders-location-map-modal');
    if (mapModal) {
        mapModal.classList.toggle('immersive-mode-active', isMapImmersiveModeActive);
        
        if (!isMapImmersiveModeActive) {
            progressBarForceShowUntil = Date.now() + 20000;
            const progressBar = document.getElementById('navigation-bottom-progress-bar');
            if (progressBar) {
                progressBar.classList.remove('progress-bar-auto-hidden');
            }
        }
        
        if (navigationMapInstance) {
            setTimeout(() => {
                try {
                    navigationMapInstance.resize();
                } catch(e) { console.error("Error al redimensionar mapa en toggleMapImmersiveMode:", e); }
            }, 350);
        }
    }
    showToast(isMapImmersiveModeActive ? 'Modo Inmersivo Activado' : 'Modo Inmersivo Desactivado', 'info');
}
        
// ===================================================================
// NOMBRE: reactivateRealGpsAfterSimulation (MODIFICADA - PARA MAPBOX)
// RESUMEN: Reactiva el seguimiento del GPS real después de una simulación.
function reactivateRealGpsAfterSimulation() {
    if (locationWatchId === null && 'geolocation' in navigator && 'watchPosition' in navigator.geolocation) {
        locationWatchId = navigator.geolocation.watchPosition(
            (position) => {
                if (isSimulatingGpsLocation) return;
                const coordsForUpdate = {
                     latitude: position.coords.latitude, longitude: position.coords.longitude,
                     accuracy: position.coords.accuracy, heading: position.coords.heading,
                     altitude: position.coords.altitude, speed: position.coords.speed
                };
                navigationCurrentLocation = coordsForUpdate;
                updateInitialUserPosition(coordsForUpdate, navigationMapInstance);
                 if(isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
                    const routeForDistCalc = navigationCurrentRouteData.routes[0];
                    let carDistTurf = 0;
                    if (routeForDistCalc.geometry && typeof turf !== 'undefined') {
                        try {
                            const carPointTurf = turf.point([coordsForUpdate.longitude, coordsForUpdate.latitude]);
                            const routeLineStringTurf = turf.lineString(routeForDistCalc.geometry.coordinates);
                            const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                            const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                            carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                        } catch(e){
                        }
                    }
                    const totalRouteLength = routeForDistCalc.distance;
                     if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                        if (carDistTurf < lastCarDistanceAlongRouteForNavLogic - 100 && lastCarDistanceAlongRouteForNavLogic > 100) {
                        } else {
                            lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                        }
                    } else if (carDistTurf > totalRouteLength + 500) {
                        lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
                    }
                    updateTurnByTurnDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                    updateNavigationProgressDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                }
            },
            (error) => {
                showToast(`Error al reactivar GPS: ${error.message}`, "warning");
            },
            { enableHighAccuracy: true, timeout: 15000, maximumAge: 3000, distanceFilter: 3 }
        );
        getCurrentLocation(coords => {
            if (!isSimulatingGpsLocation) {
                navigationCurrentLocation = coords;
                updateInitialUserPosition(coords, navigationMapInstance);
                if (isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
                    const routeForDistCalc = navigationCurrentRouteData.routes[0];
                    let carDistTurf = 0;
                     if (routeForDistCalc.geometry && typeof turf !== 'undefined') {
                        try {
                            const carPointTurf = turf.point([coords.longitude, coords.latitude]);
                            const routeLineStringTurf = turf.lineString(routeForDistCalc.geometry.coordinates);
                            const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                            const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                            carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                        } catch(e){
                        }
                     }
                    const totalRouteLength = routeForDistCalc.distance;
                     if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                        if (carDistTurf < lastCarDistanceAlongRouteForNavLogic - 100 && lastCarDistanceAlongRouteForNavLogic > 100) {
                        }
                        lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                    } else if (carDistTurf > totalRouteLength + 500) {
                        lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
                    }
                    updateTurnByTurnDisplay(routeForDistCalc, carDistTurf);
                    updateNavigationProgressDisplay(routeForDistCalc, carDistTurf);
                }
            }
        });
    }
}

// =================================================================
// REEMPLAZA TU FUNCIÓN animateMarkerAndMap CON ESTA VERSIÓN FINAL Y SIMPLIFICADA
// =================================================================

function animateMarkerAndMap(timestamp) {
    if (!initialUserLocationMarker || !navigationMapInstance) {
        markerAnimationState.animationFrameId = null;
        return;
    }

    if (!markerAnimationState.lastTimestamp) {
        markerAnimationState.lastTimestamp = timestamp;
        markerAnimationState.animationFrameId = requestAnimationFrame(animateMarkerAndMap);
        return;
    }

    const deltaTime = timestamp - markerAnimationState.lastTimestamp;
    markerAnimationState.lastTimestamp = timestamp;

    // 1. Lógica de suavizado (LERP) para el ICONO del coche (esto no cambia)
    const posLerpFactor = 1.0 - Math.exp(-deltaTime * (parseFloat(localStorage.getItem(LERP_RATE_POS_KEY)) || 0.004));
    const rotLerpFactor = 1.0 - Math.exp(-deltaTime * (parseFloat(localStorage.getItem(LERP_RATE_ROT_KEY)) || 0.002));
    
    if (markerAnimationState.currentLngLat && markerAnimationState.targetLngLat) {
        markerAnimationState.currentLngLat.lng += (markerAnimationState.targetLngLat.lng - markerAnimationState.currentLngLat.lng) * posLerpFactor;
        markerAnimationState.currentLngLat.lat += (markerAnimationState.targetLngLat.lat - markerAnimationState.currentLngLat.lat) * posLerpFactor;
        initialUserLocationMarker.setLngLat(markerAnimationState.currentLngLat);
    }
    
    let deltaIconRotation = markerAnimationState.targetIconRotation - markerAnimationState.currentIconRotation;
    if (deltaIconRotation > 180) deltaIconRotation -= 360;
    if (deltaIconRotation < -180) deltaIconRotation += 360;
    markerAnimationState.currentIconRotation += deltaIconRotation * rotLerpFactor;
    initialUserLocationMarker.setRotation(markerAnimationState.currentIconRotation);

    // 2. Lógica de suavizado (LERP) para los PARÁMETROS de la cámara
    if ((shouldCenterOnUser || navigationFollowUser) && !isFlying) {
        const zoomPitchLerpFactor = 1.0 - Math.exp(-deltaTime * (parseFloat(localStorage.getItem(LERP_RATE_ZOOM_KEY)) || 0.001));

        // Interpolar suavemente los valores objetivo de la cámara
        if (markerAnimationState.currentMapCenter && markerAnimationState.targetLngLat) {
            markerAnimationState.currentMapCenter.lng += (markerAnimationState.targetLngLat.lng - markerAnimationState.currentMapCenter.lng) * posLerpFactor;
            markerAnimationState.currentMapCenter.lat += (markerAnimationState.targetLngLat.lat - markerAnimationState.currentMapCenter.lat) * posLerpFactor;
        }
        let deltaMapBearing = markerAnimationState.targetMapBearing - markerAnimationState.currentMapBearing;
        if (deltaMapBearing > 180) deltaMapBearing -= 360;
        if (deltaMapBearing < -180) deltaMapBearing += 360;
        markerAnimationState.currentMapBearing += deltaMapBearing * rotLerpFactor;
        markerAnimationState.currentMapZoom += (markerAnimationState.targetMapZoom - markerAnimationState.currentMapZoom) * zoomPitchLerpFactor;
        markerAnimationState.currentMapPitch += (markerAnimationState.targetMapPitch - markerAnimationState.currentMapPitch) * zoomPitchLerpFactor;
        markerAnimationState.currentMapOffsetX += (markerAnimationState.targetMapOffsetX - markerAnimationState.currentMapOffsetX) * zoomPitchLerpFactor;
        markerAnimationState.currentMapOffsetY += (markerAnimationState.targetMapOffsetY - markerAnimationState.currentMapOffsetY) * zoomPitchLerpFactor;

        // 3. Construir un único objeto de opciones de cámara y aplicarlo con easeTo
        // Esta es la parte fundamentalmente nueva y correcta.
        const canvas = navigationMapInstance.getCanvas();
        
        const cameraOptions = {
            center: markerAnimationState.currentMapCenter,
            zoom: markerAnimationState.currentMapZoom,
            bearing: markerAnimationState.currentMapBearing,
            pitch: markerAnimationState.currentMapPitch,
            padding: {
                top:    markerAnimationState.currentMapOffsetY > 0 ? canvas.clientHeight * Math.abs(markerAnimationState.currentMapOffsetY / 100) : 0,
                bottom: markerAnimationState.currentMapOffsetY < 0 ? canvas.clientHeight * Math.abs(markerAnimationState.currentMapOffsetY / 100) : 0,
                left:   markerAnimationState.currentMapOffsetX < 0 ? canvas.clientWidth * Math.abs(markerAnimationState.currentMapOffsetX / 100) : 0,
                right:  markerAnimationState.currentMapOffsetX > 0 ? canvas.clientWidth * Math.abs(markerAnimationState.currentMapOffsetX / 100) : 0
            },
            duration: 0 // Aplicar los cambios instantáneamente en cada fotograma
        };
        
        navigationMapInstance.easeTo(cameraOptions);
    }
    
    markerAnimationState.animationFrameId = requestAnimationFrame(animateMarkerAndMap);
}
    
    
// ===================================================================
// NOMBRE: getRouteStyleProperties (VERSIÓN CORREGIDA)
// RESUMEN: Devuelve el estilo correcto para la ruta (amarillo para satélite/híbrido, azul para calles).
function getRouteStyleProperties() {
    let activeLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "HÍBRIDO";
    const isStreetsView = activeLayerName === 'CALLES';
    
    return {
        'line-color': isStreetsView ? 'blue' : 'yellow',        
        'line-width': (navigationMapInstance && navigationMapInstance.getPitch() > 20) ? 16 : 12,
        'line-opacity': isStreetsView ? 0.6 : 0.8
    };
}
    
// ===================================================================
// NOMBRE: parseReminderText
// RESUMEN: Parsea el texto de un recordatorio para extraer fecha, hora, repetición, etc.
function parseReminderText(text, elementsToUpdate = null) {
    const result = { text: `<b>${text.trim().toUpperCase()}</b>`, time: null, date: null, repeatDays: [], intervalDays: null, type: null, isLocationEnabled: false, locationCoordinates: null, radiusMeters: 350, excludeFromList: false };
    let norm = text.toUpperCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    const numW = { 'UNA': 1, 'UNO': 1, 'DOS': 2, 'TRES': 3, 'CUATRO': 4, 'CINCO': 5, 'SEIS': 6, 'SIETE': 7, 'OCHO': 8, 'NUEVE': 9, 'DIEZ': 10, 'ONCE': 11, 'DOCE': 12, 'TRECE': 13, 'CATORCE': 14, 'QUINCE': 15, 'DIECISEIS': 16, 'DIECISIETE': 17, 'DIECIOCHO': 18, 'DIECINUEVE': 19, 'VEINTE': 20, 'VEINTIUNO': 21, 'VEINTIDOS': 22, 'VEINTITRES': 23, 'VEINTICUATRO': 24, 'VEINTICINCO': 25, 'VEINTISEIS': 26, 'VEINTISIETE': 27, 'VEINTIOCHO': 28, 'VEINTINUEVE': 29, 'TREINTA': 30, 'TREINTAYUNO': 31 }; const tRgx = /\b(\d{1,2}):(\d{2})\b/; const ttRgx = /.*\bA\s*LAS?\s*(\d+|\w+)\s*(?:Y\s*(CUARTO|MEDIA|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA)|MENOS\s*(CUARTO|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA))?\s*(DE\s*LA\s*(MANANA|TARDE|NOCHE))?/i; const tM = norm.match(tRgx); if (tM) { let h = parseInt(tM[1]); let m = parseInt(tM[2]); if (h >= 0 && h <= 23 && m >= 0 && m <= 59) result.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`; } else { const ttM = norm.match(ttRgx); if (ttM) { let h = numW[ttM[1].toUpperCase()] || parseInt(ttM[1]); if (!isNaN(h)) { const minTxt = ttM[2]?.toUpperCase() || ''; const minus = ttM[3]?.toUpperCase() || ''; const period = ttM[5]?.toUpperCase() || null; let m = 0; if (minTxt) m = minTxt === 'CUARTO' ? 15 : minTxt === 'MEDIA' ? 30 : numW[minTxt] || parseInt(minTxt) || 0; else if (minus) { m = minus === 'CUARTO' ? 15 : numW[minus] || parseInt(minus) || 0; h = (h - 1 + 24) % 24; m = (60 - m + 60) % 60; } if (period) { if (period === 'TARDE' && h >= 1 && h <= 11) h += 12; if (period === 'NOCHE' && h >= 1 && h <= 11) h += 12; if (period === 'MANANA' && h === 12) h = 0; if (period === 'TARDE' && h === 12) h = 12; if (period === 'NOCHE' && h === 12) h = 0; } else if (h >= 1 && h <= 5) h += 12; if (h >= 0 && h <= 23 && m >= 0 && m <= 59) result.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`; } } } const daysMap = { 'LUNES': 1, 'MARTES': 2, 'MIERCOLES': 3, 'MIÉRCOLES': 3, 'JUEVES': 4, 'VIERNES': 5, 'SABADO': 6, 'SÁBADO': 6, 'DOMINGO': 0 }; const wRgx = /(TODOS\s+LOS|LOS|CADA)?\s*(LUNES|MARTES|MIERCOLES|MIÉRCOLES|JUEVES|VIERNES|SABADO|SÁBADO|DOMINGO)/g; let wM; while ((wM = wRgx.exec(norm)) !== null) { const day = daysMap[wM[2]]; if (day !== undefined && !result.repeatDays.includes(day)) result.repeatDays.push(day); }
    const now = new Date(); const manDRgx = /(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{2}|\d{4})\b/; const manDM = norm.match(manDRgx);
    if (manDM && !result.date) { let d = parseInt(manDM[1]); let m = parseInt(manDM[2]); let y = parseInt(manDM[3]); if (y >= 0 && y <= 99) y += 2000; if (d >= 1 && d <= 31 && m >= 1 && m <= 12 && y >= 2000 && y <= 2099) { const tD = new Date(Date.UTC(y, m - 1, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() + 1 === m && tD.getUTCFullYear() === y) { result.date = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } } }
    const todayRgx = /\bHOY\b/; const tomRgx = /\bMANANA\b/; const dayAftRgx = /\bPASADO\s*MANANA\b/;
    if (!result.date) { if (norm.match(todayRgx)) { result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (norm.match(dayAftRgx)) { const tD = new Date(now); tD.setDate(now.getDate() + 2); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } else if (norm.match(tomRgx)) { const tD = new Date(now); tD.setDate(now.getDate() + 1); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } }
    const dndRgx = /(?:EL\s*(PROXIMO)?\s*)?(LUNES|MARTES|MIERCOLES|MIÉRCOLES|JUEVES|VIERNES|SABADO|SÁBADO|DOMINGO)/i; const dndM = norm.match(dndRgx);
    if (dndM && !result.date) { const tDN = dndM[2].toUpperCase(); const tD = daysMap[tDN]; if (tD !== undefined) { const curD = now.getDay(); let dU = (tD - curD + 7) % 7; if (dU === 0) dU = 7; if (dndM[1]?.toUpperCase() === 'PROXIMO') dU += 7; const target = new Date(now); target.setDate(now.getDate() + dU); result.date = `${target.getFullYear()}-${(target.getMonth() + 1).toString().padStart(2, '0')}-${target.getDate().toString().padStart(2, '0')}`; } }
    const didRgx = /DENTRO\s*DE\s*(\d+)\s*DIAS?/; const didM = norm.match(didRgx);
    if (didM && !result.date) { const d = parseInt(didM[1]); if (!isNaN(d) && d > 0) { const tD = new Date(now); tD.setDate(now.getDate() + d); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } }
    const dsdRgx = /\bEL\s*DIA\s*(\d{1,2})\b/; const dsdM = norm.match(dsdRgx);
    if (dsdM && !result.date) { const d = parseInt(dsdM[1]); if (!isNaN(d) && d >= 1 && d <= 31) { let tM = now.getMonth(); let tY = now.getFullYear(); if (d < now.getDate()) { tM++; if (tM > 11) { tM = 0; tY++; } } const tD = new Date(Date.UTC(tY, tM, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() === tM) { result.date = `${tY}-${(tM + 1).toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } } }
    const intRgx = /CADA\s*(\d+)\s*DIAS?/; const intM = norm.match(intRgx);
    if (intM) { result.intervalDays = parseInt(intM[1]); if (!result.date) { result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } }
    const timRgx = /(ALARMA|AVISO|AVISAR|AVISARME|AVÍSAME|TEMPORIZADOR|TIMER|RECORDAR|RECORDARME|RECUÉRDAME)\b.*?\b(\d+|\w+)\s*(MINUTOS?|HORAS?|MINS?|HRS?)/i; const timM = norm.match(timRgx);
    if (timM) { const valStr = timM[2]; const unit = timM[3]?.toUpperCase(); let val = numW[valStr.toUpperCase()] || parseInt(valStr); if (!isNaN(val) && val > 0 && unit) { let tmc = 0; if (unit.startsWith('HORA') || unit.startsWith('HR')) { tmc = val * 60; } else if (unit.startsWith('MINUTO') || unit.startsWith('MIN')) { tmc = val; }
            if (tmc > 0) { const endT = new Date(Date.now() + tmc * 60000); result.date = `${endT.getFullYear()}-${(endT.getMonth() + 1).toString().padStart(2, '0')}-${endT.getDate().toString().padStart(2, '0')}`; result.time = `${endT.getHours().toString().padStart(2, '0')}:${endT.getMinutes().toString().padStart(2, '0')}`; result.repeatDays = []; result.intervalDays = null; result.type = 'simple'; } } }
    
    const locationPhrases = ["EN EL LUGAR", "EN EL SITIO", "EN LA UBICACION", "EN LA LOCALIZACION"];
    if (locationPhrases.some(phrase => norm.includes(phrase)) || norm.includes("RADAR")) {
        result.isLocationEnabled = true;
    }
    
    const radiusRgx = /(?:RADIO|MARGEN)\s*DE\s*(\d+)\s*METROS?/i; const radiusMatch = norm.match(radiusRgx);
    if (radiusMatch && radiusMatch[1]) { const parsedRadius = parseInt(radiusMatch[1]); if (!isNaN(parsedRadius) && parsedRadius > 0) { result.radiusMeters = parsedRadius; result.isLocationEnabled = true; } }
    const excludePhrases = ["NO LISTAR", "NO MOSTRAR EN LISTA", "EXCLUIR LISTA", "OCULTAR LISTA", "RADAR"]; if (excludePhrases.some(phrase => norm.includes(phrase))) { result.excludeFromList = true; }
    if (norm.toUpperCase().startsWith("<b>RADAR") && result.radiusMeters === 350 && !radiusMatch) {
        result.radiusMeters = 350;
    } else if (result.radiusMeters === 350 && !norm.toUpperCase().startsWith("<b>RADAR") && !radiusMatch && !excludePhrases.some(phrase => norm.includes(phrase))) {
        result.radiusMeters = 350;
    }
    if (result.type === null) {
        if (result.intervalDays !== null && result.date) { result.type = 'interval'; } else if (result.repeatDays.length > 0 && result.time) { result.type = 'weekly'; } else if (result.date && result.time) { result.type = 'daily'; } else if (result.time) { result.type = 'daily'; if (!result.date) result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (result.date) { result.type = 'daily'; } else { result.type = 'simple'; } }
    if (!result.time && (result.type === 'daily' || result.type === 'weekly' || result.type === 'interval' )) { result.time = '00:01'; }
    if (elementsToUpdate) {
         if (elementsToUpdate.locationCheckbox) { const shouldBeChecked = result.isLocationEnabled; if (elementsToUpdate.locationCheckbox.checked !== shouldBeChecked && !elementsToUpdate.mapExpandedManually) { elementsToUpdate.locationCheckbox.checked = shouldBeChecked; } }
         if (elementsToUpdate.radiusInput) { elementsToUpdate.radiusInput.value = result.radiusMeters; }
         if (!elementsToUpdate.manualTimeInput && elementsToUpdate.timeInput && result.time) { elementsToUpdate.timeInput.value = result.time; }
         if (elementsToUpdate.dateInput && result.date) { const dateParts = result.date.split('-');
         if(dateParts.length === 3) { elementsToUpdate.dateInput.value = `${dateParts[2]}/${dateParts[1]}/${dateParts[0]}`; } else { elementsToUpdate.dateInput.value = ''; } } else if (elementsToUpdate.dateInput) { elementsToUpdate.dateInput.value = ''; }
         if (elementsToUpdate.intervalInput) { elementsToUpdate.intervalInput.value = result.intervalDays || ''; }
         if (elementsToUpdate.repeatCheckboxes && result.repeatDays && result.repeatDays.length > 0) { elementsToUpdate.repeatCheckboxes.forEach(input => { input.checked = result.repeatDays.includes(parseInt(input.value)); }); } else if (elementsToUpdate.repeatCheckboxes) { elementsToUpdate.repeatCheckboxes.forEach(input => { input.checked = false; }); }
         if (elementsToUpdate.excludeFromListCheckbox) { elementsToUpdate.excludeFromListCheckbox.checked = result.excludeFromList; }
    } return result;
}

// ===================================================================
// NOMBRE: displayAddressSuggestionsModal (VERSIÓN FINAL Y CORRECTA)
// RESUMEN: La corrección clave es que ahora elimina la clase '.hidden'
function displayAddressSuggestionsModal(suggestions) {
    const searchInput = document.getElementById('map-location-search-input');
    if (!searchInput) return;

    const modalId = 'address-suggestions-modal';
    let modal = document.getElementById(modalId);
    
    if (!modal) {
        modal = document.createElement('div');
        modal.id = modalId;
        modal.className = 'address-suggestions-modal';
        modal.style.zIndex = '11005 !important'; 
        modal.innerHTML = `
            <h2 id="address-suggestions-title"></h2>
            <ul id="address-suggestions-list"></ul>
            <div class="modal-top-buttons" style="justify-content: flex-end; margin-top: 1rem;">
                <button id="close-address-suggestions-modal" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
            </div>
        `;
        document.body.appendChild(modal); 
        const closeButton = modal.querySelector('#close-address-suggestions-modal');
        closeButton.addEventListener('click', hideAddressSuggestionsModal);
    }
    
    const titleElement = modal.querySelector('#address-suggestions-title');
    const listElement = modal.querySelector('#address-suggestions-list');
    const closeButton = modal.querySelector('#close-address-suggestions-modal');
    
    clearModalAutoCloseTimer(modal, closeButton, 'address-suggestions-modal');

    if (suggestions.length === 0) {
        titleElement.textContent = "No se encontraron coincidencias";
        listElement.innerHTML = '<li style="cursor: default; background-color: #a09888; color: #444;">Prueba con términos más generales.</li>';
        modal.classList.remove('hidden'); 

        addModalAutoCloseTimer(modal, closeButton, 'address-suggestions-modal', 5000); 
        return;
    }
    
    titleElement.textContent = `${suggestions.length} coincidencia${suggestions.length !== 1 ? 's' : ''} encontrada${suggestions.length !== 1 ? 's' : ''}`;
    listElement.innerHTML = '';
    suggestions.forEach(suggestion => {
        const li = document.createElement('li');
        li.textContent = suggestion.display_name;
        li.dataset.lat = suggestion.lat;
        li.dataset.lon = suggestion.lon;
        
        li.addEventListener('click', async () => {
            const lat = parseFloat(li.dataset.lat);
            const lon = parseFloat(li.dataset.lon);
            const displayName = li.textContent;
            
            if (isNaN(lat) || isNaN(lon)) {
                showToast("Error: Coordenadas de sugerencia no válidas.", "error");
                return;
            }

            hideAddressSuggestionsModal();
            showToast("Ajustando a la carretera más cercana...", "info", 3000);
            
            const snappedLatLng = await snapCoordsToRoad(lat, lon);
            await addWaypoint(snappedLatLng, displayName);

            if (navigationMapInstance) navigationMapInstance.flyTo({ center: [lon, lat], zoom: 15 });
            if (searchInput) {
                searchInput.value = '';
                searchInput.dispatchEvent(new Event('input'));
            }
            showToast("Ubicación añadida a la ruta", "success");
        });
      
        listElement.appendChild(li);
    });
    
    const searchInputRect = searchInput.getBoundingClientRect();
    modal.style.top = `${searchInputRect.bottom + 5}px`;
    const viewportHeight = window.innerHeight;
    const modalTop = searchInputRect.bottom + 5;
    const availableHeight = viewportHeight - modalTop - 20;
    modal.style.maxHeight = `${availableHeight}px`;
    const titleHeight = titleElement.offsetHeight;
    const buttonsHeight = modal.querySelector('.modal-top-buttons').offsetHeight;
    const listMaxHeight = availableHeight - titleHeight - buttonsHeight - 30;
    listElement.style.maxHeight = `${Math.max(100, listMaxHeight)}px`;
    
    modal.classList.remove('hidden');
    
    addModalAutoCloseTimer(modal, closeButton, 'address-suggestions-modal', 30000);
}

// ===================================================================
// NOMBRE: stopAutomatedRouteSimulationInternal (NUEVA FUNCIÓN - CORRECCIÓN)
// RESUMEN: Detiene el intervalo de la simulación automática y limpia su ID. Es la función auxiliar que faltaba.
function stopAutomatedRouteSimulationInternal() {
    if (automatedSimulationIntervalId) {
        clearInterval(automatedSimulationIntervalId);
        automatedSimulationIntervalId = null;
    }
}
   
// ===================================================================
// NOMBRE: fetchRouteData (VERSIÓN FINAL CON MAPBOX PRIMARIO Y CHECKBOX OSRM)
// RESUMEN: Usa Mapbox por defecto. Si el checkbox "Rutas OSRM" está marcado, usa OSRM como primario.
// ===================================================================
async function fetchRouteData(coordsString, startHeading = null) {
    const OSRM_PRIMARY_KEY = 'boardinggate_useOsrmAsPrimary';
    const useOsrmAsPrimary = localStorage.getItem(OSRM_PRIMARY_KEY) === 'true';
  
    const osrmService = {
        name: 'OSRM',
        buildUrl: (coords) => {
            return `${OSRM_SERVICE_URL}/driving/${coords}?overview=full&geometries=geojson&steps=true&alternatives=false&annotations=true`;
        },
        processResponse: async (response) => {
            if (!response.ok) {
                let errorData = { message: `OSRM HTTP error ${response.status}` };
                try { errorData = await response.json(); } catch (e) {}
                throw new Error(errorData.code || errorData.message || response.statusText);
            }
            const data = await response.json();
            if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) {
                throw new Error(data.message || "No se encontraron rutas en OSRM.");
            }
            return { routeData: data, serviceUsed: 'OSRM' };
        }
    };

    const mapboxService = {
        name: 'Mapbox',
        buildUrl: (coords) => {
            return `https://api.mapbox.com/directions/v5/mapbox/driving/${coords}?alternatives=false&geometries=geojson&overview=full&steps=true&access_token=${MAPBOX_ACCESS_TOKEN}`;
        },
        processResponse: async (response) => {
            if (!response.ok) {
                let errorData = { message: `Mapbox HTTP error ${response.status}` };
                try { errorData = await response.json(); } catch (e) {}
                throw new Error(errorData.message || response.statusText);
            }
            const data = await response.json();
            if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) {
                throw new Error(data.message || "No se encontraron rutas en Mapbox.");
            }
            const adaptedRoute = adaptMapboxRouteToOSRMFormat(data.routes[0]);
            const adaptedWaypoints = data.waypoints.map(wp => ({
                distance: wp.distance,
                hint: wp.hint,
                location: wp.location,
                name: wp.name,
            }));
            const finalData = {
                code: 'Ok',
                routes: [adaptedRoute],
                waypoints: adaptedWaypoints
            };
            return { routeData: finalData, serviceUsed: 'Mapbox' };
        }
    };

    const buildUrlWithCorrectBearings = (service, coords) => {
        let baseUrl = service.buildUrl(coords).split('?')[0];
        let params = new URLSearchParams(service.buildUrl(coords).split('?')[1] || '');

        if (startHeading !== null && !isNaN(startHeading)) {
            const waypointCount = (coords.match(/;/g) || []).length + 1;
            let bearingsString = `${Math.round(startHeading)},45`;
            if (waypointCount > 1) {
                bearingsString += ';'.repeat(waypointCount - 1);
            }
            params.set('bearings', bearingsString);
        } else {
            params.delete('bearings'); 
        }
        
        return `${baseUrl}?${params.toString()}`;
    };

    const primaryService = useOsrmAsPrimary ? osrmService : mapboxService;
    const fallbackService = useOsrmAsPrimary ? mapboxService : osrmService;

    try {
        const primaryUrl = buildUrlWithCorrectBearings(primaryService, coordsString);
        const primaryResponse = await fetch(primaryUrl);
        return await primaryService.processResponse(primaryResponse);
    } catch (primaryError) {
        showToast(`Servicio principal (${primaryService.name}) falló. Intentando con respaldo (${fallbackService.name})...`, "warning", 4000);
        
        try {
            const fallbackUrl = buildUrlWithCorrectBearings(fallbackService, coordsString);
            const fallbackResponse = await fetch(fallbackUrl);
            const fallbackData = await fallbackService.processResponse(fallbackResponse);
            fallbackData.serviceUsed += ' (Respaldo)';
            return fallbackData;
        } catch (fallbackError) {
            return { error: fallbackError, failedServices: `${primaryService.name} (Fallo), ${fallbackService.name} (Fallo)` };
        }
    }
}

    
// ===================================================================
// NOMBRE: handleSimulateGpsPositionClick (MODIFICADA - PARA MAPBOX)
// RESUMEN: Maneja el clic en el mapa durante la simulación GPS manual.
function handleSimulateGpsPositionClick(e, forceExactPosition = false) {
    if (!isSimulatingGpsLocation || !navigationMapInstance) return;

    navigationFollowUser = true;
    shouldCenterOnUser = true;
    clearLocateMeReactivationTimer(); updateLocateMeButtonsUI(); 

    
    if (automatedSimulationIntervalId) {
        wasSimulatingBeforeRecalc = true;
        stopAutomatedRouteSimulationInternal();
        showToast("Simulación automática pausada. Forzando desvío...", "info");
    }
    let lngLatToUse = [e.lngLat.lng, e.lngLat.lat]; 
    
    if (!forceExactPosition && navigationMapInstance.getSource('route') && typeof turf !== 'undefined' && navigationMapInstance.getSource('route')._data) {
        const routeGeoJSON = navigationMapInstance.getSource('route')._data;
        if (routeGeoJSON && routeGeoJSON.type === 'Feature' && routeGeoJSON.geometry && routeGeoJSON.geometry.coordinates) {
            const routeLineString = turf.lineString(routeGeoJSON.geometry.coordinates);
            const clickPoint = turf.point(lngLatToUse);
            const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, clickPoint, { units: 'meters' });
            
            if (nearestPointOnRoute && nearestPointOnRoute.properties.dist !== undefined && nearestPointOnRoute.properties.dist < 50) { 
                lngLatToUse = nearestPointOnRoute.geometry.coordinates;
            }
        }
    }

    simulatedGpsLocation = {
        latitude: lngLatToUse[1],
        longitude: lngLatToUse[0],
        accuracy: 10,
        heading: navigationCurrentLocation ? navigationCurrentLocation.heading : 0,
        altitude: navigationCurrentLocation ? navigationCurrentLocation.altitude : 0,
        speed: 0
    };
    processSimulatedGpsPosition(true); 
    setNavigationMapClickHandler(); 
}        

// ===================================================================
// NOMBRE: setNavigationMapClickHandler (VERSIÓN SIMPLIFICADA)
// RESUMEN: Únicamente gestiona el estado visual del mapa (clases y cursor) según el modo actual.
// ===================================================================
function setNavigationMapClickHandler() {
    const mapDiv = document.getElementById('reminders-location-map-div');
    if (!navigationMapInstance || !mapDiv) return;

    mapDiv.classList.remove('add-reminder-mode', 'simulating-gps-click-mode', 'navigating');
    const canvas = navigationMapInstance.getCanvas();
    if(canvas) canvas.style.cursor = ''; // Restaura cursor por defecto

    if (isAddReminderAtLocationModeActive) {
        mapDiv.classList.add('add-reminder-mode');
    } else if (isSimulatingGpsLocation) {
        mapDiv.classList.add('simulating-gps-click-mode');
    } else if (isNavigating) {
        mapDiv.classList.add('navigating');
        if(canvas) canvas.style.cursor = 'default';
    } else {
        if(canvas) canvas.style.cursor = 'crosshair';
    }
} 
// ===================================================================
// NOMBRE: showSimulationSpeedModal (MODIFICADA - AÑADIDO TEXTO DE AYUDA PARA DESVÍOS)
// RESUMEN: Muestra un modal para que el usuario introduzca la velocidad de simulación y elija el modo, incluyendo ahora una nota sobre cómo simular desvíos.
function showSimulationSpeedModal(defaultSpeed, callback) {
    closeOtherModals('simulation-speed-modal');
    let modal = document.getElementById('simulation-speed-modal');
    if (modal) modal.remove();
    modal = document.createElement('div');
    modal.id = 'simulation-speed-modal';
    modal.innerHTML = `
        <h2>Velocidad y Modo de Simulación</h2>
        <div class="filter-group" style="margin-bottom: 20px;">
            <label id="speed-range-label">Velocidad: ${defaultSpeed} km/h</label>
            <div class="slider-container single-slider-container" style="height: 25px;">
                <div class="slider-track"></div>
                <div class="slider-range" id="speed-slider-range"></div>
                <div class="slider-thumb" id="speed-thumb" style="left: 0%;"></div>
            </div>
        </div>
        <div class="modal-top-buttons" style="flex-direction: column; gap: 10px;">
            <button id="confirm-navigation-simulation" style="background-color: #28a745; color: white;">Simular Navegación Normal <span class="button-countdown-timer unified-countdown-style"></span></button>
            <button id="confirm-freedrive-simulation" style="background-color: #34D399; color: #111827; font-weight: bold;">Recorrer en Modo Free Drive</button>
            <button id="cancel-simulation-speed" style="background-color: #6c757d; color: white;">Cancelar</button>
        </div>
        <!-- AÑADIDO: Párrafo de ayuda para simular desvíos -->
        <p style="font-size: 0.85rem; color: #444; margin-top: 1.5rem; text-align: left; font-style: italic; border-top: 1px solid #ccc; padding-top: 10px;">
            (*) Para simular DESVIOS, carga una ruta, luego pulsa simulación y cuando quieras pincha en el mapa para probar un desvio desde ese punto</p>
    `;
    document.body.appendChild(modal);

    const speedSliderContainer = modal.querySelector('#speed-thumb').parentElement;
    const speedThumb = modal.querySelector('#speed-thumb');
    const speedRange = modal.querySelector('#speed-slider-range');
    const speedLabel = modal.querySelector('#speed-range-label');
    const minSpeed = 1;
    const maxSpeed = 5000;
    let currentSpeed = defaultSpeed || 90;

    const updateSpeedVisuals = () => {
        const minLog = Math.log(minSpeed);
        const maxLog = Math.log(maxSpeed);
        const percent = (Math.log(currentSpeed) - minLog) / (maxLog - minLog);
        
        speedThumb.style.left = `${percent * 100}%`;
        speedRange.style.width = `${percent * 100}%`;
        speedLabel.textContent = `Velocidad: ${Math.round(currentSpeed)} km/h`;
    };

    const onSpeedDrag = (e) => {
        const rect = speedSliderContainer.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        let percent = (clientX - rect.left) / rect.width;
        percent = Math.max(0, Math.min(1, percent));
        
        const minLog = Math.log(minSpeed);
        const maxLog = Math.log(maxSpeed);
        currentSpeed = Math.exp(minLog + percent * (maxLog - minLog));
        
        updateSpeedVisuals();
    };

    const startSpeedDrag = (e) => {
        const moveHandler = (moveEvent) => onSpeedDrag(moveEvent);
        const endDrag = () => {
            document.removeEventListener('mousemove', moveHandler);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchmove', moveHandler);
            document.removeEventListener('touchend', endDrag);
        };
        document.addEventListener('mousemove', moveHandler);
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchmove', moveHandler);
        document.addEventListener('touchend', endDrag);
    };
    
    speedThumb.addEventListener('mousedown', startSpeedDrag);
    speedThumb.addEventListener('touchstart', startSpeedDrag);
    updateSpeedVisuals();
    
    const confirmNavBtn = modal.querySelector('#confirm-navigation-simulation');
    const confirmFreeDriveBtn = modal.querySelector('#confirm-freedrive-simulation');
    const cancelBtn = modal.querySelector('#cancel-simulation-speed');
    
    const closeHandler = () => {
        clearModalAutoCloseTimer(modal, confirmNavBtn, 'simulation-speed-modal');
        if (modal.parentNode) modal.remove();
    };

    confirmNavBtn.addEventListener('click', () => {
        isSimulatingFreeDrive = false; 
        callback(Math.round(currentSpeed));
        closeHandler();
    });

    confirmFreeDriveBtn.addEventListener('click', () => {
        isSimulatingFreeDrive = true; 
        callback(Math.round(currentSpeed));
        closeHandler();
    });

    cancelBtn.addEventListener('click', () => {
        showToast("Inicio de simulación cancelado", "info");
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) simulateGpsButton.classList.remove('active-simulate-gps-mode');
        isSimulatingGpsLocation = false;
        reactivateRealGpsAfterSimulation();
        setNavigationMapClickHandler();
        closeHandler();
    });

    addModalAutoCloseTimer(modal, confirmNavBtn, 'simulation-speed-modal', 30000);
}    

// ===================================================================
// NOMBRE: showHelpModal
// RESUMEN: Muestra el modal de ayuda con ejemplos de uso para crear recordatorios.
function showHelpModal(options = {}) {
    const modal = document.createElement('div');
    modal.className = 'help-modal reminder-modal'; 
    modal.setAttribute('aria-label', 'Ayuda recordatorios');
    
    modal.innerHTML = `
        <div class="reminder-modal-header">
            <h2 class="reminder-modal-title">Ayuda de Recordatorios</h2>
        </div>
        <div class="reminder-modal-body">
            <p class="mb-4">Ejemplos de comandos de voz o texto:</p>
            <ul class="list-disc pl-6 mb-4 space-y-2">
                <li><strong>Texto:</strong> "Recordar cita", "Llamar mamá"</li>
                <li><strong>Hora:</strong> "A LAS DIEZ Y CUARTO" → 10:15, "A LAS CINCO Y MEDIA TARDE" → 17:30</li>
                <li><strong>Fecha:</strong> "HOY", "MAÑANA", "DENTRO DE 15 DÍAS", "EL DÍA 22", "PRÓXIMO LUNES", "25/05/2025"</li>
                <li><strong>Repetición:</strong> "CADA LUNES", "TODOS LOS VIERNES Y SÁBADOS"</li>
                <li><strong>Intervalo:</strong> "CADA 7 DÍAS"</li>
                <li><strong>Alarma:</strong> "ALARMA EN 30 MINUTOS", "RECORDAR EN 2 HORAS".</li>
                <li><strong>Excluir/Radar:</strong> Añadir "NO LISTAR", "EXCLUIR LISTA" o "RADAR" para ocultarlo de la lista general y que aparezca con chincheta morada en el mapa.</li>
            </ul>
            <p class="mb-4">Nota: Combina hora, fecha, días, etc. Las palabras Alarma, Aviso, Recordar, Timer... crean alarmas de tiempo exacto.</p>
            
            <h3 class="font-bold text-lg mt-6 mb-2 text-[#007aff]">Recordatorios por Ubicación</h3>
            <ul class="list-disc pl-6 mb-4 space-y-2">
                <li><strong>Activar:</strong> Marca la casilla "RECORDATORIO POR UBICACIÓN" o usa frases como "EN EL LUGAR", "EN EL SITIO".</li>
                <li><strong>Fijar Punto:</strong> Pulsa "VER/EDITAR POSICIÓN EN MAPA" para ampliarlo y haz clic donde quieras fijar el punto. Usa "ESTÁS AQUÍ" para centrar en tu posición.</li>
                <li><strong>Radio:</strong> Ajusta el radio con el slider o con frases como "RADIO DE 200 METROS".</li>
                <li><strong>Guardar/Usar Ubicaciones:</strong> Usa el botón "Ubicaciones" para guardar y seleccionar tus lugares frecuentes.</li>
                <li><strong>Navegación:</strong> Para planificar rutas, usa el icono <img src="RADAR.PNG" alt="Radar Icon" style="width:1em; height:1em; vertical-align:middle; display:inline;"> en la barra superior. Consulta su ayuda específica <img src="./PNG/IMG_4326.PNG" alt="Ayuda" style="height:1.2em; display:inline; vertical-align:middle;">.</li>
            </ul>
        </div>
        <div class="reminder-modal-footer">
            <button type="button" id="close-help" class="action-button primary" style="grid-column: 1 / -1;">Entendido</button>
        </div>
    `;
    const parent = options.parentContainer || document.body;
    parent.appendChild(modal);
    const closeHelpButton = modal.querySelector('#close-help');
    const closeHandler = () => { clearModalAutoCloseTimer(modal, closeHelpButton, 'help-modal'); if (modal.parentNode) modal.parentNode.removeChild(modal); };
    closeHelpButton.addEventListener('click', closeHandler); 
    addModalAutoCloseTimer(modal, closeHelpButton, 'help-modal');
}

    // ===================================================================
    // NOMBRE: stopAutomatedRouteSimulation
    // RESUMEN: Detiene completamente el modo de simulación y vuelve al GPS real.
    function stopAutomatedRouteSimulation() {
        stopAutomatedRouteSimulationInternal();
        isSimulatingGpsLocation = false;
        const mapDiv = document.getElementById('reminders-location-map-div');
        if (mapDiv) {
            mapDiv.classList.remove('simulating-gps-click-mode');
        }
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) {
            simulateGpsButton.classList.remove('active-simulate-gps-mode');
            simulateGpsButton.title = "Activar Simulación GPS (recorrido automático o clic manual)";
        }
        startGpsWatching();
        setNavigationMapClickHandler();
    }
    
    
    // ===================================================================
    // NOMBRE: toggleAddReminderAtLocationMode
    // RESUMEN: Activa/desactiva el modo para añadir un recordatorio haciendo clic en el mapa.
    function toggleAddReminderAtLocationMode() {
        isAddReminderAtLocationModeActive = !isAddReminderAtLocationModeActive;
        const mapDiv = document.getElementById('reminders-location-map-div');
        const button = document.getElementById('add-reminder-at-location-button');
        if (button) {
            if (isAddReminderAtLocationModeActive) {
                button.classList.add('active-reminder-mode');
                if (mapDiv) mapDiv.classList.add('add-reminder-mode');
                showToast("Modo 'Añadir Recordatorio en Mapa' ACTIVADO. Pulsa en el mapa para crear un recordatorio.", "info", 5000);
            } else {
                button.classList.remove('active-reminder-mode');
                if (mapDiv) mapDiv.classList.remove('add-reminder-mode');
                showToast("Modo 'Añadir Recordatorio en Mapa' DESACTIVADO.", "info");
            }
        }
        setNavigationMapClickHandler();
    }
    

// ===================================================================
// NOMBRE: handlePdrSearchButtonClick
// RESUMEN: Gestiona el ciclo de búsqueda de PDRs (Buscar > Filtrar > Limpiar).
function handlePdrSearchButtonClick() {
    const pdrButton = document.getElementById('pdrs-ruta-button');

    switch (pdrSearchState) {
        case 'initial': 
            if (pdrButton) pdrButton.classList.remove('pdr-search-highlight');
            showPDRsFilterModal();
            break;
            
        case 'results_shown': 
            if (lastPdrSearchResults.length > 0) {
                if (pdrButton) pdrButton.classList.add('pdr-search-highlight');
                filterForCheapestPDRs();
                pdrSearchState = 'cheapest_shown';
            } else {
                showToast("No hay PDRs en el mapa para filtrar. Realice una nueva búsqueda.", "info");
                pdrSearchState = 'initial'; 
                showPDRsFilterModal();
            }
            break;

        case 'cheapest_shown': 
            if (pdrButton) pdrButton.classList.remove('pdr-search-highlight');
            clearChargingPoints();
            showToast("Puntos de recarga eliminados del mapa.", "info");
            pdrSearchState = 'initial'; 
            break;
    }
}

// ===================================================================
// NOMBRE: filterForCheapestPDRs (VERSIÓN CON FILTRADO CORRECTO)
// RESUMEN: Filtra para mostrar solo los PDRs más baratos y actualiza la lista principal de resultados.
function filterForCheapestPDRs() {
    if (lastPdrSearchResults.length === 0) {
        showToast("No hay resultados previos para filtrar. Realiza una nueva búsqueda.", "info");
        pdrSearchState = 'initial';
        return;
    }
    showToast("Mostrando solo los PDRs más económicos por rango de potencia...", "info");

    const cheapestBySegment = {
        '#0f130c': { price: Infinity, point: null }, 
        '#007863': { price: Infinity, point: null }, 
        'rgb(30, 144, 255)': { price: Infinity, point: null }, 
        '#de2e03': { price: Infinity, point: null },
        '#5e5e5e': { price: Infinity, point: null } // Añadir color para potencia desconocida
    };

    const parsePrice = (priceString) => {
        if (priceString && typeof priceString === 'string') {
            const priceMatch = priceString.match(/(\d[\d,.]*)/);
            if (priceMatch && priceMatch[1]) {
                const priceNum = parseFloat(priceMatch[1].replace(',', '.'));
                if (!isNaN(priceNum) && priceNum >= 0 && priceNum < 10) { // Permitir precio 0
                    return priceNum;
                }
            }
        }
        return Infinity;
    };

    lastPdrSearchResults.forEach(point => {
        const power = parseFloat(point.power);
        const segmentColor = getChargingPointColorByPower(power);
        const price = parsePrice(point.price);
        
        if (cheapestBySegment[segmentColor] && price < cheapestBySegment[segmentColor].price) {
            cheapestBySegment[segmentColor].price = price;
            cheapestBySegment[segmentColor].point = point;
        }
    });
    
    const cheapestPoints = Object.values(cheapestBySegment)
        .map(item => item.point)
        .filter(p => p !== null);
     cheapestPoints.forEach(p => { p.isCheapest = true; });
    lastPdrSearchResults = cheapestPoints;
    displayChargingPointsOnMap();
}

// ===================================================================
// NOMBRE: addChargingPointToRoute (VERSIÓN CORREGIDA)
// RESUMEN: Añade un PDR como etapa. Si no hay ruta, crea una nueva. Si se navega, preserva estadísticas.
async function addChargingPointToRoute(pointIndex) {
    const point = currentChargingPointsOnRoute[pointIndex];
    if (!point) return;

    const noRouteLoaded = navigationWaypoints.length === 0;

    if (noRouteLoaded) {
        if (!navigationCurrentLocation) {
            showToast("No se puede añadir el punto de carga sin una ubicación GPS inicial.", "error");
            return;
        }

        const startPoint = {
            id: Date.now() - 1,
            lat: navigationCurrentLocation.latitude,
            lng: navigationCurrentLocation.longitude,
            type: 'S',
            marker: null,
            label: 'S',
            address: 'Posición Actual (GPS)',
            visited: true,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false
        };

        const newWaypoint = {
            id: Date.now(),
            lat: point.lat,
            lng: point.lon,
            type: '',
            marker: null,
            label: '',
            address: point.address || 'Punto de Recarga',
            visited: false,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false
        };

        navigationWaypoints.push(startPoint, newWaypoint);
        showToast("Ruta creada desde tu posición hasta el punto de recarga.", "success");

    } else {
        let lastVisitedIndex = -1;
        navigationWaypoints.forEach((wp, index) => {
            if (wp.visited) {
                lastVisitedIndex = index;
            }
        });
        const insertIndex = lastVisitedIndex + 1;
        
        const newWaypoint = {
            id: Date.now(),
            lat: point.lat,
            lng: point.lon,
            type: '', 
            marker: null,
            label: '',
            address: point.address || 'Punto de Recarga',
            visited: false,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false
        };

        navigationWaypoints.splice(insertIndex, 0, newWaypoint);
        showToast(`'${newWaypoint.address}' añadido como etapa. Recalculando...`, "success");
    }
    
    updateWaypointTypesAndLabels();
    renderWaypointMarkers();

    try {
        await recalculateAndDrawRoute(true);
        
        clearChargingPoints();

        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
            toggleRadaresRuta(true);
        }
    } catch (e) {
        showToast("Error recalculando la ruta tras añadir el punto de recarga.", "error");
    }

    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}

    // ===================================================================
    // NOMBRE: calculateDistanceToEndOfStep
    // RESUMEN: Calcula la distancia acumulada hasta el final de un paso específico de la ruta.
    function calculateDistanceToEndOfStep(route, targetLegIndex, targetStepIndex) {
        let totalDistance = 0;
        if (!route || !route.legs) return 0;
        for (let legIdx = 0; legIdx <= targetLegIndex; legIdx++) {
            const leg = route.legs[legIdx];
            if (!leg || !leg.steps) continue;
            const limitStepIndex = (legIdx === targetLegIndex) ? targetStepIndex : leg.steps.length - 1;
            for (let stepIdx = 0; stepIdx <= limitStepIndex; stepIdx++) {
                const step = leg.steps[stepIdx];
                if (step && typeof step.distance === 'number') {
                    totalDistance += step.distance;
                }
            }
        }
        return totalDistance;
    }


// ===================================================================
// NOMBRE: plotRemindersOnNavigationMap 
// RESUMEN: Dibuja TODOS los recordatorios visibles (generales + de ruta) en el mapa
//          de forma eficiente, actualizando la fuente GeoJSON en lugar de recrearla.
// ===================================================================
function plotRemindersOnNavigationMap() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
        return;
    }

    const sourceId = 'reminders-geojson-source';
    const plottedRemindersMap = new Map();

    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    const generalRemindersWithLocation = reminders.filter(r => 
        r.isLocationEnabled && 
        r.locationCoordinates?.latitude && 
        r.locationCoordinates?.longitude &&
        !r.isFromRuta 
    );
    generalRemindersWithLocation.forEach(reminder => {
        plottedRemindersMap.set(reminder.id, reminder);
    });

    const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresCheckbox && radaresCheckbox.checked && radaresEnRutaActual.length > 0) {
        radaresEnRutaActual.forEach(radar => {
            plottedRemindersMap.set(radar.id, radar);
        });
    }

    const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasCheckbox && tareasCheckbox.checked && tareasEnRutaActual.length > 0) {
        tareasEnRutaActual.forEach(tarea => {
            plottedRemindersMap.set(tarea.id, tarea);
        });
    }

    const locationsToPlot = Array.from(plottedRemindersMap.values());
    const geojsonFeatures = locationsToPlot.map(reminder => {
        const isRadar = reminder.text.toUpperCase().includes("RADAR") || reminder.excludeFromList;
        const speed = isRadar ? extractSpeedFromRadarText(reminder.text) : null;
        const properties = {
            reminderId: reminder.id, isRadar: isRadar, isFromTarea: reminder.isFromTarea || false,
        };
        if (speed !== null) { properties.speed = speed; }
        return {
            type: 'Feature',
            geometry: { type: 'Point', coordinates: [reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude] },
            properties: properties
        };
    });

    const geojsonData = { type: 'FeatureCollection', features: geojsonFeatures };
    
    const source = navigationMapInstance.getSource(sourceId);
    if (source) {
        source.setData(geojsonData);
    } else {
        try {
            navigationMapInstance.addSource(sourceId, { type: 'geojson', data: geojsonData });
            
            navigationMapInstance.addLayer({
                id: 'reminders-icons-layer', type: 'symbol', source: sourceId, filter: ['==', 'isRadar', false],
                layout: { 'icon-image': 'reminder-icon', 'icon-size': ['interpolate', ['linear'], ['zoom'], 10, 0.3, 14, 0.4, 17, 0.5], 'icon-allow-overlap': true, 'icon-anchor': 'bottom' }
            });
            navigationMapInstance.addLayer({
                id: 'radar-circles-layer', type: 'circle', source: sourceId, filter: ['==', 'isRadar', true],
                paint: { 'circle-radius': ['interpolate', ['linear'], ['zoom'], 11.5, 9, 16.5, 24], 'circle-color': 'red', 'circle-stroke-width': ['interpolate', ['linear'], ['zoom'], 11.5, 1, 16.5, 2], 'circle-stroke-color': ['case', ['get', 'isFromTarea'], '#00FF00', 'white'] }
            });
            navigationMapInstance.addLayer({
                id: 'radar-text-layer', type: 'symbol', source: sourceId, filter: ['==', 'isRadar', true], 
                layout: { 'text-field': ['case', ['has', 'speed'], ['to-string', ['get', 'speed']], 'Rdr'], 'text-font': ["Arial Unicode MS Bold", "Open Sans Bold"], 'text-size': ['interpolate', ['linear'], ['zoom'], 11.5, 8, 16.5, 22], 'text-allow-overlap': true },
                paint: { 'text-color': 'yellow', 'text-halo-color': 'black', 'text-halo-width': 1.5 }
            });

            const interactiveLayers = ['reminders-icons-layer', 'radar-circles-layer'];
            navigationMapInstance.on('mouseenter', interactiveLayers, () => { if(navigationMapInstance) navigationMapInstance.getCanvas().style.cursor = 'pointer'; });
            navigationMapInstance.on('mouseleave', interactiveLayers, () => { if(navigationMapInstance) navigationMapInstance.getCanvas().style.cursor = ''; });

        } catch (e) {
            console.error("Error al añadir la fuente/capas de recordatorios por primera vez:", e);
        }
    }
}    
    
// ===================================================================
// NOMBRE: updateLocateMeButtonsUI (NUEVA FUNCIÓN)
// RESUMEN: Sincroniza la apariencia (icono y título) de ambos botones de localización.
function updateLocateMeButtonsUI() {
    const topButton = document.getElementById('locate-me-on-reminders-map');
    const bottomButton = document.getElementById('zoom-locate-me-button');
    const buttons = [topButton, bottomButton].filter(Boolean);

    buttons.forEach(button => {
        const img = button.querySelector('img');
        if (!img) return;

        if (navigationFollowUser) {
            img.src = "PNG/DEJARSEGUIR.PNG";
            button.title = "Dejar de centrar el mapa en mi posición";
            const countdownOverlay = bottomButton?.querySelector('.countdown-overlay');
            if (countdownOverlay) {
                countdownOverlay.remove();
            }
        } else {
            img.src = "PNG/ESTASAQUI.PNG";
            button.title = "Mostrar mi posición actual y activar seguimiento";
        }
    });
}

// ===================================================================
// NOMBRE: clearLocateMeReactivationTimer (NUEVA FUNCIÓN)
// RESUMEN: Limpia los temporizadores de reactivación y el contador visual.
function clearLocateMeReactivationTimer() {
    if (window.followMeReactivationTimer) {
        clearTimeout(window.followMeReactivationTimer);
        window.followMeReactivationTimer = null;
    }
    if (manualZoomTimeout) {
        clearTimeout(manualZoomTimeout);
        manualZoomTimeout = null;
    }
    if (locateMeCountdownInterval) {
        clearInterval(locateMeCountdownInterval);
        locateMeCountdownInterval = null;
    }
    const bottomButton = document.getElementById('zoom-locate-me-button');
    const countdownOverlay = bottomButton?.querySelector('.countdown-overlay');
    if (countdownOverlay) {
        countdownOverlay.remove();
    }
}

// ===================================================================
// NOMBRE: startLocateMeReactivationTimer (NUEVA FUNCIÓN)
// RESUMEN: Inicia el temporizador de 30s y el contador visual para reactivar el seguimiento.
function startLocateMeReactivationTimer() {
    clearLocateMeReactivationTimer();

    window.followMeReactivationTimer = setTimeout(() => {
        const mapModal = document.getElementById('reminders-location-map-modal');
        if (!navigationFollowUser && mapModal && !mapModal.classList.contains('map-modal-hidden')) {
            handleLocateMeClick();
            showToast("Seguimiento automático reactivado.", "info");
        }
        clearLocateMeReactivationTimer();
    }, 30000);
    
    manualZoomTimeout = window.followMeReactivationTimer;

    let countdown = 30;
    const bottomButton = document.getElementById('zoom-locate-me-button');
    if (!bottomButton) return;

    let countdownOverlay = bottomButton.querySelector('.countdown-overlay');
    if (!countdownOverlay) {
        countdownOverlay = document.createElement('div');
        countdownOverlay.className = 'countdown-overlay';
        bottomButton.appendChild(countdownOverlay);
    }
    countdownOverlay.textContent = countdown;

    locateMeCountdownInterval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
            countdownOverlay.textContent = countdown;
        } else {
            clearLocateMeReactivationTimer();
        }
    }, 1000);
}

// ===================================================================
// NOMBRE: triggerArrivalSequence (NUEVA FUNCIÓN - CORRECCIÓN CRÍTICA)
// RESUMEN: Inicia la secuencia de llegada, estableciendo el flag de control
//          y mostrando el modal de estadísticas. Esta función faltaba.
// ===================================================================
function triggerArrivalSequence() {
    if (isArrivalSequenceStarted) return; // Doble chequeo por seguridad
    isArrivalSequenceStarted = true;
    
    console.log("[LLEGADA] Umbral de 20m alcanzado. Iniciando secuencia de llegada.");
    
    showArrivalStatsModal();
}
    
// ===================================================================
// NOMBRE: triggerManualMapInteraction (VERSIÓN FINAL CON LÓGICA DE MODOS)
// RESUMEN: Desactiva temporalmente el seguimiento. Si el modo es 'RUTA', lo cambia a 'OFF'.
//          Si el modo es 'AUTO', solo lo anula temporalmente sin cambiar el estado.
function triggerManualMapInteraction() {
    isManualZoomActive = true;
    navigationFollowUser = false;
    shouldCenterOnUser = false;

    clearLocateMeReactivationTimer();

    const currentAutoZoomMode = localStorage.getItem(AUTO_ZOOM_MODE_KEY) || 'off';
    const autoBtn = document.getElementById('zoom-auto-button');

    if (currentAutoZoomMode === 'route') {
        localStorage.setItem(AUTO_ZOOM_MODE_KEY, 'off');
        showToast("Modo 'Ruta' desactivado por interacción manual.", "info");

        if (autoBtn) {
            autoBtn.textContent = 'AUTO';
            autoBtn.classList.remove('active', 'route-mode');
            autoBtn.title = 'Zoom automático (Desactivado)';
        }
    }
  
    startLocateMeReactivationTimer();
    updateLocateMeButtonsUI();
}

// ===================================================================
// NOMBRE: handleManualMapInteraction (VERSIÓN CON DETECCIÓN DE INTENCIÓN)
// RESUMEN: Desactiva el seguimiento SOLO cuando detecta un gesto de arrastre o
function handleManualMapInteraction() {
    if (!navigationFollowUser) {
        startLocateMeReactivationTimer();
        return;
    }

    isManualZoomActive = true;
    navigationFollowUser = false;
    shouldCenterOnUser = false;
    
    updateLocateMeButtonsUI();
    startLocateMeReactivationTimer();
}

// ===================================================================
// NOMBRE: assignMapButtonListeners (VERSIÓN MODIFICADA)
// RESUMEN: Llama a toggleNavigationState con 'isRecovery' como false en el gesto de swipe.
// ===================================================================
function assignMapButtonListeners() {
    const header = document.getElementById('reminders-location-map-header');
    const togglePanelButton = document.getElementById('toggle-map-header-buttons-panel');
    const mapLocationSearchInput = document.getElementById('map-location-search-input');
    const mapFilterInput = document.getElementById('filter-input');
    
    if (!header || !togglePanelButton || !mapLocationSearchInput || !mapFilterInput) return;

    const reassignElement = (element) => {
        const newElement = element.cloneNode(true);
        element.parentNode.replaceChild(newElement, element);
        return newElement;
    };
    
    const newTogglePanelButton = reassignElement(togglePanelButton);
    let swipeStartX = 0, swipeStartY = 0, isSwiping = false, pressTimer = null;
    const handleGestureStart = (e) => { isSwiping = false; swipeStartX = e.touches ? e.touches[0].clientX : e.clientX; swipeStartY = e.touches ? e.touches[0].clientY : e.clientY; clearTimeout(pressTimer); pressTimer = setTimeout(() => { openAlertModal(); swipeStartX = 0; swipeStartY = 0; }, 800); if(e.type === 'touchstart') e.preventDefault(); };
    const handleGestureMove = (e) => { if (swipeStartX === 0) return; const moveX = e.touches ? e.touches[0].clientX : e.clientX; const moveY = e.touches ? e.touches[0].clientY : e.clientY; if (Math.abs(moveX - swipeStartX) > 10 || Math.abs(moveY - swipeStartY) > 10) { isSwiping = true; clearTimeout(pressTimer); } };
    const handleGestureEnd = (e) => { clearTimeout(pressTimer); if (swipeStartX === 0) return; const endX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX; const endY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY; const deltaX = endX - swipeStartX; const deltaY = endY - swipeStartY; const swipeThreshold = 50; if (!isSwiping) { toggleMapHeaderRowsVisibility(!mapHeaderButtonsVisible); } else { if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > swipeThreshold) { if (deltaY < 0) { toggleNavigationState(false, false); } else { loadRouteByName("TRABAJO", true); } } else if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > swipeThreshold) { if (deltaX < 0) { toggleMapImmersiveMode(); } else { loadRouteByName("CASA", true); } } } swipeStartX = 0; swipeStartY = 0; isSwiping = false; };
    newTogglePanelButton.addEventListener('mousedown', handleGestureStart);
    newTogglePanelButton.addEventListener('mousemove', handleGestureMove);
    newTogglePanelButton.addEventListener('mouseup', handleGestureEnd);
    newTogglePanelButton.addEventListener('mouseleave', handleGestureEnd);
    newTogglePanelButton.addEventListener('touchstart', handleGestureStart, { passive: false });
    newTogglePanelButton.addEventListener('touchmove', handleGestureMove, { passive: false });
    newTogglePanelButton.addEventListener('touchend', handleGestureEnd);
    
    if (!header._delegateAttached) {
        header.addEventListener('click', (event) => {
            const button = event.target.closest('button');
            if (!button || button.disabled) return;
            event.stopPropagation();
            
            switch (button.id) {
                 case 'close-reminders-location-map': closeNavigationMap(false); break;
                 case 'locate-me-on-reminders-map': handleLocateMeClick(true); break;
                 case 'nav-map-zoomtoggle-button': handleZoomToggleButtonClick(button); break;
                 case 'start-navigation-button': toggleNavigationState(false, false); break; // <-- MODIFICADO
                 case 'save-route-button': saveCurrentRoute(); break;
                 case 'delete-current-route-button': handleLoadOrDeleteRouteClick(button); break;
                 case 'load-saved-route-button': showLoadRouteModal(); break;
                 case 'add-radar-here': handleAddRadarHereClick(button); break;
                 case 'accident-alert-button-map': openAlertModal(); break;
                 case 'pdrs-ruta-button': handlePdrSearchButtonClick(); break;
                 case 'add-reminder-at-location-button': toggleAddReminderAtLocationMode(); break;
                 case 'toggle-simulate-gps-button': handleGpsSimulationToggle(); break;
                 case 'simulate-route-button': showSimulationModal(); break;
                 case 'reorder-route-stages-button': showReorderStagesModal(); break;
                 case 'navigation-map-help-button': showNavigationMapHelpModal(); break;
                 case 'map-location-search-button':
                    const currentSearchInput = document.getElementById('map-location-search-input');
                    const currentFilterInput = document.getElementById('filter-input');
                    const mainTerm = currentSearchInput?.value.trim() || '';
                    if (!mainTerm) { showToast("El campo de búsqueda principal no puede estar vacío.", "warning"); return; }
                    const filterTerm = currentFilterInput?.value.trim() || '';
                    let combinedSearchTerm = mainTerm;
                    if (filterTerm) { combinedSearchTerm += ' ' + filterTerm; }
                    searchAndAddWaypoint(combinedSearchTerm);
                    break;
                 case 'clear-map-search-input-button':
                    const currentSearchInputToClear = document.getElementById('map-location-search-input');
                    if (currentSearchInputToClear) { currentSearchInputToClear.value = ''; }
                    currentSearchInputToClear?.dispatchEvent(new Event('input'));
                    currentSearchInputToClear?.focus();
                    hideAddressSuggestionsModal();
                    break;
            }
        });
        header._delegateAttached = true;
    }

    const newMapLocationSearchInput = reassignElement(mapLocationSearchInput);
    const newMapFilterInput = reassignElement(mapFilterInput);

    let searchDebounceTimer;
    const handleSearchInput = () => {
        const hasMainText = newMapLocationSearchInput.value.trim() !== '';
        const searchBtn = document.getElementById('map-location-search-button');
        const clearBtn = document.getElementById('clear-map-search-input-button');
        if(searchBtn) searchBtn.style.display = hasMainText ? 'inline-flex' : 'none';
        if(clearBtn) clearBtn.style.display = hasMainText ? 'inline-flex' : 'none';
        
        clearTimeout(searchDebounceTimer);
        const mainTerm = newMapLocationSearchInput.value.trim();
        if (mainTerm) {
            const filterTerm = newMapFilterInput.value.trim();
            let combinedSearchTerm = mainTerm;
            if (filterTerm) { combinedSearchTerm += ' ' + filterTerm; }
            searchDebounceTimer = setTimeout(() => fetchAddressSuggestions(combinedSearchTerm), 450);
        } else {
            hideAddressSuggestionsModal();
        }
        localStorage.setItem(MAP_FILTER_INPUT_KEY, newMapFilterInput.value);
        markCacheAsDirty(); 
    };

    newMapLocationSearchInput.addEventListener('input', handleSearchInput);
    newMapFilterInput.addEventListener('input', handleSearchInput);

    newMapLocationSearchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            const mainTerm = newMapLocationSearchInput.value.trim();
            if (!mainTerm) { showToast("El campo de búsqueda principal no puede estar vacío.", "warning"); return; }
            const filterTerm = newMapFilterInput.value.trim() || '';
            let combinedSearchTerm = mainTerm;
            if (filterTerm) { combinedSearchTerm += ' ' + filterTerm; }
            hideAddressSuggestionsModal();
            searchAndAddWaypoint(combinedSearchTerm);
        }
    });
    
    const radaresCheckbox = reassignElement(document.getElementById('radares-ruta-checkbox'));
    radaresCheckbox.addEventListener('change', (e) => {
        markCacheAsDirty();
        toggleRadaresRuta(e.target.checked);
    });
    
    const tareasCheckbox = reassignElement(document.getElementById('tareas-ruta-checkbox'));
    tareasCheckbox.addEventListener('change', (e) => {
        markCacheAsDirty();
        toggleTareasRuta(e.target.checked);
    });
    
    const mapboxCheckbox = reassignElement(document.getElementById('mapbox-primary-checkbox'));
    mapboxCheckbox.addEventListener('change', (e) => {
        const OSRM_PRIMARY_KEY = 'boardinggate_useOsrmAsPrimary';
        localStorage.setItem(OSRM_PRIMARY_KEY, e.target.checked);
        markCacheAsDirty();
        const serviceName = e.target.checked ? 'OSRM' : 'Mapbox';
        showToast(`Servicio primario cambiado a ${serviceName}. Recalculando ruta...`, 'success');
        if (navigationWaypoints.length >= 2) { recalculateAndDrawRoute(false); }
    });
    
    newMapLocationSearchInput.value = '';
    newMapFilterInput.value = localStorage.getItem(MAP_FILTER_INPUT_KEY) || 'España';
}
    
// ===================================================================
// NOMBRE: getCurrentLocationAsync (NUEVA FUNCIÓN ASÍNCRONA)
// RESUMEN: Envuelve getCurrentLocation en una Promise para poder usar async/await.
function getCurrentLocationAsync() {
    return new Promise((resolve, reject) => {
        getCurrentLocation(
            (coords) => resolve(coords),
            (errorMsg) => reject(new Error(errorMsg))
        );
    });
}

// ===================================================================
// NOMBRE: displayChargingPointsOnMap (VERSIÓN GEOJSON CON DISPONIBILIDAD)
// RESUMEN: Carga los PDRs a una fuente GeoJSON para un renderizado nativo y eficiente.
function displayChargingPointsOnMap() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) return;

    // === CORRECCIÓN: Gestionamos las capas y fuente de PDRs de forma independiente ===
    const sourceId = 'pdrs-geojson-source';
    const layersToRemove = [
        'pdr-cards-layer-availability', 'pdr-cards-layer-price', 'pdr-cards-layer-operator', 'pdr-cards-layer-power', 'pdr-cards-layer-bg-halo', 'pdr-cards-layer-bg',
        'pdr-simple-text-layer', 'pdr-simple-circle-layer'
    ];
    layersToRemove.forEach(id => { try { if (navigationMapInstance.getLayer(id)) navigationMapInstance.removeLayer(id); } catch(e) {} });
    try { if (navigationMapInstance.getSource(sourceId)) navigationMapInstance.removeSource(sourceId); } catch(e) {}

    const geojsonFeatures = lastPdrSearchResults.map((point, index) => {
        const operatorText = point.operator.length > 15 ? point.operator.substring(0, 14) + '...' : point.operator;
        
        return {
            type: 'Feature',
            geometry: {
                type: 'Point',
                coordinates: [point.lon, point.lat]
            },
            properties: {
                ocmId: point.ocmId,
                index: index,
                bgColor: getChargingPointColorByPower(parseFloat(point.power)),
                isCheapest: point.isCheapest || false,
                power: point.power,
                operator: operatorText,
                price: point.price,
                availability: point.availabilityText
            }
        };
    });

    const geojsonData = {
        type: 'FeatureCollection',
        features: geojsonFeatures
    };
    
    navigationMapInstance.addSource(sourceId, { type: 'geojson', data: geojsonData });

    // Re-añadir todas las capas de PDRs
    navigationMapInstance.addLayer({ id: 'pdr-simple-circle-layer', type: 'circle', source: sourceId, filter: ['<=', ['zoom'], 14], paint: { 'circle-radius': 18, 'circle-color': ['get', 'bgColor'], 'circle-opacity': 1, 'circle-stroke-width': ['case', ['==', ['get', 'isCheapest'], true], 3.5, 2], 'circle-stroke-color': ['case', ['==', ['get', 'isCheapest'], true], '#FFD700', 'white'] } });
    navigationMapInstance.addLayer({ id: 'pdr-simple-text-layer', type: 'symbol', source: sourceId, filter: ['<=', ['zoom'], 14], layout: { 'text-field': ['concat', ['get', 'power'], 'kW'], 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 9, 'text-allow-overlap': true }, paint: { 'text-color': 'white', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
    navigationMapInstance.addLayer({ id: 'pdr-cards-layer-bg-halo', type: 'circle', source: sourceId, filter: ['all', ['>', ['zoom'], 14], ['==', ['get', 'isCheapest'], true]], paint: { 'circle-radius': 48, 'circle-color': '#FFD700', 'circle-opacity': 0.8, 'circle-blur': 1 } });
    navigationMapInstance.addLayer({ id: 'pdr-cards-layer-bg', type: 'circle', source: sourceId, filter: ['>', ['zoom'], 14], paint: { 'circle-radius': 45, 'circle-color': ['get', 'bgColor'], 'circle-opacity': 1, 'circle-stroke-width': 3, 'circle-stroke-color': 'white' } });
    navigationMapInstance.addLayer({ id: 'pdr-cards-layer-power', type: 'symbol', source: sourceId, filter: ['>', ['zoom'], 14], layout: { 'text-field': ['concat', ['get', 'power'], ' kW'], 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 14, 'text-offset': [0, -1.5], 'text-allow-overlap': true }, paint: { 'text-color': '#ffd700', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
    navigationMapInstance.addLayer({ id: 'pdr-cards-layer-operator', type: 'symbol', source: sourceId, filter: ['>', ['zoom'], 14], layout: { 'text-field': ['get', 'operator'], 'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'], 'text-size': 11, 'text-offset': [0, -0.3], 'text-allow-overlap': true, 'text-max-width': 10 }, paint: { 'text-color': 'white', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
    navigationMapInstance.addLayer({ id: 'pdr-cards-layer-price', type: 'symbol', source: sourceId, filter: ['>', ['zoom'], 14], layout: { 'text-field': ['get', 'price'], 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 13, 'text-offset': [0, 1.0], 'text-allow-overlap': true }, paint: { 'text-color': '#90ee90', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
    navigationMapInstance.addLayer({ id: 'pdr-cards-layer-availability', type: 'symbol', source: sourceId, filter: ['>', ['zoom'], 14], layout: { 'text-field': ['get', 'availability'], 'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'], 'text-size': 10, 'text-offset': [0, 2.8], 'text-allow-overlap': true }, paint: { 'text-color': '#e0e0e0', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
}    


// ===================================================================
// NOMBRE: renderWaypointMarkers (VERSIÓN OPTIMIZADA - CORRECCIÓN DE ÁMBITO)
// RESUMEN: Actualiza los marcadores de etapa de forma eficiente, solucionando
//          el error de redeclaración de funciones de eventos al encapsular
//          la lógica de asignación para cada marcador nuevo.
// ===================================================================
function renderWaypointMarkers() {
    if (!navigationMapInstance) return;

    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    const actualWaypointIds = new Set(actualWaypoints.map(wp => wp.id));

    // 1. ELIMINAR MARCADORES ANTIGUOS
    navigationWaypoints.forEach((wp) => {
        if (wp && wp.marker && !actualWaypointIds.has(wp.id)) {
            try {
                wp.marker.remove();
            } catch (e) {}
            wp.marker = null;
        }
    });

    // 2. AÑADIR O ACTUALIZAR MARCADORES EXISTENTES
    actualWaypoints.forEach(wp => {
        if (!wp || typeof wp.lat !== 'number' || typeof wp.lng !== 'number') return;

        // Si el waypoint NO tiene un marcador asociado, lo creamos.
        if (!wp.marker) {
            const waypointIconElement = createWaypointMarkerIcon(wp.label, wp.type, wp.visited, wp.id);
            waypointIconElement.dataset.waypointId = wp.id;

            wp.marker = new mapboxgl.Marker({
                element: waypointIconElement,
                draggable: false,
                anchor: 'center'
            }).setLngLat([wp.lng, wp.lat]).addTo(navigationMapInstance);

            // --- INICIO DE LA CORRECCIÓN: Encapsular la lógica de eventos ---
            // Usamos una función anónima autoejecutable para crear un nuevo ámbito para cada marcador.
            ((waypoint, marker) => {
                const markerElement = marker.getElement();
                let isDragging = false;
                let hasMovedEnough = false;
                let startPos = { x: 0, y: 0 };

                const onPointerDown = (e) => {
                    if (isNavigating) return;
                    e.stopPropagation();
                    isDragging = false;
                    hasMovedEnough = false;
                    const point = e.touches ? e.touches[0] : e;
                    startPos = { x: point.clientX, y: point.clientY };
                    document.addEventListener('mousemove', onPointerMove);
                    document.addEventListener('mouseup', onPointerUp);
                    document.addEventListener('touchmove', onPointerMove, { passive: false });
                    document.addEventListener('touchend', onPointerUp);
                };

                const onPointerMove = (e) => {
                    if (e.type === 'touchmove') e.preventDefault();
                    const point = e.touches ? e.touches[0] : e;
                    const deltaX = Math.abs(point.clientX - startPos.x);
                    const deltaY = Math.abs(point.clientY - startPos.y);
                    if (!hasMovedEnough && (deltaX > 5 || deltaY > 5)) {
                        hasMovedEnough = true;
                        navigationMapInstance.getCanvas().style.cursor = 'grabbing';
                        markerElement.style.cursor = 'grabbing';
                    }
                    if (hasMovedEnough) {
                        isDragging = true;
                        const mapContainer = document.getElementById('mapbox-map-actual-container');
                        const mapRect = mapContainer.getBoundingClientRect();
                        const relativeX = point.clientX - mapRect.left;
                        const relativeY = point.clientY - mapRect.top;
                        const coords = navigationMapInstance.unproject([relativeX, relativeY]);
                        marker.setLngLat(coords);
                    }
                };

                const onPointerUp = async (e) => {
                    document.removeEventListener('mousemove', onPointerMove);
                    document.removeEventListener('mouseup', onPointerUp);
                    document.removeEventListener('touchmove', onPointerMove);
                    document.removeEventListener('touchend', onPointerUp);
                    navigationMapInstance.getCanvas().style.cursor = '';
                    markerElement.style.cursor = 'pointer';
                    if (isDragging) {
                        const point = e.changedTouches ? e.changedTouches[0] : e;
                        const mapContainer = document.getElementById('mapbox-map-actual-container');
                        const mapRect = mapContainer.getBoundingClientRect();
                        const relativeX = point.clientX - mapRect.left;
                        const relativeY = point.clientY - mapRect.top;
                        const finalCoords = navigationMapInstance.unproject([relativeX, relativeY]);
                        const waypointIndex = navigationWaypoints.findIndex(w => w.id === waypoint.id);
                        if (waypointIndex !== -1) {
                            navigationWaypoints[waypointIndex].lat = finalCoords.lat;
                            navigationWaypoints[waypointIndex].lng = finalCoords.lng;
                            navigationWaypoints[waypointIndex].address = await getAddressForWaypoint(finalCoords.lat, finalCoords.lng);
                            await recalculateAndDrawRoute();
                            renderWaypointMarkers();
                        }
                    } else {
                        showWaypointActionModal(waypoint.id);
                    }
                    isDragging = false;
                    hasMovedEnough = false;
                };

                markerElement.addEventListener('mousedown', onPointerDown);
                markerElement.addEventListener('touchstart', onPointerDown, { passive: false });
            })(wp, wp.marker); // Pasamos el waypoint y el marcador actual a la función
            // --- FIN DE LA CORRECCIÓN ---

        } else {
            // Si el marcador ya existe, solo actualizamos su estilo (lógica sin cambios)
            const markerElement = wp.marker.getElement();
            const currentColor = markerElement.style.backgroundColor;
            let newColor;
            if (wp.visited) {
                newColor = 'rgba(85, 85, 85, 0.8)';
            } else if (wp.type === 'S') {
                newColor = 'rgba(0, 128, 0, 0.8)';
            } else if (wp.type === 'F') {
                newColor = 'rgba(0, 0, 255, 0.8)';
            } else {
                newColor = 'rgba(230, 140, 0, 0.8)';
            }
            if (currentColor !== newColor) {
                markerElement.style.backgroundColor = newColor;
                markerElement.style.border = `2px solid ${wp.visited ? '#555' : 'white'}`;
                markerElement.style.opacity = wp.visited ? '0.7' : '1';
            }
            wp.marker.setLngLat([wp.lng, wp.lat]);
            markerElement.textContent = wp.label;
        }
    });
}    

    
// ===================================================================
// NOMBRE: handleProgressBarLockToggle (CORREGIDA)
// RESUMEN: Cambia el estado del candado, lo guarda y actualiza la UI,
//          marcando la caché como modificada para que persista en la nube.
// ===================================================================
function handleProgressBarLockToggle() {
    isProgressBarLocked = !isProgressBarLocked;
    saveSettings(); // <-- ESTA LÍNEA ES LA CORRECCIÓN. Llama a la función que guarda y marca los datos para sincronizar.
    updateProgressBarLockIcon();
    showToast(`Panel de progreso ${isProgressBarLocked ? 'BLOQUEADO' : 'DESBLOQUEADO'}`, 'info');
    
    const progressBar = document.getElementById('navigation-bottom-progress-bar');
    if (isProgressBarLocked) {
        progressBar.classList.remove('progress-bar-auto-hidden');
    } else {
        if (navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
            updateTurnByTurnDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
        }
    }
}
    
    // ===================================================================
    // NOMBRE: formatPhotonFeatureName
    // RESUMEN: Formatea el nombre de una ubicación obtenida del servicio Photon.
    function formatPhotonFeatureName(feature) {
        if (!feature || !feature.properties) return "Ubicación desconocida";
        const props = feature.properties;
        let nameParts = [];
        if (props.name) nameParts.push(props.name);
        if (props.street) { let streetPart = props.street; if (props.housenumber) streetPart += ` ${props.housenumber}`; nameParts.push(streetPart); }
        if (props.postcode) nameParts.push(props.postcode);
        if (props.city && (!props.name || props.name.toLowerCase() !== props.city.toLowerCase())) nameParts.push(props.city);
        else if (props.county && (!props.name || props.name.toLowerCase() !== props.county.toLowerCase())) nameParts.push(props.county);
        else if (props.state && (!props.name || props.name.toLowerCase() !== props.state.toLowerCase())) nameParts.push(props.state);
        if (props.country && nameParts.length > 0 && props.country.toLowerCase() !== nameParts[nameParts.length - 1].toLowerCase()) nameParts.push(props.country);
        else if (props.country && nameParts.length === 0) nameParts = [props.country];
        let formattedName = nameParts.filter((value, index, self) => self.map(v => v.toLowerCase()).indexOf(value.toLowerCase()) === index).join(', ');
        if (!formattedName && feature.geometry && feature.geometry.coordinates) { formattedName = `(${feature.geometry.coordinates[1].toFixed(4)}, ${feature.geometry.coordinates[0].toFixed(4)})`; }
        return formattedName || "Ubicación desconocida";
    }

// ===================================================================
// NOMBRE: addWaypoint (MODIFICADA - GESTIONA MODO LIBRE)
// RESUMEN: Añade un punto de ruta y pausa el modo "Free Drive" si está activo.
async function addWaypoint(latlng, displayName = null) {
    if (isNavigating) return;
    
    if (navigationFollowUser) {
        navigationFollowUser = false;
        const locateMeButton = document.getElementById('locate-me-on-reminders-map');
        const locateMeImg = locateMeButton ? locateMeButton.querySelector('img') : null;
        if (locateMeButton && locateMeImg) {
            locateMeImg.src = "PNG/ESTASAQUI.PNG";
            locateMeButton.title = "Mostrar mi posición actual y activar seguimiento";
        }
        showToast("Seguimiento pausado para añadir puntos.", "info");
    }

    if (isFreeDriveActive) {
        isFreeDrivePaused = true;
        isFreeDriveActive = false;
        showToast("Modo Conducción Libre en pausa.", "info");
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        clearNavigationGraph();
    }
    
    let address = displayName;
    if (!address) {
        address = await getAddressForWaypoint(latlng.lat, latlng.lng);
    }

    const newWaypoint = {
        id: Date.now(),
        lat: latlng.lat,
        lng: latlng.lng,
        type: '',
        marker: null,
        label: '',
        address: address,
        visited: false,
        isCriticalForRecalc: true,
        isInternal: false,
        isRecalculatedStart: false
    };

    if (navigationWaypoints.length === 0 && navigationCurrentLocation) {
        const startPoint = {
            id: Date.now() - 1,
            lat: navigationCurrentLocation.latitude,
            lng: navigationCurrentLocation.longitude,
            type: 'S',
            marker: null,
            label: 'S',
            address: 'Posición Actual (GPS)',
            visited: true,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false
        };
        navigationWaypoints.push(startPoint);
    }

    navigationWaypoints.push(newWaypoint);
    await updateWaypointTypesAndLabels();
    renderWaypointMarkers();

    if (navigationWaypoints.filter(wp => wp && !wp.isInternal).length >= 2) {
        if (navigationWaypoints.filter(wp => wp && !wp.isInternal).length === 2) {
            showToast("PULSACIÓN LARGA SOBRE LA ETAPA para ELIMINAR, COMPARTIR o BUSCAR RUTAS ALTERNATIVAS. ARRASTRE para RESITUARLA", "instructional", 3000);
        }
        recalculateAndDrawRoute();
    }
    
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}

// ===================================================================
// NOMBRE: fetchAddressSuggestions (VERSIÓN CORREGIDA CON MANEJO DE "NO RESULTADOS")
// RESUMEN: En lugar de ocultar el modal cuando no hay resultados, lo mantiene
//          abierto y le pasa un array vacío para que muestre un mensaje.
async function fetchAddressSuggestions(query) {
    if (!query || query.length < 3) {
        hideAddressSuggestionsModal();
        return;
    }
    try {
        let queryToSearch = query.replace(/,/g, '');
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(queryToSearch)}&limit=60&accept-language=es&addressdetails=1`;
        
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Error de red: ${response.status}`);
        
        const data = await response.json();

        if (data && data.length > 0) {
            const results = data.reduce((acc, item) => {
                if (item && typeof item.lat === 'string' && item.lat.trim() !== '' && typeof item.lon === 'string' && item.lon.trim() !== '') {
                    acc.push({
                        display_name: item.display_name || "Ubicación desconocida",
                        lat: parseFloat(item.lat),
                        lon: parseFloat(item.lon)
                    });
                }
                return acc;
            }, []);
            if (results.length === 0) {
                 displayAddressSuggestionsModal([]);
            } else {
                 displayAddressSuggestionsModal(results.slice(0, 60));
            }

        } else {
            displayAddressSuggestionsModal([]);
        }
    } catch (error) {
        showToast(`Error buscando sugerencias: ${error.message}`, "error");
        hideAddressSuggestionsModal();
    }
}   
// ===================================================================
// NOMBRE: snapCoordsToRoad (NUEVA FUNCIÓN)
// RESUMEN: Toma coordenadas y devuelve las coordenadas del punto más cercano en la red de carreteras.
async function snapCoordsToRoad(lat, lon) {
    try {
        const nearestUrl = `${OSRM_SERVICE_URL}/nearest/v1/driving/${lon},${lat}?number=1`;
        const nearestResponse = await fetch(nearestUrl);
        if (!nearestResponse.ok) {
            console.warn(`OSRM /nearest falló, se usarán coordenadas originales.`);
            return { lat: lat, lng: lon };
        }
        const nearestData = await nearestResponse.json();
        if (nearestData.code === "Ok" && nearestData.waypoints && nearestData.waypoints.length > 0) {
            const snappedCoords = nearestData.waypoints[0].location;
            return { lat: snappedCoords[1], lng: snappedCoords[0] };
        } else {
            console.warn("OSRM /nearest no encontró un punto válido, se usarán coordenadas originales.");
            return { lat: lat, lng: lon };
        }
    } catch (error) {
        console.error("Error en snapCoordsToRoad:", error);
        return { lat: lat, lng: lon }; 
    }
}

// ===================================================================
// NOMBRE: searchAndAddWaypoint (MODIFICADA - SIN L.latLng)
// RESUMEN: Busca una dirección, la transforma en coordenadas, las ajusta a la carretera y la añade como waypoint.
async function searchAndAddWaypoint(addressQuery = null) {
    const searchInput = document.getElementById('map-location-search-input');
    const address = addressQuery || searchInput.value.trim();
    if (!address) {
        showToast("Por favor, introduce una dirección para buscar", "warning");
        return;
    }

    const searchButton = document.getElementById('map-location-search-button');
    if (searchButton) {
        searchButton.disabled = true;
        searchButton.innerHTML = `<img src="PNG/BUSCANDO.PNG" alt="Buscando...">`;
    }

    try {
        showToast("Buscando dirección...", "info", 3000);
        const searchUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address.replace(/,/g, ''))}&limit=1&accept-language=es&addressdetails=1`;
        
        const searchResponse = await fetch(searchUrl);
        if (!searchResponse.ok) throw new Error(`Error de red en Nominatim: ${searchResponse.status}`);
        
        const searchData = await searchResponse.json();
        if (!searchData || searchData.length === 0) throw new Error("Dirección no encontrada");
        
        const result = searchData[0];
        const initialLat = parseFloat(result.lat);
        const initialLon = parseFloat(result.lon);
        const displayName = result.display_name || `Ubicación (${initialLat.toFixed(3)}, ${initialLon.toFixed(3)})`;
        if (isNaN(initialLat) || isNaN(initialLon)) throw new Error("Coordenadas no válidas de Nominatim");

        showToast("Ajustando a la carretera más cercana...", "info", 3000);
        const snappedLatLng = await snapCoordsToRoad(initialLat, initialLon);
        
        await addWaypoint(snappedLatLng, displayName);
        
        if (navigationMapInstance) navigationMapInstance.flyTo({ center: [initialLon, initialLat], zoom: 15 });
        if (searchInput) {
            searchInput.value = '';
            searchInput.dispatchEvent(new Event('input'));
        }
        showToast("Ubicación añadida a la ruta", "success");

    } catch (error) {
        showToast(`Error al buscar dirección: ${error.message}`, "error", 4000, true);
    } finally {
        if (searchButton) {
            searchButton.disabled = false;
            searchButton.innerHTML = `<img src="PNG/ANADIRPUNTO.PNG" alt="Añadir Punto Ruta">`;
            if (searchInput && searchInput.value.trim() === '') {
                searchButton.style.display = 'none';
                const clearMapSearchBtn = document.getElementById('clear-map-search-input-button');
                if (clearMapSearchBtn) clearMapSearchBtn.style.display = 'none';
            }
        }
    }
}    
    
    // ===================================================================
    // NOMBRE: hideAddressSuggestionsModal
    // RESUMEN: Oculta el modal de sugerencias de direcciones.
    function hideAddressSuggestionsModal() {
        const modal = document.getElementById('address-suggestions-modal');
        if (modal && !modal.classList.contains('hidden')) {
            clearModalAutoCloseTimer(modal, modal.querySelector('#close-address-suggestions-modal'), 'address-suggestions-modal');
            modal.classList.add('hidden');
        }
    } 
    // ===================================================================
    // NOMBRE: toggleMapLocationSearchVisibility
    // RESUMEN: Muestra u oculta la fila de búsqueda del mapa.
    function toggleMapLocationSearchVisibility(show) {
        const searchRow = document.getElementById('search-row-map-header');
        const reorderButton = document.getElementById('reorder-route-stages-button');
        if (show) {
            if (searchRow) searchRow.style.display = 'flex';
            if (reorderButton && navigationWaypoints.length >= 2) reorderButton.style.display = 'inline-flex';
            else if (reorderButton) reorderButton.style.display = 'none';
        } else {
            if (searchRow) searchRow.style.display = 'none';
            if (reorderButton) reorderButton.style.display = 'none';
        }
    } 
// ===================================================================
// NOMBRE: updateWaypointTypesAndLabels (VERSIÓN CORREGIDA Y DEFINITIVA 2)
// RESUMEN: Actualiza los tipos y etiquetas, esperando a que todas las operaciones asíncronas finalicen.
async function updateWaypointTypesAndLabels() {
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    if (actualWaypoints.length === 0) return;

    await Promise.all(actualWaypoints.map(async (wp, index) => {
        if (!wp) return;

        if (actualWaypoints.length === 1) {
            wp.type = 'S';
            wp.label = 'S';
        } else if (index === 0) {
            wp.type = 'S';
            wp.label = 'S';
        } else if (index === actualWaypoints.length - 1) {
            wp.type = 'F';
            wp.label = 'F';
        } else {
            wp.type = 'intermediate';
            wp.label = String(index);
        }

        if (!wp.address) {
            if (typeof wp.lat === 'number' && typeof wp.lng === 'number') {
                wp.address = await getAddressForWaypoint(wp.lat, wp.lng);
            } else {
                wp.address = "Coordenadas no disponibles para dirección";
            }
        }
    }));

    navigationWaypoints.forEach(wp => {
        if(wp && (wp.isInternal || wp.isRecalculatedStart)) {
            wp.label = '';
        }
    });
} 

// ===================================================================
// NOMBRE: getRouteForSingleLeg (MODIFICADA - SIN L.latLng)
// RESUMEN: Obtiene la distancia y duración de un solo tramo de ruta.
async function getRouteForSingleLeg(lon1, lat1, lon2, lat2) {
    const url = `${OSRM_SERVICE_URL}/driving/${lon1},${lat1};${lon2},${lat2}?overview=false&alternatives=false&steps=false&annotations=false`;
    try {
        const response = await fetch(url);
        if (!response.ok) {
            return { distance: 0, duration: 0 };
        }
        const data = await response.json();
        if (data.routes && data.routes.length > 0 && data.routes[0]) {
            return {
                distance: data.routes[0].distance || 0,
                duration: data.routes[0].duration || 0
            };
        }
        return { distance: 0, duration: 0 };
    } catch (error) {
        return { distance: 0, duration: 0 };
    }
}    

// ===================================================================
// NOMBRE: clearAllWaypointMarkersFromMap (MODIFICADA - PARA MAPBOX)
// RESUMEN: Elimina todos los marcadores de puntos de ruta del mapa.
function clearAllWaypointMarkersFromMap() {
    navigationWaypoints.forEach(wp => {
        if (wp && wp.marker) {
            wp.marker.remove();
            wp.marker = null;
        }
    });
}

// ===================================================================
// NOMBRE: handleSendToTeslaClick
// RESUMEN: Abre el diálogo nativo para compartir un destino a la app de Tesla.
async function handleSendToTeslaClick(lat, lng, name) {
    if (!navigator.share) {
        showToast("Tu navegador no soporta la función de compartir.", "warning");
        return;
    }

    try {
        const shareData = {
            title: `Destino: ${name}`,
            text: `Enviar "${name}" a la app de Tesla para iniciar la navegación.`,
            url: `https://maps.google.com/?q=${lat},${lng}`
        };

        await navigator.share(shareData);
        showToast("Selecciona la app de Tesla para enviar el destino.", "info");

    } catch (err) {
        if (err.name !== 'AbortError') {
            showToast(`Error al compartir: ${err.message}`, "error");
        }
    }
}
// ===================================================================
// NOMBRE: clearAllRouteVisualsFromMap (NUEVA FUNCIÓN MAESTRA)
// RESUMEN: Realiza una limpieza completa y garantizada de TODOS los
//          elementos visuales de la ruta (marcadores, etiquetas, líneas)
function clearAllRouteVisualsFromMap() {
    if (!navigationMapInstance) return;

    document.querySelectorAll('.navigation-waypoint-marker').forEach(el => el.remove());
    document.querySelectorAll('.route-label-marker').forEach(el => el.remove());

    if (navigationMapInstance.isStyleLoaded()) {
        const style = navigationMapInstance.getStyle();

        if (style && style.layers) {
            style.layers.forEach(layer => {
                if (layer.id === 'route' || layer.id.startsWith('alt-layer-')) {
                    try {
                        if (navigationMapInstance.getLayer(layer.id)) {
                            navigationMapInstance.removeLayer(layer.id);
                        }
                    } catch (e) {
                        console.warn(`Error al eliminar capa ${layer.id}: ${e.message}`);
                    }
                }
            });
        }

        if (style && style.sources) {
            Object.keys(style.sources).forEach(sourceId => {
                if (sourceId === 'route' || sourceId.startsWith('alt-route-')) {
                    try {
                        if (navigationMapInstance.getSource(sourceId)) {
                            navigationMapInstance.removeSource(sourceId);
                        }
                    } catch (e) {
                        console.warn(`Error al eliminar fuente ${sourceId}: ${e.message}`);
                    }
                }
            });
        }
    }
    
    navigationRouteLayer = null;
    alternativeRouteLayers = [];
}

// ===================================================================
// NOMBRE: resetNavigationState (MODIFICADA - USA LA NUEVA LIMPIEZA MAESTRA)
// RESUMEN: Reinicia a su estado original TODAS las variables relacionadas
//          con la navegación, llamando primero a la limpieza visual garantizada.
// ===================================================================
function resetNavigationState() {
    clearAllRouteVisualsFromMap();

    const autoStartModal = document.getElementById('auto-start-nav-modal');
    if (autoStartModal) {
        hideAutoStartNavigationModal();
        showToast("Inicio automático cancelado: La ruta ha sido modificada/borrada.", "info");
    }

    navigationWaypoints = [];
    navigationCurrentRouteData = null;
    isNavigating = false;
    currentRouteNameForSaving = null;
    
    lastCarDistanceAlongRouteForNavLogic = 0;
    lastValidCarDistanceForDisplay = 0;
    currentLegIndexNav = 0;
    currentStepIndexNav = 0;
    lastDisplayedManeuverIcon = null;
    lastProcessedStepIdentifier = null;
    lastProcessedStepForLock = null;

    tripInitialOverallEtaTime = null;
    originalTripEtaTime = null; 
    currentStageInitialExpectedEtaTime = null;
    accumulatedDeviationMs = 0;
    accumulatedDistanceBeforeCurrentSegment = 0;
    navigationStartTimeForStats = null;
    totalDistanceTravelledForStats = 0;
    lastPositionForStats = null;
    maxSpeedDuringTrip = 0;
    maxSpeedCoordinates = null;
    maxAltitudeDuringTrip = -Infinity;
    minAltitudeDuringTrip = Infinity;
    window.averageSpeedKmh = 0;

    radaresEnRutaActual = [];
    tareasEnRutaActual = [];
    alternativeRoutesCache.clear();
    selectedStageRoutes.clear();

    lastPdrSearchResults = [];
    currentChargingPointsOnRoute = [];
    if (window.lastOcmApiResponse) {
        window.lastOcmApiResponse = null;
    }
    
    isCacheDirty = true;
    trafficAlertsCache = [];
    
    speedMarkerFeatures = [];
    if (navigationMapInstance && navigationMapInstance.getSource('speed-markers-source')) {
        navigationMapInstance.getSource('speed-markers-source').setData({
            type: 'FeatureCollection',
            features: [] 
        });
    }

    isArrivalSequenceStarted = false;
    hideNavigationUI();
    hideMapInfoOverlay();
    clearNavigationGraph();
    
    actualizarContadorRadares(0);
    actualizarContadorTareas(0);
}

// ===================================================================
// NOMBRE: handleDeleteWaypointClick (MODIFICADA - CIERRA MODAL DE INICIO)
// RESUMEN: Elimina una etapa Y SUS PUNTOS INTERNOS ASOCIADOS.
async function handleDeleteWaypointClick(waypointId) {
    if (isNavigating) {
        showToast("No se pueden borrar puntos mientras se navega.", "warning");
        return;
    }
    clearAlternativeRoutesDisplay();
    alternativeRoutesCache.clear();

    const waypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    if (waypointIndex === -1) return;
    
    navigationWaypoints = navigationWaypoints.filter(wp => !(wp.isInternal && wp.parentWaypointId === waypointId));
    
    const finalWaypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    if (finalWaypointIndex !== -1) {
        const waypointToDelete = navigationWaypoints[finalWaypointIndex];
        if (waypointToDelete.marker && navigationMapInstance) {
            waypointToDelete.marker.remove();
            waypointToDelete.marker = null;
        }
        navigationWaypoints.splice(finalWaypointIndex, 1);
    }
 
    if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) { 
        const autoStartModal = document.getElementById('auto-start-nav-modal');
        if (autoStartModal) {
            hideAutoStartNavigationModal();
            showToast("Inicio automático cancelado: La ruta ya no es válida.", "info");
        }
        
        clearAllWaypointMarkersFromMap(); 
        navigationWaypoints = [];
        if (navigationMapInstance && navigationMapInstance.getLayer('route')) {
            navigationMapInstance.removeLayer('route');
            navigationMapInstance.removeSource('route');
            navigationRouteLayer = null;
        }
        

        navigationCurrentRouteData = null;
        hideNavigationUI();
        hideMapInfoOverlay();
        eliminarRadaresDeRuta();
        actualizarContadorRadares(0);
        eliminarTareasDeBarraProgreso();
        actualizarContadorTareas(0);
        const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresCheckbox) {
             localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckbox.checked)); 
        }
        const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasCheckbox) {
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckbox.checked));
        }
    } else {
        await updateWaypointTypesAndLabels();
        renderWaypointMarkers();
        if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
            if (navigationMapInstance && navigationMapInstance.getLayer('route')) { navigationMapInstance.removeLayer('route'); navigationMapInstance.removeSource('route'); }
            navigationRouteLayer = null;
           
            navigationCurrentRouteData = null;
            hideMapInfoOverlay();
            eliminarRadaresDeRuta();
            actualizarContadorRadares(0);
            eliminarTareasDeBarraProgreso();
            actualizarContadorTareas(0);
            const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
            if (radaresCheckbox) {
                localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckbox.checked));
            }
            const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
            if (tareasCheckbox) {
                localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckbox.checked));
            }
        } else {
            recalculateAndDrawRoute().then(() => {
                const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
                if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                    toggleRadaresRuta(true);
                }
                const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
                if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                    toggleTareasRuta(true);
                }
            });
        }
        showToast("Etapa eliminada.", "info");
    }
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}    

// =============================
// NOMBRE: translateOcmTerm
// RESUMEN: Traduce términos comunes de OCM del inglés al castellano.
function translateOcmTerm(term) {
    if (!term) return 'No especificado';
     const translations = {
        'Parking': 'Parking de pago',
        'Operational': 'Operativo',
        'Non-Operational': 'No operativo',
        'Not Operational': 'No operativo',   
        'Partly-Operational': 'Parcialmente operativo',
        'Planned For Future Date': 'Planificado',
        'Decommissioned': 'Fuera de servicio',
        'Public - Membership Required': 'Público - Requiere Membresía',
        'Public - Pay At Location': 'Público - Pago en el sitio',
        'Public': 'Público',
        'Privately Owned - For Staff, Visitors or Customers': 'Privado - Para personal o clientes',
        'Private - For Staff, Visitors or Customers': 'Privado - Para personal o clientes',
        'Private - Restricted Access': 'Privado - Acceso restringido'
    };
    return translations[term] || term;
}   

// ===================================================================
// NOMBRE: clearChargingPoints (CORREGIDA - PARA MAPBOX GEOJSON)
// RESUMEN: Elimina del mapa los puntos de recarga vaciando la fuente de datos.
function clearChargingPoints() {
    currentChargingPointsOnRoute = [];
    lastPdrSearchResults = [];
    
    const existingModal = document.querySelector('.ocm-modal-overlay');
    if (existingModal) {
        existingModal.remove();
    }
    
    if (window.lastOcmApiResponse) {
        window.lastOcmApiResponse = null;
    }
 
    if (navigationMapInstance && navigationMapInstance.getSource('pdrs-geojson-source')) {
        navigationMapInstance.getSource('pdrs-geojson-source').setData({
            type: 'FeatureCollection',
            features: []
        });
    }

    const pdrButton = document.getElementById('pdrs-ruta-button');
    if (pdrButton) pdrButton.classList.remove('pdr-search-highlight');
    pdrSearchState = 'initial'; 
}
    
// ===================================================================
// NOMBRE: handleFreeDriveCancellation
// RESUMEN: Gestiona la reanudación del modo libre cuando se cancela una planificación de ruta.
function handleFreeDriveCancellation() {
    if (isFreeDrivePaused) {
        isFreeDriveActive = true;
        isFreeDrivePaused = false;
        
        if (freeDriveStats && !freeDriveStats.startTime) {
            freeDriveStats.startTime = new Date();
        }

        showToast("Planificación de ruta cancelada. Reanudando registro de Conducción Libre.", "info");
        
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        initializeNavigationGraph();
    }
}    

// ===================================================================
// NOMBRE: restoreOriginalGrid
// RESUMEN: Restaura el grid de marcadores a su estado original de fábrica.
function restoreOriginalGrid() {
    if (confirm('¿Restaurar el grid de botones a su estado original? Perderás tu personalización del grid (URLs, nombres, orden).')) {
        localStorage.removeItem('customGridData');
        localStorage.removeItem('gridFilterValue');
        loadCustomData();
        renderGrid();
        renderToggleButtons();
        loadSavedSettings();
        updateButtonStyles();
        filterGridItems();
        document.getElementById('config-restore-grid-status').textContent = 'Grid restaurado al original. Recargando...';
        document.getElementById('config-restore-grid-status').style.color = '#28a745';
        showToast('Grid restaurado. Recargando...', 'success');
        setTimeout(() => location.reload(), 1500);
    }
}

// ===================================================================
// NOMBRE: clearAllLocalData
// RESUMEN: Borra todos los datos guardados en el almacenamiento local del navegador.
function clearAllLocalData() {
    if (confirm('¡ATENCIÓN! Esto borrará TODOS los datos locales (marcadores personalizados, recordatorios, configuración de usuario, PIN, etc.). Esta acción NO SE PUEDE DESHACER. ¿Estás seguro?')) {
        if (confirm('DE VERDAD, ¿ESTÁS COMPLETAMENTE SEGURO? SE BORRARÁ TODO.')) {
            managedKeys.forEach(key => localStorage.removeItem(key));
            localStorage.removeItem('personalizationHelpShown');
            localStorage.removeItem('gridFilterValue');
            showToast('Todos los datos locales borrados. Recargando...', 'success');
            setTimeout(() => location.reload(), 1500);
        } else {
            showToast('Borrado cancelado', 'info');
        }
    } else {
        showToast('Borrado cancelado', 'info');
    }
}

// ===================================================================
// NOMBRE: fetchKMLFilesList
// RESUMEN: Obtiene la lista de archivos KML a procesar desde una URL.
async function fetchKMLFilesList(listUrl) {
    try {
        const response = await fetch(listUrl, { cache: 'no-cache' });
        if (!response.ok) throw new Error(`Error HTTP ${response.status} obteniendo lista KML: ${listUrl}`);
        const text = await response.text();
        return text.split('\n').map(f => f.trim()).filter(f => f.length > 0 && f.toLowerCase().endsWith('.kml'));
    } catch (error) {
        showToast(`Error cargando lista ${listUrl.split('/').pop()}`, 'error');
        return [];
    }
}

// ===================================================================
// NOMBRE: fetchAndParseKML
// RESUMEN: Descarga y decodifica un archivo KML.
async function fetchAndParseKML(kmlFileUrl) {
    try {
        const response = await fetch(kmlFileUrl, { cache: 'no-cache' });
        if (!response.ok) throw new Error(`Error HTTP ${response.status} obteniendo KML: ${kmlFileUrl}`);
        const buffer = await response.arrayBuffer();
        const decoder = new TextDecoder('iso-8859-1');
        const kmlText = decoder.decode(buffer);
        return parseKML(kmlText);
    } catch (error) {
        throw error;
    }
}

// ===================================================================
// NOMBRE: parseKML
// RESUMEN: Parsea el texto de un archivo KML para extraer los Placemarks.
function parseKML(kmlText) {
    const placemarks = [];
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(kmlText, "application/xml");
    const parserErrorNode = xmlDoc.querySelector("parsererror");
    if (parserErrorNode) {
        let errorMessage = "Error de parseo XML desconocido.";
        if (parserErrorNode.textContent) {
            const match = parserErrorNode.textContent.match(/error on line \d+ at column \d+: ([^\n]+)/);
            if (match && match[1]) {
                errorMessage = match[1];
            } else {
                errorMessage = parserErrorNode.textContent.split('\n')[0] || parserErrorNode.textContent;
            }
        } else if (parserErrorNode.innerText) {
             errorMessage = parserErrorNode.innerText.split('\n')[0] || parserErrorNode.innerText;
        }
        throw new Error("KML parsing error: " + errorMessage);
    }
    const KML_NS_GOOGLE = "http://earth.google.com/kml/2.0";
    const KML_NS_OGC = "http://www.opengis.net/kml/2.2";
    let placemarkNodes = xmlDoc.getElementsByTagNameNS(KML_NS_GOOGLE, 'Placemark');
    if (placemarkNodes.length === 0) {
        placemarkNodes = xmlDoc.getElementsByTagNameNS(KML_NS_OGC, 'Placemark');
    }
     if (placemarkNodes.length === 0) {
        placemarkNodes = xmlDoc.getElementsByTagName('Placemark');
    }
    for (let i = 0; i < placemarkNodes.length; i++) {
        const node = placemarkNodes[i];
        let nameNode, coordinatesNode;
        nameNode = node.getElementsByTagNameNS(KML_NS_GOOGLE, 'name')[0] || node.getElementsByTagNameNS(KML_NS_OGC, 'name')[0] || node.getElementsByTagName('name')[0];
        coordinatesNode = node.getElementsByTagNameNS(KML_NS_GOOGLE, 'coordinates')[0] || node.getElementsByTagNameNS(KML_NS_OGC, 'coordinates')[0] || node.getElementsByTagName('coordinates')[0];
        if (nameNode && coordinatesNode) {
            const name = nameNode.textContent.trim();
            const coordinatesRaw = coordinatesNode.textContent.trim();
            const coordPartsMatch = coordinatesRaw.match(/^(-?\d+\.?\d*)[,\s]+(-?\d+\.?\d*)/);
            if (name && coordPartsMatch && coordPartsMatch.length >= 3) {
                const lonStr = coordPartsMatch[1];
                const latStr = coordPartsMatch[2];
                const coordinates = `${lonStr},${latStr}`;
                const lon = parseFloat(lonStr);
                const lat = parseFloat(latStr);
                if (!isNaN(lon) && !isNaN(lat)) {
                    if (name.startsWith("Radares BBS www.laradiobbs.net") && lon === 0 && lat === 0) {
                        continue;
                    }
                    placemarks.push({ name, coordinates });
                }
            }
        }
    }
    return placemarks;
}


// ===================================================================
// NOMBRE: importRadars (MODIFICADA)
// RESUMEN: Importa radares y limpia la caché para forzar su reconstrucción.
async function importRadars() {
    window.radarsCache = null;
    window.radarsSpatialIndex = null;
    localStorage.removeItem('radarsCacheData');
    localStorage.removeItem('radarsCacheIndex');
    localStorage.removeItem('radarsCacheVersion');

    const latFilterValue = document.getElementById('radar-filter-lat').value.trim();
    const lonFilterValue = document.getElementById('radar-filter-lon').value.trim();
    const keywordsFilterRaw = document.getElementById('radar-filter-keywords').value.trim().toUpperCase();
    const keywordsFilter = keywordsFilterRaw ? keywordsFilterRaw.split(/\s+/).filter(k => k) : [];
    const importExtra = document.getElementById('import-extra-radars-checkbox').checked;
    const statusMessage = document.getElementById('radar-import-status');
    const progressContainer = document.getElementById('radar-import-progress-container');
    
    progressContainer.style.display = 'block';
    const progressBar = document.getElementById('radar-import-progress-bar');
    if(progressBar) progressBar.style.display = 'none';

    statusMessage.textContent = 'Iniciando importación...';
    statusMessage.style.color = '';
    try {
        let filesToProcess = await fetchKMLFilesList(KML_FILES_LIST_STANDARD);
        if (importExtra) {
            const extraFiles = await fetchKMLFilesList(KML_FILES_LIST_EXTRA);
            filesToProcess = filesToProcess.concat(extraFiles.filter(f => !filesToProcess.includes(f)));
        }
        if (filesToProcess.length === 0) {
            statusMessage.textContent = 'No se encontraron listas de archivos KML para procesar.';
            showToast('No hay archivos KML en las listas.', 'warning');
            setTimeout(() => { progressContainer.style.display = 'none'; }, 3000);
            return;
        }
        
        statusMessage.textContent = `Procesando ${filesToProcess.length} archivos KML...`;
        
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        let newRadarsCount = 0;

        const processingPromises = filesToProcess.map(kmlFileName =>
            fetchAndParseKML(KML_BASE_PATH + kmlFileName).catch(e => {
                console.warn(`Error procesando ${kmlFileName}, se omitirá.`, e);
                return [];
            })
        );
        
        const results = await Promise.all(processingPromises);
        
        results.flat().forEach(placemark => {
            const name = placemark.name.toUpperCase();
            const coords = placemark.coordinates;
            const matchesKeywords = keywordsFilter.length === 0 || keywordsFilter.some(kw => name.includes(kw));
            if (coords && matchesKeywords) {
                const [lonStr, latStr] = coords.split(',');
                const lon = parseFloat(lonStr);
                const lat = parseFloat(latStr);
                if (isNaN(lat) || isNaN(lon)) return;
                
                const matchesLat = parseCoordinateFilter(latFilterValue, lat);
                const matchesLon = parseCoordinateFilter(lonFilterValue, lon);

                if (matchesLat && matchesLon) {
                    const existingRadar = reminders.find(r =>
                        r.isLocationEnabled && r.locationCoordinates &&
                        Math.abs(r.locationCoordinates.latitude - lat) < COORD_EPSILON &&
                        Math.abs(r.locationCoordinates.longitude - lon) < COORD_EPSILON &&
                        (r.text.toUpperCase().includes("RADAR") || r.excludeFromList)
                    );
                    if (!existingRadar) {
                        const now = new Date();
                        const newRadar = {
                            id: Date.now() + Math.random() + newRadarsCount,
                            text: `<b>RADAR: ${placemark.name}</b>`,
                            type: 'simple', time: '00:01',
                            date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                            createdAt: now.toISOString(), managedByUser: false,
                            isLocationEnabled: true, locationCoordinates: { latitude: lat, longitude: lon },
                            radiusMeters: 400, excludeFromList: true
                        };
                        reminders.push(newRadar);
                        newRadarsCount++;
                    }
                }
            }
        });
        
        localStorage.setItem('reminders', JSON.stringify(reminders));
        statusMessage.textContent = `Importación completa. ${newRadarsCount} nuevos radares/POIs añadidos.`;
        statusMessage.style.color = '#28a745';
        showToast(`${newRadarsCount} nuevos radares/POIs añadidos.`, 'success');
        updateReminderCount();
        updateButtonStyles();
        markCacheAsDirty();
    } catch (error) {
        statusMessage.textContent = `Error general: ${error.message}`;
        statusMessage.style.color = 'red';
        showToast('Error durante la importación.', 'error');
    } finally {
         setTimeout(() => {
            progressContainer.style.display = 'none';
            if(progressBar) progressBar.style.display = 'block';
            statusMessage.style.color = '';
        }, 5000);
    }
}

// ===================================================================
// NOMBRE: showSimulationModal (RESTAURADA)
// RESUMEN: Muestra un modal con la lista de maniobras de la ruta actual. No inicia ninguna simulación.
async function showSimulationModal() {
    const canSimulate = (navigationWaypoints.filter(wp => !wp.isInternal && !wp.isRecalculatedStart).length >= 2 && navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) ||
                    (isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]);
    if (!canSimulate) {
        showToast("Se necesitan al menos 2 puntos y una ruta calculada para mostrar las maniobras.", "warning");
        return;
    }
    const route = navigationCurrentRouteData.routes[0];
    if (!route || !route.legs || route.legs.length === 0) {
        showToast("Datos de ruta incompletos para mostrar maniobras.", "error");
        return;
    }
    closeOtherModals('simulation-modal');
    
    let modal = document.getElementById('simulation-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'simulation-modal';
        document.body.appendChild(modal);
    }
    modal.innerHTML = `
        <h2 style="font-size: 1.3rem; font-weight: bold; text-align: center; margin-bottom: 1rem; color: white;">Maniobras de la Ruta</h2>
        <div class="modal-top-buttons" style="justify-content: flex-start; margin-bottom: 1rem;">
            <button id="close-simulation-modal" style="flex: 0 0 auto; width: auto; min-width: unset;">Salir <span class="button-countdown-timer unified-countdown-style"></span></button>
        </div>
        <div id="simulation-content-area"><p>Cargando maniobras...</p></div>
        <p style="font-size: 0.8rem; color: #8e8e93; text-align: center; margin-top: 1rem; font-style: italic;">Si quiere ver la maniobra pulse encima de una</p>
    `;
    modal.classList.remove('hidden');

    const closeButton = modal.querySelector('#close-simulation-modal');
    const closeSimulationModalHandler = () => {
        if (simulationModalTimer) clearTimeout(simulationModalTimer);
        clearModalAutoCloseTimer(modal, closeButton, 'simulation-modal');
        modal.classList.add('hidden');
        hideIntersectionPreviewMap();
    };
    closeButton.addEventListener('click', closeSimulationModalHandler);
    addModalAutoCloseTimer(modal, closeButton, 'simulation-modal', 50000);

    const carDist = lastCarDistanceAlongRouteForNavLogic;
    let simulationList = document.createElement('ul');
    let stepsShown = 0;
    let actualStageCounter = 1;
    
    const waypointsForRequest = navigationWaypoints.filter(wp => wp);
    
    for (let legIdx = 0; legIdx < route.legs.length; legIdx++) {
        const leg = route.legs[legIdx];
        if (!leg || !leg.steps) continue;
        
        const legDestinationWaypoint = waypointsForRequest[legIdx + 1];
        if (legDestinationWaypoint && !legDestinationWaypoint.isInternal) {
             const stageAddress = legDestinationWaypoint.address || `Etapa ${legDestinationWaypoint.label}`;
             const stageDistance = leg.distance ? (leg.distance / 1000).toFixed(1) + " km" : "Dist. desc.";
             const headerLi = document.createElement('li');
             headerLi.style.cssText = "background-color: #3a3a3c; font-weight: bold; padding: 5px; margin-top:5px; color: #007aff;";
             headerLi.textContent = `ETAPA ${actualStageCounter}: ${stageAddress} (Total ${stageDistance})`;
             simulationList.appendChild(headerLi);
             actualStageCounter++;
        }
        
        for (let stepIdx = 0; stepIdx < leg.steps.length; stepIdx++) {
            const step = leg.steps[stepIdx];
            if (!step || !step.maneuver) continue;

            const isArrivalAtInternal = step.maneuver.type === 'arrive' && waypointsForRequest[legIdx + 1]?.isInternal;
            const isDepartureFromInternal = step.maneuver.type === 'depart' && stepIdx === 0 && legIdx > 0 && waypointsForRequest[legIdx]?.isInternal;
            if (isArrivalAtInternal || isDepartureFromInternal) continue;
            
            const distanceToEndOfThisStep = calculateDistanceToEndOfStep(route, legIdx, stepIdx);
            if (distanceToEndOfThisStep < carDist) continue;
            const distanceToThisStepManeuver = Math.max(0, distanceToEndOfThisStep - carDist);
            
            const maneuver = step.maneuver;
            const type = maneuver.type || '';
            
            const maneuverText = getManeuverInstructionText(maneuver);
            let streetNameText = step.name || '';
            if (type === 'arrive' || type === 'depart' || type === 'end of road' || type === 'roundabout' || type === 'rotary') {
                streetNameText = '';
            } else if (streetNameText.toLowerCase() === 'continúa' && maneuverText.toLowerCase() !== 'continúa') {
                streetNameText = '';
            }
            
            let distanceFormatted = (distanceToThisStepManeuver >= 1000) ? `${(distanceToThisStepManeuver / 1000).toFixed(1)} km` : `${Math.round(distanceToThisStepManeuver)} m`;
            
            const li = document.createElement('li');
            li.dataset.legIndex = legIdx;
            li.dataset.stepIndex = stepIdx;
            li.style.cursor = 'pointer';
            
            const iconContainer = document.createElement('span');
            iconContainer.className = 'turn-icon-sim';
            
            const textContainer = document.createElement('span');
            textContainer.innerHTML = `${maneuverText}${streetNameText ? ` <strong>${streetNameText}</strong>` : ''} (${distanceFormatted})`;
            
            li.appendChild(iconContainer);
            li.appendChild(textContainer);
            simulationList.appendChild(li);

            const iconFilename = getManeuverIconFilename(maneuver);
            const iconUrl = `https://boardinggate.github.io/Tesla/${iconFilename}`;
            iconContainer.innerHTML = `<img src="${iconUrl}" alt="Maniobra" style="width:24px; height:24px; object-fit:contain;">`;
            
            stepsShown++;
        }
    }
    
    const contentArea = modal.querySelector('#simulation-content-area');
    if (stepsShown > 0) {
        contentArea.innerHTML = '';
        contentArea.appendChild(simulationList);
        contentArea.removeEventListener('click', handleSimulationItemClick);
        contentArea.addEventListener('click', handleSimulationItemClick);
    } else {
        contentArea.innerHTML = "<p>No hay más interacciones futuras en la ruta o estás muy cerca del final.</p>";
    }
}
// ===================================================================
// NOMBRE: handleSimulationItemClick (VERSIÓN CORREGIDA)
// RESUMEN: Maneja el clic en un elemento de la lista de maniobras para mostrar el detalle del mapa.
function handleSimulationItemClick(event) {
    const listItem = event.target.closest('li[data-leg-index][data-step-index]');
    if (!listItem) {
        return;
    }
    if (!navigationCurrentRouteData || !navigationCurrentRouteData.routes || navigationCurrentRouteData.routes.length === 0) {
        return;
    }
    const legIndex = parseInt(listItem.dataset.legIndex);
    const stepIndex = parseInt(listItem.dataset.stepIndex);
    const route = navigationCurrentRouteData.routes[0];
    if (route.legs && legIndex < route.legs.length && route.legs[legIndex].steps && stepIndex < route.legs[legIndex].steps.length) {
        const step = route.legs[legIndex].steps[stepIndex];
        showIntersectionPreviewMap(step, route, true, 5000);
    } else {
        hideIntersectionPreviewMap();
    }
}


// ===================================================================
// NOMBRE: hideMapInfoOverlay
// RESUMEN: Oculta el mensaje de información del mapa.
function hideMapInfoOverlay() {
    const overlay = document.getElementById('map-info-overlay');
    if (overlay) {
        overlay.textContent = '';
        overlay.style.display = 'none';
    }
}
  

// ===================================================================
// NOMBRE: showMapInfoOverlay (VERSIÓN OPTIMIZADA CON CACHÉ DE UI)
// RESUMEN: Muestra un mensaje en el overlay, pero solo actualiza el DOM
function showMapInfoOverlay(message, isError = false) {
    const overlay = document.getElementById('map-info-overlay');
    if (overlay) {
        let finalMessage = message;
        if (message.startsWith(" ")) {
            const destName = message.substring(" ".length).trim().replace(/<br>/gi, ' ');
            finalMessage = " " + (destName.length > 55 ? destName.substring(0, 52) + "..." : destName);
        } else if (message.startsWith("ETAPA ")) {
            const stageInfo = message.substring("ETAPA ".length).trim().replace(/<br>/gi, ' ');
            finalMessage = "ETAPA " + (stageInfo.length > 55 ? stageInfo.substring(0, 52) + "..." : stageInfo);
        } else if (message.startsWith("HA LLEGADO AL ")) {
            const destinationName = message.substring("HA LLEGADO AL : ".length).trim().replace(/<br>/gi, ' ');
            finalMessage = "HA LLEGADO A: " + (destinationName.length > 55 ? destinationName.substring(0, 52) + "..." : destinationName);
        }
        
        const currentText = overlay.querySelector('span')?.textContent || '';
        
        if (currentText !== finalMessage) {
            overlay.innerHTML = `<span>${finalMessage}</span>`;
        }

        if (!isNavigating) {
            overlay.style.display = 'block';
        }
        
        overlay.classList.toggle('error-overlay', isError);
    }
}
    

// ===================================================================
// NOMBRE: showDestinationName
// RESUMEN: Muestra el nombre del destino o de la siguiente etapa en el overlay del mapa.
function showDestinationName() {
    if (!navigationWaypoints || navigationWaypoints.length === 0) {
        hideMapInfoOverlay();
        return;
    }
    let message = "";
    let nextUnvisitedStageWp = null;
    if (isNavigating) {
        const totalEtapas = navigationCurrentRouteData?.routes?.[0]?.legs?.length || 0;
        const etapaActualUsuario = currentLegIndexNav + 1;
        for(let i = currentLegIndexNav; i < navigationWaypoints.length; i++) {
            const waypointToCheck = navigationWaypoints[i];
            if (waypointToCheck && !waypointToCheck.isInternal && !waypointToCheck.visited && waypointToCheck.type !== 'S' && waypointToCheck.type !== 'S_Recalc') {
                nextUnvisitedStageWp = waypointToCheck;
                break;
            }
        }
         if (!nextUnvisitedStageWp && navigationWaypoints.length > 0) {
            const lastWaypoint = navigationWaypoints[navigationWaypoints.length -1];
            if (lastWaypoint.type === 'F' && !lastWaypoint.visited) {
                 nextUnvisitedStageWp = lastWaypoint;
            }
        }
        if (nextUnvisitedStageWp) {
            if (nextUnvisitedStageWp.type === 'F') {
                message = ` ${nextUnvisitedStageWp.address || ' Final'}`;
            } else if (nextUnvisitedStageWp.type === 'intermediate' && totalEtapas > 1) {
                message = `ETAPA ${etapaActualUsuario} de ${totalEtapas}: ${nextUnvisitedStageWp.address || `Etapa ${nextUnvisitedStageWp.label}`}`;
            } else {
                 message = ` ${nextUnvisitedStageWp.address || 'Siguiente Punto'}`;
            }
        } else {
            const finalDestination = navigationWaypoints[navigationWaypoints.length - 1];
            if (finalDestination && !finalDestination.isInternal) {
                 message = ` ${finalDestination.address || ' Final'}`;
            } else {
                 message = "RUTA NO DEFINIDA";
            }
        }
    } else {
        const finalDestination = navigationWaypoints[navigationWaypoints.length - 1];
        if (finalDestination && !finalDestination.isInternal) {
             message = ` ${finalDestination.address || ' Final'}`;
        } else {
             message = "RUTA NO DEFINIDA";
        }
    }
    showMapInfoOverlay(message);
}

// ===================================================================
// NOMBRE: clearModalAutoCloseTimer
// RESUMEN: Limpia un temporizador de autocierre de un modal.
function clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId) {
    const timerIdToClear = modalId || (modalElement ? modalElement.dataset.modalTimerId : null);
    if (timerIdToClear && globalModalTimers[timerIdToClear]) {
        clearInterval(globalModalTimers[timerIdToClear].intervalId);
        const timerData = globalModalTimers[timerIdToClear];
        if (timerData.modalElement && timerData.resetHandler) {
            timerData.modalElement.removeEventListener('click', timerData.resetHandler);
            timerData.modalElement.removeEventListener('touchstart', timerData.resetHandler);
            timerData.modalElement.removeEventListener('input', timerData.resetHandler);
            timerData.modalElement.removeEventListener('scroll', timerData.resetHandler);
        }
        if (timerData.countdownSpan && timerData.countdownSpan.parentNode) {
            timerData.countdownSpan.remove();
        }
        delete globalModalTimers[timerIdToClear];
    }
    if(closeButtonElement){
        const orphanSpans = closeButtonElement.querySelectorAll('.button-countdown-timer');
        orphanSpans.forEach(s => s.remove());
    }
     if(modalElement && modalElement.dataset.modalTimerId) {
        delete modalElement.dataset.modalTimerId;
    }
}

// ===================================================================
// NOMBRE: formatDateToDDMMMYY
// RESUMEN: Formatea una fecha (YYYY-MM-DD) a un formato legible (DD Mes Abreviado YY).
function formatDateToDDMMMYY(dateString) {
     if (!dateString) return '-';
     try {
         const [year, month, day] = dateString.split('-').map(Number);
         const date = new Date(Date.UTC(year, month - 1, day));
         if (isNaN(date.getTime())) return '-';
         const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
         const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
         const monthName = monthNames[date.getUTCMonth()];
         const yearShort = String(date.getUTCFullYear()).slice(-2);
         return `${dayOfMonth} ${monthName} ${yearShort}`;
     } catch (e) {
         return '-';
     }
}

// ===================================================================
// NOMBRE: calculateNextOccurrence
// RESUMEN: Calcula la próxima fecha de vencimiento de un recordatorio cíclico.
function calculateNextOccurrence(reminder, referenceDate) {
      if (!reminder || !reminder.type || !reminder.time || !reminder.date) { return null; } try {
          let [year, month, day] = reminder.date.split('-').map(Number); let [hour, minute] = reminder.time.split(':').map(Number);
          let baseDate = new Date(Date.UTC(year, month - 1, day, hour, minute)); if (isNaN(baseDate.getTime())) { return null; }
          const refDateUTC = new Date(referenceDate.getTime()); if (baseDate > refDateUTC) return baseDate;
          if (reminder.type === 'simple') { return null; }
          if (reminder.type === 'daily' || reminder.type === 'hourly') { let next = new Date(baseDate); while (next <= refDateUTC) { next.setUTCDate(next.getUTCDate() + 1); } return next; }
          if (reminder.type === 'weekly' && reminder.repeatDays && reminder.repeatDays.length > 0) {
              let next = new Date(refDateUTC); next.setUTCHours(hour, minute, 0, 0);
              if (next <= refDateUTC || !reminder.repeatDays.includes(next.getUTCDay())) { next.setUTCDate(next.getUTCDate() + 1); }
              for (let i = 0; i < 7; i++) { if (reminder.repeatDays.includes(next.getUTCDay())) { return next; } next.setUTCDate(next.getUTCDate() + 1); } return null;
          }
          if (reminder.type === 'interval' && reminder.intervalDays && reminder.intervalDays > 0) { let next = new Date(baseDate); while (next <= refDateUTC) { next.setUTCDate(next.getUTCDate() + reminder.intervalDays); } return next; }
          return null; } catch (e) { return null; }
 }

// ===================================================================
// NOMBRE: calculatePostponedDateTime
// RESUMEN: Calcula la fecha y hora para posponer un recordatorio.
function calculatePostponedDateTime(mins) {
      const now = new Date(); const postponedDate = new Date(now.getTime() + mins * 60000);
      const newDateISO = `${postponedDate.getFullYear()}-${(postponedDate.getMonth() + 1).toString().padStart(2, '0')}-${postponedDate.getDate().toString().padStart(2, '0')}`;
      const newTime = `${postponedDate.getHours().toString().padStart(2, '0')}:${postponedDate.getMinutes().toString().padStart(2, '0')}`; return { newDateISO, newTime };
     }
       
// ===================================================================
// NOMBRE: showPostponeOptionsModal(reminder
// RESUMEN: Muestra un modal con opciones para posponer un recordatorio.
function showPostponeOptionsModal(reminder, source = 'unified') {
         const existingModal = document.getElementById('postpone-options-modal'); if (existingModal) { if (existingModal.autoPostponeInterval) clearInterval(existingModal.autoPostponeInterval); if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal); }
         const modal = document.createElement('div'); modal.id = 'postpone-options-modal'; modal.className = 'postpone-options';
         modal.style.cssText = `position:fixed; top:10px; left:50%; transform:translateX(-50%); width:90%; max-width:480px; max-height:calc(100vh - 20px); overflow-y:auto; background-color:#F5E1A9; padding:1.5rem; border-radius:1rem; box-shadow:0 10px 25px rgba(0,0,0,0.2); z-index:7500; `;
         modal.setAttribute('aria-label', 'Posponer recordatorio');
         let countdown = 10; const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval'; const defaultMinutes = 15;
         let buttonHtml = ` <button data-minutes="15" class="postpone-option">15 Minutos</button> <button data-minutes="60" class="postpone-option">1 Hora</button> <button data-minutes="180" class="postpone-option">3 Horas</button> `;
         if (!isCyclic) { buttonHtml += ` <button data-minutes="1440" class="postpone-option">1 Día</button> <button data-minutes="4320" class="postpone-option">3 Días</button> `; }
         modal.innerHTML = `
            <style>
                .postpone-options .reminder-text { color:#333; font-size:1.2rem; margin-bottom:.5rem; word-wrap:break-word; }
                .postpone-options .reminder-details { color:#555; font-size:1rem; margin-bottom:1.5rem; }
                .postpone-options .button-group { display:flex; flex-direction:column; gap:1rem; align-items:stretch; }
                .postpone-options button.postpone-option { font-size:1.3rem; font-weight:bold; padding:.8rem 1rem; background-color:#F59E0B; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                .postpone-options button.postpone-option:hover { background-color:#D97706; }
                #postpone-countdown { text-align:center; margin-top:1.8rem; font-size:1.1rem; font-weight:500; color:#444; }
                #postpone-timer-value { font-weight:bold; font-size:1.2rem; }
                #cancel-postpone { margin-top:1.2rem; width:100%; padding:.7rem 1rem; font-size:1.1rem; background-color:#EF4444; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                #cancel-postpone:hover { background-color:#DC2626; }
            </style>
            <div class="modal-top-buttons" style="justify-content: flex-end; margin-bottom: 1rem;">
                 <button id="cancel-postpone" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
            </div>
            <p class="reminder-text">Posponer: ${reminder.text.replace(/<[^>]*>/g, '')}</p>
            <p class="reminder-details">Selecciona tiempo:</p>
            <div class="button-group">
                ${buttonHtml}
            </div>
            <p id="postpone-countdown">Automático en <span id="postpone-timer-value">${countdown}</span>s (${defaultMinutes} min)</p>
         `;
         document.body.appendChild(modal);
         const countdownDisplay = modal.querySelector('#postpone-timer-value');
         const handlePostpone = (minutes) => {
             if (modal.autoPostponeInterval) clearInterval(modal.autoPostponeInterval); modal.autoPostponeInterval = null;
             updateUnifiedWindowUI(reminder.id);
             let reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); const index = reminders.findIndex(r => r.id === reminder.id);
             if (index === -1) { showToast("Error: Recordatorio no encontrado", "error"); markCacheAsDirty(); if (modal.parentNode) document.body.removeChild(modal); return; }
             const { newDateISO, newTime } = calculatePostponedDateTime(minutes); reminders[index].date = newDateISO; reminders[index].time = newTime; reminders[index].managedByUser = false;
             if (!isCyclic) { reminders[index].type = 'daily'; reminders[index].repeatDays = []; reminders[index].intervalDays = null; }
             localStorage.setItem('reminders', JSON.stringify(reminders)); updateReminderCount(); updateButtonStyles(); 
             const durationText = minutes >= 1440 ? `${minutes / 1440} día(s)` : (minutes >= 60 ? `${minutes / 60} hora(s)` : `${minutes} minutos`);
             showToast(`Pospuesto ${durationText}`, 'info');
             if (modal.parentNode) document.body.removeChild(modal);
             if (source === 'table') { setTimeout(showAllReminders, 100); }
             else { const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                 const mapContextToReopen = sessionStorage.getItem('mapContext');
                 if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) { sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); if (!document.getElementById('reminders-location-map-modal')) { if (mapContextToReopen === 'navigation') openNavigationMap(); sessionStorage.removeItem('mapContext');} } } };
         modal.autoPostponeInterval = setInterval(() => { countdown--; if (countdownDisplay) countdownDisplay.textContent = countdown; if (countdown <= 0) { handlePostpone(defaultMinutes); } }, 1000);
         modal.querySelectorAll('.postpone-option').forEach(button => { button.addEventListener('click', () => { const minutes = parseInt(button.dataset.minutes); if (!isNaN(minutes)) { handlePostpone(minutes); } }); });
         modal.querySelector('#cancel-postpone').addEventListener('click', () => {
             clearInterval(modal.autoPostponeInterval); modal.autoPostponeInterval = null; markReminderAsManaged(reminder.id, false); if (modal.parentNode) document.body.removeChild(modal);
             if (source === 'table') { setTimeout(showAllReminders, 100); }
             else { const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                  const mapContextToReopen = sessionStorage.getItem('mapContext');
                 if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) { sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); if (!document.getElementById('reminders-location-map-modal')) { if (mapContextToReopen === 'navigation') openNavigationMap(); sessionStorage.removeItem('mapContext');} } } showToast('Posposición cancelada', 'info'); });
     }
    
  
// ===================================================================
// NOMBRE: handleDragEndReorder
// RESUMEN: Maneja la finalización de una operación de arrastre en la lista de etapas.
function handleDragEndReorder(e) {
    if (draggedStageLi) {
        draggedStageLi.classList.remove('dragging');
    }
    draggedStageLi = null;
}

// ===================================================================
// NOMBRE: handleDragOverReorder
// RESUMEN: Maneja el evento de pasar por encima al arrastrar en la lista de etapas.
function handleDragOverReorder(e) {
    e.preventDefault();
    if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
    const listElement = document.getElementById('sortable-stages-list');
    if (!listElement || !draggedStageLi) return;
    const afterElement = getDragAfterElement(listElement, e.clientY);
    const currentLi = e.target.closest('li');
    if (draggedStageLi && currentLi && draggedStageLi !== currentLi) {
        if (afterElement == null) {
            listElement.appendChild(draggedStageLi);
        } else {
            listElement.insertBefore(draggedStageLi, afterElement);
        }
    } else if (draggedStageLi && !currentLi && afterElement == null) {
         listElement.appendChild(draggedStageLi);
    } else if (draggedStageLi && !currentLi && afterElement) {
         listElement.insertBefore(draggedStageLi, afterElement);
    }
}

// ===================================================================
// NOMBRE: handleStageTouchStart
// RESUMEN: Maneja el inicio de un toque en una etapa para reordenar.
function handleStageTouchStart(e) {
    if (e.touches.length === 1 && e.target.closest('.drag-handle')) {
        draggedStageLi = e.target.closest('li');
        if (!draggedStageLi) return;
        const touch = e.touches[0];
        stageTouchStartX = touch.clientX;
        stageTouchStartY = touch.clientY;
        clearTimeout(stageScrollTimeout);
        stageScrollTimeout = setTimeout(() => {
            if (draggedStageLi) {
                draggedStageLi.classList.add('dragging');
                document.body.style.overflow = 'hidden';
            }
        }, 150);
    }
}

// ===================================================================
// NOMBRE: createWaypointMarkerIcon (MODIFICADA CON TAMAÑO DE FUENTE DINÁMICO Y COLOR DE VISITADO)
// RESUMEN: Crea el elemento DOM para un marcador de etapa, con tamaño de fuente escalable y color gris para visitados.
function createWaypointMarkerIcon(label, type, visited, id, currentZoomLevel = null) {
    const el = document.createElement('div');
    el.className = 'navigation-waypoint-marker';
    
    let color;
    if (visited) {
        color = 'rgba(85, 85, 85, 0.8)'; 
    } else if (type === 'S' || type === 'S_Recalc') {
        color = 'rgba(0, 128, 0, 0.80)'; 
    } else if (type === 'F') {
        color = 'rgba(0, 0, 255, 0.80)'; 
    } else {
        color = 'rgba(230, 140, 0, 0.80)'; 
    }
    
    const ZOOM_PEQUENO = 12;
    const ZOOM_GRANDE = 17;
    const FONT_MINIMO = 15; 
    const FONT_MAXIMO = 19; 
    
    let finalFontSize = FONT_MAXIMO;
    if (currentZoomLevel !== null) {
        if (currentZoomLevel <= ZOOM_PEQUENO) {
            finalFontSize = FONT_MINIMO;
        } else if (currentZoomLevel >= ZOOM_GRANDE) {
            finalFontSize = FONT_MAXIMO;
        } else {
            const progress = (currentZoomLevel - ZOOM_PEQUENO) / (ZOOM_GRANDE - ZOOM_PEQUENO);
            finalFontSize = FONT_MINIMO + (FONT_MAXIMO - FONT_MINIMO) * progress;
        }
    }
    
    el.style.backgroundColor = color;
    el.style.width = '45px';
    el.style.height = '45px';
    el.style.border = `2px solid ${visited ? '#555' : 'white'}`;
    el.style.opacity = visited ? '0.7' : '1';
    el.textContent = label;
    el.style.fontSize = `${Math.round(finalFontSize)}px`;
    el.style.cursor = 'pointer';
    
    return el;
}
    
// ===================================================================
// NOMBRE: handleStageTouchMove
// RESUMEN: Maneja el movimiento de un toque en una etapa para reordenar.
function handleStageTouchMove(e) {
    if (!draggedStageLi || e.touches.length !== 1) return;
    e.preventDefault();
    clearTimeout(stageScrollTimeout);
    if (!draggedStageLi.classList.contains('dragging')) {
        draggedStageLi.classList.add('dragging');
         document.body.style.overflow = 'hidden';
    }
    const touch = e.touches[0];
    const listElement = document.getElementById('sortable-stages-list');
    if (!listElement) return;
    const afterElement = getDragAfterElement(listElement, touch.clientY);
     if (afterElement == null) {
        listElement.appendChild(draggedStageLi);
    } else {
        listElement.insertBefore(draggedStageLi, afterElement);
    }
}
  
// ===================================================================
// NOMBRE: handleStageTouchEnd
// RESUMEN: Maneja el final de un toque en una etapa para reordenar.
function handleStageTouchEnd(e) {
    clearTimeout(stageScrollTimeout);
    if (draggedStageLi) {
        draggedStageLi.classList.remove('dragging');
        draggedStageLi = null;
    }
    document.body.style.overflow = '';
}

// ===================================================================
// NOMBRE: getDragAfterElement
// RESUMEN: Encuentra el elemento después del cual se debe soltar el elemento arrastrado.
function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('li:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

// ===================================================================
// NOMBRE: startGraphIntervalTimer (CORREGIDA)
function startGraphIntervalTimer() {
    if (graphIntervalTimer) clearInterval(graphIntervalTimer);
    if ((isNavigating || isFreeDriveActive) && currentGraphMode !== 'Gráfica off' && graphIntervalDuration > 0) { 
        graphIntervalTimer = setInterval(plotIntervalData, graphIntervalDuration);
    }
}

// ===================================================================
// NOMBRE: showDeviationModal (VERSIÓN FINAL CON LÓGICA DUAL Y TEMPORIZADOR)
// RESUMEN: Muestra un modal diferente si la ruta es simple o multietapa.
function showDeviationModal() {
    if (isDeviationModalActive) return;
    closeOtherModals('deviation-modal');
    isDeviationModalActive = true;
    let modal = document.getElementById('deviation-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'deviation-modal';
        document.body.appendChild(modal);
    }

    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    const unvisitedSelectableStages = actualWaypoints.filter(wp => !wp.visited && wp.type !== 'S' && wp.type !== 'S_Recalc' && wp.type !== 'F');
    const iconHtml = `<img src="PNG/GPS.PNG" alt="Icono de Desvío" style="width: 125px; height: 80px; margin: 0 auto 10px auto; display: block;">`;

    if (unvisitedSelectableStages.length === 0) {
        console.log("[MODAL DESVÍO] Ruta simple detectada. Mostrando modal informativo y comenzando recálculo automático.");
        modal.innerHTML = `
            <h2>Desvío Detectado</h2>
            ${iconHtml}
            <p id="deviation-modal-message">Recalculando nueva ruta...</p>
            <div id="deviation-status-spinner" style="border: 4px solid rgba(255, 255, 255, 0.2); border-left-color: #34c759; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 1rem auto 0;"></div>
            <style> @keyframes spin { 100% { transform: rotate(360deg); } } </style>
        `;
        modal.classList.remove('hidden');
        recalculateAndDrawRoute(true); 

    } else {
        console.log("[MODAL DESVÍO] Ruta multietapa detectada. Mostrando modal interactivo con temporizador.");
        const finalDestination = actualWaypoints[actualWaypoints.length - 1];
        const stageButtonsHtml = unvisitedSelectableStages.map(wp => {
            const addressSummary = wp.address ? (wp.address.split(',')[0].trim()) : `Etapa ${wp.label}`;
            return `<button class="btn-modal-action-primary deviation-stage-button" data-waypoint-id="${wp.id}">ETAPA ${wp.label}: ${addressSummary}</button>`;
        }).join('');

        modal.innerHTML = `
            <h2>Desvío Detectado</h2>
            ${iconHtml}
            <p id="deviation-modal-message">Elige tu próximo destino o se seleccionará el destino final automáticamente.</p>
            <div class="deviation-options-container">
                <button id="deviation-go-to-final" class="btn-modal-action-primary" style="background-color: #34c759;">Ir a Destino Final (${finalDestination.address.split(',')[0].trim()}) <span class="button-countdown-timer unified-countdown-style"></span></button>
                <p id="scroll-hint-text"></p>
                <div class="stage-list-scroll-container">
                    ${stageButtonsHtml}
                </div>
                <button id="deviation-cancel" class="btn-modal-action-secondary">Cancelar (Seguir Desviado)</button>
            </div>
        `;
        modal.classList.remove('hidden');

        const goToFinalButton = document.getElementById('deviation-go-to-final');

        const clearDefaultActionTimer = () => {
            clearModalAutoCloseTimer(modal, goToFinalButton, 'deviation-modal-default-action');
        };

        goToFinalButton.addEventListener('click', (e) => {
            e.stopPropagation();
            clearDefaultActionTimer();
            handleFinalDestinationSelection();
        });

        document.querySelectorAll('.deviation-stage-button').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                clearDefaultActionTimer();
                const waypointId = parseInt(e.currentTarget.dataset.waypointId);
                handleStageSelectionFromDeviationModal(waypointId);
            });
        });

        document.getElementById('deviation-cancel').addEventListener('click', (e) => {
            e.stopPropagation();
            clearDefaultActionTimer();
            closeModalAndProceed();
        });
        
        addModalAutoCloseTimer(modal, goToFinalButton, 'deviation-modal-default-action', 10000);

        const scrollContainer = modal.querySelector('.stage-list-scroll-container');
        const scrollHint = modal.querySelector('#scroll-hint-text');
        requestAnimationFrame(() => {
            if (scrollContainer.scrollHeight > scrollContainer.clientHeight) {
                scrollHint.textContent = `(Deslice para ver las ${unvisitedSelectableStages.length} etapas restantes)`;
                scrollHint.style.display = 'block';
            }
        });
    }
}
    
// ===================================================================
// NOMBRE: handleFinalDestinationSelection (NUEVA FUNCIÓN)
// RESUMEN: Maneja la lógica cuando el usuario elige ir al destino final.
// ===================================================================
async function handleFinalDestinationSelection() {
    const finalDestination = navigationWaypoints.find(wp => wp.type === 'F');
    const startPoint = navigationWaypoints.find(wp => wp.isRecalculatedStart || wp.type === 'S');

    if (!finalDestination || !startPoint) {
        showToast("Error: No se pudo determinar el inicio o el fin de la ruta.", "error");
        closeModalAndProceed();
        return;
    }

    navigationWaypoints = [startPoint, finalDestination];
    closeModalAndProceed();
    
    try {
        await recalculateAndDrawRoute(true, true);
        renderWaypointMarkers();
        deviationCheckGracePeriodUntil = Date.now() + 5000;
    } catch (error) {
        showToast("Error al recalcular la ruta hacia el destino final.", "error");
    }
}

// ===================================================================
// NOMBRE: handleStageSelectionFromDeviationModal (NUEVA FUNCIÓN)
// RESUMEN: Maneja la lógica cuando el usuario elige una etapa intermedia.
// ===================================================================
async function handleStageSelectionFromDeviationModal(selectedWaypointId) {
    const selectedIndex = navigationWaypoints.findIndex(wp => wp.id === selectedWaypointId);
    const startPoint = navigationWaypoints.find(wp => wp.isRecalculatedStart || wp.type === 'S');

    if (selectedIndex === -1 || !startPoint) {
        showToast("Error: No se encontró la etapa o el punto de inicio.", "error");
        closeModalAndProceed();
        return;
    }

    const newWaypoints = [startPoint];
    for (let i = selectedIndex; i < navigationWaypoints.length; i++) {
        const wp = navigationWaypoints[i];
        if (wp && !wp.isInternal && !wp.isRecalculatedStart) {
            newWaypoints.push(wp);
        }
    }
    
    navigationWaypoints = newWaypoints;
    closeModalAndProceed();
    
    try {
        await recalculateAndDrawRoute(true, true);
        renderWaypointMarkers();
        deviationCheckGracePeriodUntil = Date.now() + 5000;
    } catch (error) {
        showToast("Error al recalcular la ruta hacia la etapa seleccionada.", "error");
    }
}
   
// ===================================================================
// NOMBRE: closeModalAndProceed (MODIFICADA)
// RESUMEN: Cierra el modal de desvío y llama a la reanudación de simulación.
// ===================================================================
function closeModalAndProceed() {
    isDeviationModalActive = false;
    deviationStartTime = 0;
    const modal = document.getElementById('deviation-modal');
    if (modal) {
        modal.classList.add('hidden');
    }

    if (wasSimulatingBeforeRecalc) {
        wasSimulatingBeforeRecalc = false; // Se resetea la bandera
        showToast("Desvío recalculado. Reanudando simulación...", "info");
        setTimeout(() => {
            startAutomatedRouteSimulation(currentSimulationSpeedKmph, true); 
        }, 100);
    }
}


// ===================================================================
// FUNCIÓN A REEMPLAZAR: handleLocateMeClick (VERSIÓN FINAL Y ROBUSTA)
function handleLocateMeClick(isExplicitAction = false) {
    if (!navigationMapInstance) return;

    clearLocateMeReactivationTimer();
    isManualZoomActive = false;
    
    navigationFollowUser = !navigationFollowUser;
    shouldCenterOnUser = navigationFollowUser;

    if (navigationFollowUser) {
        if (navigationCurrentLocation) {
            isFlying = true; // <-- Inicia el bloqueo de la animación
            const flyToOptions = {
                center: [navigationCurrentLocation.longitude, navigationCurrentLocation.latitude],
                zoom: 17,
                duration: 1200,
                essential: true
            };

            const mode = mapViewMode || 'static';
            
            if (mode === 'perspective' || mode === 'relief') {
                flyToOptions.pitch = mapPitchValue;
            } else {
                flyToOptions.pitch = 0;
            }
            
            if (mode === 'heading' || mode === 'perspective' || mode === 'relief') {
                flyToOptions.bearing = navigationCurrentLocation.heading || 0;
            }

            navigationMapInstance.flyTo(flyToOptions);
            
            navigationMapInstance.once('moveend', () => {
                isFlying = false;
                markerAnimationState.currentMapCenter = navigationMapInstance.getCenter();
                markerAnimationState.currentMapZoom = navigationMapInstance.getZoom();
                markerAnimationState.currentMapPitch = navigationMapInstance.getPitch();
                markerAnimationState.currentMapBearing = navigationMapInstance.getBearing();
                
                markerAnimationState.targetMapCenter = navigationMapInstance.getCenter();
                markerAnimationState.targetMapZoom = navigationMapInstance.getZoom();
                markerAnimationState.targetMapPitch = navigationMapInstance.getPitch();
                markerAnimationState.targetMapBearing = navigationMapInstance.getBearing();
            });

        } else {
            getCurrentLocation(coords => {
                if (navigationMapInstance) {
                     const locateOptions = { center: [coords.longitude, coords.latitude], zoom: 17 };
                     const mode = mapViewMode || 'static';
                     if (mode === 'perspective' || mode === 'relief') {
                         locateOptions.pitch = mapPitchValue;
                     }
                     navigationMapInstance.flyTo(locateOptions);
                }
                updateInitialUserPosition(coords, navigationMapInstance);
            }, () => showToast("No se pudo obtener tu ubicación.", "warning"));
        }
    } else {
        if (isExplicitAction) {
            clearLocateMeReactivationTimer();
        } else {
            startLocateMeReactivationTimer();
        }
    }
    
    updateLocateMeButtonsUI();
    updateStartNavigationButtonState();
}
    
// ===================================================================
// FUNCIÓN 2 (CORREGIDA): openNavigationMap
// REEMPLAZA esta función. Se asegura de que la animación inicial use el pitch correcto.
async function openNavigationMap(isRecovery = false) {
    return new Promise(async (resolve, reject) => {
        const { primaryId: userId } = parseUserId(localStorage.getItem('userData_userId'));
        if (userId && userId.toLowerCase() !== 'boardinggate') {
            const toastId = "map-access-check";
            try {
                const adminDocRef = window.doc(window.db, "user_data", "boardinggate");
                const userDocRef = window.doc(window.db, "user_data", userId);
                
                const [adminSnap, userSnap] = await Promise.all([window.getDoc(adminDocRef), window.getDoc(userDocRef)]);
                
                let maxSessions = Infinity;
                if (adminSnap.exists() && typeof adminSnap.data().max_monthly_sessions === 'number') {
                    maxSessions = adminSnap.data().max_monthly_sessions;
                }
                
                let userMonthlyCount = 0;
                if (userSnap.exists()) {
                    const userData = userSnap.data();
                    const now = new Date();
                    const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
                    if (userData.map_sessions_last_month === currentMonthStr) {
                        userMonthlyCount = userData.map_sessions_month || 0;
                    }
                }

                const existingToast = document.getElementById(toastId);
                if(existingToast) existingToast.remove();
                
                if (userMonthlyCount >= maxSessions) {
                    showToast("HA SUPERADO EL NÚMERO MÁXIMO DE SESIONES MENSUALES DE MAPA, consulte con el administrador", "error", 10000);
                    reject(new Error("Límite de sesiones alcanzado")); 
                    return; 
                }
            } catch (error) {
                const existingToast = document.getElementById(toastId);
                if(existingToast) existingToast.remove();
                showToast("No se pudo verificar el límite de sesiones. Acceso permitido.", "warning");
            }
        }
                               
        const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'none';
        const footer = document.querySelector('footer'); if (footer) footer.style.display = 'none';
        const noticesContainer = document.querySelector('.notices-icon-container'); if (noticesContainer) noticesContainer.style.display = 'none';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'none');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button, #accident-alert-button').forEach(el => el.style.display = 'none');
        const gridFilter = document.getElementById('grid-filter-container'); if (gridFilter) gridFilter.style.display = 'none';

        isNavigationMapActive = true;
        sessionStorage.setItem('mapContext', 'navigation');
        closeOtherModals('reminders-location-map-modal');
        
        const mapModal = document.getElementById('reminders-location-map-modal');
        if (!mapModal) { console.error("Error crítico: El modal del mapa no se encuentra en el HTML."); isNavigationMapActive = false; reject(new Error("Modal no encontrado")); return; }
        
        mapModal.classList.remove('map-modal-hidden');
        const mapActualContainer = document.getElementById('mapbox-map-actual-container');
        
        const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresCheckbox) {
            radaresCheckbox.checked = localStorage.getItem(RADARES_RUTA_CHECKED_KEY) === 'true';
        }
        const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasCheckbox) {
            tareasCheckbox.checked = localStorage.getItem(TAREAS_RUTA_CHECKED_KEY) === 'true';
        }
        const mapboxCheckbox = document.getElementById('mapbox-primary-checkbox');
        if (mapboxCheckbox) {
            mapboxCheckbox.checked = localStorage.getItem('boardinggate_useMapboxAsPrimary') === 'true';
        }
        
        if (navigationMapInstance) {
            handleLoadOrDeleteRouteClick(null);
            setNavigationMapClickHandler();
            setTimeout(() => { if (navigationMapInstance) navigationMapInstance.resize(); }, 520);
            resolve(); 
            
        } else {
            try {
                const savedLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "HÍBRIDO";
                const finalLayerName = MAP_LEGACY_NAME_MAP[savedLayerName] || savedLayerName;
                const initialStyle = MAP_STYLES[finalLayerName] || MAP_STYLES["HÍBRIDO"];
                showToast("INICIALIZANDO MAPA...", "info", 0, false, "map-init-toast");
      
                const startCoordsTexas = { lat: 30.3715, lng: -97.1903 };
                navigationMapInstance = new mapboxgl.Map({
                    container: mapActualContainer,
                    style: initialStyle, 
                    center: [startCoordsTexas.lng, startCoordsTexas.lat],
                    zoom: 2.8,
                    pitch: 0,
                    bearing: 0,
                    attributionControl: false, 
                    accessToken: mapboxgl.accessToken
                });
 
                if (!isRecovery) {
                    setMapImmersiveMode(true);
                }
                
                incrementMapSessionCount();
                mapSessionStartTime = Date.now();
                
                const customControls = new CustomMapControlsGroup();
                window.mapCustomControlsInstance = customControls; 
                navigationMapInstance.addControl(customControls, 'bottom-right');
                
                compassAndModeControl = new CompassAndStatsControl();
                navigationMapInstance.addControl(compassAndModeControl, 'bottom-left');
                
                if (!navigationMapInstance._interactionListenersAttached) {
                    const mapCanvas = navigationMapInstance.getCanvasContainer();
                    let touchStartPos = null;
                    let hasMovedEnoughToDrag = false;
                    const DRAG_THRESHOLD = 10; 

                    const onTouchStart = (e) => {
                        if (e.touches && e.touches.length > 1) {
                            handleManualMapInteraction();
                            return;
                        }
                        const touch = e.touches ? e.touches[0] : e;
                        touchStartPos = { x: touch.clientX, y: touch.clientY };
                        hasMovedEnoughToDrag = false;
                    };

                    const onTouchMove = (e) => {
                        if (hasMovedEnoughToDrag || !touchStartPos || (e.touches && e.touches.length > 1)) return;
                        
                        const touch = e.touches ? e.touches[0] : e;
                        const deltaX = Math.abs(touch.clientX - touchStartPos.x);
                        const deltaY = Math.abs(touch.clientY - touchStartPos.y);

                        if (deltaX > DRAG_THRESHOLD || deltaY > DRAG_THRESHOLD) {
                            hasMovedEnoughToDrag = true;
                            handleManualMapInteraction(); 
                        }
                    };

                    const onTouchEnd = () => {
                        touchStartPos = null;
                        hasMovedEnoughToDrag = false;
                    };

                    mapCanvas.addEventListener('touchstart', onTouchStart, { passive: true });
                    mapCanvas.addEventListener('touchmove', onTouchMove, { passive: true });
                    mapCanvas.addEventListener('touchend', onTouchEnd, { passive: true });

                    navigationMapInstance.on('pitchend', (e) => {
                        if (e.originalEvent) { 
                            const newPitch = navigationMapInstance.getPitch();
                            if (Math.abs(newPitch - mapPitchValue) > 0.1) {
                                mapPitchValue = newPitch;
                                saveSettings();
                            }
                        }
                    });
                    navigationMapInstance._interactionListenersAttached = true; 
                }

                navigationMapInstance.on('error', (e) => {
                    if (e.error && e.error.message.includes("Token")) {
                        showToast("Error de Token de Mapbox. Revisa los permisos (scopes) en tu cuenta.", "error", 10000);
                    }
                });
                
                navigationMapInstance.on('load', async function() {
                    try {
                        const lockButton = document.getElementById('toggle-progress-bar-lock');
                        if (lockButton && !lockButton.dataset.listenerAttached) {
                            lockButton.addEventListener('click', (e) => {
                                e.stopPropagation();
                                handleProgressBarLockToggle();
                            });
                            lockButton.dataset.listenerAttached = 'true';
                        }
                        updateProgressBarLockIcon();
                        
                        const topInfoBar = document.getElementById('navigation-top-info-bar');
                        if (topInfoBar && !topInfoBar.dataset.listenerAttached) {
                            topInfoBar.addEventListener('click', (e) => {
                                e.stopPropagation();
                                if (nextManeuverStepForPreview && navigationCurrentRouteData?.routes?.[0]) {
                                    showIntersectionPreviewMap(
                                        nextManeuverStepForPreview, 
                                        navigationCurrentRouteData.routes[0], 
                                        true, 
                                        10000 
                                    );
                                } else {
                                    showToast("No hay una próxima maniobra que mostrar.", "info");
                                }
                            });
                            topInfoBar.dataset.listenerAttached = 'true';
                        }
                        
                        const initToast = document.getElementById("map-init-toast");
                        if (initToast) initToast.remove();

                        await loadAndAddMapImages(navigationMapInstance);
                        reAddCustomMapLayersAndSources(navigationMapInstance);
                        plotRemindersOnNavigationMap();
                        
                // ¡CLAVE! Se llama aquí, después de que las fuentes base estén cargadas.
                        await configureMapAtmosphere();
                        
                        await processTrafficAlerts(); 

                        if (alertRefreshInterval) clearInterval(alertRefreshInterval); 
                        alertRefreshInterval = setInterval(processTrafficAlerts, ALERT_CHECK_INTERVAL);
                                        
                        navigationMapInstance.on('pitch', updateLineWidthsOnPitchChange);
                        
                        mapPreviousZoomLevelForPDRs = navigationMapInstance.getZoom();
                        navigationMapInstance.on('zoomend', updateAllIconSizes);
                        toggleMapHeaderRowsVisibility(mapHeaderButtonsVisible);

                        navigationMapInstance.on('click', async (e) => {
                            if (isAddReminderAtLocationModeActive) { handleMapClickToAddReminder(e); return; }
                            if (isSimulatingGpsLocation) { handleSimulateGpsPositionClick(e); return; }
                            if (isNavigating) { return; }

                            const point = e.point;
                            const lngLat = e.lngLat;
                            
                            const pdrLayers = ['pdr-simple-circle-layer', 'pdr-cards-layer-bg-halo', 'pdr-cards-layer-bg'];
                            const pdrFeatures = navigationMapInstance.queryRenderedFeatures(point, { layers: pdrLayers });
                            if (pdrFeatures.length > 0) {
                                const fullPdrData = window.lastOcmApiResponse.find(p => p.ID === pdrFeatures[0].properties.ocmId);
                                if (fullPdrData) {
                                    showChargingPointModal(fullPdrData, pdrFeatures[0].properties.index);
                                }
                                return;
                            }

                            const alertLayers = ['traffic-alerts-layer'];
                            const alertFeatures = navigationMapInstance.queryRenderedFeatures(point, { layers: alertLayers });
                            if (alertFeatures.length > 0) {
                                const alertCode = alertFeatures[0].properties.code;
                                const alertDetailsMap = {
                                    1: 'Accidente de tráfico', 2: 'Coche averiado', 3: 'Control de tráfico / Radar',
                                    4: 'Atasco', 5: 'Peligro indeterminado', 6: 'Carretera en mal estado',
                                    7: 'Obras', 8: 'Vía / Carretera cerrada'
                                };
                                const alertText = alertDetailsMap[alertCode] || 'Alerta de tráfico';
                                showToast(alertText, 'warning', 4000);
                                return;
                            }
                            
                            const reminderLayers = ['reminders-icons-layer', 'radar-circles-layer'];
                            const reminderFeatures = navigationMapInstance.queryRenderedFeatures(point, { layers: reminderLayers });
                            if (reminderFeatures.length > 0) {
                                const reminderId = reminderFeatures[0].properties.reminderId;
                                showReminderActionModal(reminderId);
                                return;
                            }

                            const mapboxPoiLayers = ['poi-label'];
                            const features = navigationMapInstance.queryRenderedFeatures(point, { layers: mapboxPoiLayers });
                            const validPoiFeature = features.find(f => {
                                 if (!f.properties) return false;
                                 const poiName = f.properties.name || f.properties.name_en || f.properties.text;
                                 return f.layer.id === 'poi-label' && poiName;
                            });

                            if (validPoiFeature) {
                                const properties = validPoiFeature.properties;
                                const poiName = properties.name || properties.name_en || properties.text;
                                let categories = [];
                                if (properties.poi_category && Array.isArray(properties.poi_category)) { categories = properties.poi_category; } 
                                else if (properties.category) { categories = properties.category.split(',').map(c => c.trim()); } 
                                else if (properties.maki) { categories = [properties.maki]; }
                                
                                const featureForModal = { properties: { name: poiName, categories: categories }, geometry: validPoiFeature.geometry };
                                showPoiInfoModal(featureForModal);
                            } else {
                                addWaypoint(lngLat);
                            }
                        });
                        
                        enablePoiInteractivity(navigationMapInstance);
                        setNavigationMapClickHandler();
                        
                        if (!isRecovery) {
                            const globeSpinPromise = new Promise(resolve => {
                                const startCoords = { lat: 30.3715, lng: -97.1903 }; 
                                const endCoords = { lat: 40.3748, lng: -3.7354 };   
                                const duration = 1800;

                                const directLngDiff = endCoords.lng - startCoords.lng;
                                const totalLngChange = -(360 - directLngDiff);
                                const totalLatChange = endCoords.lat - startCoords.lat;
                                const startTimestamp = performance.now();

                                function animateSpin(timestamp) {
                                    const elapsedTime = timestamp - startTimestamp;
                                    let progress = Math.min(elapsedTime / duration, 1);
                                    progress = 1 - Math.pow(1 - progress, 3);

                                    const currentLng = startCoords.lng + (totalLngChange * progress);
                                    const currentLat = startCoords.lat + (totalLatChange * progress);
                                    
                                    navigationMapInstance.setCenter([currentLng, currentLat]);

                                    if (progress < 1) {
                                        requestAnimationFrame(animateSpin);
                                    } else {
                                        navigationMapInstance.setCenter([endCoords.lng, endCoords.lat]);
                                        resolve(); 
                                    }
                                }
                                requestAnimationFrame(animateSpin);
                            });
                            
                            await globeSpinPromise;
                        }
               
                        let currentPos;

                        if (preloadedGpsPosition) {
                            console.log("Usando la ubicación GPS precargada para abrir el mapa.");
                            currentPos = preloadedGpsPosition;
                            preloadedGpsPosition = null;
                        } else {
                            console.log("La ubicación GPS no fue precargada. Buscando activamente...");
                            try {
                                showToast("LOCALIZANDO VEHÍCULO...", "info", 0, false, "gps-locate-toast");
                                currentPos = await getCurrentLocationAsync();
                                const loadingToast = document.getElementById("gps-locate-toast");
                                if (loadingToast) loadingToast.remove();
                            } catch (error) {
                                const loadingToast = document.getElementById("gps-locate-toast");
                                if (loadingToast) loadingToast.remove();
                                showToast(`No se pudo obtener la ubicación para abrir el mapa. Se centrará en la vista por defecto.`, "error");
                                currentPos = { latitude: 40.416775, longitude: -3.703790, heading: 0, speed: 0, altitude: 0, accuracy: 0 };
                            }
                        }
                        
                        setMapImmersiveMode(false);
                        
                        navigationFollowUser = true;
                        shouldCenterOnUser = true;
                        updateLocateMeButtonsUI();
                        toggleMapControls(true);
                        navigationCurrentLocation = currentPos;
                        
                        const initialViewOptions = {
                            center: [currentPos.longitude, currentPos.latitude],
                            zoom: 16,
                            essential: true
                        };

                        const mode = mapViewMode;
                        
                        if (mode === 'heading' || mode === 'perspective' || mode === 'relief') {
                            initialViewOptions.bearing = currentPos.heading || 0;
                        }
                        if (mode === 'perspective' || mode === 'relief') {
                            initialViewOptions.pitch = mapPitchValue;
                        } else {
                            initialViewOptions.pitch = 0;
                        }
                        
                        navigationMapInstance.jumpTo(initialViewOptions);
                        isFlying = false;

                        markerAnimationState.currentMapCenter = navigationMapInstance.getCenter();
                        markerAnimationState.currentMapZoom = navigationMapInstance.getZoom();
                        markerAnimationState.currentMapPitch = navigationMapInstance.getPitch();
                        markerAnimationState.currentMapBearing = navigationMapInstance.getBearing();
                        markerAnimationState.targetMapCenter = navigationMapInstance.getCenter();
                        markerAnimationState.targetMapZoom = navigationMapInstance.getZoom();
                        markerAnimationState.targetMapPitch = navigationMapInstance.getPitch();
                        markerAnimationState.targetMapBearing = navigationMapInstance.getBearing();

                        updateInitialUserPosition(currentPos, navigationMapInstance);
                        
                        startGpsWatching();
                        
                        resolve();
                        
                    } catch (loadError) {
                        showToast(`Error crítico al cargar los recursos del mapa: ${loadError.message}`, "error", 10000);
                        reject(loadError); 
                    }
                });
            } catch (initError) {
                 if (mapActualContainer) mapActualContainer.innerHTML = `<div style="color:red; text-align:center; padding:20px; background: rgba(0,0,0,0.7); height:100%; display:flex; align-items:center; justify-content:center; flex-direction:column;"><h2>Error al cargar el mapa</h2><p>${initError.message}</p><p style="margin-top:10px; font-size:0.9rem;">Por favor, revisa tu token de Mapbox y sus permisos (scopes).</p></div>`;
                 isNavigationMapActive = false;
                 reject(initError); 
            }
        }
    }); 
}    
    
// ===================================================================
// NOMBRE: preflightSync 
// RESUMEN: Se ejecuta ANTES de que se cargue la app. Comprueba si hay datos más nuevos en la nube
async function preflightSync() {
    const autoSyncEnabled = JSON.parse(localStorage.getItem('boardinggate_autoBackupOnLoad') || 'false');
    const { primaryId, isMobile } = parseUserId(localStorage.getItem('userData_userId'));
    const backupPassword = localStorage.getItem('userData_backupPassword');

    if (!autoSyncEnabled || !primaryId || isMobile || !backupPassword) {
        return;
    }

    try {
        const result = await callFirebase('getUserData', { userId: primaryId });

        if (result.status === 'success' && result.data) {
            const cloudTimestamp = new Date(result.data.fechaBackup || 0).getTime();
            const localTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');

            if (cloudTimestamp > localTimestamp + 10000) { // 10s de margen
                const backupCacheData = result.data.contenidoCacheCompleto;
                if (backupCacheData) {
                    showToast('Sincronizando datos desde la nube...', 'info', 2000);

                    const currentUserIdentity = localStorage.getItem('userData_userId') || primaryId;
                    for (const key in backupCacheData) {
                        if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                            localStorage.setItem(key, backupCacheData[key]);
                        }
                    }
                    if (currentUserIdentity) {
                        localStorage.setItem('userData_userId', currentUserIdentity);
                    }
                    localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
                } else {
                 }
            } else {
                 }
        } else {
             }
    } catch (error) {
        }
   }

// ===================================================================
// NOMBRE: uploadDirtyCacheOnLoad_Car 
// RESUMEN: Función específica para el COCHE. Al cargar, si los datos locales son más nuevos, los sube a la nube.
async function uploadDirtyCacheOnLoad_Car() {
    const autoSyncEnabled = JSON.parse(localStorage.getItem('boardinggate_autoBackupOnLoad') || 'false');
    const { primaryId, isMobile } = parseUserId(localStorage.getItem('userData_userId'));
    const backupPassword = localStorage.getItem('userData_backupPassword');

    if (!autoSyncEnabled || !primaryId || isMobile || !backupPassword) {
        return;
    }

    const result = await callFirebase('getUserData', { userId: primaryId });

    if (result.status === 'success' && result.data) {
        const cloudTimestamp = new Date(result.data.fechaBackup || 0).getTime();
        const localTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');

        if (localTimestamp > cloudTimestamp + 10000) { // Si local es más nuevo, subimos
            showToast(`Subiendo cambios locales de ${primaryId} a la nube...`, 'info', 4000);
            await autoSaveFromMobile(primaryId, backupPassword); // Reutilizamos la función de guardado
        }
    } else if (result.status === 'not_found') { // Si no hay nada en la nube, subimos lo local
        showToast(`Creando primer backup en la nube para ${primaryId}...`, 'info', 4000);
        await autoSaveFromMobile(primaryId, backupPassword);
    }
}

// ===================================================================
// NOMBRE: autoSaveFromMobile
// RESUMEN: Realiza un guardado automático en Firebase, llamado por checkReminders para usuarios móviles.
async function autoSaveFromMobile(primaryId, backupPassword) {
    const cacheData = {};
    managedKeys.forEach(key => {
        const value = localStorage.getItem(key);
        if (value !== null) cacheData[key] = value;
    });
    const saveData = {
        userId: primaryId,
        usuario: primaryId,
        modelo: localStorage.getItem('userData_teslaModel') || '',
        anio: localStorage.getItem('userData_teslaYear') || '',
        provincia: localStorage.getItem('userData_teslaProvince') || '',
        rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
        datosCache: cacheData,
        backupPassword: backupPassword,
        fechaBackup: new Date().toISOString()
    };
    const saveResult = await callFirebase('saveUser', saveData);
    const toast = document.getElementById('mobile-autosave');
    if(toast) toast.remove();
    if (saveResult.status === 'success') {
        showToast('Cambios sincronizados con la nube.', 'success');
        lastMobileSyncTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0'); 
    } else {
        showToast(`Error al sincronizar: ${saveResult.message}`, 'error');
    }
}

// ===================================================================
// INICIO: LÓGICA DE MONITOREO DE RECURSOS (Versión simple y funcional)
// ===================================================================
let resourceMonitorInterval = null;
let fpsCounter = {
    frame: 0,
    lastTime: performance.now(),
    fps: 0
};
let isMonitoring = false;

function formatBytes(bytes, decimals = 2) {
    if (typeof bytes !== 'number' || isNaN(bytes) || bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

function updateFPS(timestamp) {
    if (!isMonitoring) return;
    fpsCounter.frame++;
    const delta = timestamp - fpsCounter.lastTime;
    if (delta >= 1000) {
        fpsCounter.fps = (fpsCounter.frame / (delta / 1000)).toFixed(0);
        fpsCounter.frame = 0;
        fpsCounter.lastTime = timestamp;
    }
    requestAnimationFrame(updateFPS);
}
function startResourceMonitor() {
    if (isMonitoring) return;

    if (typeof performance === 'undefined' || !performance.memory) {
        showToast("El monitoreo de memoria no es compatible.", "warning");
        const checkbox = document.getElementById('config-monitor-resources');
        if (checkbox) checkbox.checked = false;
        return;
    }

    isMonitoring = true;
    requestAnimationFrame(updateFPS);

    resourceMonitorInterval = setInterval(() => {
        const memory = performance.memory;
        
        const used = formatBytes(memory.usedJSHeapSize);
        const total = formatBytes(memory.totalJSHeapSize);
        const limit = formatBytes(memory.jsHeapSizeLimit);
        const fps = fpsCounter.fps;

        // Formatea el texto para que se alinee usando una etiqueta <pre>
        const messageContent = `<pre style="margin:0; padding:0; font-family:monospace; font-size:0.90rem;">` +
            `MEMORIA EN USO:   ${used.padStart(12)}\n` +
            `MEMORIA RESERVADA: ${total.padStart(12)}\n` +
            `MEMORIA LÍMITE:   ${limit.padStart(12)}\n` +
            `FPS:              ${String(fps).padStart(12)}` +
            `</pre>`;
            
        const buttonHtml = `<button onclick="stopResourceMonitor()" style="width:100%; margin-top:8px; padding:4px 8px; font-size:0.9rem; font-weight:bold; background-color:#dc3545; color:white; border:none; border-radius:4px; cursor:pointer;">Cancelar</button>`;
        showToast(messageContent + buttonHtml, 'debug', 0, false, 'resource-monitor-toast');
        
        // Ajustamos el estilo de la tostada después de que se cree
        const toast = document.getElementById('resource-monitor-toast');
        if (toast) {
            toast.style.top = '40px';
            toast.style.right = '20px';
            toast.style.bottom = 'auto';
            toast.style.left = 'auto';
            toast.style.transform = 'none';
            toast.style.maxWidth = '300px';
            toast.style.backgroundColor = 'rgba(40, 40, 40, 0.85)';
            toast.style.backdropFilter = 'blur(5px)';
            toast.style.border = '1px solid rgba(255, 255, 255, 0.2)';
        }
    }, 2000);
}
function stopResourceMonitor() {
    if (!isMonitoring) return;

    isMonitoring = false;
    if (resourceMonitorInterval) {
        clearInterval(resourceMonitorInterval);
        resourceMonitorInterval = null;
    }

    const toast = document.getElementById('resource-monitor-toast');
    if (toast) {
        toast.remove();
        // Limpiamos del array de toasts activos para evitar problemas
        activeToasts = activeToasts.filter(t => t.id !== 'resource-monitor-toast');
    }
}
// ===================================================================
// FIN: LÓGICA DE MONITOREO DE RECURSOS
// ===================================================================

// ===================================================================
// NOMBRE: DOMContentLoaded (MODIFICADO)
// RESUMEN: Punto de entrada principal. Ahora espera a la sincronización pre-vuelo ANTES de inicializar la app.
document.addEventListener('DOMContentLoaded', async () => {
     // 1. precargar ubicacion coche y Realiza la comprobación y posible descarga de datos antes de hacer nada más.
    preloadGpsLocation(); 
    await preflightSync();
     
     // 2. Una vez que el localStorage está actualizado, procede con la lógica de renderizado normal.
     storedPin = localStorage.getItem('password_pin');
     const savedPasswordActive = localStorage.getItem('password_active');
     isPasswordActive = savedPasswordActive ? JSON.parse(savedPasswordActive) : false;
     const initialDirectToNavPref = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
     const tempPreventDirectNav = sessionStorage.getItem(TEMP_PREVENT_DIRECT_NAV_KEY);

     if (isPasswordActive && storedPin && !(initialDirectToNavPref && !tempPreventDirectNav)) {
         promptForPin();
     } else {
         await initializeApp();
     }

    assignMapButtonListeners();
    document.body.addEventListener('click', function(event) {
        const target = event.target;
        const targetId = target.id || (target.closest('[id]') ? target.closest('[id]').id : null);

        if (targetId === 'config-close-modal') {
            const termsAcceptedForClose = localStorage.getItem('termsAccepted_v1') === 'true';
            if (!termsAcceptedForClose) {
                showToast('Debes aceptar las normas de uso para continuar.', 'warning');
                return;
            }
            const modal = document.getElementById('config-modal');
            if (modal && !modal.classList.contains('hidden')) {
                clearModalAutoCloseTimer(modal, target, 'config-modal');
                modal.classList.add('hidden');
                 const mapWasOpenBeforeConfig = sessionStorage.getItem('boardinggate_map_should_reopen_after_config') === 'true';
                 const mapContextToReopen = sessionStorage.getItem('mapContextToReopenAfterConfig');
                 sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');
                 sessionStorage.removeItem('mapContextToReopenAfterConfig');
                 if (mapWasOpenBeforeConfig && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !document.getElementById('reminders-location-map-modal')) {
                    if (mapContextToReopen === 'navigation') {
                        setTimeout(() => openNavigationMap(), 50);
                    }
                }
            }
        }
        if (target.matches('.config-tab-button')) {
            const modal = document.getElementById('config-modal');
            if(modal && modal.classList.contains('hidden') === false) {
                const tabTarget = target.dataset.tabTarget;
                modal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                modal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (modal.querySelector(tabTarget)) {
                    modal.querySelector(tabTarget).classList.add('active');
                }
            }
        }
        if (targetId === 'close-reminders-top' || targetId === 'close-reminders-bottom') {
            const modalTable = document.querySelector('.reminder-table-modal');
            if (modalTable) {
                if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                modalTable.remove();
                const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                const mapContext = sessionStorage.getItem('mapContext');
                sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                sessionStorage.removeItem('mapContext');
                if (fromReminderModal) {
                    fromReminderModal = false;
                    if (mapShouldReopen) {
                        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                        sessionStorage.setItem('mapContext', mapContext);
                    }
                    showReminderModal();
                } else if (mapShouldReopen) {
                     if (mapContext === 'navigation') openNavigationMap();
                }
            }
        }
        if (targetId === 'view-all-locations-map') {
            const modalTable = document.querySelector('.reminder-table-modal');
             if (modalTable && modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
             if (modalTable) modalTable.remove();
            setTimeout(() => {
                openLocationsPreviewMap();
            }, 50);
        }
         if (targetId === 'close-locations-preview') {
            const previewModal = document.getElementById('locations-preview-modal');
            if (previewModal) {
                if (locationsPreviewMap) {
                    try { locationsPreviewMap.remove(); } catch (e) {}
                    locationsPreviewMap = null;
                }
                if (mapLayersControlLocationsPreview) {
                    try {mapLayersControlLocationsPreview.remove();} catch(e){}
                    mapLayersControlLocationsPreview = null;
                }
                clearModalAutoCloseTimer(previewModal, target, 'locations-preview-modal');
                previewModal.classList.add('hidden');
            }
        }
        if (targetId === 'close-address-suggestions-modal') {
            hideAddressSuggestionsModal();
        }
    });
   const configModal = document.getElementById('config-modal');
    if (configModal) {
        configModal.addEventListener('click', function(event) {
            const target = event.target;
            if (target.matches('.config-tab-button')) {
                const tabTarget = target.dataset.tabTarget;
                configModal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                configModal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (configModal.querySelector(tabTarget)) {
                    configModal.querySelector(tabTarget).classList.add('active');
                }
            }
        });
    }
    const bookmarkGrid = document.getElementById('bookmark-grid');
    if (bookmarkGrid) {
        bookmarkGrid.addEventListener('click', function(event) {
            const link = event.target.closest('a.bookmark-item');
            if (link && link.href && link.href.startsWith("map-action:")) {
                event.preventDefault();
                const action = link.href.split(":")[1];
                if (action === "openRemindersMapWithNoRadars") {
                    closeOtherModals();
                    setTimeout(() => {
                        const existingPreviewModal = document.getElementById('locations-preview-modal');
                        if (existingPreviewModal && !existingPreviewModal.classList.contains('hidden')) {
                            showToast("El mapa de ubicaciones (sin radar) ya está abierto", "info");
                        } else {
                           openLocationsPreviewMap();
                        }
                    }, 50);
                } else if (action === "openRemindersMap") {
                    closeOtherModals();
                    setTimeout(() => {
                        const mapModalElement = document.getElementById('reminders-location-map-modal');
                        if (mapModalElement && !mapModalElement.classList.contains('hidden')) {
                            showToast("El mapa de navegación/ubicaciones ya está abierto", "info");
                            if (navigationMapInstance) {
                                requestAnimationFrame(() => {
                                    requestAnimationFrame(() => {
                                        if (navigationMapInstance) {
                                            try {
                                                 navigationMapInstance.resize();
                                             } catch (e) {  }
                                        }
                                    });
                                });
                            }
                        } else {
                           openNavigationMap();
                        }
                    }, 50);
                }
            }
        });
    }
    
    const accidentAlertButton = document.getElementById('accident-alert-button');
    if (accidentAlertButton) {
        accidentAlertButton.addEventListener('click', () => {
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
            openAlertModal();
        });
    }

    if (reminderCheckIntervalId) {
        clearInterval(reminderCheckIntervalId); // Doble seguridad por si acaso
    }
    checkReminders(); // Inicia el primer ciclo inmediatamente
    

     window.addEventListener('beforeunload', () => {
         if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
         if (locationWatchId !== null && navigator.geolocation) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
         if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
         const openReminderModal = document.querySelector('.reminder-modal');
         if (openReminderModal && typeof openReminderModal.cleanUpModalTimers === 'function') { openReminderModal.cleanUpModalTimers(true); }
         Object.keys(globalModalTimers).forEach(modalId => {
            const timerData = globalModalTimers[modalId];
            if (timerData) {
                clearModalAutoCloseTimer(timerData.modalElement, timerData.closeButtonElement, modalId);
            }
         });
         globalModalTimers = {};
         const openTableModal = document.querySelector('.reminder-table-modal');
         if(openTableModal && openTableModal.autoCloseInterval) { clearInterval(openTableModal.autoCloseInterval); }
         const openPostponeModal = document.getElementById('postpone-options-modal');
         if(openPostponeModal && openPostponeModal.autoPostponeInterval) { clearInterval(openPostponeModal.autoPostponeInterval); }
         const openSavedLocationsModal = document.querySelector('.saved-locations-modal');
         if (openSavedLocationsModal && locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
         const simModalUnload = document.getElementById('simulation-modal');
         if (simModalUnload && simulationModalTimer) clearTimeout(simulationModalTimer);
         if (autoStartNavTimer) clearTimeout(autoStartNavTimer);
         if (isNavigationMapActive || navigationMapInstance) {
            closeNavigationMap(true);
         }
         if (locationsPreviewMap) {
             try { locationsPreviewMap.remove(); } catch(e){}
             locationsPreviewMap = null;
         }
         if (isAssignmentMode || isEditMode || isKeywordAssignmentMode) { saveCustomData(); }
         const filterInput = document.getElementById('grid-filter-input');
         if (filterInput && filterInput.value.trim()) {
              localStorage.setItem('gridFilterValue', filterInput.value);
         } else {
              localStorage.removeItem('gridFilterValue');
         }
          saveSettings();
          if (reminderModalMap) try {reminderModalMap.remove();} catch(e){}
          Object.values(previewMaps).forEach(map => {try {map?.remove();} catch(e){}});
          if (intersectionPreviewMap) try {intersectionPreviewMap.remove();} catch(e){}
          if (navigationChart) navigationChart.destroy();
          if (graphIntervalTimer) clearInterval(graphIntervalTimer);
     });
});
    
</script>
<div id="map-garage" style="display: none;"></div>            
</body>
</html>
