
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tesla Boarding Gate</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20n6fxhV1W+HF1wNq4NV5CaA/HOkP7BC36hZ0fzaL0" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.geometryutil/0.10.3/leaflet.geometryutil.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder@latest/dist/Control.Geocoder.css" />
    <script src="https://unpkg.com/leaflet-control-geocoder@latest/dist/Control.Geocoder.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

    <style>
        body { font-family: sans-serif; background-color: #18181b; color: #f4f4f5; margin: 0; padding: 0; overflow-x: hidden; }
        body.light-mode { background-color: #f4f4f5; color: #18181b; }
        .grid-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 12px; padding: 16px; }
        .grid-item { background-color: #374151; padding: 12px; border-radius: 8px; text-align: center; cursor: pointer; user-select: none; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: transform 0.2s, background-color 0.2s, box-shadow 0.2s; }
        .grid-item:hover { background-color: #4b5563; transform: scale(1.03); }
        .grid-item.hidden-filter { display: none !important; }
        .grid-item img { width: 40px; height: 40px; margin-bottom: 8px; pointer-events: none; user-select: none; -webkit-user-drag: none; }
        .grid-item span { font-size: 0.9em; color: #d1d5db; pointer-events: none; user-select: none; -webkit-user-drag: none; }
        body.light-mode .grid-item { background-color: #e5e7eb; color: #374151; }
        body.light-mode .grid-item span { color: #4b5563; }
        body.light-mode .grid-item:hover { background-color: #d1d5db; }

        .button-bar { display: flex; justify-content: center; gap: 1rem; padding: 0.5rem 0; background-color: #262626; flex-wrap: wrap; }
        body.light-mode .button-bar { background-color: #e5e7eb; }

        .on-off-button, .settings-button, .edit-button { padding: 0.5rem 1rem; border-radius: 0.5rem; border: none; cursor: pointer; font-weight: bold; transition: background-color 0.2s; }
        .on-off-button { background-color: #ef4444; color: white; }
        .on-off-button.active { background-color: #22c55e; }
        .settings-button { background-color: #f59e0b; color: white; }
        .edit-button { background-color: #3b82f6; color: white; }

        .edit-mode-active .grid-item { cursor: grab; }
        .edit-mode-active .grid-item:active { cursor: grabbing; }
        .edit-mode-active .grid-item:hover { background-color: #fde68a !important; }
        .edit-mode-active .grid-item img, .edit-mode-active .grid-item span { pointer-events: none !important; user-select: none !important; -webkit-user-drag: none !important; }

        .edit-modal, .edit-info-modal, .help-modal, .versions-modal-overlay, .saved-locations-modal, #postpone-options-modal, .reminder-table-modal, #config-modal, #saved-routes-modal {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000;
            background-color: #374151; color: #d1d5db; padding: 1.5rem; border-radius: 1rem; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            max-width: 95%; max-height: 90vh; overflow-y: auto;
            display: flex; flex-direction: column;
            width: 500px; /* Default width, adjusted by specific modal styles */
        }

         #config-modal { width: 600px; }
         .reminder-table-modal { width: 90%; max-width: 1000px; padding: 1rem; font-size: 0.9rem; }
         .reminder-table-modal table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
         .reminder-table-modal th, .reminder-table-modal td { border: 1px solid #4b5563; padding: 8px; text-align: left; }
         .reminder-table-modal th { background-color: #4b5563; color: white; }
         .reminder-table-modal td { color: #d1d5db; }
         .reminder-table-modal .button-group { display: flex; gap: 5px; flex-wrap: wrap; }
         .reminder-table-modal .button-group button { padding: 4px 8px; font-size: 0.8rem; border-radius: 4px; cursor: pointer; }
         .reminder-table-modal .visto-prox { background-color: #ef4444; color: white; }
         .reminder-table-modal .postpone { background-color: #f59e0b; color: white; }
         .reminder-table-modal .cancel-cyclic-table { background-color: #dc2626; color: white; }
         .reminder-table-modal .text-column { cursor: pointer; text-decoration: underline; }
         .reminder-table-modal .date-column, .reminder-table-modal .time-column { white-space: nowrap; }
         .reminder-table-modal .top-button-container { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }

        #saved-locations-modal { width: 550px; }
        #saved-locations-list { max-height: 30vh; overflow-y: auto; margin-bottom: 1rem; border: 1px solid #4b5563; border-radius: 5px; padding: 10px; }
        .location-slot { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; padding: 8px; background-color: #4b5563; border-radius: 5px; }
        .location-slot input[type="text"] { flex-grow: 1; padding: 4px 8px; border-radius: 4px; border: 1px solid #6b7280; background-color: #374151; color: #d1d5db; }
        .location-slot .map-button, .location-slot .select-location-button { padding: 4px 8px; font-size: 0.8rem; border-radius: 4px; cursor: pointer; }
        .location-slot .map-button { background-color: #3b82f6; color: white; }
         .location-slot .select-location-button { background-color: #22c55e; color: white;}
        .location-slot .coords-display { font-size: 0.85em; color: #9ca3af; white-space: nowrap; }

        #location-picker-map-container { height: 300px; width: 100%; margin-top: 1rem; border: 1px solid #4b5563; border-radius: 5px; position: relative; overflow: hidden; display: none; }
        #location-picker-map-container.expanded { display: block; }
        #location-picker-map-container .leaflet-container { height: 100%; width: 100%; }
        #location-picker-map-container button { position: absolute; z-index: 401; padding: 5px 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em; }
        #picker-ok-map-button { bottom: 10px; left: 10px; background-color: #22c55e; color: white; }
        #picker-locate-me-button { bottom: 10px; right: 10px; background-color: #f59e0b; color: white; }


        body.light-mode .edit-modal, body.light-mode .edit-info-modal, body.light-mode .help-modal, body.light-mode .versions-modal-overlay, body.light-mode .saved-locations-modal, body.light-mode #postpone-options-modal, body.light-mode .reminder-table-modal, body.light-mode #config-modal, body.light-mode #saved-routes-modal {
             background-color: #e5e7eb; color: #18181b; box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
         body.light-mode .reminder-table-modal th { background-color: #d1d5db; color: #18181b; }
         body.light-mode .reminder-table-modal td { color: #18181b; border-color: #d1d5db; }
         body.light-mode .location-slot { background-color: #d1d5db; }
         body.light-mode .location-slot input[type="text"] { background-color: #e5e7eb; color: #18181b; border-color: #d1d5db; }
         body.light-mode #location-picker-map-container { border-color: #d1d5db; }


        .edit-modal h2, .edit-info-modal h2, .help-modal h2, .versions-modal-overlay h2, .saved-locations-modal h2, #postpone-options-modal h2, .reminder-table-modal h2, #config-modal h2, #saved-routes-modal h3 {
             text-align: center; color: #f59e0b; margin-bottom: 1.5rem;
        }
         body.light-mode .edit-modal h2, body.light-mode .edit-info-modal h2, body.light-mode .help-modal h2, body.light-mode .versions-modal-overlay h2, body.light-mode .saved-locations-modal h2, body.light-mode #postpone-options-modal h2, body.light-mode .reminder-table-modal h2, body.light-mode #config-modal h2, body.light-mode #saved-routes-modal h3 {
             color: #d97706;
         }


        .edit-modal label, .edit-modal input, .edit-modal select { display: block; margin-bottom: 10px; width: 100%; }
        .edit-modal input, .edit-modal select { padding: 8px; border-radius: 4px; border: 1px solid #6b7280; background-color: #4b5563; color: #d1d5db; }
         body.light-mode .edit-modal input, body.light-mode .edit-modal select { background-color: #d1d5db; color: #18181b; border-color: #6b7280;}

        .edit-modal button { padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px; }
        .edit-modal button:last-child { margin-right: 0; }
        .edit-modal .button-group { display: flex; justify-content: space-between; margin-top: 1.5rem; }

        .edit-modal .upload-section { margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid #6b7280; }
        .edit-modal .upload-section input[type="file"] { display: none; }
        .edit-modal .upload-button { display: inline-block; background-color: #3b82f6; color: white; padding: 8px 12px; border-radius: 4px; cursor: pointer; }
         body.light-mode .edit-modal .upload-button { background-color: #2563eb;}

        .editing-target { outline: 3px solid #f59e0b !important; outline-offset: 3px; box-shadow: 0 0 10px rgba(245, 158, 11, 0.5); }

        .help-modal, .versions-modal-overlay { z-index: 2000; }
        .help-modal h3, .versions-modal-overlay h3 { margin-top: 1rem; margin-bottom: 0.5rem; font-size: 1.1rem; color: #f59e0b; }
         body.light-mode .help-modal h3, body.light-mode .versions-modal-overlay h3 { color: #d97706; }
        .help-modal ul, .versions-modal-overlay ul { list-style-type: disc; margin-left: 20px; }
        .help-modal li, .versions-modal-overlay li { margin-bottom: 5px; font-size: 0.95rem; }
        .help-modal strong, .versions-modal-overlay strong { color: #d1d5db; }
        body.light-mode .help-modal strong, body.light-mode .versions-modal-overlay strong { color: #18181b; }

        .versions-modal-overlay .version-entry { margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid #6b7280; }
        .versions-modal-overlay .version-entry:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        .versions-modal-overlay .version-title { font-weight: bold; font-size: 1.2rem; color: #22c55e; }
         body.light-mode .versions-modal-overlay .version-title { color: #16a34a; }
        .versions-modal-overlay .version-date { font-style: italic; font-size: 0.9rem; color: #9ca3af; }
        .versions-modal-overlay .version-notes { margin-top: 5px; font-size: 0.95rem; }
        .versions-modal-overlay .version-notes ul { list-style-type: disc; margin-left: 20px; }
        .versions-modal-overlay .version-notes li { margin-bottom: 3px; }

        .versions-icon { position: fixed; bottom: 10px; right: 10px; font-size: 0.8rem; color: #9ca3af; cursor: pointer; text-decoration: underline; z-index: 500; opacity: 0.8; transition: opacity 0.3s; }
        .versions-icon:hover { opacity: 1; }
        body.light-mode .versions-icon { color: #6b7280; }
        .versions-icon.new-version-available { color: #f59e0b; font-weight: bold; animation: pulse 1.5s infinite; }
         body.light-mode .versions-icon.new-version-available { color: #d97706; }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }


        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
            z-index: 1001;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .grid-item:hover .tooltip { opacity: 1; }

        .draggable-marker { position: absolute; background-color: red; color: white; border-radius: 50%; width: 20px; height: 20px; text-align: center; line-height: 20px; font-weight: bold; cursor: grab; }
         .drag-helper { position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 999; }


        .modal-overlay {
             position: fixed;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             background-color: rgba(0, 0, 0, 0.7);
             z-index: 990;
        }

        .reminder-modal {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000;
            background-color: #374151; color: #d1d5db; padding: 1.5rem; border-radius: 1rem; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            max-width: 95%; max-height: 90vh; overflow-y: auto;
            width: 500px; display: flex; flex-direction: column;
        }
        body.light-mode .reminder-modal { background-color: #e5e7eb; color: #18181b; }
        .reminder-modal h2 { text-align: center; color: #f59e0b; margin-bottom: 1.5rem; }
         body.light-mode .reminder-modal h2 { color: #d97706; }
        .reminder-modal label { display: block; margin-bottom: 5px; font-weight: bold; }
        .reminder-modal input[type="text"],
        .reminder-modal input[type="time"],
        .reminder-modal input[type="date"],
        .reminder-modal input[type="number"] {
             display: block; width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #6b7280;
             background-color: #4b5563; color: #d1d5db; margin-bottom: 10px;
        }
         body.light-mode .reminder-modal input { background-color: #d1d5db; color: #18181b; border-color: #6b7280;}

        .reminder-modal .checkbox-group { margin-bottom: 10px; }
        .reminder-modal .checkbox-group label { display: inline-block; font-weight: normal; margin-right: 10px; }
        .reminder-modal .button-group { display: flex; justify-content: space-between; margin-top: 1.5rem; gap: 10px; }
        .reminder-modal .button-group button { padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; flex-grow: 1; }
        .reminder-modal .save-button { background-color: #22c55e; color: white; }
        .reminder-modal .cancel-button { background-color: #ef4444; color: white; }
        .reminder-modal .help-button { background-color: #3b82f6; color: white; }
        .reminder-modal .clear-button { background-color: #f59e0b; color: white; }
        .reminder-modal .view-button { background-color: #6366f1; color: white; }
        .reminder-modal .status-message { margin-top: 10px; text-align: center; font-size: 0.9rem; }

        .reminder-modal .map-container { width: 100%; height: 250px; margin-top: 10px; border: 1px solid #6b7280; border-radius: 4px; position: relative;}
         .reminder-modal .map-container .leaflet-container { height: 100%; width: 100%; }
        .reminder-modal .map-container .map-button { position: absolute; z-index: 401; padding: 5px 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em; }
        .reminder-modal .map-container .ok-map-button { bottom: 10px; left: 10px; background-color: #22c55e; color: white; }
        .reminder-modal .map-container .locate-me-button { bottom: 10px; right: 10px; background-color: #f59e0b; color: white; }
        .reminder-modal .map-container .saved-locations-button { bottom: 10px; left: 50%; transform: translateX(-50%); background-color: #3b82f6; color: white;}


        #reminder-button { position: relative; display: inline-flex; align-items: center; }
        #reminder-button .reminder-count {
             position: absolute; top: -5px; right: -5px; background-color: red; color: white;
             border-radius: 50%; padding: 2px 6px; font-size: 0.75rem; font-weight: bold;
        }

        #reminder-count-globe {
            position: fixed; top: 10px; left: 10px;
            width: 30px; height: 30px; border-radius: 50%; background-color: red; color: white;
            display: flex; justify-content: center; align-items: center;
            font-size: 0.8rem; font-weight: bold; z-index: 500;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            pointer-events: all; /* Make it clickable */
            cursor: pointer;
        }

        .unified-reminder-window {
             position: fixed;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             width: 95%;
             max-width: 600px;
             max-height: 95vh;
             background-color: #374151;
             border-radius: 1rem;
             box-shadow: 0 10px 30px rgba(0,0,0,0.5);
             z-index: 7000;
             display: none;
             flex-direction: column;
             overflow: hidden;
             transition: opacity 0.3s ease;
             opacity: 0;
        }
        body.light-mode .unified-reminder-window {
            background-color: #e5e7eb;
        }

        .unified-reminder-window.visible {
            display: flex;
            opacity: 1;
        }

        .reminder-count-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 1.5rem;
            background-color: #2d3748; /* Slightly darker header */
            border-bottom: 1px solid #4a5568;
            flex-shrink: 0;
        }
         body.light-mode .reminder-count-header { background-color: #cbd5e0; border-bottom-color: #a0aec0;}


        .reminder-count-header h2 {
            font-size: 1.3rem;
            color: #f59e0b;
            margin: 0;
        }
         body.light-mode .reminder-count-header h2 { color: #d97706;}


        .reminder-count-text-container {
            font-size: 1.1rem;
            color: #d1d5db;
        }
         body.light-mode .reminder-count-text-container { color: #4a5568; }


        #reminder-swiper-container {
            display: flex;
            overflow-x: auto;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch; /* Enable smooth scrolling on iOS */
             scrollbar-width: none; /* Hide scrollbar for Firefox */
            -ms-overflow-style: none; /* Hide scrollbar for Internet Explorer and Edge */
             flex-grow: 1;
        }
        #reminder-swiper-container::-webkit-scrollbar {
            display: none; /* Hide scrollbar for Chrome, Safari and Opera */
        }


        .reminder-slide {
            flex: 0 0 100%; /* Each slide takes 100% of the container width */
            width: 100%;
            scroll-snap-align: start;
            padding: 1.5rem;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            max-height: calc(95vh - 60px); /* Adjust based on header height */
            overflow-y: auto; /* Allow content inside slide to scroll if needed */
             scrollbar-width: thin; /* Show scrollbar for Firefox */
        }
         .reminder-slide::-webkit-scrollbar {
             width: 8px;
         }
         .reminder-slide::-webkit-scrollbar-track {
             background: #4b5563; /* Darker track */
             border-radius: 4px;
         }
         .reminder-slide::-webkit-scrollbar-thumb {
             background-color: #6b7280; /* Grey thumb */
             border-radius: 4px;
             border: 2px solid #4b5563; /* Padding around thumb */
         }
         body.light-mode .reminder-slide::-webkit-scrollbar-track { background: #d1d5db; }
         body.light-mode .reminder-slide::-webkit-scrollbar-thumb { background-color: #a0aec0; border-color: #d1d5db; }


        .reminder-slide-content {
             display: flex;
             flex-direction: column;
             flex-grow: 1;
        }
        .reminder-content-scrollable {
             flex-grow: 1;
             margin-bottom: 1rem;
        }

        .reminder-text {
            font-size: 1.5rem;
            font-weight: bold;
            color: #e5e7eb;
            margin-bottom: 1rem;
            word-wrap: break-word;
        }
         body.light-mode .reminder-text { color: #18181b;}


        .reminder-details {
            font-size: 1.15rem;
            color: #a0aec0;
            margin-bottom: 0.5rem;
        }
         body.light-mode .reminder-details { color: #4b5563; }


        .unified-reminder-window .button-group {
             display: flex;
             flex-direction: column;
             gap: 0.8rem;
             margin-top: auto; /* Push buttons to the bottom */
             flex-shrink: 0;
        }

        .unified-reminder-window .button-group button {
            padding: 0.8rem 1.5rem;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .unified-reminder-window .cancel { background-color: #ef4444; color: white; }
        .unified-reminder-window .cancel:hover { background-color: #dc2626; }
        .unified-reminder-window .postpone { background-color: #f59e0b; color: white; }
        .unified-reminder-window .postpone:hover { background-color: #d97706; }
        .unified-reminder-window .modify { background-color: #3b82f6; color: white; }
        .unified-reminder-window .modify:hover { background-color: #2563eb; }
         .unified-reminder-window .adjust-time-0001 { background-color: #10b981; color: white; font-size: 1.1rem; }
         .unified-reminder-window .adjust-time-0001:hover { background-color: #059669; }
         .unified-reminder-window .cancel-cyclic { background-color: #6b7280; color: white; font-size: 1.1rem; }
         .unified-reminder-window .cancel-cyclic:hover { background-color: #4b5563; }


        .reminder-swipe-hint {
            text-align: center;
            font-size: 0.9rem;
            color: #a0aec0;
            margin-top: 0.5rem;
             flex-shrink: 0;
        }
         body.light-mode .reminder-swipe-hint { color: #4b5563; }


         #hide-all-reminders-button {
             padding: 0.5rem 1rem;
             font-size: 0.9rem;
             background-color: #4b5563;
             color: white;
             border: none;
             border-radius: 0.3rem;
             cursor: pointer;
             transition: background-color 0.2s ease;
         }
         #hide-all-reminders-button:hover { background-color: #374151; }
         body.light-mode #hide-all-reminders-button { background-color: #a0aec0; color: #18181b; }
         body.light-mode #hide-all-reminders-button:hover { background-color: #8896a9; }


        .reminder-map-preview-container {
            margin-top: 1rem;
            width: 100%;
            /* height: 200px; */ /* Removed fixed height, flex will handle */
            border-radius: 0.5rem;
            overflow: hidden;
            flex-shrink: 0; /* Don't let it shrink */
             flex-basis: 200px; /* Give it a base size */
             min-height: 100px; /* Ensure min height */
        }
        .reminder-map-preview {
            width: 100%;
            height: 100%;
        }
        .reminder-map-preview .leaflet-container {
             height: 100%; width: 100%;
             z-index: 1; /* Ensure map is below modals/popups */
        }
         /* Specific z-index for Leaflet popups if needed */
        .reminder-map-preview .leaflet-popup-pane { z-index: 2; }


        .toast-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 1rem;
            z-index: 8000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none; /* Allow clicks through */
            min-width: 200px;
            text-align: center;
        }
        .toast-notification.show { opacity: 1; }
        .toast-success { background-color: #22c55e; }
        .toast-error { background-color: #ef4444; }
        .toast-warning { background-color: #f59e0b; }
        .toast-info { background-color: #3b82f6; }


        .yellow-border {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            box-sizing: border-box;
            border: 25px solid #FFFF00;
            z-index: 99999;
            pointer-events: none;
            opacity: 1;
            transition: opacity 0.5s ease-out;
        }


         #pin-modal {
             position: fixed;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             background-color: #18181b; /* Dark background */
             color: #f4f4f5; /* Light text */
             z-index: 10000; /* Ensure it's on top */
             display: flex;
             flex-direction: column;
             justify-content: center;
             align-items: center;
             font-family: sans-serif;
         }
         #pin-modal h2 {
             font-size: 2rem;
             margin-bottom: 1rem;
             color: #f59e0b;
         }
          #pin-modal p {
              margin-bottom: 1.5rem;
              font-size: 1.1rem;
          }
         #pin-input-container {
             display: flex;
             gap: 10px;
             margin-bottom: 1.5rem;
         }
         .pin-digit-input {
             width: 50px;
             height: 60px;
             font-size: 2rem;
             text-align: center;
             border: 2px solid #4b5563;
             border-radius: 8px;
             background-color: #374151;
             color: #f4f4f5;
             caret-color: #f59e0b;
             outline: none;
         }
         .pin-digit-input:focus {
             border-color: #f59e0b;
             box-shadow: 0 0 8px rgba(245, 158, 11, 0.5);
         }
          #pin-modal button {
              padding: 0.7rem 1.5rem;
              font-size: 1.1rem;
              font-weight: bold;
              background-color: #3b82f6;
              color: white;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              transition: background-color 0.2s ease;
          }
          #pin-modal button:hover {
              background-color: #2563eb;
          }
          #pin-modal .status-message {
              margin-top: 1rem;
              font-size: 1rem;
              color: #ef4444; /* Error color */
          }


        /* Styles for Config Modal */
         #config-modal { width: 90%; max-width: 700px; z-index: 8000; }
         #config-modal h2 { margin-bottom: 1rem; }
         #config-modal .tab-buttons { display: flex; justify-content: center; gap: 10px; margin-bottom: 1.5rem; }
         #config-modal .config-tab-button { padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; background-color: #6b7280; color: white; transition: background-color 0.2s; }
         #config-modal .config-tab-button.active { background-color: #f59e0b; }
         body.light-mode #config-modal .config-tab-button { background-color: #a0aec0; color: #18181b; }
         body.light-mode #config-modal .config-tab-button.active { background-color: #d97706; color: white; }

         #config-modal .tab-contents { border-top: 1px solid #6b7280; padding-top: 1.5rem; }
         #config-modal .config-tab-content { display: none; }
         #config-modal .config-tab-content.active { display: block; }

         #config-modal h3 { font-size: 1.3rem; margin-bottom: 1rem; color: #d1d5db; }
         body.light-mode #config-modal h3 { color: #374151; }

         #config-modal label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 0.95rem; }
         #config-modal input[type="text"], #config-modal input[type="number"], #config-modal textarea {
             display: block; width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #6b7280;
             background-color: #4b5563; color: #d1d5db; margin-bottom: 10px; box-sizing: border-box;
         }
          body.light-mode #config-modal input, body.light-mode #config-modal textarea { background-color: #d1d5db; color: #18181b; border-color: #6b7280;}

         #config-modal .user-data-grid {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
             gap: 15px;
             margin-bottom: 1.5rem;
         }
         #config-modal .user-data-grid .checkbox-container {
              grid-column: span 2; /* Make checkbox span two columns */
              display: flex; align-items: center;
         }
         #config-modal .user-data-grid .checkbox-container input { width: auto; margin-right: 8px; margin-bottom: 0; }
         #config-modal .user-data-grid .checkbox-container label { margin-bottom: 0; font-weight: normal; }


         #config-modal .pin-config-layout {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
              gap: 15px;
              align-items: end;
              margin-bottom: 1.5rem;
         }
         #config-modal .pin-input-group label { margin-bottom: 5px; }
         #config-modal .pin-input-group input { margin-bottom: 0; }
         #config-modal .pin-buttons-container { grid-column: span 2; display: flex; gap: 10px; justify-content: center; }
          #config-modal .pin-buttons-container button { flex-grow: 1; max-width: 200px; }


         #config-modal .backup-restore-container {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
             gap: 20px;
         }
         #config-modal .backup-restore-container > div {
              padding: 1rem; border: 1px solid #6b7280; border-radius: 8px;
              background-color: #4b5563;
         }
          body.light-mode #config-modal .backup-restore-container > div { background-color: #d1d5db; border-color: #a0aec0;}

         #config-modal .backup-restore-container h3 { margin-bottom: 0.5rem; font-size: 1.1rem; color: #e5e7eb; }
         body.light-mode #config-modal .backup-restore-container h3 { color: #18181b; }

         #config-modal .backup-restore-container p { font-size: 0.9rem; margin-bottom: 1rem; color: #a0aec0; }
         body.light-mode #config-modal .backup-restore-container p { color: #374151; }


         #config-backup-display { height: 150px; margin-top: 1rem; font-size: 0.8rem; }
         #config-restore-input { height: 150px; font-size: 0.8rem; }

         #config-modal button { padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px; font-weight: bold;}
         #config-modal button:last-child { margin-right: 0; }

         #config-modal .status-message { margin-top: 10px; text-align: center; font-size: 0.9rem; }

         #config-modal .borrar-container button { background-color: #ef4444; color: white; margin-bottom: 1rem; }
          body.light-mode #config-modal .borrar-container button { background-color: #dc2626; }
         #config-modal .borrar-container h3 { color: #ef4444; }
         body.light-mode #config-modal .borrar-container h3 { color: #dc2626; }
         #config-modal .borrar-container p { font-weight: bold; margin-bottom: 0; }
          #config-modal .borrar-container strong { color: red; }

         #config-modal .radar-filter-group {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
              gap: 10px;
              margin-bottom: 1rem;
         }
         #config-modal .radar-action-buttons {
              display: flex;
              gap: 15px;
              flex-wrap: wrap;
              margin-top: 1.5rem;
         }
         #config-modal #import-radars-button { background-color: #10b981; color: white; flex-grow: 1; }
         #config-modal #delete-filtered-radars-button { background-color: #ef4444; color: white; flex-grow: 1; }
          body.light-mode #config-modal #import-radars-button { background-color: #059669; }
          body.light-mode #config-modal #delete-filtered-radars-button { background-color: #dc2626; }

         #config-modal #radar-import-progress-container {
              margin-top: 1rem;
         }
         #config-modal #radar-import-progress-bar {
             width: 100%; height: 10px; border-radius: 5px;
             overflow: hidden; /* Ensure progress bar fills rounded edges */
             appearance: none; /* Remove default styles */
             -webkit-appearance: none; /* Safari/Chrome */
             border: 1px solid #6b7280; /* Border */
             background-color: #4b5563; /* Background for the 'empty' part */
         }

         /* Style for the filled part of the progress bar */
         #config-modal #radar-import-progress-bar::-webkit-progress-bar { background-color: #4b5563; }
         #config-modal #radar-import-progress-bar::-webkit-progress-value { background-color: #22c55e; } /* Green fill */
         #config-modal #radar-import-progress-bar::-moz-progress-bar { background-color: #22c55e; } /* Green fill */
         #config-modal #radar-import-progress-bar::-ms-fill { background-color: #22c55e; } /* Green fill */

          body.light-mode #config-modal #radar-import-progress-bar { border-color: #a0aec0; background-color: #d1d5db; }
          body.light-mode #config-modal #radar-import-progress-bar::-webkit-progress-bar { background-color: #d1d5db; }
          body.light-mode #config-modal #radar-import-progress-bar::-webkit-progress-value { background-color: #16a34a; }
          body.light-mode #config-modal #radar-import-progress-bar::-moz-progress-bar { background-color: #16a34a; }
          body.light-mode #config-modal #radar-import-progress-bar::-ms-fill { background-color: #16a34a; }


         #config-modal #radar-import-status { margin-top: 5px; font-size: 0.85rem; text-align: center; color: #a0aec0; }
          body.light-mode #config-modal #radar-import-status { color: #4b5563;}

         #config-modal .radar-import-options { display: flex; align-items: center; font-size: 0.9rem; margin-top: 1rem;}
         #config-modal .radar-import-options input { margin-right: 8px; width: auto; margin-bottom: 0;}
         #config-modal .radar-import-options label { margin-bottom: 0; font-weight: normal; color: #d1d5db; }
         body.light-mode #config-modal .radar-import-options label { color: #374151; }


         #reminders-location-map-modal {
             position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 999;
             background-color: #fff; /* Base background for map */
             display: flex; flex-direction: column;
         }
         #reminders-location-map-content-wrapper { display: flex; flex-direction: column; width: 100%; height: 100%;}
         #reminders-location-map-header {
             display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center;
             padding: 8px; background-color: #f4f4f5; flex-shrink: 0;
             box-shadow: 0 2px 5px rgba(0,0,0,0.1);
         }
         #reminders-location-map-header .button-group-main, #reminders-location-map-header .button-group-route { display: flex; gap: 5px; flex-wrap: wrap;}
         #reminders-location-map-header button { padding: 6px 10px; font-size: 0.85rem; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;}
         #reminders-location-map-header .reminders-map-button-action { background-color: #d1d5db; color: #374151;}
         #reminders-location-map-header .route-button-action { background-color: #f59e0b; color: white;}
          #reminders-location-map-header #create-route-button { background-color: #22c55e; color: white;}


         #reminders-location-map-div { flex-grow: 1; width: 100%; position: relative; }
         #reminders-location-map-div .leaflet-container { height: 100%; width: 100%; }


        /* Styles for Waypoint delete icon */
         .delete-waypoint-icon {
              position: absolute;
              top: -10px; /* Adjust position relative to marker element */
              right: -10px; /* Adjust position relative to marker element */
              width: 20px;
              height: 20px;
              background-color: red;
              color: white;
              border-radius: 50%;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 14px;
              font-weight: bold;
              cursor: pointer;
              z-index: 500; /* Ensure it's above other map elements */
              box-shadow: 0 0 5px rgba(0,0,0,0.5);
         }
        /* Ensure LRM waypoint markers have a position context for the delete icon */
        .leaflet-routing-container .leaflet-marker-draggable:not(.leaflet-marker-icon) {
             position: relative !important; /* Override LRM default if necessary */
         }
          /* Custom waypoint div icon needs relative position */
          .custom-waypoint-div-icon div { position: relative; }


         /* Styles for Progress Bar */
         #progress-bar-container {
              position: absolute; bottom: 0; left: 0; right: 0; height: 25px;
              background-color: rgba(0, 0, 0, 0.5); z-index: 400; display: none;
              box-sizing: border-box; padding: 0 5px; display: flex; align-items: center;
              flex-direction: column; justify-content: center;
         }
          #progress-bar-container #routing-info-panel {
              display: flex; justify-content: space-around; width: 100%;
              color: white; font-size: 0.8em; margin-bottom: 2px;
          }
           #progress-bar-container #routing-info-panel p { margin: 0; }
            #progress-bar-container #routing-info-panel strong { font-weight: bold; }

         #progress-bar-fill {
             height: 10px; background-color: orange; width: 0%;
             position: absolute; bottom: 0; left: 0; transition: width 0.5s linear;
             z-index: 401;
         }
         #progress-bar-text-overlay {
             position: absolute; bottom: 5px; left: 50%; transform: translateX(-50%);
             color: white; font-size: 0.8em; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
             z-index: 402; white-space: nowrap;
         }
          .waypoint-marker-on-progress {
              position: absolute;
              bottom: 0px; /* Align with the progress bar bottom */
              width: 8px;
              height: 8px;
              background-color: blue;
              border-radius: 50%;
              z-index: 403;
              transform: translateX(-50%); /* Center the dot on the calculated percentage */
          }


        /* Styles for Current Maneuver Panel */
         #current-maneuver-panel {
             position: absolute;
             top: 10px; /* Below the compass */
             left: 70px; /* To the right of the compass */
             background-color: rgba(255, 255, 255, 0.85);
             padding: 5px 10px;
             border-radius: 3px;
             box-shadow: 0 1px 4px rgba(0,0,0,0.3);
             z-index: 400; /* Below Leaflet controls */
             display: none; /* Hidden by default */
             align-items: center;
             gap: 10px;
             max-width: calc(100% - 85px); /* Leave space on the right */
             overflow: hidden; /* Prevent content overflow */
         }

         #current-maneuver-panel .maneuver-icon {
             width: 30px;
             height: 30px;
             background-size: contain;
             background-repeat: no-repeat;
             background-position: center;
              /* Map Leaflet Routing Machine icons */
         }
         .leaflet-routing-icon-continue { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 2a10 10 0 1010 10A10 10 0 0012 2zm0 18a8 8 0 118-8 8 8 0 01-8 8zm1-13v7a1 1 0 01-2 0v-7a1 1 0 012 0z"/></svg>'); }
         .leaflet-routing-icon-turn-left { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M13 18v-6h3.5a1 1 0 00.7-.29A1 1 0 0018 11.5V7a1 1 0 00-.3-.71 1 1 0 00-.7-.29h-2v-3a1 1 0 00-1.71-.71l-5 5a1 1 0 000 1.42l5 5A1 1 0 0013 18z"/></svg>'); transform: scaleX(-1); }
         .leaflet-routing-icon-turn-right { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M13 18v-6h3.5a1 1 0 00.7-.29A1 1 0 0018 11.5V7a1 1 0 00-.3-.71 1 1 0 00-.7-.29h-2v-3a1 1 0 00-1.71-.71l-5 5a1 1 0 000 1.42l5 5A1 1 0 0013 18z"/></svg>');}
         .leaflet-routing-icon-slight-left { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M13 19v-7a1 1 0 00-2 0v7a1 1 0 002 0zm-1-10a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h2a1 1 0 001-1V9zm0-4a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h2a1 1 0 001-1V5z"/></svg>'); transform: rotate(45deg) scaleX(-1);}
         .leaflet-routing-icon-slight-right { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M13 19v-7a1 1 0 00-2 0v7a1 1 0 002 0zm-1-10a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h2a1 1 0 001-1V9zm0-4a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h2a1 1 0 001-1V5z"/></svg>'); transform: rotate(-45deg); }
         .leaflet-routing-icon-sharp-left { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 18v-6a1 1 0 00-2 0v6a1 1 0 002 0zm0-10a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V8zm0-4a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V4z"/></svg>'); transform: rotate(90deg) scaleX(-1); }
         .leaflet-routing-icon-sharp-right { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 18v-6a1 1 0 00-2 0v6a1 1 0 002 0zm0-10a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V8zm0-4a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V4z"/></svg>'); transform: rotate(-90deg); }
         .leaflet-routing-icon-u-turn { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 18v-6a1 1 0 00-2 0v6a1 1 0 002 0zm0-10a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V8zm0-4a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V4z"/></svg>'); transform: rotate(180deg); } /* Using sharp turn icon rotated */
         .leaflet-routing-icon-roundabout { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 2a10 10 0 1010 10A10 10 0 0012 2zm0 18a8 8 0 118-8 8 8 0 01-8 8zm1-13v7a1 1 0 01-2 0v-7a1 1 0 012 0z"/></svg>'); } /* Using continue icon for simplicity */
          .leaflet-routing-icon-arrive { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 2a10 10 0 1010 10A10 10 0 0012 2zm0 18a8 8 0 118-8 8 8 0 01-8 8zm3-8a3 3 0 11-3-3 3 3 0 013 3z"/></svg>'); }
         .leaflet-routing-icon-depart { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 2a10 10 0 1010 10A10 10 0 0012 2zm0 18a8 8 0 118-8 8 8 0 01-8 8zm1-13v7a1 1 0 01-2 0v-7a1 1 0 012 0z"/></svg>'); } /* Using continue icon */
         .leaflet-routing-icon-fork { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 18v-6h3.5a1 1 0 00.7-.29A1 1 0 0018 11.5V7a1 1 0 00-.3-.71 1 1 0 00-.7-.29h-2v-3a1 1 0 00-1.71-.71l-5 5a1 1 0 000 1.42l5 5A1 1 0 0013 18z"/></svg>'); transform: rotate(-45deg); } /* Using right turn rotated */
         .leaflet-routing-icon-ramp { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 18v-6a1 1 0 00-2 0v6a1 1 0 002 0zm0-10a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V8zm0-4a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V4z"/></svg>'); transform: rotate(45deg); } /* Using sharp turn rotated */
         .leaflet-routing-icon-off-ramp { background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 18v-6a1 1 0 00-2 0v6a1 1 0 002 0zm0-10a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V8zm0-4a1 1 0 00-1-1H7a1 1 0 00-1 1v3a1 1 0 001 1h4a1 1 0 001-1V4z"/></svg>'); transform: rotate(-135deg); } /* Using sharp turn rotated */


         #current-maneuver-panel .maneuver-text-container {
             display: flex;
             flex-direction: column;
             flex-grow: 1;
             min-width: 0; /* Allow text to shrink */
         }
         #current-maneuver-panel .maneuver-instruction {
             font-size: 1.1em;
             font-weight: bold;
             color: #333;
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis; /* Ellipsis for long instructions */
             line-height: 1.2;
         }
         #current-maneuver-panel .maneuver-distance {
             font-size: 0.9em;
             color: #555;
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
             line-height: 1.1;
         }
         #current-maneuver-panel .next-maneuver {
             font-size: 0.8em;
             color: #666;
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
             line-height: 1.1;
             margin-top: 2px;
         }


         /* Styles for Orientation Altitude Control (Top Left) */
         .leaflet-control-orientation-altitude {
             display: flex;
             flex-direction: column;
             align-items: center;
             margin-top: 10px;
             margin-left: 10px;
             z-index: 400; /* Below default Leaflet controls but above map */
         }

         #orientation-altitude-text-container {
            /* Styles defined inline in JS */
         }

         /* Responsive Adjustments */
         @media (max-width: 768px) {
             .grid-container { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 8px; padding: 12px;}
             .grid-item { padding: 8px; border-radius: 6px; }
             .grid-item img { width: 32px; height: 32px; margin-bottom: 4px; }
             .grid-item span { font-size: 0.8em; }

             .button-bar { gap: 0.5rem; padding: 0.3rem 0;}
             .on-off-button, .settings-button, .edit-button { padding: 0.4rem 0.8rem; font-size: 0.9rem;}

             .edit-modal, .edit-info-modal, .help-modal, .versions-modal-overlay, .saved-locations-modal, #postpone-options-modal, .reminder-table-modal, #config-modal, #saved-routes-modal {
                 width: 98%; padding: 1rem; border-radius: 0.8rem;
             }
             .reminder-modal { width: 98%; padding: 1rem; border-radius: 0.8rem; }

             .reminder-modal .button-group button { padding: 8px 12px; font-size: 1rem; }

             .reminder-table-modal { font-size: 0.8rem; padding: 0.5rem;}
             .reminder-table-modal th, .reminder-table-modal td { padding: 5px; }
             .reminder-table-modal .button-group button { padding: 3px 6px; font-size: 0.7rem; }

             #saved-locations-modal { width: 98%;}
             #saved-locations-list { max-height: 25vh; padding: 8px; }
             .location-slot { gap: 5px; margin-bottom: 8px; padding: 6px; }
             .location-slot input[type="text"] { padding: 3px 6px; }
             .location-slot .map-button, .location-slot .select-location-button { padding: 3px 6px; font-size: 0.7rem; }
             .location-slot .coords-display { font-size: 0.7em; }
             #location-picker-map-container { height: 200px; }

              #config-modal { width: 98%; padding: 1rem;}
              #config-modal .tab-buttons { flex-wrap: wrap; gap: 5px; }
              #config-modal .config-tab-button { flex-grow: 1; text-align: center; padding: 6px;}
              #config-modal .user-data-grid, #config-modal .pin-config-layout, #config-modal .backup-restore-container {
                  grid-template-columns: 1fr; gap: 10px;
              }
               #config-modal .user-data-grid .checkbox-container { grid-column: span 1;}
               #config-modal .pin-buttons-container { grid-column: span 1; flex-direction: column; }
               #config-modal .pin-buttons-container button { max-width: none; }

              #config-modal .radar-filter-group { grid-template-columns: 1fr; gap: 10px; }
              #config-modal .radar-filter-group div:nth-child(3) { grid-column: span 1;} /* Keywords input */
              #config-modal .radar-action-buttons { flex-direction: column; gap: 10px;}

             #reminders-location-map-header { padding: 5px; gap: 5px;}
             #reminders-location-map-header .button-group-main, #reminders-location-map-header .button-group-route { flex-direction: column; gap: 3px; flex-basis: 100%; align-items: stretch;}
             #reminders-location-map-header button { padding: 5px 8px; font-size: 0.8rem; }
             #reminders-location-map-header .route-button-action, #reminders-location-map-header .reminders-map-button-action { flex-grow: 1;}
              #reminders-location-map-header > div:last-child { margin-left: 0; width: 100%; justify-content: space-between;}
              #reminders-location-map-header > div:last-child .button-group-main { flex-direction: row; flex-grow: 1;}
              #reminders-location-map-header label { font-size: 0.8rem; }

             #current-maneuver-panel {
                 top: 5px;
                 left: auto;
                 right: 5px;
                 max-width: calc(100% - 55px); /* Leave space for smaller compass if needed */
                 padding: 3px 6px;
                 gap: 5px;
             }
             #current-maneuver-panel .maneuver-icon { width: 25px; height: 25px;}
             #current-maneuver-panel .maneuver-text-container { font-size: 0.9em;}
             #current-maneuver-panel .maneuver-instruction { font-size: 1em;}
             #current-maneuver-panel .maneuver-distance, #current-maneuver-panel .next-maneuver { font-size: 0.8em;}


             .leaflet-control-orientation-altitude {
                  margin-top: 5px;
                  margin-left: 5px;
             }
              .leaflet-control-orientation-altitude #compass-rose-icon {
                  width: calc(70px * 1.5 * 0.9); height: calc(70px * 1.5 * 0.9);
                  margin-bottom: 3px;
              }
              .leaflet-control-orientation-altitude #orientation-altitude-text-container {
                   padding: calc(4px * 0.6) calc(6px * 0.6);
              }
               .leaflet-control-orientation-altitude #orientation-text,
              .leaflet-control-orientation-altitude #altitude-display {
                  font-size: calc(1.5em * 0.85 * 1.0);
              }
         }


         /* Styles for Light Mode */
         body.light-mode #reminders-location-map-header { background-color: #d1d5db; }
         body.light-mode #reminders-location-map-header .reminders-map-button-action { background-color: #e5e7eb; color: #18181b; }
          body.light-mode #reminders-location-map-header .route-button-action { background-color: #d97706; color: white;}
           body.light-mode #reminders-location-map-header #create-route-button { background-color: #16a34a; color: white;}


         body.light-mode #pin-modal { background-color: #f4f4f5; color: #18181b; }
         body.light-mode #pin-modal h2 { color: #d97706; }
         body.light-mode #pin-digit-input {
             border-color: #a0aec0;
             background-color: #e5e7eb;
             color: #18181b;
             caret-color: #d97706;
         }
         body.light-mode #pin-digit-input:focus { border-color: #d97706; box-shadow: 0 0 8px rgba(217, 119, 6, 0.5);}
         body.light-mode #pin-modal button { background-color: #2563eb; }
         body.light-mode #pin-modal .status-message { color: #dc2626;}

          body.light-mode .button-countdown { color: #555; }
          body.light-mode .button-countdown-timer { color: #555; }


        /* General modal button styling */
         .edit-modal button, .edit-info-modal button, .help-modal button,
         .versions-modal-overlay button, .saved-locations-modal button,
         #postpone-options-modal button, .reminder-table-modal button,
         #config-modal button, #saved-routes-modal button {
              transition: background-color 0.2s ease, opacity 0.2s ease;
         }

         .edit-modal button:hover, .edit-info-modal button:hover, .help-modal button:hover,
         .versions-modal-overlay button:hover, .saved-locations-modal button:hover,
         #postpone-options-modal button:not(#cancel-postpone):hover, .reminder-table-modal button:hover,
         #config-modal button:not(#config-clear-cache):hover, #saved-routes-modal button:not(.delete-route-btn):hover {
              opacity: 0.8; /* Simple hover effect */
         }
          #postpone-options-modal #cancel-postpone:hover,
          #config-modal #config-clear-cache:hover, #saved-routes-modal .delete-route-btn:hover {
               opacity: 0.8;
          }


         /* Styles for modal countdown timers */
         .button-countdown { font-weight: normal; }
         .button-countdown-timer { font-weight: normal; }


    </style>
</head>
<body class="dark-mode">
    <div class="modal-overlay" style="display:none;"></div>

    <div class="button-bar">
         <button id="on-off-button" class="on-off-button" title="Activar/Desactivar Recordatorios">ON/OFF</button>
         <button id="reminder-button" class="settings-button" title="Gestionar Recordatorios">RECORDATORIOS</button>
         <button id="map-button" class="settings-button" title="Mapa de Ubicaciones/Radares y Rutas">MAPA</button>
         <button id="settings-button" class="settings-button" title="Configuracin y Datos">CONFIG</button>
         <button id="edit-grid-button" class="edit-button" title="Editar Grid (Mover/Borrar)">EDITAR GRID</button>
    </div>
    <div id="filter-bar" class="flex justify-center items-center p-3" style="display: none;">
         <input type="text" id="grid-filter-input" placeholder="Filtrar botones..." class="px-2 py-1 rounded border text-sm" style="min-width: 200px; background-color: #4b5563; border-color: #6b7280; color: #d1d5db;">
         <button id="clear-filter-button" class="ml-2 px-3 py-1 text-sm rounded" style="background-color: #ef4444; color: white;">X</button>
     </div>

    <div id="grid-container" class="grid-container">
        <!-- Grid items will be rendered here -->
    </div>

    <div id="unified-reminder-window" class="unified-reminder-window">
         <div class="reminder-count-header">
             <h2>Recordatorios Activos</h2>
             <div class="reminder-count-text-container">
                 <span id="current-reminder-index">0</span> / <span id="total-reminder-count">0</span>
             </div>
             <button id="hide-all-reminders-button" class="hidden">Posponer Todos 1 min</button>
         </div>
         <div id="reminder-swiper-container">
             <!-- Reminder slides will be added here -->
         </div>
         <p id="reminder-swipe-hint" style="text-align:center; font-size:0.9rem; color:#a0aec0; padding: 0.5rem 0; display:none;">Desliza para ver ms recordatorios</p>
    </div>

    <span id="reminder-count-globe" style="display:none;"></span>
    <span id="versions-icon" class="versions-icon">Versiones</span>


    <script>
    // Global Variables
    let allLocationsMapInstance = null;
    let locationWatchId = null;
    let shouldCenterOnUserInAllLocationsMap = true;
    let initialUserLocationMarker = null;
    let initialUserLocationMarkerLat = null;
    let initialUserLocationMarkerLng = null;
    let initialUserLocationCircle = null;
    let orientationAltitudeControl = null;
    let radarMarkerIcon;
    let defaultLocationMarkerIconBlue;
    let carIcon;

    let customData = {
        bookmarks: {},
        toggles: {}
    };
    let isEditMode = false;
    let isAssignmentMode = false;
    let isKeywordAssignmentMode = false;
    let editingTargetElement = null;
    let dragTargetElement = null;
    let dragPlaceholderElement = null;
    let dragOffsetX, dragOffsetY;

    const MAX_SAVED_LOCATIONS = 10;
    const SAVED_LOCATIONS_KEY = 'boardinggate_saved_locations';
    const SHOW_EXCLUDED_REMINDERS_KEY = 'boardinggate_show_excluded_reminders';
    let tempSavedLocations = []; // Used for modal editing

    let reminderModalMap = null;
    let reminderModalMarker = null;
    let currentReminderLocation = null;
    let currentReminderBeingEdited = null;
    let mapShouldReopenAfterForm = false;

    let locationPickerMap = null;
    let locationPickerMarker = null;
    let currentEditingLocationSlotIndex = -1;

    let previewMaps = {}; // Store Leaflet map instances for unified window previews

    let reminderCheckIntervalId = null;
    let currentCheckIntervalDuration = 60000; // Start with 60 seconds
    let isUnifiedWindowVisibleByLogic = false;
    let currentNotificationSlideIndex = 0;
    let fromReminderModal = false; // Flag to indicate if opening table from reminder modal

    let storedPin = null;
    let isPasswordActive = false;
    let isRemindersLocationMapActive = false;


    // Map Related Icons
    radarMarkerIcon = new L.Icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-violet.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
    });
    defaultLocationMarkerIconBlue = new L.Icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
    });
     carIcon = L.icon({
        iconUrl: 'Coche.PNG', // Path to your car icon image
        iconSize: [30, 30], // Size of the icon
        iconAnchor: [15, 15] // Point of the icon which will correspond to marker's location (center of the icon)
    });


    // Helper to get URL parameter
    function getUrlParameter(name) {
        name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
        const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
        const results = regex.exec(location.search);
        return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
    }

    // Load custom grid data from localStorage
    function loadCustomData() {
        try {
            const data = localStorage.getItem('customGridData');
            if (data) {
                customData = JSON.parse(data);
            }
        } catch (e) {
            console.error("Error loading custom grid data:", e);
        }
    }

    // Save custom grid data to localStorage
    function saveCustomData() {
        try {
            localStorage.setItem('customGridData', JSON.stringify(customData));
        } catch (e) {
            console.error("Error saving custom grid data:", e);
        }
    }

     // Load settings from localStorage
     function loadSavedSettings() {
        try {
            const darkMode = localStorage.getItem('darkMode');
            if (darkMode !== null) {
                document.body.classList.toggle('light-mode', darkMode !== 'true');
            } else {
                document.body.classList.remove('light-mode'); // Default to dark mode
            }

            const onOffState = localStorage.getItem('onOffState');
            const onOffButton = document.getElementById('on-off-button');
            if (onOffButton) {
                 if (onOffState === 'false') {
                     onOffButton.classList.remove('active');
                     onOffButton.textContent = 'OFF';
                     // Disable reminders logic here if needed
                 } else {
                     onOffButton.classList.add('active');
                     onOffButton.textContent = 'ON';
                      // Enable reminders logic here if needed
                 }
            }

            const filterValue = localStorage.getItem('gridFilterValue');
            const filterInput = document.getElementById('grid-filter-input');
            if (filterInput && filterValue !== null) {
                 filterInput.value = filterValue;
                 filterGridItems();
                 document.getElementById('filter-bar').style.display = 'flex'; // Show filter bar if value exists
            } else if (document.getElementById('filter-bar')) {
                 document.getElementById('filter-bar').style.display = 'none';
            }


        } catch (e) {
            console.error("Error loading saved settings:", e);
        }
    }

     // Save settings to localStorage
     function saveSettings() {
         try {
             const darkMode = document.body.classList.contains('dark-mode');
             localStorage.setItem('darkMode', darkMode.toString());

             const onOffButton = document.getElementById('on-off-button');
             if (onOffButton) {
                 localStorage.setItem('onOffState', onOffButton.classList.contains('active').toString());
             }

              const filterInput = document.getElementById('grid-filter-input');
              if (filterInput && filterInput.value.trim()) {
                   localStorage.setItem('gridFilterValue', filterInput.value);
              } else {
                   localStorage.removeItem('gridFilterValue');
              }

         } catch (e) {
             console.error("Error saving settings:", e);
         }
     }


    // Initial grid data
    const initialGridData = {
        'start-reminder': { icon: 'Reloj.PNG', text: 'RECORDATORIO', action: 'showReminderModal', category: 'reminder', keywords: 'alarma fecha hora' },
        'list-reminders': { icon: 'Lista.PNG', text: 'VER LISTA', action: 'showAllReminders', category: 'reminder', keywords: 'lista tabla' },
        'saved-locations': { icon: 'Guardados.PNG', text: 'UBICACIONES', action: 'showSavedLocationsModal', category: 'location', keywords: 'guardar ubicacion mapa poi' },
        'map-radars': { icon: 'Mapa.PNG', text: 'MAPA RUTAS', action: 'showAllRemindersLocationMap', category: 'location', keywords: 'mapa gps ruta navegar radar' },
        'dark-mode': { icon: 'ModoOscuro.PNG', text: 'MODO OSCURO', action: 'toggleDarkMode', category: 'ui', keywords: 'apariencia luz noche dia' },
         'help': { icon: 'Ayuda.PNG', text: 'AYUDA', action: 'showHelpModal', category: 'ui', keywords: 'instrucciones manual' },
         'config': { icon: 'Config.PNG', text: 'CONFIG', action: 'showConfigModal', category: 'system', keywords: 'ajustes datos backup importar borrar' },
        // Add more initial items as needed
    };

    // Render the grid based on current customData or initialData
    function renderGrid() {
        const gridContainer = document.getElementById('grid-container');
        if (!gridContainer) return;

        // Use initial data keys if custom data is empty
        const itemsToRender = Object.keys(customData.bookmarks).length > 0 ? customData.bookmarks : initialGridData;

        gridContainer.innerHTML = ''; // Clear current grid

        // Ensure customData.bookmarks is populated from initial data if empty
        if (Object.keys(customData.bookmarks).length === 0) {
             customData.bookmarks = { ...initialGridData };
             saveCustomData(); // Save the initial state to customData
        }


        // Create grid items from customData.bookmarks
        for (const key in customData.bookmarks) {
             if (Object.hasOwnProperty.call(customData.bookmarks, key)) {
                 const itemData = customData.bookmarks[key];
                 const gridItem = document.createElement('div');
                 gridItem.className = 'grid-item';
                 gridItem.dataset.key = key;
                 gridItem.setAttribute('role', 'button');
                 gridItem.setAttribute('aria-label', itemData.text);


                 gridItem.innerHTML = `
                     <img src="${itemData.icon}" alt="${itemData.text}">
                     <span>${itemData.text}</span>
                 `;

                 // Add event listener for action
                 if (itemData.action && typeof window[itemData.action] === 'function') {
                     gridItem.addEventListener('click', () => {
                         if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) {
                              window[itemData.action]();
                         } else if (isAssignmentMode && editingTargetElement) {
                              assignActionToButton(editingTargetElement, key, itemData.action, itemData.icon, itemData.text);
                         } else if (isKeywordAssignmentMode && editingTargetElement) {
                             addKeywordToButton(editingTargetElement, itemData.keywords);
                         }
                     });
                      // Add event listener for editing mode
                     gridItem.addEventListener('mousedown', (e) => { handleItemMouseDown(e, gridItem); });
                     gridItem.addEventListener('touchstart', (e) => { handleItemTouchStart(e, gridItem); }, { passive: false });
                 } else {
                      // Handle items with no action (e.g., placeholders in editing mode)
                      gridItem.style.opacity = 0.7;
                 }


                 gridContainer.appendChild(gridItem);
             }
        }

         filterGridItems();
         checkToggleButtonsState();
         adjustButtonPositions(); // Adjust positions after rendering

         // Attach drag end listeners to the document to handle drops anywhere
        document.removeEventListener('mouseup', handleItemMouseUp);
        document.addEventListener('mouseup', handleItemMouseUp);
        document.removeEventListener('touchend', handleItemTouchEnd);
        document.addEventListener('touchend', handleItemTouchEnd, { passive: false });
        document.removeEventListener('mousemove', handleItemMouseMove);
        document.addEventListener('mousemove', handleItemMouseMove);
        document.removeEventListener('touchmove', handleItemTouchMove);
        document.addEventListener('touchmove', handleItemTouchMove, { passive: false });

    }

     function filterGridItems() {
         const filterInput = document.getElementById('grid-filter-input');
         const filterValue = filterInput ? filterInput.value.trim().toUpperCase() : '';
         const gridItems = document.querySelectorAll('.grid-item');

         if (!filterValue) {
             gridItems.forEach(item => {
                 item.classList.remove('hidden-filter');
                 item.style.display = ''; // Reset display style
             });
             document.getElementById('filter-bar').style.display = 'none'; // Hide filter bar
             return;
         }

         document.getElementById('filter-bar').style.display = 'flex'; // Show filter bar

         gridItems.forEach(item => {
             const key = item.dataset.key;
             const itemData = customData.bookmarks[key]; // Use customData for filtering

             if (!itemData) { // Should not happen if renderGrid is correct, but for safety
                 item.classList.add('hidden-filter');
                 item.style.display = 'none';
                 return;
             }

             const textMatch = itemData.text.toUpperCase().includes(filterValue);
             const keyMatch = key.toUpperCase().includes(filterValue);
             const keywordsMatch = itemData.keywords ? itemData.keywords.toUpperCase().includes(filterValue) : false;

             if (textMatch || keyMatch || keywordsMatch) {
                 item.classList.remove('hidden-filter');
                 item.style.display = '';
             } else {
                 item.classList.add('hidden-filter');
                 item.style.display = 'none';
             }
         });
     }


    // Drag and drop logic
    function handleItemMouseDown(e, item) {
        if (!isEditMode) return;
        if (e.button !== 0) return; // Only left click

        dragTargetElement = item;
        const rect = dragTargetElement.getBoundingClientRect();
        dragOffsetX = e.clientX - rect.left;
        dragOffsetY = e.clientY - rect.top;

        dragTargetElement.classList.add('dragging');
        dragTargetElement.style.position = 'fixed';
        dragTargetElement.style.zIndex = 1000;
        dragTargetElement.style.width = `${rect.width}px`;
        dragTargetElement.style.height = `${rect.height}px`;
        dragTargetElement.style.pointerEvents = 'none'; // Prevent clicks on the dragged element

        // Create placeholder
        dragPlaceholderElement = document.createElement('div');
        dragPlaceholderElement.className = 'grid-item placeholder';
        dragPlaceholderElement.style.opacity = 0.5;
        dragPlaceholderElement.style.border = '2px dashed #f59e0b';
        dragPlaceholderElement.style.backgroundColor = 'rgba(245, 158, 11, 0.2)';
        dragPlaceholderElement.style.boxSizing = 'border-box';
        dragPlaceholderElement.style.width = `${rect.width}px`;
        dragPlaceholderElement.style.height = `${rect.height}px`;

        dragTargetElement.parentNode.insertBefore(dragPlaceholderElement, dragTargetElement);

        // Add a helper div to track mouse movement outside the grid
        const dragHelper = document.createElement('div');
        dragHelper.className = 'drag-helper';
        document.body.appendChild(dragHelper);

        // Initial position update
        handleItemMouseMove(e);

        document.body.style.cursor = 'grabbing';
    }

    function handleItemMouseMove(e) {
         if (!dragTargetElement) return;

         // Prevent default scrolling behavior on touch devices
         if (e.type === 'touchmove') {
              e.preventDefault();
              e = e.touches[0]; // Use the first touch point
         }

        const x = e.clientX - dragOffsetX;
        const y = e.clientY - dragOffsetY;

        dragTargetElement.style.left = `${x}px`;
        dragTargetElement.style.top = `${y}px`;

         // Reorder items in the grid based on drag position
        const gridContainer = document.getElementById('grid-container');
        const children = Array.from(gridContainer.children).filter(child => child !== dragTargetElement && child !== dragPlaceholderElement);
        let targetIndex = children.length;

        // Find the closest child center to the dragged element's center
        const draggedCenterX = e.clientX;
        const draggedCenterY = e.clientY;

        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            const childRect = child.getBoundingClientRect();
            const childCenterX = childRect.left + childRect.width / 2;
            const childCenterY = childRect.top + childRect.height / 2;

             // Determine insertion point based on distance to centers
             // More complex logic needed for proper sorting in multi-column grid
             // Simple implementation: insert before the first item whose center is after the dragged item's center
             if (draggedCenterY < childCenterY || (draggedCenterY === childCenterY && draggedCenterX < childCenterX)) {
                 targetIndex = i;
                 break;
             }
        }

        // Insert placeholder at the target index
        if (targetIndex < children.length) {
            gridContainer.insertBefore(dragPlaceholderElement, children[targetIndex]);
        } else {
            gridContainer.appendChild(dragPlaceholderElement);
        }
    }


    function handleItemMouseUp(e) {
        if (!dragTargetElement) return;
        if (e.button !== 0) return;

        finalizeDrag(e);
    }

     function handleItemTouchStart(e, item) {
         if (!isEditMode) return;
         if (e.touches.length !== 1) return; // Only single touch

         e.preventDefault(); // Prevent default touch behavior (like scrolling)

         dragTargetElement = item;
         const rect = dragTargetElement.getBoundingClientRect();
         dragOffsetX = e.touches[0].clientX - rect.left;
         dragOffsetY = e.touches[0].clientY - rect.top;

         dragTargetElement.classList.add('dragging');
         dragTargetElement.style.position = 'fixed';
         dragTargetElement.style.zIndex = 1000;
         dragTargetElement.style.width = `${rect.width}px`;
         dragTargetElement.style.height = `${rect.height}px`;
         dragTargetElement.style.pointerEvents = 'none'; // Prevent further touch events on the dragged element

         // Create placeholder
         dragPlaceholderElement = document.createElement('div');
         dragPlaceholderElement.className = 'grid-item placeholder';
         dragPlaceholderElement.style.opacity = 0.5;
         dragPlaceholderElement.style.border = '2px dashed #f59e0b';
         dragPlaceholderElement.style.backgroundColor = 'rgba(245, 158, 11, 0.2)';
         dragPlaceholderElement.style.boxSizing = 'border-box';
         dragPlaceholderElement.style.width = `${rect.width}px`;
         dragPlaceholderElement.style.height = `${rect.height}px`;

         dragTargetElement.parentNode.insertBefore(dragPlaceholderElement, dragTargetElement);

          // Add a helper div for touch
         const dragHelper = document.createElement('div');
         dragHelper.className = 'drag-helper';
         document.body.appendChild(dragHelper);


         // Initial position update
         handleItemTouchMove(e);

         document.body.style.cursor = 'grabbing';
     }

    function handleItemTouchMove(e) {
        if (!dragTargetElement) return;
        if (e.touches.length !== 1) return;

        e.preventDefault(); // Prevent default touch behavior (like scrolling)

        const x = e.touches[0].clientX - dragOffsetX;
        const y = e.touches[0].clientY - dragOffsetY;

        dragTargetElement.style.left = `${x}px`;
        dragTargetElement.style.top = `${y}px`;

        // Reorder items in the grid based on drag position (using touch coordinates)
        const gridContainer = document.getElementById('grid-container');
        const children = Array.from(gridContainer.children).filter(child => child !== dragTargetElement && child !== dragPlaceholderElement);
        let targetIndex = children.length;

        // Find the closest child center to the dragged element's center
        const draggedCenterX = e.touches[0].clientX;
        const draggedCenterY = e.touches[0].clientY;


        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            const childRect = child.getBoundingClientRect();
            const childCenterX = childRect.left + childRect.width / 2;
            const childCenterY = childRect.top + childRect.height / 2;

             // Determine insertion point based on distance to centers
             if (draggedCenterY < childCenterY || (draggedCenterY === childCenterY && draggedCenterX < childCenterX)) {
                 targetIndex = i;
                 break;
             }
        }

        // Insert placeholder at the target index
        if (targetIndex < children.length) {
            gridContainer.insertBefore(dragPlaceholderElement, children[targetIndex]);
        } else {
            gridContainer.appendChild(dragPlaceholderElement);
        }
    }


     function handleItemTouchEnd(e) {
         if (!dragTargetElement) return;
         // Prevent synthetic mouse events after touch end if needed
         // e.preventDefault();

         finalizeDrag(e);
     }


    function finalizeDrag(e) {
        if (!dragTargetElement) return;

        const gridContainer = document.getElementById('grid-container');
        const children = Array.from(gridContainer.children).filter(child => child !== dragTargetElement); // Filter out the dragged element

        // Find the current position of the placeholder among the other grid items
        let placeholderIndex = -1;
        for(let i = 0; i < children.length; i++){
            if(children[i] === dragPlaceholderElement){
                placeholderIndex = i;
                break;
            }
        }

         // If placeholder found, insert the dragged element before it.
         // If not found (shouldn't happen with current logic, but fallback), append to end.
        if (placeholderIndex !== -1) {
             gridContainer.insertBefore(dragTargetElement, children[placeholderIndex]);
        } else {
             gridContainer.appendChild(dragTargetElement);
        }


        // Remove dragging styles and temporary elements
        dragTargetElement.classList.remove('dragging');
        dragTargetElement.style.position = '';
        dragTargetElement.style.zIndex = '';
        dragTargetElement.style.width = '';
        dragTargetElement.style.height = '';
        dragTargetElement.style.pointerEvents = '';

        if (dragPlaceholderElement && dragPlaceholderElement.parentNode) {
            dragPlaceholderElement.parentNode.removeChild(dragPlaceholderElement);
        }
         const dragHelper = document.querySelector('.drag-helper');
         if (dragHelper && dragHelper.parentNode) {
             dragHelper.parentNode.removeChild(dragHelper);
         }

        dragTargetElement = null;
        dragPlaceholderElement = null;
        document.body.style.cursor = 'default';

        // Save the new order
        saveGridOrder();
    }

     function saveGridOrder() {
         const gridContainer = document.getElementById('grid-container');
         const currentOrder = Array.from(gridContainer.children)
             .map(item => item.dataset.key)
             .filter(key => key); // Filter out potential non-grid-item children

         const newBookmarks = {};
          // Create a new bookmarks object based on the current DOM order
         currentOrder.forEach(key => {
             if (customData.bookmarks[key]) {
                 newBookmarks[key] = customData.bookmarks[key];
             } else if (initialGridData[key]) { // Fallback to initial data if somehow missed
                 newBookmarks[key] = initialGridData[key];
             }
         });

         // Add back any items that might have been in customData but not in the current DOM (e.g., were hidden by filter)
         // This shouldn't be necessary if we render ALL items and only hide with CSS, but is a safer approach
          for (const key in customData.bookmarks) {
              if (Object.hasOwnProperty.call(customData.bookmarks, key) && !newBookmarks[key]) {
                  newBookmarks[key] = customData.bookmarks[key];
              }
          }

         customData.bookmarks = newBookmarks;
         saveCustomData();
         console.log("Grid order saved.");
     }


    // Toggle edit mode for grid
    function toggleEditMode() {
        isEditMode = !isEditMode;
        const editButton = document.getElementById('edit-grid-button');
        const gridContainer = document.getElementById('grid-container');
        const filterBar = document.getElementById('filter-bar');

        if (isEditMode) {
            document.body.classList.add('edit-mode-active');
            if (editButton) editButton.textContent = 'SALIR EDITOR';
             if (filterBar) filterBar.style.display = 'flex'; // Always show filter in edit mode
             // Allow dragging handles for deletion
             addDeleteHandlesToItems();

        } else {
            document.body.classList.remove('edit-mode-active');
            if (editButton) editButton.textContent = 'EDITAR GRID';
             // Hide filter bar if filter input is empty
             const filterInput = document.getElementById('grid-filter-input');
             if (filterInput && filterInput.value.trim() === '' && filterBar) {
                 filterBar.style.display = 'none';
             }
             removeDeleteHandlesFromItems();
             // Ensure no drag/assign/keyword modes are left active
             stopAssignmentMode();
             stopKeywordAssignmentMode();
        }
    }

     function addDeleteHandlesToItems() {
         document.querySelectorAll('.grid-item').forEach(item => {
             if (!item.querySelector('.delete-handle')) {
                 const deleteHandle = document.createElement('div');
                 deleteHandle.className = 'delete-handle';
                 deleteHandle.innerHTML = 'X';
                 deleteHandle.style.cssText = `
                     position: absolute; top: -8px; right: -8px;
                     width: 24px; height: 24px; background-color: red;
                     color: white; border-radius: 50%; text-align: center;
                     line-height: 24px; font-weight: bold; cursor: pointer;
                     z-index: 10; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
                 `;
                 item.style.position = 'relative'; // Ensure position context for handle
                 item.appendChild(deleteHandle);

                 deleteHandle.addEventListener('click', (e) => {
                     e.stopPropagation(); // Prevent grid item click
                     const itemKey = item.dataset.key;
                     if (confirm(`Seguro que quieres borrar "${customData.bookmarks[itemKey]?.text || itemKey}"?`)) {
                         delete customData.bookmarks[itemKey];
                         saveCustomData();
                         item.remove();
                         showToast(`Botn "${itemKey}" borrado.`, 'info');
                         saveGridOrder(); // Resave order after deletion
                     }
                 });
             }
         });
     }

     function removeDeleteHandlesFromItems() {
         document.querySelectorAll('.grid-item .delete-handle').forEach(handle => {
             handle.remove();
         });
          document.querySelectorAll('.grid-item').forEach(item => {
              item.style.position = ''; // Remove relative position if added
          });
     }


     function startAssignmentMode(targetElement) {
        if (!isEditMode) return; // Only allow assignment if in edit mode
        stopAssignmentMode(); // Stop any existing assignment mode
        stopKeywordAssignmentMode(); // Stop keyword assignment too

        isAssignmentMode = true;
        editingTargetElement = targetElement;
        editingTargetElement.classList.add('editing-target');

        const assignButton = document.getElementById('assign-action-button'); // Assumes this button exists in edit mode UI
        if (assignButton) assignButton.textContent = 'CANCELAR ASIGNACIN';

        showToast('Pulsa el botn del grid que quieres asignar.', 'info', 5000);
     }

      function stopAssignmentMode() {
         isAssignmentMode = false;
         if (editingTargetElement) {
             editingTargetElement.classList.remove('editing-target');
             editingTargetElement = null;
         }
          const assignButton = document.getElementById('assign-action-button');
          if (assignButton) assignButton.textContent = 'ASIGNAR ACCIN'; // Reset button text
     }

      function assignActionToButton(targetElement, sourceKey, action, icon, text) {
          const targetKey = targetElement.dataset.key;
          if (!targetKey) {
              showToast("Error: No se encontr la clave del botn de destino.", "error");
              stopAssignmentMode();
              return;
          }

           if (customData.bookmarks[targetKey] && customData.bookmarks[targetKey].isStatic) {
               showToast("No puedes sobrescribir un botn esttico.", "warning");
               stopAssignmentMode();
               return;
           }


          // Update the target button's data
          customData.bookmarks[targetKey] = {
              action: action,
              icon: icon,
              text: text,
              category: customData.bookmarks[sourceKey]?.category || 'custom', // Keep category if exists or set to custom
              keywords: customData.bookmarks[sourceKey]?.keywords || '', // Copy keywords
              isStatic: false // Make sure custom assigned buttons are not static
          };
          saveCustomData();

          // Update the target button's appearance in the DOM
          targetElement.querySelector('img').src = icon;
          targetElement.querySelector('span').textContent = text;
          targetElement.setAttribute('aria-label', text);

           // Re-attach click listener to the target button (important if action changed)
          if (action && typeof window[action] === 'function') {
              // Remove old listener first
              const oldListener = targetElement._clickListener;
              if (oldListener) {
                  targetElement.removeEventListener('click', oldListener);
              }
               // Add new listener
              const newListener = () => {
                  if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) {
                      window[action]();
                  } else if (isAssignmentMode && editingTargetElement === targetElement) {
                       // Do nothing, this is the target button you clicked
                  } else if (isAssignmentMode && editingTargetElement) {
                       // Assigning *from* this button *to* the editingTargetElement
                       assignActionToButton(editingTargetElement, targetKey, action, icon, text);
                  } else if (isKeywordAssignmentMode && editingTargetElement) {
                       addKeywordToButton(editingTargetElement, customData.bookmarks[targetKey]?.keywords);
                  }
              };
              targetElement.addEventListener('click', newListener);
              targetElement._clickListener = newListener; // Store reference to remove later

          } else {
              // If action is removed or invalid, clear listener
              const oldListener = targetElement._clickListener;
              if (oldListener) {
                  targetElement.removeEventListener('click', oldListener);
                  targetElement._clickListener = null;
              }
          }
           // Re-attach drag listeners (they might be removed/added by renderGrid)
          targetElement.removeEventListener('mousedown', handleItemMouseDown);
          targetElement.removeEventListener('touchstart', handleItemTouchStart);
          targetElement.addEventListener('mousedown', (e) => { handleItemMouseDown(e, targetElement); });
          targetElement.addEventListener('touchstart', (e) => { handleItemTouchStart(e, targetElement); }, { passive: false });

          showToast(`Accin de "${sourceKey}" asignada a "${targetKey}".`, 'success');
          stopAssignmentMode(); // Exit assignment mode
      }

    function startKeywordAssignmentMode(targetElement) {
         if (!isEditMode) return;
         stopAssignmentMode();
         stopKeywordAssignmentMode(); // Ensure only one assignment mode is active

         isKeywordAssignmentMode = true;
         editingTargetElement = targetElement;
         editingTargetElement.classList.add('editing-target');

         // Show all items and apply initial highlights based on target's keywords
         const filterInput = document.getElementById('grid-filter-input');
         if (filterInput) filterInput.value = ''; // Clear filter to show all
         filterGridItems();
         applyInitialKeywordHighlights();

         const keywordButton = document.getElementById('assign-keyword-button'); // Assumes this button exists
         if (keywordButton) keywordButton.textContent = 'CANCELAR KEYWORD';


         showToast('Pulsa en los botones para aadir/quitar sus palabras clave.', 'info', 5000);
    }

     function stopKeywordAssignmentMode() {
         isKeywordAssignmentMode = false;
         if (editingTargetElement) {
             editingTargetElement.classList.remove('editing-target');
             editingTargetElement = null;
         }
         document.querySelectorAll('.grid-item.keyword-highlight').forEach(item => item.classList.remove('keyword-highlight'));

         const keywordButton = document.getElementById('assign-keyword-button');
         if (keywordButton) keywordButton.textContent = 'AADIR KEYWORD';

         // Restore filter based on saved value
         const filterInput = document.getElementById('grid-filter-input');
         const savedFilterValue = localStorage.getItem('gridFilterValue');
         if (filterInput && savedFilterValue !== null) {
              filterInput.value = savedFilterValue;
              filterGridItems();
         } else if (document.getElementById('filter-bar')) {
              document.getElementById('filter-bar').style.display = 'none';
         }
     }

     function applyInitialKeywordHighlights() {
         if (!isKeywordAssignmentMode || !editingTargetElement) return;

         const targetKey = editingTargetElement.dataset.key;
         const targetItem = customData.bookmarks[targetKey];
         if (!targetItem || !targetItem.keywords) return;

         const targetKeywords = targetItem.keywords.toUpperCase().split(/\s+/).filter(k => k);
         if (targetKeywords.length === 0) return;

         document.querySelectorAll('.grid-item').forEach(item => {
              const itemKey = item.dataset.key;
              const itemData = customData.bookmarks[itemKey];
              if (!itemData || !itemData.keywords) return;

              const itemKeywords = itemData.keywords.toUpperCase().split(/\s+/).filter(k => k);
              // Check if ANY keyword from the target exists in the item's keywords
              const isMatch = itemKeywords.some(keyword => targetKeywords.includes(keyword));

              if (isMatch) {
                  item.classList.add('keyword-highlight');
              } else {
                  item.classList.remove('keyword-highlight');
              }
         });
     }

    function addKeywordToButton(targetElement, sourceKeywordsString) {
         if (!isKeywordAssignmentMode || !editingTargetElement) return;

         const targetKey = editingTargetElement.dataset.key;
         const targetItem = customData.bookmarks[targetKey];
          if (!targetItem) return;

         const sourceKeywords = (sourceKeywordsString || '').toUpperCase().split(/\s+/).filter(k => k);
         if (sourceKeywords.length === 0) {
             showToast('El botn pulsado no tiene palabras clave definidas.', 'warning');
             return;
         }

         let targetKeywords = (targetItem.keywords || '').toUpperCase().split(/\s+/).filter(k => k);
         let keywordsAdded = [];
         let keywordsRemoved = [];

         sourceKeywords.forEach(kw => {
             if (targetKeywords.includes(kw)) {
                 // Keyword already exists, so clicking removes it
                 targetKeywords = targetKeywords.filter(existingKw => existingKw !== kw);
                 keywordsRemoved.push(kw);
             } else {
                 // Keyword doesn't exist, add it
                 targetKeywords.push(kw);
                 keywordsAdded.push(kw);
             }
         });

         // Update keywords for the target button
         targetItem.keywords = targetKeywords.join(' ').trim();
         customData.bookmarks[targetKey] = targetItem; // Ensure object is updated in place or reassigned
         saveCustomData();

         // Update the highlight for the item that was clicked (source)
         const clickedItemKey = document.querySelector('.grid-item.editing-target')?.dataset.key; // Get the key of the button being edited
          if (clickedItemKey !== targetKey) { // Only update highlight if we clicked a different button
               const clickedItemElement = document.querySelector(`.grid-item[data-key="${sourceKeywordsString ? Object.keys(customData.bookmarks).find(k => customData.bookmarks[k]?.keywords?.toUpperCase().includes(sourceKeywordsString.toUpperCase())) : ''}"]`);
               if (clickedItemElement) {
                   if (targetItem.keywords.toUpperCase().includes(sourceKeywordsString.toUpperCase())) {
                       clickedItemElement.classList.add('keyword-highlight');
                   } else {
                       clickedItemElement.classList.remove('keyword-highlight');
                   }
               }
          }


         let message = '';
         if (keywordsAdded.length > 0 && keywordsRemoved.length > 0) {
             message = `Aadido: ${keywordsAdded.join(', ')}. Quitado: ${keywordsRemoved.join(', ')}.`;
         } else if (keywordsAdded.length > 0) {
             message = `Aadido: ${keywordsAdded.join(', ')}.`;
         } else if (keywordsRemoved.length > 0) {
             message = `Quitado: ${keywordsRemoved.join(', ')}.`;
         } else {
              message = 'No se encontraron palabras clave para aadir/quitar.';
         }

          showToast(message, (keywordsAdded.length > 0 || keywordsRemoved.length > 0) ? 'success' : 'warning', 3000);
          applyInitialKeywordHighlights(); // Re-apply highlights based on the modified target keywords
    }


    // Create toggle buttons and settings button
    function createOtherButtons() {
        const buttonBar = document.querySelector('.button-bar');
        if (!buttonBar) return;

        const editButton = document.getElementById('edit-grid-button');
        if (editButton) {
             editButton.addEventListener('click', toggleEditMode);
        }

         // Add "Assign Action" button if needed (e.g., within an edit panel)
         // For simplicity here, assuming the edit mode UI handles assignment buttons
    }

    // Render the state of toggle buttons
    function renderToggleButtons() {
        // Not needed for this specific request's scope based on the provided HTML structure
        // (Assuming toggles are handled differently or not present in this snippet)
    }


    // Adjust button positions based on screen size and filter bar visibility
    function adjustButtonPositions() {
        const filterBar = document.getElementById('filter-bar');
        const gridContainer = document.getElementById('grid-container');
        if (!filterBar || !gridContainer) return;

        const filterBarHeight = filterBar.offsetHeight;
        // If filter bar is visible, add its height as top padding to the grid container
        if (filterBar.style.display !== 'none') {
             gridContainer.style.paddingTop = `${filterBarHeight + 16}px`; // 16px is original padding
        } else {
             gridContainer.style.paddingTop = '16px'; // Reset to original padding
        }

         // Adjust globe position
         const countElGlobe = document.getElementById('reminder-count-globe');
         if(countElGlobe) {
             const buttonBarHeight = document.querySelector('.button-bar')?.offsetHeight || 0;
             const filterBarVisible = filterBar.style.display !== 'none';
             const topOffset = buttonBarHeight + (filterBarVisible ? filterBarHeight : 0) + 10; // 10px margin
             countElGlobe.style.top = `${topOffset}px`;
         }
    }

     function toggleDarkMode() {
         document.body.classList.toggle('light-mode');
         const isDarkMode = !document.body.classList.contains('light-mode');
         document.body.classList.toggle('dark-mode', isDarkMode);
         saveSettings();
         // Update map tile layer if map is active
          if (allLocationsMapInstance) {
              // Remove old tile layer
              allLocationsMapInstance.eachLayer(layer => {
                  if (layer instanceof L.TileLayer) {
                      allLocationsMapInstance.removeLayer(layer);
                  }
              });
               // Add new tile layer (standard for both modes in this example)
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                 attribution: ' OpenStreetMap contributors'
             }).addTo(allLocationsMapInstance);
          }
     }

     // --- Version Check and Display ---
     const LATEST_VERSION_URL = 'https://raw.githubusercontent.com/yourusername/yourrepo/main/latest_version.json'; // Replace with your actual URL
     let currentVersion = '1.0.0'; // Define your app's current version here

     async function updateVersion() {
         const versionsIcon = document.getElementById('versions-icon');
         const lastCheckDate = localStorage.getItem('lastUpdatesCheckDate');
         const oneDay = 24 * 60 * 60 * 1000; // 1 day in milliseconds

         // Check for updates only if it's been more than a day or if user explicitly opens versions modal
         if (lastCheckDate && (Date.now() - new Date(lastCheckDate).getTime() < oneDay)) {
             checkVersionsIconOpacity(); // Just check if icon should be visible
             return; // Skip fetch if checked recently
         }

         if (versionsIcon) versionsIcon.style.opacity = 0.5; // Indicate checking
         localStorage.setItem('lastUpdatesCheckDate', new Date().toISOString());

         try {
             const response = await fetch(LATEST_VERSION_URL, { cache: 'no-cache' });
             if (!response.ok) throw new Error('Failed to fetch version info');
             const data = await response.json();

             if (data && data.versions && data.versions.length > 0) {
                 const latestRemoteVersion = data.versions[0].version;
                 const storedVersion = localStorage.getItem('appVersion') || currentVersion;

                 // Simple version comparison (e.g., 1.10 > 1.9)
                 const isNewVersionAvailable = latestRemoteVersion.localeCompare(storedVersion, undefined, { numeric: true, sensitivity: 'base' }) > 0;

                 if (isNewVersionAvailable) {
                     versionsIcon.classList.add('new-version-available');
                     showToast(`Nueva versin disponible (${latestRemoteVersion})! Recarga la pgina.`, 'info', 5000);
                 } else {
                     versionsIcon.classList.remove('new-version-available');
                 }
                 localStorage.setItem('appVersion', latestRemoteVersion); // Store the latest known version
             }
         } catch (error) {
             console.warn("Failed to fetch latest version:", error);
              // If fetch fails, use the locally stored version or current version
             localStorage.setItem('appVersion', localStorage.getItem('appVersion') || currentVersion);
             versionsIcon.classList.remove('new-version-available'); // Assume no new version if check failed
         } finally {
              checkVersionsIconOpacity(); // Ensure visibility is correct after check
         }
     }

     function showVersionsModal() {
         const versionsIcon = document.getElementById('versions-icon');
          if (versionsIcon) versionsIcon.style.opacity = 1; // Make sure icon is visible when modal opens

         const modalOverlay = document.querySelector('.modal-overlay');
         if(modalOverlay) modalOverlay.style.display = 'block';

         const versionsModal = document.createElement('div');
         versionsModal.className = 'versions-modal-overlay';
          versionsModal.setAttribute('aria-label', 'Registro de Versiones');


         versionsModal.innerHTML = `
             <h2>Historial de Versiones</h2>
             <div id="versions-list"></div>
             <div style="text-align:center;margin-top:1rem;">
                 <button id="close-versions-modal">Cerrar</button>
             </div>
         `;
         document.body.appendChild(versionsModal);

         const versionsList = versionsModal.querySelector('#versions-list');

         // Fetch the full version list again to display in the modal
         fetch(LATEST_VERSION_URL, { cache: 'no-cache' })
             .then(response => {
                 if (!response.ok) throw new Error('Failed to fetch version info');
                 return response.json();
             })
             .then(data => {
                 if (data && data.versions) {
                     data.versions.sort((a, b) => b.version.localeCompare(a.version, undefined, { numeric: true })); // Sort latest first
                     versionsList.innerHTML = data.versions.map(v => `
                         <div class="version-entry">
                             <div class="version-title">v${v.version}</div>
                             <div class="version-date">${v.date}</div>
                             <div class="version-notes">${v.notes || ''}</div>
                         </div>
                     `).join('');
                 } else {
                     versionsList.innerHTML = "<p>No se pudo cargar el historial de versiones.</p>";
                 }
             })
             .catch(error => {
                 console.error("Error loading versions for modal:", error);
                 versionsList.innerHTML = "<p>Error al cargar el historial de versiones.</p>";
             });


         versionsModal.querySelector('#close-versions-modal').addEventListener('click', () => {
             if(modalOverlay) modalOverlay.style.display = 'none';
             versionsModal.remove();
             checkVersionsIconOpacity(); // Restore icon opacity
         });
     }

     function checkVersionsIconOpacity() {
          const versionsIcon = document.getElementById('versions-icon');
          const currentFilterValue = localStorage.getItem('gridFilterValue');
          // Hide if there's an active filter in the grid
          if (versionsIcon) {
              if (currentFilterValue) {
                   versionsIcon.style.display = 'none';
              } else {
                   versionsIcon.style.display = 'block';
                   versionsIcon.style.opacity = versionsIcon.classList.contains('new-version-available') ? 1 : 0.8;
              }
          }
     }


     // Add event listener for versions icon
     const versionsIconElement = document.getElementById('versions-icon');
     if (versionsIconElement) {
         versionsIconElement.addEventListener('click', showVersionsModal);
     }


     // --- Reminder Modals and Logic ---

     function getCurrentLocation(successCallback, errorCallback) {
          if ('geolocation' in navigator) {
              navigator.geolocation.getCurrentPosition(
                  (position) => {
                       successCallback(position.coords);
                  },
                  (error) => {
                       let errorMessage = 'Error de Geolocalizacin: ';
                       switch(error.code) {
                           case error.PERMISSION_DENIED:
                               errorMessage += 'Permiso denegado.'; break;
                           case error.POSITION_UNAVAILABLE:
                               errorMessage += 'Posicin no disponible.'; break;
                           case error.TIMEOUT:
                               errorMessage += 'Tiempo de espera agotado.'; break;
                           case error.UNKNOWN_ERROR:
                           default:
                               errorMessage += 'Error desconocido.'; break;
                       }
                      errorCallback(errorMessage);
                  },
                  { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
              );
          } else {
              errorCallback('Geolocalizacin no soportada.');
          }
     }

     function initializeMapForReminderModal(mapContainerId, initialCoords = null) {
        if (reminderModalMap) {
            try { reminderModalMap.remove(); } catch (e) { console.warn("Error removing reminderModalMap:", e); }
            reminderModalMap = null;
            reminderModalMarker = null;
        }

        const mapDiv = document.createElement('div');
        mapDiv.style.width = '100%'; mapDiv.style.height = '100%';
        const container = document.getElementById(mapContainerId);
         // Clear existing map divs but keep buttons
        while (container.firstChild && container.firstChild.classList && !container.firstChild.classList.contains('map-button')) {
             container.removeChild(container.firstChild);
        }
        container.insertBefore(mapDiv, container.firstChild);


        const centerLat = initialCoords?.latitude || 40.416775; // Default to Madrid if no initial coords
        const centerLng = initialCoords?.longitude || -3.703790;
        const initialZoom = (initialCoords?.latitude && initialCoords?.longitude) ? 15 : 6;

        reminderModalMap = L.map(mapDiv, { zoomControl: true }).setView([centerLat, centerLng], initialZoom);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: ' OpenStreetMap contributors'
        }).addTo(reminderModalMap);

        if (initialCoords) {
            reminderModalMarker = L.marker([initialCoords.latitude, initialCoords.longitude]).addTo(reminderModalMap);
             currentReminderLocation = initialCoords; // Set global location variable
        }

        reminderModalMap.on('click', handleReminderMapClick);
        setTimeout(() => reminderModalMap.invalidateSize(), 100); // Fix map rendering issue
    }

    function handleReminderMapClick(e) {
        const latlng = e.latlng;
        if (reminderModalMarker) {
            reminderModalMarker.setLatLng(latlng);
        } else {
            reminderModalMarker = L.marker(latlng).addTo(reminderModalMap);
        }
        currentReminderLocation = { latitude: latlng.lat, longitude: latlng.lng };
    }

     function showReminderModal(parsed = null) {
    console.log("showReminderModal called with:", parsed);
    mapShouldReopenAfterForm = isRemindersLocationMapActive || sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true' || sessionStorage.getItem('boardinggate_map_should_reopen_after_form') === 'true';
    sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
    sessionStorage.removeItem('boardinggate_map_was_open_before_table');


    // Close any open map modals
    const mapModalElement = document.getElementById('reminders-location-map-modal');
    if (mapModalElement) {
         const mapCloseButton = mapModalElement.querySelector('#close-reminders-location-map');
         if (mapCloseButton) mapCloseButton.click();
         else mapModalElement.remove();
    }


    hideUnifiedReminderWindow();
    Object.values(previewMaps).forEach(map => map?.remove()); previewMaps = {};
    const otherModals = document.querySelectorAll('.choice-modal, .edit-modal, .edit-info-modal, .help-modal, .versions-modal-overlay, .saved-locations-modal, .reminder-table-modal, #postpone-options-modal, #reminders-map-help-modal-instance');
    otherModals.forEach(m => m.remove());


    const isNew = parsed === null || typeof parsed.id === 'undefined';
    currentReminderBeingEdited = parsed;
    currentReminderLocation = parsed?.isLocationEnabled ? parsed.locationCoordinates : null;

    const modalOverlay = document.querySelector('.modal-overlay');
    if(modalOverlay) modalOverlay.style.display = 'block';

    const modal = document.createElement('div');
    modal.className = 'reminder-modal';
    modal.setAttribute('aria-label', isNew ? 'Crear Recordatorio' : 'Modificar Recordatorio');

    modal.innerHTML = `
        <h2>${isNew ? 'Crear Recordatorio' : 'Modificar Recordatorio'}</h2>
        <form id="reminder-form">
            <div>
                <label for="reminder-text">Texto:</label>
                <input type="text" id="reminder-text" required value="${parsed?.text?.replace(/<[^>]*>/g, '') || ''}">
            </div>
            <div>
                 <label for="reminder-time">Hora (HH:MM, ej. 08:30):</label>
                 <input type="time" id="reminder-time" value="${parsed?.time || ''}">
            </div>
            <div>
                 <label for="reminder-date">Fecha (DD/MM/AAAA):</label>
                 <input type="text" id="reminder-date" placeholder="DD/MM/AAAA" value="${parsed?.date ? parsed.date.split('-').reverse().join('/') : ''}">
            </div>
            <div class="checkbox-group">
                 <label>Repetir Semanalmente:</label>
                 <input type="checkbox" name="repeat" value="0" id="repeat-dom" ${parsed?.type === 'weekly' && parsed.repeatDays?.includes(0) ? 'checked' : ''}><label for="repeat-dom">Dom</label>
                 <input type="checkbox" name="repeat" value="1" id="repeat-lun" ${parsed?.type === 'weekly' && parsed.repeatDays?.includes(1) ? 'checked' : ''}><label for="repeat-lun">Lun</label>
                 <input type="checkbox" name="repeat" value="2" id="repeat-mar" ${parsed?.type === 'weekly' && parsed.repeatDays?.includes(2) ? 'checked' : ''}><label for="repeat-mar">Mar</label>
                 <input type="checkbox" name="repeat" value="3" id="repeat-mie" ${parsed?.type === 'weekly' && parsed.repeatDays?.includes(3) ? 'checked' : ''}><label for="repeat-mie">Mi</label>
                 <input type="checkbox" name="repeat" value="4" id="repeat-jue" ${parsed?.type === 'weekly' && parsed.repeatDays?.includes(4) ? 'checked' : ''}><label for="repeat-jue">Jue</label>
                 <input type="checkbox" name="repeat" value="5" id="repeat-vie" ${parsed?.type === 'weekly' && parsed.repeatDays?.includes(5) ? 'checked' : ''}><label for="repeat-vie">Vie</label>
                 <input type="checkbox" name="repeat" value="6" id="repeat-sab" ${parsed?.type === 'weekly' && parsed.repeatDays?.includes(6) ? 'checked' : ''}><label for="repeat-sab">Sb</label>
            </div>
            <div>
                 <label for="interval-days">Repetir Cada (das, ej. 7):</label>
                 <input type="number" id="interval-days" min="1" value="${parsed?.type === 'interval' ? (parsed.intervalDays || '') : ''}">
            </div>
            <div class="checkbox-group">
                 <input type="checkbox" id="location-checkbox" ${parsed?.isLocationEnabled ? 'checked' : ''}>
                 <label for="location-checkbox">Asociar a Ubicacin:</label>
                 <input type="number" id="radius-input" min="1" value="${parsed?.radiusMeters || 1000}" ${!parsed?.isLocationEnabled ? 'disabled' : ''} style="width: 80px; display: inline-block; margin-left: 10px;"> metros
            </div>
             <div class="checkbox-group">
                  <input type="checkbox" id="exclude-from-list-checkbox" ${parsed?.excludeFromList ? 'checked' : ''}>
                  <label for="exclude-from-list-checkbox">No mostrar en lista general (ej. Radares)</label>
             </div>

            <div id="reminder-map-container" class="map-container">
                <!-- Map will be initialized here -->
                <button type="button" class="map-button ok-map-button">OK Ubicacin</button>
                <button type="button" class="map-button locate-me-button">Mi Ubicacin</button>
                 <button type="button" class="map-button saved-locations-button">Ubicaciones Guardadas</button>
            </div>

            <p id="parse-status" class="status-message"></p>

            <div class="button-group">
                <button type="submit" class="save-button">${isNew ? 'Crear' : 'Guardar'}</button>
                <button type="button" id="cancel-reminder" class="cancel-button">Cancelar</button>
                 ${!isNew ? `<button type="button" id="delete-reminder" class="cancel-button">Borrar</button>` : ''}
                <button type="button" id="clear-reminder" class="clear-button">Limpiar</button>
                 <button type="button" id="view-reminders" class="view-button">Ver Lista</button>
                 <button type="button" id="help-reminder" class="help-button">Ayuda</button>

            </div>
        </form>
    `;
    document.body.appendChild(modal);

    const textInput = modal.querySelector('#reminder-text');
    const timeInput = modal.querySelector('#reminder-time');
    const dateInput = modal.querySelector('#reminder-date');
    const repeatCheckboxes = modal.querySelectorAll('input[name="repeat"]');
    const intervalInput = modal.querySelector('#interval-days');
    const locationCheckbox = modal.querySelector('#location-checkbox');
    const radiusInput = modal.querySelector('#radius-input');
    const mapContainer = modal.querySelector('#reminder-map-container');
    const parseStatus = modal.querySelector('#parse-status');
    const deleteButton = modal.querySelector('#delete-reminder');
     const clearButton = modal.querySelector('#clear-reminder');
     const excludeFromListCheckbox = modal.querySelector('#exclude-from-list-checkbox');


    let manualTimeInput = !!parsed?.time;

     modal.cleanUpModalTimers = function(closeOverlay = false) {
        if (reminderModalMap) { try { reminderModalMap.remove(); } catch(e){console.warn("Error removing reminderModalMap:", e); } reminderModalMap = null; reminderModalMarker = null; }
        currentReminderLocation = null;
        currentReminderBeingEdited = null;
        if(modalOverlay && closeOverlay) modalOverlay.style.display = 'none';
         if(modal.autoCloseInterval) clearInterval(modal.autoCloseInterval);
         modal.autoCloseInterval = null;
         const countdownSpan = modal.querySelector('.button-countdown-timer');
         if(countdownSpan) countdownSpan.remove();
     };

     addModalAutoCloseTimer(modal, modal.querySelector('#cancel-reminder'), 'reminder-modal');


    if (!isNew && deleteButton) {
        deleteButton.addEventListener('click', () => {
            if (confirm('Ests seguro de borrar este recordatorio?')) {
                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                reminders = reminders.filter(r => r.id !== parsed.id);
                localStorage.setItem('reminders', JSON.stringify(reminders));
                showToast('Recordatorio borrado', 'success');
                modal.cleanUpModalTimers(true);
                if (modal.parentNode) document.body.removeChild(modal);
                 updateReminderCount();
                 updateButtonStyles();
                 checkReminders(); // Re-check reminders in case the deleted one was overdue

                const mapShouldReopen = mapShouldReopenAfterForm;
                if (mapShouldReopen) {
                     showAllRemindersLocationMap();
                }

            }
        });
    }

    const updateMapVisibility = () => {
        if (locationCheckbox.checked) {
            mapContainer.style.display = 'block';
             radiusInput.disabled = false;
            if (!reminderModalMap) {
                 initializeMapForReminderModal('reminder-map-container', currentReminderLocation);
            } else {
                setTimeout(() => reminderModalMap.invalidateSize(), 100);
            }
        } else {
            mapContainer.style.display = 'none';
            radiusInput.disabled = true;
            if (reminderModalMap) {
                try { reminderModalMap.remove(); } catch(e){console.warn("Error removing reminderModalMap:", e); }
                reminderModalMap = null;
                reminderModalMarker = null;
            }
            currentReminderLocation = null;
        }
    };

    locationCheckbox.addEventListener('change', updateMapVisibility);

    // Initialize map on load if location is enabled
    if (parsed?.isLocationEnabled) {
        updateMapVisibility();
    } else {
         mapContainer.style.display = 'none';
    }


     const locateMeButton = modal.querySelector('.locate-me-button');
     if(locateMeButton) {
         locateMeButton.addEventListener('click', () => {
             locateMeButton.disabled = true;
             locateMeButton.textContent = 'Buscando...';
              if (reminderModalMap) reminderModalMap.setView([40.416775, -3.703790], 6); // Reset view slightly while searching

             getCurrentLocation(
                 (coords) => {
                     currentReminderLocation = { latitude: coords.latitude, longitude: coords.longitude };
                     if (reminderModalMap) {
                         reminderModalMap.setView([coords.latitude, coords.longitude], 15);
                         if (reminderModalMarker) {
                             reminderModalMarker.setLatLng([coords.latitude, coords.longitude]);
                         } else {
                             reminderModalMarker = L.marker([coords.latitude, coords.longitude]).addTo(reminderModalMap);
                         }
                          showToast('Ubicacin fijada.', 'success');
                     } else {
                          initializeMapForReminderModal('reminder-map-container', currentReminderLocation);
                     }
                     locateMeButton.disabled = false;
                     locateMeButton.textContent = 'Mi Ubicacin';
                 },
                 (errorMsg) => {
                     showToast(`Error al obtener ubicacin: ${errorMsg}`, 'error');
                     locateMeButton.disabled = false;
                     locateMeButton.textContent = 'Mi Ubicacin';
                 }
             );
         });
     }

      const okMapButton = modal.querySelector('.ok-map-button');
      if (okMapButton) {
          okMapButton.addEventListener('click', () => {
              if (!reminderModalMarker) {
                  showToast("Fija una ubicacin en el mapa primero.", "warning");
                  return;
              }
              const pos = reminderModalMarker.getLatLng();
              currentReminderLocation = { latitude: pos.lat, longitude: pos.lng };
              showToast(`Ubicacin seleccionada: ${pos.lat.toFixed(4)}, ${pos.lng.toFixed(4)}`, 'info');
               // No need to hide map container, it stays visible if checkbox is checked
          });
      }

     const savedLocationsButton = modal.querySelector('.saved-locations-button');
     if (savedLocationsButton) {
         savedLocationsButton.addEventListener('click', () => {
              // Pass callbacks to handle closing the saved locations modal
             showSavedLocationsModal(
                 // Callback on close
                 () => {
                     // Re-initialize/show the reminder map if location is still checked
                      if (locationCheckbox.checked) {
                          updateMapVisibility(); // This will re-init the map
                      }
                 },
                 // Callback on selecting a location
                 (selectedLocation) => {
                      if (locationCheckbox.checked) {
                          currentReminderLocation = { latitude: selectedLocation.lat, longitude: selectedLocation.lng };
                           radiusInput.value = selectedLocation.radius || 1000;
                           // Initialize map with selected location
                           initializeMapForReminderModal('reminder-map-container', currentReminderLocation);
                           showToast(`Ubicacin "${selectedLocation.name}" cargada.`, 'success');
                      } else {
                           showToast("Activa 'Asociar a Ubicacin' primero.", "warning");
                      }
                 }
             );
         });
     }


    const form = modal.querySelector('#reminder-form');
    form.addEventListener('submit', (e) => {
        e.preventDefault(); modal.cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;

        const text = textInput.value.trim(); if (!text) { parseStatus.textContent = 'Texto obligatorio.'; parseStatus.classList.add('text-red-600'); return; }
        let time = timeInput.value.trim(); let dateStr = dateInput.value.trim(); const repeatDays = Array.from(modal.querySelectorAll('input[name="repeat"]:checked')).map(input => parseInt(input.value)); const intervalDays = parseInt(intervalInput.value) || null;
        const isLocationChecked = locationCheckbox.checked; const radius = parseInt(radiusInput.value) || 1000;
        const locationCoords = currentReminderLocation;
        const excludeFromListVal = excludeFromListCheckbox.checked;
        if (isLocationChecked && !locationCoords) { parseStatus.textContent = 'Ubicacin activada pero no fijada en el mapa.'; parseStatus.classList.add('text-red-600'); return; }
        let dateISO = null; let finalTime = time; let reminderType = 'simple';
        if (dateStr) { if (dateStr.match(/^\d{2}\/\d{2}\/\d{4}$/)) { const [d, m, y] = dateStr.split('/').map(Number); const tD = new Date(Date.UTC(y, m - 1, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() + 1 === m && y >= 2000 && y <= 2099) { dateISO = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } else { parseStatus.textContent = 'Fecha invlida'; parseStatus.classList.add('text-red-600'); return; } } else { parseStatus.textContent = 'Formato DD/MM/AAAA'; parseStatus.classList.add('text-red-600'); return; } }
        if (finalTime && !finalTime.match(/^\d{2}:\d{2}$/)) { parseStatus.textContent = 'Formato HH:MM'; parseStatus.classList.add('text-red-600'); return; } else if (finalTime) { const [h, m] = finalTime.split(':').map(Number); if (h > 23 || m > 59) { parseStatus.textContent = 'Hora invlida'; parseStatus.classList.add('text-red-600'); return; } }
        if (intervalDays !== null && intervalDays > 0) { reminderType = 'interval'; if (!dateISO) { const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } if (!finalTime) finalTime = '00:01'; }
        else if (repeatDays.length > 0) { reminderType = 'weekly'; if (!dateISO) { const tempCalc = { type: 'weekly', time: finalTime || '00:01', date: null, repeatDays: repeatDays, intervalDays: null }; const firstOcc = calculateNextOccurrence(tempCalc, new Date()); if (firstOcc) { dateISO = `${firstOcc.getUTCFullYear()}-${(firstOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOcc.getUTCDate().toString().padStart(2, '0')}`; finalTime = finalTime || `${firstOcc.getUTCHours().toString().padStart(2, '0')}:${firstOcc.getUTCMinutes().toString().padStart(2, '0')}`; } else { const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; if (!finalTime) finalTime = '00:01'; } } else { if (!finalTime) finalTime = '00:01'; } }
        else if (dateISO && finalTime) { reminderType = 'daily'; } else if (finalTime) { reminderType = 'daily'; const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (dateISO) { reminderType = 'daily'; finalTime = '00:01'; } else { reminderType = 'simple'; const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; finalTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`; }
        const now = new Date();
        const finalCreatedAt = isNew ? now.toISOString() : (parsed.createdAt || now.toISOString());
        let finalDateISO = dateISO;

        // Recalculate date for new cyclic reminders if initial date is in the past or not set
        if (isNew && (reminderType === 'weekly' || reminderType === 'interval')) {
            let needsRecalc = false;
            if (!dateInput.value.trim()) {
                 // If date is empty, always calculate the next occurrence from now
                 needsRecalc = true;
            } else {
                // If date is provided, check if it's in the past
                try {
                    const [d, m, y] = dateStr.split('/').map(Number);
                    // Create a Date object for the input date at midnight UTC for comparison
                    const inputDate = new Date(Date.UTC(y, m - 1, d));
                    // Create a Date object for today at midnight UTC
                    const todayForCompare = new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate());
                    if (inputDate < todayForCompare) {
                        needsRecalc = true;
                    }
                } catch (e) {
                    // If date parsing failed, treat as needing recalculation
                    needsRecalc = true;
                }
            }

            if (needsRecalc) {
                const tempCalcForNewCyclic = {
                    type: reminderType,
                    time: finalTime || '00:01', // Use determined time or default
                    date: null, // Pass null date to calculateNextOccurrence to start from now
                    repeatDays: reminderType === 'weekly' ? repeatDays : [],
                    intervalDays: reminderType === 'interval' ? intervalDays : null
                };
                const firstOccurrence = calculateNextOccurrence(tempCalcForNewCyclic, new Date()); // Calculate from *current* moment
                if (firstOccurrence) {
                    // Update the date ISO to the date of the first upcoming occurrence
                    finalDateISO = `${firstOccurrence.getUTCFullYear()}-${(firstOccurrence.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOccurrence.getUTCDate().toString().padStart(2, '0')}`;
                    // Note: We don't update finalTime here, as the user specified the time.
                    // The next occurrence calculation only guarantees the date is valid, the time should remain user-defined.
                    // If time was empty, it defaulted to '00:01' earlier, which is fine.
                } else {
                    // Fallback if calculation fails (shouldn't happen for weekly/interval with valid params)
                    if (!finalDateISO) {
                         finalDateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
                    }
                }
            }
        }


        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        const newReminder = {
            id: isNew ? Date.now() : parsed.id, // Keep old ID if modifying
            text: `<b>${text.toUpperCase()}</b>`,
            type: reminderType,
            time: finalTime || null,
            date: finalDateISO, // Use the determined or recalculated date
            repeatDays: reminderType === 'weekly' ? repeatDays : [],
            intervalDays: reminderType === 'interval' ? intervalDays : null,
            createdAt: finalCreatedAt, // Keep old createdAt date if modifying
            managedByUser: false, // Reset managed status when saved
            isLocationEnabled: isLocationChecked,
            locationCoordinates: isLocationChecked ? locationCoords : null,
            radiusMeters: isLocationChecked ? radius : (parsed?.radiusMeters || 1000), // Keep old radius if disabling location? No, use default or new if enabled. Updated logic: if location checked, use new radius, otherwise use old parsed radius or 1000
            excludeFromList: excludeFromListVal
        };

        // Basic validation for required fields
        if (!newReminder.date || !newReminder.time || !newReminder.createdAt){
            parseStatus.textContent = "Error GRAVE: Fechas/Hora invlidas al guardar.";
            parseStatus.classList.add('text-red-600');
            showToast("Error GRAVE: Fechas/Hora invlidas al guardar.", "error");
            // Don't reset timer on validation error, let user fix
            return;
        }

        if (!isNew) {
            // Find and replace the old reminder
            const index = reminders.findIndex(r => r.id === parsed.id);
            if (index !== -1) {
                reminders[index] = newReminder;
            } else {
                // Should not happen if editing, but add as new if somehow not found
                reminders.push(newReminder);
            }
        } else {
            // Add the new reminder
            reminders.push(newReminder);
        }

        localStorage.setItem('reminders', JSON.stringify(reminders));
        showToast('Recordatorio guardado', 'success');

        modal.cleanUpModalTimers(true); // Clean up timers and remove modal
        if (modal.parentNode) document.body.removeChild(modal); // Ensure modal is removed

        updateReminderCount();
        updateButtonStyles();
        checkReminders(); // Re-check reminders as list has changed

        // Logic to reopen map if it was open before the form
        const unifiedWindowIsVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible');

        if (mapShouldReopen && !unifiedWindowIsVisible) {
            showAllRemindersLocationMap();
        } else if (mapShouldReopen && unifiedWindowIsVisible) {
            // If unified window is open, defer reopening the map until it closes
            sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
        }
    });

    modal.querySelector('#cancel-reminder').addEventListener('click', () => {
        modal.cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        if (modal.parentNode) document.body.removeChild(modal);

        // Reopen map if it was open before, unless unified window is now open
        const unifiedWindowIsVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible');
        if (mapShouldReopen && !unifiedWindowIsVisible) {
            showAllRemindersLocationMap();
        } else if (mapShouldReopen && unifiedWindowIsVisible) {
             // Defer reopening if unified window is open
             sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
        }
    });
    modal.querySelector('#help-reminder').addEventListener('click', showHelpModal); // Assuming showHelpModal exists
    clearButton.addEventListener('click', () => {
        textInput.value=''; timeInput.value=''; dateInput.value='';
        modal.querySelectorAll('input[name="repeat"]').forEach(i=>i.checked=false);
        intervalInput.value='';
        locationCheckbox.checked = false;
        radiusInput.value = (parsed?.radiusMeters || 1000); // Reset radius to default or previous if exists
        currentReminderLocation = null;
        updateMapVisibility(); // Hide map and clear its state
        radiusInput.disabled = true;
        excludeFromListCheckbox.checked = false; // Uncheck exclude by default
        parseStatus.textContent='';
        // No speech status in this modal based on HTML provided

        // No timer reset needed for clear button as timer is attached to the modal itself
        textInput.focus();
    });
    modal.querySelector('#view-reminders').addEventListener('click', () => {
        modal.cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        if (modal.parentNode) document.body.removeChild(modal);
        fromReminderModal = true; // Set flag before opening table

        // Pass the mapShouldReopen state to the table modal context if needed
        if (mapShouldReopen) {
            sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
        }
        showAllReminders(); // Assuming showAllReminders exists
    });
    textInput.focus(); // Focus on text input when modal opens
}

    function markReminderAsManaged(reminderId, managedState = true) {
         if (typeof reminderId !== 'number') { console.warn("Invalid reminderId type:", reminderId); return; }
         try {
             let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
             const index = reminders.findIndex(r => r.id === reminderId);
             if (index !== -1) {
                 // Only update if the state is different to avoid unnecessary storage writes
                 if (reminders[index].managedByUser !== managedState) {
                     reminders[index].managedByUser = managedState;
                     localStorage.setItem('reminders', JSON.stringify(reminders));
                     // console.log(`Reminder ${reminderId} managedByUser set to ${managedState}`);
                 }
             } else {
                 console.warn(`Reminder with id ${reminderId} not found in storage.`);
             }
         } catch (e) {
             console.error("Error updating managedByUser flag:", e);
         }
     }

     function displayUnifiedReminderWindow(overdueReminders) {
         const windowElement = document.getElementById('unified-reminder-window');
         const swiperContainer = document.getElementById('reminder-swiper-container');
         const countHeader = windowElement.querySelector('.reminder-count-header');
         const countSpan = document.getElementById('total-reminder-count');
         const currentIndexSpan = document.getElementById('current-reminder-index');
         const countTextContainer = document.getElementById('reminder-count-text-container');
         const swipeHint = document.getElementById('reminder-swipe-hint');
         const hideAllButton = document.getElementById('hide-all-reminders-button');

          // Clean up previous maps before adding new ones
          Object.values(previewMaps).forEach(map => map?.remove());
          previewMaps = {};

         if (!windowElement || !swiperContainer || !countHeader || !countSpan || !currentIndexSpan || !countTextContainer || !swipeHint || !hideAllButton) {
             console.error("Missing required elements for unified reminder window.");
             return;
         }
         swiperContainer.innerHTML = ''; // Clear previous slides
         // Sort reminders by next occurrence time
         overdueReminders.sort((a, b) => {
             try {
                  // Calculate next occurrence from now for sorting
                 const nextA = calculateNextOccurrence(a, new Date());
                 const nextB = calculateNextOccurrence(b, new Date());

                 // If both have next occurrences, sort by that
                 if (nextA && nextB) return nextA.getTime() - nextB.getTime();
                 // If only one has a next occurrence, that one comes first
                 if (nextA) return -1;
                 if (nextB) return 1;

                 // If neither has a calculated next occurrence (e.g., simple past reminders), sort by original date/time
                 const dateA = new Date(`${a.date}T${a.time}:00Z`); // Assume Z for comparison consistency
                 const dateB = new Date(`${b.date}T${b.time}:00Z`);
                 return dateA - dateB;

             } catch (e) {
                  console.warn("Error sorting reminders:", e);
                 return 0; // Maintain original order in case of error
             }
         });

         // If the window was not visible, reset to the first slide
         if (!isUnifiedWindowVisibleByLogic) {
             currentNotificationSlideIndex = 0;
         }

         overdueReminders.forEach((reminder, index) => {
             const slide = document.createElement('div');
             slide.className = 'reminder-slide';
             slide.dataset.id = reminder.id;
             slide.setAttribute('role', 'group');
             slide.setAttribute('aria-label', `Recordatorio ${index + 1} de ${overdueReminders.length}: ${reminder.text.replace(/<[^>]*>/g, '')}`);

             let detailsHtml = '';
             if (reminder.time) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Hora: ${formatTimeWithPeriod(reminder.time)}</p>`;
             if (reminder.date) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Fecha: ${formatDateDetailed(reminder.date)}</p>`;
             if (reminder.type === 'weekly' && reminder.repeatDays?.length > 0) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Repite: ${reminder.repeatDays.map(d => ['Dom', 'Lun', 'Mar', 'Mi', 'Jue', 'Vie', 'Sb'][d]).join(', ')}</p>`;
             if (reminder.type === 'interval' && reminder.intervalDays) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Cada: ${reminder.intervalDays} das</p>`;
             if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                 detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Ubicacin: Activada (Radio ${reminder.radiusMeters || 1000}m)</p>`;
             }

             const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval';
             // Only show adjust time button if it's cyclic AND the time is NOT already 00:01
             const showAdjustButton = isCyclic && reminder.time !== '00:01';
             const adjustButtonHtml = showAdjustButton ? `<button class="adjust-time-0001">Ajustar Hora 00:01 y Visto</button>` : '';
             const cyclicCancelButtonHtml = isCyclic ? `<button class="cancel-cyclic">Anular Ciclo</button>` : '';

             const mapPreviewHtml = reminder.isLocationEnabled && reminder.locationCoordinates ? `
                 <div class="reminder-map-preview-container">
                     <div id="map-preview-${reminder.id}" class="reminder-map-preview"></div>
                 </div>
             ` : '';

             slide.innerHTML = `
                 <div class="reminder-slide-content">
                     <div class="reminder-content-scrollable">
                         <p class="reminder-text">${reminder.text}</p>
                         ${detailsHtml}
                     </div>
                     <div class="button-group">
                         <button class="cancel">${isCyclic ? 'Visto / Prximo' : 'Visto / Borrar'}</button>
                         <button class="postpone">Posponer</button>
                         <button class="modify">Modificar</button>
                         ${adjustButtonHtml}
                         ${cyclicCancelButtonHtml}
                     </div>
                 </div>
                 ${mapPreviewHtml}
             `;

             addSlideButtonListeners(slide, reminder); // Add event listeners to buttons within the slide
             swiperContainer.appendChild(slide);

             // Initialize map preview if location is enabled
             if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                  const mapPreviewElement = slide.querySelector(`#map-preview-${reminder.id}`);
                  if (mapPreviewElement) {
                     // Use a small delay to ensure the map container div is fully rendered and has dimensions
                     setTimeout(() => {
                         try {
                             // Double check element exists before initializing
                             if (!document.getElementById(mapPreviewElement.id)) return;

                             const map = L.map(mapPreviewElement, {
                                 dragging: false, touchZoom: false, scrollWheelZoom: false, doubleClickZoom: false,
                                 boxZoom: false, keyboard: false, tap: false, zoomControl: false // Disable interaction
                             }).setView([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude], 14); // Set a reasonable default zoom

                             L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                                 // attribution: ' OpenStreetMap contributors' // Keep attribution if space allows
                             }).addTo(map);

                             // Add marker and circle
                             L.marker([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude]).addTo(map);
                             L.circle([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude], {
                                 color: 'blue', weight: 1, fillColor: '#ADD8E6', fillOpacity: 0.05, radius: reminder.radiusMeters || 1000
                             }).addTo(map);

                             // Invalidate size is crucial for maps in hidden/flex containers
                             map.invalidateSize();
                             // Store map instance to remove later
                             previewMaps[reminder.id] = map;
                         } catch (mapError) {
                              console.error("Error initializing map preview:", mapError);
                              // Display an error message in the map container if it fails
                              if (mapPreviewElement) mapPreviewElement.innerHTML = `<p style="font-size:0.8rem; color: red; text-align: center; padding: 5px;">Error al cargar mapa</p>`;
                         }
                     }, 50); // Small delay
                  }
             }
         });

         const count = overdueReminders.length;
         countSpan.textContent = count; // Update total count

         if (count > 0) {
              // Ensure current index is valid for the new list
              if (currentNotificationSlideIndex >= count) {
                  currentNotificationSlideIndex = 0;
              }
              // Scroll to the current slide index (might be 0 if new session or window just opened)
              swiperContainer.scrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
              updateReminderIndexDisplay(); // Update the "X / Y" display

              countHeader.classList.remove('hidden'); // Show header
              if (count > 1) {
                 countTextContainer.style.display = 'inline'; // Show "X / Y" if more than one
                 swipeHint.style.display = 'block'; // Show swipe hint
                 // Adjust slide max height if hint is present
                 document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = 'calc(85vh - 60px)'); // Assuming 60px for header+hint
              } else {
                 countTextContainer.style.display = 'none'; // Hide "X / Y" if only one
                 swipeHint.style.display = 'none'; // Hide swipe hint
                 // Adjust slide max height if no hint
                 document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = '85vh');
              }
               hideAllButton.classList.remove('hidden'); // Show "Hide All" button if any reminders
               // Re-add event listener to "Hide All" button to prevent duplicates
               const newHideAllButton = hideAllButton.cloneNode(true);
               hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton);
               newHideAllButton.addEventListener('click', postponeAllVisibleReminders);
         } else {
             // No overdue reminders
             countHeader.classList.add('hidden'); // Hide header
             hideAllButton.classList.add('hidden'); // Hide "Hide All" button
             currentNotificationSlideIndex = 0; // Reset index
         }
         windowElement.classList.add('visible'); // Make the window visible
         isUnifiedWindowVisibleByLogic = true; // Update internal state

         // Add scroll listener to update index display
         swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay); // Remove previous listener
         swiperContainer.addEventListener('scroll', updateReminderIndexDisplay);
     }

     function hideUnifiedReminderWindow() {
         const windowElement = document.getElementById('unified-reminder-window');
         if (windowElement && windowElement.classList.contains('visible')) {
             windowElement.classList.remove('visible');
             isUnifiedWindowVisibleByLogic = false; // Update internal state
             const swiperContainer = document.getElementById('reminder-swiper-container');
              // Clean up map instances when window is hidden
              Object.values(previewMaps).forEach(map => map?.remove());
              previewMaps = {};
             if (swiperContainer) {
                 swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay); // Remove scroll listener
                  // Clear slides after animation completes
                  setTimeout(() => {
                      if (swiperContainer && !windowElement.classList.contains('visible')) { // Only clear if still hidden
                          swiperContainer.innerHTML = '';
                      }
                  }, 300); // Match CSS transition duration
             }
             // Re-add Hide All button listener if it exists to avoid duplicates
             const hideAllButton = document.getElementById('hide-all-reminders-button');
             if (hideAllButton) { const newHideAllButton = hideAllButton.cloneNode(true); hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton); }


            // Check if map should reopen after this window closes
            const mapShouldReopen = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
            sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); // Consume the flag

            // Reopen map ONLY if no other reminder-related modals are open
            if (mapShouldReopen &&
                !document.querySelector('.reminder-modal') &&
                !document.querySelector('.reminder-table-modal') &&
                !document.getElementById('reminders-location-map-modal') &&
                 !document.getElementById('postpone-options-modal') // Also check postpone modal
               ) {
                 showAllRemindersLocationMap(); // Assuming showAllRemindersLocationMap exists
            }
         }
     }

     function postponeAllVisibleReminders() {
         const swiperContainer = document.getElementById('reminder-swiper-container');
         if (!swiperContainer) return;
         // Select only the currently visible slides in the DOM. This might need refinement
         // based on actual swiper behavior vs overflow scroll. Assuming all are 'visible' in overflow scroll here.
         const visibleSlides = swiperContainer.querySelectorAll('.reminder-slide');
         if (visibleSlides.length === 0) {
             showToast("No hay recordatorios para posponer.", "warning");
             return;
         }

         let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
         let updated = false;
         const idsToUpdate = [];

         visibleSlides.forEach(slide => {
             const reminderId = parseInt(slide.dataset.id);
             if (isNaN(reminderId)) return;
             idsToUpdate.push(reminderId);

             const index = reminders.findIndex(r => r.id === reminderId);
             if (index !== -1) {
                 const { newDateISO, newTime } = calculatePostponedDateTime(1); // Postpone by 1 minute
                 reminders[index].date = newDateISO;
                 reminders[index].time = newTime;
                 reminders[index].managedByUser = false; // Mark as not managed so it can become overdue again
                 updated = true;
             }
         });

         if (updated) {
             localStorage.setItem('reminders', JSON.stringify(reminders));
             showToast(`${idsToUpdate.length} recordatorio(s) pospuesto(s) 1 minuto.`, 'info');
             // Remove the postponed reminders from the UI and hide the window
             idsToUpdate.forEach(id => updateUnifiedWindowUI(id));
             updateReminderCount(); // Update counts everywhere
             updateButtonStyles(); // Update button styles
              // Re-check reminders immediately to catch any others or update state
         }
         // If any reminders were postponed and the window is still open, close it
         if (idsToUpdate.length > 0 && document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
            hideUnifiedReminderWindow();
         }
     }


     function updateReminderIndexDisplay() {
         const swiperContainer = document.getElementById('reminder-swiper-container');
         const currentIndexSpan = document.getElementById('current-reminder-index');
         if (!swiperContainer || !currentIndexSpan) return;

         const totalSlides = swiperContainer.querySelectorAll('.reminder-slide').length;
         if (totalSlides === 0) {
             currentIndexSpan.textContent = '0';
             return;
         }

         const containerWidth = swiperContainer.offsetWidth;
         if (containerWidth <= 0) {
             // Cannot calculate index if container has no width
            return;
         }
         const currentScroll = swiperContainer.scrollLeft;
         // Calculate index based on scroll position and container width
         // Add a small tolerance (e.g., 10px) to handle fractional scrolling and ensure accurate rounding near snap points
         const currentIndex = Math.round((currentScroll + 10) / containerWidth);

         currentNotificationSlideIndex = currentIndex; // Store the calculated index

         // Display index (1-based)
         const displayIndex = Math.max(1, Math.min(currentIndex + 1, totalSlides));
         currentIndexSpan.textContent = displayIndex;

          // Invalidate size for the map on the currently displayed slide to fix rendering if needed
          const currentSlideElement = swiperContainer.querySelectorAll('.reminder-slide')[currentIndex];
          if (currentSlideElement) {
             const mapId = currentSlideElement.querySelector('.reminder-map-preview')?.id;
             if (mapId) {
                  const reminderId = parseInt(mapId.replace('map-preview-', ''));
                  if (previewMaps[reminderId]) {
                      // Use a timeout as map might not be ready instantly
                      setTimeout(() => { if(previewMaps[reminderId]) previewMaps[reminderId].invalidateSize(); }, 50);
                  }
             }
          }
     }

     function addSlideButtonListeners(slideElement, reminder) {
         const reminderId = reminder.id;
         const cancelButton = slideElement.querySelector('.cancel');
         const adjustTimeButton = slideElement.querySelector('.adjust-time-0001');
         const cancelCyclicButton = slideElement.querySelector('.cancel-cyclic');
         const modifyButton = slideElement.querySelector('.modify');
         const postponeButton = slideElement.querySelector('.postpone');

         // Helper to handle button clicks and then update the UI
         const handleInteraction = (actionFn) => {
             markReminderAsManaged(reminderId, true); // Mark as managed first
             actionFn(); // Perform the action (delete, postpone, update date/time etc.)
             // After action, update the UI for this specific reminder (removes the slide if deleted/handled)
             updateUnifiedWindowUI(processedReminderId);
         };

         let processedReminderId = reminderId; // Use this internally if needed

         if (cancelButton) {
             cancelButton.addEventListener('click', () => handleInteraction(() => {
                 let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                 const index = rems.findIndex(r => r.id === processedReminderId);
                 if (index === -1) {
                     showToast('Error: Recordatorio no encontrado para cancelar.', 'error');
                     return; // Reminder not found
                 }

                 const currentReminder = rems[index];
                 let needsSave = false;

                 if (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval')) {
                    // For non-cyclic location-based reminders, postpone by 15 mins
                    const { newDateISO, newTime } = calculatePostponedDateTime(15);
                    rems[index].date = newDateISO;
                    rems[index].time = newTime;
                    rems[index].managedByUser = false; // Allow it to trigger again
                    needsSave = true;
                    showToast('Recordatorio con ubicacin pospuesto 15 minutos', 'info');
                 } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                     // For cyclic reminders, calculate the next occurrence
                     let referenceDateForNext = new Date(); // Start calculation from now
                     try {
                          // If the current reminder's scheduled time is in the past but close, start calculation slightly after its time
                          // This prevents calculating the *same* occurrence again immediately
                         const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                         const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                         const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                         const nowUTC = new Date();
                         if (!isNaN(reminderDateTime.getTime()) && reminderDateTime <= nowUTC) {
                             referenceDateForNext = new Date(nowUTC.getTime() + 1000); // Start calculation 1 second from now
                         } else if (!isNaN(reminderDateTime.getTime())) {
                              referenceDateForNext = reminderDateTime; // If scheduled in future, start from there
                         }
                     } catch(e) { console.warn("Error parsing reminder date/time for next occurrence:", e); }


                     const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                     if (nextOcc) {
                         // Update date and time to the next occurrence
                         rems[index].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                         rems[index].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                         rems[index].managedByUser = false; // Allow it to trigger again
                         needsSave = true;
                         showToast('Recordatorio actualizado al prximo ciclo', 'info');
                     } else {
                         // If no next occurrence can be calculated, delete the reminder
                         rems.splice(index, 1); needsSave = true;
                         showToast('Error calculando siguiente ciclo. Recordatorio eliminado.', 'error');
                     }
                 } else {
                     // For non-cyclic, non-location reminders, delete it
                     rems.splice(index, 1); needsSave = true;
                     showToast('Recordatorio marcado como visto y eliminado', 'info');
                 }

                 if (needsSave) localStorage.setItem('reminders', JSON.stringify(rems));
             }));
         }

         if (adjustTimeButton) {
             adjustTimeButton.addEventListener('click', () => handleInteraction(() => {
                 let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                 const index = rems.findIndex(r => r.id === processedReminderId);
                 if (index === -1) {
                      showToast('Error: Recordatorio no encontrado para ajustar hora.', 'error');
                      return;
                 }

                 const currentReminder = rems[index];
                 let needsSave = false;

                 // This action is intended for cyclic reminders (weekly/interval) that are NOT 00:01
                 if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                      // Calculate the next occurrence starting from now, but forcing the time to 00:01
                      let referenceDateForNext = new Date();
                       try {
                           const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                           const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, 0, 1)); // Use 00:01 for reference
                            const nowUTC = new Date();
                           if (!isNaN(reminderDateTime.getTime()) && reminderDateTime <= nowUTC) {
                               referenceDateForNext = new Date(nowUTC.getTime() + 1000); // Start calculation 1 second from now
                           } else if (!isNaN(reminderDateTime.getTime())) {
                                referenceDateForNext = reminderDateTime;
                           }
                       } catch(e) { console.warn("Error parsing reminder date/time for next occurrence (00:01 adjust):", e); }


                     const reminderForCalc = { ...currentReminder, time: '00:01' }; // Use 00:01 for calculation logic
                     const nextOcc = calculateNextOccurrence(reminderForCalc, referenceDateForNext);

                     if (nextOcc) {
                         rems[index].date= `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                         rems[index].time = '00:01'; // Explicitly set time to 00:01
                         rems[index].managedByUser = false;
                         needsSave = true;
                         showToast('Recordatorio ajustado a 00:01 y actualizado', 'info');
                     } else {
                         // If calculation fails, delete the reminder
                         rems.splice(index, 1); needsSave = true;
                         showToast('Error calculando siguiente ciclo (ajuste 00:01). Eliminado.', 'error');
                     }
                 } else {
                     // This button shouldn't appear for non-cyclic, but handle defensively
                     rems.splice(index, 1); needsSave = true;
                     showToast('Recordatorio no cclico eliminado (ajuste 00:01)', 'info');
                 }

                 if (needsSave) localStorage.setItem('reminders', JSON.stringify(rems));
             }));
         }

         if (cancelCyclicButton) {
             cancelCyclicButton.addEventListener('click', () => handleInteraction(() => {
                 // Confirm with user before permanent deletion
                 if (confirm('Ests seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE? Esto borrar este recordatorio y no volver a aparecer.')) {
                     let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                     const initialLength = rems.length;
                     rems = rems.filter(r => r.id !== processedReminderId); // Filter out the reminder
                     if (rems.length < initialLength) {
                         localStorage.setItem('reminders', JSON.stringify(rems));
                         showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                     } else {
                         showToast('Error: No se encontr el ciclo para anular.', 'warning');
                          // If not found/deleted, unmark as managed
                         markReminderAsManaged(processedReminderId, false);
                     }
                 } else {
                     // If user cancels confirm, unmark as managed so it can be seen again
                     markReminderAsManaged(processedReminderId, false);
                      // Prevent updateUnifiedWindowUI from removing the slide
                     throw new Error("Anulacin cancelada por el usuario."); // Throw to stop the handleInteraction flow
                 }
             }));
         }

         if (modifyButton) {
             modifyButton.addEventListener('click', () => {
                 markReminderAsManaged(reminder.id, true); // Mark as managed before opening modify modal
                 let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                 const reminderToModify = remindersFromStorage.find(r => r.id === reminder.id);

                 // Check if map should reopen AFTER the reminder modal closes and the unified window is hidden
                 const mapShouldReopenWhenUnifiedCloses = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';

                 hideUnifiedReminderWindow(); // Close the unified window

                 if (reminderToModify) {
                     // Set a flag so showReminderModal knows to potentially reopen the map later
                     if (mapShouldReopenWhenUnifiedCloses) {
                          sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                     }
                     showReminderModal(reminderToModify); // Open the modify modal
                 }
                 else {
                     showToast("Error: no se pudo encontrar el recordatorio para modificar.", "error");
                      // If reminder not found, unmark as managed
                     markReminderAsManaged(reminder.id, false);
                     // Re-check reminders to update the list in case it was deleted elsewhere
                     checkReminders();
                      // Attempt to reopen map if the flag was set and no other map is open
                     if (mapShouldReopenWhenUnifiedCloses &&
                         sessionStorage.getItem('boardinggate_map_should_reopen_after_form') !== 'true' && // Don't re-open if the form is supposed to do it
                         !document.getElementById('reminders-location-map-modal') // Check if map is already open
                        ) {
                         showAllRemindersLocationMap();
                     }
                 }
                 // Always clear the flag, it's handled now
                 sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
             });
         }

         if (postponeButton) {
             postponeButton.addEventListener('click', () => {
                 markReminderAsManaged(processedReminderId, true); // Mark as managed before showing options
                 let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                 const reminderToPostpone = remindersFromStorage.find(r => r.id === processedReminderId);
                 if (reminderToPostpone) {
                     // Pass the source context ('unified')
                     showPostponeOptionsModal(reminderToPostpone, 'unified');
                 }
                 else {
                     showToast("Error: no se pudo encontrar el recordatorio para posponer.", "error");
                     markReminderAsManaged(processedReminderId, false); // Unmark if not found
                     // Re-check reminders to update the list
                     checkReminders();
                 }
             });
         }
     }


     // Function to update the Unified Window UI after an action on a reminder
     function updateUnifiedWindowUI(processedReminderId) {
         const windowElement = document.getElementById('unified-reminder-window');
         const swiperContainer = document.getElementById('reminder-swiper-container');
         // Find the slide element corresponding to the processed reminder ID
         const slideToRemove = swiperContainer ? swiperContainer.querySelector(`.reminder-slide[data-id="${processedReminderId}"]`) : null;

         // Remove the map preview instance if it exists
         if (previewMaps[processedReminderId]) {
             previewMaps[processedReminderId].remove();
             delete previewMaps[processedReminderId];
         }

         // Remove the slide element from the DOM
         if (slideToRemove && slideToRemove.parentNode === swiperContainer) {
             swiperContainer.removeChild(slideToRemove);
         }

         // Re-evaluate remaining slides
         const remainingSlides = swiperContainer ? swiperContainer.querySelectorAll('.reminder-slide') : [];
         const remainingCount = remainingSlides.length;

         if (remainingCount === 0) {
             // If no slides left, hide the entire window
             hideUnifiedReminderWindow();
         }
         else {
             // Update counts and index display for the remaining slides
             const countHeader = windowElement.querySelector('.reminder-count-header');
             const countSpan = document.getElementById('total-reminder-count');
             const currentIndexSpan = document.getElementById('current-reminder-index'); // Ensure this is present
             const countTextContainer = document.getElementById('reminder-count-text-container');
             const swipeHint = document.getElementById('reminder-swipe-hint');

             countSpan.textContent = remainingCount; // Update total count displayed
             updateReminderIndexDisplay(); // Recalculate and display current index


             // Adjust UI elements based on remaining count
             if (remainingCount > 1) {
                 countTextContainer.style.display = 'inline';
                 swipeHint.style.display = 'block';
                 countHeader.classList.remove('hidden');
             } else {
                 countTextContainer.style.display = 'none';
                 swipeHint.style.display = 'none';
                 countHeader.classList.remove('hidden'); // Keep header visible even for 1 item
             }

             // Adjust scroll position if the current slide index is now out of bounds
             const maxScrollIndex = remainingCount - 1;
             if (currentNotificationSlideIndex > maxScrollIndex) {
                  currentNotificationSlideIndex = maxScrollIndex; // Go to the last slide
                   // Scroll smoothly to the new index
                  if (swiperContainer) {
                       const targetScrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
                       swiperContainer.scrollTo({ left: targetScrollLeft, behavior: 'smooth' });
                       // Update display after scroll finishes (or after a small delay)
                       setTimeout(updateReminderIndexDisplay, 400);
                  }
             } else {
                  // If the current index is still valid, just update the display
                   updateReminderIndexDisplay();
             }
         }

         // Always update global counts and check for new overdue reminders
         updateReminderCount();
         updateButtonStyles();
         checkReminders();
     }

    function setupReminderTableListeners(modalTable) {
        modalTable.querySelectorAll('.visto-prox').forEach(button => {
            // Clone and replace to ensure fresh listeners
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent row click
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true); // Mark as managed

                let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderIndex = rems.findIndex(r => r.id === id);
                let needsSave = false;
                const row = newButton.closest('tr'); // Get the table row

                if (reminderIndex > -1 && row) {
                    const currentReminder = rems[reminderIndex];
                     if (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval')) {
                        // Location-based, non-cyclic: postpone 15 mins
                        const { newDateISO, newTime } = calculatePostponedDateTime(15);
                        rems[reminderIndex].date = newDateISO;
                        rems[reminderIndex].time = newTime;
                        rems[reminderIndex].managedByUser = false;
                        needsSave = true;
                        // Update date/time display in the table row
                        const dateCell = row.cells[3]; const timeCell = row.cells[2];
                        if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date);
                        if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                        showToast('Recordatorio con ubicacin pospuesto 15 min', 'info');
                    } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                         // Cyclic: calculate next occurrence
                         let referenceDateForNext = new Date();
                          try {
                              const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                              const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                              const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                              const nowUTC = new Date();
                              if (!isNaN(reminderDateTime.getTime()) && reminderDateTime <= nowUTC) {
                                   referenceDateForNext = new Date(nowUTC.getTime() + 1000);
                              } else if (!isNaN(reminderDateTime.getTime())) {
                                   referenceDateForNext = reminderDateTime;
                              }
                          } catch(er) { console.warn("Error parsing reminder date/time for next occurrence (table):", er); }


                        const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                        if (nextOcc) {
                            rems[reminderIndex].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                            rems[reminderIndex].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                            rems[reminderIndex].managedByUser = false;
                            needsSave = true;
                             // Update date/time display in the table row
                            const dateCell = row.cells[3]; const timeCell = row.cells[2];
                            if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date); // Need to recalculate formatted next date
                            if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                            showToast('Actualizado al prximo periodo', 'info');
                        } else {
                             // If no next occurrence, delete it
                            rems.splice(reminderIndex, 1); needsSave = true;
                            row.remove(); // Remove row from table
                            showToast('Error calculando siguiente ciclo. Eliminado.', 'error');
                        }
                    } else {
                        // Simple or daily non-location: delete it
                        rems.splice(reminderIndex, 1); needsSave = true;
                        row.remove(); // Remove row from table
                        showToast('Recordatorio borrado', 'info');
                    }
                    if (needsSave) localStorage.setItem('reminders', JSON.stringify(rems));

                    // Check if table is now empty
                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                        // Add empty message row
                         const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
                         tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios ${showExcluded ? ' (incluyendo excluidos)' : ''}.</td></tr>`;
                    }
                } else {
                    showToast('Error: Recordatorio no encontrado para actualizar/borrar.', 'error');
                     // If row was somehow found but reminder wasn't, just remove the row
                    if(row) row.remove();
                }
                // Update counts and check reminders globally
                updateReminderCount(); updateButtonStyles(); checkReminders();
            });
        });

        modalTable.querySelectorAll('.postpone').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent row click
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true); // Mark as managed

                const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderToPostpone = reminders.find(r => r.id === id);
                if (reminderToPostpone) {
                    // Clear table modal auto-close timer and remove the modal
                    if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                    modalTable.remove(); // Remove table modal before opening postpone modal
                    showPostponeOptionsModal(reminderToPostpone, 'table'); // Open postpone options modal
                } else {
                    showToast('Error: Recordatorio no encontrado para posponer.', 'error');
                    markReminderAsManaged(id, false); // Unmark if not found
                    checkReminders(); // Re-check reminders
                }
            });
        });

        modalTable.querySelectorAll('.cancel-cyclic-table').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent row click
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                if (confirm('Ests seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE? Esta accin no se puede deshacer.')) {
                    markReminderAsManaged(id, true); // Mark as managed (briefly)
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const initialLength = rems.length;
                    rems = rems.filter(r => r.id !== id); // Remove the reminder
                    if (rems.length < initialLength) {
                        localStorage.setItem('reminders', JSON.stringify(rems));
                        showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                    } else {
                        showToast('Error: No se encontr el ciclo para anular.', 'warning');
                         // If not found/deleted, unmark as managed
                        markReminderAsManaged(id, false);
                    }
                    const row = newButton.closest('tr'); // Get the row
                    if (row) row.remove(); // Remove row from table
                    // Check if table is now empty
                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                         const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
                        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios ${showExcluded ? ' (incluyendo excluidos)' : ''}.</td></tr>`;
                    }
                    // Update counts and check reminders globally
                    updateReminderCount(); updateButtonStyles(); checkReminders();
                }
            });
        });

        // Add click listener to table rows to open modify modal
        const tableBody = modalTable.querySelector('#reminder-table-body');
        if (tableBody) {
             // Clone and replace tbody to remove old listeners, then add new one
            const newTableBody = tableBody.cloneNode(false); // Clone tbody structure
            while(tableBody.firstChild) newTableBody.appendChild(tableBody.firstChild); // Move existing rows
            tableBody.parentNode.replaceChild(newTableBody, tableBody); // Replace old tbody with new

            newTableBody.addEventListener('click', (e) => {
                 // Ignore clicks on buttons within the first cell (actions)
                if (e.target.closest('td:first-child button')) {
                    return;
                }

                const row = e.target.closest('tr[data-id]');
                if (row?.dataset.id) {
                    const id = parseInt(row.dataset.id); if (isNaN(id)) return;
                    markReminderAsManaged(id, true); // Mark as managed before opening modify modal

                    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const reminderToModify = reminders.find(r => r.id === id);
                    if (reminderToModify) {
                         // Check if map was open before table was opened
                         const mapWasOpenBeforeTable = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';

                         // Clear table modal auto-close timer and remove the modal
                        if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                        modalTable.remove(); // Remove table modal before opening reminder modal

                         // Set flag so showReminderModal knows to potentially reopen the map later
                         if (mapWasOpenBeforeTable) {
                             sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                         }
                         // Clear the flag indicating table was opened from map
                         sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                        showReminderModal(reminderToModify); // Open the modify modal
                    } else {
                        showToast('Error: Recordatorio no encontrado para modificar.', 'error');
                         markReminderAsManaged(id, false); // Unmark if not found
                         checkReminders(); // Re-check reminders
                    }
                }
            });
        }
    }

     function showAllReminders() {
         // Check if map is active before closing it to open the table
         const mapWasOpenBeforeThisTable = isRemindersLocationMapActive || !!document.getElementById('reminders-location-map-modal');
         if (mapWasOpenBeforeThisTable) {
             // Set a flag to potentially reopen map after the table is closed
             sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
              // Close the map if it's open
              const mapModalElement = document.getElementById('reminders-location-map-modal');
              if (mapModalElement) {
                  const mapCloseButton = mapModalElement.querySelector('#close-reminders-location-map');
                  if (mapCloseButton) mapCloseButton.click();
                   else mapModalElement.remove();
              }
         } else {
             sessionStorage.removeItem('boardinggate_map_was_open_before_table');
         }

         hideUnifiedReminderWindow(); // Close the unified reminder window if open
         Object.values(previewMaps).forEach(map => map?.remove()); previewMaps = {}; // Clean up preview maps
         // Close any other non-reminder related modals
         const otherModals = document.querySelectorAll('.choice-modal, .edit-modal, .edit-info-modal, .help-modal, .reminder-modal, .versions-modal-overlay, .saved-locations-modal, #postpone-options-modal, #reminders-map-help-modal-instance');
         otherModals.forEach(m => m.remove());


         let allReminders = [];
         try {
             // Retrieve and parse reminders, creating copies to avoid modifying stored data directly during sorting/filtering
             allReminders = JSON.parse(localStorage.getItem('reminders') || '[]').map(r => ({ ...r }));
         } catch(e) {
             showToast("Error al cargar lista de recordatorios.", "error");
             return;
         }

         // Get user preference for showing excluded items (like radars)
         const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
         let remindersToDisplay = allReminders;
         if (!showExcluded) {
             // Filter out items marked as excluded from list
             remindersToDisplay = allReminders.filter(r => !r.excludeFromList);
         }


         // Sort reminders for display
         remindersToDisplay.sort((a, b) => {
             const nowForSort = new Date();
             // Calculate the *next* occurrence time for sorting cyclic reminders
             const nextA = calculateNextOccurrence(a, nowForSort);
             const nextB = calculateNextOccurrence(b, nowForSort);

             if (nextA && nextB) {
                 // If both have a next occurrence, sort by the time of that occurrence
                 const timeDiff = nextA.getTime() - nextB.getTime();
                 if (timeDiff !== 0) return timeDiff;
             } else if (nextA) {
                 // If only A has a future occurrence, A comes first
                 return -1;
             } else if (nextB) {
                 // If only B has a future occurrence, B comes first
                 return 1;
             }
              // If neither has a future occurrence (e.g., simple past reminders), sort by type, then creation date
             const typeOrder = { 'simple': 1, 'hourly': 2, 'daily': 3, 'weekly': 4, 'interval': 5 };
             const typeDiff = (typeOrder[a.type] ?? 99) - (typeOrder[b.type] ?? 99);
             if (typeDiff !== 0) return typeDiff;

             const createdAtA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
             const createdAtB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
             return createdAtA - createdAtB; // Sort by creation date ascending if types/next occurrences are the same
         });

         // Remove any existing reminder table modal
         const existingModal = document.querySelector('.reminder-table-modal');
         if (existingModal) {
             // Clear its auto-close timer if it exists
             const closeButton = existingModal.querySelector('#close-reminders'); // Assuming there's a close button with this ID
             if (closeButton) clearModalAutoCloseTimer(existingModal, closeButton, 'reminder-table-modal');
             else if (existingModal.autoCloseInterval) clearInterval(existingModal.autoCloseInterval);

             if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal);
         }

         const modalTable = document.createElement('div');
         modalTable.className = 'reminder-table-modal';
         modalTable.setAttribute('aria-label', 'Tabla recordatorios');

         modalTable.innerHTML = `
             <h2 style="text-align:center;margin-bottom:1rem;font-size:1.5rem;color:#333;">Recordatorios</h2>

           <div class="top-button-container">
                 <button type="button" id="close-reminders-top">SALIR <span class="button-countdown-timer"></span></button>
                 <button type="button" id="view-all-locations-map">VER UBICACIONES</button>
                 <div style="display: flex; align-items: center; margin-left: 20px;">
                    <input type="checkbox" id="show-excluded-reminders" ${showExcluded ? 'checked' : ''} style="transform: scale(1.2); margin-right: 5px;">
                    <label for="show-excluded-reminders" style="margin-left: 0.5rem; font-size: 1.1rem;">MOSTRAR RADARES u OTROS</label>
                 </div>
             </div>


             <table>
                 <thead>
                     <tr>
                         <th style="width:12%;">Acciones</th>
                         <th>Texto</th>
                         <th style="width:8%;">Hora</th>
                         <th style="width:10%;">Fecha Prox.</th>
                         <th style="width:15%;">Das Rep.</th>
                         <th style="width:8%;">Cada x das</th>
                         <th style="width:8%;">Geoloc.</th>
                         <th style="width:10%;">Creado</th>
                     </tr>
                 </thead>
                 <tbody id="reminder-table-body">
                     ${remindersToDisplay.length === 0 ? `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios ${showExcluded ? ' (incluyendo excluidos)' : ''}.</td></tr>` :
                     remindersToDisplay.map(r => {
                         const isCyclic = r.type === 'weekly' || r.type === 'interval';
                         // Alternate row background colors based on type and excludeFromList status
                         const rowBackgroundColor = isCyclic ? (r.excludeFromList ? '#C0D8C0' : '#D9E5DB') : (r.excludeFromList ? '#D8BFBF' : '#EAD9D9');
                         // Calculate the next occurrence date for display in the table
                         const nextOccurrenceDate = calculateNextOccurrence(r, new Date());
                         const formattedNextDate = nextOccurrenceDate ? formatDateToDDMMMYY(nextOccurrenceDate.toISOString().split('T')[0]) : formatDateToDDMMMYY(r.date);
                         const timeDisplay = r.time ? r.time : '-';
                         const geoIndicator = r.isLocationEnabled ? '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#008000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>' : '-';
                         // Format creation date
                         const formattedCreatedAt = r.createdAt ? formatDateToDDMMMYY(r.createdAt.split('T')[0]) : '-';


                         return `<tr data-id="${r.id}" style="background-color: ${rowBackgroundColor};">
                                     <td>
                                         <button class="visto-prox" data-id="${r.id}" title="${isCyclic ? 'Marcar Visto y Avanzar al Prximo Ciclo' : 'Marcar Visto y Borrar'}">Visto/Prox</button>
                                         <button class="postpone" data-id="${r.id}" title="Posponer">Posponer</button>
                                         ${isCyclic ? `<button class="cancel-cyclic-table" data-id="${r.id}" title="Anular Ciclo Permanente">Anular Ciclo</button>` : ''}
                                     </td>
                                     <td class="text-column" title="Modificar">${r.text}</td>
                                     <td class="time-column">${timeDisplay}</td>
                                     <td class="date-column">${formattedNextDate}</td>
                                     <td>${r.type === 'weekly' && r.repeatDays?.length > 0 ? r.repeatDays.map(d => ['Dom','Lun','Mar','Mi','Jue','Vie','Sb'][d]).join(', ') : '-'}</td>
                                     <td>${r.type === 'interval' ? r.intervalDays || '-' : '-'}</td>
                                     <td>${geoIndicator}</td>
                                     <td class="date-column">${formattedCreatedAt}</td>
                                 </tr>`;
                     }).join('')}
                 </tbody>
             </table>
             <div class="button-group flex justify-start" style="margin-top:1rem;"><button type="button" id="close-reminders">SALIR <span class="button-countdown-timer"></span></button></div>`;
         document.body.appendChild(modalTable);

         // Add event listener for the "Show Excluded" checkbox
         const showExcludedCheckbox = modalTable.querySelector('#show-excluded-reminders');
         if (showExcludedCheckbox) {
             showExcludedCheckbox.addEventListener('change', () => {
                 localStorage.setItem(SHOW_EXCLUDED_REMINDERS_KEY, JSON.stringify(showExcludedCheckbox.checked));
                 // Close the current modal and re-open it with the new filter setting
                 const closeButton = modalTable.querySelector('#close-reminders');
                 if (closeButton) clearModalAutoCloseTimer(modalTable, closeButton, 'reminder-table-modal');
                 else if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);

                 modalTable.remove();
                 showAllReminders(); // Re-open the table
             });
         }

         // Add event listener for "View Locations Map" button
         const viewLocationsMapButton = modalTable.querySelector('#view-all-locations-map');
         if (viewLocationsMapButton) {
             viewLocationsMapButton.addEventListener('click', () => {
                  // Close the table modal before opening the map
                 const closeButton = modalTable.querySelector('#close-reminders');
                 if (closeButton) clearModalAutoCloseTimer(modalTable, closeButton, 'reminder-table-modal');
                 else if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);

                 modalTable.remove();
                 showAllRemindersLocationMap(); // Open the map
             });
         }


         // Add auto-close timer to the modal
         const closeButton = modalTable.querySelector('#close-reminders');
         const closeButtonTop = modalTable.querySelector('#close-reminders-top');

         const closeClean = () => {
             clearModalAutoCloseTimer(modalTable, closeButton, 'reminder-table-modal');
             // If the modal is still in the DOM (e.g., not removed by another action), remove it
             if (modalTable.parentNode) modalTable.parentNode.removeChild(modalTable);

             // Check if map should reopen after the table is closed
             const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
             sessionStorage.removeItem('boardinggate_map_was_open_before_table'); // Consume the flag

             // Handle case where table was opened from Reminder Modal
             if (fromReminderModal) {
                 fromReminderModal = false; // Reset flag
                  // If map should reopen, set flag for reminder modal to handle it
                 if (mapShouldReopen) {
                     sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                 }
                 showReminderModal(); // Reopen reminder modal
             } else if (mapShouldReopen) {
                 // Reopen map if it was open before and we didn't come from Reminder Modal
                 showAllRemindersLocationMap(); // Assuming showAllRemindersLocationMap exists
             }
         };

          // Add event listeners to both close buttons
         closeButton.addEventListener('click', closeClean);
         closeButtonTop.addEventListener('click', closeClean);

         // Add auto-close timer (e.g., 60 seconds)
         addModalAutoCloseTimer(modalTable, closeButton, 'reminder-table-modal');


         // Setup listeners for buttons within the table rows (postpone, delete etc.)
         setupReminderTableListeners(modalTable);
     }


     function updateReminderCount() {
         let reminders = [];
         try {
             reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
         } catch (e) {
             console.error("Error parsing reminders for count update:", e);
             reminders = []; // Use empty array if parsing fails
         }

         // Get preference for table view (affects the side button count)
         const showExcludedInTable = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
         let remindersForCount = reminders;
         if (!showExcludedInTable) {
             // Filter out excluded items for the count on the side button
             remindersForCount = reminders.filter(r => !r.excludeFromList);
         }

         const totalCount = remindersForCount.length;

         // The globe count shows only non-cyclic (or potentially only overdue non-cyclic?)
         // Based on checkReminders logic, it counts *overdue* reminders. Let's stick to that.
         // The checkReminders function itself calculates and updates this count based on current overdue state.
         // This function should only update the *total* count displayed on the sidebar button.

         // const nonCyclicReminders = remindersForCount.filter(r => r.type !== 'weekly' && r.type !== 'interval');
         // const nonCyclicCount = nonCyclicReminders.length;

         // const countElGlobe = document.getElementById('reminder-count-globe');
         // if (countElGlobe) {
         //     // The globe is updated by checkReminders() with the *overdue* count
         //     // We don't update it here.
         // }

         const reminderButtonElem = document.getElementById('reminder-button');
         if (reminderButtonElem) {
             let countSpanSide = reminderButtonElem.querySelector('.reminder-count');
             if (totalCount > 0) {
                 if (!countSpanSide) {
                     // Create the span if it doesn't exist
                     countSpanSide = document.createElement('span');
                     countSpanSide.className = 'reminder-count';
                     reminderButtonElem.appendChild(countSpanSide);
                 }
                 // Update the text content with the total count displayed in the table (filtered by excluded preference)
                 countSpanSide.textContent = totalCount;
             } else {
                 // Remove the span if count is 0
                 if (countSpanSide) {
                     countSpanSide.remove();
                 }
             }
         }
     }

     function calculateNextOccurrence(reminder, referenceDate) {
          if (!reminder || !reminder.type || !reminder.time || !reminder.date) {
              // console.warn("Invalid reminder data for calculateNextOccurrence:", reminder);
              return null;
          }
          try {
               // Parse date and time in UTC assuming reminder.date/time are UTC components
              let [year, month, day] = reminder.date.split('-').map(Number);
              let [hour, minute] = reminder.time.split(':').map(Number);
              // Create the base date in UTC
              let baseDate = new Date(Date.UTC(year, month - 1, day, hour, minute));

              if (isNaN(baseDate.getTime())) {
                   console.warn("Invalid Date object created for reminder:", reminder);
                   return null;
              }

               // Use UTC time for the reference date as well for consistent comparison
              const refDateUTC = new Date(referenceDate.getTime());
              const refDateUTCMidnight = new Date(Date.UTC(refDateUTC.getUTCFullYear(), refDateUTC.getUTCMonth(), refDateUTC.getUTCDate()));


               // For sorting purposes in the table, we might need the next occurrence even if the baseDate is in the future.
               // However, for determining *overdue* reminders, we only care if the baseDate is <= now.
               // The `checkReminders` function uses `now` as the reference. This function is used by both.
               // Let's assume `referenceDate` is the point in time from which we need to find the *next* occurrence strictly *after* or *at* (depending on context) the reference.
               // The logic in `checkReminders` handles the "overdue" check (baseDate <= now).
               // This function should find the first occurrence *at or after* referenceDate if baseDate is in the past,
               // or simply return baseDate if baseDate is in the future compared to referenceDate.

              if (baseDate > refDateUTC) {
                   // If the original scheduled time is in the future relative to the reference, that's the next occurrence
                   return baseDate;
              }

              // If baseDate is in the past relative to referenceDate, calculate the next one based on the type
              if (reminder.type === 'simple') {
                   // Simple reminders don't repeat, so if the base date is past the reference, there is no "next" occurrence.
                   return null;
              }

              if (reminder.type === 'daily' || reminder.type === 'hourly') { // Hourly isn't strictly implemented but follows daily pattern for next date
                  let next = new Date(baseDate);
                   // Advance day by day until it's after the reference date/time
                  while (next <= refDateUTC) {
                       next.setUTCDate(next.getUTCDate() + 1);
                  }
                  return next;
              }

              if (reminder.type === 'weekly' && reminder.repeatDays && reminder.repeatDays.length > 0) {
                   // Find the next occurrence on a repeating day at the specified time, starting from referenceDate
                  let next = new Date(refDateUTC); // Start checking from the reference date/time
                   // Normalize time to the reminder's time for comparison/calculation
                  next.setUTCHours(hour, minute, 0, 0);


                   // If the time on the reference date is already past the reminder time, start checking from the next day
                  if (next <= refDateUTC && reminder.time !== '00:00') { // Add a small buffer or check strictly after
                       next.setUTCDate(next.getUTCDate() + 1);
                  } else if (reminder.time === '00:00' && next < refDateUTC) {
                       // If time is midnight and reference date is after midnight of next, start next day
                       next.setUTCDate(next.getUTCDate() + 1);
                  }


                  // Iterate through the next 7 days to find the first matching repeat day
                  for (let i = 0; i < 7; i++) {
                      if (reminder.repeatDays.includes(next.getUTCDay())) {
                          return next; // Found the next occurrence date and time
                      }
                       // Move to the next day
                      next.setUTCDate(next.getUTCDate() + 1);
                  }
                  // If no matching day found in the next 7 days (shouldn't happen if repeatDays is not empty)
                  return null;
              }

              if (reminder.type === 'interval' && reminder.intervalDays && reminder.intervalDays > 0) {
                   // Calculate the next occurrence by adding intervals to the base date
                  let next = new Date(baseDate);
                   // Advance by interval days until it's after the reference date/time
                  while (next <= refDateUTC) {
                      next.setUTCDate(next.getUTCDate() + reminder.intervalDays);
                  }
                  return next;
              }

              // Should not reach here if reminder.type is valid
              return null;
          } catch (e) {
              console.error("Error calculating next occurrence:", e, "Reminder:", reminder);
              return null;
          }
     }
     function calculatePostponedDateTime(mins) {
          const now = new Date();
          const postponedDate = new Date(now.getTime() + mins * 60000);
           // Format to YYYY-MM-DD and HH:MM
          const newDateISO = `${postponedDate.getFullYear()}-${(postponedDate.getMonth() + 1).toString().padStart(2, '0')}-${postponedDate.getDate().toString().padStart(2, '0')}`;
          const newTime = `${postponedDate.getHours().toString().padStart(2, '0')}:${postponedDate.getMinutes().toString().padStart(2, '0')}`;
          return { newDateISO, newTime };
     }

     function showPostponeOptionsModal(reminder, source = 'unified') {
         // Close any existing postpone modal
         const existingModal = document.getElementById('postpone-options-modal');
         if (existingModal) {
             // Clear its auto-postpone timer
             if (existingModal.autoPostponeInterval) clearInterval(existingModal.autoPostponeInterval);
             if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal);
         }

         const modal = document.createElement('div');
         modal.id = 'postpone-options-modal';
         modal.className = 'postpone-options';
         // Apply basic styling for positioning/appearance
         modal.style.cssText = `position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); width:90%; max-width:480px; max-height:85vh; overflow-y:auto; background-color:#F5E1A9; padding:1.5rem; border-radius:1rem; box-shadow:0 10px 25px rgba(0,0,0,0.2); z-index:7500; `;
         modal.setAttribute('aria-label', 'Posponer recordatorio');

         let countdown = 10; // Auto-postpone countdown in seconds
         const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval';
         const defaultMinutes = 15; // Default postpone time

         // Create buttons. Different options for cyclic vs non-cyclic.
         let buttonHtml = `
             <button data-minutes="15" class="postpone-option">15 Minutos</button>
             <button data-minutes="60" class="postpone-option">1 Hora</button>
             <button data-minutes="180" class="postpone-option">3 Horas</button>
         `;
         // Add longer options only for non-cyclic reminders
         if (!isCyclic) {
             buttonHtml += `
                 <button data-minutes="1440" class="postpone-option">1 Da</button>
                 <button data-minutes="4320" class="postpone-option">3 Das</button>
             `;
         }

         // Build the modal content
         modal.innerHTML = `
             <style>
                 /* Inline styles or link to a stylesheet */
                 .postpone-options .reminder-text { color:#333; font-size:1.2rem; margin-bottom:.5rem; word-wrap:break-word; }
                 .postpone-options .reminder-details { color:#555; font-size:1rem; margin-bottom:1.5rem; }
                 .postpone-options .button-group { display:flex; flex-direction:column; gap:1rem; align-items:stretch; }
                 .postpone-options button.postpone-option { font-size:1.3rem; font-weight:bold; padding:.8rem 1rem; background-color:#F59E0B; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                 .postpone-options button.postpone-option:hover { background-color:#D97706; }
                 #postpone-countdown { text-align:center; margin-top:1.8rem; font-size:1.1rem; font-weight:500; color:#444; }
                 #postpone-timer-value { font-weight:bold; font-size:1.2rem; }
                 #cancel-postpone { margin-top:1.2rem; width:100%; padding:.7rem 1rem; font-size:1.1rem; background-color:#EF4444; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                 #cancel-postpone:hover { background-color:#DC2626; }
             </style>
             <p class="reminder-text">Posponer: ${reminder.text.replace(/<[^>]*>/g, '')}</p>
             <p class="reminder-details">Selecciona tiempo:</p>
             <div class="button-group">
                 ${buttonHtml}
             </div>
             <p id="postpone-countdown">Automtico en <span id="postpone-timer-value">${countdown}</span>s (${defaultMinutes} min)</p>
             <button id="cancel-postpone">Cancelar</button>
         `;
         document.body.appendChild(modal);

         const countdownDisplay = modal.querySelector('#postpone-timer-value');

         // Function to handle the actual postponement logic
         const handlePostpone = (minutes) => {
             // Clear the auto-postpone timer
             if (modal.autoPostponeInterval) clearInterval(modal.autoPostponeInterval);
             modal.autoPostponeInterval = null;

             // If the source was the unified window, remove that reminder's slide
             if (source === 'unified') {
                  updateUnifiedWindowUI(reminder.id); // Removes the slide and updates counts/display
             }


             let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
             const index = reminders.findIndex(r => r.id === reminder.id);

             if (index === -1) {
                 showToast("Error: Recordatorio no encontrado para posponer.", "error");
                 checkReminders(); // Re-check reminders if one seems missing
                 if (modal.parentNode) document.body.removeChild(modal); // Close modal
                 return;
             }

             // Calculate the new date and time after postponement
             const { newDateISO, newTime } = calculatePostponedDateTime(minutes);
             reminders[index].date = newDateISO;
             reminders[index].time = newTime;
             reminders[index].managedByUser = false; // Reset managed state so it can trigger again

             // If it was a cyclic reminder and we postponed it, it now effectively acts like a simple/daily reminder for this next occurrence.
             // However, keeping the original type might be better for calculating the *next* cycle after this postponed one expires.
             // Let's not change the type here. The logic in `checkReminders` and `calculateNextOccurrence` should handle a past date correctly for cyclic reminders.
             // NO, if you postpone a cyclic reminder, it should become a simple reminder for *that specific* postponement instance, until that instance is cleared.
             // The original cyclic definition (repeatDays/intervalDays) should probably be preserved but ignored until the postponed date is past.
             // A simpler approach: When a cyclic is postponed, turn it into a simple reminder with the new date/time. The user can then modify it back to cyclic if needed via the modify button.
             // Reverting this: The current calculateNextOccurrence handles past dates for cyclic reminders by finding the *next* future date. If we postpone a cyclic reminder, its `date` and `time` properties are updated to the postponed time. `calculateNextOccurrence` should then use *these* new properties as the base date for finding the *subsequent* occurrence. This seems more correct - the user is just delaying the *current* notification, not breaking the cycle structure.
             // Okay, let's stick to just updating date/time and managedByUser flag.


             localStorage.setItem('reminders', JSON.stringify(reminders)); // Save changes
             updateReminderCount(); // Update counts everywhere
             updateButtonStyles(); // Update button styles
             checkReminders(); // Re-check reminders immediately

             // Show confirmation toast
             const durationText = minutes >= 1440 ? `${minutes / 1440} da(s)` : (minutes >= 60 ? `${minutes / 60} hora(s)` : `${minutes} minutos`);
             showToast(`Pospuesto ${durationText}`, 'info');

             if (modal.parentNode) document.body.removeChild(modal); // Close modal

             // If the source was the table, reopen the table after postponing
             if (source === 'table') {
                 setTimeout(showAllReminders, 100); // Small delay to allow modal to close
             } else if (source === 'unified') {
                  // If source was unified window, check if map should reopen after unified window closes
                  const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                 sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); // Consume flag

                  // Reopen map ONLY if no other reminder-related modals are open
                  if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !document.getElementById('reminders-location-map-modal')) {
                      showAllRemindersLocationMap();
                  }
             }
         };

         // Start the auto-postpone timer
         modal.autoPostponeInterval = setInterval(() => {
             countdown--;
             // Update countdown display if the element exists and is in the document
             if (countdownDisplay && document.body.contains(countdownDisplay)) countdownDisplay.textContent = countdown;

             if (countdown <= 0) {
                 // Auto-postpone with the default time
                 handlePostpone(defaultMinutes);
             }
         }, 1000);

         // Add event listeners to the postpone option buttons
         modal.querySelectorAll('.postpone-option').forEach(button => {
             button.addEventListener('click', () => {
                 const minutes = parseInt(button.dataset.minutes); // Get minutes from data attribute
                 if (!isNaN(minutes)) {
                     handlePostpone(minutes); // Postpone with the selected time
                 }
             });
         });

         // Add event listener to the cancel button
         modal.querySelector('#cancel-postpone').addEventListener('click', () => {
             // Clear the auto-postpone timer
             clearInterval(modal.autoPostponeInterval);
             modal.autoPostponeInterval = null;
             // Unmark the reminder as managed so it can become overdue again
             markReminderAsManaged(reminder.id, false);
             if (modal.parentNode) document.body.removeChild(modal); // Close modal

             // Handle reopening based on source
             if (source === 'table') {
                 setTimeout(showAllReminders, 100); // Reopen table
             } else if (source === 'unified') {
                  // Check if map should reopen after unified window closes
                 const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                 sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); // Consume flag

                  // Reopen map ONLY if no other reminder-related modals are open
                 if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !document.getElementById('reminders-location-map-modal')) {
                      showAllRemindersLocationMap();
                 }
             }
             showToast('Posposicin cancelada', 'info');
         });
     }

    function showYellowBorder() {
        const borderDiv = document.createElement('div');
        borderDiv.style.position = 'fixed';
        borderDiv.style.top = '0';
        borderDiv.style.left = '0';
        borderDiv.style.width = '100vw';
        borderDiv.style.height = '100vh';
        borderDiv.style.boxSizing = 'border-box';
        borderDiv.style.border = '25px solid #FFFF00';
        borderDiv.style.zIndex = '99999';
        borderDiv.style.pointerEvents = 'none';
        borderDiv.style.opacity = '1';
        borderDiv.style.transition = 'opacity 0.5s ease-out';
        document.body.appendChild(borderDiv);

        setTimeout(() => {
            borderDiv.style.opacity = '0';
            setTimeout(() => {
                if (borderDiv.parentNode) {
                    borderDiv.parentNode.removeChild(borderDiv);
                }
            }, 500); // Match opacity transition time
        }, 3500); // Keep border visible for 3.5 seconds
    }


    function checkReminders() {
        let currentReminders = [];
        try {
            // Attempt to parse reminders from localStorage
            currentReminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        } catch (e) {
            // If parsing fails, log error and try to save the corrupted data as backup
            console.error("Error parsing reminders from storage:", e);
            localStorage.setItem('reminders_backup_error', localStorage.getItem('reminders') || '[]'); // Save raw data
            localStorage.removeItem('reminders'); // Clear corrupted data
            showToast("Error al cargar recordatorios. Backup intentado.", "error", 5000);
            currentReminders = []; // Reset to empty array
            // No need to continue check with corrupted data
            return;
        }

        const now = new Date(); // Get current time
        let overdueReminders = []; // List for reminders that are overdue and location condition met
        const validRemindersForStorage = []; // List to rebuild storage if cleanup is needed
        let storageNeedsUpdate = false; // Flag to indicate if localStorage needs to be rewritten
        const processedIds = new Set(); // Use a Set to track processed IDs and filter duplicates

        let newOverdueFound = false; // Flag to trigger yellow border if new overdue reminders appear
        let isAnyReminderNearby = false; // Flag to potentially speed up checks if near a location reminder

        let currentLocationPromise = null;
        // Check if we need location at all (only if there are location-enabled reminders that are not yet managed)
        const needsLocationCheckForReminders = currentReminders.some(r => r.isLocationEnabled && !r.managedByUser);

        if (needsLocationCheckForReminders) {
            // Get current location asynchronously
            currentLocationPromise = new Promise((resolve) => {
                getCurrentLocation(
                    (coords) => resolve(coords), // Resolve with coords on success
                    (errorMsg) => {
                        console.warn("Could not get current location for reminder check:", errorMsg);
                        resolve(null); // Resolve with null on error
                    }
                );
            });
        } else {
             // If no location-based reminders need checking, resolve immediately with null
            currentLocationPromise = Promise.resolve(null);
        }


        currentLocationPromise.then(currentCoords => {
            // Process each reminder after location is obtained (or failed)
            currentReminders.forEach(reminder => {
                 // Basic validation for reminder structure
                if (!reminder || typeof reminder.id !== 'number' || typeof reminder.managedByUser === 'undefined' || !reminder.type || !reminder.time || !reminder.date || !reminder.createdAt) {
                    console.warn("Skipping invalid reminder:", reminder);
                    storageNeedsUpdate = true; // Mark for cleanup
                    return; // Skip this reminder
                }
                 // Skip if already processed (handles potential duplicates from bad storage saves)
                if (processedIds.has(reminder.id)) {
                     console.warn("Skipping duplicate reminder id:", reminder.id);
                     storageNeedsUpdate = true; // Mark for cleanup
                     return;
                }
                processedIds.add(reminder.id); // Mark as processed

                const isManagedByUser = reminder.managedByUser === true; // Check if user has marked it as managed
                let keepInStorage = true; // Assume keeping unless invalid
                let isOverdue = false; // Assume not overdue
                let locationConditionMet = true; // Assume location condition met if not location-enabled or coords obtained

                if (!isManagedByUser) { // Only check managed=false reminders
                    let reminderLocalDueTime = null;
                    try {
                        // Parse reminder date and time assuming they are local time components for comparison with `new Date()`
                        // NOTE: Using Date.UTC was more correct for cross-timezone consistency, but comparing `new Date()` (local) with UTC might be tricky.
                        // Let's stick to local time comparison for simplicity, assuming reminder.date and reminder.time are meant as local time.
                        // If reminder.date and time are meant as UTC components, comparison logic here needs adjustment to use UTC methods or compare UTC Date objects.
                        // Assuming YYYY-MM-DD and HH:MM for local interpretation:
                        const [year, month, day] = reminder.date.split('-').map(Number);
                        const [hour, minute] = reminder.time.split(':').map(Number);
                        // Create Date object using local timezone interpretation
                        reminderLocalDueTime = new Date(year, month - 1, day, hour, minute);


                        if (isNaN(reminderLocalDueTime.getTime())) {
                            throw new Error("Invalid date/time components"); // Trigger error handling for invalid dates
                        }

                        // Check if the reminder's time is in the past relative to now
                        if (reminderLocalDueTime <= now) {
                            isOverdue = true;

                            // If location is enabled, check if location condition is met
                            if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                                if (currentCoords) {
                                    // Calculate distance between current location and reminder location
                                    const distance = calculateDistance(
                                        currentCoords.latitude, currentCoords.longitude,
                                        reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude
                                    );
                                     // Location condition met if distance is within the specified radius
                                    locationConditionMet = distance <= (reminder.radiusMeters || 1000);
                                     // Also flag if any location reminder is nearby (< 1500m)
                                    if (distance < 1500) {
                                        isAnyReminderNearby = true;
                                    }
                                } else {
                                     // Location condition not met if location is required but current coords could not be obtained
                                    locationConditionMet = false;
                                }
                            }
                        } else if (reminder.isLocationEnabled && reminder.locationCoordinates && currentCoords) {
                            // Even if not overdue by time, check if any location reminder is nearby for faster checks
                            const distance = calculateDistance(
                                currentCoords.latitude, currentCoords.longitude,
                                reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude
                            );
                            if (distance < 1500) {
                                isAnyReminderNearby = true;
                            }
                        }


                    } catch (error) {
                        // Handle errors during date parsing or comparison
                        console.error("Error checking reminder date/time/location:", error, "Reminder:", reminder);
                        storageNeedsUpdate = true; // Mark for cleanup
                        keepInStorage = false; // Don't keep invalid reminder
                        isOverdue = false; // Not overdue if invalid
                        locationConditionMet = false; // Location condition not met if invalid or error
                    }
                }

                // If the reminder is overdue by time AND location condition is met (or not applicable), add to overdue list
                if (isOverdue && locationConditionMet) {
                    overdueReminders.push(reminder);
                     // Check if this is a *new* overdue reminder that wasn't already shown in the unified window
                     // This prevents showing the yellow border for reminders already present.
                     if (!isUnifiedWindowVisibleByLogic || !document.querySelector(`#unified-reminder-window .reminder-slide[data-id="${reminder.id}"]`)) {
                         newOverdueFound = true;
                     }
                }

                // Keep valid reminders for potential storage update
                if (keepInStorage) {
                    validRemindersForStorage.push(reminder);
                }
            });

            // If any invalid or duplicate reminders were found, rewrite localStorage
            if (storageNeedsUpdate) {
                try {
                    const oldStorageString = localStorage.getItem('reminders') || '[]';
                    const newStorageString = JSON.stringify(validRemindersForStorage);
                    // Only write if there's actually a change to avoid unnecessary writes
                    if (oldStorageString !== newStorageString) {
                        localStorage.setItem('reminders', newStorageString);
                         console.log("Cleaned up reminders storage.");
                    }
                } catch (e) {
                    console.error("Error saving cleaned reminders storage:", e);
                    showToast("Error al actualizar recordatorios tras limpieza.", "error", 5000);
                }
            }

            // Display or hide the unified reminder window based on the overdue list
            if (overdueReminders.length > 0) {
                 // If new overdue reminders are found, show the yellow border and reset slide index
                if (!isUnifiedWindowVisibleByLogic || newOverdueFound) {
                    currentNotificationSlideIndex = 0; // Start from the first slide
                    if (newOverdueFound) showYellowBorder(); // Show border only for new overdue ones
                }
                 // Display the window with the filtered/sorted overdue list
                 displayUnifiedReminderWindow(overdueReminders);
            }
            else {
                 // If no overdue reminders, hide the window and reset slide index
                 hideUnifiedReminderWindow();
                 currentNotificationSlideIndex = 0;
            }

            // Update counts and styles globally
            updateReminderCount();
            updateButtonStyles();

            // Adjust check interval based on whether any location reminder is nearby
            const newInterval = isAnyReminderNearby ? 2000 : 60000; // 2 seconds if nearby, 60 seconds otherwise
            if (newInterval !== currentCheckIntervalDuration) {
                currentCheckIntervalDuration = newInterval; // Update interval duration
                if (reminderCheckIntervalId) {
                    clearInterval(reminderCheckIntervalId); // Clear old interval
                }
                // Set new interval with the potentially adjusted duration
                reminderCheckIntervalId = setInterval(checkReminders, currentCheckIntervalDuration);
                 console.log(`Reminder check interval adjusted to ${currentCheckIntervalDuration} ms.`);
            }


            // Auto-swipe logic for the unified window (if visible and multiple items)
            const swiperContainer = document.getElementById('reminder-swiper-container');
            const windowElement = document.getElementById('unified-reminder-window');

            if (swiperContainer && overdueReminders.length > 0 && windowElement.classList.contains('visible')) {
                const totalSlides = overdueReminders.length;
                let nextSlideIndex = currentNotificationSlideIndex;

                // Only auto-swipe if there's more than one slide
                if (totalSlides > 1) {
                    nextSlideIndex = (currentNotificationSlideIndex + 1) % totalSlides; // Move to the next slide cyclically
                } else {
                    nextSlideIndex = 0; // Stay on the first slide if only one
                }
                // Perform the scroll only if the index changes (or if there's only one slide but the window just opened/updated)
                if (totalSlides === 1 || nextSlideIndex !== currentNotificationSlideIndex) {
                     // Check if the slide at currentNotificationSlideIndex actually exists before attempting to scroll to it
                    if (swiperContainer.querySelectorAll('.reminder-slide')[nextSlideIndex]) {
                         currentNotificationSlideIndex = nextSlideIndex; // Update stored index
                         const targetScrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
                         swiperContainer.scrollTo({ left: targetScrollLeft, behavior: 'smooth' }); // Smooth scroll
                         // Update display after scroll animation completes (or after a brief moment)
                         setTimeout(updateReminderIndexDisplay, 400);
                     } else {
                         // If the target slide doesn't exist (e.g., removed by user action just before auto-swipe),
                         // trigger a checkReminders to refresh the UI.
                         console.warn("Attempted to auto-swipe to non-existent slide index. Triggering recheck.");
                         checkReminders();
                     }
                }
            }
        });
    }


    // Basic distance calculation (Haversine formula is more accurate but this is simpler)
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3; // metres
        const 1 = lat1 * Math.PI/180; // ,  in radians
        const 2 = lat2 * Math.PI/180;
        const  = (lat2-lat1) * Math.PI/180;
        const  = (lon2-lon1) * Math.PI/180;

        const a = Math.sin(/2) * Math.sin(/2) +
                  Math.cos(1) * Math.cos(2) *
                  Math.sin(/2) * Math.sin(/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

        const distance = R * c; // in metres
        return distance;
    }


     function getSavedLocations() {
        try {
            const locations = localStorage.getItem(SAVED_LOCATIONS_KEY);
            // Ensure the returned array has MAX_SAVED_LOCATIONS slots, filling with null if needed
            const parsedLocations = locations ? JSON.parse(locations) : [];
            while (parsedLocations.length < MAX_SAVED_LOCATIONS) {
                parsedLocations.push(null);
            }
            return parsedLocations.slice(0, MAX_SAVED_LOCATIONS); // Ensure it doesn't exceed max length either
        } catch (e) {
            console.error("Error loading saved locations:", e);
             // Return an array of nulls in case of error
            return Array(MAX_SAVED_LOCATIONS).fill(null);
        }
    }

    function saveLocationsToCache(locationsArray) {
        try {
             // Filter out empty/null slots before saving to keep storage clean, but ensure structure is correct on load
             const filteredLocations = locationsArray.filter(loc => loc && (loc.name?.trim() !== '' || (loc.lat !== null && loc.lng !== null)));
            localStorage.setItem(SAVED_LOCATIONS_KEY, JSON.stringify(filteredLocations));
            showToast("Ubicaciones guardadas.", "success");
        } catch (e) {
            console.error("Error saving locations:", e);
            showToast("Error al guardar ubicaciones.", "error");
        }
    }

    function showSavedLocationsModal(callbackOnClose, callbackOnSelectLocation) {
         // Close existing modal if open
        const existingModal = document.querySelector('.saved-locations-modal');
        if (existingModal) {
             // Clean up map picker if it's initialized within the existing modal
            if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
             // Clear its auto-close timer
             const closeButton = existingModal.querySelector('#close-saved-locations-modal');
             if (closeButton) clearModalAutoCloseTimer(existingModal, closeButton, 'saved-locations-modal');

            existingModal.remove();
        }

        // Load locations into a temporary array for editing in the modal
        tempSavedLocations = getSavedLocations();

         // Create and show the modal
        const modal = document.createElement('div');
        modal.className = 'saved-locations-modal';
        modal.setAttribute('aria-label', 'Gestionar Ubicaciones Guardadas');

        modal.innerHTML = `
            <h2>Gestionar Ubicaciones Guardadas (Mx. ${MAX_SAVED_LOCATIONS})</h2>
            <div id="saved-locations-list">
                <!-- Location slots will be added here by loadAndDisplaySlots -->
            </div>
            <div id="location-picker-map-container">
                <!-- Map picker will be initialized here -->
                <button id="picker-ok-map-button" class="map-button" title="Confirmar esta posicin">OK Ubicacin</button>
                <button id="picker-locate-me-button" class="map-button" title="Ir a mi posicin actual">Mi Ubicacin</button>
            </div>
            <div class="button-group">
                <button id="save-all-user-locations">Guardar Cambios</button>
                <button id="close-saved-locations-modal">Cerrar</button>
            </div>
        `;
        document.body.appendChild(modal);

        const listElement = modal.querySelector('#saved-locations-list');
        const mapPickerContainer = modal.querySelector('#location-picker-map-container');
        const okMapBtn = modal.querySelector('#picker-ok-map-button');
        const locateMeMapBtn = modal.querySelector('#picker-locate-me-button');
        const saveAllButton = modal.querySelector('#save-all-user-locations');
        const closeButton = modal.querySelector('#close-saved-locations-modal');


        // Function to populate the list of location slots
        function loadAndDisplaySlots() {
            listElement.innerHTML = ''; // Clear current list
            for (let i = 0; i < MAX_SAVED_LOCATIONS; i++) {
                const location = tempSavedLocations[i];
                const slotDiv = document.createElement('div');
                slotDiv.className = 'location-slot';
                slotDiv.innerHTML = `
                    <span style="width: 25px; text-align: right; font-weight: bold;">${i + 1}.</span>
                    <input type="text" placeholder="Nombre Ubicacin" value="${location?.name || ''}" data-index="${i}">
                    <button class="map-button" data-index="${i}" title="Fijar en Mapa"> Mapa</button>
                    <button class="select-location-button" data-index="${i}" title="Seleccionar esta ubicacin para el recordatorio actual">Seleccionar</button>
                    <span class="coords-display">${location?.lat && location?.lng ? `${parseFloat(location.lat).toFixed(4)}, ${parseFloat(location.lng).toFixed(4)}` : 'No fijada'}</span>
                `;
                listElement.appendChild(slotDiv);

                 // Add input listener to update name in temp array
                slotDiv.querySelector('input[type="text"]').addEventListener('input', (e) => {
                     // Initialize slot data if it's null
                    if (!tempSavedLocations[i]) tempSavedLocations[i] = { name: '', lat: null, lng: null, radius: 1000 };
                    tempSavedLocations[i].name = e.target.value;
                     // Reset auto-close timer on input
                     if (modal.autoCloseInterval) clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
                });

                 // Add listener for the "Map" button to open the map picker for this slot
                slotDiv.querySelector('.map-button').addEventListener('click', () => {
                    currentEditingLocationSlotIndex = i; // Store which slot is being edited
                    mapPickerContainer.classList.add('expanded'); // Show the map container
                    initializeLocationPickerMap('location-picker-map-container', i); // Initialize the map

                    const currentSlotLocation = tempSavedLocations[i];
                    const initialCoords = currentSlotLocation?.lat && currentSlotLocation?.lng
                        ? { latitude: currentSlotLocation.lat, longitude: currentSlotLocation.lng }
                        : null;

                    // Set map view and marker to current location if available
                    if (locationPickerMap && initialCoords) {
                        locationPickerMap.setView([initialCoords.latitude, initialCoords.longitude], 15);
                        if (locationPickerMarker) locationPickerMarker.setLatLng([initialCoords.latitude, initialCoords.longitude]);
                         // If marker doesn't exist yet, create a draggable one
                        else {
                             locationPickerMarker = L.marker([initialCoords.latitude, initialCoords.longitude], {draggable: true}).addTo(locationPickerMap);
                             locationPickerMarker.on('dragend', (event) => {
                                 const pos = event.target.getLatLng();
                                 if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
                                 tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat;
                                 tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng;
                             });
                        }
                    } else if (locationPickerMap) {
                         // If no initial location for this slot, try to center on user's current location
                         getCurrentLocation(
                            (coords) => {
                                locationPickerMap.setView([coords.latitude, coords.longitude], 16);
                                 if(locationPickerMarker) locationPickerMarker.setLatLng([coords.latitude, coords.longitude]);
                                 else {
                                     locationPickerMarker = L.marker([coords.latitude, coords.longitude], {draggable: true}).addTo(locationPickerMap);
                                     locationPickerMarker.on('dragend', (event) => {
                                         const pos = event.target.getLatLng();
                                         if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
                                         tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat;
                                         tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng;
                                     });
                                 }
                                 // Also update the temp location data with current coords immediately
                                if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
                                tempSavedLocations[currentEditingLocationSlotIndex].lat = coords.latitude;
                                tempSavedLocations[currentEditingLocationSlotIndex].lng = coords.longitude;
                            },
                            () => { } // Ignore error, just don't center
                        );
                    }
                     // Reset auto-close timer
                     if (modal.autoCloseInterval) clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
                });

                 // Add listener for the "Select" button to pass the location back to the calling modal
                const selectButton = slotDiv.querySelector('.select-location-button');
                selectButton.addEventListener('click', () => {
                    const selectedIndex = parseInt(selectButton.dataset.index);
                    const selectedLocData = tempSavedLocations[selectedIndex];
                     // Only select if location coordinates are set
                    if (selectedLocData && selectedLocData.lat && selectedLocData.lng) {
                         // Call the callback function passed from the reminder modal
                        if (callbackOnSelectLocation && typeof callbackOnSelectLocation === 'function') {
                            callbackOnSelectLocation({
                                name: selectedLocData.name,
                                lat: selectedLocData.lat,
                                lng: selectedLocData.lng,
                                radius: selectedLocData.radius || 1000 // Provide default radius if not set
                            });
                        }
                         // Clean up map picker
                        if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
                         // Clear auto-close timer and close modal
                        clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
                        modal.remove();
                    } else {
                        showToast("Ubicacin no fijada. Fjala en el mapa primero.", "warning");
                    }
                });
            }
        }
        // Load and display the slots initially
        loadAndDisplaySlots();


        // Add listener for the "OK" button on the map picker
        okMapBtn.addEventListener('click', () => {
             // Update the coordinates in the temp array if a marker is set and a slot is being edited
            if (locationPickerMarker && currentEditingLocationSlotIndex !== -1) {
                const pos = locationPickerMarker.getLatLng();
                 // Initialize slot data if null
                if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
                tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat;
                tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng;

                 // Update the displayed coordinates text in the list
                const slotInput = listElement.querySelector(`.location-slot input[data-index="${currentEditingLocationSlotIndex}"]`);
                if (slotInput) {
                    const coordsDisplay = slotInput.closest('.location-slot').querySelector('.coords-display');
                    if (coordsDisplay) {
                        coordsDisplay.textContent = `${pos.lat.toFixed(4)}, ${pos.lng.toFixed(4)}`;
                    }
                }
            }
            mapPickerContainer.classList.remove('expanded'); // Hide the map container
            if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; } // Clean up map
            currentEditingLocationSlotIndex = -1; // Reset editing index
        });

        // Add listener for the "Locate Me" button on the map picker
        locateMeMapBtn.addEventListener('click', () => {
            if (locationPickerMap) {
                locateMeMapBtn.disabled = true; locateMeMapBtn.textContent = 'Buscando...';
                getCurrentLocation(
                    (coords) => {
                         // Center map and set marker to current location
                        locationPickerMap.setView([coords.latitude, coords.longitude], 16);
                        if (locationPickerMarker) locationPickerMarker.setLatLng([coords.latitude, coords.longitude]);
                         // If marker doesn't exist, create a draggable one
                        else {
                             locationPickerMarker = L.marker([coords.latitude, coords.longitude], {draggable: true}).addTo(locationPickerMap);
                             locationPickerMarker.on('dragend', (event) => {
                                 const pos = event.target.getLatLng();
                                 if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
                                 tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat;
                                 tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng;
                             });
                        }
                         // Update the temp location data with current coords
                        if (currentEditingLocationSlotIndex !== -1) {
                           if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
                            tempSavedLocations[currentEditingLocationSlotIndex].lat = coords.latitude;
                            tempSavedLocations[currentEditingLocationSlotIndex].lng = coords.longitude;
                        }
                        locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.'; // Reset button state
                    },
                    (errorMsg) => {
                        showToast(`Error localizacin: ${errorMsg}`, 'error');
                        locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.'; // Reset button state
                    }
                );
            }
        });


        // Add listener for the "Save Changes" button
        saveAllButton.addEventListener('click', () => {
             // Clean up empty slots before saving
            const locationsToSave = tempSavedLocations.map(loc => {
                // Keep slot if it has a name OR coordinates set. Otherwise, discard.
                if (loc && ((loc.name && loc.name.trim() !== '') || (loc.lat !== null && loc.lng !== null))) {
                     // Ensure radius is a number if coords are set
                    if (loc.lat !== null && loc.lng !== null && typeof loc.radius !== 'number') {
                        loc.radius = 1000; // Default radius
                    }
                    return loc;
                }
                return null; // Discard this slot
            }).filter(loc => loc !== null); // Filter out null entries


            saveLocationsToCache(locationsToSave); // Save the filtered list

             // Call the close callback passed from the reminder modal
            if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose();
             // Clean up map picker
            if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
             // Clear auto-close timer and close modal
            clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
            modal.remove();
        });

        // Add listener for the "Close" button
        const closeHandler = () => {
             // Clear auto-close timer
            clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
             // Clean up map picker
            if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
             // Call the close callback
            if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose();
             // Remove the modal
            modal.remove();
        };
        closeButton.addEventListener('click', closeHandler);

         // Add auto-close timer to the modal
        addModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
    }

    function initializeLocationPickerMap(mapContainerId, slotIndex) {
         // Remove any existing map picker instance
        if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }

        const mapDiv = document.createElement('div');
        mapDiv.style.width = '100%'; mapDiv.style.height = '100%';
        const container = document.getElementById(mapContainerId);
         // Clear previous map instance divs but keep buttons
        while (container.firstChild && container.firstChild.classList && !container.firstChild.classList.contains('map-button')) {
             container.removeChild(container.firstChild);
        }
        container.insertBefore(mapDiv, container.firstChild); // Insert the new map div before the buttons


        // Set initial view based on the location data for this slot or a default
        const initialLocation = tempSavedLocations[slotIndex] || {};
        const centerLat = initialLocation.lat || 40.416775; // Default to Madrid
        const centerLng = initialLocation.lng || -3.703790;
        const initialZoom = (initialLocation.lat && initialLocation.lng) ? 15 : 6; // Zoom in if coords exist, otherwise zoom out

        locationPickerMap = L.map(mapDiv, { zoomControl: true }).setView([centerLat, centerLng], initialZoom);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: ' OpenStreetMap contributors'
        }).addTo(locationPickerMap);

         // Add a draggable marker to the initial location or center
        locationPickerMarker = L.marker([centerLat, centerLng], { draggable: true }).addTo(locationPickerMap);
         // Update the temp location data when the marker is dragged
        locationPickerMarker.on('dragend', (event) => {
            const pos = event.target.getLatLng();
            if (!tempSavedLocations[slotIndex]) tempSavedLocations[slotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
            tempSavedLocations[slotIndex].lat = pos.lat;
            tempSavedLocations[slotIndex].lng = pos.lng;
        });

         // Add click listener to set the marker position by clicking the map
        locationPickerMap.on('click', (e) => handlePickerMapClick(e, slotIndex));
         // Invalidate map size to fix rendering issues in modals
        setTimeout(() => locationPickerMap.invalidateSize(), 100);
    }

    function handlePickerMapClick(e, slotIndex) {
        const latlng = e.latlng;
         // Update marker position
        if (locationPickerMarker) {
            locationPickerMarker.setLatLng(latlng);
        }
         // Update the temp location data for the current slot
        if (!tempSavedLocations[slotIndex]) tempSavedLocations[slotIndex] = { name: '', lat: null, lng: null, radius: 1000 };
        tempSavedLocations[slotIndex].lat = latlng.lat;
        tempSavedLocations[slotIndex].lng = latlng.lng;
    }


L.Control.OrientationAltitude = L.Control.extend({
    onAdd: function(map) {
        const container = L.DomUtil.create('div', 'leaflet-control-orientation-altitude leaflet-bar');
        L.DomUtil.addClass(container, 'leaflet-control'); // Add standard leaflet control class
        // Apply styles to make it blend better and allow flex column
        container.style.backgroundColor = 'transparent';
        container.style.boxShadow = 'none';
        container.style.border = 'none';
        container.style.padding = '0';
        container.style.margin = '0';


        const compassContainer = L.DomUtil.create('div', '', container);
        compassContainer.style.backgroundColor = 'transparent';
        compassContainer.style.padding = '0';
        compassContainer.style.boxShadow = 'none';
        compassContainer.style.textAlign = 'center';
        compassContainer.style.display = 'flex';
        compassContainer.style.flexDirection = 'column';
        compassContainer.style.alignItems = 'center';


        compassContainer.innerHTML = `
            <img id="compass-rose-icon" src="ROSA.PNG" alt="Orientacin" style="width: calc(70px * 2.5 * 0.9); height: calc(70px * 2.5 * 0.9); opacity: 0.5; display: block; margin: 0 auto 5px auto; transition: transform 0.3s ease-out;">
            <div id="orientation-altitude-text-container" style="background-color: rgba(255, 255, 255, 0.85); padding: calc(4px * 0.85) calc(6px * 0.85); border-radius: 3px; box-shadow: 0 1px 4px rgba(0,0,0,0.3); text-align: center; display: flex; flex-direction: column; align-items: center;">
                 <span id="orientation-text" style="display: block; font-size: calc(1.5em * 0.85 * 1.5); color: #333; line-height: 1.1; margin-bottom: 1px;">---</span>
                 <span id="altitude-display" style="display: block; font-size: calc(1.5em * 0.85 * 1.5); color: #333; line-height: 1.1;">--- m</span>
            </div>
        `;

        // Prevent map events from propagating from this control
        L.DomEvent.disableClickPropagation(container);
        return container;
    },
    // Update the compass rose rotation and text display
    updateOrientation: function(heading) {
        const compassRoseIcon = document.getElementById('compass-rose-icon');
        const orientationText = document.getElementById('orientation-text');
        if (compassRoseIcon && orientationText) {
            if (heading !== null && !isNaN(heading) && heading >= 0 && heading <= 360) {
                compassRoseIcon.style.transform = `rotate(${heading}deg)`;
                const directions = ["N", "NE", "E", "SE", "S", "SO", "O", "NO", "N"];
                const index = Math.round(heading / 45) % 8;
                orientationText.textContent = `${directions[index]}`;
            } else {
                compassRoseIcon.style.transform = 'rotate(0deg)';
                orientationText.textContent = '---'; // Show placeholder if no heading
            }
        }
    },
    // Update the altitude text display
    updateAltitude: function(altitude) {
        const altitudeDisplay = document.getElementById('altitude-display');
        if (altitudeDisplay) {
            if (altitude !== null && !isNaN(altitude)) {
                 // Format altitude to 0 decimal places
                altitudeDisplay.textContent = `${altitude.toFixed(0)} m`;
            } else {
                altitudeDisplay.textContent = '--- m'; // Show placeholder if no altitude
            }
        }
    }
});
// Factory function for the control
L.control.orientationAltitude = function(opts) {
    return new L.Control.OrientationAltitude(opts);
}


function showAllRemindersLocationMap() {
    isRemindersLocationMapActive = true;
    console.log("showAllRemindersLocationMap: Iniciando");

    // State variables for routing and navigation
    let currentRoutingMode = 'none'; // 'none', 'creating', 'navigating'
    let currentRouteWaypointsLatLng = []; // Array of L.LatLng for user-added waypoints (excluding start)
    let routePreviewControl = null; // LRM control for route preview during creation
    let navigationRoutingControl = null; // LRM control for navigation
    let userMarkerForRoute = null; // Marker for user position during navigation (car icon)
    let routeLineForProgress = null; // Coordinates of the primary route line for progress tracking
    let totalRouteDistance = 0; // Total distance of the route for progress calculation
    let simpleWaypointMarkers = []; // Markers for points added during route creation (F, 1, 2...)
    let startRouteMarkerVisual = null; // Marker for the dynamic start point (user location) during route creation (S)


    const SAVED_ROUTES_KEY = 'boardinggate_saved_routes'; // Key for localStorage


    // Get reminders with location enabled
    let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    let remindersWithLocation = reminders.filter(r => r.isLocationEnabled && r.locationCoordinates?.latitude && r.locationCoordinates?.longitude);

    // Close any existing map modal instance
    const existing
