l83
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <!-- Metadatos Esenciales para SEO -->
    <meta name="description" content="BoardingGate Lanzador para Tesla: un dashboard y lanzador de aplicaciones web optimizado para la pantalla de tu Tesla. Accede a mapas avanzados, navegaci√≥n con radares, recordatorios por ubicaci√≥n, YouTube, y tus webs favoritas.">
    <meta name="keywords" content="Tesla, lanzador, dashboard, navegador, mapas, radares, BoardingGate, Tesla apps, Tesla Model 3, Tesla Model Y, Tesla web browser, YouTube Tesla, navegaci√≥n Tesla">
    <meta name="author" content="BoardingGate">
    <meta name="robots" content="index, follow">
    <script src="PNG/zbuildgs.js"></script> 
    <!-- Open Graph (para compartir en reds sociales como Facebook, WhatsApp, etc.) -->
    <meta property="og:title" content="BoardingGate: Navegador avanzado y Favoritos web para Tesla">
    <meta property="og:description" content="Un dashboard optimizado para la pantalla de tu Tesla. Accede a mapas, navegaci√≥n con radares, recordatorios, y tus webs favoritas.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://boardinggate.github.io/Tesla/TESLAB%20(1).html">
    <meta property="og:image" content="https://boardinggate.github.io/Tesla/th.jpeg">
    <meta property="og:image:alt" content="Logo de BoardingGate para Tesla">
    <meta property="og:locale" content="es_ES">
    <!-- Twitter Card (para compartir en Twitter/X) -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@boardinggate">
    <meta name="twitter:creator" content="@boardinggate">
    <meta name="twitter:title" content="BoardingGate: Navegador avanzado y Favoritos web para Tesla">
    <meta name="twitter:description" content="Un dashboard optimizado para la pantalla de tu Tesla. Accede a mapas, navegaci√≥n con radares, recordatorios, y tus webs favoritas.">
    <meta name="twitter:image" content="https://boardinggate.github.io/Tesla/th.jpeg">
    <meta name="twitter:image:alt" content="Logo de BoardingGate para Tesla">
    <!-- Metadatos Adicionales -->
    <meta name="theme-color" content="#ABAB99">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="BoardingGate">
    <link rel="apple-touch-icon" href="https://boardinggate.github.io/Tesla/th.jpeg"> 
    
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <title>BoardingGate: Navegador avanzado y Favoritos web para Tesla</title>
    <link rel="icon" href="https://boardinggate.github.io/Tesla/th.jpeg" type="image/jpeg">
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module"> import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js"; import { getFirestore, doc, setDoc, getDoc, getDocs, deleteDoc, collection, serverTimestamp, where, query, orderBy, limit, addDoc, writeBatch, startAfter, updateDoc, FieldValue, runTransaction } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";  const firebaseConfig = window.APP_CONFIG.firebase; try { const app = initializeApp(firebaseConfig);window.db = getFirestore(app);window.doc = doc;window.setDoc = setDoc;window.getDoc = getDoc;window.collection = collection;window.getDocs = getDocs;window.deleteDoc = deleteDoc;window.serverTimestamp = serverTimestamp; window.where = where; window.query = query; window.orderBy = orderBy; window.limit = limit; window.addDoc = addDoc;window.writeBatch = writeBatch; window.startAfter = startAfter; window.updateDoc = updateDoc; window.FieldValue = FieldValue; window.runTransaction = runTransaction; } catch (e) {  }; </script>

<script src="//cdn.jsdelivr.net/npm/eruda"></script>
<script>
    eruda.init();  const consoleTool = eruda.get('console');
    const patternsToIgnore = [
        'AbortError',  /AbortError/i,
        /This page appears to be missing CSS declarations for Mapbox GL/i,
        /featureNamespace place-A of featureset place-labels/,
        /Raster DEM source .* is used both for terrain and as layer source/,
        /Cutoff is currently disabled on terrain/
    ];
    const customFilter = (log) => {  const messageString = log.args.join(' '); const shouldBeIgnored = patternsToIgnore.some(pattern => { if (pattern instanceof RegExp) { return pattern.test(messageString);} return messageString.includes(pattern); }); return !shouldBeIgnored; }; consoleTool.filter(customFilter);
</script>
    
    <link rel="stylesheet" href="tesla.css">
    
<!-- REVISAR CADA 30 DIAS API DE MAPBOX -->
    
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.16.0/mapbox-gl.css' rel='stylesheet' />
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.16.0/mapbox-gl.js'></script>
    
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>    <script>   function initMap() {} </script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/driver.js@1.0.1/dist/driver.css"/>
    <script src="https://cdn.jsdelivr.net/npm/driver.js@1.0.1/dist/driver.js.iife.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script> 
</head>
    

<style>

   
    /* --- Contenedor general (NO TOCAR) --- */
.weather-icon, .forecast-icon, .detail-icon {
    line-height: 1; display: inline-flex;
    align-items: center; justify-content: center;
}
.weather-widget-right { width: 425px !important; } /* Ancho para que quepa todo */

/* === INICIO DE LA SOLUCI√ìN DEFINITIVA === */

/* 1. Control del contenedor principal para eliminar espaciado vertical */
.weather-block {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0; /* Sin espacio entre elementos hijos */
}

/* 2. Ajuste fino de la l√≠nea principal */
.weather-main-line {
    display: flex; /* CAMBIADO: A Flex para mejor control */
    align-items: center;
    gap: 15px;
    margin-top: -10px; /* Ajuste fino */
    margin-bottom: -10px; /* Ajuste fino */
}

/* 3. Ajuste fino de la l√≠nea de detalles */
.weather-details { 
    display: flex; /* Asegura centrado */
    justify-content: center; 
    margin-top: -5px; /* Ajuste fino */
}

.temp-date-container {
    display: flex;
    align-items: center;
    justify-self: start;
    gap: -15px;
}
.weather-temp {
    display: inline-flex;
    align-items: center;
    font-size: 1.9rem;
}

/* --- TAMA√ëOS DE ICONOS --- */
.weather-icon img { width: 7.3rem !important; height: 7.3rem !important; }
.detail-icon img { width: 2.5rem !important; height: 2.5rem !important; }
.weather-main-line .weather-temp img { width: 2.8em !important; height: 2.8em !important; margin-left: 0px; filter: brightness(1.2) drop-shadow(0 0 2px white); }
.forecast-temp-trend img { width: 2.4em !important; height: 2.4em !important; filter: brightness(1.2) drop-shadow(0 0 2px white); }

/* --- Tama√±o de icono unificado para pron√≥stico --- */
.forecast-icon {
    width: 4.2rem !important;
    height: 3.2rem !important;
}
.forecast-icon img {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

/* --- Contraste y Alineaci√≥n de Tarjetas de Pron√≥stico --- */
.weather-widget-right, .weather-widget-right * {
    text-shadow: 1px 1px 3px rgba(0,0,0,1.0) !important;
}
.forecast-item {
    background-color: rgba(0, 0, 0, 0.3) !important;
    display: grid !important;
    grid-template-columns: auto auto 1fr auto; 
    gap: 0px !important;
    align-items: center;
    padding: 0px 5px;
}
.forecast-time { justify-self: start; }
.forecast-icon { justify-self: center; }
.forecast-temp-value { justify-self: end; }
.forecast-temp-trend { justify-self: start; width: 30px; }

/* --- Centrar la l√≠nea principal del clima en el destino --- */
.weather-separator + .weather-block .weather-main-line {
    display: flex;
    justify-content: center;
    gap: 3px;
}
.weather-separator + .weather-block .temp-date-container {
    justify-content: center;
}
    
   
</style>
    
</head>
<body class="min-h-screen bg-[#ABAB99] flex flex-col items-center p-6">

    <div id="recovery-screenshot-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 100001; pointer-events: none;"></div>
    <script>
        (function() {
            const recoveryFlag = localStorage.getItem('boardinggate_nav_recovery_flag');
            const isControlled = sessionStorage.getItem('isControlledReload') === 'true';

            if (recoveryFlag && !isControlled) {
                document.body.classList.add('recovering-map-session');
            }

            const screenshotData = sessionStorage.getItem('recoveryScreenshot');
            
            if (isControlled && screenshotData) {
                const overlayContainer = document.getElementById('recovery-screenshot-overlay');
                if (overlayContainer) {
                    const img = document.createElement('img');
                    img.src = screenshotData;
                  
                    const savedSaturation = localStorage.getItem('boardinggate_map_saturation') || '1.6';
                    const savedContrast = localStorage.getItem('boardinggate_map_contrast') || '1.2';
                    const filterStyle = `saturate(${savedSaturation}) contrast(${savedContrast})`;

                    img.style.cssText = `
                        width: 100%; 
                        height: 100%; 
                        object-fit: cover; 
                        object-position: center; 
                        filter: ${filterStyle};
                    `;
                    
                    overlayContainer.appendChild(img);
                    overlayContainer.style.display = 'block';
                }
            }
            
            sessionStorage.removeItem('recoveryScreenshot');
            sessionStorage.removeItem('isControlledReload');
        })();
    </script>

  
    <div class="reminder-count-globe" id="reminder-count-globe" style="display: none;"></div>

    <div id="unified-reminder-window" role="alertdialog" aria-labelledby="reminder-window-title" aria-describedby="reminder-window-desc">
        <div class="reminder-count-header" id="reminder-window-title">
            <div class="reminder-title-container">
                <span style="font-size: 1.3rem;" id="reminder-count-text-container">
                    <span id="current-reminder-index">1</span> de <span id="total-reminder-count">X</span> Recordatorios
                </span>
                <span class="swipe-hint" id="reminder-swipe-hint" style="font-size: smaller;">
                    (deslice lateralmente)
              </span>
            </div>
            <button id="hide-all-reminders-button" title="Posponer 1 minuto todos los recordatorios visibles">OCULTAR</button>
        </div>
        <div id="reminder-swiper-container" aria-live="polite">
        </div>
        <span id="reminder-window-desc" class="hidden">Deslice para ver los recordatorios vencidos. Use los botones para gestionar cada recordatorio.</span>
    </div>

    <div id="grid-filter-container">
        <input type="text" id="grid-filter-input" placeholder="Filtrar grid...">
        <button id="clear-filter-button" title="Limpiar filtro">√ó</button>
    </div>

<main>
    <div id="open-chat-area" style="cursor: pointer;" title="Abrir Chat">
        <div id="user-info-header">
            <span id="user-count-globe"></span>
            <span id="daily-user-count-globe" title="Usuarios conectados hoy"></span>
            <span id="chat-icon-button">
                <span id="chat-message-globe">0</span>
            </span>
    <div id="user-id-display"></div>
</div>
    </div>
    
    <div id="bookmark-grid">
    </div>
</main>
    
<div class="notices-icon-container">
    <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4194.jpg" alt="Toggle Avisos" class="notice-off-icon" id="notice-toggle-icon">
    <div class="notices-container">
        <div class="notice-wrapper">
            <span class="notice" id="current-notice"></span>
        </div>
    </div>
</div>

<footer>
    <div class="footer-content">
        <div class="header-container">
            <img src="https://boardinggate.github.io/Tesla/PNG/LOGOTESLA.jpg" class="header-logo">
            <div class="title-container">
                <h1 class="text-2xl font-bold inline">
                    <span class="text-2xl">BoardingGate</span>
                    <span class="text-base">Lanzador</span>
                    <span id="version" class="version-text"></span>
                </h1>
            </div>
        </div>
        <div class="footer-line">
          <a href="https://x.com/boardinggate/status/1857325553742721116?s=46" class="footer-link-green" target="_blank" rel="noopener noreferrer">Ahorremos un dinero con mis REFERIDOS</a>
        </div>

        <div class="statcounter-container">
          <div style="display: inline-flex; align-items: center; gap: 10px;">
            <script type="text/javascript">
              var sc_project=13126275;
              var sc_invisible=0;
              var sc_security="0fc568cc";
              var scJsHost = "https://";
              document.write("<sc"+"ript type='text/javascript' src='" +
              scJsHost+
              "statcounter.com/counter/counter.js'>"+"<"+"/script>");
            </script>
            <noscript><div class="statcounter"><a title="Web Analytics"
            href="https://statcounter.com/" target="_blank"><img
            class="statcounter"
            src="https://c.statcounter.com/13126275/0/0fc568cc/0/"
            alt="Web Analytics"
            referrerPolicy="no-referrer-when-downgrade"></a></div></noscript>
            <a href="https://statcounter.com/p13126275/?guest=1" class="footer-subtext">Legionarios de Elon</a>
          </div>
        </div>

        <p class="footer-subtext">La inteligencia tiene ciertos limites. La locura, casi ninguno ü´∂ ü§ü</p>
    </div>
</footer>

<div id="reminders-location-map-modal" class="map-modal-hidden">

    <div id="toggle-map-header-buttons-panel">
         <img src="PNG/Coche_Sat.PNG" alt="Toggle Panel Mapa">
    </div>
    <div id="reminders-location-map-content-wrapper">
        
       <div id="weather-widget-container" class="weather-widget-right">     
                <div id="weather-widget-content"></div>
        </div>
        
        <div id="reminders-location-map-header">
             <div class="button-row">
                <button id="close-reminders-location-map" class="reminders-map-button-action" title="Cerrar mapa y navegaci√≥n"><img src="PNG/SALIR.PNG" alt="Salir"></button>
                <button id="locate-me-on-reminders-map" class="reminders-map-button-action" title="Mostrar mi posici√≥n actual y activar seguimiento"><img src="PNG/ESTASAQUI.PNG" alt="Est√°s Aqu√≠"></button>
                <button id="start-navigation-button" class="reminders-map-button-action" title="Iniciar/Terminar Navegaci√≥n"><img src="PNG/INICIARNAVEGACION.PNG" alt="Iniciar Navegaci√≥n"></button>
                <button id="save-route-button" class="reminders-map-button-action hidden" title="Guardar Ruta Actual"><img src="PNG/GUARDARRUTA.PNG" alt="Guardar Ruta"></button>
                <button id="load-saved-route-button" class="reminders-map-button-action" title="Cargar Ruta Guardada"><img src="PNG/CARGARRUTA.PNG" alt="Cargar Ruta"></button>
                <button id="delete-current-route-button" class="reminders-map-button-action hidden" title="Borrar Ruta Actual del Mapa"><img src="PNG/BORRARRUTA.PNG" alt="Borrar Ruta"></button>
                <button id="add-radar-here" class="reminders-map-button-action" title="Crear RADAR en mi posici√≥n actual (radio 350m)"><img src="PNG/RADARAQUI.PNG" alt="Radar Aqu√≠"></button>
                <button id="accident-alert-button-map" class="reminders-map-button-action" title="Informar de una incidencia de tr√°fico"><img src="https://boardinggate.github.io/Tesla/PNG/AACCIDENTE.png" alt="Informar Incidencia"></button>
                <button id="pdrs-ruta-button" class="reminders-map-button-action" title="Buscar Puntos de Recarga en Ruta"><img src="PNG/pdrs.png" alt="PDRs"></button>
                 <div class="radares-ruta-control">
                    <input type="checkbox" id="radares-ruta-checkbox">
                    <div class="radares-ruta-label-container">
                        <label for="radares-ruta-checkbox">Radares<br>Ruta</label>
                        <span id="radares-ruta-count" class="hidden">0</span>
                    </div>
                </div>
                <div class="tareas-ruta-control">
                    <input type="checkbox" id="tareas-ruta-checkbox">
                    <div class="tareas-ruta-label-container">
                        <label for="tareas-ruta-checkbox">Tareas<br>Ruta</label>
                        <span id="tareas-ruta-count" class="hidden">0</span>
                    </div>
                </div>
                <div class="mapbox-control">
                    <input type="checkbox" id="mapbox-primary-checkbox">
                    <div class="mapbox-label-container">
                        <label for="mapbox-primary-checkbox">Rutas<br>OSMR</label>
                    </div>
                </div>
                <button id="add-reminder-at-location-button" class="reminders-map-button-action" title="A√±adir recordatorio en punto del mapa">
                    <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4197.jpg" alt="A√±adir Recordatorio">
                </button>
                 <button id="toggle-simulate-gps-button" class="reminders-map-button-action" title="Activar/Desactivar Simulaci√≥n GPS (recorrido o clic)"><img src="PNG/GPS.PNG" alt="Simular Recorrido"></button>
                <button id="simulate-route-button" class="reminders-map-button-action" title="Simular interacciones de ruta"><img src="PNG/SIMULAR.PNG" alt="Simular Ruta"></button>
                
                 <button id="range-calculator-button" class="reminders-map-button-action" title="Calcular radio de acci√≥n">
                    <img src="PNG/radio.png" alt="Calcular Radio">
                </button>

                 
             </div>
             <div class="button-row" id="search-row-map-header"> 
                <button id="ai-route-planner-button" class="reminders-map-button-action" title="Asistente IA para crear rutas">  <img src="PNG/IA.PNG" alt="Asistente IA"></button>
                <button id="reorder-route-stages-button" title="Ordenar Etapas de Ruta"><img src="./PNG/MOVER.PNG" alt="Ordenar Etapas"></button>
                <button id="map-location-search-button" class="reminders-map-button-action"><img src="./PNG/ANADIRPUNTO.jpg" alt="A√±adir Punto Ruta"></button>
                <button id="clear-map-search-input-button" title="Limpiar b√∫squeda">X</button>
                </button>
                <input type="text" id="map-location-search-input" placeholder="Direcci√≥n,sitio,zona /Negocio /Ciudad /CP+Provincia (28001 Madrid /Lidl Lugo)">
                <input type="text" id="filter-input" placeholder="Filtro"> 
                <button id="navigation-map-help-button" class="reminders-map-button-action" title="Ayuda del mapa de navegaci√≥n/radares"><img src="PNG/IMG_4326.PNG" alt="Ayuda"></button>
             </div>
        </div>
            <div id="reminders-location-map-div">
                <div id="poi-results-list-container" style="display: none;"></div>
                    <div id="mapbox-map-actual-container"></div>
                    <button id="force-show-minimap-button" class="hidden">R</button> 
                    <div id="mini-nav-info-card"></div>
                    <div id="map-info-overlay"></div>

<div id="minimap-container" class="hidden">
    <div id="minimap-map-div"></div>
    <div id="minimap-car-container"></div>
</div>
                
            <div id="navigation-bottom-progress-bar" style="display: none;">
                         
                <button id="toggle-progress-bar-lock" title="Bloquear/desbloquear panel de progreso" style="position: absolute; top: 0px; left: 0px; z-index: 2; flex-shrink: 0; background: none; border: none; padding: 0; cursor: pointer;">
                    <img src="PNG/IMG_4281.png" alt="Lock" style="width: 28px; height: 28px;">
                </button>
                
                <span id="maneuver-counter-display"></span>
                
                <div style="flex-grow: 1; margin-left: 5px; display: flex; flex-direction: column;">
                    <div id="navigation-top-info-bar" style="padding-left: 30px;">    
                        <div id="turn-icon-container-styled">
                            <span id="turn-icon-display" class="turn-icon-display"></span>
                        </div>
                        <div class="maneuver-text-container">
                            <div id="street-name-line" class="street-name-line" style="display: none;">
                                <span id="street-name-display" class="street-name road-sign-banner"></span>
                            </div>
                            <div class="maneuver-instruction-line">
                                <span id="maneuver-text-display" class="maneuver-text"></span>
                            </div>
                        </div>             
                    </div>
                
                    <div id="maneuver-distance-progress-wrapper">
                        <div id="distance-to-turn-formatted"></div>
                        
                        <div id="distance-progress-bar-to-turn-container">
                            <div id="distance-progress-bar-to-turn"></div>
                        </div>
                    </div>
                 
                    <hr>
                    <div id="route-overall-progress-container">
                         <div id="route-overall-progress">
                             <img id="route-progress-icon" src="PNG/AVANCE.PNG" alt="Avance" style="display:none;">
                             <span id="route-progress-text"></span>
                         </div>
                    </div>
                    <div id="navigation-eta-info">
                        <div id="next-stage-info">
                            <strong id="next-stage-label">Pr√≥xima Etapa</strong>
                            <span id="next-stage-distance">-- km</span> &nbsp; | &nbsp;
                            <span id="next-stage-time">-- min</span> &nbsp; | &nbsp; ETA:
                            <span id="next-stage-eta">--:--</span>
                            <span id="next-stage-eta-deviation" class="eta-deviation"></span>
                        </div>
                        <div id="final-destination-info">
                            <strong> Destino</strong>
                            <span id="final-destination-distance">-- km</span> &nbsp; | &nbsp;
                            <span id="final-destination-time">-- min</span> &nbsp; | &nbsp; ETA:
                            <span id="final-destination-eta">--:--</span>
                            <span id="final-destination-eta-deviation" class="eta-deviation"></span>
                        </div>
                    </div>
                </div>
            </div>
               
        </div>
    </div>
    <div id="ai-route-modal" class="hidden">
        <div class="ai-modal-content">
            <h2>Asistente de Rutas IA</h2>
            <p>Describe la ruta que quieres o lo que buscas (Preferiblemente por voz). 
                Por ejemplo: "Sugiereme los 3 museos m√°s importantes para visitar en Madrid" o "Busca un buen restaurante italiano cerca para cenar".
                Adem√°s puedes preguntar horarios, el tiempo, etc. PREG√öNTALE EN CUALQUIER CASO A LA iA LO QUE PUEDE HACER POR T√ç.</p>
            <div class="ai-modal-buttons">
                <button id="ai-generate-route-button">Generar Sugerencia</button>
                <button id="ai-cancel-button">Cerrar</button>
            </div>
            <textarea id="ai-prompt-input" rows="3" placeholder="Escribe o dicta tu petici√≥n. Puedes mantener una conversaci√≥n y repreguntar..."></textarea>
            <div id="ai-status-area">
            </div>
        </div>
    </div>
</div>

<div id="pin-modal-overlay" class="hidden">
    <div id="pin-modal-content">
        <h2>Introducir Clave de Acceso</h2>
        <div class="modal-top-buttons" style="justify-content: center;">
            <button id="pin-submit-button">Entrar</button>
        </div>
        <label for="pin-input">Clave (4 cifras):</label>
        <input type="password" id="pin-input" maxlength="4" pattern="\d{4}" inputmode="numeric" required>
        <p id="pin-error-message"></p>
    </div>
</div>

<div id="versions-modal-overlay" class="versions-modal-overlay hidden">
    <div class="versions-modal-content">
        <h2>Hist√≥rico de versiones y recomendaciones</h2>
        <div class="modal-top-buttons" style="justify-content: flex-end;">
             <button id="close-versions-modal" style="flex: 0 1 auto; min-width: 120px;">Salir</button>
        </div>
        <pre id="versions-content">Cargando...</pre>
    </div>
</div>

<div id="reorder-stages-modal" class="hidden">
    <h2>Ordenar Etapas de Ruta</h2>
    <div class="modal-top-buttons">
        <button id="confirm-reorder-stages">Aceptar <span class="button-countdown-timer unified-countdown-style"></span></button>
        <button id="cancel-reorder-stages">Cancelar</button>
    </div>
    <p style="font-size: 0.9rem; color: #555; margin-bottom: 1rem;">Arrastra y suelta las etapas para cambiar su orden. Pulsa el aspa (X) para eliminar una etapa.</p>
    <ul id="sortable-stages-list">
    </ul>
</div>

<div id="scroll-toggle" class="scroll-toggle-button" title="Ir al inicio o fin">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M19 12l-7 7-7-7"/></svg>
</div>

<div id="route-concat-choice-modal" class="hidden">
    <h2>EXISTE UN TRAZADO PREVIO</h2>
    <p>¬øQu√© deseas hacer con la nueva ruta?</p>
    <div class="modal-top-buttons">
        <button id="concat-choice-append">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke-width="2.5" stroke="white">
                <path d="M4 12H20" stroke-linecap="round"/>
                <path d="M12 4V20" stroke-linecap="round"/>
                <path d="M8 8C4 8 4 16 8 16" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M16 8C20 8 20 16 16 16" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <span>UNIR AMBAS RUTAS</span>
            <span class="button-countdown-timer unified-countdown-style"></span>
        </button>
        <button id="concat-choice-replace">
            <span class="icon-emoji">üîÑ</span>
            <span>REEMPLAZARLA</span>
        </button>
        <button id="concat-choice-cancel">
            <span class="icon-emoji">‚ùå</span>
            <span>Cancelar</span>
        </button>
    </div>
</div>

<div id="config-modal" class="hidden">
    <div class="modal-top-buttons">
        <h2>Configuraci√≥n y Datos</h2>
        <button id="config-close-modal" style="padding: 0.5rem 1rem; font-size:1rem;">Cerrar</button>
    </div>
    <div class="tab-buttons">
        <button class="config-tab-button active" data-tab-target="#tab-content-usuario">Usuario</button>
        <button class="config-tab-button" data-tab-target="#tab-content-pin">Clave Acceso</button>
        <button class="config-tab-button" data-tab-target="#tab-content-radares">RADARES</button>
        <button class="config-tab-button" data-tab-target="#tab-content-backup-restore">Backup/Restore</button>
        <button class="config-tab-button" data-tab-target="#tab-content-borrar">Borrar Datos</button>
        <button class="config-tab-button" data-tab-target="#tab-content-normas">Normas uso</button>
    </div>
    <div class="tab-contents">
        <div id="tab-content-usuario" class="config-tab-content active">
            <h3>Datos de Usuario y Sincronizaci√≥n</h3>
            <p style="font-size:.9rem;color:#555;margin-bottom:1.5rem;text-align:center;">
                Introduce un nombre de usuario √∫nico para guardar y recuperar tus datos en la nube.
            </p>
            <p style="font-size: .95rem; color: #005A9C; margin-bottom: 1.5rem; text-align: left; background-color: #e6f7ff; padding: 10px; border-radius: 5px; border-left: 5px solid #007bff;">
                <strong>Modo Compa√±ero (M√≥vil):</strong> Para sincronizar datos desde tu m√≥vil, usa tu nombre de usuario seguido de <strong>@MOVIL o M√ìVIL</strong> (ej: `MI_USUARIO@MOVIL`).
                Al iniciar sesi√≥n, se cargar√°n los √öLTIMOS DATOS que el coche haya GUARDADO EN LA NUBE. Cada cambio que hagas en el m√≥vil (crear rutas, etc.) se guardar√° autom√°ticamente en la nube para que est√© disponible en el coche al CARGAR. 
                 -----IMPORTANTE!!!!---- SI QUIERES ENVIAR DATOS DESDE EL M√ìVIL RECUERDA ANTES FORZAR UNA RECARGA DE LA P√ÅGINA EN EL COCHE (debes tener el check activo de copias autom√°ticas) O REALIZAR MANUALMENTE UN BACKUP</p>
            <div class="user-data-grid">
                <div><label for="user-id">* ID Usuario (√önico, no se puede cambiar):</label><input type="text" id="user-id" name="userId" required></div>
                <div><label for="tesla-model">Modelo Tesla:</label><input type="text" id="tesla-model" name="teslaModel"></div>
                <div><label for="tesla-year">A√±o Modelo:</label><input type="number" id="tesla-year" name="teslaYear" min="2012" max="2099"></div>
                <div><label for="tesla-province">Provincia:</label><input type="text" id="tesla-province" name="teslaProvince"></div>
                <div class="checkbox-container">
                    <input type="checkbox" id="allow-dms" name="allowDMs"><label for="allow-dms">Permitir MDs (v√≠a admin)</label>
                    <span id="map-session-status" style="margin-left: 20px; font-size: 0.85em; color: #555;"></span>
                </div>
                
                <div class="checkbox-container" style="border-top: 1px solid #ccc; padding-top: 1rem; margin-top: 1rem;">
                    <input type="checkbox" id="config-auto-backup-on-load" name="autoBackup">
                    <label for="config-auto-backup-on-load">Sincronizar/Hacer copia de seguridad autom√°tica al cargar la p√°gina (en el coche)</label>
                </div>
            </div>
            <div class="user-buttons-container" style="margin-top:1.5rem;">
                <button id="config-save-user-firebase" style="background-color:#16A34A;color:white;">Validar usuario y/o Sincronizar/Guardar en la nube</button>
            </div>
            <p id="config-user-status" class="status-message"></p>
            </div>
         <div id="tab-content-pin" class="config-tab-content">
             <h3>Clave de Acceso (Local)</h3>
             <div class="pin-buttons-container" style="margin-bottom: 1rem;">
                 <button id="config-save-pin" style="background-color:#2563EB;color:white;">Guardar Clave y Preferencias</button>
                 <button id="config-remove-pin" style="background-color:#dc3545;color:white;">Quitar Clave</button>
             </div>
             <p style="font-size: 0.9rem; color: #555; margin-bottom: 1rem;">Establece una clave de 4 cifras para proteger el acceso inicial a la p√°gina</p>
             <div class="pin-config-layout">
                 <div class="pin-input-group">
                     <label for="config-pin-set">Establecer/Cambiar Clave:</label>
                     <input type="password" id="config-pin-set" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="4 cifras">
                 </div>
                 <div class="pin-input-group">
                     <label for="config-pin-confirm">Confirmar Clave:</label>
                     <input type="password" id="config-pin-confirm" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="Repetir 4 cifras">
                 </div>
             </div>
             <div class="checkbox-container" style="margin-top: 1.5rem; border-top: 1px solid #ccc; padding-top: 1rem;">
                <input type="checkbox" id="config-direct-to-nav" name="directToNav">
                <label for="config-direct-to-nav">Entrar directamente al Navegador de rutas</label>
            </div>
            
             <p id="config-pin-status" class="status-message"></p>
         </div>
         <div id="tab-content-radares" class="config-tab-content">
            <h3>Importar / Borrar Radares y Otros POIs</h3>
            <div class="radar-action-buttons" style="margin-bottom: 1rem;">
                <button id="import-radars-button">IMPORTAR RADARES y otros</button>
                <button id="delete-filtered-radars-button">BORRAR CACH√â (seg√∫n filtro)</button>
            </div>
            <p style="font-size:0.85rem; color:#444; margin-bottom:0.5rem;">
                Para <strong>importar</strong>, el filtro de "Palabras Clave" buscar√° coincidencias (OR) en el nombre del POI (ej: provincia, poblaci√≥n, tipo).
                Los filtros de Lat/Lon pueden ser un valor √∫nico (aprox.) o un rango (ej: "<code>40.1 40.5</code>" para buscar entre esas latitudes). Si un filtro est√° vac√≠o, no se aplica.
            </p>
             <p style="font-size:0.85rem; color:#444; margin-bottom:1rem;">
                 Los POIs importados (RADARES) se guardar√°n con un radio de <strong>400 metros</strong> y excluidos de la lista por defecto.
             </p>
            <p style="font-size:0.85rem; color:#444; margin-bottom:1.5rem;">
                Para <strong>borrar</strong>: Si NO se especifica NING√öN filtro, se borrar√°n TODOS los recordatorios de tipo "RADAR" o excluidos de lista. Si se especifica alg√∫n filtro, se borrar√°n los que cumplan TODAS las condiciones activas (Palabras Clave OR, Latitud Y Longitud).
            </p>
            <div class="radar-filter-group">
                <div>
                    <label for="radar-filter-lat">Latitud (valor o "min max"):</label>
                    <input type="text" id="radar-filter-lat" placeholder="Ej: 40.123 o 40.0 40.5">
                </div>
                <div>
                    <label for="radar-filter-lon">Longitud (valor o "min max"):</label>
                    <input type="text" id="radar-filter-lon" placeholder="Ej: -3.567 o -4.0 -3.0">
                </div>
                <div style="grid-column: span 2;">
                    <label for="radar-filter-keywords">Palabras Clave (en nombre POI, separadas por espacio, condici√≥n OR):</label>
                    <input type="text" id="radar-filter-keywords" placeholder="Ej: FIJO CAMUFLADO MADRID">
                </div>
            </div>
            <div class="radar-import-options">
                <input type="checkbox" id="import-extra-radars-checkbox">
                <label for="import-extra-radars-checkbox">Importar tambi√©n radares m√≥viles, sem√°foro, etc (usa ficheros KLM adicionales)</label>
            </div>
             <div id="radar-import-progress-container" style="display:none;">
                 <progress id="radar-import-progress-bar" value="0" max="100"></progress>
                 <p id="radar-import-status" class="status-message"></p>
             </div>
         </div>
        <div id="tab-content-backup-restore" class="config-tab-content">
            <h3>Recuperar Backup / Hacer Copia en la Nube</h3>
            <p style="margin-bottom:1.2rem;">
                Para <strong>Recuperar</strong>, introduce tu ID de usuario y pulsa el bot√≥n naranja.<br>
                Para <strong>Hacer una Copia de Seguridad</strong>, aseg√∫rate de que tu ID est√° introducido en la pesta√±a "Usuario" y pulsa el bot√≥n verde.
            </p>
            
            <div class="user-data-grid" style="grid-template-columns: 1fr auto; align-items: end; gap: 1rem;">
                <div style="grid-column: 1 / 2;">
                    <label for="restore-user-id">ID Usuario a recuperar:</label>
                    <input type="text" id="restore-user-id" placeholder="Tu apodo √∫nico (el que est√° en la pesta√±a usuario)...">
                </div>
                <div style="grid-column: 2 / 3; display: flex; flex-direction: column; gap: 0.5rem;">
                    <button id="config-restore-backup-firebase" style="background-color:#E65100;color:white;width:100%;padding: 0.6rem 1rem;">Recuperar Backup de la nube</button>
                    <button id="config-save-user-firebase-from-backup-tab" style="background-color:#16A34A;color:white;width:100%;padding: 0.6rem 1rem;">Hacer la copia de seguridad en la nube</button>
                </div>
            </div>
            <p id="config-restore-status" class="status-message"></p>
            <hr style="margin: 2rem 0;">
            <h3>Backup/Restore Local (Manual)</h3>
            <p style="font-size:.85rem; color:#555;">Esto es para copias manuales de texto. No interact√∫a con la nube</p>
            <div class="backup-restore-container" style="margin-top:1rem;">
                 <div>
                    <h4>Crear Backup Local</h4>
                     <button id="config-generate-backup" style="background-color:#2563EB;color:white; margin-bottom: 1rem;">Generar C√≥digo</button>
                    <textarea id="config-backup-display" readonly style="display:none;"></textarea>
                    <p id="config-backup-status" class="status-message"></p>
                </div>
                <div>
                    <h4>Restaurar Copia Local</h4>
                    <button id="config-restore-backup" style="background-color:#10B981;color:white; margin-bottom: 1rem;">Restaurar</button>
                    <textarea id="config-restore-input" placeholder="Pega el c√≥digo de backup local aqu√≠..."></textarea>
                </div>
            </div>
        </div>
        
        <div id="tab-content-borrar" class="config-tab-content borrar-container">
            <h3>Borrar Datos Locales</h3>
             <button id="config-restore-grid-button">RESTAURAR EL GRID ORIGINAL DE BOTONES</button>
             <p id="config-restore-grid-status" class="status-message" style="margin-bottom: 1.5rem;"></p>
            <h3 style="border-top: 1px solid #ccc; padding-top: 1.5rem; margin-top:1.5rem;">Acci√≥n Irreversible</h3>
            <button id="config-clear-cache" style="margin-bottom: 0.5rem;">Borrar TODO</button>
            <p>Elimina TODOS los datos locales.</p>
            <p><strong style="color:red;">¬°Sin deshacer!</strong> Ten backup.</p>
        </div>
        <div id="tab-content-normas" class="config-tab-content">
             <h3 style="text-align: center; font-size: 1.4rem; color: #c0392b; margin-bottom: 1rem;">Aviso Importante: Uso de la Aplicaci√≥n de Navegaci√≥n</h3>
             <div style="text-align: left; font-size: 0.95rem; line-height: 1.5; color: #333; max-height: 45vh; overflow-y: auto; padding-right: 10px;">
                 <p>¬°Bienvenido/a a nuestra aplicaci√≥n de navegaci√≥n de rutas para coche! Hemos dise√±ado esta herramienta con la mejor intenci√≥n de ayudarte a planificar tus viajes.</p>
                 <p style="margin-top: 1rem;">Sin embargo, es fundamental que entiendas que el uso de esta aplicaci√≥n es <strong>bajo tu propia y exclusiva responsabilidad</strong>. Al utilizar nuestra web, aceptas plenamente las siguientes condiciones:</p>
                 <ul style="list-style-type: disc; margin-left: 20px; margin-top: 1rem; space-y: 0.5rem;">
                     <li><strong>Responsabilidad del usuario:</strong> Eres el √∫nico/a responsable de la toma de decisiones al volante. Nuestra aplicaci√≥n es una herramienta de apoyo y nunca debe sustituir tu juicio, la observaci√≥n directa de las condiciones de la v√≠a, las se√±ales de tr√°fico o la normativa de circulaci√≥n vigente.</li>
                     <li><strong>Supervisi√≥n constante:</strong> La aplicaci√≥n debe ser utilizada siempre bajo tu supervisi√≥n activa. La informaci√≥n proporcionada (cartograf√≠a, trazados, indicaciones, etc.) puede no estar actualizada en tiempo real o contener imprecisiones. Las condiciones de la carretera, el tr√°fico o las regulaciones pueden cambiar sin previo aviso.</li>
                     <li><strong>Conducci√≥n segura:</strong> Prioriza siempre la seguridad. Evita manipular la aplicaci√≥n mientras conduces y presta toda tu atenci√≥n a la carretera. Detente en un lugar seguro para consultar la ruta si es necesario.</li>
                     <li><strong>Errores y fallos:</strong> Aunque nos esforzamos por ofrecer un servicio fiable, no podemos garantizar que la aplicaci√≥n est√© libre de errores, interrupciones o fallos. No nos hacemos responsables de ning√∫n da√±o, perjuicio o incidente que pueda derivarse del uso o la imposibilidad de uso de esta aplicaci√≥n.</li>
                     <li><strong>Actualizaciones:</strong> Te recomendamos mantener tu navegador y sistema operativo actualizados para el mejor funcionamiento de la aplicaci√≥n, aunque no podemos garantizar la compatibilidad total con todos los dispositivos y versiones.</li>
                 </ul>
                 <p style="margin-top: 1rem;">Al continuar utilizando esta aplicaci√≥n, confirmas que has le√≠do, entendido y aceptado este descargo de responsabilidad. ¬°Disfruta de tu viaje con precauci√≥n!</p>
             </div>
             <div style="text-align: center; margin-top: 1.5rem;">
                 <button id="accept-terms-button" style="background-color:#28a745; color:white; padding: 0.8rem 2rem; font-size: 1.2rem; border-radius: 0.25rem;">Acepto</button>
             </div>
         </div>
    </div>
</div>   
<div id="simulation-modal" class="hidden">
</div>

<div id="simulation-speed-modal" class="hidden">
</div>

<div id="locations-preview-modal" class="hidden">
    <h2 id="locations-preview-title">Ubicaciones (filtrado seg√∫n tabla)</h2>
    <div id="locations-preview-map-container" style="height: calc(100% - 100px); width: 100%;"></div>
    <div class="modal-top-buttons" style="justify-content: center; margin-top: 1rem;">
        <button id="close-locations-preview">Salir</button>
    </div>
</div>

<div id="address-suggestions-modal" class="hidden">
    <h2 id="address-suggestions-title">Sugerencias de Direcci√≥n</h2>
    <ul id="address-suggestions-list"></ul>
    <div class="modal-top-buttons" style="justify-content: flex-end; margin-top: 1rem;">
        <button id="close-address-suggestions-modal" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
    </div>
</div>

<div id="deviation-modal" class="hidden">
</div>

<div id="arrival-stats-modal" class="hidden">
</div>

<div id="intersection-preview-map-window" class="hidden">
    <div id="intersection-preview-map-container"></div>
</div>

<div id="alert-modal-overlay" class="hidden">
    <div id="alert-modal-content">
      </div>
</div>

<div id="proximity-alert-modal" class="hidden">
</div>

<div id="flashing-border-overlay" class="hidden"></div>

<div id="maneuver-flashing-border-overlay" class="hidden"></div>
    
<div id="chat-modal-overlay" class="hidden">
    <div id="chat-modal-content">
        <div id="chat-left-column">
            
            <div id="chat-input-area">
                <div id="chat-permission-warning" class="hidden"></div>
                <textarea id="chat-message-input" rows="4" maxlength="500" placeholder="Escribe un mensaje... (antecede @usuario para mensaje privado, o pulsa en el lateral. Para referirse simplemente n√≥mbralo). Vida de los mensajes 96 horas. En el coche usa los comandos de voz. Elon cree en la humanidad, the White Monkey y yo tambi√©n, ser educad@s."></textarea>
              
                <div id="chat-input-footer">
                    <div id="chat-buttons">
                        <button id="chat-send-button">Enviar</button>
                        <button id="chat-exit-button">Salir</button>
                    </div>
                    <div id="chat-char-counter">500</div>
                </div>
            </div>
            
            <div id="chat-messages-container"></div>
        </div>

        <div id="chat-right-column">
            <div id="chat-users-filter-container">
                <input type="text" id="chat-user-filter-input" placeholder="Filtrar por cualquier dato...">
            </div>
            <div id="chat-users-list"></div>
        </div>
    </div>
</div>
    <div id="route-recovery-overlay" class="hidden">
        <div class="recovery-spinner"></div>
        <p class="recovery-text">Reanudando navegaci√≥n...</p>
    </div>    
    
</div>

<div id="range-calc-modal" class="hidden">
    <div class="range-calc-content">
        <h2>Calculador de Radio de Acci√≥n</h2>
        <div class="modal-body">
            <div class="form-group">
                <label for="rc-capacity">Capacidad Bater√≠a (kWh):</label>
                <input type="number" id="rc-capacity" value="75" step="0.1">
            </div>
            <div class="form-group">
                <label for="rc-charge">% Carga Actual:</label>
                <input type="number" id="rc-charge" value="80" min="0" max="100">
            </div>
            <div class="form-group">
                <label for="rc-consumption">Consumo Medio (Wh/km):</label>
                <input type="number" id="rc-consumption" value="165">
            </div>
            <div class="form-group">
                <label for="rc-reserve">% Reserva en Destino:</label>
                <input type="number" id="rc-reserve" value="10" min="0" max="100">
            </div>
            <div class="form-group checkbox-group">
                <input type="checkbox" id="rc-round-trip">
                <label for="rc-round-trip">Calcular Ida y Vuelta</label>
                <input type="checkbox" id="rc-search-chargers">
                <label for="rc-search-chargers">Buscar Cargadores</label>
            </div>

            <div class="form-group info-text-group" style="grid-column: 1 / -1;">
                <p style="font-size: 0.8rem; color: #8e8e93; text-align: center; margin-top: 0.5rem;">
                    (*) Si tiene una ruta cargada se estima el radio desde la salida, 
                    sino puede indicar el punto de salida de c√°lculo dando una pulsaci√≥n 
                    larga en el mapa (puede pulsar en varios sitios en la misma sesi√≥n, incluso navegando). 
                    El c√°lculo es una estimaci√≥n que tiene en cuenta el desnivel del terreno y clima
                    (temperatura, viento y tipo precipitaci√≥n). 
                </p>
            </div>
        </div>
        <div class="modal-footer">
            <button id="rc-start-calculation">Situar punto y Calcular</button>
            <button id="rc-cancel">Cancelar</button>
        </div>
    </div>
</div>

    
<script>
    
//ofu mapbox
                                                                                                                                                                                                    mapboxgl.accessToken = window.APP_CONFIG.keys.mapbox;                                                                                                   

    
//=======================================================        
    
    const originalToFixed = Number.prototype.toFixed;
    Number.prototype.toFixed = function(digits) {
        if (this === undefined || this === null || isNaN(this)) {
            try {
                throw new Error("Debug toFixed Call");
            } catch (e) {
            }
            return "NaN";
        }
        return originalToFixed.call(this, digits);
    };
 
    const MAP_STYLES = {
        "H√çBRIDO": "mapbox://styles/mapbox/satellite-streets-v12?optimize=true",
        "SAT√âLITE": "mapbox://styles/mapbox/satellite-v9?optimize=true",
        "CALLES_LIGHT": "mapbox://styles/mapbox/standard?optimize=true",
        "CALLES_DARK": "mapbox://styles/boardinggate11/cmgp4njxr000l01sd8spdci26?optimize=true"
    };  
    const MAP_LEGACY_NAME_MAP = {
        "Sat√©lite + Calles": "H√çBRIDO",
        "Sat√©lite Puro": "SAT√âLITE",
        "Mapa Normal": "CALLES_LIGHT"
    };
    
    const MAP_VIEW_MODES = {
        'NORTE': { pitch: 0, bearing: 0, mode: 'static', terrain: false },
        'AVANCE': { pitch: 0, bearing: null, mode: 'heading', terrain: false },
        '3D': { pitch: 62, bearing: null, mode: 'perspective', terrain: false },
        '3D RELIEVE': { pitch: 73, bearing: null, mode: 'relief', terrain: true }
    };
 
    let lerpRatePosition = 0.004;
    let lerpRateRotation = 0.002;
    let lerpRateZoom = 0.0007;

    let personalizationSnapshot = null;

    let markerAnimationState = {
        animationFrameId: null,
        currentLngLat: null,
        targetLngLat: null,
        currentIconRotation: 0,
        targetIconRotation: 0,
        currentMapCenter: null,   
        currentMapBearing: 0,
        targetMapBearing: 0,
        currentMapZoom: 16,      
        targetMapZoom: 16,
        currentMapPitch: 0,      
        targetMapPitch: 0,
        currentMapOffsetX: 0,
        targetMapOffsetX: 0,
        currentMapOffsetY: 0,
        targetMapOffsetY: 0,
        currentMapAltitude: null, 
        targetMapAltitude: null,    
        lastTimestamp: null,
        lastCameraTimestamp: null,  
        lastCompassUpdateTime: 0 
    };
 
    let manualZoomLevelMemory = null;
    let smoothedGpsAltitude = 0;
    const ALTITUDE_HISTORY = [];
    const MAX_ALTITUDE_SAMPLES = 10;

    let nextManeuverStepForPreview = null;
    let isMobileSession = false;
    let processedRemindersCache = [];
    let isCacheDirty = true;
    let deviationCheckIntervalId = null;

    let zoomToggleMemory = null;
    let locateMeCountdownInterval = null;
    let deviationCheckGracePeriodUntil = 0; 
    let wasSimulatingBeforeRecalc = false;
    const MAP_VIEW_OFFSET_X_KEY = 'mapView_offsetX';
    const MAP_VIEW_OFFSET_Y_KEY = 'mapView_offsetY';
    const MAP_VIEW_SHOW_MINIMAP_KEY = 'mapView_showMinimap';
    let mapOffsetX = 0;
    let mapOffsetY = 15;
    let showMinimapPreference = true;
    const MAP_VIEW_PITCH_KEY = 'mapView_pitch';
    let mapPitchValue = 62;

    let lastGpsUpdateTime = 0;
    const maneuverTexts = { 'turn-sharp right': 'Giro brusco a la derecha', 'turn-right': 'Gira a la derecha', 'bear-right': 'Mantente a la derecha', 'turn-sharp left': 'Giro brusco a la izquierda', 'turn-left': 'Gira a la izquierda', 'bear-left': 'Mantente a la izquierda', 'turn-': 'Gira', 'straight-straight': 'Sigue recto', 'straight-': 'Sigue recto', 'roundabout-': 'Entra en la rotonda', 'roundabout turn-': 'Toma la salida de la rotonda', 'rotary-': 'Entra en la glorieta', 'roundabout turn-left': 'En la rotonda, toma la salida hacia la izquierda', 'roundabout turn-right': 'En la rotonda, toma la salida hacia la derecha', 'roundabout turn-straight': 'En la rotonda, sigue recto', 'destination-left': 'Has llegado a tu destino  (a la izquierda)', 'destination-right': 'Has llegado a tu destino (a la derecha)', 'destination-': ' tu destino ', 'depart-': 'Inicia la ruta', 'arrive-left': 'Has llegado a tu destino (a la izquierda)', 'arrive-right': 'Has llegado a tu destino  (a la derecha)', 'arrive-': 'Has llegado a tu destino', 'continue-straight': 'Contin√∫a recto', 'continue-': 'Contin√∫a', 'new name-': 'Contin√∫a por', 'fork-right': 'En la bifurcaci√≥n, mantente a la derecha', 'fork-left': 'En la bifurcaci√≥n, mantente a la izquierda', 'fork-': 'En la bifurcaci√≥n', 'merge-left': 'Incorp√≥rate por la izquierda', 'merge-right': 'Incorp√≥rate por la derecha', 'merge-straight': 'Incorp√≥rate', 'merge-': 'Incorp√≥rate', 'end of road-left': 'Al final de la v√≠a, gira a la izquierda', 'end of road-right': 'Al final de la v√≠a, gira a la derecha', 'end of road-': 'Fin de la v√≠a', 'u turn-left': 'Haz un cambio de sentido (hacia la izquierda)', 'u turn-right': 'Haz un cambio de sentido (hacia la derecha)', 'u turn-': 'Haz un cambio de sentido', 'use lane-': 'Usa el carril indicado', 'notification-': 'Atenci√≥n', 'exit roundabout-': 'Sal de la rotonda', 'exit rotary-': 'Sal de la glorieta', 'off ramp-': 'V√≠a de salida', 'on ramp-': 'Incorporate a la v√≠a de Entrada',};
    let distanceToNextManeuverOSRM = Infinity;
    let mapHeaderButtonsVisible = true;
    
    let autoStartNavModalTimer = null;
    let mapSessionStartTime = null;
    let speedMarkerFeatures = []; 
    let mapPreviousZoomLevelForPDRs = 0;
    const AUTO_ZOOM_MODE_KEY = 'boardinggate_autoZoomMode_v2';
    let isManualZoomActive = false;
    let manualZoomTimeout = null;
    let mapViewMode = 'relief'; 
    let isSimulatingFreeDrive = false; 
    let isFreeDriveActive = false;
    let isFreeDrivePaused = false;
    let freeDriveStats = null;
    let lastDynamicRadarCheck = 0;
    window.radarsCache = null;
    window.radarsSpatialIndex = null;
    let isRadarCacheInitializing = false;
    let lastDisplayedManeuverIcon = null;
    let selectedStageRoutes = new Map();
    let alternativeRoutesCache = new Map();
    let alternativeRouteLayers = [];
    let realtimeSpeedUpdateInterval = null;
    let tripInitialDurationSec = null;
    let tripInitialDistanceMeters = null;
    let mapHeaderAutohideTimer = null;
    let tripInitialOverallEtaTime = null;
    let currentStageInitialExpectedEtaTime = null;
    let accumulatedDeviationMs = 0;
    let minAverageSpeedInTrip = Infinity;
    let maxAverageSpeedInTrip = -Infinity;
    
    let isGraphingActive = false;
    let pdrSearchState = 'initial'; 
    let lastPdrSearchResults = []; 
    let currentChargingPointsOnRoute = [];
 
    let tripStartLocationForStats = null; 
    let stageScrollTimeout;
    let locationsPreviewMap = null;
    let globalModalTimers = {};
    const originalBookmarks = [ { name: "YouTube", url: "https://www.youtube.com" }, { name: "Google", url: "https://www.google.com" }, { name: "GDrive", url: "https://drive.google.com", favicon: "./PNG/IMG_4172.png" }, { name: "GMail", url: "https://mail.google.com/mail/mu/mp/603/#tl/Recibidos", favicon: "./PNG/IMG_4171.png"}, { name: "Google Fotos", url: "https://photos.google.com" }, { name: "iCloud", url: "https://www.icloud.com/"}, { name: "ABRP", url: "https://abetterrouteplanner.com" }, { name: "ElectroMaps", url: "https://map.electromaps.com/es/", favicon: "https://www.google.com/s2/favicons?domain=electromaps.com&sz=64" }, { name: "REVE PdR Espa√±a", url: "https://www.mapareve.es/mapa-puntos-recarga", favicon: "https://www.google.com/s2/favicons?domain=mapareve.es&sz=64" }, { name: "Ver ubicaciones", url: "map-action:openRemindersMapWithNoRadars", favicon: "https://www.google.com/s2/favicons?domain=google.com/maps&sz=64" }, { name: "Google Maps", url: "https://www.google.com/maps/search/electric+vehicle+charging+stations" }, { name: "WhatsApp", url: "https://web.whatsapp.com/" }, { name: "TESSIE", url: "https://dash.tessie.com/signin", favicon: "https://www.google.com/s2/favicons?domain=tessie.com&sz=64" }, { name: "Mis Updates", url: "https://dash.tessie.com/software", favicon: "https://cdn-icons-png.flaticon.com/512/148/148767.png" }, { name: "Olas Updates", url: "https://es.stats.tessie.com/", favicon: "https://cdn-icons-png.flaticon.com/512/5815/5815902.png" }, { name: "NotaTeslaApp", url: "https://www.notateslaapp.com/software-updates/" }, { name: "ENHAUTO", url: "https://www.enhauto.com" }, { name: "MAREAS", url: "https://www.meteogalicia.gal/web/predicion/mareas-e-luas" }, { name: "ELECTROVERSE", url: "https://electroverse.com/es/map", favicon: "https://www.google.com/s2/favicons?domain=electroverse.com&sz=64" }, { name: "ACCIONA", url: "https://www.google.com/maps/search/recarga+Acciona", favicon: "https://www.google.com/s2/favicons?domain=acciona.com&sz=64" }, { name: "IBERDROLA", url: "https://www.google.com/maps/search/recarga+IBERDROLA", favicon: "https://www.google.com/s2/favicons?domain=iberdrola.com&sz=64" }, { name: "WAYLET Repsol", url: "https://www.google.com/maps/search/recarga+REPSOL+Waylet", favicon: "https://www.google.com/s2/favicons?domain=repsol.com&sz=64" }, { name: "ENDESA xWay", url: "https://www.google.com/maps/search/recarga+ENDESA+XWAY", favicon: "https://www.google.com/s2/favicons?domain=endesa.com&sz=64" }, { name: "ZUNDER", url: "https://www.google.com/maps/search/recarga+ZUNDER", favicon: "https://www.google.com/s2/favicons?domain=zunder.com&sz=64" }, { name: "IONITY", url: "https://www.google.com/maps/search/recarga+IONITY", favicon: "https://www.google.com/s2/favicons?domain=ionity.eu&sz=64" }, { name: "WENEA", url: "https://www.google.com/maps/search/recarga+WENEA", favicon: "https://www.google.com/s2/favicons?domain=wenea.com&sz=64" }, { name: "T.ENERGIES", url: "https://www.google.com/maps/search/recarga+TOTAL+ENERGIES", favicon: "https://www.google.com/s2/favicons?domain=totalenergies.com&sz=64" }, { name: "GALP", url: "https://www.google.com/maps/search/recarga+GALP", favicon: "https://www.google.com/s2/favicons?domain=galp.com&sz=64" }, { name: "MIIO", url: "https://miio.com", favicon: "https://www.google.com/s2/favicons?domain=miio.com&sz=64" }, { name: "EVDC", url: "https://evdc.network", favicon: "https://www.google.com/s2/favicons?domain=evdc.network&sz=64" }, { name: "GROK", url: "https://grok.com/?referrer=website" }, { name: "CHATGPT", url: "https://chat.openai.com" }, { name: "CLAUDE", url: "https://claude.ai/new" }, { name: "GEMINI", url: "https://gemini.google.com" }, { name: "NOTEBOOKLM", url: "https://notebooklm.google.com" }, { name: "Bater√≠a", url: "https://docs.google.com/spreadsheets/d/1bLZmgVGTBqg2bS2E45JpORjs9eK2nb05AWXYLLDY-RI/edit?gid=1398548891#gid=1398548891", favicon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='10'/><polyline points='12 6 12 12 16 14'/></svg>" }, { name: "TeslaParaTodos", url: "https://teslaparatodos.com/cine/" }, { name: "BetterTheater", url: "https://abettertheater.com", favicon: "https://www.google.com/s2/favicons?domain=abettertheater.com&sz=64" }, { name: "Filmin", url: "https://www.filmin.es/catalogo/peliculas" }, { name: "Octopus", url: "https://octopusenergy.es/login" }, { name: "App MCE", url: "https://www.oscarabilleira.com/app-mi-coche-electrico/#ayuda" }, { name: "Patr√≥n Luz", url: "https://docs.google.com/spreadsheets/d/1R7UUZ9i4BAYWAGAX6PQT1WGd12GEZ4Ja/edit?usp=sharing&ouid=108345701896498198132&rtpof=true&sd=true" }, { name: "TradingView", url: "https://es.tradingview.com/chart/t5g9UFG0/" }, { name: "Telegram", url: "https://web.telegram.org/a/" }, { name: "Twitter", url: "https://x.com" }, { name: "Maesal Detailer", url: "https://www.maesaldetailer.es/" }, { name: "Superchargers", url: "https://www.tesla.com/es_es/findus?bounds=45.41107111786193%2C19.27853056943938%2C29.703668286784747%2C-16.64676239931062" }, { name: "TESLA web", url: "https://www.tesla.com/es_es" }, { name: "Manual M3", url: "https://www.tesla.com/ownersmanual/model3/es_es/" }, { name: "de Servicio", url: "https://service.tesla.com/docs/Model3/ServiceManual/2024/es-es/" }, { name: "de Despiece", url: "https://epc.tesla.com/es-MX/catalogs/e0e07c3d-272f-4d06-b8b6-9e92f857e5f3" }, { name: "de Usted Mismo", url: "https://www.tesla.com/es_es/support/do-it-yourself-guides" }, { name: "de Filtro Cabina", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-DB0A1E3C-926E-498C-A2FD-A27B8421A471.html" }, { name: "de M√≥vil remoto", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-53651B16-A2E3-4118-933E-B5F41C74D433.html" }, { name: "Waze (consultas)", url: "https://www.waze.com/es/live-map/", favicon: "https://www.google.com/s2/favicons?domain=waze.com&sz=64" }, { name: "AMAZON", url: "https://www.amazon.es" }, { name: "BIP&DRIVE", url: "https://areaprivada.bipdrive.com/login" }, { name: "ITV Cita", url: "https://www.sycitv.com/es/cita-previa-particulares/", favicon: "https://boardinggate.github.io/Tesla/PNG/itv.png" }, { name: "Deportes", url: "https://www.sofascore.com/es/tenis" }, null, { name: "Jaime Odena", url: "https://www.youtube.com/@Jaimeodena", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Eduardo Arcos", url: "https://www.youtube.com/@earcos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "AutoIngenium", url: "https://www.youtube.com/@AutoIngenium", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Gallego en Munich", url: "https://www.youtube.com/@ungallegoenmunich", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Electromiaumiau", url: "https://www.youtube.com/@electromiaumiau", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Manuel Martos", url: "https://www.youtube.com/@Manuel_Martos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Todos Electricos", url: "https://www.youtube.com/@TodosElectricos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Juan Vidal Haces", url: "https://www.youtube.com/@JuanVidalHaces", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Ruedana", url: "https://www.youtube.com/@ruedana", favicon: "https://www.youtube.com/favicon.ico" }, { name: "STR-600", url: "https://www.youtube.com/@STR-600", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Juanjo T. Aventuras", url: "https://www.youtube.com/@juanjoteslaventuras", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Carlos Cuezva", url: "https://www.youtube.com/@CarlosCuezva", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Javi Manzanoo", url: "https://www.youtube.com/@javimanzanoo", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Crifedi", url: "https://www.youtube.com/@Crifedi", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Tescno Tesla", url: "https://www.youtube.com/@TecnoTesla", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Full Electric Mex", url: "https://www.youtube.com/@FullElectricMexico", favicon: "https://www.youtube.com/favicon.ico" }, null, null, { name: "La iA Jon", url: "https://www.youtube.com/@la_inteligencia_artificial", favicon: "https://www.youtube.com/favicon.ico" }, { name: "JF Ccalero", url: "https://www.youtube.com/@jfcalero", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Visual Politik", url: "https://www.youtube.com/@VisualPolitik", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Fabian Barrio", url: "https://www.youtube.com/@fabiancbarrio", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Loquetudigas", url: "https://www.youtube.com/@Loquetudigas", favicon: "https://www.youtube.com/favicon.ico" }, { name: "David Antunes", url: "https://www.youtube.com/@davidantunesmusic", favicon: "https://www.youtube.com/favicon.ico" }, { name: "TheWildProject", url: "https://www.youtube.com/@TheWildProject", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Estas Tonne", url: "https://www.youtube.com/@Estastonne", favicon: "https://www.youtube.com/favicon.ico" }, { name: "BBC6 Music", url: "https://www.youtube.com/@BBC6Music", favicon: "https://www.youtube.com/favicon.ico" }, null, null ];
    const originalToggleRanges = [ { start: 18, end: 29, name: "ELECTROVERSE", label: "PdR,s" }, { start: 30, end: 41, name: "GROK", label: "iAs" }, { start: 42, end: 59, name: "TradingView", label: "√ötil" }, { start: 60, end: 95, name: "Jaimeodena", label: "Varios" } ];
    const sectionColors = { 18: '#F0E0D3', 30: '#D8D4E0', 42: '#D9E5DB', 60: '#F2ECD0', unassigned: '#C5C8B8', off: '#ABAB99' };
    const darkModeGenericButtonColor = '#ABAB99';
    const DEFAULT_LOCATION_RADIUS = 450;
    const MAP_SEARCH_INPUT_KEY = 'boardinggate_map_search_value';
    let gpsRetryTimeoutId = null;
    let gpsRetryAttempt = 0;
    const MAX_GPS_RETRIES = 10;
    const GPS_RETRY_DELAY_MS = 5000;
    let isMapImmersiveModeActive = false;
    let isArrivalSequenceStarted = false;
    let maxSpeedCoordinates = null;
    let progressiveZoomState = 'none';
    let lastProcessedStepIdentifier = null;
    const PROGRESSIVE_ZOOM_START_DISTANCE = 180;
    const PROGRESSIVE_ZOOM_PEAK_DISTANCE = 50;
    const PROGRESSIVE_ZOOM_EXIT_START_DISTANCE = 60;
    const PROGRESSIVE_ZOOM_EXIT_END_DISTANCE = 150;
    let isZoomedForManeuver = false;
    let navigationTargetZoom = null;
    let currentSmoothedMapCenter = null;
    let lastMobileSyncTimestamp = 0;
    const TOTAL_CELLS = 96; const COLS = 6; const grid = document.getElementById('bookmark-grid');
    let isDarkMode = false; let pressStartTime = null; let reminderPressStartTime = null; let isActive = true; let isFooterVisible = true; let notices = []; let currentNoticeIndex = 0; let fromReminderModal = false;
    let isEditMode = false; let isAssignmentMode = false;
    let isKeywordAssignmentMode = false;
    let currentlyAssigningToggleStart = null;
    let customData = { bookmarks: {}, toggles: {} };
    let cellElements = []; let toggleButtonElements = {}; let currentBookmarks = []; let currentToggleRanges = [];
    let onOffToggle, weatherButton, reminderButton, zoomButton, darkModeToggle, versionsButton, infoButton;
    let radarButton;
    let firstPersonalizationSession = !sessionStorage.getItem('personalizationHelpShown');
    let editingTargetElement = null; let draggedItem = null; let draggedItemIndex = null; let dragOverIndex = null;
    let touchStartX = 0; let touchStartY = 0; let currentTouchTarget = null;
    let isPasswordActive = false; let storedPin = null;
    
    let reminderCheckIntervalId = null;
    let remindersSpatialIndex = {}; 
    let nonLocationRemindersCache = []; 
    let nextEventHorizon = { 
        timestamp: Infinity, 
        type: null,          
        targetId: null       
    };

    let lastUpdatesCheckDate = localStorage.getItem('lastUpdatesCheckDate');
    let currentNotificationSlideIndex = 0;
    let isUnifiedWindowVisibleByLogic = false;
    let reminderModalMap = null;
    let reminderMarker = null;
    let reminderCircle = null;
    let previewMaps = {};
    const MAX_SAVED_LOCATIONS = 15;
    const SAVED_LOCATIONS_KEY = 'boardinggate_saved_locations';
    const MAP_VIEW_MODE_KEY = 'mapViewMode_v1';
    const SHOW_EXCLUDED_REMINDERS_KEY = 'boardinggate_showExcludedRemindersInTable';
    const RADARES_RUTA_CHECKED_KEY = 'boardinggate_radaresRutaCheckboxChecked';
    const TAREAS_RUTA_CHECKED_KEY = 'boardinggate_tareasRutaCheckboxChecked';
    const ACTIVE_MAP_LAYER_KEY = 'boardinggate_activeMapLayer';
    const DIRECT_TO_NAVIGATION_KEY = 'boardinggate_directToNavigation';
    const MAP_ENTRY_OVERRIDE_KEY = 'boardinggate_map_entry_override';
    const TEMP_PREVENT_DIRECT_NAV_KEY = 'tempPreventDirectNavAfterMapExit';
    const GRAPH_STATE_KEY = 'boardinggate_graphState';
    let locationPickerMap = null;
    let locationPickerMarker = null;
    let currentEditingLocationSlotIndex = -1;
    let tempSavedLocations = [];
    let navigationMapInstance = null;
    let isNavigationMapActive = false;
    let initialUserLocationMarkerLat = null;
    let initialUserLocationMarkerLng = null;
    let navigationCurrentLocation = null;
    let locationWatchId = null;
    let shouldCenterOnUser = false;
    let navigationFollowUser = false;
    const MIN_MANEUVER_ZOOM_LEVEL = 17;
    let currentMapBearing = 0;
    let compassAndModeControl = null;
    let navigationWaypoints = [];
    let navigationRouteLayer = null;
    let navigationCurrentRouteData = null;
    let isNavigating = false;
    let routeStartTime = null;
    let navigationStartTimeForStats = null;
    let totalDistanceTravelledForStats = 0;
    let accumulatedDistanceBeforeCurrentSegment = 0;
    let lastPositionForStats = null;
    let maxDistanceReachedOnRoute = 0; 
    let maxSpeedDuringTrip = 0;
    let maxAltitudeDuringTrip = -Infinity;
    let minAltitudeDuringTrip = Infinity;
    window.lastPositionForSpeedCalc = null;
    window.currentSpeedKmh = 0;
    window.averageSpeedKmh = 0;
    let isSimulatingGpsLocation = false;
    let simulatedGpsLocation = null;
    let automatedSimulationIntervalId = null;
    let simulatedDistanceAlongRoute = 0;
    let simulationSpeedKmph = 85;
    let currentSimulationSpeedKmph = 85; 
    const SIMULATION_TICK_INTERVAL_MS = 80;
    
    const OSRM_SERVICE_URL = 'https://router.project-osrm.org/route/v1';
    const SAVED_ROUTES_KEY = 'boardinggate_saved_routes';
    const MAX_SAVED_ROUTES = 100;
    let currentRouteNameForSaving = null;
    let navigationMapClickHandler = null;
    let draggedStageLi = null;
    const DEVIATION_THRESHOLD_METERS = 17;
    const DEVIATION_MIN_TIME_SECONDS = 0.1;
    let deviationStartTime = 0;
    let isRecalculatingRoute = false;
    let deviationModalTimerId = null;
    let isDeviationModalActive = false;
    const WAYPOINT_VISITED_THRESHOLD_METERS = 70;
    let currentLegIndexNav = 0;
    let currentStepIndexNav = 0;
    let lastCarDistanceAlongRouteForNavLogic = 0;
    let lastValidCarDistanceForDisplay = 0;
    let lastProcessedStepManeuverLocation = null;
    let recalculationRetryTimeoutId = null;
    let recalculationAttempts = 0;
    let isAddReminderAtLocationModeActive = false;
    let addReminderAtLocationButton = null;
    let simulationModalTimer = null;
    let autoStartNavTimer = null;
    let mapLayersControl = null;
    const KML_FILES_LIST_STANDARD = './KLM/KLMFILES.TXT';
    const KML_FILES_LIST_EXTRA = './KLM/KLMFILES2.TXT';
    const KML_BASE_PATH = './KLM/';
    const COORD_EPSILON = 0.00001;
    const RUTA_RADAR_PROXIMITY_THRESHOLD = 10; //antes 75
    let reminderMapObjects = [];
    let radaresEnRutaActual = [];
    let tareasEnRutaActual = [];
    const STATIC_MODAL_IDS = ['config-modal', 'versions-modal-overlay', 'pin-modal-overlay', 'reorder-stages-modal', 'simulation-modal', 'locations-preview-modal', 'deviation-modal', 'arrival-stats-modal', 'simulation-speed-modal'];
    let activeToasts = [];
    let intersectionPreviewMap = null;
    let intersectionPreviewRouteLayer = null;
    let intersectionPreviewManeuverMarker = null;
    let intersectionPreviewCarMarker = null;
    let intersectionPreviewTimer = null;
    let lastAutoShownManeuverId = null;
    let directToNavOnLoad = false;
    let mapLayersControlLocationsPreview = null;
    let navigationChart = null;
    let currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviaci√≥n Ruta';
    let graphPlotState = { lastPlotTime: null, lastPlotCoords: null };
    let graphIntervalDuration = 0; 
    let graphIntervalTimer = null;
    let graphDataPoints = { speed: [], altitude: [] };
    let graphLabels = [];
    let graphExpectedAvgSpeed = 0;
    let maxGraphPoints = 150;
    let isCarStoppedForGraph = false; 
    const GRAPH_PIXELS_PER_DATAPOINT = 2; 
    const GRAPH_BUFFER_PERCENTAGE = 0.15;
    const MAP_FILTER_INPUT_KEY = 'boardinggate_map_filter_value';
    const PROGRESS_BAR_LOCKED_KEY = 'boardinggate_progressBarLocked';
    let isProgressBarLocked = false;
    let progressBarForceShowUntil = 0;
    let lastProcessedStepForLock = null;
    const ARRIVAL_MODAL_THRESHOLD_METERS = 15;
    window.mapCustomControlsInstance = null;
    window.offsetXBeforeManeuver = null;
    window.offsetYBeforeManeuver = null;
    window.maneuverHorizontalTarget = 0;

    const _turfLastPoint = turf.point([0, 0]);
    const _turfCurrentPoint = turf.point([0, 0]);
    
    const PERFORMANCE_RATIO_ROUTE_KEY = 'perf_ratio_route';
    const PERFORMANCE_RATIO_ALERTS_KEY = 'perf_ratio_alerts';
    const PERFORMANCE_RATIO_STATS_KEY = 'perf_ratio_stats';
    const PERFORMANCE_RATIO_GRAPH_KEY = 'perf_ratio_graph';
    const PERFORMANCE_RATIO_CRITICAL_KEY = 'perf_ratio_critical';
    
    let performanceRatios = {
    criticalUpdate: 3,
    routeProgress: 20,
    trafficAlerts: 350,
    tripStats: 50,
    performanceGraph: 75};

    let baseCameraFps = 18;
    let baseCriticalRatio = 3;
    
    let gpsTickCounter = 0;
    let gpsHzMonitor = {
        ticks: 0,
        interval: null
    };

    let trafficAlertsCache = [];
    let lastAlertCheckTimestamp = 0;
    const ALERT_CHECK_INTERVAL = 15 * 60 * 1000;
    let currentlyDisplayedProximityAlerts = new Set();
    let alertModalTimer = null;
    let proximityAlertTimer = null;

    let trafficAlertsSpatialIndex = {};
    let alertRefreshInterval = null; 
    let lastAlertCleanupTimestamp = 0; 

    const LERP_RATE_POS_KEY = 'boardinggate_lerp_rate_position';
    const LERP_RATE_ROT_KEY = 'boardinggate_lerp_rate_rotation';
    const LERP_RATE_ZOOM_KEY = 'boardinggate_lerp_rate_zoom';

    let chatUpdateInterval = null;
    let lastVisibleUserDoc = null; 
    let lastVisibleMessageDoc = null; 
    let isFetchingUsers = false; 
    let isFetchingMessages = false; 
   
    const vehicleIconElement = document.createElement('div');
    vehicleIconElement.className = 'vehicle-icon-mapbox-container';
    vehicleIconElement.innerHTML = `<div class="vehicle-icon-wrapper"><img src="PNG/AVANCE.PNG" alt="Coche"><div class="vehicle-maneuver-overlay"></div></div>`;  
    let groundAnchorMarker = null;
    
    
    let eventosEnRuta = []; 
    let proximoEventoEnRutaIndex = 0; 
    const GPS_BASE_FREQUENCY_HZ = 10; 

    let lastMapUpdateTime = 0;
    let MAP_UPDATE_INTERVAL_MS = 13; 
    let originalMapUpdateIntervalMs = 13; 
    const PERFORMANCE_CAMERA_FPS_KEY = 'boardinggate_camera_fps'; 

    let originalTripEtaTime = null;   
    let isFlying = false;
 
    const MAP_TERRAIN_EXAGGERATION_KEY = 'boardinggate_mapTerrainExaggeration'; 
    let mapTerrainExaggeration = 0.5; 
    let aiConversationHistory = []; 
    let initialUserLocationMarker = null;

    let areEcoLabelsHidden = false;
    
    let layerVisibilityBeforeEco = {}; 
    let currentVisibilityProfile = 'full';
    const LAYER_VISIBILITY_KEY = 'boardinggate_map_layer_visibility';

    const LAYER_VISIBILITY_GROUPS = {
    poblaciones: {
        label: 'Poblaciones',
        layers: ['settlement-major-label', 'settlement-minor-label', 'settlement-subdivision-label']
    },
    pois: {
        label: 'Negocios/POIs',
        layers: ['poi-label', 'transit-label', 'airport-label']
    },
    carreteras: {
        label: 'Carreteras/Calles',
        layers: ['road-label']
    },
    geografia: {
        label: 'Geograf√≠a/Natural',
        layers: ['natural-label', 'water-point-label', 'water-line-label', 'waterway-label']
    },
    };

        
    const navigationTasks = {
        CRITICAL_VISUALS: {
            id: 'CRITICAL_VISUALS',
            handler: (coords, map) => {
                updateVehicleMarker(coords, map);
                if (!markerAnimationState.animationFrameId) {
                    markerAnimationState.animationFrameId = requestAnimationFrame(animateMarkerAndMap);
                }
            },
            getFrequency: () => {
                if (isNavigating && distanceToNextManeuverOSRM < 310) {
                    return 0; 
                }
                return (performanceRatios.criticalUpdate / GPS_BASE_FREQUENCY_HZ) * 1000;
            },
            priority: 1,
            lastRun: 0
        },
        ROUTE_PROGRESS: {
            id: 'ROUTE_PROGRESS',
            handler: (coords, map) => { if (isNavigating) processRouteProgress(coords, map); },
            getFrequency: () => {
                const baseIntervalMs = (performanceRatios.routeProgress / GPS_BASE_FREQUENCY_HZ) * 1000;
                
                if (distanceToNextManeuverOSRM < 310) {
                    return baseIntervalMs / 4;
                } else {
                    return baseIntervalMs;
                }
            },
            priority: 2,
            lastRun: 0
        },
        UPDATE_CAMERA_ALTITUDE: {
            id: 'UPDATE_CAMERA_ALTITUDE',
            handler: (coords, map) => {
                const currentMode = mapViewMode || localStorage.getItem(MAP_VIEW_MODE_KEY) || 'relief';
                if (currentMode !== 'relief' && currentMode !== 'perspective') {
                    markerAnimationState.targetMapAltitude = null; 
                    return; 
                }
        
                const terrainElevation = map.queryTerrainElevation({ lng: coords.longitude, lat: coords.latitude });
                const baseAltitude = terrainElevation !== null ? terrainElevation : smoothedGpsAltitude;
                const cameraAltitudeOffset = 150; 
                markerAnimationState.targetMapAltitude = baseAltitude + cameraAltitudeOffset;
            },
            getFrequency: () => 3500,
            priority: 2.5,
            lastRun: 0
        }, 
        TRIP_STATS: {
            id: 'TRIP_STATS',
            handler: (coords, map) => updateTripStatistics(coords),
            getFrequency: () => {
                const baseIntervalMs = (performanceRatios.tripStats / GPS_BASE_FREQUENCY_HZ) * 1000;
                
                if (distanceToNextManeuverOSRM < 310) {
                    return baseIntervalMs / 2;
                } else {
                    return baseIntervalMs;
                }
            },
            priority: 3,
            lastRun: 0
        },
        PERFORMANCE_GRAPH: {
            id: 'PERFORMANCE_GRAPH',
            handler: (coords, map) => plotIntervalData(),
            getFrequency: () => (performanceRatios.performanceGraph / GPS_BASE_FREQUENCY_HZ) * 1000,
            priority: 4,
            lastRun: 0
        },
        TRAFFIC_ALERTS: {
            id: 'TRAFFIC_ALERTS',
            handler: (coords, map) => checkAlertsProximity(),
            getFrequency: () => (performanceRatios.trafficAlerts / GPS_BASE_FREQUENCY_HZ) * 1000,
            priority: 5,
            lastRun: 0
        }
    };
 
     const TASKS_BY_PRIORITY = Object.values(navigationTasks)
        .sort((a, b) => a.priority - b.priority);
    
    let announceManeuverWithFlash = true; 
    let maneuverFlashTriggeredId = null; 
    let lastAutoBackupTimestamp = 0;

    let isPoiSearchActive = false;
    let poiSearchResultMarkers = [];
    let isPitchManuallyFlattened = false; 
    let previousLegIndexForEta = 0; 
    const _turfCarPointForAnimation = turf.point([0, 0]);

    let isPerformingControlledReload = false;
    let memoryReloadThreshold = 0.25; 
    let mapPreviousZoomLevelForProgressive = null;
    let lastKnownAverageAltitude = null;
    let currentAutoZoomMode = 'eco';
    let compassForceShowUntil = 0; 

    let showRouteMinimapPreference = true; 
    const SHOW_ROUTE_MINIMAP_KEY = 'boardinggate_showRouteMinimap';

    let minimapInstance = null;
    let minimapCarMarker = null;
    let memoryCheckGracePeriodUntil = 0;
    let isAddingWaypointsDuringNav = false;
    let minimapForceShowUntil = 0;

    let isRangeCalcModeActive = false;
    let longPressTimer = null;
    let currentRangeCalcParams = {};
    let deviationCheckTimerId = null;
    let isHighAlertMode = false;
    let highAlertTimeoutId = null;
    let weatherUpdateTimer = null;
    let lastWeatherCoords = { lat: 0, lon: 0 };
    let weatherHideTimer = null; 
    let weatherWidgetForceShowUntil = 0;
    let isConcatenatingRoute = false;
    let autoStartFreeDriveDisabledUntil = 0; 
    
    const easeInOutQuad = t => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
   
    const managedKeys = [ 
        'reminders','darkMode','toggleStates','zoomState','onOffState','noticesActive', 
        'footerVisible','teslaHtmlLastModified','teslaHtmlLastModifiedTimestamp', 
        'userData_userId','userData_teslaModel','userData_teslaYear','userData_teslaProvince', 
        'userData_allowDMs', 'customGridData', 'personalizationHelpShown', 'gridFilterValue',  
        'password_pin', 'password_active', 'lastUpdatesCheckDate', SAVED_LOCATIONS_KEY,  
        SHOW_EXCLUDED_REMINDERS_KEY, SAVED_ROUTES_KEY, 'boardinggate_recent_routes', 
        RADARES_RUTA_CHECKED_KEY,  TAREAS_RUTA_CHECKED_KEY, ACTIVE_MAP_LAYER_KEY, 
        DIRECT_TO_NAVIGATION_KEY, GRAPH_STATE_KEY, 'boardinggate_autoBackupOnLoad', 
        'userData_backupPassword', MAP_SEARCH_INPUT_KEY, 'mapViewMode_v1', MAP_FILTER_INPUT_KEY, 
        PROGRESS_BAR_LOCKED_KEY,  MAP_VIEW_OFFSET_X_KEY,MAP_VIEW_OFFSET_Y_KEY,  
        MAP_VIEW_SHOW_MINIMAP_KEY, MAP_VIEW_PITCH_KEY, PERFORMANCE_RATIO_CRITICAL_KEY, 
        PERFORMANCE_RATIO_ROUTE_KEY, PERFORMANCE_RATIO_ALERTS_KEY, 
        PERFORMANCE_RATIO_STATS_KEY, PERFORMANCE_RATIO_GRAPH_KEY,
        'boardinggate_map_saturation', 'boardinggate_map_contrast', 
        LERP_RATE_POS_KEY, LERP_RATE_ROT_KEY, LERP_RATE_ZOOM_KEY,
        PERFORMANCE_CAMERA_FPS_KEY, MAP_TERRAIN_EXAGGERATION_KEY, 
        'boardinggate_announce_maneuver_flash', 
        'boardinggate_dynamicRadarRadius',
        'boardinggate_memory_threshold',
        SHOW_ROUTE_MINIMAP_KEY
     ];

    const managedDesc = managedKeys.map(k => {
        switch(k){
            case 'reminders':return 'Recordatorios'; case 'darkMode':return 'Modo Oscuro'; case 'toggleStates':return 'Visibilidad Secc.';
            case 'zoomState':return 'Zoom Grid'; case 'onOffState':return 'On/Off Gral'; case 'noticesActive':return 'Avisos/Footer';
            case 'footerVisible':return 'Vis. Footer'; case 'teslaHtmlLastModified':return 'Cache Versi√≥n'; case 'teslaHtmlLastModifiedTimestamp':return 'TS Cache';
            case 'userData_userId':return 'ID Usuario'; case 'userData_teslaModel':return 'Modelo'; case 'userData_teslaYear':return 'A√±o';
            case 'userData_teslaProvince':return 'Provincia'; case 'userData_allowDMs':return 'Permitir DMs'; case 'customGridData': return 'Grid Pers.';
            case 'personalizationHelpShown': return 'Ayuda Pers. Vista'; case 'gridFilterValue': return 'Filtro Grid';
            case 'password_pin': return 'PIN Acceso'; case 'password_active': return 'PIN Activo'; case 'lastUpdatesCheckDate': return 'Cache Fecha Updates';
            case SAVED_LOCATIONS_KEY: return 'Ubicaciones Guardadas';
            case SHOW_EXCLUDED_REMINDERS_KEY: return 'Mostrar Excluidos Tabla';
            case SAVED_ROUTES_KEY: return 'Rutas Guardadas';
            case 'boardinggate_recent_routes': return 'Rutas Recientes';
            case RADARES_RUTA_CHECKED_KEY: return 'Check Radares Ruta';
            case TAREAS_RUTA_CHECKED_KEY: return 'Check Tareas Ruta';
            case ACTIVE_MAP_LAYER_KEY: return 'Capa de Mapa Activa';
            case DIRECT_TO_NAVIGATION_KEY: return 'Directo a Navegaci√≥n';
            case GRAPH_STATE_KEY: return 'Estado Gr√°fica';
            case MAP_SEARCH_INPUT_KEY: return 'Buscador Mapa (Principal)';
            case MAP_FILTER_INPUT_KEY: return 'Buscador Mapa (Filtro)';
            case PERFORMANCE_RATIO_CRITICAL_KEY: return 'Ratio Cr√≠ticos';
            case PERFORMANCE_RATIO_ROUTE_KEY: return 'Ratio Progreso Ruta';
            case PERFORMANCE_RATIO_ALERTS_KEY: return 'Ratio Alertas';
            case PERFORMANCE_RATIO_STATS_KEY: return 'Ratio Estad√≠sticas';
            case PERFORMANCE_RATIO_GRAPH_KEY: return 'Ratio Gr√°fica';
            case 'boardinggate_map_saturation': return 'Saturaci√≥n Mapa';
            case 'boardinggate_map_contrast': return 'Contraste Mapa';
            case LERP_RATE_POS_KEY: return 'Suavizado Posici√≥n';
            case LERP_RATE_ROT_KEY: return 'Suavizado Rotaci√≥n';
            case LERP_RATE_ZOOM_KEY: return 'Suavizado Zoom';
            case PERFORMANCE_CAMERA_FPS_KEY: return 'FPS Animaci√≥n C√°mara';  
            case MAP_TERRAIN_EXAGGERATION_KEY: return 'Exageraci√≥n 3D';  
            case 'boardinggate_announce_maneuver_flash': return 'Anunciar Maniobra Destello'; 
            case 'boardinggate_dynamicRadarRadius': return 'Radio Radares Din√°micos'; 
            case 'boardinggate_memory_threshold': return 'Umbral Recarga Memoria';    
            default:return k;
        }
    }).join(', ');   



// ===================================================================
// NOMBRE: add3DBuildingsLayer (VERSI√ìN CORREGIDA Y ROBUSTA CON COALESCE)
// RESUMEN: A√±ade la capa 3D con expresiones a prueba de fallos para garantizar la visibilidad en todos los zooms.
async function add3DBuildingsLayer(mapInstance) {
    if (!mapInstance || !mapInstance.isStyleLoaded()) {
        return;
    }

    const layerId = '3d-buildings';
    if (mapInstance.getLayer(layerId)) {
        try { mapInstance.removeLayer(layerId); } catch (e) {}
    }

    if (!mapInstance.getSource('composite')) {
        return; // El estilo actual no tiene datos de edificios.
    }
    
    const layers = mapInstance.getStyle().layers;
    let firstSymbolId;
    for (const layer of layers) {
        if (layer.type === 'symbol') {
            firstSymbolId = layer.id;
            break;
        }
    }

    try {
        mapInstance.addLayer({
            'id': layerId,
            'source': 'composite',
            'source-layer': 'building',
            'filter': ['==', 'extrude', 'true'],
            'type': 'fill-extrusion',
            'minzoom': 14,
            'paint': {
                'fill-extrusion-color': [
                    'interpolate', ['linear'], ['coalesce', ['get', 'height'], 0], 
                     0, '#fcc2a4',
                    20, '#fcc2a4',
                    40, '#f3a070',
                    60, '#ef8f56',
                    120, '#ea7e3c',
                    150, '#e66d22',
                ],   
                
                'fill-extrusion-height': [
                    'interpolate', ['linear'], ['zoom'],
                    14, 0,
                    15, ['*', ['coalesce', ['get', 'height'], 0], 1], 
                    18.2, ['*', ['coalesce', ['get', 'height'], 0], 0.85],
                    18.5, ['*', ['coalesce', ['get', 'height'], 0], 0.30] 
                ],

                // 3. Base del edificio (Ya era robusto, no necesita cambios)
                'fill-extrusion-base': ['get', 'min_height'],
                
                // 4. Opacidad din√°mica (No depende de 'height', no necesita cambios)
                'fill-extrusion-opacity': [
                    'interpolate', ['linear'], ['zoom'],
                    15, 1,
                    18.2, 0.85,
                    18.5, 0
                ]
            }
        }, firstSymbolId);
    } catch (error) {
        console.error("Error al a√±adir la capa de edificios 3D:", error);
    }
}

// ===================================================================
// NOMBRE: showReferralsModal
// RESUMEN: Muestra el modal de referidos y afiliados.
function showReferralsModal() {
    closeOtherModals('referrals-modal');

    const modal = document.createElement('div');
    modal.id = 'referrals-modal';
    modal.className = 'referrals-modal-overlay';

    const amazonAffiliateTag = 'comprandoenamazon-21';
    
    const amazonItems = [
        { label: 'Accesorios para Model 3', query: 'accesorios tesla model 3' },
        { label: 'Accesorios para Model Y', query: 'accesorios tesla model y' },
        { label: 'Accesorios para Model S', query: 'accesorios tesla model s' },
        { label: 'Accesorios para Model X', query: 'accesorios tesla model x' },
        { label: '20 Accesorios Imprescindibles', query: 'accesorios imprescindibles tesla' },
        { label: 'Cargadores para M√≥vil Tesla', query: 'cargador inalambrico tesla' },
        { label: 'Alfombrillas y Almacenamiento', query: 'alfombrillas y organizador tesla' },
        { label: 'Protectores de Pantalla', query: 'protector pantalla tesla' },
        { label: 'Productos de Detailing', query: 'productos limpieza coche detailing' },
        { label: 'Los + Vendidos de Amazon', url: 'https://www.amazon.es/gp/bestsellers' }
    ];

    // L√≥gica que construye los enlaces din√°micamente
    let amazonLinksHtml = amazonItems.map(item => {
        let finalUrl = '';
        if (item.query) {
            finalUrl = `https://www.amazon.es/s?k=${encodeURIComponent(item.query)}&tag=${amazonAffiliateTag}`;
        } else if (item.url) {
            finalUrl = `${item.url}?tag=${amazonAffiliateTag}`;
        }

        return `
            <a href="${finalUrl}" target="_blank" class="referral-button amazon">
                <img src="https://www.google.com/s2/favicons?domain=amazon.es&sz=64" alt="Amazon">
                <span>${item.label}</span>
            </a>
        `;
    }).join('');

    modal.innerHTML = `
        <style>
            .referrals-modal-overlay {
                position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.9);
                backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
                z-index: 8000; display: flex; justify-content: center; align-items: center;
                padding: 20px;
            }
            .referrals-modal-content {
                background-color: #2c2c2e; color: #f0f0f0; border-radius: 14px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5); border: 1px solid #444;
                width: 90vw; height: 97vh; max-width: 1160px;
                display: flex; flex-direction: column; overflow: hidden;
            }
            .referrals-header {
                height: 120px;
                background-image: url('PNG/store.png');
                background-size: contain; background-repeat: no-repeat;
                background-position: center; position: relative;
                padding: 1.5rem; display: flex; align-items: flex-end;
            }
            .referrals-header::before {
                content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
                background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.3) 60%, rgba(0,0,0,0) 100%);
            }
            .referrals-title {
                font-size: 1.8rem; font-weight: bold; color: white;
                text-shadow: 2px 2px 5px rgba(0,0,0,0.8);
                position: relative; z-index: 1;
            }
            .referrals-body {
                padding: 1.5rem; flex-grow: 1; overflow-y: auto;
            }
            .referrals-section { margin-bottom: 2rem; }
            .referrals-section h3 {
                font-size: 1.3rem; font-weight: bold; color: #007aff;
                margin-bottom: 1rem; padding-bottom: 0.5rem;
                border-bottom: 1px solid #444;
            }
            .referral-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 1rem;
            }
            .referral-button {
                display: flex; align-items: center; gap: 15px;
                padding: 15px; background-color: #3a3a3c;
                border: 1px solid #555; border-radius: 8px;
                text-decoration: none; color: #f0f0f0;
                font-size: 1.1rem; font-weight: 500;
                transition: background-color 0.2s, transform 0.1s;
                cursor: pointer; width: 100%;
            }
            .referral-button:hover { background-color: #4a4a4c; transform: translateY(-2px); }
            .referral-button img { width: 32px; height: 32px; flex-shrink: 0; }
            .referral-button.amazon img { border-radius: 4px; }
            .referrals-footer {
                padding: 1rem 1.5rem; border-top: 1px solid #444;
                background-color: #1c1c1e; display: flex; justify-content: flex-end;
            }
            .referrals-footer button {
                background-color: #555; color: white; padding: 12px 25px;
                font-size: 1.1rem; font-weight: bold; border-radius: 8px;
                border: none; cursor: pointer;
            }
        </style>
        <div class="referrals-modal-content">
            <div class="referrals-header">
                <h2 class="referrals-title">Apoya el Proyecto</h2>
            </div>
            <div class="referrals-body">
                <div class="referrals-section">
                    <h3>Mis Referidos</h3>
                    <div class="referral-grid">
                        <a href="https://t.co/7wMG2AOk10" target="_blank" class="referral-button">
                            <img src="https://www.google.com/s2/favicons?domain=octopusenergy.es&sz=64" alt="Octopus Energy">
                            <span>Contrato de Luz (Octopus)</span>
                        </a>
                        <a href="https://ts.la/juancarlos162231" target="_blank" class="referral-button">
                            <img src="https://www.google.com/s2/favicons?domain=tesla.com&sz=64" alt="Tesla">
                            <span>Comprar un Tesla</span>
                        </a>
                        <a href="https://share.tessie.com/JDukqlINZMb" target="_blank" class="referral-button">
                            <img src="https://www.google.com/s2/favicons?domain=tessie.com&sz=64" alt="Tessie">
                            <span>App Tessie</span>
                        </a>
                        <button onclick="copyBizumNumber()" class="referral-button">
                            <img src="https://www.google.com/s2/favicons?domain=bizum.es&sz=64" alt="Bizum">
                            <span>Apoya con un Bizum</span>
                        </button>
                    </div>
                </div>
                <div class="referrals-section">
                    <h3>Accesorios en Amazon</h3>
                    <p style="font-size: 0.9rem; color: #b0b0b0; margin-bottom: 1rem;">
                        Al comprar a trav√©s de estos enlaces, me ayudas a mantener y mejorar esta aplicaci√≥n sin coste para ti. ¬°Gracias por tu apoyo!
                    </p>
                    
                    <p style="background-color: rgba(255, 229, 100, 0.15); border: 1px solid #FFD700; color: #FFD700; padding: 0.75rem; border-radius: 8px; margin: 1rem 0; font-size: 0.95rem; font-weight: 500; text-align: center;">
                        Recuerda que esta web es accesible desde cualquier dispositivo (PC, m√≥vil, tablet). ¬°Puede que te resulte m√°s c√≥modo usar estos enlaces desde all√≠!
                    </p>
               
                    <div class="referral-grid">
                        ${amazonLinksHtml}
                    </div>
                </div>
            </div>
            <div class="referrals-footer">
                <button id="close-referrals-modal">Cerrar</button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    const closeButton = modal.querySelector('#close-referrals-modal');
    const closeHandler = () => {
        if (modal.parentNode) modal.remove();
    };
    closeButton.addEventListener('click', closeHandler);
}

    

function copyBizumNumber() {
    const bizumNumber = '639083773'; // Tu n√∫mero de tel√©fono real
    const message = `Para apoyar el proyecto a trav√©s de Bizum, puedes enviar tu donaci√≥n al siguiente n√∫mero:\n\n${bizumNumber}\n\nGracias por tu apoyo.`;
    
    alert(message);
}
    
// ===================================================================
// NOMBRE: setMapLighting 
// RESUMEN: Configura la iluminaci√≥n para proyectar sombras m√°s definidas y realistas.
function setMapLighting(mapInstance) {
    if (!mapInstance || !mapInstance.isStyleLoaded()) {
        return;
    }

    try {
        mapInstance.setLight({
            anchor: 'map', // La luz se mueve con el mapa
            position: [
                1.5,  // Distancia radial
                210,  // √Ångulo azimutal (desde el Suroeste)
                35    // √Ångulo polar (sol m√°s bajo para sombras largas)
            ],
            color: '#d9d9c7', // Color de luz c√°lido
            intensity: 0.8   // Intensidad aumentada para sombras m√°s oscuras
        });
    } catch (error) {
        console.error("Error al configurar la iluminaci√≥n del mapa:", error);
    }
}
// NOMBRE: showWeatherWidgetTemporarily
// RESUMEN: Muestra el widget del clima bajo demanda, usando la ubicaci√≥n actual.
function showWeatherWidgetTemporarily() {
    if (navigationCurrentLocation) {
        weatherWidgetForceShowUntil = Date.now() + 30000; // Forzar visibilidad por 30s
        updateWeatherWidget(navigationCurrentLocation.latitude, navigationCurrentLocation.longitude);
    } else {
        showToast("Ubicaci√≥n no disponible para mostrar el tiempo.", "warning");
    }
}
    
// ===================================================================
// NOMBRE: processWeatherData (CON FALLBACK MEJORADO)
// RESUMEN: Procesa la respuesta de la API. Si el c√≥digo de clima actual falta,
function processWeatherData(data) {
    if (!data || !data.current_condition || !data.weather) {
        return null; 
    }
    const current = data.current_condition[0];

    // L√ìGICA DE FALLBACK MEJORADA: Si no hay c√≥digo de clima v√°lido, busca el siguiente.
    const isCodeInvalid = !current.weatherCode || current.weatherCode === "0" || isNaN(parseInt(current.weatherCode, 10));
    if (isCodeInvalid) {
        try {
            const now = new Date();
            const currentHourBlock = now.getHours() * 100;
            if (data.weather[0] && data.weather[0].hourly) {
                // Busca el primer pron√≥stico futuro que tenga un c√≥digo v√°lido.
                const nextHourForecast = data.weather[0].hourly.find(h => parseInt(h.time, 10) >= currentHourBlock && h.weatherCode && h.weatherCode !== "0" && !isNaN(parseInt(h.weatherCode, 10)));
                if (nextHourForecast && nextHourForecast.weatherCode) {
                    current.weatherCode = nextHourForecast.weatherCode; // Usamos el c√≥digo de la pr√≥xima hora
                }
            }
        } catch (e) {
            console.warn("No se pudo encontrar un weatherCode de fallback.");
        }
    }

    const temp = Math.round(parseFloat(current.temp_C));
    const feelsLike = Math.round(parseFloat(current.FeelsLikeC));
    const emoji = getWeatherEmoji(current.weatherCode);
    const humidity = current.humidity;
    const windSpeed = current.windspeedKmph;
    const windDirDegrees = current.winddirDegree;
    const precipMM = parseFloat(current.precipMM);
    let chanceOfRain = '0';
    const now = new Date();
    const currentHourValue = now.getHours() * 100;
    if (data.weather && data.weather[0] && data.weather[0].hourly) {
        const currentHourForecast = data.weather[0].hourly.find(h => parseInt(h.time, 10) === currentHourValue);
        if (currentHourForecast && currentHourForecast.chanceofrain) {
            chanceOfRain = currentHourForecast.chanceofrain;
        }
    }
    let locationName = "Ubicaci√≥n Desconocida";
    if (data.nearest_area && data.nearest_area[0] && data.nearest_area[0].areaName && data.nearest_area[0].areaName[0]) {
        locationName = data.nearest_area[0].areaName[0].value;
    }
    return {
        current: { temp, feelsLike, emoji, humidity, windSpeed, windDirDegrees, precipMM, chanceOfRain, weatherCode: current.weatherCode },
        locationName: locationName,
        daily: data.weather
    };
}
    
// ===================================================================
// NOMBRE: getWeatherEmoji (Versi√≥n final que restaura las clases CSS)
// RESUMEN: A√±ade la clase correcta al span para que el CSS pueda aplicar el tama√±o.
function getWeatherEmoji(weatherCode, hour = null) {
    const baseUrl = 'https://cdn.jsdelivr.net/gh/basmilius/weather-icons@dev/production/fill/svg/';
    
    // Esta funci√≥n interna ahora recibe la clase CSS que debe aplicar
    const createIcon = (filenames, altText = 'Clima', iconClass) => {
        const files = Array.isArray(filenames) ? filenames : [filenames];
        const images = files.map(file => 
            `<img src="${baseUrl}${file}" alt="${altText}" style="margin: 0 -0.4em;">`
        ).join('');
        return `<span class="${iconClass}">${images}</span>`;
    };
    
    const code = parseInt(weatherCode, 10);
    
    const isMainIcon = arguments.length > 2 && typeof arguments[2] === 'string' && parseFloat(arguments[2]) > 3;
    const finalIconClass = isMainIcon ? 'weather-icon' : 'forecast-icon';

    if (isNaN(code)) {
        return createIcon('compass.svg', 'Determinando clima', finalIconClass);
    }
    const isNight = (hour !== null) ? (hour >= 2000 || hour < 600) : false;
    const ICON_CHOICES = {
        113: isNight ? 'clear-night.svg' : 'clear-day.svg',
        116: isNight ? 'partly-cloudy-night.svg' : 'partly-cloudy-day.svg',
        119: 'cloudy.svg', 122: 'overcast.svg', 143: 'mist.svg', 248: 'fog.svg',
        260: 'overcast-fog.svg', 176: isNight ? 'partly-cloudy-night-rain.svg' : 'partly-cloudy-day-rain.svg',
        263: isNight ? 'partly-cloudy-night-drizzle.svg' : 'partly-cloudy-day-drizzle.svg',
        266: 'hail.svg', 293: ['rain.svg', 'overcast.svg'], 296: 'drizzle.svg', 353: 'rain.svg',
        299: ['drizzle.svg','cloudy.svg'], 302: 'rain.svg', 305: ['rain.svg','overcast.svg'],
        308: 'heavy-rain.svg', 356: ['heavy-rain.svg', 'rain.svg'], 359: ['extreme-rain.svg', 'wind.svg'],
        311: isNight ? 'partly-cloudy-night-sleet.svg' : 'partly-cloudy-day-sleet.svg',
        314: 'sleet.svg', 179: isNight ? 'partly-cloudy-night-snow.svg' : 'partly-cloudy-day-snow.svg',
        227: 'wind-snow.svg', 230: 'blizzard.svg', 323: ['snow.svg', 'mist.svg'],
        326: 'snow.svg', 329: ['cloudy.svg', 'snow.svg'], 332: ['cloudy.svg', 'snow.svg'],
        335: ['heavy-snow.svg','snow.svg'], 338: 'heavy-snow.svg', 368: 'snow.svg',
        371: 'heavy-snow.svg', 182: isNight ? 'partly-cloudy-night-sleet.svg' : 'partly-cloudy-day-sleet.svg',
        185: isNight ? 'partly-cloudy-night-hail.svg' : 'partly-cloudy-day-hail.svg',
        317: 'sleet.svg', 320: ['heavy-rain.svg', 'sleet.svg'], 350: 'hail.svg',
        362: 'sleet.svg', 365: ['heavy-rain.svg', 'sleet.svg'], 374: 'hail.svg',
        377: ['heavy-rain.svg', 'hail.svg'], 200: 'thunderstorms.svg',
        386: isNight ? 'thunderstorms-night-rain.svg' : 'thunderstorms-day-rain.svg',
        389: 'thunderstorms-rain.svg', 392: isNight ? 'thunderstorms-night-snow.svg' : 'thunderstorms-day-snow.svg',
        395: 'thunderstorms-snow.svg'
    };
    const iconFilename = ICON_CHOICES[code];
    return iconFilename ? createIcon(iconFilename, 'Clima', finalIconClass) : createIcon('compass.svg', 'Clima desconocido', finalIconClass);
}

// ===================================================================
// NOMBRE: generateWeatherBlockHtml (Versi√≥n Final con Alineaci√≥n Corregida)
// RESUMEN: Genera el HTML con la nueva estructura que permite la alineaci√≥n perfecta v√≠a CSS.
function generateWeatherBlockHtml(weatherData, forecastType = 'origin', etaDate = null) {
    if (!weatherData) return '';
    const { current, locationName, daily } = weatherData;
    const baseUrl = 'https://cdn.jsdelivr.net/gh/basmilius/weather-icons@dev/production/fill/svg/';
    const createDetailIcon = (filename, altText = '') => `<img src="${baseUrl}${filename}" alt="${altText}">`;
    const createTrendIcon = (trend) => {
        if (trend === 'up') return `<img src="${baseUrl}thermometer-warmer.svg" alt="subiendo">`;
        if (trend === 'down') return `<img src="${baseUrl}thermometer-colder.svg" alt="bajando">`;
        return '';
    };
    let conditionToShow = { ...current };
    let baseHourForForecast = new Date().getHours();
    let arrivalDayIndex = 0;
    if (forecastType === 'destination' && etaDate && daily && daily.length > 0) {
        const arrivalDateString = etaDate.toISOString().split('T')[0];
        const arrivalHour = etaDate.getHours();
        baseHourForForecast = arrivalHour;
        const arrivalDayData = daily.find((day, index) => { if (day.date === arrivalDateString) { arrivalDayIndex = index; return true; } return false; });
        if (arrivalDayData && arrivalDayData.hourly) {
            const arrivalForecast = arrivalDayData.hourly.reduce((prev, curr) => {
                const prevHour = parseInt(prev.time) / 100;
                const currHour = parseInt(curr.time) / 100;
                return (Math.abs(currHour - arrivalHour) < Math.abs(prevHour - arrivalHour) ? curr : prev);
            });
            if (arrivalForecast) {
                conditionToShow = {
                    temp: Math.round(parseFloat(arrivalForecast.tempC)), humidity: arrivalForecast.humidity, windSpeed: arrivalForecast.windspeedKmph,
                    windDirDegrees: arrivalForecast.winddirDegree, precipMM: parseFloat(arrivalForecast.precipMM),
                    chanceOfRain: arrivalForecast.chanceofrain, weatherCode: arrivalForecast.weatherCode
                };
            }
        }
    }
    const mainIconHtml = getWeatherEmoji(conditionToShow.weatherCode, forecastType === 'destination' ? (etaDate ? etaDate.getHours() * 100 : null) : new Date().getHours() * 100, '5.5rem');
    const precipHtml = (conditionToShow.precipMM > 0) ? `-${conditionToShow.precipMM}mm` : '';
    let dateHtml = '';
    if (forecastType === 'origin') {
        const now = new Date();
        const days = ['Dom', 'Lun', 'Mar', 'Mi√©', 'Jue', 'Vie', 'S√°b'];
        const months = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
        dateHtml = `<span class="weather-date">${days[now.getDay()]} ${now.getDate()} ${months[now.getMonth()]}</span>`;
    }
    let currentTempTrend = '';
    if (forecastType === 'origin' && daily && daily[0]) {
        const maxTempToday = parseFloat(daily[0].maxtempC);
        const currentTempNum = parseFloat(current.temp);
        if (!isNaN(maxTempToday) && !isNaN(currentTempNum) && currentTempNum < maxTempToday) {
            currentTempTrend = createTrendIcon('up');
        }
    }
    let hourlyItemsHtml = '';
    let hoursFound = 0;
    let lastHourlyTemp = Math.round(parseFloat(current.feelsLike));
    const hourlyForPanel = (daily && daily[arrivalDayIndex]) ? daily[arrivalDayIndex].hourly : [];
    if (hourlyForPanel) {
        for (let d = arrivalDayIndex; d < daily.length && hoursFound < 3; d++) {
            const dayToScan = daily[d];
            if (dayToScan && dayToScan.hourly) {
                for (const hourData of dayToScan.hourly) {
                    const forecastHour = parseInt(hourData.time) / 100;
                    if ((d === arrivalDayIndex && forecastHour > baseHourForForecast) || d > arrivalDayIndex) {
                        const currentTemp = Math.round(parseFloat(hourData.FeelsLikeC));
                        let hourlyTrend = '';
                        if (lastHourlyTemp !== null) {
                            if (currentTemp > lastHourlyTemp) hourlyTrend = createTrendIcon('up');
                            else if (currentTemp < lastHourlyTemp) hourlyTrend = createTrendIcon('down');
                        }
                        lastHourlyTemp = currentTemp;
                        hourlyItemsHtml += `<div class="forecast-item"><span class="forecast-time">${String(forecastHour).padStart(2, '0')}:00</span><span class="forecast-icon">${getWeatherEmoji(hourData.weatherCode, parseInt(hourData.time))}</span><span class="forecast-temp-value">${currentTemp}¬∞</span><span class="forecast-temp-trend">${hourlyTrend}</span></div>`;
                        hoursFound++;
                        if (hoursFound >= 3) break;
                    }
                }
            }
            if (hoursFound >= 3) break;
        }
    }
    let dailyItemsHtml = '';
    let lastDailyMaxTemp = null;
    if (daily) {
        if (arrivalDayIndex > 0) { lastDailyMaxTemp = parseFloat(daily[arrivalDayIndex - 1].maxtempC); } 
        else if (daily.length > 0) { lastDailyMaxTemp = parseFloat(daily[0].maxtempC); }
        for (let i = 0; i < 3 && (arrivalDayIndex + i) < daily.length; i++) {
            const dayData = daily[arrivalDayIndex + i];
            const date = new Date(dayData.date + 'T12:00:00Z');
            const middayForecast = dayData.hourly.find(h => h.time === "1200") || dayData.hourly[4];
            const dayIcon = getWeatherEmoji(middayForecast.weatherCode, 1200);
            const currentMaxTemp = parseFloat(dayData.maxtempC);
            let dailyTrend = '';
            if (lastDailyMaxTemp !== null && i > 0) {
                if (currentMaxTemp > lastDailyMaxTemp) dailyTrend = createTrendIcon('up');
                else if (currentMaxTemp < lastDailyMaxTemp) dailyTrend = createTrendIcon('down');
            }
            lastDailyMaxTemp = currentMaxTemp;
            let dayName = (i === 0 && forecastType === 'origin') ? "Hoy" : date.toLocaleDateString('es-ES', { weekday: 'short', timeZone: 'UTC' }).replace('.', '');
            dayName = dayName.charAt(0).toUpperCase() + dayName.slice(1);
            dailyItemsHtml += `<div class="forecast-item"><span class="forecast-time">${dayName}</span><span class="forecast-icon">${dayIcon}</span><span class="forecast-temp-value">${Math.round(currentMaxTemp)}¬∞</span><span class="forecast-temp-trend">${dailyTrend}</span></div>`;
        }
    }
    const forecastPanelHtml = `<div class="forecast-panel-container"><div class="forecast-column"><h4>Pr√≥ximas Horas</h4>${hourlyItemsHtml || '<div class="forecast-item-empty">No hay datos</div>'}</div><div class="forecast-column"><h4>M√°x Hoy / Prox. D√≠as</h4>${dailyItemsHtml || '<div class="forecast-item-empty">No hay datos</div>'}</div></div>`;
    const extendedInfoHtml = (forecastType === 'origin') ? `<div class="weather-extended-info-container"><button id="weather-extended-info-link" data-href="https://www.ventusky.com/?p=40.2;-4.7;5&l=rain-3h" class="weather-extended-info-btn">Informaci√≥n ampliada</button><p class="weather-extended-info-note">(*) Pulse retroceder en el navegador para volver aqu√≠</p></div>` : '';
    
    return `<div class="weather-block"><div class="location-header-wrapper">${forecastType === 'origin' ? `<span class="location-icon">üöó</span>` : `<span class="location-icon">üèÅ</span>`}<div class="location-name ${forecastType === 'destination' ? 'destination' : ''}">${forecastType === 'destination' ? '<span class="destination-prefix">Destino</span>' : ''}<span class="${forecastType === 'destination' ? 'destination-location' : 'origin-location'}">${locationName}</span></div></div><div class="weather-main-line"><span class="weather-icon">${mainIconHtml}</span><div class="temp-date-container"><span class="weather-temp">${conditionToShow.temp}¬∞C${currentTempTrend}</span>${dateHtml}</div></div><div class="weather-details"><div class="detail-item" title="Probabilidad y cantidad de lluvia"><span class="detail-icon">${createDetailIcon('umbrella.svg')}</span><span>${conditionToShow.chanceOfRain}%${precipHtml}</span></div><div class="detail-item" title="Humedad"><span class="detail-icon">${createDetailIcon('humidity.svg')}</span><span>${conditionToShow.humidity}%</span></div><div class="detail-item" title="Viento"><span class="detail-icon">${createDetailIcon('dust-wind.svg')}</span><span class="wind-direction-arrow" style="transform: rotate(${conditionToShow.windDirDegrees}deg);">‚Üë</span><span>${conditionToShow.windSpeed} km/h</span></div></div>${forecastPanelHtml}${extendedInfoHtml}</div>`;
}
    
// ===================================================================
// NOMBRE: updateWeatherWidget 
// RESUMEN: Llama a `generateWeatherBlockHtml` con los par√°metros correctos ('origin' y 'destination') y el ETA.
async function updateWeatherWidget(lat, lon, overrideDestinationCoords = null) {
    const widget = document.getElementById('weather-widget-container');
    if (!widget) return;

    if (!widget.dataset.clickListenerAdded) {
        widget.addEventListener('click', (event) => {
            if (event.target.closest('#weather-extended-info-link')) {
                return;
            }
            hideWeatherWidgetManually();
        });
        widget.dataset.clickListenerAdded = 'true'; }

    if (weatherHideTimer) {
        clearTimeout(weatherHideTimer);
        weatherHideTimer = null;
    }

    const distanceMoved = calculateDistance(lastWeatherCoords.lat, lastWeatherCoords.lon, lat, lon);
    
    if (Date.now() < weatherWidgetForceShowUntil) {
    } else if (distanceMoved < 5000 && widget.classList.contains('visible') && !overrideDestinationCoords) {
        weatherHideTimer = setTimeout(() => {
            if (Date.now() >= weatherWidgetForceShowUntil) { 
                widget.classList.remove('visible');
            }
        }, 30000);
        return;
    }
    
    lastWeatherCoords = { lat, lon };
    widget.classList.add('visible');
    widget.classList.remove('hidden'); 
    const duration = (weatherWidgetForceShowUntil > Date.now()) 
        ? (weatherWidgetForceShowUntil - Date.now()) 
        : 30000;

    weatherHideTimer = setTimeout(() => {
        if (Date.now() >= weatherWidgetForceShowUntil) {
             widget.classList.remove('visible');
        }
    }, duration);

    try {
        let destinationCoords = null;
        let finalEtaDate = null;
        
        if (overrideDestinationCoords) {
            destinationCoords = overrideDestinationCoords;
            finalEtaDate = new Date(); 
        } else if (navigationCurrentRouteData?.routes?.[0]) {
            const finalWaypoint = navigationWaypoints.filter(wp => wp && !wp.isInternal).pop();
            if (finalWaypoint) {
                destinationCoords = { lat: finalWaypoint.lat, lon: finalWaypoint.lng };
                const route = navigationCurrentRouteData.routes[0];
                
                let remainingDuration;
                if (isNavigating) {
                    const remainingDistance = Math.max(0, route.distance - lastCarDistanceAlongRouteForNavLogic);
                    remainingDuration = route.distance > 0 ? route.duration * (remainingDistance / route.distance) : 0;
                } else {
                    remainingDuration = route.duration;
                }
                finalEtaDate = new Date(Date.now() + remainingDuration * 1000);
            }
        }

        let currentData, destinationData = null;
        let finalHtml = '';

        if (destinationCoords) {
            const [currentResponse, destResponse] = await Promise.all([
                fetch(`https://wttr.in/${lat},${lon}?format=j1`),
                fetch(`https://wttr.in/${destinationCoords.lat},${destinationCoords.lon}?format=j1`)
            ]);
            
            if (!currentResponse.ok) throw new Error('No se pudo obtener el tiempo actual');
            
            const currentJson = await currentResponse.json();
            currentData = processWeatherData(currentJson);
            if(currentData) {
                finalHtml = generateWeatherBlockHtml(currentData, 'origin');
            }

            if (destResponse.ok) {
                const destJson = await destResponse.json();
                destinationData = processWeatherData(destJson);
                if(destinationData) {
                    finalHtml += `<hr class="weather-separator">`;
                    finalHtml += generateWeatherBlockHtml(destinationData, 'destination', finalEtaDate);
                }
            }
        } else {
            const response = await fetch(`https://wttr.in/${lat},${lon}?format=j1`);
            if (!response.ok) throw new Error('No se pudo obtener el tiempo');
            const json = await response.json();
            currentData = processWeatherData(json);
            if(currentData) {
                finalHtml = generateWeatherBlockHtml(currentData, 'origin');
            }
        }
        
        const content = document.getElementById('weather-widget-content');
        content.innerHTML = finalHtml;

        const extendedInfoButton = content.querySelector('#weather-extended-info-link');
        if (extendedInfoButton) {
            extendedInfoButton.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const url = extendedInfoButton.getAttribute('data-href');
                if (url) {
                    window.open(url, '_blank');
                }
            });
        }

    } catch (error) {
        console.error("Error al actualizar el widget del tiempo:", error);
        if (widget) {
            widget.classList.remove('visible');
        }
        throw error;
    }
}
// ===================================================================
// NOMBRE: hideWeatherWidgetManually
// RESUMEN: Oculta el widget del clima al ser pulsado por el usuario.
function hideWeatherWidgetManually() {
    const widget = document.getElementById('weather-widget-container');
    if (!widget) return;

    if (weatherHideTimer) {
        clearTimeout(weatherHideTimer);
        weatherHideTimer = null;
    }

    weatherWidgetForceShowUntil = 0;

    widget.classList.remove('visible');
}    
    
// ===================================================================
// NOMBRE: startWeatherUpdates / stopWeatherUpdates 
// RESUMEN: Inicia y detiene el ciclo de actualizaci√≥n del tiempo, manejando ambos temporizadores.
function startWeatherUpdates(initialCoords = null) {
    stopWeatherUpdates(); 

    const updatePeriodic = () => {
        if (navigationCurrentLocation) {
            updateWeatherWidget(navigationCurrentLocation.latitude, navigationCurrentLocation.longitude);
        }
    };
    
    if (initialCoords) {
        updateWeatherWidget(initialCoords.latitude, initialCoords.longitude);
    } else {
        updatePeriodic();
    }
    
    weatherUpdateTimer = setInterval(updatePeriodic, 11 * 60 * 1000); 
}    
function stopWeatherUpdates() {
    weatherWidgetForceShowUntil = 0; 
    if (weatherUpdateTimer) {
        clearInterval(weatherUpdateTimer);
        weatherUpdateTimer = null;
    }
    if (weatherHideTimer) {
        clearTimeout(weatherHideTimer);
        weatherHideTimer = null;
    }
    const widget = document.getElementById('weather-widget-container');
    if (widget) {
        widget.classList.remove('visible');
    }
}
    
// ===================================================================
// NOMBRE: configureMapAtmosphere (VERSI√ìN SIMPLIFICADA PARA TERRENO)
// ===================================================================
async function configureMapAtmosphere() {
    if (!navigationMapInstance) return;
    await waitForMapStyleLoad(navigationMapInstance);

    if (navigationMapInstance.getTerrain()) {
        navigationMapInstance.setTerrain(null);
    }
    navigationMapInstance.setFog(null);

    const currentMode = mapViewMode || localStorage.getItem(MAP_VIEW_MODE_KEY) || 'relief';

    if (currentMode === 'relief' || currentMode === 'perspective') {
        if (!navigationMapInstance.getSource('mapbox-dem')) {
            navigationMapInstance.addSource('mapbox-dem', {
                'type': 'raster-dem',
                'url': 'mapbox://mapbox.terrain-rgb',
                'tileSize': 512,
                'maxzoom': 16 
            });
        }
        
        const exaggeration = (currentMode === 'relief') ? mapTerrainExaggeration : 0.0;
        navigationMapInstance.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': exaggeration });
        
        navigationMapInstance.setFog({
            'range': [0.9, 10], 'color': '#d8e2e8', 'horizon-blend': 0.1,
            'high-color': '#58636B', 'space-color': '#B3E3FF', 'star-intensity': 0.15
        });
        setMapLighting(navigationMapInstance);
    }
} 

//===================================================================
// NOMBRE: generateAndCacheCleanManeuverList
// RESUMEN: Crea y cachea la lista de maniobras "reales" una sola vez por ruta,
function generateAndCacheCleanManeuverList(route, actualWaypoints) {
    if (!route || !route.legs) {
        if (route) route._cleanSteps = [];
        return;
    }

    const cleanSteps = [];
    const significantManeuverTypes = new Set([
        'turn', 'fork', 'merge', 'roundabout', 'rotary', 'end of road', 
        'off ramp', 'on ramp', 'use lane'
    ]);

    route.legs.forEach((leg, legIdx) => {
        if (!leg.steps) return;

        for (let stepIdx = 0; stepIdx < leg.steps.length; stepIdx++) {
            const step = leg.steps[stepIdx];
            const maneuver = step.maneuver;

            const isFirstStepOfAll = legIdx === 0 && stepIdx === 0;

            const isSignificantType = significantManeuverTypes.has(maneuver.type);

            const isLongContinuation = (maneuver.type === 'continue' || maneuver.type === 'new name') && step.distance >= 40;

            const isRealArrival = maneuver.type === 'arrive' && !actualWaypoints[legIdx + 1]?.isInternal;

            if (isFirstStepOfAll || isSignificantType || isLongContinuation || isRealArrival) {
                cleanSteps.push({ ...step, originalLegIndex: legIdx, originalStepIndex: stepIdx });
            }
        }
    });
    
    route._cleanSteps = cleanSteps;
}

// ===================================================================
// NOMBRE: closeNavigationMap (CORREGIDA Y DEFINITIVA)
// RESUMEN: Llama al reseteo completo ANTES de destruir la instancia del mapa para garantizar una limpieza total.
function closeNavigationMap(force = false) {
    const aiModal = document.getElementById('ai-route-modal');
    if (aiModal) aiModal.classList.add('hidden');

    stopWeatherUpdates();
    
    clearRecoveryFlag();
    hideAddressSuggestionsModal();
    stopGpsWatching();
    if (markerAnimationState.animationFrameId) {
        cancelAnimationFrame(markerAnimationState.animationFrameId);
        markerAnimationState.animationFrameId = null;
    }
    if (alertRefreshInterval) {
        clearInterval(alertRefreshInterval);
        alertRefreshInterval = null;
    }
    if (gpsHzMonitor.interval) {
        clearInterval(gpsHzMonitor.interval);
        gpsHzMonitor.interval = null;
    }
    if (manualZoomTimeout) { clearTimeout(manualZoomTimeout); manualZoomTimeout = null; }

    resetNavigationState();
   
    const header = document.getElementById('reminders-location-map-header');
    if (header && header._mapButtonClickHandler) {
        header.removeEventListener('click', header._mapButtonClickHandler);
        delete header._mapButtonClickHandler; // Elimina la propiedad para limpiar la referencia.
    }

   if (intersectionPreviewMap) {
        try { intersectionPreviewMap.remove(); } catch(e){}
        intersectionPreviewMap = null;
        intersectionPreviewCarMarker = null; // Tambi√©n limpiar sus marcadores
        intersectionPreviewManeuverMarker = null;
    }
    if (locationPickerMap) {
        try { locationPickerMap.remove(); } catch(e){}
        locationPickerMap = null;
        locationPickerMarker = null;
    }
    
    if (navigationMapInstance) {
        try {
            navigationMapInstance.off('load');
            navigationMapInstance.off('error');
            navigationMapInstance.off('pitch');
            navigationMapInstance.off('zoomend');
            navigationMapInstance.off('click');
            navigationMapInstance.off('sourcedata');  } catch (e) {
        }

        if (minimapInstance) {
            try { minimapInstance.remove(); } catch(e) {}
            minimapInstance = null;
            minimapCarMarker = null;
        }
        
        navigationMapInstance.remove();
        navigationMapInstance = null;
    }
  
    isManualZoomActive = false;
    if (markerAnimationState.animationFrameId) { cancelAnimationFrame(markerAnimationState.animationFrameId); markerAnimationState.animationFrameId = null; }
 
    const wasInDirectToMapModeSession = sessionStorage.getItem('isInDirectToMapMode') === 'true';
    const userPrefersDirectToNav = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
    if (wasInDirectToMapModeSession && userPrefersDirectToNav && !force) {
        sessionStorage.removeItem('isInDirectToMapMode');
        sessionStorage.setItem(TEMP_PREVENT_DIRECT_NAV_KEY, 'true');
        location.reload();
        return;
    }
    
    isNavigationMapActive = false;
    sessionStorage.removeItem('mapContext');
    if (locationWatchId !== null && navigator.geolocation) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
    if (gpsRetryTimeoutId) { clearTimeout(gpsRetryTimeoutId); gpsRetryTimeoutId = null; }
    gpsRetryAttempt = 0;
    
    const mapModalElement = document.getElementById('reminders-location-map-modal');
    if (mapModalElement) {
        mapModalElement.classList.add('map-modal-hidden');
    }
    
    const simModal = document.getElementById('simulation-modal');
    if (simModal && !simModal.classList.contains('hidden')) {
        if (simulationModalTimer) clearTimeout(simulationModalTimer);
        const simCloseBtn = simModal.querySelector('#close-simulation-modal');
        if (simCloseBtn) clearModalAutoCloseTimer(simModal, simCloseBtn, 'simulation-modal');
        simModal.classList.add('hidden');
        hideIntersectionPreviewMap();
    }

    sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
    hideUnifiedReminderWindow();
    
    if (directToNavOnLoad) {
        loadCustomData();
        loadSavedSettings();
        applyMainUISettings();
        directToNavOnLoad = false;
    }
 
    const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'block';
    const footer = document.querySelector('footer'); if (footer) footer.style.display = 'block';
    const noticesContainer = document.querySelector('.notices-icon-container'); if (noticesContainer) noticesContainer.style.display = 'flex';
    const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'flex');
    document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'block');
    const gridFilter = document.getElementById('grid-filter-container'); if (gridFilter) gridFilter.style.display = 'flex';
}


//===================================================================
// NOMBRE: drawRouteOnMap 
// RESUMEN: Encapsula la l√≥gica completa de pintado: destruye la ruta antigua
async function drawRouteOnMap(route) {
    if (!navigationMapInstance) {
        throw new Error("La instancia del mapa no existe para poder dibujar.");
    }

    await waitForMapStyleLoad(navigationMapInstance);

    return new Promise((resolve, reject) => {
        const geojsonData = (route && route.geometry && route.geometry.coordinates.length >= 2) 
            ? { type: 'Feature', properties: {}, geometry: route.geometry }
            : { type: 'Feature', properties: {}, geometry: { type: 'LineString', coordinates: [] } };

        const cleanupAndReject = (message) => {
            clearTimeout(timeoutId);
            navigationMapInstance.off('sourcedata', onSourceData);
            reject(new Error(message));
        };
        
        const timeoutId = setTimeout(() => {
            cleanupAndReject("Timeout esperando la confirmaci√≥n de renderizado del mapa.");
        }, 7000);

        const onSourceData = (e) => {
            if (e.sourceId === 'route' && e.isSourceLoaded) {
                clearTimeout(timeoutId);
                navigationMapInstance.off('sourcedata', onSourceData);
                resolve();
            }
        };
        
        navigationMapInstance.on('sourcedata', onSourceData);

        try {
            if (navigationMapInstance.getLayer('route')) {
                navigationMapInstance.removeLayer('route');
            }
            if (navigationMapInstance.getSource('route')) {
                navigationMapInstance.removeSource('route');
            }

            navigationMapInstance.addSource('route', { type: 'geojson', data: geojsonData });
            navigationMapInstance.addLayer({
                id: 'route',
                type: 'line',
                source: 'route',
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                minzoom: 1.5, maxzoom: 19, 
                paint: getRouteStyleProperties()
            });

            drawRouteOnMinimap();
            
           } catch (error) {
            cleanupAndReject(`Error al a√±adir capa/fuente: ${error.message}`);
        }
    });
}    
   
// ===================================================================
// 
function createMinimapInstanceIfNeeded() {
    if (!showRouteMinimapPreference || minimapInstance) {
        return;
    }

    const minimapContainer = document.getElementById('minimap-container');
    if (minimapContainer && !minimapContainer.dataset.listenerAdded) {
        minimapContainer.style.cursor = 'pointer';
        // T√≠tulo inicial m√°s gen√©rico
        minimapContainer.title = 'Pulsar para alternar vista';

        minimapContainer.addEventListener('click', () => {
            const zoomToggleButton = document.getElementById('zoom-toggle-button');
            if (zoomToggleButton) {
                handleZoomToggleButtonClick(zoomToggleButton);
              }
        });
        minimapContainer.dataset.listenerAdded = 'true';
    }

    const minimapMapDiv = document.getElementById('minimap-map-div');
    if (minimapMapDiv) {
        minimapInstance = new mapboxgl.Map({
            container: minimapMapDiv,
            style: 'mapbox://styles/boardinggate11/cmgp5snhk000s01qx1v5i4tlq?optimize=true', 
            center: [-97.1903, 30.3715],
            zoom: 1,
            interactive: false,
            attributionControl: false,
            maxTileCacheSize: 6,
            antialias: false,
            preserveDrawingBuffer: false,
            projection: 'mercator'
        });

        minimapInstance.on('load', () => {
            minimapInstance.addSource('minimap-route-source', {
                type: 'geojson',
                data: { type: 'Feature', geometry: { type: 'LineString', coordinates: [] } }
            });
            minimapInstance.addLayer({
                id: 'minimap-route-layer',
                type: 'line',
                source: 'minimap-route-source',
                paint: { 
                    'line-color': '#FFFB00', 
                    'line-width': 6 
                }
            }); 
             
            minimapInstance.addSource('minimap-waypoints-source', {
                type: 'geojson',
                data: { type: 'FeatureCollection', features: [] }
            });
            
            minimapInstance.addLayer({
                id: 'minimap-waypoints-layer',
                type: 'circle',
                source: 'minimap-waypoints-source',
                paint: {
                    'circle-color': [
                        'case',
                        ['==', ['get', 'isFinal'], true],
                        '#52BDE3', // Color para el destino final
                        '#d66b1e'  // Color para las dem√°s etapas
                    ],
                    'circle-radius': 7,
                    'circle-stroke-width': 4,
                    'circle-stroke-color': '#fffb00'
                }
            });

            const carContainer = document.getElementById('minimap-car-container');
            if (carContainer) {
                carContainer.innerHTML = '';
                const carEl = document.createElement('div');
                carEl.className = 'minimap-car-icon';
                carEl.innerHTML = `<img src="PNG/AVANCE.PNG" alt="Coche">`;
                carContainer.appendChild(carEl);
                
                minimapCarMarker = carEl; 
            }
        });
    }
}
    
// ===================================================================
// NOMBRE: drawRouteOnMinimap 
// RESUMEN: Dibuja la ruta en el minimapa, calculando un marco virtual para garantizar
async function drawRouteOnMinimap() {
    if (!showRouteMinimapPreference) {
        const minimapContainer = document.getElementById('minimap-container');
        if (minimapContainer) minimapContainer.classList.add('hidden');
        if (minimapInstance) {
            try { minimapInstance.remove(); } catch(e) {}
            minimapInstance = null;
            minimapCarMarker = null;
        }
        return;
    }
    
    createMinimapInstanceIfNeeded();
    if (!minimapInstance) return;

    let route = navigationCurrentRouteData?.routes?.[0];
    let hasValidGeometry = route && route.geometry && Array.isArray(route.geometry.coordinates) && route.geometry.coordinates.length > 1;
    
    if (!hasValidGeometry) {
        const maxRetries = 5;
        const retryDelay = 200; 
        for (let i = 0; i < maxRetries; i++) {
            await wait(retryDelay); 
            route = navigationCurrentRouteData?.routes?.[0]; 
            hasValidGeometry = route && route.geometry && Array.isArray(route.geometry.coordinates) && route.geometry.coordinates.length > 1;
            if (hasValidGeometry) {
                break; 
            }
        }
    }
    
    const minimapContainer = document.getElementById('minimap-container');

    if (!hasValidGeometry) {
        if (minimapContainer) minimapContainer.classList.add('hidden');
        if (minimapInstance.isStyleLoaded()) {
            try {
                const routeSource = minimapInstance.getSource('minimap-route-source');
                if (routeSource) routeSource.setData({ type: 'Feature', geometry: { type: 'LineString', coordinates: [] } });
            } catch (e) {}
        }
        return;
    }
    
    const drawContent = () => {
        const geojsonData = route.geometry;
        const source = minimapInstance.getSource('minimap-route-source');
        if (source) source.setData(geojsonData);
        
        const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
        const waypointFeatures = actualWaypoints.map((wp, index) => ({
            type: 'Feature',
            properties: {
                isFinal: index === actualWaypoints.length - 1
            },
            geometry: { type: 'Point', coordinates: [wp.lng, wp.lat] }
        }));
        const waypointSource = minimapInstance.getSource('minimap-waypoints-source');
        if (waypointSource) waypointSource.setData({ type: 'FeatureCollection', features: waypointFeatures });

        const routeLine = turf.lineString(geojsonData.coordinates);
        
        const center = turf.center(routeLine);

        const bbox = turf.bbox(routeLine);
        const sw = turf.point([bbox[0], bbox[1]]);
        const ne = turf.point([bbox[2], bbox[3]]);
        const maxRadiusKm = Math.max(
            turf.distance(center, sw, { units: 'kilometers' }),
            turf.distance(center, ne, { units: 'kilometers' })
        );

        const PADDING_FACTOR = 2.4; 
        const paddedRadiusKm = maxRadiusKm * PADDING_FACTOR;

        const newSW = turf.destination(center, paddedRadiusKm, -135, { units: 'kilometers' });
        const newNE = turf.destination(center, paddedRadiusKm, 45, { units: 'kilometers' });

        const paddedBounds = new mapboxgl.LngLatBounds(
            [newSW.geometry.coordinates[0], newSW.geometry.coordinates[1]],
            [newNE.geometry.coordinates[0], newNE.geometry.coordinates[1]]
        );

        if (!paddedBounds.isEmpty()) {
            minimapInstance.fitBounds(paddedBounds, { padding: 0, duration: 0 });
        }
      
    };
    
    if (minimapInstance.isStyleLoaded()) {
        drawContent();
    } else {
        minimapInstance.once('load', drawContent);
    }
}    
    
// ===================================================================
// NOMBRE: MapSettingsPanel (VERSI√ìN CON SEPARADOR VISUAL)
// ===================================================================
class MapSettingsPanel {
    constructor(map) {
        this._map = map;
        this.layerVisibilityKey = 'boardinggate_map_layer_visibility';
        this.streetMapThemeKey = 'boardinggate_streetMapTheme';
        this.layerGroups = {
            poblaciones: {
                label: 'Poblaciones',
                layers: ['settlement-major-label', 'settlement-minor-label', 'settlement-subdivision-label']
            },
            pois: {
                label: 'Negocios/POIs',
                layers: ['poi-label', 'transit-label', 'airport-label']
            },
            carreteras: {
                label: 'Carreteras/Calles',
                layers: ['road-label']
            },
            geografia: {
                label: 'Geograf√≠a/Natural',
                layers: ['natural-label', 'water-point-label', 'water-line-label', 'waterway-label']
            },
        };
    }

    createPanelContent() {
        const fragment = document.createDocumentFragment();
        
        const layerSelectorContainer = document.createElement('div');
        layerSelectorContainer.className = 'map-layer-selector';

        const baseMapOptions = ["H√çBRIDO", "SAT√âLITE", "CALLES"];
        let savedLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "H√çBRIDO";
        
        if (MAP_LEGACY_NAME_MAP[savedLayerName]) {
            savedLayerName = MAP_LEGACY_NAME_MAP[savedLayerName];
            localStorage.setItem(ACTIVE_MAP_LAYER_KEY, savedLayerName);
        }
        if (savedLayerName === "CALLES_LIGHT" || savedLayerName === "CALLES_DARK") {
             savedLayerName = "CALLES";
        }
        if (!baseMapOptions.includes(savedLayerName)) {
            savedLayerName = "H√çBRIDO";
        }

        const streetThemeCheckboxContainer = document.createElement('div');
        streetThemeCheckboxContainer.id = 'street-theme-checkbox-container';
        streetThemeCheckboxContainer.style.marginLeft = '30px';
        streetThemeCheckboxContainer.innerHTML = `
            <label style="display: flex; align-items: center; gap: 8px;">
                <input type="checkbox" id="street-theme-checkbox">
                <span>Tono Oscuro</span>
            </label>
        `;
        const streetThemeCheckbox = streetThemeCheckboxContainer.querySelector('#street-theme-checkbox');
        const savedTheme = localStorage.getItem(this.streetMapThemeKey) || 'dark'; 
        streetThemeCheckbox.checked = savedTheme === 'dark';

        const updateStyle = () => {
            const selectedRadio = layerSelectorContainer.querySelector('input[name="map-style-selector"]:checked');
            if (!selectedRadio) return;

            const baseStyle = selectedRadio.value;
            let finalStyleUrl;
            let finalLayerNameForStorage = baseStyle;

            if (baseStyle === "CALLES") {
                const isDark = streetThemeCheckbox.checked;
                finalStyleUrl = isDark ? MAP_STYLES.CALLES_DARK : MAP_STYLES.CALLES_LIGHT;
                localStorage.setItem(this.streetMapThemeKey, isDark ? 'dark' : 'light');
            } else {
                 finalStyleUrl = MAP_STYLES[baseStyle];
            }
            
            localStorage.setItem(ACTIVE_MAP_LAYER_KEY, finalLayerNameForStorage);
            markCacheAsDirty();

            this._map.setStyle(finalStyleUrl, { diff: false });
            
            this._map.once('style.load', async () => {
                
                await loadAndAddMapImages(this._map);

                await configureMapAtmosphere();
                setMapLighting(this._map);
                
                await new Promise(resolve => this._map.once('idle', resolve));
                
                await add3DBuildingsLayer(this._map);
                
                await reAddCustomMapLayersAndSources(this._map);
                applyLayerVisibility();
                plotRemindersOnNavigationMap();
                displayChargingPointsOnMap();
                displayAlertsOnMap();
                renderWaypointMarkers();
                updateRouteAndCarIconStyle();
            });
        };
        
        baseMapOptions.forEach(name => {
            const optionContainer = document.createElement('div');
            const label = document.createElement('label');
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = 'map-style-selector';
            input.value = name;
            if (name === savedLayerName) {
                input.checked = true;
            }
            label.appendChild(input);
            label.appendChild(document.createTextNode(` ${name}`));
            optionContainer.appendChild(label);
            
            if (name === "CALLES") {
                optionContainer.appendChild(streetThemeCheckboxContainer);
            }
            layerSelectorContainer.appendChild(optionContainer);

            input.addEventListener('change', () => {
                streetThemeCheckboxContainer.style.display = (input.value === 'CALLES' && input.checked) ? 'block' : 'none';
                updateStyle();
            });
        });
        
        streetThemeCheckbox.addEventListener('change', updateStyle);
        streetThemeCheckboxContainer.style.display = (savedLayerName === 'CALLES') ? 'block' : 'none';

        const viewSelector = document.createElement('div');
        viewSelector.className = 'map-view-selector';
        const viewModes = { 'NORTE': { pitch: 0, bearing: 0, mode: 'static' }, 'AVANCE': { pitch: 0, bearing: null, mode: 'heading' }, '3D': { pitch: 62, bearing: null, mode: 'perspective' }, '3D RELIEVE': { pitch: 73, bearing: null, mode: 'relief' } };
        const savedViewMode = localStorage.getItem(MAP_VIEW_MODE_KEY) || 'relief';
        Object.keys(viewModes).forEach(name => {
            const label = document.createElement('label'); const input = document.createElement('input');
            input.type = 'radio'; input.name = 'map-view-selector'; const modeDetails = viewModes[name];
            input.value = modeDetails.mode; if (modeDetails.mode === savedViewMode) input.checked = true;
            input.onchange = async () => {
                if (!input.checked) return; isPitchManuallyFlattened = false; 
                const selectedModeValue = input.value;
                const newModeDetails = Object.values(viewModes).find(m => m.mode === selectedModeValue);
                const newModeName = Object.keys(viewModes).find(key => viewModes[key].mode === selectedModeValue);
                if (newModeDetails) {
                    mapViewMode = newModeDetails.mode; localStorage.setItem(MAP_VIEW_MODE_KEY, mapViewMode); markCacheAsDirty(); showToast(`Modo Vista: ${newModeName}`, 'info');
                    await configureMapAtmosphere();
                    const easeOptions = { bearing: newModeDetails.bearing };
                    if (navigationCurrentLocation && newModeDetails.bearing === null && navigationCurrentLocation.heading !== null) { easeOptions.bearing = navigationCurrentLocation.heading; }
                    if (newModeDetails.mode === 'perspective' || newModeDetails.mode === 'relief') { easeOptions.pitch = mapPitchValue; } else { easeOptions.pitch = newModeDetails.pitch; }
                    this._map.easeTo(easeOptions);
                    if (navigationCurrentLocation) { updateInitialUserPosition(navigationCurrentLocation, this._map); }
                }
            };
            label.appendChild(input); label.appendChild(document.createTextNode(` ${name}`)); viewSelector.appendChild(label);
        });

        const visibilitySelector = document.createElement('div');
        visibilitySelector.className = 'map-layer-visibility-selector';
        const title = document.createElement('h3');
        title.textContent = 'VISIBILIDAD DE CAPAS';
        visibilitySelector.appendChild(title);
        
        let visibilitySettings = {};
        try {
            visibilitySettings = JSON.parse(localStorage.getItem(this.layerVisibilityKey)) || {};
        } catch (e) {
            visibilitySettings = {};
        }

        Object.keys(this.layerGroups).forEach(groupKey => {
            const group = this.layerGroups[groupKey];
            const isChecked = visibilitySettings[groupKey] !== false;
            const label = document.createElement('label');
            label.className = 'layer-visibility-toggle';
            const input = document.createElement('input');
            input.type = 'checkbox'; input.id = `vis-toggle-${groupKey}`; input.dataset.groupKey = groupKey;
            input.checked = isChecked;
            input.addEventListener('change', (e) => {
                const key = e.target.dataset.groupKey;
                const checked = e.target.checked;
                visibilitySettings[key] = checked;
                localStorage.setItem(this.layerVisibilityKey, JSON.stringify(visibilitySettings));
                markCacheAsDirty();
                applyLayerVisibility();
            });
            label.appendChild(input);
            label.appendChild(document.createTextNode(` ${group.label}`));
            visibilitySelector.appendChild(label);
        });

        const routeMinimapControl = document.createElement('div');
        routeMinimapControl.className = 'route-minimap-toggle-container';
        routeMinimapControl.style.marginTop = '10px';
        routeMinimapControl.style.borderTop = '1px solid #444';
        routeMinimapControl.style.paddingTop = '10px';
        routeMinimapControl.innerHTML = `
            <label class="layer-visibility-toggle">
                <input type="checkbox" id="route-minimap-toggle-checkbox">
                <span>Ver Minimapa de Ruta</span>
            </label>
        `;
        
        const routeMinimapCheckbox = routeMinimapControl.querySelector('#route-minimap-toggle-checkbox');
        routeMinimapCheckbox.checked = showRouteMinimapPreference;
        routeMinimapCheckbox.addEventListener('change', (e) => {
            e.stopPropagation();
            showRouteMinimapPreference = e.target.checked;
            localStorage.setItem(SHOW_ROUTE_MINIMAP_KEY, showRouteMinimapPreference);
            markCacheAsDirty();
        
            const minimapContainer = document.getElementById('minimap-container');
        
            if (showRouteMinimapPreference) {
                const miniNavCard = document.getElementById('mini-nav-info-card');
                const shouldBeVisible = miniNavCard && miniNavCard.style.display === 'flex';
                if (minimapContainer) {
                    minimapContainer.classList.toggle('hidden', !shouldBeVisible);
                }
            } else {
                if (minimapContainer) {
                    minimapContainer.classList.add('hidden');
                }
                if (minimapInstance) {
                    try {
                        minimapInstance.remove();
                    } catch(e) {}
                    minimapInstance = null;
                    minimapCarMarker = null;
                }
            }
            showToast(`Minimapa de ruta ${showRouteMinimapPreference ? 'ACTIVADO' : 'DESACTIVADO'}`, 'info');
        });
        visibilitySelector.appendChild(routeMinimapControl);
    
        const ecoNote = document.createElement('p');
        ecoNote.className = 'eco-note';
        ecoNote.textContent = '(*) El Modo ECO/RUTA anular√° esta configuraci√≥n temporalmente.';
        visibilitySelector.appendChild(ecoNote);
        
        const separator = (className = 'separator') => {
            const sep = document.createElement('div'); sep.className = className; return sep;
        };
        
        fragment.appendChild(layerSelectorContainer);
        fragment.appendChild(separator());
        fragment.appendChild(viewSelector);
        fragment.appendChild(separator());
        fragment.appendChild(visibilitySelector);

        return fragment;
    }
}  

// ===================================================================
// NOMBRE: handleZoomToggleButtonClick (VERSI√ìN CON ACTIVACI√ìN DE CAPAS)
// RESUMEN: Gestiona el zoom y activa todas las capas al alejar para ver la ruta completa.
function handleZoomToggleButtonClick(button) {
    if (!navigationMapInstance || !button) return;

    const currentState = button.dataset.zoomState || 'waypoints';
    
    if (currentState === 'car') { 
        const currentZoom = navigationMapInstance.getZoom();
        zoomToggleMemory = currentZoom;
        triggerManualMapInteraction();
        
        manageAdaptiveLayerVisibility('full');
        
        toggleRouteDetailOverlays(false);

        const routeSource = navigationMapInstance.getSource('route');
        if (routeSource && routeSource._data && routeSource._data.geometry && routeSource._data.geometry.coordinates.length > 1) {
            const coordinates = routeSource._data.geometry.coordinates;
            const bounds = new mapboxgl.LngLatBounds();
            coordinates.forEach(coord => bounds.extend(coord));
            if (!bounds.isEmpty()) {
                navigationMapInstance.fitBounds(bounds, { padding: 80, animate: true, duration: 1500 });
            }
        } else {
            navigationMapInstance.flyTo({ zoom: 10, duration: 1500 });
        }     
        button.dataset.zoomState = 'waypoints';

    } else {
        if (navigationCurrentLocation) {
            navigationFollowUser = true;
            shouldCenterOnUser = true;
            clearLocateMeReactivationTimer();
            updateLocateMeButtonsUI();
                        
            toggleRouteDetailOverlays(true);

            const animationOptions = { 
                center: [navigationCurrentLocation.longitude, navigationCurrentLocation.latitude], 
                zoom: zoomToggleMemory || 17,
                duration: 1400 
            };
            
            if (mapViewMode === 'perspective' || mapViewMode === 'relief') {
                animationOptions.pitch = mapPitchValue;
            } else {
                animationOptions.pitch = 0;
            }
            navigationMapInstance.easeTo(animationOptions);
            zoomToggleMemory = null;
            
            button.dataset.zoomState = 'car';
        
        } else {
            showToast("Ubicaci√≥n actual no disponible para hacer zoom.", "warning");
        }
    }  
    updateAllZoomToggleButtonsVisuals();
}

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// NOMBRE: toggleNavigationState 
// RESUMEN: Ahora detecta si la ruta es manual y la guarda en el historial de recientes antes de iniciar la navegaci√≥n.
async function toggleNavigationState(isRecalculationStop = false, isRecovery = false) {
    const startNavButton = document.getElementById('start-navigation-button');
    const startNavImg = startNavButton ? startNavButton.querySelector('img') : null;
    const mapContainer = document.getElementById('reminders-location-map-div');
    
    if (isNavigating) {
        manageAdaptiveLayerVisibility('full');
    
        if (navigationMapInstance && navigationCurrentLocation) {
            isFlying = true;
            navigationFollowUser = false;
            shouldCenterOnUser = false;
            const targetZoom = 16.5;
            const targetPitch = 0;
            const targetBearing = 0;
            markerAnimationState.targetMapZoom = targetZoom;
            markerAnimationState.targetMapPitch = targetPitch;
            markerAnimationState.targetMapBearing = targetBearing;
            markerAnimationState.currentMapZoom = navigationMapInstance.getZoom();
            markerAnimationState.currentMapPitch = navigationMapInstance.getPitch();
            markerAnimationState.currentMapBearing = navigationMapInstance.getBearing();
            navigationMapInstance.flyTo({ center: [navigationCurrentLocation.longitude, navigationCurrentLocation.latitude], zoom: targetZoom, pitch: targetPitch, bearing: targetBearing, duration: 1500 });
            navigationMapInstance.once('moveend', () => { isFlying = false; });
        }
        
        clearRecoveryFlag();
        startMemoryManagement(false);
        
        if (isSimulatingGpsLocation) {
            stopAutomatedRouteSimulation();
        }
        if (!isRecalculationStop && !isArrivalSequenceStarted) {
            if (!document.getElementById('arrival-stats-modal') || document.getElementById('arrival-stats-modal').classList.contains('hidden')) {
                showArrivalStatsModal();
            }
        }
        isNavigating = false;
        navigationFollowUser = false;
        
        MAP_UPDATE_INTERVAL_MS = originalMapUpdateIntervalMs; 
    } else if (isFreeDriveActive) {
        stopFreeDrive();
    } else {
        const hasEnoughWaypointsForRoute = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2;
        const hasRouteData = navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0];
        if (hasEnoughWaypointsForRoute && hasRouteData) {
            isArrivalSequenceStarted = false;
            hideAutoStartNavigationModal();
            clearAlternativeRoutesDisplay();
            
            const waypointsForRecents = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
            
            if (!currentRouteNameForSaving) {
                await Promise.all(waypointsForRecents.map(async (wp) => {
                    if (!wp.address) {
                        wp.address = await getAddressForWaypoint(wp.lat, wp.lng);
                    }
                }));
                const lastWpForName = waypointsForRecents[waypointsForRecents.length - 1];
                const isMultiStageForName = waypointsForRecents.length > 2;
                const suggestedName = await getSuggestedRouteName(lastWpForName.lat, lastWpForName.lng, isMultiStageForName, waypointsForRecents.length);
                const routeForStorage = { 
                    name: suggestedName, 
                    waypoints: sanitizeWaypointsForStorage(waypointsForRecents) 
                };
                addRouteToRecents(routeForStorage);
            }
            
            if (!isRecovery) {
                clearNavigationGraph();
                gpsTickCounter = 0; 
                navigationWaypoints.forEach(wp => { 
                    if(wp) { 
                        if (wp.type === 'S' || wp.type === 'S_Recalc') { wp.visited = true; } else { wp.visited = false; }
                    }
                });
                tripStartLocationForStats = navigationCurrentLocation ? { ...navigationCurrentLocation } : null;
                navigationStartTimeForStats = new Date();
                totalDistanceTravelledForStats = 0;
                maxSpeedDuringTrip = 0;
                maxSpeedCoordinates = null;
                maxAltitudeDuringTrip = -Infinity;
                minAltitudeDuringTrip = Infinity;
                lastKnownAverageAltitude = null; 
                window.averageSpeedKmh = 0; 
                lastPositionForStats = navigationCurrentLocation ? {...navigationCurrentLocation} : null;
                accumulatedDeviationMs = 0;
                accumulatedDistanceBeforeCurrentSegment = 0;
                graphDataPoints = { speed: [], altitude: [] };
                graphLabels = [];
                minAverageSpeedInTrip = Infinity;
                maxAverageSpeedInTrip = -Infinity;
            }

            const recoveryData = { 
                isActive: true, 
                route: { // Guardamos la ruta que se est√° navegando para la recuperaci√≥n
                    name: currentRouteNameForSaving || 'Ruta Manual',
                    waypoints: sanitizeWaypointsForStorage(waypointsForRecents)
                },
                tripStartTime: navigationStartTimeForStats ? navigationStartTimeForStats.getTime() : Date.now(),
                originalTripEtaTime: originalTripEtaTime ? originalTripEtaTime.getTime() : null,
                stats: {
                    totalDistance: totalDistanceTravelledForStats,
                    maxSpeed: maxSpeedDuringTrip,
                    maxAltitude: maxAltitudeDuringTrip,
                    minAltitude: minAltitudeDuringTrip,
                    maxSpeedCoords: maxSpeedCoordinates
                },
                tripContext: {
                    graphLabels: graphLabels || [],
                    graphDataPoints: graphDataPoints || { speed: [], altitude: [] },
                    minAvgSpeed: minAverageSpeedInTrip,
                    maxAvgSpeed: maxAverageSpeedInTrip,
                    accumulatedDeviationMs: accumulatedDeviationMs
                }
            };
            localStorage.setItem('boardinggate_nav_recovery_flag', JSON.stringify(recoveryData));
            
            navigationWaypoints.forEach(wp => { if (wp && wp.marker) wp.marker.setDraggable(false); });
            
            stopGpsWatching();  
            
            getCurrentLocation(
                (initialCoords) => { navigationCurrentLocation = initialCoords; updateInitialUserPosition(initialCoords, navigationMapInstance); },
                (errorMsg) => { showToast(`No se pudo obtener tu ubicaci√≥n inicial: ${errorMsg}. El mapa se centrar√° cuando el GPS est√© listo.`, "warning", 5000); }
            );
            startGpsWatching();
            const loadingToast = document.getElementById("gps-init-toast"); if (loadingToast) loadingToast.remove(); activeToasts = activeToasts.filter(t => t.id !== "gps-init-toast");
            
            isNavigating = true;
            startMemoryManagement(true); 
            startDeviationChecker(); 
            mapHeaderButtonsVisible = false;
            toggleMapHeaderRowsVisibility(false);
            
            const routeData = navigationCurrentRouteData.routes[0];
            if (routeData) {
                tripInitialDurationSec = routeData.duration;
                tripInitialDistanceMeters = routeData.distance;
                tripInitialOverallEtaTime = new Date(Date.now() + routeData.duration * 1000);
                if (routeData.legs && routeData.legs.length > 0) {
                    currentStageInitialExpectedEtaTime = new Date(Date.now() + routeData.legs[0].duration * 1000);
                }
                if (!isRecovery) {
                    originalTripEtaTime = tripInitialOverallEtaTime; 
                }
            }
                  
            const toastMessage = isRecovery ? "Navegaci√≥n reanudada." : "Navegaci√≥n iniciada. Esperando movimiento...";
            showToast(toastMessage, "success");

            currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviaci√≥n ETA';
            initializeNavigationGraph();
            const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox'); if (radaresRutaCheckbox && radaresRutaCheckbox.checked) { toggleRadaresRuta(true); }
            const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox'); if (tareasRutaCheckbox && tareasRutaCheckbox.checked) { toggleTareasRuta(true); }
            if (navigationMapInstance) {
                shouldCenterOnUser = true; 
                navigationFollowUser = true;
                updateLocateMeButtonsUI();
                const locateMeButton = document.getElementById('locate-me-on-reminders-map');
                if (locateMeButton) {
                    const locateMeImg = locateMeButton.querySelector('img');
                    if (locateMeImg) locateMeImg.src = "PNG/DEJARSEGUIR.PNG";
                    locateMeButton.title = "Dejar de centrar el mapa en mi posici√≥n";
                }
                const startCoords = navigationCurrentLocation 
                    ? [navigationCurrentLocation.longitude, navigationCurrentLocation.latitude] 
                    : [navigationWaypoints[0].lng, navigationWaypoints[0].lat];
                const savedViewMode = localStorage.getItem(MAP_VIEW_MODE_KEY) || 'static';
                const modeDetails = MAP_VIEW_MODES[Object.keys(MAP_VIEW_MODES).find(key => MAP_VIEW_MODES[key].mode === savedViewMode)] || MAP_VIEW_MODES.NORTE;
                let pitchToUse = 0;
                if (modeDetails.mode === 'static') {
                    pitchToUse = 0; 
                } else {
                    pitchToUse = mapPitchValue; 
                }
                const initialFlyToOptions = { center: startCoords, zoom: 17.5, pitch: pitchToUse, essential: true, duration: 1500 };
                if ((modeDetails.mode === 'heading' || modeDetails.mode === 'perspective') && navigationCurrentLocation && navigationCurrentLocation.heading !== null) {
                    initialFlyToOptions.bearing = navigationCurrentLocation.heading;
                } else {
                    initialFlyToOptions.bearing = modeDetails.bearing;
                }
                navigationMapInstance.flyTo(initialFlyToOptions);
            }
        } else {
            try {
                const initialCoords = await getCurrentLocationAsync();
                startFreeDrive(initialCoords);
            } catch (error) {
                showToast(`No se pudo obtener la ubicaci√≥n para iniciar el modo libre: ${error.message}`, "error");
            }
        }
    }
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    setNavigationMapClickHandler(); 
    actualizarContadorRadares(radaresEnRutaActual.length);
    actualizarContadorTareas(tareasEnRutaActual.length);
}

// ===================================================================
// NOMBRE: restoreTripProgress (VERSI√ìN FINAL CON L√ìGICA DE ESTABILIZACI√ìN)
// RESUMEN: Restaura el viaje, y si es una recarga controlada, espera a que la memoria se estabilice antes de mostrar la UI.
async function restoreTripProgress(recoveryInfo) {
    if (!navigationCurrentRouteData?.routes?.[0] || !recoveryInfo) {
        console.warn("[Recovery] Datos insuficientes para restaurar el progreso del viaje.");
        const overlay = document.getElementById('route-recovery-overlay');
        if (overlay) overlay.classList.add('hidden');
        return;
    }

    try {
        const route = navigationCurrentRouteData.routes[0];
        const isSimulatedRecovery = recoveryInfo.simulationState && recoveryInfo.simulationState.isSimulating;
        
        let currentCoords = null;
        let carDistanceAlongRoute;

        if (isSimulatedRecovery) {
            carDistanceAlongRoute = recoveryInfo.simulationState.distance;
        } else {
            currentCoords = await getCurrentLocationAsync();
            const carPoint = turf.point([currentCoords.longitude, currentCoords.latitude]);
            const routeLine = turf.lineString(route.geometry.coordinates);
            carDistanceAlongRoute = turf.nearestPointOnLine(routeLine, carPoint, { units: 'meters' }).properties.location;
            
            const physicalDistanceToRoute = turf.pointToLineDistance(carPoint, routeLine, { units: 'meters' });
            if (physicalDistanceToRoute > 25) {
                console.warn(`[Recovery] Desv√≠o de ${physicalDistanceToRoute.toFixed(0)}m detectado. Forzando rec√°lculo.`);
                showToast("Desv√≠o detectado al reanudar. Recalculando ruta...", "warning");
                showDeviationModal();
                const overlay = document.getElementById('route-recovery-overlay');
                if (overlay) overlay.classList.add('hidden');
                hideRecoveryScreenshotOverlay();
                return;
            }
        }
      
        navigationStartTimeForStats = new Date(recoveryInfo.tripStartTime);
        if (recoveryInfo.originalTripEtaTime) originalTripEtaTime = new Date(recoveryInfo.originalTripEtaTime);

        if (!recoveryInfo.isRichRecovery) {
            totalDistanceTravelledForStats = carDistanceAlongRoute;
            accumulatedDistanceBeforeCurrentSegment = carDistanceAlongRoute;
            if(currentCoords) lastPositionForStats = { ...currentCoords };
            const timeElapsedS = (Date.now() - recoveryInfo.tripStartTime) / 1000;
            window.averageSpeedKmh = (timeElapsedS > 0 && totalDistanceTravelledForStats > 0) ? (totalDistanceTravelledForStats / timeElapsedS) * 3.6 : 0;
        } else { // Si es "rica", simplemente las cargamos
            if (recoveryInfo.stats) {
                totalDistanceTravelledForStats = recoveryInfo.stats.totalDistance || 0;
                accumulatedDistanceBeforeCurrentSegment = totalDistanceTravelledForStats;
                maxSpeedDuringTrip = recoveryInfo.stats.maxSpeed || 0;
                maxAltitudeDuringTrip = recoveryInfo.stats.maxAltitude || -Infinity;
                minAltitudeDuringTrip = recoveryInfo.stats.minAltitude || Infinity;
                maxSpeedCoordinates = recoveryInfo.stats.maxSpeedCoords || null;
            }
            if(currentCoords) lastPositionForStats = { ...currentCoords };
            if (recoveryInfo.tripContext) {
                graphLabels = recoveryInfo.tripContext.graphLabels || [];
                graphDataPoints = recoveryInfo.tripContext.graphDataPoints || { speed: [], altitude: [] };
                minAverageSpeedInTrip = recoveryInfo.tripContext.minAvgSpeed ?? Infinity;
                maxAverageSpeedInTrip = recoveryInfo.tripContext.maxAvgSpeed ?? -Infinity;
                accumulatedDeviationMs = recoveryInfo.tripContext.accumulatedDeviationMs || 0;
            }
        }
        
        lastCarDistanceAlongRouteForNavLogic = carDistanceAlongRoute;
        deviationCheckGracePeriodUntil = 0;

        let cumulativeDistance = 0;
        let legFound = false;
        
        if (route.legs && route.legs.length > 0) {
            for (let i = 0; i < route.legs.length; i++) {
                const leg = route.legs[i];
                if (!leg || !leg.steps) continue;
                const legTotalDistance = leg.distance || 0;
                // Usamos un peque√±o margen para evitar errores de redondeo al final de la ruta
                if (carDistanceAlongRoute <= cumulativeDistance + legTotalDistance + 0.1) {
                    currentLegIndexNav = i;
                    let legDistanceTraveled = 0;
                    for (let j = 0; j < leg.steps.length; j++) {
                        const step = leg.steps[j];
                        if (step && carDistanceAlongRoute <= cumulativeDistance + legDistanceTraveled + (step.distance || 0) + 0.1) {
                            currentStepIndexNav = j;
                            legFound = true;
                            break;
                        }
                        legDistanceTraveled += (step?.distance || 0);
                    }
                    if (legFound) break;
                }
                cumulativeDistance += legTotalDistance;
            }
        }

        // Safety net: si la distancia es mayor que la ruta, nos situamos al final
        if (!legFound) {
            currentLegIndexNav = route.legs.length > 0 ? route.legs.length - 1 : 0;
            const lastLeg = route.legs[currentLegIndexNav];
            currentStepIndexNav = (lastLeg && lastLeg.steps.length > 0) ? lastLeg.steps.length - 1 : 0;
        }

        updateNavigationProgressDisplay(route, carDistanceAlongRoute);
        updateTurnByTurnDisplay(route, carDistanceAlongRoute);
        if (navigationChart) updateChartData();

        await toggleNavigationState(false, true);

        if (isSimulatedRecovery) {
            showToast("Reanudando simulaci√≥n de ruta...", "success", 3000);
            startAutomatedRouteSimulation(recoveryInfo.simulationState.speed, recoveryInfo.simulationState.distance);
        }
       
    } catch (error) {
        console.error("Error al restaurar progreso del viaje:", error);
        showToast(`Error al restaurar progreso: ${error.message}. Se continuar√° desde el inicio.`, "error");
        navigationStartTimeForStats = new Date();
        totalDistanceTravelledForStats = 0;
        accumulatedDistanceBeforeCurrentSegment = 0;
    } finally {
        const overlay = document.getElementById('route-recovery-overlay');
        if (overlay) {
            setTimeout(() => {
                overlay.classList.add('hidden');
            }, 600);
        }
        hideRecoveryScreenshotOverlay();
    }
}    
    
// ===================================================================
// NOMBRE: manageMemoryCycle 
// ===================================================================
async function manageMemoryCycle() {
    if (!isNavigating && !isFreeDriveActive && !automatedSimulationIntervalId) {
        return;
    }
    if (isPerformingControlledReload) {
        return;
    }

    if (Date.now() < memoryCheckGracePeriodUntil) {
        return;
    }
  
    if (navigationMapInstance) {
        navigationMapInstance.triggerRepaint();
    }

    if (typeof performance !== 'undefined' && performance.memory) {
        const memoryInfo = performance.memory;
        const memoryUsageRatio = memoryInfo.usedJSHeapSize / memoryInfo.jsHeapSizeLimit;
        
        const MEMORY_THRESHOLD = memoryReloadThreshold; 

        if (memoryUsageRatio > MEMORY_THRESHOLD) {
            initiateControlledReload();
        } else {
            console.log(`[Memory Manager] Uso de memoria (${(memoryUsageRatio * 100).toFixed(1)}%) es aceptable (Umbral: ${MEMORY_THRESHOLD * 100}%).`);
        }
    } else {
    }
}    
    
// ===================================================================
// NOMBRE: startMemo
// RESUMEN: Inicia/detiene los temporizadores para el reinicio ligero (peri√≥dico) y la recarga pesada (por umbral).
let memoryManagementInterval = null;

function startMemoryManagement(start) { 
    if (memoryManagementInterval) {
        clearInterval(memoryManagementInterval);
        memoryManagementInterval = null;
    }
  
    if (start) {
        const HEAVY_RELOAD_CHECK_INTERVAL_MS = 2 * 60 * 1000; // DESPUES DE LOS 3 MINUTOS CADA 2
        setTimeout(manageMemoryCycle, 180000);  // PRIMERA A LOS 3 MINUTOS 
        memoryManagementInterval = setInterval(manageMemoryCycle, HEAVY_RELOAD_CHECK_INTERVAL_MS);

    } else {
    }
} 

// ===================================================================
// NOMBRE: CompassAndStatsControl
// RESUMEN: Control que muestra br√∫jula, altitud, velocidades y un men√∫ de acci√≥n radial con 5 opciones.
class CompassAndStatsControl {
    constructor(options) {
        this.options = options || {};
        this.lastAppliedHeading = null;
        this.lastAppliedOrientationText = null;
        this.lastAppliedAltitudeText = null;
        this.lastAppliedCurrentSpeedText = null;
        this.lastAppliedAverageSpeedText = null;
        this.lastAppliedMaxSpeedText = null;
        this.radialMenuVisible = false;
        this.pressTimer = null;
    }

    _hideRadialMenuOnClickOutside(e) {
        if (this.radialMenuVisible && this._container && !this._container.contains(e.target)) {
            this._toggleRadialMenu(false);
        }
    }

    onAdd(map) {
        this._map = map;
        this._boundHideMenu = this._hideRadialMenuOnClickOutside.bind(this);
        document.addEventListener('click', this._boundHideMenu, true);

        this._container = document.createElement('div');
        this._container.className = 'mapboxgl-ctrl map-control-custom-map-controls';
        
        const compassContainer = document.createElement('div');
        compassContainer.className = 'map-control-orientation-altitude';
        compassContainer.innerHTML = `
            <img id="compass-rose-icon" src="PNG/ROSA.PNG" alt="Orientaci√≥n">
            <span id="orientation-text">---</span>
            <span id="altitude-display">--- m</span>
            <span id="current-speed-display">--- km/h</span>
            <span id="average-speed-display" class="speed-stats-text">Med: --- km/h</span>
            <span id="max-speed-display" class="speed-stats-text">M√°x: --- km/h</span>
        `;
        
        let touchStartX = 0, touchStartY = 0, isGestureActionTaken = false; 

        const handleGestureStart = (e) => {
            if (e.target.closest('.radial-menu-button')) {
                return;
            }
            e.preventDefault();
            isGestureActionTaken = false;
            const touch = e.touches ? e.touches[0] : e;
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            clearTimeout(this.pressTimer);
            
            this.pressTimer = setTimeout(() => {
                isGestureActionTaken = true; 
                this._toggleRadialMenu(!this.radialMenuVisible);
            }, 350);
        };

        const handleGestureMove = (e) => {
            if (touchStartX === 0) return;
            const touch = e.touches ? e.touches[0] : e;
            const moveX = touch.clientX;
            const moveY = touch.clientY;
            if (Math.abs(moveX - touchStartX) > 15 || Math.abs(moveY - touchStartY) > 15) {
                clearTimeout(this.pressTimer);
            }
        };

        const handleGestureEnd = (e) => {
            clearTimeout(this.pressTimer);
            if (e.target.closest('.radial-menu-button')) {
                return;
            }
            if (touchStartX === 0 || isGestureActionTaken) return; 
            
            const touch = e.changedTouches ? e.changedTouches[0] : e;
            const endX = touch.clientX;
            const endY = touch.clientY;
            const deltaX = endX - touchStartX;
            const deltaY = endY - touchStartY;
            const swipeThreshold = 50;

            if (Math.abs(deltaX) > swipeThreshold || Math.abs(deltaY) > swipeThreshold) {
                isGestureActionTaken = true;
                if (Math.abs(deltaX) > Math.abs(deltaY)) { 
                    if (deltaX > 0) showQuickReminderModal(); 
                    else { const radarButton = document.getElementById('add-radar-here'); if (radarButton) handleAddRadarHereClick(radarButton); }
                } else { 
                    if (deltaY > 0) togglePoiCategorySearch();
                    else openAiPlannerModal(); 
                }
            } else {
                if (!isGestureActionTaken) {
                    if (this.radialMenuVisible) {
                        this._toggleRadialMenu(false);
                    }
                    this._toggleGraphMode(e);
                }
            }
            touchStartX = 0;
            touchStartY = 0;
        };

        compassContainer.addEventListener('mousedown', handleGestureStart);
        compassContainer.addEventListener('mousemove', handleGestureMove);
        compassContainer.addEventListener('mouseup', handleGestureEnd);
        compassContainer.addEventListener('mouseleave', () => { clearTimeout(this.pressTimer); touchStartX=0; touchStartY=0; });
        compassContainer.addEventListener('touchstart', handleGestureStart, { passive: false });
        compassContainer.addEventListener('touchmove', handleGestureMove, { passive: false });
        compassContainer.addEventListener('touchend', handleGestureEnd);

        compassContainer.title = "Clic: Gr√°fica | Gestos: Atajos | Pulsaci√≥n Larga: Men√∫ R√°pido";

        const graphCard = document.createElement('div');
        graphCard.className = 'hidden';
        graphCard.id = 'navigation-graph-card';
        graphCard.style.position = 'relative'; 
        graphCard.style.cursor = 'pointer';
        graphCard.addEventListener('click', toggleEnlargedGraph);
        
        const graphTitle = document.createElement('div');
        graphTitle.id = 'navigation-graph-title';
        graphCard.appendChild(graphTitle);

        const enlargeButton = document.createElement('div');
        enlargeButton.id = 'enlarge-graph-button';
        enlargeButton.title = 'Ampliar/Reducir gr√°fica';
        enlargeButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>`;
        enlargeButton.addEventListener('click', (e) => { e.stopPropagation(); toggleEnlargedGraph(); });
        graphCard.appendChild(enlargeButton);

        const graphCanvasContainer = document.createElement('div');
        graphCanvasContainer.id = 'navigation-graph-container';
        const canvas = document.createElement('canvas');
        canvas.id = 'navigation-chart';
        graphCanvasContainer.appendChild(canvas);
        graphCard.appendChild(graphCanvasContainer);
        
        this._container.appendChild(this._createRadialMenu());
        this._container.appendChild(compassContainer);
        this._container.appendChild(graphCard);
        this._updateGraphTitle();
        return this._container;
    }


    _createRadialMenu() {
        this.radialMenu = document.createElement('div');
        this.radialMenu.className = 'radial-menu-container';
                                                                                                      
         const radialButtons = [
            { id: 'radial-add-radar', icon: 'PNG/RADARAQUI.PNG', title: 'A√±adir Radar Aqu√≠', action: () => { const btn = document.getElementById('add-radar-here'); if (btn) handleAddRadarHereClick(btn); } }, 
            { id: 'radial-ai', icon: 'PNG/IA.PNG', title: 'Asistente IA de Rutas', action: () => openAiPlannerModal() },
            { id: 'radial-pdr', icon: 'PNG/pdrs.png', title: 'Buscar Puntos de Recarga', action: () => handlePdrSearchButtonClick() },
            { id: 'radial-range-calc', icon: 'PNG/radio.png', title: 'Calcular Radio de Acci√≥n', action: () => toggleRangeCalcMode() },
            { id: 'radial-poi', icon: './PNG/ANADIRPUNTO.jpg', title: 'Buscar Puntos de Inter√©s', action: () => togglePoiCategorySearch() },
            { id: 'radial-quick-reminder', icon: 'https://boardinggate.github.io/Tesla/PNG/IMG_4197.jpg', title: 'Crear Recordatorio R√°pido', action: () => showQuickReminderModal() }
        ];                                                                                                   
      
        radialButtons.forEach(btnInfo => {
            const button = document.createElement('button');
            button.id = btnInfo.id;
            button.className = 'radial-menu-button';
            button.title = btnInfo.title;
            button.innerHTML = `<img src="${btnInfo.icon}" alt="${btnInfo.title}">`;
            
            button.addEventListener('click', (e) => {
                e.stopPropagation();
                btnInfo.action();
                this._toggleRadialMenu(false);
            });
            
            this.radialMenu.appendChild(button);
        });

        return this.radialMenu;
    }

    _toggleRadialMenu(show) {
        if (this.radialMenu) {
            this.radialMenuVisible = show;
            this.radialMenu.classList.toggle('active', show);
        }
    }

    onRemove() {
        document.removeEventListener('click', this._boundHideMenu, true);
        if (this._container && this._container.parentNode) {
            this._container.parentNode.removeChild(this._container);
        }
        this._map = undefined;
    }
    
    _toggleGraphMode(e) {
        if (e) e.stopPropagation();
        if (!navigationCurrentRouteData && !isFreeDriveActive) {
            showToast("La gr√°fica estar√° disponible cuando se calcule una ruta o inicies un viaje libre.", "info");
            return;
        }
        const modes = ['Desviaci√≥n ETA', 'Altitud', 'Gr√°fica off'];
        let currentIndex = modes.indexOf(currentGraphMode);
        currentIndex = (currentIndex + 1) % modes.length;
        currentGraphMode = modes[currentIndex];
        localStorage.setItem(GRAPH_STATE_KEY, currentGraphMode); 
        updateNavigationGraphVisibilityAndMode();
        if (currentGraphMode !== 'Gr√°fica off') {
            showToast(`Gr√°fica cambiada a: ${currentGraphMode}`, 'info');
        } else {
            showToast(`Gr√°fica desactivada`, 'info');
        }
    }

    _updateGraphTitle() {
        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            if (currentGraphMode === 'Desviaci√≥n ETA') {
                graphTitleElement.textContent = 'Desviaci√≥n ETA';
            } else if (currentGraphMode === 'Altitud') {
                graphTitleElement.textContent = 'Desnivel Ruta';
            } else {
                graphTitleElement.textContent = ''; 
            }
        }
    }
    
    updateOrientation(heading) {
        const compassRoseIcon = document.getElementById('compass-rose-icon');
        const orientationText = document.getElementById('orientation-text');
        if (!compassRoseIcon || !orientationText) return;

        if (heading !== null && !isNaN(heading) && heading >= 0 && heading <= 360) {
            const roundedHeading = Math.round(heading);
            
            if (this.lastAppliedHeading !== roundedHeading) {
                compassRoseIcon.style.transform = `rotate(-${roundedHeading}deg)`;
                this.lastAppliedHeading = roundedHeading;
            }
            
            currentMapBearing = heading;
            
            const directions = ["N", "NnE", "NE", "EnE", "E", "EsE", "SE", "SsE", "S", "SsO", "SO", "OsO", "O", "OnO", "NO", "NnO", "N"];
            const index = Math.round(heading / 22.5) % 16;
            const newOrientationText = `${directions[index]} (${roundedHeading}¬∞)`;
            
            if (this.lastAppliedOrientationText !== newOrientationText) {
                orientationText.textContent = newOrientationText;
                this.lastAppliedOrientationText = newOrientationText;
            }
        } else {
            if (this.lastAppliedHeading !== 0) {
                compassRoseIcon.style.transform = 'rotate(0deg)';
                this.lastAppliedHeading = 0;
            }
            if (this.lastAppliedOrientationText !== '---') {
                orientationText.textContent = '---';
                this.lastAppliedOrientationText = '---';
            }
            currentMapBearing = 0;
        }
    }
    
    updateAltitude(altitude) {
        const altitudeDisplay = document.getElementById('altitude-display');
        if (!altitudeDisplay) return;

        let newDisplayText = '--- m';
        if (altitude !== null && !isNaN(altitude)) {
            newDisplayText = `${altitude.toFixed(0)} m`;
            if (maxAltitudeDuringTrip !== -Infinity && isNavigating) {
                newDisplayText += ` \u2261 ${maxAltitudeDuringTrip.toFixed(0)} m`;
            }
        } else if (isNavigating && maxAltitudeDuringTrip !== -Infinity) {
             newDisplayText = `-- m \u2261 ${maxAltitudeDuringTrip.toFixed(0)} m`;
        }

        if (this.lastAppliedAltitudeText !== newDisplayText) {
            altitudeDisplay.textContent = newDisplayText;
            this.lastAppliedAltitudeText = newDisplayText;
        }
    }

    updateCurrentSpeed(speedKmh) {
        const speedDisplay = document.getElementById('current-speed-display');
        if (!speedDisplay) return;

        let newDisplayText = '--- km/h';
        if (speedKmh !== null && !isNaN(speedKmh)) {
            newDisplayText = `${speedKmh.toFixed(1)} km/h`;
        }

        if (this.lastAppliedCurrentSpeedText !== newDisplayText) {
            speedDisplay.textContent = newDisplayText;
            this.lastAppliedCurrentSpeedText = newDisplayText;
        }
    }

    updateAverageSpeed(avgSpeedKmh) {
        const avgSpeedDisplay = document.getElementById('average-speed-display');
        if (!avgSpeedDisplay) return;

        let newDisplayText = 'Med: --- km/h';
        if (avgSpeedKmh !== null && !isNaN(avgSpeedKmh) && (isNavigating || (isSimulatingGpsLocation && automatedSimulationIntervalId) || isFreeDriveActive)) {
             newDisplayText = `Med: ${avgSpeedKmh.toFixed(1)} km/h`;
        }
        
        if (this.lastAppliedAverageSpeedText !== newDisplayText) {
            avgSpeedDisplay.textContent = newDisplayText;
            this.lastAppliedAverageSpeedText = newDisplayText;
        }
    }

    updateMaxSpeed(currentSpeedKmh, currentCoords) {
        if (typeof currentSpeedKmh === 'number' && currentSpeedKmh > maxSpeedDuringTrip) {
            maxSpeedDuringTrip = currentSpeedKmh;
            if (currentCoords) {
                maxSpeedCoordinates = { lat: currentCoords.latitude, lng: currentCoords.longitude };
            }
        }
        const maxSpeedDisplay = document.getElementById('max-speed-display');
        if (!maxSpeedDisplay) return;
        
        let newDisplayText = 'M√°x: --- km/h'; 
        if (typeof maxSpeedDuringTrip === 'number' && !isNaN(maxSpeedDuringTrip)) {
            if (maxSpeedDuringTrip > 0) {
                newDisplayText = `M√°x: ${maxSpeedDuringTrip.toFixed(1)} km/h`;
            } else if ((isNavigating || (isSimulatingGpsLocation && automatedSimulationIntervalId) || isFreeDriveActive) && maxSpeedDuringTrip === 0) {
                newDisplayText = `M√°x: 0.0 km/h`;
            }
        }
        
        if (this.lastAppliedMaxSpeedText !== newDisplayText) {
            maxSpeedDisplay.textContent = newDisplayText;
            this.lastAppliedMaxSpeedText = newDisplayText;
        }
    }
}
     
// ===================================================================
// NOMBRE: CustomMapControlsGroup 
// RESUMEN: Gestiona la barra horizontal y los paneles emergentes.
class CustomMapControlsGroup {
    onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.className = 'mapboxgl-ctrl map-controls-bottom-right';
        
        this._settingsPopup = document.createElement('div');
        this._settingsPopup.className = 'map-settings-popup';
        const settingsPanel = new MapSettingsPanel(map);
        this._settingsPopup.appendChild(settingsPanel.createPanelContent());
        
        this._offsetPopup = document.createElement('div');
        this._offsetPopup.className = 'map-offset-popup';
        
        this._offsetPopup.innerHTML = `
            <div class="crosshair-container" style="position: relative;">
                <div id="offset-value-display-y" class="offset-value-display vertical"></div>

                <button id="offset-arrow-up" class="offset-arrow" title="Mover vista hacia arriba">
                    <svg viewBox="0 0 24 24"><path d="M12 19V5M5 12l7-7 7 7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
                <button id="offset-arrow-left" class="offset-arrow" title="Mover vista a la izquierda">
                    <svg viewBox="0 0 24 24"><path d="M19 12H5M12 5l-7 7 7 7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>

                <!-- NUEVO: Contenedor para el valor X (Horizontal) -->
                <div id="offset-value-display-x" class="offset-value-display horizontal"></div>
                
                <div id="minimap-toggle-container">
                    <input type="checkbox" id="minimap-toggle-checkbox">
                    <label for="minimap-toggle-checkbox">Giros</label>
                </div>
                <button id="offset-arrow-right" class="offset-arrow" title="Mover vista a la derecha">
                    <svg viewBox="0 0 24 24"><path d="M5 12h14M12 5l7 7-7 7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
                <button id="offset-arrow-down" class="offset-arrow" title="Mover vista hacia abajo">
                    <svg viewBox="0 0 24 24"><path d="M12 5v14M19 12l-7 7-7-7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
                
            </div>
            <div class="offset-popup-separator"></div>
            <div class="pitch-controls-container">
                <button id="pitch-arrow-up" class="offset-arrow" title="Aumentar inclinaci√≥n (pitch)">
                    <svg viewBox="0 0 24 24"><path d="M12 19V5M5 12l7-7 7 7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
                <span id="pitch-value-display" class="pitch-value-display">0¬∞</span>
                <button id="pitch-arrow-down" class="offset-arrow" title="Reducir inclinaci√≥n (pitch)">
                    <svg viewBox="0 0 24 24"><path d="M12 5v14M19 12l-7 7-7-7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
            </div>
        `;
      
        this.zoomControl = new ZoomControl(this); 
        const zoomControlElement = this.zoomControl.onAdd(map);
        
        this._container.appendChild(this._settingsPopup);
        this._container.appendChild(this._offsetPopup);
        this._container.appendChild(zoomControlElement);
        
        this._popupTimer = null; 
        this._offsetPopupTimer = null;

        this._offsetPopup.querySelector('#offset-arrow-up').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapOffset('y', -1); });
        this._offsetPopup.querySelector('#offset-arrow-down').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapOffset('y', 1); });
        this._offsetPopup.querySelector('#offset-arrow-left').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapOffset('x', 1); });
        this._offsetPopup.querySelector('#offset-arrow-right').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapOffset('x', -1); });
        
        this._offsetPopup.querySelector('#pitch-arrow-up').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapPitch(1); });
        this._offsetPopup.querySelector('#pitch-arrow-down').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapPitch(-1); });
        
        const pitchDisplay = this._offsetPopup.querySelector('#pitch-value-display');
        pitchDisplay.style.cursor = 'pointer';
        pitchDisplay.title = 'Pulsar para restaurar inclinaci√≥n por defecto del modo actual';
        pitchDisplay.addEventListener('click', (e) => {
            e.stopPropagation();
            triggerManualMapInteraction();

            const viewModes = {
                'NORTE': { pitch: 0, bearing: 0, mode: 'static', terrain: false },
                'AVANCE': { pitch: 0, bearing: null, mode: 'heading', terrain: false },
                '3D': { pitch: 62, bearing: null, mode: 'perspective', terrain: false },
                '3D RELIEVE': { pitch: 73, bearing: null, mode: 'relief', terrain: true }
            };

            const currentModeDetails = Object.values(viewModes).find(m => m.mode === mapViewMode);
            const currentModeName = Object.keys(viewModes).find(key => viewModes[key].mode === mapViewMode);

            let targetPitch = 0; 
            if (currentModeDetails) {
                targetPitch = currentModeDetails.pitch;
            }

            mapPitchValue = targetPitch; 
            localStorage.setItem(MAP_VIEW_PITCH_KEY, mapPitchValue); 
            markCacheAsDirty();

            this._map.easeTo({ pitch: targetPitch, duration: 500 });
            showToast(`Pitch restaurado al valor por defecto de ${currentModeName} (${targetPitch}¬∞)`, 'info');
         });
        
        const minimapCheckbox = this._offsetPopup.querySelector('#minimap-toggle-checkbox');
        minimapCheckbox.checked = showMinimapPreference;
        minimapCheckbox.addEventListener('change', (e) => {
            e.stopPropagation();
            showMinimapPreference = e.target.checked;
            saveSettings();
            showToast(`Minimapa de maniobras ${showMinimapPreference ? 'ACTIVADO' : 'DESACTIVADO'}`, 'info');
        });

        this._map.on('pitch', () => this.updatePitchDisplay());

        return this._container;
    }

    updateOffsetDisplay(x = mapOffsetX, y = mapOffsetY) {
        const displayX = this._offsetPopup.querySelector('#offset-value-display-x');
        const displayY = this._offsetPopup.querySelector('#offset-value-display-y');
        if (displayX) {
            displayX.textContent = `X : ${Math.round(x)}%`;
        }
        if (displayY) {
            displayY.textContent = `Y : ${Math.round(y)}%`;
        }
    }
   
    updatePitchDisplay() {
        const display = this._offsetPopup.querySelector('#pitch-value-display');
        if (display) {
            display.textContent = `${this._map.getPitch().toFixed(0)}¬∞`;
        }
    }

    adjustMapOffset(axis, amount) {
        triggerManualMapInteraction(); 
        if (axis === 'y') {
            mapOffsetY = Math.max(-75, Math.min(75, mapOffsetY + amount));
        } else if (axis === 'x') {
            mapOffsetX = Math.max(-75, Math.min(75, mapOffsetX + amount));
        }
        this.updateOffsetDisplay();
        saveSettings();
        if (isNavigating && navigationCurrentLocation && navigationMapInstance) {
            updateInitialUserPosition(navigationCurrentLocation, navigationMapInstance);
        }
    }

    adjustMapPitch(amount) {
        triggerManualMapInteraction(); 
        const currentPitch = this._map.getPitch();
        const newPitch = Math.max(0, Math.min(85, currentPitch + amount));
        mapPitchValue = newPitch; 
        saveSettings();
        this._map.easeTo({ pitch: newPitch, duration: 300 });
       }

    toggleSettingsPopup() {
        if (this._offsetPopup.classList.contains('visible')) this.toggleOffsetPopup();
        if (this._settingsPopup.classList.contains('visible')) {
            this._settingsPopup.classList.remove('visible');
            if (this._popupTimer) { clearTimeout(this._popupTimer); this._popupTimer = null; }
        } else {
            this._settingsPopup.classList.add('visible');
            if (this._popupTimer) clearTimeout(this._popupTimer);
            this._popupTimer = setTimeout(() => { this._settingsPopup.classList.remove('visible'); this._popupTimer = null; }, 80000);
        }
    }

    toggleOffsetPopup() {
        if (this._settingsPopup.classList.contains('visible')) this.toggleSettingsPopup();
        if (this._offsetPopup.classList.contains('visible')) {
            this._offsetPopup.classList.remove('visible');
            if (this._offsetPopupTimer) { clearTimeout(this._offsetPopupTimer); this._offsetPopupTimer = null; }
        } else {
            this.updateOffsetDisplay();
            this.updatePitchDisplay();
            this._offsetPopup.classList.add('visible');
            if (this._offsetPopupTimer) clearTimeout(this._offsetPopupTimer);
            this._offsetPopupTimer = setTimeout(() => { this._offsetPopup.classList.remove('visible'); this._offsetPopupTimer = null; }, 80000);
        }
    }

    onRemove() {
        if (this.zoomControl) this.zoomControl.onRemove();
        if (this._popupTimer) clearTimeout(this._popupTimer);
        if (this._offsetPopupTimer) clearTimeout(this._offsetPopupTimer);
        if (this._container && this._container.parentNode) this._container.parentNode.removeChild(this._container);
        this._map = undefined;
    }
} 
  

// ===================================================================
// NOMBRE: ZoomControl 
// RESUMEN: Gestiona el zoom. Un clic en el n√∫mero alterna el pitch.
class ZoomControl {
    constructor(parentControl) {
        this.parentControl = parentControl;
    }
        onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.id = 'zoom-controls-horizontal';
        
        const zoomInBtn = document.createElement('div');
        zoomInBtn.className = 'zoom-control-button';
        zoomInBtn.textContent = '+';
        zoomInBtn.title = 'Acercar';

        const zoomOutBtn = document.createElement('div');
        zoomOutBtn.className = 'zoom-control-button';
        zoomOutBtn.textContent = '‚àí';
        zoomOutBtn.title = 'Alejar';

        const levelDisplay = document.createElement('div');
        levelDisplay.id = 'zoom-level-display';
        levelDisplay.style.cssText = 'color: white; font-weight: bold; text-shadow: 1px 1px 2px black; min-width: 40px; text-align: center;';
        levelDisplay.textContent = map.getZoom().toFixed(1);

        levelDisplay.style.cursor = 'pointer';
        levelDisplay.title = 'Clic: Alternar inclinaci√≥n (pitch) | Pulsaci√≥n Larga: Alternar zoom (5.5 / 11)';

        let pressTimer = null;
        let isLongPress = false;

        const handlePressStart = (e) => {
            e.preventDefault(); 
            isLongPress = false;
            pressTimer = setTimeout(() => {
                isLongPress = true; 
                triggerManualMapInteraction();
                
                const currentZoom = map.getZoom();
                const continentalZoom = 5.5;
                const regionalZoom = 11;
                
                let targetZoom;
                let toastMessage;

                if (currentZoom > ((continentalZoom + regionalZoom) / 2)) {
                    targetZoom = continentalZoom;
                } else {
                    targetZoom = regionalZoom;
                }
                
                map.easeTo({ zoom: targetZoom, duration: 400 });
           
            }, 500); 
        };

        const handlePressEnd = (e) => {
            clearTimeout(pressTimer);
            if (!isLongPress) {
                e.stopPropagation();
                triggerManualMapInteraction();

                if (isPitchManuallyFlattened) {
                    const currentModeDetails = Object.values(MAP_VIEW_MODES).find(m => m.mode === mapViewMode);
                    const defaultPitch = currentModeDetails ? currentModeDetails.pitch : 0;
                    const modeName = Object.keys(MAP_VIEW_MODES).find(key => MAP_VIEW_MODES[key].mode === mapViewMode) || "Desconocido";
                    
                    map.easeTo({ pitch: defaultPitch });
                    showToast(`Pitch restaurado al valor por defecto del modo (${modeName})`, 'info');
                    isPitchManuallyFlattened = false;
                } else {
                    map.easeTo({ pitch: 0 });
                    showToast('Pitch ajustado a 0¬∞ (vista cenital)', 'info');
                    isPitchManuallyFlattened = true;
                }
            }
            isLongPress = false;
        };
        
        levelDisplay.addEventListener('mousedown', handlePressStart);
        levelDisplay.addEventListener('mouseup', handlePressEnd);
        levelDisplay.addEventListener('mouseleave', () => clearTimeout(pressTimer));
        levelDisplay.addEventListener('touchstart', handlePressStart, { passive: false });
        levelDisplay.addEventListener('touchend', handlePressEnd);
        levelDisplay.addEventListener('touchcancel', () => clearTimeout(pressTimer));
       
        const autoBtn = document.createElement('div');
        autoBtn.id = 'zoom-auto-button';
        autoBtn.className = 'zoom-control-button';
        
        const locateMeBtn = document.createElement('div');
        locateMeBtn.id = 'zoom-locate-me-button';
        locateMeBtn.className = 'zoom-control-button';
        locateMeBtn.innerHTML = `<img src="PNG/ESTASAQUI.PNG" alt="Localizar">`;
        
        const toggleBtn = document.createElement('div');
        toggleBtn.id = 'zoom-toggle-button';
        toggleBtn.className = 'zoom-control-button';
        toggleBtn.innerHTML = `<img src="PNG/ZOOM+.PNG" alt="Toggle Zoom">`;

        const settingsBtn = document.createElement('div');
        settingsBtn.id = 'map-settings-toggle-button';
        settingsBtn.className = 'zoom-control-button';
        settingsBtn.title = 'Ajustes de mapa y vista';
        settingsBtn.innerHTML = `<img src="PNG/GPS.PNG" alt="Ajustes">`;
        
        const offsetBtn = document.createElement('div');
        offsetBtn.id = 'map-offset-toggle-button';
        offsetBtn.className = 'zoom-control-button';
        offsetBtn.title = 'Ajustar posici√≥n del coche en pantalla';
        offsetBtn.innerHTML = `<img src="PNG/picht.png" alt="Offset">`;

        const weatherBtn = document.createElement('div');
        weatherBtn.id = 'show-weather-button';
        weatherBtn.className = 'zoom-control-button icon-btn'; 
        weatherBtn.title = 'Mostrar/Ocultar el tiempo';
        weatherBtn.innerHTML = `üå§Ô∏è`; 
        weatherBtn.style.fontSize = '38px'; 

        weatherBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const widget = document.getElementById('weather-widget-container');
            if (widget && widget.classList.contains('visible') && Date.now() < weatherWidgetForceShowUntil) {
                stopWeatherUpdates(); // Esto ocultar√° el widget y resetear√° el temporizador.
            } else {
                weatherWidgetForceShowUntil = Date.now() + 30000; 
                showWeatherWidgetTemporarily();
            }
        });    
      
        this._container.appendChild(zoomInBtn);
        this._container.appendChild(levelDisplay);
        this._container.appendChild(zoomOutBtn);
        this._container.appendChild(autoBtn);
        this._container.appendChild(locateMeBtn);
        this._container.appendChild(toggleBtn);
        this._container.appendChild(settingsBtn);
        this._container.appendChild(offsetBtn);
        this._container.appendChild(weatherBtn); 
        
        map.on('zoom', () => {
            levelDisplay.textContent = map.getZoom().toFixed(1);
            updateAllZoomToggleButtonsVisuals();

        });
        updateAllZoomToggleButtonsVisuals();         
        
        const ZOOM_INCREMENT = 0.3;
        
        zoomInBtn.addEventListener('click', (e) => { 
            e.stopPropagation(); 
            triggerManualMapInteraction();
            map.easeTo({ zoom: map.getZoom() + ZOOM_INCREMENT }); 
        });
        zoomOutBtn.addEventListener('click', (e) => { 
            e.stopPropagation(); 
            triggerManualMapInteraction();
            map.easeTo({ zoom: map.getZoom() - ZOOM_INCREMENT }); 
        });

        const zoomModesCycle = { eco: 'auto', auto: 'route', route: 'off', off: 'eco' };
    
        const updateAutoButtonVisuals = () => {
            autoBtn.classList.remove('active', 'route-mode', 'eco-mode');

            if (currentAutoZoomMode === 'eco') {
                autoBtn.textContent = 'ECO';
                autoBtn.classList.add('active', 'eco-mode');
                autoBtn.title = 'Modo ECO: Optimiza en autopista, autom√°tico en ciudad.';
            } else if (currentAutoZoomMode === 'auto') {
                autoBtn.textContent = 'AUTO';
                autoBtn.classList.add('active'); 
                autoBtn.title = 'Zoom autom√°tico por velocidad (Activado)';
            } else if (currentAutoZoomMode === 'route') {
                autoBtn.textContent = 'RUTA';
                autoBtn.classList.add('active', 'route-mode'); 
                autoBtn.title = 'Vista general de ruta (Zoom fijo a nivel 14.5)';
            } else { 
                autoBtn.textContent = 'LIBRE';
                autoBtn.title = 'Zoom autom√°tico (Desactivado)';
            }
        };

        autoBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            currentAutoZoomMode = zoomModesCycle[currentAutoZoomMode];
            localStorage.setItem(AUTO_ZOOM_MODE_KEY, currentAutoZoomMode);
            
            if (currentAutoZoomMode !== 'off') { 
                manualZoomLevelMemory = null;
            }
            
            updateAutoButtonVisuals();
            markCacheAsDirty(); 
               
            isManualZoomActive = false;
            if (manualZoomTimeout) clearTimeout(manualZoomTimeout);

            switch (currentAutoZoomMode) { 
                case 'auto':
                case 'eco': 
                    handleAutoZoom();
                    break;
                case 'off':
                    break;
                case 'route':
                    const targetPitch = Math.max(4, mapPitchValue - 3);
                    map.easeTo({ zoom: 14.5, pitch: targetPitch });
                    break;
            }
        });
        
        updateAutoButtonVisuals();
        
        toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            handleZoomToggleButtonClick(toggleBtn);
        });
        
        locateMeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            handleLocateMeClick(true);
        });
        
        settingsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.parentControl.toggleSettingsPopup();
        });

        offsetBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.parentControl.toggleOffsetPopup();
        });

        return this._container;
    }
    onRemove() { if (this._container && this._container.parentNode) this._container.parentNode.removeChild(this._container); this._map = undefined; }
}
    
// ===================================================================
// NOMBRE: applyLayerVisibility
// RESUMEN: Lee las preferencias del usuario y aplica la visibilidad a cada grupo de capas.
function applyLayerVisibility() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
        return;
    }
    
    let visibilitySettings = {};
    try {
        visibilitySettings = JSON.parse(localStorage.getItem(LAYER_VISIBILITY_KEY)) || {};
    } catch(e) {
        visibilitySettings = {};
    }

    Object.keys(LAYER_VISIBILITY_GROUPS).forEach(groupKey => {
        const group = LAYER_VISIBILITY_GROUPS[groupKey];
        const isVisible = visibilitySettings[groupKey] !== false; 
        const targetVisibility = isVisible ? 'visible' : 'none';
        
        group.layers.forEach(layerId => {
            if (navigationMapInstance.getLayer(layerId)) {
                navigationMapInstance.setLayoutProperty(layerId, 'visibility', targetVisibility);
            }
        });
    });
}

//=========== FUNCIONES CALCULO RADIO CONSUMO ======================
//=========== FUNCIONES CALCULO RADIO CONSUMO ======================    
function toggleRangeCalcMode() {
    if (isRangeCalcModeActive) {
        deactivateRangeCalcMode();
    } else {
        showRangeCalcModal();
    }
}

function activateRangeCalcMode() {
    isRangeCalcModeActive = true;
    const button = document.getElementById('range-calculator-button');
    if (button) button.classList.add('active');
    
    const hasRoute = navigationWaypoints.filter(wp => wp && !wp.isInternal).length >= 2;
    if (!hasRoute) {
        showToast("Modo 'Radio de Acci√≥n' activado. Haz una PULSACI√ìN LARGA en el mapa para fijar el punto de partida.", "info", 6000);
    }
}

function clearRangeCircleFromMap() {
    if (navigationMapInstance) {
        if (navigationMapInstance.getLayer('range-polygon-layer')) {
            navigationMapInstance.removeLayer('range-polygon-layer');
        }
        if (navigationMapInstance.getLayer('range-polygon-outline')) {
            navigationMapInstance.removeLayer('range-polygon-outline');
        }
        if (navigationMapInstance.getSource('range-polygon-source')) {
            navigationMapInstance.removeSource('range-polygon-source');
        }
    }
}

// ===================================================================
// NOMBRE: translateWeatherDescription (NUEVA FUNCI√ìN AUXILIAR)
// RESUMEN: Traduce las descripciones del clima de wttr.in al espa√±ol.
function translateWeatherDescription(englishDesc) {
    if (!englishDesc) return "desconocido";
    const lowerDesc = englishDesc.toLowerCase();
    const WEATHER_TRANSLATIONS = {
        'clear': 'Despejado',
        'sunny': 'Soleado',
        'partly cloudy': 'Parcialmente nuboso',
        'cloudy': 'Nublado',
        'overcast': 'Cubierto',
        'mist': 'Niebla',
        'patchy rain possible': 'Posibles chubascos',
        'patchy snow possible': 'Posibles nevadas',
        'patchy sleet possible': 'Posible aguanieve',
        'patchy freezing drizzle possible': 'Posible llovizna helada',
        'thundery outbreaks possible': 'Posibles tormentas',
        'blowing snow': 'Ventisca',
        'blizzard': 'Ventisca',
        'fog': 'Niebla',
        'freezing fog': 'Niebla helada',
        'patchy light drizzle': 'Llovizna ligera',
        'light drizzle': 'Llovizna',
        'freezing drizzle': 'Llovizna helada',
        'heavy freezing drizzle': 'Llovizna helada intensa',
        'patchy light rain': 'Lluvia ligera dispersa',
        'light rain': 'Lluvia ligera',
        'rain': 'Lluvia',
        'moderate rain at times': 'Lluvia moderada a ratos',
        'moderate rain': 'Lluvia moderada',
        'heavy rain at times': 'Lluvia intensa a ratos',
        'heavy rain': 'Lluvia intensa',
        'light freezing rain': 'Lluvia helada ligera',
        'moderate or heavy freezing rain': 'Lluvia helada intensa',
        'light sleet': 'Aguanieve ligera',
        'moderate or heavy sleet': 'Aguanieve intensa',
        'patchy light snow': 'Nieve ligera dispersa',
        'light snow': 'Nieve ligera',
        'patchy moderate snow': 'Nieve moderada dispersa',
        'moderate snow': 'Nieve moderada',
        'patchy heavy snow': 'Nieve intensa dispersa',
        'heavy snow': 'Nieve intensa',
        'ice pellets': 'Granizo',
        'light rain shower': 'Chubasco ligero',
        'moderate or heavy rain shower': 'Chubasco intenso',
        'torrential rain shower': 'Chubasco torrencial',
        'light sleet showers': 'Chubascos de aguanieve',
        'moderate or heavy sleet showers': 'Chubascos de aguanieve intensos',
        'light snow showers': 'Chubascos de nieve',
        'moderate or heavy snow showers': 'Chubascos de nieve intensos',
        'light showers of ice pellets': 'Chubascos de granizo',
        'moderate or heavy showers of ice pellets': 'Chubascos de granizo intensos',
        'patchy light rain with thunder': 'Lluvia y tormenta',
        'moderate or heavy rain with thunder': 'Lluvia intensa y tormenta',
        'patchy light snow with thunder': 'Nieve y tormenta',
        'moderate or heavy snow with thunder': 'Nieve intensa y tormenta'
    };
    for (const key in WEATHER_TRANSLATIONS) {
        if (lowerDesc.includes(key)) {
            return WEATHER_TRANSLATIONS[key];
        }
    }
    return englishDesc; // Devuelve el original si no hay traducci√≥n
}

// ===================================================================
// NOMBRE: calculateAndDrawRangeCircle 
// RESUMEN: Llama a la funci√≥n de dibujo pas√°ndole el pol√≠gono real calculado para un mejor ajuste del zoom.
async function calculateAndDrawRangeCircle(startPoint) {
    if (!startPoint) {
        showToast("Punto de partida no definido.", "error");
        return;
    }

    triggerManualMapInteraction();
    
    clearRangeCircleFromMap();

    const originalCamera = {
        center: navigationMapInstance.getCenter(),
        zoom: navigationMapInstance.getZoom(),
        pitch: navigationMapInstance.getPitch(),
        bearing: navigationMapInstance.getBearing()
    };

    try {
        const params = currentRangeCalcParams;
        const usableChargePercent = params.charge - params.reserve;
        let totalAvailableEnergyKWh = params.capacity * (usableChargePercent / 100);
        
        const consumptionKwhPerKm = params.consumptionWhKm / 1000;
        const theoreticalRoadRangeKm = (consumptionKwhPerKm > 0) ? ((params.capacity * (params.charge / 100)) / consumptionKwhPerKm) : 1;
        
        const startPointTurf = turf.point([startPoint.lng, startPoint.lat]);
        const bbox = turf.bbox(turf.buffer(startPointTurf, theoreticalRoadRangeKm, { units: 'kilometers' }));
        const bounds = new mapboxgl.LngLatBounds([bbox[0], bbox[1]], [bbox[2], bbox[3]]);

        navigationMapInstance.fitBounds(bounds, { padding: 40, duration: 1000, essential: true });
        
        await new Promise(resolve => {
            navigationMapInstance.once('idle', resolve);
        });

        showToast("Calculando radio autonom√≠a (considerando desnivel, temperatura, direcci√≥n del viento y tipo precipitaci√≥n...)", "info", 0, false, "range-calc-toast");
        
        let weatherData = null;
        try {
            const weatherUrl = `https://wttr.in/${startPoint.lat},${startPoint.lng}?format=j1`;
            const response = await fetch(weatherUrl);
            if (response.ok) {
                const data = await response.json();
                weatherData = {
                    main: { temp: parseFloat(data.current_condition[0].temp_C) },
                    weather: [{ main: data.current_condition[0].weatherDesc[0].value, description: data.current_condition[0].weatherDesc[0].value }],
                    wind: { speed: parseFloat(data.current_condition[0].windspeedKmph) / 3.6, deg: parseFloat(data.current_condition[0].winddirDegree) }
                };
            } else {
                showToast("No se pudo obtener el clima, se calcular√° sin factores clim√°ticos.", "warning");
            }
        } catch (e) { 
            console.warn("Error obteniendo clima, se omitir√°.", e); 
            showToast("Error de red al obtener clima. Se calcular√° sin factores clim√°ticos.", "warning");
        }

        if (weatherData) {
            const OPTIMAL_TEMP = 21; 
            const COLD_PENALTY_FACTOR = 0.04;
            const HEAT_PENALTY_FACTOR = 0.02; 
            const MAX_PENALTY_PERCENT = 60;  

            const temp = weatherData.main.temp;
            let tempPenalty = 0;
            const tempDifference = OPTIMAL_TEMP - temp;

            if (tempDifference > 0) { 
                tempPenalty = COLD_PENALTY_FACTOR * Math.pow(tempDifference, 2);
            } else { 
                tempPenalty = HEAT_PENALTY_FACTOR * Math.pow(Math.abs(tempDifference), 2);
            }
            
            let precipPenalty = 0;
            const weatherCondition = weatherData.weather[0].main.toLowerCase();
            if (weatherCondition.includes('rain') || weatherCondition.includes('drizzle') || weatherCondition.includes('llovizna') || weatherCondition.includes('lluvia')) precipPenalty = 5;
            if (weatherCondition.includes('snow') || weatherCondition.includes('nieve')) precipPenalty = 12;

            const totalPenaltyPercent = Math.min(tempPenalty + precipPenalty, MAX_PENALTY_PERCENT);
            totalAvailableEnergyKWh *= (1 - (totalPenaltyPercent / 100));
        }

        let energyBudgetForCalc = totalAvailableEnergyKWh;
        if (params.isRoundTrip) { energyBudgetForCalc = totalAvailableEnergyKWh / 2; }

        const tortuosityFactor = 1.50;
        const finalTheoreticalRoadRangeKm = (consumptionKwhPerKm > 0) ? (energyBudgetForCalc / consumptionKwhPerKm) : 0;
        const baseRangeKm = finalTheoreticalRoadRangeKm / tortuosityFactor;

        if (baseRangeKm <= 0) throw new Error("Con los par√°metros actuales (y el clima), el rango de acci√≥n es cero.");

        const numRays = 50;
        const sampleIntervalKm = 2;
        const elevationFactor = 1.5;
        const regenerationFactor = 0.65;
        const WATER_POINT_THRESHOLD = 9;

        const rayPromises = [];
        for (let i = 0; i < numRays; i++) {
            const bearing = i * (360 / numRays);
            const processRay = async () => {
                let lastValidPoint = startPointTurf;
                let totalPositiveElevation = 0;
                let totalNegativeElevation = 0;
                let lastElevation = navigationMapInstance.queryTerrainElevation({ lng: startPoint.lng, lat: startPoint.lat });
                let consecutiveWaterPoints = 0;
                for (let dist = sampleIntervalKm; dist <= baseRangeKm * 1.5; dist += sampleIntervalKm) {
                    const currentPoint = turf.destination(startPointTurf, dist, bearing, { units: 'kilometers' });
                    const currentCoords = currentPoint.geometry.coordinates;
                    const currentElevation = navigationMapInstance.queryTerrainElevation({ lng: currentCoords[0], lat: currentCoords[1] });
                    if (currentElevation === null || currentElevation <= 0) {
                        consecutiveWaterPoints++;
                        if (consecutiveWaterPoints >= WATER_POINT_THRESHOLD) return lastValidPoint.geometry.coordinates;
                        continue;
                    } else {
                        consecutiveWaterPoints = 0;
                    }
                    if (lastElevation !== null) {
                        const elevationChange = currentElevation - lastElevation;
                        if (elevationChange > 0) { totalPositiveElevation += elevationChange; } 
                        else { totalNegativeElevation += Math.abs(elevationChange); }
                    }
                    lastElevation = currentElevation;
                    let windConsumptionFactor = 1.0;
                    if (weatherData && weatherData.wind) {
                        const windSpeedKmh = weatherData.wind.speed * 3.6;
                        const windDirection = weatherData.wind.deg;
                        let angleDiff = Math.abs(bearing - windDirection);
                        if (angleDiff > 180) angleDiff = 360 - angleDiff;
                        const angleDiffRad = angleDiff * (Math.PI / 180);
                        const effectiveWindSpeed = windSpeedKmh * Math.cos(angleDiffRad);
                        const windPenalty = (effectiveWindSpeed / 100) * 0.5;
                        windConsumptionFactor += windPenalty;
                    }
                    const roadDistanceKm = dist * tortuosityFactor;
                    const consumptionDistanceKWh = roadDistanceKm * (consumptionKwhPerKm * windConsumptionFactor);
                    const consumptionElevationKWh = ((totalPositiveElevation / 100) * elevationFactor) - ((totalNegativeElevation / 100) * regenerationFactor);
                    const totalConsumptionKWh = consumptionDistanceKWh + consumptionElevationKWh;
                    if (totalConsumptionKWh > energyBudgetForCalc) return lastValidPoint.geometry.coordinates;
                    lastValidPoint = currentPoint;
                }
                return lastValidPoint.geometry.coordinates;
            };
            rayPromises.push(processRay());
        }

        const points = await Promise.all(rayPromises);
        points.push(points[0]);
        const rangePolygon = turf.polygon([points]);
        
        document.getElementById("range-calc-toast")?.remove();
        
        let weatherToastMessage = '';
        if (weatherData) {
            const temp = weatherData.main.temp.toFixed(0);
            const desc = translateWeatherDescription(weatherData.weather[0].description);
            const windSpeed = (weatherData.wind.speed * 3.6).toFixed(0);
            const windDir = weatherData.wind.deg;
            const windArrow = ['‚Üì', '‚Üô', '‚Üê', '‚Üñ', '‚Üë', '‚Üó', '‚Üí', '‚Üò'][Math.round(windDir / 45) % 8];
            weatherToastMessage = `
                <div style="text-align: left; line-height: 1.1;">
                    <span>Clima: ${temp}¬∞C, ${desc}</span><br>
                    <span>Viento: ${windSpeed} km/h (${windArrow})</span><br>
                    <span style="color: #FFD700;">Autonom√≠a Estimada: <b>${Math.round(finalTheoreticalRoadRangeKm)} km</b></span>
                </div>
            `;
        } else {
            weatherToastMessage = `<div style="text-align: left; line-height: 1.1;"><span style="color: #FFD700;">Autonom√≠a Estimada (sin clima): <b>${Math.round(finalTheoreticalRoadRangeKm)} km</b></span></div>`;
        }

        showToast(`<span style="font-size: 1.0rem;">${weatherToastMessage}</span>`, 'info', 10000);
        setTimeout(() => {
            showToast("Haga una pulsaci√≥n larga en cualquier zona del mapa (puede repetir e incluso hacerlo navegando) y recalcule la autonom√≠a, salga pulsando el bot√≥n de nuevo", 'instructional', 10000);
        }, 14000);
        
        await drawRangePolygon(rangePolygon);
        activateRangeCalcMode(); 

        if (params.searchChargers) {
            const currentZoom = navigationMapInstance.getZoom();
            await new Promise(resolve => {
                navigationMapInstance.easeTo({
                    zoom: Math.max(2, currentZoom + 0.5), 
                    duration: 500
                });
                navigationMapInstance.once('moveend', resolve);
            });
            const PDR_SEARCH_IN_VIEW_KEY = 'boardinggate_pdrSearchInView';
            const originalSearchInView = localStorage.getItem(PDR_SEARCH_IN_VIEW_KEY);
            localStorage.setItem(PDR_SEARCH_IN_VIEW_KEY, 'true'); 

            const powerFilters = {
                min: parseInt(localStorage.getItem('boardinggate_pdrFilterMinPower') || '30'),
                max: parseInt(localStorage.getItem('boardinggate_pdrFilterMaxPower') || '600')
            };
            const searchConfig = { type: 'view' };
            
            setTimeout(() => {
                findChargingPointsOnRoute(powerFilters, searchConfig);
                if (originalSearchInView !== null) {
                    localStorage.setItem(PDR_SEARCH_IN_VIEW_KEY, originalSearchInView);
                } else {
                    localStorage.removeItem(PDR_SEARCH_IN_VIEW_KEY);
                }
            }, 300);
    
            triggerManualMapInteraction();
    
        }

    } catch (error) {
        document.getElementById("range-calc-toast")?.remove();
        showToast(error.message || "Error al calcular el radio de acci√≥n.", "error");
        
        navigationMapInstance.flyTo({
            ...originalCamera,
            duration: 1200,
            essential: true
        });
    }
}

async function drawRangePolygon(polygonGeoJSON) {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) return;

    if (navigationMapInstance.getSource('range-polygon-source')) {
        navigationMapInstance.getSource('range-polygon-source').setData(polygonGeoJSON);
    } else {
        navigationMapInstance.addSource('range-polygon-source', {
            type: 'geojson',
            data: polygonGeoJSON
        });
        navigationMapInstance.addLayer({
            id: 'range-polygon-layer',
            type: 'fill',
            source: 'range-polygon-source',
            paint: {
                'fill-color': '#FFD700',
                'fill-opacity': 0.25
            }
        });
        navigationMapInstance.addLayer({
            id: 'range-polygon-outline',
            type: 'line',
            source: 'range-polygon-source',
            paint: {
                'line-color': '#FFD700',
                'line-width': 2,
                'line-opacity': 0.7
            }
        });
    }

    const bbox = turf.bbox(polygonGeoJSON);
    const bounds = new mapboxgl.LngLatBounds(
        [bbox[0], bbox[1]], 
        [bbox[2], bbox[3]]  
    );
    
    if (!bounds.isEmpty()) {
        navigationMapInstance.fitBounds(bounds, {
            padding: { top: 80, bottom: 80, left: 80, right: 80 },
            duration: 1200
        });
        
        await new Promise(resolve => navigationMapInstance.once('moveend', resolve));

        const MIN_ZOOM_FOR_PDRS = 6.0;
        if (navigationMapInstance.getZoom() < MIN_ZOOM_FOR_PDRS) {
            await new Promise(resolve => {
                navigationMapInstance.easeTo({
                    zoom: MIN_ZOOM_FOR_PDRS,
                    duration: 800
                });
                navigationMapInstance.once('moveend', resolve);
            });
        }
    }
} 

function showRangeCalcModal() {
    closeOtherModals('range-calc-modal');
    const modal = document.getElementById('range-calc-modal');
    if (!modal) return;

    deactivateRangeCalcMode();

    document.getElementById('rc-capacity').value = localStorage.getItem('rc_capacity') || '60';
    document.getElementById('rc-charge').value = localStorage.getItem('rc_charge') || '100';
    document.getElementById('rc-consumption').value = localStorage.getItem('rc_consumption') || '155';
    document.getElementById('rc-reserve').value = localStorage.getItem('rc_reserve') || '10';
    document.getElementById('rc-round-trip').checked = localStorage.getItem('rc_round_trip') === 'true';
    document.getElementById('rc-search-chargers').checked = localStorage.getItem('rc_search_chargers') === 'true';
    
    modal.style.zIndex = '99999';
    modal.classList.remove('hidden');

    const closeAndCleanup = () => {
        modal.classList.add('hidden');
        modal.style.zIndex = ''; 
    };

    document.getElementById('rc-start-calculation').onclick = async () => {
        const params = {
            capacity: parseFloat(document.getElementById('rc-capacity').value),
            charge: parseFloat(document.getElementById('rc-charge').value),
            consumptionWhKm: parseFloat(document.getElementById('rc-consumption').value),
            reserve: parseFloat(document.getElementById('rc-reserve').value),
            isRoundTrip: document.getElementById('rc-round-trip').checked,
            searchChargers: document.getElementById('rc-search-chargers').checked
        };

        if (isNaN(params.capacity) || isNaN(params.charge) || isNaN(params.consumptionWhKm) || isNaN(params.reserve)) {
            showToast("Por favor, rellena todos los campos con valores num√©ricos.", "error");
            return;
        }

        localStorage.setItem('rc_capacity', params.capacity);
        localStorage.setItem('rc_charge', params.charge);
        localStorage.setItem('rc_consumption', params.consumptionWhKm);
        localStorage.setItem('rc_reserve', params.reserve);
        localStorage.setItem('rc_round_trip', params.isRoundTrip);
        localStorage.setItem('rc_search_chargers', params.searchChargers);
        
        currentRangeCalcParams = params;
        closeAndCleanup();

        setMapImmersiveMode(true);
        
        const hasRoute = navigationWaypoints.filter(wp => wp && !wp.isInternal).length >= 2;
        if (hasRoute) {
            const startPoint = navigationWaypoints[0];
            calculateAndDrawRangeCircle({ lat: startPoint.lat, lng: startPoint.lng });
        } else {
            try {
                const currentPos = await getCurrentLocationAsync();
                calculateAndDrawRangeCircle({ lat: currentPos.latitude, lng: currentPos.longitude });
            } catch (error) {
                showToast(`Error al obtener ubicaci√≥n para el c√°lculo: ${error.message}`, "error");
            }
        }
    };

    document.getElementById('rc-cancel').onclick = () => {
        closeAndCleanup();
    };
}
        
function deactivateRangeCalcMode() {
    isRangeCalcModeActive = false;
    const button = document.getElementById('range-calculator-button');
    if (button) button.classList.remove('active');
    clearRangeCircleFromMap();
    
    clearChargingPoints();
    const pdrButton = document.getElementById('pdrs-ruta-button');
    if (pdrButton) pdrButton.classList.remove('pdr-search-highlight');

    setMapImmersiveMode(false);   
}
    
//=========== FIN FUNCIONES CALCULO RADIO CONSUMO ======================
//=========== FUNCIONES CALCULO RADIO CONSUMO ======================

    
// ===================================================================
// NOMBRE: findGooglePlaceId 
// RESUMEN: Busca un lugar usando texto/coordenadas para obtener su place_id.
async function findGooglePlaceId(poiName, lat, lng) {
    if (!window.google || !window.google.maps || !window.google.maps.places) {
        showToast("Error: No se pudo cargar el servicio de lugares.", "error");
        return null;
    }

    const request = {
        textQuery: poiName,
        fields: ['id'], 
        locationBias: { center: { lat: lat, lng: lng }, radius: 2000 }, // Radio en metros
    };

    try {
        const { places } = await google.maps.places.Place.searchByText(request);
        
        if (places && places.length > 0) {
            return places[0].id; 
        } else {
            return null;
        }
    } catch (error) {
        return null;
    }
}

// ===================================================================
// NOMBRE: getGooglePlaceDetails 
async function getGooglePlaceDetails(placeId, fields = null) {
    if (!window.google || !window.google.maps || !window.google.maps.places) {
        showToast("Error: No se pudo cargar el servicio de lugares.", "error");
        return null;
    }
    
    const place = new google.maps.places.Place({ id: placeId });

    const fieldsToRequest = fields || [
        'displayName', 'formattedAddress', 'websiteURI', 'nationalPhoneNumber',
        'regularOpeningHours', 'photos', 'rating', 'userRatingCount', 'googleMapsURI', 'reviews'
    ];
    
    try {
        await place.fetchFields({ fields: fieldsToRequest });
        return place;
    } catch (error) {
        return null;
    }
}

// ===================================================================
// NOMBRE: showSimulationSpeedModal 
// RESUMEN: Muestra un modal para que el usuario introduzca la velocidad de simulaci√≥n y elija el modo, incluyendo ahora una nota sobre c√≥mo simular desv√≠os.
function showSimulationSpeedModal(defaultSpeed, callback) {
    closeOtherModals('simulation-speed-modal');
    let modal = document.getElementById('simulation-speed-modal');
    if (modal) modal.remove();
    modal = document.createElement('div');
    modal.id = 'simulation-speed-modal';
    modal.innerHTML = `
        <h2>Velocidad y Modo de Simulaci√≥n</h2>
        <div class="filter-group" style="margin-bottom: 20px;">
            <label id="speed-range-label">Velocidad: ${defaultSpeed} km/h</label>
            <div class="slider-container single-slider-container" style="height: 25px;">
                <div class="slider-track"></div>
                <div class="slider-range" id="speed-slider-range"></div>
                <div class="slider-thumb" id="speed-thumb" style="left: 0%;"></div>
            </div>
        </div>
        <div class="modal-top-buttons" style="flex-direction: column; gap: 10px;">
            <button id="confirm-navigation-simulation" style="background-color: #28a745; color: white;">Simular Navegaci√≥n Normal <span class="button-countdown-timer unified-countdown-style"></span></button>
            <button id="confirm-freedrive-simulation" style="background-color: #34D399; color: #111827; font-weight: bold;">Recorrer en Modo Free Drive</button>
            <button id="cancel-simulation-speed" style="background-color: #6c757d; color: white;">Cancelar</button>
        </div>
        <!-- A√ëADIDO: P√°rrafo de ayuda para simular desv√≠os -->
        <p style="font-size: 0.85rem; color: #444; margin-top: 1.5rem; text-align: left; font-style: italic; border-top: 1px solid #ccc; padding-top: 10px;">
            (*) Para simular DESVIOS, carga una ruta, luego pulsa simulaci√≥n y cuando quieras pincha en el mapa para probar un desvio desde ese punto</p>
    `;
    document.body.appendChild(modal);

    const speedSliderContainer = modal.querySelector('#speed-thumb').parentElement;
    const speedThumb = modal.querySelector('#speed-thumb');
    const speedRange = modal.querySelector('#speed-slider-range');
    const speedLabel = modal.querySelector('#speed-range-label');
    const minSpeed = 1;
    const maxSpeed = 5000;
    let currentSpeed = defaultSpeed || 90;

    const updateSpeedVisuals = () => {
        const minLog = Math.log(minSpeed);
        const maxLog = Math.log(maxSpeed);
        const percent = (Math.log(currentSpeed) - minLog) / (maxLog - minLog);
        
        speedThumb.style.left = `${percent * 100}%`;
        speedRange.style.width = `${percent * 100}%`;
        speedLabel.textContent = `Velocidad: ${Math.round(currentSpeed)} km/h`;
    };

    const onSpeedDrag = (e) => {
        const rect = speedSliderContainer.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        let percent = (clientX - rect.left) / rect.width;
        percent = Math.max(0, Math.min(1, percent));
        
        const minLog = Math.log(minSpeed);
        const maxLog = Math.log(maxSpeed);
        currentSpeed = Math.exp(minLog + percent * (maxLog - minLog));
        
        updateSpeedVisuals();
    };

    const startSpeedDrag = (e) => {
        const moveHandler = (moveEvent) => onSpeedDrag(moveEvent);
        const endDrag = () => {
            document.removeEventListener('mousemove', moveHandler);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchmove', moveHandler);
            document.removeEventListener('touchend', endDrag);
        };
        document.addEventListener('mousemove', moveHandler);
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchmove', moveHandler);
        document.addEventListener('touchend', endDrag);
    };
    
    speedThumb.addEventListener('mousedown', startSpeedDrag);
    speedThumb.addEventListener('touchstart', startSpeedDrag);
    updateSpeedVisuals();
    
    const confirmNavBtn = modal.querySelector('#confirm-navigation-simulation');
    const confirmFreeDriveBtn = modal.querySelector('#confirm-freedrive-simulation');
    const cancelBtn = modal.querySelector('#cancel-simulation-speed');
    
    const closeHandler = () => {
        clearModalAutoCloseTimer(modal, confirmNavBtn, 'simulation-speed-modal');
        if (modal.parentNode) modal.remove();
    };

    confirmNavBtn.addEventListener('click', () => {
        isSimulatingFreeDrive = false; 
        callback(Math.round(currentSpeed));
        closeHandler();
    });

    confirmFreeDriveBtn.addEventListener('click', () => {
        isSimulatingFreeDrive = true; 
        callback(Math.round(currentSpeed));
        closeHandler();
    });

    cancelBtn.addEventListener('click', () => {
        showToast("Inicio de simulaci√≥n cancelado", "info");
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) simulateGpsButton.classList.remove('active-simulate-gps-mode');
        isSimulatingGpsLocation = false;
        reactivateRealGpsAfterSimulation();
        setNavigationMapClickHandler();
        closeHandler();
    });

    addModalAutoCloseTimer(modal, confirmNavBtn, 'simulation-speed-modal', 30000);
}

// ===================================================================
// NOMBRE: clearPoiSearchResults 
// RESUMEN: Limpia los marcadores y la lista de resultados de POIs, SIN modificar el estado de la aplicaci√≥n.
function clearPoiSearchResults() {
    [...poiSearchResultMarkers].forEach(marker => {
        try {
            if (marker && typeof marker.remove === 'function') {
                marker.remove();
            }
        } catch (e) {
            console.warn("Error menor al intentar eliminar un marcador de POI:", e);
        }
    });
    poiSearchResultMarkers = [];
    
    const listContainer = document.getElementById('poi-results-list-container');
    if (listContainer) {
        listContainer.innerHTML = '';
        listContainer.style.display = 'none';
    }
}    

// ===================================================================
// NOMBRE: displayPoiSearchResults 
// RESUMEN: Muestra resultados de POI. Clic en la lista a√±ade a la ruta; clic en el marcador muestra info.
function displayPoiSearchResults(features, map) {
    clearPoiSearchResults();

    if (!features || features.length === 0) {
        showToast("No se encontraron resultados para esa categor√≠a en esta zona.", "info");
        return;
    }

    const listContainer = document.getElementById('poi-results-list-container');
    if (listContainer) {
        listContainer.innerHTML = `
            <div class="poi-list-filter-container">
                <input type="text" class="poi-list-filter-input" placeholder="Filtrar resultados...">
                <button class="poi-list-filter-clear" title="Limpiar filtro">√ó</button>
            </div>
            <ul id="poi-results-ul"></ul>
        `;
        listContainer.style.display = 'block';

        const filterInput = listContainer.querySelector('.poi-list-filter-input');
        const clearButton = listContainer.querySelector('.poi-list-filter-clear');
        const listUl = listContainer.querySelector('#poi-results-ul');

        const bounds = new mapboxgl.LngLatBounds();
        features.forEach((feature, index) => {
            const coords = feature.geometry.coordinates;
            const props = feature.properties;
            const poiName = props.name || `${props.street || ''} ${props.housenumber || ''}`.trim() || 'Punto de inter√©s';

            const el = document.createElement('div');
            el.className = 'numbered-poi-marker';
            el.textContent = index + 1;
            
            const marker = new mapboxgl.Marker(el)
                .setLngLat(coords)
                .addTo(map);

            marker.getElement().addEventListener('click', (e) => { e.stopPropagation(); showPoiInfoModal(feature); });
            poiSearchResultMarkers.push(marker);
            bounds.extend(coords);
            
            const listItem = document.createElement('li');
            listItem.className = 'poi-list-item';
            listItem.title = `A√±adir a la ruta: ${poiName}`;
            listItem.dataset.markerIndex = index;
            
            listItem.innerHTML = `
                <span class="poi-list-number">${index + 1}</span>
                <span class="poi-list-name">${poiName}</span>
            `;

            listItem.addEventListener('click', () => {
                addWaypoint({ lat: coords[1], lng: coords[0] }, poiName);
                clearPoiSearchResults();
            });
            
            listUl.appendChild(listItem);
        });
        
        filterInput.addEventListener('input', () => {
            const filterText = filterInput.value.toLowerCase().trim();
            clearButton.style.display = filterText ? 'block' : 'none';
            const allListItems = listUl.querySelectorAll('.poi-list-item');
            
            allListItems.forEach(item => {
                const name = item.querySelector('.poi-list-name').textContent.toLowerCase();
                const markerIndex = parseInt(item.dataset.markerIndex, 10);
                const correspondingMarker = poiSearchResultMarkers[markerIndex];
                const isVisible = name.includes(filterText);
                item.style.display = isVisible ? 'flex' : 'none';
                if (correspondingMarker && correspondingMarker.getElement()) {
                    correspondingMarker.getElement().style.display = isVisible ? 'flex' : 'none';
                }
            });
        });

        clearButton.addEventListener('click', () => {
            filterInput.value = '';
            filterInput.dispatchEvent(new Event('input'));
            filterInput.focus();
        });

        if (!bounds.isEmpty()) {
            map.fitBounds(bounds, { padding: {top: 80, bottom: 80, left: 200, right: 80}, maxZoom: 16 });
        }
    }
}    

// ===================================================================
// NOMBRE: updateVehicleIconPerspective 
// RESUMEN: Inclina el icono del coche y muestra/oculta el marcador de anclaje.
function updateVehicleIconPerspective() {
    if (!navigationMapInstance || !vehicleIconElement) return;

    const iconWrapper = vehicleIconElement.querySelector('.vehicle-icon-wrapper');
    if (!iconWrapper) return;

    const pitch = navigationMapInstance.getPitch();
    const START_PITCH = 50;
    const MAX_PITCH = 85;
    const MAX_TILT_ANGLE = 65;
    const MAX_SCALE_FACTOR = 1.6;

    let tiltAngle = 0;
    let scale = 1.0;

    if (pitch > START_PITCH) {
        const progress = Math.min(1, (pitch - START_PITCH) / (MAX_PITCH - START_PITCH));
        tiltAngle = progress * MAX_TILT_ANGLE;
        scale = 1.0 + (progress * (MAX_SCALE_FACTOR - 1.0));
    }

    iconWrapper.style.transform = `rotateX(${tiltAngle}deg) scale(${scale})`;
    
    const PITCH_THRESHOLD_FOR_ANCHOR = 20; // Grados a partir de los cuales se muestra el anclaje
    if (groundAnchorMarker) {
        const anchorElement = groundAnchorMarker.getElement();
        if (pitch > PITCH_THRESHOLD_FOR_ANCHOR) {
            anchorElement.classList.remove('ground-anchor-hidden');
        } else {
            anchorElement.classList.add('ground-anchor-hidden');
        }
    }
}
        
// ===================================================================
// NOMBRE: normalizeOverpassResult 
// RESUMEN: Convierte un resultado de Overpass al formato GeoJSON est√°ndar de la app.
function normalizeOverpassResult(overpassElement) {
    if (!overpassElement || !overpassElement.lat || !overpassElement.lon) {
        return null;
    }  
    const tags = overpassElement.tags || {};
    const name = tags.name || tags['addr:street'] || "Punto de Inter√©s";  
    return {
        type: 'Feature',
        geometry: {
            type: 'Point',
            coordinates: [parseFloat(overpassElement.lon), parseFloat(overpassElement.lat)]
        },
        properties: {
            name: name,
            osm_key: `${overpassElement.type}:${tags.amenity || tags.shop || tags.tourism || 'generic'}`,
            source: 'Overpass'
        }
    };
}

// ===================================================================
// NOMBRE: buildOverpassQuery 
// RESUMEN: Construye la consulta en lenguaje QL para la API Overpass.
function buildOverpassQuery(osmTag) {
    if (!osmTag) return null;
    const bounds = navigationMapInstance.getBounds();
    const bbox = `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;
    const [key, value] = osmTag.split(':');
    if (!key || !value) return null;
    const query = `
        [out:json][timeout:25];
        (
          node["${key}"="${value}"](${bbox});
          way["${key}"="${value}"](${bbox});
          relation["${key}"="${value}"](${bbox});
        );
        out center;
    `;
    return query.trim();
}

// ===================================================================
// NOMBRE: initiateControlledReload
// RESUMEN: Inicia el reinicio controlado. Prioriza la estabilidad sobre la est√©tica,
async function initiateControlledReload() {
    if (isPerformingControlledReload) return;
    isPerformingControlledReload = true; 

    const finalizeAndReload = async () => {
        try {
            const recoveryFlagJSON = localStorage.getItem('boardinggate_nav_recovery_flag');
            if (recoveryFlagJSON) {
                const recoveryData = JSON.parse(recoveryFlagJSON);
                
                recoveryData.route.waypoints = sanitizeWaypointsForStorage(navigationWaypoints);
                if (navigationCurrentLocation) recoveryData.lastKnownLocation = navigationCurrentLocation;
                
                if (markerAnimationState && typeof markerAnimationState.currentMapBearing === 'number') {
                    recoveryData.lastKnownBearing = markerAnimationState.currentMapBearing;
                }

                recoveryData.stats = { totalDistance: totalDistanceTravelledForStats, maxSpeed: maxSpeedDuringTrip, maxAltitude: maxAltitudeDuringTrip, minAltitude: minAltitudeDuringTrip, maxSpeedCoords: maxSpeedCoordinates };
                recoveryData.tripStartTime = navigationStartTimeForStats ? navigationStartTimeForStats.getTime() : Date.now();
                recoveryData.originalTripEtaTime = originalTripEtaTime ? originalTripEtaTime.getTime() : null;
                recoveryData.tripContext = { graphLabels: graphLabels, graphDataPoints: graphDataPoints, minAvgSpeed: minAverageSpeedInTrip, maxAvgSpeed: maxAverageSpeedInTrip, accumulatedDeviationMs: accumulatedDeviationMs };
                if (isSimulatingGpsLocation && automatedSimulationIntervalId) {
                    recoveryData.simulationState = { isSimulating: true, speed: simulationSpeedKmph, distance: simulatedDistanceAlongRoute };
                }
                recoveryData.isRichRecovery = true;
                localStorage.setItem('boardinggate_nav_recovery_flag', JSON.stringify(recoveryData));
            }
            
            await destroyAllMapInstances();

            setTimeout(() => { location.reload(); }, 50); 
        } catch (e) {
            console.error("Error durante la finalizaci√≥n de la recarga controlada:", e);
            await destroyAllMapInstances(); // Intento de limpieza incluso si falla
            setTimeout(() => location.reload(), 100);
        }
    };

    const captureAndProceed = async () => {
        try {
            const elementToCapture = document.body;
            if (typeof html2canvas === 'undefined' || !elementToCapture) {
                await finalizeAndReload();
                return;
            }
            
            const canvas = await html2canvas(elementToCapture, { useCORS: true, allowTaint: true, logging: false });
            let dataUrl;

            try {
                dataUrl = canvas.toDataURL('image/jpeg', 0.50);
                sessionStorage.setItem('recoveryScreenshot', dataUrl); 
            } catch (e) {
                try {
                    dataUrl = canvas.toDataURL('image/jpeg', 0.30);
                    sessionStorage.setItem('recoveryScreenshot', dataUrl);
                } catch (e2) {
                    sessionStorage.removeItem('recoveryScreenshot');
                }
            }

            sessionStorage.setItem('isControlledReload', 'true');
            await finalizeAndReload();

        } catch (error) {
            console.error("Error en html2canvas, procediendo sin captura:", error);
            sessionStorage.setItem('isControlledReload', 'true');
            sessionStorage.removeItem('recoveryScreenshot');
            await finalizeAndReload();
        }
    };
    
    if (navigationMapInstance && navigationMapInstance.isStyleLoaded()) {
        const safetyTimeout = setTimeout(captureAndProceed, 100); 
        navigationMapInstance.once('render', () => {
            clearTimeout(safetyTimeout);
            setTimeout(captureAndProceed, 100); // Peque√±a pausa para que todo se asiente.
        });
        navigationMapInstance.triggerRepaint();
    } else {
        await captureAndProceed();
    }
}
    
// ===================================================================
// NOMBRE: recalculateAndDrawRoute (VERSI√ìN CON REINICIO DEL DETECTOR)
// RESUMEN: Recalcula la ruta y, al finalizar, reinicia el detector de desv√≠os.
async function recalculateAndDrawRoute(preserveAccumulatedStats = false, recoveryInfo = null) {
    const RETRY_CADENCE_MS = 3000;
    const MAX_RETRIES = 5;
    let attempt = 1;

    while (attempt <= MAX_RETRIES) {
        isRecalculatingRoute = true;
        clearAlternativeRoutesDisplay(); 
        alternativeRoutesCache.clear();
        selectedStageRoutes.clear();
        
        const toastId = `recalc-toast-${Date.now()}`;
        showToast(`Calculando ruta... (Intento ${attempt}/${MAX_RETRIES})`, "info", 0, false, toastId);

        const wasNavigatingBeforeRecalc = isNavigating;

        try {
            let waypointsForAPI = [];
            let currentHeading = null;

            if (recoveryInfo) {
                const isSimulatedRecovery = recoveryInfo.simulationState && recoveryInfo.simulationState.isSimulating;
            
                if (isSimulatedRecovery) {
                    waypointsForAPI = sanitizeWaypointsForStorage(recoveryInfo.route.waypoints);
                    currentHeading = null; 
                } else {
                    const currentPos = await getGpsWithRetries();
                    
                    currentHeading = currentPos.heading;
                    
                    if (currentHeading === null && recoveryInfo && typeof recoveryInfo.lastKnownBearing === 'number') {
                        currentHeading = recoveryInfo.lastKnownBearing;
                    }
                    else if (currentHeading === null && recoveryInfo && recoveryInfo.lastKnownLocation && recoveryInfo.lastKnownLocation.heading !== null) {
                        currentHeading = recoveryInfo.lastKnownLocation.heading;
                    }
                
                    if (!recoveryInfo.isRichRecovery) {
                        const tempRouteUrl = `${OSRM_SERVICE_URL}/driving/${navigationWaypoints.map(wp => `${wp.lng},${wp.lat}`).join(';')}?overview=full&geometries=geojson&steps=true`;
                        const tempRouteResponse = await fetch(tempRouteUrl);
                        const tempRouteData = await tempRouteResponse.json();
                        
                        if (tempRouteData.code === 'Ok' && tempRouteData.routes.length > 0) {
                            const originalRouteLine = turf.lineString(tempRouteData.routes[0].geometry.coordinates);
                            const carPoint = turf.point([currentPos.longitude, currentPos.latitude]);
                            const carDistanceAlongOriginalRoute = turf.nearestPointOnLine(originalRouteLine, carPoint, { units: 'meters' }).properties.location;
                            
                            let cumulativeDistance = 0;
                            tempRouteData.routes[0].legs.forEach((leg, legIndex) => {
                                if (navigationWaypoints[legIndex + 1]) {
                                    if (cumulativeDistance + leg.distance < carDistanceAlongOriginalRoute) {
                                        navigationWaypoints[legIndex + 1].visited = true;
                                    }
                                    cumulativeDistance += leg.distance;
                                }
                            });
                        }
                    }
                    
                    let lastVisitedIndex = -1;
                    navigationWaypoints.forEach((wp, index) => {
                        if (wp && wp.visited && !wp.isInternal) {
                            lastVisitedIndex = index;
                        }
                    });
                    
                    const waypointsBefore = navigationWaypoints.slice(0, lastVisitedIndex + 1);
                    const waypointsAfter = navigationWaypoints.slice(lastVisitedIndex + 1);
                    const invisibleWaypoint = { lat: currentPos.latitude, lng: currentPos.longitude, isInternal: true };
                    waypointsForAPI = [...waypointsBefore, invisibleWaypoint, ...waypointsAfter];
                }

            } else if (!isNavigating) {
                waypointsForAPI = [...navigationWaypoints];
                currentHeading = null;
            } else { 
                if (navigationCurrentLocation) {
                    currentHeading = navigationCurrentLocation.heading;
                    waypointsForAPI.push({ lat: navigationCurrentLocation.latitude, lng: navigationCurrentLocation.longitude, isRecalculatedStart: true });
                    waypointsForAPI.push(...navigationWaypoints.filter(wp => !wp.visited));
                } else {
                    waypointsForAPI = [...navigationWaypoints];
                }
            }
            
            const validWaypoints = waypointsForAPI.filter(wp => wp && typeof wp.lat === 'number' && typeof wp.lng === 'number');
            if (validWaypoints.length < 2) { 
                const existingToast = document.getElementById(toastId);
                if (existingToast) existingToast.remove();
                isRecalculatingRoute = false;
                return; 
            };

            const coordsString = validWaypoints.map(wp => `${wp.lng},${wp.lat}`).join(';');
            const result = await fetchRouteData(coordsString, currentHeading);
            if (result.error) throw result.error;

            const newRouteData = result.routeData;
            const newRemainingRoute = newRouteData.routes[0];

            navigationCurrentRouteData = newRouteData;
            precalculateRouteStepDistances(navigationCurrentRouteData);

            generateAndCacheCleanManeuverList(newRemainingRoute, navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart));
            
            await drawRouteOnMap(newRemainingRoute);
            
            const isRadaresRutaActive = document.getElementById('radares-ruta-checkbox').checked;

            if (isRadaresRutaActive) {
                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const originalLength = reminders.length;
                reminders = reminders.filter(r => !r.isDynamicRadar);
                if (reminders.length < originalLength) {
                    localStorage.setItem('reminders', JSON.stringify(reminders));
                    markCacheAsDirty();
                }
            }
            
            if (preserveAccumulatedStats) {
                accumulatedDistanceBeforeCurrentSegment = totalDistanceTravelledForStats;
            } else {
                accumulatedDistanceBeforeCurrentSegment = 0;
                navigationStartTimeForStats = new Date();
                originalTripEtaTime = null;
            }
            
            lastCarDistanceAlongRouteForNavLogic = 0;
            currentLegIndexNav = 0;
            currentStepIndexNav = 0;
            previousLegIndexForEta = 0;
            lastProcessedStepIdentifier = null;
            lastProcessedStepForLock = null;
            lastDisplayedManeuverIcon = null;

            tripInitialOverallEtaTime = new Date(Date.now() + newRemainingRoute.duration * 1000);
            if (newRemainingRoute.legs && newRemainingRoute.legs.length > 0) {
                currentStageInitialExpectedEtaTime = new Date(Date.now() + newRemainingRoute.legs[0].duration * 1000);
            } else {
                currentStageInitialExpectedEtaTime = null;
            }
            
            renderWaypointMarkers();

            if (!recoveryInfo) {
                updateNavigationProgressDisplay(newRemainingRoute, 0); 
                updateTurnByTurnDisplay(newRemainingRoute, 0);
            }
            drawStaticMarkersOnProgressBar();
            showDestinationName();
            toggleRadaresRuta(document.getElementById('radares-ruta-checkbox').checked);
            toggleTareasRuta(document.getElementById('tareas-ruta-checkbox').checked);
            updateStartNavigationButtonState();
            updateNavigationButtonColor();

            deviationCheckGracePeriodUntil = Date.now() + 7000;
            closeModalAndProceed();
            
            if (wasNavigatingBeforeRecalc || isSimulatingGpsLocation) {
                startDeviationChecker();
            }

            return;
            
        } catch (error) {
            console.error(`[RECALC] Fallo en intento #${attempt}:`, error);
            if (attempt === MAX_RETRIES) {
                showToast("Fallo al recalcular la ruta tras varios intentos. Comprueba tu conexi√≥n.", "error");
                closeModalAndProceed();
                throw new Error("Fallo al recalcular la ruta tras m√∫ltiples intentos.");
            } else {
                await new Promise(resolve => setTimeout(resolve, RETRY_CADENCE_MS));
            }
        } finally {
            const existingToast = document.getElementById(toastId);
            if (existingToast) existingToast.remove();
            activeToasts = activeToasts.filter(t => t.id !== toastId);

            isRecalculatingRoute = false;
            isNavigating = wasNavigatingBeforeRecalc; 
            
            if (attempt > MAX_RETRIES) { 
                 updateStartNavigationButtonState();
                 updateNavigationButtonColor();
            }
        }
        attempt++; 
    }
}    

// ===================================================================
// NOMBRE: fetchOverpassData 
// RESUMEN: Realiza la petici√≥n a la API de Overpass y devuelve los resultados.
async function fetchOverpassData(query) {
    const overpassUrl = 'https://overpass-api.de/api/interpreter';
    try {
        const response = await fetch(overpassUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
            },
            body: `data=${encodeURIComponent(query)}`
        });
        if (!response.ok) {
            throw new Error(`Overpass API respondi√≥ con estado: ${response.status}`);
        }
        const data = await response.json();
        return data.elements || [];
    } catch (error) {
        console.error("Error al contactar con la API Overpass:", error);
        return [];
    }
}
 
// ===================================================================
// NOMBRE: initializeApp 
// RESUMEN: A√±ade la comprobaci√≥n de usuario y permisos ANTES de intentar entrar al mapa directamente.
async function initializeApp() {
    const recoveryExecuted = await checkForAndExecuteCrashRecovery();
    loadCustomData();
    loadSavedSettings();
    applyMapVisualSettings();
    applyMainUISettings();
    isMobileSession = parseUserId(localStorage.getItem('userData_userId')).isMobile; 
    if (isMobileSession) {
        document.body.classList.add('mobile-view');
        await restoreCacheForMobile();
    } else {
        await uploadDirtyCacheOnLoad_Car();
    }
    lastMobileSyncTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');
    checkForExcessiveRadars();
    const termsAccepted = localStorage.getItem('termsAccepted_v1') === 'true';
    const shouldDirectToNav = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY) || 'false');
    const tempPreventDirectNav = sessionStorage.getItem(TEMP_PREVENT_DIRECT_NAV_KEY);

    const userId = localStorage.getItem('userData_userId');
    const allowDMs = JSON.parse(localStorage.getItem('userData_allowDMs') || 'false');
    const canAccessMaps = (userId && userId.trim() !== '' && allowDMs);
  
    if (((shouldDirectToNav && !tempPreventDirectNav) || recoveryExecuted) && termsAccepted && canAccessMaps) {
        if(!recoveryExecuted) sessionStorage.setItem('isInDirectToMapMode', 'true');
        directToNavOnLoad = true;
        const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'none';
        const footerContent = document.querySelector('footer'); if (footerContent) footerContent.style.display = 'none';
        const noticesIconContainer = document.querySelector('.notices-icon-container'); if (noticesIconContainer) noticesIconContainer.style.display = 'none';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'none');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button, #store-button').forEach(el => el.style.display = 'none');
        document.getElementById('grid-filter-container').style.display = 'none';
        
        if (!recoveryExecuted) {
            openNavigationMap();
        }
    } else {
        if (shouldDirectToNav && !tempPreventDirectNav && termsAccepted && !canAccessMaps) {
            const message = "PARA ACCEDER A MAPAS, ES IMPRESCINDIBLE QUE CREE EN CONFIGURACI√ìN UN NOMBRE DE USUARIO √öNICO (y debe estar activado Permitir MDs tambi√©n y BACKUP AUTOM√ÅTICO)...";
            const duration = 10000; 
            showToast(message, 'error', duration);
            setTimeout(() => { showConfigModal(); }, duration);
        }

        sessionStorage.removeItem('isInDirectToMapMode');
        directToNavOnLoad = false;
        sessionStorage.removeItem(TEMP_PREVENT_DIRECT_NAV_KEY); 

        const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'block';
        const footerContent = document.querySelector('footer'); if (footerContent) footerContent.style.display = 'block';
        const noticesIconContainer = document.querySelector('.notices-icon-container'); if (noticesIconContainer) noticesIconContainer.style.display = 'flex';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'flex');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button, #store-button').forEach(el => el.style.display = 'block');
        document.getElementById('grid-filter-container').style.display = 'flex';
    }
    initializeConfigModalListeners();
    try { await updateVersion(); } catch (e) { }
    try { await loadNotices(); startNoticeRotation(); } catch (e) { }
    if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
    if (!termsAccepted) {
        showConfigModal();
    }
    const noticeToggleIcon = document.getElementById('notice-toggle-icon');
    if (noticeToggleIcon) noticeToggleIcon.addEventListener('click', toggleNotices);
    const countEl = document.getElementById('reminder-count-globe');
    if (countEl) {
         const openTable = (e) => {
             if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
             e.preventDefault(); e.stopPropagation();
             showAllReminders();
         };
         countEl.addEventListener('click', openTable);
         countEl.style.cursor = 'pointer';
    }
    const filterInput = document.getElementById('grid-filter-input');
    const clearButton = document.getElementById('clear-filter-button');
    if (filterInput) {
        const savedFilter = localStorage.getItem('gridFilterValue');
        if (savedFilter !== null) filterInput.value = savedFilter;
        filterInput.addEventListener('input', () => {
             localStorage.setItem('gridFilterValue', filterInput.value);
             filterGridItems();
             if(isKeywordAssignmentMode) applyInitialKeywordHighlights();
        });
    }
    if (clearButton) {
        clearButton.addEventListener('click', () => {
             if (filterInput) filterInput.value = '';
             localStorage.removeItem('gridFilterValue');
             markCacheAsDirty(); 
             filterGridItems();
             if(isKeywordAssignmentMode) applyInitialKeywordHighlights();
        });
    }
    
    const openChatArea = document.getElementById('open-chat-area');
    if (openChatArea) {
        openChatArea.addEventListener('click', openChatModal);
    }
    updateTotalMessageCount(); 
    const userCountGlobe = document.getElementById('user-count-globe');
    if (userCountGlobe) {
        userCountGlobe.addEventListener('click', () => {
            showToast('Usuarios activos', 'info');
        });   
    if (window.db && window.getDoc && window.doc) {
        const statsDocRef = window.doc(window.db, "stats", "user_count");
        window.getDoc(statsDocRef).then(docSnap => {
        if (docSnap.exists()) {
            userCountGlobe.textContent = docSnap.data().total || 0;
        } else {
            userCountGlobe.textContent = 'N/A';
            console.warn("El documento de estad√≠sticas 'stats/user_count' no existe.");
        }
    }).catch(error => {
        userCountGlobe.textContent = 'X';
    });
}
    }

    const dailyUserCountGlobe = document.getElementById('daily-user-count-globe');
    if (dailyUserCountGlobe && window.db) {
        try {
            const dailyStatsRef = window.doc(window.db, "stats", "daily_activity");
            window.getDoc(dailyStatsRef).then(docSnap => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    const todayString = new Date().toISOString().split('T')[0];
                    if (data.hoy === todayString && data.sesionesDia > 0) {
                        dailyUserCountGlobe.textContent = data.sesionesDia;
                        dailyUserCountGlobe.style.display = 'flex';
                    } else {
                        dailyUserCountGlobe.style.display = 'none';
                    }
                } else {
                    dailyUserCountGlobe.style.display = 'none';
                }
            });
        } catch(e) {
            console.error("Error al obtener contador diario:", e);
        }
    }

    await checkVersionsIconOpacity();
    document.body.addEventListener('click', function(event) {
        const target = event.target;
        const targetId = target.id || (target.closest('[id]') ? target.closest('[id]').id : null);
        if (targetId === 'config-close-modal') {
            const termsAcceptedForClose = localStorage.getItem('termsAccepted_v1') === 'true';
            if (!termsAcceptedForClose) {
                showToast('Debes aceptar las normas de uso para continuar.', 'warning');
                return;
            }
            const modal = document.getElementById('config-modal');
            if (modal && !modal.classList.contains('hidden')) {
                clearModalAutoCloseTimer(modal, target, 'config-modal');
                modal.classList.add('hidden');
                 const mapWasOpenBeforeConfig = sessionStorage.getItem('boardinggate_map_should_reopen_after_config') === 'true';
                 const mapContextToReopen = sessionStorage.getItem('mapContextToReopenAfterConfig');
                 sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');
                 sessionStorage.removeItem('mapContextToReopenAfterConfig');
                 if (mapWasOpenBeforeConfig && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !document.getElementById('reminders-location-map-modal')) {
                    if (mapContextToReopen === 'navigation') {
                        setTimeout(() => openNavigationMap(), 50);
                    }
                }
            }
        }
        if (target.matches('.config-tab-button')) {
            const modal = document.getElementById('config-modal');
            if(modal && modal.classList.contains('hidden') === false) {
                const tabTarget = target.dataset.tabTarget;
                modal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                modal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (modal.querySelector(tabTarget)) {
                    modal.querySelector(tabTarget).classList.add('active');
                }
            }
        }
        if (targetId === 'close-reminders-top' || targetId === 'close-reminders-bottom') {
            const modalTable = document.querySelector('.reminder-table-modal');
            if (modalTable) {
                if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                modalTable.remove();
                const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                const mapContext = sessionStorage.getItem('mapContext');
                sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                sessionStorage.removeItem('mapContext');
                if (fromReminderModal) {
                    fromReminderModal = false;
                    if (mapShouldReopen) {
                        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                        sessionStorage.setItem('mapContext', mapContext);
                    }
                    showReminderModal();
                } else if (mapShouldReopen) {
                     if (mapContext === 'navigation') openNavigationMap();
                }
            }
        }
        if (targetId === 'view-all-locations-map') {
            const modalTable = document.querySelector('.reminder-table-modal');
             if (modalTable && modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
             if (modalTable) modalTable.remove();
            setTimeout(() => {
                openLocationsPreviewMap();
            }, 50);
        }
         if (targetId === 'close-locations-preview') {
            const previewModal = document.getElementById('locations-preview-modal');
            if (previewModal) {
                if (locationsPreviewMap) {
                    try { locationsPreviewMap.remove(); } catch (e) {}
                    locationsPreviewMap = null;
                }
                if (mapLayersControlLocationsPreview) {
                    try {mapLayersControlLocationsPreview.remove();} catch(e){}
                    mapLayersControlLocationsPreview = null;
                }
                clearModalAutoCloseTimer(previewModal, target, 'locations-preview-modal');
                previewModal.classList.add('hidden');
            }
        }
         if (targetId === 'close-address-suggestions-modal') {
            hideAddressSuggestionsModal();
        }
    });
   const configModal = document.getElementById('config-modal');
    if (configModal) {
        configModal.addEventListener('click', function(event) {
            const target = event.target;
            if (target.matches('.config-tab-button')) {
                const tabTarget = target.dataset.tabTarget;
                configModal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                configModal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (configModal.querySelector(tabTarget)) {
                    configModal.querySelector(tabTarget).classList.add('active');
                }
            }
        });
    }
    const bookmarkGrid = document.getElementById('bookmark-grid');
    if (bookmarkGrid) {
        bookmarkGrid.addEventListener('click', function(event) {
            const link = event.target.closest('a.bookmark-item');
            if (link && link.href && link.href.startsWith("map-action:")) {
                event.preventDefault();
                const action = link.href.split(":")[1];
                if (action === "openRemindersMapWithNoRadars") {
                    closeOtherModals();
                    setTimeout(() => {
                        const existingPreviewModal = document.getElementById('locations-preview-modal');
                        if (existingPreviewModal && !existingPreviewModal.classList.contains('hidden')) {
                            showToast("El mapa de ubicaciones (sin radar) ya est√° abierto", "info");
                        } else {
                           openLocationsPreviewMap();
                        }
                    }, 50);
                } else if (action === "openRemindersMap") {
                    closeOtherModals();
                    setTimeout(() => {
                        const mapModalElement = document.getElementById('reminders-location-map-modal');
                        if (mapModalElement && !mapModalElement.classList.contains('hidden')) {
                            showToast("El mapa de navegaci√≥n/ubicaciones ya est√° abierto", "info");
                            if (navigationMapInstance) {
                                requestAnimationFrame(() => {
                                    requestAnimationFrame(() => {
                                        if (navigationMapInstance) {
                                            try {
                                                 navigationMapInstance.resize();
                                             } catch (e) {  }
                                        }
                                    });
                                });
                            }
                        } else {
                           openNavigationMap();
                        }
                    }, 50);
                }
            }
        });
    }
    
    const accidentAlertButton = document.getElementById('accident-alert-button');
    if (accidentAlertButton) {
        accidentAlertButton.addEventListener('click', () => {
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
            openAlertModal();
        });
    }  
}
    
// ===================================================================
// NOMBRE: recalculateAndSaveUserCount 
// RESUMEN: Cuenta todos los usuarios y actualiza el documento de estad√≠sticas.
async function recalculateAndSaveUserCount() {
    const currentUserId = localStorage.getItem('userData_userId');
    if (currentUserId !== 'BoardingGate') {
        return;
    }
    showToast("Recalculando total de usuarios...", "info");
    try {
        const usersCollectionRef = window.collection(window.db, "user_data");
        const snapshot = await window.getDocs(usersCollectionRef);
        const totalUsers = snapshot.size;

        const statsDocRef = window.doc(window.db, "stats", "user_count");
        await window.setDoc(statsDocRef, { total: totalUsers, adminRequest: true });
        
        showToast(`Recuento actualizado a ${totalUsers} usuarios.`, "success");
        const userCountGlobe = document.getElementById('user-count-globe');
        if (userCountGlobe) {
            userCountGlobe.textContent = totalUsers;
        }
    } catch (error) {
        showToast(`Error al recalcular: ${error.message}`, "error");
    }
}
    
//=============================================================
function updateSmoothedGpsAltitude(newAltitude) {
    if (typeof newAltitude !== 'number' || isNaN(newAltitude)) return;
    ALTITUDE_HISTORY.push(newAltitude);
    if (ALTITUDE_HISTORY.length > MAX_ALTITUDE_SAMPLES) {
        ALTITUDE_HISTORY.shift();
    }
    smoothedGpsAltitude = ALTITUDE_HISTORY.reduce((a, b) => a + b, 0) / ALTITUDE_HISTORY.length;
}

// ===================================================================
// NOMBRE: toggleEditMode 
// RESUMEN: Activa/desactiva el modo de edici√≥n y crea un snapshot completo al activar.
function toggleEditMode(activate) {
    const personalButton = document.getElementById('personal-button'); 
    isEditMode = activate; 
    personalButton.classList.toggle('editing', isEditMode); 
    document.body.classList.toggle('editing-active', isEditMode);
    
    if (isEditMode) {
        if (isAssignmentMode) toggleAssignmentMode(false); 
        if (isKeywordAssignmentMode) toggleKeywordAssignmentMode(false);
        personalizationSnapshot = {
            customData: JSON.parse(JSON.stringify(customData)),
            currentBookmarks: JSON.parse(JSON.stringify(currentBookmarks))
        };
        
        if (firstPersonalizationSession) { 
            showEditInfoModal(); 
            firstPersonalizationSession = false; 
            sessionStorage.setItem('personalizationHelpShown', 'true'); 
        }
        showToast("Modo Edici√≥n (URLs/Etiquetas/Arrastrar) Activado", "info", 4000);
    } else {
        personalizationSnapshot = null;
        cellElements.forEach(cell => cell.classList.remove('dragging', 'drag-over')); 
        draggedItem = null; draggedItemIndex = null; currentTouchTarget = null; dragOverIndex = null;
        if (editingTargetElement) { 
            editingTargetElement.classList.remove('editing-target'); 
            editingTargetElement = null; 
        }
    } 
    renderGrid(); 
    renderToggleButtons(); 
    loadSavedSettings(); 
    updateButtonStyles(); 
    adjustButtonPositions();
    document.querySelectorAll('.range-toggle').forEach(el => { el.classList.toggle('editable', isEditMode); }); 
    filterGridItems();
}

// ===================================================================
// NOMBRE: toggleAssignmentMode 
// RESUMEN: Activa o desactiva el modo de asignaci√≥n y crea un snapshot completo al activar.
function toggleAssignmentMode(activate) {
    const personalButton = document.getElementById('personal-button'); 
    isAssignmentMode = activate; 
    personalButton.classList.toggle('assigning', isAssignmentMode); 
    document.body.classList.toggle('assignment-active', isAssignmentMode);
    
    if (isAssignmentMode) {
        if (isEditMode) toggleEditMode(false); 
        if (isKeywordAssignmentMode) toggleKeywordAssignmentMode(false);
        personalizationSnapshot = {
            customData: JSON.parse(JSON.stringify(customData)),
            currentBookmarks: JSON.parse(JSON.stringify(currentBookmarks))
        };

        if (firstPersonalizationSession) { 
            showEditInfoModal(); 
            firstPersonalizationSession = false; 
            sessionStorage.setItem('personalizationHelpShown', 'true'); 
        }
        showToast("Modo Asignaci√≥n Botones Activado", "info", 4000);
        const firstToggle = document.querySelector('.range-toggle');
        if (firstToggle) { 
            handleToggleClickForAssignment(firstToggle); 
        } else { 
            currentlyAssigningToggleStart = null; 
            updateGridAssignmentVisuals(); 
        }
    } else {
        personalizationSnapshot = null;
        document.querySelectorAll('.range-toggle.assigning-selected').forEach(t => t.classList.remove('assigning-selected'));
        document.querySelectorAll('.grid-cell.assigned-to-current').forEach(c => { c.classList.remove('assigned-to-current'); c.style.opacity = ''; c.style.outline=''; c.style.boxShadow=''; c.style.backgroundColor = ''; });
        document.querySelectorAll('.range-toggle').forEach(t => t.style.opacity = '');
        currentlyAssigningToggleStart = null;
    } 
    renderGrid(); 
    renderToggleButtons(); 
    loadSavedSettings(); 
    updateButtonStyles(); 
    adjustButtonPositions(); 
    filterGridItems(); 
}
// ===================================================================
// NOMBRE: revertPersonalizationChanges 
// RESUMEN: Restaura los datos desde el snapshot completo y sale de los modos de edici√≥n/asignaci√≥n.
function revertPersonalizationChanges() {
    if (personalizationSnapshot) {
        customData = JSON.parse(JSON.stringify(personalizationSnapshot.customData));
        currentBookmarks = JSON.parse(JSON.stringify(personalizationSnapshot.currentBookmarks));
        
    }
    if (isEditMode) toggleEditMode(false);
    if (isAssignmentMode) toggleAssignmentMode(false);
    showToast("Cambios descartados. Se ha restaurado el estado anterior.", "info");
}
  
// ===================================================================
// NOMBRE: showPoiCategoryModal 
// RESUMEN: Muestra el modal de categor√≠as con un bot√≥n de "A√±adir Manual" m√°s peque√±o y estilizado.
function showPoiCategoryModal() {
    closeOtherModals('poi-category-modal');
    hideAddressSuggestionsModal();
    const searchInput = document.getElementById('map-location-search-input');
    const customSearchQuery = searchInput ? searchInput.value.trim() : '';

    const groups = {
        "Veh√≠culo y Carretera": [
            { icon: 'üÖøÔ∏è', label: 'Parking', query: 'parking', key: 'amenity:parking' },
            { icon: 'üîã', label: 'P. Recarga VE', query: 'estacion de carga', key: 'amenity:charging_station' },
            { icon: 'üîã+', label: 'PdRs con + info', action: 'open_pdr_filters' },
            { icon: 'üöó', label: 'Tesla', query: 'tesla', key: 'shop:car' },
            { icon: 'üîß', label: 'Talleres', query: 'taller mecanico', key: 'shop:car_repair' },
            { icon: 'üßº', label: 'Lavado Coches', query: 'lavado de coches', key: 'amenity:car_wash' },
            { icon: '‚õΩ', label: 'Gasolineras :-))', query: 'gasolinera', key: 'amenity:fuel' },
            { icon: 'üöì', label: 'Polic√≠a', query: 'policia', key: 'amenity:police' }
        ],
        "Comer y Beber": [
            { icon: 'üçΩÔ∏è', label: 'Restaurantes', query: 'restaurante', key: 'amenity:restaurant' },
            { icon: '‚òï', label: 'Cafeter√≠as', query: 'cafeteria', key: 'amenity:cafe' },
            { icon: 'üç∫', label: 'Bares', query: 'bar', key: 'amenity:bar' },
            { icon: 'üçî', label: 'Comida R√°pida', query: 'comida rapida', key: 'amenity:fast_food' },
            { icon: 'ü•ê', label: 'Panader√≠as', query: 'panaderia', key: 'shop:bakery' }
        ],
        "Servicios y Compras": [
            { icon: 'üè®', label: 'Hoteles', query: 'hotel', key: 'tourism:hotel' },
            { icon: 'üõí', label: 'Supermercados', query: 'supermercado', key: 'shop:supermarket' },
            { icon: 'üõçÔ∏è', label: 'C. Comercial', query: 'centro comercial', key: 'shop:mall' },
            { icon: 'üèß', label: 'Cajeros', query: 'cajero automatico', key: 'amenity:atm' },
            { icon: 'üíä', label: 'Farmacias', query: 'farmacia', key: 'amenity:pharmacy' },
            { icon: 'üè•', label: 'Hospitales', query: 'hospital', key: 'amenity:hospital' },
            { icon: 'ü©∫', label: 'Centro Salud', query: 'centro de salud', key: 'amenity:clinic' }
        ],
        "Ocio y Turismo": [
            { icon: 'üèñÔ∏è', label: 'Playas', query: 'playa', key: 'natural:beach' },
            { icon: 'üèûÔ∏è', label: 'Parques', query: 'parques y/o zonas naturales', key: 'leisure:park' },
            { icon: 'üèõÔ∏è', label: 'Museos', query: 'museo', key: 'tourism:museum' },
            { icon: 'üè∞', label: 'Monumentos', query: 'monumento', key: 'historic:monument' },
            { icon: 'üî≠', label: 'Inter√©s tur√≠stico', query: 'Zona de inter√©s tur√≠stico', key: 'tourism:attraction' },
            { icon: 'üçø', label: 'Cines', query: 'cine', key: 'amenity:cinema' }
        ]
    };

    const modalOverlay = document.createElement('div');
    modalOverlay.id = 'poi-category-modal';
    modalOverlay.className = 'poi-category-modal-overlay';
    modalOverlay.style.position = 'absolute'; 
    
    let customSearchHtml = '';
    if (customSearchQuery) {
        const truncatedQuery = customSearchQuery.length > 20 ? customSearchQuery.substring(0, 17) + '...' : customSearchQuery;
        customSearchHtml = `
            <h3 class="poi-group-title custom-search-title">B√∫squeda Personalizada</h3>
            <div class="poi-category-grid custom-search-grid">
                <button id="custom-poi-search-button" class="poi-category-button custom-search-button" data-query="${customSearchQuery}">
                    <span class="icon">üîç</span>
                    <span style="font-style: italic;">"${truncatedQuery}"</span>
                </button>
            </div>
        `;
    }

    const addManualButtonHtml = isNavigating ? `
        <h3 class="poi-group-title" style="color: #FFD700; margin-bottom: 0.5rem;">A√±adir Etapa Manualmente pulsando en el mapa</h3>
        <div class="poi-add-manual-container">
            <button class="poi-add-manual-button" data-action="add_manual">
                <span class="icon">üìç</span>
                <span>Pulsar en el mapa para a√±adir una etapa o un POI de abajo (luego podr√° reordenar las etapas pulsando el bot√≥n de reordenaci√≥n)</span>
            </button>
        </div>
    ` : '';
 
    let groupsHtml = '';
    for (const groupName in groups) {
        let buttonsHtml = '';
        groups[groupName].forEach(cat => {
            if (cat.action) {
                buttonsHtml += `
                    <button class="poi-category-button" data-action="${cat.action}">
                        <span class="icon">${cat.icon}</span>
                        <span>${cat.label}</span>
                    </button>
                `;
            } else {
                buttonsHtml += `
                    <button class="poi-category-button" data-query="${cat.query}" data-key="${cat.key}">
                        <span class="icon">${cat.icon}</span>
                        <span>${cat.label}</span>
                    </button>
                `;
            }
        });
        groupsHtml += `
            <h3 class="poi-group-title">${groupName}</h3>
            <div class="poi-category-grid">${buttonsHtml}</div>
        `;
    }

    modalOverlay.innerHTML = `
        <style>

            .poi-category-modal-content { 
                max-height: 90vh; 
                overflow-y: auto; 
                width: 95vw;
                max-width: 1100px;
            }

            .poi-category-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
                gap: 15px;
            }

            .poi-category-button .icon {
                font-family: 'Noto Color Emoji', sans-serif;
                font-variant-emoji: emoji;
                -webkit-font-variant-emoji: emoji;
            }

            .poi-group-title {
                color: #ffffff;
                font-size: 1.1rem;
                font-weight: bold;
                margin-top: 20px;
                margin-bottom: 10px;
                padding-bottom: 5px;
                border-bottom: 1px solid #444;
            }
            .poi-group-title:first-of-type {
                margin-top: 0;
            }
            .poi-search-info-note {
                font-size: 0.8rem;
                color: #b0b0b0;
                text-align: center;
                margin-top: 20px;
                padding-top: 10px;
                border-top: 1px solid #444;
            }
            .custom-search-title {
                color: #50E3C2;
            }
            .custom-search-grid {
                grid-template-columns: 1fr;
            }
            .custom-search-button {
                background-color: #1c1c1e;
                border-color: #50E3C2;
                flex-direction: row;
                justify-content: center;
            }
            
            .poi-add-manual-container {
                margin-bottom: 20px;
                text-align: center;
            }
            .poi-add-manual-button {
                background-color: #007aff;
                color: white;
                border: 1px solid #0056b3;
                border-radius: 8px;
                padding: 8px 16px;
                font-size: 1rem;
                font-weight: bold;
                cursor: pointer;
                transition: background-color 0.2s, transform 0.1s;
                display: inline-flex;
                align-items: center;
                gap: 8px;
            }
            .poi-add-manual-button:hover {
                background-color: #0056b3;
            }
            .poi-add-manual-button .icon {
                font-family: 'Noto Color Emoji', sans-serif;
                font-size: 1.2rem;
            }
            
        </style>
        <div class="poi-category-modal-content">
            <div class="poi-category-modal-header">
                <h2>Buscar Puntos de Inter√©s</h2>
                <button class="poi-category-close-btn" title="Salir de la b√∫squeda de POIs">&times;</button>
            </div>
            ${addManualButtonHtml}
            ${customSearchHtml}
            ${groupsHtml}
            <p class="poi-search-info-note">(*) Las b√∫squedas se realizan en el √°rea que est√© viendo en ese momento en el mapa, est√© o no navegando una ruta. Si est√° navegando se pueden a√±adir sobre la marcha nuevas etapas o puntos de inter√©s e incluso reordenarlos pulsando el bot√≥n de reordenaci√≥n, para salir del modo pulse de nuevo el bot√≥n A√ëADIR PUNTO. TAMBI√âN PODR√Å BUSCAR CUALQUIER TIPO DE ESTABLECIMIENTO TECLEANDO LO QUE DESEA BUSCAR EN EL CAMPO DE B√öSQUEDA, A CONTINUACI√ìN ACCEDIENDO A ESTA PANTALLA Y PULSANDO ARRIBA DEL TODO EL BOT√ìN CON EL LITERAL.</p>
        </div>
    `;

    const mapModalContainer = document.getElementById('reminders-location-map-modal');
    if (mapModalContainer) {
        mapModalContainer.appendChild(modalOverlay);
    } else {
        document.body.appendChild(modalOverlay);
    }

    const closeModalAndDeactivate = () => {
        if (modalOverlay.parentNode) modalOverlay.remove();
        if (!isNavigating) {
             if (isPoiSearchActive) {
                togglePoiCategorySearch();
            }
        }
    };

    modalOverlay.querySelector('.poi-category-close-btn').addEventListener('click', closeModalAndDeactivate);

    if (customSearchQuery) {
        modalOverlay.querySelector('#custom-poi-search-button').addEventListener('click', (e) => {
            const button = e.currentTarget;
            const query = button.dataset.query;
            searchPoisByCategory(query, null); 
            if (modalOverlay.parentNode) modalOverlay.remove();
        });
    }

    modalOverlay.querySelector('.poi-category-modal-content').addEventListener('click', (e) => {
        const button = e.target.closest('.poi-category-button:not(#custom-poi-search-button), .poi-add-manual-button');
        if (!button) return;

        const action = button.dataset.action;

        if (action === 'add_manual') {
            if (modalOverlay.parentNode) modalOverlay.remove();
            return;
        }
        
        if (action === 'open_pdr_filters') {
            if (modalOverlay.parentNode) modalOverlay.remove();
            handlePdrSearchButtonClick();
        } else {
            const query = button.dataset.query;
            const key = button.dataset.key;
            searchPoisByCategory(query, key);
            if (modalOverlay.parentNode) modalOverlay.remove();
        }
    });
}
    
// ===================================================================
// NOMBRE: checkAndMarkWaypointsAsVisited 
// RESUMEN: Marca la etapa como visitada a 70m y muestra el modal de llegada solo a 20m.
function checkAndMarkWaypointsAsVisited(route, carDistanceAlongRoute, currentCoords) {
    if (!route || !route.legs || !currentCoords) return;

    let cumulativeDistance = 0;
    navigationWaypoints.forEach((wp, index) => {
        if (wp) {
            const isStartPoint = wp.type === 'S' || wp.isRecalculatedStart;
            const isIntermediate = wp.type === 'intermediate';
            const isFinal = wp.type === 'F';

            if (isStartPoint) {
                wp.visited = true;
            } else if (isIntermediate && (index - 1) < route.legs.length) {
                const leg = route.legs[index - 1];
                if (leg) {
                    const distanceToEndOfThisLeg = cumulativeDistance + (leg.distance || 0);
                    const tripHasPhysicallyStarted = isNavigating && navigationStartTimeForStats;
                    const hasClearedStartBuffer = carDistanceAlongRoute > 20;

                    if (tripHasPhysicallyStarted && hasClearedStartBuffer && carDistanceAlongRoute >= distanceToEndOfThisLeg - WAYPOINT_VISITED_THRESHOLD_METERS) {
                        wp.visited = true;
                    }
                    cumulativeDistance = distanceToEndOfThisLeg;
                }
            } else if (isFinal) {
                const finalDestinationCoords = route.legs[route.legs.length - 1].steps.slice(-1)[0].maneuver.location;
                const physicalDistanceToFinal = calculateDistance(currentCoords.latitude, currentCoords.longitude, finalDestinationCoords[1], finalDestinationCoords[0]);

                if (physicalDistanceToFinal <= WAYPOINT_VISITED_THRESHOLD_METERS) {
                    wp.visited = true;
                }

                if (physicalDistanceToFinal <= ARRIVAL_MODAL_THRESHOLD_METERS && !isArrivalSequenceStarted) {
                    triggerArrivalSequence();
                }
            }
        }
    });
}

// ===================================================================
// NOMBRE: showLoadRouteModal (VERSI√ìN 12.1 - CORRECCI√ìN DE EMOJIS)
// RESUMEN: Asegura que los botones con iconos usen la clase .icon-btn para renderizar emojis a color.
function showLoadRouteModal() {
    const displayLoadModal = () => {
        const existingOverlay = document.getElementById('route-modal-load-overlay');
        if (existingOverlay) existingOverlay.remove();

        const overlay = document.createElement('div');
        overlay.id = 'route-modal-load-overlay';
        overlay.className = 'route-modal-overlay';

        const modalContent = document.createElement('div');
        modalContent.id = 'saved-routes-modal';
        modalContent.className = 'route-modal-container';
        
        const newStyles = `
            #saved-routes-modal { max-width: 95vw; width: 1100px; }
            .route-list { display: grid; grid-template-columns: repeat(2, 1fr); gap: 2px 20px; }
            .route-list-item { display: flex; align-items: center; justify-content: space-between; padding: 0 12px; background-color: rgba(255, 255, 255, 0.08); border-radius: 8px; height: 50px; }
            #recent-items-list .route-list-item {}
            .route-name { font-size: 1.1rem; font-weight: 500; cursor: pointer; flex-grow: 1; margin-right: 10px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
            .route-actions { display: flex; gap: 8px; flex-shrink: 0; }
            .icon-btn { width: 40px; height: 40px; border-radius: 8px; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s, transform 0.1s; font-size: 22px; line-height: 1; font-variant-emoji: emoji; -webkit-font-variant-emoji: emoji; }
            .icon-btn:active { transform: scale(0.90); }
            .icon-btn svg { width: 24px; height: 24px; fill: white; }
            .btn-return { background-color: #8ccfff; }
            .btn-share { background-color: #bd894d; }
            .btn-delete { background-color: #dc2626; }
            .btn-save-from-recent { background-color: #0ea5e9; }
            @media (max-width: 768px) { #saved-routes-modal { width: 95vw; } .route-list { grid-template-columns: 1fr; } }
        `;

        modalContent.innerHTML = `
            <style>${newStyles}</style>
            <div class="route-modal-header"> <div class="route-modal-title-card"> <span class="route-modal-title">${isConcatenatingRoute ? 'A√±adir a Ruta Actual' : 'Cargar Destinos o Rutas'}</span> </div> </div>
            <div class="route-modal-body">
                <div class="route-modal-controls"> <input type="text" id="filter-saved-routes" class="route-filter-input" placeholder="FILTRAR DESTINOS Y RUTAS..."> <button id="clear-filter-button" class="clear-input-btn" title="Limpiar filtro" style="display: none;">√ó</button> </div>
                <h3 class="routes-section-title">Recientes</h3>
                <div id="recents-container" style="flex-grow: 0; margin-bottom: 15px; overflow: visible;"> <ul id="recent-items-list" class="route-list" style="grid-template-columns: 1fr; gap: 4px;"></ul> </div>
                <div class="route-modal-tabs"> <button class="route-modal-tab active" data-tab="destinos">DESTINOS GUARDADOS</button> <button class="route-modal-tab" data-tab="rutas">RUTAS GUARDADAS</button> </div>
                <div id="routes-container" class="route-scroll-container">
                    <div class="route-modal-panel active" id="panel-destinos"> <ul id="saved-destinations-list" class="route-list"></ul> </div>
                    <div class="route-modal-panel" id="panel-rutas"> <ul id="saved-routes-list" class="route-list"></ul> </div>
                </div>
            </div>
            <div class="route-modal-footer"> <button id="close-saved-routes-modal" class="btn-modal-action-secondary" style="flex: 1;">Cerrar <span class="button-countdown-timer unified-countdown-style"></span></button> </div>
        `;
        
        overlay.appendChild(modalContent);
        document.body.appendChild(overlay);

        const closeButton = modalContent.querySelector('#close-saved-routes-modal');
        const filterInput = modalContent.querySelector('#filter-saved-routes');
        const clearFilterBtn = modalContent.querySelector('#clear-filter-button');
        const tabs = modalContent.querySelectorAll('.route-modal-tab');
        const panels = modalContent.querySelectorAll('.route-modal-panel');
        let allSavedRoutes = []; 

        const closeHandler = () => {
            isConcatenatingRoute = false; 
            clearModalAutoCloseTimer(overlay, closeButton, 'saved-routes-modal');
            if (overlay.parentNode) overlay.remove();
        };
        closeButton.addEventListener('click', closeHandler);
        addModalAutoCloseTimer(overlay, closeButton, 'saved-routes-modal', 45000);

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                panels.forEach(p => p.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(`panel-${tab.dataset.tab}`).classList.add('active');
            });
        });
        
        const returnIcon = 'üîÑ';
        const shareIcon = 'üì≤';
        const deleteIcon = 'üóëÔ∏è';
        const saveIcon = '‚≠ê';

        const renderRouteListItem = (route, listElement, isRecent) => {
            const li = document.createElement('li');
            li.className = 'route-list-item';
            const showReturnButton = route.waypoints.length > 1;
            let actionButtonsHtml = '';
            if (isRecent) {
                const isAlreadyFavorite = allSavedRoutes.some(savedRoute => savedRoute.name.toUpperCase() === route.name.toUpperCase());
                if (!isAlreadyFavorite) {
                    actionButtonsHtml += `<button class="icon-btn btn-save-from-recent" title="Guardar en Favoritos">${saveIcon}</button>`;
                }
                actionButtonsHtml += `<button class="icon-btn btn-delete" title="Quitar de Recientes">${deleteIcon}</button>`;
            } else {
                actionButtonsHtml = `<button class="icon-btn btn-delete" title="Borrar permanentemente">${deleteIcon}</button>`;
            }

            li.innerHTML = `
                <span class="route-name">${route.name}</span>
                <div class="route-actions">
                    ${showReturnButton ? `<button class="icon-btn btn-return" title="Cargar ruta en sentido inverso">${returnIcon}</button>` : ''}
                    <button class="icon-btn btn-share" title="Compartir coordenadas">${shareIcon}</button> 
                    ${actionButtonsHtml}
                </div>
            `;
            
            li.querySelector('.route-name').addEventListener('click', () => {
                loadRouteByName(route.name, true);
                if (!isConcatenatingRoute) { 
                    addRouteToRecents(route);
                }
                closeHandler();
            });

            li.querySelector('.btn-share').addEventListener('click', (e) => {
                 e.stopPropagation();
                 if (route.waypoints.length === 1) {
                     const dest = route.waypoints[0];
                     handleSendToTeslaClick(dest.lat, dest.lng, dest.address);
                 } else {
                     closeHandler();
                     showShareStageModal(route);
                 }
            });

            if (showReturnButton) {
                li.querySelector('.btn-return').addEventListener('click', (e) => {
                    e.stopPropagation();
                    getCurrentLocation(
                        async (currentPos) => {
                            const originalWaypoints = [...route.waypoints];
                            const originalStart = originalWaypoints.shift();
                            if (originalWaypoints.length > 0) { originalWaypoints.pop(); }
                            const intermediateReversed = originalWaypoints.reverse();
                            let returnWaypoints = [{ lat: currentPos.latitude, lng: currentPos.longitude, address: 'Posici√≥n Actual (GPS)'}, ...intermediateReversed, originalStart];
                            const returnRouteObject = { name: `VUELTA: ${route.name}`, waypoints: returnWaypoints };
                            loadRouteFromObject(returnRouteObject, true);
                            addRouteToRecents(returnRouteObject);
                            closeHandler();
                        },
                        (errorMsg) => { showToast(`Error al obtener ubicaci√≥n: ${errorMsg}`, "error"); }
                    );
                });
            }
            
            const deleteButton = li.querySelector('.btn-delete');
            if (deleteButton) {
                deleteButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const storageKey = isRecent ? 'boardinggate_recent_routes' : SAVED_ROUTES_KEY;
                    let routes = JSON.parse(localStorage.getItem(storageKey) || "[]");
                    routes = routes.filter(r => r.name !== route.name);
                    localStorage.setItem(storageKey, JSON.stringify(routes));
                    if (!isRecent) { markCacheAsDirty(); }
                    showToast(`"${route.name}" ${isRecent ? 'quitado de recientes' : 'borrado'}.`, "info");
                    displayRoutes();
                });
            }

            const saveButton = li.querySelector('.btn-save-from-recent');
            if (saveButton) {
                saveButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showSaveRoutePromptModal(route.name, (confirmedName) => {
                        const routeToSave = { ...route, name: confirmedName, createdAt: new Date().toISOString() };
                        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
                        const existingRouteIndex = savedRoutes.findIndex(r => r.name.toUpperCase() === confirmedName.toUpperCase());
                        if (existingRouteIndex !== -1) {
                            if (confirm(`Ya existe una ruta/destino con el nombre "${confirmedName}". ¬øDeseas sobreescribirla?`)) {
                                savedRoutes[existingRouteIndex] = routeToSave;
                            } else {
                                showToast("Guardado cancelado", "info");
                                return;
                            }
                        } else {
                            savedRoutes.push(routeToSave);
                        }
                        localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes));
                        markCacheAsDirty();
                        showToast(`"${confirmedName}" guardado en favoritos.`, "success");
                        displayRoutes();
                    });
                });
            }
            listElement.appendChild(li);
        };
        
        const displayRoutes = () => {
            const filterText = filterInput.value.toUpperCase().trim();
            clearFilterBtn.style.display = filterText ? 'block' : 'none';
            let recentRoutes = JSON.parse(localStorage.getItem('boardinggate_recent_routes') || "[]");
            allSavedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");

            const recentItemsList = document.getElementById('recent-items-list');
            const recentsTitle = recentItemsList.parentElement.previousElementSibling;
            recentItemsList.innerHTML = '';
            const filteredRecents = recentRoutes.filter(r => r.name.toUpperCase().includes(filterText));
            if (filteredRecents.length > 0) {
                recentsTitle.style.display = 'block';
                filteredRecents.forEach(route => renderRouteListItem(route, recentItemsList, true));
            } else {
                recentsTitle.style.display = 'none';
            }

            allSavedRoutes.sort((a, b) => a.name.localeCompare(b.name, 'es', { sensitivity: 'base' }));
            const recentRouteNames = recentRoutes.map(r => r.name);
            const savedDestinationsList = document.getElementById('saved-destinations-list');
            savedDestinationsList.innerHTML = '';
            const savedDestinations = allSavedRoutes.filter(r => {
                const isSingleDestination = r.waypoints.length === 1 || (r.waypoints.length === 2 && (r.waypoints[0].type === 'S' || r.waypoints[0].isRecalculatedStart));
                return isSingleDestination && !recentRouteNames.includes(r.name) && r.name.toUpperCase().includes(filterText);
            });
       
            if (savedDestinations.length > 0) {
                savedDestinations.forEach(route => renderRouteListItem(route, savedDestinationsList, false));
            } else {
                savedDestinationsList.innerHTML = `<li class="route-list-empty">No hay destinos guardados que coincidan.</li>`;
            }

            const savedRoutesList = document.getElementById('saved-routes-list');
            savedRoutesList.innerHTML = '';
            const savedMultiStage = allSavedRoutes.filter(r => {
                const isMultiStageRoute = r.waypoints.length > 1 && !(r.waypoints.length === 2 && (r.waypoints[0].type === 'S' || r.waypoints[0].isRecalculatedStart));
                return isMultiStageRoute && !recentRouteNames.includes(r.name) && r.name.toUpperCase().includes(filterText);
            });
            
            if (savedMultiStage.length > 0) {
                savedMultiStage.forEach(route => renderRouteListItem(route, savedRoutesList, false));
            } else {
                savedRoutesList.innerHTML = `<li class="route-list-empty">No hay rutas guardadas que coincidan.</li>`;
            }
        };

        filterInput.addEventListener('input', displayRoutes);
        clearFilterBtn.addEventListener('click', () => { filterInput.value = ''; displayRoutes(); });
        displayRoutes();
    };

    const hasExistingRoute = navigationWaypoints.filter(wp => wp && !wp.isInternal).length >= 2;

    if (hasExistingRoute) {
        closeOtherModals('route-concat-choice-modal');
        const choiceModal = document.getElementById('route-concat-choice-modal');
        choiceModal.classList.remove('hidden');
        
        const appendBtn = document.getElementById('concat-choice-append');
        const replaceBtn = document.getElementById('concat-choice-replace');
        const cancelBtn = document.getElementById('concat-choice-cancel');
        
        const choiceCloseHandler = () => {
            clearModalAutoCloseTimer(choiceModal, appendBtn, 'route-concat-choice-modal');
            choiceModal.classList.add('hidden');
        };

        appendBtn.onclick = () => {
            isConcatenatingRoute = true;
            choiceCloseHandler();
            displayLoadModal();
        };

        replaceBtn.onclick = () => {
            resetNavigationState();
            choiceCloseHandler();
            displayLoadModal();
        };
        
        cancelBtn.onclick = choiceCloseHandler;

        addModalAutoCloseTimer(choiceModal, appendBtn, 'route-concat-choice-modal', 20000);

    } else {
        resetNavigationState();
        displayLoadModal();
    }
}
    
// ===================================================================
// NOMBRE: showWaypointActionModal 
// RESUMEN: Muestra un modal con el nuevo dise√±o oscuro y botones con emojis a color.
function showWaypointActionModal(waypointId) {
    const wp = navigationWaypoints.find(w => w && w.id === waypointId);
    if (!wp) return;

    const existingOverlay = document.getElementById('route-modal-action-overlay');
    if(existingOverlay) existingOverlay.remove();
    
    const overlay = document.createElement('div');
    overlay.id = 'route-modal-action-overlay';
    overlay.className = 'route-modal-overlay';
    
    let distanceToWaypoint = 0, timeToWaypoint = 0, etaToWaypoint = "--:--";
    const currentActualWaypointsForModal = navigationWaypoints.filter(w => w && !w.isInternal && !w.isRecalculatedStart);
    const actualWaypointIndexInRoute = currentActualWaypointsForModal.findIndex(awp => awp.id === wp.id);
    if (navigationCurrentRouteData?.routes?.[0]) {
        const route = navigationCurrentRouteData.routes[0];
        if (actualWaypointIndexInRoute > 0) {
            for (let i = 0; i < actualWaypointIndexInRoute && i < route.legs.length; i++) {
                distanceToWaypoint += (route.legs[i].distance || 0);
                timeToWaypoint += (route.legs[i].duration || 0);
            }
        }
        if (timeToWaypoint > 0) etaToWaypoint = new Date(Date.now() + timeToWaypoint * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }
    const distanciaTexto = `${(distanceToWaypoint / 1000).toFixed(1)} km`;
    const waypointTotalMinutes = Math.round(timeToWaypoint / 60);
    const tiempoTexto = `${String(Math.floor(waypointTotalMinutes / 60)).padStart(2, '0')}:${String(waypointTotalMinutes % 60).padStart(2, '0')}`;
    
    const alternativesButtonHtml = (wp.type !== 'S' && wp.type !== 'S_Recalc') ? `<button id="modal-alternatives-btn" class="btn-modal-action-primary icon-btn">Otras Rutas üó∫Ô∏è</button>` : '';
    const deleteButtonHtml = (wp.type !== 'S_Recalc') ? `<button id="modal-delete-btn" class="btn-modal-danger icon-btn">Borrar Punto üóëÔ∏è</button>` : '';
    const favoriteButtonHtml = `<button id="modal-favorite-btn" class="btn-modal-favorite icon-btn">A√±adir a Favoritos ‚≠ê</button>`;
    const weatherButtonHtml = `<button id="modal-weather-btn" class="btn-modal-action-primary icon-btn">Clima en esta Etapa üå§Ô∏è</button>`;
    const reorderButtonHtml = `<button id="modal-reorder-btn" class="btn-modal-favorite icon-btn">Reordenar üîÅ</button>`; // <-- BOT√ìN NUEVO

    overlay.innerHTML = `
        <div id="waypoint-action-modal" class="route-modal-container">
            <div class="route-modal-header">
                <div class="route-modal-title-card">
                    <span class="route-modal-title">Etapa ${wp.label}</span>
                </div>
            </div>
            <div class="route-modal-body">
                <p style="font-size: 1.1rem; color: #f0f0f0; margin-bottom: 15px;"><strong>Destino:</strong> ${wp.address}</p>
                <p><strong>Distancia:</strong> ${distanciaTexto}</p>
                <p><strong>Tiempo:</strong> ${tiempoTexto}</p>
                <p><strong>Llegada (ETA):</strong> ${etaToWaypoint}</p>
            </div>
            <div class="route-modal-footer" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <button id="modal-share-btn" class="btn-modal-action-primary icon-btn">Compartir üì≤</button>
                ${alternativesButtonHtml}
                ${favoriteButtonHtml}
                ${weatherButtonHtml}
                ${reorderButtonHtml}
                ${deleteButtonHtml}
                <button id="modal-close-btn" class="btn-modal-action-secondary" style="grid-column: 1 / -1;">Cerrar <span class="button-countdown-timer unified-countdown-style"></span></button>
            </div>
        </div>
    `;

    document.body.appendChild(overlay);

    const closeHandler = () => {
        clearModalAutoCloseTimer(overlay, overlay.querySelector('#modal-close-btn, #modal-delete-btn'), 'waypoint-action-modal');
        if (overlay.parentNode) overlay.remove();
    };

    overlay.querySelector('#modal-close-btn').addEventListener('click', closeHandler);
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) closeHandler();
    });

    overlay.querySelector('#modal-share-btn').addEventListener('click', () => {
        handleSendToTeslaClick(wp.lat, wp.lng, wp.address);
        closeHandler();
    });

    overlay.querySelector('#modal-favorite-btn').addEventListener('click', () => {
        saveSingleWaypointAsFavorite(wp.id);
        closeHandler();
    });
    
    const reorderBtn = overlay.querySelector('#modal-reorder-btn');
    if (reorderBtn) {
        reorderBtn.addEventListener('click', () => {
            closeHandler();
            showReorderStagesModal();
        });
    }
 
    const weatherBtn = overlay.querySelector('#modal-weather-btn');
    if (weatherBtn) {
        weatherBtn.addEventListener('click', () => {
            if (navigationCurrentLocation) {
                weatherWidgetForceShowUntil = Date.now() + 30000; // Forzar visibilidad
                updateWeatherWidget(navigationCurrentLocation.latitude, navigationCurrentLocation.longitude, { lat: wp.lat, lon: wp.lng });
                closeHandler();
            } else {
                showToast("No se puede mostrar el clima. Ubicaci√≥n actual no disponible.", "warning");
            }
        });
    }

    const alternativesBtn = overlay.querySelector('#modal-alternatives-btn');
    if (alternativesBtn) {
        alternativesBtn.addEventListener('click', () => {
            fetchAndDisplayAlternativeRoutes(wp.id);
            closeHandler();
        });
    }

    const deleteBtn = overlay.querySelector('#modal-delete-btn');
    if (deleteBtn) {
        deleteBtn.addEventListener('click', () => {
            handleDeleteWaypointClick(wp.id);
            closeHandler();
        });
    }
    addModalAutoCloseTimer(overlay, overlay.querySelector('#modal-close-btn, #modal-delete-btn'), 'waypoint-action-modal', 20000);
}
// ===================================================================
// NOMBRE: loadAndCacheLerpSettings 
// RESUMEN: Lee los valores de suavizado desde localStorage y los guarda
function loadAndCacheLerpSettings() {
    lerpRatePosition = parseFloat(localStorage.getItem(LERP_RATE_POS_KEY)) || 0.004;
    lerpRateRotation = parseFloat(localStorage.getItem(LERP_RATE_ROT_KEY)) || 0.002;
    lerpRateZoom = parseFloat(localStorage.getItem(LERP_RATE_ZOOM_KEY)) || 0.0007;
}

// ===================================================================
// NOMBRE: saveSettings 
// ===================================================================
function saveSettings() {
    localStorage.setItem('darkMode', JSON.stringify(isDarkMode));
    const tS = {};
    document.querySelectorAll('.range-toggle').forEach(t => {
        const start = t.dataset.rangeStart;
        if (start) tS[start] = t.dataset.state;
    });
    localStorage.setItem('toggleStates', JSON.stringify(tS));
    const zoomButton = document.getElementById('zoom-button');
    if (zoomButton) localStorage.setItem('zoomState', zoomButton.dataset.zoomState);
    const onOffBtn = document.getElementById('on-off-toggle');
    if (onOffBtn) localStorage.setItem('onOffState', onOffBtn.dataset.state);
    localStorage.setItem('noticesActive', JSON.stringify(isActive));
    localStorage.setItem('footerVisible', JSON.stringify(isFooterVisible));
    localStorage.setItem('password_active', JSON.stringify(isPasswordActive));
    localStorage.setItem('lastUpdatesCheckDate', lastUpdatesCheckDate);
    localStorage.setItem(GRAPH_STATE_KEY, currentGraphMode);
    localStorage.setItem(MAP_VIEW_OFFSET_X_KEY, mapOffsetX);
    localStorage.setItem(MAP_VIEW_OFFSET_Y_KEY, mapOffsetY);
    localStorage.setItem(MAP_VIEW_SHOW_MINIMAP_KEY, showMinimapPreference);
    localStorage.setItem(MAP_VIEW_PITCH_KEY, mapPitchValue);
    
    localStorage.setItem('boardinggate_map_saturation', document.documentElement.style.getPropertyValue('--map-saturation').trim() || '1.6');
    localStorage.setItem('boardinggate_map_contrast', document.documentElement.style.getPropertyValue('--map-contrast').trim() || '1.2');
    localStorage.setItem(LERP_RATE_POS_KEY, localStorage.getItem(LERP_RATE_POS_KEY) || '0.004');
    localStorage.setItem(LERP_RATE_ROT_KEY, localStorage.getItem(LERP_RATE_ROT_KEY) || '0.002');
    localStorage.setItem(LERP_RATE_ZOOM_KEY, localStorage.getItem(LERP_RATE_ZOOM_KEY) || '0.001');
    localStorage.setItem(MAP_TERRAIN_EXAGGERATION_KEY, mapTerrainExaggeration); 

    const radaresCheckboxElement = document.getElementById('radares-ruta-checkbox');
    if (radaresCheckboxElement) {
        localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckboxElement.checked));
    }
    const tareasCheckboxElement = document.getElementById('tareas-ruta-checkbox');
    if (tareasCheckboxElement) { 
        localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckboxElement.checked));
    }
    const mainSearchInputGrid = document.getElementById('main-search-input');  
    if (mainSearchInputGrid) {
        localStorage.setItem('gridFilterValue', mainSearchInputGrid.value);
    }
    const mapFilterInput = document.getElementById('filter-input'); 
    if (mapFilterInput) {
        localStorage.setItem(MAP_FILTER_INPUT_KEY, mapFilterInput.value);
    }
    if (mapLayersControl && mapLayersControl._map && mapLayersControl._map._layers) {
        const layersArray = Object.values(mapLayersControl._map._layers);
        const baseLayerMapObject = layersArray.find(l => l._map && l.options && !l.options.pane && l.options.attribution);
        if (baseLayerMapObject) {
            const activeLayerEntry = mapLayersControl._layers.find(l => l.layer === baseLayerMapObject);
            if (activeLayerEntry && activeLayerEntry.name) {
                localStorage.setItem(ACTIVE_MAP_LAYER_KEY, activeLayerEntry.name);
            }
        }
    }
    markCacheAsDirty(); 
}
 
// ===================================================================
// NOMBRE: loadSavedSettings
// ===================================================================
function loadSavedSettings() {
    const savedDarkMode = localStorage.getItem('darkMode');
    isDarkMode = savedDarkMode ? JSON.parse(savedDarkMode) : false;
    if (isDarkMode) document.body.classList.add('dark-mode');

    showRouteMinimapPreference = localStorage.getItem(SHOW_ROUTE_MINIMAP_KEY) === null ? true : JSON.parse(localStorage.getItem(SHOW_ROUTE_MINIMAP_KEY));
    
    mapOffsetX = parseInt(localStorage.getItem(MAP_VIEW_OFFSET_X_KEY)) || 0;
    mapOffsetY = parseInt(localStorage.getItem(MAP_VIEW_OFFSET_Y_KEY)) || 15;
    const savedMinimapPref = localStorage.getItem(MAP_VIEW_SHOW_MINIMAP_KEY);
    showMinimapPreference = savedMinimapPref === null ? false : JSON.parse(savedMinimapPref);
    mapPitchValue = parseInt(localStorage.getItem(MAP_VIEW_PITCH_KEY)) || 62;
    mapTerrainExaggeration = parseFloat(localStorage.getItem(MAP_TERRAIN_EXAGGERATION_KEY)) || 0.5; 

    const savedAnnounceFlash = localStorage.getItem('boardinggate_announce_maneuver_flash');
    announceManeuverWithFlash = savedAnnounceFlash === null ? true : JSON.parse(savedAnnounceFlash);
    
    baseCriticalRatio = parseInt(localStorage.getItem(PERFORMANCE_RATIO_CRITICAL_KEY)) || 3;
    performanceRatios.criticalUpdate = baseCriticalRatio;
    performanceRatios.routeProgress = parseInt(localStorage.getItem(PERFORMANCE_RATIO_ROUTE_KEY)) || 20;
    performanceRatios.trafficAlerts = parseInt(localStorage.getItem(PERFORMANCE_RATIO_ALERTS_KEY)) || 350;
    performanceRatios.tripStats = parseInt(localStorage.getItem(PERFORMANCE_RATIO_STATS_KEY)) || 50;
    performanceRatios.performanceGraph = parseInt(localStorage.getItem(PERFORMANCE_RATIO_GRAPH_KEY)) || 75;

    baseCameraFps = parseInt(localStorage.getItem(PERFORMANCE_CAMERA_FPS_KEY)) || 18;
    MAP_UPDATE_INTERVAL_MS = 1000 / baseCameraFps;
    originalMapUpdateIntervalMs = MAP_UPDATE_INTERVAL_MS;
    
    loadAndCacheLerpSettings();
 
    if (!localStorage.getItem('boardinggate_map_saturation')) localStorage.setItem('boardinggate_map_saturation', '1.6');
    if (!localStorage.getItem('boardinggate_map_contrast')) localStorage.setItem('boardinggate_map_contrast', '1.2');
    
    memoryReloadThreshold = parseFloat(localStorage.getItem('boardinggate_memory_threshold')) || 0.20;
    
    const savedZoomState = localStorage.getItem('zoomState');
    const zoomButtonElem = document.getElementById('zoom-button');
    if (zoomButtonElem) {
        zoomButtonElem.dataset.zoomState = savedZoomState || 'off';
        applyZoom(zoomButtonElem.dataset.zoomState);
    }
    const savedPasswordActive = localStorage.getItem('password_active');
    isPasswordActive = savedPasswordActive ? JSON.parse(savedPasswordActive) : false;
    storedPin = localStorage.getItem('password_pin');
    lastUpdatesCheckDate = localStorage.getItem('lastUpdatesCheckDate');
    mapViewMode = localStorage.getItem(MAP_VIEW_MODE_KEY) || 'relief';
    currentAutoZoomMode = localStorage.getItem(AUTO_ZOOM_MODE_KEY) || 'off';
    const savedNoticesActive = localStorage.getItem('noticesActive');
    const savedFooterVisible = localStorage.getItem('footerVisible');
    isActive = savedNoticesActive ? JSON.parse(savedNoticesActive) : true;
    isFooterVisible = savedFooterVisible ? JSON.parse(savedFooterVisible) : true;
    const noticeContainer = document.querySelector('.notices-container');
    if (noticeContainer) noticeContainer.style.display = isActive ? 'flex' : 'none';
    const footerElement = document.querySelector('footer');
    if (footerElement) footerElement.classList.toggle('footer-hidden', !isFooterVisible);
    const onOffBtn = document.getElementById('on-off-toggle');
    if (onOffBtn) {
        const savedOnOffState = localStorage.getItem('onOffState');
        onOffBtn.dataset.state = savedOnOffState ? savedOnOffState : 'on';
    }
    const toggleStatesFromCache = JSON.parse(localStorage.getItem('toggleStates') || '{}');
    document.querySelectorAll('.range-toggle').forEach(toggle => {
        const start = parseInt(toggle.dataset.rangeStart);
        const savedState = toggleStatesFromCache[start] || 'visible';
        toggle.dataset.state = savedState;
    });
    const mainSearchInputGrid = document.getElementById('grid-filter-input');
    if (mainSearchInputGrid) {
        const savedMainFilter = localStorage.getItem('gridFilterValue');
        if (savedMainFilter !== null) {
            mainSearchInputGrid.value = savedMainFilter;
        } else {
            mainSearchInputGrid.value = '';
        }
    }
    
    const mapFilterInput = document.getElementById('filter-input'); 
    if (mapFilterInput) {
        mapFilterInput.value = localStorage.getItem(MAP_FILTER_INPUT_KEY) || 'Espa√±a';
    }
    
    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresRutaCheckbox) {
        const savedCheckState = localStorage.getItem(RADARES_RUTA_CHECKED_KEY);
        radaresRutaCheckbox.checked = savedCheckState === 'true';
    }
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasRutaCheckbox) {
        const savedTareasCheckState = localStorage.getItem(TAREAS_RUTA_CHECKED_KEY);
        tareasRutaCheckbox.checked = savedTareasCheckState === 'true';
    }
    currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviaci√≥n ETA';
    const userIdInput = document.getElementById('user-id');
    const modelInput = document.getElementById('tesla-model');
    const yearInput = document.getElementById('tesla-year');
    const provinceInput = document.getElementById('tesla-province');
    const dmsCheckbox = document.getElementById('allow-dms');
    const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
    if (userIdInput) userIdInput.value = localStorage.getItem('userData_userId') || '';
    if (modelInput) modelInput.value = localStorage.getItem('userData_teslaModel') || '';
    if (yearInput) yearInput.value = localStorage.getItem('userData_teslaYear') || '';
    if (provinceInput) provinceInput.value = localStorage.getItem('userData_teslaProvince') || '';
   
   const savedAllowDMs = localStorage.getItem('userData_allowDMs');
   if (dmsCheckbox) {
    dmsCheckbox.checked = savedAllowDMs === null ? true : JSON.parse(savedAllowDMs); 
   } 
    
    if (autoBackupCheckbox) {
        const savedAutoBackup = localStorage.getItem('boardinggate_autoBackupOnLoad');
        autoBackupCheckbox.checked = savedAutoBackup === null ? true : JSON.parse(savedAutoBackup);
    }
    const savedLockState = localStorage.getItem(PROGRESS_BAR_LOCKED_KEY);
    isProgressBarLocked = savedLockState === null ? true : JSON.parse(savedLockState);
    actualizarContadorRadares(0);
    actualizarContadorTareas(0);
    updateUserIdDisplay();
    updateReminderCount();
}
        
// ===================================================================
// NOMBRE: updateDynamicRadars 
// RESUMEN: Carga radares din√°micos. Se ha eliminado la condici√≥n que
async function updateDynamicRadars(isInitialLoadCheck = false) {
    const nowDate = new Date();
    const now = nowDate.getTime();
    const timeSinceLastCheck = now - lastDynamicRadarCheck;
    if (isInitialLoadCheck) {
        const hasExistingDynamicRadars = processedRemindersCache.some(r => r.isDynamicRadar === true);
        if (timeSinceLastCheck < 30 * 60 * 1000 && hasExistingDynamicRadars) return;
    }
    lastDynamicRadarCheck = now;
        
    if (!window.radarsCache || !window.radarsSpatialIndex) {
        await initializeRadarCache();
        if (!window.radarsCache) {
            showToast("No se pudo inicializar la base de datos de radares.", "error");
            return;
        }
    }
    
    try {
        let newRadars = [];
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]').filter(r => !r.isDynamicRadar);
        
        let coords = null;
        if (navigationCurrentLocation && (Date.now() - lastGpsUpdateTime < 30000)) {
            coords = navigationCurrentLocation;
        } else {
            coords = await getCurrentLocationAsync();
        }
        if (!coords) throw new Error("Ubicaci√≥n del veh√≠culo no disponible.");

        const DYNAMIC_RADAR_SEARCH_RADIUS_KM = 25;
        const candidateRadars = new Set();
        const R = 6371;
        const rad = DYNAMIC_RADAR_SEARCH_RADIUS_KM / R;
        const latRad = coords.latitude * Math.PI / 180;
        const GRID_SIZE = 0.1;

        const latMin = coords.latitude - (rad * 180 / Math.PI);
        const latMax = coords.latitude + (rad * 180 / Math.PI);
        const deltaLon = Math.asin(Math.sin(rad) / Math.cos(latRad));
        const lonMin = coords.longitude - (deltaLon * 180 / Math.PI);
        const lonMax = coords.longitude + (deltaLon * 180 / Math.PI);
        
        const latIndexMin = Math.floor(latMin / GRID_SIZE);
        const latIndexMax = Math.floor(latMax / GRID_SIZE);
        const lonIndexMin = Math.floor(lonMin / GRID_SIZE);
        const lonIndexMax = Math.floor(lonMax / GRID_SIZE);
        
        for (let i = latIndexMin; i <= latIndexMax; i++) {
            for (let j = lonIndexMin; j <= lonIndexMax; j++) {
                const cellId = `cell_${i}_${j}`;
                if (window.radarsSpatialIndex[cellId]) {
                    window.radarsSpatialIndex[cellId].forEach(radar => candidateRadars.add(radar));
                }
            }
        }

       const savedRadius = parseInt(localStorage.getItem('boardinggate_dynamicRadarRadius'), 10);
       const radiusToUse = (savedRadius && savedRadius > 0) ? savedRadius : 400;

        candidateRadars.forEach(radar => {
            const distance = calculateDistance(coords.latitude, coords.longitude, radar.lat, radar.lon);
            if (distance <= (DYNAMIC_RADAR_SEARCH_RADIUS_KM * 1000)) {
                newRadars.push({
                    id: Date.now() + Math.random() + newRadars.length,
                    text: `<b>RADAR: ${radar.name}</b>`,
                    type: 'simple', time: '00:01',
                    date: `${nowDate.getFullYear()}-${(nowDate.getMonth() + 1).toString().padStart(2, '0')}-${nowDate.getDate().toString().padStart(2, '0')}`,
                    createdAt: nowDate.toISOString(), managedByUser: false,
                    isLocationEnabled: true, locationCoordinates: { latitude: radar.lat, longitude: radar.lon },
                    radiusMeters: radiusToUse, excludeFromList: true,
                    isDynamicRadar: true
                });
            }
        });
        
        reminders.push(...newRadars);
        localStorage.setItem('reminders', JSON.stringify(reminders));
        markCacheAsDirty();
        
        if (isNavigationMapActive) {
            plotRemindersOnNavigationMap();
        }
        updateReminderCount();
        updateButtonStyles();
     
    } catch (error) {
        console.error("Error al actualizar radares din√°micos:", error);
    }
}
    
    
// ===================================================================
// NOMBRE: applyMainUISettings 
// RESUMEN: Aplica todas las configuraciones visuales de la interfaz principal (toggles, filtros, etc.).
function applyMainUISettings() {
    renderGrid();
    createOtherButtons();
    renderToggleButtons();
    updateButtonStyles();
    filterGridItems();
    setTimeout(adjustButtonPositions, 100);
}    

// ===================================================================
// NOMBRE: showPoiInfoModal 
// RESUMEN: Muestra un modal enriquecido con datos de Google Places.
async function showPoiInfoModal(feature) {
    const existingModal = document.querySelector('.poi-modal-overlay');
    if (existingModal) existingModal.remove();

    const overlay = document.createElement('div');
    overlay.className = 'poi-modal-overlay';
    
    overlay.innerHTML = `
        <div class="poi-modal-content">
            <div class="poi-modal-body" style="text-align: center; padding: 3rem;">
                <p>Obteniendo informaci√≥n del lugar...</p>
            </div>
        </div>
    `;
    document.body.appendChild(overlay);

    try {
        const canProceed = await checkAndIncrementPoiCount();
        if (!canProceed) {
            if (overlay.parentNode) overlay.remove();
            return;
        }

        const mapboxProperties = feature.properties || {};
        const coordinates = feature.geometry.coordinates.slice();
        const mapboxName = mapboxProperties.name || 'Punto de Inter√©s';
        
        const placeId = await findGooglePlaceId(mapboxName, coordinates[1], coordinates[0]);
        
        let name, address, phone, website, imageUrl, saveName, photosHtml = '', commentsHtml = '', detailsHtml = '';
        const lat = coordinates[1];
        const lng = coordinates[0];

        if (placeId) {
            const googleDetails = await getGooglePlaceDetails(placeId);
            
            if (googleDetails) {
                name = googleDetails.displayName || mapboxName;
                address = googleDetails.formattedAddress || `(${lat.toFixed(4)}, ${lng.toFixed(4)})`;
                phone = googleDetails.nationalPhoneNumber;
                website = googleDetails.websiteURI;
                imageUrl = (googleDetails.photos && googleDetails.photos.length > 0) 
                    ? googleDetails.photos[0].getURI({ maxWidth: 600, maxHeight: 400 }) 
                    : 'PNG/modalrutas.png'; // <-- CAMBIO APLICADO AQU√ç
                saveName = name;

                detailsHtml += '<h4>Valoraci√≥n</h4>';
                if(googleDetails.rating) {
                    detailsHtml += `<p>${'‚òÖ'.repeat(Math.round(googleDetails.rating))}${'‚òÜ'.repeat(5 - Math.round(googleDetails.rating))} (${googleDetails.rating} de ${googleDetails.userRatingCount} opiniones)</p>`;
                } else {
                    detailsHtml += '<p>No hay valoraciones disponibles.</p>';
                }
                
                if (googleDetails.regularOpeningHours) {
                    detailsHtml += '<h4>Horario</h4>';
                    googleDetails.regularOpeningHours.weekdayDescriptions.forEach(day => {
                        detailsHtml += `<p>${day}</p>`;
                    });
                }
                
                detailsHtml += '<h4>Contacto</h4>';
                if(phone) detailsHtml += `<p><strong>Tel√©fono:</strong> <a href="tel:${phone}">${phone}</a></p>`;
                if(website) detailsHtml += `<p><strong>Web:</strong> <a href="${website}" target="_blank">${website}</a></p>`;
                if(googleDetails.googleMapsURI) detailsHtml += `<p><strong>En Google Maps:</strong> <a href="${googleDetails.googleMapsURI}" target="_blank">Abrir</a></p>`;

                if (googleDetails.photos && googleDetails.photos.length > 0) {
                    photosHtml = '<div class="ocm-photo-grid">' + googleDetails.photos.slice(0, 6).map(photo => 
                        `<img src="${photo.getURI({ maxWidth: 200, maxHeight: 200 })}" alt="Foto de ${name}" data-full-url="${photo.getURI()}">`
                    ).join('') + '</div>';
                } else { photosHtml = '<p>No hay fotos disponibles.</p>'; }

                if (googleDetails.reviews && googleDetails.reviews.length > 0) {
                    commentsHtml = '<ul class="ocm-comment-list">' + googleDetails.reviews.map(review => {
                        const authorName = review.authorAttribution ? review.authorAttribution.displayName : 'An√≥nimo';
                        const reviewDate = review.publishTime ? new Date(review.publishTime).toLocaleDateString('es-ES', { day: '2-digit', month: 'short', year: 'numeric'}) : '';
                        const reviewText = review.text ? review.text.originalText : 'Sin comentario.';
                        return `
                        <li class="ocm-comment">
                            <div class="ocm-comment-header">
                                <span class="user">${authorName} (${review.rating} ‚òÖ)</span>
                                <span class="date">${reviewDate}</span>
                            </div>
                            <p class="comment-text">${reviewText}</p>
                        </li>
                    `}).join('') + '</ul>';
                } else { commentsHtml = '<p>No hay opiniones disponibles.</p>'; }

            } else {
                throw new Error("Google Place Details fall√≥ despu√©s de encontrar un ID.");
            }
        } else {
            name = mapboxName;
            address = `(${lat.toFixed(4)}, ${lng.toFixed(4)})`;
            category = translatePoiCategory(mapboxProperties.categories || []);
            imageUrl = 'PNG/modalrutas.png'; // <-- CAMBIO APLICADO AQU√ç
            saveName = name;
            detailsHtml = `<h4>Categor√≠a</h4><p>${category}</p><p>No se encontraron detalles adicionales en Google.</p>`;
            photosHtml = '<p>No disponible.</p>';
            commentsHtml = '<p>No disponible.</p>';
        }
        
        const existingWaypoint = findExistingWaypointAtCoords(lat, lng);
        let buttonsHtml = `
            <button id="poi-add-btn" class="btn-modal-action-primary">A√±adir a Ruta</button>
            <button id="poi-save-btn" class="btn-modal-favorite">Guardar POI</button>
            <button id="poi-share-btn" class="btn-modal-action-primary">Compartir</button>
        `;
        if (existingWaypoint) {
            buttonsHtml += `<button id="poi-delete-btn" class="btn-modal-danger" data-waypoint-id="${existingWaypoint.id}">Eliminar Etapa</button>`;
        } else {
             buttonsHtml += `<button id="poi-close-btn" class="btn-modal-action-secondary">Cerrar <span class="button-countdown-timer"></span></button>`;
        }
        
        overlay.querySelector('.poi-modal-content').innerHTML = `
            <div class="poi-modal-header" style="background-image: url('${imageUrl}');">
                <h3 class="poi-modal-title">${name}</h3>
                <p class="poi-modal-address">${address}</p>
            </div>
            <div class="ocm-modal-tabs">
                <div class="ocm-modal-tab active" data-panel="details">DETALLES</div>
                <div class="ocm-modal-tab" data-panel="photos">FOTOS</div>
                <div class="ocm-modal-tab" data-panel="comments">OPINIONES</div>
            </div>
            <div class="poi-modal-body">
                <div id="poi-panel-details" class="ocm-modal-panel active">${detailsHtml}</div>
                <div id="poi-panel-photos" class="ocm-modal-panel">${photosHtml}</div>
                <div id="poi-panel-comments" class="ocm-modal-panel">${commentsHtml}</div>
            </div>
            <div class="poi-modal-footer">${buttonsHtml}</div>
        `;
        
        const closeHandler = () => {
            clearModalAutoCloseTimer(overlay, overlay.querySelector('#poi-close-btn, #poi-delete-btn'), 'poi-modal');
            if (overlay.parentNode) overlay.remove();
        };

        const closeBtn = overlay.querySelector('#poi-close-btn');
        if (closeBtn) closeBtn.addEventListener('click', closeHandler);
        
        overlay.querySelector('#poi-add-btn').addEventListener('click', async () => {
            const snapped = await snapCoordsToRoad(lat, lng);
            addWaypoint({ lat: snapped.lat, lng: snapped.lng }, address);
            closeHandler();
        });

        overlay.querySelector('#poi-save-btn').addEventListener('click', () => {
             const waypointForSave = { lat: lat, lng: lng, address: saveName, id: Date.now() };
             showSaveRoutePromptForSingleWaypoint(waypointForSave);
             closeHandler();
        });

        overlay.querySelector('#poi-share-btn').addEventListener('click', () => {
            handleSendToTeslaClick(lat, lng, name);
            closeHandler();
        });
        
        overlay.querySelectorAll('.ocm-modal-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                overlay.querySelectorAll('.ocm-modal-tab, .ocm-modal-panel').forEach(el => el.classList.remove('active'));
                tab.classList.add('active');
                overlay.querySelector(`#poi-panel-${tab.dataset.panel}`).classList.add('active');
            });
        });

        overlay.querySelectorAll('.ocm-photo-grid img').forEach(img => {
            img.addEventListener('click', () => showPhotoModal(img.dataset.fullUrl));
        });

        const deleteBtn = overlay.querySelector('#poi-delete-btn');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', () => {
                handleDeleteWaypointClick(parseInt(deleteBtn.dataset.waypointId));
                closeHandler();
            });
        }
        addModalAutoCloseTimer(overlay, overlay.querySelector('#poi-close-btn, #poi-delete-btn'), 'poi-modal', 45000);

    } catch (error) {
        console.error("Error al mostrar el modal del POI:", error);
        showToast("Error al mostrar informaci√≥n del POI.", 'error');
        if (overlay.parentNode) overlay.remove();
    }
}    
    

// ===================================================================
// NOMBRE: toggleRadaresRuta 
// RESUMEN: Solo limpia los radares din√°micos si se activa el check Y hay una ruta cargada.
async function toggleRadaresRuta(activo) {
    localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(activo));
    markCacheAsDirty();

    radaresEnRutaActual = [];

    const hasRoute = navigationMapInstance && 
                     navigationMapInstance.getSource('route') && 
                     navigationMapInstance.getSource('route')._data &&
                     navigationMapInstance.getSource('route')._data.geometry &&
                     navigationMapInstance.getSource('route')._data.geometry.coordinates.length > 1;

    if (activo) {
        if (hasRoute) {
            let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
            const originalLength = reminders.length;
            reminders = reminders.filter(r => !r.isDynamicRadar);
            if (reminders.length < originalLength) {
                localStorage.setItem('reminders', JSON.stringify(reminders));
                isCacheDirty = true; 
            }

            try {
                if (!window.radarsCache) await initializeRadarCache();
                if (!window.radarsCache) throw new Error("Base de datos de radares no disponible.");

                const routeLineString = turf.lineString(navigationMapInstance.getSource('route')._data.geometry.coordinates);
                
                processedRemindersCache.forEach(reminder => {
                    const isRadarType = (reminder.text.toUpperCase().includes("RADAR") || reminder.excludeFromList);
                    if (isRadarType && reminder.isLocationEnabled && reminder.locationCoordinates) {
                        const radarPoint = turf.point([reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]);
                        const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, radarPoint, { units: 'meters' });

                        if (nearestPointOnRoute.properties.dist <= RUTA_RADAR_PROXIMITY_THRESHOLD) {
                            radaresEnRutaActual.push({
                                ...reminder, isFromRuta: true, distanceOnRoute: nearestPointOnRoute.properties.location
                            });
                        }
                    }
                });

                const intersectingCells = new Set();
                const routeCoords = routeLineString.geometry.coordinates;
                for (let i = 0; i < routeCoords.length; i++) {
                    intersectingCells.add(getGridCellId(routeCoords[i][1], routeCoords[i][0]));
                }
                const cellsToSearch = new Set(intersectingCells);
                intersectingCells.forEach(cellId => {
                    const [_, latIdx, lonIdx] = cellId.split('_').map(Number);
                    for (let i = -1; i <= 1; i++) { for (let j = -1; j <= 1; j++) { cellsToSearch.add(`cell_${latIdx + i}_${lonIdx + j}`); } }
                });

                const candidateRadars = [];
                cellsToSearch.forEach(cellId => { if (window.radarsSpatialIndex[cellId]) candidateRadars.push(...window.radarsSpatialIndex[cellId]); });
                const uniqueCandidates = [...new Set(candidateRadars)];

                const savedRadius = parseInt(localStorage.getItem('boardinggate_dynamicRadarRadius'), 10);
                const radiusToUse = (savedRadius && savedRadius > 0) ? savedRadius : 400;
                
                uniqueCandidates.forEach(radar => {
                    const radarPoint = turf.point([radar.lon, radar.lat]);
                    const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, radarPoint, { units: 'meters' });

                    if (nearestPointOnRoute.properties.dist <= RUTA_RADAR_PROXIMITY_THRESHOLD) {
                        const radarYaExiste = radaresEnRutaActual.some(rem => 
                            rem.locationCoordinates &&
                            Math.abs(rem.locationCoordinates.latitude - radar.lat) < COORD_EPSILON &&
                            Math.abs(rem.locationCoordinates.longitude - radar.lon) < COORD_EPSILON
                        );
                        if (!radarYaExiste) {
                            const now = new Date();
                            const radarData = {
                                id: Date.now() + Math.random() + radaresEnRutaActual.length,
                                text: `<b>RADAR RUTA: ${radar.name}</b>`, type: 'simple', time: '00:01',
                                date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                                createdAt: now.toISOString(), managedByUser: false, isLocationEnabled: true,
                                locationCoordinates: { latitude: radar.lat, longitude: radar.lon },
                                radiusMeters: radiusToUse, excludeFromList: true, isFromRuta: true,
                                distanceOnRoute: nearestPointOnRoute.properties.location
                            };
                            radaresEnRutaActual.push(radarData);
                        }
                    }
                });
            } catch (error) {
                showToast(`Error al procesar radares en ruta: ${error.message}`, "error");
            }
        } else {
            console.log("[Radar Logic] 'Radares Ruta' activado, pero no hay ruta. Se recordar√° la preferencia.");
        }
        
    } else {
        
        await updateDynamicRadars(true); 
    }
    
    actualizarYOrdenarEventosEnRuta();
    plotRemindersOnNavigationMap(); 
}
    
// ===================================================================
// NOMBRE: toggleTareasRuta 
// ===================================================================
async function toggleTareasRuta(activo) {
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(activo));
    
    tareasEnRutaActual = [];

    if (activo) {
        const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
        if (actualWaypoints.length < 2) {
            actualizarYOrdenarEventosEnRuta();
            plotRemindersOnNavigationMap(); // Aseguramos que se limpie el mapa si no hay ruta
            return;
        }

        if (navigationMapInstance) {
            const routeSource = navigationMapInstance.getSource('route');
            if (!routeSource || !routeSource._data || !routeSource._data.geometry || routeSource._data.geometry.coordinates.length < 2) {
                if (activo) showToast("Geometr√≠a de ruta no disponible para buscar tareas.", "warning");
                actualizarYOrdenarEventosEnRuta();
                plotRemindersOnNavigationMap();
                return;
            }

            try {
                const routeLineString = turf.lineString(routeSource._data.geometry.coordinates);
                const locationReminders = processedRemindersCache.filter(r => {
                    if (!r.isLocationEnabled || !r.locationCoordinates) return false;
                    const isRadarType = r.text.toUpperCase().includes("RADAR") || r.excludeFromList;
                    return !isRadarType;
                });
            
                locationReminders.forEach(reminder => {
                    const taskPoint = turf.point([reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]);
                    const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, taskPoint, { units: 'meters' });
                    const radius = reminder.radiusMeters || DEFAULT_LOCATION_RADIUS;
                    
                    if (nearestPointOnRoute && nearestPointOnRoute.properties.dist !== undefined && nearestPointOnRoute.properties.dist <= radius) {
                        const taskData = { ...reminder, isFromTarea: true, distanceOnRoute: nearestPointOnRoute.properties.location };
                        tareasEnRutaActual.push(taskData);
                    }
                });
            } catch (error) {
                 showToast("Error al procesar tareas en ruta: " + error.message, "error");
            }
        }
    }

    actualizarYOrdenarEventosEnRuta();
    plotRemindersOnNavigationMap();
}   
    
// ===================================================================
// NOMBRE: actualizarYOrdenarEventosEnRuta
// RESUMEN: Unifica los arrays de radares y tareas en una sola lista,
function actualizarYOrdenarEventosEnRuta() {
    eventosEnRuta = [];
    proximoEventoEnRutaIndex = 0;
    
    const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresCheckbox && radaresCheckbox.checked) {
        radaresEnRutaActual.forEach(radar => {
            eventosEnRuta.push({ ...radar, tipoEvento: 'radar' });
        });
    }

    const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasCheckbox && tareasCheckbox.checked) {
        tareasEnRutaActual.forEach(tarea => {
            eventosEnRuta.push({ ...tarea, tipoEvento: 'task' });
        });
    }

    eventosEnRuta.sort((a, b) => a.distanceOnRoute - b.distanceOnRoute);
    
    actualizarContadorRadares(radaresCheckbox && radaresCheckbox.checked ? radaresEnRutaActual.length : 0);
    actualizarContadorTareas(tareasCheckbox && tareasCheckbox.checked ? tareasEnRutaActual.length : 0);
    
    drawStaticMarkersOnProgressBar();
    
}    

// ===================================================================
// NOMBRE: checkReminders (VERSI√ìN FINAL Y DEFINITIVA)
// RESUMEN: L√≥gica central para verificar recordatorios y radares.
async function checkReminders() {
    if (reminderCheckIntervalId) {
        clearInterval(reminderCheckIntervalId);
        reminderCheckIntervalId = null;
    }

    const now = Date.now();
 
    if (isCacheDirty) {
        rebuildProcessedRemindersCache();
        updateReminderCount();
        updateButtonStyles();
    }
    
    const overdueReminders = [];
    let coords = navigationCurrentLocation;
    if (!coords && processedRemindersCache.some(r => r.isLocationEnabled)) {
        coords = await getCurrentLocationAsync().catch(() => null);
    }

    const DYNAMIC_RADAR_REFRESH_INTERVAL = 30 * 60 * 1000; // 30 minutos

    if (!isNavigating && coords && (now - lastDynamicRadarCheck > DYNAMIC_RADAR_REFRESH_INTERVAL)) {
        updateDynamicRadars(false); 
    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
    let isNearActiveLocationPoint = false;
    let hasPendingOverdueEvents = false;

    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    const isRadaresRutaFeatureActive = radaresRutaCheckbox && radaresRutaCheckbox.checked;

    processedRemindersCache.forEach(reminder => {
        if (reminder.managedByUser) return; // Si el usuario ya ha gestionado este recordatorio, lo ignoramos

        const timeConditionMet = reminder.dueTimeUTC && reminder.dueTimeUTC <= now;
        const isRadarType = reminder.text.toUpperCase().includes("RADAR") || reminder.excludeFromList === true;

        if (isRadarType) {
            if (isNavigating && isRadaresRutaFeatureActive) {
                return; 
            }
        }
    
        let locationConditionMet = false;
        if (reminder.isLocationEnabled && reminder.locationCoordinates && coords) {
            const distance = calculateDistance(coords.latitude, coords.longitude, reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude);
            const radius = reminder.radiusMeters || DEFAULT_LOCATION_RADIUS;
            const VIGILANCE_BUFFER = 500; // 500 metros de pre-aviso para activar el modo de chequeo r√°pido

            if (timeConditionMet && distance <= radius + VIGILANCE_BUFFER) {
                isNearActiveLocationPoint = true;
            }

            if (distance <= radius) {
                locationConditionMet = true;
            }
        }
        
        let shouldNotifyNow = false;
        if (reminder.isLocationEnabled) {
            if (timeConditionMet && locationConditionMet) shouldNotifyNow = true;
        } else {
            if (timeConditionMet) {
                shouldNotifyNow = true;
                hasPendingOverdueEvents = true; // Para ajustar el intervalo
            }
        }

        if (shouldNotifyNow) {
            overdueReminders.push(reminder);
        }
    });
    
    if (overdueReminders.length > 0) {
        displayUnifiedReminderWindow(overdueReminders);
    } else if (isUnifiedWindowVisibleByLogic) {
        hideUnifiedReminderWindow();
    }
    
    let newInterval;
    let reason = "";
    
    if (isNavigating) {
        newInterval = 20000; // Chequear cada 20 segundos si estamos navegando
        reason = "Navegaci√≥n activa";
    } else if (hasPendingOverdueEvents) {
        newInterval = 1500; // Chequear m√°s frecuentemente si hay eventos de tiempo vencidos
        reason = "MODO ALERTA (hay eventos DE TIEMPO vencidos)";
    } else if (isNearActiveLocationPoint) {
        newInterval = 1500; // Chequear m√°s frecuentemente si estamos cerca de un punto de ubicaci√≥n activo
        reason = "MODO PROXIMIDAD (cerca de un punto ACTIVO)";
    } else {
        // En modo "eficiente", recalcular el pr√≥ximo "horizonte de eventos"
        recalculateNextEventHorizon();
        const timeToWake = nextEventHorizon.timestamp - now;
        // El intervalo m√≠nimo es 3 segundos, m√°ximo 30 segundos, o la mitad del tiempo hasta el pr√≥ximo evento
        newInterval = timeToWake <= 0 ? 3000 : Math.max(3000, Math.min(30000, timeToWake / 2));
        reason = `MODO EFICIENTE (pr√≥ximo despertar en ${Math.round(timeToWake/1000)}s)`;
    }
    
    const secondsToNextCheck = newInterval / 1000;
    console.log(`%c[INTERVALO] Pr√≥ximo chequeo en ${secondsToNextCheck} segundos. Raz√≥n: ${reason}.`, 'color: #BA55D3;');
    
    reminderCheckIntervalId = setInterval(checkReminders, newInterval);
}
    
// ===================================================================
// NOMBRE: recalculateNextEventHorizon 
// ===================================================================
function recalculateNextEventHorizon() {
    const now = Date.now();
    let nextTemporalEvent = { timestamp: Infinity, id: null, text: 'Ninguno' };
    let nextLocationEvent = { timestamp: Infinity, id: null, text: 'Ninguno' };
    
    processedRemindersCache.forEach(reminder => {
        if (!reminder.managedByUser && reminder.dueTimeUTC && reminder.dueTimeUTC > now && reminder.dueTimeUTC < nextTemporalEvent.timestamp) {
            nextTemporalEvent = { timestamp: reminder.dueTimeUTC, id: reminder.id, text: reminder.text };
        }
    });

    const coords = navigationCurrentLocation;
    if (coords) {
        const candidateReminders = new Set();
        const centerCellId = getGridCellId(coords.latitude, coords.longitude);
        const [_, centerLatIndex, centerLonIndex] = centerCellId.split('_').map(Number);
        for (let i = -1; i <= 1; i++) { for (let j = -1; j <= 1; j++) { const cellId = `cell_${centerLatIndex + i}_${centerLonIndex + j}`; if (remindersSpatialIndex[cellId]) { remindersSpatialIndex[cellId].forEach(r => candidateReminders.add(r)); } } }
        let closestVigia = { distance: Infinity, reminder: null };
        candidateReminders.forEach(reminder => {
            if (!reminder.managedByUser && reminder.isLocationEnabled && reminder.locationCoordinates && reminder.dueTimeUTC <= now) {
                const distance = calculateDistance(coords.latitude, coords.longitude, reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude);
                if (distance < closestVigia.distance) { closestVigia = { distance: distance, reminder: reminder }; }
            }
        });

        if (closestVigia.reminder) {
            let speedKmh;
            if (isNavigating || isFreeDriveActive) {
                const tripDurationMinutes = navigationStartTimeForStats ? (now - navigationStartTimeForStats.getTime()) / 60000 : 0;
                if (tripDurationMinutes < 5) {
                    speedKmh = 90; 
                } else {
                    const MINIMUM_AVERAGE_SPEED_FOR_CALC = 60;
                    speedKmh = Math.max(window.averageSpeedKmh, MINIMUM_AVERAGE_SPEED_FOR_CALC);
                }
            } else {
                speedKmh = (window.currentSpeedKmh || 0) > 10 ? window.currentSpeedKmh : 90;
            }
            
            const speedMps = speedKmh * 1000 / 3600;
            const distanceToActivationZone = Math.max(0, closestVigia.distance - (closestVigia.reminder.radiusMeters || DEFAULT_LOCATION_RADIUS));
            const etaSeconds = speedMps > 0 ? distanceToActivationZone / speedMps : Infinity;
            const MARGEN_SEGURIDAD_MS = 60 * 1000; 
            const wakeUpTimestamp = now + (etaSeconds * 1000) - MARGEN_SEGURIDAD_MS;
            
            nextLocationEvent = {
                timestamp: Math.max(now, wakeUpTimestamp),
                id: closestVigia.reminder.id,
                text: closestVigia.reminder.text
            };
        }
    }

    if (nextTemporalEvent.timestamp < nextLocationEvent.timestamp) {
        nextEventHorizon = { timestamp: nextTemporalEvent.timestamp, type: 'time', targetId: nextTemporalEvent.id };
        const secondsToWake = Math.round((nextEventHorizon.timestamp - now) / 1000);
        const eventText = nextTemporalEvent.text.replace(/<[^>]*>/g, '').substring(0, 50);
        console.log(`[HORIZONTE] Pr√≥ximo evento: TIEMPO. Despertar en ${secondsToWake}s para: "${eventText}"`);
    } else if (nextLocationEvent.id) {
        nextEventHorizon = { timestamp: nextLocationEvent.timestamp, type: 'location', targetId: nextLocationEvent.id };
        const secondsToWake = Math.round((nextEventHorizon.timestamp - now) / 1000);
        const eventText = nextLocationEvent.text.replace(/<[^>]*>/g, '').substring(0, 50);
        console.log(`[HORIZONTE] Pr√≥ximo evento: UBICACION. Despertar en ${secondsToWake}s para: "${eventText}"`);
    } else {
        nextEventHorizon = { timestamp: Infinity, type: null, targetId: null };
    }
}
    
// ===================================================================
// NOMBRE: rebuildProcessedRemindersCache 
// RESUMEN: Parsea las fechas y horas en la zona horaria local del navegador,
function rebuildProcessedRemindersCache() {
    try {
        const allReminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        
        processedRemindersCache = [];
        remindersSpatialIndex = {};
        nonLocationRemindersCache = [];

        allReminders.forEach(reminder => {
            let dueTimeUTC = null;
            if (reminder.date && reminder.time) {
                try {
                    const [year, month, day] = reminder.date.split('-').map(Number);
                    const [hour, minute] = reminder.time.split(':').map(Number);
                    
                    const dueDate = new Date(year, month - 1, day, hour, minute);
                 
                    if (!isNaN(dueDate.getTime())) {
                        dueTimeUTC = dueDate.getTime(); }
                } catch (e) {
                    console.warn(`Fecha/hora inv√°lida para recordatorio ID ${reminder.id}:`, reminder.date, reminder.time);
                }
            }

            const processedReminder = { ...reminder, dueTimeUTC: dueTimeUTC };
            processedRemindersCache.push(processedReminder);

            if (processedReminder.isLocationEnabled && processedReminder.locationCoordinates) {
                const { latitude, longitude } = processedReminder.locationCoordinates;
                if (typeof latitude === 'number' && typeof longitude === 'number') {
                    const cellId = getGridCellId(latitude, longitude);
                    if (!remindersSpatialIndex[cellId]) {
                        remindersSpatialIndex[cellId] = [];
                    }
                    remindersSpatialIndex[cellId].push(processedReminder);
                }
            } else {
                nonLocationRemindersCache.push(processedReminder);
            }
        });

        isCacheDirty = false;
        console.log(`[CACHE] Cach√© reconstruida: ${processedRemindersCache.length} en total, ${nonLocationRemindersCache.length} solo de tiempo, ${Object.keys(remindersSpatialIndex).length} celdas espaciales.`);
        
        recalculateNextEventHorizon();
        
    } catch (e) {
        console.error("Error al reconstruir la cach√© de recordatorios:", e);
        processedRemindersCache = [];
        remindersSpatialIndex = {};
        nonLocationRemindersCache = [];
    }
}
    
//===================================================================
// NOMBRE: startDeviationChecker 
// RESUMEN: Inicia un ciclo de comprobaci√≥n de desv√≠o con intervalo adaptativo.
// ===================================================================
function startDeviationChecker() {
    stopDeviationChecker(); // Limpia cualquier ciclo anterior

    const NORMAL_CHECK_INTERVAL_MS = 5000;
    const HIGH_ALERT_INTERVAL_MS = 500;
    const HIGH_ALERT_DURATION_MS = 5000;
    const WARNING_THRESHOLD_METERS = 9; // Nuevo umbral de "sospecha"

    const runDeviationCheck = () => {
        const MIN_DISTANCE_FOR_DEVIATION_CHECK = 200;
        if (totalDistanceTravelledForStats < MIN_DISTANCE_FOR_DEVIATION_CHECK || isArrivalSequenceStarted || Date.now() < deviationCheckGracePeriodUntil || !isNavigating || !navigationCurrentLocation || isRecalculatingRoute || isDeviationModalActive || isAddReminderAtLocationModeActive) {
            if (isHighAlertMode) { // Si estamos en alerta y una de estas condiciones se cumple, cancelamos la alerta.
                clearTimeout(highAlertTimeoutId);
                isHighAlertMode = false;
            }
            deviationCheckTimerId = setTimeout(runDeviationCheck, NORMAL_CHECK_INTERVAL_MS); // Reintentar en 5s
            return;
        }

        const route = navigationCurrentRouteData?.routes?.[0];
        if (!route || !route.legs || !route.legs[currentLegIndexNav] || !route.legs[currentLegIndexNav].steps[currentStepIndexNav] || typeof turf === 'undefined') {
            deviationCheckTimerId = setTimeout(runDeviationCheck, NORMAL_CHECK_INTERVAL_MS); // Reintentar en 5s
            return;
        }
        
        let distanceToRoute = 0;
        try {
            const carPoint = turf.point([navigationCurrentLocation.longitude, navigationCurrentLocation.latitude]);
            const searchWindowCoords = [];
            const stepsToInclude = 5;
            let legIdx = currentLegIndexNav, stepIdx = currentStepIndexNav;
            for (let i = 0; i < stepsToInclude && legIdx < route.legs.length; i++) {
                const currentLeg = route.legs[legIdx];
                if (stepIdx < currentLeg.steps.length) {
                    const currentStep = currentLeg.steps[stepIdx];
                    if (currentStep.geometry?.coordinates) {
                        searchWindowCoords.push(...(searchWindowCoords.length > 0 ? currentStep.geometry.coordinates.slice(1) : currentStep.geometry.coordinates));
                    }
                    stepIdx++;
                } else {
                    legIdx++;
                    stepIdx = 0;
                    i--; 
                }
            }
            if (searchWindowCoords.length > 1) {
                distanceToRoute = turf.pointToLineDistance(carPoint, turf.lineString(searchWindowCoords), { units: 'meters' });
            }
        } catch (e) {
             distanceToRoute = DEVIATION_THRESHOLD_METERS + 1;
        }

        if (distanceToRoute > DEVIATION_THRESHOLD_METERS) {
            showDeviationModal();
            stopDeviationChecker(); // Detiene todos los temporizadores asociados a esta funci√≥n.
            return;

        } else if (distanceToRoute > WARNING_THRESHOLD_METERS) {
            if (!isHighAlertMode) {
                isHighAlertMode = true;
                
                highAlertTimeoutId = setTimeout(() => {
                    isHighAlertMode = false;
                    highAlertTimeoutId = null;
                    if (deviationCheckTimerId) clearTimeout(deviationCheckTimerId);
                    deviationCheckTimerId = setTimeout(runDeviationCheck, NORMAL_CHECK_INTERVAL_MS);
                }, HIGH_ALERT_DURATION_MS);
            }
            deviationCheckTimerId = setTimeout(runDeviationCheck, HIGH_ALERT_INTERVAL_MS);

        } else {
            if (isHighAlertMode) {
                clearTimeout(highAlertTimeoutId);
                highAlertTimeoutId = null;
                isHighAlertMode = false;
            }
            deviationCheckTimerId = setTimeout(runDeviationCheck, NORMAL_CHECK_INTERVAL_MS);
        }
    };
    runDeviationCheck();
}

// ===================================================================
// NOMBRE: stopDeviationChecker (MODIFICADA PARA MODO ADAPTATIVO)
// RESUMEN: Detiene todos los temporizadores de comprobaci√≥n de desv√≠o.
function stopDeviationChecker() {
    if (deviationCheckTimerId) {
        clearTimeout(deviationCheckTimerId); 
        deviationCheckTimerId = null;
    }
    if (highAlertTimeoutId) {
        clearTimeout(highAlertTimeoutId);
        highAlertTimeoutId = null;
    }
    isHighAlertMode = false;
    deviationStartTime = 0; // Se mantiene por compatibilidad, aunque la l√≥gica ya no lo usa.
}
        
// ===================================================================
// NOMBRE: saveCustomData 
// RESUMEN: Guarda la personalizaci√≥n y marca la cach√© de recordatorios como sucia.
function saveCustomData() {
    try {
        if (customData.bookmarks) {
            Object.keys(customData.bookmarks).forEach(indexKey => {
                const index = parseInt(indexKey);
                const custom = customData.bookmarks[index];
                const original = index < originalBookmarks.length ? originalBookmarks[index] : null;
                const bookmarksAreEqual = (b1, b2) => {
                    if (b1 === null && b2 === null) return true;
                    if (b1 === null || b2 === null) return false;
                    return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null);
                };
                if (bookmarksAreEqual(custom, original)) {
                    delete customData.bookmarks[index];
                }
            });
            if (Object.keys(customData.bookmarks).length === 0) {
                delete customData.bookmarks;
            }
        }
        if (customData.toggles) {
            Object.keys(customData.toggles).forEach(startKey => {
                const customToggle = customData.toggles[startKey];
                const originalRange = originalToggleRanges.find(r => r.start == startKey);
                if (customToggle && customToggle.assignedIndexes && originalRange) {
                    const originalDefaultIndexes = [];
                    for (let i = originalRange.start; i <= originalRange.end; i++) {
                        originalDefaultIndexes.push(i);
                    }
                    if (customToggle.assignedIndexes.length === originalDefaultIndexes.length &&
                        customToggle.assignedIndexes.every((val, idx) => val === originalDefaultIndexes[idx])) {
                        delete customToggle.assignedIndexes;
                    }
                }
                if (customToggle && originalRange && customToggle.label === originalRange.label) {
                    delete customToggle.label;
                }
                if (customData.toggles[startKey] && Object.keys(customData.toggles[startKey]).length === 0) {
                    delete customData.toggles[startKey];
                }
            });
            if (Object.keys(customData.toggles).length === 0) {
                delete customData.toggles;
            }
        }
        localStorage.setItem('customGridData', JSON.stringify(customData));
        markCacheAsDirty(); 
    } catch (e) {
        showToast("Error al guardar personalizaci√≥n", "error");
    }
}

// ===================================================================
// NOMBRE: showIntersectionPreviewMap 
// RESUMEN: Muestra y actualiza el minimapa existente en lugar de crearlo de nuevo.
function showIntersectionPreviewMap(step, route, isSimulationContextOrClick = false, timerDurationMs = null) {
    const savedMinimapPref = localStorage.getItem(MAP_VIEW_SHOW_MINIMAP_KEY);
    const showMinimapPreference = savedMinimapPref === null ? true : JSON.parse(savedMinimapPref);

    if (!intersectionPreviewMap || !showMinimapPreference) {
        hideIntersectionPreviewMap();
        return;
    }
  
    const previewWindow = document.getElementById('intersection-preview-map-window');
    if (!previewWindow || !step || !step.geometry || !route || !navigationMapInstance) {
        hideIntersectionPreviewMap();
        return;
    }
    
    const progressBarEl = document.getElementById('navigation-bottom-progress-bar');
    const isProgressBarVisible = progressBarEl && progressBarEl.offsetParent !== null;

    if (isProgressBarVisible) {
        const progressBarRect = progressBarEl.getBoundingClientRect();
        previewWindow.style.width = `${progressBarEl.offsetWidth}px`;
        previewWindow.style.top = '5px';
        previewWindow.style.left = '5px';
        previewWindow.style.bottom = 'auto';
        previewWindow.style.transform = 'none';
    } else if (isSimulationContextOrClick) {
        previewWindow.style.width = '90%'; previewWindow.style.maxWidth = '500px';
        previewWindow.style.left = '50%'; previewWindow.style.top = '50%';
        previewWindow.style.transform = 'translate(-50%, -50%)';
    } else {
        hideIntersectionPreviewMap();
        return;
    }
    
    previewWindow.classList.remove('hidden');
    previewWindow.dataset.source = isSimulationContextOrClick ? 'click' : 'auto';
    if (intersectionPreviewTimer) clearTimeout(intersectionPreviewTimer);

    try {
       if (intersectionPreviewMap.isMoving()) {
            intersectionPreviewMap.stop();
        }

        const fullRouteLineString = turf.lineString(route.geometry.coordinates);
        const maneuverPointOnRoute = turf.nearestPointOnLine(fullRouteLineString, step.maneuver.location, { units: 'kilometers' });
        const maneuverDistanceKm = maneuverPointOnRoute.properties.location;
        const startSliceDistanceKm = Math.max(0, maneuverDistanceKm - (75 / 1000));
        const endSliceDistanceKm = Math.min(turf.length(fullRouteLineString), maneuverDistanceKm + (90 / 1000));
        const startSlicePoint = turf.along(fullRouteLineString, startSliceDistanceKm);
        const endSlicePoint = turf.along(fullRouteLineString, endSliceDistanceKm);
        const routeSlice = turf.lineSlice(startSlicePoint, endSlicePoint, fullRouteLineString);
        
        const bounds = new mapboxgl.LngLatBounds();
        routeSlice.geometry.coordinates.forEach(coord => bounds.extend(coord));
        const lookAheadPointTurf = turf.along(routeSlice, Math.min(5, turf.length(routeSlice, {units: 'meters'})), { units: 'meters' });
        const segmentBearing = turf.bearing(startSlicePoint, lookAheadPointTurf);

        if (intersectionPreviewMap.getSource('intersection-route')) {
            intersectionPreviewMap.getSource('intersection-route').setData(routeSlice.geometry);
        }

        const carPositionPointTurf = turf.along(routeSlice, 30, { units: 'meters' });
        intersectionPreviewCarMarker.setLngLat(carPositionPointTurf.geometry.coordinates);

        const maneuver = step.maneuver;
        const iconFilename = getManeuverIconFilename(maneuver);
        const maneuverPointTurf = turf.point(step.maneuver.location);
        const lineStringToManeuver = turf.lineSlice(turf.point(routeSlice.geometry.coordinates[0]), maneuverPointTurf, routeSlice);
        const iconPositionPointTurf = turf.along(routeSlice, Math.max(0, turf.length(lineStringToManeuver, { units: 'meters' }) - 15), { units: 'meters' });
        
        intersectionPreviewManeuverMarker.getElement().style.backgroundImage = `url('https://boardinggate.github.io/Tesla/${iconFilename}')`;
        intersectionPreviewManeuverMarker.setLngLat(iconPositionPointTurf.geometry.coordinates);
        
        requestAnimationFrame(() => {
            if (intersectionPreviewMap) {
                intersectionPreviewMap.resize();
                intersectionPreviewMap.fitBounds(bounds, {
                    padding: 25, maxZoom: 19, bearing: segmentBearing, pitch: 50, duration: 800 // Animaci√≥n suave
                });
            }
        });

        if (timerDurationMs && timerDurationMs > 0) {
            intersectionPreviewTimer = setTimeout(hideIntersectionPreviewMap, timerDurationMs);
        }
    } catch (error) {
        console.error("Error al actualizar el minimapa de intersecci√≥n:", error);
        hideIntersectionPreviewMap();
    }
}

// ===================================================================
// NOMBRE: hideIntersectionPreviewMap 
// RESUMEN: Solo oculta el contenedor, no destruye el mapa.
function hideIntersectionPreviewMap() {
    const card = document.getElementById('intersection-preview-map-window');
    if (card) {
        card.classList.add('hidden');
    }
    if (intersectionPreviewTimer) {
        clearTimeout(intersectionPreviewTimer);
        intersectionPreviewTimer = null;
    }
    
    if (intersectionPreviewMap && intersectionPreviewMap.isStyleLoaded()) {
        try {
            if (intersectionPreviewMap.isMoving()) {
                intersectionPreviewMap.stop();
            }
            const source = intersectionPreviewMap.getSource('intersection-route');
            if (source) {
                source.setData({ type: 'Feature', geometry: { type: 'LineString', coordinates: [] } });
            }
        } catch(e) {
            console.warn("Error menor al limpiar el mapa de previsualizaci√≥n:", e);
        }
    }
}
    
// ===================================================================
// NOMBRE: showAllReminders 
// RESUMEN: Muestra la tabla y marca la cach√© como sucia si se cambia el filtro de excluidos.
function showAllReminders(options = {}) {
     const mapWasOpenBeforeThisTable = isNavigationMapActive;
     if (mapWasOpenBeforeThisTable) {
         sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
         sessionStorage.setItem('mapContext', 'navigation');
     } else {
         sessionStorage.removeItem('boardinggate_map_was_open_before_table');
         sessionStorage.removeItem('mapContext');
     }
     closeOtherModals();
     let allReminders = []; try { allReminders = JSON.parse(localStorage.getItem('reminders') || '[]').map(r => ({ ...r })); } catch(e) { showToast("Error al cargar lista de recordatorios.", "error"); return; }
     const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false; let remindersToDisplay = allReminders;
     if (!showExcluded) { remindersToDisplay = allReminders.filter(r => !r.excludeFromList); }
     remindersToDisplay.sort((a, b) => {
         const nowForSort = new Date(); const nextA = calculateNextOccurrence(a, nowForSort); const nextB = calculateNextOccurrence(b, nowForSort);
         if (nextA && nextB) { const timeDiff = nextA.getTime() - nextB.getTime(); if (timeDiff !== 0) return timeDiff; } else if (nextA) { return -1; } else if (nextB) { return 1; }
         const typeOrder = { 'simple': 1, 'hourly': 2, 'daily': 3, 'weekly': 4, 'interval': 5 }; const typeDiff = (typeOrder[a.type] ?? 99) - (typeOrder[b.type] ?? 99); if (typeDiff !== 0) return typeDiff;
         const createdAtA = a.createdAt ? new Date(a.createdAt).getTime() : 0; const createdAtB = b.createdAt ? new Date(b.createdAt).getTime() : 0; return createdAtA - createdAtB;
     });
     const existingModal = document.querySelector('.reminder-table-modal');
     if (existingModal) { if (existingModal.autoCloseInterval) clearInterval(existingModal.autoCloseInterval); if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal); }
     const modalTable = document.createElement('div');
     modalTable.className = 'reminder-table-modal';
     modalTable.setAttribute('aria-label', 'Tabla recordatorios');
     modalTable.innerHTML = `
        <div class="reminder-table-header">
            <div class="reminder-table-top-controls">
                <div style="display: flex; align-items: center;">
                    <input type="checkbox" id="show-excluded-reminders" ${showExcluded ? 'checked' : ''} style="transform: scale(1.3);">
                    <label for="show-excluded-reminders" style="margin-left: 0.5rem; font-size: 1.1rem;">MOSTRAR RADARES u OTROS</label>
                </div>
                <div style="display: flex; align-items: center;">
                    <button type="button" id="view-all-locations-map">VER UBICACIONES</button>
                    <button type="button" id="close-reminders-top" style="margin-left:10px;">SALIR <span class="button-countdown"></span></button>
                </div>
            </div>
            <h2>Recordatorios</h2>
        </div>
        <div class="reminder-table-body-container">
            <table>
                <thead>
                    <tr>
                        <th style="width:12%;">Acciones</th> <th>Texto</th> <th style="width:8%;">Hora</th>
                        <th style="width:10%;">Fecha Prox.</th> <th style="width:15%;">D√≠as Rep.</th>
                        <th style="width:8%;">Cada x d√≠as</th> <th style="width:8%;">Geoloc.</th>
                        <th style="width:10%;">Creado</th>
                    </tr>
                </thead>
                <tbody id="reminder-table-body">
                    ${remindersToDisplay.length === 0 ? `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios ${showExcluded ? ' (incluyendo excluidos)' : ''}.</td></tr>` : remindersToDisplay.map(r => { 
                        const isRadarOrExcluded = r.excludeFromList || r.text.toUpperCase().includes("RADAR");
                        const rowBackgroundColor = isRadarOrExcluded ? 'rgba(52, 199, 89, 0.15)' : 'rgba(88, 86, 214, 0.15)';
                        const nextOccurrenceDate = calculateNextOccurrence(r, new Date()); 
                        const formattedNextDate = nextOccurrenceDate ? formatDateToDDMMMYY(nextOccurrenceDate.toISOString().split('T')[0]) : formatDateToDDMMMYY(r.date); 
                        const timeDisplay = r.time ? r.time : '-'; 
                        const geoIndicator = r.isLocationEnabled ? '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#34c759" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>' : '-'; 
                        const isCyclic = r.type === 'weekly' || r.type === 'interval';
                        const cyclicStyle = isCyclic ? 'style="color: #ffd700; font-weight: bold;"' : '';
                        return `<tr data-id="${r.id}" style="background-color: ${rowBackgroundColor};"> <td> <button class="visto-prox" data-id="${r.id}" title="${isCyclic ? 'Marcar Visto y Avanzar al Pr√≥ximo Ciclo' : 'Marcar Visto y Borrar'}">Visto/Prox</button> <button class="postpone" data-id="${r.id}" title="Posponer">Posponer</button> ${isCyclic ? `<button class="cancel-cyclic-table" data-id="${r.id}" title="Anular Ciclo Permanente">Anular Ciclo</button>` : ''} </td> <td class="text-column" title="Modificar">${r.text}</td> <td class="time-column">${timeDisplay}</td> <td class="date-column">${formattedNextDate}</td> <td ${cyclicStyle}>${r.type === 'weekly' && r.repeatDays?.length > 0 ? r.repeatDays.map(d => ['Dom','Lun','Mar','Mi√©','Jue','Vie','S√°b'][d]).join(', ') : '-'}</td> <td ${cyclicStyle}>${r.type === 'interval' ? r.intervalDays || '-' : '-'}</td> <td>${geoIndicator}</td> <td class="date-column">${r.createdAt ? formatDateToDDMMMYY(r.createdAt.split('T')[0]) : '-'}</td> </tr>`; 
                    }).join('')}
                    </tbody>
                </table>
        </div>
        <div class="bottom-button-container" style="display:none;">
            <button type="button" id="close-reminders-bottom">SALIR <span class="button-countdown-timer unified-countdown-style"></span></button>
        </div>
        `;
         const parent = document.body;
         parent.appendChild(modalTable);
         const showExcludedCheckbox = modalTable.querySelector('#show-excluded-reminders');
         if (showExcludedCheckbox) { 
             showExcludedCheckbox.addEventListener('change', () => { 
                 localStorage.setItem(SHOW_EXCLUDED_REMINDERS_KEY, JSON.stringify(showExcludedCheckbox.checked)); 
                 markCacheAsDirty();
                 if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval); 
                 modalTable.remove(); 
                 showAllReminders(); 
            }); 
        }
         const viewLocationsMapButton = modalTable.querySelector('#view-all-locations-map');
         if (viewLocationsMapButton) {
            viewLocationsMapButton.addEventListener('click', () => {
                if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                if (modalTable.parentNode) modalTable.remove();
                setTimeout(() => {
                    openLocationsPreviewMap();
                }, 50);
            });
        }
         let count = 60; const countdownSpans = modalTable.querySelectorAll('.button-countdown'); countdownSpans.forEach(span => span.textContent = `${count}`);
         const closeClean = () => { clearInterval(modalTable.autoCloseInterval); modalTable.autoCloseInterval = null; if (modalTable.parentNode) modalTable.parentNode.removeChild(modalTable);
             const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true'; sessionStorage.removeItem('boardinggate_map_was_open_before_table');
             const mapContext = sessionStorage.getItem('mapContext'); sessionStorage.removeItem('mapContext');
             if (fromReminderModal) { fromReminderModal = false; if (mapShouldReopen) { sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true'); sessionStorage.setItem('mapContext', mapContext); } showReminderModal(); }
             else if (mapShouldReopen) { if (mapContext === 'navigation') openNavigationMap(); }
         };
         modalTable.autoCloseInterval = setInterval(() => { count--; countdownSpans.forEach(span => span.textContent = `(${count})`); if (count <= 0) { closeClean(); } }, 1000);
         const resetTimer = () => { if (!modalTable.autoCloseInterval) return; clearInterval(modalTable.autoCloseInterval); count = 60; countdownSpans.forEach(span => span.textContent = `${count}`); modalTable.autoCloseInterval = setInterval(() => { count--; countdownSpans.forEach(span => span.textContent = `${count}`); if (count <= 0) { closeClean(); } }, 1000); };
         modalTable.addEventListener('click', resetTimer); modalTable.addEventListener('touchstart', resetTimer, { passive: true }); modalTable.addEventListener('input', resetTimer);
         modalTable.querySelector('#close-reminders-top').addEventListener('click', closeClean);
         modalTable.querySelector('#close-reminders-bottom').addEventListener('click', closeClean);
         setupReminderTableListeners(modalTable);
}

// ===================================================================
// NOMBRE: setupReminderTableListeners 
// RESUMEN: A√±ade listeners y marca la cach√© como sucia en cada modificaci√≥n.
function setupReminderTableListeners(modalTable) {
        modalTable.querySelectorAll('.visto-prox').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#EF4444';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #B91C1C';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true);
                let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderIndex = rems.findIndex(r => r.id === id);
                let needsSave = false;
                const row = newButton.closest('tr');
                if (reminderIndex > -1 && row) {
                     const currentReminder = rems[reminderIndex];
                     if (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval')) {
                        const { newDateISO, newTime } = calculatePostponedDateTime(15);
                        rems[reminderIndex].date = newDateISO;
                        rems[reminderIndex].time = newTime;
                        rems[reminderIndex].managedByUser = false;
                        needsSave = true;
                        const dateCell = row.cells[3]; const timeCell = row.cells[2];
                        if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date);
                        if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                        showToast('Recordatorio con ubicaci√≥n pospuesto 15 min', 'info');
                    } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                         let referenceDateForNext = new Date();
                         try {
                             const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                             const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                             const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                             if (!isNaN(reminderDateTime.getTime())) {
                                 referenceDateForNext = new Date(reminderDateTime.getTime() + 60000);
                             }
                         } catch(er) { }
                        const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                        if (nextOcc) {
                            rems[reminderIndex].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                            rems[reminderIndex].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                            rems[reminderIndex].managedByUser = false;
                            needsSave = true;
                            const dateCell = row.cells[3]; const timeCell = row.cells[2];
                            if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date);
                            if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                            showToast('Actualizado al pr√≥ximo periodo', 'info');
                        } else {
                            rems.splice(reminderIndex, 1); needsSave = true;
                            row.remove(); showToast('Error calculando siguiente ciclo. Eliminado.', 'error');
                        }
                    } else {
                        rems.splice(reminderIndex, 1); needsSave = true;
                        row.remove(); showToast('Recordatorio borrado', 'info');
                    }
                    if (needsSave) {
                        localStorage.setItem('reminders', JSON.stringify(rems)); 
                        markCacheAsDirty();
                        if (isNavigationMapActive) { plotRemindersOnNavigationMap(); } // <-- CORRECCI√ìN
                    }
                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios.</td></tr>`;
                    }
                } else {
                    showToast('Error: Recordatorio no encontrado para actualizar/borrar.', 'error');
                    if(row) row.remove();
                }
                updateReminderCount(); updateButtonStyles(); markCacheAsDirty();
            });
        });
        modalTable.querySelectorAll('.postpone').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#F59E0B';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #B45309';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true);
                const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderToPostpone = reminders.find(r => r.id === id);
                if (reminderToPostpone) {
                    if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                    modalTable.remove();
                    showPostponeOptionsModal(reminderToPostpone, 'table');
                } else {
                    showToast('Error: Recordatorio no encontrado para posponer.', 'error');
                    markReminderAsManaged(id, false);
                }
            });
        });
        modalTable.querySelectorAll('.cancel-cyclic-table').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#8B0000';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #580000';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                if (confirm('¬øEst√°s seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE?')) {
                    markReminderAsManaged(id, true);
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const initialLength = rems.length;
                    rems = rems.filter(r => r.id !== id);
                    if (rems.length < initialLength) {
                       localStorage.setItem('reminders', JSON.stringify(rems)); 
                       markCacheAsDirty();
                       if (isNavigationMapActive) { plotRemindersOnNavigationMap(); } // <-- CORRECCI√ìN
                       showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                    } else {
                        showToast('Error: No se encontr√≥ el ciclo para anular', 'warning');
                    }
                    const row = newButton.closest('tr');
                    if (row) row.remove();
                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios.</td></tr>`;
                    }
                    updateReminderCount(); updateButtonStyles();
                }
            });
        });
        const tableBody = modalTable.querySelector('#reminder-table-body');
        if (tableBody) {
            const newTableBody = tableBody.cloneNode(false);
            while(tableBody.firstChild) newTableBody.appendChild(tableBody.firstChild);
            tableBody.parentNode.replaceChild(newTableBody, tableBody);
            newTableBody.addEventListener('click', (e) => {
                if (e.target.closest('td:first-child button')) return;
               const row = e.target.closest('tr[data-id]');
                if (row?.dataset.id) {
                    const id = parseInt(row.dataset.id); if (isNaN(id)) return;
                    markReminderAsManaged(id, true);
                    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const reminderToModify = reminders.find(r => r.id === id);
                    if (reminderToModify) {
                        const mapWasOpenBeforeTable = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                        const mapContextBeforeTable = sessionStorage.getItem('mapContext');
                        if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                        modalTable.remove();
                        if (mapWasOpenBeforeTable) {
                            sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                            if (mapContextBeforeTable) {
                                sessionStorage.setItem('mapContext', mapContextBeforeTable);
                            }
                        }
                        sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                        showReminderModal(reminderToModify);
                    } else {
                        showToast('Error: Recordatorio no encontrado para modificar', 'error');
                        markReminderAsManaged(id, false);
                    }
                }
            });
        }
}

// ===================================================================
// NOMBRE: showReminderModal 
// RESUMEN: Muestra el modal de edici√≥n/creaci√≥n y marca la cach√© como sucia al guardar/borrar.
function showReminderModal(reminder = null, options = {}) {
    const mapShouldReopenAfterForm = sessionStorage.getItem('boardinggate_map_should_reopen_after_form') === 'true';
    const mapContextBeforeThisModal = sessionStorage.getItem('mapContext');
    closeOtherModals();
    let autoSaveInterval = null; let parseTimeout = null; let restartTimeout = null; let focusTimeout = null; let countdownSave = 25; let manualTimeInput = false; let lastInputWasSpeech = false;
    let currentReminderLocation = null;
    let locationEnabledByUser = false;
    let mapExpandedManually = false;
    let mapMoveDebounceTimer = null;

    function cleanUpModalTimers(clearAll = true) {
        if (autoSaveInterval) { clearInterval(autoSaveInterval); autoSaveInterval = null; }
        if (clearAll) {
            if (parseTimeout) clearTimeout(parseTimeout);
            if (restartTimeout) clearTimeout(restartTimeout);
            if (focusTimeout) clearTimeout(focusTimeout);
            parseTimeout = null; restartTimeout = null; focusTimeout = null;
        }
    }

    const existingModal = document.querySelector('.reminder-modal');
    if (existingModal) {
        if (typeof existingModal.cleanUpModalTimers === 'function') existingModal.cleanUpModalTimers(true);
        if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal);
    }
    
    let isNew = true;
    let parsed = {
         id: null, text: '', time: null, date: null, repeatDays: [], intervalDays: null, type: 'simple',
         createdAt: new Date().toISOString(), managedByUser: false,
         isLocationEnabled: false, locationCoordinates: null, radiusMeters: DEFAULT_LOCATION_RADIUS,
         excludeFromList: false
    };
    if (reminder && typeof reminder.id === 'number' && reminder.id !== null) {
        const remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
        const foundReminder = remindersFromStorage.find(r => r.id === reminder.id);
        if (foundReminder) {
            parsed = { ...foundReminder };
            isNew = false;
        } else {
            parsed = { ...reminder, id: null, createdAt: new Date().toISOString(), managedByUser: false };
            isNew = true;
            if(reminder.text && reminder.text.toUpperCase().includes("RADAR RUTA:")) {
                 parsed.text = reminder.text.replace("RADAR RUTA:", "RADAR:");
                 parsed.excludeFromList = true;
                 parsed.radiusMeters = 350;
            }
        }
    } else if (reminder) {
        parsed = { ...reminder, id: null, createdAt: new Date().toISOString(), managedByUser: false };
        isNew = true;
         if(reminder.text && reminder.text.toUpperCase().includes("RADAR RUTA:")) {
            parsed.text = reminder.text.replace("RADAR RUTA:", "RADAR:");
            parsed.excludeFromList = true;
            parsed.radiusMeters = 350;
        }
    }
    if (!isNew && !parsed.createdAt) { parsed.createdAt = new Date(0).toISOString(); }
    locationEnabledByUser = parsed.isLocationEnabled;
    currentReminderLocation = parsed.locationCoordinates;
    let fmtDate = '';
    if (parsed.date?.match(/^\d{4}-\d{2}-\d{2}$/)) {
        try {
            const [y,m,d] = parsed.date.split('-');
            const dt=new Date(Date.UTC(y,m-1,d));
            if(!isNaN(dt.getTime())&&dt.getUTCDate()==d&&dt.getUTCMonth()==m-1) {
                fmtDate=`${d.toString().padStart(2,'0')}/${m.toString().padStart(2,'0')}/${y}`;
            }
        } catch(e){}
    }
    const modal = document.createElement('div');
    modal.className = 'reminder-modal';
    modal.setAttribute('aria-label','Formulario recordatorio');
    const titleText = isNew ? 'NUEVO RECORDATORIO' : 'MODIFICAR RECORDATORIO';
    modal.innerHTML = `
        <div class="reminder-modal-header">
            <h2 class="reminder-modal-title">${titleText}</h2>
             <div class="header-options">
                <label for="reminder-exclude-from-list" class="form-label-exclude">
                    <input type="checkbox" id="reminder-exclude-from-list" ${parsed.excludeFromList ? 'checked' : ''}>
                    <span>No listar (Radares, etc.)</span>
                </label>
            </div>
        </div>

        <div class="reminder-modal-body">
            <form id="reminder-form" class="reminder-modal-form">
                
                <div class="form-section">
                    <div class="input-with-buttons">
                        <div class="button-and-status-wrapper">
                            <button type="button" id="clear-fields" class="clear-button" title="Limpiar todo el formulario">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                            </button>
                            <p id="speech-status" class="speech-status"></p>
                            <p id="parse-status" class="parse-status"></p>
                        </div>
                        <textarea id="reminder-text" rows="2" required placeholder="Escriba o dicte aqu√≠...">${parsed.text.replace(/<b>|<\/b>/gi,'')}</textarea>
                    </div>
                </div>
                
                <div class="form-section controls-grid">
                    <div class="control-item">
                        <label for="reminder-time" class="form-label">Hora:</label>
                        <input type="text" id="reminder-time" placeholder="HH:MM" pattern="\\d{2}:\\d{2}" value="${parsed.time||''}">
                    </div>
                    <div class="control-item">
                        <label for="reminder-date" class="form-label">Fecha:</label>
                        <input type="text" id="reminder-date" placeholder="DD/MM/AAAA" pattern="\\d{2}/\\d{2}/\\d{4}" value="${fmtDate}">
                    </div>
                    <div class="control-item">
                        <label for="reminder-interval" class="form-label">Int.(d√≠as):</label>
                        <input type="number" id="reminder-interval" min="1" max="9999" value="${parsed.intervalDays||''}">
                    </div>
                     <div class="control-item days-group-grid-item">
                         <label class="form-label">D√≠as Repet.:</label>
                         <div class="days-checkbox-container">
                            ${['Lun','Mar','Mi√©','Jue','Vie','S√°b','Dom'].map((d,i)=>`<label><input type="checkbox" name="repeat" value="${(i+1)%7}" ${parsed.repeatDays?.includes((i+1)%7)?'checked':''}><span>${d}</span></label>`).join('')}
                         </div>
                    </div>
                </div>

                <div class="form-section location-section">
                    <div class="location-header">
                        <label for="location-enabled" class="form-label-location">
                             <input type="checkbox" id="location-enabled" ${parsed.isLocationEnabled ? 'checked' : ''}>
                             <span>RECORDATORIO POR UBICACI√ìN</span>
                        </label>
                         <div id="radius-slider-group" class="radius-slider-group">
                             <div class="radius-control-wrapper">
                                <button type="button" class="slider-btn minus" id="radius-minus-btn">-</button>
                                <button type="button" class="slider-btn plus" id="radius-plus-btn">+</button>
                                <label id="radius-range-label" class="form-label">Radio: ${parsed.radiusMeters || 350}m</label>
                             </div>
                             <div class="slider-container single-slider-container">
                                 <div class="slider-track"></div>
                                 <div class="slider-range" id="radius-slider-range"></div>
                                 <div class="slider-thumb" id="radius-thumb"></div>
                             </div>
                         </div>
                        <button type="button" id="expand-map-button" class="expand-map-button">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
                            <span>MAPA</span>
                        </button>
                    </div>
                    <div id="location-controls-container" style="display: ${parsed.isLocationEnabled ? 'block' : 'none'};">
                         <div id="location-map-container" class="location-map-container">
                            <button type="button" id="reduce-map-button" class="hidden">REDUCIR</button>
                            <button type="button" id="locate-me-button" class="hidden">EST√ÅS AQU√ç</button>
                         </div>
                    </div>
                </div>
            </form>
        </div>

        <div class="reminder-modal-footer">
            <button type="submit" id="save-reminder" class="action-button primary">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13H7v8"></polyline><polyline points="7 3 7 8h10"></polyline></svg>
                <span>ACEPTAR</span>
                <span id="countdown-save" class="unified-countdown-style">${countdownSave}</span>
            </button>
             <button type="button" id="cancel-reminder" class="action-button secondary">Cancelar</button>
             <button type="button" id="delete-reminder" title="Borrar este recordatorio permanentemente" class="action-button danger">Borrar</button>
             <button type="button" id="view-reminders" class="action-button secondary">Ver Lista</button>
             <button type="button" id="manage-saved-locations" class="action-button secondary">Ubicaciones</button>
             <button type="button" id="help-reminder" class="action-button secondary">Ayuda</button>
        </div>
    `;
    
    if (options.onTopOfMap) {
        const mapContainerEl = document.getElementById('reminders-location-map-modal');
        if (mapContainerEl) mapContainerEl.appendChild(modal);
        else document.body.appendChild(modal);
    } else {
        document.body.appendChild(modal);
    }

    modal.cleanUpModalTimers = cleanUpModalTimers;
    
    const mapContainer = modal.querySelector('#location-map-container');
    const reduceMapButton = modal.querySelector('#reduce-map-button');
    const locateMeButton = modal.querySelector('#locate-me-button');
    const expandMapButton = modal.querySelector('#expand-map-button');
    const locationCheckbox = modal.querySelector('#location-enabled');

    function destroyMap() {
        if (reminderModalMap) {
            try { reminderModalMap.remove(); } catch(e) {}
            reminderModalMap = null;
            reminderMarker = null;
        }
        if (mapContainer) {
            mapContainer.style.display = 'none';
            mapContainer.classList.remove('preview', 'expanded');
            const mapDiv = mapContainer.querySelector('#reminder-modal-map-div');
            if (mapDiv) mapDiv.remove();
        }
        if (reduceMapButton) reduceMapButton.classList.add('hidden');
        if (locateMeButton) locateMeButton.classList.add('hidden');
        if (expandMapButton) expandMapButton.style.display = 'block';
    }

    function initializeOrUpdateMap(centerCoords, radius, isInteractive = false) {
        destroyMap(); 

        const effectiveLocationEnabled = locationCheckbox.checked;
        const showMap = effectiveLocationEnabled || isInteractive;
        if (!showMap) return;

        mapContainer.style.display = 'block';
        mapContainer.classList.toggle('preview', !isInteractive && effectiveLocationEnabled && centerCoords);
        mapContainer.classList.toggle('expanded', isInteractive && effectiveLocationEnabled);
        
        expandMapButton.style.display = (isInteractive && effectiveLocationEnabled) ? 'none' : 'block';
        
        const effectiveCoords = centerCoords || { latitude: 40.416775, longitude: -3.703790 };
        const effectiveRadius = parseInt(radius) || DEFAULT_LOCATION_RADIUS;
        const zoomLevel = isInteractive ? 13 : 11;

        const mapDiv = document.createElement('div');
        mapDiv.id = 'reminder-modal-map-div';
        mapDiv.style.width = '100%'; mapDiv.style.height = '100%';
        mapContainer.insertBefore(mapDiv, reduceMapButton);

        reminderModalMap = new mapboxgl.Map({
            container: mapDiv,
            style: 'mapbox://styles/mapbox/satellite-streets-v12?optimize=true',
            center: [effectiveCoords.longitude, effectiveCoords.latitude],
            zoom: zoomLevel,
            interactive: isInteractive && effectiveLocationEnabled,
            maxTileCacheSize: 25,
            antialias: false,
            preserveDrawingBuffer: false,
            minzoom: 7,
            maxzoom: 19
        });
        
        reminderModalMap.on('load', () => {
            updateMarkerAndCircle(effectiveCoords, effectiveRadius);
            
            reminderModalMap.on('click', handleMapClick);
            
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    if (reminderModalMap) {
                        try { reminderModalMap.resize(); } catch (e) {}
                    }
                });
            });
        });
        
        if (reduceMapButton) reduceMapButton.classList.toggle('hidden', !(isInteractive && effectiveLocationEnabled));
        if (locateMeButton) locateMeButton.classList.toggle('hidden', !(isInteractive && effectiveLocationEnabled));
    }
    const parseStatus = modal.querySelector('#parse-status');
    const speechStatus = modal.querySelector('#speech-status');
    let countdownSaveElement = modal.querySelector('#countdown-save');
    const textInput = modal.querySelector('#reminder-text');
    const timeInput = modal.querySelector('#reminder-time');
    const dateInput = modal.querySelector('#reminder-date');
    const intervalInput = modal.querySelector('#reminder-interval');
    const saveButton = modal.querySelector('#save-reminder');
    const clearButton = modal.querySelector('#clear-fields');
    const locationControlsContainer = modal.querySelector('#location-controls-container');
    const manageLocationsBtn = modal.querySelector('#manage-saved-locations');
    const excludeFromListCheckbox = modal.querySelector('#reminder-exclude-from-list');
    const deleteButton = modal.querySelector('#delete-reminder');
    
    const radiusSliderGroup = modal.querySelector('#radius-slider-group');

    function toggleLocationControlsVisibility() {
        const isChecked = locationCheckbox.checked;
        if (locationControlsContainer) {
            locationControlsContainer.style.display = isChecked ? 'block' : 'none';
        }
        if (radiusSliderGroup) {
            radiusSliderGroup.style.display = isChecked ? 'flex' : 'none';
        }
        if(!isChecked) {
           destroyMap();
        }
    }
    
    locationCheckbox.addEventListener('change', toggleLocationControlsVisibility);
    toggleLocationControlsVisibility();

    const radiusSliderContainer = modal.querySelector('#radius-thumb')?.parentElement;
    const radiusThumb = modal.querySelector('#radius-thumb');
    const radiusRange = modal.querySelector('#radius-slider-range');
    const radiusLabel = modal.querySelector('#radius-range-label');
    const minRadius = 1;
    const maxRadius = 5000;
    let currentRadius = parsed.radiusMeters || 350;
    
    const radiusMinusBtn = modal.querySelector('#radius-minus-btn');
    const radiusPlusBtn = modal.querySelector('#radius-plus-btn');

    const adjustRadius = (direction) => {
        let step;
        if (currentRadius < 100) step = 5; 
        else if (currentRadius < 500) step = 25; 
        else step = 100;

        if (direction === 'plus') {
            currentRadius += step;
        } else {
            currentRadius -= step;
        }

        currentRadius = Math.max(minRadius, Math.min(maxRadius, currentRadius));
        updateRadiusVisuals();
        if (reminderModalMap && currentReminderLocation) {
            updateMarkerAndCircle(currentReminderLocation, Math.round(currentRadius));
        }
        resetAndStartCountdown();
    };

    if (radiusPlusBtn) radiusPlusBtn.addEventListener('click', () => adjustRadius('plus'));
    if (radiusMinusBtn) radiusMinusBtn.addEventListener('click', () => adjustRadius('minus'));


    const updateRadiusVisuals = () => {
        if (!radiusThumb || !radiusRange || !radiusLabel) return;
        const minLog = Math.log(minRadius);
        const maxLog = Math.log(maxRadius);
        const percent = (Math.log(currentRadius) - minLog) / (maxLog - minLog);
        
        radiusThumb.style.left = `${percent * 100}%`;
        radiusRange.style.width = `${percent * 100}%`;
        radiusLabel.textContent = `Radio: ${Math.round(currentRadius)}m`;
    };

    if (radiusSliderContainer && radiusThumb) {
        const onRadiusDrag = (e) => {
            const rect = radiusSliderContainer.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let percent = ((clientX - rect.left) / rect.width);
            percent = Math.max(0, Math.min(1, percent));
            const minLog = Math.log(minRadius);
            const maxLog = Math.log(maxRadius);
            let rawRadius = Math.exp(minLog + percent * (maxLog - minLog));
            let step;
            if (rawRadius < 100) step = 5; 
            else if (rawRadius < 500) step = 25; 
            else step = 100;
            currentRadius = Math.round(rawRadius / step) * step;
            currentRadius = Math.max(minRadius, Math.min(maxRadius, currentRadius));
            updateRadiusVisuals();
            if (reminderModalMap && currentReminderLocation) {
                 updateMarkerAndCircle(currentReminderLocation, Math.round(currentRadius));
            }
            resetAndStartCountdown();
        };
        const startRadiusDrag = (e) => {
            const moveHandler = (moveEvent) => onRadiusDrag(moveEvent);
            const endDrag = () => {
                document.removeEventListener('mousemove', moveHandler);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchmove', moveHandler);
                document.removeEventListener('touchend', endDrag);
            };
            document.addEventListener('mousemove', moveHandler);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchmove', moveHandler);
            document.addEventListener('touchend', endDrag);
        };
        radiusThumb.addEventListener('mousedown', startRadiusDrag);
        radiusThumb.addEventListener('touchstart', startRadiusDrag);
        updateRadiusVisuals();
    }
    
    function handleMapClick(e) {
        const lngLat = e.lngLat;
        currentReminderLocation = { latitude: lngLat.lat, longitude: lngLat.lng };
        updateMarkerAndCircle(currentReminderLocation, Math.round(currentRadius));
        resetAndStartCountdown();
    }
    
    function updateMarkerAndCircle(coords, radius) {
        if (!reminderModalMap || !coords) return;
        const lngLat = [coords.longitude, coords.latitude];
        
        if (!reminderMarker) {
            const vehicleEl = document.createElement('div');
            vehicleEl.innerHTML = `<div style="width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;"><img src="PNG/AVANCE.PNG" style="width: 100%; height: 100%; object-fit: contain;"></div>`;
            reminderMarker = new mapboxgl.Marker({ element: vehicleEl, draggable: true })
                .setLngLat(lngLat)
                .addTo(reminderModalMap);
            reminderMarker.on('dragend', handleMarkerDragEnd);
        } else {
            reminderMarker.setLngLat(lngLat);
        }
        
        const circleId = 'reminder-circle';
        const circlePolygon = turf.circle(lngLat, radius, { steps: 64, units: 'meters' });

        if (reminderModalMap.getSource(circleId)) {
            reminderModalMap.getSource(circleId).setData(circlePolygon);
        } else {
            reminderModalMap.addSource(circleId, { 'type': 'geojson', 'data': circlePolygon });
            
            const isRadarType = textInput.value.toUpperCase().includes("RADAR") || excludeFromListCheckbox.checked;
            
            const circleFillColor = isRadarType ? 'rgba(255, 255, 0, 0.3)' : 'rgba(37, 99, 235, 0.3)';
            const circleStrokeColor = isRadarType ? '#FFD700' : '#2563EB';

            reminderModalMap.addLayer({
                'id': circleId,
                'type': 'fill',
                'source': circleId,
                'paint': {
                    'fill-color': circleFillColor,
                    'fill-outline-color': circleStrokeColor
                }
            });
        }
    }
    
    function handleMarkerDragEnd(event) {
        const lngLat = event.target.getLngLat();
        currentReminderLocation = { latitude: lngLat.lat, longitude: lngLat.lng };
        updateMarkerAndCircle(currentReminderLocation, Math.round(currentRadius));
        resetAndStartCountdown();
    }
    
    function handleLocationCheckboxChange() {
        const wasEnabled = locationEnabledByUser;
        locationEnabledByUser = locationCheckbox.checked;
        if (locationEnabledByUser) {
            if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && currentReminderLocation) {
                initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false);
            } else if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && !currentReminderLocation) {
                destroyMap();
            }
             if (!currentReminderLocation && !wasEnabled) {
                getCurrentLocation( (coords) => { currentReminderLocation = coords; if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && currentReminderLocation) { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false); } });
            }
        } else {
            destroyMap();
        }
        resetAndStartCountdown();
    }
    
    if (deleteButton) {
        deleteButton.addEventListener('click', () => {
            cleanUpModalTimers(true);
            const mapShouldReopen = mapShouldReopenAfterForm;
            const mapContextToReopen = mapContextBeforeThisModal;
            
            if (!isNew) {
                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const initialLength = reminders.length;
                reminders = reminders.filter(r => r.id !== parsed.id);
                if (reminders.length < initialLength) {
                    localStorage.setItem('reminders', JSON.stringify(reminders));
                    markCacheAsDirty();
                    if (isNavigationMapActive) {
                        plotRemindersOnNavigationMap();
                    }
                } else { 
                    showToast('Recordatorio no encontrado para borrar.', 'warning');
                }
            }

            destroyMap();
            if (modal.parentNode) modal.parentNode.removeChild(modal);
            updateReminderCount(); 
            updateButtonStyles(); 
            

            if (mapShouldReopen && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !isNavigationMapActive) {
                if (mapContextToReopen === 'navigation') openNavigationMap();
            } else if (mapShouldReopen) {
                 sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
                 if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen);
            }
            sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
        });
    }

    if (manageLocationsBtn) {
        manageLocationsBtn.addEventListener('click', () => {
            showSavedLocationsModal( () => { }, (selectedLocationData) => {
                    if (selectedLocationData && typeof selectedLocationData.lat === 'number' && typeof selectedLocationData.lng === 'number') {
                        currentReminderLocation = { latitude: selectedLocationData.lat, longitude: selectedLocationData.lng };
                        locationCheckbox.checked = true; locationEnabledByUser = true;
                        toggleLocationControlsVisibility();
                        currentRadius = typeof selectedLocationData.radius === 'number' && selectedLocationData.radius > 0 ? selectedLocationData.radius : DEFAULT_LOCATION_RADIUS;
                        updateRadiusVisuals();
                        if (mapContainer.classList.contains('expanded')) { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), true); } 
                        else { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false); }
                        showToast(`Ubicaci√≥n "${selectedLocationData.name || 'Seleccionada'}" aplicada.`, "success");
                        resetAndStartCountdown();
                    } else { showToast("Error: Datos de ubicaci√≥n seleccionada no v√°lidos.", "error"); }
                }, { parentContainer: modal } 
            );
        });
    }

    locationCheckbox.addEventListener('change', handleLocationCheckboxChange);
    if (parsed.isLocationEnabled && parsed.locationCoordinates) { initializeOrUpdateMap(parsed.locationCoordinates, parsed.radiusMeters, false); } 
    else if (parsed.isLocationEnabled && !parsed.locationCoordinates) { destroyMap(); } 
    else { destroyMap(); }

    if (expandMapButton) {
        expandMapButton.addEventListener('click', () => {
            if (!locationCheckbox.checked) { locationCheckbox.checked = true; toggleLocationControlsVisibility(); }
            locationEnabledByUser = true; mapExpandedManually = true;
            if (!currentReminderLocation) {
                locateMeButton.disabled = true; locateMeButton.textContent = 'Buscando...';
                getCurrentLocation(
                    (gpsCoords) => {
                        currentReminderLocation = { latitude: gpsCoords.latitude, longitude: gpsCoords.longitude };
                        initializeOrUpdateMap(gpsCoords, Math.round(currentRadius), true);
                        if (reminderModalMap) { reminderModalMap.flyTo({ zoom: 16 }); }
                        locateMeButton.disabled = false; locateMeButton.textContent = 'EST√ÅS AQU√ç';
                    }, (errorMsg) => {
                        initializeOrUpdateMap(null, Math.round(currentRadius), true);
                        if (reminderModalMap) { reminderModalMap.flyTo({ zoom: 6 }); }
                        showToast(`Error GPS: ${errorMsg}. Mapa centrado por defecto`, "warning", 3000);
                        locateMeButton.disabled = false; locateMeButton.textContent = 'EST√ÅS AQU√ç';
                    }
                );
            } else { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), true); }
            resetAndStartCountdown();
            setTimeout(() => { mapExpandedManually = false; }, 100);
        });
    }

    if (reduceMapButton) { reduceMapButton.addEventListener('click', () => { if (locationEnabledByUser && currentReminderLocation) { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false); } else { destroyMap(); } resetAndStartCountdown(); }); }
    if (locateMeButton) {
        locateMeButton.addEventListener('click', () => {
             if (!reminderModalMap || !mapContainer.classList.contains('expanded')) return;
             resetAndStartCountdown(); locateMeButton.disabled = true; locateMeButton.textContent = 'Buscando...';
             getCurrentLocation(
                 (coords) => {
                     currentReminderLocation = { latitude: coords.latitude, longitude: coords.longitude };
                     if (reminderModalMap) { reminderModalMap.flyTo({center: [coords.longitude, coords.latitude], zoom: 16}); updateMarkerAndCircle(coords, Math.round(currentRadius)); }
                     locateMeButton.disabled = false; locateMeButton.textContent = 'EST√ÅS AQU√ç';
                 }, (errorMsg) => { showToast(`Error al localizar: ${errorMsg}`, 'error'); locateMeButton.disabled = false; locateMeButton.textContent = 'EST√ÅS AQU√ç'; }
             );
        });
    }

    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) { } 
    else { speechStatus.textContent = 'Dictado no soportado.'; speechStatus.style.color = '#EF4444'; }

    function startCountdown() { autoSaveInterval = setInterval(() => { if (!document.body.contains(modal)) { clearInterval(autoSaveInterval); autoSaveInterval = null; return; } countdownSave--; if (countdownSaveElement) countdownSaveElement.textContent = countdownSave; if (countdownSave === 23) { if (document.activeElement === textInput) { textInput.value += ' '; textInput.selectionStart = textInput.selectionEnd = textInput.value.length; } } if (countdownSave <= 0) { clearInterval(autoSaveInterval); autoSaveInterval = null; if (saveButton) saveButton.click(); } }, 1000); }
    function resetAndStartCountdown() { countdownSave = 25; if (countdownSaveElement) countdownSaveElement.textContent = countdownSave; if (autoSaveInterval) { clearInterval(autoSaveInterval); autoSaveInterval = null; } startCountdown(); }
    
    timeInput.addEventListener('input', (e) => {
        manualTimeInput = true;
        let v = e.target.value.replace(/\D/g, '');
        let fV = '';
        if (v.length >= 2) fV = v.slice(0, 2);
        if (v.length > 2) fV += ':' + v.slice(2, 4);
        else if (v.length < 2) fV = v;
        e.target.value = fV;
        if (fV.match(/^\d{2}:\d{2}$/)) {
            const [h, m] = fV.split(':').map(Number);
            parseStatus.textContent = (h > 23 || m > 59) ? 'Hora inv√°lida' : '';
            parseStatus.classList.toggle('text-red-600', h > 23 || m > 59);
            parseStatus.classList.remove('text-green-600');
        } else if (fV.length > 0) {
            parseStatus.textContent = 'Formato HH:MM';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        } else {
            parseStatus.textContent = '';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        }
        resetAndStartCountdown();
    });

    dateInput.addEventListener('input', (e) => {
        let v = e.target.value.replace(/\D/g, '');
        let fV = '';
        if (v.length >= 2) fV = v.slice(0, 2);
        if (v.length > 2) fV += '/' + v.slice(2, 4);
        if (v.length > 4) fV += '/' + v.slice(4, 8);
        else if (v.length < 2) fV = v;
        e.target.value = fV;
        if (fV.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
            const [d, m, y] = fV.split('/').map(Number);
            const dt = new Date(Date.UTC(y, m - 1, d));
            const ok = !isNaN(dt.getTime()) && dt.getUTCDate() === d && dt.getUTCMonth() + 1 === m && y >= 2000 && y <= 2099;
            parseStatus.textContent = ok ? '' : 'Fecha inv√°lida';
            parseStatus.classList.toggle('text-red-600', !ok);
            parseStatus.classList.remove('text-green-600');
        } else if (fV.length > 0) {
            parseStatus.textContent = 'Formato DD/MM/AAAA';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        } else {
            parseStatus.textContent = '';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        }
        resetAndStartCountdown();
    });

    intervalInput.addEventListener('input', resetAndStartCountdown);
    modal.querySelectorAll('input[name="repeat"]').forEach(chk => chk.addEventListener('change', resetAndStartCountdown));
    
    if (countdownSaveElement) countdownSaveElement.textContent = countdownSave;

    function startFocusCheck() {
        if (restartTimeout) clearTimeout(restartTimeout);
        restartTimeout = setTimeout(() => {
            if (document.activeElement !== textInput && document.activeElement !== timeInput && document.activeElement !== dateInput && document.activeElement !== intervalInput && !Array.from(modal.querySelectorAll('input[name="repeat"]')).includes(document.activeElement) && document.activeElement !== saveButton && document.activeElement !== modal.querySelector('#cancel-reminder') && document.activeElement !== modal.querySelector('#help-reminder') && document.activeElement !== clearButton && document.activeElement !== modal.querySelector('#view-reminders') && document.activeElement !== locationCheckbox && document.activeElement !== radiusThumb && document.activeElement !== expandMapButton && document.activeElement !== reduceMapButton && document.activeElement !== locateMeButton && !(reminderModalMap && reminderModalMap.getCanvasContainer().contains(document.activeElement))) {
                resetAndStartCountdown();
                restartTimeout = null;
            } else {
                restartTimeout = null;
            }
        }, 500);
    }

    resetAndStartCountdown();
    startFocusCheck();
    modal.addEventListener('input', resetAndStartCountdown);
    modal.addEventListener('click', resetAndStartCountdown);
    modal.addEventListener('touchstart', resetAndStartCountdown, { passive: true });
    modal.addEventListener('focusin', () => {
        resetAndStartCountdown();
        if (focusTimeout) clearTimeout(focusTimeout);
        focusTimeout = null;
    });
    modal.addEventListener('focusout', () => {
        if (!focusTimeout) {
            startFocusCheck();
        }
    });

    textInput.addEventListener('input', (e) => {
        lastInputWasSpeech = false;
        const txt = e.target.value || '';
        parseStatus.textContent = 'Analizando...';
        parseStatus.classList.remove('text-green-600', 'text-red-600');
        if (parseTimeout) clearTimeout(parseTimeout);
        parseTimeout = setTimeout(() => {
            if (!document.body.contains(modal)) return;
            try {
                const uiElements = {
                    timeInput: timeInput,
                    dateInput: dateInput,
                    intervalInput: intervalInput,
                    repeatCheckboxes: modal.querySelectorAll('input[name="repeat"]'),
                    locationCheckbox: locationCheckbox,
                    radiusInput: null,
                    manualTimeInput: manualTimeInput,
                    mapExpandedManually: mapExpandedManually,
                    excludeFromListCheckbox: excludeFromListCheckbox
                };
                if (!manualTimeInput) uiElements.timeInput.value = '';
                uiElements.dateInput.value = '';
                uiElements.intervalInput.value = '';
                uiElements.repeatCheckboxes.forEach(chk => chk.checked = false);
                const pD = parseReminderText(txt, uiElements);
                
                if(pD.radiusMeters) {
                    currentRadius = pD.radiusMeters;
                    updateRadiusVisuals();
                }

                if (isNew && (pD.type === 'weekly' || pD.type === 'interval')) {
                    const tempReminderForCalc = { type: pD.type, time: pD.time, date: pD.date, repeatDays: pD.repeatDays, intervalDays: pD.intervalDays };
                    const nowForCalc = new Date();
                    if (!tempReminderForCalc.date) tempReminderForCalc.date = `${nowForCalc.getFullYear()}-${(nowForCalc.getMonth() + 1).toString().padStart(2, '0')}-${nowForCalc.getDate().toString().padStart(2, '0')}`;
                    if (!tempReminderForCalc.time) tempReminderForCalc.time = '00:01';
                    const firstOcc = calculateNextOccurrence(tempReminderForCalc, new Date());
                    if (firstOcc) {
                        const firstOccISO = `${firstOcc.getUTCFullYear()}-${(firstOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOcc.getUTCDate().toString().padStart(2, '0')}`;
                        const firstOccTime = `${firstOcc.getUTCHours().toString().padStart(2, '0')}:${firstOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                        pD.date = firstOccISO;
                        pD.time = firstOccTime;
                        const datePartsCalc = pD.date.split('-');
                        if (datePartsCalc.length === 3) dateInput.value = `${datePartsCalc[2]}/${datePartsCalc[1]}/${datePartsCalc[0]}`;
                        if (!manualTimeInput) timeInput.value = pD.time;
                    } else {
                        if (!pD.date) { const today = new Date(); pD.date = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}-${today.getDate().toString().padStart(2, '0')}`; }
                        if (!pD.time) pD.time = '00:01';
                        const datePartsFb = pD.date.split('-');
                        if (datePartsFb.length === 3) dateInput.value = `${datePartsFb[2]}/${datePartsFb[1]}/${datePartsFb[0]}`;
                        if (!manualTimeInput) timeInput.value = pD.time;
                    }
                }
                parseStatus.textContent = 'OK';
                parseStatus.classList.add('text-green-600');
                parseStatus.classList.remove('text-red-600');
                toggleLocationControlsVisibility();
                handleLocationCheckboxChange();
            } catch (error) {
                parseStatus.textContent = `Error: ${error.message.substring(0, 100)}`;
                parseStatus.classList.add('text-red-600');
                parseStatus.classList.remove('text-green-600');
            }
            parseTimeout = null;
        }, 1000);
        resetAndStartCountdown();
    });

    saveButton.addEventListener('click', (e) => {
        e.preventDefault();
        const form = modal.querySelector('#reminder-form');
        if (form.checkValidity && !form.checkValidity()) { form.reportValidity(); return; }
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        const mapContextToReopen = mapContextBeforeThisModal;
        const text = textInput.value.trim();
        if (!text) { parseStatus.textContent = 'Texto obligatorio.'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; }
        let time = timeInput.value.trim();
        let dateStr = dateInput.value.trim();
        const repeatDays = Array.from(modal.querySelectorAll('input[name="repeat"]:checked')).map(input => parseInt(input.value));
        const intervalDays = parseInt(intervalInput.value) || null;
        const isLocationChecked = locationCheckbox.checked;
        const radius = Math.round(currentRadius);
        const locationCoords = currentReminderLocation;
        const excludeFromListVal = excludeFromListCheckbox.checked;
        if (isLocationChecked && !locationCoords) { parseStatus.textContent = 'Ubicaci√≥n activada pero no fijada en el mapa.'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; }
        let dateISO = null; let finalTime = time; let reminderType = 'simple';
        if (dateStr) { if (dateStr.match(/^\d{2}\/\d{2}\/\d{4}$/)) { const [d, m, y] = dateStr.split('/').map(Number); const tD = new Date(Date.UTC(y, m - 1, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() + 1 === m && y >= 2000 && y <= 2099) { dateISO = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } else { parseStatus.textContent = 'Fecha inv√°lida'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } } else { parseStatus.textContent = 'Formato DD/MM/AAAA'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } }
        if (finalTime && !finalTime.match(/^\d{2}:\d{2}$/)) { parseStatus.textContent = 'Formato HH:MM'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } else if (finalTime) { const [h, m] = finalTime.split(':').map(Number); if (h > 23 || m > 59) { parseStatus.textContent = 'Hora inv√°lida'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } }
        if (intervalDays !== null && intervalDays > 0) { reminderType = 'interval'; if (!dateISO) { const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } if (!finalTime) finalTime = '00:01'; } 
        else if (repeatDays.length > 0) { reminderType = 'weekly'; if (!dateISO) { const tempCalc = { type: 'weekly', time: finalTime || '00:01', date: null, repeatDays: repeatDays, intervalDays: null }; const firstOcc = calculateNextOccurrence(tempCalc, new Date()); if (firstOcc) { dateISO = `${firstOcc.getUTCFullYear()}-${(firstOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOcc.getUTCDate().toString().padStart(2, '0')}`; finalTime = finalTime || `${firstOcc.getUTCHours().toString().padStart(2, '0')}:${firstOcc.getUTCMinutes().toString().padStart(2, '0')}`; } else { const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; if (!finalTime) finalTime = '00:01'; } } else { if (!finalTime) finalTime = '00:01'; } } 
        else if (dateISO && finalTime) { reminderType = 'daily'; } else if (finalTime) { reminderType = 'daily'; const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (dateISO) { reminderType = 'daily'; finalTime = '00:01'; } 
        else { reminderType = 'simple'; const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; finalTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`; }
        const now = new Date(); const finalCreatedAt = isNew ? now.toISOString() : (parsed.createdAt || now.toISOString()); let finalDateISO = dateISO;
        if (isNew && (reminderType === 'weekly' || reminderType === 'interval')) { let needsRecalc = false; if (!dateInput.value.trim()) { needsRecalc = true; } else { try { const [d, m, y] = dateStr.split('/').map(Number); const inputDate = new Date(Date.UTC(y, m - 1, d)); const todayForCompare = new Date(now.getFullYear(), now.getMonth(), now.getDate()); if (inputDate < todayForCompare) { needsRecalc = true; } } catch (e) { needsRecalc = true; } } if (needsRecalc) { const tempCalcForNewCyclic = { type: reminderType, time: finalTime || '00:01', date: null, repeatDays: reminderType === 'weekly' ? repeatDays : [], intervalDays: reminderType === 'interval' ? intervalDays : null }; const firstOccurrence = calculateNextOccurrence(tempCalcForNewCyclic, new Date()); if (firstOccurrence) { finalDateISO = `${firstOccurrence.getUTCFullYear()}-${(firstOccurrence.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOccurrence.getUTCDate().toString().padStart(2, '0')}`; } else { if (!finalDateISO) { finalDateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } } } }
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        const newReminder = { id: isNew ? Date.now() : parsed.id, text: `<b>${text.toUpperCase()}</b>`, type: reminderType, time: finalTime || null, date: finalDateISO, repeatDays: reminderType === 'weekly' ? repeatDays : [], intervalDays: reminderType === 'interval' ? intervalDays : null, createdAt: finalCreatedAt, managedByUser: false, isLocationEnabled: isLocationChecked, locationCoordinates: isLocationChecked ? locationCoords : null, radiusMeters: isLocationChecked ? radius : (parsed.radiusMeters || (text.toUpperCase().startsWith("RADAR") ? 350 : DEFAULT_LOCATION_RADIUS)), excludeFromList: excludeFromListVal, isFromRuta: parsed.isFromRuta || false };
        if (!newReminder.date || !newReminder.time || !newReminder.createdAt) { showToast("Error GRAVE: Fechas/Hora inv√°lidas al guardar", "error"); resetAndStartCountdown(); return; }
        if (options.onTopOfMap) { const mapObjectIndex = reminderMapObjects.findIndex(obj => obj.reminderId === newReminder.id); if (mapObjectIndex !== -1) { const { marker, circleId } = reminderMapObjects[mapObjectIndex]; if (marker) marker.remove(); if (circleId && navigationMapInstance.getLayer(circleId)) navigationMapInstance.removeLayer(circleId); if (circleId && navigationMapInstance.getSource(circleId)) navigationMapInstance.removeSource(circleId); reminderMapObjects.splice(mapObjectIndex, 1); } if(navigationMapInstance) { const newMapObject = plotRemindersOnNavigationMap(); if(newMapObject) reminderMapObjects.push(newMapObject); } }
        if (!isNew) { const index = reminders.findIndex(r => r.id === parsed.id); if (index !== -1) { reminders[index] = newReminder; } else { newReminder.id = Date.now() + Math.random(); reminders.push(newReminder); } } else { reminders.push(newReminder); }
        localStorage.setItem('reminders', JSON.stringify(reminders)); 
        markCacheAsDirty();
        destroyMap();
        if (modal.parentNode) modal.parentNode.removeChild(modal);
        updateReminderCount(); updateButtonStyles(); 
        if (!options.onTopOfMap) { const unifiedWindowIsVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible'); if (mapShouldReopen && !unifiedWindowIsVisible && !isNavigationMapActive) { if (mapContextToReopen === 'navigation') openNavigationMap(); } else if (mapShouldReopen && unifiedWindowIsVisible) { sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true'); if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen); } }
        sessionStorage.removeItem('boardinggate_map_should_reopen_after_form'); sessionStorage.removeItem('mapContext');
    });

    modal.querySelector('#cancel-reminder').addEventListener('click', () => {
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        const mapContextToReopen = mapContextBeforeThisModal;
        destroyMap();
        if (modal.parentNode) modal.parentNode.removeChild(modal);
        const unifiedWindowIsVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible');
        if (mapShouldReopen && !unifiedWindowIsVisible && !isNavigationMapActive) { if (mapContextToReopen === 'navigation') openNavigationMap(); }
        sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
        sessionStorage.removeItem('mapContext');
    });

    modal.querySelector('#help-reminder').addEventListener('click', () => { showHelpModal({ parentContainer: modal }); });

    clearButton.addEventListener('click', () => {
        textInput.value=''; timeInput.value=''; dateInput.value='';
        modal.querySelectorAll('input[name="repeat"]').forEach(i=>i.checked=false);
        intervalInput.value=''; locationCheckbox.checked = false; toggleLocationControlsVisibility();
        currentRadius = parsed.radiusMeters || DEFAULT_LOCATION_RADIUS; updateRadiusVisuals();
        currentReminderLocation = null; destroyMap();
        excludeFromListCheckbox.checked = false; parseStatus.textContent=''; speechStatus.textContent=''; manualTimeInput=false;
        resetAndStartCountdown(); textInput.focus();
    });

    modal.querySelector('#view-reminders').addEventListener('click', () => {
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        const mapContextToReopen = mapContextBeforeThisModal;
        destroyMap();
        if (modal.parentNode) modal.parentNode.removeChild(modal);
        fromReminderModal = true;
        if (mapShouldReopen) {
            sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
            if (mapContextToReopen) {
                sessionStorage.setItem('mapContext', mapContextToReopen);
            }
        }
        showAllReminders();
    });
    
    textInput.focus();
}

// ===================================================================
// NOMBRE: markReminderAsManaged 
// RESUMEN: Marca un recordatorio como gestionado y marca la cach√© como sucia.
function markReminderAsManaged(reminderId, managedState = true) {
     if (typeof reminderId !== 'number') { return; } try { let reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); const index = reminders.findIndex(r => r.id === reminderId); if (index !== -1) { if (reminders[index].managedByUser !== managedState) { reminders[index].managedByUser = managedState; localStorage.setItem('reminders', JSON.stringify(reminders)); 
     markCacheAsDirty(); } } } catch (e) { }
}
   
// ===================================================================
// NOMBRE: clearRecoveryFlag 
    function clearRecoveryFlag() {
    localStorage.removeItem('boardinggate_nav_recovery_flag');
}   
// ===================================================================
// NOMBRE: addSlideButtonListeners 
// RESUMEN: A√±ade listeners a los botones del slide y marca la cach√© como sucia en cada modificaci√≥n.
function addSlideButtonListeners(slideElement, reminder) {
        const reminderId = reminder.id;
        const cancelButton = slideElement.querySelector('.cancel');
        const adjustTimeButton = slideElement.querySelector('.adjust-time-0001');
        const cancelCyclicButton = slideElement.querySelector('.cancel-cyclic');
        const modifyButton = slideElement.querySelector('.modify');
        const postponeButton = slideElement.querySelector('.postpone');
        const routeRadarVistoButton = slideElement.querySelector('.route-radar-seen');
        const handleInteraction = (actionFn) => {
            markReminderAsManaged(reminderId, true);
            actionFn();
            updateUnifiedWindowUI(processedReminderId);
        };
        let processedReminderId = reminderId;
        if (routeRadarVistoButton) {
            routeRadarVistoButton.addEventListener('click', () => {
                const minutesToSnooze = 5;
                markReminderAsManaged(reminder.id, true);
                
                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const index = reminders.findIndex(r => r.id === reminder.id);

                if (index !== -1) {
                    const { newDateISO, newTime } = calculatePostponedDateTime(minutesToSnooze);
                    
                    reminders[index].date = newDateISO;
                    reminders[index].time = newTime;
                    reminders[index].managedByUser = false;
                    localStorage.setItem('reminders', JSON.stringify(reminders));
                    
                    const radarEnRutaIndex = radaresEnRutaActual.findIndex(r => r.id === reminder.id);
                    if (radarEnRutaIndex !== -1) {
                        const newDueTime = new Date(`${newDateISO}T${newTime}:00Z`).getTime();
                        radaresEnRutaActual[radarEnRutaIndex].date = newDateISO;
                        radaresEnRutaActual[radarEnRutaIndex].time = newTime;
                        radaresEnRutaActual[radarEnRutaIndex].dueTimeUTC = newDueTime;
                    }

                    markCacheAsDirty();
                    actualizarYOrdenarEventosEnRuta();
                } else {
                    showToast("Error: No se pudo encontrar el radar para posponer.", "error");
                }
                
                updateUnifiedWindowUI(reminder.id);
            });
        }
        if (cancelButton) {
            cancelButton.addEventListener('click', () => { 
                handleInteraction(() => { 
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const index = rems.findIndex(r => r.id === processedReminderId); 
                    if (index === -1) {
                        if (reminder.isFromRuta === true) {
                            const eventoIndex = eventosEnRuta.findIndex(e => e.id === processedReminderId);
                            if (eventoIndex !== -1) {
                                eventosEnRuta[eventoIndex].managedByUser = true;
                            }
                            showToast(`Alerta de ruta marcada como vista.`, 'info');
                            return; // Salimos aqu√≠ para no ejecutar la l√≥gica de abajo
                        } else {
                            showToast("Error: No se encontr√≥ el recordatorio para actualizar.", "error");
                            return;
                        }
                    }

                    const currentReminder = rems[index];
                    let needsSave = false;
                    const isRadarTypeStored = currentReminder.text.toUpperCase().includes("RADAR") || currentReminder.excludeFromList;
                    
                    if (isRadarTypeStored || (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval'))) { 
                       const minutesToPostpone = 15;
                       const { newDateISO, newTime } = calculatePostponedDateTime(minutesToPostpone);
                       rems[index].date = newDateISO;
                       rems[index].time = newTime;
                       rems[index].managedByUser = false;
                       needsSave = true;
                       showToast(`Recordatorio pospuesto ${minutesToPostpone} minutos`, 'info');
                    } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                        let referenceDateForNext = new Date();
                        try {
                            const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                            const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                            const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                            if (!isNaN(reminderDateTime.getTime())) {
                                referenceDateForNext = new Date(reminderDateTime.getTime() + 60000); 
                            }
                        } catch(er) {  }
                        const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                        if (nextOcc) {
                            rems[index].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                            rems[index].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                            rems[index].managedByUser = false;
                            needsSave = true;
                        } else {
                            rems.splice(index, 1); needsSave = true;
                            showToast('Error calculando siguiente ciclo. Recordatorio eliminado.', 'error');
                        }
                    } else {
                       rems.splice(index, 1);
                       needsSave = true;
                    }
                    
                    if (needsSave) {
                        localStorage.setItem('reminders', JSON.stringify(rems));
                        markCacheAsDirty();
                        actualizarYOrdenarEventosEnRuta();
                    }
                }); 
            });
        }
        if (adjustTimeButton) {
            adjustTimeButton.addEventListener('click', () => handleInteraction(() => {
                let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                const index = rems.findIndex(r => r.id === processedReminderId);
                if (index === -1) return;
                const currentReminder = rems[index];
                let needsSave = false;
                if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                     let referenceDateForNext = new Date();
                     try {
                         const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                         const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, 0, 1)); 
                         if (!isNaN(reminderDateTime.getTime())) {
                             referenceDateForNext = new Date(reminderDateTime.getTime() + 60000); 
                         }
                     } catch(e) {  }
                    const reminderForCalc = { ...currentReminder, time: '00:01' };
                    const nextOcc = calculateNextOccurrence(reminderForCalc, referenceDateForNext);
                    if (nextOcc) {
                        rems[index].date= `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                        rems[index].time = '00:01';
                        rems[index].managedByUser = false;
                        needsSave = true;
                    } else {
                        rems.splice(index, 1); needsSave = true;
                        showToast('Error calculando siguiente ciclo (ajuste 00:01). Eliminado.', 'error');
                    }
                } else { 
                    rems.splice(index, 1); needsSave = true;
                }
                if (needsSave) {
                    localStorage.setItem('reminders', JSON.stringify(rems));
                    markCacheAsDirty();
                    actualizarYOrdenarEventosEnRuta();
                }
            }));
        }
        if (cancelCyclicButton) {
            cancelCyclicButton.addEventListener('click', () => handleInteraction(() => {
                if (confirm('¬øEst√°s seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE?')) {
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const initialLength = rems.length;
                    rems = rems.filter(r => r.id !== processedReminderId);
                    if (rems.length < initialLength) {
                       localStorage.setItem('reminders', JSON.stringify(rems)); 
                       markCacheAsDirty();
                       actualizarYOrdenarEventosEnRuta();
                       showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                    } else {
                        showToast('Error: No se encontr√≥ el ciclo para anular.', 'warning');
                    }
                } else {
                    markReminderAsManaged(processedReminderId, false); 
                }
            }));
        }
        if (modifyButton) {
            modifyButton.addEventListener('click', () => {
                markReminderAsManaged(reminder.id, true);
                let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                let reminderToModify = remindersFromStorage.find(r => r.id === reminder.id);
                if (!reminderToModify && reminder.isFromRuta) {
                   reminderToModify = { ...reminder };
                   reminderToModify.isFromRuta = false;
                }
                const mapIsVisible = document.getElementById('reminders-location-map-modal') && !document.getElementById('reminders-location-map-modal').classList.contains('hidden');
                const mapShouldReopenWhenUnifiedCloses = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                const mapContextBeforeUnified = sessionStorage.getItem('mapContext');
                hideUnifiedReminderWindow();
                if (reminderToModify) {
                    if (mapShouldReopenWhenUnifiedCloses) {
                         sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                         if (mapContextBeforeUnified) {
                           sessionStorage.setItem('mapContext', mapContextBeforeUnified);
                         }
                    }
                    showReminderModal(reminderToModify, { onTopOfMap: mapIsVisible });
                }
                else {
                    showToast("Error: no se pudo encontrar el recordatorio para modificar.", "error");
                    updateUnifiedWindowUI(reminder.id);
                    if (mapShouldReopenWhenUnifiedCloses &&
                        sessionStorage.getItem('boardinggate_map_should_reopen_after_form') !== 'true' &&
                        !document.getElementById('reminders-location-map-modal')
                       ) {
                        if (mapContextBeforeUnified === 'navigation') openNavigationMap();
                         sessionStorage.removeItem('mapContext');
                    }
                }
                sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
            });
        }
        if (postponeButton) {
            postponeButton.addEventListener('click', () => {
                markReminderAsManaged(processedReminderId, true); 
                let reminderToPostpone;
                if (reminder.isFromRuta) {
                    const eventoIndex = eventosEnRuta.findIndex(e => e.id === processedReminderId);
                    if (eventoIndex !== -1) {
                        eventosEnRuta[eventoIndex].managedByUser = true;
                    }
                    updateUnifiedWindowUI(reminder.id);
                    return; 
                } else {
                    let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                    reminderToPostpone = remindersFromStorage.find(r => r.id === processedReminderId);
                }
                if (reminderToPostpone) {
                    showPostponeOptionsModal(reminderToPostpone, 'unified');
                }
                else {
                    showToast("Error: no se pudo encontrar el recordatorio para posponer", "error");
                    updateUnifiedWindowUI(processedReminderId); 
                }
            });
        }
    }    

// ===================================================================
// NOMBRE: precalculateRouteStepDistances (MODIFICADA PARA INCLUIR TURF.JS)
// RESUMEN: Procesa la ruta una sola vez para crear el objeto Turf LineString y las distancias acumuladas.
function precalculateRouteStepDistances(routeData) {
    if (!routeData || !routeData.routes || !routeData.routes[0]) {
        if(routeData && routeData.routes && routeData.routes[0]) {
            delete routeData.routes[0].totalPrecalculatedDistance;
        }
        window.optimizationHasFailed = true; 
        return;
    }
    
    try {
        const route = routeData.routes[0];
        
        if (route.geometry && typeof turf !== 'undefined') {
            route._turfLineString = turf.lineString(route.geometry.coordinates);
        }
        let cumulativeDistance = 0;
        if (route.legs) {
            route.legs.forEach(leg => {
                if (leg.steps) {
                    leg.steps.forEach(step => {
                        step.cumulativeDistance = cumulativeDistance;
                        cumulativeDistance += (step.distance || 0);
                    });
                }
            });
        }
        route.totalPrecalculatedDistance = cumulativeDistance;
        window.optimizationHasFailed = false; // Marcamos como exitoso
    
    } catch (error) {
        console.error("[PRE-CALC] Error durante el pre-c√°lculo de distancias:", error);
        if(routeData && routeData.routes && routeData.routes[0]) {
            delete routeData.routes[0].totalPrecalculatedDistance;
        }
        window.optimizationHasFailed = true;
    }
}              
    
// ===================================================================
// NOMBRE: checkAndIncrementPoiCount 
// RESUMEN: Verifica el l√≠mite global y actualiza el contador del usuario
async function checkAndIncrementPoiCount() {
    const { primaryId: userId } = parseUserId(localStorage.getItem('userData_userId'));
    if (!userId || !window.db) return false;

    const GLOBAL_POI_LIMIT = 7000;

    try {
        const globalStats = await getGlobalPoiStats();
        if (globalStats.totalMonth >= GLOBAL_POI_LIMIT) {
            showToast("Servicio de POI temporalmente inactivo (l√≠mite mensual alcanzado).", "warning");
            return false; // Bloquear si se ha alcanzado el l√≠mite global
        }

        const userDocRef = window.doc(window.db, "user_data", userId);
        const userDocSnap = await window.getDoc(userDocRef);
        
        const now = new Date();
        const monthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        let dataToUpdate = {};

        if (!userDocSnap.exists()) {
            dataToUpdate = {
                poi_clicks_last_month: monthStr,
                poi_clicks_month: 1
            };
        } else {
            const userData = userDocSnap.data();
            let newMonthCount = 1;
            if (userData.poi_clicks_last_month === monthStr) {
                newMonthCount = (userData.poi_clicks_month || 0) + 1;
            }
            
            dataToUpdate = {
                poi_clicks_last_month: monthStr,
                poi_clicks_month: newMonthCount
            };
        }

        await window.setDoc(userDocRef, dataToUpdate, { merge: true });

        return true; 

    } catch (error) {
        console.error("Error al verificar/incrementar el contador de POIs:", error);
        showToast("Error al verificar l√≠mite de POIs. Int√©ntalo de nuevo.", "error");
        return false; 
    }
}    

// ===================================================================
// NOMBRE: initializeLocationPickerMap 
function initializeLocationPickerMap(mapContainerId, slotIndex) {
    const container = document.getElementById(mapContainerId);
    if (!container) return;

  
    const initialLocation = tempSavedLocations[slotIndex] || {};
    const centerLat = initialLocation.lat || 40.416775;
    const centerLng = initialLocation.lng || -3.703790;
    const initialZoom = (initialLocation.lat && initialLocation.lng) ? 15 : 6;

    const mapDiv = document.createElement('div');
    mapDiv.style.width = '100%';
    mapDiv.style.height = '100%';
    container.insertBefore(mapDiv, container.firstChild); 
    locationPickerMap = new mapboxgl.Map({
        container: mapDiv, // Usamos el nuevo div.
        style: 'mapbox://styles/mapbox/satellite-streets-v12?optimize=true',
        center: [centerLng, centerLat],
        zoom: initialZoom,
        maxTileCacheSize: 20,
        antialias: false,
        preserveDrawingBuffer: false,
        interactive: true,
        minzoom: 2,
        maxzoom: 19
    });

    locationPickerMap.activeSlotIndex = slotIndex;

    locationPickerMap.on('load', () => {
        locationPickerMarker = new mapboxgl.Marker({ draggable: true })
            .setLngLat([centerLng, centerLat])
            .addTo(locationPickerMap);

        locationPickerMarker.on('dragend', (event) => {
            const activeSlotIndex = locationPickerMap.activeSlotIndex;
            if (typeof activeSlotIndex !== 'number') return;
            const pos = event.target.getLngLat();
            if (!tempSavedLocations[activeSlotIndex]) {
                tempSavedLocations[activeSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
            }
            tempSavedLocations[activeSlotIndex].lat = pos.lat;
            tempSavedLocations[activeSlotIndex].lng = pos.lng;
        });

        locationPickerMap.on('click', (e) => {
            const activeSlotIndex = locationPickerMap.activeSlotIndex;
            if (typeof activeSlotIndex !== 'number') return;
            handlePickerMapClick(e, activeSlotIndex);
        });

        setTimeout(() => {
            if (locationPickerMap) {
                try {
                    locationPickerMap.resize();
                } catch(e) { console.error("Error al redimensionar mapa reci√©n creado:", e); }
            }
        }, 50);
    });
}
    
// ===================================================================
// NOMBRE: applyMapVisualSettings 
// RESUMEN: Carga los ajustes de saturaci√≥n y contraste del mapa desde localStorage y los aplica como variables CSS.
function applyMapVisualSettings() {
    const savedSaturation = localStorage.getItem('boardinggate_map_saturation') || '1.6';
    const savedContrast = localStorage.getItem('boardinggate_map_contrast') || '1.2';
    
    document.documentElement.style.setProperty('--map-saturation', savedSaturation);
    document.documentElement.style.setProperty('--map-contrast', savedContrast);
}
 
// ===================================================================
// NOMBRE: showReminderActionModal 
// RESUMEN: Muestra un modal personalizado para las acciones de un recordatorio/radar.
function showReminderActionModal(reminderId) {
    const rems = JSON.parse(localStorage.getItem('reminders') || '[]');
    const reminder = rems.find(r => r.id === reminderId);
    if (!reminder) return;

    const overlay = document.createElement('div');
    overlay.className = 'map-item-modal-overlay';

    overlay.innerHTML = `
        <div class="map-item-modal-content">
            <h3>${reminder.text.replace(/<b>|<\/b>/gi,'')}</h3>
            <hr>
            ${reminder.time ? `<p><strong>Hora:</strong> ${formatTimeWithPeriod(reminder.time)}</p>` : ''}
            ${reminder.date ? `<p><strong>Fecha:</strong> ${formatDateDetailed(reminder.date)}</p>` : ''}
            <p><strong>Radio:</strong> ${reminder.radiusMeters || DEFAULT_LOCATION_RADIUS}m</p>
            <div class="map-item-modal-buttons">
                <button id="modal-modify-btn" style="background-color: #10B981;">Modificar</button>
                <button id="modal-close-btn" style="background-color: #6c757d;">Cerrar</button>
            </div>
        </div>
    `;

    document.body.appendChild(overlay);

    const closeHandler = () => {
        if (overlay.parentNode) overlay.remove();
    };

    overlay.querySelector('#modal-close-btn').addEventListener('click', closeHandler);
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) closeHandler();
    });

    overlay.querySelector('#modal-modify-btn').addEventListener('click', () => {
        const mapContextBeforeModal = sessionStorage.getItem('mapContext');
        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
        if (mapContextBeforeModal) {
            sessionStorage.setItem('mapContext', mapContextBeforeModal);
        }
        showReminderModal(reminder, { onTopOfMap: true });
        closeHandler();
    });
}   

// ===================================================================
// NOMBRE: manageAdaptiveLayerVisibility
// RESUMEN: Gestiona la visibilidad de las capas seg√∫n un perfil ('full', 'road_only').
function manageAdaptiveLayerVisibility(profile) {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded() || currentVisibilityProfile === profile) {
        return; 
    }

    const panel = document.querySelector('.map-layer-visibility-selector');
    const checkboxes = panel ? panel.querySelectorAll('input[type="checkbox"]') : [];

    if (currentVisibilityProfile !== 'full' && profile === 'full') {
        Object.keys(layerVisibilityBeforeEco).forEach(layerId => {
            if (navigationMapInstance.getLayer(layerId)) {
                navigationMapInstance.setLayoutProperty(layerId, 'visibility', layerVisibilityBeforeEco[layerId]);
            }
        });
        if (panel) panel.classList.remove('disabled');
        checkboxes.forEach(cb => cb.disabled = false);
        layerVisibilityBeforeEco = {}; // Limpiamos el estado guardado
    }
    else if (profile !== 'full') {
        if (currentVisibilityProfile === 'full') {
            layerVisibilityBeforeEco = {}; // Reiniciamos
            Object.values(LAYER_VISIBILITY_GROUPS).flatMap(g => g.layers).forEach(layerId => {
                if (navigationMapInstance.getLayer(layerId)) {
                    layerVisibilityBeforeEco[layerId] = navigationMapInstance.getLayoutProperty(layerId, 'visibility') || 'visible';
                }
            });
        }
        
        Object.keys(LAYER_VISIBILITY_GROUPS).forEach(groupKey => {
            const group = LAYER_VISIBILITY_GROUPS[groupKey];
            let targetVisibility = 'none';

            if (profile === 'road_only' && groupKey === 'carreteras') {
                targetVisibility = 'visible';
            }
            
            group.layers.forEach(layerId => {
                if (navigationMapInstance.getLayer(layerId)) {
                    navigationMapInstance.setLayoutProperty(layerId, 'visibility', targetVisibility);
                }
            });
        });
        
        if (panel) panel.classList.add('disabled');
        checkboxes.forEach(cb => cb.disabled = true);
    }
    
    currentVisibilityProfile = profile;
}
    
// ===================================================================
// NOMBRE: handleAutoZoom (VERSI√ìN FINAL CON L√ìGICA CORRECTA Y DEFINITIVA)
// RESUMEN: Gestiona el zoom y la visibilidad de capas seg√∫n las reglas exactas de navegaci√≥n.
function handleAutoZoom() {
    const currentAutoZoomMode = localStorage.getItem(AUTO_ZOOM_MODE_KEY) || 'off';

    if (!isNavigating && !isFreeDriveActive) {
        manageAdaptiveLayerVisibility('full');
        return null;
    }

    if (isManualZoomActive || isZoomedForManeuver) {
        manageAdaptiveLayerVisibility('full');
        return null;
    }
    
    if (!navigationMapInstance) {
        return null;
    }
    
    const speed = window.currentSpeedKmh || 0;
    const distanceToManeuver = distanceToNextManeuverOSRM;
    const currentZoom = navigationMapInstance.getZoom();

    switch (currentAutoZoomMode) {
        case 'eco':
        case 'route':
            manageAdaptiveLayerVisibility('road_only');
            
            if (currentAutoZoomMode === 'route') {
                return 14.5;
            } else { // Modo ECO
                const isEcoHighwayCondition = speed > 70 && distanceToManeuver > 2000;
                if (isEcoHighwayCondition) {
                    return 14.5;
                }
                let targetZoomEco;
                if (speed < 30) targetZoomEco = 18.8;
                else if (speed < 50) targetZoomEco = 18.5;
                else if (speed < 80) targetZoomEco = 18;
                else if (speed < 100) targetZoomEco = 17.5;
                else if (speed < 110) targetZoomEco = 17.1;
                else if (speed < 120) targetZoomEco = 16.6;
                else targetZoomEco = 16.3;
                return (Math.abs(currentZoom - targetZoomEco) > 0.1) ? targetZoomEco : null;
            }

        case 'auto':
        case 'off':
        default:
            if (currentZoom < 17.6 || distanceToManeuver < 225) {
                manageAdaptiveLayerVisibility('road_only');
            } else {
                manageAdaptiveLayerVisibility('full');
            }

            // L√≥gica de zoom espec√≠fica para cada modo
            if (currentAutoZoomMode === 'auto') {
                let targetZoom;
                if (speed < 30) targetZoom = 18.7;
                else if (speed < 50) targetZoom = 18.4;
                else if (speed < 80) targetZoom = 18;
                else if (speed < 100) targetZoom = 17.5;
                else if (speed < 110) targetZoom = 17.1;
                else if (speed < 120) targetZoom = 16.6;
                else targetZoom = 16.3;
                return (Math.abs(currentZoom - targetZoom) > 0.1) ? targetZoom : null;
            } else { // Modo OFF
                return manualZoomLevelMemory; 
            }
    }
}    
    
// ===================================================================
// NOMBRE: handleDragStartReorder
// RESUMEN: Inicia el arrastre de una etapa en la lista de reordenamiento.
function handleDragStartReorder(e) {
    draggedStageLi = e.target.closest('li');
    if (draggedStageLi) {
        setTimeout(() => {
            if(draggedStageLi) draggedStageLi.classList.add('dragging');
        }, 0);
    }
}

//===================================================================
// NOMBRE: updateInitialUserPosition (MODIFICADA CON ROTACI√ìN ROBUSTA EN MINIMAPA)
// RESUMEN: Orquestador principal del GPS. Gestiona FPS y la rotaci√≥n del minimapa con fallback.
function updateInitialUserPosition(coords, mapInstanceToUse) {
    if (isRecalculatingRoute || !mapInstanceToUse || !coords) return;

    gpsTickCounter++;

    const minimapUpdatePeriod = performanceRatios.routeProgress * 3;
    
    if (gpsTickCounter === 1 || gpsTickCounter % minimapUpdatePeriod === 0) {
        if (minimapInstance && minimapCarMarker && minimapInstance.isStyleLoaded()) {
            const lngLat = [coords.longitude, coords.latitude];
            const point = minimapInstance.project(lngLat);

            let validatedHeading = null;
            if (coords.heading !== null && typeof coords.heading === 'number' && !isNaN(coords.heading) && coords.heading >= 0) {
                validatedHeading = coords.heading;
            } 
            else if (window.lastPositionForSpeedCalc && typeof turf !== 'undefined' && (window.currentSpeedKmh || 0) > 3) {
                _turfLastPoint.geometry.coordinates[0] = window.lastPositionForSpeedCalc.longitude;
                _turfLastPoint.geometry.coordinates[1] = window.lastPositionForSpeedCalc.latitude;
                _turfCurrentPoint.geometry.coordinates[0] = coords.longitude;
                _turfCurrentPoint.geometry.coordinates[1] = coords.latitude;
                
                if (turf.distance(_turfLastPoint, _turfCurrentPoint, { units: 'meters' }) > 0.5) {
                    const bearing = turf.bearing(_turfLastPoint, _turfCurrentPoint);
                    validatedHeading = (bearing < 0) ? bearing + 360 : bearing;
                }
            }
            
            const rotation = validatedHeading !== null ? validatedHeading - 90 : 0;
            
            minimapCarMarker.style.transform = `translate(-50%, -50%) translate(${point.x}px, ${point.y}px) rotate(${rotation}deg)`;
        }
    }
    
    const speed = (coords.speed || 0) * 3.6;

    if (currentAutoZoomMode === 'eco') {
        const isEcoActive = speed > 70 && distanceToNextManeuverOSRM > 2000;
        if (isEcoActive) {
            MAP_UPDATE_INTERVAL_MS = 1000 / Math.max(5, baseCameraFps - 2); 
            performanceRatios.criticalUpdate = baseCriticalRatio + 2;
        } else {
            MAP_UPDATE_INTERVAL_MS = originalMapUpdateIntervalMs;
            performanceRatios.criticalUpdate = baseCriticalRatio;
        }
    } else {
        const PROXIMITY_THRESHOLD_FPS = 310;
        if (isNavigating && distanceToNextManeuverOSRM < PROXIMITY_THRESHOLD_FPS) {
            MAP_UPDATE_INTERVAL_MS = 1000 / 45;
        } else {
            MAP_UPDATE_INTERVAL_MS = originalMapUpdateIntervalMs;
        }
        performanceRatios.criticalUpdate = baseCriticalRatio;
    }

    const now = performance.now();
    navigationCurrentLocation = { ...coords };
    
    for (const task of TASKS_BY_PRIORITY) { 
        if (now - task.lastRun >= task.getFrequency()) {
            task.handler(coords, mapInstanceToUse);
            task.lastRun = now;
            
            if (task.id !== 'CRITICAL_VISUALS') {
                break;
            }
        }
    }
}    
    
// ===================================================================
// NOMBRE: updateVehicleMarker 
// RESUMEN: Establece los objetivos del icono y LUEGO llama a updateMapCamera.
function updateVehicleMarker(coords, mapInstanceToUse) {
    lastGpsUpdateTime = Date.now();
    const lngLat = new mapboxgl.LngLat(coords.longitude, coords.latitude);
    initialUserLocationMarkerLat = coords.latitude;
    initialUserLocationMarkerLng = coords.longitude;

    let validatedHeading = null;
    
    if (coords.heading !== null && typeof coords.heading === 'number' && !isNaN(coords.heading) && coords.heading >= 0) {
        validatedHeading = coords.heading;
    } else if (window.lastPositionForSpeedCalc && typeof turf !== 'undefined' && (window.currentSpeedKmh || 0) > 5) {
        _turfLastPoint.geometry.coordinates[0] = window.lastPositionForSpeedCalc.longitude;
        _turfLastPoint.geometry.coordinates[1] = window.lastPositionForSpeedCalc.latitude;
        _turfCurrentPoint.geometry.coordinates[0] = coords.longitude;
        _turfCurrentPoint.geometry.coordinates[1] = coords.latitude;
        if (turf.distance(_turfLastPoint, _turfCurrentPoint, { units: 'meters' }) > 1) {
            const bearing = turf.bearing(_turfLastPoint, _turfCurrentPoint);
            validatedHeading = (bearing < 0) ? bearing + 360 : bearing;
        }
    }
    
    if (validatedHeading === null) {
        validatedHeading = (markerAnimationState.currentIconRotation + 90 + 360) % 360; 
    }

    if (!initialUserLocationMarker) {
        vehicleIconElement.style.perspective = '200px';

        initialUserLocationMarker = new mapboxgl.Marker({ 
            element: vehicleIconElement, 
            rotationAlignment: 'map',  anchor: 'bottom'    })
        .setLngLat(lngLat)
        .addTo(mapInstanceToUse);

        const anchorEl = document.createElement('div');
        anchorEl.className = 'ground-anchor-marker ground-anchor-hidden'; // Empieza oculto
        groundAnchorMarker = new mapboxgl.Marker({ 
            element: anchorEl, 
            anchor: 'center' 
        })
        .setLngLat(lngLat)
        .addTo(mapInstanceToUse);
   }
    
    if (!markerAnimationState.currentLngLat) {
        markerAnimationState.currentLngLat = lngLat;
    }
   
    markerAnimationState.targetLngLat = lngLat;
    markerAnimationState.targetIconRotation = validatedHeading - 90; 

    updateMapCamera(coords, mapInstanceToUse);
    
    const now = Date.now();
    if (compassAndModeControl && (now - markerAnimationState.lastCompassUpdateTime > 1800)) {
        compassAndModeControl.updateOrientation(validatedHeading);
        markerAnimationState.lastCompassUpdateTime = now; // Actualizamos el timestamp
    }
} 

// =====================================================================================
//  updateMapCamera
// =====================================================================================
function updateMapCamera(coords, mapInstanceToUse) {
    if (!shouldCenterOnUser && !navigationFollowUser) {
        return;
    }
    
    updateSmoothedGpsAltitude(coords.altitude); 

    const cameraAdjustments = handleProgressiveManeuverZoom(
        navigationCurrentRouteData?.routes?.[0]?.legs?.[currentLegIndexNav]?.steps?.[currentStepIndexNav],
        distanceToNextManeuverOSRM,
        lastCarDistanceAlongRouteForNavLogic
    );

    let targetZoom = cameraAdjustments?.zoom ?? handleAutoZoom();
    if (targetZoom !== null) {
        markerAnimationState.targetMapZoom = targetZoom;
    } else {
        markerAnimationState.targetMapZoom = mapInstanceToUse.getZoom();
    }
    
    let targetPitch = cameraAdjustments?.pitch ?? ((mapViewMode === 'perspective' || mapViewMode === 'relief') ? mapPitchValue : 0);
    
    const isEcoActive = currentAutoZoomMode === 'eco' && (window.currentSpeedKmh || 0) > 70 && distanceToNextManeuverOSRM > 2000;

    if ((currentAutoZoomMode === 'route' || isEcoActive) && !cameraAdjustments) {
        targetPitch = Math.max(4, mapPitchValue - 3);
    }
    
    markerAnimationState.targetMapPitch = targetPitch;

    const targetOffsetX = cameraAdjustments?.offsetX ?? mapOffsetX;
    const targetOffsetY = cameraAdjustments?.offsetY ?? mapOffsetY;
    markerAnimationState.targetMapOffsetX = targetOffsetX;
    markerAnimationState.targetMapOffsetY = targetOffsetY;
    
    let targetBearing = markerAnimationState.currentMapBearing; 
    if (mapViewMode === 'heading' || mapViewMode === 'perspective' || mapViewMode === 'relief') {
        let validatedHeading = null;
        if (coords.heading !== null && typeof coords.heading === 'number' && !isNaN(coords.heading) && coords.heading >= 0) {
            validatedHeading = coords.heading;
        } else if (window.lastPositionForSpeedCalc && typeof turf !== 'undefined' && (window.currentSpeedKmh || 0) > 5) {
            _turfLastPoint.geometry.coordinates[0] = window.lastPositionForSpeedCalc.longitude;
            _turfLastPoint.geometry.coordinates[1] = window.lastPositionForSpeedCalc.latitude;
            _turfCurrentPoint.geometry.coordinates[0] = coords.longitude;
            _turfCurrentPoint.geometry.coordinates[1] = coords.latitude;
            if (turf.distance(_turfLastPoint, _turfCurrentPoint, { units: 'meters' }) > 1) {
                const bearing = turf.bearing(_turfLastPoint, _turfCurrentPoint);
                validatedHeading = (bearing < 0) ? bearing + 360 : bearing;
            }
        }
        if (validatedHeading !== null) {
            targetBearing = validatedHeading;
        }
    } else if (mapViewMode === 'static') {
        targetBearing = 0;
    }
    markerAnimationState.targetMapBearing = targetBearing;
}

// ===================================================================
// NOMBRE: updateTripStatistics 
// RESUMEN: Gestiona estad√≠sticas, aplicando un periodo de gracia para evitar picos de velocidad media.
function updateTripStatistics(coords) {
    if (compassAndModeControl) {
        compassAndModeControl.updateAltitude(coords.altitude);

        if (window.lastPositionForSpeedCalc && typeof coords.speed === 'number' && coords.speed !== null) {
            const distM = calculateDistance(window.lastPositionForSpeedCalc.latitude, window.lastPositionForSpeedCalc.longitude, coords.latitude, coords.longitude);
            const timeS = (Date.now() - window.lastPositionForSpeedCalc.time) / 1000;
            if (timeS > 0 && distM >= 0) {
                let speedMs = coords.speed;
                if (typeof speedMs !== 'number' || speedMs === null || speedMs < 0) { speedMs = distM / timeS; }
                window.currentSpeedKmh = speedMs * 3.6;
            } else { window.currentSpeedKmh = 0; }
        } else {
            if (typeof coords.speed === 'number' && coords.speed !== null && coords.speed >= 0) { window.currentSpeedKmh = coords.speed * 3.6; } else { window.currentSpeedKmh = 0; }
        }
        window.lastPositionForSpeedCalc = { latitude: coords.latitude, longitude: coords.longitude, time: Date.now() };

        const isTripActive = isNavigating || isFreeDriveActive;
        if (isTripActive) {
             if (navigationStartTimeForStats === null && window.currentSpeedKmh > 1 && !isSimulatingGpsLocation) {
                navigationStartTimeForStats = new Date();
             }
             if (lastPositionForStats && navigationStartTimeForStats) {
                if (!automatedSimulationIntervalId) {
                    const distanceMoved = calculateDistance(lastPositionForStats.latitude, lastPositionForStats.longitude, coords.latitude, coords.longitude);
                    totalDistanceTravelledForStats += distanceMoved;
                }
                
                const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000;
                if (timeElapsedS > 5 && totalDistanceTravelledForStats > 20) {
                    window.averageSpeedKmh = (totalDistanceTravelledForStats / timeElapsedS) * 3.6;
                }
             }
            lastPositionForStats = { ...coords };
            
            if (window.currentSpeedKmh > maxSpeedDuringTrip) {
                maxSpeedDuringTrip = window.currentSpeedKmh;
                if (coords) { maxSpeedCoordinates = { lat: coords.latitude, lng: coords.longitude }; }
            }
            if (coords.altitude !== null && !isNaN(coords.altitude)) {
                if (coords.altitude > maxAltitudeDuringTrip) maxAltitudeDuringTrip = coords.altitude;
                if (coords.altitude < minAltitudeDuringTrip) minAltitudeDuringTrip = coords.altitude;
            }
        }
        compassAndModeControl.updateCurrentSpeed(window.currentSpeedKmh);
        compassAndModeControl.updateAverageSpeed(window.averageSpeedKmh);
        compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip);
 
        if (isFreeDriveActive) {
            updateNavigationProgressDisplay(); 
        }
    }
}  
    
// ===================================================================
// NOMBRE: plotIntervalData 
// RESUMEN: A√±ade un punto a la gr√°fica, pero solo si se ha superado el periodo de gracia inicial.
// ===================================================================
function plotIntervalData() {
    if (!isGraphingActive || !(isNavigating || isFreeDriveActive) || !navigationChart || !navigationStartTimeForStats || !navigationCurrentLocation) {
        return;
    }
    
    const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000;

    if (timeElapsedS < 10 || totalDistanceTravelledForStats < 40) {
        return;
    }

    const currentAverageSpeed = window.averageSpeedKmh || 0;
    
    if (currentAverageSpeed > 1) { 
        minAverageSpeedInTrip = Math.min(minAverageSpeedInTrip, currentAverageSpeed);
        maxAverageSpeedInTrip = Math.max(maxAverageSpeedInTrip, currentAverageSpeed);
        
        while (graphLabels.length >= maxGraphPoints) {
            graphLabels.shift();
            graphDataPoints.speed.shift();
            graphDataPoints.altitude.shift();
        }

        const timeLabel = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        graphLabels.push(timeLabel);
        graphDataPoints.speed.push(currentAverageSpeed);
    }
    
    const currentAltitude = navigationCurrentLocation.altitude || 0;
    
    if (graphDataPoints.altitude.length < graphDataPoints.speed.length) {
        graphDataPoints.altitude.push(currentAltitude);
    }
    
    updateChartData();

    const isCurrentlyStopped = (window.currentSpeedKmh || 0) < 1;
    if (isCurrentlyStopped) {
        if (isCarStoppedForGraph) return; 
        isCarStoppedForGraph = true;
    } else {
        isCarStoppedForGraph = false;
    }
}   
    
// ===================================================================
// NOMBRE: processRouteProgress 
// RESUMEN: Elimina el umbral de pre-vigilancia. La alerta se activa
function processRouteProgress(coords, mapInstanceToUse) {
    if (!isNavigating || !navigationCurrentRouteData?.routes?.[0]?._turfLineString || !coords) {
        return;
    }
    const route = navigationCurrentRouteData.routes[0];
    const fullRouteLineString = route._turfLineString; 
    
    let carDistCalculated = 0;

    try {
        _turfCurrentPoint.geometry.coordinates[0] = coords.longitude;
        _turfCurrentPoint.geometry.coordinates[1] = coords.latitude;
        const nearestPointOnRoute = turf.nearestPointOnLine(fullRouteLineString, _turfCurrentPoint, { units: 'meters' });
        carDistCalculated = nearestPointOnRoute.properties.location;
    } catch (e) {
        try { 
            _turfCurrentPoint.geometry.coordinates[0] = coords.longitude;
            _turfCurrentPoint.geometry.coordinates[1] = coords.latitude;
            const carPointTurf = _turfCurrentPoint;
            const routeLineStringTurf = fullRouteLineString;
            const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
            const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
            carDistCalculated = turf.length(lineSliceToNearestTurf, { units: 'meters' });
        } catch (turfError) {
            carDistCalculated = lastCarDistanceAlongRouteForNavLogic;
        }
    }
    
    const totalRouteLength = route.distance;
    if (carDistCalculated >= 0 && carDistCalculated <= totalRouteLength + 500) {
        if (carDistCalculated > lastCarDistanceAlongRouteForNavLogic - 100) {
             lastCarDistanceAlongRouteForNavLogic = carDistCalculated;
        }
    } else if (carDistCalculated > totalRouteLength + 500) {
        lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
    }

    if (currentLegIndexNav > previousLegIndexForEta) {
        const newLeg = route.legs[currentLegIndexNav];
        if (newLeg && typeof newLeg.duration === 'number') {
            currentStageInitialExpectedEtaTime = new Date(Date.now() + newLeg.duration * 1000);
            
            previousLegIndexForEta = currentLegIndexNav;
        }
    }
   
    if (distanceToNextManeuverOSRM > 200) {
        if (eventosEnRuta.length > 0 && proximoEventoEnRutaIndex < eventosEnRuta.length) {
            const proximoEvento = eventosEnRuta[proximoEventoEnRutaIndex];
            const distanciaAlEvento = proximoEvento.distanceOnRoute - lastCarDistanceAlongRouteForNavLogic;
            
            const radioDelEvento = proximoEvento.radiusMeters || DEFAULT_LOCATION_RADIUS;

            if (distanciaAlEvento <= radioDelEvento) {
                
                const dueTime = proximoEvento.dueTimeUTC;
                const now = Date.now();
                
                if ((!dueTime || dueTime <= now) && !proximoEvento.managedByUser) {
                    displayUnifiedReminderWindow([proximoEvento]);
                }
            }
            
            if (distanciaAlEvento < 0) {
                proximoEventoEnRutaIndex++; 
            }
        }
    }
   
    checkAndMarkWaypointsAsVisited(route, lastCarDistanceAlongRouteForNavLogic, coords);
    renderWaypointMarkers();
    updateTurnByTurnDisplay(route, lastCarDistanceAlongRouteForNavLogic);
    updateNavigationProgressDisplay(route, lastCarDistanceAlongRouteForNavLogic);
}
    
// ===================================================================
// NOMBRE: startGpsWatching 
// RESUMEN: Inicia el seguimiento GPS. Incluye tanto la l√≥gica de inicio autom√°tico
function startGpsWatching() {
    if (gpsRetryTimeoutId) {
        clearTimeout(gpsRetryTimeoutId);
        gpsRetryTimeoutId = null;
    }
    if (locationWatchId !== null) {
        return;
    }

    if (gpsRetryAttempt >= MAX_GPS_RETRIES) {
        showToast("Error persistente: No se pudo conectar al GPS. Revisa los permisos del dispositivo.", "error", 0, false, "gps-persistent-error");
        return;
    }
    gpsRetryAttempt++;
    
    locationWatchId = navigator.geolocation.watchPosition(
        (position) => {
            gpsHzMonitor.ticks++; 
            
            if (isSimulatingGpsLocation) return;

            const persistentErrorToast = document.getElementById("gps-persistent-error");
            if (persistentErrorToast) persistentErrorToast.remove();
            gpsRetryAttempt = 0;
            
            const coordsForUpdate = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                heading: position.coords.heading,
                speed: position.coords.speed,
                altitude: position.coords.altitude
            };

            updateInitialUserPosition(coordsForUpdate, navigationMapInstance);

            if (!isNavigating && navigationWaypoints.length >= 2) {
                const isRouteDataFullyAvailable = navigationCurrentRouteData &&
                                                navigationCurrentRouteData.routes &&
                                                navigationCurrentRouteData.routes[0] &&
                                                navigationCurrentRouteData.routes[0].geometry &&
                                                navigationCurrentRouteData.routes[0].geometry.coordinates.length > 1;

                if (isRouteDataFullyAvailable) {
                    const startPoint = navigationWaypoints[0];
                    const distanceFromStart = calculateDistance(startPoint.lat, startPoint.lng, coordsForUpdate.latitude, coordsForUpdate.longitude);
                    const START_TRIGGER_DISTANCE = 50;  
                    const RELEVANCE_DISTANCE = 200; 

                    const isRouteCompleted = navigationWaypoints[navigationWaypoints.length - 1]?.visited === true;

                    if (!isRouteCompleted && distanceFromStart > START_TRIGGER_DISTANCE && distanceFromStart < RELEVANCE_DISTANCE) {
                        toggleNavigationState(); 
                        return; 
                    }
                }
            }
            
            if (!isNavigating && !isFreeDriveActive && navigationWaypoints.length === 0) {
                if (Date.now() < autoStartFreeDriveDisabledUntil) {
                    return;
                }
                
                const speedKmh = position.coords.speed ? (position.coords.speed * 3.6) : 0;
                const SPEED_TRIGGER_KMH = 20;

                if (speedKmh > SPEED_TRIGGER_KMH) {
                    startFreeDrive(coordsForUpdate);
                    return; 
                }
            }
           },
        (error) => {
            if (locationWatchId !== null) {
                navigator.geolocation.clearWatch(locationWatchId);
                locationWatchId = null;
            }
            gpsRetryTimeoutId = setTimeout(startGpsWatching, GPS_RETRY_DELAY_MS);
        },
        { enableHighAccuracy: true, timeout: 15000, maximumAge: 2000, distanceFilter: 3 }
    );
}
    
// ===================================================================
// NOMBRE: processSimulatedGpsPosition 
// RESUMEN: Procesa la posici√≥n GPS simulada, actualiza las estad√≠sticas
function processSimulatedGpsPosition(forceExactPosition = false) {
    if (!isSimulatingGpsLocation || !simulatedGpsLocation) return;
    navigationCurrentLocation = { ...simulatedGpsLocation };

    const isTripActive = isNavigating || isFreeDriveActive;
    if (isTripActive && lastPositionForStats) {
        const distanceMovedSinceLastPoint = calculateDistance(lastPositionForStats.latitude, lastPositionForStats.longitude, navigationCurrentLocation.latitude, navigationCurrentLocation.longitude);
        
        if (navigationStartTimeForStats === null && distanceMovedSinceLastPoint > 1) {
            navigationStartTimeForStats = new Date();
            showToast("Viaje simulado iniciado. Registrando estad√≠sticas.", "success");
        }

        if (navigationStartTimeForStats !== null) {
            totalDistanceTravelledForStats += distanceMovedSinceLastPoint;
            const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000;
            if (timeElapsedS > 0) {
                window.averageSpeedKmh = (totalDistanceTravelledForStats / timeElapsedS) * 3.6;
            }
        }
        lastPositionForStats = { ...navigationCurrentLocation };
    }
    
    updateInitialUserPosition(navigationCurrentLocation, navigationMapInstance);

    if (!automatedSimulationIntervalId) { 
        showToast(`Posici√≥n GPS simulada: ${simulatedGpsLocation.latitude.toFixed(4)}, ${simulatedGpsLocation.longitude.toFixed(4)}`, "info");
    }
}   
   
// ===================================================================
// NOMBRE: createAndLoadReturnTrip 
// RESUMEN: Se corrige el bug de numeraci√≥n y estado persistente.
async function createAndLoadReturnTrip() {
    if (!navigationWaypoints || navigationWaypoints.length < 2) {
        showToast("No hay una ruta completa para invertir.", "warning");
        return;
    }

    showToast("Preparando ruta de vuelta...", "info", 2000);

    try {
        const originalWaypointsForReturn = navigationWaypoints
            .filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart)
            .map(wp => ({ lat: wp.lat, lng: wp.lng, address: wp.address }));

        handleLoadOrDeleteRouteClick(null);

        await new Promise(resolve => setTimeout(resolve, 50));
        
        const currentPos = await getCurrentLocationAsync();
        
        const originalStart = originalWaypointsForReturn.shift(); // Este era 'S', ahora ser√° el nuevo 'F'.
        if (originalWaypointsForReturn.length > 0) {
            originalWaypointsForReturn.pop(); // Eliminamos el 'F' original.
        }
        const intermediateReversed = originalWaypointsForReturn.reverse();

        let returnWaypointsData = [
            { lat: currentPos.latitude, lng: currentPos.longitude, address: 'Posici√≥n Actual (GPS)' },
            ...intermediateReversed,
            originalStart 
        ];

        const returnRouteObject = {
            name: `VUELTA: ${originalStart.address || 'Ruta Original'}`,
            waypoints: returnWaypointsData
        };

        loadRouteFromObject(returnRouteObject, true);
        addRouteToRecents(returnRouteObject);

    } catch (error) {
        showToast(`Error al crear ruta de vuelta: ${error.message}`, "error");
    }
}

// ===================================================================
// NOMBRE: fetchRouteData 
// RESUMEN: Incluye reintentos, solicitud de indicaciones detalladas y
async function fetchRouteData(coordsString, startHeading = null) {
    const OSRM_PRIMARY_KEY = 'boardinggate_useOsrmAsPrimary';
    const useOsrmAsPrimary = localStorage.getItem(OSRM_PRIMARY_KEY) === 'true';
  
    const osrmService = {
        name: 'OSRM',
        buildUrl: (coords) => {
            return `${OSRM_SERVICE_URL}/driving/${coords}?overview=full&geometries=geojson&steps=true&alternatives=false&annotations=true`;
        },
        processResponse: async (response) => {
            if (!response.ok) {
                let errorData = { message: `OSRM HTTP error ${response.status}` };
                try { errorData = await response.json(); } catch (e) {}
                throw new Error(errorData.code || errorData.message || response.statusText);
            }
            const data = await response.json();
            if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) {
                throw new Error(data.message || "No se encontraron rutas en OSRM.");
            }
            console.log('%c[Route Service] Respuesta OSRM (Completa)', 'color: #28a745; font-weight: bold;');
            return { routeData: data, serviceUsed: 'OSRM' };
        }
    };

    const mapboxService = {
        name: 'Mapbox',
        buildUrl: (coords) => {
            const accessToken = window.APP_CONFIG.keys.mapbox;
            const params = new URLSearchParams({
                alternatives: 'false',
                geometries: 'geojson',
                overview: 'full',
                steps: 'true',
                banner_instructions: 'true',
                voice_instructions: 'true', 
                language: 'es',
                access_token: accessToken
            });
            return `https://api.mapbox.com/directions/v5/mapbox/driving/${coords}?${params.toString()}`
        },
        processResponse: async (response) => {
            if (!response.ok) {
                let errorData = { message: `Mapbox HTTP error ${response.status}` };
                try { errorData = await response.json(); } catch (e) {}
                throw new Error(errorData.message || response.statusText);
            }
            const data = await response.json();
            if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) {
                throw new Error(data.message || "No se encontraron rutas en Mapbox.");
            }

            const hasBanners = data.routes[0]?.legs?.[0]?.steps?.some(step => step.bannerInstructions);
            const statusMessage = hasBanners ? 'COMPLETA (con Banners)' : 'SIMPLE (sin Banners)';
            const logStyle = hasBanners ? 'color: #28a745; font-weight: bold;' : 'color: #ffc107; font-weight: bold;';
            console.log(`%c[Route Service] Respuesta Mapbox: ${statusMessage}`, logStyle);
  
            const adaptedRoute = adaptMapboxRouteToOSRMFormat(data.routes[0]);
            const adaptedWaypoints = data.waypoints.map(wp => ({
                distance: wp.distance,
                hint: wp.hint,
                location: wp.location,
                name: wp.name,
            }));
            const finalData = {
                code: 'Ok',
                routes: [adaptedRoute],
                waypoints: adaptedWaypoints
            };
            return { routeData: finalData, serviceUsed: 'Mapbox' };
        }
    };

    const buildUrlWithCorrectBearings = (service, coords) => {
        let baseUrl = service.buildUrl(coords).split('?')[0];
        let params = new URLSearchParams(service.buildUrl(coords).split('?')[1] || '');

        if (startHeading !== null && !isNaN(startHeading)) {
            const waypointCount = (coords.match(/;/g) || []).length + 1;
            let bearingsString = `${Math.round(startHeading)},45`;
            if (waypointCount > 1) {
                bearingsString += ';'.repeat(waypointCount - 1);
            }
            params.set('bearings', bearingsString);
        } else {
            params.delete('bearings'); 
        }
        
        return `${baseUrl}?${params.toString()}`;
    };

    const primaryService = useOsrmAsPrimary ? osrmService : mapboxService;
    const fallbackService = useOsrmAsPrimary ? mapboxService : osrmService;
    
    const MAX_PRIMARY_RETRIES = 5;

    for (let attempt = 1; attempt <= MAX_PRIMARY_RETRIES; attempt++) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 segundos de timeout
  
        try {
            const primaryUrl = buildUrlWithCorrectBearings(primaryService, coordsString);
            
            const primaryResponse = await fetch(primaryUrl, { signal: controller.signal });
            clearTimeout(timeoutId); // Si la petici√≥n tiene √©xito, cancelamos el timeout
          
            return await primaryService.processResponse(primaryResponse);
        } catch (primaryError) {
            clearTimeout(timeoutId); // Asegurarse de limpiar el timeout tambi√©n en caso de error
            console.warn(`[Route Fetch] Fallo en intento #${attempt} con ${primaryService.name}:`, primaryError.name === 'AbortError' ? 'Timeout de 5s alcanzado' : primaryError);

            if (attempt === MAX_PRIMARY_RETRIES) {
                console.log(`%c[Route Service] ${primaryService.name} fall√≥ ${MAX_PRIMARY_RETRIES} veces. Usando FALLBACK: ${fallbackService.name}...`, 'color: #dc3545; font-weight: bold;');
                showToast(`${primaryService.name} fall√≥. Probando con ${fallbackService.name}...`, "warning", 5000);
                break;
            } else {
                await new Promise(resolve => setTimeout(resolve, 600));
            }
        }
    }
    
    try {
        const fallbackUrl = buildUrlWithCorrectBearings(fallbackService, coordsString);
        const fallbackResponse = await fetch(fallbackUrl);
        const fallbackData = await fallbackService.processResponse(fallbackResponse);
        fallbackData.serviceUsed += ' (Respaldo)';
        return fallbackData;
    } catch (fallbackError) {
        return { error: fallbackError, failedServices: `${primaryService.name} (Fallo), ${fallbackService.name} (Fallo)` };
    }
}    
    
// ===================================================================
// NOMBRE: adaptMapboxRouteToOSRMFormat (VERSI√ìN CORREGIDA CON N√öMERO DE SALIDA)
// RESUMEN: Convierte la respuesta de Mapbox al formato OSRM, asegur√°ndose de
function adaptMapboxRouteToOSRMFormat(mapboxRoute) {
    const adaptedLegs = mapboxRoute.legs.map(leg => {
        const adaptedSteps = leg.steps.map(step => {
            return {
                distance: step.distance,
                duration: step.duration,
                geometry: step.geometry,
                maneuver: {
                    bearing_after: step.maneuver.bearing_after,
                    bearing_before: step.maneuver.bearing_before,
                    location: step.maneuver.location,
                    modifier: step.maneuver.modifier,
                    type: step.maneuver.type,
                    exit: step.maneuver.exit // <-- ¬°ESTA ES LA L√çNEA CLAVE A√ëADIDA!
                },
                name: step.name,
                bannerInstructions: step.bannerInstructions || null
            };
        });
        return {
            distance: leg.distance,
            duration: leg.duration,
            steps: adaptedSteps,
            summary: leg.summary,
        };
    });
    return {
        distance: mapboxRoute.distance,
        duration: mapboxRoute.duration,
        geometry: mapboxRoute.geometry,
        legs: adaptedLegs,
    };
}  

// ===================================================================
// NOMBRE: openNavigationMap (VERSI√ìN FINAL CON GESTI√ìN DE ARRASTRE ROBUSTA)
// RESUMEN: Abre el mapa. Gestiona la pulsaci√≥n larga cancel√°ndola si se detecta un inicio de arrastre, zoom o inclinaci√≥n.
async function openNavigationMap(isRecovery = false) {
    return new Promise(async (resolve, reject) => {
        const { primaryId: userId } = parseUserId(localStorage.getItem('userData_userId'));
        
        if (userId && userId.toLowerCase() !== 'boardinggate') {
            try {
                const adminDocRef = window.doc(window.db, "user_data", "boardinggate");
                const userDocRef = window.doc(window.db, "user_data", userId);
                const [adminSnap, userSnap] = await Promise.all([window.getDoc(adminDocRef), window.getDoc(userDocRef)]);
                if (userSnap.exists() && userSnap.data().mapAccessEnabled === false) {
                    showToast("ACCESO DENEGADO A MAPAS TEMPORALMENTE. Contacte con el administrador v√≠a chat", "error", 5000);
                    reject(new Error("Acceso denegado"));
                    return;
                }
                let maxSessions = Infinity;
                if (adminSnap.exists() && typeof adminSnap.data().max_monthly_sessions === 'number') {
                    maxSessions = adminSnap.data().max_monthly_sessions;
                }
                let userMonthlyCount = 0;
                if (userSnap.exists()) {
                    const userData = userSnap.data();
                    const now = new Date();
                    const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
                    if (userData.map_sessions_last_month === currentMonthStr) {
                        userMonthlyCount = userData.map_sessions_month || 0;
                    }
                }
                if (userMonthlyCount >= maxSessions) {
                    showToast("HA SUPERADO EL N√öMERO M√ÅXIMO DE SESIONES MENSUALES DE MAPA, consulte con el administrador v√≠a chat", "error", 10000);
                    reject(new Error("L√≠mite de sesiones alcanzado"));
                    return;
                }
            } catch (error) {
                console.warn("No se pudo verificar el l√≠mite de sesiones de mapa:", error.message);
            }
        }
                               
        const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'none';
        const footer = document.querySelector('footer'); if (footer) footer.style.display = 'none';
        const noticesContainer = document.querySelector('.notices-icon-container'); if (noticesContainer) noticesContainer.style.display = 'none';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'none');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button, #accident-alert-button').forEach(el => el.style.display = 'none');
        const gridFilter = document.getElementById('grid-filter-container'); if (gridFilter) gridFilter.style.display = 'none';

        isNavigationMapActive = true;
        sessionStorage.setItem('mapContext', 'navigation');
        closeOtherModals('reminders-location-map-modal');
        
        const mapModal = document.getElementById('reminders-location-map-modal');
        if (!mapModal) { console.error("Error cr√≠tico: El modal del mapa no se encuentra en el HTML."); isNavigationMapActive = false; reject(new Error("Modal no encontrado")); return; }
        
        mapModal.classList.remove('map-modal-hidden');
        const mapActualContainer = document.getElementById('mapbox-map-actual-container');
        
        const minimapTriggerButton = document.getElementById('force-show-minimap-button');
        if (minimapTriggerButton && !minimapTriggerButton.listenerAdded) {
            minimapTriggerButton.addEventListener('click', (e) => {
                e.stopPropagation();
                if (showRouteMinimapPreference) {
                    minimapForceShowUntil = Date.now() + 30000;
                    updateTurnByTurnDisplay(navigationCurrentRouteData?.routes?.[0], lastCarDistanceAlongRouteForNavLogic);
                }
            });
            minimapTriggerButton.listenerAdded = true;
        }
     
        const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresCheckbox) { radaresCheckbox.checked = localStorage.getItem(RADARES_RUTA_CHECKED_KEY) === 'true'; }
        const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasCheckbox) { tareasCheckbox.checked = localStorage.getItem(TAREAS_RUTA_CHECKED_KEY) === 'true'; }
        const mapboxCheckbox = document.getElementById('mapbox-primary-checkbox');
        if (mapboxCheckbox) { mapboxCheckbox.checked = localStorage.getItem('boardinggate_useMapboxAsPrimary') === 'true'; }
        
        if (navigationMapInstance) {
            handleLoadOrDeleteRouteClick(null);
            setNavigationMapClickHandler();
            setTimeout(() => { if (navigationMapInstance) navigationMapInstance.resize(); }, 520);
            resolve();
        } else {
            try {
                const STREET_MAP_THEME_KEY = 'boardinggate_streetMapTheme';
                let savedLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "H√çBRIDO";

                let initialStyle;
                if (savedLayerName === "CALLES") {
                    const streetTheme = localStorage.getItem(STREET_MAP_THEME_KEY) || 'dark';
                    initialStyle = (streetTheme === 'light') ? MAP_STYLES.CALLES_LIGHT : MAP_STYLES.CALLES_DARK;
                } else {
                    const finalLayerName = MAP_LEGACY_NAME_MAP[savedLayerName] || savedLayerName;
                    initialStyle = MAP_STYLES[finalLayerName] || MAP_STYLES["H√çBRIDO"];
                }
                               
                if (!isRecovery) { showToast("INICIALIZANDO MAPA...", "info", 0, false, "map-init-toast"); }
      
                navigationMapInstance = new mapboxgl.Map({
                    container: mapActualContainer,
                    style: initialStyle, 
                    center: [ -97.1903, 30.3715],
                    zoom: 2.8, pitch: 0, bearing: 0,
                    attributionControl: false, 
                    pixelRatio: window.devicePixelRatio || 1,
                    maxTileCacheSize: 50,
                    antialias: false,
                    preserveDrawingBuffer: true,
                    accessToken: mapboxgl.accessToken,
                    minzoom: 2,
                    maxzoom: 19
                });

                if (!isRecovery) { setMapImmersiveMode(true); }
                
                incrementMapSessionCount();
                mapSessionStartTime = Date.now();
                
                const customControls = new CustomMapControlsGroup();
                window.mapCustomControlsInstance = customControls; 
                navigationMapInstance.addControl(customControls, 'bottom-right');
                
                compassAndModeControl = new CompassAndStatsControl();
                navigationMapInstance.addControl(compassAndModeControl, 'bottom-left');
                
                if (!navigationMapInstance._interactionListenersAttached) {
                    const mapCanvas = navigationMapInstance.getCanvasContainer();
                    let touchStartPos = null, hasMovedEnoughToDrag = false;
                    const DRAG_THRESHOLD = 10; 
                    const onTouchStart = (e) => { if (e.touches && e.touches.length > 1) { handleManualMapInteraction(); return; } const touch = e.touches ? e.touches[0] : e; touchStartPos = { x: touch.clientX, y: touch.clientY }; hasMovedEnoughToDrag = false; };
                    const onTouchMove = (e) => { if (hasMovedEnoughToDrag || !touchStartPos || (e.touches && e.touches.length > 1)) return; const touch = e.touches ? e.touches[0] : e; const deltaX = Math.abs(touch.clientX - touchStartPos.x); const deltaY = Math.abs(touch.clientY - touchStartPos.y); if (deltaX > DRAG_THRESHOLD || deltaY > DRAG_THRESHOLD) { hasMovedEnoughToDrag = true; handleManualMapInteraction(); } };
                    const onTouchEnd = () => { touchStartPos = null; hasMovedEnoughToDrag = false; };
                    mapCanvas.addEventListener('touchstart', onTouchStart, { passive: true });
                    mapCanvas.addEventListener('touchmove', onTouchMove, { passive: true });
                    mapCanvas.addEventListener('touchend', onTouchEnd, { passive: true });
                    navigationMapInstance.on('pitchend', (e) => { if (e.originalEvent) { const newPitch = navigationMapInstance.getPitch(); if (Math.abs(newPitch - mapPitchValue) > 0.1) { mapPitchValue = newPitch; saveSettings(); } } });
                    navigationMapInstance._interactionListenersAttached = true; 
                }

                navigationMapInstance.on('error', (e) => { if (e.error && e.error.message.includes("Token")) { showToast("Error de Token de Mapbox...", "error", 10000); } });
                
                navigationMapInstance.on('load', async function() {
                    try {
                        await wait(300);

                        let longPressTimer = null;
                        const LONG_PRESS_DURATION = 500;

                        const clearLongPressTimer = () => {
                            if (longPressTimer) {
                                clearTimeout(longPressTimer);
                                longPressTimer = null;
                            }
                        };
                        
                        // 1. Al presionar, iniciamos el temporizador para la pulsaci√≥n larga.
                        const handlePressStart = (e) => {
                            if (isAddReminderAtLocationModeActive || isSimulatingGpsLocation) {
                                return;
                            }
                            clearLongPressTimer();
                            longPressTimer = setTimeout(() => {
                                addWaypoint(e.lngLat);
                                longPressTimer = null; 
                            }, LONG_PRESS_DURATION);
                        };

                        navigationMapInstance.on('mousedown', handlePressStart);
                        navigationMapInstance.on('touchstart', handlePressStart);

                        // 2. Si el mapa detecta el inicio de un arrastre, zoom o inclinaci√≥n, CANCELAMOS el temporizador.
                        navigationMapInstance.on('dragstart', clearLongPressTimer);
                        navigationMapInstance.on('zoomstart', clearLongPressTimer);
                        navigationMapInstance.on('pitchstart', clearLongPressTimer);

                        // 3. Al soltar, tambi√©n cancelamos. El evento 'click' se encargar√° del resto si fue un toque corto.
                        navigationMapInstance.on('mouseup', clearLongPressTimer);
                        navigationMapInstance.on('touchend', clearLongPressTimer);
                        
                        navigationMapInstance.on('click', async (e) => {
                            if (isAddReminderAtLocationModeActive) { handleMapClickToAddReminder(e); return; } 
                            if (isSimulatingGpsLocation) { handleSimulateGpsPositionClick(e); return; } 
                            
                            const point = e.point; 
                            const pdrLayers = ['pdr-simple-circle-layer', 'pdr-cards-layer-bg-halo', 'pdr-cards-layer-bg']; 
                            const pdrFeatures = navigationMapInstance.queryRenderedFeatures(point, { layers: pdrLayers }); 
                            if (pdrFeatures.length > 0) { const fullPdrData = window.lastOcmApiResponse.find(p => p.ID === pdrFeatures[0].properties.ocmId); if (fullPdrData) { showChargingPointModal(fullPdrData, pdrFeatures[0].properties.index); } return; } 
                            const alertLayers = ['traffic-alerts-layer']; 
                            const alertFeatures = navigationMapInstance.queryRenderedFeatures(point, { layers: alertLayers }); 
                            if (alertFeatures.length > 0) { const alertDetailsMap = { 1: 'Accidente de tr√°fico', 2: 'Coche averiado', 3: 'Control de tr√°fico / Radar', 4: 'Atasco', 5: 'Peligro indeterminado', 6: 'Carretera en mal estado', 7: 'Obras', 8: 'V√≠a / Carretera cerrada' }; showToast(alertDetailsMap[alertFeatures[0].properties.code] || 'Alerta de tr√°fico', 'warning', 4000); return; } 
                            const reminderLayers = ['reminders-icons-layer', 'radar-circles-layer']; 
                            const reminderFeatures = navigationMapInstance.queryRenderedFeatures(point, { layers: reminderLayers }); 
                            if (reminderFeatures.length > 0) { showReminderActionModal(reminderFeatures[0].properties.reminderId); return; } 
                            const mapboxPoiLayers = ['poi-label']; 
                            const features = navigationMapInstance.queryRenderedFeatures(point, { layers: mapboxPoiLayers }); 
                            const validPoiFeature = features.find(f => f.properties && (f.properties.name || f.properties.name_en || f.properties.text)); 
                            if (validPoiFeature) { const { name, name_en, text, poi_category, category, maki } = validPoiFeature.properties; const poiName = name || name_en || text; let categories = []; if (poi_category && Array.isArray(poi_category)) { categories = poi_category; } else if (category) { categories = category.split(',').map(c => c.trim()); } else if (maki) { categories.push(maki); } showPoiInfoModal({ properties: { name: poiName, categories: categories }, geometry: validPoiFeature.geometry }); }
                        });
                        
                        const lockButton = document.getElementById('toggle-progress-bar-lock'); if (lockButton && !lockButton.dataset.listenerAttached) { lockButton.addEventListener('click', (e) => { e.stopPropagation(); handleProgressBarLockToggle(); }); lockButton.dataset.listenerAttached = 'true'; } updateProgressBarLockIcon();
                        const topInfoBar = document.getElementById('navigation-top-info-bar'); if (topInfoBar && !topInfoBar.dataset.listenerAttached) { topInfoBar.addEventListener('click', (e) => { e.stopPropagation(); if (nextManeuverStepForPreview && navigationCurrentRouteData?.routes?.[0]) { showIntersectionPreviewMap(nextManeuverStepForPreview, navigationCurrentRouteData.routes[0], true, 10000); } else { showToast("No hay una pr√≥xima maniobra que mostrar.", "info"); } }); topInfoBar.dataset.listenerAttached = 'true'; }
                        const initToast = document.getElementById("map-init-toast"); if (initToast) initToast.remove();
                        
                        await loadAndAddMapImages(navigationMapInstance);
                        await configureMapAtmosphere();
                        
                        await new Promise(resolve => navigationMapInstance.once('idle', resolve));
                        await add3DBuildingsLayer(navigationMapInstance);
                        
                        await wait(300);
                        
                        reAddCustomMapLayersAndSources(navigationMapInstance); 
                        applyLayerVisibility(); 
                        plotRemindersOnNavigationMap();
                        
                        await wait(100);

                        await processTrafficAlerts(); 
                        if (alertRefreshInterval) clearInterval(alertRefreshInterval); 
                        alertRefreshInterval = setInterval(processTrafficAlerts, ALERT_CHECK_INTERVAL);

                        navigationMapInstance.on('pitch', updateVehicleIconPerspective); 
                        mapPreviousZoomLevelForPDRs = navigationMapInstance.getZoom(); 
                        navigationMapInstance.on('zoomend', updateAllIconSizes); 
                        toggleMapHeaderRowsVisibility(mapHeaderButtonsVisible);
                        
                        enablePoiInteractivity(navigationMapInstance); 
                        setNavigationMapClickHandler();
                        
                        let currentPos = await getInitialGpsPositionForMap();
                        
                        startWeatherUpdates(currentPos); 
                        
                        setMapImmersiveMode(false); 
                        navigationFollowUser = true; 
                        shouldCenterOnUser = true; 
                        updateLocateMeButtonsUI(); 
                        toggleMapControls(true); 
                        navigationCurrentLocation = currentPos;
                        const initialViewOptions = { center: [currentPos.longitude, currentPos.latitude], zoom: 15.5, essential: true };
                        const mode = mapViewMode; if (mode === 'heading' || mode === 'perspective' || mode === 'relief') { initialViewOptions.bearing = currentPos.heading || 0; } if (mode === 'perspective' || mode === 'relief') { initialViewOptions.pitch = mapPitchValue; } else { initialViewOptions.pitch = 0; }
                        initialViewOptions.pitch = 0;
                        if (!isRecovery) { const globeSpinPromise = new Promise(resolve => { const startCoords = { lat: 30.3715, lng: -97.1903 }; const endCoords = { lat: 40.3748, lng: -3.7354 }; const duration = 1800; const totalLngChange = -(360 - (endCoords.lng - startCoords.lng)); const totalLatChange = endCoords.lat - startCoords.lat; const startTimestamp = performance.now(); function animateSpin(timestamp) { const progress = Math.min((timestamp - startTimestamp) / duration, 1); const easedProgress = 1 - Math.pow(1 - progress, 3); navigationMapInstance.setCenter([startCoords.lng + (totalLngChange * easedProgress), startCoords.lat + (totalLatChange * easedProgress)]); if (progress < 1) { requestAnimationFrame(animateSpin); } else { navigationMapInstance.setCenter([endCoords.lng, endCoords.lat]); resolve(); } } requestAnimationFrame(animateSpin); }); await globeSpinPromise; navigationMapInstance.jumpTo(initialViewOptions); } else { navigationMapInstance.jumpTo(initialViewOptions); }
                        markerAnimationState.currentMapCenter = navigationMapInstance.getCenter(); markerAnimationState.currentMapZoom = navigationMapInstance.getZoom(); markerAnimationState.currentMapPitch = navigationMapInstance.getPitch(); markerAnimationState.currentMapBearing = navigationMapInstance.getBearing(); markerAnimationState.targetMapCenter = navigationMapInstance.getCenter(); markerAnimationState.targetMapZoom = navigationMapInstance.getZoom(); markerAnimationState.targetMapPitch = navigationMapInstance.getPitch(); markerAnimationState.targetMapBearing = navigationMapInstance.getBearing();
                        
                        updateInitialUserPosition(currentPos, navigationMapInstance); 
                        startGpsWatching();               
                        resolve();

                    } catch (loadError) { 
                        const overlay = document.getElementById('route-recovery-overlay'); if (overlay) overlay.classList.add('hidden');
                        showToast(`Error cr√≠tico al cargar los recursos del mapa: ${loadError.message}`, "error", 10000); 
                        reject(loadError); 
                    }
                });
                navigationMapInstance.on('pitch', updateVehicleIconPerspective);
            } catch (initError) { 
                const overlay = document.getElementById('route-recovery-overlay'); if (overlay) overlay.classList.add('hidden');
                if (mapActualContainer) mapActualContainer.innerHTML = `<div style="color:red; text-align:center; padding:20px;"><h2>Error al cargar el mapa</h2><p>${initError.message}</p></div>`; 
                isNavigationMapActive = false; 
                reject(initError); 
            }
        }
    }); 
}

//===================================================================
// NOMBRE: updateTurnByTurnDisplay 
// RESUMEN: Gestiona la visibilidad de la UI de navegaci√≥n, incluyendo ahora el widget del tiempo.
//===================================================================
function updateTurnByTurnDisplay(route, carDistanceAlongTheRoute = 0) {
    const topInfoBar = document.getElementById('navigation-top-info-bar');
    const intersectionPreviewWindow = document.getElementById('intersection-preview-map-window');
    const miniNavCard = document.getElementById('mini-nav-info-card'); 
    const progressBar = document.getElementById('navigation-bottom-progress-bar');
    const compassControl = document.querySelector('.mapboxgl-ctrl-bottom-left'); 
    const maneuverCounterEl = document.getElementById('maneuver-counter-display');
    const minimapContainer = document.getElementById('minimap-container');
    const showMinimapButton = document.getElementById('force-show-minimap-button');
    const weatherWidget = document.getElementById('weather-widget-container'); 
   
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    const totalStages = actualWaypoints.length > 1 ? actualWaypoints.length - 1 : 1;

    const isAutoStartModalVisible = !!document.getElementById('auto-start-nav-modal');
    if (!route || !topInfoBar || !route.legs || route.legs.length === 0 || !progressBar || !maneuverCounterEl || (!isNavigating && !isAutoStartModalVisible && (!navigationCurrentRouteData || actualWaypoints.length < 2))) {
        if (topInfoBar) topInfoBar.style.display = 'none';
        if (miniNavCard) miniNavCard.style.display = 'none'; 
        if (minimapContainer) minimapContainer.classList.add('hidden');
        if (showMinimapButton) showMinimapButton.classList.add('hidden');
        if (progressBar) progressBar.classList.remove('scaled-for-maneuver');
        if (compassControl) compassControl.classList.remove('hidden-for-maneuver');
        if (weatherWidget) weatherWidget.classList.remove('hidden'); 
        if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
        if (maneuverCounterEl) maneuverCounterEl.style.display = 'none';
        nextManeuverStepForPreview = null;
        return;
    }  

    const cleanManeuvers = route._cleanSteps || [];
    const carDistance = Math.min(Math.max(0, carDistanceAlongTheRoute), route.distance);
    let maneuversPassed = 0;
    for (const cleanStep of cleanManeuvers) { if ((cleanStep.cumulativeDistance + cleanStep.distance) < carDistance) { maneuversPassed++; } else { break; } }
    const totalIntermediateActions = Math.max(0, cleanManeuvers.length - 2);
    const passedIntermediateActions = Math.max(0, maneuversPassed - 1);
    const actionsRemaining = totalIntermediateActions - passedIntermediateActions;
    if (actionsRemaining > 0) { const newCountStr = actionsRemaining.toString(); if (maneuverCounterEl.textContent !== newCountStr) { maneuverCounterEl.textContent = newCountStr; } if (maneuverCounterEl.style.display !== 'flex') { maneuverCounterEl.style.display = 'flex'; } } else { if (maneuverCounterEl.style.display !== 'none') { maneuverCounterEl.style.display = 'none'; } }
    let currentLegIndex = -1, currentStepIndex = -1;
    let stepFound = false;
    for (let i = 0; i < route.legs.length; i++) { const leg = route.legs[i]; if (!leg || !leg.steps) continue; for (let j = 0; j < leg.steps.length; j++) { const step = leg.steps[j]; if (step && typeof step.cumulativeDistance === 'number' && (step.cumulativeDistance + (step.distance || 0)) > carDistance) { currentLegIndex = i; currentStepIndex = j; stepFound = true; break; } } if (stepFound) break; }
    if (currentLegIndex === -1) { currentLegIndex = route.legs.length - 1; currentStepIndex = route.legs[currentLegIndex].steps.length - 1; }
    const currentStepForProgress = route.legs[currentLegIndex].steps[currentStepIndex];
    currentLegIndexNav = currentLegIndex;
    currentStepIndexNav = currentStepIndex;
    let finalStepToShow;
    let finalStepLegIndex = -1;
    let tempLegIdx = currentLegIndex;
    let tempStepIdx = currentStepIndex + 1;
    while (true) { if (tempLegIdx >= route.legs.length) { finalStepToShow = route.legs[route.legs.length - 1].steps[route.legs[route.legs.length - 1].steps.length - 1]; finalStepLegIndex = route.legs.length - 1; break; } let leg = route.legs[tempLegIdx]; if (!leg.steps || tempStepIdx >= leg.steps.length) { tempLegIdx++; tempStepIdx = 0; continue; } const candidateStep = leg.steps[tempStepIdx]; const isArrival = candidateStep.maneuver.type === 'arrive'; const arrivalWaypoint = isArrival ? actualWaypoints[tempLegIdx + 1] : null; if (isArrival && arrivalWaypoint && arrivalWaypoint.isInternal) { tempStepIdx++; continue; } else { finalStepToShow = candidateStep; finalStepLegIndex = tempLegIdx; break; } }
    let nextStepToDisplay = finalStepToShow;
    nextManeuverStepForPreview = nextStepToDisplay;
    const distanceToEndOfCurrentStepForProgress = (currentStepForProgress.cumulativeDistance || 0) + (currentStepForProgress.distance || 0);
    const distanceToNextManeuver = Math.max(0, distanceToEndOfCurrentStepForProgress - carDistance);
    const distanceIntoCurrentStep = (currentStepForProgress.distance || 0) - distanceToNextManeuver;
    const now = Date.now();
    const infoOverlay = document.getElementById('map-info-overlay');
    const uniqueManeuverId = `${currentLegIndex}_${currentStepIndex}_${nextStepToDisplay.name}`;
    if (announceManeuverWithFlash && distanceToNextManeuver < 220 && maneuverFlashTriggeredId !== uniqueManeuverId) { maneuverFlashTriggeredId = uniqueManeuverId; const borderOverlay = document.getElementById('maneuver-flashing-border-overlay'); if (borderOverlay) { borderOverlay.classList.remove('hidden'); setTimeout(() => { borderOverlay.classList.add('hidden'); }, 3000); } }
    
    const MANEUVER_ZONE_DISTANCE = 225;
    if (isNavigating) { 
        if (distanceToNextManeuver < MANEUVER_ZONE_DISTANCE) { 
            progressBar.classList.add('scaled-for-maneuver'); 
            if (compassControl && Date.now() > compassForceShowUntil) { 
                compassControl.classList.add('hidden-for-maneuver'); 
            }
            if (weatherWidget && Date.now() >= weatherWidgetForceShowUntil) { // <-- MODIFICADO AQU√ç
                weatherWidget.classList.add('hidden'); // Ocultamos el widget del tiempo
            }
        } else { 
            progressBar.classList.remove('scaled-for-maneuver'); 
            if (compassControl) compassControl.classList.remove('hidden-for-maneuver');
            if (weatherWidget && !isMapImmersiveModeActive) { 
                weatherWidget.classList.remove('hidden'); // Mostramos el widget del tiempo
            }
        } 
    } else {
        progressBar.classList.remove('scaled-for-maneuver'); 
        if (compassControl) compassControl.classList.remove('hidden-for-maneuver');
        if (weatherWidget) weatherWidget.classList.remove('hidden');
    }
    
    const shouldHideMainBar = !isAutoStartModalVisible && !isProgressBarLocked && !isMapImmersiveModeActive && now > progressBarForceShowUntil && distanceToNextManeuver > 1000 && distanceIntoCurrentStep > 100;
    const isForcedVisible = Date.now() < minimapForceShowUntil;
 
    progressBar.classList.toggle('progress-bar-auto-hidden', shouldHideMainBar);
    miniNavCard.style.display = shouldHideMainBar ? 'flex' : 'none';

    const shouldShowMinimap = (shouldHideMainBar || isForcedVisible) && showRouteMinimapPreference;
    if (minimapContainer) minimapContainer.classList.toggle('hidden', !shouldShowMinimap);

    if (infoOverlay) {
        if (shouldShowMinimap) infoOverlay.style.display = 'none';
        else if (isNavigating) infoOverlay.style.display = 'block';
    }
    
    if (showMinimapButton) {
        const shouldShowTButton = showRouteMinimapPreference && !shouldShowMinimap;
        showMinimapButton.classList.toggle('hidden', !shouldShowTButton);
    }

    if (miniNavCard.style.display === 'flex') {
        let mainInfoEl = miniNavCard.querySelector('#mini-card-main-info');
        let roadSignEl = miniNavCard.querySelector('#mini-card-road-sign');
        if (!mainInfoEl) { miniNavCard.innerHTML = `<div id="mini-card-road-sign" style="display: none;"></div><div id="mini-card-main-info"></div>`; mainInfoEl = miniNavCard.querySelector('#mini-card-main-info'); roadSignEl = miniNavCard.querySelector('#mini-card-road-sign');}
        const distanceText = distanceToNextManeuver < 1000 ? `${Math.round(distanceToNextManeuver / 5) * 5} m` : `${(distanceToNextManeuver / 1000).toFixed(1)} km`;
        let etaHtml = '';
        const remainingDistanceTotal = Math.max(0, route.distance - carDistanceAlongTheRoute);
        const remainingDurationTotal = route.distance > 0 ? route.duration * (remainingDistanceTotal / route.distance) : 0;
        const currentFinalEta = new Date(Date.now() + remainingDurationTotal * 1000);
        if (isNavigating && tripInitialOverallEtaTime) {
            const etaText = currentFinalEta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const finalDeviationMs = currentFinalEta.getTime() - tripInitialOverallEtaTime.getTime();
            const deviationHtml = formatDeviationForMiniCard(finalDeviationMs);
            etaHtml = `<div style="font-size: 0.90em; margin-top: 2px; text-align: center; "><span>${etaText}</span><span style="margin-left: 8px;">${deviationHtml}</span></div>`;
        }
        mainInfoEl.innerHTML = `<div>${distanceText}</div>${etaHtml}`;
    }
 
    const turnIconDisplayEl = document.getElementById('turn-icon-display');
    const maneuverTextEl = document.getElementById('maneuver-text-display');
    const distanceFormattedEl = document.getElementById('distance-to-turn-formatted');
    const streetNameLine = document.getElementById('street-name-line');
    const streetEl = document.getElementById('street-name-display');
    const progressBarFillEl = document.getElementById('distance-progress-bar-to-turn');

    if (nextStepToDisplay && nextStepToDisplay.maneuver) {
        const maneuver = nextStepToDisplay.maneuver;
        const type = maneuver.type || '';
        let maneuverText, streetNameText;

        if (type === 'arrive') {
            const arrivalWaypoint = actualWaypoints[finalStepLegIndex + 1] || actualWaypoints[actualWaypoints.length - 1];
            if (arrivalWaypoint && arrivalWaypoint.type === 'intermediate') {
                maneuverText = `Llegada a Etapa ${arrivalWaypoint.label} de ${totalStages}`;
                streetNameText = arrivalWaypoint.address || '';
            } else {
                maneuverText = "Has llegado a tu destino";
                streetNameText = arrivalWaypoint ? (arrivalWaypoint.address || "") : "";
            }
        } else {
            maneuverText = maneuver.instruction || getManeuverInstructionText(maneuver);
            const banner = nextStepToDisplay.bannerInstructions;
            if (banner && banner.length > 0 && banner[0].primary) {
                let bannerPrimaryText = banner[0].primary.text;
                let bannerSecondaryText = banner[0].secondary ? banner[0].secondary.text : '';
                streetNameText = bannerPrimaryText + (bannerSecondaryText ? `: ${bannerSecondaryText}` : '');
            } else {
                streetNameText = (type === 'depart' || type.includes('roundabout') || type === 'end of road') ? '' : (nextStepToDisplay.name || '');
            }
        }

        if (turnIconDisplayEl) {
            const iconFilename = getManeuverIconFilename(maneuver);
            if (iconFilename !== lastDisplayedManeuverIcon) {
                turnIconDisplayEl.innerHTML = `<img src="https://boardinggate.github.io/Tesla/${iconFilename}" alt="${maneuverText}" style="width: 95%; height: 95%; object-fit: contain;">`;
                lastDisplayedManeuverIcon = iconFilename;
            }
        }
        if (maneuverTextEl.textContent !== maneuverText) {
            maneuverTextEl.textContent = maneuverText;
        }
        if (streetNameText) {
            if (streetEl.textContent !== streetNameText) {
                streetEl.textContent = streetNameText;
            }
            streetEl.classList.toggle('road-sign-banner', streetNameText.includes(':') || /^[A-Z]{1,2}-?\d+/.test(streetNameText));
            if (streetNameLine.style.display !== 'flex') {
                streetNameLine.style.display = 'flex';
            }
        } else {
            if (streetNameLine.style.display !== 'none') {
                streetNameLine.style.display = 'none';
            }
        }
        distanceToNextManeuverOSRM = distanceToNextManeuver;
        const newDistanceText = distanceToNextManeuver < 1000 ? `${Math.round(distanceToNextManeuver / 5) * 5} m` : `${(distanceToNextManeuver / 1000).toFixed(1)} km`;
        if (distanceFormattedEl.textContent !== newDistanceText) {
            distanceFormattedEl.textContent = newDistanceText;
        }
        const progressPercent = (currentStepForProgress.distance > 0) ? ((currentStepForProgress.distance - distanceToNextManeuver) / currentStepForProgress.distance) * 100 : (distanceToNextManeuver === 0 ? 100 : 0);
        const newWidthPercent = `${Math.min(100, Math.max(0, progressPercent))}%`;
        if (progressBarFillEl && progressBarFillEl.style.width !== newWidthPercent) {
            progressBarFillEl.style.width = newWidthPercent;
        }
        const isRelevantIntersectionManeuver = type !== 'continue' && type !== 'new name' && type !== 'depart' && type !== 'straight';
        if (isNavigating && distanceToNextManeuver < 800 && distanceToNextManeuver >= 100 && isRelevantIntersectionManeuver && (!intersectionPreviewWindow || intersectionPreviewWindow.classList.contains('hidden') || intersectionPreviewWindow.dataset.source !== 'click') && (currentLegIndex + '_' + currentStepIndex) !== lastAutoShownManeuverId) {
            showIntersectionPreviewMap(nextStepToDisplay, route, false, 10000);
            lastAutoShownManeuverId = currentLegIndex + '_' + currentStepIndex;
        } else if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click' && (distanceToNextManeuver >= 800 || distanceToNextManeuver < 100 || !isRelevantIntersectionManeuver)) {
            hideIntersectionPreviewMap();
        }
    } else {   
        if (turnIconDisplayEl) {
            const iconFilename = 'PNG/arrive.png';
            if (iconFilename !== lastDisplayedManeuverIcon) {
                turnIconDisplayEl.innerHTML = `<img src="https://boardinggate.github.io/Tesla/${iconFilename}" style="width:95%; height:95%; object-fit:contain;">`;
                lastDisplayedManeuverIcon = iconFilename;
            }
        }
        if (maneuverTextEl.textContent !== 'Has llegado a tu destino') {
            maneuverTextEl.textContent = 'Has llegado a tu destino';
        }
        if (streetNameLine && streetNameLine.style.display !== 'none') {
            streetNameLine.style.display = 'none';
        }
        if (distanceFormattedEl.textContent !== '0 m') {
            distanceFormattedEl.textContent = '0 m';
        }
        if (progressBarFillEl && progressBarFillEl.style.width !== '100%') {
            progressBarFillEl.style.width = '100%';
        }
        distanceToNextManeuverOSRM = Infinity;
        nextManeuverStepForPreview = null;
        if (miniNavCard) miniNavCard.style.display = 'none';
        if (minimapContainer) minimapContainer.classList.add('hidden');
        if (showMinimapButton) showMinimapButton.classList.add('hidden');
        if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
    }
}    
    
// ===================================================================
// NOMBRE: showArrivalStatsModal 
// RESUMEN: Al finalizar el viaje, a√±ade el marcador de velocidad m√°xima y
function showArrivalStatsModal(freeDriveStatsData = null) {
    clearRecoveryFlag();
    closeOtherModals('arrival-stats-modal');
    document.body.classList.add('modal-open');

    let modal = document.getElementById('arrival-stats-modal');
    if (modal) {
        clearModalAutoCloseTimer(modal, modal.querySelector('#arrival-stats-accept-button'), 'arrival-stats-modal');
        modal.remove();
    }

    modal = document.createElement('div');
    modal.id = 'arrival-stats-modal';
    
    const isFreeDrive = !!freeDriveStatsData;
    
    const destinationName = isFreeDrive ? "Viaje Libre" : (navigationWaypoints[navigationWaypoints.length - 1]?.address || "Destino");
    const startTime = isFreeDrive ? freeDriveStatsData.startTime : (navigationStartTimeForStats ? new Date(navigationStartTimeForStats) : new Date());
    const arrivalTime = new Date();
    const durationMs = arrivalTime - startTime;
    const durationHours = Math.floor(durationMs / (1000 * 60 * 60));
    const durationMinutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
    
    let kmRealizados = isFreeDrive 
        ? (freeDriveStatsData.totalDistance / 1000).toFixed(1)
        : (totalDistanceTravelledForStats / 1000).toFixed(1);
    if (isSimulatingGpsLocation && automatedSimulationIntervalId) {
        kmRealizados = (simulatedDistanceAlongRoute / 1000).toFixed(1);
    }

    const kmEstimadosTexto = (!isFreeDrive && tripInitialDistanceMeters !== null) 
        ? `<br><small style="font-size: 0.7em; color: #b0b0b0;">(Estimados: ${(tripInitialDistanceMeters / 1000).toFixed(1)} km)</small>`
        : '';
    
    const initialDurationTotalMinutes = tripInitialDurationSec ? Math.round(tripInitialDurationSec / 60) : 0;
    const initialDurationHours = Math.floor(initialDurationTotalMinutes / 60);
    const initialDurationMinutes = initialDurationTotalMinutes % 60;
    const tiempoEstimadoTexto = (!isFreeDrive && tripInitialDurationSec !== null)
        ? `<br><small style="font-size: 0.7em; color: #b0b0b0;">(Estimado: ${String(initialDurationHours).padStart(2,'0')}:${String(initialDurationMinutes).padStart(2,'0')})</small>`
        : '';

    const velocidadMedia = window.averageSpeedKmh.toFixed(1);
    const velocidadMediaEstimadaTexto = (!isFreeDrive && graphExpectedAvgSpeed)
        ? `<br><small style="font-size: 0.7em; color: #b0b0b0;">(Estimada: ${graphExpectedAvgSpeed.toFixed(1)} km/h)</small>`
        : '';
    
    const horaLlegadaEstimadaTexto = (!isFreeDrive && originalTripEtaTime)
        ? `<br><small style="font-size: 0.7em; color: #b0b0b0;">(Estimada: ${originalTripEtaTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'})})</small>`
        : '';

    const velocidadMaxima = maxSpeedDuringTrip.toFixed(1);
    const altitudMaxima = maxAltitudeDuringTrip !== -Infinity ? `${maxAltitudeDuringTrip.toFixed(0)} m` : 'N/D';
    const altitudMinima = minAltitudeDuringTrip !== Infinity ? `${minAltitudeDuringTrip.toFixed(0)} m` : 'N/D';
    
    let altitudMediaHtml = 'No Graf.';
    if (lastKnownAverageAltitude !== null && !isNaN(lastKnownAverageAltitude)) {
        altitudMediaHtml = `${lastKnownAverageAltitude.toFixed(0)} m`;
    }

    let deviationHtml = '';
    let initialEtaDetailsHtml = '';
    if (!isFreeDrive) {
        if (originalTripEtaTime) {
            const finalDeviationMs = arrivalTime.getTime() - originalTripEtaTime.getTime();
            deviationHtml = formatDeviation(finalDeviationMs);
            if (Math.abs(finalDeviationMs) < 5000) {
                initialEtaDetailsHtml = `Previsi√≥n inicial coincidi√≥ con la real.`;
            } else {
                const initialEtaTime = originalTripEtaTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                const initialDurationFormatted = `${String(initialDurationHours).padStart(2,'0')}:${String(initialDurationMinutes).padStart(2,'0')}`;
                const initialAvgSpeed = graphExpectedAvgSpeed ? graphExpectedAvgSpeed.toFixed(1) : '0.0';
                initialEtaDetailsHtml = `<strong>Previsi√≥n inicial:</strong> Llegada: ${initialEtaTime} | Tiempo: ${initialDurationFormatted} | Vel. media: ${initialAvgSpeed} Km/h`;
            }
        }
    }
    
    const deviationSectionHtml = isFreeDrive ? '' : `
        <h3 class="stats-section-header">Desviaci√≥n ETA</h3>
        <div class="stats-grid">
            <div class="stat-card" style="grid-column: 1 / -1;">
                <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=_gn_lN6WnWZh&format=png&color=FFFFFF" alt="Desviaci√≥n ETA"/></div>
                <span class="stat-label">Desviaci√≥n sobre ETA (mm:ss)</span>
                <span class="stat-value">${deviationHtml}</span>
            </div>
        </div>
        ${initialEtaDetailsHtml ? `<div class="initial-eta-details">${initialEtaDetailsHtml}</div>` : ''}
    `;

    modal.innerHTML = `
        <div class="arrival-stats-header">
            <h2>${isFreeDrive ? 'RESUMEN DEL VIAJE' : '¬°HAS LLEGADO!'}</h2>
            <p class="destination-name">${destinationName}</p>
        </div>
        <div class="arrival-stats-body">
            <div class="arrival-stats-layout-grid">
                <div class="main-stats-container">
                    <h3 class="stats-section-header">Tiempos y Duraci√≥n</h3>
                    <div class="stats-grid" style="grid-template-columns: repeat(3, 1fr);">
                         <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=25235&format=png&color=FFFFFF" alt="Salida"/></div>
                            <span class="stat-label">Hora Salida</span>
                            <span class="stat-value">${startTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/time.png" alt="Duraci√≥n"/></div>
                            <span class="stat-label">Duraci√≥n Viaje</span>
                            <span class="stat-value">${String(durationHours).padStart(2,'0')}:${String(durationMinutes).padStart(2,'0')} ${tiempoEstimadoTexto}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/finish-flag.png" alt="Llegada"/></div>
                            <span class="stat-label">Hora Llegada</span>
                            <span class="stat-value">${arrivalTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})} ${horaLlegadaEstimadaTexto}</span>
                        </div>
                    </div>

                    <h3 class="stats-section-header">Distancia y Velocidad</h3>
                    <div class="stats-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=fodDbvH8xepW&format=png&color=ffffff" alt="Distancia"/></div>
                            <span class="stat-label">Km Realizados</span>
                            <span class="stat-value">${kmRealizados} km ${kmEstimadosTexto}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/speedometer.png" alt="Velocidad Media"/></div>
                            <span class="stat-label">Velocidad Media</span>
                            <span class="stat-value">${velocidadMedia} km/h ${velocidadMediaEstimadaTexto}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=c7DeWFZX07r8&format=png&color=ffffff" alt="Velocidad M√°xima"/></div>
                            <span class="stat-label">Velocidad M√°xima</span>
                            <span class="stat-value">${velocidadMaxima} km/h <button id="show-max-speed-location-button">¬øD√≥nde?</button></span>
                        </div>
                    </div>
                </div>

                <div class="side-stats-container">
                    ${deviationSectionHtml}
                    <h3 class="stats-section-header">M√©tricas de Altitud</h3>
                    <div class="stats-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/mountain.png" alt="Altitud M√°xima"/></div>
                            <span class="stat-label">Altitud M√°xima</span>
                            <span class="stat-value">${altitudMaxima}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/mountain.png" alt="Altitud M√≠nima" style="transform: scaleY(-1);"/></div>
                            <span class="stat-label">Altitud M√≠nima</span>
                            <span class="stat-value">${altitudMinima}</span>
                        </div>
                         <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=113129&format=png&color=ffffff" alt="Altitud Media"/></div>
                            <span class="stat-label">Altitud Media</span>
                            <span class="stat-value">${altitudMediaHtml}</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="arrival-stats-footer">
            <button id="arrival-stats-accept-button">Aceptar <span class="button-countdown-timer unified-countdown-style"></span></button>
        </div>
    `;

    document.body.appendChild(modal);
    
    const coordsAreValid = maxSpeedCoordinates && typeof maxSpeedCoordinates.lat === 'number' && !isNaN(maxSpeedCoordinates.lat) && typeof maxSpeedCoordinates.lng === 'number' && !isNaN(maxSpeedCoordinates.lng);
    if (coordsAreValid && navigationMapInstance) {
        const maxSpeedFeature = {
            type: 'Feature',
            geometry: {
                type: 'Point',
                coordinates: [maxSpeedCoordinates.lng, maxSpeedCoordinates.lat]
            },
            properties: {
                type: 'maxSpeed',
                speedText: maxSpeedDuringTrip.toFixed(0)
            }
        };
        speedMarkerFeatures.push(maxSpeedFeature);
        if (navigationMapInstance.getSource('speed-markers-source')) {
            navigationMapInstance.getSource('speed-markers-source').setData({
                type: 'FeatureCollection',
                features: speedMarkerFeatures
            });

            try {
                if (navigationMapInstance.getLayer('speed-markers-circle-bg')) {
                    navigationMapInstance.moveLayer('speed-markers-circle-bg');
                }
                if (navigationMapInstance.getLayer('speed-markers-text')) {
                    navigationMapInstance.moveLayer('speed-markers-text');
                }
            } catch (e) {
            }
        }

        modal.querySelector('#show-max-speed-location-button').addEventListener('click', () => {
            closeHandler();
            navigationMapInstance.flyTo({ center: [maxSpeedCoordinates.lng, maxSpeedCoordinates.lat], zoom: 17 });
        });
    }

    const acceptButton = modal.querySelector('#arrival-stats-accept-button');
    const closeHandler = () => {
        document.body.classList.remove('modal-open');
        clearModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal');
        if (modal.parentNode) modal.remove();
        isGraphingActive = false;
        if (graphIntervalTimer) { clearInterval(graphIntervalTimer); graphIntervalTimer = null; }

        if (navigationFollowUser) { 
            handleLocateMeClick(true);
            updateLocateMeButtonsUI();

        }
    
        if (isFreeDrive) {
             isFreeDriveActive = false;
             isFreeDrivePaused = false;
             freeDriveStats = null;
             tripStartLocationForStats = null;
        } else {
            isNavigating = false;
            navigationFollowUser = false;
            showPostArrivalActionModal(); 
          }

        updateDynamicRadars(true);
        
        mapHeaderButtonsVisible = true;
        toggleMapHeaderRowsVisibility(true);
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        showMapInfoOverlay(isFreeDrive ? "Viaje libre finalizado" : "HA LLEGADO A: " + destinationName);
    };

    acceptButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal', 150000);
}   

// ===================================================================
// NOMBRE: handleAddRadarHereClick 
// RESUMEN: Crea el radar en localStorage y luego redibuja la capa completa.
// ===================================================================
function handleAddRadarHereClick(button) {
    showRadarSpeedModal((selectedSpeed) => {
        if (selectedSpeed === null) {
            return;
        }

        button.disabled = true;
        const radarImg = button.querySelector('img');
        if (radarImg) radarImg.src = "PNG/RADAR.PNG";

        getCurrentLocation(
            (coords) => {
                const now = new Date();
                let radarText;
                if (selectedSpeed === 'TRAMO') {
                    radarText = `<b>RADAR: DE TRAMO (A√±adido por el usuario)</b>`;
                } else {
                    radarText = `<b>RADAR: DE ${selectedSpeed} KM/H (A√±adido por el usuario)</b>`;
                }

                const newRadarReminder = {
                    id: Date.now(),
                    text: radarText,
                    type: 'simple',
                    time: `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`,
                    date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                    createdAt: now.toISOString(),
                    managedByUser: false,
                    isLocationEnabled: true,
                    locationCoordinates: { latitude: coords.latitude, longitude: coords.longitude },
                    radiusMeters: 350,
                    excludeFromList: true
                };

                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                reminders.push(newRadarReminder);
                localStorage.setItem('reminders', JSON.stringify(reminders));
                
                showToast(`Radar de ${selectedSpeed === 'TRAMO' ? 'Tramo' : selectedSpeed + ' km/h'} creado en tu ubicaci√≥n.`, "success");
                
                updateReminderCount();
                updateButtonStyles();
                markCacheAsDirty();
                
                if (navigationMapInstance) {
                    plotRemindersOnNavigationMap();
                    navigationMapInstance.flyTo({ center: [coords.longitude, coords.latitude], zoom: 15 });
                }
                
                button.disabled = false;
                if (radarImg) radarImg.src = "PNG/RADARAQUI.PNG";
            },
            (errorMsg) => {
                showToast(`Error al obtener ubicaci√≥n para RADAR: ${errorMsg}`, "error");
                button.disabled = false;
                if (radarImg) radarImg.src = "PNG/RADARAQUI.PNG";
            }
        );
    });
}

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// NOMBRE: findChargingPointsOnRoute 
// RESUMEN: Busca PDRs de OCM y gestiona el estado de la b√∫squeda.
async function findChargingPointsOnRoute(powerFilters, searchConfig) {
    
    const pdrButton = document.getElementById('pdrs-ruta-button');  const OCM_API_KEY = "be9a78f7-0f5e-4f28-b742-4b7ab4b7eb5a";
    
    if (pdrButton) pdrButton.classList.remove('pdr-search-highlight');

    clearChargingPoints();
    lastPdrSearchResults = [];
    
    showToast("Buscando puntos de recarga...", "info", 0, false, "pdrs-search");
    const PDR_SEARCH_IN_VIEW_KEY = 'boardinggate_pdrSearchInView';
    const hasRoute = searchConfig.type === 'route';
    const searchInCurrentViewChecked = localStorage.getItem(PDR_SEARCH_IN_VIEW_KEY) === 'true';
    
    let apiUrl;

    if (searchInCurrentViewChecked) {
        const bounds = navigationMapInstance.getBounds();
        apiUrl = `https://api.openchargemap.io/v3/poi/?output=json&key=${OCM_API_KEY}&boundingbox=(${bounds.getSouthWest().lat},${bounds.getSouthWest().lng}),(${bounds.getNorthEast().lat},${bounds.getNorthEast().lng})&maxresults=1500&compact=false&verbose=true`;
        showToast("Buscando en la vista actual del mapa...", "info", 2000);
    } else if (hasRoute) {
        const routeSource = navigationMapInstance.getSource('route');
        if (!routeSource || !routeSource._data || !routeSource._data.geometry || !routeSource._data.geometry.coordinates || routeSource._data.geometry.coordinates.length < 2) {
            showToast("No hay ruta v√°lida para buscar PDRs sobre ella.", "error");
            const existingToast = document.getElementById("pdrs-search");
            if (existingToast) existingToast.remove();
            return;
        }
        const routeBounds = new mapboxgl.LngLatBounds();
        routeSource._data.geometry.coordinates.forEach(coord => routeBounds.extend(coord));
        apiUrl = `https://api.openchargemap.io/v3/poi/?output=json&key=${OCM_API_KEY}&boundingbox=(${routeBounds.getSouthWest().lat},${routeBounds.getSouthWest().lng}),(${routeBounds.getNorthEast().lat},${routeBounds.getNorthEast().lng})&maxresults=1500&compact=false&verbose=true`;
    } else if (searchConfig.type === 'radius') {
        apiUrl = `https://api.openchargemap.io/v3/poi/?output=json&key=${OCM_API_KEY}&latitude=${searchConfig.center.lat}&longitude=${searchConfig.center.lng}&distance=${searchConfig.radiusKm}&distanceunit=km&maxresults=1000&compact=false&verbose=true`;
    } else {
        showToast("Tipo de b√∫squeda no v√°lido.", "error");
        pdrSearchState = 'initial';
        return;
    }
    
    try {
        const response = await fetch(apiUrl);
        if (!response.ok) throw new Error(`Error de red de OCM: ${response.statusText}`);
        const data = await response.json();
        if (!data || !Array.isArray(data)) throw new Error("Respuesta de OCM no v√°lida.");

        window.lastOcmApiResponse = data;

        const operatorFilterText = (document.getElementById('operator-filter-input')?.value || localStorage.getItem('boardinggate_operator_filter') || '').toLowerCase().trim();
        const operatorFilterWords = operatorFilterText ? operatorFilterText.split(/\s+/).filter(w => w) : [];
        
        const routeLineForDistanceCheck = (searchConfig.type === 'route' && navigationMapInstance.getSource('route') && navigationMapInstance.getSource('route')._data) ? turf.lineString(navigationMapInstance.getSource('route')._data.geometry.coordinates) : null;
        
        let filteredPoints = [];

        data.forEach(point => {
            const formattedPoint = formatOCMPoint(point);
            if (!formattedPoint) return;
            const power = parseFloat(formattedPoint.power);
            if (isNaN(power) || power < powerFilters.min || power > powerFilters.max) return;

            if (operatorFilterWords.length > 0) {
                const pointOperator = (formattedPoint.operator || '').toLowerCase();
                const pointAddress = (formattedPoint.address || '').toLowerCase();
                const operatorMatch = operatorFilterWords.some(word => 
                    pointOperator.includes(word) || pointAddress.includes(word)
                );
                if (!operatorMatch) return;
            }
            
            if (!searchInCurrentViewChecked && hasRoute && routeLineForDistanceCheck) {
                const pointTurf = turf.point([formattedPoint.lon, formattedPoint.lat]);
                const distanceKm = turf.pointToLineDistance(pointTurf, routeLineForDistanceCheck, { units: 'kilometers' });
                if (distanceKm <= searchConfig.distanceFilters.max) {
                    filteredPoints.push(formattedPoint);
                }
            } else { 
                filteredPoints.push(formattedPoint);
            }
        });
        
        lastPdrSearchResults = [...filteredPoints];
        currentChargingPointsOnRoute = [...filteredPoints];

        const cheapestBySegment = {
            '#5e5e5e': { price: Infinity, point: null },
            '#007863': { price: Infinity, point: null },
            'rgb(30, 144, 255)': { price: Infinity, point: null },
            '#de2e03': { price: Infinity, point: null }
        };

        const parsePrice = (priceString) => {
            if (priceString && typeof priceString === 'string') {
                const priceMatch = priceString.match(/(\d[\d,.]*)/);
                if (priceMatch && priceMatch[1]) {
                    const priceNum = parseFloat(priceMatch[1].replace(',', '.'));
                    if (!isNaN(priceNum) && priceNum > 0 && priceNum < 10) {
                        return priceNum;
                    }
                }
            }
            return Infinity;
        };

        currentChargingPointsOnRoute.forEach(point => {
            point.isCheapest = false;
            const power = parseFloat(point.power);
            const segmentColor = getChargingPointColorByPower(power);
            const price = parsePrice(point.price);
            
            if (cheapestBySegment[segmentColor] && price < cheapestBySegment[segmentColor].price) {
                cheapestBySegment[segmentColor].price = price;
                cheapestBySegment[segmentColor].point = point;
            }
        });

        for (const color in cheapestBySegment) {
            const cheapest = cheapestBySegment[color];
            if (cheapest.point) {
                cheapest.point.isCheapest = true;
            }
        }

        const existingToast = document.getElementById("pdrs-search");
        if (existingToast) existingToast.remove();
        showToast(`${currentChargingPointsOnRoute.length} PDRs encontrados.`, "success");
        displayChargingPointsOnMap();

        pdrSearchState = 'results_shown';

    } catch (error) {
        const existingToast = document.getElementById("pdrs-search");
        if (existingToast) existingToast.remove();
        showToast(`Error al buscar PDRs: ${error.message}`, "error");
        pdrSearchState = 'initial';
    }
}

// NOMBRE: updateUserIdDisplay
// RESUMEN: Muestra el ID de usuario en la pantalla si existe.
// ===================================================================
function updateUserIdDisplay() {
    const userIdDisplay = document.getElementById('user-id-display');
    const userId = localStorage.getItem('userData_userId');
    if (userIdDisplay) {
        if (userId) {
            userIdDisplay.textContent = userId.trim();
            userIdDisplay.style.display = 'block';
        } else {
            userIdDisplay.textContent = '';
            userIdDisplay.style.display = 'none';
        }
    }
}

// ===================================================================
// NOMBRE: handleGpsSimulationToggle 
// RESUMEN: Activa/desactiva el modo de simulaci√≥n GPS. Si hay una ruta cargada al activar, muestra el modal de selecci√≥n de velocidad y tipo de simulaci√≥n.
function handleGpsSimulationToggle() {
    const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
    const mapDiv = document.getElementById('reminders-location-map-div');
    if (isSimulatingGpsLocation) { 
        if (isSimulatingFreeDrive) {
            stopFreeDrive();
            isSimulatingFreeDrive = false; 
        }
        
        stopAutomatedRouteSimulationInternal(); 
        isSimulatingGpsLocation = false;
        reactivateRealGpsAfterSimulation();
        if (mapDiv) mapDiv.classList.remove('simulating-gps-click-mode');
        if (simulateGpsButton) {
            simulateGpsButton.classList.remove('active-simulate-gps-mode'); 
            simulateGpsButton.title = "Activar Simulaci√≥n GPS (recorrido autom√°tico o clic manual)";
        }
      
        showToast("Modo simulaci√≥n GPS desactivado. Volviendo a GPS real.", "info");
    } else { 
        if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0] && navigationWaypoints.filter(wp => !wp.isInternal && !wp.isRecalculatedStart).length >= 2) {
            showSimulationSpeedModal(simulationSpeedKmph, (newSpeed) => {
                startAutomatedRouteSimulation(newSpeed); 
                if (mapDiv) mapDiv.classList.remove('simulating-gps-click-mode'); 
            });
        } else {
            isSimulatingGpsLocation = true;
            if (simulateGpsButton) simulateGpsButton.classList.add('active-simulate-gps-mode'); 
            if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode'); 
            showToast("Modo simulaci√≥n GPS por clic ACTIVADO. Carga una ruta para recorrido autom√°tico o toca el mapa.", "info", 6000);
        }
    }
    setNavigationMapClickHandler();
}

//==============================================
//===========================
async function deleteFilteredRadars() {
    window.radarsCache = null;
    window.radarsSpatialIndex = null;
    localStorage.removeItem('radarsCacheData');
    localStorage.removeItem('radarsCacheIndex');
    localStorage.removeItem('radarsCacheVersion');
    
    const latFilterValue = document.getElementById('radar-filter-lat').value.trim();
    const lonFilterValue = document.getElementById('radar-filter-lon').value.trim();
    const keywordsFilterRaw = document.getElementById('radar-filter-keywords').value.trim().toUpperCase();
    const keywordsFilter = keywordsFilterRaw ? keywordsFilterRaw.split(/\s+/).filter(k => k) : [];
    const statusMessage = document.getElementById('radar-import-status');
    const progressContainer = document.getElementById('radar-import-progress-container');
    const noFiltersProvided = !latFilterValue && !lonFilterValue && keywordsFilter.length === 0;
    let confirmationMessage = "";
    if (noFiltersProvided) {
        confirmationMessage = "¬øEst√°s seguro de que quieres borrar TODOS los recordatorios tipo RADAR/POI importados (se respetar√°n los creados manualmente)? Esta acci√≥n no se puede deshacer.";
    } else {
        confirmationMessage = "¬øEst√°s seguro de que quieres borrar los recordatorios tipo RADAR/POI que coincidan con los filtros actuales (se respetar√°n los creados manualmente)? Esta acci√≥n no se puede deshacer.";
    }
    if (!confirm(confirmationMessage)) {
        showToast("Borrado cancelado", "info");
        return;
    }
    progressContainer.style.display = 'block';
    const progressBar = document.getElementById('radar-import-progress-bar');
    if(progressBar) progressBar.style.display = 'none';
    statusMessage.textContent = 'Borrando recordatorios...';
    statusMessage.style.color = '';
    try {
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        let originalLength = reminders.length;
        reminders = reminders.filter(r => {
            const isRadarType = r.isLocationEnabled && (r.text.toUpperCase().includes("RADAR") || r.excludeFromList);
            
            if (!isRadarType) return true;

            if (r.radiusMeters === 350) {
                return true; }
            if (noFiltersProvided) {
                return false; }

            let matchesKeywords = true;
            if (keywordsFilter.length > 0) {
                matchesKeywords = keywordsFilter.some(kw => r.text.toUpperCase().includes(kw));
            }
            let matchesLat = true;
            if (latFilterValue) {
                if (r.locationCoordinates) {
                    matchesLat = parseCoordinateFilter(latFilterValue, r.locationCoordinates.latitude);
                } else {
                    matchesLat = false;
                }
            }
            let matchesLon = true;
            if (lonFilterValue) {
                if (r.locationCoordinates) {
                    matchesLon = parseCoordinateFilter(lonFilterValue, r.locationCoordinates.longitude);
                } else {
                    matchesLon = false;
                }
            }

            return !(matchesKeywords && matchesLat && matchesLon);
        });
        localStorage.setItem('reminders', JSON.stringify(reminders));
        const numDeleted = originalLength - reminders.length;
        statusMessage.textContent = `Borrado completo. ${numDeleted} recordatorios eliminados.`;
        statusMessage.style.color = '#28a745';
        showToast(`${numDeleted} recordatorios eliminados`, 'success');
        updateReminderCount();
        updateButtonStyles();
        markCacheAsDirty();
    } catch (error) {
        statusMessage.textContent = `Error: ${error.message}`;
        statusMessage.style.color = 'red';
        showToast('Error durante el borrado', 'error');
    } finally {
        setTimeout(() => {
            progressContainer.style.display = 'none';
            if(progressBar) progressBar.style.display = 'block';
            statusMessage.style.color = '';
        }, 3000);
    }
}
// ===================================================================
// NOMBRE: handleMapClickToAddReminder 
// RESUMEN: Maneja el clic para a√±adir un recordatorio en el mapa.
function handleMapClickToAddReminder(e) {
    if (!isAddReminderAtLocationModeActive || !navigationMapInstance) return;
    const latlng = e.lngLat;
    toggleAddReminderAtLocationMode(); 
    const mapContextBeforeModal = sessionStorage.getItem('mapContext');
    sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
    if (mapContextBeforeModal) {
      sessionStorage.setItem('mapContext', mapContextBeforeModal);
    }
    showReminderModal({
        isLocationEnabled: true,
        locationCoordinates: { latitude: latlng.lat, longitude: latlng.lng },
        radiusMeters: DEFAULT_LOCATION_RADIUS,
        text: 'Recordatorio en mapa: ',
        excludeFromList: false
    }, { onTopOfMap: true });
}

// ===================================================================
// NOMBRE: togglePoiCategorySearch (VERSI√ìN DEFINITIVA CORREGIDA)
// RESUMEN: Gestiona el modo de "a√±adir etapas en ruta" o la b√∫squeda de POIs, asegurando la limpieza de la UI en todos los casos.
function togglePoiCategorySearch() {
    const searchButton = document.getElementById('map-location-search-button');
    if (!searchButton) return;

    if (isNavigating) {
        isAddingWaypointsDuringNav = !isAddingWaypointsDuringNav;

        if (isAddingWaypointsDuringNav) {
            searchButton.style.setProperty('background-color', '#FFD700', 'important');
            showToast("MODO EDICI√ìN DE RUTA ACTIVADO. Pulse en el mapa para a√±adir una etapa.", "info", 5000);
            
            triggerManualMapInteraction();
            showPoiCategoryModal();
            toggleMapControls(true);

        } else {
            clearPoiSearchResults(); 
            searchButton.style.removeProperty('background-color');
            showToast("Modo edici√≥n de ruta finalizado. Recalculando...", "success", 4000);

            handleLocateMeClick(true);
            
            if (navigationWaypoints.length >= 2) {
                recalculateAndDrawRoute(true);
            }
        }
    } else {
        if (isPoiSearchActive) {
            clearPoiSearchResults();
            const existingModal = document.getElementById('poi-category-modal');
            if (existingModal) existingModal.remove();
            isPoiSearchActive = false;
            searchButton.style.removeProperty('background-color');
            showToast("B√∫squeda de POIs limpiada.", "info");

        } else {
            isPoiSearchActive = true;
            searchButton.style.setProperty('background-color', '#FFD700', 'important');
            showPoiCategoryModal();
        }
    }
    updateStartNavigationButtonState();
    setNavigationMapClickHandler();
}

// ===================================================================
// NOMBRE: updateStartNavigationButtonState (CORREGIDA - PERMITE EDICI√ìN EN RUTA)
// RESUMEN: Actualiza la UI de navegaci√≥n. Mantiene los controles de planificaci√≥n disponibles pero atenuados durante la navegaci√≥n.
function updateStartNavigationButtonState() {
    const startNavButton = document.getElementById('start-navigation-button');
    const saveRouteButton = document.getElementById('save-route-button');
    const reorderBtn = document.getElementById('reorder-route-stages-button');
    const startNavImg = startNavButton ? startNavButton.querySelector('img') : null;
    const simulateBtn = document.getElementById('simulate-route-button');
    const deleteRouteBtn = document.getElementById('delete-current-route-button');
    const loadRouteBtn = document.getElementById('load-saved-route-button'); 
    const toggleSimulateGpsBtn = document.getElementById('toggle-simulate-gps-button');
    const graphCard = document.getElementById('navigation-graph-card');

    if (!startNavButton || !saveRouteButton || !reorderBtn || !simulateBtn || !loadRouteBtn || !deleteRouteBtn || !toggleSimulateGpsBtn || !graphCard) return;
    
    const hasEnoughWaypointsForRoute = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2;
    const hasRouteData = navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0];
    const canDisplayRoute = hasEnoughWaypointsForRoute && hasRouteData;

    startNavButton.classList.remove('hidden');
    if (toggleSimulateGpsBtn) toggleSimulateGpsBtn.style.display = 'inline-flex';

    if (isNavigating || isFreeDriveActive) {
        if(startNavImg) startNavImg.src = "PNG/TERMINARNAVEGACION.PNG";
        if (isNavigating) {
            if (loadRouteBtn) {
                loadRouteBtn.disabled = true;
                loadRouteBtn.style.opacity = '0.5';
                loadRouteBtn.style.cursor = 'not-allowed';
            }
        } else { // Este caso es solo para isFreeDriveActive
            toggleMapControls(true);
        }
    } else {
        if(startNavImg) startNavImg.src = "PNG/INICIARNAVEGACION.PNG";
        toggleMapControls(true); 
    }
    
    saveRouteButton.classList.toggle('hidden', !(!isNavigating && canDisplayRoute));

    if (reorderBtn) {
        reorderBtn.style.display = canDisplayRoute ? 'inline-flex' : 'none';
        reorderBtn.disabled = !canDisplayRoute;
    }
    
    const canSimulate = (canDisplayRoute || (isNavigating && hasRouteData));
    if(simulateBtn) simulateBtn.style.display = canSimulate ? 'inline-flex' : 'none';
    
    if (deleteRouteBtn) {
        deleteRouteBtn.classList.remove('hidden');
    }
    if (loadRouteBtn) {
        loadRouteBtn.classList.remove('hidden');
    }
    const hasGraphData = graphDataPoints && (graphDataPoints.speed.length > 0 || graphDataPoints.altitude.length > 0);
    graphCard.classList.toggle('hidden', !hasGraphData || currentGraphMode === 'Gr√°fica off');
    
    if (!hasEnoughWaypointsForRoute && !isNavigating && !isFreeDriveActive) {
         if (navigationMapInstance && navigationMapInstance.getLayer('route')) {
             navigationMapInstance.removeLayer('route');
             navigationMapInstance.removeSource('route');
         }
         navigationRouteLayer = null;
         navigationCurrentRouteData = null;
         hideNavigationUI();
         hideMapInfoOverlay();
         eliminarRadaresDeRuta();
         actualizarContadorRadares(0);
         eliminarTareasDeBarraProgreso();
         actualizarContadorTareas(0);
         const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
         if (radaresCheckbox) {
             localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckbox.checked)); 
         }
         const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
         if (tareasCheckbox) {
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckbox.checked));
         }
    }
    updateNavigationGraphVisibilityAndMode();
}

    
//===================================================================
// NOMBRE: showReorderStagesModal (CORREGIDA - SIEMPRE DISPONIBLE CON RUTA)
// RESUMEN: Permite abrir el modal de reordenar etapas siempre que haya una ruta cargada, incluso durante la navegaci√≥n.
// ===================================================================
function showReorderStagesModal() {
    const actualWaypointsForReorder = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    if (actualWaypointsForReorder.length < 2) {
        showToast("Se necesitan al menos 2 puntos para reordenar", "warning");
        return;
    }

    const modal = document.getElementById('reorder-stages-modal');
    const listElement = modal.querySelector('#sortable-stages-list');

    listElement.innerHTML = '';
    
    actualWaypointsForReorder.forEach(async (wp) => {
        const li = document.createElement('li');
        li.dataset.id = wp.id;

        const dragHandle = document.createElement('span');
        dragHandle.className = 'drag-handle';
        dragHandle.innerHTML = '<img src="PNG/MOVER.PNG" alt="Mover etapa">';
        dragHandle.title = 'Arrastrar para reordenar';
        dragHandle.draggable = true;

        const badge = document.createElement('span');
        badge.className = 'stage-label-badge';
        badge.textContent = wp.label;

        const nameSpan = document.createElement('span');
        nameSpan.className = 'stage-name-text';
        nameSpan.textContent = wp.address || `Cargando... (${wp.lat.toFixed(3)}, ${wp.lng.toFixed(3)})`;
        if (!wp.address) {
             wp.address = await getAddressForWaypoint(wp.lat, wp.lng);
             nameSpan.textContent = wp.address;
        }

        const deleteButton = document.createElement('span');
        deleteButton.className = 'delete-stage-button';
        deleteButton.innerHTML = '√ó';
        deleteButton.title = 'Eliminar esta etapa';

        deleteButton.addEventListener('click', (e) => {
            e.stopPropagation();
            const listItem = e.target.closest('li');
            if (listItem) {
                listItem.remove();
            }
        });

        li.appendChild(dragHandle);
        li.appendChild(badge);
        li.appendChild(nameSpan);
        li.appendChild(deleteButton);
        listElement.appendChild(li);
    });

    modal.classList.remove('hidden');
    
    const confirmButton = modal.querySelector('#confirm-reorder-stages');
    const cancelButton = modal.querySelector('#cancel-reorder-stages');
    
    const newConfirmButton = confirmButton.cloneNode(true);
    confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
    const newCancelButton = cancelButton.cloneNode(true);
    cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);
    
    const closeReorderModal = () => {
        clearModalAutoCloseTimer(modal, newConfirmButton, 'reorder-stages-modal');
        modal.classList.add('hidden');
        listElement.removeEventListener('dragstart', handleDragStartReorder);
        listElement.removeEventListener('dragend', handleDragEndReorder);
        listElement.removeEventListener('dragover', handleDragOverReorder);
        listElement.removeEventListener('touchstart', handleStageTouchStart);
        listElement.removeEventListener('touchmove', handleStageTouchMove);
        listElement.removeEventListener('touchend', handleStageTouchEnd);
        listElement.removeEventListener('touchcancel', handleStageTouchEnd);
        document.body.style.overflow = '';
    };

    newConfirmButton.addEventListener('click', async () => {
        const orderedLiElements = Array.from(listElement.children);
        
        const finalWaypointIds = orderedLiElements.map(li => parseFloat(li.dataset.id));
        clearAllWaypointMarkersFromMap();

        if (finalWaypointIds.length < 2) {
            navigationWaypoints = [];
            handleLoadOrDeleteRouteClick(null);
            closeReorderModal();
            return;
        }

        try {
            const waypointMap = new Map(navigationWaypoints.map(wp => [wp.id, wp]));
            
            const userWaypointsInNewOrder = [];
            finalWaypointIds.forEach(id => {
                if (waypointMap.has(id)) {
                    userWaypointsInNewOrder.push(waypointMap.get(id));
                }
            });
            
            const recalcStartPoint = navigationWaypoints.find(wp => wp && wp.isRecalculatedStart);
            navigationWaypoints = recalcStartPoint ? [recalcStartPoint, ...userWaypointsInNewOrder] : [...userWaypointsInNewOrder];
            
            const safeFinalWaypoints = navigationWaypoints.map(wp => ({ id: wp.id, address: wp.address, type: wp.type, label: wp.label, isInternal: wp.isInternal }));
            
            await updateWaypointTypesAndLabels();
            renderWaypointMarkers();
            
            await recalculateAndDrawRoute(true); 

        } catch (error) {
        } finally {
            closeReorderModal();
            updateStartNavigationButtonState();
            updateNavigationButtonColor();
        }
    });
    
    newCancelButton.addEventListener('click', () => {
        showToast("Reordenaci√≥n cancelada.", "info");
        closeReorderModal();
        if (navigationWaypoints.length >= 2) {
            renderWaypointMarkers();
            recalculateAndDrawRoute(true).catch(() => {});
        } else {
            handleLoadOrDeleteRouteClick(null);
        }
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
    });

    addModalAutoCloseTimer(modal, newConfirmButton, 'reorder-stages-modal', 60000);
    
    listElement.addEventListener('dragstart', handleDragStartReorder);
    listElement.addEventListener('dragend', handleDragEndReorder);
    listElement.addEventListener('dragover', handleDragOverReorder);
    listElement.addEventListener('touchstart', handleStageTouchStart, { passive: false });
    listElement.addEventListener('touchmove', handleStageTouchMove, { passive: false });
    listElement.addEventListener('touchend', handleStageTouchEnd);
    listElement.addEventListener('touchcancel', handleStageTouchEnd);
}
    
// ===================================================================
// NOMBRE: updateProgressBarLockIcon 
// RESUMEN: Actualiza el icono del candado en la barra de progreso seg√∫n su estado.
function updateProgressBarLockIcon() {
    const lockButton = document.getElementById('toggle-progress-bar-lock');
    if (!lockButton) return;
    const img = lockButton.querySelector('img');
    if (img) {
        if (isProgressBarLocked) {
            img.src = "PNG/IMG_4281.png";
            lockButton.title = "Panel de progreso BLOQUEADO. P√∫lsame para activar auto-ocultaci√≥n.";
        } else {
            img.src = "PNG/IMG_4280.png";
            lockButton.title = "Panel de progreso DESBLOQUEADO. Se ocultar√° autom√°ticamente. P√∫lsame para bloquearlo.";
        }
    }
}

// ===================================================================
// NOMBRE: L√≥gica de Pre-carga de GPS
// RESUMEN: Obtiene la ubicaci√≥n del GPS al cargar la p√°gina para acelerar la apertura del mapa.
let preloadedGpsPosition = null;

function preloadGpsLocation() {
    if ('geolocation' in navigator) {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                preloadedGpsPosition = {
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy,
                    altitude: position.coords.altitude,
                    heading: position.coords.heading,
                    speed: position.coords.speed
                };
            },
            (error) => {
            },
            { 
                enableHighAccuracy: true, 
                timeout: 15000,      
                maximumAge: 60000    
            }
        );
    }
}    

// ===================================================================
// NOMBRE: showNavigationMapHelpModal (VERSI√ìN COMPLETA Y CORREGIDA CON BOT√ìN ADMIN)
// ===================================================================
function showNavigationMapHelpModal() {
    const existingHelpModal = document.getElementById('reminders-map-help-modal-instance');
    if (existingHelpModal) {
        clearModalAutoCloseTimer(existingHelpModal, existingHelpModal.querySelector('#close-reminders-map-help-instance'), 'reminders-map-help-modal-instance');
        existingHelpModal.remove();
    }

    const helpModal = document.createElement('div');
    helpModal.id = 'reminders-map-help-modal-instance';
    helpModal.className = 'help-modal';
    helpModal.setAttribute('aria-label', 'Ayuda Mapa de Navegaci√≥n/Radares');
    
    const LERP_RATE_POS_KEY = 'boardinggate_lerp_rate_position';
    const LERP_RATE_ROT_KEY = 'boardinggate_lerp_rate_rotation';
    const LERP_RATE_ZOOM_KEY = 'boardinggate_lerp_rate_zoom';

    const currentLerpPosition = localStorage.getItem(LERP_RATE_POS_KEY) || '0.004';
    const currentLerpRotation = localStorage.getItem(LERP_RATE_ROT_KEY) || '0.002';
    const currentLerpZoom = localStorage.getItem(LERP_RATE_ZOOM_KEY) || '0.001';

    // --> A√ëADIDO: L√≥gica para el bot√≥n de administrador
    const currentUserId = localStorage.getItem('userData_userId');
    const adminButtonHtml = (currentUserId === 'BoardingGate')
        ? `<button id="mass-update-btn" class="reset-visuals-btn" style="background-color: #c0392b; margin-top: 15px; width: 100%;">ACTUALIZACI√ìN MASIVA</button>`
        : '';
    // --> FIN DEL A√ëADIDO
    
    helpModal.innerHTML = `
        <style>
            #reminders-map-help-modal-instance h3 { color: #87CEEB; margin-top: 1.2rem; margin-bottom: 0.5rem; border-bottom: 1px solid #444; padding-bottom: 4px;}
            #reminders-map-help-modal-instance ul { list-style-position: inside; padding-left: 0.5rem; }
            #reminders-map-help-modal-instance li { margin-bottom: 0.5rem; }
            #reminders-map-help-modal-instance .icon-in-text { height: 1.4em; display: inline; vertical-align: middle; margin: 0 4px; padding: 2px; border-radius: 4px; background: rgba(255,255,255,0.1);}
            #reminders-map-help-modal-instance .icon-in-text.circle { border-radius: 50%; }
            .visual-settings-container { background-color: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin-top: 10px; flex-grow: 1;}
            .slider-control { display: flex; align-items: center; gap: 15px; margin-bottom: 10px; }
            .slider-control label { flex-shrink: 0; text-align: right; font-weight: bold; color: #a0a0a0; }
            .slider-control .value-display { width: 90px; flex-shrink: 0; font-weight: bold; color: #f0f0f0; text-align: left; }
            .slider-control > input[type="range"] { flex-grow: 1; }
            .reset-visuals-btn { background-color: #0838a3; color: white; padding: 4px 8px; border:none; border-radius: 5px; cursor: pointer; margin-top: 5px; }
            .slider-input-wrapper { display: flex; align-items: center; gap: 8px; flex-grow: 1; }
            .slider-input-wrapper input[type="range"] { flex-grow: 1; }
            .slider-btn {
                flex-shrink: 0; width: 28px; height: 28px;
                background-color: #0838a3; color: white;
                border: 1px solid #777; border-radius: 50%;
                cursor: pointer; font-size: 20px; font-weight: bold;
                line-height: 26px; text-align: center;
                padding: 0; user-select: none;
            }
            .slider-btn:active { background-color: #777; transform: scale(0.95); }
            .lerp-help-text { font-size: 0.8rem; color: #b0b0b0; margin-top: 10px; text-align: center; font-style: italic; }
            .two-column-layout { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem; }
            .two-column-layout > div { display: flex; flex-direction: column; }
            .settings-checkbox-label {display: flex; align-items: center; cursor: pointer; font-size: 1rem; user-select: none;}
            .settings-checkbox-label input {width: 1.2rem; height: 1.2rem; margin-right: 10px; flex-shrink: 0;}
            .settings-checkbox-label span {font-weight: bold; color: #a0a0a0;}
            .memory-input-control { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; border-top: 1px solid #444; padding-top: 15px; }
            .memory-input-control label { white-space: normal; text-align: left; color: #a0a0a0; font-weight: bold; flex-grow: 1; }
            .memory-input-control input[type="number"] { width: 70px; text-align: center; background-color: #3a3a3c; border: 1px solid #555; color: #f0f0f0; border-radius: 4px; padding: 4px; font-size: 1rem; -moz-appearance: textfield; }
            .memory-input-control input[type="number"]::-webkit-outer-spin-button, .memory-input-control input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        </style>

        <h2 class="text-xl font-bold mb-4">Ayuda del Mapa de Navegaci√≥n</h2>
        <div class="modal-top-buttons" style="justify-content: flex-end;">
            <button type="button" id="close-reminders-map-help-instance" style="flex: 0 1 auto; min-width: 120px;">Entendido</button>
        </div>
        <div style="max-height: 70vh; overflow-y: auto; padding-right: 15px;">
            
            <h3><img src="https://boardinggate.github.io/Tesla/PNG/personal.png" class="icon-in-text"> Ajustes Visuales y Suavizado</h3>
            <div class="two-column-layout">
                <div>
                    <div class="visual-settings-container">
                        <div class="slider-control">
                            <label for="map-saturation-slider">Saturaci√≥n:</label>
                            <input type="range" id="map-saturation-slider" min="0.5" max="2" step="0.01">
                            <span id="map-saturation-value" class="value-display"></span>
                        </div>
                        <div class="slider-control">
                            <label for="map-contrast-slider">Contraste:</label>
                            <input type="range" id="map-contrast-slider" min="0.5" max="2" step="0.01">
                            <span id="map-contrast-value" class="value-display"></span>
                        </div>
                        <div class="slider-control">
                            <label for="map-exaggeration-slider">Desnivel 3D:</label>
                            <input type="range" id="map-exaggeration-slider" min="0" max="3" step="0.01">
                            <span id="map-exaggeration-value" class="value-display"></span>
                        </div>
                        <button id="map-visuals-reset-btn" class="reset-visuals-btn">Valores √≥ptimos</button>
                        <div class="visual-settings-container" style="margin-top: 10px; padding: 10px; text-align: left;">
                             <label for="direct-to-nav-checkbox-map-help" class="settings-checkbox-label">
                                 <input type="checkbox" id="direct-to-nav-checkbox-map-help">
                                 <span>Entrar directamente al Navegador</span>
                             </label>
                             <label for="announce-maneuver-flash-checkbox" class="settings-checkbox-label" style="margin-top: 10px;">
                                 <input type="checkbox" id="announce-maneuver-flash-checkbox">
                                 <span>Anunciar maniobra con destello</span>
                             </label>
                             <div class="slider-control" style="margin-top: 15px; border-top: 1px solid #444; padding-top: 15px;">
                                <label for="dynamic-radar-radius-slider">Radio Radares Din√°micos:</label>
                                <input type="range" id="dynamic-radar-radius-slider" min="50" max="2000" step="10">
                                <span id="dynamic-radar-radius-value" class="value-display"></span>
                             </div>
                        </div>
                    </div>
                </div>
                <div>
                    <div class="visual-settings-container">
                        <div class="slider-control">
                            <label for="lerp-position-slider" title="SUAVIZADO MOV.LATERAL MAPA:">Movimiento Lateral:</label>
                            <input type="range" id="lerp-position-slider" min="0.0001" max="0.02" step="0.0001" value="${currentLerpPosition}">
                            <span id="lerp-position-value" class="value-display">${parseFloat(currentLerpPosition).toFixed(4)}</span>
                        </div>
                        <div class="slider-control">
                            <label for="lerp-rotation-slider" title="SUAVIZADO ROTACIONES:">Rotaciones:</label>
                            <input type="range" id="lerp-rotation-slider" min="0.0001" max="0.02" step="0.0001" value="${currentLerpRotation}">
                            <span id="lerp-rotation-value" class="value-display">${parseFloat(currentLerpRotation).toFixed(4)}</span>
                        </div>
                        <div class="slider-control">
                            <label for="lerp-zoom-slider" title="SUAVIZADO INCLINACI√ìN">Zoom e Inclinaci√≥n:</label>
                            <input type="range" id="lerp-zoom-slider" min="0.0001" max="0.02" step="0.0001" value="${currentLerpZoom}">
                            <span id="lerp-zoom-value" class="value-display">${parseFloat(currentLerpZoom).toFixed(4)}</span>
                        </div>
                        <button id="lerp-reset-btn" class="reset-visuals-btn">Valores √≥ptimos</button>
                        <p class="lerp-help-text">(*) Valor Mayor = Movimientos m√°s bruscos y r√°pidos. Valor Menor = M√°s suaves y lentos.</p>
                    </div>
                </div>
            </div>

            <h3><img src="https://boardinggate.github.io/Tesla/PNG/config.jpg" class="icon-in-text"> Ajuste de Rendimiento (Navegaci√≥n)</h3>
            <div class="visual-settings-container">
                <p style="font-size: 0.9rem; margin-bottom: 15px;">Ajusta la frecuencia de actualizaci√≥n para optimizar el rendimiento. Un n√∫mero m√°s alto significa que la tarea se ejecuta con menos frecuencia (mejor rendimiento, menos actualizaciones). Un n√∫mero m√°s bajo es m√°s "en tiempo real" pero consume m√°s recursos.</p>
                <div class="slider-control">
                    <label for="gps-hz-display" style="color: #f0f0f0;">GPS Ticks/seg:</label>
                    <span id="gps-hz-display" class="value-display" style="text-align: left;">Calculando...</span>
                </div>
                <div class="slider-control">
                    <label for="camera-fps-slider">Animaci√≥n C√°mara FPS:</label>
                    <div class="slider-input-wrapper">
                        <button type="button" class="slider-btn minus" data-target="camera-fps-slider">-</button>
                        <button type="button" class="slider-btn plus" data-target="camera-fps-slider">+</button>
                        <input type="range" id="camera-fps-slider" min="5" max="60" step="1">
                    </div>
                    <span id="camera-fps-value" class="value-display"></span>
                </div>
                <div class="slider-control">
                    <label for="ratio-critical-update-slider">Procesos Cr√≠ticos.........:</label>
                    <div class="slider-input-wrapper">
                        <button type="button" class="slider-btn minus" data-target="ratio-critical-update-slider">-</button>
                        <button type="button" class="slider-btn plus" data-target="ratio-critical-update-slider">+</button>
                        <input type="range" id="ratio-critical-update-slider" min="1" max="100" step="1">
                    </div>
                    <span id="ratio-critical-update-value" class="value-display"></span>
                </div>
                <div class="slider-control">
                    <label for="ratio-route-progress-slider">Progreso Ruta..............:</label>
                     <div class="slider-input-wrapper">
                        <button type="button" class="slider-btn minus" data-target="ratio-route-progress-slider">-</button>
                        <button type="button" class="slider-btn plus" data-target="ratio-route-progress-slider">+</button>
                        <input type="range" id="ratio-route-progress-slider" min="1" max="200" step="1">
                    </div>
                    <span id="ratio-route-progress-value" class="value-display"></span>
                </div>
                <div class="slider-control">
                    <label for="ratio-traffic-alerts-slider">Alertas Tr√°fico.............:</label>
                    <div class="slider-input-wrapper">
                        <button type="button" class="slider-btn minus" data-target="ratio-traffic-alerts-slider">-</button>
                        <button type="button" class="slider-btn plus" data-target="ratio-traffic-alerts-slider">+</button>
                        <input type="range" id="ratio-traffic-alerts-slider" min="1" max="1000" step="1">
                    </div>
                    <span id="ratio-traffic-alerts-value" class="value-display"></span>
                </div>
                <div class="slider-control">
                    <label for="ratio-trip-stats-slider">Estad√≠sticas.................:</label>
                    <div class="slider-input-wrapper">
                        <button type="button" class="slider-btn minus" data-target="ratio-trip-stats-slider">-</button>
                        <button type="button" class="slider-btn plus" data-target="ratio-trip-stats-slider">+</button>
                        <input type="range" id="ratio-trip-stats-slider" min="1" max="1000" step="1">
                    </div>
                    <span id="ratio-trip-stats-value" class="value-display"></span>
                </div>
                <div class="slider-control">
                    <label for="ratio-performance-graph-slider">Gr√°fica.........................:</label>
                    <div class="slider-input-wrapper">
                        <button type="button" class="slider-btn minus" data-target="ratio-performance-graph-slider">-</button>
                        <button type="button" class="slider-btn plus" data-target="ratio-performance-graph-slider">+</button>
                        <input type="range" id="ratio-performance-graph-slider" min="1" max="1000" step="1">
                    </div>
                    <span id="ratio-performance-graph-value" class="value-display"></span>
                </div>
                <button id="perf-ratios-reset-btn" class="reset-visuals-btn">Valores √≥ptimos</button>
                <div class="visual-settings-container" style="margin-top: 10px; text-align: left;">
                     <div class="memory-input-control">
                         <label for="memory-threshold-input">Prevenir cuelgue al llegar la memoria al (%):</label>
                         <input type="number" id="memory-threshold-input" min="5" max="100" step="5">
                     </div>
                    <label for="monitor-resources-checkbox-map" class="settings-checkbox-label">
                        <input type="checkbox" id="monitor-resources-checkbox-map">
                        <span>Activar Monitor de Recursos (Memoria/FPS)</span>
                    </label>
                    <p style="font-size: 0.8rem; margin-left: 32px; color: #ff9500;">No dejar activado permanentemente, consume recursos adicionales.</p>
                    ${adminButtonHtml}
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(helpModal); 
    const mapModal = document.getElementById('reminders-location-map-modal');
    if (mapModal) {
        mapModal.style.zIndex = 6400;
    }

    const massUpdateButton = helpModal.querySelector('#mass-update-btn');
    if (massUpdateButton) {
        massUpdateButton.addEventListener('click', performMassUpdate);
    }
 
    const announceFlashCheckbox = helpModal.querySelector('#announce-maneuver-flash-checkbox');
    if (announceFlashCheckbox) {
        announceFlashCheckbox.checked = announceManeuverWithFlash;
        announceFlashCheckbox.addEventListener('change', () => {
            announceManeuverWithFlash = announceFlashCheckbox.checked;
            localStorage.setItem('boardinggate_announce_maneuver_flash', JSON.stringify(announceManeuverWithFlash));
            markCacheAsDirty();
            showToast(`Anuncio de maniobra por destello ${announceManeuverWithFlash ? 'ACTIVADO' : 'DESACTIVADO'}.`, 'info');
        });
    }
 
    const directToNavCheckboxMapHelp = helpModal.querySelector('#direct-to-nav-checkbox-map-help');
    if (directToNavCheckboxMapHelp) {
        directToNavCheckboxMapHelp.checked = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
        directToNavCheckboxMapHelp.addEventListener('change', () => {
            const isChecked = directToNavCheckboxMapHelp.checked;
            localStorage.setItem(DIRECT_TO_NAVIGATION_KEY, JSON.stringify(isChecked));
            markCacheAsDirty();
            showToast(`Inicio directo al navegador ${isChecked ? 'ACTIVADO' : 'DESACTIVADO'}.`, 'info');
        });
    }
    
    const setupLerpSlider = (sliderId, valueId, storageKey) => {
        const slider = helpModal.querySelector(`#${sliderId}`);
        const valueDisplay = helpModal.querySelector(`#${valueId}`);
        if (!slider || !valueDisplay) return;
        slider.addEventListener('input', () => {
            const val = slider.value;
            valueDisplay.textContent = parseFloat(val).toFixed(4);
            localStorage.setItem(storageKey, val);
            loadAndCacheLerpSettings(); 
            markCacheAsDirty();
         });
    };
    setupLerpSlider('lerp-position-slider', 'lerp-position-value', LERP_RATE_POS_KEY);
    setupLerpSlider('lerp-rotation-slider', 'lerp-rotation-value', LERP_RATE_ROT_KEY);
    setupLerpSlider('lerp-zoom-slider', 'lerp-zoom-value', LERP_RATE_ZOOM_KEY);

    const lerpResetBtn = helpModal.querySelector('#lerp-reset-btn');
    lerpResetBtn.addEventListener('click', () => {
        const defaults = { 'lerp-position-slider': '0.004', 'lerp-rotation-slider': '0.002', 'lerp-zoom-slider': '0.0007' };
        for (const sliderId in defaults) {
            const slider = helpModal.querySelector(`#${sliderId}`);
            if (slider) { slider.value = defaults[sliderId]; slider.dispatchEvent(new Event('input')); }
        }
     });

    const monitorCheckboxMap = helpModal.querySelector('#monitor-resources-checkbox-map');
    if (monitorCheckboxMap) {
        monitorCheckboxMap.checked = isMonitoring;
        monitorCheckboxMap.addEventListener('change', () => {
            if (monitorCheckboxMap.checked) { startResourceMonitor(); showToast('Monitor de recursos ACTIVADO.', 'info'); } 
            else { stopResourceMonitor(); showToast('Monitor de recursos DESACTIVADO.', 'info'); }
        });
    }

    helpModal.addEventListener('click', (e) => {
        if (e.target.classList.contains('slider-btn')) {
            e.preventDefault(); 
            const targetSliderId = e.target.dataset.target;
            const slider = helpModal.querySelector(`#${targetSliderId}`);
            if (slider) {
                if (e.target.classList.contains('minus')) { slider.stepDown(); } 
                else { slider.stepUp(); }
                slider.dispatchEvent(new Event('input'));
            }
        }
    });

    const gpsHzDisplay = helpModal.querySelector('#gps-hz-display');
    let baseFrequency = 0;
    
    const cameraFpsSlider = helpModal.querySelector('#camera-fps-slider');
    const cameraFpsValue = helpModal.querySelector('#camera-fps-value');
    if (cameraFpsSlider && cameraFpsValue) {
        cameraFpsSlider.value = baseCameraFps;
        cameraFpsValue.textContent = `${baseCameraFps} FPS`;
       
        cameraFpsSlider.addEventListener('input', () => {
            const fps = parseInt(cameraFpsSlider.value);
            cameraFpsValue.textContent = `${fps} FPS`;
            const newInterval = 1000 / fps;
            MAP_UPDATE_INTERVAL_MS = newInterval; 
            originalMapUpdateIntervalMs = newInterval; 
            localStorage.setItem(PERFORMANCE_CAMERA_FPS_KEY, fps);
            baseCameraFps = fps; 
            markCacheAsDirty();
        })
    }

    const sliders = [
        { id: 'ratio-critical-update-slider', valueId: 'ratio-critical-update-value', key: PERFORMANCE_RATIO_CRITICAL_KEY, default: 3, name: 'criticalUpdate' },
        { id: 'ratio-route-progress-slider', valueId: 'ratio-route-progress-value', key: PERFORMANCE_RATIO_ROUTE_KEY, default: 20, name: 'routeProgress' },
        { id: 'ratio-traffic-alerts-slider', valueId: 'ratio-traffic-alerts-value', key: PERFORMANCE_RATIO_ALERTS_KEY, default: 350, name: 'trafficAlerts' },
        { id: 'ratio-trip-stats-slider', valueId: 'ratio-trip-stats-value', key: PERFORMANCE_RATIO_STATS_KEY, default: 50, name: 'tripStats' },
        { id: 'ratio-performance-graph-slider', valueId: 'ratio-performance-graph-value', key: PERFORMANCE_RATIO_GRAPH_KEY, default: 75, name: 'performanceGraph' }
    ];

    const updateAllIntervalDisplays = () => {
        if (baseFrequency > 0) {
            sliders.forEach(sliderConfig => {
                const slider = helpModal.querySelector(`#${sliderConfig.id}`);
                const valueDisplay = helpModal.querySelector(`#${sliderConfig.valueId}`);
                if (slider && valueDisplay) {
                    const ratio = parseInt(slider.value);
                    const intervalMs = Math.round((ratio / baseFrequency) * 1000);
                    valueDisplay.textContent = `${ratio} (~${intervalMs} ms)`;
                }
            });
        } else {
            sliders.forEach(sliderConfig => {
                const slider = helpModal.querySelector(`#${sliderConfig.id}`);
                const valueDisplay = helpModal.querySelector(`#${sliderConfig.valueId}`);
                if (slider && valueDisplay) {
                    valueDisplay.textContent = `${slider.value} (~? ms)`;
                }
            });
        }
    };

    const setupRatioSlider = (config) => {
        const slider = helpModal.querySelector(`#${config.id}`);
        const valueDisplay = helpModal.querySelector(`#${config.valueId}`);
        if (!slider || !valueDisplay) return;
        slider.value = localStorage.getItem(config.key) || config.default;
        performanceRatios[config.name] = parseInt(slider.value);
        slider.addEventListener('input', () => {
            const val = slider.value;
            localStorage.setItem(config.key, val);
            markCacheAsDirty(); 
            performanceRatios[config.name] = parseInt(val);
            if (config.name === 'criticalUpdate') { 
                baseCriticalRatio = parseInt(val);
            }
            updateAllIntervalDisplays();
        });
    };
    
    sliders.forEach(setupRatioSlider);
    
    if (gpsHzDisplay) {
        if (gpsHzMonitor.interval) clearInterval(gpsHzMonitor.interval);
        gpsHzMonitor.interval = setInterval(() => {
            if (document.body.contains(gpsHzDisplay)) {
                if (isSimulatingGpsLocation) {
                    baseFrequency = (1000 / SIMULATION_TICK_INTERVAL_MS);
                    gpsHzDisplay.textContent = `SIM (~${baseFrequency.toFixed(1)})`;
                } else {
                    baseFrequency = gpsHzMonitor.ticks;
                    gpsHzDisplay.textContent = `${baseFrequency.toFixed(1)}`;
                    gpsHzMonitor.ticks = 0;
                }
                updateAllIntervalDisplays();
            } else {
                clearInterval(gpsHzMonitor.interval);
                gpsHzMonitor.interval = null;
            }
        }, 1000);
    }

    const perfResetBtn = helpModal.querySelector('#perf-ratios-reset-btn');
    perfResetBtn.addEventListener('click', () => {
        const teslaYearStr = localStorage.getItem('userData_teslaYear');
        const teslaYear = parseInt(teslaYearStr, 10);
        const defaultsNewerCars = { cameraFps: 18, criticalUpdate: 3, routeProgress: 20, trafficAlerts: 350, tripStats: 50, performanceGraph: 75 };
        const defaultsOlderCars = { cameraFps: 14, criticalUpdate: 4, routeProgress: 30, trafficAlerts: 370, tripStats: 60, performanceGraph: 100 };
        let defaultsToApply = (isNaN(teslaYear) || teslaYear >= 2021) ? defaultsNewerCars : defaultsOlderCars;
        if (cameraFpsSlider) {
            cameraFpsSlider.value = defaultsToApply.cameraFps;
            cameraFpsSlider.dispatchEvent(new Event('input'));
        }
        sliders.forEach(config => {
            const slider = document.getElementById(config.id);
            if (slider && defaultsToApply.hasOwnProperty(config.name)) {
                slider.value = defaultsToApply[config.name];
                slider.dispatchEvent(new Event('input'));
            }
        });
        showToast("Valores restaurados por defecto.", 'success');
    });

    const memoryThresholdInput = helpModal.querySelector('#memory-threshold-input');
    if (memoryThresholdInput) {
        memoryThresholdInput.value = Math.round(memoryReloadThreshold * 100);
        memoryThresholdInput.addEventListener('change', () => {
            let value = parseInt(memoryThresholdInput.value, 10);
            if (isNaN(value) || value < 5 || value > 100) {
                showToast("El umbral debe estar entre 5 y 100.", "warning");
                memoryThresholdInput.value = Math.round(memoryReloadThreshold * 100);
                return;
            }
            memoryReloadThreshold = value / 100.0;
            localStorage.setItem('boardinggate_memory_threshold', memoryReloadThreshold);
            markCacheAsDirty();
            showToast(`Umbral de recarga de memoria guardado al ${value}%.`, 'success');
        });
    }

    const saturationSlider = helpModal.querySelector('#map-saturation-slider');
    const contrastSlider = helpModal.querySelector('#map-contrast-slider');
    const exaggerationSlider = helpModal.querySelector('#map-exaggeration-slider'); 
    const saturationValue = helpModal.querySelector('#map-saturation-value');
    const contrastValue = helpModal.querySelector('#map-contrast-value');
    const exaggerationValue = helpModal.querySelector('#map-exaggeration-value'); 
    const resetButton = helpModal.querySelector('#map-visuals-reset-btn');
    const updateVisualLabels = () => {
        saturationValue.textContent = `${Math.round(saturationSlider.value * 100)}%`;
        contrastValue.textContent = `${Math.round(contrastSlider.value * 100)}%`;
        exaggerationValue.textContent = `${parseFloat(exaggerationSlider.value).toFixed(2)}x`; 
    };
    saturationSlider.value = getComputedStyle(document.documentElement).getPropertyValue('--map-saturation').trim() || '1.6';
    contrastSlider.value = getComputedStyle(document.documentElement).getPropertyValue('--map-contrast').trim() || '1.15';
    exaggerationSlider.value = mapTerrainExaggeration; 
    updateVisualLabels();
    saturationSlider.addEventListener('input', () => {
        document.documentElement.style.setProperty('--map-saturation', saturationSlider.value);
        localStorage.setItem('boardinggate_map_saturation', saturationSlider.value);
        markCacheAsDirty(); updateVisualLabels();
    });
    contrastSlider.addEventListener('input', () => {
        document.documentElement.style.setProperty('--map-contrast', contrastSlider.value);
        localStorage.setItem('boardinggate_map_contrast', contrastSlider.value);
        updateVisualLabels(); markCacheAsDirty();
    });
    exaggerationSlider.addEventListener('input', async () => {
        mapTerrainExaggeration = parseFloat(exaggerationSlider.value);
        saveSettings(); await configureMapAtmosphere(); updateVisualLabels();
    });
    resetButton.addEventListener('click', () => {
        saturationSlider.value = '1.6';
        contrastSlider.value = '1.2';
        exaggerationSlider.value = '0.5'; 
        saturationSlider.dispatchEvent(new Event('input'));
        contrastSlider.dispatchEvent(new Event('input'));
        exaggerationSlider.dispatchEvent(new Event('input')); 
        showToast('Ajustes visuales restaurados.', 'info');
    });

    const DYNAMIC_RADAR_RADIUS_KEY = 'boardinggate_dynamicRadarRadius';
    const radarRadiusSlider = helpModal.querySelector('#dynamic-radar-radius-slider');
    const radarRadiusValue = helpModal.querySelector('#dynamic-radar-radius-value');
    if (radarRadiusSlider && radarRadiusValue) {
        const savedRadius = parseInt(localStorage.getItem(DYNAMIC_RADAR_RADIUS_KEY)) || 400;
        radarRadiusSlider.value = savedRadius;
        radarRadiusValue.textContent = `${savedRadius} m`;
        radarRadiusSlider.addEventListener('input', () => {
            const radius = parseInt(radarRadiusSlider.value);
            radarRadiusValue.textContent = `${radius} m`;
            localStorage.setItem(DYNAMIC_RADAR_RADIUS_KEY, radius);
            markCacheAsDirty();
        });
        resetButton.addEventListener('click', () => {
            const defaultRadius = 400;
            radarRadiusSlider.value = defaultRadius;
            radarRadiusValue.textContent = `${defaultRadius} m`;
            localStorage.setItem(DYNAMIC_RADAR_RADIUS_KEY, defaultRadius);
            markCacheAsDirty();
        });
    }
   
    const closeButtonHelp = helpModal.querySelector('#close-reminders-map-help-instance');
    const closeHandlerHelp = () => { 
        if(gpsHzMonitor.interval) clearInterval(gpsHzMonitor.interval);
        gpsHzMonitor.interval = null;
        clearModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance'); 
        if (helpModal.parentNode) helpModal.remove(); 
        if (mapModal) mapModal.style.zIndex = '';
    };
    
    closeButtonHelp.addEventListener('click', closeHandlerHelp); 
    addModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance', 90000);
}

// ===================================================================
// NOMBRE: resetNavigationState 
// RESUMEN: Reinicia a su estado original TODAS las variables relacionadas
function resetNavigationState() {
    clearAllRouteVisualsFromMap();

    const autoStartModal = document.getElementById('auto-start-nav-modal');
    if (autoStartModal) {
        hideAutoStartNavigationModal();
        showToast("Inicio autom√°tico cancelado: La ruta ha sido modificada/borrada.", "info");
    }

    const minimapContainer = document.getElementById('minimap-container');
    if (minimapContainer) {
        minimapContainer.classList.add('hidden');
    }
    if (minimapInstance) {
        try {
            minimapInstance.remove(); 
    } catch(e) {
        }
        minimapInstance = null;
        minimapCarMarker = null; 
    }

    if (initialUserLocationMarker) {
        try { initialUserLocationMarker.remove(); } catch(e) {}
        initialUserLocationMarker = null;
    }
    if (groundAnchorMarker) {
        try { groundAnchorMarker.remove(); } catch(e) {}
        groundAnchorMarker = null;
    }

    navigationWaypoints = [];
    navigationCurrentRouteData = null;
    isNavigating = false;
    currentRouteNameForSaving = null;
    
    lastCarDistanceAlongRouteForNavLogic = 0;
    lastValidCarDistanceForDisplay = 0;
    currentLegIndexNav = 0;
    currentStepIndexNav = 0;
    previousLegIndexForEta = 0;
    lastDisplayedManeuverIcon = null;
    lastProcessedStepIdentifier = null;
    lastProcessedStepForLock = null;

    tripInitialOverallEtaTime = null;
    originalTripEtaTime = null; 
    currentStageInitialExpectedEtaTime = null;
    accumulatedDeviationMs = 0;
    accumulatedDistanceBeforeCurrentSegment = 0;
    navigationStartTimeForStats = null;
    totalDistanceTravelledForStats = 0;
    lastPositionForStats = null;
    maxSpeedDuringTrip = 0;
    maxSpeedCoordinates = null;
    maxAltitudeDuringTrip = -Infinity;
    minAltitudeDuringTrip = Infinity;
    window.averageSpeedKmh = 0;
    reminderMapObjects = [];
    radaresEnRutaActual = [];
    tareasEnRutaActual = [];
    alternativeRoutesCache.clear();
    selectedStageRoutes.clear();

    lastPdrSearchResults = [];
    currentChargingPointsOnRoute = [];
    if (window.lastOcmApiResponse) {
        window.lastOcmApiResponse = null;
    }
    
    isCacheDirty = true;
    trafficAlertsCache = [];
    
    speedMarkerFeatures = [];
    if (navigationMapInstance && navigationMapInstance.getSource('speed-markers-source')) {
        navigationMapInstance.getSource('speed-markers-source').setData({
            type: 'FeatureCollection',
            features: [] 
        });
    }

    updateDynamicRadars(true);
    
    isArrivalSequenceStarted = false;
    hideNavigationUI();
    hideMapInfoOverlay();
    clearNavigationGraph();
    
    actualizarContadorRadares(0);
    actualizarContadorTareas(0);
}
// ===================================================================
// NOMBRE: checkForAndExecuteCrashRecovery (CON PERIODO DE GRACIA)
// RESUMEN: Gestiona la recuperaci√≥n, estableciendo un periodo de gracia para la comprobaci√≥n de memoria.
async function checkForAndExecuteCrashRecovery() {
    const recoveryFlagJSON = localStorage.getItem('boardinggate_nav_recovery_flag');
    if (!recoveryFlagJSON) {
        return false;
    }

    const memoryCheckGracePeriodSeconds = 300;
    memoryCheckGracePeriodUntil = Date.now() + (memoryCheckGracePeriodSeconds * 1000);
    
    const isControlled = sessionStorage.getItem('isControlledReload') === 'true';

    try {
        const recoveryData = JSON.parse(recoveryFlagJSON);
        if (recoveryData && recoveryData.isActive && recoveryData.route) {
            
            if (!isControlled) {
                mapHeaderButtonsVisible = false; 
                const overlay = document.getElementById('route-recovery-overlay');
                if (overlay) {
                    overlay.classList.remove('hidden');
                }
            }
            
            const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'none';
            const footer = document.querySelector('footer'); if (footer) footer.style.display = 'none';
            const noticesContainer = document.querySelector('.notices-icon-container'); if (noticesContainer) noticesContainer.style.display = 'none';
            const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'none');
            document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button, #accident-alert-button').forEach(el => el.style.display = 'none');
            const gridFilter = document.getElementById('grid-filter-container'); if (gridFilter) gridFilter.style.display = 'none';
            
            try {
                await openNavigationMap(true); 
                await loadRouteFromObject(recoveryData.route, true, true, recoveryData); 
                return true;

            } catch (recoveryError) {
                clearRecoveryFlag();
                if (!isControlled) {
                    const overlay = document.getElementById('route-recovery-overlay');
                    if (overlay) overlay.classList.add('hidden'); 
                }
                showToast("Fallo en la recuperaci√≥n. Recargando de nuevo...", "error", 2000);
                setTimeout(() => location.reload(), 100);
                return true; // Se considera gestionado.
            }
        }
    } catch (e) {
    }

    clearRecoveryFlag();
    return false;
}    

// ===================================================================
// NOMBRE: updateNavigationProgressDisplay 
// RESUMEN: Muestra la barra de progreso completa SOLO si isNavigating es true. En caso contrario, muestra la versi√≥n reducida con ETA.
// ===================================================================
function updateNavigationProgressDisplay(route, carDistanceAlongTheRoute = 0) {
    const progressBarContainer = document.getElementById('navigation-bottom-progress-bar');
    if (!progressBarContainer) return;

    const topInfoBar = document.getElementById('navigation-top-info-bar');
    const overallProgressContainer = document.getElementById('route-overall-progress-container');
    const etaInfoContainer = document.getElementById('navigation-eta-info');
    const maneuverDistanceWrapper = document.getElementById('maneuver-distance-progress-wrapper');
    const hrSeparator = progressBarContainer.querySelector('hr');
    let freeDriveCard = document.getElementById('free-drive-stats-card');

    if (isFreeDriveActive) {
        // MODO FREE DRIVE: Mostrar solo la tarjeta de viaje libre
        progressBarContainer.style.display = 'flex';
        progressBarContainer.style.minWidth = 'auto';
        progressBarContainer.style.width = 'auto';
        if (topInfoBar) topInfoBar.style.display = 'none';
        if (overallProgressContainer) overallProgressContainer.style.display = 'none';
        if (etaInfoContainer) etaInfoContainer.style.display = 'none';
        if (maneuverDistanceWrapper) maneuverDistanceWrapper.style.display = 'none';
        if (hrSeparator) hrSeparator.style.display = 'none';
    } else {
        const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
        const hasValidRoute = route && typeof route.distance === 'number' && typeof route.duration === 'number' && actualWaypoints.length >= 2;

        if (hasValidRoute) {
            // HAY RUTA: Mostrar la barra de progreso, pero adaptar su contenido
            progressBarContainer.style.display = 'flex';
            progressBarContainer.style.minWidth = '480px';
            progressBarContainer.style.width = 'auto';
            
            // SIEMPRE visibles si hay ruta
            if (overallProgressContainer) overallProgressContainer.style.display = 'block';
            if (etaInfoContainer) etaInfoContainer.style.display = 'flex';

            if (isNavigating) {
                // MODO NAVEGACI√ìN ACTIVA: Mostrar todo
                if (topInfoBar) topInfoBar.style.display = 'flex';
                if (maneuverDistanceWrapper) maneuverDistanceWrapper.style.display = 'block';
                if (hrSeparator) hrSeparator.style.display = 'block';
            } else {
                // MODO PLANIFICACI√ìN: Ocultar la parte superior
                if (topInfoBar) topInfoBar.style.display = 'none';
                if (maneuverDistanceWrapper) maneuverDistanceWrapper.style.display = 'none';
                if (hrSeparator) hrSeparator.style.display = 'none';
            }
        } else {
            // NO HAY RUTA: Ocultar todo
            progressBarContainer.style.display = 'none';
            return;
        }
    }
  
    if (isFreeDriveActive) {
        if (!freeDriveCard) {
            freeDriveCard = document.createElement('div');
            freeDriveCard.id = 'free-drive-stats-card';
            progressBarContainer.appendChild(freeDriveCard);
        }
        freeDriveCard.style.display = 'block';

        const kmRealizadosTexto = `${(totalDistanceTravelledForStats / 1000).toFixed(1)} km`;
        const startTime = freeDriveStats ? freeDriveStats.startTime : new Date();
        const startTimeFormatted = `${startTime.getHours().toString().padStart(2, '0')}:${startTime.getMinutes().toString().padStart(2, '0')}`;
        const durationMs = Date.now() - startTime.getTime();
        const totalTravelSeconds = Math.floor(durationMs / 1000); 
        const travelHours = Math.floor(totalTravelSeconds / 3600);
        const travelMinutes = Math.floor((totalTravelSeconds % 3600) / 60);
        const travelSeconds = totalTravelSeconds % 60;
        const travelTimeFormatted = `${String(travelHours).padStart(2, '0')}:${String(travelMinutes).padStart(2, '0')}:${String(travelSeconds).padStart(2, '0')}`;
       
        const newFreeDriveHTML = `
            <div class="free-drive-card-content">
                <div class="fd-title">Modo Free Drive</div>
                <div class="fd-stats-grid">
                    <div class="fd-label">Distancia</div>
                    <div class="fd-label">Inicio</div>
                    <div class="fd-label">Duraci√≥n</div>
                    <div class="fd-data">${kmRealizadosTexto}</div>
                    <div class="fd-data">${startTimeFormatted}</div>
                    <div class="fd-data">${travelTimeFormatted}</div>
                </div>
            </div>
        `;
        if (freeDriveCard.innerHTML !== newFreeDriveHTML) {
            freeDriveCard.innerHTML = newFreeDriveHTML;
        }
        return;
    }

    if (freeDriveCard) {
        freeDriveCard.style.display = 'none';
    }
    
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    if (!route || typeof route.distance !== 'number' || typeof route.duration !== 'number' || actualWaypoints.length < 2) {
        return;
    }
    const overallProgressFill = document.getElementById('route-overall-progress');
    const routeProgressTextEl = document.getElementById('route-progress-text');
    const routeProgressIconEl = document.getElementById('route-progress-icon');
    const nextStageDistEl = document.getElementById('next-stage-distance');
    const nextStageTimeEl = document.getElementById('next-stage-time');
    const nextStageEtaEl = document.getElementById('next-stage-eta');
    const nextStageDeviationEl = document.getElementById('next-stage-eta-deviation');
    const finalDestDistEl = document.getElementById('final-destination-distance');
    const finalDestTimeEl = document.getElementById('final-destination-time');
    const finalDestEtaEl = document.getElementById('final-destination-eta');
    const finalDestDeviationEl = document.getElementById('final-destination-eta-deviation');
    const nextStageInfoDiv = document.getElementById('next-stage-info');
    const finalDestInfoDiv = document.getElementById('final-destination-info');
    const nextStageLabelEl = document.getElementById('next-stage-label');
    const totalJourneyDistanceForBar = (accumulatedDistanceBeforeCurrentSegment || 0) + route.distance;
    const currentJourneyDistanceForBar = (accumulatedDistanceBeforeCurrentSegment || 0) + carDistanceAlongTheRoute;
    const progressPercent = totalJourneyDistanceForBar > 0 ? (currentJourneyDistanceForBar / totalJourneyDistanceForBar) * 100 : 0;
    
    const newOverallWidth = `${Math.min(100, progressPercent)}%`;
    if (overallProgressFill.style.width !== newOverallWidth) {
        overallProgressFill.style.width = newOverallWidth;
    }
    if (routeProgressIconEl) {
        const shouldDisplayIcon = progressPercent > 0 && progressPercent < 100;
        if ((routeProgressIconEl.style.display === 'none') === shouldDisplayIcon) {
            routeProgressIconEl.style.display = shouldDisplayIcon ? 'block' : 'none';
        }
    }
    if (routeProgressTextEl) {
        let kmRecorridosTexto = isNavigating && navigationStartTimeForStats ? `${(totalDistanceTravelledForStats / 1000).toFixed(1)} km` : "0.0 km";
        let timeInfoString = isNavigating && navigationStartTimeForStats ? ` (${navigationStartTimeForStats.getHours().toString().padStart(2, '0')}:${navigationStartTimeForStats.getMinutes().toString().padStart(2, '0')} ‚Ä¢ ${String(Math.floor((Date.now() - navigationStartTimeForStats) / 3600000)).padStart(2, '0')}:${String(Math.floor(((Date.now() - navigationStartTimeForStats) % 3600000) / 60000)).padStart(2, '0')})` : ` (Stop)`;
        
        const newProgressTextHtml = `${kmRecorridosTexto}${timeInfoString}`;
        if (routeProgressTextEl.innerHTML !== newProgressTextHtml) {
            routeProgressTextEl.innerHTML = newProgressTextHtml;
        }
    }
    const remainingDistanceTotal = Math.max(0, route.distance - carDistanceAlongTheRoute);
    const remainingDurationTotal = route.distance > 0 ? route.duration * (remainingDistanceTotal / route.distance) : 0;
    
    const finalDistText = `${(remainingDistanceTotal / 1000).toFixed(1)} km`;
    if (finalDestDistEl.textContent !== finalDistText) finalDestDistEl.textContent = finalDistText;

    const finalDestTotalMinutes = Math.round(remainingDurationTotal / 60);
    const finalTimeText = `${String(Math.floor(finalDestTotalMinutes / 60)).padStart(2, '0')}:${String(finalDestTotalMinutes % 60).padStart(2, '0')}`;
    if (finalDestTimeEl.textContent !== finalTimeText) finalDestTimeEl.textContent = finalTimeText;

    const currentFinalEta = new Date(Date.now() + remainingDurationTotal * 1000);
    const finalEtaText = currentFinalEta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    if (finalDestEtaEl.textContent !== finalEtaText) finalDestEtaEl.textContent = finalEtaText;

    let finalDeviationHtml = "";
    if (originalTripEtaTime && isNavigating && navigationStartTimeForStats) {
        const finalDeviationMs = currentFinalEta.getTime() - originalTripEtaTime.getTime();
        finalDeviationHtml = formatDeviation(finalDeviationMs);
    }
    
    if (finalDestDeviationEl.innerHTML !== finalDeviationHtml) {
        finalDestDeviationEl.innerHTML = finalDeviationHtml;
    }
    
    const hasUnvisitedIntermediateStages = actualWaypoints.some(wp => !wp.visited && wp.type === 'intermediate');
    if (hasUnvisitedIntermediateStages) {
        etaInfoContainer.classList.remove('single-destination');
        finalDestInfoDiv.classList.remove('single-destination-layout');
        nextStageInfoDiv.style.display = 'block';
        const totalRealStages = actualWaypoints.length - 1;
        const currentRealStageIndex = actualWaypoints.findIndex(wp => !wp.visited && wp.type !== 'S') -1;
        const nextStageWaypointObject = actualWaypoints.find(wp => !wp.visited && wp.type !== 'S');
        if (nextStageLabelEl && nextStageWaypointObject) {
            let stageDescription = nextStageWaypointObject.address || `Etapa ${nextStageWaypointObject.label}`;
            if (stageDescription.length > 20) {
                stageDescription = stageDescription.substring(0, 20) + '...';
            }
            const newLabelText = `Etapa ${currentRealStageIndex + 1} de ${totalRealStages}: ${stageDescription}`;
            if (nextStageLabelEl.textContent !== newLabelText) {
                nextStageLabelEl.textContent = newLabelText;
            }
        }
        let cumulativeDistanceToStartOfCurrentLegOSRM = 0;
        if (route.legs) {
            for (let i = 0; i < currentLegIndexNav; i++) {
                if (route.legs[i] && typeof route.legs[i].distance === 'number') {
                    cumulativeDistanceToStartOfCurrentLegOSRM += route.legs[i].distance;
                }
            }
        }
        const legForDisplay = route.legs[currentLegIndexNav];
        if (legForDisplay) {
            const distanceIntoCurrentLegDisplay = Math.max(0, carDistanceAlongTheRoute - cumulativeDistanceToStartOfCurrentLegOSRM);
            const remainingDistanceThisLegDisplay = Math.max(0, (legForDisplay.distance || 0) - distanceIntoCurrentLegDisplay);
            const remainingDurationThisLegDisplay = (legForDisplay.distance > 0 && typeof legForDisplay.duration === 'number') ? legForDisplay.duration * (remainingDistanceThisLegDisplay / legForDisplay.distance) : 0;
            const currentNextStageEta = new Date(Date.now() + remainingDurationThisLegDisplay * 1000);
            
            const nextDistText = `${(remainingDistanceThisLegDisplay / 1000).toFixed(1)} km`;
            if (nextStageDistEl.textContent !== nextDistText) nextStageDistEl.textContent = nextDistText;

            const nextStageTotalMinutes = Math.round(remainingDurationThisLegDisplay / 60);
            const nextTimeText = `${String(Math.floor(nextStageTotalMinutes / 60)).padStart(2, '0')}:${String(nextStageTotalMinutes % 60).padStart(2, '0')}`;
            if (nextStageTimeEl.textContent !== nextTimeText) nextStageTimeEl.textContent = nextTimeText;
            
            const nextEtaText = currentNextStageEta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            if (nextStageEtaEl.textContent !== nextEtaText) nextStageEtaEl.textContent = nextEtaText;
            
            let nextStageDeviationHtml = "";
            if (currentStageInitialExpectedEtaTime && isNavigating && navigationStartTimeForStats) {
               const deviationStageMs = currentNextStageEta.getTime() - currentStageInitialExpectedEtaTime.getTime();
               nextStageDeviationHtml = formatDeviation(accumulatedDeviationMs + deviationStageMs);
            }
            if (nextStageDeviationEl.innerHTML !== nextStageDeviationHtml) {
                nextStageDeviationEl.innerHTML = nextStageDeviationHtml;
            }
        }
    } else {
        etaInfoContainer.classList.add('single-destination');
        finalDestInfoDiv.classList.add('single-destination-layout');
        nextStageInfoDiv.style.display = 'none';
        if(nextStageDeviationEl && nextStageDeviationEl.innerHTML !== "") nextStageDeviationEl.innerHTML = "";
    }
   
    if (isNavigating) {
        const destinationWp = navigationWaypoints[navigationWaypoints.length - 1];
        if (destinationWp && destinationWp.address) {
            const mapOverlay = document.getElementById('map-info-overlay');
            if (mapOverlay && !mapOverlay.textContent.startsWith("HA LLEGADO AL ")) {
                 showDestinationName();
            }
        }
    }
}
    
    
//==================================================================
//==================================================================    
function animateMarkerAndMap(timestamp) {
    const now = timestamp || performance.now();
    if (now - lastMapUpdateTime < MAP_UPDATE_INTERVAL_MS) {
        markerAnimationState.animationFrameId = requestAnimationFrame(animateMarkerAndMap);
        return;
    }
    lastMapUpdateTime = now;
    
    if (!initialUserLocationMarker || !navigationMapInstance || isFlying) {
        markerAnimationState.animationFrameId = requestAnimationFrame(animateMarkerAndMap);
        return;
    }

    if (!markerAnimationState.lastTimestamp) {
        markerAnimationState.lastTimestamp = timestamp;
        markerAnimationState.animationFrameId = requestAnimationFrame(animateMarkerAndMap);
        return;
    }

    const deltaTime = timestamp - markerAnimationState.lastTimestamp;
    markerAnimationState.lastTimestamp = timestamp;
    const clampedDeltaTime = Math.min(deltaTime, 33);

    const posLerpFactor = 1.0 - Math.exp(-clampedDeltaTime * lerpRatePosition);
    const rotLerpFactor = 1.0 - Math.exp(-clampedDeltaTime * lerpRateRotation);
    const zoomPitchLerpFactor = 1.0 - Math.exp(-clampedDeltaTime * lerpRateZoom);

    if (markerAnimationState.currentLngLat && markerAnimationState.targetLngLat) {
        markerAnimationState.currentLngLat.lng += (markerAnimationState.targetLngLat.lng - markerAnimationState.currentLngLat.lng) * posLerpFactor;
        markerAnimationState.currentLngLat.lat += (markerAnimationState.targetLngLat.lat - markerAnimationState.currentLngLat.lat) * posLerpFactor;
        initialUserLocationMarker.setLngLat(markerAnimationState.currentLngLat);
        
        if (groundAnchorMarker) {
            groundAnchorMarker.setLngLat(markerAnimationState.currentLngLat);
        }
     }
    let deltaIconRotation = markerAnimationState.targetIconRotation - markerAnimationState.currentIconRotation;
    if (deltaIconRotation > 180) deltaIconRotation -= 360;
    if (deltaIconRotation < -180) deltaIconRotation += 360;
    markerAnimationState.currentIconRotation += deltaIconRotation * rotLerpFactor;
    initialUserLocationMarker.setRotation(markerAnimationState.currentIconRotation);

    if (shouldCenterOnUser || navigationFollowUser) {
        
        if (markerAnimationState.currentMapCenter && markerAnimationState.targetLngLat) {
            markerAnimationState.currentMapCenter.lng += (markerAnimationState.targetLngLat.lng - markerAnimationState.currentMapCenter.lng) * posLerpFactor;
            markerAnimationState.currentMapCenter.lat += (markerAnimationState.targetLngLat.lat - markerAnimationState.currentMapCenter.lat) * posLerpFactor;
        }

        if (markerAnimationState.currentMapAltitude !== null && markerAnimationState.targetMapAltitude !== null) {
            markerAnimationState.currentMapAltitude += (markerAnimationState.targetMapAltitude - markerAnimationState.currentMapAltitude) * posLerpFactor;
        } else {
             markerAnimationState.currentMapAltitude = markerAnimationState.targetMapAltitude;
        }
        
        let deltaMapBearing = markerAnimationState.targetMapBearing - markerAnimationState.currentMapBearing;
        if (deltaMapBearing > 180) deltaMapBearing -= 360;
        if (deltaMapBearing < -180) deltaMapBearing += 360;
        markerAnimationState.currentMapBearing += deltaMapBearing * rotLerpFactor;
        
        markerAnimationState.currentMapZoom += (markerAnimationState.targetMapZoom - markerAnimationState.currentMapZoom) * zoomPitchLerpFactor;
        markerAnimationState.currentMapPitch += (markerAnimationState.targetMapPitch - markerAnimationState.currentMapPitch) * zoomPitchLerpFactor;
        
        markerAnimationState.currentMapOffsetX += (markerAnimationState.targetMapOffsetX - markerAnimationState.currentMapOffsetX) * zoomPitchLerpFactor;
        markerAnimationState.currentMapOffsetY += (markerAnimationState.targetMapOffsetY - markerAnimationState.currentMapOffsetY) * zoomPitchLerpFactor;

        let offsetXToUse = markerAnimationState.currentMapOffsetX;
        let offsetYToUse = markerAnimationState.currentMapOffsetY;

        const viewModes = { '3D RELIEVE': { mode: 'relief' } };
        const savedViewMode = localStorage.getItem(MAP_VIEW_MODE_KEY) || 'relief';
        if (savedViewMode === viewModes['3D RELIEVE'].mode) {
            offsetXToUse = Math.max(-10, Math.min(offsetXToUse, 10));
            offsetYToUse = Math.max(-20, Math.min(offsetYToUse, 20));
        }

        const canvas = navigationMapInstance.getCanvas();
        const pitchInRadians = (markerAnimationState.currentMapPitch * Math.PI) / 180;
        const cameraHeightAboveCar = 150; 
        
        const verticalOffsetFactor = offsetYToUse / 100;
        const groundDistanceOffset = (cameraHeightAboveCar * Math.tan(pitchInRadians)) * verticalOffsetFactor * -1; // Hacia atr√°s

        const metersPerPixel = 156543.03 * Math.cos(markerAnimationState.currentMapCenter.lat * Math.PI / 180) / Math.pow(2, markerAnimationState.currentMapZoom);
        const pixelOffsetX = canvas.clientWidth * (offsetXToUse / 100);
        const horizontalDistanceOffset = metersPerPixel * pixelOffsetX * -1; // -1 para que el anclaje se mueva en direcci√≥n opuesta al coche

        const totalDistance = Math.sqrt(Math.pow(groundDistanceOffset, 2) + Math.pow(horizontalDistanceOffset, 2));
        const angleAdjustment = Math.atan2(horizontalDistanceOffset, groundDistanceOffset) * (180 / Math.PI); // √Ångulo relativo al vector "hacia atr√°s"

        _turfCarPointForAnimation.geometry.coordinates[0] = markerAnimationState.currentMapCenter.lng;
        _turfCarPointForAnimation.geometry.coordinates[1] = markerAnimationState.currentMapCenter.lat;
        const finalBearingForOffset = markerAnimationState.currentMapBearing - 180 + angleAdjustment;
        const cameraAnchorPoint = turf.destination(_turfCarPointForAnimation, totalDistance / 1000, finalBearingForOffset, { units: 'kilometers' });
        
        const cameraOptions = {
            center: cameraAnchorPoint.geometry.coordinates,
            zoom: markerAnimationState.currentMapZoom,
            bearing: markerAnimationState.currentMapBearing,
            pitch: markerAnimationState.currentMapPitch,
            offset: [0, 0]
        };
        
        if (markerAnimationState.currentMapAltitude !== null && !isNaN(markerAnimationState.currentMapAltitude)) {
            cameraOptions.altitude = markerAnimationState.currentMapAltitude;
        }

        navigationMapInstance.jumpTo(cameraOptions);
    }
    
    markerAnimationState.animationFrameId = requestAnimationFrame(animateMarkerAndMap);
}

//===================================================================
// NOMBRE: loadRouteFromObject (VERSI√ìN FINAL CON L√ìGICA DE DESTINO √öNICO Y CONCATENACI√ìN)
// RESUMEN: Carga la ruta. Si isConcatenatingRoute es true, a√±ade los nuevos waypoints a la ruta existente.
async function loadRouteFromObject(routeObject, autoStartNavigation = false, forceImmediateStart = false, recoveryInfo = null) {
    if (isRecalculatingRoute) {
        showToast("Procesando otra ruta, por favor espere.", "warning");
        return;
    }
    
    if (!recoveryInfo && !isConcatenatingRoute) {
        resetNavigationState();
    }
    
    if (!routeObject || !routeObject.waypoints || routeObject.waypoints.length === 0) {
        showToast("Error: El objeto de la ruta es inv√°lido.", "error");
        return;
    }

    isRecalculatingRoute = true;
    try {
        if (isFreeDriveActive) {
            isFreeDrivePaused = true;
            isFreeDriveActive = false;
            showToast("Modo Conducci√≥n Libre en pausa.", "info");
            updateStartNavigationButtonState();
            updateNavigationButtonColor();
            clearNavigationGraph();
        }

        if (isConcatenatingRoute) {
            const waypointsToAdd = sanitizeWaypointsForStorage(routeObject.waypoints);
            
            if (waypointsToAdd.length > 0 && (waypointsToAdd[0].type === 'S' || waypointsToAdd[0].isRecalculatedStart)) {
                waypointsToAdd.shift();
            }

            navigationWaypoints.push(...waypointsToAdd);
            showToast(`Ruta "${routeObject.name}" a√±adida. Recalculando...`, "success");
            isConcatenatingRoute = false; // Reseteamos el flag.
        
        } else if (recoveryInfo) {
            navigationWaypoints = sanitizeWaypointsForStorage(routeObject.waypoints);
        } else {
            let startPointPosition = null;
            
            if (navigationCurrentLocation && (Date.now() - lastGpsUpdateTime < 5000)) {
                startPointPosition = navigationCurrentLocation;
            } else {
                showToast("Obteniendo tu ubicaci√≥n actual...", "info", 0, false, "gps-load-route");
                try {
                    startPointPosition = await getCurrentLocationAsync();
                    const existingToast = document.getElementById("gps-load-route");
                    if (existingToast) existingToast.remove();
                } catch (error) {
                    const existingToast = document.getElementById("gps-load-route");
                    if (existingToast) existingToast.remove();
                    showToast(`No se pudo obtener la ubicaci√≥n GPS para iniciar la ruta: ${error.message}`, "error");
                    isRecalculatingRoute = false;
                    return; 
                }
            }
            
            const startPoint = {
                id: Date.now() - 1,
                lat: startPointPosition.latitude,
                lng: startPointPosition.longitude,
                type: 'S',
                marker: null,
                label: 'S',
                address: 'Posici√≥n Actual (GPS)',
                visited: true,
                isCriticalForRecalc: true,
                isInternal: false,
                isRecalculatedStart: false
            };
            
            const waypointsFromSavedRoute = routeObject.waypoints;
            
            if (waypointsFromSavedRoute.length === 1) {
                navigationWaypoints = [startPoint, ...sanitizeWaypointsForStorage(waypointsFromSavedRoute)];
            } else {
                const remainingWaypoints = waypointsFromSavedRoute.slice(1);
                navigationWaypoints = [startPoint, ...sanitizeWaypointsForStorage(remainingWaypoints)];
            }
        }
        
        currentRouteNameForSaving = routeObject.name;
        
        await updateWaypointTypesAndLabels();
        renderWaypointMarkers();

        if (navigationWaypoints.filter(wp => wp && !wp.isInternal).length >= 2) {
            try {
                await recalculateAndDrawRoute(false, recoveryInfo); 

                const progressBar = document.getElementById('navigation-bottom-progress-bar');
                if (progressBar) {
                    progressBar.style.display = 'flex';
                    if (navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
                        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], 0);
                    }
                }
                
                setTimeout(() => {
                    if (navigationMapInstance) {
                        try { navigationMapInstance.resize(); } catch(e) {}
                    }
                }, 50);

                if (recoveryInfo) {
                    await restoreTripProgress(recoveryInfo); 
                }
                
                if (autoStartNavigation && !recoveryInfo) {
                    if (forceImmediateStart) {
                        toggleNavigationState(false, false); 
                    } else {
                        const routeGeoJSON = navigationMapInstance.getSource('route')._data;
                        if (routeGeoJSON.geometry && routeGeoJSON.geometry.coordinates.length > 1) {
                            const bounds = new mapboxgl.LngLatBounds();
                            routeGeoJSON.geometry.coordinates.forEach(coord => bounds.extend(coord));
                            if (!bounds.isEmpty()) {
                                navigationMapInstance.fitBounds(bounds, { padding: 80, animate: true, duration: 1500 });
                            }
                        }
                        const firstDestination = navigationWaypoints.find(wp => wp && !wp.isInternal && wp.type !== 'S' && !wp.visited);
                        if (firstDestination) { fetchAndDisplayAlternativeRoutes(firstDestination.id); }
                        showAutoStartNavigationModal();
                    }
                }
            } catch (error) {
                showToast("No se pudo trazar la ruta. Comprueba la conexi√≥n o intenta mover un punto.", "error", 8000);
                const fallbackCoords = navigationWaypoints.map(wp => [wp.lng, wp.lat]);
                await drawRouteOnMap({ geometry: { type: 'LineString', coordinates: fallbackCoords } });
            }
        
        }
    } catch (error) {
        console.error("Error al cargar la ruta desde el objeto:", error);
    } finally {
        isRecalculatingRoute = false;
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
    }
}

// ===================================================================
// NOMBRE: startAutomatedRouteSimulation (VERSI√ìN CON L√ìGICA DE RECUPERACI√ìN CORREGIDA)
// RESUMEN: Inicia o reanuda una simulaci√≥n autom√°tica. No resetea las estad√≠sticas si est√° reanudando.
function startAutomatedRouteSimulation(speedKmph, continueFromDistance = null) {
    if (!isSimulatingGpsLocation) {
        isSimulatingGpsLocation = true;
        if (locationWatchId !== null && navigator.geolocation) {
            navigator.geolocation.clearWatch(locationWatchId);
            locationWatchId = null;
        }
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) {
            simulateGpsButton.classList.add('active-simulate-gps-mode');
            simulateGpsButton.title = "Desactivar Simulaci√≥n GPS (Volver a GPS Real)";
        }
    }
    
    if (automatedSimulationIntervalId) {
        clearInterval(automatedSimulationIntervalId);
        automatedSimulationIntervalId = null;
    }
    
    simulationSpeedKmph = speedKmph;
    currentSimulationSpeedKmph = speedKmph;
    
    const route = navigationCurrentRouteData?.routes?.[0];
    if (!route) {
        showToast("No hay ruta v√°lida para iniciar la simulaci√≥n.", "error");
        stopAutomatedRouteSimulation();
        return;
    }

    if (!navigationFollowUser) {
        navigationFollowUser = true;
        shouldCenterOnUser = true;
        updateLocateMeButtonsUI();
    }
    
    if (typeof continueFromDistance === 'number' && continueFromDistance >= 0) {
        // MODO REANUDACI√ìN: Las estad√≠sticas ya fueron restauradas por restoreTripProgress.
        simulatedDistanceAlongRoute = continueFromDistance;
        
        const turfLine = turf.lineString(route.geometry.coordinates);
        const pointOnLine = turf.along(turfLine, simulatedDistanceAlongRoute / 1000, { units: 'kilometers' });
        if (pointOnLine?.geometry?.coordinates) {
            const [lng, lat] = pointOnLine.geometry.coordinates;
            simulatedGpsLocation = { latitude: lat, longitude: lng, accuracy: 5, heading: 0, altitude: (navigationCurrentLocation?.altitude) ?? 0, speed: 0 };
            processSimulatedGpsPosition(true);
        }
        showToast(`Reanudando simulaci√≥n a ${speedKmph.toFixed(0)} km/h.`, "info");
    } else {
        // MODO INICIO DESDE CERO: Las estad√≠sticas se resetean ANTES de llamar a esta funci√≥n.
        wasSimulatingBeforeRecalc = false;
        simulatedDistanceAlongRoute = 0;
        navigationStartTimeForStats = new Date(); 
        totalDistanceTravelledForStats = 0;
        accumulatedDistanceBeforeCurrentSegment = 0;
        maxSpeedDuringTrip = 0;
        const startWaypoint = navigationWaypoints.find(wp => wp.type === 'S' || wp.isRecalculatedStart) || navigationWaypoints[0];
        lastPositionForStats = { latitude: startWaypoint.lat, longitude: startWaypoint.lng };
        let initialHeading = 0;
        if (route.geometry.coordinates.length >= 2) {
            initialHeading = turf.bearing(turf.point(route.geometry.coordinates[0]), turf.point(route.geometry.coordinates[1]));
            if (initialHeading < 0) initialHeading += 360;
        }
        simulatedGpsLocation = { latitude: startWaypoint.lat, longitude: startWaypoint.lng, accuracy: 5, heading: initialHeading, altitude: (navigationCurrentLocation?.altitude) ?? 0, speed: 0 };
        maxSpeedCoordinates = { lat: startWaypoint.lat, lng: startWaypoint.lng };
        processSimulatedGpsPosition(true);
        showToast(`Simulaci√≥n autom√°tica de ruta iniciada a ${speedKmph.toFixed(0)} km/h.`, "info");
    }
    
    lastCarDistanceAlongRouteForNavLogic = simulatedDistanceAlongRoute;
    setNavigationMapClickHandler(); 

    let simulationStepIndex = 0;
    let simulationLegIndex = 0;
    let tempDistance = 0;
    for (let i = 0; i < route.legs.length; i++) {
        let legFound = false;
        for (let j = 0; j < route.legs[i].steps.length; j++) {
            tempDistance += route.legs[i].steps[j].distance;
            if (simulatedDistanceAlongRoute < tempDistance) {
                simulationLegIndex = i;
                simulationStepIndex = j;
                legFound = true;
                break;
            }
        }
        if (legFound) break;
    }
    let distanceToEndOfCurrentStep = calculateDistanceToEndOfStep(route, simulationLegIndex, simulationStepIndex);

    automatedSimulationIntervalId = setInterval(() => {
        const currentRouteForInterval = navigationCurrentRouteData?.routes?.[0];
        if (!currentRouteForInterval) {
            stopAutomatedRouteSimulationInternal();
            return;
        }
        const totalRouteDistance = currentRouteForInterval.distance;
        const speedMps = (currentSimulationSpeedKmph * 1000) / 3600;
        const distanceIncrement = speedMps * (SIMULATION_TICK_INTERVAL_MS / 1000);
        
        simulatedDistanceAlongRoute += distanceIncrement;

        if (navigationStartTimeForStats) {
            totalDistanceTravelledForStats = simulatedDistanceAlongRoute;
        }
        
        if (simulatedDistanceAlongRoute > distanceToEndOfCurrentStep) {
            simulationStepIndex++;
            if (currentRouteForInterval.legs[simulationLegIndex] && simulationStepIndex >= currentRouteForInterval.legs[simulationLegIndex].steps.length) {
                simulationStepIndex = 0;
                simulationLegIndex++;
            }
            if (simulationLegIndex < currentRouteForInterval.legs.length && currentRouteForInterval.legs[simulationLegIndex]) {
                const currentStep = currentRouteForInterval.legs[simulationLegIndex].steps[simulationStepIndex];
                if (currentStep) { 
                    const multiplier = getRandomSpeedMultiplierForManeuver(currentStep.maneuver);
                    currentSimulationSpeedKmph = Math.max(20, Math.min(5000, simulationSpeedKmph * (1 + multiplier)));
                    distanceToEndOfCurrentStep = calculateDistanceToEndOfStep(currentRouteForInterval, simulationLegIndex, simulationStepIndex);
                }
            }
        }
        if (simulatedDistanceAlongRoute >= totalRouteDistance) {
            stopAutomatedRouteSimulationInternal();
            const endPointCoords = currentRouteForInterval.geometry.coordinates[currentRouteForInterval.geometry.coordinates.length - 1];
            simulatedGpsLocation = {
                ...simulatedGpsLocation, latitude: endPointCoords[1], longitude: endPointCoords[0], speed: 0
            };
            processSimulatedGpsPosition(true);
            showToast("Simulaci√≥n de ruta completada. Modo simulaci√≥n por clic activo.", "success");
            const mapDiv = document.getElementById('reminders-location-map-div');
            if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode'); 
            if (isNavigating || (!isNavigating && navigationWaypoints.length > 0)) {
                 showArrivalStatsModal();
            }
            setNavigationMapClickHandler();
            return;
        }
        const turfLine = turf.lineString(currentRouteForInterval.geometry.coordinates);
        const pointOnLine = turf.along(turfLine, simulatedDistanceAlongRoute / 1000, { units: 'kilometers' });
        if (pointOnLine?.geometry?.coordinates) {
            const [lng, lat] = pointOnLine.geometry.coordinates;
            let headingSim = 0;
            const lookAheadDistance = Math.min(distanceIncrement * 2, totalRouteDistance - simulatedDistanceAlongRoute);
            if (simulatedDistanceAlongRoute + lookAheadDistance <= totalRouteDistance && lookAheadDistance > 0) {
                const nextPointOnLine = turf.along(turfLine, (simulatedDistanceAlongRoute + lookAheadDistance) / 1000, { units: 'kilometers' });
                if (nextPointOnLine?.geometry?.coordinates) {
                    headingSim = turf.bearing(pointOnLine, nextPointOnLine);
                    if (headingSim < 0) headingSim += 360;
                }
            } else {
                headingSim = simulatedGpsLocation?.heading || 0;
            }
            simulatedGpsLocation = {
                latitude: lat, longitude: lng, accuracy: 5, heading: headingSim, altitude: (navigationCurrentLocation?.altitude) ?? 0, speed: speedMps
            };
            processSimulatedGpsPosition(false);
        }
    }, SIMULATION_TICK_INTERVAL_MS);
    startMemoryManagement(true); 
}

// ===================================================================
// NOMBRE: proceedWithRecalculation 
// RESUMEN: Gestiona la l√≥gica de rec√°lculo de ruta seg√∫n la acci√≥n del usuario.
async function proceedWithRecalculation(action) {
    if (!isNavigating || !navigationCurrentLocation) {
        showToast("No se puede recalcular: no se est√° navegando o la ubicaci√≥n es desconocida.", "error");
        return;
    }
    if (action === 'skip_one') {
        const nextUnvisitedStageIndex = navigationWaypoints.findIndex(wp => wp && !wp.isInternal && !wp.isRecalculatedStart && !wp.visited && wp.type !== 'S' && wp.type !== 'S_Recalc' && wp.type !== 'F');
        if (nextUnvisitedStageIndex !== -1) {
            navigationWaypoints[nextUnvisitedStageIndex].visited = true;
            showToast(`Omitiendo etapa: ${navigationWaypoints[nextUnvisitedStageIndex].address || 'Siguiente' }`, "info");
        } else {
            showToast("No hay pr√≥ximas etapas intermedias para omitir. Recalculando a destino.", "info");
        }
    } else if (action === 'skip_multiple') {
        const stagesToSkip = [];
        const currentHeading = navigationCurrentLocation.heading;
        navigationWaypoints.forEach(wp => {
            if (wp.visited || wp.type === 'S' || wp.type === 'S_Recalc' || wp.type === 'F') return;
            const bearingToWp = turf.bearing(
                turf.point([navigationCurrentLocation.longitude, navigationCurrentLocation.latitude]),
                turf.point([wp.lng, wp.lat])
            );
            let angleDiff = Math.abs(currentHeading - (bearingToWp < 0 ? bearingToWp + 360 : bearingToWp));
            if (angleDiff > 180) angleDiff = 360 - angleDiff;
            if (angleDiff > 110) {
                stagesToSkip.push(wp.id);
            }
        });
        if (stagesToSkip.length > 0) {
            navigationWaypoints.forEach(wp => {
                if (stagesToSkip.includes(wp.id)) wp.visited = true;
            });
            showToast(`Saltando ${stagesToSkip.length} etapas que han quedado atr√°s.`, "info");
        }
    }
    await recalculateAndDrawRoute(true);
}
    
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// NOMBRE: fetchAndRenderChatUsers 
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
async function fetchAndRenderChatUsers() {
    const usersListContainer = document.getElementById('chat-users-list');
    const messageInput = document.getElementById('chat-message-input');
    const filterInput = document.getElementById('chat-user-filter-input');
    
    if (!usersListContainer || !window.db || !messageInput || !filterInput || isFetchingUsers) return;

    if (!filterInput.listenerAdded) {
        filterInput.addEventListener('input', () => {
            fetchAndRenderChatUsers(); 
        });
        filterInput.listenerAdded = true;
    }
    
    isFetchingUsers = true;
    
    if (!filterInput.value.trim()) {
        usersListContainer.innerHTML = ''; 
    }
    
    const currentUserId = localStorage.getItem('userData_userId') || '';
    const isAdmin = currentUserId.toLowerCase() === 'boardinggate';

    if (isAdmin) {
        filterInput.placeholder = "Filtrar o usar: SES, TOT, POI, FECHA";
    } else {
        filterInput.placeholder = "Filtrar por cualquier dato...";
    }

    if (isAdmin) {
        if (!document.getElementById('recalculate-users-btn')) {
            const adminPanel = document.createElement('div');
            adminPanel.style.cssText = 'padding: 10px; border-bottom: 2px solid #555;';
            
            const recalculateButton = document.createElement('button');
            recalculateButton.id = 'recalculate-users-btn';
            recalculateButton.textContent = 'Recalcular Total Usuarios';
            recalculateButton.style.cssText = 'width: 100%; padding: 8px; background-color: #ff9500; color: white; border: none; border-radius: 6px; font-weight: bold; cursor: pointer;';
            
            adminPanel.appendChild(recalculateButton);
            usersListContainer.prepend(adminPanel);
            recalculateButton.addEventListener('click', recalculateAndSaveUserCount);
        }
    
        const [sessionStats, poiStats] = await Promise.all([
            getGlobalMapSessionStats(),
            getGlobalPoiStats()
        ]);

        let statsHeader = document.getElementById('chat-admin-stats-header');
        if (!statsHeader) {
            statsHeader = document.createElement('div');
            statsHeader.id = 'chat-admin-stats-header';
            statsHeader.className = 'chat-admin-stats-header';
            const filterContainer = document.getElementById('chat-users-filter-container');
            if (filterContainer) {
                filterContainer.insertAdjacentElement('afterend', statsHeader);
            }
        }
        statsHeader.innerHTML = `Sesiones-> Mes: ${sessionStats.totalMonth} | Total: ${sessionStats.totalHistoric}<br>POI Clics (Mes): ${poiStats.totalMonth}`;
        
        let maxSessionsControl = document.getElementById('chat-max-sessions-control');
        if (!maxSessionsControl) {
            maxSessionsControl = document.createElement('div');
            maxSessionsControl.id = 'chat-max-sessions-control';
            maxSessionsControl.style.cssText = 'padding: 8px; background-color: #3a3a3c; border-bottom: 1px solid #444; display: flex; align-items: center; justify-content: center; gap: 10px;';
            maxSessionsControl.innerHTML = `
                <label for="chat-max-sessions-input" style="font-weight: bold; color: #ffd700;">M√ÅXIMO SESIONES:</label>
                <input type="number" id="chat-max-sessions-input" style="width: 80px; text-align: center; background-color: #2c2c2e; border: 1px solid #555; color: #f0f0f0; border-radius: 4px;">
            `;
            statsHeader.insertAdjacentElement('afterend', maxSessionsControl);

            const maxSessionsInput = document.getElementById('chat-max-sessions-input');
            const adminDocRef = window.doc(window.db, "user_data", "boardinggate");

            try {
                const docSnap = await window.getDoc(adminDocRef);
                if (docSnap.exists() && typeof docSnap.data().max_monthly_sessions === 'number') {
                    maxSessionsInput.value = docSnap.data().max_monthly_sessions;
                } else {
                    maxSessionsInput.value = 5000;
                }
            } catch(e) {
                 maxSessionsInput.value = 5000;
            }
            
            maxSessionsInput.addEventListener('change', async () => {
                const newValue = parseInt(maxSessionsInput.value, 10);
                const adminPin = localStorage.getItem('userData_backupPassword');
                
                if (!adminPin) {
                    showToast("Error: No se encontr√≥ el PIN de administrador en local. No se puede guardar.", 'error');
                    return;
                }

                if (!isNaN(newValue) && newValue >= 0) {
                    try {
                        const dataToUpdate = { 
                            max_monthly_sessions: newValue,
                            backupPassword: adminPin
                        };
                        
                        await window.setDoc(adminDocRef, dataToUpdate, { merge: true });
                        showToast(`L√≠mite de sesiones actualizado en la nube a ${newValue}.`, 'success');
                    } catch (error) {
                        showToast(`Error al guardar el l√≠mite en la nube: ${error.message}`, 'error');
                    }
                }
            });
        }
    }
 
    try {
        const usersRef = window.collection(window.db, "user_data");
        const q = window.query(usersRef, window.where("rss", "==", true));
        const querySnapshot = await window.getDocs(q);
        const docs = querySnapshot.docs;
        
        let allUsersData = [];
        docs.forEach(doc => {
            const userData = doc.data();
            const userId = userData.usuario || doc.id;
            allUsersData.push({ id: userId, ...userData });
        });
        
        const now = new Date();
        const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        const filterText = filterInput.value.toLowerCase().trim();
        let sortMode = null;
        let filteredUsers = allUsersData;

        if (filterText === 'ses') {
            sortMode = 'ses';
        } else if (filterText === 'tot') {
            sortMode = 'tot';
        } else if (filterText === 'poi') {
            sortMode = 'poi';
        } else if (filterText === 'fecha') {
            sortMode = 'fecha';
        } else if (filterText) {
            filteredUsers = allUsersData.filter(userData => {
                const userString = `${userData.id} ${userData.modelo || ''} ${userData.anio || ''} ${userData.provincia || ''}`.toLowerCase();
                return userString.includes(filterText);
            });
        }

        if (sortMode) {
            filteredUsers.sort((a, b) => {
                const aMonthSessions = (a.map_sessions_last_month === currentMonthStr) ? (a.map_sessions_month || 0) : 0;
                const bMonthSessions = (b.map_sessions_last_month === currentMonthStr) ? (b.map_sessions_month || 0) : 0;
                const aTotalSessions = a.map_sessions_total || 0;
                const bTotalSessions = b.map_sessions_total || 0;
                const aPoiClicks = (a.poi_clicks_last_month === currentMonthStr) ? (a.poi_clicks_month || 0) : 0;
                const bPoiClicks = (b.poi_clicks_last_month === currentMonthStr) ? (b.poi_clicks_month || 0) : 0;
                const aDate = a.fechaBackup ? new Date(a.fechaBackup).getTime() : 0;
                const bDate = b.fechaBackup ? new Date(b.fechaBackup).getTime() : 0;

                if (sortMode === 'ses') return bMonthSessions - aMonthSessions;
                if (sortMode === 'tot') return bTotalSessions - aTotalSessions;
                if (sortMode === 'poi') return bPoiClicks - aPoiClicks;
                if (sortMode === 'fecha') return bDate - aDate;
                return 0;
            });
        } else if (!filterText) { // Orden alfab√©tico por defecto si no hay filtro
            filteredUsers.sort((a, b) => a.id.localeCompare(b.id));
        }
     
        usersListContainer.querySelectorAll('.chat-user-item, .chat-no-users').forEach(el => el.remove());

        if (filteredUsers.length === 0) {
            usersListContainer.innerHTML += '<p class="chat-no-users">No hay usuarios que coincidan con el filtro.</p>';
        } else {
            const userListFragment = document.createDocumentFragment();
            filteredUsers.forEach(userData => {
                const userId = userData.id;
                const isBoardingGateAccount = userId.toLowerCase().includes('boardinggate');
                const isMainAdminAccount = userId.toLowerCase() === 'boardinggate';
                if (isBoardingGateAccount && !isMainAdminAccount) {
                    return; 
                }

                const userElement = document.createElement('div');
                userElement.className = 'chat-user-item';

                if (isAdmin && !isMainAdminAccount) {
                    const adminControls = document.createElement('div');
                    adminControls.className = 'chat-admin-controls';
                    const accessCheckbox = document.createElement('input');
                    accessCheckbox.type = 'checkbox';
                    accessCheckbox.className = 'map-access-toggle';
                    accessCheckbox.title = `Permitir/Denegar acceso a mapas para ${userId}`;
                    accessCheckbox.dataset.userid = userId;
                    accessCheckbox.checked = userData.mapAccessEnabled !== false;
                    accessCheckbox.addEventListener('change', async (e) => {
                        e.stopPropagation();
                        const targetUserId = e.target.dataset.userid;
                        const hasAccess = e.target.checked;
                        try {
                            const userDocRef = window.doc(window.db, "user_data", targetUserId);
                            await window.setDoc(userDocRef, { mapAccessEnabled: hasAccess }, { merge: true });
                            showToast(`Acceso a mapas para ${targetUserId} ${hasAccess ? 'ACTIVADO' : 'DESACTIVADO'}.`, 'success');
                        } catch (error) {
                            showToast(`Error al cambiar permiso para ${targetUserId}.`, 'error');
                            e.target.checked = !hasAccess;
                        }
                    });
                    adminControls.appendChild(accessCheckbox);
                    userElement.appendChild(adminControls);
                }
            
                const mainInfoContainer = document.createElement('div');
                mainInfoContainer.className = 'chat-user-main-info';
                mainInfoContainer.style.cursor = 'pointer';
                mainInfoContainer.title = `Enviar mensaje privado a ${userId}`;
                mainInfoContainer.addEventListener('click', () => {
                    const currentText = messageInput.value;
                    if (currentText.startsWith('@')) {
                        const existingMentionEndIndex = currentText.indexOf(' ');
                        if (existingMentionEndIndex !== -1) {
                            messageInput.value = `@${userId} ` + currentText.substring(existingMentionEndIndex + 1);
                        } else {
                            messageInput.value = `@${userId} `;
                        }
                    } else {
                        messageInput.value = `@${userId} ` + currentText;
                    }
                    messageInput.focus();
                    messageInput.dispatchEvent(new Event('input'));
                });

                const userName = document.createElement('span');
                userName.className = 'chat-user-name';
                userName.textContent = userId;
                
                const userDetails = document.createElement('span');
                userDetails.className = 'chat-user-details';
                const detailsParts = [];
                if (userData.modelo) detailsParts.push(userData.modelo);
                if (userData.anio) detailsParts.push(userData.anio);
                if (userData.provincia) detailsParts.push(userData.provincia);
                userDetails.textContent = `(${detailsParts.join(', ')})`;
                
                mainInfoContainer.appendChild(userName);
                mainInfoContainer.appendChild(userDetails);
                userElement.appendChild(mainInfoContainer);
                
                if (isAdmin) {
                    const userMonthSessions = (userData.map_sessions_last_month === currentMonthStr) ? (userData.map_sessions_month || 0) : 0;
                    const userTotalSessions = userData.map_sessions_total || 0;
                    const userPoiClicks = (userData.poi_clicks_last_month === currentMonthStr) ? (userData.poi_clicks_month || 0) : 0;
                    
                    const statsSpan = document.createElement('span');
                    statsSpan.className = 'chat-user-session-stats';
                    statsSpan.textContent = `(Ses:${userMonthSessions} | Poi:${userPoiClicks} | Tot:${userTotalSessions})`;
                    userDetails.appendChild(statsSpan);

                    if (userData.fechaBackup) {
                        try {
                            const backupDate = new Date(userData.fechaBackup);
                            const formattedDate = `${backupDate.getDate().toString().padStart(2, '0')}/${(backupDate.getMonth() + 1).toString().padStart(2, '0')}/${backupDate.getFullYear().toString().slice(-2)} ${backupDate.getHours().toString().padStart(2, '0')}:${backupDate.getMinutes().toString().padStart(2, '0')}`;
                            const dateSpan = document.createElement('span');
                            dateSpan.style.cssText = 'display: block; font-size: 0.7rem; color: #87CEEB; margin-top: 2px;';
                            dateSpan.textContent = `√ölt. Backup: ${formattedDate}`;
                            mainInfoContainer.appendChild(dateSpan);
                        } catch (e) { /* Ignorar si la fecha es inv√°lida */ }
                    }
                }
                
                userListFragment.appendChild(userElement);
            });
            usersListContainer.appendChild(userListFragment);
        }

    } catch (error) {
        console.error("Error al renderizar usuarios del chat:", error);
        usersListContainer.innerHTML = '<p class="chat-no-users">Error al cargar usuarios.</p>';
    } finally {
        isFetchingUsers = false;
    }
}
      
// ===================================================================
// NOMBRE: handleProgressiveManeuverZoom 
// RESUMEN: Incluye mejoras y correcci√≥n del bug de estado. Ahora recibe
function findNextValidStep(route, currentLeg, currentStep) {
    let legIndex = currentLeg;
    let stepIndex = currentStep + 1;
    const waypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal);

    while (legIndex < route.legs.length) {
        const leg = route.legs[legIndex];
        if (stepIndex >= leg.steps.length) {
            legIndex++;
            stepIndex = 0;
            continue;
        }
        const candidateStep = leg.steps[stepIndex];
        const isArrival = candidateStep.maneuver.type === 'arrive';
        const arrivalWaypoint = isArrival ? waypoints[legIndex + 1] : null;
        if (isArrival && arrivalWaypoint && arrivalWaypoint.isInternal) {
            stepIndex++;
            continue; 
        }
        return { step: candidateStep, legIndex: legIndex, stepIndex: stepIndex };
    }
    return null;
}

// ===================================================================
// NOMBRE: clearAllMapLayersAndSources (NUEVA FUNCI√ìN DE DESMANTELAMIENTO)
// RESUMEN: Elimina expl√≠citamente todas las capas y fuentes de una instancia de mapa.
function clearAllMapLayersAndSources(mapInstance) {
    if (!mapInstance || !mapInstance.isStyleLoaded()) {
        return;
    }
        
    try {
        if (mapInstance.getTerrain()) {
            mapInstance.setTerrain(null);
        }

        const style = mapInstance.getStyle();

        if (style && style.layers) {
            style.layers.forEach(layer => {
                try {
                    if (mapInstance.getLayer(layer.id)) {
                        mapInstance.removeLayer(layer.id);
                    }
                } catch (e) {
                }
            });
        }

        if (style && style.sources) {
            Object.keys(style.sources).forEach(sourceId => {
                try {
                    if (mapInstance.getSource(sourceId)) {
                        mapInstance.removeSource(sourceId);
                    }
                } catch (e) {
                }
            });
        }
    } catch(e) {
    }
}
    
// ===================================================================
// NOMBRE: destroyAllMapInstances
// RESUMEN: Desmantela y destruye todas las instancias de mapa de forma secuencial y segura.
async function destroyAllMapInstances() {
    console.log("[Memory Manager] Iniciando destrucci√≥n de todas las instancias de mapa...");
    
    const mapsToDestroy = [
        { instance: navigationMapInstance, name: "Principal" },
        { instance: minimapInstance, name: "Minimapa" },
        { instance: intersectionPreviewMap, name: "Intersecci√≥n" },
        { instance: locationPickerMap, name: "Selector Ubicaci√≥n" },
        { instance: locationsPreviewMap, name: "Vista Previa Ubicaciones" }
    ];

    for (const mapInfo of mapsToDestroy) {
        if (mapInfo.instance) {
            try {
                clearAllMapLayersAndSources(mapInfo.instance);
                await wait(70);
                mapInfo.instance.remove();
            } catch (e) {
            }
        }
    }
    
    navigationMapInstance = null;
    minimapInstance = null;
    intersectionPreviewMap = null;
    locationPickerMap = null;
    locationsPreviewMap = null;
    minimapCarMarker = null;
    intersectionPreviewCarMarker = null;
    locationPickerMarker = null;

    if (navigationChart) {
        try {
            navigationChart.destroy();
        } catch(e) {}
        navigationChart = null;
    }
}
    
// ===================================================================
// NOMBRE: hideRecoveryScreenshotOverlay 
// RESUMEN: Oculta con una transici√≥n suave y elimina el overlay de la captura de pantalla.
function hideRecoveryScreenshotOverlay() {
    const overlay = document.getElementById('recovery-screenshot-overlay');
    if (overlay && overlay.style.display !== 'none') {
        if (navigationMapInstance) {
            try {
                navigationMapInstance.resize();
            } catch (e) {
            }
        }
        overlay.classList.add('fade-out');
        setTimeout(() => {
            if (overlay.parentNode) {
                overlay.parentNode.removeChild(overlay);
            }
        }, 500); 
    }
}
        
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// NOMBRE: openLocationsPreviewMap 
// RESUMEN: Abre un mapa modal sat√©lite y dibuja TODOS los marcadores de forma eficiente, corrigiendo el error de sintaxis en el filtro de la capa de texto.
function openLocationsPreviewMap() {
    closeOtherModals('locations-preview-modal');
    document.body.classList.add('modal-open');

    let modal = document.getElementById('locations-preview-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'locations-preview-modal';
        modal.innerHTML = `
            <h2 id="locations-preview-title">Ubicaciones con Recordatorios</h2>
            <div id="locations-preview-map-container" style="height: calc(100% - 100px); width: 100%;"></div>
            <div class="modal-top-buttons" style="justify-content: center; margin-top: 1rem;">
                <button id="close-locations-preview">Salir</button>
            </div>
        `;
        document.body.appendChild(modal);
    }
    
    modal.classList.remove('hidden');
    const mapContainerEl = modal.querySelector('#locations-preview-map-container');
    const closeButton = modal.querySelector('#close-locations-preview');
    const titleElement = modal.querySelector('#locations-preview-title');
    
    const closeHandler = () => {
        if (locationsPreviewMap) {
            try { locationsPreviewMap.remove(); } catch (e) {}
            locationsPreviewMap = null;
        }
        clearModalAutoCloseTimer(modal, closeButton, 'locations-preview-modal');
        modal.classList.add('hidden');
        document.body.classList.remove('modal-open');
    };

    const newCloseButton = closeButton.cloneNode(true);
    closeButton.parentNode.replaceChild(newCloseButton, closeButton);
    newCloseButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(modal, newCloseButton, 'locations-preview-modal', 120000);

    if (locationsPreviewMap) {
        try { locationsPreviewMap.remove(); } catch (e) {}
    }
    
    locationsPreviewMap = new mapboxgl.Map({
        container: mapContainerEl,
        style: 'mapbox://styles/mapbox/satellite-streets-v12?optimize=true', 
        center: [-3.703790, 40.416775],
        zoom: 6,
        attributionControl: true, 
        maxTileCacheSize: 50,
        antialias: false,
        preserveDrawingBuffer: false,
        minzoom: 2,
        maxzoom: 19
    });

    const plotAllLocations = async () => {
        await loadAndAddMapImages(locationsPreviewMap);

        const allReminders = JSON.parse(localStorage.getItem('reminders') || '[]').map(r => ({ ...r }));
        const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
        let locationsToPlot = allReminders.filter(r => {
            const hasLocation = r.isLocationEnabled && r.locationCoordinates?.latitude && r.locationCoordinates?.longitude;
            if (!hasLocation) return false;
            return showExcluded ? true : !r.excludeFromList;
        });

        if (titleElement) {
            titleElement.textContent = `Ubicaciones con Recordatorios ${showExcluded ? '(incl. Radares)' : '(sin Radares)'}`;
        }

        const geojsonFeatures = locationsToPlot.map(reminder => {
            const isRadar = reminder.text.toUpperCase().includes("RADAR") || reminder.excludeFromList;
            const speed = isRadar ? extractSpeedFromRadarText(reminder.text) : null;
            
            const properties = {
                reminderId: reminder.id,
                isRadar: isRadar,
                isFromTarea: reminder.isFromTarea || false,
            };
            if (speed !== null) {
                properties.speed = String(speed);
            }

            return {
                type: 'Feature',
                geometry: {
                    type: 'Point',
                    coordinates: [reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]
                },
                properties: properties
            };
        });

        const geojsonData = {
            type: 'FeatureCollection',
            features: geojsonFeatures
        };

        const sourceId = 'locations-preview-source';
        if (locationsPreviewMap.getSource(sourceId)) {
            locationsPreviewMap.getSource(sourceId).setData(geojsonData);
        } else {
            locationsPreviewMap.addSource(sourceId, { type: 'geojson', data: geojsonData });
        }

        const layers = [
            { id: 'preview-circles', type: 'circle', minzoom: 5, maxzoom: 19, filter: ['==', 'isRadar', true], paint: {'circle-color': 'red', 'circle-radius': 15, 'circle-stroke-width': 2, 'circle-stroke-color': 'white'} },
            { id: 'preview-speed-text', type: 'symbol', minzoom: 5, maxzoom: 19, filter: ['all', ['==', 'isRadar', true], ['has', 'speed']], layout: {'text-field': '{speed}', 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 12, 'text-allow-overlap': true}, paint: {'text-color': 'yellow'} },
            { id: 'preview-radar-text', type: 'symbol', minzoom: 5, maxzoom: 19, filter: ['all', ['==', 'isRadar', true], ['!', ['has', 'speed']]], layout: { 'text-field': 'Rdar', 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 10, 'text-allow-overlap': true}, paint: { 'text-color': 'yellow'} },
            { id: 'preview-reminder-icons', type: 'symbol', minzoom: 5, maxzoom: 19, filter: ['==', 'isRadar', false], layout: {'icon-image': 'reminder-icon', 'icon-size': 0.7, 'icon-allow-overlap': true, 'icon-anchor': 'bottom'} }
        ];

        layers.forEach(layer => {
            if (!locationsPreviewMap.getLayer(layer.id)) {
                locationsPreviewMap.addLayer({ ...layer, source: sourceId });
            }
        });
        
        setTimeout(() => {
            if (!locationsPreviewMap) return; 
            if (geojsonFeatures.length > 0) {
                const bounds = new mapboxgl.LngLatBounds();
                geojsonFeatures.forEach(feature => {
                    bounds.extend(feature.geometry.coordinates);
                });
                if (!bounds.isEmpty()) {
                    try {
                        locationsPreviewMap.fitBounds(bounds, { padding: 50, duration: 0 });
                    } catch(e) {
                        console.error("Error al ejecutar fitBounds en el modal de vista previa:", e);
                    }
                }
            } else {
                showToast(`No hay recordatorios con ubicaci√≥n para mostrar seg√∫n el filtro actual.`, "info");
            }
        }, 100);

        const interactiveLayers = ['preview-circles', 'preview-reminder-icons'];
        locationsPreviewMap.on('click', interactiveLayers, (e) => {
            if (e.features && e.features.length > 0) {
                const reminderId = e.features[0].properties.reminderId;
                showReminderActionModal(reminderId);
            }
        });

        locationsPreviewMap.on('mouseenter', interactiveLayers, () => { locationsPreviewMap.getCanvas().style.cursor = 'pointer'; });
        locationsPreviewMap.on('mouseleave', interactiveLayers, () => { locationsPreviewMap.getCanvas().style.cursor = ''; });
    };

    if (locationsPreviewMap.isStyleLoaded()) {
        plotAllLocations();
    } else {
        locationsPreviewMap.on('load', plotAllLocations);
    }
}    
  

// ===================================================================
// NOMBRE: showSavedLocationsModal 
// ===================================================================
function showSavedLocationsModal(callbackOnClose, callbackOnSelectLocation, options = {}) {

    const existingModal = document.querySelector('.saved-locations-modal');
    if (existingModal) {
        const closeBtn = existingModal.querySelector('#close-saved-locations-modal');
        if (closeBtn) clearModalAutoCloseTimer(existingModal, closeBtn, 'saved-locations-modal');
        existingModal.remove();
    }

    tempSavedLocations = getSavedLocations().map(loc => loc ? {...loc} : null);
    const modal = document.createElement('div');
    modal.className = 'saved-locations-modal';
    
    modal.innerHTML = `
        <h2>Gestionar Ubicaciones Guardadas (M√°x. ${MAX_SAVED_LOCATIONS})</h2>
        <div class="modal-top-buttons">
            <button id="save-all-user-locations">Guardar Cambios</button>
            <button id="close-saved-locations-modal">Cerrar</button>
        </div>
        <div id="saved-locations-list"> 
            <!-- El div para el mapa se crea dentro de esta lista -->
            <div id="location-picker-map-container">
                <button id="picker-ok-map-button" title="Confirmar esta posici√≥n">OK</button>
                <button id="picker-locate-me-button" title="Ir a mi posici√≥n actual">Mi Ubic.</button>
            </div>
        </div>
    `;
  
    const parent = options.parentContainer || document.body;
    parent.appendChild(modal);
    
    const listElement = modal.querySelector('#saved-locations-list');
    const mapPickerContainer = modal.querySelector('#location-picker-map-container');
    const okMapBtn = modal.querySelector('#picker-ok-map-button');
    const locateMeMapBtn = modal.querySelector('#picker-locate-me-button');
    const saveAllButton = modal.querySelector('#save-all-user-locations');
    const closeButton = modal.querySelector('#close-saved-locations-modal');

    const closeHandler = () => {
        clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
        
        if (locationPickerMap) {
            try {
                locationPickerMap.off('load');
                locationPickerMap.off('click');
                locationPickerMap.remove();
            } catch(e) {
                console.error("Error menor durante la limpieza del mapa selector de ubicaci√≥n:", e);
            }
            locationPickerMap = null;
            locationPickerMarker = null; // Tambi√©n limpiamos la referencia al marcador
        }
        
        if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose();
        modal.remove();
    };

    // =====================================================================

    function loadAndDisplaySlots() {
        listElement.querySelectorAll('.location-slot').forEach(el => el.remove());
        
        for (let i = 0; i < MAX_SAVED_LOCATIONS; i++) {
            const location = tempSavedLocations[i];
            const slotDiv = document.createElement('div');
            slotDiv.className = 'location-slot';
            slotDiv.innerHTML = ` <span style="width: 25px; text-align: right; font-weight: bold;">${i + 1}.</span> <input type="text" placeholder="Nombre Ubicaci√≥n" value="${location?.name || ''}" data-index="${i}"> <button class="map-button" data-index="${i}" title="Fijar en Mapa">üìç Mapa</button> <button class="select-location-button" data-index="${i}" title="Seleccionar esta ubicaci√≥n para el recordatorio actual">Seleccionar</button> <span class="coords-display">${location?.lat && location?.lng ? `${parseFloat(location.lat).toFixed(4)}, ${parseFloat(location.lng).toFixed(4)}` : 'No fijada'}</span> `;
            
            listElement.insertBefore(slotDiv, mapPickerContainer);
            
            slotDiv.querySelector('input[type="text"]').addEventListener('input', (e) => {
                if (!tempSavedLocations[i]) tempSavedLocations[i] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
                tempSavedLocations[i].name = e.target.value;
            });
            
            slotDiv.querySelector('.map-button').addEventListener('click', () => {
                currentEditingLocationSlotIndex = i;
                mapPickerContainer.classList.add('expanded');
                initializeLocationPickerMap('location-picker-map-container', i);

                setTimeout(() => {
                    if (listElement) {
                        listElement.scrollTo({ top: listElement.scrollHeight, behavior: 'smooth' });
                    }
                }, 100);
            });
            
            const selectButton = slotDiv.querySelector('.select-location-button');
            selectButton.addEventListener('click', () => {
                const selectedIndex = parseInt(selectButton.dataset.index);
                const selectedLocData = tempSavedLocations[selectedIndex];
                if (selectedLocData && selectedLocData.lat && selectedLocData.lng) {
                    if (callbackOnSelectLocation && typeof callbackOnSelectLocation === 'function') {
                        callbackOnSelectLocation({ name: selectedLocData.name, lat: selectedLocData.lat, lng: selectedLocData.lng, radius: selectedLocData.radius || DEFAULT_LOCATION_RADIUS });
                    }
                    closeHandler();
                } else { showToast("Ubicaci√≥n no fijada. F√≠jala en el mapa primero", "warning"); }
            });
        }
    }
    
    loadAndDisplaySlots();

    okMapBtn.addEventListener('click', () => {
        if (locationPickerMarker && currentEditingLocationSlotIndex !== -1) {
            const pos = locationPickerMarker.getLngLat();
            if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
            tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat;
            tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng;
            const slotInput = listElement.querySelector(`.location-slot input[data-index="${currentEditingLocationSlotIndex}"]`); 
            if (slotInput) {
                const coordsDisplay = slotInput.closest('.location-slot').querySelector('.coords-display');
                if (coordsDisplay) { coordsDisplay.textContent = `${pos.lat.toFixed(4)}, ${pos.lng.toFixed(4)}`; }
            }
        }
        mapPickerContainer.classList.remove('expanded');
        
        if (locationPickerMap) {
            try { locationPickerMap.remove(); } catch(e){}
            locationPickerMap = null;
            locationPickerMarker = null;
        }
        
        currentEditingLocationSlotIndex = -1;
    });

    locateMeMapBtn.addEventListener('click', () => {
        if (locationPickerMap) {
            locateMeMapBtn.disabled = true; locateMeMapBtn.textContent = 'Buscando...';
            getCurrentLocation(
                (coords) => {
                    locationPickerMap.flyTo({center: [coords.longitude, coords.latitude], zoom: 16});
                    if (locationPickerMarker) locationPickerMarker.setLngLat([coords.longitude, coords.latitude]);
                    if (currentEditingLocationSlotIndex !== -1) {
                        if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
                        tempSavedLocations[currentEditingLocationSlotIndex].lat = coords.latitude;
                        tempSavedLocations[currentEditingLocationSlotIndex].lng = coords.longitude;
                    }
                    locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.';
                },
                (errorMsg) => { showToast(`Error localizaci√≥n: ${errorMsg}`, 'error'); locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.'; }
            );
        }
    });

    saveAllButton.addEventListener('click', () => {
        const locationsToSave = tempSavedLocations.map(loc => {
            if (loc && (!loc.name || loc.name.trim() === '') && (loc.lat === null || loc.lng === null)) { return null; }
            if (loc && (loc.lat !== null && loc.lng !== null) && typeof loc.radius !== 'number') { loc.radius = DEFAULT_LOCATION_RADIUS; }
            return loc;
        }).filter(Boolean); 

        saveLocationsToCache(locationsToSave);
        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        savedRoutes = savedRoutes.filter(r => !r.name.startsWith("UBICACI√ìN: "));

        locationsToSave.forEach(loc => {
            if (loc && loc.name && loc.lat && loc.lng) {
                const routeName = `UBICACI√ìN: ${loc.name.toUpperCase()}`;
                const routeWaypoint = { id: Date.now() + Math.random(), lat: loc.lat, lng: loc.lng, type: 'F', label: 'F', address: loc.name, visited: false, isCriticalForRecalc: true };
                const existingRouteIndex = savedRoutes.findIndex(r => r.name === routeName);
                const routeToSave = { name: routeName, waypoints: [routeWaypoint], createdAt: new Date().toISOString() };
                if (existingRouteIndex !== -1) { savedRoutes[existingRouteIndex] = routeToSave; } else { savedRoutes.push(routeToSave); }
            }
        });
        if (savedRoutes.length > MAX_SAVED_ROUTES) {
             savedRoutes.sort((a,b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
             savedRoutes = savedRoutes.slice(0, MAX_SAVED_ROUTES);
        }
        localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes)); 
        showToast("Ubicaciones guardadas y sincronizadas.", "success"); 
        closeHandler();
    });

    closeButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
}

// ===================================================================
// NOMBRE: handleProgressiveManeuverZoom 
// RESUMEN: Gestiona el zoom progresivo. Corrige el bug de no retornar
function handleProgressiveManeuverZoom(currentStep, distanceToManeuver, carDistanceAlongRouteForNavLogic) {
    if (isManualZoomActive) return null;

    if (!isNavigating || !navigationMapInstance || !currentStep) {
        if (isZoomedForManeuver) {
            isZoomedForManeuver = false;
            mapPreviousZoomLevelForProgressive = null;
        }
        return null;
    }
    
    let ANIMATION_START_DISTANCE = 225;
    if (navigationMapInstance.getZoom() < 16) {
        ANIMATION_START_DISTANCE = 250;
    }

    const route = navigationCurrentRouteData?.routes?.[0];
    if (!route || !route.geometry || !route.geometry.coordinates || route.geometry.coordinates.length < 2) {
        return null;
    }
    
    const ZOOM_PEAK_DISTANCE = 50;
    const HOLD_ZOOM_THRESHOLD = 300; // Aumentamos ligeramente para ser m√°s robusto en encadenamientos.
    const currentMapLayerName = (localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "H√çBRIDO").toLowerCase();
    const isSatelliteWithLabels = currentMapLayerName.includes("sat√©lite") && currentMapLayerName.includes("calles");
    const MANEUVER_PEAK_ZOOM_LEVEL = Math.min(isSatelliteWithLabels ? 17.5 : 18.5, 19.5);
    
    const nextStepInfo = findNextValidStep(route, currentLegIndexNav, currentStepIndexNav);
    const distanceToNextManeuver = nextStepInfo ? calculateDistanceToEndOfStep(route, nextStepInfo.legIndex, nextStepInfo.stepIndex) - carDistanceAlongRouteForNavLogic : Infinity;

    if (distanceToManeuver < ANIMATION_START_DISTANCE) {
        if (!isZoomedForManeuver) {
            isZoomedForManeuver = true;
            originalMapUpdateIntervalMs = MAP_UPDATE_INTERVAL_MS;
            MAP_UPDATE_INTERVAL_MS = 1000 / 60; // Aumentamos FPS para la animaci√≥n.
            
            const currentAutoZoomMode = localStorage.getItem(AUTO_ZOOM_MODE_KEY) || 'off';
            if (currentAutoZoomMode === 'off' && manualZoomLevelMemory !== null) {
                mapPreviousZoomLevelForProgressive = manualZoomLevelMemory; // Priorizamos el zoom manual expl√≠cito.
            } else {
                mapPreviousZoomLevelForProgressive = navigationMapInstance.getZoom();
            }
            
            window.pitchBeforeManeuver = navigationMapInstance.getPitch();
            window.offsetXBeforeManeuver = mapOffsetX;
            window.offsetYBeforeManeuver = mapOffsetY;

            let dynamicHorizontalTarget = 0;
            const maneuver = currentStep.maneuver;
            const instructionText = getManeuverInstructionText(maneuver).toLowerCase();
            if (instructionText.includes('derecha')) dynamicHorizontalTarget = -5;
            else if (instructionText.includes('izquierda')) dynamicHorizontalTarget = 5;
            window.maneuverHorizontalTarget = dynamicHorizontalTarget;
        }

        let zoomProgress = 0;
        if (distanceToManeuver <= ZOOM_PEAK_DISTANCE) zoomProgress = 1;
        else zoomProgress = (ANIMATION_START_DISTANCE - distanceToManeuver) / (ANIMATION_START_DISTANCE - ZOOM_PEAK_DISTANCE);
        
        const easedZoomProgress = easeInOutQuad(Math.max(0, Math.min(1, zoomProgress)));
        const targetZoom = mapPreviousZoomLevelForProgressive + (MANEUVER_PEAK_ZOOM_LEVEL - mapPreviousZoomLevelForProgressive) * easedZoomProgress;
        
        let targetPitch;
        if (mapViewMode === 'perspective' || mapViewMode === 'relief') {
            const pitchTarget = window.pitchBeforeManeuver * 0.75;
            const finalPitchTarget = Math.max(55, pitchTarget);
            targetPitch = window.pitchBeforeManeuver - ((window.pitchBeforeManeuver - finalPitchTarget) * easedZoomProgress);
        } else {
            targetPitch = window.pitchBeforeManeuver + (55 - window.pitchBeforeManeuver) * easedZoomProgress;
        }
        
        return { 
            zoom: targetZoom, 
            pitch: targetPitch, 
            offsetX: window.maneuverHorizontalTarget,
            offsetY: window.offsetYBeforeManeuver
        };

    } else if (isZoomedForManeuver && distanceToNextManeuver < HOLD_ZOOM_THRESHOLD) {
        const pitchTarget = (mapViewMode === 'perspective' || mapViewMode === 'relief') ? window.pitchBeforeManeuver * 0.75 : 55;
        return {
            zoom: MANEUVER_PEAK_ZOOM_LEVEL,
            pitch: Math.max(55, pitchTarget),
            offsetX: window.maneuverHorizontalTarget,
            offsetY: window.offsetYBeforeManeuver
        };

    } else {
        if (isZoomedForManeuver) {
            isZoomedForManeuver = false; 
            MAP_UPDATE_INTERVAL_MS = originalMapUpdateIntervalMs;
        }
        return null;
    }
}    
    
// ===================================================================
// NOMBRE: showRadarSpeedModal
// RESUMEN: Muestra un modal para seleccionar la velocidad de un radar a a√±adir.
function showRadarSpeedModal(callbackOnSelect) {
    closeOtherModals('radar-speed-selection-modal');
    
    const modal = document.createElement('div');
    modal.id = 'radar-speed-selection-modal';
    modal.className = 'reminder-modal';
    modal.style.zIndex = '11000';
    
    const speeds = [30, 50, 60, 70, 80, 90, 100, 120, 'TRAMO'];
    
    let buttonsHtml = '';
    speeds.forEach(speed => {
        const isDefault = speed === 50;
        buttonsHtml += `<button class="action-button secondary speed-option ${isDefault ? 'default-selection' : ''}" data-speed="${speed}">${speed}</button>`;
    });

    modal.innerHTML = `
        <style>
            #radar-speed-selection-modal .reminder-modal-body {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                gap: 1.5rem;
            }
            #radar-speed-selection-modal .speed-options-grid {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 1rem;
                width: 100%;
                max-width: 400px;
            }
            #radar-speed-selection-modal .speed-option.selected {
                background-color: #007aff;
                border: 2px solid white;
                transform: scale(1.05);
            }
            #radar-speed-selection-modal .speed-option.default-selection {
                background-color: #F59E0B;
            }
        </style>
        <div class="reminder-modal-header">
            <h2 class="reminder-modal-title">Velocidad del Radar</h2>
        </div>
        <div class="reminder-modal-body">
            <p style="font-size: 1.1rem; text-align: center;">Selecciona la velocidad o se guardar√° la opci√≥n por defecto en <span id="radar-modal-countdown">4</span>s.</p>
            <div class="speed-options-grid">
                ${buttonsHtml}
            </div>
        </div>
        <div class="reminder-modal-footer" style="justify-content: center;">
             <button id="cancel-radar-add" class="action-button danger">Cancelar</button>
        </div>
    `;

    document.body.appendChild(modal);

    let countdown = 4;
    const countdownElement = modal.querySelector('#radar-modal-countdown');
    
    const closeHandler = () => {
        if (countdownInterval) clearInterval(countdownInterval);
        if (modal.parentNode) modal.remove();
    };

    let countdownInterval = setInterval(() => {
        countdown--;
        if (countdownElement) countdownElement.textContent = countdown;
        if (countdown <= 0) {
            clearInterval(countdownInterval);
            const defaultSpeed = modal.querySelector('.speed-option.default-selection')?.dataset.speed || '50';
            callbackOnSelect(defaultSpeed);
            closeHandler();
        }
    }, 1000);

    modal.querySelectorAll('.speed-option').forEach(button => {
        button.addEventListener('click', () => {
            const selectedSpeed = button.dataset.speed;
            callbackOnSelect(selectedSpeed);
            closeHandler();
        });
    });

    modal.querySelector('#cancel-radar-add').addEventListener('click', () => {
        showToast("Creaci√≥n de radar cancelada.", "info");
        callbackOnSelect(null);
        closeHandler();
    });
}

// ===================================================================
// NOMBRE: checkForExcessiveRadars 
// RESUMEN: Comprueba si el usuario tiene demasiados radares importados. Al limpiar,
function checkForExcessiveRadars() {
    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    const manualRadarReminders = reminders.filter(r => r && (r.text.toUpperCase().includes('RADAR') || r.excludeFromList === true) && !r.isDynamicRadar);

    if (manualRadarReminders.length > 200) {
        const modalId = 'excessive-radars-modal';
        const existingModal = document.getElementById(modalId);
        if (existingModal) return;

        const modal = document.createElement('div');
        modal.id = modalId;
        modal.className = 'choice-modal';
        modal.innerHTML = `
            <h2>Optimizaci√≥n de Radares</h2>
            <p style="margin-bottom: 1rem;">Hemos detectado que tienes <strong>${manualRadarReminders.length} radares</strong> importados. Un nuevo sistema carga autom√°ticamente los radares cercanos para mejorar el rendimiento.</p>
            <p style="margin-bottom: 1.5rem; font-weight: bold;">¬øDeseas eliminar los radares importados (excepto los creados manualmente con radio de 350m) y activar el nuevo sistema din√°mico?</p>
            <div class="modal-top-buttons">
                <button id="confirm-radar-cleanup" class="choice-edit" style="background-color: #28a745; color: white;">S√≠, limpiar y optimizar</button>
                <button id="cancel-radar-cleanup" class="choice-cancel">No, mantener mis radares</button>
            </div>
        `;
        document.body.appendChild(modal);

        const confirmBtn = document.getElementById('confirm-radar-cleanup');
        const cancelBtn = document.getElementById('cancel-radar-cleanup');
        
        const closeHandler = () => {
            clearModalAutoCloseTimer(modal, confirmBtn, modalId);
            if (modal.parentNode) modal.remove();
        };
        
        confirmBtn.addEventListener('click', async () => {
            showToast("Limpiando radares manuales antiguos...", "info", 0, false, "radar-cleanup-toast");
            
            const remindersToKeep = reminders.filter(r => {
                const isCandidateForDeletion = (r.text.toUpperCase().includes('RADAR') || r.excludeFromList === true) && !r.isDynamicRadar;
                
                if (!isCandidateForDeletion) {
                    return true;
                }
                
                if (r.radiusMeters === 350) {
                    return true;
                }
                
                return false;
            });
         
            localStorage.setItem('reminders', JSON.stringify(remindersToKeep));
            
            showToast("Guardando copia de seguridad en la nube...", "info", 0, false, "radar-cleanup-toast");
            await validateAndSaveUserToFirebase(); 
            
            const existingToast = document.getElementById("radar-cleanup-toast");
            if (existingToast) existingToast.remove();
            
            closeHandler();
            updateReminderCount();
            updateButtonStyles();
        });

        cancelBtn.addEventListener('click', () => {
             showToast("Optimizaci√≥n cancelada. Puedes limpiar los radares manualmente desde Configuraci√≥n > Radares > Borrar.", "info", 8000);
             closeHandler();
        });
        
        addModalAutoCloseTimer(modal, confirmBtn, modalId, 60000);
    }
}    
    
// ===================================================================
// NOMBRE: toggleMapControls
// RESUMEN: Activa o desactiva los controles de planificaci√≥n de ruta en el mapa (botones, buscador) y actualiza el estado de geolocalizaci√≥n.
function toggleMapControls(enabled) {
    
    const controls = [
        document.getElementById('map-location-search-input'),
        document.getElementById('map-location-search-button'),
        document.getElementById('clear-map-search-input-button'),
        document.getElementById('load-saved-route-button'),
        document.getElementById('reorder-route-stages-button'),
        document.getElementById('pdrs-ruta-button'),
        document.getElementById('add-reminder-at-location-button')
    ];

    controls.forEach(control => {
        if (control) {
            control.disabled = !enabled;
            control.style.opacity = enabled ? '1' : '0.5';
            control.style.cursor = enabled ? 'pointer' : 'not-allowed';
        }
    });
    
    setNavigationMapClickHandler();
}
    
// ===================================================================
// NOMBRE: getGridCellId
// RESUMEN: Calcula el ID de una celda de la cuadr√≠cula espacial para un punto geogr√°fico.
function getGridCellId(lat, lon) {
    const GRID_SIZE = 0.1;
    const latIndex = Math.floor(lat / GRID_SIZE);
    const lonIndex = Math.floor(lon / GRID_SIZE);
    return `cell_${latIndex}_${lonIndex}`;
}

// ===================================================================
// NOMBRE: initializeRadarCache 
// RESUMEN: Carga solo los radares de KLMFILES.TXT desde localStorage o los reconstruye si es necesario.
async function initializeRadarCache() {
    if (window.radarsCache) return; 
    if (isRadarCacheInitializing) {
        return new Promise(resolve => {
            const interval = setInterval(() => {
                if (!isRadarCacheInitializing) {
                    clearInterval(interval);
                    resolve();
                }
            }, 100);
        });
    }

    isRadarCacheInitializing = true;
    
    try {
        let remoteManifestDate = null;
        try {
            const response = await fetch(KML_FILES_LIST_STANDARD, { method: 'HEAD', cache: 'no-cache' });
            if (response.ok) {
                remoteManifestDate = response.headers.get('Last-Modified');
            }
        } catch (e) {
            console.warn("No se pudo obtener la fecha del manifiesto de radares, se forzar√° la recarga si no hay cach√©.");
        }

        const localCacheDate = localStorage.getItem('radarsCacheVersion');
        const cachedRadarsJSON = localStorage.getItem('radarsCacheData');
        const cachedIndexJSON = localStorage.getItem('radarsCacheIndex');

        if (remoteManifestDate && localCacheDate === remoteManifestDate && cachedRadarsJSON && cachedIndexJSON) {
            try {
                window.radarsCache = JSON.parse(cachedRadarsJSON);
                window.radarsSpatialIndex = JSON.parse(cachedIndexJSON);
                return; 
            } catch (e) {
                console.error("Error al parsear la cach√© de radares local. Se reconstruir√°.", e);
            }
        }

    
        let filesToProcess = await fetchKMLFilesList(KML_FILES_LIST_STANDARD);

        const processingPromises = filesToProcess.map(kmlFileName => 
            fetchAndParseKML(KML_BASE_PATH + kmlFileName)
                .catch(error => {
                    console.warn(`No se pudo procesar el archivo ${kmlFileName}:`, error);
                    return [];
                })
        );
        
        const results = await Promise.all(processingPromises);
        
        const allRadars = [];
        const spatialIndex = {};

        results.flat().forEach(placemark => {
            const coords = placemark.coordinates;
            if (coords) {
                const [lonStr, latStr] = coords.split(',');
                const lon = parseFloat(lonStr);
                const lat = parseFloat(latStr);
                if (!isNaN(lat) && !isNaN(lon)) {
                    const radarData = { name: placemark.name, lat: lat, lon: lon };
                    allRadars.push(radarData);
                    
                    const cellId = getGridCellId(lat, lon);
                    if (!spatialIndex[cellId]) spatialIndex[cellId] = [];
                    spatialIndex[cellId].push(radarData);
                }
            }
        });
        
        window.radarsCache = allRadars;
        window.radarsSpatialIndex = spatialIndex;

        try {
            localStorage.setItem('radarsCacheData', JSON.stringify(allRadars));
            localStorage.setItem('radarsCacheIndex', JSON.stringify(spatialIndex));
            if (remoteManifestDate) {
                localStorage.setItem('radarsCacheVersion', remoteManifestDate);
            }
        } catch (e) {
            console.error("No se pudo guardar la cach√© de radares en localStorage:", e);
            showToast("No se pudo guardar la cach√© de radares. Puede que la optimizaci√≥n se repita.", "warning");
        }
        
        const existingToast = document.getElementById("radar-cache-init");
        if (existingToast) existingToast.remove();
       
    } catch (error) {
        showToast("Error cr√≠tico al inicializar la cach√© de radares.", "error");
        window.radarsCache = [];
        window.radarsSpatialIndex = {};
    } finally {
        isRadarCacheInitializing = false;
    }
}   
    
// ===================================================================
// NOMBRE: deletePollMessage 
// RESUMEN: Permite al administrador borrar una encuesta permanentemente.
async function deletePollMessage(pollId) {
    if (!pollId) return;

    if (confirm('¬øEst√°s seguro de que deseas eliminar esta encuesta/votaci√≥n permanentemente?')) {
        try {
            const pollRef = window.doc(window.db, 'chatPolls', pollId);
            await window.deleteDoc(pollRef);
            showToast("Encuesta eliminada.", "success");
        } catch (error) {
            showToast("Error al eliminar la encuesta.", "error");
        }
    }
}

// ===================================================================
// NOMBRE: handlePollVote 
// RESUMEN: Gestiona el voto, actualiza la UI y actualiza el timestamp de la encuesta.
async function handlePollVote(pollId, optionIndex) {
    const currentUserId = localStorage.getItem('userData_userId');
    if (!currentUserId) {
        showToast("Debes configurar un ID de usuario para poder votar.", "warning");
        return;
    }

    const pollRef = window.doc(window.db, 'chatPolls', pollId);

    try {
        const pollSnap = await window.getDoc(pollRef);
        if (!pollSnap.exists()) {
            showToast("Error: La encuesta ya no existe.", "error");
            return;
        }

        const pollData = pollSnap.data();
        const updatedVotes = pollData.votes || {};

        if (updatedVotes[currentUserId] === optionIndex) {
            delete updatedVotes[currentUserId];
        } else {
            updatedVotes[currentUserId] = optionIndex;
        }

        await window.setDoc(pollRef, { 
            votes: updatedVotes,
            timestamp: window.serverTimestamp() 
        }, { merge: true });
        
        const pollElement = document.getElementById(`poll-${pollId}`);
        if (!pollElement) return;

        const totalVotes = Object.keys(updatedVotes).length;

        pollData.options.forEach((option, index) => {
            const optionElement = pollElement.querySelector(`[data-option-index="${index}"]`);
            if (!optionElement) return;

            const voteCount = Object.values(updatedVotes).filter(v => v === index).length;
            const percentage = totalVotes > 0 ? (voteCount / totalVotes) * 100 : 0;
            
            optionElement.querySelector('.poll-vote-count').textContent = voteCount;
            optionElement.querySelector('.poll-progress-fill').style.width = `${percentage}%`;
            
            const button = optionElement.querySelector('.poll-option-button');
            if (updatedVotes[currentUserId] === index) {
                button.classList.add('voted');
            } else {
                button.classList.remove('voted');
            }
            
            const voters = Object.entries(updatedVotes)
                .filter(([_, voteIndex]) => voteIndex === index)
                .map(([userId, _]) => userId);

            const votersList = optionElement.querySelector('.poll-voter-list');
            if (votersList) {
                if (voters.length > 0) {
                    votersList.innerHTML = voters.map(user => `<li class="poll-voter-name">${user}</li>`).join('');
                } else {
                    votersList.innerHTML = '';
                }
            }
        });

    } catch (error) {
        showToast("Error al registrar el voto.", "error");
    }
}

//===================================================================
// NOMBRE: showQuickReminderModal 
// RESUMEN: Muestra el modal de acciones r√°pidas para crear recordatorios.
// ===================================================================
function showQuickReminderModal() {
    closeOtherModals('quick-reminder-modal');

    const modal = document.createElement('div');
    modal.id = 'quick-reminder-modal';

    const hasRoute = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2;
    const hasLocation = !!navigationCurrentLocation;
    const savedLocations = getSavedLocations().filter(Boolean);

    let savedLocationsHtml = '';
    if (savedLocations.length > 0) {
        savedLocations.forEach((loc, index) => {
            savedLocationsHtml += `<li><button class="quick-action-btn" data-action="saved_location" data-index="${index}">${loc.name}</button></li>`;
        });
    } else {
        savedLocationsHtml = `<li style="color: #8e8e93; text-align: center; font-style: italic;">No hay ubicaciones guardadas.</li>`;
    }

    modal.innerHTML = `
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Noto+Color+Emoji&display=swap');

            .quick-action-btn .icon {
                font-family: 'Noto Color Emoji', 'Apple Color Emoji', 'Segoe UI Emoji', sans-serif;
                font-variant-emoji: emoji;
                -webkit-font-variant-emoji: emoji;
            }

            .quick-action-btn {
                display: flex;
                align-items: center;
                gap: 10px; 
                justify-content: flex-start;
            }
        </style>
        <div class="quick-reminder-content">
            <div class="quick-reminder-header">
                <h2>Crear Recordatorio R√°pido</h2>
            </div>
            <div class="quick-reminder-body">
                <div class="quick-reminder-columns">
                    <div class="quick-reminder-column">
                        <h3>Acciones Inmediatas</h3>
                        <ul class="quick-action-list">
                            <li><button class="quick-action-btn" data-action="map_click"><span class="icon">üìç</span> DONDE PULSE EN EL MAPA</button></li>
                            <li><button class="quick-action-btn" data-action="start_point" ${!hasRoute ? 'disabled' : ''}><span class="icon">‚Ü©Ô∏è</span> RECORDAR AL VOLVER (Salida)</button></li>
                            <li><button class="quick-action-btn" data-action="end_point" ${!hasRoute ? 'disabled' : ''}><span class="icon">üèÅ</span> AL LLEGAR (Destino)</button></li>
                            <li><button class="quick-action-btn" data-action="current_location" ${!hasLocation ? 'disabled' : ''}><span class="icon">üöó</span> AL PASAR POR AQU√ç</button></li>
                            <li><button class="quick-action-btn" data-action="time_15"><span class="icon">‚è±Ô∏è</span> EN 15 MINUTOS</button></li>
                            <li><button class="quick-action-btn" data-action="time_25"><span class="icon">‚è±Ô∏è</span> EN 25 MINUTOS</button></li>
                            <li><button class="quick-action-btn" data-action="time_60"><span class="icon">‚è±Ô∏è</span> EN 1 HORA</button></li>
                            <li><button class="quick-action-btn" data-action="tomorrow"><span class="icon">üóìÔ∏è</span> MA√ëANA</button></li>
                        </ul>
                    </div>
                    <div class="quick-reminder-column">
                        <h3>Ubicaciones Guardadas</h3>
                        <ul class="saved-locations-list">${savedLocationsHtml}</ul>
                    </div>
                </div>
            </div>
            <div class="quick-reminder-footer">
                <button id="close-quick-reminder-modal">Salir <span class="button-countdown-timer unified-countdown-style"></span></button>
            </div>
        </div>
    `;

    const mapModalContainer = document.getElementById('reminders-location-map-modal');
    mapModalContainer.appendChild(modal);

    const closeButton = modal.querySelector('#close-quick-reminder-modal');
    const closeHandler = () => {
        clearModalAutoCloseTimer(modal, closeButton, 'quick-reminder-modal');
        if (modal.parentNode) modal.remove();
    };
    closeButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(modal, closeButton, 'quick-reminder-modal', 30000);

    const handleAction = (action, data) => {
        closeHandler();
        
        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
        sessionStorage.setItem('mapContext', 'navigation');

        let reminderData = { text: '', isLocationEnabled: false };

        switch (action) {
            case 'map_click':
                sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
                sessionStorage.removeItem('mapContext');
                toggleAddReminderAtLocationMode();
                return;
            case 'start_point':
                const startWp = navigationWaypoints.find(wp => wp.type === 'S' || wp.isRecalculatedStart);
                reminderData.locationCoordinates = { latitude: startWp.lat, longitude: startWp.lng };
                reminderData.isLocationEnabled = true;
                reminderData.text = 'RECORDAR AL VOLVER: ';
                break;
            case 'end_point':
                const endWp = navigationWaypoints[navigationWaypoints.length - 1];
                reminderData.locationCoordinates = { latitude: endWp.lat, longitude: endWp.lng };
                reminderData.isLocationEnabled = true;
                reminderData.text = 'RECORDAR AL LLEGAR: ';
                break;
            case 'current_location':
                reminderData.locationCoordinates = { latitude: navigationCurrentLocation.latitude, longitude: navigationCurrentLocation.longitude };
                reminderData.isLocationEnabled = true;
                reminderData.text = 'RECORDAR AL PASAR POR AQU√ç: ';
                break;
            case 'time_15':
            case 'time_25':
            case 'time_60':
                const minutes = parseInt(action.split('_')[1]);
                const { newDateISO, newTime } = calculatePostponedDateTime(minutes);
                reminderData.date = newDateISO;
                reminderData.time = newTime;
                reminderData.text = `RECORDAR EN ${minutes === 60 ? '1 HORA' : `${minutes} MINUTOS`}: `;
                break;
            case 'tomorrow':
                const tomorrow = new Date();
                tomorrow.setDate(tomorrow.getDate() + 1);
                reminderData.date = `${tomorrow.getFullYear()}-${(tomorrow.getMonth() + 1).toString().padStart(2, '0')}-${tomorrow.getDate().toString().padStart(2, '0')}`;
                reminderData.time = '00:01';
                reminderData.text = 'RECORDAR MA√ëANA: ';
                break;
            case 'saved_location':
                const location = savedLocations[data.index];
                reminderData.locationCoordinates = { latitude: location.lat, longitude: location.lng };
                reminderData.isLocationEnabled = true;
                reminderData.text = `RECORDAR EN ${location.name.toUpperCase()}: `;
                break;
        }
        showReminderModal(reminderData, { onTopOfMap: true });
    };

    modal.addEventListener('click', (e) => {
        const button = e.target.closest('button[data-action]');
        if (button) {
            handleAction(button.dataset.action, { index: parseInt(button.dataset.index) });
        }
    });
}
    
// ===================================================================
// NOMBRE: startEditPollQuestion 
// RESUMEN: Permite al admin editar la pregunta y actualiza el timestamp de la encuesta.
async function startEditPollQuestion(pollId, currentQuestion) {
    const newQuestion = prompt("Edita la pregunta de la encuesta:", currentQuestion);

    if (newQuestion && newQuestion.trim() !== '' && newQuestion !== currentQuestion) {
        try {
            const pollRef = window.doc(window.db, 'chatPolls', pollId);
            await window.setDoc(pollRef, { 
                question: newQuestion.trim(),
                timestamp: window.serverTimestamp() 
            }, { merge: true });
            showToast("Pregunta de la encuesta actualizada.", "success");
        } catch (error) {
            showToast("Error al actualizar la pregunta.", "error");
        }
    }
}

// ===================================================================
// NOMBRE: incrementMapSessionCount 
// RESUMEN: Usa updateDoc para garantizar que solo se modifican los contadores de sesi√≥n del usuario.
// ===================================================================
async function incrementMapSessionCount() {
    const { primaryId: userId } = parseUserId(localStorage.getItem('userData_userId'));
    if (!userId || !window.db) {
        return;
    }

    try {
        const dailyCounterRef = window.doc(window.db, "stats", "daily_activity");
        
        await window.runTransaction(window.db, async (transaction) => {
            const counterDoc = await transaction.get(dailyCounterRef);
            const todayString = new Date().toISOString().split('T')[0];

            let data = counterDoc.exists() ? counterDoc.data() : {};
            let usersToday = (data.hoy === todayString && Array.isArray(data.users)) ? data.users : [];
            
            if (!usersToday.includes(userId)) {
                usersToday.push(userId);
                const newData = {
                    hoy: todayString,
                    users: usersToday,
                    sesionesDia: usersToday.length
                };
                transaction.set(dailyCounterRef, newData);
            }
        });

    } catch (error) {
        console.error("Error en la transacci√≥n del contador diario:", error);
    }

    try {
        const userDocRef = window.doc(window.db, "user_data", userId);
        const docSnap = await window.getDoc(userDocRef);
        
        const now = new Date();
        const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        let newTotal = 1;
        let newMonthCount = 1;
        
        if (docSnap.exists()) {
            const data = docSnap.data();
            newTotal = (data.map_sessions_total || 0) + 1;
            
            if (data.map_sessions_last_month === currentMonthStr) {
                newMonthCount = (data.map_sessions_month || 0) + 1;
            } else {
                newMonthCount = 1;
            }
        }
        
        const dataToUpdate = {
            map_sessions_total: newTotal,
            map_sessions_month: newMonthCount,
            map_sessions_last_month: currentMonthStr
        };

        await window.updateDoc(userDocRef, dataToUpdate);

    } catch (error) {
        console.error("Error al actualizar el contador de sesiones del usuario:", error);
    }
}    
    
// ===================================================================
// NOMBRE: getGlobalMapSessionStats 
// RESUMEN: Calcula las estad√≠sticas globales de sesiones de mapa de todos los usuarios.
async function getGlobalMapSessionStats() {
    if (!window.db) return { totalMonth: 0, totalHistoric: 0 };
    
    let totalMonth = 0;
    let totalHistoric = 0;
    
    try {
        const usersCollectionRef = window.collection(window.db, "user_data");
        const querySnapshot = await window.getDocs(usersCollectionRef);
        
        const now = new Date();
        const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        querySnapshot.forEach(doc => {
            const data = doc.data();
            totalHistoric += (data.map_sessions_total || 0);
            
            if (data.map_sessions_last_month === currentMonthStr) {
                totalMonth += (data.map_sessions_month || 0);
            }
        });

    } catch (error) {
        console.error("Error al obtener estad√≠sticas globales de sesiones de mapa:", error);
    }
    
    return { totalMonth, totalHistoric };
}

// ===================================================================
// NOMBRE: displayAlertsOnMap 
// RESUMEN: Dibuja las alertas y a√±ade un listener de clic a cada marcador para que sean interactivos.
function displayAlertsOnMap() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
        return;
    }
    
    const alertFeatures = trafficAlertsCache.map(alert => {
        if (alert.code === 9) return null;
        return {
            type: 'Feature',
            geometry: {
                type: 'Point',
                coordinates: [alert.coordinates.lon, alert.coordinates.lat]
            },
            properties: {
                code: alert.code,
                id: alert.id
            }
        };
    }).filter(Boolean);

    const geojsonData = {
        type: 'FeatureCollection',
        features: alertFeatures
    };

    const sourceId = 'traffic-alerts-source';
    const source = navigationMapInstance.getSource(sourceId);
    if (source) {
        source.setData(geojsonData);
    } else {
        navigationMapInstance.addSource(sourceId, {
            type: 'geojson',
            data: geojsonData
        });
    }

    const layerId = 'traffic-alerts-layer';
    if (!navigationMapInstance.getLayer(layerId)) {
        navigationMapInstance.addLayer({
            id: layerId,
            type: 'symbol',
            source: sourceId,
            minzoom: 5.5, maxzoom: 19,
            layout: {
                'icon-image': [
                    'match',
                    ['get', 'code'],
                    1, 'alert-1',
                    2, 'alert-2',
                    3, 'alert-3',
                    4, 'alert-4',
                    5, 'alert-5',
                    6, 'alert-6',
                    7, 'alert-7',
                    8, 'alert-8',
                    'alert-5' 
                ],
                'icon-size': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    12, 0.30,  
                    16, 0.50   
                ],
                'icon-allow-overlap': true,
                'icon-anchor': 'center'
            }
        });

        navigationMapInstance.on('mouseenter', layerId, () => { if(navigationMapInstance) navigationMapInstance.getCanvas().style.cursor = 'pointer'; });
        navigationMapInstance.on('mouseleave', layerId, () => { if(navigationMapInstance) navigationMapInstance.getCanvas().style.cursor = ''; });
    }
}

// ===================================================================
// NOMBRE: assignMapButtonListeners 
// RESUMEN: Se actualiza el gesto de toque simple en el bot√≥n multifunci√≥n.
function assignMapButtonListeners() {
    const header = document.getElementById('reminders-location-map-header');
    const togglePanelButton = document.getElementById('toggle-map-header-buttons-panel');
    const mapLocationSearchInput = document.getElementById('map-location-search-input');
    const mapFilterInput = document.getElementById('filter-input');
    
    if (!header || !togglePanelButton || !mapLocationSearchInput || !mapFilterInput) return;

    if (header._mapButtonClickHandler) {
        header.removeEventListener('click', header._mapButtonClickHandler);
    }
    
    const reassignElement = (element) => {
        const newElement = element.cloneNode(true);
        element.parentNode.replaceChild(newElement, element);
        return newElement;
    };
    
    const newTogglePanelButton = reassignElement(togglePanelButton);
    let swipeStartX = 0, swipeStartY = 0, isSwiping = false, pressTimer = null;
    const handleGestureStart = (e) => { isSwiping = false; swipeStartX = e.touches ? e.touches[0].clientX : e.clientX; swipeStartY = e.touches ? e.touches[0].clientY : e.clientY; clearTimeout(pressTimer); pressTimer = setTimeout(() => { openAlertModal(); swipeStartX = 0; swipeStartY = 0; }, 350); if(e.type === 'touchstart') e.preventDefault(); };
    const handleGestureMove = (e) => { if (swipeStartX === 0) return; const moveX = e.touches ? e.touches[0].clientX : e.clientX; const moveY = e.touches ? e.touches[0].clientY : e.clientY; if (Math.abs(moveX - swipeStartX) > 10 || Math.abs(moveY - swipeStartY) > 10) { isSwiping = true; clearTimeout(pressTimer); } };
    const handleGestureEnd = (e) => { 
        clearTimeout(pressTimer); 
        if (swipeStartX === 0) return; 
        const endX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX; 
        const endY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY; 
        const deltaX = endX - swipeStartX; 
        const deltaY = endY - swipeStartY; 
        const swipeThreshold = 50; 
        
        if (!isSwiping) {
            if (isMapImmersiveModeActive) {
                setMapImmersiveMode(false);
            } else {
                toggleMapHeaderRowsVisibility(!mapHeaderButtonsVisible);
            }
        } 
        
        else { // L√≥gica de deslizamiento (sin cambios)
            if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > swipeThreshold) { 
                if (deltaY < 0) { toggleNavigationState(false, false); } else { loadRouteByName("TRABAJO", true); } 
            } else if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > swipeThreshold) { 
                if (deltaX < 0) { toggleMapImmersiveMode(); } else { loadRouteByName("CASA", true); } 
            } 
        } 
        swipeStartX = 0; swipeStartY = 0; isSwiping = false; 
    };

    newTogglePanelButton.addEventListener('mousedown', handleGestureStart);
    newTogglePanelButton.addEventListener('mousemove', handleGestureMove);
    newTogglePanelButton.addEventListener('mouseup', handleGestureEnd);
    newTogglePanelButton.addEventListener('mouseleave', handleGestureEnd);
    newTogglePanelButton.addEventListener('touchstart', handleGestureStart, { passive: false });
    newTogglePanelButton.addEventListener('touchmove', handleGestureMove, { passive: false });
    newTogglePanelButton.addEventListener('touchend', handleGestureEnd);
    
    if (!header._delegateAttached) {
        header.addEventListener('click', (event) => {
            const button = event.target.closest('button');
            if (!button || button.disabled) return;
            event.stopPropagation();
            
            if (button.id === 'ai-route-planner-button') {
                return; 
            }
            
            switch (button.id) {
                 case 'close-reminders-location-map': closeNavigationMap(false); break;
                 case 'locate-me-on-reminders-map': handleLocateMeClick(true); break;
                 case 'nav-map-zoomtoggle-button': handleZoomToggleButtonClick(button); break;
                 case 'start-navigation-button': toggleNavigationState(false, false); break;
                 case 'save-route-button': saveCurrentRoute(); break;
                 case 'delete-current-route-button': handleLoadOrDeleteRouteClick(button); break;
                 case 'load-saved-route-button': showLoadRouteModal(); break;
                 case 'add-radar-here': handleAddRadarHereClick(button); break;
                 case 'accident-alert-button-map': openAlertModal(); break;
                 case 'pdrs-ruta-button': handlePdrSearchButtonClick(); break;
                 case 'add-reminder-at-location-button': showQuickReminderModal(); break;   
                 case 'toggle-simulate-gps-button': handleGpsSimulationToggle(); break;
                 case 'simulate-route-button': showSimulationModal(); break;
                 case 'reorder-route-stages-button': showReorderStagesModal(); break;
                 case 'navigation-map-help-button':
                    const existingChoiceModal = document.querySelector('.choice-modal.help-choice');
                    if(existingChoiceModal) existingChoiceModal.remove();

                    const choiceModal = document.createElement('div');
                    choiceModal.className = 'choice-modal help-choice';
                    choiceModal.style.zIndex = '9999';
                    choiceModal.innerHTML = `
                        <h2>Men√∫ de Ayuda</h2>
                        <p>¬øQu√© deseas hacer?</p>
                        <div class="personalization-options">
                            <button id="start-interactive-guide-choice">Iniciar Gu√≠a Interactiva</button>
                            <button id="open-config-panel-choice">Abrir Panel de Configuraci√≥n</button>
                            <button id="cancel-help-choice-btn">Cancelar</button>
                        </div>
                    `;
                    document.body.appendChild(choiceModal);
                    
                    document.getElementById('start-interactive-guide-choice').onclick = () => {
                        choiceModal.remove();
                        if (typeof iniciarGuiaInteractivaCompleta === 'function') {
                            iniciarGuiaInteractivaCompleta();
                        }
                    };
                    document.getElementById('open-config-panel-choice').onclick = () => {
                        choiceModal.remove();
                        showNavigationMapHelpModal();  };
                    document.getElementById('cancel-help-choice-btn').onclick = () => {
                        choiceModal.remove();
                    };
                    break;
                 case 'range-calculator-button':
                    toggleRangeCalcMode();
                    break;
                 case 'map-location-search-button': 
                    togglePoiCategorySearch();
                    break;
                 case 'clear-map-search-input-button':
                    const currentSearchInputToClear = document.getElementById('map-location-search-input');
                    if (currentSearchInputToClear) { currentSearchInputToClear.value = ''; }
                    currentSearchInputToClear?.dispatchEvent(new Event('input'));
                    currentSearchInputToClear?.focus();
                    hideAddressSuggestionsModal();
                    if (isPoiSearchActive) {
                        clearPoiSearchResults();
                        isPoiSearchActive = false;
                        const searchButton = document.getElementById('map-location-search-button');
                        if (searchButton) searchButton.style.removeProperty('background-color');
                    }
                    break;
            }
        });
        header.addEventListener('click', header._mapButtonClickHandler);
    }
    
    const aiPlannerButton = document.getElementById('ai-route-planner-button');
    if (aiPlannerButton && !aiPlannerButton.dataset.listenerAttached) {
        aiPlannerButton.addEventListener('click', openAiPlannerModal);
        aiPlannerButton.dataset.listenerAttached = 'true';
    }
   
    const newMapLocationSearchInput = reassignElement(mapLocationSearchInput);
    const newMapFilterInput = reassignElement(mapFilterInput);

    let searchDebounceTimer;
    const handleSearchInput = () => {
        const hasMainText = newMapLocationSearchInput.value.trim() !== '';
        const clearBtn = document.getElementById('clear-map-search-input-button');
        if(clearBtn) clearBtn.style.display = hasMainText ? 'inline-flex' : 'none';
        
        clearTimeout(searchDebounceTimer);
        const mainTerm = newMapLocationSearchInput.value.trim();
        if (mainTerm) {
            const filterTerm = newMapFilterInput.value.trim();
            let combinedSearchTerm = mainTerm;
            if (filterTerm) { combinedSearchTerm += ' ' + filterTerm; }
            searchDebounceTimer = setTimeout(() => fetchAddressSuggestions(combinedSearchTerm), 450);
        } else {
            hideAddressSuggestionsModal();
        }
        localStorage.setItem(MAP_FILTER_INPUT_KEY, newMapFilterInput.value);
        markCacheAsDirty(); 
    };

    newMapLocationSearchInput.addEventListener('input', handleSearchInput);
    newMapFilterInput.addEventListener('input', handleSearchInput);

    newMapLocationSearchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            const mainTerm = newMapLocationSearchInput.value.trim();
            if (!mainTerm) { showToast("El campo de b√∫squeda principal no puede estar vac√≠o.", "warning"); return; }
            const filterTerm = newMapFilterInput.value.trim() || '';
            let combinedSearchTerm = mainTerm;
            if (filterTerm) { combinedSearchTerm += ' ' + filterTerm; }
            hideAddressSuggestionsModal();
            searchAndAddWaypoint(combinedSearchTerm);
        }
    });
    
    const radaresCheckbox = reassignElement(document.getElementById('radares-ruta-checkbox'));
    radaresCheckbox.addEventListener('change', (e) => {
        markCacheAsDirty();
        toggleRadaresRuta(e.target.checked);
    });
    
    const tareasCheckbox = reassignElement(document.getElementById('tareas-ruta-checkbox'));
    tareasCheckbox.addEventListener('change', (e) => {
        markCacheAsDirty();
        toggleTareasRuta(e.target.checked);
    });
    
    const mapboxCheckbox = reassignElement(document.getElementById('mapbox-primary-checkbox'));
    mapboxCheckbox.addEventListener('change', (e) => {
        const OSRM_PRIMARY_KEY = 'boardinggate_useOsrmAsPrimary';
        localStorage.setItem(OSRM_PRIMARY_KEY, e.target.checked);
        markCacheAsDirty();
        const serviceName = e.target.checked ? 'OSRM' : 'Mapbox';
        showToast(`Servicio primario cambiado a ${serviceName}. Recalculando ruta...`, 'success');
        if (navigationWaypoints.length >= 2) { recalculateAndDrawRoute(false); }
    });
    
    newMapLocationSearchInput.value = '';
    newMapFilterInput.value = localStorage.getItem(MAP_FILTER_INPUT_KEY) || 'Espa√±a';
}
    
// ===================================================================
// NOMBRE: reAddCustomMapLayersAndSources 
// RESUMEN: Garantiza el orden de renderizado creando una capa de anclaje
async function reAddCustomMapLayersAndSources(mapInstance) {
    if (!mapInstance || !mapInstance.isStyleLoaded()) return;

    const routeGeojsonData = (navigationCurrentRouteData?.routes?.[0]?.geometry)
        ? { type: 'Feature', properties: {}, geometry: navigationCurrentRouteData.routes[0].geometry }
        : { type: 'FeatureCollection', features: [] };
    
    const speedMarkersGeojsonData = {
        type: 'FeatureCollection',
        features: speedMarkerFeatures || []
    };

    const layersToRemove = ['speed-markers-text', 'speed-markers-circle-bg', 'route', 'custom-layers-anchor'];
    const sourcesToRemove = ['speed-markers-source', 'route'];

    layersToRemove.forEach(id => { try { if (mapInstance.getLayer(id)) mapInstance.removeLayer(id); } catch (e) {} });
    sourcesToRemove.forEach(id => { try { if (mapInstance.getSource(id)) mapInstance.removeSource(id); } catch (e) {} });

    try {
        mapInstance.addSource('route', { type: 'geojson', data: routeGeojsonData });
        mapInstance.addSource('speed-markers-source', {  type: 'geojson', data: speedMarkersGeojsonData });
     
        mapInstance.addLayer({
            id: 'custom-layers-anchor',
            type: 'background',  paint: {
                'background-opacity': 0 }
        });
        mapInstance.addLayer({ 
            id: 'route', 
            type: 'line', 
            source: 'route', 
            minzoom: 1.5, maxzoom: 19, 
            layout: { 'line-join': 'round', 'line-cap': 'round' }, 
            paint: getRouteStyleProperties() 
        }, 'custom-layers-anchor'); 
        mapInstance.addLayer({ 
            id: 'speed-markers-circle-bg', 
            type: 'circle', 
            source: 'speed-markers-source', 
            minzoom: 9, maxzoom: 19, 
            paint: { 'circle-radius': 30, 'circle-color': '#FF2E08', 'circle-stroke-width': 6, 'circle-stroke-color': 'white' } 
        }, 'custom-layers-anchor'); 
        mapInstance.addLayer({ 
            id: 'speed-markers-text', 
            type: 'symbol', 
            source: 'speed-markers-source', 
            minzoom: 9, maxzoom: 19, 
            layout: { 'text-field': ['get', 'speedText'], 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 20, 'text-allow-overlap': true }, 
            paint: { 'text-color': 'white' } 
        }, 'custom-layers-anchor'); 

    } catch (e) {
        console.error("Error al re-a√±adir capas de ruta/velocidad:", e);
    }
 }
 
// ===================================================================
// NOMBRE: openChatModal 
// RESUMEN: Rellena autom√°ticamente el campo de filtro con "fecha" si el usuario es el administrador.
// ===================================================================
async function openChatModal() {
    const modalOverlay = document.getElementById('chat-modal-overlay');
    if (!modalOverlay) return;
    
    lastVisibleUserDoc = null;
    lastVisibleMessageDoc = null;
    isFetchingUsers = false;
    isFetchingMessages = false;
    
    document.body.classList.add('chat-open');
    modalOverlay.classList.remove('hidden');

    const sendButton = document.getElementById('chat-send-button');
    const messageInput = document.getElementById('chat-message-input');
    const charCounter = document.getElementById('chat-char-counter');
    const permissionWarning = document.getElementById('chat-permission-warning');
    const messagesContainer = document.getElementById('chat-messages-container');
    const usersListContainer = document.getElementById('chat-users-list');
    
    const currentUserId = localStorage.getItem('userData_userId');
    const isAdmin = (currentUserId || '').toLowerCase() === 'boardinggate';
    const filterInput = document.getElementById('chat-user-filter-input');
    
    if (filterInput) {
        if (isAdmin) {
            filterInput.value = 'fecha';
        } else {
            filterInput.value = ''; // Aseguramos que para otros usuarios est√© vac√≠o
        }
    }
    
    const originalPlaceholder = "Escribe un mensaje... (antecede @usuario para mensaje privado, o pulsa en el lateral. Para referirse simplemente n√≥mbralo). Vida de los mensajes 96 horas. En el coche usa los comandos de voz. Elon cree en la humanidad, the White Monkey y yo tambi√©n, ser educad@s.";
    const pollPlaceholder = "Para encuestas/votaciones, usa el formato: #COMUNIDAD#Pregunta#Opci√≥n1 $ Opci√≥n2...#";
    messageInput.placeholder = `${originalPlaceholder} ${pollPlaceholder}`;

    const currentUserDmsAllowed = JSON.parse(localStorage.getItem('userData_allowDMs') || 'false');
    
    if (isAdmin && !sessionStorage.getItem('chatCleanupSessionDone')) {
        sessionStorage.setItem('chatCleanupSessionDone', 'true');
        showToast("Hola Admin. Realizando limpieza de mensajes antiguos...", "info");
        cleanUpOldChatMessages();
    }

    if (!currentUserId) {
        permissionWarning.textContent = "Debes configurar un ID de Usuario para poder chatear.";
        permissionWarning.classList.remove('hidden');
        sendButton.disabled = true;
        messageInput.disabled = true;
    } else if (!currentUserDmsAllowed) {
        permissionWarning.innerHTML = `Si quiere recibir mensajes o poder enviar mensajes tanto p√∫blicos como dirigidos a un usuario concreto debe activar en <strong>Configuraci√≥n > Usuario > Permitir MDs (v√≠a admin)</strong>`;
        permissionWarning.classList.remove('hidden');
        sendButton.disabled = true;
        messageInput.disabled = true;
    } else {
        permissionWarning.classList.add('hidden');
        sendButton.disabled = false;
        messageInput.disabled = false;
    }
    
    charCounter.textContent = messageInput.maxLength;
    
    if (!messageInput.listenerAdded) {
        messageInput.addEventListener('input', () => {
            const remaining = messageInput.maxLength - messageInput.value.length;
            charCounter.textContent = remaining;
        });
        messageInput.listenerAdded = true;
    }

    const newExitButton = document.getElementById('chat-exit-button').cloneNode(true);
    document.getElementById('chat-exit-button').parentNode.replaceChild(newExitButton, document.getElementById('chat-exit-button'));
    newExitButton.addEventListener('click', closeChatModal);

    const newSendButton = sendButton.cloneNode(true);
    sendButton.parentNode.replaceChild(newSendButton, sendButton);
    newSendButton.addEventListener('click', sendMessage);

    if (!messagesContainer.listenerAdded) {
        messagesContainer.addEventListener('click', (event) => {
            const target = event.target.closest('[data-action]');
            if (!target) return;

            event.stopPropagation();
            const action = target.dataset.action;
            const id = target.dataset.id;
            
            switch (action) {
                case 'vote-poll':
                    const optionIndex = parseInt(target.dataset.optionIndex, 10);
                    handlePollVote(id, optionIndex);
                    break;
                case 'edit-message':
                    const content = target.dataset.content;
                    startEditMessage(id, content);
                    break;
                case 'delete-message':
                    deleteChatMessage(id);
                    break;
                case 'edit-poll':
                    const question = target.dataset.question;
                    startEditPollQuestion(id, question);
                    break;
                case 'delete-poll':
                    deletePollMessage(id);
                    break;
            }
        });
        messagesContainer.addEventListener('scroll', () => {
            if (messagesContainer.scrollTop + messagesContainer.clientHeight >= messagesContainer.scrollHeight - 100) {
                fetchAndRenderChatMessages(true); // Cargar m√°s
            }
        });
        messagesContainer.listenerAdded = true;
    }

    if (!usersListContainer.listenerAdded) {
        usersListContainer.addEventListener('scroll', () => {
            if (usersListContainer.scrollTop + usersListContainer.clientHeight >= usersListContainer.scrollHeight - 100) {
                fetchAndRenderChatUsers(true); 
            }
        });
        usersListContainer.listenerAdded = true;
    }

    await fetchAndRenderChatUsers(false); 
    await fetchAndRenderChatMessages(false); 
    updateTotalMessageCount();

    if (chatUpdateInterval) clearInterval(chatUpdateInterval);
    chatUpdateInterval = setInterval(() => {
        if (!modalOverlay.classList.contains('hidden')) {
            updateTotalMessageCount();
        }
    }, 15000);
}    
    
// ===================================================================
// NOMBRE: fetchAndRenderChatMessages 
// RESUMEN: Carga mensajes y encuestas en lotes de 100 y gestiona el scroll infinito.
async function fetchAndRenderChatMessages(loadMore = false) {
    const messagesContainer = document.getElementById('chat-messages-container');
    if (!messagesContainer || !window.db || isFetchingMessages) return;

    const currentUserId = (localStorage.getItem('userData_userId') || '').trim();
    if (!currentUserId) {
        messagesContainer.innerHTML = '<p class="chat-system-message">Configura tu ID de usuario para ver el chat.</p>';
        return;
    }

    if (!loadMore) {
        messagesContainer.innerHTML = '';
    }
  
    if (loadMore && !lastVisibleMessageDoc) {
        return; 
    }

    isFetchingMessages = true;
    const currentUserIdLower = currentUserId.toLowerCase();

    try {
        const PAGE_SIZE = 100;
        const oneHundredTwentyHoursAgo = new Date(Date.now() - 120 * 60 * 60 * 1000);
        
        let messagesQuery;
        const messagesRef = window.collection(window.db, 'chatMessages');
        
        if (lastVisibleMessageDoc) {
            messagesQuery = window.query(messagesRef, window.where('timestamp', '>', oneHundredTwentyHoursAgo), window.orderBy('timestamp', 'desc'), window.startAfter(lastVisibleMessageDoc), window.limit(PAGE_SIZE));
        } else {
            messagesQuery = window.query(messagesRef, window.where('timestamp', '>', oneHundredTwentyHoursAgo), window.orderBy('timestamp', 'desc'), window.limit(PAGE_SIZE));
        }
        
        const pollsQuery = window.query(window.collection(window.db, 'chatPolls'), window.orderBy('timestamp', 'desc'));
        
        const [messagesSnapshot, pollsSnapshot] = await Promise.all([
            window.getDocs(messagesQuery),
            loadMore ? Promise.resolve({ docs: [] }) : window.getDocs(pollsQuery)
        ]);

        const messageDocs = messagesSnapshot.docs;
        if (messageDocs.length > 0) {
            lastVisibleMessageDoc = messageDocs[messageDocs.length - 1];
        } else {
            lastVisibleMessageDoc = null; 
        }

        let combinedItems = [];
        messageDocs.forEach(doc => combinedItems.push({ id: doc.id, ...doc.data(), isPoll: false }));
        
        if (!loadMore) {
            pollsSnapshot.forEach(doc => combinedItems.push({ id: doc.id, ...doc.data(), isPoll: true }));
        }

        if (!loadMore) {
            combinedItems.sort((a, b) => (b.timestamp?.toMillis() || 0) - (a.timestamp?.toMillis() || 0));
        }
        
        if (combinedItems.length === 0 && !loadMore) {
            messagesContainer.innerHTML = '<p class="chat-system-message">No hay mensajes recientes. ¬°S√© el primero en escribir!</p>';
            isFetchingMessages = false;
            return;
        }

        combinedItems.forEach(item => {
            if (item.isPoll) {
                messagesContainer.appendChild(renderPollBubble(item, currentUserId));
            } else {
                const isPublic = item.recipientId.toLowerCase() === 'public';
                const isForMe = item.recipientId.toLowerCase() === currentUserIdLower;
                const iSentIt = item.senderId.toLowerCase() === currentUserIdLower;

                if (isPublic || isForMe || iSentIt) {
                    const bubble = document.createElement('div');
                    bubble.className = 'chat-message-bubble';
                    
                    let bubbleClass = '';
                    if (iSentIt && isPublic) { bubble.style.backgroundColor = '#DF6565'; bubbleClass = 'public-msg'; }
                    else if (isForMe && !iSentIt) { bubbleClass = 'private-msg'; }
                    else if (isPublic) { bubbleClass = 'public-msg'; }
                    else if (iSentIt && !isPublic) { bubbleClass = 'private-msg-sent'; }
                    bubble.classList.add(iSentIt ? 'sent' : 'received', bubbleClass);

                    const senderSpan = document.createElement('span');
                    senderSpan.className = 'chat-message-sender';
                    senderSpan.textContent = item.senderId + (item.recipientId.toLowerCase() !== 'public' ? ` a ${item.recipientId}` : '');
                    
                    const contentSpan = document.createElement('span');
                    contentSpan.className = 'chat-message-content';
                    contentSpan.textContent = item.content;
                    
                    const timeSpan = document.createElement('span');
                    timeSpan.className = 'chat-message-time';
                    const timeText = document.createElement('span');
                    timeText.textContent = item.timestamp?.toDate ? `${item.timestamp.toDate().toLocaleDateString([], {day:'2-digit', month:'2-digit'})} - ${item.timestamp.toDate().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}` : '';
                    timeSpan.appendChild(timeText);

                    if (iSentIt || currentUserId === 'BoardingGate') {
                        const actionsContainer = document.createElement('div');
                        actionsContainer.className = 'chat-message-actions';
                        
                        const editIcon = document.createElement('img');
                        editIcon.src = 'https://boardinggate.github.io/Tesla/PNG/editmsg.png';
                        editIcon.className = 'chat-action-icon';
                        editIcon.title = 'Editar mensaje';
                        editIcon.dataset.action = 'edit-message';
                        editIcon.dataset.id = item.id;
                        editIcon.dataset.content = item.content;

                        const deleteIcon = document.createElement('img');
                        deleteIcon.src = 'https://boardinggate.github.io/Tesla/PNG/erasemsg.png';
                        deleteIcon.className = 'chat-action-icon';
                        deleteIcon.title = 'Eliminar mensaje';
                        deleteIcon.dataset.action = 'delete-message';
                        deleteIcon.dataset.id = item.id;

                        actionsContainer.appendChild(editIcon);
                        actionsContainer.appendChild(deleteIcon);
                        timeSpan.appendChild(actionsContainer);
                    }
                    
                    bubble.appendChild(senderSpan);
                    bubble.appendChild(contentSpan);
                    bubble.appendChild(timeSpan);
                    messagesContainer.appendChild(bubble);
                }
            }
        });
        
        if (!loadMore) {
            messagesContainer.scrollTop = 0;
        }

    } catch (error) {
        messagesContainer.innerHTML = `<p class="chat-system-message">Error al cargar el chat: ${error.message}</p>`;
    } finally {
        isFetchingMessages = false;
    }
}
    
// ===================================================================
// NOMBRE: renderPollBubble 
// RESUMEN: Construye un elemento DOM para la encuesta, evitando errores de sintaxis.
function renderPollBubble(poll, currentUserId) {
    const totalVotes = Object.keys(poll.votes || {}).length;
    
    const pollBubble = document.createElement('div');
    pollBubble.id = `poll-${poll.id}`;
    pollBubble.className = 'chat-message-bubble chat-poll-bubble';

    const senderTime = poll.timestamp?.toDate 
        ? `${poll.timestamp.toDate().toLocaleDateString([], {day: '2-digit', month: '2-digit'})} - ${poll.timestamp.toDate().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`
        : 'enviando...';

    const senderInfo = document.createElement('div');
    senderInfo.className = 'poll-sender-info';
    senderInfo.innerHTML = `<span class="chat-message-sender">${poll.senderId}</span><span class="poll-time">${senderTime}</span>`;
    
    const questionEl = document.createElement('p');
    questionEl.className = 'poll-question';
    questionEl.textContent = poll.question;

    const optionsList = document.createElement('ul');
    optionsList.className = 'poll-options-list';

    poll.options.forEach((option, index) => {
        const voteCount = Object.values(poll.votes || {}).filter(voteIndex => voteIndex === index).length;
        const percentage = totalVotes > 0 ? (voteCount / totalVotes) * 100 : 0;
        const hasVotedThis = (poll.votes || {})[currentUserId] === index;

        const voters = Object.entries(poll.votes || {}).filter(([_, vIndex]) => vIndex === index).map(([userId, _]) => userId);
        
        const listItem = document.createElement('li');
        listItem.className = 'poll-option-item';
        listItem.dataset.optionIndex = index;

        const button = document.createElement('button');
        button.className = `poll-option-button ${hasVotedThis ? 'voted' : ''}`;
        button.dataset.action = 'vote-poll';
        button.dataset.id = poll.id;
        button.dataset.optionIndex = index;
        button.innerHTML = `<div class="poll-option-text">${option}</div><div class="poll-vote-count">${voteCount}</div>`;

        const progressBar = document.createElement('div');
        progressBar.className = 'poll-progress-bar';
        progressBar.innerHTML = `<div class="poll-progress-fill" style="width: ${percentage}%;"></div>`;
        
        const votersContainer = document.createElement('div');
        votersContainer.className = 'poll-voters-container';
        const votersUl = document.createElement('ul');
        votersUl.className = 'poll-voter-list';
        votersUl.innerHTML = voters.map(user => `<li class="poll-voter-name">${user}</li>`).join('');
        votersContainer.appendChild(votersUl);

        listItem.appendChild(button);
        listItem.appendChild(progressBar);
        listItem.appendChild(votersContainer);
        optionsList.appendChild(listItem);
    });

    pollBubble.appendChild(senderInfo);
    pollBubble.appendChild(questionEl);
    pollBubble.appendChild(optionsList);

    if (currentUserId === 'BoardingGate') {
        const moderationIcons = document.createElement('div');
        moderationIcons.className = 'poll-moderation-icons';
        
        const editIcon = document.createElement('img');
        editIcon.src = "https://boardinggate.github.io/Tesla/PNG/editmsg.png";
        editIcon.className = 'chat-action-icon';
        editIcon.title = "Editar pregunta";
        editIcon.dataset.action = "edit-poll";
        editIcon.dataset.id = poll.id;
        editIcon.dataset.question = poll.question;
        
        const deleteIcon = document.createElement('img');
        deleteIcon.src = "https://boardinggate.github.io/Tesla/PNG/erasemsg.png";
        deleteIcon.className = 'chat-action-icon';
        deleteIcon.title = "Eliminar encuesta";
        deleteIcon.dataset.action = "delete-poll";
        deleteIcon.dataset.id = poll.id;
        
        moderationIcons.appendChild(editIcon);
        moderationIcons.appendChild(deleteIcon);
        pollBubble.appendChild(moderationIcons);
    }
    
    return pollBubble;
}

// ===================================================================
// NOMBRE: showDeviationModal 
// RESUMEN: Muestra el modal de desv√≠o con el bot√≥n 'X' redimensionado y reposicionado.
function showDeviationModal() {
    if (isDeviationModalActive) return;
    closeOtherModals('deviation-modal');
    isDeviationModalActive = true;
    let modal = document.getElementById('deviation-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'deviation-modal';
        document.body.appendChild(modal);
    }

    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    const unvisitedSelectableStages = actualWaypoints.filter(wp => !wp.visited && wp.type !== 'S' && wp.type !== 'S_Recalc' && wp.type !== 'F');
    const iconHtml = `<img src="PNG/GPS.PNG" alt="Icono de Desv√≠o" style="width: 125px; height: 80px; margin: 0 auto 10px auto; display: block;">`;

    if (unvisitedSelectableStages.length === 0) {
        console.log("[MODAL DESV√çO] Ruta simple detectada. Mostrando modal informativo y comenzando rec√°lculo autom√°tico.");
        modal.innerHTML = `
            <h2>Desv√≠o Detectado</h2>
            
            <!-- BOT√ìN 'X' ELIMINADO -->
            
            ${iconHtml}
            <p id="deviation-modal-message">Recalculando nueva ruta...</p>
            <div id="deviation-status-spinner" style="border: 4px solid rgba(255, 255, 255, 0.2); border-left-color: #34c759; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 1rem auto 0;"></div>
            
            <button id="deviation-cancel-simple" class="btn-modal-action-secondary" style="margin-top: 0.9rem; width: 100%;">Cancelar</button>
            
            <style> @keyframes spin { 100% { transform: rotate(360deg); } } </style>
        `;
        modal.classList.remove('hidden');

        document.getElementById('deviation-cancel-simple').addEventListener('click', (e) => {
            e.stopPropagation();
            showToast("Rec√°lculo cancelado. Se reintentar√° si sigues fuera de ruta.", "info");
            closeModalAndProceed();
        });

        recalculateAndDrawRoute(wasSimulatingBeforeRecalc || isNavigating); 

    } else {
        const finalDestination = actualWaypoints[actualWaypoints.length - 1];
        const stageButtonsHtml = unvisitedSelectableStages.map(wp => {
            const addressSummary = wp.address ? (wp.address.split(',')[0].trim()) : `Etapa ${wp.label}`;
            return `<button class="btn-modal-action-primary deviation-stage-button" data-waypoint-id="${wp.id}">ETAPA ${wp.label}: ${addressSummary}</button>`;
        }).join('');

        modal.innerHTML = `
            <h2>Desv√≠o Detectado</h2>
            ${iconHtml}
            <p id="deviation-modal-message">Elige tu pr√≥ximo destino o se seleccionar√° el destino final autom√°ticamente.</p>
            <div class="deviation-options-container">
                <button id="deviation-go-to-final" class="btn-modal-action-primary" style="background-color: #34c759;">Ir a Destino Final (${finalDestination.address.split(',')[0].trim()}) <span class="button-countdown-timer unified-countdown-style"></span></button>
                <p id="scroll-hint-text"></p>
                <div class="stage-list-scroll-container">
                    ${stageButtonsHtml}
                </div>
                <button id="deviation-cancel" class="btn-modal-action-secondary">Cancelar (Seguir Desviado)</button>
            </div>
        `;
        modal.classList.remove('hidden');

        const goToFinalButton = document.getElementById('deviation-go-to-final');

        const clearDefaultActionTimer = () => {
            clearModalAutoCloseTimer(modal, goToFinalButton, 'deviation-modal-default-action');
        };

        goToFinalButton.addEventListener('click', (e) => {
            e.stopPropagation();
            clearDefaultActionTimer();
            handleFinalDestinationSelection();
        });

        document.querySelectorAll('.deviation-stage-button').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                clearDefaultActionTimer();
                const waypointId = parseInt(e.currentTarget.dataset.waypointId);
                handleStageSelectionFromDeviationModal(waypointId);
            });
        });

        document.getElementById('deviation-cancel').addEventListener('click', (e) => {
            e.stopPropagation();
            clearDefaultActionTimer();
            closeModalAndProceed();
        });
        
        addModalAutoCloseTimer(modal, goToFinalButton, 'deviation-modal-default-action', 10000);

        const scrollContainer = modal.querySelector('.stage-list-scroll-container');
        const scrollHint = modal.querySelector('#scroll-hint-text');
        requestAnimationFrame(() => {
            if (scrollContainer.scrollHeight > scrollContainer.clientHeight) {
                scrollHint.textContent = `(Deslice para ver las ${unvisitedSelectableStages.length} etapas restantes)`;
                scrollHint.style.display = 'block';
            }
        });
    }
}
    
// ===================================================================
// NOMBRE: cleanUpOldChatMessages 
// RESUMEN: Borra los mensajes (no encuestas) con m√°s de 120 horas (ejecutado por el admin).
async function cleanUpOldChatMessages() {
    if (!window.db) return;
    const oneHundredTwentyHoursAgo = new Date(Date.now() - 120 * 60 * 60 * 1000);
    const messagesRef = window.collection(window.db, 'chatMessages');
    const q = window.query(messagesRef, window.where('timestamp', '<=', oneHundredTwentyHoursAgo));

    try {
        const querySnapshot = await window.getDocs(q);
        if (querySnapshot.empty) {
            showToast("No hay mensajes antiguos que limpiar.", "info", 2000);
            return;
        }

        const batchPromises = [];
        const batchSize = 499;
        let currentBatch = window.writeBatch(window.db);
        let batchCount = 0;

        querySnapshot.forEach((doc, index) => {
            currentBatch.delete(doc.ref);
            batchCount++;
            if (batchCount === batchSize) {
                batchPromises.push(currentBatch.commit());
                currentBatch = window.writeBatch(window.db);
                batchCount = 0;
            }
        });
        
        if (batchCount > 0) {
            batchPromises.push(currentBatch.commit());
        }

        await Promise.all(batchPromises);
        showToast(`Limpieza completada: ${querySnapshot.size} mensajes eliminados.`, 'success');
        updateTotalMessageCount();

    } catch (error) {
        showToast('Error durante la limpieza de mensajes antiguos.', 'error');
    }
}    
    
// ===================================================================
// NOMBRE: createRouteLabelMarker 
// RESUMEN: Crea un icono de etiqueta personalizado para las rutas alternativas.
function createRouteLabelMarker(text, color) {
    const iconHtml = `<div class="route-label-marker" style="background-color: ${color};">${text}</div>`;
    const div = document.createElement('div');
    div.innerHTML = iconHtml;
    return div.firstChild; 
}
    
// ===================================================================
// NOMBRE: showAutoStartNavigationModal 
// RESUMEN: Muestra el modal de inicio de ruta con un dise√±o asim√©trico, visual e intuitivo.
function showAutoStartNavigationModal(route) {
    hideAutoStartNavigationModal();

    const header = document.getElementById('reminders-location-map-header');
    if (header) {
        header.querySelectorAll('.button-row').forEach(row => {
            row.classList.add('hidden-map-header');
        });
    }

    const progressBar = document.getElementById('navigation-bottom-progress-bar');
    if (progressBar) {
        progressBar.classList.add('progress-bar-partially-hidden');
    }

    const modal = document.createElement('div');
    modal.id = 'auto-start-nav-modal';
    
    let countdown = 25;
    
    modal.innerHTML = `
        <div id="start-nav-buttons-container">
            <button id="start-route-now-button" class="primary-action-btn" title="Iniciar Ruta">
                <div class="button-text-container">
                    <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path d="M 5 3 L 19 12 L 5 21 Z" />
                    </svg>
                    <span>Iniciar</span>
                    <span class="button-countdown-timer unified-countdown-style">${countdown}</span>
                </div>
            </button>
            <button id="start-and-add-reminder-button" class="secondary-action-btn" title="Crear recordatorio de 'Cargar' al llegar">
                <span class="icon">‚ö°Ô∏è</span>
                <span>Cargar al llegar</span>
            </button>
            <button id="midpoint-reminder-button" class="secondary-action-btn" title="Crear recordatorio a mitad de trayecto">
                <span class="icon">üîî</span>
                <span>Recordar algo a mitad de trayecto</span>
            </button>
            <button id="cancel-start-nav" class="secondary-action-btn">
                 <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M18 6L6 18M6 6L18 18" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span>Cancelar</span>
            </button>
        </div>
    `;

    document.body.appendChild(modal);

    const startButton = document.getElementById('start-route-now-button');
    const cancelButton = document.getElementById('cancel-start-nav');
    const startWithReminderButton = document.getElementById('start-and-add-reminder-button');
    const midpointReminderButton = document.getElementById('midpoint-reminder-button');

    const startNavAndClose = () => {
        hideAutoStartNavigationModal();
        if (!isNavigating) {
            toggleNavigationState(false, false);
        }
    };
    
    startButton.addEventListener('click', startNavAndClose);
    
    cancelButton.addEventListener('click', () => {
        if (navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
            updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], 0);
        }
        hideAutoStartNavigationModal();
        const header = document.getElementById('reminders-location-map-header');
        if (header) {
            header.querySelectorAll('.button-row').forEach(row => {
                row.classList.remove('hidden-map-header');
            });
        }
    });

    startWithReminderButton.addEventListener('click', () => {
        const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
        if (actualWaypoints.length < 2) {
            showToast("No hay un destino v√°lido para crear el recordatorio.", "error");
            return;
        }
        const finalDestination = actualWaypoints[actualWaypoints.length - 1];

        const now = new Date();
        const newReminder = {
            id: Date.now(),
            text: '<b>CARGAR EL VEHICULO</b>',
            type: 'simple',
            time: '00:01',
            date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
            createdAt: now.toISOString(),
            managedByUser: false,
            isLocationEnabled: true,
            locationCoordinates: { latitude: finalDestination.lat, longitude: finalDestination.lng },
            radiusMeters: DEFAULT_LOCATION_RADIUS,
            excludeFromList: false
        };

        try {
            let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
            reminders.push(newReminder);
            localStorage.setItem('reminders', JSON.stringify(reminders));
            
            markCacheAsDirty();
            updateReminderCount();
            updateButtonStyles();
      
        } catch (e) {
            showToast("Error al guardar el recordatorio de carga.", "error");
        }

        startNavAndClose();
    });
    
    midpointReminderButton.addEventListener('click', () => {
        const route = navigationCurrentRouteData?.routes?.[0];
        const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);

        if (!route || !route.duration || actualWaypoints.length < 2) {
            showToast("No se puede calcular el punto medio sin datos de ruta completos.", "error");
            return;
        }

        const finalDestination = actualWaypoints[actualWaypoints.length - 1];
        const destinationName = (finalDestination.address || 'Destino').split(',')[0].trim();
        const reminderText = `RECORDAR A MEDIO CAMINO DE LLEGAR A ${destinationName.toUpperCase()}...`;
        
        const totalDurationSeconds = route.duration;
        const halfwayTimeMilliseconds = (totalDurationSeconds / 2) * 1000;
        const reminderTime = new Date(Date.now() + halfwayTimeMilliseconds);

        const newDateISO = `${reminderTime.getFullYear()}-${(reminderTime.getMonth() + 1).toString().padStart(2, '0')}-${reminderTime.getDate().toString().padStart(2, '0')}`;
        const newTime = `${reminderTime.getHours().toString().padStart(2, '0')}:${reminderTime.getMinutes().toString().padStart(2, '0')}`;
        
        const reminderData = {
            text: reminderText,
            date: newDateISO,
            time: newTime,
            isLocationEnabled: false
        };
        
        hideAutoStartNavigationModal();
        showReminderModal(reminderData, { onTopOfMap: true });
    });

    if (route) {
        updateNavigationProgressDisplay(route, 0);
    }

    autoStartNavModalTimer = setInterval(() => {
        const isRouteStillValid = navigationCurrentRouteData && navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2;
        
        if (!isRouteStillValid) {
            hideAutoStartNavigationModal();
            return;
        }
        
        countdown--;
  
        const countdownSpan = document.querySelector('#auto-start-nav-modal .unified-countdown-style');
        
        if (countdown > 0) {
            if (countdownSpan) {
                countdownSpan.textContent = `${countdown}`;
            }
        } else {
            const btn = document.getElementById('start-route-now-button');
            if (btn) {
                startNavAndClose(); 
            }
        }
    }, 1000);
}
    
// ===================================================================
// NOMBRE: selectAlternativeRoute 
// RESUMEN: Limpia las alternativas INMEDIATAMENTE, luego recalcula la ruta seleccionada.
async function selectAlternativeRoute(waypointId, routeType) {
    clearAlternativeRoutesDisplay();

    if (!alternativeRoutesCache.has(waypointId)) {
        showToast("Error de cach√©: No se encontraron datos para la ruta seleccionada.", "error");
        return;
    }

    const routesData = alternativeRoutesCache.get(waypointId);
    const selectedRouteData = routesData[routeType];

    if (!selectedRouteData || !selectedRouteData.geometry || !selectedRouteData.geometry.coordinates) {
        showToast("Error: La ruta alternativa seleccionada no tiene geometr√≠a v√°lida.", "error");
        return;
    }

    selectedStageRoutes.set(waypointId, routeType);

    const endWaypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    if (endWaypointIndex < 1) return;

    let startWaypointIndex = -1;
    for (let i = endWaypointIndex - 1; i >= 0; i--) {
        if (navigationWaypoints[i] && !navigationWaypoints[i].isInternal) {
            startWaypointIndex = i;
            break;
        }
    }
    if (startWaypointIndex === -1) return;

    navigationWaypoints = navigationWaypoints.filter(wp => !(wp.isInternal && wp.parentWaypointId === waypointId));
    
    const geometryPoints = selectedRouteData.geometry.coordinates;
    const totalPoints = geometryPoints.length;
    const maxInternalPoints = 10;
    const step = totalPoints > maxInternalPoints + 2 ? Math.floor((totalPoints - 2) / maxInternalPoints) : 1;
    
    const internalWaypoints = [];
    for (let i = step; i < totalPoints - 1; i += step) {
         const coord = geometryPoints[i];
         internalWaypoints.push({
            id: Date.now() + Math.random() + i,
            lat: coord[1],
            lng: coord[0],
            type: 'internal',
            label: '',
            address: 'Punto de paso interno',
            isInternal: true,
            parentWaypointId: waypointId,
            visited: false,
            isCriticalForRecalc: true
        });
    }

    const newEndIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    navigationWaypoints.splice(newEndIndex, 0, ...internalWaypoints);
    
    await recalculateAndDrawRoute(true);
    
    const routeTypeTranslations = {
        'fastest': 'R√ÅPIDA',
        'shortest': 'CORTA',
        'alternative': 'ALTERNATIVA'
    };
    const translatedType = routeTypeTranslations[routeType] || routeType.toUpperCase();
    showToast(`Ruta para esta etapa cambiada a: ${translatedType}.`, "success");
}
    
// ===================================================================
// NOMBRE: drawAlternativeRoutes 
// RESUMEN: Dibuja en el mapa las polil√≠neas y etiquetas de las rutas alternativas.
function drawAlternativeRoutes(waypointId, routesData) {
    clearAlternativeRoutesDisplay(); 
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) return;

    const routeConfigs = [
        { type: 'fastest', data: routesData.fastest, color: '#0066FF', label: 'RAP' }, 
        { type: 'shortest', data: routesData.shortest, color: '#BA6BFF', label: 'COR' }, 
        { type: 'alternative', data: routesData.alternative, color: '#FF5900', label: 'ALT' } 
    ];

    routeConfigs.forEach((config, index) => {
        if (config.data && config.data.geometry) {
            const sourceId = `alt-route-${waypointId}-${config.type}`;
            const layerId = `alt-layer-${waypointId}-${config.type}`;
            const labelMarkerId = `alt-label-${waypointId}-${config.type}`;

            navigationMapInstance.addSource(sourceId, {
                type: 'geojson',
                data: config.data.geometry
            });
            navigationMapInstance.addLayer({
                id: layerId,
                type: 'line',
                source: sourceId,
                minzoom: 1.5, maxzoom: 19,
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                paint: {
                    'line-color': config.color,
                    'line-width': (navigationMapInstance && navigationMapInstance.getPitch() > 20) ? 12 : 8,
                    'line-opacity': 0.8
                }
            });

            const midPoint = turf.along(config.data.geometry, turf.length(config.data.geometry) / 2).geometry.coordinates;
            const labelElement = createRouteLabelMarker(config.label, config.color);
            const labelMarker = new mapboxgl.Marker({ element: labelElement })
                .setLngLat(midPoint)
                .addTo(navigationMapInstance);
            
            labelMarker.getElement().addEventListener('click', (e) => {
                e.stopPropagation(); 
                selectAlternativeRoute(waypointId, config.type);
            });

            alternativeRouteLayers.push({ sourceId, layerId, labelMarker });
        }
    });
}

// ===================================================================
// NOMBRE: clearAlternativeRoutesDisplay 
// RESUMEN: Inicia el proceso de limpieza de rutas alternativas, delegando
function clearAlternativeRoutesDisplay() {
    if (!navigationMapInstance) {
        alternativeRouteLayers = [];
        return;
    }

    const itemsToClear = [...alternativeRouteLayers];
    alternativeRouteLayers = [];

    attemptClear(itemsToClear, 1);
}

// ===================================================================
// NOMBRE: attemptClear
// RESUMEN: Intenta limpiar los elementos de la ruta. Si alguno falla,
function attemptClear(itemsToClear, attemptNumber) {
    const MAX_ATTEMPTS = 5;
    const RETRY_DELAY_MS = 150; 

    if (attemptNumber > MAX_ATTEMPTS || itemsToClear.length === 0) {
        if (itemsToClear.length > 0) {
            console.error(`Fallo definitivo al limpiar ${itemsToClear.length} elementos de ruta alternativa tras ${MAX_ATTEMPTS} intentos.`);
        }
        return; // Detenemos la recursi√≥n
    }

    const failedItems = [];

    if (attemptNumber === 1) {
        document.querySelectorAll('.route-label-marker').forEach(el => el.remove());
    }

    itemsToClear.forEach(item => {
        let success = true;
        try {
            if (navigationMapInstance.getLayer(item.layerId)) {
                navigationMapInstance.removeLayer(item.layerId);
            }
            if (navigationMapInstance.getSource(item.sourceId)) {
                navigationMapInstance.removeSource(item.sourceId);
            }
            if (item.labelMarker && typeof item.labelMarker.remove === 'function') {
                item.labelMarker.remove();
            }
        } catch (e) {
            success = false;
            failedItems.push(item); // Si falla, lo a√±adimos a la lista de reintento
        }
    });

    if (failedItems.length > 0) {
        setTimeout(() => {
            attemptClear(failedItems, attemptNumber + 1);
        }, RETRY_DELAY_MS);
    }
}
    
// ===================================================================
// NOMBRE: fetchAndDisplayAlternativeRoutes 
// RESUMEN: Obtiene y muestra las rutas alternativas para una etapa espec√≠fica.
async function fetchAndDisplayAlternativeRoutes(waypointId) {
    if (alternativeRoutesCache.has(waypointId)) {
        drawAlternativeRoutes(waypointId, alternativeRoutesCache.get(waypointId));
        return;
    }

    const endWaypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    if (endWaypointIndex < 1) return;

    let startWaypoint = null;
    for (let i = endWaypointIndex - 1; i >= 0; i--) {
        if (navigationWaypoints[i] && !navigationWaypoints[i].isInternal) {
            startWaypoint = navigationWaypoints[i];
            break;
        }
    }
    
    if (!startWaypoint) return;
    const endWaypoint = navigationWaypoints[endWaypointIndex];

    const url = `${OSRM_SERVICE_URL}/driving/${startWaypoint.lng},${startWaypoint.lat};${endWaypoint.lng},${endWaypoint.lat}?alternatives=true&overview=full&geometries=geojson&steps=false`;

    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Respuesta de red no fue OK');
        const data = await response.json();

        if (!data.routes || data.routes.length < 1) {
             showToast("NO HAY RUTAS ALTERNATIVAS", "info");
            return;
        }

        const fastestRoute = data.routes[0];
        const shortestRoute = [...data.routes].sort((a, b) => a.distance - b.distance)[0];
        const alternativeRoute = data.routes.find(r => r !== fastestRoute && r !== shortestRoute) || null;
        
        if (fastestRoute === shortestRoute && !alternativeRoute) {
            showToast("NO HAY RUTAS ALTERNATIVAS", "info");
            return;
        }

        const routesData = {
            fastest: fastestRoute,
            shortest: fastestRoute === shortestRoute ? null : shortestRoute,
            alternative: alternativeRoute
        };

        alternativeRoutesCache.set(waypointId, routesData);
        drawAlternativeRoutes(waypointId, routesData);

    } catch (error) {
        showToast("Error al obtener rutas alternativas", "error");
    }
}
   
// ===================================================================
// NOMBRE: cancelAutoStartNav 
// RESUMEN: Cancela la navegaci√≥n autom√°tica iniciada al cargar una ruta.
function cancelAutoStartNav(toastId) {
    if (autoStartNavTimer) {
        clearInterval(autoStartNavTimer);
        autoStartNavTimer = null;
    }
    const toastElement = document.getElementById(toastId);
    if (toastElement) {
        toastElement.remove();
        activeToasts = activeToasts.filter(t => t.id !== toastId);
    }
    }
window.cancelAutoStartNav = cancelAutoStartNav;

// ===================================================================
// NOMBRE: showChargingPointModal 
// RESUMEN: Crea y muestra un modal detallado para un punto de recarga OCM.
function showChargingPointModal(point, index) {
    const existingModal = document.querySelector('.ocm-modal-overlay');
    if (existingModal) existingModal.remove();

    const overlay = document.createElement('div');
    overlay.className = 'ocm-modal-overlay';

    const photoUrl = (point.MediaItems && point.MediaItems.length > 0 && point.MediaItems[0].ItemURL) 
        ? point.MediaItems[0].ItemURL 
        : 'https://boardinggate.github.io/Tesla/PNG/PDREJEMPLO.PNG';
    
    const addressInfo = point.AddressInfo || {};
    const stationName = addressInfo.Title || 'Punto de Recarga';
    
    let addressParts = [];
    if (addressInfo.AddressLine1) addressParts.push(addressInfo.AddressLine1);
    
    const locationName = addressInfo.Town || addressInfo.StateOrProvince;
    if (addressInfo.Postcode && locationName) {
        addressParts.push(`${addressInfo.Postcode} - ${locationName}`);
    } else if (addressInfo.Postcode) {
        addressParts.push(addressInfo.Postcode);
    } else if (locationName) {
        addressParts.push(locationName);
    }
    const addressHtml = addressParts.join('<br>');

    const operatorInfo = point.OperatorInfo || {};

    let detailsHtml = '<h4>Detalles de Ubicaci√≥n</h4>';
    detailsHtml += `<p><strong>Direcci√≥n Completa:</strong> ${addressInfo.Title}</p>`;
    detailsHtml += `<p><strong>Lat/Lon:</strong> ${addressInfo.Latitude.toFixed(5)}, ${addressInfo.Longitude.toFixed(5)}</p>`;
    
    const lat = addressInfo.Latitude;
    const lon = addressInfo.Longitude;
    const zoom = 17;

    const googleUrl = `https://www.google.com/maps/search/electric+vehicle+charging+stations/@${lat},${lon},${zoom}z`;
    const electroverseUrl = `https://electroverse.com/map?search=${lat}%2C${lon}`;
    const electromapsUrl = `https://map.electromaps.com/es/p/${lat},${lon}`;
    const reveUrl = "https://www.mapareve.es/mapa-puntos-recarga";

    detailsHtml += `
        <div class="ocm-external-links-container">
            <div class="ocm-external-links-left-group">
                <span class="ocm-external-links-label">Abrir en...</span>
                <p class="ocm-external-links-note">
                    <span style="font-size: 0.6rem;">(*) Para volver retroceda en el browser</span>
                </p>
            </div>
            <div class="ocm-external-links-buttons">
                <a href="${googleUrl}" target="_blank" rel="noopener noreferrer" class="ocm-external-link-btn" title="Abrir en Google Maps" onclick="event.stopPropagation();">
                    <img src="https://www.google.com/s2/favicons?domain=maps.google.com&sz=64" alt="Google Maps">
                </a>
                <a href="${reveUrl}" target="_blank" rel="noopener noreferrer" class="ocm-external-link-btn" title="Abrir en REVE (no admite localizaci√≥n)" onclick="event.stopPropagation();">
                    <img src="https://www.google.com/s2/favicons?domain=mapareve.es&sz=64" alt="REVE">
                </a>
                <a href="${electroverseUrl}" target="_blank" rel="noopener noreferrer" class="ocm-external-link-btn" title="Abrir en Electroverse" onclick="event.stopPropagation();">
                    <img src="https://www.google.com/s2/favicons?domain=electroverse.com&sz=64" alt="Electroverse">
                </a>
                <a href="${electromapsUrl}" target="_blank" rel="noopener noreferrer" class="ocm-external-link-btn" title="Abrir en Electromaps" onclick="event.stopPropagation();">
                    <img src="https://www.google.com/s2/favicons?domain=electromaps.com&sz=64" alt="Electromaps">
                </a>
                <button class="ocm-external-link-btn" title="Enviar a la app de Tesla" onclick="handleSendToTeslaClick(${lat}, ${lon}, '${stationName.replace(/'/g, "\\'")}'); event.stopPropagation();">
                    <img src="https://boardinggate.github.io/Tesla/PNG/th.jpeg" alt="Enviar a Tesla">
                </button>
            </div>
        </div>
    `;

    detailsHtml += '<h4>Equipamiento / Tarifa</h4>';
    if (point.Connections && point.Connections.length > 0) {
        point.Connections.forEach(conn => {
            const connType = conn.ConnectionType ? conn.ConnectionType.Title.replace(' (Socket)', '').replace(' (Connector)', '') : 'Desconocido';
            const power = conn.PowerKW ? `${conn.PowerKW.toFixed(0)} kW` : '';
            const status = conn.StatusType ? `(${translateOcmTerm(conn.StatusType.Title)})` : '';
            detailsHtml += `
                <div class="ocm-connection-item">
                    <span class="ocm-connection-type">‚Ä¢ ${connType}</span>
                    <span class="ocm-connection-power-status">${power} ${status}</span>
                </div>`;
        });
    } else {
        detailsHtml += '<p>No hay informaci√≥n de conectores.</p>';
    }
    if (point.UsageCost) detailsHtml += `<p class="ocm-price-info"><strong>${point.UsageCost}</strong></p>`;

    detailsHtml += '<h4>Restricciones de Uso</h4>';
    detailsHtml += `<p><strong>Estado:</strong> ${translateOcmTerm(point.StatusType?.Title)}</p>`;
    detailsHtml += `<p><strong>Uso:</strong> ${translateOcmTerm(point.UsageType?.Title)}</p>`;

    detailsHtml += '<h4>Operador/Red</h4>';
    detailsHtml += `<p><strong>Nombre:</strong> ${operatorInfo.Title || 'No especificado'}</p>`;
    if (operatorInfo.WebsiteURL) detailsHtml += `<p><strong>Web:</strong> <a href="${operatorInfo.WebsiteURL}" target="_blank" rel="noopener noreferrer">${operatorInfo.WebsiteURL}</a></p>`;
    if (operatorInfo.PhonePrimaryContact) detailsHtml += `<p><strong>Tel√©fono:</strong> <a href="tel:${operatorInfo.PhonePrimaryContact}">${operatorInfo.PhonePrimaryContact}</a></p>`;

    let photosHtml = '<div class="ocm-photo-grid">';
    if (point.MediaItems && point.MediaItems.length > 0) {
        point.MediaItems.forEach(item => {
            if (item.ItemURL) {
                 photosHtml += `<img src="${item.ItemURL}" alt="${item.Comment || 'Foto del punto de recarga'}" data-full-url="${item.ItemURL}">`;
            }
        });
    } else {
        photosHtml += '<p>No hay fotograf√≠as disponibles para este punto.</p>';
    }
    photosHtml += '</div>';

    let commentsHtml = '<ul class="ocm-comment-list">';
    if (point.UserComments && point.UserComments.length > 0) {
        point.UserComments.forEach(comment => {
            commentsHtml += `
                <li class="ocm-comment">
                    <div class="ocm-comment-header">
                        <span class="user">${comment.UserName || 'An√≥nimo'}</span>
                        <span class="date">${comment.DateCreated ? formatDateToDDMMMYY(comment.DateCreated.split('T')[0]) : ''}</span>
                    </div>
                    <p class="comment-text">${comment.Comment}</p>
                </li>`;
        });
    } else {
        commentsHtml += '<p>No hay comentarios para este punto.</p>';
    }
    commentsHtml += '</ul>';

    overlay.innerHTML = `
        <div class="ocm-modal-content">
            <div class="ocm-modal-header" style="background-image: url('${photoUrl}')">
                <div class="ocm-modal-station-name-wrapper">
                    <span class="ocm-modal-station-name">${stationName}</span>
                </div>
                <div class="ocm-modal-address">${addressHtml}</div>
            </div>
            <div class="ocm-modal-tabs">
                <div class="ocm-modal-tab active" data-panel="details">DETALLES</div>
                <div class="ocm-modal-tab" data-panel="photos">FOTOS (${point.MediaItems?.length || 0})</div>
                <div class="ocm-modal-tab" data-panel="comments">COMENTARIOS (${point.UserComments?.length || 0})</div>
            </div>
            <div class="ocm-modal-body">
                <div id="ocm-panel-details" class="ocm-modal-panel active">${detailsHtml}</div>
                <div id="ocm-panel-photos" class="ocm-modal-panel">${photosHtml}</div>
                <div id="ocm-panel-comments" class="ocm-modal-panel">${commentsHtml}</div>
            </div>
            <div class="ocm-modal-footer">
                <button id="ocm-add-route-btn" data-index="${index}">A√±adir a la Ruta</button>
                <button id="ocm-close-btn">Salir</button>
            </div>
        </div>
    `;

    const mapModalContainer = document.getElementById('reminders-location-map-modal');
    if (mapModalContainer) {
        mapModalContainer.appendChild(overlay);
    } else {
        document.body.appendChild(overlay);
    }

    const closeBtn = overlay.querySelector('#ocm-close-btn');
    let modalTimer = null;

    const closeHandler = () => {
        if (modalTimer) clearInterval(modalTimer);
        if (overlay.parentNode) {
            overlay.remove();
        }
    };
    closeBtn.addEventListener('click', closeHandler);
    
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            closeHandler();
        }
    });
    
    overlay.querySelector('#ocm-add-route-btn').addEventListener('click', (e) => {
        const pointIndex = parseInt(e.target.dataset.index);
        addChargingPointToRoute(pointIndex);
        closeHandler();
    });

    overlay.querySelectorAll('.ocm-modal-tab').forEach(tab => {
        tab.addEventListener('click', () => {
            overlay.querySelectorAll('.ocm-modal-tab').forEach(t => t.classList.remove('active'));
            overlay.querySelectorAll('.ocm-modal-panel').forEach(p => p.classList.remove('active'));
            tab.classList.add('active');
            overlay.querySelector(`#ocm-panel-${tab.dataset.panel}`).classList.add('active');
        });
    });

    overlay.querySelectorAll('.ocm-photo-grid img').forEach(img => {
        img.addEventListener('click', () => {
            showPhotoModal(img.dataset.fullUrl);
        });
    });

    let countdown = 70;
    
    const countdownSpan = document.createElement('span');
    countdownSpan.className = 'button-countdown-timer unified-countdown-style';
    countdownSpan.textContent = ` ${countdown}`;
    closeBtn.appendChild(countdownSpan);

    modalTimer = setInterval(() => {
        countdown--;
        countdownSpan.textContent = ` ${countdown}`;
        if (countdown <= 0) {
            closeHandler();
        }
    }, 1000);
}

// ===================================================================
// NOMBRE: showShareSt
// RESUMEN: Muestra un modal para que el usuario seleccione qu√© etapa de una ruta compartir.
function showShareStageModal(routeObject) {
    if (!routeObject || !routeObject.waypoints || routeObject.waypoints.length === 0) {
        showToast("No hay etapas para compartir en esta ruta.", "error");
        return;
    }

    const existingOverlay = document.getElementById('share-stage-modal-overlay');
    if (existingOverlay) existingOverlay.remove();

    const overlay = document.createElement('div');
    overlay.id = 'share-stage-modal-overlay';
    overlay.className = 'route-modal-overlay';

    const modalContent = document.createElement('div');
    modalContent.id = 'share-stage-modal';
    modalContent.className = 'route-modal-container';

    modalContent.innerHTML = `
        <div class="route-modal-header" style="background-image: url('https://boardinggate.github.io/Tesla/PNG/modalrutas.png');">
            <div class="route-modal-title-card">
                <span class="route-modal-title">Compartir Etapa de Ruta</span>
            </div>
        </div>
        <div class="route-modal-body">
            <p style="margin-bottom: 15px; font-weight: 500; color: #333;">Selecciona una etapa para compartir sus coordenadas:</p>
            <div class="route-scroll-container">
                <ul id="share-stage-list" class="route-list"></ul>
            </div>
        </div>
        <div class="route-modal-footer">
            <button id="cancel-share-stage" class="btn-modal-action-secondary">Cancelar</button>
        </div>
    `;

    overlay.appendChild(modalContent);
    document.body.appendChild(overlay);

    const listElement = modalContent.querySelector('#share-stage-list');
    const cancelButton = modalContent.querySelector('#cancel-share-stage');

    const closeShareModal = () => {
        clearModalAutoCloseTimer(overlay, cancelButton, 'share-stage-modal');
        if (overlay.parentNode) overlay.remove();
    };

    routeObject.waypoints.forEach((waypoint, index) => {
        const li = document.createElement('li');
        li.className = 'route-list-item';
        li.style.cursor = 'pointer';

        const stageLabel = waypoint.type === 'S' ? 'Salida' : (waypoint.type === 'F' ? 'Destino' : `Etapa ${waypoint.label}`);
        const addressText = waypoint.address || `(${waypoint.lat.toFixed(4)}, ${waypoint.lng.toFixed(4)})`;

        li.innerHTML = `<span class="route-name" style="color: #105a52;"><strong>${stageLabel}:</strong> ${addressText}</span>`;
        
        li.addEventListener('click', () => {
            handleSendToTeslaClick(waypoint.lat, waypoint.lng, addressText);
            closeShareModal();
        });
        
        listElement.appendChild(li);
    });

    cancelButton.addEventListener('click', closeShareModal);
    addModalAutoCloseTimer(overlay, cancelButton, 'share-stage-modal', 25000);
}

// ===================================================================
// NOMBRE: getChargingPointColorByPower
// RESUMEN: Devuelve un color hexadecimal basado en el rango de potencia del PDR.
function getChargingPointColorByPower(power) {
    if (isNaN(power)) {
        return '#5e5e5e'; }
    if (power >= 0 && power <= 50) {
        return '#0f130c'; 
    } else if (power > 50 && power <= 100) {
        return '#007863'; 
    } else if (power > 100 && power <= 250) {
        return 'rgb(30, 144, 255)'; 
    } else if (power > 250 && power <= 2000) {
        return '#de2e03'; 
    }
    return '#5e5e5e'; 
}  

// ===================================================================
// NOMBRE: showPhotoModal
// RESUMEN: Muestra una imagen en un modal superpuesto.
function showPhotoModal(imageUrl) {
    const existingModal = document.querySelector('.ocm-photo-modal-overlay');
    if (existingModal) existingModal.remove();

    const overlay = document.createElement('div');
    overlay.className = 'ocm-photo-modal-overlay';
    
    overlay.innerHTML = `
        <div class="ocm-photo-modal-content">
            <img src="${imageUrl}" alt="Vista ampliada del punto de recarga">
            <div class="ocm-photo-modal-close-btn" title="Cerrar imagen">√ó</div>
        </div>
    `;

    document.body.appendChild(overlay);

    const close = () => {
        if (overlay.parentNode) {
            overlay.remove();
        }
    };
    overlay.querySelector('.ocm-photo-modal-close-btn').addEventListener('click', close);
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            close();
        }
    });
}

// ===================================================================
// NOMBRE: startFreeDrive 
// RESUMEN: Inicia el modo de conducci√≥n libre, limpiando marcadores de velocidad anteriores.
function startFreeDrive(initialCoords) {
    if (isFreeDriveActive || isNavigating) return;

    isFreeDriveActive = true;
    isFreeDrivePaused = false;
    gpsTickCounter = 0; 
    
    navigationStartTimeForStats = new Date(); // Hora de inicio actual
    freeDriveStats = {
        startTime: navigationStartTimeForStats, // Usamos la misma hora para consistencia
        totalDistance: 0,
        lastPosition: { ...initialCoords },
    };
    totalDistanceTravelledForStats = 0;
    maxSpeedDuringTrip = 0;
    speedMarkerFeatures = []; 
    maxSpeedCoordinates = null;
    maxAltitudeDuringTrip = -Infinity;
    minAltitudeDuringTrip = Infinity;
    lastKnownAverageAltitude = null; 
    window.averageSpeedKmh = 0;
    lastPositionForStats = { ...initialCoords };
    
    showToast("Viaje en modo libre iniciado", "success");

    navigationFollowUser = true;
    shouldCenterOnUser = true;
    const locateMeButton = document.getElementById('locate-me-on-reminders-map');
    const locateMeImg = locateMeButton ? locateMeButton.querySelector('img') : null;
    if (locateMeButton && locateMeImg) {
        locateMeImg.src = "PNG/DEJARSEGUIR.PNG";
        locateMeButton.title = "Dejar de centrar el mapa en mi posici√≥n";
    }
    toggleMapHeaderRowsVisibility(false);
    showMapInfoOverlay("Modo FREE DRIVE sin destino conocido");

    startMemoryManagement(true); 
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviaci√≥n ETA'; 
    initializeNavigationGraph();
    updateNavigationProgressDisplay();
}
    
// ===================================================================
// NOMBRE: stopFreeDrive
// RESUMEN: Detiene el modo de conducci√≥n libre y muestra el modal de estad√≠sticas.
function stopFreeDrive() {
    if (!isFreeDriveActive) return;
    clearRecoveryFlag();
    const statsToSend = { ...freeDriveStats };
    showArrivalStatsModal(statsToSend);

    autoStartFreeDriveDisabledUntil = Date.now() + 30000; // 30 segundos de gracia

    isFreeDriveActive = false;
    isFreeDrivePaused = false;
    freeDriveStats = null;
    tripStartLocationForStats = null;
    startMemoryManagement(false); 
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    clearNavigationGraph();
    showMapInfoOverlay("Modo FREE DRIVE fin de viaje");
}   
    
// ===================================================================
// NOMBRE: drawStaticMarkersOnProgressBar 
// RESUMEN: Dibuja los elementos est√°ticos (etapas, radares, tareas) en la barra de progreso.
function drawStaticMarkersOnProgressBar() {
    const overallProgressContainer = document.getElementById('route-overall-progress-container');
    if (!overallProgressContainer || !navigationCurrentRouteData?.routes?.[0]) {
        return;
    }

    const route = navigationCurrentRouteData.routes[0];
    const totalJourneyDistanceForBar = (accumulatedDistanceBeforeCurrentSegment || 0) + route.distance;

    overallProgressContainer.querySelectorAll('.waypoint-dot-on-progress-bar, .radar-marker-on-progress-bar, .task-marker-on-progress-bar').forEach(dot => dot.remove());
    
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    if (actualWaypoints.length > 2 && totalJourneyDistanceForBar > 0 && typeof turf !== 'undefined' && navigationMapInstance.getSource('route') && navigationMapInstance.getSource('route')._data) {
        const routeGeoJSON = navigationMapInstance.getSource('route')._data;
        const routeLineString = turf.lineString(routeGeoJSON.geometry.coordinates);
        const startOfRoute = turf.point(routeLineString.geometry.coordinates[0]);

        for (let i = 1; i < actualWaypoints.length - 1; i++) {
            const waypoint = actualWaypoints[i];
            const waypointPoint = turf.point([waypoint.lng, waypoint.lat]);
            const nearestPointOnLine = turf.nearestPointOnLine(routeLineString, waypointPoint, { units: 'meters' });
            const lineSliceToWaypoint = turf.lineSlice(startOfRoute, nearestPointOnLine, routeLineString);
            const distanceToWaypoint = turf.length(lineSliceToWaypoint, { units: 'meters' });
            const totalDistanceWithAccumulated = (accumulatedDistanceBeforeCurrentSegment || 0) + distanceToWaypoint;
            const percent = (totalDistanceWithAccumulated / totalJourneyDistanceForBar) * 100;
            if (percent < 100 && percent > 0) {
                const dot = document.createElement('div');
                dot.className = 'waypoint-dot-on-progress-bar';
                dot.style.left = `calc(${percent}% - 7px)`;
                dot.title = `Etapa ${waypoint.label}`;
                overallProgressContainer.appendChild(dot);
            }
        }
    }

    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresRutaCheckbox && radaresRutaCheckbox.checked && radaresEnRutaActual.length > 0 && totalJourneyDistanceForBar > 0) {
        radaresEnRutaActual.forEach(radar => {
            if (radar.distanceOnRoute !== undefined) {
                const totalDistanceToRadar = (accumulatedDistanceBeforeCurrentSegment || 0) + radar.distanceOnRoute;
                if(totalDistanceToRadar <= totalJourneyDistanceForBar) {
                    const percent = (totalDistanceToRadar / totalJourneyDistanceForBar) * 100;
                    if (percent >= 0 && percent <= 100) {
                        const radarMarker = document.createElement('div');
                        radarMarker.className = 'radar-marker-on-progress-bar';
                        radarMarker.style.left = `${percent}%`;
                        radarMarker.title = radar.text.replace(/<b>|<\/b>/gi, '');
                        overallProgressContainer.appendChild(radarMarker);
                    }
                }
            }
        });
    }

    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasRutaCheckbox && tareasRutaCheckbox.checked && tareasEnRutaActual.length > 0 && totalJourneyDistanceForBar > 0) {
        tareasEnRutaActual.forEach(tarea => {
            if (tarea.distanceOnRoute !== undefined) {
                const totalDistanceToTask = (accumulatedDistanceBeforeCurrentSegment || 0) + tarea.distanceOnRoute;
                if(totalDistanceToTask <= totalJourneyDistanceForBar) {
                    const percent = (totalDistanceToTask / totalJourneyDistanceForBar) * 100;
                    if (percent >= 0 && percent <= 100) {
                        const taskMarker = document.createElement('div');
                        taskMarker.className = 'task-marker-on-progress-bar';
                        taskMarker.style.left = `${percent}%`;
                        taskMarker.title = tarea.text.replace(/<b>|<\/b>/gi, '');
                        overallProgressContainer.appendChild(taskMarker);
                    }
                }
            }
        });
    }
}

// ===================================================================
// NOMBRE: toggleRouteDetailOverlays
// RESUMEN: Muestra u oculta los paneles de progreso y br√∫jula/estad√≠sticas.
function toggleRouteDetailOverlays(show) {
    const progressBar = document.getElementById('navigation-bottom-progress-bar');
    const compassControl = document.querySelector('.map-control-custom-map-controls');

    if (progressBar) {
        progressBar.classList.toggle('hidden-by-zoom', !show);
    }
    if (compassControl) {
        compassControl.classList.toggle('hidden-by-zoom', !show);
    }
}
    
// ===================================================================
// NOMBRE: performMassUpdate 
// RESUMEN: Actualiza la configuraci√≥n de rendimiento Y de vista de c√°mara para todos
async function performMassUpdate() {
    if (localStorage.getItem('userData_userId') !== 'BoardingGate') {
        showToast("Acci√≥n no permitida.", "error");
        return;
    }

    const confirmation = confirm(
        "¬°ACCI√ìN IRREVERSIBLE!\n\n" +
        "Est√°s a punto de sobreescribir la configuraci√≥n visual, de rendimiento y de c√°mara de TODOS los usuarios con tus valores actuales.\n\n" +
        "Esto NO afectar√° a sus rutas, recordatorios o dise√±o del grid. ¬øEst√°s completamente seguro de que quieres continuar?"
    );

    if (!confirmation) {
        showToast("Actualizaci√≥n masiva cancelada.", "info");
        return;
    }

    const updateButton = document.getElementById('mass-update-btn');
    if (updateButton) updateButton.disabled = true;

    showToast("Iniciando actualizaci√≥n masiva...", "info", 0, false, "mass-update-toast");

    try {
        const keysToUpdate = [
            'boardinggate_map_saturation', 'boardinggate_map_contrast', MAP_TERRAIN_EXAGGERATION_KEY,
            
            LERP_RATE_POS_KEY, LERP_RATE_ROT_KEY, LERP_RATE_ZOOM_KEY,
            
            PERFORMANCE_CAMERA_FPS_KEY,
            PERFORMANCE_RATIO_CRITICAL_KEY, PERFORMANCE_RATIO_ROUTE_KEY, PERFORMANCE_RATIO_ALERTS_KEY,
            PERFORMANCE_RATIO_STATS_KEY, PERFORMANCE_RATIO_GRAPH_KEY, 'boardinggate_memory_threshold',
            
            'boardinggate_announce_maneuver_flash', 'boardinggate_dynamicRadarRadius',

            MAP_VIEW_PITCH_KEY,       // Inclinaci√≥n (Pitch)
            MAP_VIEW_MODE_KEY,        // Modo de vista (3D, Norte, etc.)
            ACTIVE_MAP_LAYER_KEY,     // Tipo de mapa (H√≠brido, Sat√©lite, etc.)
            MAP_VIEW_OFFSET_X_KEY,    // Descentrado X del coche
            MAP_VIEW_OFFSET_Y_KEY,    // Descentrado Y del coche
            MAP_VIEW_SHOW_MINIMAP_KEY // Mostrar/ocultar minimapa de intersecci√≥n
        ];

        const adminSettings = {};
        keysToUpdate.forEach(key => {
            const value = localStorage.getItem(key);
            if (value !== null) {
                adminSettings[key] = value;
            }
        });

        showToast("Obteniendo lista de usuarios...", "info", 0, false, "mass-update-toast");
        const usersCollectionRef = window.collection(window.db, "user_data");
        const querySnapshot = await window.getDocs(usersCollectionRef);
        const userDocs = querySnapshot.docs;
        const totalUsers = userDocs.length;

        const BATCH_OPERATIONS_LIMIT = 499;
        const BATCH_SIZE_LIMIT_BYTES = 8 * 1024 * 1024; // 8 MB
        const DELAY_BETWEEN_BATCHES_MS = 500;

        let batch = window.writeBatch(window.db);
        let operationCount = 0;
        let batchSizeBytes = 0;
        let usersProcessed = 0;
        const newTimestamp = new Date().toISOString();
        
        for (const doc of userDocs) {
            if (doc.id === 'BoardingGate') continue;

            let cacheData = {};
            try {
                cacheData = JSON.parse(doc.data().contenidoCacheCompleto || '{}');
            } catch (e) {
                console.warn(`Cache corrupta para el usuario ${doc.id}, se omitir√°.`);
                continue;
            }

            const updatedCache = { ...cacheData, ...adminSettings };
            updatedCache['lastCacheUpdateTimestamp'] = Date.now().toString();

            const updatePayload = {
                contenidoCacheCompleto: JSON.stringify(updatedCache),
                fechaBackup: newTimestamp
            };
            
            const payloadSize = JSON.stringify(updatePayload).length * 2;
            batchSizeBytes += payloadSize;

            batch.update(doc.ref, updatePayload);
            operationCount++;
            usersProcessed++;

            if (operationCount >= BATCH_OPERATIONS_LIMIT || batchSizeBytes >= BATCH_SIZE_LIMIT_BYTES) {
                showToast(`Enviando lote... (${usersProcessed}/${totalUsers})`, "info", 0, false, "mass-update-toast");
                
                await batch.commit();
                await wait(DELAY_BETWEEN_BATCHES_MS);
                
                batch = window.writeBatch(window.db);
                operationCount = 0;
                batchSizeBytes = 0;
            }
        }

        if (operationCount > 0) {
            showToast(`Enviando lote final... (${usersProcessed}/${totalUsers})`, "info", 0, false, "mass-update-toast");
            await batch.commit();
        }

        showToast(`¬°√âxito! Se actualizaron ${usersProcessed} usuarios.`, "success", 5000);

    } catch (error) {
        console.error("Error en la actualizaci√≥n masiva:", error);
        showToast(`Error: ${error.message}`, "error", 10000);
    } finally {
        if (updateButton) updateButton.disabled = false;
        const existingToast = document.getElementById("mass-update-toast");
        if(existingToast) existingToast.remove();
    }
}    
    
// ===================================================================
// NOMBRE: getAddressForWaypoint 
// RESUMEN: Obtiene la direcci√≥n o solo la calle de un punto de ruta.
async function getAddressForWaypoint(lat, lng, streetOnly = false) {
    if (typeof lat !== 'number' || typeof lng !== 'number' || isNaN(lat) || isNaN(lng)) {
        return "Ubicaci√≥n Desconocida";
    }
    try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=1&accept-language=es`);
        if (response.ok) {
            const data = await response.json();
            if (streetOnly) {
                return data.address?.road || "Calle desconocida";
            }
            return data.display_name || `(${lat.toFixed(3)}, ${lng.toFixed(3)})`;
        } else {
            return streetOnly ? "Calle desconocida" : `Etapa (${lat.toFixed(3)}, ${lng.toFixed(3)})`;
        }
    } catch (err) {
        return streetOnly ? "Calle desconocida" : `Etapa (${lat.toFixed(3)}, ${lng.toFixed(3)})`;
    }
}
// ===================================================================
// NOMBRE: openAlertModal
// RESUMEN: Abre el modal para que el usuario seleccione una incidencia de tr√°fico.
function openAlertModal() {
   
    processTrafficAlerts();
    
    const alertModalOverlay = document.getElementById('alert-modal-overlay');
    const alertModalContent = document.getElementById('alert-modal-content');
    if (!alertModalOverlay || !alertModalContent) return;

    const alertOptions = [
        { code: 1, text: 'ACCIDENTE TR√ÅFICO', icon: 'PNG/AACCIDENTE.png' },
        { code: 2, text: 'COCHE AVERIADO', icon: 'PNG/AAVERIADO.png' },
        { code: 3, text: 'CONTROL TR√ÅFICO / RADAR', icon: 'PNG/AGUARDIA22.png' },
        { code: 4, text: 'ATASCO', icon: 'PNG/AATASCO.png' },
        { code: 5, text: 'PELIGRO INDETERMINADO', icon: 'PNG/APELIGRO.png' },
        { code: 6, text: 'CARRETERA MAL ESTADO', icon: 'PNG/ARESVALAR.png' },
        { code: 7, text: 'OBRAS', icon: 'PNG/AOBRAS.png' },
        { code: 8, text: 'V√çA / CARRETERA CERRADA', icon: 'PNG/ACERRADA.png' }, 
        { code: 9, text: 'YA NO HAY NADA', icon: 'PNG/BORRARRUTA.PNG' }           
    ];
    alertModalContent.innerHTML = '<div id="alert-columns-container"></div>';
    const columnsContainer = document.getElementById('alert-columns-container');

    const column1 = document.createElement('div');
    column1.className = 'alert-column';
    const column2 = document.createElement('div');
    column2.className = 'alert-column';

    alertOptions.forEach((option, index) => {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'alert-option';
        optionDiv.onclick = () => sendTrafficAlert(option.code, option.text);
        optionDiv.innerHTML = `<img src="${option.icon}" alt="${option.text}"><span>${option.text}</span>`;

        if (index < 5) {
            column1.appendChild(optionDiv);
        } else {
            column2.appendChild(optionDiv);
        }
    });

    const cancelButton = document.createElement('div');
    cancelButton.id = 'alert-cancel-button';
    cancelButton.innerHTML = '<span>CANCELAR <span id="alert-timer">(10)</span></span>';
    cancelButton.onclick = closeAlertModal;
    column2.appendChild(cancelButton); 

    columnsContainer.appendChild(column1);
    columnsContainer.appendChild(column2);

    alertModalOverlay.classList.remove('hidden');

    let countdown = 10;
    const timerSpan = document.getElementById('alert-timer');
    if (alertModalTimer) clearInterval(alertModalTimer);
    alertModalTimer = setInterval(() => {
        countdown--;
        if (timerSpan) timerSpan.textContent = `${countdown}`;
        if (countdown <= 0) {
            closeAlertModal();
        }
    }, 1000);
}

// ===================================================================
// NOMBRE: formatOCMPoint
// RESUMEN: Convierte un punto de recarga del formato OCM a un formato interno estandarizado.
function formatOCMPoint(point) {
    if (!point || !point.AddressInfo) {
        return null;
    }

    let maxPower = 0;
    if (point.Connections && Array.isArray(point.Connections)) {
        point.Connections.forEach(conn => {
            if (conn.PowerKW && conn.PowerKW > maxPower) {
                maxPower = conn.PowerKW;
            }
        });
    }

    const totalPoints = point.NumberOfPoints || (point.Connections ? point.Connections.length : 0);
    const availabilityText = `${totalPoints} Poste${totalPoints !== 1 ? 's' : ''}`;

    let priceText = 'N/D';
    if (point.UsageCost) {
        const priceMatch = point.UsageCost.match(/(\d[\d,.]*)/);
        if (priceMatch && priceMatch[1]) {
            let priceNum = parseFloat(priceMatch[1].replace(',', '.'));
            if (!isNaN(priceNum) && priceNum > 0 && priceNum < 10) { 
                 priceText = `${priceNum.toFixed(2)} ‚Ç¨/kWh`;
            }
        }
    }

    return {
        ocmId: point.ID,
        lat: point.AddressInfo.Latitude,
        lon: point.AddressInfo.Longitude,
        address: point.AddressInfo.Title || 'Direcci√≥n no disponible',
        availabilityText: availabilityText,
        price: priceText,
        fullPriceInfo: point.UsageCost || 'N/D',
        power: maxPower > 0 ? maxPower.toFixed(0) : 'N/A',
        operator: point.OperatorInfo ? point.OperatorInfo.Title : 'Desconocido',
        usageType: point.UsageType ? point.UsageType.Title : 'No especificado',
        accessInfo: point.AddressInfo.AccessComments || 'No especificado',
        connections: point.Connections || []
    };
}
    
// ===================================================================
// NOMBRE: closeAlertModal
// RESUMEN: Cierra el modal de selecci√≥n de incidencias y limpia su temporizador.
function closeAlertModal() {
    const alertModalOverlay = document.getElementById('alert-modal-overlay');
    if (alertModalOverlay) {
        alertModalOverlay.classList.add('hidden');
    }
    if (alertModalTimer) {
        clearInterval(alertModalTimer);
        alertModalTimer = null;
    }
}

// ===================================================================
// NOMBRE: sendTrafficAlert 
// RESUMEN: Env√≠a la alerta, la a√±ade a la cach√© local y redibuja el mapa al instante.
function sendTrafficAlert(alertCode, alertName) {
    const userId = localStorage.getItem('userData_userId');
    if (!userId) {
        showToast("Debes configurar un ID de Usuario para enviar alertas.", "warning");
        closeAlertModal();
        return;
    }
    closeAlertModal();
    const sendData = async (coords) => {
        if (!window.db || !window.doc || !window.setDoc || !window.collection) {
            showToast("Error: Firebase no est√° inicializado.", "error");
            return;
        }
        const alertData = {
            user: userId,
            code: alertCode,
            latitude: coords.latitude,
            longitude: coords.longitude,
            timestamp: new Date().toISOString()
        };

        try {
            const alertsCollectionRef = window.collection(window.db, "users", "ALERTAS", "events");
            const docId = `${Date.now()}_${userId.replace(/[^a-zA-Z0-9]/g, '_')}`;
            const newAlertRef = window.doc(alertsCollectionRef, docId);
            
            await window.setDoc(newAlertRef, alertData);

            const newAlertForCache = {
                id: docId,
                code: alertData.code,
                coordinates: { lat: alertData.latitude, lon: alertData.longitude }
            };
            
            const existingIndex = trafficAlertsCache.findIndex(a => a.id === newAlertForCache.id);
            if (existingIndex > -1) {
                trafficAlertsCache[existingIndex] = newAlertForCache; // Evita duplicados
            } else {
                trafficAlertsCache.push(newAlertForCache);
            }

            displayAlertsOnMap(); // Fuerza el redibujado inmediato del mapa con la nueva alerta.
            
            showToast(`Alerta "${alertName}" enviada y mostrada en el mapa.`, "success");

        } catch (error) {
            showToast(`Error al enviar alerta a Firebase: ${error.message}`, "error");
        }
    };

    if (isSimulatingGpsLocation && simulatedGpsLocation) {
        sendData(simulatedGpsLocation);
    } else {
        getCurrentLocation(
            (realCoords) => { sendData(realCoords); },
            (errorMsg) => { showToast(`No se pudo obtener la ubicaci√≥n: ${errorMsg}`, "error"); }
        );
    }
}    
    
// ===================================================================
// NOMBRE: processTrafficAlerts 
// RESUMEN: L√≥gica principal que lee, limpia, actualiza las alertas desde Firebase y construye el √≠ndice.
async function processTrafficAlerts() {
    if (!window.db || !window.getDocs || !window.deleteDoc || !window.collection) {
        console.warn("Funciones de Firebase no disponibles, no se pueden procesar alertas.");
        return;
    }
    
    lastAlertCheckTimestamp = Date.now();
    
    try {
        const alertsCollectionRef = window.collection(window.db, "users", "ALERTAS", "events");
        const querySnapshot = await window.getDocs(alertsCollectionRef);
        
        let allAlerts = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        const now = new Date();
        const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
        
        const removals = allAlerts.filter(alert => alert.code === 9);
        let activeAlerts = allAlerts.filter(alert => alert.code !== 9);

        for (const removal of removals) {
            const removalCoords = { lat: removal.latitude, lon: removal.longitude };
            const alertsToDelete = new Set();
            
            activeAlerts.forEach(alert => {
                if(alert.latitude && alert.longitude){
                    const alertCoords = { lat: alert.latitude, lon: alert.longitude };
                    if (calculateDistance(removalCoords.lat, removalCoords.lon, alertCoords.lat, alertCoords.lon) <= 800) {
                        alertsToDelete.add(alert.id);
                    }
                }
            });

            for (const idToDelete of alertsToDelete) {
                const docRef = window.doc(window.db, "users", "ALERTAS", "events", idToDelete);
                await window.deleteDoc(docRef);
            }
            
            const removalDocRef = window.doc(window.db, "users", "ALERTAS", "events", removal.id);
            await window.deleteDoc(removalDocRef);
        }

        activeAlerts = activeAlerts.filter(alert => {
            if (!alert.timestamp || new Date(alert.timestamp) < twentyFourHoursAgo) {
                const docRef = window.doc(window.db, "users", "ALERTAS", "events", alert.id);
                window.deleteDoc(docRef); // Borrado as√≠ncrono, no esperamos
                return false;
            }
            return true;
        });
        
        trafficAlertsCache = activeAlerts.filter(alert => alert.latitude && alert.longitude).map(alert => ({
            id: alert.id,
            code: alert.code,
            coordinates: { lat: alert.latitude, lon: alert.longitude }
        }));
        
        trafficAlertsSpatialIndex = {};
        trafficAlertsCache.forEach(alert => {
            if (alert.coordinates && alert.coordinates.lat && alert.coordinates.lon) {
                const cellId = getGridCellId(alert.coordinates.lat, alert.coordinates.lon);
                if (!trafficAlertsSpatialIndex[cellId]) {
                    trafficAlertsSpatialIndex[cellId] = [];
                }
                trafficAlertsSpatialIndex[cellId].push(alert);
            }
        });
   
        displayAlertsOnMap(); 
        checkAlertsProximity();
      
    } catch (error) {
        console.error("Error procesando alertas de tr√°fico: ", error);
    }
}

// ===================================================================
// NOMBRE: eliminarTareasDeMapa 
// RESUMEN: Elimina del mapa los marcadores de tareas/radares personales.
function eliminarTareasDeMapa() {
    reminderMapObjects = reminderMapObjects.filter(obj => {
        if (obj.isFromTarea) {
            if (obj.marker) obj.marker.remove();
            if (obj.circleId && navigationMapInstance.getLayer(obj.circleId)) {
                navigationMapInstance.removeLayer(obj.circleId);
            }
            if (obj.circleId && navigationMapInstance.getSource(obj.circleId)) {
                navigationMapInstance.removeSource(obj.circleId);
            }
            return false;
        }
        return true;
    });
}
// ===================================================================
// NOMBRE: createRadarAlertIcon 
// RESUMEN: Crea un icono de alerta escalable asegurando que devuelve un elemento DOM.
function createRadarAlertIcon(currentZoomLevel = null, isFromTarea = false) {
    const container = document.createElement('div'); 
    const SCALE_THRESHOLD_ZOOM = 16;
    const MIN_SCALE = 0.35;
    const MIN_ZOOM_FOR_SCALING = 10;
    let scale = 1.0;

    if (currentZoomLevel !== null && currentZoomLevel < SCALE_THRESHOLD_ZOOM) {
        if (currentZoomLevel <= MIN_ZOOM_FOR_SCALING) {
            scale = MIN_SCALE;
        } else {
            const progress = (currentZoomLevel - MIN_ZOOM_FOR_SCALING) / (SCALE_THRESHOLD_ZOOM - MIN_ZOOM_FOR_SCALING);
            scale = MIN_SCALE + (1 - MIN_SCALE) * progress;
        }
    }

    const baseSize = 55;
    const finalSize = Math.round(baseSize * scale);
    const finalBorderSize = Math.max(1, Math.round(3 * scale));
    
    const borderColor = isFromTarea ? '#00FF00' : 'white';

    container.className = 'radar-alert-circle';
    container.style.cssText = `width:${finalSize}px; height:${finalSize}px; border-width:${finalBorderSize}px; border-color:${borderColor};`;
    container.innerHTML = `<img src="PNG/radar.png" alt="Radar">`;
    
    return container; 
}
    
// ===================================================================
// NOMBRE: checkAlertsProximity 
// RESUMEN: Comprueba la proximidad usando el √≠ndice espacial y limpia alertas ya vistas y lejanas.
function checkAlertsProximity() {
    if (!navigationCurrentLocation || Object.keys(trafficAlertsSpatialIndex).length === 0) {
        return;
    }

    const carLat = navigationCurrentLocation.latitude;
    const carLon = navigationCurrentLocation.longitude;

    const centerCellId = getGridCellId(carLat, carLon);
    const [_, centerLatIndex, centerLonIndex] = centerCellId.split('_').map(Number);
    const candidateAlerts = new Set(); 

    for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
            const cellId = `cell_${centerLatIndex + i}_${centerLonIndex + j}`;
            if (trafficAlertsSpatialIndex[cellId]) {
                trafficAlertsSpatialIndex[cellId].forEach(alert => candidateAlerts.add(alert));
            }
        }
    }

    candidateAlerts.forEach(alert => {
        const distance = calculateDistance(carLat, carLon, alert.coordinates.lat, alert.coordinates.lon);
        if (distance <= 500 && !currentlyDisplayedProximityAlerts.has(alert.id)) {
            showProximityAlert(alert);
            currentlyDisplayedProximityAlerts.add(alert.id);
        }
    });

    const now = Date.now();
    if (now - lastAlertCleanupTimestamp > 30000) {
        lastAlertCleanupTimestamp = now;

        if (currentlyDisplayedProximityAlerts.size > 0) {
            const CLEANUP_DISTANCE_THRESHOLD_METERS = 2000; // 2 km

            const alertsToCheckForCleanup = new Set(currentlyDisplayedProximityAlerts);

            alertsToCheckForCleanup.forEach(alertId => {
                const alertData = trafficAlertsCache.find(a => a.id === alertId);
                if (alertData) {
                    const distanceToOldAlert = calculateDistance(carLat, carLon, alertData.coordinates.lat, alertData.coordinates.lon);
                    if (distanceToOldAlert > CLEANUP_DISTANCE_THRESHOLD_METERS) {
                        currentlyDisplayedProximityAlerts.delete(alertId);
                    }
                } else {
                    currentlyDisplayedProximityAlerts.delete(alertId);
                }
            });
        }
    }
}

// ===================================================================
// NOMBRE: showProximityAlert
// RESUMEN: Muestra el modal de aviso de proximidad a una alerta de tr√°fico.
function showProximityAlert(alert) {
    const proximityModal = document.getElementById('proximity-alert-modal');
    if (!proximityModal) return;

    const alertDetails = [
        null, 
        { text: 'ACCIDENTE TR√ÅFICO', icon: 'PNG/AACCIDENTE.png' },
        { text: 'COCHE AVERIADO', icon: 'PNG/AAVERIADO.png' },
        { text: 'CONTROL TR√ÅFICO / RADAR', icon: 'PNG/AGUARDIA22.png' },
        { text: 'ATASCO', icon: 'PNG/AATASCO.png' },
        { text: 'PELIGRO INDETERMINADO', icon: 'PNG/APELIGRO.png' },
        { text: 'CARRETERA MAL ESTADO', icon: 'PNG/ARESVALAR.png' },
        { text: 'OBRAS', icon: 'PNG/AOBRAS.png' },
        null, 
        { text: 'V√çA / CARRETERA CERRADA', icon: 'PNG/ACERRADA.png' } 
    ][alert.code];

    if (!alertDetails) return;

    proximityModal.innerHTML = `
        <img src="${alertDetails.icon}" alt="${alertDetails.text}">
        <div class="content">
            <span class="alert-text">${alertDetails.text}</span>
            <button id="proximity-ok-button">ENTERADO <span id="proximity-timer">(10)</span></button>
        </div>
    `;

    document.getElementById('flashing-border-overlay').classList.remove('hidden');
    proximityModal.classList.remove('hidden');

    const okButton = document.getElementById('proximity-ok-button');
    const timerSpan = document.getElementById('proximity-timer');
    let countdown = 15;
    
    if (proximityAlertTimer) clearInterval(proximityAlertTimer);
    proximityAlertTimer = setInterval(() => {
        countdown--;
        if (timerSpan) timerSpan.textContent = `${countdown}`;
        if (countdown <= 0) {
            hideProximityAlert(alert.id);
        }
    }, 1000);
    
    okButton.onclick = () => hideProximityAlert(alert.id);
}

// ===================================================================
// NOMBRE: handleLocateMeClick (VERSI√ìN CON REACTIVACI√ìN DE OVERLAYS)
function handleLocateMeClick(isExplicitAction = false) {
    if (!navigationMapInstance) return;

    clearLocateMeReactivationTimer();
    isManualZoomActive = false;
    
    navigationFollowUser = !navigationFollowUser;
    shouldCenterOnUser = navigationFollowUser;

    if (navigationFollowUser) {
        toggleRouteDetailOverlays(true);  
        if (navigationCurrentLocation) {
            isFlying = true; 

            const targetZoom = manualZoomLevelMemory !== null ? manualZoomLevelMemory : 17;
      
            const flyToOptions = {
                center: [navigationCurrentLocation.longitude, navigationCurrentLocation.latitude],
                zoom: targetZoom, 
                duration: 1200,
                essential: true
            };

            const mode = mapViewMode || 'static';
            
            if (mode === 'perspective' || mode === 'relief') {
                flyToOptions.pitch = mapPitchValue;
            } else {
                flyToOptions.pitch = 0;
            }
            
            if (mode === 'heading' || mode === 'perspective' || mode === 'relief') {
                flyToOptions.bearing = navigationCurrentLocation.heading || 0;
            }

            navigationMapInstance.flyTo(flyToOptions);
            
            navigationMapInstance.once('moveend', () => {
                isFlying = false;
                markerAnimationState.currentMapCenter = navigationMapInstance.getCenter();
                markerAnimationState.currentMapZoom = navigationMapInstance.getZoom();
                markerAnimationState.currentMapPitch = navigationMapInstance.getPitch();
                markerAnimationState.currentMapBearing = navigationMapInstance.getBearing();
                
                markerAnimationState.targetMapCenter = navigationMapInstance.getCenter();
                markerAnimationState.targetMapZoom = navigationMapInstance.getZoom();
                markerAnimationState.targetMapPitch = navigationMapInstance.getPitch();
                markerAnimationState.targetMapBearing = navigationMapInstance.getBearing();
            });

        } else {
            getCurrentLocation(coords => {
                if (navigationMapInstance) {
                     const locateOptions = { center: [coords.longitude, coords.latitude], zoom: 17 };
                     const mode = mapViewMode || 'static';
                     if (mode === 'perspective' || mode === 'relief') {
                         locateOptions.pitch = mapPitchValue;
                     }
                     navigationMapInstance.flyTo(locateOptions);
                }
                updateInitialUserPosition(coords, navigationMapInstance);
            }, () => showToast("No se pudo obtener tu ubicaci√≥n.", "warning"));
        }
    } else {
        if (isExplicitAction) {
            clearLocateMeReactivationTimer();
        } else {
            startLocateMeReactivationTimer();
        }
    }
    
    updateLocateMeButtonsUI();
    updateStartNavigationButtonState();
}
    
// ===================================================================
// NOMBRE: loadRouteByName 
// RESUMEN: Busca una ruta guardada por su nombre y llama a la funci√≥n de carga gen√©rica.
function loadRouteByName(routeName, autoStartNavigation = false) {
    const savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
    const recentRoutes = JSON.parse(localStorage.getItem('boardinggate_recent_routes') || "[]");
    let routeToLoad = savedRoutes.find(r => r.name.toUpperCase() === routeName.toUpperCase());
    if (!routeToLoad) {
        routeToLoad = recentRoutes.find(r => r.name.toUpperCase() === routeName.toUpperCase());
    }
    if (routeToLoad) {
        loadRouteFromObject(routeToLoad, autoStartNavigation);
    } else {
        showToast(`No se pudo cargar la ruta "${routeName}". No encontrada`, "error");
        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox) {
           localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked));
        }
        const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasRutaCheckbox) {
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
        }
    }
}

// ===================================================================
// NOMBRE: getManeuverIconFilename (
// RESUMEN: Devuelve el nombre del fichero de imagen para una maniobra,
function getManeuverIconFilename(maneuver) {
    if (!maneuver) return 'PNG/continue.png';
    const type = maneuver.type || '';
    const modifier = maneuver.modifier || '';

    if (type.includes('roundabout') && typeof maneuver.exit === 'number' && maneuver.exit >= 1 && maneuver.exit <= 5) {
        return `PNG/S${maneuver.exit}.PNG`;
    }
    if (type.includes('roundabout') || type.includes('rotary')) {
        return 'PNG/roundabout.png';
    }
    
    if (type === 'depart') return 'PNG/depart.png';
    if (type === 'arrive') return 'PNG/arrive.png';
    
    if (modifier.includes('uturn')) return 'PNG/uturn.png';
    if (modifier.includes('sharp right')) return 'PNG/sharp-right.png';
    if (modifier.includes('sharp left')) return 'PNG/sharp-left.png';
    if (modifier.includes('slight right') || modifier.includes('bear right')) return 'PNG/bear-right.png';
    if (modifier.includes('slight left') || modifier.includes('bear left')) return 'PNG/bear-left.png';
    if (modifier.includes('right')) return 'PNG/turn-right.png';
    if (modifier.includes('left')) return 'PNG/turn-left.png';
    if (modifier.includes('ramp')) return 'PNG/ramp.png';
    
    return 'PNG/continue.png'; 
}    
    
// ===================================================================
// NOMBRE: getSuggestedRouteName
// RESUMEN: Sugiere un nombre de ruta por defecto basado en la ubicaci√≥n final.
async function getSuggestedRouteName(lat, lng, isMultiStage = false, totalWaypoints = 0) {
    let baseName = `RUTA: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
    try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=1&accept-language=es`);
        if (response.ok) {
            const data = await response.json();
            if (data.address) {
                const road = data.address.road;
                const city = data.address.city || data.address.town || data.address.village || data.address.hamlet;
                if (road && city) baseName = `${road}, ${city}`;
                else if (city) baseName = city;
                else if (road) baseName = road;
            }
        }
    } catch (e) {
    }
    if (isMultiStage) {
        const numStages = Math.max(0, totalWaypoints - 1);
        return `${numStages} ETAPAS: ${baseName}`;
    } else {
        return `  ${baseName}`;
    }
}

function initializeConfigModalListeners() {
    document.getElementById('config-save-user-firebase')?.addEventListener('click', validateAndSaveUserToFirebase);
    document.getElementById('config-save-user-firebase-from-backup-tab')?.addEventListener('click', validateAndSaveUserToFirebase);
    document.getElementById('config-restore-backup-firebase')?.addEventListener('click', restoreBackupFromFirebase);
    document.getElementById('config-save-pin')?.addEventListener('click', savePinSettings);
    document.getElementById('config-remove-pin')?.addEventListener('click', removePinSettings);
    document.getElementById('config-generate-backup')?.addEventListener('click', generateBackup);
    document.getElementById('config-restore-backup')?.addEventListener('click', restoreBackup);
    document.getElementById('config-restore-grid-button')?.addEventListener('click', restoreOriginalGrid);
    document.getElementById('config-clear-cache')?.addEventListener('click', clearAllLocalData);

    const importBtn = document.getElementById('import-radars-button');
    if (importBtn && !importBtn.dataset.listenerAttached) {
        importBtn.addEventListener('click', importRadars);
        importBtn.dataset.listenerAttached = "true";
    }

    const deleteBtn = document.getElementById('delete-filtered-radars-button');
    if (deleteBtn && !deleteBtn.dataset.listenerAttached) {
        deleteBtn.addEventListener('click', deleteFilteredRadars);
        deleteBtn.dataset.listenerAttached = "true";
    }

    const acceptTermsButton = document.getElementById('accept-terms-button');
    if (acceptTermsButton && !acceptTermsButton.dataset.listenerAttached) {
        acceptTermsButton.addEventListener('click', () => {
            localStorage.setItem('termsAccepted_v1', 'true');
            showToast('Normas aceptadas. Gracias.', 'success');
            const modal = document.getElementById('config-modal');
            markCacheAsDirty(); 
        
            if (modal) {
                modal.querySelectorAll('.config-tab-button').forEach(btn => {
                    btn.disabled = false;
                    btn.style.cursor = 'pointer';
                    btn.style.opacity = '1';
                });
                modal.querySelector('.config-tab-button[data-tab-target="#tab-content-normas"]').classList.remove('active');
                modal.querySelector('#tab-content-normas').classList.remove('active');
                modal.querySelector('.config-tab-button[data-tab-target="#tab-content-usuario"]').classList.add('active');
                modal.querySelector('#tab-content-usuario').classList.add('active');
            }
        });
        acceptTermsButton.dataset.listenerAttached = "true";
    }
    
    const directToNavCheckbox = document.getElementById('config-direct-to-nav');
    if (directToNavCheckbox && !directToNavCheckbox.dataset.listenerAttached) {
        directToNavCheckbox.addEventListener('change', () => {
            localStorage.setItem(DIRECT_TO_NAVIGATION_KEY, JSON.stringify(directToNavCheckbox.checked));
            showToast('Preferencia de inicio directo al mapa guardada.', 'success', 2000);
        });
        directToNavCheckbox.dataset.listenerAttached = "true";
    }
    const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
    if (autoBackupCheckbox && !autoBackupCheckbox.dataset.listenerAttached) {
        autoBackupCheckbox.addEventListener('change', () => {
            localStorage.setItem('boardinggate_autoBackupOnLoad', JSON.stringify(autoBackupCheckbox.checked));
            showToast(`Copia de seguridad autom√°tica al inicio: ${autoBackupCheckbox.checked ? 'Activada' : 'Desactivada'}`, 'info', 3000);
        });
        autoBackupCheckbox.dataset.listenerAttached = "true";
    } 
}    
    
    // ===================================================================
    // NOMBRE: parseUserId
    // RESUMEN: Analiza el ID de usuario para detectar si es un usuario m√≥vil y extrae el ID principal.
    function parseUserId(rawUserId) {
        if (!rawUserId) {
            return { primaryId: null, isMobile: false, originalId: null };
        }
        const mobileRegex = /^(.*?)@(M√ìVIL|MOVIL)$/i;
        const match = rawUserId.trim().match(mobileRegex);
        if (match && match[1]) {
            return {
                primaryId: match[1].trim(),
                isMobile: true,
                originalId: rawUserId.trim()
            };
        } else {
            return {
                primaryId: rawUserId.trim(),
                isMobile: false,
                originalId: rawUserId.trim()
            };
        }
    }
       

// ===================================================================
// NOMBRE: markCacheAsDirty
// RESUMEN: CADA VEZ QUE SE CAMBIA (SI HAN PASADO 30 MINUTOS) SE SALVA A FIREBASE
// ===================================================================
function markCacheAsDirty() {
    isCacheDirty = true; // Para la reconstrucci√≥n inmediata de la cach√© en memoria
    localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString()); // Para la l√≥gica de sincronizaci√≥n

    const { isMobile } = parseUserId(localStorage.getItem('userData_userId'));
    if (isMobile) {
    }
    
    const now = Date.now();
    const THIRTY_MINUTES_MS = 30 * 60 * 1000;

    if (lastAutoBackupTimestamp === 0 || (now - lastAutoBackupTimestamp > THIRTY_MINUTES_MS)) {
        triggerSilentFirebaseBackup();
    }
  }

// ===================================================================
// NOMBRE: sanitizeWaypointsForStorage 
// RESUMEN: Crea una copia "limpia" de un array de waypoints, eliminando propiedades
function sanitizeWaypointsForStorage(waypoints) {
    if (!Array.isArray(waypoints)) return [];
    return waypoints.map(wp => {
        if (!wp) return null;
        return {
            id: wp.id,
            lat: wp.lat,
            lng: wp.lng,
            address: wp.address,
            type: wp.type,
            label: wp.label,
            visited: wp.visited,
            isInternal: wp.isInternal,
            isRecalculatedStart: wp.isRecalculatedStart,
            isCriticalForRecalc: wp.isCriticalForRecalc
        };
    }).filter(Boolean); 
}
    
// ===================================================================
// NOMBRE: autoSaveToFirebase 
// RESUMEN: Realiza un guardado en Firebase, aceptando un flag para indicar si es una actualizaci√≥n.
async function autoSaveToFirebase(primaryId, backupPassword, isUpdate = false) {
    if (!primaryId || !backupPassword) {
        return { status: "error", message: "Faltan credenciales" };
    }

    const cacheData = {};
    managedKeys.forEach(key => {
        const value = localStorage.getItem(key);
        if (value !== null) cacheData[key] = value;
    });

    if (cacheData.reminders) {
        try {
            let reminders = JSON.parse(cacheData.reminders);
            const remindersFiltrados = reminders.filter(r => !r.isDynamicRadar);
            cacheData.reminders = JSON.stringify(remindersFiltrados);
        } catch (e) {
            console.error("Error al filtrar radares para backup:", e);
        }
    }

    const saveData = {
        userId: primaryId,
        usuario: primaryId,
        modelo: localStorage.getItem('userData_teslaModel') || '',
        anio: localStorage.getItem('userData_teslaYear') || '',
        provincia: localStorage.getItem('userData_teslaProvince') || '',
        rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
        datosCache: cacheData,
        backupPassword: backupPassword,
        fechaBackup: new Date().toISOString()
    };
    
    // Pasamos el flag a la funci√≥n de Firebase
    return await callFirebase('saveUser', saveData, isUpdate);
}
// ===================================================================
// NOMBRE: triggerSilentFirebaseBackup 
// RESUMEN: Orquesta el backup silencioso, llamando a la funci√≥n de guardado.
// ===================================================================
async function triggerSilentFirebaseBackup() {
    const { primaryId, isMobile } = parseUserId(localStorage.getItem('userData_userId'));
    const backupPassword = localStorage.getItem('userData_backupPassword');

    if (isMobile || !primaryId || !backupPassword) {
        return; 
    }
    
    try {
        const result = await autoSaveToFirebase(primaryId, backupPassword);
        if (result.status === 'success') {
            lastAutoBackupTimestamp = Date.now(); 
            console.log("[AutoSave] COPIA A FIREBASE SILENCIOSA");
        
        } else {
            console.error("[AutoSave] Fall√≥ el backup silencioso:", result.message);
        }
    } catch (error) {
        console.error("[AutoSave] Error inesperado durante el backup silencioso:", error);
    }
}
    
    // ===================================================================
    // NOMBRE: promptForBackupPassword
    // RESUMEN: Muestra un modal para que el usuario introduzca un PIN de seguridad para backups.
    function promptForBackupPassword(message, onConfirm, onCancel, isSettingPassword = false) {
        const existingModal = document.getElementById('backup-password-modal-overlay');
        if (existingModal) existingModal.remove();
        const modalOverlay = document.createElement('div');
        modalOverlay.id = 'backup-password-modal-overlay';
        modalOverlay.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85); display: flex; justify-content: center;
            align-items: center; z-index: 9999;
        `;
        const modalContent = document.createElement('div');
        modalContent.id = 'backup-password-modal-content';
        modalContent.style.cssText = `
            background-color: #DAC8A0; padding: 2rem; border-radius: 0.75rem;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4); text-align: center; border: 1px solid #A0522D;
            margin-top: -50px;
            max-width: 350px; width: 90%;
        `;
        modalContent.innerHTML = `
            <h2 style="font-size: 1.5rem; font-weight: bold; color: #333; margin-bottom: 1rem;">${message}</h2>
            <input type="password" id="backup-password-input" maxlength="6" pattern="\\d{6}" inputmode="numeric" style="
                width: 150px; padding: 0.8rem; font-size: 1.8rem; text-align: center;
                border: 2px solid #A0522D; border-radius: 0.25rem; margin-bottom: 1.5rem;
                letter-spacing: 0.5em; background-color: #f0f0e0;
            " required>
            ${isSettingPassword ? `
                <label for="backup-password-confirm" style="display: block; font-size: 1.1rem; color: #444; margin-bottom: 0.8rem;">Confirmar PIN:</label>
                <input type="password" id="backup-password-confirm" maxlength="6" pattern="\\d{6}" inputmode="numeric" style="
                    width: 150px; padding: 0.8rem; font-size: 1.8rem; text-align: center;
                    border: 2px solid #A0522D; border-radius: 0.25rem; margin-bottom: 1.5rem;
                    letter-spacing: 0.5em; background-color: #f0f0e0;
                " required>
            ` : ''}
            <p id="backup-password-error" style="color: #dc3545; font-weight: bold; margin-top: -0.5rem; margin-bottom: 1rem; min-height: 1.2em;"></p>
            <div style="display:flex; justify-content: space-around; gap:1rem;">
                <button id="backup-password-submit" style="padding: 0.8rem 1.5rem; font-size: 1.2rem; background-color: #28a745; color: white; border: none; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; flex: 1;">Aceptar</button>
                <button id="backup-password-cancel" style="padding: 0.8rem 1.5rem; font-size: 1.2rem; background-color: #6c757d; color: white; border: none; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; flex: 1;">Cancelar</button>
            </div>
        `;
        document.body.appendChild(modalOverlay);
        modalOverlay.appendChild(modalContent);
        const pinInput = document.getElementById('backup-password-input');
        const pinConfirmInput = document.getElementById('backup-password-confirm');
        const errorEl = document.getElementById('backup-password-error');
        const submitBtn = document.getElementById('backup-password-submit');
        const cancelBtn = document.getElementById('backup-password-cancel');
        pinInput.focus();
        const validateAndSubmit = () => {
            errorEl.textContent = '';
            const pin = pinInput.value;
            if (!/^\d{6}$/.test(pin)) {
                errorEl.textContent = 'El PIN debe ser de 6 d√≠gitos num√©ricos.';
                if (navigator.vibrate) navigator.vibrate(100);
                return;
            }
            if (isSettingPassword) {
                const confirmPin = pinConfirmInput.value;
                if (pin !== confirmPin) {
                    errorEl.textContent = 'Los PINs no coinciden.';
                    if (navigator.vibrate) navigator.vibrate(100);
                    return;
                }
            }
            modalOverlay.remove();
            onConfirm(pin);
        };
        submitBtn.addEventListener('click', validateAndSubmit);
        cancelBtn.addEventListener('click', () => {
            modalOverlay.remove();
            onCancel();
        });
        pinInput.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                if (isSettingPassword && pinConfirmInput) {
                    pinConfirmInput.focus();
                } else {
                    validateAndSubmit();
                }
            }
        });
        if (isSettingPassword && pinConfirmInput) {
            pinConfirmInput.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') {
                    validateAndSubmit();
                }
            });
        }
        addModalAutoCloseTimer(modalOverlay, submitBtn, 'backup-password-modal', isSettingPassword ? 90000 : 30000);
    }
     
// ===================================================================
// NOMBRE: callFirebase 
// RESUMEN: Usa setDoc con { merge: true } para todas las operaciones de guardado,
//          evitando borrados accidentales.
// ===================================================================
async function callFirebase(action, data, isUpdate = false) { // isUpdate ya no es necesario aqu√≠, pero lo mantenemos por compatibilidad
    if (!window.db || !window.doc || !window.setDoc || !window.getDoc || !window.updateDoc) {
        return { status: "error", message: "Error interno: Funciones de Firebase no est√°n disponibles." };
    }
    const userId = data.userId;
    if (!userId) {
        return { status: "error", message: "ID de Usuario es obligatorio." };
    }

    try {
        const userDocRef = window.doc(window.db, "user_data", userId);

        if (action === 'saveUser') {
            const documentData = {
                usuario: data.usuario,
                modelo: data.modelo || '',
                anio: data.anio || '',
                provincia: data.provincia || '',
                rss: typeof data.rss === 'boolean' ? data.rss : false,
                contenidoCacheCompleto: JSON.stringify(data.datosCache || {}),
                fechaBackup: new Date().toISOString(),
                backupPassword: data.backupPassword || null
            };

            // --> A√ëADIDO: Si la data que llega tiene contadores, los incluimos.
            if (data.map_sessions_total) documentData.map_sessions_total = data.map_sessions_total;
            if (data.map_sessions_month) documentData.map_sessions_month = data.map_sessions_month;
            if (data.map_sessions_last_month) documentData.map_sessions_last_month = data.map_sessions_last_month;

            Object.keys(documentData).forEach(key => {
                if (documentData[key] === undefined) {
                    delete documentData[key];
                }
            });

            await window.setDoc(userDocRef, documentData, { merge: true });

            return { status: "success", message: "Datos guardados en Firebase." };

        } else if (action === 'getUserData') {
            const docSnap = await window.getDoc(userDocRef);
            if (docSnap.exists()) {
                const firebaseData = docSnap.data();
                try {
                    firebaseData.contenidoCacheCompleto = JSON.parse(firebaseData.contenidoCacheCompleto || '{}');
                } catch (e) {
                    firebaseData.contenidoCacheCompleto = {};
                }
                return { status: "success", message: "Datos recuperados de Firebase.", data: firebaseData };
            } else {
                return { status: "not_found", message: "No se encontr√≥ ning√∫n backup para ese ID." };
            }
        } else if (action === 'checkUserExists') {
             const docSnap = await window.getDoc(userDocRef);
             return { status: "success", exists: docSnap.exists() };
        } else {
            return { status: "error", message: "Acci√≥n de Firebase no reconocida." };
        }
    } catch (error) {
        console.error("Error en la operaci√≥n de Firebase:", error);
        return { status: "error", message: `Error de Firebase: ${error.message}` };
    }
}
    
// ===================================================================
// NOMBRE: incrementUserCount 
// RESUMEN: Incrementa de forma at√≥mica y segura el contador de usuarios en Firebase.
async function incrementUserCount() {
    if (!window.runTransaction) {
        console.error("La funci√≥n runTransaction de Firebase no est√° disponible. Revisa la importaci√≥n en el HTML.");
        return;
    }

    const counterRef = window.doc(window.db, "stats", "user_count");

    try {
        await window.runTransaction(window.db, async (transaction) => {
            const counterDoc = await transaction.get(counterRef);

            if (!counterDoc.exists()) {
                transaction.set(counterRef, { total: 1 });
            } else {
                const newTotal = (counterDoc.data().total || 0) + 1;
                transaction.update(counterRef, { total: newTotal });
            }
        });
    } catch (error) {
        console.error("Fall√≥ la transacci√≥n para incrementar el contador de usuarios:", error);
     }
}   

// ===================================================================
// NOMBRE: getGpsWithRetries 
// RESUMEN: L√≥gica de fallback que busca el GPS con reintentos y muestra un toast.
// ===================================================================
async function getGpsWithRetries() {
    const toastId = "gps-locate-toast";
    showToast("LOCALIZANDO VEH√çCULO...", "info", 0, false, toastId);
    
    let retries = 0;
    const MAX_RETRIES = 10; 

    while (retries < MAX_RETRIES) {
        try {
            const coords = await getCurrentLocationAsync();
            const loadingToast = document.getElementById(toastId);
            if (loadingToast) loadingToast.remove();
            return coords;
        } catch (error) {
            retries++;
            const message = `No se pudo obtener la ubicaci√≥n. Reintentando en 3s... (${retries}/${MAX_RETRIES})`;
            showToast(message, "warning", 0, false, toastId);
            await new Promise(resolve => setTimeout(resolve, 3000));
        }
    }

    const loadingToast = document.getElementById(toastId);
    if (loadingToast) loadingToast.remove();
    showToast("Fallo al obtener la ubicaci√≥n tras varios intentos. Revise los permisos.", "error");
    throw new Error("Fallo al obtener la ubicaci√≥n GPS tras m√∫ltiples reintentos.");
}
// ===================================================================
// NOMBRE: getInitialGpsPositionForMap 
// RESUMEN: Prioriza la ubicaci√≥n guardada en la bandera de recuperaci√≥n si existe y es v√°lida.
// ===================================================================
async function getInitialGpsPositionForMap() {
    const recoveryFlagJSON = localStorage.getItem('boardinggate_nav_recovery_flag');
    if (recoveryFlagJSON) {
        try {
            const recoveryData = JSON.parse(recoveryFlagJSON);
            if (recoveryData && recoveryData.lastKnownLocation) {
                return Promise.resolve(recoveryData.lastKnownLocation);
            }
        } catch (e) {
        }
    }

    if (preloadedGpsPosition) {
        const positionToReturn = { ...preloadedGpsPosition }; 
        preloadedGpsPosition = null; 
        return positionToReturn;
    } 
    
    else {
        return getGpsWithRetries();
    }
}

// ===================================================================
// NOMBRE: renameUser 
// RESUMEN: "Renombra" un usuario en Firebase de forma segura usando una escritura por lotes.
async function renameUser(oldUsername, newUsername, pin) {
    if (!oldUsername || !newUsername || !pin) {
        return { success: false, message: "Faltan datos para el renombrado." };
    }
    if (oldUsername === newUsername) {
        return { success: true, message: "El nombre de usuario no ha cambiado." };
    }
    try {
        const oldDocRef = window.doc(window.db, "user_data", oldUsername);
        const newDocRef = window.doc(window.db, "user_data", newUsername);
        const newDocSnap = await window.getDoc(newDocRef);
        if (newDocSnap.exists()) {
            return { success: false, message: `El nombre de usuario "${newUsername}" ya est√° en uso.` };
        }
        const oldDocSnap = await window.getDoc(oldDocRef);
        if (!oldDocSnap.exists()) {
            return { success: false, message: `No se encontr√≥ el usuario original "${oldUsername}".` };
        }
        const userData = oldDocSnap.data();
        if (userData.backupPassword !== pin) {
            return { success: false, message: "El PIN del usuario original es incorrecto." };
        }
        const dataToMove = { ...userData, usuario: newUsername }; // Actualiza el campo 'usuario' interno
        const batch = window.writeBatch(window.db);
        batch.set(newDocRef, dataToMove);
        batch.delete(oldDocRef);
        await batch.commit();
        localStorage.setItem('userData_userId', newUsername);
        return { success: true, message: `Usuario renombrado de "${oldUsername}" a "${newUsername}" con √©xito.` };
    } catch (error) {
        return { success: false, message: `Error de red: ${error.message}` };
    }
}

// ===================================================================
// NOMBRE: validateAndSaveUserToFirebase 
// RESUMEN: Valida y guarda los datos del usuario, distinguiendo entre creaci√≥n y actualizaci√≥n para llamar a la funci√≥n de Firebase correctamente.
async function validateAndSaveUserToFirebase() {
    const statusEl = document.getElementById('config-user-status');
    const userIdInput = document.getElementById('user-id');
    const { primaryId: newUsername, originalId: newOriginalId } = parseUserId(userIdInput.value);

    if (!newUsername) {
        statusEl.textContent = 'El ID de Usuario es obligatorio.';
        statusEl.style.color = '#EF4444';
        return;
    }

    const currentLocalUserId = localStorage.getItem('userData_userId');
    const { primaryId: oldUsername } = parseUserId(currentLocalUserId);
    const hasChangedUser = newUsername.toLowerCase() !== (oldUsername || '').toLowerCase();

    const finalSaveProcess = async (username, pin, isAnUpdate) => {
        statusEl.textContent = isAnUpdate ? 'Sincronizando datos con la nube...' : 'Guardando datos en la nube...';
        statusEl.style.color = '#17a2b8';

        localStorage.setItem('userData_userId', newOriginalId);
        localStorage.setItem('userData_teslaModel', document.getElementById('tesla-model').value.trim());
        localStorage.setItem('userData_teslaYear', document.getElementById('tesla-year').value.trim());
        localStorage.setItem('userData_teslaProvince', document.getElementById('tesla-province').value.trim());
        localStorage.setItem('userData_allowDMs', JSON.stringify(document.getElementById('allow-dms').checked));
        localStorage.setItem('boardinggate_autoBackupOnLoad', JSON.stringify(document.getElementById('config-auto-backup-on-load').checked));
        localStorage.setItem('userData_backupPassword', pin);
        updateUserIdDisplay();

        const result = await autoSaveToFirebase(username, pin, isAnUpdate); // Pasamos el flag

        if (result.status === 'success') {
            statusEl.textContent = `Datos para "${username}" ${isAnUpdate ? 'sincronizados' : 'guardados'} correctamente.`;
            statusEl.style.color = '#28a745';
            showToast(`Datos ${isAnUpdate ? 'sincronizados' : 'guardados'} en la nube.`, 'success');
        } else {
            statusEl.textContent = `Error al guardar: ${result.message}`;
            statusEl.style.color = '#EF4444';
            showToast(`Error al guardar: ${result.message}`, 'error');
        }
    };

    if (!oldUsername) { // CASO: Usuario nuevo
        statusEl.textContent = `Verificando disponibilidad de "${newUsername}"...`;
        const checkResult = await callFirebase('checkUserExists', { userId: newUsername });

        if (checkResult.exists) {
            statusEl.textContent = `El nombre "${newUsername}" ya est√° en uso. Elige otro.`;
            statusEl.style.color = '#EF4444';
            return;
        }

        promptForBackupPassword(
            `Crea un PIN de 6 d√≠gitos para tu nueva cuenta "${newUsername}".`,
            async (newPin) => {
                await finalSaveProcess(newUsername, newPin, false); // isAnUpdate = false
                await incrementUserCount();
            },
            () => {
                statusEl.textContent = 'Creaci√≥n cancelada.';
                statusEl.style.color = '#6c757d';
            },
            true
        );

    } else if (hasChangedUser) { // CASO: Renombrar usuario
        promptForBackupPassword(
            `Introduce el PIN de tu cuenta ("${oldUsername}") para autorizar el cambio:`,
            async (enteredPin) => {
                const renameResult = await renameUser(oldUsername, newUsername, enteredPin);
                if (renameResult.success) {
                    await finalSaveProcess(newUsername, enteredPin, true); // Es una actualizaci√≥n del nuevo doc
                    statusEl.textContent = renameResult.message;
                    statusEl.style.color = '#28a745';
                } else {
                    statusEl.textContent = `Error: ${renameResult.message}`;
                    statusEl.style.color = '#EF4444';
                }
            },
            () => {
                statusEl.textContent = 'Cambio de nombre cancelado.';
                statusEl.style.color = '#6c757d';
                userIdInput.value = currentLocalUserId || '';
            }
        );

    } else { // CASO: Sincronizar usuario existente (el que falla)
        const localPin = localStorage.getItem('userData_backupPassword');
        if (!localPin) {
             statusEl.textContent = 'Error: No se encontr√≥ PIN local. No se puede guardar.';
             statusEl.style.color = '#EF4444';
             return;
        }
        await finalSaveProcess(newUsername, localPin, true); // isAnUpdate = true
    }
}    
    
// ===================================================================
// NOMBRE: restoreBackupFromFirebase
// RESUMEN: Recupera y aplica un backup de datos desde Firebase, pidiendo PIN para confirmar.
async function restoreBackupFromFirebase(isAutoLoad = false) {
    const statusEl = document.getElementById('config-restore-status');
    const { primaryId, isMobile, originalId } = parseUserId(document.getElementById('restore-user-id').value || localStorage.getItem('userData_userId'));
    if (!primaryId) {
        if (!isAutoLoad) statusEl.textContent = 'Introduce un ID de Usuario para recuperar.';
        if (!isAutoLoad) statusEl.style.color = '#EF4444';
        return;
    }
    if (!isAutoLoad) {
        statusEl.textContent = `Buscando backup para "${primaryId}"...`;
        statusEl.style.color = '#17a2b8';
        showToast(`Recuperando backup de "${primaryId}"...`, 'info', 0, false, "firebase-restore-toast");
    }
    const result = await callFirebase('getUserData', { userId: primaryId });
    if (!isAutoLoad) {
        const existingToast = document.getElementById("firebase-restore-toast");
        if (existingToast) existingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== "firebase-restore-toast");
    }
    if (result.status === 'success' && result.data) {
        const firebaseData = result.data;
        const backupCacheData = firebaseData.contenidoCacheCompleto;
        if (!backupCacheData) {
            if (!isAutoLoad) {
                statusEl.textContent = `El backup para "${primaryId}" no contiene datos de cach√©.`;
                statusEl.style.color = '#EF4444';
                showToast('Backup incompleto.', 'error');
            }
            return;
        }
        const applyChanges = () => {
            const currentUserIdentity = localStorage.getItem('userData_userId') || originalId;
            for (const key in backupCacheData) {
                if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                    localStorage.setItem(key, backupCacheData[key]);
                }
            }
            localStorage.setItem('userData_userId', currentUserIdentity);
            const newTimestamp = Date.now().toString();
            localStorage.setItem('lastCacheUpdateTimestamp', newTimestamp);
            if (isMobile) {
                lastMobileSyncTimestamp = parseInt(newTimestamp);
            }
            showToast('Restauraci√≥n completada. Recargando...', 'success', 3000);
            setTimeout(() => location.reload(), 2500);
        };
        if (isAutoLoad) {
            applyChanges();
        } else {
            promptForBackupPassword(
                `Introduce el PIN para "${primaryId}":`,
                (enteredPin) => {
                    if (enteredPin === firebaseData.backupPassword) {
                        if (confirm(`Backup para "${primaryId}" desbloqueado.\n\n¬øEst√°s seguro de que quieres restaurar estos datos?\n\n¬°ATENCI√ìN! Se sobreescribir√°n TODOS tus datos locales actuales (grid, recordatorios, etc.). Esta acci√≥n NO se puede deshacer.`)) {
                            applyChanges();
                        } else {
                            statusEl.textContent = 'Restauraci√≥n cancelada.';
                            statusEl.style.color = '#6c757d';
                            showToast("Restauraci√≥n cancelada por el usuario.", "info");
                        }
                    } else {
                        statusEl.textContent = 'PIN incorrecto. Restauraci√≥n cancelada.';
                        statusEl.style.color = '#EF4444';
                        showToast('PIN incorrecto.', 'error');
                    }
                },
                () => {
                    statusEl.textContent = 'Restauraci√≥n cancelada.';
                    statusEl.style.color = '#6c757d';
                }
            );
        }
    } else if (result.status === 'not_found' && !isAutoLoad) {
        statusEl.textContent = `No se encontr√≥ backup para "${primaryId}".`;
        statusEl.style.color = '#EF4444';
        showToast('Backup no encontrado.', 'error not-found');
    } else if (!isAutoLoad) {
        statusEl.textContent = `Error al recuperar: ${result.message}`;
        statusEl.style.color = '#EF4444';
        showToast(`Error de recuperaci√≥n: ${result.message}`, 'error');
    }
}
    
    // ===================================================================
    // NOMBRE: getRandomSpeedMultiplierForManeuver
    // RESUMEN: Devuelve un multiplicador aleatorio de velocidad para simular variaciones en las maniobras.
    function getRandomSpeedMultiplierForManeuver(maneuver) {
        const type = maneuver.type || '';
        const modifier = maneuver.modifier || '';
        let min, max;
        if (type === 'roundabout' || type === 'rotary' || modifier.includes('sharp') || modifier.includes('uturn')) {
            min = -0.40;
            max = 0.20;
        } else if (type === 'turn' || type === 'fork' || type === 'merge' || type === 'end of road') {
            min = -0.30;
            max = 0.10;
        } else {
            min = -0.25;
            max = 0.35;
        }
        return Math.random() * (max - min) + min;
    }

// ===================================================================
// NOMBRE: addRouteToRecents 
// RESUMEN: A√±ade una ruta o destino al historial, evitando duplicados por nombre
function addRouteToRecents(routeObject) {
    if (!routeObject || !routeObject.waypoints || routeObject.waypoints.length < 1) {
        return;
    }
    const RECENT_ROUTES_KEY = 'boardinggate_recent_routes';
    const MAX_RECENT_ROUTES = 3; 
    let recentRoutes = [];
    try {
        recentRoutes = JSON.parse(localStorage.getItem(RECENT_ROUTES_KEY)) || [];
    } catch (e) {
        recentRoutes = [];
    }

    let simplifiedRoute;
    const waypointsForCheck = routeObject.waypoints;
    const isSingleDestination = waypointsForCheck.length === 1 || (waypointsForCheck.length === 2 && (waypointsForCheck[0].type === 'S' || waypointsForCheck[0].isRecalculatedStart));

    if (isSingleDestination) {
        const finalWaypoint = waypointsForCheck[waypointsForCheck.length - 1];
        simplifiedRoute = {
            name: routeObject.name,
            waypoints: sanitizeWaypointsForStorage([finalWaypoint]), // Guardamos solo el destino
            timestamp: new Date().toISOString()
        };
    } else {
        simplifiedRoute = {
            name: routeObject.name,
            waypoints: sanitizeWaypointsForStorage(waypointsForCheck), // Guardamos la ruta completa
            timestamp: new Date().toISOString()
        };
    }
    
    const uniqueRecentRoutes = recentRoutes.filter(item => item.name !== simplifiedRoute.name);
    
    uniqueRecentRoutes.unshift(simplifiedRoute);
    const finalRecentRoutes = uniqueRecentRoutes.slice(0, MAX_RECENT_ROUTES);
    localStorage.setItem(RECENT_ROUTES_KEY, JSON.stringify(finalRecentRoutes));
    markCacheAsDirty(); 
}
    
// ===================================================================
// NOMBRE: addModalAutoCloseTimer
// RESUMEN: A√±ade un temporizador de autocierre a un modal.
function addModalAutoCloseTimer(modalElement, closeButtonElement, modalId, duration = 90000) {
    if (!modalElement || !closeButtonElement || !modalId) {
        return;
    }
    modalElement.dataset.modalTimerId = modalId;
    clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId);
    let countdown = duration / 1000;
    const originalButtonText = closeButtonElement.textContent.split(' (')[0];
    const countdownSpanId = `modal-countdown-${modalId}`;
    let countdownSpan = closeButtonElement.querySelector(`.button-countdown-timer`);
    if (!countdownSpan) {
        countdownSpan = document.createElement('span');
        countdownSpan.className = 'button-countdown-timer';
        countdownSpan.style.marginLeft = '5px';
        countdownSpan.style.fontWeight = 'normal';
        closeButtonElement.appendChild(countdownSpan);
    }
    countdownSpan.textContent = ` ${countdown}`;
    const intervalId = setInterval(() => {
        countdown--;
        if (countdownSpan && document.body.contains(countdownSpan)) {
          countdownSpan.textContent = ` ${countdown}`;
        }
        if (countdown <= 0) {
            if (globalModalTimers[modalId]) {
                clearInterval(globalModalTimers[modalId].intervalId);
                delete globalModalTimers[modalId];
            }
            if (closeButtonElement && document.body.contains(closeButtonElement)) {
                closeButtonElement.click();
            } else if (modalElement && modalElement.parentNode) {
                 if (!STATIC_MODAL_IDS.includes(modalElement.id)) {
                    modalElement.parentNode.removeChild(modalElement);
                 } else {
                    modalElement.classList.add('hidden');
                 }
            }
        }
    }, 1000);
    const resetTimerHandler = () => {
        if (!globalModalTimers[modalId] || !globalModalTimers[modalId].intervalId) return;
        clearInterval(globalModalTimers[modalId].intervalId);
        countdown = duration / 1000;
        if (countdownSpan && document.body.contains(countdownSpan)) {
           countdownSpan.textContent = ` ${countdown}`;
        }
        const newIntervalId = setInterval(() => {
            countdown--;
            if (countdownSpan && document.body.contains(countdownSpan)) {
                countdownSpan.textContent = ` ${countdown}`;
            }
            if (countdown <= 0) {
                if (globalModalTimers[modalId]) {
                    clearInterval(globalModalTimers[modalId].intervalId);
                    delete globalModalTimers[modalId];
                }
                if (closeButtonElement && document.body.contains(closeButtonElement)) {
                    closeButtonElement.click();
                } else if (modalElement && modalElement.parentNode) {
                    if (!STATIC_MODAL_IDS.includes(modalElement.id)) {
                       modalElement.parentNode.removeChild(modalElement);
                    } else {
                       modalElement.classList.add('hidden');
                    }
                }
            }
        }, 1000);
        globalModalTimers[modalId].intervalId = newIntervalId;
    };
    modalElement.addEventListener('click', resetTimerHandler);
    modalElement.addEventListener('touchstart', resetTimerHandler, { passive: true });
    modalElement.addEventListener('input', resetTimerHandler);
    modalElement.addEventListener('scroll', resetTimerHandler, { passive: true });
    globalModalTimers[modalId] = {
        intervalId: intervalId,
        resetHandler: resetTimerHandler,
        modalElement: modalElement,
        closeButtonElement: closeButtonElement,
        countdownSpan: countdownSpan
    };
}
// ===================================================================
// NOMBRE: restoreBackup
// RESUMEN: Restaura los datos locales desde un c√≥digo de backup manual.
function restoreBackup() {
    const restoreInput = document.getElementById('config-restore-input');
    const backupStringBase64 = restoreInput.value.trim();
    const statusEl = document.getElementById('config-restore-status');
    statusEl.textContent = '';
    if (!backupStringBase64) {
        statusEl.textContent = 'Pega el c√≥digo de backup primero.';
        statusEl.style.color = '#EF4444';
        return;
    }
    try {
        const backupString = decodeURIComponent(escape(atob(backupStringBase64)));
        const backupData = JSON.parse(backupString);
        let restoredCount = 0;
        let incompatibleCount = 0;
        if (confirm('Esto sobreescribir√° tus datos actuales con los del backup. ¬øEst√°s seguro?')) {
            Object.keys(backupData).forEach(key => {
                if (managedKeys.includes(key)) {
                    localStorage.setItem(key, backupData[key]);
                    restoredCount++;
                } else {
                    incompatibleCount++;
                }
            });
            loadCustomData();
            loadSavedSettings();
            updateUserIdDisplay();
    
            markCacheAsDirty(); 
            statusEl.textContent = `Restauraci√≥n completada. ${restoredCount} claves restauradas. ${incompatibleCount} claves ignoradas (incompatibles). La p√°gina se recargar√°.`;
            statusEl.style.color = '#28a745';
            showToast('Restauraci√≥n completada. Recargando...', 'success');
            setTimeout(() => location.reload(), 2500);
        } else {
             statusEl.textContent = 'Restauraci√≥n cancelada.';
             statusEl.style.color = '#6c757d';
        }
    } catch (e) {
        statusEl.textContent = 'Error: C√≥digo de backup inv√°lido o corrupto.';
        statusEl.style.color = '#EF4444';
        showToast('Error en el c√≥digo de backup', 'error');
    }
}  
    
    // ===================================================================
    // NOMBRE: clearNavigationGraph
    // RESUMEN: Limpia y oculta la gr√°fica de navegaci√≥n.
    function clearNavigationGraph() {
        if (graphIntervalTimer) {
            clearInterval(graphIntervalTimer);
            graphIntervalTimer = null;
        }
        if (navigationChart) {
            navigationChart.destroy();
            navigationChart = null;
        }
        const graphCard = document.getElementById('navigation-graph-card');
        if (graphCard) {
            graphCard.classList.add('hidden');
        }
        graphDataPoints = { speed: [], altitude: [] };
        graphLabels = [];
    }


// ===================================================================
// NOMBRE: hideNavigationUI
// RESUMEN: Oculta los elementos de la interfaz de usuario de navegaci√≥n.
function hideNavigationUI() {
    const topInfoBar = document.getElementById('navigation-top-info-bar');
    const bottomProgressBar = document.getElementById('navigation-bottom-progress-bar');
    const startNavButton = document.getElementById('start-navigation-button');
    const saveRouteButton = document.getElementById('save-route-button');
    const reorderBtn = document.getElementById('reorder-route-stages-button');
    const simulateBtn = document.getElementById('simulate-route-button');
    const toggleSimulateGpsBtn = document.getElementById('toggle-simulate-gps-button');
    const graphCard = document.getElementById('navigation-graph-card');
    const miniNavCard = document.getElementById('mini-nav-info-card');
    if (topInfoBar) topInfoBar.style.display = 'none';
    if (bottomProgressBar) bottomProgressBar.style.display = 'none';
    if (miniNavCard) miniNavCard.style.display = 'none';
    if (saveRouteButton) saveRouteButton.classList.add('hidden');
    if (reorderBtn) reorderBtn.style.display = 'none';
    if (simulateBtn) simulateBtn.style.display = 'none';
    if (graphCard) graphCard.classList.add('hidden');
    hideIntersectionPreviewMap();
}
    
    // ===================================================================
    // NOMBRE: showNavigationUIElementsForPlanning
    // RESUMEN: Muestra los elementos de la UI para la planificaci√≥n de rutas.
    function showNavigationUIElementsForPlanning() {
        const topInfoBar = document.getElementById('navigation-top-info-bar');
        const bottomProgressBar = document.getElementById('navigation-bottom-progress-bar');
        if (!navigationCurrentRouteData || !navigationCurrentRouteData.routes || navigationCurrentRouteData.routes.length === 0 || navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
            if (topInfoBar) topInfoBar.style.display = 'none';
            if (bottomProgressBar) bottomProgressBar.style.display = 'none';
            hideMapInfoOverlay();
            hideIntersectionPreviewMap();
        } else {
            if (topInfoBar) topInfoBar.style.display = 'flex';
            if (bottomProgressBar) bottomProgressBar.style.display = 'flex';
            let carDistAlongRoutePlan = 0;
            const currentCarPosForShowUI = navigationCurrentLocation;
            if (currentCarPosForShowUI && navigationMapInstance && navigationCurrentRouteData.routes[0] && typeof turf !== 'undefined') {
                try {
                    const carPointTurf = turf.point([currentCarPosForShowUI.longitude, currentCarPosForShowUI.latitude]);
                    const routeLineStringTurf = turf.lineString(navigationCurrentRouteData.routes[0].geometry.coordinates);
                    const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                    const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                    carDistAlongRoutePlan = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                } catch(e){  }
             }
            updateTurnByTurnDisplay(navigationCurrentRouteData.routes[0], carDistAlongRoutePlan);
            showDestinationName();
        }
    }
     
    // ===================================================================
    // NOMBRE: getManeuverInstructionText
    // RESUMEN: Convierte una maniobra de OSRM en un texto legible.
    function getManeuverInstructionText(maneuver) {
        if (!maneuver) return '';
        const type = maneuver.type || '';
        const modifier = maneuver.modifier || '';
        let exit = maneuver.exit;
        let key = `${type}-${modifier}`;
        let text = maneuverTexts[key];
        if (!text) {
            key = `${type}-`;
            text = maneuverTexts[key];
        }
        if (!text && type === 'turn' && !modifier) {
            text = maneuverTexts['turn-'] || type.replace(/-/g, ' ');
        } else if (!text) {
            text = type.replace(/-/g, ' ');
        }
        const roundaboutExitTypes = ['roundabout turn', 'exit roundabout', 'rotary', 'roundabout'];
        if (roundaboutExitTypes.includes(type) && typeof exit === 'number' && exit > 0) {
             const ordinals = ["", "primera", "segunda", "tercera", "cuarta", "quinta"];
             const ordinalText = (exit >= 1 && exit <= 5) ? ordinals[exit] : `${exit}¬™`;
             text = `Sal en la rotonda en la ${ordinalText} salida`;
        }
        let baseText = text.charAt(0).toUpperCase() + text.slice(1);
        return baseText;
    }  

// ===================================================================
// NOMBRE: formatDeviationForMiniCard (VERSI√ìN FINAL CON SOMBREADO HEREDADO)
// RESUMEN: Formatea la desviaci√≥n aplicando solo el color, para que herede el sombreado del contenedor.
// ===================================================================
function formatDeviationForMiniCard(milliseconds) {
    if (typeof milliseconds !== 'number' || isNaN(milliseconds) || Math.abs(milliseconds) < 1000) {
        const style = `color: white;`;
        return `<span class="eta-deviation" style="${style}">[ 00:00 ]</span>`;
    }
    
    const totalSeconds = Math.round(Math.abs(milliseconds) / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const sign = milliseconds > 0 ? '+' : '-';
    
    const textColor = milliseconds > 0 ? '#F0B7B4' : '#C7FCCB';
    
    const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

    const style = `color: ${textColor};`;
  
    return `<span class="eta-deviation" style="${style}">[ ${sign}${formattedTime} ]</span>`;
}
    
// ===================================================================
// NOMBRE: formatDeviation 
// RESUMEN: Formatea la desviaci√≥n de tiempo ETA, devolviendo directamente
function formatDeviation(milliseconds) {
    if (typeof milliseconds !== 'number' || isNaN(milliseconds)) {
        return '';
    }
    if (Math.abs(milliseconds) < 1000) {
        return `<span class="eta-deviation">[00:00]</span>`;
    }
    const totalSeconds = Math.round(Math.abs(milliseconds) / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const sign = milliseconds > 0 ? '+' : '-';
    const colorClass = milliseconds > 0 ? 'positive' : 'negative';
    const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    return `<span class="eta-deviation ${colorClass}">[${sign}${formattedTime}]</span>`;
}    
    
    // ===================================================================
    // NOMBRE: parseCoordinateFilter
    // RESUMEN: Parsea y aplica un filtro de coordenadas (valor √∫nico o rango).
   function parseCoordinateFilter(filterValue, coordinate) {
        if (!filterValue) return true;
        const parts = filterValue.trim().split(/\s+/).map(s => parseFloat(s.replace(',','.'))).filter(n => !isNaN(n));
        if (parts.length === 1) {
            return Math.abs(coordinate - parts[0]) < COORD_EPSILON;
        } else if (parts.length === 2) {
            const minVal = Math.min(parts[0], parts[1]);
            const maxVal = Math.max(parts[0], parts[1]);
            return coordinate >= minVal && coordinate <= maxVal;
        } else if (parts.length === 0 && filterValue.trim() !== "") {
            return false;
        }
        return true;
    }
    
// ===================================================================
// NOMBRE: closeOtherModals 
// RESUMEN: Se ha eliminado 'address-suggestions-modal' de la lista
function closeOtherModals(modalToKeepOpenId = null) {
    const STATIC_MODAL_IDS = ['config-modal', 'versions-modal-overlay', 'pin-modal-overlay', 'reorder-stages-modal', 'simulation-modal', 'locations-preview-modal', 'deviation-modal', 'arrival-stats-modal', 'simulation-speed-modal'];

    STATIC_MODAL_IDS.forEach(id => {
        if (id === modalToKeepOpenId) return;
        const modal = document.getElementById(id);
        if (modal && !modal.classList.contains('hidden')) {
            if (id === 'reorder-stages-modal') {
                const listElement = modal.querySelector('#sortable-stages-list');
                if (listElement) {
                    listElement.removeEventListener('dragstart', handleDragStartReorder);
                    listElement.removeEventListener('dragend', handleDragEndReorder);
                    listElement.removeEventListener('dragover', handleDragOverReorder);
                    listElement.removeEventListener('touchstart', handleStageTouchStart);
                    listElement.removeEventListener('touchmove', handleStageTouchMove);
                    listElement.removeEventListener('touchend', handleStageTouchEnd);
                    listElement.removeEventListener('touchcancel', handleStageTouchEnd);
                }
                if (draggedStageLi) {
                    draggedStageLi.classList.remove('dragging');
                    draggedStageLi = null;
                }
                clearTimeout(stageScrollTimeout);
                document.body.style.overflow = '';
            }
             if (id === 'deviation-modal') {
                if (deviationModalTimerId) clearInterval(deviationModalTimerId);
                deviationModalTimerId = null;
                isDeviationModalActive = false;
            }
             if (id === 'arrival-stats-modal') {
                const acceptButton = modal.querySelector('#arrival-stats-accept-button');
                if (acceptButton) clearModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal');
             }
             if (id === 'simulation-speed-modal') {
                const confirmBtn = modal.querySelector('#confirm-navigation-simulation');
                if(confirmBtn) clearModalAutoCloseTimer(modal, confirmBtn, 'simulation-speed-modal');
             }
            modal.classList.add('hidden');
            const closeBtn = modal.querySelector('button[id^="close-"], button[id*="-close"], #cancel-postpone, #close-saved-routes-modal, #cancel-reorder-stages, #config-close-modal, #close-versions-modal, #pin-submit-button, #close-simulation-modal, #close-locations-preview, #deviation-accept, #arrival-stats-accept-button, #cancel-simulation-speed');
            if (closeBtn) clearModalAutoCloseTimer(modal, closeBtn, id.replace(/-/g, '_') || `modal_timer_${Date.now()}`);
             if (id === 'simulation-modal') {
                 if (simulationModalTimer) {
                     clearTimeout(simulationModalTimer);
                     simulationModalTimer = null;
                 }
                 hideIntersectionPreviewMap();
             }
        }
    });
    document.querySelectorAll(
        '.choice-modal, .edit-modal, .edit-info-modal, .help-modal, .reminder-modal, .reminder-table-modal, #postpone-options-modal, .saved-locations-modal, #reminders-map-help-modal-instance'
    ).forEach(m => {
        if (m.id === modalToKeepOpenId) return;
        if (m.parentNode) {
             const closeBtn = m.querySelector('button[id^="close-"], button[id*="-close"], #cancel-postpone');
             if(closeBtn) clearModalAutoCloseTimer(m, closeBtn, m.id.replace(/-/g, '_') || `modal_timer_${Date.now()}`);
             m.remove();
        }
    });
     if (modalToKeepOpenId !== 'unified-reminder-window') {
        hideUnifiedReminderWindow();
     }
}    
// ===================================================================
// NOMBRE: showConfigModal 
// RESUMEN: Muestra el modal de configuraci√≥n principal, incluyendo la hora de inicio de la sesi√≥n de mapa activa.
function showConfigModal() {
    closeOtherModals('config-modal');
    const modal = document.getElementById('config-modal');
    if (!modal) return;

    const sessionStatusEl = document.getElementById('map-session-status');
    if (sessionStatusEl) {
        if (mapSessionStartTime) {
            const sessionDate = new Date(mapSessionStartTime);
            const formattedTime = sessionDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            sessionStatusEl.textContent = `(Sesi√≥n de mapa abierta: ${formattedTime})`;
        } else {
            sessionStatusEl.textContent = '(No hay sesi√≥n de mapa activa)';
        }
    }
  
    const termsAccepted = localStorage.getItem('termsAccepted_v1') === 'true';
    const tabButtons = modal.querySelectorAll('.config-tab-button');
    const tabContents = modal.querySelectorAll('.config-tab-content');

    if (!termsAccepted) {
        tabButtons.forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.tabTarget !== '#tab-content-normas') {
                btn.disabled = true; 
                btn.style.cursor = 'not-allowed';
                btn.style.opacity = '0.5';
            }
        });
        tabContents.forEach(content => content.classList.remove('active'));
        
        modal.querySelector('.config-tab-button[data-tab-target="#tab-content-normas"]').classList.add('active');
        modal.querySelector('#tab-content-normas').classList.add('active');
    } else {
        tabButtons.forEach(btn => {
            btn.disabled = false;
            btn.style.cursor = 'pointer';
            btn.style.opacity = '1';
            btn.classList.toggle('active', btn.dataset.tabTarget === '#tab-content-usuario');
        });
        tabContents.forEach(content => {
            content.classList.toggle('active', content.id === 'tab-content-usuario');
        });
    }

    modal.querySelectorAll('.status-message').forEach(msg => msg.textContent = '');
    modal.querySelectorAll('input[type="text"], input[type="number"], textarea').forEach(input => {
        if (!['user-id', 'config-pin-set', 'config-pin-confirm'].includes(input.id)) {
            input.value = '';
        }
    });
    modal.querySelector('#config-pin-set').value = '';
    modal.querySelector('#config-pin-confirm').value = '';
    modal.querySelector('#config-backup-display').value = '';
    modal.querySelector('#config-restore-input').value = '';
    if(modal.querySelector('#config-backup-display')) modal.querySelector('#config-backup-display').style.display = 'none';
    const userIdInput = modal.querySelector('#user-id');
    const storedUserId = localStorage.getItem('userData_userId');
    if (userIdInput) userIdInput.value = storedUserId || '';
    
    const teslaModelInput = modal.querySelector('#tesla-model');
    if (teslaModelInput) teslaModelInput.value = localStorage.getItem('userData_teslaModel') || '';
    const teslaYearInput = modal.querySelector('#tesla-year');
    if (teslaYearInput) teslaYearInput.value = localStorage.getItem('userData_teslaYear') || '';
    const teslaProvinceInput = modal.querySelector('#tesla-province');
    if (teslaProvinceInput) teslaProvinceInput.value = localStorage.getItem('userData_teslaProvince') || '';
    const allowDmsCheckbox = modal.querySelector('#allow-dms');
    if (allowDmsCheckbox) allowDmsCheckbox.checked = JSON.parse(localStorage.getItem('userData_allowDMs')) || false;
    
    const directToNavCheckbox = document.getElementById('config-direct-to-nav');
    if (directToNavCheckbox) directToNavCheckbox.checked = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;

    const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
    if (autoBackupCheckbox) {
        const savedAutoBackup = localStorage.getItem('boardinggate_autoBackupOnLoad');
        autoBackupCheckbox.checked = savedAutoBackup === null ? true : JSON.parse(savedAutoBackup);
    }

    modal.classList.remove('hidden');
    const closeButtonConfig = modal.querySelector('#config-close-modal');
    addModalAutoCloseTimer(modal, closeButtonConfig, 'config-modal', 120000);
}  
 
// ===================================================================
// NOMBRE: translatePoiCategory (VERSI√ìN CON TRADUCCI√ìN MANUAL)
// RESUMEN: Traduce y formatea las categor√≠as de POI recibidas en ingl√©s desde la API de Mapbox.
function translatePoiCategory(categories) {
    if (!Array.isArray(categories) || categories.length === 0) {
        return 'General';
    }

    const MAPBOX_CATEGORY_TRANSLATIONS = {
        'restaurant': 'Restaurante',
        'cafe': 'Cafeter√≠a',
        'bar': 'Bar',
        'fast_food': 'Comida R√°pida',
        'food_court': 'Zona de Restaurantes',
        'gas_station': 'Gasolinera',
        'parking': 'Parking',
        'hotel': 'Hotel',
        'motel': 'Motel',
        'lodging': 'Alojamiento',
        'supermarket': 'Supermercado',
        'grocery': 'Tienda de Alimentaci√≥n',
        'convenience': 'Tienda de Conveniencia',
        'shopping': 'Tiendas',
        'mall': 'Centro Comercial',
        'clothing_store': 'Tienda de Ropa',
        'hardware_store': 'Ferreter√≠a',
        'home_goods_store': 'Tienda de Hogar',
        'pharmacy': 'Farmacia',
        'hospital': 'Hospital',
        'clinic': 'Cl√≠nica',
        'doctor': 'M√©dico',
        'dentist': 'Dentista',
        'atm': 'Cajero Autom√°tico',
        'bank': 'Banco',
        'tourist_attraction': 'Atracci√≥n Tur√≠stica',
        'landmark': 'Lugar de Inter√©s',
        'museum': 'Museo',
        'park': 'Parque',
        'zoo': 'Zoo',
        'airport': 'Aeropuerto',
        'bus_station': 'Estaci√≥n de Autobuses',
        'train_station': 'Estaci√≥n de Tren',
        'subway_station': 'Estaci√≥n de Metro',
        'car_rental': 'Alquiler de Coches',
        'car_repair': 'Taller Mec√°nico',
        'car_wash': 'Lavado de Coches',
        'library': 'Biblioteca',
        'school': 'Colegio',
        'university': 'Universidad',
        'post_office': 'Oficina de Correos',
        'police': 'Polic√≠a',
        'fire_station': 'Bomberos',
        'cinema': 'Cine',
        'night_club': 'Discoteca',
        'stadium': 'Estadio',
        'gym': 'Gimnasio',
        'golf_course': 'Campo de Golf',
        'beach': 'Playa',
        'campground': 'Camping',
        'marina': 'Puerto Deportivo'
    };

    const translatedCategories = categories.map(englishCategory => {
        const translated = MAPBOX_CATEGORY_TRANSLATIONS[englishCategory];
        if (translated) {
            return translated;
        } else {
            const cleaned = englishCategory.replace(/_/g, ' ');
            return cleaned.charAt(0).toUpperCase() + cleaned.slice(1);
        }
    });

    return translatedCategories.join(', ');
}

// ===================================================================
// NOMBRE: showPDRsFilterModal
// RESUMEN: Muestra un modal de filtro que se adapta si hay o no una ruta cargada.
function showPDRsFilterModal() {
    const mapContainer = document.getElementById('reminders-location-map-modal');
    if (!mapContainer || !navigationMapInstance) {
        showToast("El mapa de navegaci√≥n debe estar abierto para usar los filtros.", "error");
        return;
    }

    const hasRoute = navigationMapInstance.getSource('route') && 
                     navigationMapInstance.getSource('route')._data &&
                     navigationMapInstance.getSource('route')._data.geometry &&
                     navigationMapInstance.getSource('route')._data.geometry.coordinates &&
                     navigationMapInstance.getSource('route')._data.geometry.coordinates.length > 1;

    const PDR_MIN_POWER_KEY = 'boardinggate_pdrFilterMinPower';
    const PDR_MAX_POWER_KEY = 'boardinggate_pdrFilterMaxPower';
    const PDR_DISTANCE_KEY = 'boardinggate_pdrFilterDistance';
    const PDR_RADIUS_KEY = 'boardinggate_pdrFilterRadius';

    const savedMinPower = parseInt(localStorage.getItem(PDR_MIN_POWER_KEY)) || 30;
    const savedMaxPower = parseInt(localStorage.getItem(PDR_MAX_POWER_KEY)) || 600;
    const savedDistance = parseInt(localStorage.getItem(PDR_DISTANCE_KEY)) || 20;
    const savedRadius = parseInt(localStorage.getItem(PDR_RADIUS_KEY)) || 15;
    let distanceControlHtml;
    if (hasRoute) {
        distanceControlHtml = `
            <div id="distance-slider-container" class="filter-group">
                <label id="distance-range-label">Distancia M√°xima a la Ruta: ${savedDistance} km</label> 
                <div class="slider-container single-slider-container">
                    <div class="slider-track"></div>
                    <div class="slider-range" id="distance-slider-range"></div>
                    <div class="slider-thumb" id="distance-thumb"></div>
                </div>
            </div>`;
    } else {
        distanceControlHtml = `
            <div id="radius-slider-container" class="filter-group">
                <label id="radius-range-label">Radio de B√∫squeda: ${savedRadius} km</label> 
                <div class="slider-container single-slider-container">
                    <div class="slider-track"></div>
                    <div class="slider-range" id="radius-slider-range"></div>
                    <div class="slider-thumb" id="radius-thumb"></div>
                </div>
            </div>`;
    }

    const existingModal = document.getElementById('pdrs-filter-modal-overlay');
    if (existingModal) existingModal.remove();

    const savedOperatorFilter = localStorage.getItem('boardinggate_operator_filter') || '';
    const modalOverlay = document.createElement('div');
    modalOverlay.id = 'pdrs-filter-modal-overlay';
    modalOverlay.className = 'filter-modal-overlay';
    
    modalOverlay.innerHTML = `
        <div class="filter-modal-content">
            <h2>FILTRO PUNTOS DE CARGA</h2>
            <div class="filter-group">
                <label for="operator-filter-input">Filtrar operadores:</label>
                <div style="position: relative; width: 90%; margin: 5px auto 0 auto;">
                    <input type="text" id="operator-filter-input" value="${savedOperatorFilter}" placeholder="Ej: Zunder Iberdrola">
                    <button id="clear-operator-filter" title="Limpiar filtro de operadores" style="display: none;">√ó</button>
                </div>
            </div>
            <div class="filter-group">
                <label id="power-range-label">Potencia: ${savedMinPower} kW - ${savedMaxPower} kW</label> 
                <div class="slider-container">
                    <div class="slider-track"></div>
                    <div class="slider-range" id="power-slider-range"></div>
                    <div class="slider-thumb left" id="power-thumb-min"></div>
                    <div class="slider-thumb right" id="power-thumb-max"></div>
                </div>
            </div>
            
            <div class="ocm-color-legend">
                <div class="ocm-color-legend-item">
                    <div class="ocm-color-legend-icon" style="border-color: #0f130c;"></div>
                    <span>‚â§50kW</span>
                </div>
                <div class="ocm-color-legend-item">
                    <div class="ocm-color-legend-icon" style="border-color: #007863;"></div>
                    <span>‚â§100kW</span>
                </div>
                <div class="ocm-color-legend-item">
                    <div class="ocm-color-legend-icon" style="border-color: rgb(30, 144, 255);"></div>
                    <span>‚â§250kW</span>
                </div>
                <div class="ocm-color-legend-item">
                    <div class="ocm-color-legend-icon" style="border-color: #de2e03;"></div>
                    <span>>250kW</span>
                </div>
            </div>

            ${distanceControlHtml}
            
            <div class="filter-group" style="text-align: left; margin-top: 20px;">
                <label id="search-in-view-label">
                    <input type="checkbox" id="search-in-view-checkbox">
                    Buscar en la zona del mapa que est√©s viendo ahora
                </label>
            </div>

            <button id="accept-filters-btn">Aceptar <span class="button-countdown-timer unified-countdown-style"></span></button>

            <div class="ocm-modal-info-footer">
                <p><strong>(*) C√≥mo buscar:</strong> Si hay una ruta cargada, la b√∫squeda por defecto es sobre el trazado. Si no hay ruta, en un radio desde el centro. Para buscar siempre en la vista actual, marque la casilla superior.</p>
                <p><strong>(*) Secuencia del bot√≥n:</strong> 1¬™ Pulsaci√≥n: Abre filtros. | 2¬™ Pulsaci√≥n: Muestra solo los m√°s econ√≥micos. | 3¬™ Pulsaci√≥n: Limpia el mapa de PDRs.</p>
                <p style="margin-top:10px; font-style:italic;">Datos proporcionados por <a href="https://openchargemap.org" target="_blank">Open Charge Map</a>.</p>
            </div>
        </div>
    `;

    mapContainer.appendChild(modalOverlay);
    
    const PDR_SEARCH_IN_VIEW_KEY = 'boardinggate_pdrSearchInView';
    const searchInViewCheckbox = document.getElementById('search-in-view-checkbox');
    const distanceSliderContainer = document.getElementById('distance-slider-container') || document.getElementById('radius-slider-container');
    
    const updateControlsState = () => {
        if (searchInViewCheckbox.checked) {
            distanceSliderContainer.style.opacity = '0.5';
            distanceSliderContainer.style.pointerEvents = 'none';
        } else {
            distanceSliderContainer.style.opacity = '1';
            distanceSliderContainer.style.pointerEvents = 'auto';
        }
    };
    
    const savedSearchInView = localStorage.getItem(PDR_SEARCH_IN_VIEW_KEY) === 'true';
    searchInViewCheckbox.checked = savedSearchInView;
    searchInViewCheckbox.addEventListener('change', () => {
        localStorage.setItem(PDR_SEARCH_IN_VIEW_KEY, searchInViewCheckbox.checked);
        updateControlsState();
        markCacheAsDirty(); 
    });
    
    updateControlsState();

    const operatorInput = document.getElementById('operator-filter-input');
    const clearOperatorButton = document.getElementById('clear-operator-filter');
    
    const toggleClearButtonVisibility = () => {
        clearOperatorButton.style.display = operatorInput.value.trim() ? 'block' : 'none';
    };

    operatorInput.addEventListener('input', toggleClearButtonVisibility);
    clearOperatorButton.addEventListener('click', () => {
        operatorInput.value = '';
        toggleClearButtonVisibility();
        operatorInput.focus();
    });
    toggleClearButtonVisibility();

    const setupSlider = (idPrefix, minVal, maxVal, defaultMin, defaultMax, unit, isRange = true) => {
        const thumbMax = document.getElementById(`${idPrefix}-thumb` + (isRange ? '-max' : ''));
        if (!thumbMax) return () => ({ min: 0, max: 0 });
        const container = thumbMax.parentElement;
        const range = document.getElementById(`${idPrefix}-slider-range`);
        const label = document.getElementById(`${idPrefix}-range-label`);
        const thumbMin = isRange ? document.getElementById(`${idPrefix}-thumb-min`) : null;
        let currentMin = defaultMin; 
        let currentMax = defaultMax;

        const updateVisuals = () => {
            const minPercent = isRange ? ((currentMin - minVal) / (maxVal - minVal)) * 100 : 0;
            const maxPercent = ((currentMax - minVal) / (maxVal - minVal)) * 100;
            
            if (isRange && thumbMin) thumbMin.style.left = `${minPercent}%`;
            thumbMax.style.left = `${maxPercent}%`;
            range.style.left = `${minPercent}%`;
            range.style.width = `${maxPercent - minPercent}%`;
            
            if(isRange){
                label.textContent = `Potencia: ${Math.round(currentMin)} ${unit} - ${Math.round(currentMax)} ${unit}`;
            } else {
                label.textContent = `${hasRoute ? 'Distancia M√°xima a la Ruta' : 'Radio de B√∫squeda'}: ${Math.round(currentMax)} ${unit}`;
            }
        };

        const onDrag = (e, thumb) => {
            const rect = container.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let percent = ((clientX - rect.left) / rect.width) * 100;
            percent = Math.max(0, Math.min(100, percent));
            
            let value = minVal + (percent / 100) * (maxVal - minVal);
            
            if (isRange && thumb === thumbMin) {
                currentMin = Math.min(value, currentMax);
            } else {
                currentMax = isRange ? Math.max(value, currentMin) : value;
            }
            updateVisuals();
        };

        const thumbsToSetup = isRange ? [thumbMin, thumbMax] : [thumbMax];
        thumbsToSetup.forEach(thumb => {
            const startDrag = (e) => {
                const moveHandler = (moveEvent) => onDrag(moveEvent, thumb);
                const endDrag = () => {
                    document.removeEventListener('mousemove', moveHandler);
                    document.removeEventListener('mouseup', endDrag);
                    document.removeEventListener('touchmove', moveHandler);
                    document.removeEventListener('touchend', endDrag);
                };
                document.addEventListener('mousemove', moveHandler);
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchmove', moveHandler);
                document.addEventListener('touchend', endDrag);
            };
            thumb.addEventListener('mousedown', startDrag);
            thumb.addEventListener('touchstart', startDrag);
        });
        
        updateVisuals();
        return () => ({ min: isRange ? currentMin : minVal, max: currentMax });
    };

    const getPowerValues = setupSlider('power', 7, 2000, savedMinPower, savedMaxPower, 'kW', true);
    const getDistanceValues = hasRoute ? setupSlider('distance', 0, 50, 0, savedDistance, 'km', false) : () => ({});
    const getRadiusValues = !hasRoute ? setupSlider('radius', 1, 100, 1, savedRadius, 'km', false) : () => ({});

    const acceptButton = document.getElementById('accept-filters-btn');
    acceptButton.addEventListener('click', () => {
        const operatorFilterValue = document.getElementById('operator-filter-input').value;
        localStorage.setItem('boardinggate_operator_filter', operatorFilterValue);

        const powerFilters = getPowerValues();
        localStorage.setItem(PDR_MIN_POWER_KEY, Math.round(powerFilters.min));
        localStorage.setItem(PDR_MAX_POWER_KEY, Math.round(powerFilters.max));

        let searchConfig;
        if (hasRoute) {
            const distanceFilters = getDistanceValues();
            localStorage.setItem(PDR_DISTANCE_KEY, Math.round(distanceFilters.max));
            searchConfig = { type: 'route', distanceFilters };
        } else {
            const radiusFilters = getRadiusValues();
            localStorage.setItem(PDR_RADIUS_KEY, Math.round(radiusFilters.max));
            searchConfig = { type: 'radius', radiusKm: radiusFilters.max, center: navigationMapInstance.getCenter() };
        }
        markCacheAsDirty(); 
        
        if (navigationFollowUser) {
            const locateMeButton = document.getElementById('locate-me-on-reminders-map');
            if (locateMeButton) {
                handleLocateMeClick(locateMeButton);
                showToast('Seguimiento pausado por 1 minuto para explorar el mapa.', 'info', 4000);
                if (window.followMeReactivationTimer) {
                    clearTimeout(window.followMeReactivationTimer);
                }
                window.followMeReactivationTimer = setTimeout(() => {
                    if (!navigationFollowUser) {
                        handleLocateMeClick(locateMeButton);
                        showToast('Seguimiento autom√°tico reactivado.', 'info');
                    }
                    window.followMeReactivationTimer = null;
                }, 60000);
            }
        }

        modalOverlay.remove();
        findChargingPointsOnRoute(powerFilters, searchConfig);
    });

    addModalAutoCloseTimer(modalOverlay, acceptButton, 'pdrs-filter-modal', 20000);
}
    
// ===================================================================
// NOMBRE: findExistingWaypointAtCoords
// RESUMEN: Busca si ya existe una etapa de ruta en las coordenadas dadas.
function findExistingWaypointAtCoords(lat, lon, toleranceMeters = 10) {
    for (const waypoint of navigationWaypoints) {
        if (waypoint && !waypoint.isInternal) {
            const distance = calculateDistance(lat, lon, waypoint.lat, waypoint.lng);
            if (distance <= toleranceMeters) {
                return waypoint;
            }
        }
    }
    return null;
}
    
// ===================================================================
// NOMBRE: enablePoiInteractivit
// RESUMEN: √önicamente cambia el cursor a "puntero" al pasar sobre los POIs.
function enablePoiInteractivity(mapInstance) {
    if (!mapInstance) return;

    const interactiveLayers = [
        'poi-label', 'transit-label', 'airport-label', 'settlement-label', 
        'natural-label', 'water-point-label'
    ];

    mapInstance.on('mouseenter', interactiveLayers, () => {
        mapInstance.getCanvas().style.cursor = 'pointer';
    });
    mapInstance.on('mouseleave', interactiveLayers, () => {
        mapInstance.getCanvas().style.cursor = '';
    });
}
    
// ===================================================================
// NOMBRE: loadAndAddMapImages 
// RESUMEN: Carga im√°genes y contin√∫a aunque alguna falle.
async function loadAndAddMapImages(mapInstance) {
    const imagesToLoad = [
        { name: 'reminder-icon', url: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png' },
        { name: 'radar-generic-icon', url: 'PNG/RADARAQUI.PNG' },
        { name: 'pdr-icon-simple', url: 'PNG/pdrs.png' },
        { name: 'radar-no-speed-icon', url: 'PNG/radar.png' }, 
        { name: 'alert-1', url: 'PNG/AACCIDENTE.png' },
        { name: 'alert-2', url: 'PNG/AAVERIADO.png' },
        { name: 'alert-3', url: 'PNG/AGUARDIA22.png' },
        { name: 'alert-4', url: 'PNG/AATASCO.png' },
        { name: 'alert-5', url: 'PNG/APELIGRO.png' },
        { name: 'alert-6', url: 'PNG/ARESVALAR.png' },
        { name: 'alert-7', url: 'PNG/AOBRAS.png' },
        { name: 'alert-8', url: 'PNG/ACERRADA.png' }
    ];

    const imageLoadPromises = imagesToLoad.map(img => 
        new Promise((resolve) => { 
            if (mapInstance.hasImage(img.name)) {
                resolve();
                return;
            }
            mapInstance.loadImage(img.url, (error, image) => {
                if (error) {
                    console.error(`Error al cargar imagen ${img.name}:`, error);
                    resolve(); 
                    return;
                }
                if (!mapInstance.hasImage(img.name)) {
                    mapInstance.addImage(img.name, image, { sdf: false });
                }
                resolve();
            });
        })
    );
    await Promise.all(imageLoadPromises);
}
        
// ===================================================================
// NOMBRE: showSaveRoutePromptForSingleWaypoint (VERSI√ìN CORREGIDA Y DEFINITIVA)
// RESUMEN: Muestra el modal de guardado, usando directamente el nombre descriptivo
async function showSaveRoutePromptForSingleWaypoint(waypointObject) {
    const defaultName = `UBICACI√ìN: ${waypointObject.address}`.toUpperCase();
    
    const onSaveCallback = (confirmedName) => {
        const routeToSave = {
            name: confirmedName,
            waypoints: [{ ...waypointObject, type: 'F', label: 'F' }],
            createdAt: new Date().toISOString()
        };

        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        const existingRouteIndex = savedRoutes.findIndex(r => r.name.toUpperCase() === confirmedName);

        if (existingRouteIndex !== -1) {
            if (confirm(`Ya existe una ubicaci√≥n guardada como "${confirmedName}". ¬øDeseas sobreescribirla?`)) {
                savedRoutes[existingRouteIndex] = routeToSave;
            } else {
                showToast("Guardado cancelado", "info");
                return;
            }
        } else {
            savedRoutes.push(routeToSave);
        }

        if (savedRoutes.length > MAX_SAVED_ROUTES) {
            savedRoutes.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
            savedRoutes = savedRoutes.slice(0, MAX_SAVED_ROUTES);
        }
        localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes));
        markCacheAsDirty();
        showToast(`Ubicaci√≥n "${confirmedName}" guardada en favoritos.`, "success");
    };

    showSaveRoutePromptModal(defaultName, onSaveCallback);
} 
// ===================================================================
// NOMBRE: getGlobalPoiStats
// RESUMEN: Calcula las estad√≠sticas globales de clics en POIs de todos los usuarios.
async function getGlobalPoiStats() {
    if (!window.db) return { totalMonth: 0 };
    
    let totalMonth = 0;
    
    try {
        const usersCollectionRef = window.collection(window.db, "user_data");
        const querySnapshot = await window.getDocs(usersCollectionRef);
        
        const now = new Date();
        const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        querySnapshot.forEach(doc => {
            const data = doc.data();
            if (data.poi_clicks_last_month === currentMonthStr) {
                totalMonth += (data.poi_clicks_month || 0);
            }
        });

    } catch (error) {
        console.error("Error al obtener estad√≠sticas globales de POIs:", error);
    } 
    return { totalMonth };
}
    
// ===================================================================
// NOMBRE: updateRouteAndCarIconStyle (MODIFICADA)
// RESUMEN: Ajusta el estilo de la l√≠nea de ruta cuando ya existe, tras un cambio de capa de mapa.
function updateRouteAndCarIconStyle() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) return;

    if (navigationMapInstance.getLayer('route')) {
        const styleProps = getRouteStyleProperties();
        Object.keys(styleProps).forEach(prop => {
            navigationMapInstance.setPaintProperty('route', prop, styleProps[prop]);
        });
    }
}
    
// ===================================================================
function loadCustomData() { const savedData = localStorage.getItem('customGridData'); currentBookmarks = []; currentToggleRanges = []; customData = { bookmarks: {}, toggles: {} }; if (savedData) { try { customData = JSON.parse(savedData) || { bookmarks: {}, toggles: {} }; } catch (e) { customData = { bookmarks: {}, toggles: {} }; } } if (!customData.bookmarks) customData.bookmarks = {}; if (!customData.toggles) customData.toggles = {}; currentBookmarks = Array.from({ length: TOTAL_CELLS }).map((_, index) => { if (customData.bookmarks.hasOwnProperty(index)) { return customData.bookmarks[index] ? { ...customData.bookmarks[index] } : null; } else { const original = index < originalBookmarks.length ? originalBookmarks[index] : null; return original ? { ...original } : null; } }); currentToggleRanges = originalToggleRanges.map(originalRange => { const customToggle = customData.toggles[originalRange.start]; const rangeCopy = { ...originalRange }; if (customToggle) { if (typeof customToggle.label === 'string') rangeCopy.label = customToggle.label; if (Array.isArray(customToggle.assignedIndexes)) rangeCopy.assignedIndexes = [...customToggle.assignedIndexes]; } if (!rangeCopy.assignedIndexes) rangeCopy.assignedIndexes = Array.from({ length: rangeCopy.end - originalRange.start + 1 }, (_, i) => originalRange.start + i); return rangeCopy; }); }
     
// ===================================================================
function loadReminders() { updateReminderCount(); }

// ===================================================================
// NOMBRE: actualizarContadorRadares
// RESUMEN: Actualiza el contador num√©rico de radares en la UI del mapa.
function actualizarContadorRadares(count) {
    const contadorElement = document.getElementById('radares-ruta-count');
    if (contadorElement) {
        contadorElement.textContent = count;
        const checkbox = document.getElementById('radares-ruta-checkbox');
        contadorElement.classList.toggle('hidden', count === 0 && (!checkbox || !checkbox.checked));
    }
}
// ===================================================================
// NOMBRE: actualizarContadorTareas
// RESUMEN: Actualiza el contador num√©rico de tareas en la UI del mapa.
function actualizarContadorTareas(count) {
    const contadorElement = document.getElementById('tareas-ruta-count');
    if (contadorElement) {
        contadorElement.textContent = count;
        const checkbox = document.getElementById('tareas-ruta-checkbox');
        contadorElement.classList.toggle('hidden', count === 0 && (!checkbox || !checkbox.checked));
    }
}    
// ===================================================================
// NOMBRE: applyZoom (VERSI√ìN CON PROPORCIONALIDAD CORREGIDA)
// RESUMEN: Aplica el zoom. En modo 'on', usa un tama√±o fijo de 190px por columna, que es proporcionalmente
function applyZoom(state) {
    const originalWidth = 984;
    const zoomedCols = 4;
    const originalCols = 6;
    const gap = 15;
    const zoomButton = document.getElementById('zoom-button');

    if (state === 'on') {
        const zoomedColumnWidth = 224; // Nuevo tama√±o calculado para ser proporcionalmente m√°s grande.
        grid.style.gridTemplateColumns = `repeat(${zoomedCols}, ${zoomedColumnWidth}px)`;
        grid.style.gap = `${gap}px`;
        grid.style.maxWidth = `${(zoomedCols * zoomedColumnWidth) + ((zoomedCols - 1) * gap)}px`; 
        
        document.querySelectorAll('.bookmark-item img').forEach(i => { i.style.width = '48px'; i.style.maxWidth = '52px'; });
        document.querySelectorAll('.bookmark-name').forEach(n => { n.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)'; });
        document.querySelectorAll('.small-bookmark img').forEach(i => { i.style.width = '48px'; i.style.maxWidth = '52px'; });
        document.querySelectorAll('.small-bookmark .bookmark-name').forEach(n => { n.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)'; });
        if (zoomButton) zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/zoon+.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`;
    } else {
        grid.style.gridTemplateColumns = `repeat(${originalCols}, minmax(120px, 1fr))`;
        grid.style.gap = `${gap}px`;
        grid.style.maxWidth = `${originalWidth}px`; 
        document.querySelectorAll('.bookmark-item img').forEach(i => { i.style.width = '36px'; i.style.maxWidth = '40px'; });
        document.querySelectorAll('.bookmark-name').forEach(n => { n.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)'; });
        document.querySelectorAll('.small-bookmark img').forEach(i => { i.style.width = '24px'; i.style.maxWidth = '28px'; });
        document.querySelectorAll('.small-bookmark .bookmark-name').forEach(n => { n.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)'; });
        if (zoomButton) zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`;
    }
}    
    
    // ===================================================================
    function getSectionForIndex(index) { return currentToggleRanges.find(range => range.assignedIndexes.includes(index)); } 
    
    // ===================================================================
    function getColorForSection(sectionStart, state = 'visible') { if (state === 'hidden') { return sectionColors.off; } if (isDarkMode) { return darkModeGenericButtonColor; } else { return sectionColors[sectionStart] || sectionColors.unassigned; } }
     
    // ===================================================================
    // NOMBRE: updateButtonStyles
    // RESUMEN: Actualiza los estilos visuales de todos los botones de la UI.
    function updateButtonStyles() {
        const darkModeToggleElem = document.getElementById('dark-mode-toggle');
        const onOffToggleElem = document.getElementById('on-off-toggle');
        const rangeToggleButtonsElems = document.querySelectorAll('.toggle-sign.range-toggle');
        const reminderButtonElem = document.getElementById('reminder-button');
        if (onOffToggleElem) {
            onOffToggleElem.src = `https://boardinggate.github.io/Tesla/${onOffToggleElem.dataset.state === 'on' ? 'PNG/IMG_4192.jpg' : 'PNG/IMG_4191.jpg'}`;
            onOffToggleElem.alt = `Toggle ${onOffToggleElem.dataset.state === 'on' ? 'On' : 'Off'}`;
            onOffToggleElem.style.backgroundColor = sectionColors.off;
            if (isDarkMode) {
                onOffToggleElem.style.filter = 'brightness(85%)';
                 if (onOffToggleElem.dataset.state === 'on') {
                    onOffToggleElem.style.backgroundColor = darkModeGenericButtonColor;
                 }
            } else {
                onOffToggleElem.style.filter = '';
            }
        }
        if (darkModeToggleElem) {
            darkModeToggleElem.src = `https://boardinggate.github.io/Tesla/PNG/${isDarkMode ? 'oscuro2.png' : 'claro2.png'}`;
            darkModeToggleElem.alt = `Toggle ${isDarkMode ? 'Oscuro' : 'Claro'}`;
            darkModeToggleElem.style.backgroundColor = sectionColors.off;
            if (isDarkMode) darkModeToggleElem.style.filter = 'brightness(85%)'; else darkModeToggleElem.style.filter = '';
        }
        let reminders = [];
        try {
            reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        } catch(e) {
            reminders = [];
        }
        const showExcludedInTable = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
        let remindersForButtonStyleCount = reminders;
        if (!showExcludedInTable) {
            remindersForButtonStyleCount = reminders.filter(r => !r.excludeFromList);
        }
        const totalPendingCount = remindersForButtonStyleCount.length;
        if (reminderButtonElem) {
            reminderButtonElem.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/IMG_4197.jpg" alt="Recordatorio" style="max-width: 70%; max-height: 70%; object-fit: contain;">${totalPendingCount > 0 ? `<span class="reminder-count">${totalPendingCount}</span>` : ''}`;
            reminderButtonElem.style.backgroundColor = sectionColors.off;
            if (isDarkMode) reminderButtonElem.style.filter = 'brightness(85%)'; else reminderButtonElem.style.filter = '';
        }
        rangeToggleButtonsElems.forEach(toggle => {
            const start = parseInt(toggle.dataset.rangeStart);
            const state = toggle.dataset.state || 'visible';
            const rangeConfig = currentToggleRanges.find(r => r.start === start);
            if (rangeConfig) {
                toggle.innerHTML = `<span class="sign">${state === 'visible' ? '-' : '+'}</span>${rangeConfig.label}`;
            }
            toggle.style.backgroundColor = getColorForSection(start, state);
            if (isDarkMode && state === 'visible') {
                toggle.style.filter = 'brightness(85%)';
            } else {
                toggle.style.filter = '';
            }
        });
        updatePasswordToggleIcon();
        const zoomButtonElem = document.getElementById('zoom-button');
        if (zoomButtonElem && zoomButtonElem.dataset.zoomState) {
            applyZoom(zoomButtonElem.dataset.zoomState);
        }
        if (cellElements && cellElements.length > 0) {
            cellElements.forEach((cell, index) => {
                const bookmarkItem = cell.querySelector('.bookmark-item');
                const emptySlot = cell.classList.contains('empty-slot');
                const section = getSectionForIndex(index);
                const color = sectionColors[section ? section.start : null] || sectionColors.unassigned;
                if (bookmarkItem) {
                    bookmarkItem.style.backgroundColor = color;
                } else if (emptySlot) {
                    cell.style.backgroundColor = color;
                }
            });
        }
    }

// ===================================================================
// NOMBRE: saveSingleWaypointAsFavorite 
// RESUMEN: Inicia el proceso de guardado para un √∫nico punto de ruta como favorito.
function saveSingleWaypointAsFavorite(waypointId) {
    const waypointToSave = navigationWaypoints.find(wp => wp && wp.id === waypointId);
    if (!waypointToSave) {
        showToast("Error: No se pudo encontrar la etapa para guardar.", "error");
        return;
    }
    showSaveRoutePromptForSingleWaypoint(waypointToSave);
}

// ===================================================================
// NOMBRE: saveCurrentRoute 
// RESUMEN: Inicia el proceso para guardar la ruta completa, llamando al modal reutilizable de guardado.
async function saveCurrentRoute() {
    const actualWaypointsToSave = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    
    if (actualWaypointsToSave.length < 2) {
        showToast("No hay ruta activa para guardar (se necesitan al menos 2 puntos)", "warning");
        return;
    }

    const isMultiStage = actualWaypointsToSave.length > 2;
    const lastWp = actualWaypointsToSave[actualWaypointsToSave.length - 1];
    const defaultRouteName = await getSuggestedRouteName(lastWp.lat, lastWp.lng, isMultiStage, actualWaypointsToSave.length);
    
    const onSaveCallback = (confirmedName) => {
        let waypointsToSave = sanitizeWaypointsForStorage(actualWaypointsToSave);
   
        const routeToSave = {
            name: confirmedName,
            waypoints: waypointsToSave,
            createdAt: new Date().toISOString()
        };

        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        const existingRouteIndex = savedRoutes.findIndex(r => r.name.toUpperCase() === confirmedName);
        if (existingRouteIndex !== -1) {
            if (!confirm(`Ya existe una ruta llamada "${confirmedName}". ¬øSobreescribir?`)) {
                showToast("Guardado cancelado", "info");
                return;
            }
            savedRoutes[existingRouteIndex] = routeToSave;
        } else {
            savedRoutes.push(routeToSave);
        }
        if (savedRoutes.length > MAX_SAVED_ROUTES) {
            savedRoutes.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
            savedRoutes = savedRoutes.slice(0, MAX_SAVED_ROUTES);
        }
        localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes));
        markCacheAsDirty();
        addRouteToRecents(routeToSave);
        showToast(`Ruta "${confirmedName}" guardada.`, "success");
    };

    showSaveRoutePromptModal(defaultRouteName, onSaveCallback);
}
    
// ===================================================================
// NOMBRE: showSaveRoutePromptModal 
// RESUMEN: Muestra un modal de guardado gen√©rico con el nuevo dise√±o oscuro.
function showSaveRoutePromptModal(defaultName, onSaveCallback) {
    const existingOverlay = document.getElementById('route-modal-save-overlay');
    if (existingOverlay) existingOverlay.remove();

    const overlay = document.createElement('div');
    overlay.id = 'route-modal-save-overlay';
    overlay.className = 'route-modal-overlay';
    
    const modalContent = document.createElement('div');
    modalContent.id = 'save-route-prompt-modal';
    modalContent.className = 'route-modal-container';
    modalContent.innerHTML = `
        <div class="route-modal-header">
            <div class="route-modal-title-card">
                 <span class="route-modal-title">Guardar Favorito</span>
            </div>
        </div>
        <div class="route-modal-body">
            <label for="route-name-input" class="route-label">Nombre:</label>
            <div class="input-with-clear-button" style="position: relative;">
                <input type="text" id="route-name-input" value="${defaultName.toUpperCase()}" class="route-filter-input" style="padding-right: 40px;">
                <button class="clear-input-btn" title="Limpiar nombre" style="position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: transparent; border: none; font-size: 1.8rem; color: #aaa; cursor: pointer; display: none;">√ó</button>
            </div>
            <p style="font-size: 0.8rem; color: #8e8e93; margin-top: 10px;">
                (*) Las rutas se guardan y recuperan con el trayecto M√ÅS R√ÅPIDO.
            </p>
        </div>
        <div class="route-modal-footer">
            <button id="confirm-save-route" class="btn-modal-save">Guardar <span class="button-countdown-timer unified-countdown-style"></span></button>
            <button id="cancel-save-route" class="btn-modal-cancel">Cancelar</button>
        </div>
    `;
    
    overlay.appendChild(modalContent);
    document.body.appendChild(overlay);

    const nameInput = modalContent.querySelector('#route-name-input');
    const confirmButton = modalContent.querySelector('#confirm-save-route');
    const cancelButton = modalContent.querySelector('#cancel-save-route');
    const clearBtn = modalContent.querySelector('.clear-input-btn');
    
    const toggleClearButton = () => { clearBtn.style.display = nameInput.value.trim().length > 0 ? 'block' : 'none'; };
    nameInput.addEventListener('input', toggleClearButton);
    clearBtn.addEventListener('click', () => { nameInput.value = ''; toggleClearButton(); nameInput.focus(); });
    toggleClearButton();

    nameInput.focus();
    const textLength = nameInput.value.length;
    nameInput.setSelectionRange(textLength, textLength);

    const closePrompt = () => {
        clearModalAutoCloseTimer(overlay, confirmButton, 'save-route-prompt-modal');
        if (overlay.parentNode) overlay.remove();
    };

    const saveAction = () => {
        let routeName = nameInput.value.trim().toUpperCase();
        if (!routeName) {
            showToast("El nombre no puede estar vac√≠o", "warning");
            addModalAutoCloseTimer(overlay, confirmButton, 'save-route-prompt-modal', 15000);
            return;
        }
        onSaveCallback(routeName);
        closePrompt();
    };

    confirmButton.addEventListener('click', saveAction);
    cancelButton.addEventListener('click', closePrompt);
    addModalAutoCloseTimer(overlay, confirmButton, 'save-route-prompt-modal', 20000);
}    
    
    // ===================================================================
    function formatVersionDate(date) { const y = date.getUTCFullYear().toString().slice(-2); const m = String(date.getUTCMonth() + 1).padStart(2, '0'); const d = String(date.getUTCDate()).padStart(2, '0'); const h = String(date.getUTCHours()).padStart(2, '0'); return `${y}.${m}.${d}${h}`; }
    
    // ===================================================================
    // NOMBRE: getLastModifiedDate
    // RESUMEN: Obtiene la fecha de la √∫ltima modificaci√≥n desde un archivo remoto, con cach√© local.
    async function getLastModifiedDate() {
        const k = 'teslaHtmlLastModified';
        const tk = 'teslaHtmlLastModifiedTimestamp';
        const dur = 86400000;
        const cd = localStorage.getItem(k);
        const ct = localStorage.getItem(tk);
        const now = Date.now();
        if (cd && ct && (now - parseInt(ct)) < dur) {
            return new Date(cd);
        }
        try {
            const r = await fetch('https://boardinggate.github.io/Tesla/version.txt', { cache: 'no-cache' });
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const txt = await r.text();
            const lmd = new Date(txt.trim());
            if (isNaN(lmd.getTime())) throw new Error('Invalid date format');
            localStorage.setItem(k, lmd.toISOString());
            localStorage.setItem(tk, now.toString());
            return lmd;
        } catch (e) {
            if (cd) return new Date(cd);
            return new Date('2024-01-01T00:00:00Z');
        }
    }
    
    
    // ===================================================================
    async function updateVersion() { try { const lmd = await getLastModifiedDate(); const v = formatVersionDate(lmd); const el = document.getElementById('version'); if (el) el.textContent = `versi√≥n: ${v}`; } catch (e) { const el = document.getElementById('version'); if (el) el.textContent = 'versi√≥n: error'; } }
    
    // ===================================================================
    const getFaviconUrl = (bookmarkData) => { try { const urlToParse = bookmarkData?.url || ''; const customFavicon = bookmarkData?.favicon; if (customFavicon && (customFavicon.startsWith('data:image') || customFavicon.startsWith('http') || customFavicon.startsWith('./'))) return customFavicon; if (urlToParse) { const domain = new URL(urlToParse).hostname; return `https://www.google.com/s2/favicons?domain=${domain}&sz=64`; } } catch (e) { } return 'https://via.placeholder.com/64'; };
    
    // ===================================================================
    // NOMBRE: renderGrid
    // RESUMEN: Dibuja o redibuja el grid completo de marcadores.
    function renderGrid() { grid.innerHTML = ''; cellElements = []; Array.from({ length: TOTAL_CELLS }).forEach((_, index) => { const cellContainer = document.createElement('div'); cellContainer.classList.add('grid-cell'); cellContainer.dataset.index = index; const bookmarkData = currentBookmarks[index]; const section = getSectionForIndex(index); const bgColor = sectionColors[section ? section.start : null] || sectionColors.unassigned; if (bookmarkData) { const link = document.createElement('a'); link.className = 'bookmark-item'; link.title = bookmarkData.name; link.style.backgroundColor = bgColor; link.href = bookmarkData.url || "#"; link.dataset.index = index;
        if (isKeywordAssignmentMode || (bookmarkData.name && bookmarkData.name === "Inicio Tesla") || !bookmarkData.url || bookmarkData.url === '#') { } else { link.target = "_blank"; link.rel = "noopener noreferrer"; }
        const img = document.createElement('img'); img.src = getFaviconUrl(bookmarkData); img.alt = `Favicon ${bookmarkData.name}`; img.loading = "lazy"; img.onerror = function() { this.src = 'https://via.placeholder.com/64'; this.onerror = null; }; if (bookmarkData.name === "Mis Updates") img.classList.add('favicon-red'); else if (bookmarkData.name === "Olas Updates") img.classList.add('favicon-blue'); const nameSpan = document.createElement('span'); nameSpan.className = 'bookmark-name'; nameSpan.textContent = bookmarkData.name; link.appendChild(img); link.appendChild(nameSpan); cellContainer.appendChild(link); } else { cellContainer.classList.add('empty-slot'); const addIcon = document.createElement('span'); addIcon.textContent = '+'; cellContainer.appendChild(addIcon); cellContainer.style.backgroundColor = bgColor; }
        cellContainer.addEventListener('click', handleGridCellClick);
        if (isEditMode) {
             cellContainer.draggable = true;
             cellContainer.addEventListener('dragstart', handleDragStart); cellContainer.addEventListener('dragover', handleDragOver);
             cellContainer.addEventListener('dragleave', handleDragLeave);
             cellContainer.addEventListener('drop', handleDrop);
             cellContainer.addEventListener('dragend', handleDragEnd);
             cellContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
             cellContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
             cellContainer.addEventListener('touchend', handleTouchEnd);
             cellContainer.addEventListener('touchcancel', handleTouchCancel);
             cellContainer.classList.add('editable');
        } else {
             cellContainer.draggable = false;
             cellContainer.removeEventListener('dragstart', handleDragStart);
             cellContainer.removeEventListener('dragover', handleDragOver);
             cellContainer.removeEventListener('dragleave', handleDragLeave);
             cellContainer.removeEventListener('drop', handleDrop);
             cellContainer.removeEventListener('dragend', handleDragEnd);
             cellContainer.removeEventListener('touchstart', handleTouchStart);
             cellContainer.removeEventListener('touchmove', handleTouchMove);
             cellContainer.removeEventListener('touchend', handleTouchEnd);
             cellContainer.removeEventListener('touchcancel', handleTouchCancel);
             cellContainer.classList.remove('editable');
        }
        grid.appendChild(cellContainer); cellElements.push(cellContainer); }); }
    
    
    // ===================================================================
    // NOMBRE: renderToggleButtons
    // RESUMEN: Dibuja los botones laterales para ocultar/mostrar secciones del grid.
    function renderToggleButtons() {
        document.querySelectorAll('.range-toggle').forEach(btn => btn.remove());
        toggleButtonElements = {};
        const toggleStatesFromCache = JSON.parse(localStorage.getItem('toggleStates') || '{}');
        currentToggleRanges.forEach((range) => {
            const toggle = document.createElement('span');
            toggle.className = 'toggle-sign range-toggle';
            toggle.dataset.rangeStart = range.start;
            toggle.dataset.rangeEnd = range.end;
            toggle.style.position = 'fixed';
            toggle.style.top = '100px';
            toggle.style.left = '10px';
            const initialState = toggleStatesFromCache[range.start] || 'visible';
            toggle.dataset.state = initialState;
            toggle.addEventListener('click', handleToggleClick);
            document.body.appendChild(toggle);
            toggleButtonElements[range.start] = toggle;
        });
    }

// ===================================================================
// NOMBRE: createOtherButtons
// RESUMEN: Crea y a√±ade a la UI los botones de acci√≥n fijos.
function createOtherButtons() {
    if (!document.getElementById('on-off-toggle')) {
        onOffToggle = document.createElement('img');
        onOffToggle.className = 'toggle-image';
        onOffToggle.id = 'on-off-toggle';
        const savedOnOffState = localStorage.getItem('onOffState');
        onOffToggle.dataset.state = savedOnOffState ? savedOnOffState : 'on';
        document.body.appendChild(onOffToggle);
        onOffToggle.addEventListener('mousedown', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) pressStartTime = Date.now(); });
        onOffToggle.addEventListener('mouseup', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) handleOnOffAction(); });
        onOffToggle.addEventListener('mouseleave', () => { pressStartTime = null; });
        onOffToggle.addEventListener('touchstart', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); pressStartTime = Date.now(); } });
        onOffToggle.addEventListener('touchend', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); handleOnOffAction(); } });
    }
    if (!document.getElementById('weather-button')) { 
        weatherButton = document.createElement('span'); 
        weatherButton.className = 'toggle-sign icon-btn'; // <-- CLASE A√ëADIDA
        weatherButton.id = 'weather-button'; 
        weatherButton.innerHTML = 'üå§Ô∏è'; 
        weatherButton.style.fontSize = '2.5rem'; 
        document.body.appendChild(weatherButton); 
        weatherButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; window.open('https://www.ventusky.com/?p=40.2;-4.7;5&l=rain-3h', '_blank'); }); 
    }
    if (!document.getElementById('reminder-button')) { reminderButton = document.createElement('span'); reminderButton.className = 'toggle-sign'; reminderButton.id = 'reminder-button'; document.body.appendChild(reminderButton); reminderButton.addEventListener('mousedown', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) reminderPressStartTime = Date.now(); }); reminderButton.addEventListener('mouseup', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) handleReminderLongPress(); }); reminderButton.addEventListener('mouseleave', () => { reminderPressStartTime = null; }); reminderButton.addEventListener('touchstart', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); reminderPressStartTime = Date.now(); } }); reminderButton.addEventListener('touchend', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); handleReminderLongPress(); } }); }
    if (!document.getElementById('zoom-button')) { zoomButton = document.createElement('span'); zoomButton.className = 'toggle-sign'; zoomButton.id = 'zoom-button'; zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; zoomButton.dataset.zoomState = localStorage.getItem('zoomState') || 'off'; document.body.appendChild(zoomButton); zoomButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const cS = zoomButton.dataset.zoomState; const nS = cS === 'off' ? 'on' : 'off'; applyZoom(nS); zoomButton.dataset.zoomState = nS; updateButtonStyles(); saveSettings(); adjustButtonPositions(); }); }
    if (!document.getElementById('dark-mode-toggle')) { darkModeToggle = document.createElement('img'); darkModeToggle.className = 'toggle-image'; darkModeToggle.id = 'dark-mode-toggle'; document.body.appendChild(darkModeToggle); darkModeToggle.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; isDarkMode = !isDarkMode; document.body.classList.toggle('dark-mode', isDarkMode); updateButtonStyles(); saveSettings(); }); }
    if (!document.getElementById('config-button')) {
        const configButton = document.createElement('span');
        configButton.id = 'config-button';
        configButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/config.jpg" alt="Configuraci√≥n">`;
        document.body.appendChild(configButton);
        configButton.addEventListener('click', () => {
            if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) {
                const mapIsCurrentlyOpen = isNavigationMapActive;
                const currentMapContext = sessionStorage.getItem('mapContext');
                if (mapIsCurrentlyOpen && currentMapContext) {
                    sessionStorage.setItem('boardinggate_map_should_reopen_after_config', 'true');
                    sessionStorage.setItem('mapContextToReopenAfterConfig', currentMapContext);
                    closeNavigationMap(true);
                }
                showConfigModal();
            }
        });
    }
    if (!document.getElementById('personal-button')) {
        const personalButton = document.createElement('span');
        personalButton.id = 'personal-button';
        personalButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="Personal">`;
        document.body.appendChild(personalButton);
        personalButton.addEventListener('click', handlePersonalizationClick);
    }
    if (!document.getElementById('radar-button')) {
        radarButton = document.createElement('span');
        radarButton.id = 'radar-button';
        radarButton.innerHTML = `<img src="PNG/AVANCE.PNG" alt="Radar/Ubicaciones/Navegaci√≥n">`;
        document.body.appendChild(radarButton);
        radarButton.addEventListener('click', () => {
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;

            const userId = localStorage.getItem('userData_userId');
            const allowDMs = JSON.parse(localStorage.getItem('userData_allowDMs') || 'false');

            if (userId && userId.trim() !== '' && allowDMs) {
                openNavigationMap();
                
                const AUTO_BACKUP_KEY = 'boardinggate_autoBackupOnLoad';
                const isAutoBackupEnabled = localStorage.getItem(AUTO_BACKUP_KEY) === 'true';
            
                if (!isAutoBackupEnabled) {localStorage.setItem(AUTO_BACKUP_KEY, 'true');
                    
                    const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
                    if (autoBackupCheckbox) {
                        autoBackupCheckbox.checked = true;
                    }
                    markCacheAsDirty();
                }

            } else {
                const message = "PARA ACCEDER A MAPAS, ES IMPRESCINDIBLE QUE CREE EN CONFIGURACI√ìN UN NOMBRE DE USUARIO √öNICO (y debe estar activado Permitir MDs tambi√©n y BACKUP AUTOM√ÅTICO)...";
                const duration = 10000; 

                showToast(message, 'error', duration);

                setTimeout(() => {
                    showConfigModal();
                }, duration);
            }
             });
    }
    if (!document.getElementById('home-button')) {
        const homeButton = document.createElement('span');
        homeButton.id = 'home-button';
        homeButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/home.webp" alt="Inicio">`;
        document.body.appendChild(homeButton);
        homeButton.addEventListener('click', (e) => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) { e.preventDefault(); return; } window.history.back(); });
    }
    if (!document.getElementById('reload-button')) {
        const reloadButton = document.createElement('span');
        reloadButton.id = 'reload-button';
        reloadButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/reload.webp" alt="Recargar">`;
        document.body.appendChild(reloadButton);
        reloadButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; location.reload(); });
    }

    if (!document.getElementById('store-button')) {
        const storeButton = document.createElement('span');
        storeButton.id = 'store-button';
        storeButton.innerHTML = `<img src="PNG/store.png" alt="Tienda/Referidos">`;
        document.body.appendChild(storeButton);
        storeButton.addEventListener('click', () => {
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
            showReferralsModal(); // Funci√≥n que crearemos a continuaci√≥n
        });
    }
    
    if (!document.getElementById('keyword-assignment-button')) {
         const keywordButton = document.createElement('span');
         keywordButton.id = 'keyword-assignment-button';
         keywordButton.title = "Asignar/Quitar palabra clave filtro";
         keywordButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/IMG_4314.PNG" alt="Asignar Keyword">`;
         document.body.appendChild(keywordButton);
         keywordButton.addEventListener('click', () => { toggleKeywordAssignmentMode(!isKeywordAssignmentMode); });
    }
    if (!document.getElementById('password-toggle-button')) {
        const passwordButton = document.createElement('span');
        passwordButton.id = 'password-toggle-button';
        passwordButton.innerHTML = `<img src="" alt="Clave">`;
        document.body.appendChild(passwordButton);
        passwordButton.addEventListener('click', handlePasswordToggleClick);
    }
    if (!document.getElementById('versions-button')) {
         versionsButton = document.createElement('span');
         versionsButton.id = 'versions-button';
         versionsButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/IMG_4309.PNG" alt="Versiones">`;
         document.body.appendChild(versionsButton);
         versionsButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; showVersionsModal(); });
    }
    if (!document.getElementById('info-button')) {
         infoButton = document.createElement('span');
         infoButton.id = 'info-button';
         infoButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/IMG_4326.PNG" alt="Info">`;
         document.body.appendChild(infoButton);
         infoButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; window.open('https://boardinggate.github.io/Tesla/manual.html', '_blank'); });
    }
}
    
    // ===================================================================
    // NOMBRE: handleGridCellClick
    // RESUMEN: Gestiona los clics en las celdas del grid, seg√∫n el modo activo.
    function handleGridCellClick(event) {
        const cellContainer = event.currentTarget; const index = parseInt(cellContainer.dataset.index);
        if (isEditMode) { const link = cellContainer.querySelector('a.bookmark-item'); if (link) event.preventDefault(); showEditModal(index, false); }
        else if (isAssignmentMode) { event.preventDefault(); handleGridCellClickForAssignment(index); }
        else if (isKeywordAssignmentMode) { event.preventDefault(); handleKeywordAssignmentClick(index); }
        else { const link = cellContainer.querySelector('a.bookmark-item'); const bookmarkData = currentBookmarks[index];
            if (!link || !link.href || link.href === '#') {
                event.preventDefault();
                if (bookmarkData && bookmarkData.url && bookmarkData.url.startsWith("map-action:")) {
                    const action = bookmarkData.url.split(":")[1];
                    if (action === "openRemindersMapWithNoRadars") {
                        openLocationsPreviewMap();
                    } else if (action === "openRemindersMap") {
                        openNavigationMap();
                    }
                }
            } else {
                if (!link.target && bookmarkData && bookmarkData.name !== "Inicio Tesla") {
                    link.target = "_blank"; link.rel = "noopener noreferrer";
                }
            }
        }
    }
    
    // ===================================================================
    function handleToggleClick(event) { const toggle = event.currentTarget; if (isEditMode) { event.preventDefault(); const start = parseInt(toggle.dataset.rangeStart); showEditModal(start, true); } else if (isAssignmentMode) { event.preventDefault(); handleToggleClickForAssignment(toggle); } else if (isKeywordAssignmentMode) { event.preventDefault(); } else { updateToggleState(toggle); } }
    
    // ===================================================================
    function updateToggleState(toggle) { if (!toggle || isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const start = parseInt(toggle.dataset.rangeStart); if (isNaN(start)) return; const rangeConfig = currentToggleRanges.find(r => r.start === start); if (!rangeConfig) return; const currentState = toggle.dataset.state; const newState = currentState === 'visible' ? 'hidden' : 'visible'; toggle.dataset.state = newState; const savedStates = JSON.parse(localStorage.getItem('toggleStates') || '{}'); savedStates[start] = newState; localStorage.setItem('toggleStates', JSON.stringify(savedStates)); updateButtonStyles(); filterGridItems(); } 
    
    // ===================================================================
    function updateAllToggles(newState) { const onOffToggleElem = document.getElementById('on-off-toggle'); if (!onOffToggleElem) return; onOffToggleElem.dataset.state = newState; localStorage.setItem('onOffState', newState); updateButtonStyles(); filterGridItems(); saveSettings(); }
    const scrollToggle = document.getElementById('scroll-toggle'); if (scrollToggle) scrollToggle.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const sP = window.scrollY; const mS = document.body.scrollHeight - window.innerHeight; window.scrollTo({ top: sP < 100 ? mS : 0, behavior: 'smooth' }); });
    
    // ===================================================================
    function handleOnOffAction() { if (pressStartTime !== null) { const t = document.getElementById('on-off-toggle'); if (t) { const nS = t.dataset.state === 'on' ? 'off' : 'on'; updateAllToggles(nS); } } pressStartTime = null; } 
    
    // ===================================================================
    function handleReminderLongPress() { if (reminderPressStartTime === null) return; const dur = Date.now() - reminderPressStartTime; if (dur >= 2000) showAllReminders(); else showReminderModal(); reminderPressStartTime = null; }
    
 
// ===================================================================
// NOMBRE: handlePersonalizationClick (MODIFICADA)
// RESUMEN: Muestra el men√∫ de opciones o el di√°logo de confirmaci√≥n de salida.
function handlePersonalizationClick() {
    const wasEditing = isEditMode;
    const wasAssigning = isAssignmentMode;
    const wasKeywordAssigning = isKeywordAssignmentMode;

    if (wasKeywordAssigning) {
        toggleKeywordAssignmentMode(false);
    }

    if (editingTargetElement) {
        editingTargetElement.classList.remove('editing-target');
        editingTargetElement = null;
    }

    if (wasEditing || wasAssigning) {
        showExitPersonalizationModal();
    } 
    else if (!wasKeywordAssigning) {
        showPersonalizationChoice();
    }
}   

// ===================================================================
// NOMBRE: showExitPersonalizationModal (NUEVA FUNCI√ìN)
// RESUMEN: Muestra el modal para confirmar o descartar los cambios de personalizaci√≥n.
function showExitPersonalizationModal() {
    closeOtherModals();
    const modal = document.createElement('div');
    modal.className = 'choice-modal';
    modal.innerHTML = `
        <h2>Finalizar Personalizaci√≥n</h2>
        <p class="mb-6">Has realizado cambios en el grid. ¬øQu√© deseas hacer?</p>
        <div class="personalization-options">
            <button id="confirm-personalization" class="choice-edit" style="background-color: #28a745;">Guardar Cambios</button>
            <button id="revert-personalization" class="choice-assign" style="background-color: #dc3545;">Descartar Cambios</button>
            <button id="continue-editing" class="choice-help" style="background-color: #6c757d;">Continuar Editando</button>
        </div>
    `;
    modal.querySelector('#confirm-personalization').addEventListener('click', () => {
        modal.remove();
        confirmPersonalizationChanges();
    });
    modal.querySelector('#revert-personalization').addEventListener('click', () => {
        modal.remove();
        revertPersonalizationChanges();
    });
    modal.querySelector('#continue-editing').addEventListener('click', () => {
        modal.remove();
    });
    document.body.appendChild(modal);
}

// ===================================================================
// NOMBRE: confirmPersonalizationChanges 
// RESUMEN: Guarda los cambios y sale de los modos de edici√≥n/asignaci√≥n.
function confirmPersonalizationChanges() {
    saveCustomData(); // Guarda la versi√≥n actual de customData en localStorage
    if (isEditMode) toggleEditMode(false);
    if (isAssignmentMode) toggleAssignmentMode(false);
    showToast("Cambios guardados correctamente.", "success");
}
   
    // ===================================================================
    // NOMBRE: showPersonalizationChoice
    // RESUMEN: Muestra el modal para elegir el tipo de personalizaci√≥n.
    function showPersonalizationChoice() {
        const existingModal = document.querySelector('.choice-modal'); if (existingModal) existingModal.remove();
        const modal = document.createElement('div'); modal.className = 'choice-modal'; modal.setAttribute('aria-label', 'Elegir tipo de personalizaci√≥n');
        modal.innerHTML = `
            <h2>¬øQu√© quieres personalizar?</h2>
            <div class="modal-top-buttons">
                <button class="choice-cancel">Cancelar</button>
            </div>
            <p class="mb-6">Elige una opci√≥n:</p>
            <div class="personalization-options">
                <button class="choice-edit">URLs / Etiquetas / Reordenar</button>
                <button class="choice-assign">Asignar Botones Ocultaci√≥n</button>
                <button class="choice-help">Ver Ayuda</button>
            </div>
        `;
        modal.querySelector('.choice-edit').addEventListener('click', () => { modal.remove(); toggleEditMode(true); });
        modal.querySelector('.choice-assign').addEventListener('click', () => { modal.remove(); toggleAssignmentMode(true); });
        modal.querySelector('.choice-help').addEventListener('click', () => { modal.remove(); showEditInfoModal(); });
        modal.querySelector('.choice-cancel').addEventListener('click', () => { modal.remove(); });
        document.body.appendChild(modal);
        addModalAutoCloseTimer(modal, modal.querySelector('.choice-cancel'), 'choice-modal', 30000);
}
    
    // ===================================================================
    // NOMBRE: toggleKeywordAssignmentMode
    // RESUMEN: Activa o desactiva el modo de asignaci√≥n de palabras clave a los nombres de los marcadores.
    function toggleKeywordAssignmentMode(activate) {
         const keywordButton = document.getElementById('keyword-assignment-button'); const filterInput = document.getElementById('grid-filter-input'); isKeywordAssignmentMode = activate;
         if (keywordButton) { keywordButton.classList.toggle('active', isKeywordAssignmentMode); }
        document.body.classList.toggle('keyword-assignment-active', isKeywordAssignmentMode);
         if (isKeywordAssignmentMode) {
              if (isEditMode) toggleEditMode(false); if (isAssignmentMode) toggleAssignmentMode(false);
              const toastMessage = "Modo activo: Escribe palabra(s) en el campo filtro grid (separadas por espacio si son varias). Pulsa ICONO FILTRO para a√±adir/quitar esa(s) palabra(s) al nombre del bot√≥n(es) que vaya seleccionando. Pulsa el icono para salir de este modo.";
              showToast(toastMessage, "info", 15000); filterGridItems(); applyInitialKeywordHighlights();
         } else {
              showToast("Modo Asignaci√≥n de Palabras Clave Desactivado", "info", 2000); cellElements.forEach(cell => cell.classList.remove('keyword-assigned-highlight')); filterGridItems();
         }
    }
    
    // ===================================================================
    function applyInitialKeywordHighlights() { const filterInput = document.getElementById('grid-filter-input'); const keyword = filterInput.value.trim().replace(/\s+/g, '').toUpperCase(); if (!keyword) return; const keywordTag = `[${keyword}]`; cellElements.forEach((cell, index) => { const bookmark = currentBookmarks[index]; if (bookmark && bookmark.name && bookmark.name.includes(keywordTag)) { cell.classList.add('keyword-assigned-highlight'); } else { cell.classList.remove('keyword-assigned-highlight'); } }); }
    
    // ===================================================================
    function handleToggleClickForAssignment(toggleElement) { const start = parseInt(toggleElement.dataset.rangeStart); if (isNaN(start)) return; currentlyAssigningToggleStart = start; document.querySelectorAll('.range-toggle').forEach(t => { t.classList.toggle('assigning-selected', t === toggleElement); t.style.opacity = t === toggleElement ? '' : '0.7'; }); updateGridAssignmentVisuals(); showToast(`Asignando botones para: ${toggleElement.textContent.substring(1)}`, "info", 2500); } 

    // ===================================================================
    // NOMBRE: handleKeywordAssignmentClick
    // RESUMEN: A√±ade o quita la palabra clave del filtro al nombre de un marcador.
    function handleKeywordAssignmentClick(index) {
        const filterInput = document.getElementById('grid-filter-input'); const keyword = filterInput.value.trim().replace(/\s+/g, '').toUpperCase();
        if (!keyword) { showToast("Escribe una palabra en el campo filtro primero.", "warning"); return; }
        const bookmark = currentBookmarks[index]; const cellElement = cellElements[index];
        if (!bookmark || !cellElement) { showToast(`No hay un marcador en la posici√≥n ${index + 1}.`, "warning"); return; }
        const keywordTag = `[${keyword}]`; const currentName = bookmark.name || ""; const nameSpan = cellElement.querySelector('.bookmark-name');
        let newName = currentName; let actionTaken = '';
        if (currentName.includes(keywordTag)) { newName = currentName.replace(keywordTag, '').replace(/\s{2,}/g, ' ').trim(); cellElement.classList.remove('keyword-assigned-highlight'); actionTaken = 'removed'; }
        else { newName = currentName.trim(); const lastBracketIndex = newName.lastIndexOf(']'); const endsWithBracket = lastBracketIndex !== -1 && lastBracketIndex === newName.length - 1;
            if (endsWithBracket) { newName += '  ' + keywordTag; } else { newName += '          ' + keywordTag; } cellElement.classList.add('keyword-assigned-highlight'); actionTaken = 'added'; }
        bookmark.name = newName; currentBookmarks[index] = { ...bookmark }; if (!customData.bookmarks) customData.bookmarks = {}; customData.bookmarks[index] = { ...bookmark }; saveCustomData();
        if (nameSpan) { nameSpan.textContent = newName; }
        if (actionTaken === 'added') { showToast(`"${keyword}" a√±adido. Nombre: ${newName}`, "success", 2500); } else if (actionTaken === 'removed') { showToast(`"${keyword}" quitado. Nombre: ${newName}`, "info", 2500); }
    }
        
    // ===================================================================
    // NOMBRE: handleGridCellClickForAssignment
    // RESUMEN: Asigna o desasigna un marcador a la secci√≥n actualmente seleccionada.
    function handleGridCellClickForAssignment(cellIndex) {
        if (currentlyAssigningToggleStart === null) { showToast("Selecciona primero un bot√≥n lateral (PdR,s, iAs, etc.)", "warning"); return; }
        const startKey = currentlyAssigningToggleStart.toString(); if (!customData.toggles[startKey]) { const currentRange = currentToggleRanges.find(r => r.start == startKey); customData.toggles[startKey] = { label: currentRange ? currentRange.label : `Rango ${startKey}`, assignedIndexes: currentRange ? [...currentRange.assignedIndexes] : [] }; }
        else if (!customData.toggles[startKey].assignedIndexes) { const currentRange = currentToggleRanges.find(r => r.start == startKey); customData.toggles[startKey].assignedIndexes = currentRange ? [...currentRange.assignedIndexes] : []; }
        const assigned = customData.toggles[startKey].assignedIndexes; const indexInArray = assigned.indexOf(cellIndex);
        if (indexInArray > -1) { assigned.splice(indexInArray, 1); } else { assigned.push(cellIndex); assigned.sort((a, b) => a - b); }
        const currentRangeIndex = currentToggleRanges.findIndex(r => r.start == startKey); if (currentRangeIndex > -1) { currentToggleRanges[currentRangeIndex].assignedIndexes = [...assigned]; }
        updateGridAssignmentVisuals(); saveCustomData(); showToast('Asignaci√≥n guardada', 'success', 500);
    }
    
    // ===================================================================
    // NOMBRE: updateGridAssignmentVisuals
    // RESUMEN: Actualiza la apariencia visual del grid durante el modo de asignaci√≥n.
    function updateGridAssignmentVisuals() { if (!isAssignmentMode || currentlyAssigningToggleStart === null) { cellElements.forEach(cell => { cell.classList.remove('assigned-to-current'); cell.style.opacity = ''; cell.style.outline = ''; cell.style.boxShadow = ''; }); return; } const startKey = currentlyAssigningToggleStart.toString(); let assignedIndexesForCurrentToggle = []; if (customData.toggles[startKey] && customData.toggles[startKey].assignedIndexes) { assignedIndexesForCurrentToggle = customData.toggles[startKey].assignedIndexes; } else { const currentRange = currentToggleRanges.find(r => r.start == startKey); if (currentRange?.assignedIndexes) { assignedIndexesForCurrentToggle = currentRange.assignedIndexes; } } cellElements.forEach((cell, index) => { const isAssigned = assignedIndexesForCurrentToggle.includes(index); cell.classList.toggle('assigned-to-current', isAssigned); if (isAssigned) { cell.style.opacity = ''; cell.style.outline = '3px solid cyan'; cell.style.boxShadow = document.body.classList.contains('dark-mode') ? 'inset 0 0 10px rgba(0, 200, 200, 0.7)' : 'inset 0 0 8px rgba(0, 255, 255, 0.6)'; } else { cell.style.opacity = document.body.classList.contains('dark-mode') ? '0.5' : '0.6'; cell.style.outline = `1px dashed ${document.body.classList.contains('dark-mode') ? '#555' : '#aaa'}`; cell.style.boxShadow = ''; } }); } 
    
    // ===================================================================
    // NOMBRE: showEditInfoModal
    // RESUMEN: Muestra el modal con la ayuda sobre los modos de personalizaci√≥n.
    function showEditInfoModal() {
        const existingModal = document.querySelector('.edit-info-modal'); if (existingModal) existingModal.remove();
        const modal = document.createElement('div'); modal.className = 'edit-info-modal'; modal.setAttribute('aria-label', 'Ayuda Personalizaci√≥n');
        modal.innerHTML = `
            <h2 class="text-xl font-bold mb-4">Ayuda de Personalizaci√≥n</h2>
            <div class="modal-top-buttons" style="justify-content: flex-end;">
                <button type="button" id="close-edit-info" class="px-6 py-2" style="flex: 0 1 auto; min-width: 120px;">Entendido</button>
            </div>
            <p class="mb-3">Al pulsar el bot√≥n <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (personalizar) o el icono <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4314.PNG" alt="Key" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (llave) puedes elegir entre varios modos:</p>
            <div class="mb-4 p-3 bg-yellow-100 border border-yellow-300 rounded">
                 <h3 class="font-semibold text-lg mb-2">1. Editar URLs / Etiquetas / Reordenar (Bot√≥n Personalizar Amarillo)</h3>
                 <ul class="list-disc pl-5 space-y-1 text-sm">
                    <li><strong>Activar:</strong> Elige "URLs / Etiquetas / Reordenar" en el men√∫ inicial. El bot√≥n <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> se pondr√° amarillo.</li>
                    <li><strong>Editar Marcador/Bot√≥n Lateral:</strong> Haz clic en un marcador del grid o en un bot√≥n lateral (PdR,s, iAs, etc.). Se abrir√° una ventana para editar su nombre, URL (si es marcador) o etiqueta (si es bot√≥n lateral). <strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                    <li><strong>Arrastrar y Soltar:</strong> Mant√©n pulsado un marcador del grid y arr√°stralo a otra posici√≥n (incluso vac√≠a) para reordenarlos.</li>
                    <li><strong>Guardar Cambios:</strong> Los cambios en nombre/URL/etiqueta se guardan al pulsar "Guardar" en la ventana de edici√≥n. El reordenamiento se guarda autom√°ticamente al soltar.</li>
                    <li><strong>Vaciar Casilla:</strong> En la ventana de edici√≥n de un marcador, pulsa "Vaciar" para eliminarlo.</li>
                    <li><strong>Resetear:</strong> En la ventana de edici√≥n, pulsa "Resetear" para volver a los valores originales (si los ten√≠a).</li>
                 </ul>
            </div>
            <div class="mb-4 p-3 bg-cyan-100 border border-cyan-300 rounded">
                <h3 class="font-semibold text-lg mb-2">2. Asignar Botones Ocultaci√≥n (Bot√≥n Personalizar Cian)</h3>
                <ul class="list-disc pl-5 space-y-1 text-sm">
                    <li><strong>Activar:</strong> Elige "Asignar Botones Ocultaci√≥n" en el men√∫ inicial. El bot√≥n <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> se pondr√° cian.</li>
                    <li><strong>Seleccionar Bot√≥n Lateral:</strong> Haz clic en el bot√≥n lateral (PdR,s, iAs, etc.) cuyos marcadores quieres definir. Se resaltar√°.</li>
                    <li><strong>Asignar/Desasignar Marcadores:</strong> Haz clic en cualquier marcador de la rejilla. Si estaba asignado, se desasignar√° (atenuado). Si no lo estaba, se asignar√° (resaltado). <strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                    <li><strong>Cambiar Bot√≥n Lateral:</strong> Haz clic en otro bot√≥n lateral para asignar sus marcadores.</li>
                    <li><strong>Guardar:</strong> Los cambios se guardan autom√°ticamente al salir de este modo (pulsando el bot√≥n <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> cian).</li>
                    <li><strong>Visibilidad por defecto:</strong> Marcadores no asignados a <i>ning√∫n</i> bot√≥n lateral siempre ser√°n visibles (salvo que el bot√≥n general <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4191.jpg" alt="OFF" style="width:20px; height:11px; display:inline; vertical-align:middle;"> est√© desactivado).</li>
                </ul>
            </div>
            <div class="mb-4 p-3 bg-green-100 border border-green-300 rounded">
            <h3 class="font-semibold text-lg mb-2">3. Asignar Palabra Clave Filtro (Icono Llave Verde)</h3>
            <ul class="list-disc pl-5 space-y-1 text-sm">
                <li><strong>Activar:</strong> Pulsa el icono de la llave <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4314.PNG" alt="Key" style="width:16px; height:16px; display:inline; vertical-align:middle;"> junto al campo de filtro. El icono se pondr√° verde. Si vuelves a pulsar, se desactivar√°.</li>
                <li><strong>Escribe la Palabra:</strong> Escribe la palabra que quieres a√±adir al nombre de los botones en el campo de filtro. Se eliminar√°n los espacios autom√°ticamente.</li>
                <li><strong>Asignar:</strong> Haz clic en el bot√≥n del grid al que quieres a√±adir la palabra clave. La palabra (en corchetes) se a√±adir√° a su nombre (si no existe ya).</li>
                <li><strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                <li><strong>Guardar:</strong> Los cambios se guardan autom√°ticamente cada vez que asignas una palabra clave a un bot√≥n.</li>
                <li><strong>Mostrar Todo:</strong> Al activar este modo, se limpiar√° el filtro y se mostrar√°n todos los botones para facilitar la asignaci√≥n.</li>
            </ul>
            </div>
            <p class="mb-4"><strong>Salir de Personalizaci√≥n:</strong> Pulsa el bot√≥n activo <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (amarillo o cian) o el icono de la llave <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4314.PNG" alt="Key" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (verde) para desactivar el modo actual y volver al uso normal.</p>
        `;
        document.body.appendChild(modal);
        const closeEditInfoButton = modal.querySelector('#close-edit-info');
        const closeHandler = () => { clearModalAutoCloseTimer(modal, closeEditInfoButton, 'edit-info-modal'); if (modal.parentNode) modal.parentNode.removeChild(modal); };
        closeEditInfoButton.addEventListener('click', closeHandler); addModalAutoCloseTimer(modal, closeEditInfoButton, 'edit-info-modal');
    }
    
    // ===================================================================
    // NOMBRE: showEditModal
    // RESUMEN: Muestra el modal para editar los detalles de un marcador o de un bot√≥n de secci√≥n.
    function showEditModal(targetIndexOrStart, isToggle = false) { if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); } const existingModal = document.querySelector('.edit-modal'); if (existingModal) existingModal.remove(); const modal = document.createElement('div'); modal.className = 'edit-modal'; if (isToggle) { editingTargetElement = toggleButtonElements[targetIndexOrStart]; } else { editingTargetElement = cellElements[targetIndexOrStart]; } if (editingTargetElement) { editingTargetElement.classList.add('editing-target'); } else { } let currentItemData = {}; let originalItemData = {}; let title = ''; let isNewBookmark = false; const targetIndex = isToggle ? -1 : targetIndexOrStart; if (isToggle) { const targetStart = targetIndexOrStart; const currentRange = currentToggleRanges.find(r => r.start === targetStart); const originalRange = originalToggleRanges.find(r => r.start === targetStart); const currentLabel = customData.toggles[targetStart]?.label ?? currentRange?.label ?? ''; currentItemData = { label: currentLabel }; originalItemData = { label: originalRange?.label || '' }; title = `Editar Etiqueta Secci√≥n`;
        modal.innerHTML = `
            <h2>${title}</h2>
            <div class="modal-top-buttons" style="margin-bottom: 1.2rem;">
                <button class="save">Guardar</button>
                <button class="reset">Resetear</button>
                <button class="cancel">Cancelar</button>
            </div>
            <div><label for="edit-label">Etiqueta (m√°x 7):</label><input type="text" id="edit-label" value="${currentItemData.label}" maxlength="7"></div>
        `;
    } else { const currentBookmark = currentBookmarks[targetIndex]; const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null; currentItemData = currentBookmark ? { ...currentBookmark } : { name: '', url: '', favicon: '' }; originalItemData = originalBookmark ? { ...originalBookmark } : { name: '', url: '', favicon: '' }; isNewBookmark = !currentBookmark; title = currentBookmark ? `Editar Marcador: ${currentItemData?.name || `√çndice ${targetIndex}`}` : `A√±adir Marcador (Posici√≥n ${targetIndex + 1})`;
        modal.innerHTML = `
            <h2>${title}</h2>
            <div class="modal-top-buttons" style="margin-bottom: 1.2rem;">
                <button class="save">Guardar</button>
                <button class="reset">Resetear</button>
                <button class="empty">Vaciar</button>
                <button class="cancel">Cancelar</button>
            </div>
            <div><label for="edit-name">Nombre:</label><input type="text" id="edit-name" value="${currentItemData.name || ''}"></div>
            <div><label for="edit-url">URL:</label><div class="input-with-button"><input type="url" id="edit-url" value="${currentItemData.url || ''}" placeholder="https://ejemplo.com"><button class="search-button" id="search-url-button" title="Buscar URL en Google (basado en URL/Nombre)">üîç</button></div></div>
            <div><label for="edit-favicon">URL Favicon (Opcional):</label><div class="input-with-button"><input type="text" id="edit-favicon" value="${currentItemData.favicon || ''}" placeholder="Dejar vac√≠o para auto"><button class="search-button" id="search-favicon-button" title="Buscar Favicon en Google Images (basado en Favicon/Nombre)">üñºÔ∏è</button></div></div>
        `;
    } document.body.appendChild(modal); const cleanupEditModal = () => { if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; } if (modal.parentNode) modal.parentNode.removeChild(modal); }; modal.querySelector('.save').addEventListener('click', () => { let dataChanged = false; if (isToggle) { const targetStart = targetIndexOrStart; const newLabel = modal.querySelector('#edit-label').value.trim(); if (!newLabel) { showToast("La etiqueta no puede estar vac√≠a.", "warning"); return; } if (newLabel.length > 7) { showToast("La etiqueta no puede exceder 7 caracteres.", "warning"); return; } const originalLabel = originalToggleRanges.find(r => r.start === targetStart)?.label || ''; if (newLabel !== originalLabel) { if (!customData.toggles[targetStart]) customData.toggles[targetStart] = {}; customData.toggles[targetStart].label = newLabel; dataChanged = true; } else { if (customData.toggles[targetStart] && customData.toggles[targetStart].hasOwnProperty('label')) { delete customData.toggles[targetStart].label; if (Object.keys(customData.toggles[targetStart]).length === 0) delete customData.toggles[targetStart]; dataChanged = true; } } const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetStart); if (rangeIdx > -1) currentToggleRanges[rangeIdx].label = newLabel; } else { const nameInput = modal.querySelector('#edit-name'); const urlInput = modal.querySelector('#edit-url'); const faviconInput = modal.querySelector('#edit-favicon');
                const newName = nameInput.value.trim();
                const newUrl = urlInput.value.trim();
                const newFavicon = faviconInput.value.trim() || null;
                const isEmpty = !newName && !newUrl && !newFavicon;
                const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                if (isEmpty) {
                    if (originalBookmark !== null && originalBookmark !== undefined) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = null;
                        dataChanged = true;
                    } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = null;
                } else {
                    if (!newName || !newUrl) {
                        showToast("Nombre y URL son obligatorios.", "warning");
                        return;
                    }
                    try { new URL(newUrl); } catch (_) {
                        showToast("URL inv√°lida.", "warning");
                        return;
                    }
                    const bookmarkUpdate = { name: newName, url: newUrl, favicon: newFavicon };
                    const originalData = originalBookmark ? { name: originalBookmark.name, url: originalBookmark.url, favicon: originalBookmark.favicon || null } : null;
                    const bookmarksAreEqual = (b1, b2) => { if (b1 === null && b2 === null) return true; if (b1 === null || b2 === null) return false; return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null); };
                    if (!bookmarksAreEqual(bookmarkUpdate, originalData)) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = bookmarkUpdate;
                        dataChanged = true;
                   } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = bookmarkUpdate;
                }
            }
            if (dataChanged) {
                saveCustomData();
                showToast("Cambios guardados", "success");
            } else {
          }
            updateGridItemUI(targetIndexOrStart, isToggle);
            cleanupEditModal();
        });
        modal.querySelector('.reset').addEventListener('click', () => {
            let dataChanged = false;
            if (isToggle) {
                const targetStart = targetIndexOrStart;
                const originalRange = originalToggleRanges.find(r => r.start === targetStart);
                const originalLabel = originalRange?.label || '';
                modal.querySelector('#edit-label').value = originalLabel;
                if (customData.toggles && customData.toggles[targetStart] && customData.toggles[targetStart].hasOwnProperty('label')) {
                    delete customData.toggles[targetStart].label;
                    if (Object.keys(customData.toggles[targetStart]).length === 0) delete customData.toggles[targetStart];
                    dataChanged = true;
                }
                const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetStart);
                if (rangeIdx > -1) currentToggleRanges[rangeIdx].label = originalLabel;
            } else {
                const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                modal.querySelector('#edit-name').value = originalBookmark?.name || '';
                modal.querySelector('#edit-url').value = originalBookmark?.url || '';
                modal.querySelector('#edit-favicon').value = originalBookmark?.favicon || '';
                if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                    delete customData.bookmarks[targetIndex];
                    dataChanged = true;
                }
                currentBookmarks[targetIndex] = originalBookmark ? { ...originalBookmark } : null;
            }
            if (dataChanged) {
                saveCustomData();
                showToast("Valores reseteados al original y guardados", "info");
            } else {
                showToast("Ya estaba con los valores originales", "info");
            }
            updateGridItemUI(targetIndexOrStart, isToggle);
            cleanupEditModal();
        });
        modal.querySelector('.cancel').addEventListener('click', cleanupEditModal);
        if (!isToggle) {
            const emptyBtn = modal.querySelector('.empty');
            if (emptyBtn) {
                emptyBtn.addEventListener('click', () => {
                    modal.querySelector('#edit-name').value = '';
                    modal.querySelector('#edit-url').value = '';
                    modal.querySelector('#edit-favicon').value = '';
                    const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                    let dataChanged = false;
                    if (originalBookmark !== null && originalBookmark !== undefined) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = null;
                        dataChanged = true;
                    } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = null;
                    if(dataChanged) {
                        saveCustomData();
                        showToast("Marcador vaciado y guardado.", "success");
                    } else {
                        oast("Marcador ya estaba vac√≠o.", "info");
                    }
                    updateGridItemUI(targetIndex, false);
                    cleanupEditModal();
                });
            }
            const searchUrlBtn = modal.querySelector('#search-url-button');
            const searchFaviconBtn = modal.querySelector('#search-favicon-button');
            const nameInput = modal.querySelector('#edit-name');
            const urlInputSearch = modal.querySelector('#edit-url');
            const faviconInputSearch = modal.querySelector('#edit-favicon');
            if (searchUrlBtn) {
                searchUrlBtn.addEventListener('click', () => {
                    const urlValue = urlInputSearch.value.trim();
                    const nameValue = nameInput.value.trim();
                    const query = urlValue || nameValue;
                    if (query) { window.open(`https://www.google.com/search?q=${encodeURIComponent(query)}`, '_blank'); }
                    else { showToast("Escribe un Nombre o URL para buscar.", "warning"); }
                });
            }
            if (searchFaviconBtn) {
                searchFaviconBtn.addEventListener('click', () => {
                    const faviconValue = faviconInputSearch.value.trim();
                    const nameValue = nameInput.value.trim();
                    const query = faviconValue || nameValue;
                    if (query) { window.open(`https://www.google.com/search?tbm=isch&q=${encodeURIComponent(`"${query}" favicon logo icon`)}`, '_blank'); }
                    else { showToast("Escribe un Nombre o URL de Favicon para buscar.", "warning"); }
                });
            }
        }
    }    

// ===================================================================
// NOMBRE: startEditMessage 
// RESUMEN: Prepara la UI para editar un mensaje existente.
function startEditMessage(messageId, content) {
    const messageInput = document.getElementById('chat-message-input');
    const sendButton = document.getElementById('chat-send-button');

    if (messageInput && sendButton) {
        messageInput.value = content;
        messageInput.dataset.editingMessageId = messageId;
        sendButton.textContent = 'Actualizar';
        messageInput.focus();
        }
}

// ===================================================================
// NOMBRE: deleteChatMessage 
// RESUMEN: Elimina un mensaje del chat y de Firebase previa confirmaci√≥n.
async function deleteChatMessage(messageId) {
    if (!messageId) return;

    if (confirm('¬øEst√°s seguro de que deseas eliminar este mensaje permanentemente?')) {
        try {
            const messageRef = window.doc(window.db, 'chatMessages', messageId);
            await window.deleteDoc(messageRef);
            
            openChatModal(); 

        } catch (error) {
        }
    }
}   
// ===================================================================
// NOMBRE: closeChatModal 
// RESUMEN: Cierra el modal, detiene timers y limpia el contenido para liberar memoria.
function closeChatModal() {
    const modalOverlay = document.getElementById('chat-modal-overlay');
    if (modalOverlay) {
        modalOverlay.classList.add('hidden');
    }
    document.body.classList.remove('chat-open'); 
    if (chatUpdateInterval) {
        clearInterval(chatUpdateInterval);
        chatUpdateInterval = null;
    }
    
    const messagesContainer = document.getElementById('chat-messages-container');
    const usersListContainer = document.getElementById('chat-users-list');

    if (messagesContainer) {
        messagesContainer.innerHTML = ''; 
    }
    if (usersListContainer) {
        usersListContainer.innerHTML = ''; 
    }
    
    lastVisibleUserDoc = null;
    lastVisibleMessageDoc = null;
    isFetchingUsers = false;
    isFetchingMessages = false;
}

// ===================================================================
// NOMBRE: updateTotalMessageCount 
// RESUMEN: Actualiza el contador de mensajes en el nuevo globo principal.
async function updateTotalMessageCount() {
    const globeButton = document.getElementById('chat-icon-button');
    const globeCounter = document.getElementById('chat-message-globe');
    if (!globeButton || !globeCounter || !window.db) return;

    try {
        const ninetySixHoursAgo = new Date(Date.now() - 96 * 60 * 60 * 1000);
        const messagesRef = window.collection(window.db, 'chatMessages');
        const q = window.query(messagesRef, window.where('timestamp', '>', ninetySixHoursAgo));
        
        const querySnapshot = await window.getDocs(q);
        const count = querySnapshot.size;

        if (count > 0) {
            globeCounter.textContent = count;
            globeButton.classList.remove('hidden');
        } else {
            globeCounter.textContent = '0';
             
        }
    } catch (error) {
        globeCounter.textContent = 'X';
        globeButton.classList.remove('hidden');
    }
}    

// ===================================================================
// NOMBRE: sendMessage 
// RESUMEN: Env√≠a mensajes/encuestas y fuerza la actualizaci√≥n inmediata del chat.
async function sendMessage() {
    const messageInput = document.getElementById('chat-message-input');
    const sendButton = document.getElementById('chat-send-button');
    const content = messageInput.value.trim();
    const editingId = messageInput.dataset.editingMessageId;

    if (!content) {
        showToast("El mensaje no puede estar vac√≠o.", "warning");
        return;
    }
    
    const currentUserId = localStorage.getItem('userData_userId');
    if (!currentUserId) {
        showToast("Error: No se ha podido identificar al usuario.", "error");
        return;
    }
    
    sendButton.disabled = true;

    try {
        if (content.toUpperCase().startsWith('#COMUNIDAD#')) {
            const parts = content.split('#');
            if (parts.length < 4 || !parts[2] || !parts[3]) {
                throw new Error("Formato de encuesta incorrecto. Use #COMUNIDAD#Pregunta#Opci√≥n1 $ Opci√≥n2 ...");
            }
            
            const question = parts[2].trim();
            const options = parts[3].split('$').map(opt => opt.trim()).filter(Boolean);

            if (options.length < 2 || options.length > 6) {
                throw new Error("Las encuestas deben tener entre 2 y 6 opciones.");
            }
            if (!question) {
                throw new Error("La pregunta de la encuesta no puede estar vac√≠a.");
            }

            const newPoll = {
                senderId: currentUserId,
                question: question,
                options: options,
                timestamp: window.serverTimestamp(),
                votes: {}
            };

            await window.addDoc(window.collection(window.db, 'chatPolls'), newPoll);
            messageInput.value = '';

        } else if (editingId) {
            const messageRef = window.doc(window.db, 'chatMessages', editingId);
            await window.setDoc(messageRef, { content: content }, { merge: true });
            
            messageInput.value = '';
            delete messageInput.dataset.editingMessageId;
            sendButton.textContent = 'Enviar';
            showToast("Mensaje actualizado correctamente.", "success");

        } else {
            if (content.length > 500) {
                showToast("El mensaje excede los 500 caracteres.", "warning");
                sendButton.disabled = false;
                return;
            }
            
            let recipientId = 'public';
            let messageContent = content;
            const mentionMatch = content.match(/^@(\w+)\s/);
            
            if (mentionMatch) {
                const mentionedUser = mentionMatch[1];
                const usersRef = window.collection(window.db, "user_data");
                const q = window.query(usersRef, window.where("rss", "==", true));
                const querySnapshot = await window.getDocs(q);
                let foundRecipientId = null;

                querySnapshot.forEach(doc => {
                    const userData = doc.data();
                    const actualUserId = userData.usuario || doc.id;
                    if (actualUserId.toLowerCase() === mentionedUser.toLowerCase()) {
                        foundRecipientId = actualUserId;
                    }
                });

                if (foundRecipientId) {
                    recipientId = foundRecipientId;
                    messageContent = content.substring(mentionMatch[0].length).trim();
                } else {
                    showToast(`Usuario "@${mentionedUser}" no encontrado o no tiene MDs activados.`, "warning");
                    sendButton.disabled = false;
                    return;
                }
            }

            const newMessage = {
                senderId: currentUserId,
                recipientId: recipientId,
                content: messageContent,
                timestamp: window.serverTimestamp()
            };
            
            await window.addDoc(window.collection(window.db, 'chatMessages'), newMessage);
            messageInput.value = '';
        }
        
        messageInput.dispatchEvent(new Event('input')); 
        lastVisibleMessageDoc = null; // <-- Resetea la paginaci√≥n para la recarga
        await fetchAndRenderChatMessages(false); // <-- Vuelve a llamar al renderizado

    } catch (error) {
        showToast(error.message || (editingId ? "Error al actualizar." : "Error al enviar."), "error");
    } finally {
        sendButton.disabled = false;
    }
}    

    // ===================================================================
    // NOMBRE: filterGridItems
    // RESUMEN: Filtra los elementos del grid seg√∫n el texto del filtro y los toggles de secci√≥n.
    function filterGridItems() {
        const filterInput = document.getElementById('grid-filter-input');
        const clearButton = document.getElementById('clear-filter-button');
        if (!filterInput || !clearButton || !cellElements || cellElements.length === 0) { return; }
        if (isKeywordAssignmentMode) {
            cellElements.forEach(cellContainer => { cellContainer.classList.remove('hidden'); });
            clearButton.style.display = filterInput.value.trim() ? 'inline-block' : 'none';
            return;
        }
        const rawFilterText = filterInput.value.trim();
        clearButton.style.display = rawFilterText ? 'inline-block' : 'none';
        const filterWords = rawFilterText.split(/\s+/).filter(word => word.length > 0).map(word => normalizeText(word));
        const onOffToggleElem = document.getElementById('on-off-toggle');
        const masterState = onOffToggleElem ? (onOffToggleElem.dataset.state || 'on') : 'on';
        cellElements.forEach((cellContainer, index) => {
            const isMasterOff = masterState === 'off';
            if (isMasterOff) {
                cellContainer.classList.add('hidden');
                return;
            }
            const bookmark = currentBookmarks[index];
            const bookmarkName = bookmark ? normalizeText(bookmark.name) : '';
            const isEmptySlot = !bookmark;
            let matchesFilter = true;
            if (filterWords.length > 0) {
                if (isEmptySlot) {
                    matchesFilter = false;
                } else {
                    matchesFilter = filterWords.every(word => bookmarkName.includes(word));
                }
            }
            const shouldBeHiddenByFilter = filterWords.length > 0 && !matchesFilter;
            let shouldBeHiddenByToggles = false;
            const containingRange = getSectionForIndex(index);
            if (containingRange) {
                const toggleButton = toggleButtonElements[containingRange.start] || document.querySelector(`.range-toggle[data-range-start="${containingRange.start}"]`);
                if (toggleButton) {
                    const toggleState = toggleButton.dataset.state || 'visible';
                    shouldBeHiddenByToggles = toggleState === 'hidden';
                }
            } else {
                shouldBeHiddenByToggles = false;
            }
            const shouldBeHidden = shouldBeHiddenByToggles || shouldBeHiddenByFilter;
            cellContainer.classList.toggle('hidden', shouldBeHidden);
        });
    }
    
    // ===================================================================
    // NOMBRE: promptForPin
    // RESUMEN: Muestra el modal para introducir el PIN de acceso.
    function promptForPin() { const pinModal = document.getElementById('pin-modal-overlay'); const pinInput = document.getElementById('pin-input'); const pinSubmit = document.getElementById('pin-submit-button'); const pinError = document.getElementById('pin-error-message'); pinModal.classList.remove('hidden');
        pinInput.value = ''; pinError.textContent = ''; pinInput.focus(); const newPinSubmit = pinSubmit.cloneNode(true); pinSubmit.parentNode.replaceChild(newPinSubmit, pinSubmit); newPinSubmit.addEventListener('click', checkPin); pinInput.addEventListener('keyup', (event) => { if (event.key === 'Enter') { checkPin(); } }); }
    
    
    // ===================================================================
    // NOMBRE: checkPin
    // RESUMEN: Verifica el PIN introducido por el usuario.
    function checkPin() { const pinModal = document.getElementById('pin-modal-overlay'); const pinInput = document.getElementById('pin-input'); const pinError = document.getElementById('pin-error-message'); const enteredPin = pinInput.value; if (enteredPin === storedPin) { pinModal.classList.add('hidden'); initializeApp(); } else { pinError.textContent = 'Clave incorrecta.'; pinInput.value = ''; pinInput.focus(); if (navigator.vibrate) navigator.vibrate(100); } }
    
    // ===================================================================
    // NOMBRE: handlePasswordToggleClick
    // RESUMEN: Activa o desactiva la solicitud de PIN al inicio.
    function handlePasswordToggleClick() { if (!storedPin) { showToast('Primero establece una clave en Configuraci√≥n -> Usuario.', 'warning'); return; } isPasswordActive = !isPasswordActive; updatePasswordToggleIcon(); saveSettings(); showToast(`Solicitar clave al inicio: ${isPasswordActive ? 'Activado' : 'Desactivado'}`, 'info'); }
    
    
    // ===================================================================
    // NOMBRE: updatePasswordToggleIcon
    // RESUMEN: Actualiza el icono del candado seg√∫n si el PIN est√° activo o no.
    function updatePasswordToggleIcon() { const passwordButton = document.getElementById('password-toggle-button'); if (passwordButton) { const img = passwordButton.querySelector('img'); if(img) { const iconPath = isPasswordActive ? 'PNG/IMG_4281.png' : 'PNG/IMG_4280.png'; img.src = `https://boardinggate.github.io/Tesla/${iconPath}`;
        img.alt = isPasswordActive ? 'Clave Activada' : 'Clave Desactivada'; passwordButton.title = `Clave al inicio: ${isPasswordActive ? 'Activada' : 'Desactivada'}`; } } }
    
    // ===================================================================
    // NOMBRE: savePinSettings
    // RESUMEN: Guarda las nuevas configuraciones de PIN y preferencias de inicio.
    function savePinSettings() {
        const pinSetInput = document.getElementById('config-pin-set');
        const pinConfirmInput = document.getElementById('config-pin-confirm');
        const pinStatus = document.getElementById('config-pin-status');
        const directToNavCheckbox = document.getElementById('config-direct-to-nav');
        const newPin = pinSetInput.value;
        const confirmPin = pinConfirmInput.value;
        pinStatus.textContent = '';
        let keySaved = false;
        let prefSaved = false;
        if (newPin || confirmPin) {
            if (!/^\d{4}$/.test(newPin)) {
                pinStatus.textContent = 'La clave debe tener exactamente 4 cifras.';
                pinStatus.style.color = '#EF4444';
                return;
            }
            if (newPin !== confirmPin) {
                pinStatus.textContent = 'Las claves no coinciden.';
                pinStatus.style.color = '#EF4444';
                return;
            }
            try {
                localStorage.setItem('password_pin', newPin);
                storedPin = newPin;
                if (!localStorage.getItem('password_active') || isPasswordActive) {
                    isPasswordActive = true;
                    localStorage.setItem('password_active', 'true');
                }
                pinStatus.textContent = 'Clave guardada. ';
                pinStatus.style.color = '#28a745';
                pinSetInput.value = '';
                pinConfirmInput.value = '';
                updatePasswordToggleIcon();
                keySaved = true;
            } catch (e) {
                pinStatus.textContent ='Error al guardar la clave.';
                pinStatus.style.color = '#EF4444';
                showToast('Error al guardar la clave.', 'error');
            }
        }
        const directToNavChecked = directToNavCheckbox.checked;
        localStorage.setItem(DIRECT_TO_NAVIGATION_KEY, JSON.stringify(directToNavChecked));
        prefSaved = true;
        if (keySaved && prefSaved) {
            showToast('Clave y preferencia de inicio guardadas.', 'success');
            pinStatus.textContent += (pinStatus.textContent ? "Y " : "") + "Preferencia de inicio guardada.";
             pinStatus.style.color = '#28a745';
        } else if (keySaved) {
            showToast('Clave guardada. Preferencia de inicio tambi√©n actualizada.', 'success');
             pinStatus.textContent += (pinStatus.textContent ? " " : "") + "Preferencia de inicio guardada.";
             pinStatus.style.color = '#28a745';
        } else if (prefSaved) {
            showToast('Preferencia de inicio guardada.', 'success');
            pinStatus.textContent = "Preferencia de inicio guardada.";
            pinStatus.style.color = '#28a745';
        } else if (!newPin && !confirmPin) {
             pinStatus.textContent = "No se realizaron cambios en la clave. Preferencia de inicio no cambi√≥.";
             pinStatus.style.color = '#17a2b8';
        }
        saveSettings();
    }
    
    // ===================================================================
    // NOMBRE: removePinSettings
    // RESUMEN: Elimina la configuraci√≥n de PIN de acceso.
    function removePinSettings() { const pinStatus = document.getElementById('config-pin-status'); if (confirm('¬øEst√°s seguro de que deseas eliminar la clave de acceso? Ya no se solicitar√° al inicio.')) { try { localStorage.removeItem('password_pin'); localStorage.setItem('password_active', 'false'); storedPin = null; isPasswordActive = false; pinStatus.textContent = 'Clave eliminada.'; pinStatus.style.color = '#17a2b8'; document.getElementById('config-pin-set').value = ''; document.getElementById('config-pin-confirm').value = ''; updatePasswordToggleIcon(); saveSettings(); showToast('Clave eliminada.', 'info'); } catch (e) { pinStatus.textContent = 'Error al eliminar la clave.'; pinStatus.style.color = '#EF4444'; showToast('Error al eliminar la clave.', 'error'); } } }
    
    // ===================================================================
    // NOMBRE: getRemoteUpdatesDate
    // RESUMEN: Obtiene la fecha de la √∫ltima actualizaci√≥n de un archivo remoto.
    async function getRemoteUpdatesDate() { try { const response = await fetch('https://boardinggate.github.io/Tesla/updates.txt', { cache: 'no-cache' }); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const text = await response.text(); const firstLine = text.split('\n')[0].trim(); const dateMatch = firstLine.match(/^\d{4}-\d{2}-\d{2}/); if (dateMatch) { const [year, month, day] = dateMatch[0].split('-').map(Number); const remoteDate = new Date(Date.UTC(year, month - 1, day)); if (!isNaN(remoteDate.getTime())) { return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`; } } return null; } catch (e) { return null; } }
    
    // ===================================================================
    // NOMBRE: isRemoteDateNewer
    // RESUMEN: Compara si una fecha remota es m√°s reciente que una fecha en cach√©.
    function isRemoteDateNewer(remoteDateStr, cachedDateStr) { if (!remoteDateStr) return false; if (!cachedDateStr) return true; try { return remoteDateStr > cachedDateStr; } catch (e) { return false; } }
    
    // ===================================================================
    // NOMBRE: checkVersionsIconOpacity
    // RESUMEN: Ajusta la opacidad del icono de versiones si hay actualizaciones nuevas.
    async function checkVersionsIconOpacity() { const versionsIcon = document.getElementById('versions-button'); const versionsImg = versionsIcon ? versionsIcon.querySelector('img') : null; if (!versionsImg) return;
        let showAsNew = false; const remoteDateStr = await getRemoteUpdatesDate();
        if (remoteDateStr) { showAsNew = isRemoteDateNewer(remoteDateStr, lastUpdatesCheckDate); } versionsImg.style.opacity = showAsNew ? '1.0' : '0.1';
    }
    
// ===================================================================
// NOMBRE: showVersionsModal 
// RESUMEN: Muestra el modal con el historial de versiones y limpia el contenido al cerrar.
// ===================================================================
async function showVersionsModal() {
    const versionsModalOverlay = document.getElementById('versions-modal-overlay');
    const versionsContent = document.getElementById('versions-content');
    const closeButton = document.getElementById('close-versions-modal');
    if (!versionsModalOverlay || !versionsContent || !closeButton) return;

    const newCloseButton = closeButton.cloneNode(true);
    closeButton.parentNode.replaceChild(newCloseButton, closeButton);

    const closeHandler = () => {
        versionsModalOverlay.classList.add('hidden');
        clearModalAutoCloseTimer(versionsModalOverlay, newCloseButton, 'versions-modal');
        
        versionsContent.textContent = ''; // Vaciamos el contenido para que el recolector de basura act√∫e
    };

    newCloseButton.addEventListener('click', closeHandler);

    versionsContent.textContent = 'Cargando hist√≥rico...';
    versionsModalOverlay.classList.remove('hidden');
    addModalAutoCloseTimer(versionsModalOverlay, newCloseButton, 'versions-modal');

    try {
        const response = await fetch('https://boardinggate.github.io/Tesla/updates.txt', { cache: 'no-cache' });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const text = await response.text();
        versionsContent.textContent = text;
        
        const firstLine = text.split('\n')[0].trim();
        const dateMatch = firstLine.match(/^\d{4}-\d{2}-\d{2}/);
        let dateToStore = null;
        if (dateMatch) {
            const [year, month, day] = dateMatch[0].split('-').map(Number);
            const checkDate = new Date(Date.UTC(year, month - 1, day));
            if (!isNaN(checkDate.getTime())) {
                dateToStore = dateMatch[0];
            }
        }

        if (dateToStore) {
            lastUpdatesCheckDate = dateToStore;
        } else {
            const today = new Date();
            lastUpdatesCheckDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
        }
        
        saveSettings();
        await checkVersionsIconOpacity();
    } catch (e) {
        versionsContent.textContent = `Error al cargar el hist√≥rico:\n${e.message}`;
    }
}    
    
    // ===================================================================
    // NOMBRE: getCurrentLocation
    // RESUMEN: Obtiene la ubicaci√≥n actual del dispositivo a trav√©s de la API de Geolocalizaci√≥n.
    function getCurrentLocation(callback, errorCallback) {
        if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    callback({
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy,
                        altitude: position.coords.altitude,
                        heading: position.coords.heading,
                        speed: position.coords.speed
                    });
                },
                (error) => {
                    let message = "No se pudo obtener la ubicaci√≥n.";
                    switch (error.code) {
                        case error.PERMISSION_DENIED:
                            message = "Permiso de ubicaci√≥n denegado.";
                            break;
                        case error.POSITION_UNAVAILABLE:
                            message = "Informaci√≥n de ubicaci√≥n no disponible.";
                            break;
                        case error.TIMEOUT:
                            message = "Timeout obteniendo ubicaci√≥n.";
                            break;
                    }
                    if (errorCallback) errorCallback(message);
                    else showToast(message, "error");
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        } else {
            const message = "Geolocalizaci√≥n no soportada por este navegador.";
            if (errorCallback) errorCallback(message);
            else showToast(message, "error");
        }
    }
    
    // ===================================================================
    // NOMBRE: calculateDistance
    // RESUMEN: Calcula la distancia en metros entre dos coordenadas geogr√°ficas.
    function calculateDistance(lat1, lon1, lat2, lon2) {
        if (typeof lat1 !== 'number' || typeof lon1 !== 'number' || typeof lat2 !== 'number' || typeof lon2 !== 'number' || isNaN(lat1) || isNaN(lon1) || isNaN(lat2) || isNaN(lon2)) {
             return Infinity;
        }
        const R = 6371e3; 
        const œÜ1 = lat1 * Math.PI / 180; 
        const œÜ2 = lat2 * Math.PI / 180; 
        const ŒîœÜ = (lat2 - lat1) * Math.PI / 180; 
        const ŒîŒª = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return R * c;
    }
    
    // ===================================================================
    // NOMBRE: restoreCacheForMobile
    // RESUMEN: Descarga silenciosamente la cach√© de Firebase al iniciar en m√≥vil.
    async function restoreCacheForMobile() {
        const { primaryId } = parseUserId(localStorage.getItem('userData_userId'));
        if (!primaryId) return;
        const result = await callFirebase('getUserData', { userId: primaryId });
        if (result.status === 'success' && result.data) {
            const backupCacheData = result.data.contenidoCacheCompleto;
            if (backupCacheData) {
                showToast('Sincronizando datos desde la nube...', 'info', 2000);
                const currentUserIdentity = localStorage.getItem('userData_userId');
                for (const key in backupCacheData) {
                    if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                        localStorage.setItem(key, backupCacheData[key]);
                    }
                }
                if (currentUserIdentity) {
                    localStorage.setItem('userData_userId', currentUserIdentity);
                }
                loadCustomData();
                loadSavedSettings();
                updateUserIdDisplay();
                markCacheAsDirty();
            }
        }
}

// ===================================================================
// NOMBRE: showPostArrivalActionModal 
// RESUMEN: Muestra un modal persistente con opciones despu√©s de llegar a un destino,
function showPostArrivalActionModal() {
    hidePostArrivalActionModal(); 

    const modal = document.createElement('div');
    modal.id = 'post-arrival-action-modal';
    
    // Se utiliza una estructura y clases similares a 'auto-start-nav-modal' para replicar el estilo
    modal.innerHTML = `
        <div id="post-arrival-buttons-container">
            <button id="return-trip-button" class="primary-action-btn" title="Crea e inicia una ruta de vuelta desde tu posici√≥n actual.">
                <span class="icon">üîÑ</span>
                <span>Viajar de VUELTA</span>
            </button>
            <button id="clear-completed-route-button" class="secondary-action-btn" title="Limpia la ruta actual del mapa.">
                <span class="icon">üóëÔ∏è</span>
                <span>Borrar Ruta</span>
            </button>
            <button id="post-arrival-exit-button" class="secondary-action-btn" title="Cierra este men√∫ de acciones.">
                <span class="icon">‚ùå</span>
                <span>Cancelar</span>
            </button>
        </div>
    `;

    document.body.appendChild(modal);

    document.getElementById('return-trip-button').addEventListener('click', () => {
        createAndLoadReturnTrip();
        hidePostArrivalActionModal();
    });

    document.getElementById('clear-completed-route-button').addEventListener('click', () => {
        handleLoadOrDeleteRouteClick(null);
        hidePostArrivalActionModal();
    });

    document.getElementById('post-arrival-exit-button').addEventListener('click', () => {
        hidePostArrivalActionModal();
    });
}

// ===================================================================
// NOMBRE: hidePostArrivalActionModal 
// RESUMEN: Oculta y elimina el modal de acciones post-llegada.
// ===================================================================
function hidePostArrivalActionModal() {
    const modal = document.getElementById('post-arrival-action-modal');
    if (modal) {
        modal.remove();
    }
}
    
// ===================================================================
// NOMBRE: hideUnifiedReminderWindow
// RESUMEN: Oculta la ventana unificada de recordatorios y limpia sus elementos.
function hideUnifiedReminderWindow() {
    if (realtimeSpeedUpdateInterval) {
        clearInterval(realtimeSpeedUpdateInterval);
        realtimeSpeedUpdateInterval = null;
    }
    const windowElement = document.getElementById('unified-reminder-window');
    if (windowElement && windowElement.classList.contains('visible')) {
        windowElement.classList.remove('visible');
        isUnifiedWindowVisibleByLogic = false;
        const swiperContainer = document.getElementById('reminder-swiper-container');
        Object.values(previewMaps).forEach(map => {
            if (map && typeof map.remove === 'function') {
                map.remove();
            }
        });
        previewMaps = {};
        if (swiperContainer) {
            swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay);
            setTimeout(() => {
                if (swiperContainer && !windowElement.classList.contains('visible')) {
                    swiperContainer.innerHTML = '';
                }
            }, 600);
        }
        const hideAllButton = document.getElementById('hide-all-reminders-button');
        if (hideAllButton) { const newHideAllButton = hideAllButton.cloneNode(true); hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton); }
        const mapShouldReopen = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
        const mapContextToReopen = sessionStorage.getItem('mapContext');
        sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
        if (mapShouldReopen &&
            !document.querySelector('.reminder-modal') &&
            !document.querySelector('.reminder-table-modal') &&
            !document.getElementById('reminders-location-map-modal')
           ) {
             if (mapContextToReopen === 'navigation') openNavigationMap();
              sessionStorage.removeItem('mapContext');
        }
    }
}
    
// ===================================================================
// NOMBRE: postponeAllVisibleReminders
// RESUMEN: Pospone todos los recordatorios actualmente visibles en la ventana unificada.
function postponeAllVisibleReminders() {
    const swiperContainer = document.getElementById('reminder-swiper-container'); if (!swiperContainer) return;
    const visibleSlides = swiperContainer.querySelectorAll('.reminder-slide'); if (visibleSlides.length === 0) return;
    let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    let updated = false;
    const idsToUpdate = [];
    visibleSlides.forEach(slide => {
        const reminderId = parseInt(slide.dataset.id);
        if (isNaN(reminderId)) return;
        idsToUpdate.push(reminderId);
        const index = reminders.findIndex(r => r.id === reminderId);
        if (index !== -1) {
            const { newDateISO, newTime } = calculatePostponedDateTime(1);
            reminders[index].date = newDateISO;
            reminders[index].time = newTime;
            reminders[index].managedByUser = false;
            updated = true;
        }
    });
    if (updated) {
        localStorage.setItem('reminders', JSON.stringify(reminders));
        
        markCacheAsDirty();
        showToast(`${idsToUpdate.length} recordatorio(s) pospuesto(s) 1 minuto`, 'info');
        idsToUpdate.forEach(id => updateUnifiedWindowUI(id)); // Esto es para la UI, no afecta la l√≥gica.
        updateReminderCount();
        updateButtonStyles();
    }
    if (idsToUpdate.length > 0 && document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
       hideUnifiedReminderWindow();
    }
}

    
    // ===================================================================
    // NOMBRE: updateReminderIndexDisplay
    // RESUMEN: Actualiza el contador de √≠ndice del slide actual en la ventana unificada.
    function updateReminderIndexDisplay() {
        const swiperContainer = document.getElementById('reminder-swiper-container');
        const currentIndexSpan = document.getElementById('current-reminder-index');
        if (!swiperContainer || !currentIndexSpan) return;
        const totalSlides = swiperContainer.querySelectorAll('.reminder-slide').length;
        if (totalSlides === 0) {
            currentIndexSpan.textContent = '0';
            return;
        }
        const containerWidth = swiperContainer.offsetWidth;
        if (containerWidth <= 0) {
           return;
        }
        const currentScroll = swiperContainer.scrollLeft;
        const currentIndex = Math.round(currentScroll / containerWidth);
        currentNotificationSlideIndex = currentIndex;
        const displayIndex = Math.max(1, Math.min(currentIndex + 1, totalSlides));
        currentIndexSpan.textContent = displayIndex;
         const currentSlideElement = swiperContainer.querySelectorAll('.reminder-slide')[currentIndex];
         if (currentSlideElement && !isNavigationMapActive) {
            const mapId = currentSlideElement.querySelector('.reminder-map-preview')?.id;
            if (mapId) {
                 const reminderId = parseInt(mapId.replace('map-preview-', ''));
                 if (previewMaps[reminderId]) {
                     setTimeout(() => { if(previewMaps[reminderId]) previewMaps[reminderId].resize(); }, 50);
                 }
            }
         }
    }
    
    // ===================================================================
    // NOMBRE: updateUnifiedWindowUI
    // RESUMEN: Actualiza la UI de la ventana unificada despu√©s de que un recordatorio es gestionado.
    function updateUnifiedWindowUI(processedReminderId) {
        const windowElement = document.getElementById('unified-reminder-window');
        const swiperContainer = document.getElementById('reminder-swiper-container');
        const slideToRemove = swiperContainer ? swiperContainer.querySelector(`.reminder-slide[data-id="${processedReminderId}"]`) : null;
        if (previewMaps[processedReminderId]) {
           if (typeof previewMaps[processedReminderId].remove === 'function') {
               previewMaps[processedReminderId].remove();
           }
           delete previewMaps[processedReminderId];
        }
        if (slideToRemove && slideToRemove.parentNode === swiperContainer) {
            swiperContainer.removeChild(slideToRemove);
        }
        const remainingSlides = swiperContainer ? swiperContainer.querySelectorAll('.reminder-slide') : [];
        const remainingCount = remainingSlides.length;
        if (remainingCount === 0) {
            hideUnifiedReminderWindow();
        }
        else {
            const countHeader = windowElement.querySelector('.reminder-count-header');
            const countSpan = document.getElementById('total-reminder-count');
            const countTextContainer = document.getElementById('reminder-count-text-container');
            const swipeHint = document.getElementById('reminder-swipe-hint');
            countSpan.textContent = remainingCount;
            updateReminderIndexDisplay();
            if (remainingCount > 1) {
                countTextContainer.style.display = 'inline';
                swipeHint.style.display = 'block';
                document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = 'calc(85vh - 60px)');
            } else {
                countTextContainer.style.display = 'none';
                swipeHint.style.display = 'none';
                document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = '85vh');
            }
            const maxScrollIndex = remainingCount - 1;
            if (currentNotificationSlideIndex > maxScrollIndex) {
                 currentNotificationSlideIndex = maxScrollIndex;
                 swiperContainer.scrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
                 updateReminderIndexDisplay();
            }
        }
        updateReminderCount();
        updateButtonStyles();
    }
    
    
    // ===================================================================
    // NOMBRE: updateReminderCount
    // RESUMEN: Actualiza los contadores de recordatorios en la UI.
    function updateReminderCount() {
         let reminders = []; try { reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); } catch (e) { reminders = []; }
         const showExcludedInTable = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false; let remindersForCount = reminders;
         if (!showExcludedInTable) { remindersForCount = reminders.filter(r => !r.excludeFromList); }
         const totalCount = remindersForCount.length; const nonCyclicReminders = remindersForCount.filter(r => r.type !== 'weekly' && r.type !== 'interval'); const nonCyclicCount = nonCyclicReminders.length;
         const countElGlobe = document.getElementById('reminder-count-globe'); if (countElGlobe) { countElGlobe.textContent = nonCyclicCount > 0 ? nonCyclicCount : ''; countElGlobe.style.display = nonCyclicCount > 0 ? 'flex' : 'none'; }
         const reminderButtonElem = document.getElementById('reminder-button'); if (reminderButtonElem) { let countSpanSide = reminderButtonElem.querySelector('.reminder-count'); if (totalCount > 0) { if (!countSpanSide) { countSpanSide = document.createElement('span'); countSpanSide.className = 'reminder-count'; reminderButtonElem.appendChild(countSpanSide); } countSpanSide.textContent = totalCount; } else { if (countSpanSide) { countSpanSide.remove(); } } }
    }
        
 
// ===================================================================
// NOMBRE: formatTimeWithPeriod
// RESUMEN: Formatea una hora (HH:MM) para a√±adir un per√≠odo del d√≠a (Ma√±ana, Tarde, etc.).
function formatTimeWithPeriod(timeString) {
     if (!timeString || !timeString.match(/^\d{2}:\d{2}$/)) return '-';
     try {
         const [hourStr, minuteStr] = timeString.split(':');
         const hour = parseInt(hourStr);
         const minute = parseInt(minuteStr);
         if (isNaN(hour) || isNaN(minute) || hour < 0 || hour > 23 || minute < 0 || minute > 59) {
             return timeString;
         }
         let period = '';
         if (hour >= 22 || hour < 5) { period = 'de la Noche'; }
         else if (hour >= 5 && hour < 12) { period = 'de la Ma√±ana'; }
         else if (hour >= 12 && hour < 14) { period = 'del Mediod√≠a'; }
         else { period = 'de la Tarde'; }
         return `${hourStr}:${minuteStr} (${period})`;
     } catch (e) {
         return timeString;
     }
}

// ===================================================================
// NOMBRE: formatDateDetailed
// RESUMEN: Formatea una fecha (YYYY-MM-DD) a un formato m√°s legible (DD-Mes-YYYY).
function formatDateDetailed(dateString) {
    if (!dateString || !dateString.match(/^\d{4}-\d{2}-\d{2}$/)) return '-';
    try {
        const [year, month, day] = dateString.split('-').map(Number);
        const date = new Date(Date.UTC(year, month - 1, day));
        if (isNaN(date.getTime())) return dateString;
        const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
        const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
        const monthName = monthNames[date.getUTCMonth()];
        const fullYear = date.getUTCFullYear();
        return `${dayOfMonth}-${monthName}-${fullYear}`;
    } catch (e) {
        return dateString;
    }
}

// ===================================================================
// NOMBRE: extractSpeedFromRadarText 
// RESUMEN: Extrae un l√≠mite de velocidad v√°lido (entre 20-130) del texto de un recordatorio.
function extractSpeedFromRadarText(text) {
    if (!text) return null;
    const cleanText = text.replace(/<[^>]*>/g, '').toUpperCase();
    const validSpeeds = [20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130];

    const kmMatch = cleanText.match(/\b(\d{2,3})\s*KM/);
    if (kmMatch && kmMatch[1]) {
        const speed = parseInt(kmMatch[1], 10);
        if (validSpeeds.includes(speed)) return speed;
    }
    
    const codeMatch = cleanText.match(/\b[FCN](\d{2,3})\b/);
    if (codeMatch && codeMatch[1]) {
        const speed = parseInt(codeMatch[1], 10);
        if (validSpeeds.includes(speed)) return speed;
    }
    
    const looseNumbers = cleanText.match(/\b(\d{2,3})\b/g);
    if (looseNumbers) {
        for (const numStr of looseNumbers) {
            const speed = parseInt(numStr, 10);
            if (validSpeeds.includes(speed)) {
                return speed; 
            }
        }
    }

    return null; 
}

//==================================================================   
//NOMBRE: displayUnifiedReminderWindow
function displayUnifiedReminderWindow(overdueReminders) {
    const windowElement = document.getElementById('unified-reminder-window');
    const swiperContainer = document.getElementById('reminder-swiper-container');
    const countHeader = windowElement.querySelector('.reminder-count-header');
    const countSpan = document.getElementById('total-reminder-count');
    const currentIndexSpan = document.getElementById('current-reminder-index');
    const countTextContainer = document.getElementById('reminder-count-text-container');
    const swipeHint = document.getElementById('reminder-swipe-hint');
    const hideAllButton = document.getElementById('hide-all-reminders-button');
    
    Object.values(previewMaps).forEach(map => {
       if (map && typeof map.remove === 'function') {
           map.remove();
       }
    });
    previewMaps = {};
 
    if (realtimeSpeedUpdateInterval) {
        clearInterval(realtimeSpeedUpdateInterval);
        realtimeSpeedUpdateInterval = null;
    }
    if (!windowElement || !swiperContainer || !countHeader || !countSpan || !currentIndexSpan || !countTextContainer || !swipeHint || !hideAllButton) {
        return;
    }
    swiperContainer.innerHTML = '';
    overdueReminders.sort((a, b) => { try { const dateA = new Date(`${a.date}T${a.time}:00Z`); const dateB = new Date(`${b.date}T${b.time}:00Z`); return dateA - dateB; } catch (e) { return 0; } });
    if (!isUnifiedWindowVisibleByLogic) {
        currentNotificationSlideIndex = 0;
    }
    overdueReminders.forEach((reminder, index) => {
        const slide = document.createElement('div');
        slide.className = 'reminder-slide';
        slide.dataset.id = reminder.id;
        slide.setAttribute('role', 'group');
        slide.setAttribute('aria-label', `Recordatorio: ${reminder.text.replace(/<[^>]*>/g, '')}`);
        
        let slideContentHtml = '';
        const isRadarAlert = reminder.text.toUpperCase().includes("RADAR");

        if (isRadarAlert) {
            const radarSpeed = extractSpeedFromRadarText(reminder.text);
            const validSpeeds = [20, 30, 50, 60, 70, 80, 90, 100, 110, 120];
            const isStandardSpeed = radarSpeed !== null && validSpeeds.includes(radarSpeed);

            let speedLimitHtml = '';
            let currentSpeedHtml = '';

            if (isStandardSpeed) {
                speedLimitHtml = `<p class="reminder-text" style="color: red; font-weight: bold; text-transform: uppercase; font-size: 1.8rem; margin-bottom: 0.2rem; text-align: center;">${radarSpeed} Km/h</p>`;
            } else {
                speedLimitHtml = `<p class="reminder-text" style="color: red; font-weight: bold; text-transform: uppercase; font-size: 1.4rem; margin-bottom: 0.2rem; text-align: center;">RADAR DE TRAMO o INDETERMINADO</p>`;
            }

            const carSpeed = Math.round(window.currentSpeedKmh || 0);
            const speedExceeded = isStandardSpeed && carSpeed > radarSpeed;
            
            currentSpeedHtml = `<p id="current-speed-display-${reminder.id}" style="text-align:center; font-size: 1.7rem; font-weight: bold; color: ${speedExceeded ? '#FF5938' : '#13bd60'};">[Velocidad actual: ${carSpeed} Km/h]</p>`;

            slideContentHtml = `
                <div class="reminder-slide-content">
                    <img src="https://boardinggate.github.io/Tesla/PNG/AGUARDIA.png" alt="Icono Radar" class="radar-icon">
                    <div class="reminder-content-scrollable">
                        ${speedLimitHtml}
                        ${currentSpeedHtml}
                        <p class="reminder-text" style="text-align: center; margin-top: 0.5rem; ${isStandardSpeed ? 'font-size: 1rem; color: #444;' : ''}">${reminder.text}</p>
                    </div>
                    <div class="button-group">
                        <button class="route-radar-seen" style="background-color: #2563EB; color: white; font-weight: bold; height: 70px; font-size: 1.2rem;">VISTO (Posponer 5 min)</button>
                        <button class="modify">Modificar</button>
                    </div>
                </div>
            `;
        } else {
            let detailsHtml = '';
            if (reminder.time) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Hora: ${formatTimeWithPeriod(reminder.time)}</p>`;
            if (reminder.date) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Fecha: ${formatDateDetailed(reminder.date)}</p>`;
            if (reminder.type === 'weekly' && reminder.repeatDays?.length > 0) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Repite: ${reminder.repeatDays.map(d => ['Dom', 'Lun', 'Mar', 'Mi√©', 'Jue', 'Vie', 'S√°b'][d]).join(', ')}</p>`;
            if (reminder.type === 'interval' && reminder.intervalDays) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Cada: ${reminder.intervalDays} d√≠as</p>`;
            if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Ubicaci√≥n: Activada (Radio ${reminder.radiusMeters || DEFAULT_LOCATION_RADIUS}m)</p>`;
            }
            const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval';
            const showAdjustButton = isCyclic && reminder.time !== '00:01';
            const adjustButtonHtml = showAdjustButton ? `<button class="adjust-time-0001">Ajustar Hora 00:01 y Visto</button>` : '';
            const cyclicCancelButtonHtml = isCyclic ? `<button class="cancel-cyclic">Anular Ciclo</button>` : '';
            
            const buttonsHtml = `
                <div class="button-group">
                    <button class="cancel">Visto / Pr√≥ximo</button>
                    <button class="postpone">Posponer</button>
                    <button class="modify">Modificar</button>
                    ${adjustButtonHtml}
                    ${cyclicCancelButtonHtml}
                </div>`;

            const mapPreviewHtml = '';

            slideContentHtml = `
                <div class="reminder-slide-content">
                    <div class="reminder-content-scrollable">
                        <p class="reminder-text">${reminder.text}</p>
                        ${detailsHtml}
                    </div>
                    ${buttonsHtml} 
                </div>
                ${mapPreviewHtml}
            `;
        }
        
        slide.innerHTML = slideContentHtml;

        addSlideButtonListeners(slide, reminder);
        swiperContainer.appendChild(slide);
    });
    const count = overdueReminders.length;
    countSpan.textContent = count;
    if (count > 0) {
         if (currentNotificationSlideIndex >= count) {
             currentNotificationSlideIndex = 0;
         }
         swiperContainer.scrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
         updateReminderIndexDisplay();
         countHeader.classList.remove('hidden');
         if (count > 1) {
            countTextContainer.style.display = 'inline';
            swipeHint.style.display = 'block';
            document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = 'calc(85vh - 60px)');
         } else {
            countTextContainer.style.display = 'none';
            swipeHint.style.display = 'none';
            document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = '85vh');
         }
          hideAllButton.classList.remove('hidden');
          const newHideAllButton = hideAllButton.cloneNode(true);
          hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton);
          newHideAllButton.addEventListener('click', postponeAllVisibleReminders);
          
          realtimeSpeedUpdateInterval = setInterval(() => {
              if (!windowElement.classList.contains('visible')) {
                  clearInterval(realtimeSpeedUpdateInterval);
                  realtimeSpeedUpdateInterval = null;
                  return;
              }
              const carSpeed = Math.round(window.currentSpeedKmh || 0);
              overdueReminders.forEach(reminder => {
                  if(reminder.text.toUpperCase().includes("RADAR")) {
                      const speedDisplayElement = document.getElementById(`current-speed-display-${reminder.id}`);
                      if (speedDisplayElement) {
                          const radarSpeed = extractSpeedFromRadarText(reminder.text);
                          const speedExceeded = radarSpeed !== null && carSpeed > radarSpeed;
                          speedDisplayElement.textContent = `[Velocidad actual: ${carSpeed} Km/h]`;
                          speedDisplayElement.style.color = speedExceeded ? '#FF5938' : '#13bd60';
                      }
                  }
              });
          }, 500);

    } else {
        countHeader.classList.add('hidden');
        hideAllButton.classList.add('hidden');
        currentNotificationSlideIndex = 0;
    }
    windowElement.classList.add('visible');
    isUnifiedWindowVisibleByLogic = true;
    swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay);
    swiperContainer.addEventListener('scroll', updateReminderIndexDisplay);
}      

// ===================================================================
// NOMBRE: updateChartData 
// RESUMEN: Actualiza los datos y la configuraci√≥n de la gr√°fica de navegaci√≥n, adaptando el t√≠tulo y contenido para el modo "Free Drive".
function updateChartData() {
    if (!navigationChart) return;
    const graphCard = document.getElementById('navigation-graph-card');
    const isEnlarged = graphCard ? graphCard.classList.contains('enlarged') : false;
    const valueStyle = "font-size: 1.2em; opacity: 1.0; line-height: 1.4; font-weight: bold; text-align: right; padding-right: 22px;";
    const etaColor = "#D29BFD";
    const avgColor = "yellow";
    const maxColor = "#FFA420";
    const minAvgLineColor = '#FFA500';
    const maxAvgLineColor = '#28a745';

    const mainDataset = navigationChart.data.datasets[0];
    const altitudeFillDataset = navigationChart.data.datasets[1];
    const referenceDataset = navigationChart.data.datasets[2];
    const minAvgSpeedDataset = navigationChart.data.datasets[3];
    const maxAvgSpeedDataset = navigationChart.data.datasets[4];
    const accumulatedAvgSpeedDataset = navigationChart.data.datasets[5];

    if (currentGraphMode === 'Desviaci√≥n ETA') {
        navigationChart.options.scales.yPrimary.ticks.callback = function(value) { return Math.round(value) + ' km/h'; };
        
        mainDataset.borderColor = 'rgba(129, 216, 208, 0.6)'; 
        mainDataset.backgroundColor = 'rgba(37, 99, 235, 0.25)';
        mainDataset.fill = 'origin';
        mainDataset.pointRadius = 0;

        altitudeFillDataset.hidden = true; 
        altitudeFillDataset.data = []; 
        
        const currentAvgSpeed = window.averageSpeedKmh || 0;
        
        const valuesToShow = [graphExpectedAvgSpeed];
        if (currentAvgSpeed > 1) valuesToShow.push(currentAvgSpeed);
        if (maxAverageSpeedInTrip > -Infinity) valuesToShow.push(maxAverageSpeedInTrip);
        if (minAverageSpeedInTrip < Infinity) valuesToShow.push(minAverageSpeedInTrip);
        
        const maxVisibleValue = Math.max(...valuesToShow);
        const minVisibleValue = Math.min(...valuesToShow);

        const newYMax = maxVisibleValue + 3;
        const newYMin = Math.max(0, minVisibleValue - 3);
        
        navigationChart.options.scales.yPrimary.min = newYMin;
        navigationChart.options.scales.yPrimary.max = newYMax;

        const yAxisRange = newYMax - newYMin;
        const targetTickCount = isEnlarged ? 20 : 10;
        let stepSize = yAxisRange > 0 ? yAxisRange / targetTickCount : 1;
        const niceIntervals = [0.1, 0.2, 0.5, 1, 2, 5];
        let bestFitStep = niceIntervals[niceIntervals.length - 1];
        for (const interval of niceIntervals) {
            if (stepSize <= interval) {
                bestFitStep = interval;
                break;
            }
        }
        navigationChart.options.scales.yPrimary.ticks.stepSize = bestFitStep;

        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            const avgVal = (window.averageSpeedKmh || 0).toFixed(1);
            const maxVal = (maxSpeedDuringTrip || 0).toFixed(1);
            
            if (isFreeDriveActive) {
                graphTitleElement.innerHTML = `
                    <span style="font-size: 0.9em;">VELOCIDAD</span> 
                    <small style="${valueStyle}">
                        <span style="color:${avgColor};">Med: ${avgVal}</span> 
                        <span style="color:${maxColor};">   |  M√°x: ${maxVal} Km/h</span>
                    </small>`;
                referenceDataset.hidden = true;
            } else {
                const etaVal = (graphExpectedAvgSpeed || 0).toFixed(1);
                graphTitleElement.innerHTML = `
                    <span style="font-size: 0.9em;">ETA</span> 
                    <small style="${valueStyle}">
                        <span style="color:${etaColor};">ETA: ${etaVal}</span> 
                        <span style="color:${avgColor};">   |  Med: ${avgVal}</span> 
                        <span style="color:${maxColor};">   |  M√°x: ${maxVal} Km/h</span>
                    </small>`;
                referenceDataset.hidden = false;
            }
        }
        
        mainDataset.data = graphDataPoints.speed;
        mainDataset.label = 'Velocidad Media Real';
        
        referenceDataset.data = graphLabels.map(() => graphExpectedAvgSpeed);
        referenceDataset.label = 'Media ETA Inicial';
        
        minAvgSpeedDataset.data = graphLabels.map(() => minAverageSpeedInTrip === Infinity ? null : minAverageSpeedInTrip);
        minAvgSpeedDataset.label = 'Media M√≠nima';
        minAvgSpeedDataset.borderColor = minAvgLineColor;
        
        maxAvgSpeedDataset.data = graphLabels.map(() => maxAverageSpeedInTrip === -Infinity ? null : maxAverageSpeedInTrip);
        maxAvgSpeedDataset.label = 'Media M√°xima';
        maxAvgSpeedDataset.borderColor = maxAvgLineColor;

        accumulatedAvgSpeedDataset.data = graphLabels.map(() => window.averageSpeedKmh);
        accumulatedAvgSpeedDataset.hidden = false;

    } else if (currentGraphMode === 'Altitud') {
        accumulatedAvgSpeedDataset.hidden = true;
        accumulatedAvgSpeedDataset.data = [];

        navigationChart.options.scales.yPrimary.ticks.callback = function(value) { return Math.round(value) + ' m'; };
        navigationChart.options.scales.yPrimary.max = undefined;
        navigationChart.options.scales.yPrimary.min = undefined;
        
        mainDataset.borderColor = 'rgba(129, 216, 208, 1)'; 
        mainDataset.backgroundColor = 'transparent';
        mainDataset.fill = 'origin' ;
        mainDataset.pointRadius = 0;

        altitudeFillDataset.data = graphDataPoints.altitude;
        altitudeFillDataset.hidden = false;
        
        const altitudeValues = graphDataPoints.altitude.length > 0 ? graphDataPoints.altitude : [0];
        const minAlt = Math.min(...altitudeValues);
        const maxAlt = Math.max(...altitudeValues);
        const altRange = maxAlt - minAlt;
        const targetTickCountAlt = isEnlarged ? 10 : 5;

        if (altRange > 0) {
            const rawStepAlt = altRange / targetTickCountAlt;
            const niceIntervalsAlt = [2, 5, 10, 20, 50, 100];
            let stepSizeAlt = niceIntervalsAlt[niceIntervalsAlt.length - 1];
            for (const interval of niceIntervalsAlt) { if(rawStepAlt <= interval) { stepSizeAlt = interval; break; } }
            navigationChart.options.scales.yPrimary.ticks.stepSize = stepSizeAlt;
        } else {
             navigationChart.options.scales.yPrimary.ticks.stepSize = undefined;
        }
        
        const altitudePoints = graphDataPoints.altitude;
        const avgAltitudeValue = altitudePoints.length > 0 ? altitudePoints.reduce((a, b) => a + b, 0) / altitudePoints.length : 0;

        lastKnownAverageAltitude = avgAltitudeValue;

        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            const maxAltVal = (maxAltitudeDuringTrip !== -Infinity ? maxAltitudeDuringTrip : 0).toFixed(0);
            const avgAltVal = avgAltitudeValue.toFixed(0);
            const minAltVal = (minAltitudeDuringTrip !== Infinity ? minAltitudeDuringTrip : 0).toFixed(0);
            graphTitleElement.innerHTML = `
                <span style="font-size: 0.7em;">DESNIVEL RUTA</span>
                <small style="${valueStyle}">
                    <span style="color:${maxColor};">M√°x: ${maxAltVal}</span> 
                    <span style="color:${etaColor};">   |  Med: ${avgAltVal}</span> 
                    <span style="color:${avgColor};">   |  M√≠n: ${minAltVal}m</span>
                </small>`;
        }
        
        mainDataset.data = graphDataPoints.altitude;
        mainDataset.label = 'Altitud';
        
        referenceDataset.data = graphLabels.map(() => avgAltitudeValue);
        referenceDataset.label = 'Media';
        
        minAvgSpeedDataset.data = graphLabels.map(() => minAltitudeDuringTrip !== Infinity ? minAltitudeDuringTrip : null);
        minAvgSpeedDataset.label = 'M√≠nima';
        minAvgSpeedDataset.borderColor = '#FFA500';
        
        maxAvgSpeedDataset.data = graphLabels.map(() => maxAltitudeDuringTrip !== -Infinity ? maxAltitudeDuringTrip : null);
        maxAvgSpeedDataset.label = 'M√°xima';
        maxAvgSpeedDataset.borderColor = '#28a745';
    }
    navigationChart.data.labels = graphLabels; 
    navigationChart.update('none');
}    
 // ===================================================================
// NOMBRE: initializeNavigationGraph 
// RESUMEN: Inicializa la gr√°fica. Si los datos ya han sido restaurados
function initializeNavigationGraph() {
    const graphCard = document.getElementById('navigation-graph-card');
    const graphContainer = document.getElementById('navigation-graph-container');
    const graphTitleElement = document.getElementById('navigation-graph-title');
    if (!graphCard || !graphContainer || !graphTitleElement || (!isNavigating && !isFreeDriveActive) || currentGraphMode === 'Gr√°fica off') {
        if (graphCard) graphCard.classList.add('hidden');
        if (navigationChart) { navigationChart.destroy(); navigationChart = null; }
        return;
    }
    graphCard.classList.remove('hidden');
    const compassElement = document.querySelector('.map-control-orientation-altitude');
    graphCard.style.height = compassElement ? (compassElement.offsetHeight + 'px') : '157px';
    
    if (navigationChart) {
        navigationChart.destroy();
        navigationChart = null;
    }
    isGraphingActive = true;
    
    if (graphLabels.length === 0 && graphDataPoints.speed.length === 0) {
        isCarStoppedForGraph = false;
        graphDataPoints = { speed: [], altitude: [] };
        graphLabels = [];
        minAverageSpeedInTrip = Infinity;
        maxAverageSpeedInTrip = -Infinity;
    } else {
        console.log(`[Graph] Inicializando gr√°fica con ${graphLabels.length} puntos de datos pre-cargados desde recuperaci√≥n.`);
    }
 
    graphPlotState = { 
        lastPlotTime: Date.now(), 
        lastPlotCoords: navigationCurrentLocation ? { ...navigationCurrentLocation } : null 
    };

    const ctx = document.getElementById('navigation-chart')?.getContext('2d');
    if (!ctx || !ctx.canvas) {
        showToast("Error cr√≠tico: Canvas para gr√°fica no encontrado.", "error");
        if (graphCard) graphCard.classList.add('hidden');
        return;
    }
    
    const initialRouteDurationSec = navigationCurrentRouteData?.routes?.[0]?.duration || 0;
    const initialRouteDistance = navigationCurrentRouteData?.routes?.[0]?.distance || 0;
    
    const graphWidth = ctx.canvas.clientWidth || 300;
    const pixelsPerPoint = 3;
    maxGraphPoints = Math.floor(graphWidth / pixelsPerPoint) || 150;
    
    if (isNavigating && initialRouteDurationSec > 0 && maxGraphPoints > 0) {
        const idealIntervalMs = (initialRouteDurationSec / maxGraphPoints) * 1000;
        graphIntervalDuration = Math.max(5000, idealIntervalMs); 
    } else if (isFreeDriveActive) {
        graphIntervalDuration = 10000;
    } else {
        graphIntervalDuration = 30000;
    }

    graphExpectedAvgSpeed = (initialRouteDurationSec > 0 && initialRouteDistance > 0) ? (initialRouteDistance / initialRouteDurationSec) * 3.6 : 0;
    
    navigationChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: graphLabels, // Usamos los datos ya existentes
            datasets: [
                {
                    label: 'Velocidad Media Real', data: graphDataPoints.speed,
                    borderColor: 'rgba(75, 192, 192, 0.5)',
                    backgroundColor: 'rgba(75, 192, 192, 0.25)',
                    tension: 0.1, yAxisID: 'yPrimary', 
                    pointRadius: 0, 
                    order: 3, 
                    fill: 'origin'
                },
                {
                    label: '√Årea Desnivel', data: graphDataPoints.altitude,
                    borderColor: 'rgba(255, 165, 0, 0.5)', 
                    backgroundColor: 'rgba(255, 165, 0, 0.3)', 
                    fill: 'origin',
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: true, order: 4
                },
                {
                    label: 'Media ETA Inicial', data: [], 
                    borderColor: '#dfcae1', 
                    borderWidth: 3,          
                    fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 2
                },
                {
                    label: 'Media M√≠nima', data: [], borderColor: '#FFA500',
                    borderWidth: 1.5, borderDash: [5, 5], fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 1
                },
                {
                    label: 'Media M√°xima', data: [], borderColor: '#28a745',
                    borderWidth: 1.5, borderDash: [5, 5], fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 0
                },
                {
                    label: 'Media Acumulada Real', data: [], 
                    borderColor: '#F9e4b7', 
                    borderWidth: 3,        
                    fill: false,
                    pointRadius: 0, 
                    yAxisID: 'yPrimary', 
                    hidden: false, 
                    order: 2
                }
            ]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            layout: {
                padding: { top: 5, bottom: 2, left: 0, right: 2 }
            },
            scales: {
                x: {
                    type: 'category',
                    ticks: {
                        display: false 
                    },
                    grid: {
                        drawOnChartArea: false
                    }
                },
                yPrimary: {
                    type: 'linear', position: 'left',
                    min: Math.max(0, graphExpectedAvgSpeed - 3),
                    max: graphExpectedAvgSpeed + 3,
                    ticks: { color: 'white', font: { size: 11 }, callback: (v) => Math.round(Number(v)).toString(), stepSize: 0.2 },
                    grid: { color: 'rgba(255,255,255,0.1)' }, title: { display: false }
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: { 
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) { label += ': '; }
                            if (context.parsed.y !== null) {
                                label += context.parsed.y.toFixed(1);
                                if (currentGraphMode === 'Desviaci√≥n ETA') label += ' km/h';
                                else if (currentGraphMode === 'Altitud') label += ' m';
                            }
                            return label;
                        }
                    }
                 }
            },
            animation: { duration: 0 } // Desactivar la animaci√≥n inicial en la recuperaci√≥n
        }
    });
    startGraphIntervalTimer();
    updateNavigationGraphVisibilityAndMode();
}   


// ===================================================================
// NOMBRE: hideProximityAlert
// RESUMEN: Oculta el modal de aviso de proximidad.
function hideProximityAlert(alertId) {
    const proximityModal = document.getElementById('proximity-alert-modal');
    if (proximityModal) proximityModal.classList.add('hidden');
    document.getElementById('flashing-border-overlay').classList.add('hidden');
    
    if (proximityAlertTimer) {
        clearInterval(proximityAlertTimer);
        proximityAlertTimer = null;
    }
}
// ===================================================================
// NOMBRE: forceProcessTrafficAlerts
// RESUMEN: Lanza el proceso de actualizaci√≥n de alertas inmediatamente.
function forceProcessTrafficAlerts() {
    console.log("-> Forzando actualizaci√≥n inmediata de alertas de tr√°fico...");
    lastAlertCheckTimestamp = Date.now();
    processTrafficAlerts();
}    
    
// ===================================================================
// NOMBRE: handleLoadOrDeleteRouteClick 
// RESUMEN: Llama a la funci√≥n de reseteo completa antes de realizar otras acciones.
function handleLoadOrDeleteRouteClick(button) {

        const minimapContainer = document.getElementById('minimap-container');
        if (minimapContainer) {
            minimapContainer.classList.add('hidden');
        }
        if (minimapInstance && minimapInstance.isStyleLoaded()) {
            try {
                const routeSource = minimapInstance.getSource('minimap-route-source');
                if (routeSource) routeSource.setData({ type: 'Feature', geometry: { type: 'LineString', coordinates: [] } });
                const waypointSource = minimapInstance.getSource('minimap-waypoints-source');
                if (waypointSource) waypointSource.setData({ type: 'FeatureCollection', features: [] });
            } catch (e) {
            }
        }
        
        if (navigationMapInstance && navigationCurrentLocation) {
            isFlying = true;
            navigationFollowUser = false; // Desactivamos el seguimiento ANTES de volar
            shouldCenterOnUser = false;
            
            const targetZoom = 16.5;
            const targetPitch = 0;
            const targetBearing = 0;

            markerAnimationState.targetMapZoom = targetZoom;
            markerAnimationState.targetMapPitch = targetPitch;
            markerAnimationState.targetMapBearing = targetBearing;
            markerAnimationState.currentMapZoom = navigationMapInstance.getZoom(); // Empezamos desde el zoom actual
            markerAnimationState.currentMapPitch = navigationMapInstance.getPitch();
            markerAnimationState.currentMapBearing = navigationMapInstance.getBearing();

            navigationMapInstance.flyTo({
                center: [navigationCurrentLocation.longitude, navigationCurrentLocation.latitude],
                zoom: targetZoom,
                pitch: targetPitch,
                bearing: targetBearing,
                duration: 1500
            });
            navigationMapInstance.once('moveend', () => { isFlying = false; });
        }
    
    clearRecoveryFlag();
    clearAlternativeRoutesDisplay(); 
    resetNavigationState();

    if (isSimulatingGpsLocation) {
        stopAutomatedRouteSimulation();
    }
    
    if (isFreeDrivePaused) {
        isFreeDriveActive = false;
        isFreeDrivePaused = false;
        freeDriveStats = null;
        tripStartLocationForStats = null;
        autoStartFreeDriveDisabledUntil = Date.now() + 30000; // 30 segundos de gracia
        showToast("Viaje Libre cancelado.", "info");
        updateStartNavigationButtonState();
    }

    clearAllWaypointMarkersFromMap();
    if (navigationMapInstance && navigationMapInstance.getSource('route')) {
        navigationMapInstance.getSource('route').setData({ type: 'FeatureCollection', features: [] });
    }
    
    if (button) {
       }
    
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}

// ===================================================================
// NOMBRE: stopGpsWatching 
function stopGpsWatching() {
    if (locationWatchId !== null && navigator.geolocation) {
        navigator.geolocation.clearWatch(locationWatchId);
        locationWatchId = null;
    }
    if (gpsRetryTimeoutId) {
        clearTimeout(gpsRetryTimeoutId);
        gpsRetryTimeoutId = null;
    }
    gpsRetryAttempt = 0; 
}
    
//
//==================================================================    
function removeWaypointMarkerListeners(marker) {
    if (!marker) return;
    const element = marker.getElement();
    if (element && element._onPointerDown) {
        element.removeEventListener('mousedown', element._onPointerDown);
        element.removeEventListener('touchstart', element._onPointerDown);
        // Las de move y up se a√±aden/quitan din√°micamente, as√≠ que no es necesario quitarlas aqu√≠.
        delete element._onPointerDown;
        delete element._onPointerMove;
        delete element._onPointerUp;
    }
}
       
// ===================================================================
// NOMBRE: updateNavigationGraphVisibilityAndMode
// RESUMEN: Actualiza la visibilidad y modo de la gr√°fica de navegaci√≥n.
function updateNavigationGraphVisibilityAndMode() {
    const graphCard = document.getElementById('navigation-graph-card');
    const graphContainer = document.getElementById('navigation-graph-container');
    const graphTitleElement = document.getElementById('navigation-graph-title');
    const compassControl = document.querySelector('.map-control-orientation-altitude');
    if (!graphCard || !graphContainer || !graphTitleElement) {
        return;
    }
    if (compassAndModeControl) {
        compassAndModeControl._updateGraphTitle();
    }
    const isEnlarged = graphCard.classList.contains('enlarged');
    if ((navigationCurrentRouteData || isFreeDriveActive) && currentGraphMode !== 'Gr√°fica off') {
        graphCard.classList.remove('hidden');
        if (!isEnlarged) {
            const compassHeight = compassControl ? compassControl.offsetHeight : 0;
            graphCard.style.height = compassHeight > 0 ? `${compassHeight}px` : '157px';
        }
        if (navigationChart) {
            updateChartData(); 
        } else if (isNavigating || isFreeDriveActive) {
            initializeNavigationGraph();
        }
    } else {
        graphCard.classList.add('hidden');
    }
}    
    
// ===================================================================
// NOMBRE: handlePickerMapClick 
// RESUMEN: Maneja el clic en el mapa selector de ubicaciones para fijar coordenadas.
function handlePickerMapClick(e, slotIndex) {
    const lngLat = e.lngLat;
    if (locationPickerMarker) {
        locationPickerMarker.setLngLat(lngLat);
    }
    if (!tempSavedLocations[slotIndex]) tempSavedLocations[slotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
    tempSavedLocations[slotIndex].lat = lngLat.lat;
    tempSavedLocations[slotIndex].lng = lngLat.lng;
}
    
    // ===================================================================
    // NOMBRE: updateNavigationButtonColor
    // RESUMEN: Actualiza el color del bot√≥n de inicio de navegaci√≥n seg√∫n el estado.
    function updateNavigationButtonColor() {
        const startNavButton = document.getElementById('start-navigation-button');
        if (startNavButton) {
            if (isNavigating) {
                startNavButton.style.setProperty('background-color', '#000000', 'important');
            } else {
                startNavButton.style.backgroundColor = 'white';
                startNavButton.style.boxShadow = '2px 3px 5px rgba(0,0,0,0.60)';
            }
        }
    }
    
// ===================================================================
// NOMBRE: showToast 
function showToast(message, type = 'info', duration = 3000, isErrorNotFound = false, toastId = null) {
    const uniqueToastId = toastId || 'toast-notification-element' + (type === 'debug' ? '-debug' : '') + `-${Date.now()}`;
    
    let currentTopOffset = 180;
    const toastSpacing = 10;
    
    if (type !== 'instructional') {
        activeToasts.forEach(activeToast => {
            const toastElement = document.getElementById(activeToast.id);
            if (toastElement) {
                 currentTopOffset += toastElement.offsetHeight + toastSpacing;
            }
        });
    }

    const existingToast = document.getElementById(uniqueToastId);
    if (existingToast && !toastId) {
        existingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
    } else if (existingToast && toastId) {
         existingToast.remove();
         activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
         currentTopOffset = 180;
         activeToasts.forEach(activeToast => {
            const toastElement = document.getElementById(activeToast.id);
            if (toastElement) {
                currentTopOffset += toastElement.offsetHeight + toastSpacing;
            }
         });
    }
    const toast = document.createElement('div');
    toast.id = uniqueToastId;
    toast.className = `toast-notification toast-${type}`;
    if (isErrorNotFound && type === 'error') {
        toast.classList.add('not-found');
    }
    const messageSpan = document.createElement('span');
    messageSpan.innerHTML = message.replace(/\n/g, '<br>');
    toast.appendChild(messageSpan);
    if (type === 'debug') {
        toast.style.top = 'auto';
        toast.style.bottom = '20px';
        toast.style.right = '20px';
        toast.style.left = 'auto';
        toast.style.transform = 'none';
        toast.style.maxWidth = 'calc(100% - 40px)';
        const closeButtonToast = document.createElement('button');
        closeButtonToast.textContent = 'Cerrar Info Debug';
        closeButtonToast.style.cssText = "display: block; margin-top: 10px; padding: 5px 10px; background-color: rgba(255,255,255,0.2); color: white; border: 1px solid white; border-radius: 3px; cursor: pointer;";
        closeButtonToast.onclick = () => {
            if (toast.parentNode) toast.parentNode.removeChild(toast);
             activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
        };
        toast.appendChild(closeButtonToast);
    }

    if (type === 'instructional') {
        const buttonContainer = document.createElement('div');
        buttonContainer.style.marginTop = '10px';
        const enteradoButton = document.createElement('button');
        enteradoButton.textContent = 'ENTERADO';
        enteradoButton.style.cssText = `
            background-color: rgba(0,0,0,0.3); color: white; border: 1px solid white; 
            padding: 5px 10px; border-radius: 5px; font-weight: bold; cursor: pointer;
        `;
        
        const closeToast = () => {
            if (toast.classList.contains('show')) {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => {
                    if (toast.parentNode) toast.parentNode.removeChild(toast);
                    activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
                }, { once: true });
            } else {
                if (toast.parentNode) toast.parentNode.removeChild(toast);
                activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
            }
        };

        enteradoButton.addEventListener('click', closeToast);
        buttonContainer.appendChild(enteradoButton);
        toast.appendChild(buttonContainer);
        
        toast.style.top = '25px';
        toast.style.right = '15px';
        
    } else {
        toast.style.top = `${currentTopOffset}px`;
    }

    document.body.appendChild(toast);
    activeToasts.push({ id: uniqueToastId, element: toast });
    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            toast.classList.add('show');
        });
    });
    if (duration > 0 && type !== 'debug') {
        setTimeout(() => {
            const toastElement = document.getElementById(uniqueToastId);
            if (toastElement && toastElement.classList.contains('show')) {
                toastElement.classList.remove('show');
                toastElement.addEventListener('transitionend', () => {
                     if (toastElement.parentNode) { toastElement.parentNode.removeChild(toastElement); }
                     activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
                }, { once: true });
            } else if (toastElement) {
                 if (toastElement.parentNode) { toastElement.parentNode.removeChild(toastElement); }
                 activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
            }
        }, duration);
    }
}    
// ===================================================================
// NOMBRE: toggleEnlargedGraph
// RESUMEN: Ampl√≠a o reduce la gr√°fica de navegaci√≥n.
function toggleEnlargedGraph() {
    const graphCard = document.getElementById('navigation-graph-card');
    const enlargeButton = document.getElementById('enlarge-graph-button');
    const compassControlContainer = document.querySelector('.map-control-orientation-altitude');
    const mapModal = document.getElementById('reminders-location-map-modal');
    if (!graphCard || !enlargeButton || !compassControlContainer || !mapModal) return;
    const isCurrentlyEnlarged = graphCard.classList.contains('enlarged');
    if (!isCurrentlyEnlarged) {
        graphCard.classList.add('enlarged');
        const compassRect = compassControlContainer.getBoundingClientRect();
        const fixedWidth = 995; 
        const fixedHeight = 600; 
        const newLeft = compassRect.left;
        const distanceFromBottom = window.innerHeight - compassRect.bottom;
        const newBottom = distanceFromBottom;
        graphCard.style.left = `${newLeft}px`;
        graphCard.style.bottom = `${newBottom}px`;
        graphCard.style.width = `${fixedWidth}px`;
        graphCard.style.height = `${fixedHeight}px`;
        enlargeButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        `;
        enlargeButton.title = 'Reducir gr√°fica';
    } else {
        graphCard.classList.remove('enlarged');
        graphCard.style.left = '';
        graphCard.style.bottom = '';
        graphCard.style.width = '';
        graphCard.style.height = '';
        graphCard.style.top = '';
        graphCard.style.right = '';
        graphCard.style.transform = '';
        enlargeButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="11" y1="8" x2="11" y2="14"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        `;
        enlargeButton.title = 'Ampliar gr√°fica';
    }
    if (navigationChart) {
        updateChartData(); 
        setTimeout(() => {
            navigationChart.resize();
        }, 200);
    }
    updateNavigationGraphVisibilityAndMode();    
}
// ===================================================================
// NOMBRE: SETMAPINMERSIVEMODE
// RESUMEN:
function setMapImmersiveMode(activate) {
    if (isMapImmersiveModeActive === activate) return;

    isMapImmersiveModeActive = activate;
    const mapModal = document.getElementById('reminders-location-map-modal');
    
    const weatherWidget = document.getElementById('weather-widget-container');
    if (weatherWidget) {
        weatherWidget.classList.toggle('hidden', activate);
    }
    
    if (mapModal) {
        mapModal.classList.toggle('immersive-mode-active', isMapImmersiveModeActive);
        
        if (!isMapImmersiveModeActive) {
            progressBarForceShowUntil = Date.now() + 20000;
            const progressBar = document.getElementById('navigation-bottom-progress-bar');
            if (progressBar) progressBar.classList.remove('progress-bar-auto-hidden');
        }
        
        if (navigationMapInstance) {
            setTimeout(() => {
                try { navigationMapInstance.resize(); } catch(e) {}
            }, 350);
        }
    }
}

/**============================================================
 * Pausa la ejecuci√≥n durante un n√∫mero determinado de milisegundos.
 * @returns {Promise<void>}
 */
function wait(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}    

async function waitForMapStyleLoad(mapInstance) {
    let attempts = 0;
    const maxAttempts = 50; // 50 intentos * 100ms = 5 segundos de timeout
    const interval = 200;

    while (!mapInstance.isStyleLoaded() && attempts < maxAttempts) {
        await wait(interval);
        attempts++;
    }

    if (!mapInstance.isStyleLoaded()) {
        throw new Error("El estilo del mapa no se carg√≥ despu√©s de varios intentos.");
    }
}      
    
// ===================================================================
// NOMBRE: hideAutoStartNavigationModal
// RESUMEN: Oculta el modal de inicio y restaura la posici√≥n de la barra de progreso.
function hideAutoStartNavigationModal() {
    if (autoStartNavModalTimer) {
        clearInterval(autoStartNavModalTimer);
        autoStartNavModalTimer = null;
    }
    const modal = document.getElementById('auto-start-nav-modal');
    if (modal) {
        modal.remove();
    }
    
    const progressBar = document.getElementById('navigation-bottom-progress-bar');
    if (progressBar) {
        progressBar.classList.remove('progress-bar-partially-hidden');
    }
}    

// ===================================================================
// NOMBRE: toggleMapImmersiveMode 
// RESUMEN: Activa/desactiva el modo inmersivo y reactiva el seguimiento si es necesario.
function toggleMapImmersiveMode() {
    isMapImmersiveModeActive = !isMapImmersiveModeActive;
    const mapModal = document.getElementById('reminders-location-map-modal');
    const weatherWidget = document.getElementById('weather-widget-container');

    if (weatherWidget) {
        weatherWidget.classList.toggle('hidden', isMapImmersiveModeActive);
    }

    if (mapModal) {
        mapModal.classList.toggle('immersive-mode-active', isMapImmersiveModeActive);

        if (isMapImmersiveModeActive) {
            showToast('Modo Inmersivo Activado', 'info');
            if (!navigationFollowUser) {
                handleLocateMeClick(true);
            }
        } else {
            showToast('Modo Inmersivo Desactivado', 'info');
            toggleMapHeaderRowsVisibility(true);
        }

        if (navigationMapInstance) {
            setTimeout(() => {
                try { navigationMapInstance.resize(); } catch(e) {}
            }, 350);
        }
    }
}
    
// ===================================================================
// NOMBRE: reactivateRealGpsAfterSimulation 
// RESUMEN: Reactiva el seguimiento del GPS real despu√©s de una simulaci√≥n.
function reactivateRealGpsAfterSimulation() {
    if (locationWatchId === null && 'geolocation' in navigator && 'watchPosition' in navigator.geolocation) {
        locationWatchId = navigator.geolocation.watchPosition(
            (position) => {
                if (isSimulatingGpsLocation) return;
                const coordsForUpdate = {
                     latitude: position.coords.latitude, longitude: position.coords.longitude,
                     accuracy: position.coords.accuracy, heading: position.coords.heading,
                     altitude: position.coords.altitude, speed: position.coords.speed
                };
                navigationCurrentLocation = coordsForUpdate;
                updateInitialUserPosition(coordsForUpdate, navigationMapInstance);
                 if(isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
                    const routeForDistCalc = navigationCurrentRouteData.routes[0];
                    let carDistTurf = 0;
                    if (routeForDistCalc.geometry && typeof turf !== 'undefined') {
                        try {
                            const carPointTurf = turf.point([coordsForUpdate.longitude, coordsForUpdate.latitude]);
                            const routeLineStringTurf = turf.lineString(routeForDistCalc.geometry.coordinates);
                            const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                            const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                            carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                        } catch(e){
                        }
                    }
                    const totalRouteLength = routeForDistCalc.distance;
                     if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                        if (carDistTurf < lastCarDistanceAlongRouteForNavLogic - 100 && lastCarDistanceAlongRouteForNavLogic > 100) {
                        } else {
                            lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                        }
                    } else if (carDistTurf > totalRouteLength + 500) {
                        lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
                    }
                    updateTurnByTurnDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                    updateNavigationProgressDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                }
            },
            (error) => {
                showToast(`Error al reactivar GPS: ${error.message}`, "warning");
            },
            { enableHighAccuracy: true, timeout: 15000, maximumAge: 3000, distanceFilter: 3 }
        );
        getCurrentLocation(coords => {
            if (!isSimulatingGpsLocation) {
                navigationCurrentLocation = coords;
                updateInitialUserPosition(coords, navigationMapInstance);
                if (isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
                    const routeForDistCalc = navigationCurrentRouteData.routes[0];
                    let carDistTurf = 0;
                     if (routeForDistCalc.geometry && typeof turf !== 'undefined') {
                        try {
                            const carPointTurf = turf.point([coords.longitude, coords.latitude]);
                            const routeLineStringTurf = turf.lineString(routeForDistCalc.geometry.coordinates);
                            const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                            const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                            carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                        } catch(e){
                        }
                     }
                    const totalRouteLength = routeForDistCalc.distance;
                     if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                        if (carDistTurf < lastCarDistanceAlongRouteForNavLogic - 100 && lastCarDistanceAlongRouteForNavLogic > 100) {
                        }
                        lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                    } else if (carDistTurf > totalRouteLength + 500) {
                        lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
                    }
                    updateTurnByTurnDisplay(routeForDistCalc, carDistTurf);
                    updateNavigationProgressDisplay(routeForDistCalc, carDistTurf);
                }
            }
        });
    }
}

// ===================================================================
// NOMBRE: getRouteStyleProperties 
// RESUMEN: Devuelve el estilo correcto para la ruta (amarillo para sat√©lite/h√≠brido, azul para calles).
function getRouteStyleProperties() {
    if (!navigationMapInstance) { // Fallback por si el mapa no est√° listo
        return { 'line-color': 'yellow', 'line-width': 12, 'line-opacity': 0.8 };
    }
    
    const isPitched = navigationMapInstance.getPitch() > 20;
    const isStreetsView = (localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "H√çBRIDO") === 'CALLES';

    const mainWidthExpression = isPitched 
        ? ['interpolate', ['linear'], ['zoom'], 13.49, 7, 13.5, 16] 
        : ['interpolate', ['linear'], ['zoom'], 13.49, 7, 13.5, 12];
    
    return {
        'line-color': isStreetsView ? 'blue' : 'yellow',        
        'line-width': mainWidthExpression, 
        'line-opacity': isStreetsView ? 0.6 : 0.8
    };
}
    
// ===================================================================
// NOMBRE: updateLineWidthsOnPitchChange (VERSI√ìN MODIFICADA CON ZOOM DIN√ÅMICO)
// RESUMEN: Ajusta el grosor de las l√≠neas de ruta seg√∫n la inclinaci√≥n Y el zoom.
function updateLineWidthsOnPitchChange() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) return;

    const isPitched = navigationMapInstance.getPitch() > 20;
    
    const mainWidthExpr = isPitched 
        ? ['interpolate', ['linear'], ['zoom'], 13.49, 7, 13.5, 16] 
        : ['interpolate', ['linear'], ['zoom'], 13.49, 7, 13.5, 12];
        
    const altWidthExpr = isPitched 
        ? ['interpolate', ['linear'], ['zoom'], 13.49, 5, 13.5, 12] 
        : ['interpolate', ['linear'], ['zoom'], 13.49, 5, 13.5, 8];
        
    const completedWidthExpr = isPitched 
        ? ['interpolate', ['linear'], ['zoom'], 13.49, 4, 13.5, 10] 
        : ['interpolate', ['linear'], ['zoom'], 13.49, 4, 13.5, 6];

    try {
        if (navigationMapInstance.getLayer('route')) {
            navigationMapInstance.setPaintProperty('route', 'line-width', mainWidthExpr);
        }
        if (navigationMapInstance.getLayer('completed-segments-layer')) {
            navigationMapInstance.setPaintProperty('completed-segments-layer', 'line-width', completedWidthExpr);
        }
        alternativeRouteLayers.forEach(alt => {
            if (navigationMapInstance.getLayer(alt.layerId)) {
                navigationMapInstance.setPaintProperty(alt.layerId, 'line-width', altWidthExpr);
            }
        });
    } catch (e) { /* Ignorar errores si la capa no existe durante la actualizaci√≥n */ }
}
    
// ===================================================================
// NOMBRE: parseReminderText
// RESUMEN: Parsea el texto de un recordatorio para extraer fecha, hora, repetici√≥n, etc.
function parseReminderText(text, elementsToUpdate = null) {
    const result = { text: `<b>${text.trim().toUpperCase()}</b>`, time: null, date: null, repeatDays: [], intervalDays: null, type: null, isLocationEnabled: false, locationCoordinates: null, radiusMeters: 350, excludeFromList: false };
    let norm = text.toUpperCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    const numW = { 'UNA': 1, 'UNO': 1, 'DOS': 2, 'TRES': 3, 'CUATRO': 4, 'CINCO': 5, 'SEIS': 6, 'SIETE': 7, 'OCHO': 8, 'NUEVE': 9, 'DIEZ': 10, 'ONCE': 11, 'DOCE': 12, 'TRECE': 13, 'CATORCE': 14, 'QUINCE': 15, 'DIECISEIS': 16, 'DIECISIETE': 17, 'DIECIOCHO': 18, 'DIECINUEVE': 19, 'VEINTE': 20, 'VEINTIUNO': 21, 'VEINTIDOS': 22, 'VEINTITRES': 23, 'VEINTICUATRO': 24, 'VEINTICINCO': 25, 'VEINTISEIS': 26, 'VEINTISIETE': 27, 'VEINTIOCHO': 28, 'VEINTINUEVE': 29, 'TREINTA': 30, 'TREINTAYUNO': 31 }; const tRgx = /\b(\d{1,2}):(\d{2})\b/; const ttRgx = /.*\bA\s*LAS?\s*(\d+|\w+)\s*(?:Y\s*(CUARTO|MEDIA|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA)|MENOS\s*(CUARTO|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA))?\s*(DE\s*LA\s*(MANANA|TARDE|NOCHE))?/i; const tM = norm.match(tRgx); if (tM) { let h = parseInt(tM[1]); let m = parseInt(tM[2]); if (h >= 0 && h <= 23 && m >= 0 && m <= 59) result.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`; } else { const ttM = norm.match(ttRgx); if (ttM) { let h = numW[ttM[1].toUpperCase()] || parseInt(ttM[1]); if (!isNaN(h)) { const minTxt = ttM[2]?.toUpperCase() || ''; const minus = ttM[3]?.toUpperCase() || ''; const period = ttM[5]?.toUpperCase() || null; let m = 0; if (minTxt) m = minTxt === 'CUARTO' ? 15 : minTxt === 'MEDIA' ? 30 : numW[minTxt] || parseInt(minTxt) || 0; else if (minus) { m = minus === 'CUARTO' ? 15 : numW[minus] || parseInt(minus) || 0; h = (h - 1 + 24) % 24; m = (60 - m + 60) % 60; } if (period) { if (period === 'TARDE' && h >= 1 && h <= 11) h += 12; if (period === 'NOCHE' && h >= 1 && h <= 11) h += 12; if (period === 'MANANA' && h === 12) h = 0; if (period === 'TARDE' && h === 12) h = 12; if (period === 'NOCHE' && h === 12) h = 0; } else if (h >= 1 && h <= 5) h += 12; if (h >= 0 && h <= 23 && m >= 0 && m <= 59) result.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`; } } } const daysMap = { 'LUNES': 1, 'MARTES': 2, 'MIERCOLES': 3, 'MI√âRCOLES': 3, 'JUEVES': 4, 'VIERNES': 5, 'SABADO': 6, 'S√ÅBADO': 6, 'DOMINGO': 0 }; const wRgx = /(TODOS\s+LOS|LOS|CADA)?\s*(LUNES|MARTES|MIERCOLES|MI√âRCOLES|JUEVES|VIERNES|SABADO|S√ÅBADO|DOMINGO)/g; let wM; while ((wM = wRgx.exec(norm)) !== null) { const day = daysMap[wM[2]]; if (day !== undefined && !result.repeatDays.includes(day)) result.repeatDays.push(day); }
    const now = new Date(); const manDRgx = /(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{2}|\d{4})\b/; const manDM = norm.match(manDRgx);
    if (manDM && !result.date) { let d = parseInt(manDM[1]); let m = parseInt(manDM[2]); let y = parseInt(manDM[3]); if (y >= 0 && y <= 99) y += 2000; if (d >= 1 && d <= 31 && m >= 1 && m <= 12 && y >= 2000 && y <= 2099) { const tD = new Date(Date.UTC(y, m - 1, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() + 1 === m && tD.getUTCFullYear() === y) { result.date = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } } }
    const todayRgx = /\bHOY\b/; const tomRgx = /\bMANANA\b/; const dayAftRgx = /\bPASADO\s*MANANA\b/;
    if (!result.date) { if (norm.match(todayRgx)) { result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (norm.match(dayAftRgx)) { const tD = new Date(now); tD.setDate(now.getDate() + 2); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } else if (norm.match(tomRgx)) { const tD = new Date(now); tD.setDate(now.getDate() + 1); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } }
    const dndRgx = /(?:EL\s*(PROXIMO)?\s*)?(LUNES|MARTES|MIERCOLES|MI√âRCOLES|JUEVES|VIERNES|SABADO|S√ÅBADO|DOMINGO)/i; const dndM = norm.match(dndRgx);
    if (dndM && !result.date) { const tDN = dndM[2].toUpperCase(); const tD = daysMap[tDN]; if (tD !== undefined) { const curD = now.getDay(); let dU = (tD - curD + 7) % 7; if (dU === 0) dU = 7; if (dndM[1]?.toUpperCase() === 'PROXIMO') dU += 7; const target = new Date(now); target.setDate(now.getDate() + dU); result.date = `${target.getFullYear()}-${(target.getMonth() + 1).toString().padStart(2, '0')}-${target.getDate().toString().padStart(2, '0')}`; } }
    const didRgx = /DENTRO\s*DE\s*(\d+)\s*DIAS?/; const didM = norm.match(didRgx);
    if (didM && !result.date) { const d = parseInt(didM[1]); if (!isNaN(d) && d > 0) { const tD = new Date(now); tD.setDate(now.getDate() + d); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } }
    const dsdRgx = /\bEL\s*DIA\s*(\d{1,2})\b/; const dsdM = norm.match(dsdRgx);
    if (dsdM && !result.date) { const d = parseInt(dsdM[1]); if (!isNaN(d) && d >= 1 && d <= 31) { let tM = now.getMonth(); let tY = now.getFullYear(); if (d < now.getDate()) { tM++; if (tM > 11) { tM = 0; tY++; } } const tD = new Date(Date.UTC(tY, tM, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() === tM) { result.date = `${tY}-${(tM + 1).toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } } }
    const intRgx = /CADA\s*(\d+)\s*DIAS?/; const intM = norm.match(intRgx);
    if (intM) { result.intervalDays = parseInt(intM[1]); if (!result.date) { result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } }
    const timRgx = /(ALARMA|AVISO|AVISAR|AVISARME|AV√çSAME|TEMPORIZADOR|TIMER|RECORDAR|RECORDARME|RECU√âRDAME)\b.*?\b(\d+|\w+)\s*(MINUTOS?|HORAS?|MINS?|HRS?)/i; const timM = norm.match(timRgx);
    if (timM) { const valStr = timM[2]; const unit = timM[3]?.toUpperCase(); let val = numW[valStr.toUpperCase()] || parseInt(valStr); if (!isNaN(val) && val > 0 && unit) { let tmc = 0; if (unit.startsWith('HORA') || unit.startsWith('HR')) { tmc = val * 60; } else if (unit.startsWith('MINUTO') || unit.startsWith('MIN')) { tmc = val; }
            if (tmc > 0) { const endT = new Date(Date.now() + tmc * 60000); result.date = `${endT.getFullYear()}-${(endT.getMonth() + 1).toString().padStart(2, '0')}-${endT.getDate().toString().padStart(2, '0')}`; result.time = `${endT.getHours().toString().padStart(2, '0')}:${endT.getMinutes().toString().padStart(2, '0')}`; result.repeatDays = []; result.intervalDays = null; result.type = 'simple'; } } }
    
    const locationPhrases = ["EN EL LUGAR", "EN EL SITIO", "EN LA UBICACION", "EN LA LOCALIZACION"];
    if (locationPhrases.some(phrase => norm.includes(phrase)) || norm.includes("RADAR")) {
        result.isLocationEnabled = true;
    }
    
    const radiusRgx = /(?:RADIO|MARGEN)\s*DE\s*(\d+)\s*METROS?/i; const radiusMatch = norm.match(radiusRgx);
    if (radiusMatch && radiusMatch[1]) { const parsedRadius = parseInt(radiusMatch[1]); if (!isNaN(parsedRadius) && parsedRadius > 0) { result.radiusMeters = parsedRadius; result.isLocationEnabled = true; } }
    const excludePhrases = ["NO LISTAR", "NO MOSTRAR EN LISTA", "EXCLUIR LISTA", "OCULTAR LISTA", "RADAR"]; if (excludePhrases.some(phrase => norm.includes(phrase))) { result.excludeFromList = true; }
    if (norm.toUpperCase().startsWith("<b>RADAR") && result.radiusMeters === 350 && !radiusMatch) {
        result.radiusMeters = 350;
    } else if (result.radiusMeters === 350 && !norm.toUpperCase().startsWith("<b>RADAR") && !radiusMatch && !excludePhrases.some(phrase => norm.includes(phrase))) {
        result.radiusMeters = 350;
    }
    if (result.type === null) {
        if (result.intervalDays !== null && result.date) { result.type = 'interval'; } else if (result.repeatDays.length > 0 && result.time) { result.type = 'weekly'; } else if (result.date && result.time) { result.type = 'daily'; } else if (result.time) { result.type = 'daily'; if (!result.date) result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (result.date) { result.type = 'daily'; } else { result.type = 'simple'; } }
    if (!result.time && (result.type === 'daily' || result.type === 'weekly' || result.type === 'interval' )) { result.time = '00:01'; }
    if (elementsToUpdate) {
         if (elementsToUpdate.locationCheckbox) { const shouldBeChecked = result.isLocationEnabled; if (elementsToUpdate.locationCheckbox.checked !== shouldBeChecked && !elementsToUpdate.mapExpandedManually) { elementsToUpdate.locationCheckbox.checked = shouldBeChecked; } }
         if (elementsToUpdate.radiusInput) { elementsToUpdate.radiusInput.value = result.radiusMeters; }
         if (!elementsToUpdate.manualTimeInput && elementsToUpdate.timeInput && result.time) { elementsToUpdate.timeInput.value = result.time; }
         if (elementsToUpdate.dateInput && result.date) { const dateParts = result.date.split('-');
         if(dateParts.length === 3) { elementsToUpdate.dateInput.value = `${dateParts[2]}/${dateParts[1]}/${dateParts[0]}`; } else { elementsToUpdate.dateInput.value = ''; } } else if (elementsToUpdate.dateInput) { elementsToUpdate.dateInput.value = ''; }
         if (elementsToUpdate.intervalInput) { elementsToUpdate.intervalInput.value = result.intervalDays || ''; }
         if (elementsToUpdate.repeatCheckboxes && result.repeatDays && result.repeatDays.length > 0) { elementsToUpdate.repeatCheckboxes.forEach(input => { input.checked = result.repeatDays.includes(parseInt(input.value)); }); } else if (elementsToUpdate.repeatCheckboxes) { elementsToUpdate.repeatCheckboxes.forEach(input => { input.checked = false; }); }
         if (elementsToUpdate.excludeFromListCheckbox) { elementsToUpdate.excludeFromListCheckbox.checked = result.excludeFromList; }
    } return result;
}

// ===================================================================
// NOMBRE: handleWaypointPlacement 
// RESUMEN: Coloca un marcador temporal transl√∫cido con la letra "F",
function handleWaypointPlacement(displayName, lat, lon) {
    if (!navigationMapInstance) return;

    triggerManualMapInteraction();

    const tempMarkerElement = document.createElement('div');
    tempMarkerElement.className = 'navigation-waypoint-marker';
    tempMarkerElement.style.cssText = `
        background-color: rgba(255, 140, 0, 0.7); /* Naranja transl√∫cido */
        opacity: 0.8; /* Transparencia del propio marcador */
        border: 2px solid white;
        width: 45px;
        height: 45px;
        font-size: 24px;
        font-weight: bold;
    `;
    tempMarkerElement.textContent = 'F'; // Letra "F" en lugar de "?"

    const tempMarker = new mapboxgl.Marker({
        element: tempMarkerElement,
        draggable: false, // Inicialmente no es arrastrable
        anchor: 'center'
    }).setLngLat([lon, lat]).addTo(navigationMapInstance);
    
    const popupContent = document.createElement('div');
    popupContent.style.cssText = `
        font-family: sans-serif;
        text-align: center;
        color: #333;
        width: 270px;
    `;
    popupContent.innerHTML = `
        <style>
            .placement-popup-btn {
                width: 100%; padding: 8px; margin-top: 6px; border: none;
                border-radius: 6px; font-weight: bold; font-size: 0.80rem;
                cursor: pointer; transition: background-color 0.2s;
            }
            .placement-popup-btn.add { background-color: #34c759; color: white; }
            .placement-popup-btn.drag { background-color: #ff9500; color: white; }
            .placement-popup-btn.cancel { background-color: #555; color: white; }
        </style>
        <p style="font-size: 0.85rem; font-weight: bold; margin: 0 0 8px 0; color: #111;">${displayName}</p>
        <button id="placement-add" class="placement-popup-btn add">A√±adir Aqu√≠</button>
        <button id="placement-drag" class="placement-popup-btn drag">Arrastrar y A√±adir</button>
        <button id="placement-cancel" class="placement-popup-btn cancel">Cancelar</button>
    `;

    const confirmationPopup = new mapboxgl.Popup({
        closeButton: false,
        closeOnClick: false,
        anchor: 'bottom',
        offset: 35,
        className: 'charging-point-popup' // Reutilizamos un estilo de popup oscuro
    })
    .setLngLat([lon, lat])
    .setDOMContent(popupContent)
    .addTo(navigationMapInstance);
    
    const popupElement = confirmationPopup.getElement();
    if (popupElement) {
        popupElement.style.opacity = '0.85'; // 85% de opacidad (60% es 0.6)
    }

    isFlying = true;
    navigationMapInstance.flyTo({ center: [lon, lat], zoom: 14.5, duration: 1500 });
    navigationMapInstance.once('moveend', () => { isFlying = false; });

    const cleanup = () => {
        tempMarker.remove();
        confirmationPopup.remove();
    };

    const addBtn = popupContent.querySelector('#placement-add');
    const dragBtn = popupContent.querySelector('#placement-drag');
    const cancelBtn = popupContent.querySelector('#placement-cancel');

    addBtn.addEventListener('click', async () => {
        const finalCoords = tempMarker.getLngLat();
        cleanup();
        showToast("Ajustando a la carretera...", "info", 1500);
        const snapped = await snapCoordsToRoad(finalCoords.lat, finalCoords.lng);
        addWaypoint(snapped, displayName);
    });

    dragBtn.addEventListener('click', () => {
        tempMarker.setDraggable(true);
        tempMarkerElement.style.cursor = 'grabbing';
        confirmationPopup.remove(); // Cerramos el popup para no estorbar al arrastrar
        showToast("Arrastra el marcador a la posici√≥n deseada y su√©ltalo para a√±adir.", "info", 4000);
        
        tempMarker.on('dragend', async () => {
            const finalCoords = tempMarker.getLngLat();
            tempMarker.remove(); 
            showToast("Ajustando a la carretera...", "info", 1500);
            const snapped = await snapCoordsToRoad(finalCoords.lat, finalCoords.lng);
            addWaypoint(snapped, displayName);
        });
    });

    cancelBtn.addEventListener('click', cleanup);
}    

// ===================================================================
// NOMBRE: displayAddressSuggestionsModal 
// RESUMEN: Muestra las sugerencias y un bot√≥n para buscar POIs, evitando el error "onclick of null".
function displayAddressSuggestionsModal(suggestions) {
    const searchInput = document.getElementById('map-location-search-input');
    if (!searchInput) return;

    const poiCategoryModal = document.getElementById('poi-category-modal');
    if (poiCategoryModal) poiCategoryModal.remove();

    const modalId = 'address-suggestions-modal';
    let modal = document.getElementById(modalId);
    
    if (!modal) {
        modal = document.createElement('div');
        modal.id = modalId;
        modal.className = 'address-suggestions-modal';
        document.body.appendChild(modal); 
    }
    
    modal.innerHTML = `
        <h2 id="address-suggestions-title"></h2>
        <ul id="address-suggestions-list"></ul>
        <div class="modal-top-buttons" style="justify-content: space-between; margin-top: 1rem; flex-wrap: wrap; gap: 10px;">
            <button id="search-as-poi-button" style="flex: 1 1 auto; min-width: 200px; background-color: #ff9500; color: white;">Buscar en la Zona del Mapa</button>
            <button id="close-address-suggestions-modal" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
        </div>
    `;

    const titleElement = modal.querySelector('#address-suggestions-title');
    const listElement = modal.querySelector('#address-suggestions-list');
    const closeButton = modal.querySelector('#close-address-suggestions-modal');
    const searchAsPoiButton = modal.querySelector('#search-as-poi-button');
    
    closeButton.addEventListener('click', hideAddressSuggestionsModal);

    searchAsPoiButton.onclick = () => {
        const query = searchInput.value.trim();
        if (query) {
            hideAddressSuggestionsModal();
            searchAndAddWaypoint(query, true); 
        } else {
            showToast("No hay texto que buscar.", "warning");
        }
    };
    
    clearModalAutoCloseTimer(modal, closeButton, 'address-suggestions-modal');

    if (suggestions.length === 0) {
        titleElement.textContent = "No se encontraron direcciones";
        listElement.innerHTML = '<li style="cursor: default; background-color: #a09888; color: #444;">Puedes probar a buscarlo como negocio/lugar de inter√©s en la zona.</li>';
        modal.classList.remove('hidden'); 
        addModalAutoCloseTimer(modal, closeButton, 'address-suggestions-modal', 8000); 
        return;
    }
    
    titleElement.textContent = `${suggestions.length} coincidencia${suggestions.length !== 1 ? 's' : ''} encontrada${suggestions.length !== 1 ? 's' : ''}`;
    listElement.innerHTML = '';
    suggestions.forEach(suggestion => {
        const li = document.createElement('li');
        li.textContent = suggestion.display_name;
        li.dataset.lat = suggestion.lat;
        li.dataset.lon = suggestion.lon;
        
        li.addEventListener('click', () => {
            const lat = parseFloat(li.dataset.lat);
            const lon = parseFloat(li.dataset.lon);
            const displayName = li.textContent;
            
            if (isNaN(lat) || isNaN(lon)) {
                showToast("Error: Coordenadas de sugerencia no v√°lidas.", "error");
                return;
            }
            
            hideAddressSuggestionsModal();
            handleWaypointPlacement(displayName, lat, lon);
        });
      
        listElement.appendChild(li);
    });
    
    const searchInputRect = searchInput.getBoundingClientRect();
    modal.style.top = `${searchInputRect.bottom + 5}px`;
    modal.style.width = `calc(100% - 40px)`;
    modal.style.maxWidth = '900px';
    modal.style.left = '50%';
    modal.style.transform = 'translateX(-50%)';

    const viewportHeight = window.innerHeight;
    const modalTop = searchInputRect.bottom + 5;
    const availableHeight = viewportHeight - modalTop - 20;
    modal.style.maxHeight = `${availableHeight}px`;
    const titleHeight = titleElement.offsetHeight;
    const buttonsHeight = modal.querySelector('.modal-top-buttons').offsetHeight;
    const listMaxHeight = availableHeight - titleHeight - buttonsHeight - 30;
    listElement.style.maxHeight = `${Math.max(100, listMaxHeight)}px`;
    
    modal.classList.remove('hidden');
    addModalAutoCloseTimer(modal, closeButton, 'address-suggestions-modal', 30000);
}    

// NOMBRE: redrawAllHTMLMarkers 
// RESUMEN: Limpia y redibuja los marcadores de Etapas y Recordatorios/Radares.
// ===================================================================
function redrawAllHTMLMarkers() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
        return;
    }
    navigationWaypoints.forEach(wp => {
        if (wp && wp.marker) {
            wp.marker.remove();
            wp.marker = null;
        }
    });
    reminderMapObjects.forEach(obj => {
        if (obj.marker) obj.marker.remove();
    });
    reminderMapObjects = [];
    renderWaypointMarkers();
    plotRemindersOnNavigationMap();
}
 
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// NOMBRE: updateAllIconSizes 
// RESUMEN: Controlador central que decide CU√ÅNDO se deben redibujar los iconos.
function updateAllIconSizes() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
        return;
    }

    const currentZoomLevel = navigationMapInstance.getZoom();

    const ZOOM_LEJANO = 10;
    const ZOOM_MEDIO = 14;

    const getZoomRange = (zoom) => {
        if (zoom <= ZOOM_LEJANO) return 'lejano';
        if (zoom <= ZOOM_MEDIO) return 'medio';
        return 'cercano';
    };

    const currentRange = getZoomRange(currentZoomLevel);
    const previousRange = getZoomRange(mapPreviousZoomLevelForPDRs); // Reutilizamos la variable

    if (currentRange !== previousRange) {
        redrawAllHTMLMarkers();
    }

    const PDR_ZOOM_THRESHOLD = 14;
    const crossedThresholdUp = mapPreviousZoomLevelForPDRs <= PDR_ZOOM_THRESHOLD && currentZoomLevel > PDR_ZOOM_THRESHOLD;
    const crossedThresholdDown = mapPreviousZoomLevelForPDRs > PDR_ZOOM_THRESHOLD && currentZoomLevel <= PDR_ZOOM_THRESHOLD;

    if (crossedThresholdUp || crossedThresholdDown) {
        displayChargingPointsOnMap();
    }
    
    mapPreviousZoomLevelForPDRs = currentZoomLevel;
}
       
// ===================================================================
// NOMBRE: stopAutomatedRouteSimulationInternal 
// RESUMEN: Detiene el intervalo de la simulaci√≥n autom√°tica y limpia su ID. Es la funci√≥n auxiliar que faltaba.
function stopAutomatedRouteSimulationInternal() {
    if (automatedSimulationIntervalId) {
        clearInterval(automatedSimulationIntervalId);
        automatedSimulationIntervalId = null;
        startMemoryManagement(false); 
    }
}  
    
// ===================================================================
// NOMBRE: handleSimulateGpsPositionClick 
// RESUMEN: Detiene la navegaci√≥n activa al simular un desv√≠o manual.
// ===================================================================
function handleSimulateGpsPositionClick(e, forceExactPosition = false) {
    if (!isSimulatingGpsLocation || !navigationMapInstance) return;
   
    wasSimulatingBeforeRecalc = true;

    navigationFollowUser = true;
    shouldCenterOnUser = true;
    clearLocateMeReactivationTimer(); updateLocateMeButtonsUI(); 

    if (automatedSimulationIntervalId) {
        stopAutomatedRouteSimulationInternal();
        showToast("Simulaci√≥n autom√°tica pausada. Forzando desv√≠o...", "info");
    }
    let lngLatToUse = [e.lngLat.lng, e.lngLat.lat]; 
    
    if (!forceExactPosition && navigationMapInstance.getSource('route') && typeof turf !== 'undefined' && navigationMapInstance.getSource('route')._data) {
        const routeGeoJSON = navigationMapInstance.getSource('route')._data;
        if (routeGeoJSON && routeGeoJSON.type === 'Feature' && routeGeoJSON.geometry && routeGeoJSON.geometry.coordinates) {
            const routeLineString = turf.lineString(routeGeoJSON.geometry.coordinates);
            const clickPoint = turf.point(lngLatToUse);
            const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, clickPoint, { units: 'meters' });
            
            if (nearestPointOnRoute && nearestPointOnRoute.properties.dist !== undefined && nearestPointOnRoute.properties.dist < 50) { 
                lngLatToUse = nearestPointOnRoute.geometry.coordinates;
            }
        }
    }

    simulatedGpsLocation = {
        latitude: lngLatToUse[1],
        longitude: lngLatToUse[0],
        accuracy: 10,
        heading: navigationCurrentLocation ? navigationCurrentLocation.heading : 0,
        altitude: navigationCurrentLocation ? navigationCurrentLocation.altitude : 0,
        speed: 0
    };
    processSimulatedGpsPosition(true); 
    setNavigationMapClickHandler(); 
}
    
// ===================================================================
// NOMBRE: setNavigationMapClickHandler 
// RESUMEN: √önicamente gestiona el estado visual del mapa (clases y cursor) seg√∫n el modo actual.
// ===================================================================
function setNavigationMapClickHandler() {
    const mapDiv = document.getElementById('reminders-location-map-div');
    if (!navigationMapInstance || !mapDiv) return;

    mapDiv.classList.remove('add-reminder-mode', 'simulating-gps-click-mode', 'navigating');
    const canvas = navigationMapInstance.getCanvas();
    if(canvas) canvas.style.cursor = ''; // Restaura cursor por defecto

    if (isAddReminderAtLocationModeActive) {
        mapDiv.classList.add('add-reminder-mode');
    } else if (isSimulatingGpsLocation) {
        mapDiv.classList.add('simulating-gps-click-mode');
    } else if (isNavigating) {
        mapDiv.classList.add('navigating');
        if(canvas) canvas.style.cursor = 'default';
    } else {
        if(canvas) canvas.style.cursor = 'crosshair';
    }
} 

// ===================================================================
// NOMBRE: showSimulationModal 
// RESUMEN: Muestra un modal con la lista de maniobras "limpia" y diferencia entre
async function showSimulationModal() {
    const canSimulate = (navigationWaypoints.filter(wp => !wp.isInternal && !wp.isRecalculatedStart).length >= 2 && navigationCurrentRouteData?.routes?.[0]) ||
                        (isNavigating && navigationCurrentRouteData?.routes?.[0]);

    if (!canSimulate) {
        showToast("Se necesitan al menos 2 puntos y una ruta calculada para mostrar las maniobras.", "warning");
        return;
    }
    const route = navigationCurrentRouteData.routes[0];
    const cleanManeuvers = route._cleanSteps || [];

    if (cleanManeuvers.length === 0) {
        showToast("No hay maniobras significativas en la ruta para mostrar.", "info");
        return;
    }

    closeOtherModals('simulation-modal');
    
    let modal = document.getElementById('simulation-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'simulation-modal';
        document.body.appendChild(modal);
    }
    modal.innerHTML = `
        <h2 style="font-size: 1.5rem; font-weight: bold; text-align: center; margin-bottom: 1rem; color: white;">Maniobras de la Ruta</h2>
        <div class="modal-top-buttons" style="justify-content: flex-start; margin-bottom: 1rem;">
            <button id="close-simulation-modal" style="flex: 0 0 auto; width: auto; min-width: unset;">Salir <span class="button-countdown-timer unified-countdown-style"></span></button>
        </div>
        <div id="simulation-content-area"><p>Cargando maniobras...</p></div>
        <p style="font-size: 0.8rem; color: #8e8e93; text-align: center; margin-top: 1rem; font-style: italic;">Si quiere ver la maniobra pulse encima de una</p>
    `;
    modal.classList.remove('hidden');

    const closeButton = modal.querySelector('#close-simulation-modal');
    const closeSimulationModalHandler = () => {
        if (simulationModalTimer) clearTimeout(simulationModalTimer);
        clearModalAutoCloseTimer(modal, closeButton, 'simulation-modal');
        modal.classList.add('hidden');
        hideIntersectionPreviewMap();
    };
    closeButton.addEventListener('click', closeSimulationModalHandler);
    addModalAutoCloseTimer(modal, closeButton, 'simulation-modal', 50000);

    const carDist = lastCarDistanceAlongRouteForNavLogic;
    let simulationList = document.createElement('ul');
    let stepsShown = 0;
    let actualStageCounter = 1;
    let lastProcessedLegIndex = -1;
    
    const actualWaypointsForModal = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    
    for (const step of cleanManeuvers) {
        const distanceToEndOfThisStep = calculateDistanceToEndOfStep(route, step.originalLegIndex, step.originalStepIndex);
        if (distanceToEndOfThisStep < carDist) continue;

        if (step.originalLegIndex > lastProcessedLegIndex) {
            const leg = route.legs[step.originalLegIndex];
            const legDestinationWaypoint = actualWaypointsForModal[step.originalLegIndex]; // El destino de la etapa anterior es el inicio de esta.
            
            if (legDestinationWaypoint) { // Mostramos la cabecera para la etapa que COMIENZA.
                 const stageAddress = legDestinationWaypoint.address || `Etapa ${legDestinationWaypoint.label}`;
                 const stageDistance = route.legs[step.originalLegIndex -1]?.distance ? (route.legs[step.originalLegIndex -1].distance / 1000).toFixed(1) + " km" : "Dist. desc.";
                 const headerLi = document.createElement('li');
                 headerLi.style.cssText = "background-color: #3a3a3c; font-weight: bold; padding: 5px; margin-top:5px; color: #007aff;";
                headerLi.textContent = `ETAPA ${actualStageCounter}: ${stageAddress} (Total ${stageDistance})`;
                 simulationList.appendChild(headerLi);
                 actualStageCounter++; 
             
            }
            lastProcessedLegIndex = step.originalLegIndex;
        }
        
        const distanceToThisStepManeuver = Math.max(0, distanceToEndOfThisStep - carDist);
        const maneuver = step.maneuver;
        const type = maneuver.type || '';
        
        let maneuverText, streetNameText;

        if (type === 'arrive') {
            const arrivalWaypoint = actualWaypointsForModal[step.originalLegIndex + 1] || actualWaypointsForModal[actualWaypointsForModal.length - 1];
            if (arrivalWaypoint && arrivalWaypoint.type === 'intermediate') {
                maneuverText = `Llegada a Etapa ${actualStageCounter}`;
                streetNameText = ` <strong>${arrivalWaypoint.address || ''}</strong>`;
            } else {
                maneuverText = "Has llegado a tu destino";
                streetNameText = arrivalWaypoint ? ` <strong>${arrivalWaypoint.address || ""}</strong>` : "";
            }
        } else {
            maneuverText = maneuver.instruction || getManeuverInstructionText(maneuver);
            const banner = step.bannerInstructions;
            if (banner && banner.length > 0 && banner[0].primary) {
                let bannerPrimaryText = banner[0].primary.text;
                let bannerSecondaryText = banner[0].secondary ? banner[0].secondary.text : '';
                let fullBannerText = bannerPrimaryText + (bannerSecondaryText ? `: ${bannerSecondaryText}` : '');
                streetNameText = ` <strong style="color: #FFD700; font-size: 0.95em;">${fullBannerText}</strong>`;
            } else {
                streetNameText = (type === 'depart' || type.includes('roundabout') || type === 'end of road') ? '' : (step.name || '');
                if (streetNameText) {
                    streetNameText = ` <strong>${streetNameText}</strong>`;
                }
            }
        }
    
        let distanceFormatted = (distanceToThisStepManeuver >= 1000) ? `${(distanceToThisStepManeuver / 1000).toFixed(1)} km` : `${Math.round(distanceToThisStepManeuver)} m`;
        
        const li = document.createElement('li');
        li.dataset.legIndex = step.originalLegIndex;
        li.dataset.stepIndex = step.originalStepIndex;
        li.style.cursor = 'pointer';
        
        const iconContainer = document.createElement('span');
        iconContainer.className = 'turn-icon-sim';
        
        const textContainer = document.createElement('span');
        textContainer.innerHTML = `${maneuverText}${streetNameText} (${distanceFormatted})`;
        
        li.appendChild(iconContainer);
        li.appendChild(textContainer);
        simulationList.appendChild(li);

        const iconFilename = getManeuverIconFilename(maneuver);
        const iconUrl = `https://boardinggate.github.io/Tesla/${iconFilename}`;
        iconContainer.innerHTML = `<img src="${iconUrl}" alt="Maniobra" style="width:24px; height:24px; object-fit:contain;">`;
        
        stepsShown++;
    }
    
    const contentArea = modal.querySelector('#simulation-content-area');
    if (stepsShown > 0) {
        contentArea.innerHTML = '';
        contentArea.appendChild(simulationList);
        contentArea.removeEventListener('click', handleSimulationItemClick);
        contentArea.addEventListener('click', handleSimulationItemClick);
    } else {
        contentArea.innerHTML = "<p>No hay m√°s interacciones futuras en la ruta o est√°s muy cerca del final.</p>";
    }
}

// ===================================================================
// NOMBRE: showHelpModal
// RESUMEN: Muestra el modal de ayuda con ejemplos de uso para crear recordatorios.
function showHelpModal(options = {}) {
    const modal = document.createElement('div');
    modal.className = 'help-modal reminder-modal'; 
    modal.setAttribute('aria-label', 'Ayuda recordatorios');
    
    modal.innerHTML = `
        <div class="reminder-modal-header">
            <h2 class="reminder-modal-title">Ayuda de Recordatorios</h2>
        </div>
        <div class="reminder-modal-body">
            <p class="mb-4">Ejemplos de comandos de voz o texto:</p>
            <ul class="list-disc pl-6 mb-4 space-y-2">
                <li><strong>Texto:</strong> "Recordar cita", "Llamar mam√°"</li>
                <li><strong>Hora:</strong> "A LAS DIEZ Y CUARTO" ‚Üí 10:15, "A LAS CINCO Y MEDIA TARDE" ‚Üí 17:30</li>
                <li><strong>Fecha:</strong> "HOY", "MA√ëANA", "DENTRO DE 15 D√çAS", "EL D√çA 22", "PR√ìXIMO LUNES", "25/05/2025"</li>
                <li><strong>Repetici√≥n:</strong> "CADA LUNES", "TODOS LOS VIERNES Y S√ÅBADOS"</li>
                <li><strong>Intervalo:</strong> "CADA 7 D√çAS"</li>
                <li><strong>Alarma:</strong> "ALARMA EN 30 MINUTOS", "RECORDAR EN 2 HORAS".</li>
                <li><strong>Excluir/Radar:</strong> A√±adir "NO LISTAR", "EXCLUIR LISTA" o "RADAR" para ocultarlo de la lista general y que aparezca con chincheta morada en el mapa.</li>
            </ul>
            <p class="mb-4">Nota: Combina hora, fecha, d√≠as, etc. Las palabras Alarma, Aviso, Recordar, Timer... crean alarmas de tiempo exacto.</p>
            
            <h3 class="font-bold text-lg mt-6 mb-2 text-[#007aff]">Recordatorios por Ubicaci√≥n</h3>
            <ul class="list-disc pl-6 mb-4 space-y-2">
                <li><strong>Activar:</strong> Marca la casilla "RECORDATORIO POR UBICACI√ìN" o usa frases como "EN EL LUGAR", "EN EL SITIO".</li>
                <li><strong>Fijar Punto:</strong> Pulsa "VER/EDITAR POSICI√ìN EN MAPA" para ampliarlo y haz clic donde quieras fijar el punto. Usa "EST√ÅS AQU√ç" para centrar en tu posici√≥n.</li>
                <li><strong>Radio:</strong> Ajusta el radio con el slider o con frases como "RADIO DE 200 METROS".</li>
                <li><strong>Guardar/Usar Ubicaciones:</strong> Usa el bot√≥n "Ubicaciones" para guardar y seleccionar tus lugares frecuentes.</li>
                <li><strong>Navegaci√≥n:</strong> Para planificar rutas, usa el icono <img src="RADAR.PNG" alt="Radar Icon" style="width:1em; height:1em; vertical-align:middle; display:inline;"> en la barra superior. Consulta su ayuda espec√≠fica <img src="./PNG/IMG_4326.PNG" alt="Ayuda" style="height:1.2em; display:inline; vertical-align:middle;">.</li>
            </ul>
        </div>
        <div class="reminder-modal-footer">
            <button type="button" id="close-help" class="action-button primary" style="grid-column: 1 / -1;">Entendido</button>
        </div>
    `;
    const parent = options.parentContainer || document.body;
    parent.appendChild(modal);
    const closeHelpButton = modal.querySelector('#close-help');
    const closeHandler = () => { clearModalAutoCloseTimer(modal, closeHelpButton, 'help-modal'); if (modal.parentNode) modal.parentNode.removeChild(modal); };
    closeHelpButton.addEventListener('click', closeHandler); 
    addModalAutoCloseTimer(modal, closeHelpButton, 'help-modal');
}

    // ===================================================================
    // NOMBRE: stopAutomatedRouteSimulation
    // RESUMEN: Detiene completamente el modo de simulaci√≥n y vuelve al GPS real.
    function stopAutomatedRouteSimulation() {
        stopAutomatedRouteSimulationInternal();
        isSimulatingGpsLocation = false;
        const mapDiv = document.getElementById('reminders-location-map-div');
        if (mapDiv) {
            mapDiv.classList.remove('simulating-gps-click-mode');
        }
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) {
            simulateGpsButton.classList.remove('active-simulate-gps-mode');
            simulateGpsButton.title = "Activar Simulaci√≥n GPS (recorrido autom√°tico o clic manual)";
        }
        startGpsWatching();
        setNavigationMapClickHandler();
    }
    
    // ===================================================================
    // NOMBRE: toggleAddReminderAtLocationMode
    // RESUMEN: Activa/desactiva el modo para a√±adir un recordatorio haciendo clic en el mapa.
    function toggleAddReminderAtLocationMode() {
        isAddReminderAtLocationModeActive = !isAddReminderAtLocationModeActive;
        const mapDiv = document.getElementById('reminders-location-map-div');
        const button = document.getElementById('add-reminder-at-location-button');
        if (button) {
            if (isAddReminderAtLocationModeActive) {
                button.classList.add('active-reminder-mode');
                if (mapDiv) mapDiv.classList.add('add-reminder-mode');
                showToast("Modo 'A√±adir Recordatorio en Mapa' ACTIVADO. Pulsa en el mapa para crear un recordatorio.", "info", 5000);
            } else {
                button.classList.remove('active-reminder-mode');
                if (mapDiv) mapDiv.classList.remove('add-reminder-mode');
                showToast("Modo 'A√±adir Recordatorio en Mapa' DESACTIVADO.", "info");
            }
        }
        setNavigationMapClickHandler();
    }
    

// ===================================================================
// NOMBRE: handlePdrSearchButtonClick
// RESUMEN: Gestiona el ciclo de b√∫squeda de PDRs (Buscar > Filtrar > Limpiar).
function handlePdrSearchButtonClick() {
    const pdrButton = document.getElementById('pdrs-ruta-button');

    switch (pdrSearchState) {
        case 'initial': 
            if (pdrButton) pdrButton.classList.remove('pdr-search-highlight');
            showPDRsFilterModal();
            break;
            
        case 'results_shown': 
            if (lastPdrSearchResults.length > 0) {
                if (pdrButton) pdrButton.classList.add('pdr-search-highlight');
                filterForCheapestPDRs();
                pdrSearchState = 'cheapest_shown';
            } else {
                showToast("No hay PDRs en el mapa para filtrar. Realice una nueva b√∫squeda.", "info");
                pdrSearchState = 'initial'; 
                showPDRsFilterModal();
            }
            break;

        case 'cheapest_shown': 
            if (pdrButton) pdrButton.classList.remove('pdr-search-highlight');
            clearChargingPoints();
            showToast("Puntos de recarga eliminados del mapa.", "info");
            pdrSearchState = 'initial'; 
            break;
    }
}

// ===================================================================
// NOMBRE: filterForCheapestPDRs 
// RESUMEN: Filtra para mostrar solo los PDRs m√°s baratos y actualiza la lista principal de resultados.
function filterForCheapestPDRs() {
    if (lastPdrSearchResults.length === 0) {
        showToast("No hay resultados previos para filtrar. Realiza una nueva b√∫squeda.", "info");
        pdrSearchState = 'initial';
        return;
    }
    showToast("Mostrando solo los PDRs m√°s econ√≥micos por rango de potencia...", "info");

    const cheapestBySegment = {
        '#0f130c': { price: Infinity, point: null }, 
        '#007863': { price: Infinity, point: null }, 
        'rgb(30, 144, 255)': { price: Infinity, point: null }, 
        '#de2e03': { price: Infinity, point: null },
        '#5e5e5e': { price: Infinity, point: null } // A√±adir color para potencia desconocida
    };

    const parsePrice = (priceString) => {
        if (priceString && typeof priceString === 'string') {
            const priceMatch = priceString.match(/(\d[\d,.]*)/);
            if (priceMatch && priceMatch[1]) {
                const priceNum = parseFloat(priceMatch[1].replace(',', '.'));
                if (!isNaN(priceNum) && priceNum >= 0 && priceNum < 10) { // Permitir precio 0
                    return priceNum;
                }
            }
        }
        return Infinity;
    };

    lastPdrSearchResults.forEach(point => {
        const power = parseFloat(point.power);
        const segmentColor = getChargingPointColorByPower(power);
        const price = parsePrice(point.price);
        
        if (cheapestBySegment[segmentColor] && price < cheapestBySegment[segmentColor].price) {
            cheapestBySegment[segmentColor].price = price;
            cheapestBySegment[segmentColor].point = point;
        }
    });
    
    const cheapestPoints = Object.values(cheapestBySegment)
        .map(item => item.point)
        .filter(p => p !== null);
     cheapestPoints.forEach(p => { p.isCheapest = true; });

    lastPdrSearchResults = cheapestPoints;
    currentChargingPointsOnRoute = cheapestPoints;
 
    displayChargingPointsOnMap();
}    

//===================================================
// NOMBRE: addChargingPointToRoute 
// RESUMEN: A√±ade un PDR como etapa. Si no hay ruta, crea una nueva. Si se navega, preserva estad√≠sticas y permite la inserci√≥n.
async function addChargingPointToRoute(pointIndex) {
    const point = currentChargingPointsOnRoute[pointIndex];
    if (!point) return;

    const newWaypoint = {
        id: Date.now(),
        lat: point.lat,
        lng: point.lon,
        type: '', 
        marker: null,
        label: '',
        address: point.address || 'Punto de Recarga',
        visited: false,
        isCriticalForRecalc: true,
        isInternal: false,
        isRecalculatedStart: false
    };

    const hasExistingRoute = navigationWaypoints.filter(wp => wp && !wp.isInternal).length >= 2;
    
    if (hasExistingRoute) {
        try {
            const route = navigationCurrentRouteData?.routes?.[0];
            if (!route || !route._turfLineString) {
                throw new Error("Geometr√≠a de ruta no disponible para inserci√≥n inteligente.");
            }
            const routeLine = route._turfLineString;
            
            const pdrPoint = turf.point([newWaypoint.lng, newWaypoint.lat]);
            const pdrDistanceOnRoute = turf.nearestPointOnLine(routeLine, pdrPoint, { units: 'meters' }).properties.location;

            const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal);
            const waypointDistances = actualWaypoints.map(wp => {
                const wpPoint = turf.point([wp.lng, wp.lat]);
                const distance = turf.nearestPointOnLine(routeLine, wpPoint, { units: 'meters' }).properties.location;
                return { waypoint: wp, distance: distance };
            });

            let insertAfterIndex = -1;
            for (let i = 0; i < waypointDistances.length - 1; i++) {
                if (pdrDistanceOnRoute > waypointDistances[i].distance && pdrDistanceOnRoute < waypointDistances[i+1].distance) {
                    insertAfterIndex = i;
                    break;
                }
            }
            
            if (insertAfterIndex === -1) {
                insertAfterIndex = waypointDistances.length - 2;
            }

            const waypointToInsertAfter = actualWaypoints[insertAfterIndex];
            const finalInsertIndex = navigationWaypoints.findIndex(wp => wp.id === waypointToInsertAfter.id);

            if (finalInsertIndex !== -1) {
                navigationWaypoints.splice(finalInsertIndex + 1, 0, newWaypoint);
                showToast(`'${newWaypoint.address}' insertado en la ruta.`, "success");
            } else {
                throw new Error("No se pudo encontrar el punto de inserci√≥n.");
            }
        } catch (error) {
            console.error("Fallo en la inserci√≥n inteligente, usando fallback:", error);
            const finalDestinationIndex = navigationWaypoints.findIndex(wp => wp.type === 'F');
            if (finalDestinationIndex !== -1) {
                navigationWaypoints.splice(finalDestinationIndex, 0, newWaypoint);
            } else {
                navigationWaypoints.push(newWaypoint);
            }
            showToast(`'${newWaypoint.address}' a√±adido como etapa. Recalculando...`, "success");
        }
    } else {
        if (!navigationCurrentLocation) {
            showToast("No se puede a√±adir el punto de carga sin una ubicaci√≥n GPS inicial.", "error");
            return;
        }

        const startPoint = {
            id: Date.now() - 1, lat: navigationCurrentLocation.latitude, lng: navigationCurrentLocation.longitude,
            type: 'S', marker: null, label: 'S', address: 'Posici√≥n Actual (GPS)',
            visited: true, isCriticalForRecalc: true, isInternal: false, isRecalculatedStart: false
        };
        navigationWaypoints.push(startPoint, newWaypoint);
        showToast("Ruta creada desde tu posici√≥n hasta el punto de recarga.", "success");
    }

    await updateWaypointTypesAndLabels();
    renderWaypointMarkers();

    try {
        await recalculateAndDrawRoute(isNavigating);
        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
            toggleRadaresRuta(true);
        }
    } catch (e) {
        showToast("Error recalculando la ruta tras a√±adir el punto de recarga.", "error");
    }
    
    clearChargingPoints();
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}

// ===================================================================
// NOMBRE: calculateDistanceToEndOfStep
// RESUMEN: Calcula la distancia acumulada hasta el final de un paso espec√≠fico de la ruta.
    function calculateDistanceToEndOfStep(route, targetLegIndex, targetStepIndex) {
        let totalDistance = 0;
        if (!route || !route.legs) return 0;
        for (let legIdx = 0; legIdx <= targetLegIndex; legIdx++) {
            const leg = route.legs[legIdx];
            if (!leg || !leg.steps) continue;
            const limitStepIndex = (legIdx === targetLegIndex) ? targetStepIndex : leg.steps.length - 1;
            for (let stepIdx = 0; stepIdx <= limitStepIndex; stepIdx++) {
                const step = leg.steps[stepIdx];
                if (step && typeof step.distance === 'number') {
                    totalDistance += step.distance;
                }
            }
        }
        return totalDistance;
}
// ===================================================================
// NOMBRE: plotRemindersOnNavigationMap 
// RESUMEN: Dibuja TODOS los recordatorios visibles (generales + de ruta) en el mapa
function plotRemindersOnNavigationMap() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
        return;
    }

    const sourceId = 'reminders-geojson-source';
    const plottedRemindersMap = new Map();

    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    const generalRemindersWithLocation = reminders.filter(r => 
        r.isLocationEnabled && 
        r.locationCoordinates?.latitude && 
        r.locationCoordinates?.longitude &&
        !r.isFromRuta 
    );
    generalRemindersWithLocation.forEach(reminder => {
        plottedRemindersMap.set(reminder.id, reminder);
    });

    const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresCheckbox && radaresCheckbox.checked && radaresEnRutaActual.length > 0) {
        radaresEnRutaActual.forEach(radar => {
            plottedRemindersMap.set(radar.id, radar);
        });
    }

    const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasCheckbox && tareasCheckbox.checked && tareasEnRutaActual.length > 0) {
        tareasEnRutaActual.forEach(tarea => {
            plottedRemindersMap.set(tarea.id, tarea);
        });
    }

    const locationsToPlot = Array.from(plottedRemindersMap.values());
    const geojsonFeatures = locationsToPlot.map(reminder => {
        const isRadar = reminder.text.toUpperCase().includes("RADAR") || reminder.excludeFromList;
        const speed = isRadar ? extractSpeedFromRadarText(reminder.text) : null;
        const properties = {
            reminderId: reminder.id, isRadar: isRadar, isFromTarea: reminder.isFromTarea || false,
        };
        if (speed !== null) { properties.speed = speed; }
        return {
            type: 'Feature',
            geometry: { type: 'Point', coordinates: [reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude] },
            properties: properties
        };
    });

    const geojsonData = { type: 'FeatureCollection', features: geojsonFeatures };
    
    const source = navigationMapInstance.getSource(sourceId);
    if (source) {
        source.setData(geojsonData);
    } else {
        try {
            navigationMapInstance.addSource(sourceId, { type: 'geojson', data: geojsonData });
            
            navigationMapInstance.addLayer({
                id: 'reminders-icons-layer', type: 'symbol', source: sourceId, filter: ['==', 'isRadar', false],
                minzoom: 6.5, maxzoom: 19, 
                layout: { 'icon-image': 'reminder-icon', 'icon-size': ['interpolate', ['linear'], ['zoom'], 10, 0.3, 14, 0.4, 17, 0.5], 'icon-allow-overlap': true, 'icon-anchor': 'bottom' }
            });
            navigationMapInstance.addLayer({
                id: 'radar-circles-layer', type: 'circle', source: sourceId, filter: ['==', 'isRadar', true],
                minzoom: 6.5, maxzoom: 19, 
                paint: { 'circle-radius': ['interpolate', ['linear'], ['zoom'], 11.5, 9, 16.5, 24], 'circle-color': 'red', 'circle-stroke-width': ['interpolate', ['linear'], ['zoom'], 11.5, 1, 16.5, 2], 'circle-stroke-color': ['case', ['get', 'isFromTarea'], '#00FF00', 'white'] }
            });
            navigationMapInstance.addLayer({
                id: 'radar-text-layer', type: 'symbol', source: sourceId, filter: ['==', 'isRadar', true], 
                minzoom: 6.5, maxzoom: 19, 
                layout: { 'text-field': ['case', ['has', 'speed'], ['to-string', ['get', 'speed']], 'Rdr'], 'text-font': ["Arial Unicode MS Bold", "Open Sans Bold"], 'text-size': ['interpolate', ['linear'], ['zoom'], 11.5, 8, 16.5, 22], 'text-allow-overlap': true },
                paint: { 'text-color': 'yellow', 'text-halo-color': 'black', 'text-halo-width': 1.5 }
            });
            
            const interactiveLayers = ['reminders-icons-layer', 'radar-circles-layer'];
            navigationMapInstance.on('mouseenter', interactiveLayers, () => { if(navigationMapInstance) navigationMapInstance.getCanvas().style.cursor = 'pointer'; });
            navigationMapInstance.on('mouseleave', interactiveLayers, () => { if(navigationMapInstance) navigationMapInstance.getCanvas().style.cursor = ''; });

        } catch (e) {
            console.error("Error al a√±adir la fuente/capas de recordatorios por primera vez:", e);
        }
    }
}    
    
// ===================================================================
// NOMBRE: updateLocateMeButtonsUI 
// RESUMEN: Sincroniza la apariencia (icono y t√≠tulo) de ambos botones de localizaci√≥n.
function updateLocateMeButtonsUI() {
    const topButton = document.getElementById('locate-me-on-reminders-map');
    const bottomButton = document.getElementById('zoom-locate-me-button');
    const buttons = [topButton, bottomButton].filter(Boolean);

    buttons.forEach(button => {
        const img = button.querySelector('img');
        if (!img) return;

        if (navigationFollowUser) {
            img.src = "PNG/DEJARSEGUIR.PNG";
            button.title = "Dejar de centrar el mapa en mi posici√≥n";
            const countdownOverlay = bottomButton?.querySelector('.countdown-overlay');
            if (countdownOverlay) {
                countdownOverlay.remove();
            }
        } else {
            img.src = "PNG/ESTASAQUI.PNG";
            button.title = "Mostrar mi posici√≥n actual y activar seguimiento";
        }
    });
}

// ===================================================================
// NOMBRE: clearLocateMeReactivationTimer 
// RESUMEN: Limpia los temporizadores de reactivaci√≥n y el contador visual.
function clearLocateMeReactivationTimer() {
    const mapModal = document.getElementById('reminders-location-map-modal');
    if (mapModal) {
        mapModal.classList.remove('manual-override');
    }
   
    if (window.followMeReactivationTimer) {
        clearTimeout(window.followMeReactivationTimer);
        window.followMeReactivationTimer = null;
    }
  
    if (manualZoomTimeout) { clearTimeout(manualZoomTimeout); manualZoomTimeout = null; }
    if (locateMeCountdownInterval) { clearInterval(locateMeCountdownInterval); locateMeCountdownInterval = null; }
    const bottomButton = document.getElementById('zoom-locate-me-button');
    const countdownOverlay = bottomButton?.querySelector('.countdown-overlay');
    if (countdownOverlay) { countdownOverlay.remove(); }
}
    
// ===================================================================
// NOMBRE: startLocateMeReactivationTimer 
// RESUMEN: Inicia el temporizador de 30s y el contador visual para reactivar el seguimiento.

function startLocateMeReactivationTimer() {
    clearLocateMeReactivationTimer();

    window.followMeReactivationTimer = setTimeout(() => {
        setMapImmersiveMode(false); // Desactiva el modo inmersivo, restaurando todo a la normalidad
        const mapModal = document.getElementById('reminders-location-map-modal');
        if (mapModal) {
            mapModal.classList.remove('manual-override'); // Limpia la clase de anulaci√≥n
        }
     
        const mapModalVisible = document.getElementById('reminders-location-map-modal');
        if (!navigationFollowUser && mapModalVisible && !mapModalVisible.classList.contains('map-modal-hidden')) {
            handleLocateMeClick(true);
            showToast("Seguimiento autom√°tico reactivado.", "info");
        }
        clearLocateMeReactivationTimer();
    }, 30000);
    
    manualZoomTimeout = window.followMeReactivationTimer;
    let countdown = 30;
    const bottomButton = document.getElementById('zoom-locate-me-button');
    if (!bottomButton) return;
    let countdownOverlay = bottomButton.querySelector('.countdown-overlay');
    if (!countdownOverlay) {
        countdownOverlay = document.createElement('div');
        countdownOverlay.className = 'countdown-overlay';
        bottomButton.appendChild(countdownOverlay);
    }
    countdownOverlay.textContent = countdown;
    locateMeCountdownInterval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
            countdownOverlay.textContent = countdown;
        } else {
            clearLocateMeReactivationTimer();
        }
    }, 1000);
}
    
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// NOMBRE: triggerArrivalSequence 
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function triggerArrivalSequence() {
    if (isArrivalSequenceStarted) return; 
    isArrivalSequenceStarted = true;
  
    if (navigationMapInstance && navigationCurrentLocation) {
        isFlying = true;
        navigationFollowUser = false; 
        shouldCenterOnUser = false;
        
        const targetZoom = 16;
        const targetPitch = 0;
        const targetBearing = 0;

        markerAnimationState.targetMapZoom = targetZoom;
        markerAnimationState.targetMapPitch = targetPitch;
        markerAnimationState.targetMapBearing = targetBearing;
        markerAnimationState.currentMapZoom = navigationMapInstance.getZoom();
        markerAnimationState.currentMapPitch = navigationMapInstance.getPitch();
        markerAnimationState.currentMapBearing = navigationMapInstance.getBearing();

        navigationMapInstance.flyTo({
            center: [navigationCurrentLocation.longitude, navigationCurrentLocation.latitude],
            zoom: targetZoom,
            pitch: targetPitch,
            bearing: targetBearing,
            duration: 1500
        });
        navigationMapInstance.once('moveend', () => { isFlying = false; });
    }
    
    showArrivalStatsModal();
}    

// ===================================================================
// NOMBRE: triggerManualMapInteraction 
// RESUMEN: Desactiva temporalmente el seguimiento. Si el modo es 'RUTA', lo cambia a 'OFF'.
function triggerManualMapInteraction() {
    isManualZoomActive = true;
    navigationFollowUser = false;
    shouldCenterOnUser = false;

    setMapImmersiveMode(true); // Activa el modo inmersivo para ocultar todo
    const mapModal = document.getElementById('reminders-location-map-modal');
    if (mapModal) {
        mapModal.classList.add('manual-override'); // A√±ade la clase que rescata la botonera inferior
    }
  
    clearLocateMeReactivationTimer();
    
    if (navigationMapInstance) {
        manualZoomLevelMemory = navigationMapInstance.getZoom();
    }

    const currentAutoZoomMode = localStorage.getItem(AUTO_ZOOM_MODE_KEY) || 'off';
    const autoBtn = document.getElementById('zoom-auto-button');

    if (currentAutoZoomMode === 'route') {
        localStorage.setItem(AUTO_ZOOM_MODE_KEY, 'off');
        showToast("Modo 'Ruta' desactivado por interacci√≥n manual.", "info");

        if (autoBtn) {
            autoBtn.textContent = 'AUTO';
            autoBtn.classList.remove('active', 'route-mode');
            autoBtn.title = 'Zoom autom√°tico (Desactivado)';
        }
    }
  
    startLocateMeReactivationTimer();
    updateLocateMeButtonsUI();
}
// ===================================================================
// NOMBRE: handleManualMapInteraction 
// RESUMEN: Desactiva el seguimiento SOLO cuando detecta un gesto de arrastre o
function handleManualMapInteraction() {
    if (!navigationFollowUser) {
        startLocateMeReactivationTimer();
        return;
    }
    
    triggerManualMapInteraction();
}
    

// ===================================================================
// NOMBRE: generateBackup
// RESUMEN: Genera un c√≥digo de backup con todos los datos locales y lo copia al portapapeles.
function generateBackup() {
    const backupData = {};
    managedKeys.forEach(key => {
        const value = localStorage.getItem(key);
        if (value !== null) {
            backupData[key] = value;
        }
    });
    const backupString = JSON.stringify(backupData);
    const backupDisplay = document.getElementById('config-backup-display');
    backupDisplay.value = btoa(unescape(encodeURIComponent(backupString)));
    backupDisplay.style.display = 'block';
    backupDisplay.select();
    try {
        document.execCommand('copy');
        showToast('Backup copiado al portapapeles', 'success');
         document.getElementById('config-backup-status').textContent = '¬°Copiado! Guarda este c√≥digo en un lugar seguro.';
         document.getElementById('config-backup-status').style.color = '#28a745';
    } catch (err) {
        showToast('Error al copiar. Por favor, copia manualmente', 'warning');
        document.getElementById('config-backup-status').textContent = 'Copia este c√≥digo manualmente y gu√°rdalo.';
        document.getElementById('config-backup-status').style.color = '#ffc107';
    }
}    

// ===================================================================
function handleTouchCancel(e) {    if (!isEditMode) return;     handleTouchEndCleanup(); }
       
// ===================================================================
// NOMBRE: getCurrentLocationAsync 
// RESUMEN: Envuelve getCurrentLocation en una Promise para poder usar async/await.
function getCurrentLocationAsync() {
    return new Promise((resolve, reject) => {
        getCurrentLocation(
            (coords) => resolve(coords),
            (errorMsg) => reject(new Error(errorMsg))
        );
    });
}

// ===================================================================
// NOMBRE: displayChargingPointsOnMap 
// RESUMEN: Aumenta el maxzoom de las capas de PDRs para que sean visibles desde m√°s lejos.
// ===================================================================
function displayChargingPointsOnMap() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) return;

    const sourceId = 'pdrs-geojson-source';
    const layersToRemove = [
        'pdr-cards-layer-availability', 'pdr-cards-layer-price', 'pdr-cards-layer-operator', 'pdr-cards-layer-power', 'pdr-cards-layer-bg-halo', 'pdr-cards-layer-bg',
        'pdr-simple-text-layer', 'pdr-simple-circle-layer'
    ];
    layersToRemove.forEach(id => { try { if (navigationMapInstance.getLayer(id)) navigationMapInstance.removeLayer(id); } catch(e) {} });
    try { if (navigationMapInstance.getSource(sourceId)) navigationMapInstance.removeSource(sourceId); } catch(e) {}

    const geojsonFeatures = lastPdrSearchResults.map((point, index) => {
        const operatorText = point.operator.length > 15 ? point.operator.substring(0, 14) + '...' : point.operator;
        
        return {
            type: 'Feature',
            geometry: {
                type: 'Point',
                coordinates: [point.lon, point.lat]
            },
            properties: {
                ocmId: point.ocmId,
                index: index,
                bgColor: getChargingPointColorByPower(parseFloat(point.power)),
                isCheapest: point.isCheapest || false,
                power: point.power,
                operator: operatorText,
                price: point.price,
                availability: point.availabilityText
            }
        };
    });

    const geojsonData = {
        type: 'FeatureCollection',
        features: geojsonFeatures
    };
    
    navigationMapInstance.addSource(sourceId, { type: 'geojson', data: geojsonData });

    navigationMapInstance.addLayer({ id: 'pdr-simple-circle-layer', type: 'circle', source: sourceId, minzoom: 6, maxzoom: 13.99, filter: ['<=', ['zoom'], 14], paint: { 'circle-radius': 18, 'circle-color': ['get', 'bgColor'], 'circle-opacity': 1, 'circle-stroke-width': ['case', ['==', ['get', 'isCheapest'], true], 3.5, 2], 'circle-stroke-color': ['case', ['==', ['get', 'isCheapest'], true], '#FFD700', 'white'] } });
    navigationMapInstance.addLayer({ id: 'pdr-simple-text-layer', type: 'symbol', source: sourceId, minzoom: 6, maxzoom: 13.99, filter: ['<=', ['zoom'], 14], layout: { 'text-field': ['concat', ['get', 'power'], 'kW'], 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 9, 'text-allow-overlap': true }, paint: { 'text-color': 'white', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
    
    navigationMapInstance.addLayer({ id: 'pdr-cards-layer-bg-halo', type: 'circle', source: sourceId, minzoom: 14, maxzoom: 19, filter: ['all', ['>', ['zoom'], 14], ['==', ['get', 'isCheapest'], true]], paint: { 'circle-radius': 48, 'circle-color': '#FFD700', 'circle-opacity': 0.8, 'circle-blur': 1 } });
    navigationMapInstance.addLayer({ id: 'pdr-cards-layer-bg', type: 'circle', source: sourceId, minzoom: 14, maxzoom: 19, filter: ['>', ['zoom'], 14], paint: { 'circle-radius': 45, 'circle-color': ['get', 'bgColor'], 'circle-opacity': 1, 'circle-stroke-width': 3, 'circle-stroke-color': 'white' } });
    navigationMapInstance.addLayer({ id: 'pdr-cards-layer-power', type: 'symbol', source: sourceId, minzoom: 14, maxzoom: 19, filter: ['>', ['zoom'], 14], layout: { 'text-field': ['concat', ['get', 'power'], ' kW'], 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 14, 'text-offset': [0, -1.5], 'text-allow-overlap': true }, paint: { 'text-color': '#ffd700', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
    navigationMapInstance.addLayer({ id: 'pdr-cards-layer-operator', type: 'symbol', source: sourceId, minzoom: 14, maxzoom: 19, filter: ['>', ['zoom'], 14], layout: { 'text-field': ['get', 'operator'], 'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'], 'text-size': 11, 'text-offset': [0, -0.3], 'text-allow-overlap': true, 'text-max-width': 10 }, paint: { 'text-color': 'white', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
    navigationMapInstance.addLayer({ id: 'pdr-cards-layer-price', type: 'symbol', source: sourceId, minzoom: 14, maxzoom: 19, filter: ['>', ['zoom'], 14], layout: { 'text-field': ['get', 'price'], 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 13, 'text-offset': [0, 1.0], 'text-allow-overlap': true }, paint: { 'text-color': '#90ee90', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
    navigationMapInstance.addLayer({ id: 'pdr-cards-layer-availability', type: 'symbol', source: sourceId, minzoom: 14, maxzoom: 19, filter: ['>', ['zoom'], 14], layout: { 'text-field': ['get', 'availability'], 'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'], 'text-size': 10, 'text-offset': [0, 2.8], 'text-allow-overlap': true }, paint: { 'text-color': '#e0e0e0', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
}

// ===================================================================
// NOMBRE: renderWaypointMarkers (VERSI√ìN OPTIMIZADA - CORRECCI√ìN DE √ÅMBITO)
// RESUMEN: Actualiza los marcadores de etapa de forma eficiente, solucionando
function renderWaypointMarkers() {
    if (!navigationMapInstance) return;

    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    const actualWaypointIds = new Set(actualWaypoints.map(wp => wp.id));

    navigationWaypoints.forEach((wp) => {
        if (wp && wp.marker && !actualWaypointIds.has(wp.id)) {
            try {
                wp.marker.remove();
            } catch (e) {}
            wp.marker = null;
        }
    });

    actualWaypoints.forEach(wp => {
        if (!wp || typeof wp.lat !== 'number' || typeof wp.lng !== 'number') return;

        if (!wp.marker) {
            const waypointIconElement = createWaypointMarkerIcon(wp.label, wp.type, wp.visited, wp.id);
            waypointIconElement.dataset.waypointId = wp.id;

            wp.marker = new mapboxgl.Marker({
                element: waypointIconElement,
                draggable: false,
                anchor: 'center'
            }).setLngLat([wp.lng, wp.lat]).addTo(navigationMapInstance);

            if (!isNavigating) {
                ((waypoint, marker) => {
                    const markerElement = marker.getElement();
                    let isDragging = false;
                    let hasMovedEnough = false;
                    let startPos = { x: 0, y: 0 };

                    const onPointerDown = (e) => {
                        if (isNavigating) return;
                        e.stopPropagation();
                        isDragging = false;
                        hasMovedEnough = false;
                        const point = e.touches ? e.touches[0] : e;
                        startPos = { x: point.clientX, y: point.clientY };
                        document.addEventListener('mousemove', onPointerMove);
                        document.addEventListener('mouseup', onPointerUp);
                        document.addEventListener('touchmove', onPointerMove, { passive: false });
                        document.addEventListener('touchend', onPointerUp);
                    };

                    const onPointerMove = (e) => {
                        if (e.type === 'touchmove') e.preventDefault();
                        const point = e.touches ? e.touches[0] : e;
                        const deltaX = Math.abs(point.clientX - startPos.x);
                        const deltaY = Math.abs(point.clientY - startPos.y);
                        if (!hasMovedEnough && (deltaX > 5 || deltaY > 5)) {
                            hasMovedEnough = true;
                            navigationMapInstance.getCanvas().style.cursor = 'grabbing';
                            markerElement.style.cursor = 'grabbing';
                        }
                        if (hasMovedEnough) {
                            isDragging = true;
                            const mapContainer = document.getElementById('mapbox-map-actual-container');
                            const mapRect = mapContainer.getBoundingClientRect();
                            const relativeX = point.clientX - mapRect.left;
                            const relativeY = point.clientY - mapRect.top;
                            const coords = navigationMapInstance.unproject([relativeX, relativeY]);
                            marker.setLngLat(coords);
                        }
                    };

                    const onPointerUp = async (e) => {
                        document.removeEventListener('mousemove', onPointerMove);
                        document.removeEventListener('mouseup', onPointerUp);
                        document.removeEventListener('touchmove', onPointerMove);
                        document.removeEventListener('touchend', onPointerUp);
                        navigationMapInstance.getCanvas().style.cursor = '';
                        markerElement.style.cursor = 'pointer';
                        if (isDragging) {
                            const point = e.changedTouches ? e.changedTouches[0] : e;
                            const mapContainer = document.getElementById('mapbox-map-actual-container');
                            const mapRect = mapContainer.getBoundingClientRect();
                            const relativeX = point.clientX - mapRect.left;
                            const relativeY = point.clientY - mapRect.top;
                            const finalCoords = navigationMapInstance.unproject([relativeX, relativeY]);
                            const waypointIndex = navigationWaypoints.findIndex(w => w.id === waypoint.id);
                            if (waypointIndex !== -1) {
                                navigationWaypoints[waypointIndex].lat = finalCoords.lat;
                                navigationWaypoints[waypointIndex].lng = finalCoords.lng;
                                navigationWaypoints[waypointIndex].address = await getAddressForWaypoint(finalCoords.lat, finalCoords.lng);
                                await recalculateAndDrawRoute();
                                renderWaypointMarkers();
                            }
                        } else {
                            showWaypointActionModal(waypoint.id);
                        }
                        isDragging = false;
                        hasMovedEnough = false;
                    };

                    markerElement.addEventListener('mousedown', onPointerDown);
                    markerElement.addEventListener('touchstart', onPointerDown, { passive: false });
                })(wp, wp.marker);
            }
     
        } else {
            const markerElement = wp.marker.getElement();
            const currentColor = markerElement.style.backgroundColor;
            let newColor;
            if (wp.visited) {
                newColor = 'rgba(85, 85, 85, 0.8)';
            } else if (wp.type === 'S') {
                newColor = 'rgba(0, 128, 0, 0.8)';
            } else if (wp.type === 'F') {
                newColor = 'rgba(0, 0, 255, 0.8)';
            } else {
                newColor = 'rgba(230, 140, 0, 0.8)';
            }
            if (currentColor !== newColor) {
                markerElement.style.backgroundColor = newColor;
                markerElement.style.border = `2px solid ${wp.visited ? '#555' : 'white'}`;
                markerElement.style.opacity = wp.visited ? '0.7' : '1';
            }
            wp.marker.setLngLat([wp.lng, wp.lat]);
            markerElement.textContent = wp.label;
        }
    });
}    
 
// ===================================================================
// NOMBRE: handleProgressBarLockToggle
// RESUMEN: Cambia el estado del candado, lo guarda y actualiza la UI,
function handleProgressBarLockToggle() {
    isProgressBarLocked = !isProgressBarLocked;
    saveSettings(); // <-- ESTA L√çNEA ES LA CORRECCI√ìN. Llama a la funci√≥n que guarda y marca los datos para sincronizar.
    updateProgressBarLockIcon();
    showToast(`Panel de progreso ${isProgressBarLocked ? 'BLOQUEADO' : 'DESBLOQUEADO'}`, 'info');
    
    const progressBar = document.getElementById('navigation-bottom-progress-bar');
    if (isProgressBarLocked) {
        progressBar.classList.remove('progress-bar-auto-hidden');
    } else {
        if (navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
            updateTurnByTurnDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
        }
    }
}
    
    // ===================================================================
    // NOMBRE: formatPhotonFeatureName
    // RESUMEN: Formatea el nombre de una ubicaci√≥n obtenida del servicio Photon.
    function formatPhotonFeatureName(feature) {
        if (!feature || !feature.properties) return "Ubicaci√≥n desconocida";
        const props = feature.properties;
        let nameParts = [];
        if (props.name) nameParts.push(props.name);
        if (props.street) { let streetPart = props.street; if (props.housenumber) streetPart += ` ${props.housenumber}`; nameParts.push(streetPart); }
        if (props.postcode) nameParts.push(props.postcode);
        if (props.city && (!props.name || props.name.toLowerCase() !== props.city.toLowerCase())) nameParts.push(props.city);
        else if (props.county && (!props.name || props.name.toLowerCase() !== props.county.toLowerCase())) nameParts.push(props.county);
        else if (props.state && (!props.name || props.name.toLowerCase() !== props.state.toLowerCase())) nameParts.push(props.state);
        if (props.country && nameParts.length > 0 && props.country.toLowerCase() !== nameParts[nameParts.length - 1].toLowerCase()) nameParts.push(props.country);
        else if (props.country && nameParts.length === 0) nameParts = [props.country];
        let formattedName = nameParts.filter((value, index, self) => self.map(v => v.toLowerCase()).indexOf(value.toLowerCase()) === index).join(', ');
        if (!formattedName && feature.geometry && feature.geometry.coordinates) { formattedName = `(${feature.geometry.coordinates[1].toFixed(4)}, ${feature.geometry.coordinates[0].toFixed(4)})`; }
        return formattedName || "Ubicaci√≥n desconocida";
    }

// ===================================================================
// NOMBRE: addWaypoint 
// RESUMEN: A√±ade un punto de ruta. Pausa el modo "Free Drive" si est√° activo y gestiona la inserci√≥n de etapas durante la navegaci√≥n.
async function addWaypoint(latlng, displayName = null) {
    
    if (navigationFollowUser) {
        triggerManualMapInteraction();
        showToast("Seguimiento pausado para a√±adir puntos.", "info");
    }

    if (isFreeDriveActive) {
        isFreeDrivePaused = true;
        isFreeDriveActive = false;
        showToast("Modo Conducci√≥n Libre en pausa.", "info");
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        clearNavigationGraph();
    }
    
    let address = displayName;
    if (!address) {
        address = await getAddressForWaypoint(latlng.lat, latlng.lng);
    }

    const newWaypoint = {
        id: Date.now(),
        lat: latlng.lat,
        lng: latlng.lng,
        type: '',
        marker: null,
        label: '',
        address: address,
        visited: false,
        isCriticalForRecalc: true,
        isInternal: false,
        isRecalculatedStart: false
    };

    const hasExistingRoute = navigationWaypoints.filter(wp => wp && !wp.isInternal).length >= 2;

    if (hasExistingRoute) {
        try {
            const route = navigationCurrentRouteData?.routes?.[0];
            if (!route || !route._turfLineString) {
                throw new Error("Geometr√≠a de ruta no disponible para inserci√≥n inteligente.");
            }
            const routeLine = route._turfLineString;
            
            const newPoint = turf.point([newWaypoint.lng, newWaypoint.lat]);
            const newWaypointDistanceOnRoute = turf.nearestPointOnLine(routeLine, newPoint, { units: 'meters' }).properties.location;

            const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal);
            const waypointDistances = actualWaypoints.map(wp => {
                const wpPoint = turf.point([wp.lng, wp.lat]);
                const distance = turf.nearestPointOnLine(routeLine, wpPoint, { units: 'meters' }).properties.location;
                return { waypoint: wp, distance: distance };
            });

            let insertAfterIndex = -1;
            for (let i = 0; i < waypointDistances.length - 1; i++) {
                if (newWaypointDistanceOnRoute > waypointDistances[i].distance && newWaypointDistanceOnRoute < waypointDistances[i+1].distance) {
                    insertAfterIndex = i;
                    break;
                }
            }
            if (insertAfterIndex === -1) {
                insertAfterIndex = waypointDistances.length - 2;
            }

            const waypointToInsertAfter = actualWaypoints[insertAfterIndex];
            const finalInsertIndex = navigationWaypoints.findIndex(wp => wp.id === waypointToInsertAfter.id);
            if (finalInsertIndex !== -1) {
                navigationWaypoints.splice(finalInsertIndex + 1, 0, newWaypoint);
                showToast(`'${newWaypoint.address}' insertado en la ruta.`, "success");
            } else {
                throw new Error("No se pudo encontrar el punto de inserci√≥n.");
            }
        } catch (error) {
            console.error("Fallo en la inserci√≥n inteligente de POI, usando fallback:", error);
            const finalDestinationIndex = navigationWaypoints.findIndex(wp => wp.type === 'F');
            if (finalDestinationIndex !== -1) {
                navigationWaypoints.splice(finalDestinationIndex, 0, newWaypoint);
            } else {
                navigationWaypoints.push(newWaypoint);
            }
            showToast(`'${newWaypoint.address}' a√±adido como etapa. Recalculando...`, "success");
        }
    } else {
        if (navigationWaypoints.length === 0 && navigationCurrentLocation) {
            const startPoint = {
                id: Date.now() - 1,
                lat: navigationCurrentLocation.latitude,
                lng: navigationCurrentLocation.longitude,
                type: 'S',
                marker: null,
                label: 'S',
                address: 'Posici√≥n Actual (GPS)',
                visited: true,
                isCriticalForRecalc: true,
                isInternal: false,
                isRecalculatedStart: false
            };
            navigationWaypoints.push(startPoint);
        }
        navigationWaypoints.push(newWaypoint);
        
        if (navigationWaypoints.filter(wp => wp && !wp.isInternal).length >= 2) {
            showToast("PULSACI√ìN LARGA PARA A√ëADIR y ELIMINAR ETAPA, PUEDE ARRASTRARLA para RESITUARLA", "instructional", 3000);
        }
    }

    await updateWaypointTypesAndLabels();
    renderWaypointMarkers();

    if (navigationWaypoints.filter(wp => wp && !wp.isInternal).length >= 2) {
        recalculateAndDrawRoute(isNavigating);
        
        if (navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
            updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], 0);
        }
    }
    
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}
    
// ===================================================================
// NOMBRE: fetchAddressSuggestions 
// RESUMEN: En lugar de ocultar el modal cuando no hay resultados, lo mantiene
//          abierto y le pasa un array vac√≠o para que muestre un mensaje.
async function fetchAddressSuggestions(query) {
    if (!query || query.length < 3) {
        hideAddressSuggestionsModal();
        return;
    }
    try {
        let queryToSearch = query.replace(/,/g, '');
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(queryToSearch)}&limit=60&accept-language=es&addressdetails=1`;
        
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Error de red: ${response.status}`);
        
        const data = await response.json();

        if (data && data.length > 0) {
            const results = data.reduce((acc, item) => {
                if (item && typeof item.lat === 'string' && item.lat.trim() !== '' && typeof item.lon === 'string' && item.lon.trim() !== '') {
                    acc.push({
                        display_name: item.display_name || "Ubicaci√≥n desconocida",
                        lat: parseFloat(item.lat),
                        lon: parseFloat(item.lon)
                    });
                }
                return acc;
            }, []);
            if (results.length === 0) {
                 displayAddressSuggestionsModal([]);
            } else {
                 displayAddressSuggestionsModal(results.slice(0, 60));
            }

        } else {
            displayAddressSuggestionsModal([]);
        }
    } catch (error) {
        showToast(`Error buscando sugerencias: ${error.message}`, "error");
        hideAddressSuggestionsModal();
    }
}   
// ===================================================================
// NOMBRE: snapCoordsToRoad 
// RESUMEN: Toma coordenadas y devuelve las coordenadas del punto m√°s cercano en la red de carreteras.
async function snapCoordsToRoad(lat, lon) {
    try {
        const nearestUrl = `${OSRM_SERVICE_URL}/nearest/v1/driving/${lon},${lat}?number=1`;
        const nearestResponse = await fetch(nearestUrl);
        if (!nearestResponse.ok) {
            console.warn(`OSRM /nearest fall√≥, se usar√°n coordenadas originales.`);
            return { lat: lat, lng: lon };
        }
        const nearestData = await nearestResponse.json();
        if (nearestData.code === "Ok" && nearestData.waypoints && nearestData.waypoints.length > 0) {
            const snappedCoords = nearestData.waypoints[0].location;
            return { lat: snappedCoords[1], lng: snappedCoords[0] };
        } else {
            console.warn("OSRM /nearest no encontr√≥ un punto v√°lido, se usar√°n coordenadas originales.");
            return { lat: lat, lng: lon };
        }
    } catch (error) {
        console.error("Error en snapCoordsToRoad:", error);
        return { lat: lat, lng: lon }; 
    }
}

// ===================================================================
// NOMBRE: searchAndAddWaypoint 
// RESUMEN: Busca una direcci√≥n. Si `searchAsPoi` es true, lanza una b√∫squeda de POIs.
async function searchAndAddWaypoint(addressQuery = null, searchAsPoi = false) {
    const searchInput = document.getElementById('map-location-search-input');
    const address = addressQuery || searchInput.value.trim();
    if (!address) {
        showToast("Por favor, introduce una direcci√≥n para buscar", "warning");
        return;
    }

    if (searchAsPoi) {
        searchPoisByCategory(address, null);
        return;
    }

    const searchButton = document.getElementById('map-location-search-button');
    if (searchButton) {
        searchButton.disabled = true;
        searchButton.innerHTML = `<img src="PNG/BUSCANDO.PNG" alt="Buscando...">`;
    }

    try {
        const searchUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address.replace(/,/g, ''))}&limit=1&accept-language=es&addressdetails=1`;
        
        const searchResponse = await fetch(searchUrl);
        if (!searchResponse.ok) throw new Error(`Error de red en Nominatim: ${searchResponse.status}`);
        
        const searchData = await searchResponse.json();
        if (!searchData || searchData.length === 0) throw new Error("Direcci√≥n no encontrada");
        
        const result = searchData[0];
        const initialLat = parseFloat(result.lat);
        const initialLon = parseFloat(result.lon);
        const displayName = result.display_name || `Ubicaci√≥n (${initialLat.toFixed(3)}, ${initialLon.toFixed(3)})`;

        showToast("Ajustando a la carretera m√°s cercana...", "info", 3000);
        const snappedLatLng = await snapCoordsToRoad(initialLat, initialLon);
        
        await addWaypoint(snappedLatLng, displayName);
        
        if (navigationMapInstance) navigationMapInstance.flyTo({ center: [initialLon, initialLat], zoom: 15 });
        if (searchInput) {
            searchInput.value = '';
            searchInput.dispatchEvent(new Event('input'));
        }
        showToast("Ubicaci√≥n a√±adida a la ruta", "success");

    } catch (error) {
        showToast(`Error al buscar direcci√≥n: ${error.message}`, "error", 4000, true);
    } finally {
        if (searchButton) {
            searchButton.disabled = false;
            searchButton.innerHTML = `<img src="PNG/ANADIRPUNTO.jpg" alt="A√±adir Punto Ruta">`;
        }
    }
}    
   
// ===================================================================
// NOMBRE: hideAddressSuggestionsModal
// RESUMEN: Oculta el modal de sugerencias de direcciones.
    function hideAddressSuggestionsModal() {
        const modal = document.getElementById('address-suggestions-modal');
        if (modal && !modal.classList.contains('hidden')) {
            clearModalAutoCloseTimer(modal, modal.querySelector('#close-address-suggestions-modal'), 'address-suggestions-modal');
            modal.classList.add('hidden');
        }
    } 

// ===================================================================
// NOMBRE: updateWaypointTypesAndLabels (VERSI√ìN CORREGIDA Y DEFINITIVA 2)
// RESUMEN: Actualiza los tipos y etiquetas, esperando a que todas las operaciones as√≠ncronas finalicen.
async function updateWaypointTypesAndLabels() {
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    if (actualWaypoints.length === 0) return;

    await Promise.all(actualWaypoints.map(async (wp, index) => {
        if (!wp) return;

        if (actualWaypoints.length === 1) {
            wp.type = 'S';
            wp.label = 'S';
        } else if (index === 0) {
            wp.type = 'S';
            wp.label = 'S';
        } else if (index === actualWaypoints.length - 1) {
            wp.type = 'F';
            wp.label = 'F';
        } else {
            wp.type = 'intermediate';
            wp.label = String(index);
        }

        if (!wp.address) {
            if (typeof wp.lat === 'number' && typeof wp.lng === 'number') {
                wp.address = await getAddressForWaypoint(wp.lat, wp.lng);
            } else {
                wp.address = "Coordenadas no disponibles para direcci√≥n";
            }
        }
    }));

    navigationWaypoints.forEach(wp => {
        if(wp && (wp.isInternal || wp.isRecalculatedStart)) {
            wp.label = '';
        }
    });
} 

// ===================================================================
// NOMBRE: getRouteForSingleLeg (MODIFICADA - SIN L.latLng)
// RESUMEN: Obtiene la distancia y duraci√≥n de un solo tramo de ruta.
async function getRouteForSingleLeg(lon1, lat1, lon2, lat2) {
    const url = `${OSRM_SERVICE_URL}/driving/${lon1},${lat1};${lon2},${lat2}?overview=false&alternatives=false&steps=false&annotations=false`;
    try {
        const response = await fetch(url);
        if (!response.ok) {
            return { distance: 0, duration: 0 };
        }
        const data = await response.json();
        if (data.routes && data.routes.length > 0 && data.routes[0]) {
            return {
                distance: data.routes[0].distance || 0,
                duration: data.routes[0].duration || 0
            };
        }
        return { distance: 0, duration: 0 };
    } catch (error) {
        return { distance: 0, duration: 0 };
    }
}    

// ===================================================================
// NOMBRE: clearAllWaypointMarkersFromMap (MODIFICADA - PARA MAPBOX)
// RESUMEN: Elimina todos los marcadores de puntos de ruta del mapa.
function clearAllWaypointMarkersFromMap() {
    navigationWaypoints.forEach(wp => {
        if (wp && wp.marker) {
            removeWaypointMarkerListeners(wp.marker); 
            wp.marker.remove();
            wp.marker = null;
        }
    });
}

// ===================================================================
// NOMBRE: handleSendToTeslaClick
// RESUMEN: Abre el di√°logo nativo para compartir un destino a la app de Tesla.
async function handleSendToTeslaClick(lat, lng, name) {
    if (!navigator.share) {
        showToast("Tu navegador no soporta la funci√≥n de compartir.", "warning");
        return;
    }

    try {
        const shareData = {
            title: `Destino: ${name}`,
            text: `Enviar "${name}" a la app de Tesla para iniciar la navegaci√≥n.`,
            url: `https://maps.google.com/?q=${lat},${lng}`
        };

        await navigator.share(shareData);
        showToast("Selecciona la app de Tesla para enviar el destino.", "info");

    } catch (err) {
        if (err.name !== 'AbortError') {
            showToast(`Error al compartir: ${err.message}`, "error");
        }
    }
}
// ===================================================================
// NOMBRE: clearAllRouteVisualsFromMap 
// RESUMEN: Realiza una limpieza completa y garantizada de TODOS los
function clearAllRouteVisualsFromMap() {
    if (!navigationMapInstance) return;

    document.querySelectorAll('.navigation-waypoint-marker').forEach(el => el.remove());
    document.querySelectorAll('.route-label-marker').forEach(el => el.remove());

    if (navigationMapInstance.isStyleLoaded()) {
        const style = navigationMapInstance.getStyle();

        if (style && style.layers) {
            style.layers.forEach(layer => {
                if (layer.id === 'route' || layer.id.startsWith('alt-layer-')) {
                    try {
                        if (navigationMapInstance.getLayer(layer.id)) {
                            navigationMapInstance.removeLayer(layer.id);
                        }
                    } catch (e) {
                        console.warn(`Error al eliminar capa ${layer.id}: ${e.message}`);
                    }
                }
            });
        }

        if (style && style.sources) {
            Object.keys(style.sources).forEach(sourceId => {
                if (sourceId === 'route' || sourceId.startsWith('alt-route-')) {
                    try {
                        if (navigationMapInstance.getSource(sourceId)) {
                            navigationMapInstance.removeSource(sourceId);
                        }
                    } catch (e) {
                        console.warn(`Error al eliminar fuente ${sourceId}: ${e.message}`);
                    }
                }
            });
        }
    }
    
    navigationRouteLayer = null;
    alternativeRouteLayers = [];
}

// ===================================================================
// NOMBRE: handleDeleteWaypointClick 
// RESUMEN: Elimina una etapa Y SUS PUNTOS INTERNOS ASOCIADOS.
async function handleDeleteWaypointClick(waypointId) {
    clearAlternativeRoutesDisplay();
    alternativeRoutesCache.clear();

    const waypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    if (waypointIndex === -1) return;
    
    navigationWaypoints = navigationWaypoints.filter(wp => !(wp.isInternal && wp.parentWaypointId === waypointId));
    
    const finalWaypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    if (finalWaypointIndex !== -1) {
        const waypointToDelete = navigationWaypoints[finalWaypointIndex];
        if (waypointToDelete.marker && navigationMapInstance) {
            removeWaypointMarkerListeners(waypointToDelete.marker); 
            waypointToDelete.marker.remove();
            waypointToDelete.marker = null;
        }
        navigationWaypoints.splice(finalWaypointIndex, 1);
    }
 
    if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) { 
        const autoStartModal = document.getElementById('auto-start-nav-modal');
        if (autoStartModal) {
            hideAutoStartNavigationModal();
            showToast("Inicio autom√°tico cancelado: La ruta ya no es v√°lida.", "info");
        }
        
        clearAllWaypointMarkersFromMap(); 
        navigationWaypoints = [];
        if (navigationMapInstance && navigationMapInstance.getLayer('route')) {
            navigationMapInstance.removeLayer('route');
            navigationMapInstance.removeSource('route');
            navigationRouteLayer = null;
        }

        navigationCurrentRouteData = null;
        hideNavigationUI();
        hideMapInfoOverlay();
        eliminarRadaresDeRuta();
        actualizarContadorRadares(0);
        eliminarTareasDeBarraProgreso();
        actualizarContadorTareas(0);
        const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresCheckbox) {
             localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckbox.checked)); 
        }
        const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasCheckbox) {
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckbox.checked));
        }
    } else {
        await updateWaypointTypesAndLabels();
        renderWaypointMarkers();
        if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
            if (navigationMapInstance && navigationMapInstance.getLayer('route')) { navigationMapInstance.removeLayer('route'); navigationMapInstance.removeSource('route'); }
            navigationRouteLayer = null;
           
            navigationCurrentRouteData = null;
            hideMapInfoOverlay();
            eliminarRadaresDeRuta();
            actualizarContadorRadares(0);
            eliminarTareasDeBarraProgreso();
            actualizarContadorTareas(0);
            const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
            if (radaresCheckbox) {
                localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckbox.checked));
            }
            const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
            if (tareasCheckbox) {
                localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckbox.checked));
            }
        } else {
            recalculateAndDrawRoute(true).then(() => {
                const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
                if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                    toggleRadaresRuta(true);
                }
                const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
                if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                    toggleTareasRuta(true);
                }
            });
        }
        showToast("Etapa eliminada.", "info");
    }
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}
    
// =============================
// NOMBRE: translateOcmTerm
function translateOcmTerm(term) {
    if (!term) return 'No especificado';
     const translations = {
        'Parking': 'Parking de pago',
        'Operational': 'Operativo',
        'Non-Operational': 'No operativo',
        'Not Operational': 'No operativo',   
        'Partly-Operational': 'Parcialmente operativo',
        'Planned For Future Date': 'Planificado',
        'Decommissioned': 'Fuera de servicio',
        'Public - Membership Required': 'P√∫blico - Requiere Membres√≠a',
        'Public - Pay At Location': 'P√∫blico - Pago en el sitio',
        'Public': 'P√∫blico',
        'Privately Owned - For Staff, Visitors or Customers': 'Privado - Para personal o clientes',
        'Private - For Staff, Visitors or Customers': 'Privado - Para personal o clientes',
        'Private - Restricted Access': 'Privado - Acceso restringido'
    };
    return translations[term] || term;
}   

// ===================================================================
// NOMBRE: clearChargingPoints 
// RESUMEN: Elimina del mapa los puntos de recarga vaciando la fuente de datos.
function clearChargingPoints() {
    currentChargingPointsOnRoute = [];
    lastPdrSearchResults = [];
    
    const existingModal = document.querySelector('.ocm-modal-overlay');
    if (existingModal) {
        existingModal.remove();
    }
    
    if (window.lastOcmApiResponse) {
        window.lastOcmApiResponse = null;
    }
 
    if (navigationMapInstance && navigationMapInstance.getSource('pdrs-geojson-source')) {
        navigationMapInstance.getSource('pdrs-geojson-source').setData({
            type: 'FeatureCollection',
            features: []
        });
    }

    const pdrButton = document.getElementById('pdrs-ruta-button');
    if (pdrButton) pdrButton.classList.remove('pdr-search-highlight');
    pdrSearchState = 'initial'; 
}
    
// ===================================================================
// NOMBRE: handleFreeDriveCancellation
// RESUMEN: Gestiona la reanudaci√≥n del modo libre cuando se cancela una planificaci√≥n de ruta.
function handleFreeDriveCancellation() {
    if (isFreeDrivePaused) {
        isFreeDriveActive = true;
        isFreeDrivePaused = false;
        
        if (freeDriveStats && !freeDriveStats.startTime) {
            freeDriveStats.startTime = new Date();
        }

        showToast("Planificaci√≥n de ruta cancelada. Reanudando registro de Conducci√≥n Libre.", "info");
        
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        initializeNavigationGraph();
    }
}    

// ===================================================================
// NOMBRE: restoreOriginalGrid
// RESUMEN: Restaura el grid de marcadores a su estado original de f√°brica.
function restoreOriginalGrid() {
    if (confirm('¬øRestaurar el grid de botones a su estado original? Perder√°s tu personalizaci√≥n del grid (URLs, nombres, orden).')) {
        localStorage.removeItem('customGridData');
        localStorage.removeItem('gridFilterValue');
        loadCustomData();
        renderGrid();
        renderToggleButtons();
        loadSavedSettings();
        updateButtonStyles();
        filterGridItems();
        document.getElementById('config-restore-grid-status').textContent = 'Grid restaurado al original. Recargando...';
        document.getElementById('config-restore-grid-status').style.color = '#28a745';
        showToast('Grid restaurado. Recargando...', 'success');
        setTimeout(() => location.reload(), 1500);
    }
}

// ===================================================================
// NOMBRE: clearAllLocalData
// RESUMEN: Borra todos los datos guardados en el almacenamiento local del navegador.
function clearAllLocalData() {
    if (confirm('¬°ATENCI√ìN! Esto borrar√° TODOS los datos locales (marcadores personalizados, recordatorios, configuraci√≥n de usuario, PIN, etc.). Esta acci√≥n NO SE PUEDE DESHACER. ¬øEst√°s seguro?')) {
        if (confirm('DE VERDAD, ¬øEST√ÅS COMPLETAMENTE SEGURO? SE BORRAR√Å TODO.')) {
            managedKeys.forEach(key => localStorage.removeItem(key));
            localStorage.removeItem('personalizationHelpShown');
            localStorage.removeItem('gridFilterValue');
            showToast('Todos los datos locales borrados. Recargando...', 'success');
            setTimeout(() => location.reload(), 1500);
        } else {
            showToast('Borrado cancelado', 'info');
        }
    } else {
        showToast('Borrado cancelado', 'info');
    }
}

// ===================================================================
// NOMBRE: fetchKMLFilesList
// RESUMEN: Obtiene la lista de archivos KML a procesar desde una URL.
async function fetchKMLFilesList(listUrl) {
    try {
        const response = await fetch(listUrl, { cache: 'no-cache' });
        if (!response.ok) throw new Error(`Error HTTP ${response.status} obteniendo lista KML: ${listUrl}`);
        const text = await response.text();
        return text.split('\n').map(f => f.trim()).filter(f => f.length > 0 && f.toLowerCase().endsWith('.kml'));
    } catch (error) {
        showToast(`Error cargando lista ${listUrl.split('/').pop()}`, 'error');
        return [];
    }
}

// ===================================================================
// NOMBRE: fetchAndParseKML
// RESUMEN: Descarga y decodifica un archivo KML.
async function fetchAndParseKML(kmlFileUrl) {
    try {
        const response = await fetch(kmlFileUrl, { cache: 'no-cache' });
        if (!response.ok) throw new Error(`Error HTTP ${response.status} obteniendo KML: ${kmlFileUrl}`);
        const buffer = await response.arrayBuffer();
        const decoder = new TextDecoder('iso-8859-1');
        const kmlText = decoder.decode(buffer);
        return parseKML(kmlText);
    } catch (error) {
        throw error;
    }
}

// ===================================================================
// NOMBRE: parseKML
// RESUMEN: Parsea el texto de un archivo KML para extraer los Placemarks.
function parseKML(kmlText) {
    const placemarks = [];
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(kmlText, "application/xml");
    const parserErrorNode = xmlDoc.querySelector("parsererror");
    if (parserErrorNode) {
        let errorMessage = "Error de parseo XML desconocido.";
        if (parserErrorNode.textContent) {
            const match = parserErrorNode.textContent.match(/error on line \d+ at column \d+: ([^\n]+)/);
            if (match && match[1]) {
                errorMessage = match[1];
            } else {
                errorMessage = parserErrorNode.textContent.split('\n')[0] || parserErrorNode.textContent;
            }
        } else if (parserErrorNode.innerText) {
             errorMessage = parserErrorNode.innerText.split('\n')[0] || parserErrorNode.innerText;
        }
        throw new Error("KML parsing error: " + errorMessage);
    }
    const KML_NS_GOOGLE = "http://earth.google.com/kml/2.0";
    const KML_NS_OGC = "http://www.opengis.net/kml/2.2";
    let placemarkNodes = xmlDoc.getElementsByTagNameNS(KML_NS_GOOGLE, 'Placemark');
    if (placemarkNodes.length === 0) {
        placemarkNodes = xmlDoc.getElementsByTagNameNS(KML_NS_OGC, 'Placemark');
    }
     if (placemarkNodes.length === 0) {
        placemarkNodes = xmlDoc.getElementsByTagName('Placemark');
    }
    for (let i = 0; i < placemarkNodes.length; i++) {
        const node = placemarkNodes[i];
        let nameNode, coordinatesNode;
        nameNode = node.getElementsByTagNameNS(KML_NS_GOOGLE, 'name')[0] || node.getElementsByTagNameNS(KML_NS_OGC, 'name')[0] || node.getElementsByTagName('name')[0];
        coordinatesNode = node.getElementsByTagNameNS(KML_NS_GOOGLE, 'coordinates')[0] || node.getElementsByTagNameNS(KML_NS_OGC, 'coordinates')[0] || node.getElementsByTagName('coordinates')[0];
        if (nameNode && coordinatesNode) {
            const name = nameNode.textContent.trim();
            const coordinatesRaw = coordinatesNode.textContent.trim();
            const coordPartsMatch = coordinatesRaw.match(/^(-?\d+\.?\d*)[,\s]+(-?\d+\.?\d*)/);
            if (name && coordPartsMatch && coordPartsMatch.length >= 3) {
                const lonStr = coordPartsMatch[1];
                const latStr = coordPartsMatch[2];
                const coordinates = `${lonStr},${latStr}`;
                const lon = parseFloat(lonStr);
                const lat = parseFloat(latStr);
                if (!isNaN(lon) && !isNaN(lat)) {
                    if (name.startsWith("Radares BBS www.laradiobbs.net") && lon === 0 && lat === 0) {
                        continue;
                    }
                    placemarks.push({ name, coordinates });
                }
            }
        }
    }
    return placemarks;
}

// ===================================================================
// NOMBRE: importRadars 
// RESUMEN: Importa radares y limpia la cach√© para forzar su reconstrucci√≥n.
async function importRadars() {
    window.radarsCache = null;
    window.radarsSpatialIndex = null;
    localStorage.removeItem('radarsCacheData');
    localStorage.removeItem('radarsCacheIndex');
    localStorage.removeItem('radarsCacheVersion');

    const latFilterValue = document.getElementById('radar-filter-lat').value.trim();
    const lonFilterValue = document.getElementById('radar-filter-lon').value.trim();
    const keywordsFilterRaw = document.getElementById('radar-filter-keywords').value.trim().toUpperCase();
    const keywordsFilter = keywordsFilterRaw ? keywordsFilterRaw.split(/\s+/).filter(k => k) : [];
    const importExtra = document.getElementById('import-extra-radars-checkbox').checked;
    const statusMessage = document.getElementById('radar-import-status');
    const progressContainer = document.getElementById('radar-import-progress-container');
    
    progressContainer.style.display = 'block';
    const progressBar = document.getElementById('radar-import-progress-bar');
    if(progressBar) progressBar.style.display = 'none';

    statusMessage.textContent = 'Iniciando importaci√≥n...';
    statusMessage.style.color = '';
    try {
        let filesToProcess = await fetchKMLFilesList(KML_FILES_LIST_STANDARD);
        if (importExtra) {
            const extraFiles = await fetchKMLFilesList(KML_FILES_LIST_EXTRA);
            filesToProcess = filesToProcess.concat(extraFiles.filter(f => !filesToProcess.includes(f)));
        }
        if (filesToProcess.length === 0) {
            statusMessage.textContent = 'No se encontraron listas de archivos KML para procesar.';
            showToast('No hay archivos KML en las listas.', 'warning');
            setTimeout(() => { progressContainer.style.display = 'none'; }, 3000);
            return;
        }
        
        statusMessage.textContent = `Procesando ${filesToProcess.length} archivos KML...`;
        
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        let newRadarsCount = 0;

        const processingPromises = filesToProcess.map(kmlFileName =>
            fetchAndParseKML(KML_BASE_PATH + kmlFileName).catch(e => {
                console.warn(`Error procesando ${kmlFileName}, se omitir√°.`, e);
                return [];
            })
        );
        
        const results = await Promise.all(processingPromises);
        
        results.flat().forEach(placemark => {
            const name = placemark.name.toUpperCase();
            const coords = placemark.coordinates;
            const matchesKeywords = keywordsFilter.length === 0 || keywordsFilter.some(kw => name.includes(kw));
            if (coords && matchesKeywords) {
                const [lonStr, latStr] = coords.split(',');
                const lon = parseFloat(lonStr);
                const lat = parseFloat(latStr);
                if (isNaN(lat) || isNaN(lon)) return;
                
                const matchesLat = parseCoordinateFilter(latFilterValue, lat);
                const matchesLon = parseCoordinateFilter(lonFilterValue, lon);

                if (matchesLat && matchesLon) {
                    const existingRadar = reminders.find(r =>
                        r.isLocationEnabled && r.locationCoordinates &&
                        Math.abs(r.locationCoordinates.latitude - lat) < COORD_EPSILON &&
                        Math.abs(r.locationCoordinates.longitude - lon) < COORD_EPSILON &&
                        (r.text.toUpperCase().includes("RADAR") || r.excludeFromList)
                    );
                    if (!existingRadar) {
                        const now = new Date();
                        const newRadar = {
                            id: Date.now() + Math.random() + newRadarsCount,
                            text: `<b>RADAR: ${placemark.name}</b>`,
                            type: 'simple', time: '00:01',
                            date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                            createdAt: now.toISOString(), managedByUser: false,
                            isLocationEnabled: true, locationCoordinates: { latitude: lat, longitude: lon },
                            radiusMeters: 400, excludeFromList: true
                        };
                        reminders.push(newRadar);
                        newRadarsCount++;
                    }
                }
            }
        });
        
        localStorage.setItem('reminders', JSON.stringify(reminders));
        statusMessage.textContent = `Importaci√≥n completa. ${newRadarsCount} nuevos radares/POIs a√±adidos.`;
        statusMessage.style.color = '#28a745';
        showToast(`${newRadarsCount} nuevos radares/POIs a√±adidos.`, 'success');
        updateReminderCount();
        updateButtonStyles();
        markCacheAsDirty();
    } catch (error) {
        statusMessage.textContent = `Error general: ${error.message}`;
        statusMessage.style.color = 'red';
        showToast('Error durante la importaci√≥n.', 'error');
    } finally {
         setTimeout(() => {
            progressContainer.style.display = 'none';
            if(progressBar) progressBar.style.display = 'block';
            statusMessage.style.color = '';
        }, 5000);
    }
}

// ===================================================================
// NOMBRE: handleSimulationItemClick 
// RESUMEN: Maneja el clic en un elemento de la lista de maniobras para mostrar el detalle del mapa.
function handleSimulationItemClick(event) {
    const listItem = event.target.closest('li[data-leg-index][data-step-index]');
    if (!listItem) {
        return;
    }
    if (!navigationCurrentRouteData || !navigationCurrentRouteData.routes || navigationCurrentRouteData.routes.length === 0) {
        return;
    }
    const legIndex = parseInt(listItem.dataset.legIndex);
    const stepIndex = parseInt(listItem.dataset.stepIndex);
    const route = navigationCurrentRouteData.routes[0];
    if (route.legs && legIndex < route.legs.length && route.legs[legIndex].steps && stepIndex < route.legs[legIndex].steps.length) {
        const step = route.legs[legIndex].steps[stepIndex];
        showIntersectionPreviewMap(step, route, true, 5000);
    } else {
        hideIntersectionPreviewMap();
    }
}

// ===================================================================
// NOMBRE: hideMapInfoOverlay
// RESUMEN: Oculta el mensaje de informaci√≥n del mapa.
function hideMapInfoOverlay() {
    const overlay = document.getElementById('map-info-overlay');
    if (overlay) {
        overlay.textContent = '';
        overlay.style.display = 'none';
    }
}
  
// ===================================================================
// NOMBRE: showMapInfoOverlay 
// RESUMEN: Muestra un mensaje en el overlay, pero solo actualiza el DOM
function showMapInfoOverlay(message, isError = false) {
    const overlay = document.getElementById('map-info-overlay');
    if (overlay) {
        let finalMessage = message;
        if (message.startsWith(" ")) {
            const destName = message.substring(" ".length).trim().replace(/<br>/gi, ' ');
            finalMessage = " " + (destName.length > 55 ? destName.substring(0, 52) + "..." : destName);
        } else if (message.startsWith("ETAPA ")) {
            const stageInfo = message.substring("ETAPA ".length).trim().replace(/<br>/gi, ' ');
            finalMessage = "ETAPA " + (stageInfo.length > 55 ? stageInfo.substring(0, 52) + "..." : stageInfo);
        } else if (message.startsWith("HA LLEGADO AL ")) {
            const destinationName = message.substring("HA LLEGADO AL : ".length).trim().replace(/<br>/gi, ' ');
            finalMessage = "HA LLEGADO A: " + (destinationName.length > 55 ? destinationName.substring(0, 52) + "..." : destinationName);
        }
        
        const currentText = overlay.querySelector('span')?.textContent || '';
        
        if (currentText !== finalMessage) {
            overlay.innerHTML = `<span>${finalMessage}</span>`;
        }

        if (!isNavigating) {
            overlay.style.display = 'block';
        }
        
        overlay.classList.toggle('error-overlay', isError);
    }
}
    
// ===================================================================
// NOMBRE: showDestinationName
// RESUMEN: Muestra el nombre del destino o de la siguiente etapa en el overlay del mapa.
function showDestinationName() {
    if (!navigationWaypoints || navigationWaypoints.length === 0) {
        hideMapInfoOverlay();
        return;
    }
    let message = "";
    let nextUnvisitedStageWp = null;
    if (isNavigating) {
        const totalEtapas = navigationCurrentRouteData?.routes?.[0]?.legs?.length || 0;
        const etapaActualUsuario = currentLegIndexNav + 1;
        for(let i = currentLegIndexNav; i < navigationWaypoints.length; i++) {
            const waypointToCheck = navigationWaypoints[i];
            if (waypointToCheck && !waypointToCheck.isInternal && !waypointToCheck.visited && waypointToCheck.type !== 'S' && waypointToCheck.type !== 'S_Recalc') {
                nextUnvisitedStageWp = waypointToCheck;
                break;
            }
        }
         if (!nextUnvisitedStageWp && navigationWaypoints.length > 0) {
            const lastWaypoint = navigationWaypoints[navigationWaypoints.length -1];
            if (lastWaypoint.type === 'F' && !lastWaypoint.visited) {
                 nextUnvisitedStageWp = lastWaypoint;
            }
        }
        if (nextUnvisitedStageWp) {
            if (nextUnvisitedStageWp.type === 'F') {
                message = ` ${nextUnvisitedStageWp.address || ' Final'}`;
            } else if (nextUnvisitedStageWp.type === 'intermediate' && totalEtapas > 1) {
                message = `ETAPA ${etapaActualUsuario} de ${totalEtapas}: ${nextUnvisitedStageWp.address || `Etapa ${nextUnvisitedStageWp.label}`}`;
            } else {
                 message = ` ${nextUnvisitedStageWp.address || 'Siguiente Punto'}`;
            }
        } else {
            const finalDestination = navigationWaypoints[navigationWaypoints.length - 1];
            if (finalDestination && !finalDestination.isInternal) {
                 message = ` ${finalDestination.address || ' Final'}`;
            } else {
                 message = "RUTA NO DEFINIDA";
            }
        }
    } else {
        const finalDestination = navigationWaypoints[navigationWaypoints.length - 1];
        if (finalDestination && !finalDestination.isInternal) {
             message = ` ${finalDestination.address || ' Final'}`;
        } else {
             message = "RUTA NO DEFINIDA";
        }
    }
    showMapInfoOverlay(message);
}

// ===================================================================
// NOMBRE: clearModalAutoCloseTimer
// RESUMEN: Limpia un temporizador de autocierre de un modal.
function clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId) {
    const timerIdToClear = modalId || (modalElement ? modalElement.dataset.modalTimerId : null);
    if (timerIdToClear && globalModalTimers[timerIdToClear]) {
        clearInterval(globalModalTimers[timerIdToClear].intervalId);
        const timerData = globalModalTimers[timerIdToClear];
        if (timerData.modalElement && timerData.resetHandler) {
            timerData.modalElement.removeEventListener('click', timerData.resetHandler);
            timerData.modalElement.removeEventListener('touchstart', timerData.resetHandler);
            timerData.modalElement.removeEventListener('input', timerData.resetHandler);
            timerData.modalElement.removeEventListener('scroll', timerData.resetHandler);
        }
        if (timerData.countdownSpan && timerData.countdownSpan.parentNode) {
            timerData.countdownSpan.remove();
        }
        delete globalModalTimers[timerIdToClear];
    }
    if(closeButtonElement){
        const orphanSpans = closeButtonElement.querySelectorAll('.button-countdown-timer');
        orphanSpans.forEach(s => s.remove());
    }
     if(modalElement && modalElement.dataset.modalTimerId) {
        delete modalElement.dataset.modalTimerId;
    }
}

// ===================================================================
// NOMBRE: formatDateToDDMMMYY
// RESUMEN: Formatea una fecha (YYYY-MM-DD) a un formato legible (DD Mes Abreviado YY).
function formatDateToDDMMMYY(dateString) {
     if (!dateString) return '-';
     try {
         const [year, month, day] = dateString.split('-').map(Number);
         const date = new Date(Date.UTC(year, month - 1, day));
         if (isNaN(date.getTime())) return '-';
         const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
         const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
         const monthName = monthNames[date.getUTCMonth()];
         const yearShort = String(date.getUTCFullYear()).slice(-2);
         return `${dayOfMonth} ${monthName} ${yearShort}`;
     } catch (e) {
         return '-';
     }
}

// ===================================================================
// NOMBRE: calculateNextOccurrence
// RESUMEN: Calcula la pr√≥xima fecha de vencimiento de un recordatorio c√≠clico.
function calculateNextOccurrence(reminder, referenceDate) {
      if (!reminder || !reminder.type || !reminder.time || !reminder.date) { return null; } try {
          let [year, month, day] = reminder.date.split('-').map(Number); let [hour, minute] = reminder.time.split(':').map(Number);
          let baseDate = new Date(Date.UTC(year, month - 1, day, hour, minute)); if (isNaN(baseDate.getTime())) { return null; }
          const refDateUTC = new Date(referenceDate.getTime()); if (baseDate > refDateUTC) return baseDate;
          if (reminder.type === 'simple') { return null; }
          if (reminder.type === 'daily' || reminder.type === 'hourly') { let next = new Date(baseDate); while (next <= refDateUTC) { next.setUTCDate(next.getUTCDate() + 1); } return next; }
          if (reminder.type === 'weekly' && reminder.repeatDays && reminder.repeatDays.length > 0) {
              let next = new Date(refDateUTC); next.setUTCHours(hour, minute, 0, 0);
              if (next <= refDateUTC || !reminder.repeatDays.includes(next.getUTCDay())) { next.setUTCDate(next.getUTCDate() + 1); }
              for (let i = 0; i < 7; i++) { if (reminder.repeatDays.includes(next.getUTCDay())) { return next; } next.setUTCDate(next.getUTCDate() + 1); } return null;
          }
          if (reminder.type === 'interval' && reminder.intervalDays && reminder.intervalDays > 0) { let next = new Date(baseDate); while (next <= refDateUTC) { next.setUTCDate(next.getUTCDate() + reminder.intervalDays); } return next; }
          return null; } catch (e) { return null; }
 }

// ===================================================================
// NOMBRE: calculatePostponedDateTime
// RESUMEN: Calcula la fecha y hora para posponer un recordatorio.
function calculatePostponedDateTime(mins) {
      const now = new Date(); const postponedDate = new Date(now.getTime() + mins * 60000);
      const newDateISO = `${postponedDate.getFullYear()}-${(postponedDate.getMonth() + 1).toString().padStart(2, '0')}-${postponedDate.getDate().toString().padStart(2, '0')}`;
      const newTime = `${postponedDate.getHours().toString().padStart(2, '0')}:${postponedDate.getMinutes().toString().padStart(2, '0')}`; return { newDateISO, newTime };
     }
       
// ===================================================================
// NOMBRE: showPostponeOptionsModal
// RESUMEN: Muestra un modal con opciones para posponer un recordatorio.
function showPostponeOptionsModal(reminder, source = 'unified') {
         const existingModal = document.getElementById('postpone-options-modal'); if (existingModal) { if (existingModal.autoPostponeInterval) clearInterval(existingModal.autoPostponeInterval); if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal); }
         const modal = document.createElement('div'); modal.id = 'postpone-options-modal'; modal.className = 'postpone-options';
         modal.style.cssText = `position:fixed; top:10px; left:50%; transform:translateX(-50%); width:90%; max-width:480px; max-height:calc(100vh - 20px); overflow-y:auto; background-color:#F5E1A9; padding:1.5rem; border-radius:1rem; box-shadow:0 10px 25px rgba(0,0,0,0.2); z-index:7500; `;
         modal.setAttribute('aria-label', 'Posponer recordatorio');
         let countdown = 10; const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval'; const defaultMinutes = 15;
         let buttonHtml = ` <button data-minutes="15" class="postpone-option">15 Minutos</button> <button data-minutes="60" class="postpone-option">1 Hora</button> <button data-minutes="180" class="postpone-option">3 Horas</button> `;
         if (!isCyclic) { buttonHtml += ` <button data-minutes="1440" class="postpone-option">1 D√≠a</button> <button data-minutes="4320" class="postpone-option">3 D√≠as</button> `; }
         modal.innerHTML = `
            <style>
                .postpone-options .reminder-text { color:#333; font-size:1.2rem; margin-bottom:.5rem; word-wrap:break-word; }
                .postpone-options .reminder-details { color:#555; font-size:1rem; margin-bottom:1.5rem; }
                .postpone-options .button-group { display:flex; flex-direction:column; gap:1rem; align-items:stretch; }
                .postpone-options button.postpone-option { font-size:1.3rem; font-weight:bold; padding:.8rem 1rem; background-color:#F59E0B; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                .postpone-options button.postpone-option:hover { background-color:#D97706; }
                #postpone-countdown { text-align:center; margin-top:1.8rem; font-size:1.1rem; font-weight:500; color:#444; }
                #postpone-timer-value { font-weight:bold; font-size:1.2rem; }
                #cancel-postpone { margin-top:1.2rem; width:100%; padding:.7rem 1rem; font-size:1.1rem; background-color:#EF4444; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                #cancel-postpone:hover { background-color:#DC2626; }
            </style>
            <div class="modal-top-buttons" style="justify-content: flex-end; margin-bottom: 1rem;">
                 <button id="cancel-postpone" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
            </div>
            <p class="reminder-text">Posponer: ${reminder.text.replace(/<[^>]*>/g, '')}</p>
            <p class="reminder-details">Selecciona tiempo:</p>
            <div class="button-group">
                ${buttonHtml}
            </div>
            <p id="postpone-countdown">Autom√°tico en <span id="postpone-timer-value">${countdown}</span>s (${defaultMinutes} min)</p>
         `;
         document.body.appendChild(modal);
         const countdownDisplay = modal.querySelector('#postpone-timer-value');
         const handlePostpone = (minutes) => {
             if (modal.autoPostponeInterval) clearInterval(modal.autoPostponeInterval); modal.autoPostponeInterval = null;
             updateUnifiedWindowUI(reminder.id);
             let reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); const index = reminders.findIndex(r => r.id === reminder.id);
             if (index === -1) { showToast("Error: Recordatorio no encontrado", "error"); markCacheAsDirty(); if (modal.parentNode) document.body.removeChild(modal); return; }
             const { newDateISO, newTime } = calculatePostponedDateTime(minutes); reminders[index].date = newDateISO; reminders[index].time = newTime; reminders[index].managedByUser = false;
             if (!isCyclic) { reminders[index].type = 'daily'; reminders[index].repeatDays = []; reminders[index].intervalDays = null; }
             localStorage.setItem('reminders', JSON.stringify(reminders)); updateReminderCount(); updateButtonStyles(); 
             const durationText = minutes >= 1440 ? `${minutes / 1440} d√≠a(s)` : (minutes >= 60 ? `${minutes / 60} hora(s)` : `${minutes} minutos`);
             showToast(`Pospuesto ${durationText}`, 'info');
             if (modal.parentNode) document.body.removeChild(modal);
             if (source === 'table') { setTimeout(showAllReminders, 100); }
             else { const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                 const mapContextToReopen = sessionStorage.getItem('mapContext');
                 if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) { sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); if (!document.getElementById('reminders-location-map-modal')) { if (mapContextToReopen === 'navigation') openNavigationMap(); sessionStorage.removeItem('mapContext');} } } };
         modal.autoPostponeInterval = setInterval(() => { countdown--; if (countdownDisplay) countdownDisplay.textContent = countdown; if (countdown <= 0) { handlePostpone(defaultMinutes); } }, 1000);
         modal.querySelectorAll('.postpone-option').forEach(button => { button.addEventListener('click', () => { const minutes = parseInt(button.dataset.minutes); if (!isNaN(minutes)) { handlePostpone(minutes); } }); });
         modal.querySelector('#cancel-postpone').addEventListener('click', () => {
             clearInterval(modal.autoPostponeInterval); modal.autoPostponeInterval = null; markReminderAsManaged(reminder.id, false); if (modal.parentNode) document.body.removeChild(modal);
             if (source === 'table') { setTimeout(showAllReminders, 100); }
             else { const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                  const mapContextToReopen = sessionStorage.getItem('mapContext');
                 if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) { sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); if (!document.getElementById('reminders-location-map-modal')) { if (mapContextToReopen === 'navigation') openNavigationMap(); sessionStorage.removeItem('mapContext');} } } showToast('Posposici√≥n cancelada', 'info'); });
}
    
// ===================================================================
// NOMBRE: handleDragEndReorder
// RESUMEN: Maneja la finalizaci√≥n de una operaci√≥n de arrastre en la lista de etapas.
function handleDragEndReorder(e) {
    if (draggedStageLi) {
        draggedStageLi.classList.remove('dragging');
    }
    draggedStageLi = null;
}

// ===================================================================
// NOMBRE: handleDragOverReorder
// RESUMEN: Maneja el evento de pasar por encima al arrastrar en la lista de etapas.
function handleDragOverReorder(e) {
    e.preventDefault();
    if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
    const listElement = document.getElementById('sortable-stages-list');
    if (!listElement || !draggedStageLi) return;
    const afterElement = getDragAfterElement(listElement, e.clientY);
    const currentLi = e.target.closest('li');
    if (draggedStageLi && currentLi && draggedStageLi !== currentLi) {
        if (afterElement == null) {
            listElement.appendChild(draggedStageLi);
        } else {
            listElement.insertBefore(draggedStageLi, afterElement);
        }
    } else if (draggedStageLi && !currentLi && afterElement == null) {
         listElement.appendChild(draggedStageLi);
    } else if (draggedStageLi && !currentLi && afterElement) {
         listElement.insertBefore(draggedStageLi, afterElement);
    }
}

// ===================================================================
// NOMBRE: handleStageTouchStart
// RESUMEN: Maneja el inicio de un toque en una etapa para reordenar.
function handleStageTouchStart(e) {
    if (e.touches.length === 1 && e.target.closest('.drag-handle')) {
        draggedStageLi = e.target.closest('li');
        if (!draggedStageLi) return;
        const touch = e.touches[0];
        stageTouchStartX = touch.clientX;
        stageTouchStartY = touch.clientY;
        clearTimeout(stageScrollTimeout);
        stageScrollTimeout = setTimeout(() => {
            if (draggedStageLi) {
                draggedStageLi.classList.add('dragging');
                document.body.style.overflow = 'hidden';
            }
        }, 150);
    }
}

// =================================================================
function createWaypointMarkerIcon(label, type, visited, id, currentZoomLevel = null) {
    const el = document.createElement('div');
    el.className = 'navigation-waypoint-marker';
    el.dataset.waypointId = id; 

    let color;
    if (visited) {
        color = 'rgba(85, 85, 85, 0.8)'; 
    } else if (type === 'S' || type === 'S_Recalc') {
        color = 'rgba(0, 128, 0, 0.80)'; 
    } else if (type === 'F') {
        color = 'rgba(0, 0, 255, 0.80)'; 
    } else {
        color = 'rgba(230, 140, 0, 0.80)'; 
    }
    const ZOOM_PEQUENO = 12;
    const ZOOM_GRANDE = 17;
    const FONT_MINIMO = 15; 
    const FONT_MAXIMO = 19; 
    
    let finalFontSize = FONT_MAXIMO;
    if (currentZoomLevel !== null) {
        if (currentZoomLevel <= ZOOM_PEQUENO) {
            finalFontSize = FONT_MINIMO;
        } else if (currentZoomLevel >= ZOOM_GRANDE) {
            finalFontSize = FONT_MAXIMO;
        } else {
            const progress = (currentZoomLevel - ZOOM_PEQUENO) / (ZOOM_GRANDE - ZOOM_PEQUENO);
            finalFontSize = FONT_MINIMO + (FONT_MAXIMO - FONT_MINIMO) * progress;
        }
    }
    
    el.style.backgroundColor = color;
    el.style.width = '45px';
    el.style.height = '45px';
    el.style.border = `2px solid ${visited ? '#555' : 'white'}`;
    el.style.opacity = visited ? '0.7' : '1';
    el.textContent = label;
    el.style.fontSize = `${Math.round(finalFontSize)}px`;
    el.style.cursor = 'pointer';

    let isDragging = false;
    let hasMovedEnough = false;
    let startPos = { x: 0, y: 0 };
    const waypointId = id; 

    const onPointerDown = (e) => {
        e.stopPropagation();
        isDragging = false;
        hasMovedEnough = false;
        const point = e.touches ? e.touches[0] : e;
        startPos = { x: point.clientX, y: point.clientY };
        document.addEventListener('mousemove', el._onPointerMove);
        document.addEventListener('mouseup', el._onPointerUp);
        document.addEventListener('touchmove', el._onPointerMove, { passive: false });
        document.addEventListener('touchend', el._onPointerUp);
    };

    const onPointerMove = (e) => {
        if (e.type === 'touchmove') e.preventDefault();
        const point = e.touches ? e.touches[0] : e;
        const deltaX = Math.abs(point.clientX - startPos.x);
        const deltaY = Math.abs(point.clientY - startPos.y);
        if (!hasMovedEnough && (deltaX > 5 || deltaY > 5)) {
            hasMovedEnough = true;
            navigationMapInstance.getCanvas().style.cursor = 'grabbing';
            el.style.cursor = 'grabbing';
        }
        if (hasMovedEnough) {
            isDragging = true;
            const waypoint = navigationWaypoints.find(w => w.id === waypointId);
            if(waypoint && waypoint.marker) {
                const mapContainer = document.getElementById('mapbox-map-actual-container');
                const mapRect = mapContainer.getBoundingClientRect();
                const relativeX = point.clientX - mapRect.left;
                const relativeY = point.clientY - mapRect.top;
                const coords = navigationMapInstance.unproject([relativeX, relativeY]);
                waypoint.marker.setLngLat(coords);
            }
        }
    };

    const onPointerUp = async (e) => {
        document.removeEventListener('mousemove', el._onPointerMove);
        document.removeEventListener('mouseup', el._onPointerUp);
        document.removeEventListener('touchmove', el._onPointerMove);
        document.removeEventListener('touchend', el._onPointerUp);
        navigationMapInstance.getCanvas().style.cursor = '';
        el.style.cursor = 'pointer';

        if (isDragging) {
            const waypoint = navigationWaypoints.find(w => w.id === waypointId);
            if (waypoint && waypoint.marker) {
                showToast("Etapa movida. Recalculando ruta...", "info");
                const finalCoords = waypoint.marker.getLngLat();
                waypoint.lat = finalCoords.lat;
                waypoint.lng = finalCoords.lng;
                waypoint.address = await getAddressForWaypoint(finalCoords.lat, finalCoords.lng);
                await recalculateAndDrawRoute(true); 
                renderWaypointMarkers();
            }
        } else {
            showWaypointActionModal(waypointId);
        }
        isDragging = false;
        hasMovedEnough = false;
    };

    el._onPointerDown = onPointerDown;
    el._onPointerMove = onPointerMove;
    el._onPointerUp = onPointerUp;
    
    el.addEventListener('mousedown', el._onPointerDown);
    el.addEventListener('touchstart', el._onPointerDown, { passive: false });
   
    return el;
}
    
// ===================================================================
// NOMBRE: handleStageTouchMove
// RESUMEN: Maneja el movimiento de un toque en una etapa para reordenar.
function handleStageTouchMove(e) {
    if (!draggedStageLi || e.touches.length !== 1) return;
    e.preventDefault();
    clearTimeout(stageScrollTimeout);
    if (!draggedStageLi.classList.contains('dragging')) {
        draggedStageLi.classList.add('dragging');
         document.body.style.overflow = 'hidden';
    }
    const touch = e.touches[0];
    const listElement = document.getElementById('sortable-stages-list');
    if (!listElement) return;
    const afterElement = getDragAfterElement(listElement, touch.clientY);
     if (afterElement == null) {
        listElement.appendChild(draggedStageLi);
    } else {
        listElement.insertBefore(draggedStageLi, afterElement);
    }
}
  
// ===================================================================
// NOMBRE: handleStageTouchEnd
// RESUMEN: Maneja el final de un toque en una etapa para reordenar.
function handleStageTouchEnd(e) {
    clearTimeout(stageScrollTimeout);
    if (draggedStageLi) {
        draggedStageLi.classList.remove('dragging');
        draggedStageLi = null;
    }
    document.body.style.overflow = '';
}
    
// ===================================================================
// NOMBRE: getDragAfterElement
// RESUMEN: Encuentra el elemento despu√©s del cual se debe soltar el elemento arrastrado.
function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('li:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

// ===================================================================
// NOMBRE: eliminarTareasDeBarraProgreso
// RESUMEN: Limpia tareas de la barra de progreso Y del mapa.
function eliminarTareasDeBarraProgreso() {
    eliminarTareasDeMapa(); 
    tareasEnRutaActual = [];
    actualizarContadorTareas(0);
    if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
      
        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
}
    
// ===================================================================
// NOMBRE: toggleMapHeaderRowsVisibility 
// RESUMEN: Muestra/oculta la cabecera, llama a map.resize() y AHORA tambi√©n ajusta la posici√≥n del widget del tiempo.
function toggleMapHeaderRowsVisibility(show) {
    const header = document.getElementById('reminders-location-map-header');
    if (!header) return;

    mapHeaderButtonsVisible = show;
    header.querySelectorAll('.button-row').forEach(row => {
        row.classList.toggle('hidden-map-header', !show);
    });

       
    const togglePanel = document.getElementById('toggle-map-header-buttons-panel');

    const removeCountdownOverlay = () => {
        if (togglePanel) {
            const existingOverlay = togglePanel.querySelector('#map-header-countdown-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
        }
    };

    if (mapHeaderAutohideTimer) {
        clearInterval(mapHeaderAutohideTimer);
        mapHeaderAutohideTimer = null;
    }
    removeCountdownOverlay();

    if (isNavigating && show) {
        mapHeaderButtonsVisible = true;
        header.querySelectorAll('.button-row').forEach(row => {
            row.classList.remove('hidden-map-header');
        });

        if (togglePanel) {
            const countdownOverlay = document.createElement('span');
            countdownOverlay.id = 'map-header-countdown-overlay';
            countdownOverlay.style.cssText = `
                position: absolute;
                top: 50%; left: 50%;
                transform: translate(-50%, -50%);
                font-size: 48px; font-weight: bold;
                color: rgba(189, 150, 24, 0.7);
                z-index: 10; pointer-events: none;
                text-shadow: 2px 2px 3px rgba(0,0,0,0.5);
            `;
            togglePanel.appendChild(countdownOverlay);

            let countdown = 20;
            countdownOverlay.textContent = countdown;

            mapHeaderAutohideTimer = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownOverlay.textContent = countdown;
                } else {
                    clearInterval(mapHeaderAutohideTimer);
                    mapHeaderAutohideTimer = null;
                    removeCountdownOverlay();
                    if (mapHeaderButtonsVisible) {
                       toggleMapHeaderRowsVisibility(false);
                    }
                }
            }, 1000);
        }
    } else {
        mapHeaderButtonsVisible = show;
        header.querySelectorAll('.button-row').forEach(row => {
            row.classList.toggle('hidden-map-header', !show);
        });
    }
    
    if (navigationMapInstance) {
        setTimeout(() => {
            const mapContainer = document.getElementById('mapbox-map-actual-container');
            if (navigationMapInstance && mapContainer && mapContainer.offsetHeight > 0) {
                try {
                    navigationMapInstance.resize();
                } catch(e) {
                    console.error("Error al redimensionar el mapa (dentro del timeout):", e);
                }
            }
        }, 350);
    }
}
    
// ===================================================================
// NOMBRE: eliminarRadaresDeRuta 
// RESUMEN: Elimina del mapa los radares que se hab√≠an a√±adido din√°micamente a la ruta.
function eliminarRadaresDeRuta() {
    reminderMapObjects = reminderMapObjects.filter(obj => {
        if (obj.isFromRuta) {
            if (obj.marker) obj.marker.remove();
            if (obj.circleId && navigationMapInstance.getLayer(obj.circleId)) {
                navigationMapInstance.removeLayer(obj.circleId);
            }
            if (obj.circleId && navigationMapInstance.getSource(obj.circleId)) {
                navigationMapInstance.removeSource(obj.circleId);
            }
            return false;
        }
        return true;
    });
    radaresEnRutaActual = [];
    actualizarContadorRadares(0);
    if (navigationCurrentRouteData?.routes?.[0]) { 
      
        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
}

// ===================================================================
// NOMBRE: updateAllZoomToggleButtonsVisuals 
function updateAllZoomToggleButtonsVisuals() {
    if (!navigationMapInstance) return;

    const ZOOM_THRESHOLD = 13.5;
    const currentZoom = navigationMapInstance.getZoom();
    
    const newState = currentZoom < ZOOM_THRESHOLD ? 'waypoints' : 'car';
    
    const buttonsToUpdate = [
        document.getElementById('zoom-toggle-button'),
        document.getElementById('nav-map-zoomtoggle-button')
    ].filter(Boolean);

    buttonsToUpdate.forEach(btn => {
        const img = btn.querySelector('img');
        if (!img) return;
        
        btn.dataset.zoomState = newState;

        if (newState === 'waypoints') {
            img.src = 'PNG/ZOOM+.PNG';
            btn.title = "Acercar a la ubicaci√≥n del coche";
        } else { 
            img.src = 'PNG/ZOOM-.PNG';
            btn.title = "Alejar para ver la ruta completa";
        }
    });

    const minimapContainer = document.getElementById('minimap-container');
    if (minimapContainer) {
        if (newState === 'waypoints') {
            minimapContainer.title = "Pulsar para acercar a la ubicaci√≥n del coche";
        } else {
            minimapContainer.title = "Pulsar para alejar y ver la ruta completa";
        }
    }
}
   
// ===================================================================
// NOMBRE: startGraphIntervalTimer (CORREGIDA)
function startGraphIntervalTimer() {
    if (graphIntervalTimer) clearInterval(graphIntervalTimer);
    if ((isNavigating || isFreeDriveActive) && currentGraphMode !== 'Gr√°fica off' && graphIntervalDuration > 0) { 
        graphIntervalTimer = setInterval(plotIntervalData, graphIntervalDuration);
    }
}
    
// ===================================================================
// NOMBRE: handleFinalDestinationSelection (NUEVA FUNCI√ìN)
// RESUMEN: Maneja la l√≥gica cuando el usuario elige ir al destino final.
async function handleFinalDestinationSelection() {
    const finalDestination = navigationWaypoints.find(wp => wp.type === 'F');
    const startPoint = navigationWaypoints.find(wp => wp.isRecalculatedStart || wp.type === 'S');

    if (!finalDestination || !startPoint) {
        showToast("Error: No se pudo determinar el inicio o el fin de la ruta.", "error");
        closeModalAndProceed();
        return;
    }

    navigationWaypoints = [startPoint, finalDestination];
    closeModalAndProceed();
    
    try {
        await recalculateAndDrawRoute(true, true);
        renderWaypointMarkers();
        deviationCheckGracePeriodUntil = Date.now() + 5000;
    } catch (error) {
        showToast("Error al recalcular la ruta hacia el destino final.", "error");
    }
}

// ===================================================================
// NOMBRE: handleStageSelectionFromDeviationModal 
// RESUMEN: Maneja la l√≥gica cuando el usuario elige una etapa intermedia.
async function handleStageSelectionFromDeviationModal(selectedWaypointId) {
    const selectedIndex = navigationWaypoints.findIndex(wp => wp.id === selectedWaypointId);
    const startPoint = navigationWaypoints.find(wp => wp.isRecalculatedStart || wp.type === 'S');

    if (selectedIndex === -1 || !startPoint) {
        showToast("Error: No se encontr√≥ la etapa o el punto de inicio.", "error");
        closeModalAndProceed();
        return;
    }

    const newWaypoints = [startPoint];
    for (let i = selectedIndex; i < navigationWaypoints.length; i++) {
        const wp = navigationWaypoints[i];
        if (wp && !wp.isInternal && !wp.isRecalculatedStart) {
            newWaypoints.push(wp);
        }
    }
    
    navigationWaypoints = newWaypoints;
    closeModalAndProceed();
    
    try {
        await recalculateAndDrawRoute(true, true);
        renderWaypointMarkers();
        deviationCheckGracePeriodUntil = Date.now() + 5000;
    } catch (error) {
        showToast("Error al recalcular la ruta hacia la etapa seleccionada.", "error");
    }
}
   
// ===================================================================
// NOMBRE: closeModalAndProceed (MODIFICADA)
// RESUMEN: Cierra el modal de desv√≠o y llama a la reanudaci√≥n de simulaci√≥n.
function closeModalAndProceed() {
    isDeviationModalActive = false;
    deviationStartTime = 0;
    const modal = document.getElementById('deviation-modal');
    if (modal) {
        modal.classList.add('hidden');
    }

    if (wasSimulatingBeforeRecalc) {
        wasSimulatingBeforeRecalc = false; // Se resetea la bandera
        showToast("Desv√≠o recalculado. Reanudando simulaci√≥n...", "info");
        setTimeout(() => {
            startAutomatedRouteSimulation(currentSimulationSpeedKmph, true); 
        }, 100);
    }
}
 
// ===================================================================
// NOMBRE: preflightSync 
// RESUMEN: Se ejecuta ANTES de que se cargue la app. Comprueba si hay datos m√°s nuevos en la nube
async function preflightSync() {
    const autoSyncEnabled = JSON.parse(localStorage.getItem('boardinggate_autoBackupOnLoad') || 'false');
    const { primaryId, isMobile } = parseUserId(localStorage.getItem('userData_userId'));
    const backupPassword = localStorage.getItem('userData_backupPassword');

    if (!autoSyncEnabled || !primaryId || isMobile || !backupPassword) {
        return;
    }

    try {
        const result = await callFirebase('getUserData', { userId: primaryId });

        if (result.status === 'success' && result.data) {
            const cloudTimestamp = new Date(result.data.fechaBackup || 0).getTime();
            const localTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');

            if (cloudTimestamp > localTimestamp + 10000) { // 10s de margen
                const backupCacheData = result.data.contenidoCacheCompleto;
                if (backupCacheData) {
                    showToast('Sincronizando datos desde la nube...', 'info', 2000);

                    const currentUserIdentity = localStorage.getItem('userData_userId') || primaryId;
                    for (const key in backupCacheData) {
                        if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                            localStorage.setItem(key, backupCacheData[key]);
                        }
                    }
                    if (currentUserIdentity) {
                        localStorage.setItem('userData_userId', currentUserIdentity);
                    }
                    localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
                } else {
                 }
            } else {
                 }
        } else {
             }
    } catch (error) {
        }
   }

// ===================================================================
// NOMBRE: uploadDirtyCacheOnLoad_Car 
// RESUMEN: Funci√≥n espec√≠fica para el COCHE. Al cargar, si los datos locales son m√°s nuevos, los sube a la nube.
async function uploadDirtyCacheOnLoad_Car() {
    const autoSyncEnabled = JSON.parse(localStorage.getItem('boardinggate_autoBackupOnLoad') || 'false');
    const { primaryId, isMobile } = parseUserId(localStorage.getItem('userData_userId'));
    const backupPassword = localStorage.getItem('userData_backupPassword');

    if (!autoSyncEnabled || !primaryId || isMobile || !backupPassword) {
        return;
    }

    const result = await callFirebase('getUserData', { userId: primaryId });

    if (result.status === 'success' && result.data) {
        const cloudTimestamp = new Date(result.data.fechaBackup || 0).getTime();
        const localTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');

        if (localTimestamp > cloudTimestamp + 10000) { // Si local es m√°s nuevo, subimos
            showToast(`Subiendo cambios locales de ${primaryId} a la nube...`, 'info', 4000);
            await autoSaveFromMobile(primaryId, backupPassword); // Reutilizamos la funci√≥n de guardado
        }
    } else if (result.status === 'not_found') { // Si no hay nada en la nube, subimos lo local
        showToast(`Creando primer backup en la nube para ${primaryId}...`, 'info', 4000);
        await autoSaveFromMobile(primaryId, backupPassword);
    }
}

// ===================================================================
// NOMBRE: autoSaveFromMobile (VERSI√ìN CON PRESERVACI√ìN DE CONTADORES)
// RESUMEN: Antes de guardar, lee los contadores de sesi√≥n de Firebase para no sobreescribirlos.
async function autoSaveFromMobile(primaryId, backupPassword) {
    const userDocRef = window.doc(window.db, "user_data", primaryId);
    let existingCounters = {}; // Objeto para guardar los contadores que queremos preservar

    try {
        const docSnap = await window.getDoc(userDocRef);
        if (docSnap.exists()) {
            const data = docSnap.data();
            if (data.map_sessions_total) existingCounters.map_sessions_total = data.map_sessions_total;
            if (data.map_sessions_month) existingCounters.map_sessions_month = data.map_sessions_month;
            if (data.map_sessions_last_month) existingCounters.map_sessions_last_month = data.map_sessions_last_month;
        }
    } catch (e) {
        console.error("No se pudieron leer los contadores existentes antes de guardar. Podr√≠an perderse si no est√°n en la cach√© local.", e);
    }

    const cacheData = {};
    managedKeys.forEach(key => {
        const value = localStorage.getItem(key);
        if (value !== null) cacheData[key] = value;
    });

    const saveData = {
        userId: primaryId,
        usuario: primaryId,
        modelo: localStorage.getItem('userData_teslaModel') || '',
        anio: localStorage.getItem('userData_teslaYear') || '',
        provincia: localStorage.getItem('userData_teslaProvince') || '',
        rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
        datosCache: cacheData,
        backupPassword: backupPassword,
        fechaBackup: new Date().toISOString(),
        ...existingCounters
    };

    const saveResult = await callFirebase('saveUser', saveData);
    const toast = document.getElementById('mobile-autosave');
    if(toast) toast.remove();
    if (saveResult.status === 'success') {
        showToast('Cambios sincronizados con la nube.', 'success');
        lastMobileSyncTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0'); 
    } else {
        showToast(`Error al sincronizar: ${saveResult.message}`, 'error');
    }
}    

// ===================================================================
// INICIO: L√ìGICA DE MONITOREO DE RECURSOS (Versi√≥n simple y funcional)
// ===================================================================
let resourceMonitorInterval = null;
let fpsCounter = {
    frame: 0,
    lastTime: performance.now(),
    fps: 0
};
let isMonitoring = false;

function formatBytes(bytes, decimals = 2) {
    if (typeof bytes !== 'number' || isNaN(bytes) || bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

function updateFPS(timestamp) {
    if (!isMonitoring) return;
    fpsCounter.frame++;
    const delta = timestamp - fpsCounter.lastTime;
    if (delta >= 1000) {
        fpsCounter.fps = (fpsCounter.frame / (delta / 1000)).toFixed(0);
        fpsCounter.frame = 0;
        fpsCounter.lastTime = timestamp;
    }
    requestAnimationFrame(updateFPS);
}
function startResourceMonitor() {
    if (isMonitoring) return;

    if (typeof performance === 'undefined' || !performance.memory) {
        showToast("El monitoreo de memoria no es compatible.", "warning");
        const checkbox = document.getElementById('config-monitor-resources');
        if (checkbox) checkbox.checked = false;
        return;
    }

    isMonitoring = true;
    requestAnimationFrame(updateFPS);

    resourceMonitorInterval = setInterval(() => {
        const memory = performance.memory;
        
        const used = formatBytes(memory.usedJSHeapSize);
        const total = formatBytes(memory.totalJSHeapSize);
        const limit = formatBytes(memory.jsHeapSizeLimit);
        const fps = fpsCounter.fps;

        const messageContent = `<pre style="margin:0; padding:0; font-family:monospace; font-size:0.90rem;">` +
            `MEMORIA EN USO:   ${used.padStart(12)}\n` +
            `MEMORIA RESERVADA: ${total.padStart(12)}\n` +
            `MEMORIA L√çMITE:   ${limit.padStart(12)}\n` +
            `FPS:              ${String(fps).padStart(12)}` +
            `</pre>`;
            
        const buttonHtml = `<button onclick="stopResourceMonitor()" style="width:100%; margin-top:8px; padding:4px 8px; font-size:0.9rem; font-weight:bold; background-color:#dc3545; color:white; border:none; border-radius:4px; cursor:pointer;">Cancelar</button>`;
        showToast(messageContent + buttonHtml, 'debug', 0, false, 'resource-monitor-toast');
        
        const toast = document.getElementById('resource-monitor-toast');
        if (toast) {
            toast.style.top = '40px';
            toast.style.right = '20px';
            toast.style.bottom = 'auto';
            toast.style.left = 'auto';
            toast.style.transform = 'none';
            toast.style.maxWidth = '300px';
            toast.style.backgroundColor = 'rgba(40, 40, 40, 0.85)';
            toast.style.backdropFilter = 'blur(5px)';
            toast.style.border = '1px solid rgba(255, 255, 255, 0.2)';
        }
    }, 2000);
}
function stopResourceMonitor() {
    if (!isMonitoring) return;

    isMonitoring = false;
    if (resourceMonitorInterval) {
        clearInterval(resourceMonitorInterval);
        resourceMonitorInterval = null;
    }

    const toast = document.getElementById('resource-monitor-toast');
    if (toast) {
        toast.remove();
        activeToasts = activeToasts.filter(t => t.id !== 'resource-monitor-toast');
    }
}
// ===================================================================
// FIN: L√ìGICA DE MONITOREO DE RECURSOS
// ===================================================================
function loadGoogleMapsScript() {
    if (window.google && window.google.maps) return;
    const script = document.createElement('script');
    script.src = `https://maps.googleapis.com/maps/api/js?key=${window.APP_CONFIG.keys.googleMaps}&v=beta&libraries=places&callback=initMap&loading=async`;
    script.async = true;
    document.head.appendChild(script);
}
// ===================================================================
// INICIO: L√ìGICA DEL ASISTENTE DE RUTAS IA (Google Gemini - Versi√≥n Final Segura)
// ===================================================================   
async function ai_tool_google_search_places(args) {
    if (!window.google || !window.google.maps || !window.google.maps.places) {
        return { error: "El servicio de Google Places no est√° disponible." };
    }
    if (!args.queries || args.queries.length === 0) {
        return { message: "No se proporcionaron lugares para buscar." };
    }

    const searchPromises = args.queries.map(query => {
        const request = {
            textQuery: query,
            fields: ['displayName', 'location'],
            maxResultCount: 1    };
        if (navigationCurrentLocation) {
            request.locationBias = {
                center: { lat: navigationCurrentLocation.latitude, lng: navigationCurrentLocation.longitude },
                radius: 50000 // 50km
            };
        }
        return google.maps.places.Place.searchByText(request);
    });

    try {
        const results = await Promise.all(searchPromises);
        const waypoints = results.flatMap(result => {
            if (result.places && result.places.length > 0) {
                const place = result.places[0];
                return {
                    name: place.displayName,
                    lat: place.location.lat(),
                    lng: place.location.lng()
                };
            }
            return [];  });

        if (waypoints.length === 0) {
            return { message: `No se encontraron resultados para: ${args.queries.join(', ')}` };
        }
        
        return waypoints;

    } catch (error) {
        return { error: `Error al contactar con Google Places: ${error.message}` };
    }
}
    
// ===================================================================
// NOMBRE: searchPoisByCategory 
// RESUMEN: Busca POIs. Si no encuentra, ya no desactiva el modo de b√∫squeda, permitiendo al usuario refinar o cancelar.
async function searchPoisByCategory(query, osmKey) {
    if (!query || query.trim() === '') {
        return [];
    }
    const isCalledByAI = (new Error()).stack.includes('ai_tool_search_places');
    if (!isCalledByAI) {
        showToast(`Buscando "${query}"...`, "info");
    }

    const searchButton = document.getElementById('map-location-search-button');
    let photonUrl = `https://photon.komoot.io/api/?q=${encodeURIComponent(query)}&limit=50`;
    const bounds = navigationMapInstance.getBounds();
    photonUrl += `&bbox=${bounds.getWest()},${bounds.getSouth()},${bounds.getEast()},${bounds.getNorth()}`;
    if (osmKey) {
        photonUrl += `&osm_tag=${osmKey}`;
    }
    const photonPromise = fetch(photonUrl).then(res => res.json()).catch(err => ({ features: [] }));
    
    const overpassQuery = osmKey ? buildOverpassQuery(osmKey) : `[out:json][timeout:25];(node[~"name"~"${query.replace(/"/g, '\\"')}"](${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()});way[~"name"~"${query.replace(/"/g, '\\"')}"](${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}););out center;`;
    const overpassPromise = fetchOverpassData(overpassQuery).catch(err => []);

    try {
        const [photonResponse, overpassResponse] = await Promise.all([photonPromise, overpassPromise]);
        const photonFeatures = (photonResponse.features || []);
        const overpassFeaturesRaw = (overpassResponse || []);
        const normalizedPhoton = photonFeatures.map(f => ({ ...f, properties: { ...f.properties, source: 'Photon' } }));
        const normalizedOverpass = overpassFeaturesRaw.map(normalizeOverpassResult).filter(Boolean);
        let combinedFeatures = [...normalizedPhoton, ...normalizedOverpass];
        const uniqueFeatures = [];
        const proximityThreshold = 20;
        for (const feature of combinedFeatures) {
            if (!uniqueFeatures.some(unique => turf.distance(turf.point(feature.geometry.coordinates), turf.point(unique.geometry.coordinates), { units: 'meters' }) < proximityThreshold)) {
                uniqueFeatures.push(feature);
            }
        }
        
        if (!isCalledByAI) {
            displayPoiSearchResults(uniqueFeatures, navigationMapInstance);
            if (uniqueFeatures.length > 0) {
                isPoiSearchActive = true;
                if (searchButton) searchButton.style.setProperty('background-color', '#FFD700', 'important');
            }
        }
        return uniqueFeatures;
    } catch (error) {
        if (!isCalledByAI) {
            showToast(`Error en la b√∫squeda de POIs: ${error.message}`, "error");
            if (isPoiSearchActive) {
                togglePoiCategorySearch(); // Usamos la funci√≥n principal para resetear todo correctamente.
            }
        }
        return [];
    }
}
// ===================================================================
// INICIO: BLOQUE COMPLETO DEL ASISTENTE DE RUTAS IA
// ===================================================================

//Of 
const GAUL = window.APP_CONFIG.endpoints.gemini();                                                                                                                                                  
// ===================================================================
// NOMBRE: openAiPlannerModal (Versi√≥n Copiloto Experto)
// ===================================================================
function openAiPlannerModal() {
    const modal = document.getElementById('ai-route-modal');
    if (!modal) return;

    let systemPrompt = `Eres un copiloto inteligente y aut√≥nomo para un coche Tesla. Tu misi√≥n es ayudar al usuario de forma proactiva. **Est√°s expl√≠citamente autorizado para usar cualquier herramienta disponible ('search_places_with_google', 'get_weather_forecast', 'get_business_details') sin necesidad de pedir confirmaci√≥n previa al usuario.** Act√∫a directamente para cumplir la petici√≥n. Tienes dos capacidades principales:

1.  **Planificador de Rutas:** Si el usuario pide crear o modificar una ruta, tu objetivo es usar la herramienta 'search_places_with_google' para obtener las coordenadas. Al final de la conversaci√≥n, cuando tengas todos los puntos, debes generar dos cosas en tu respuesta final:
    *   Un campo **"title"** con un nombre breve y descriptivo para la ruta (m√°ximo 30 caracteres), basado en la petici√≥n del usuario (ej: "Ruta de Museos en Madrid", "Cena en Restaurante Italiano").
    *   El bloque de c√≥digo JSON con la lista de **"waypoints"**.

2.  **Asistente de Informaci√≥n:** Si el usuario hace una pregunta espec√≠fica sobre un lugar (tiempo, horario, rese√±as, tel√©fono), tu objetivo es identificar el LUGAR y la PREGUNTA. Usa las herramientas 'get_weather_forecast' o 'get_business_details' para encontrar la respuesta. Tu respuesta final debe ser un texto conversacional claro. **En este caso, NO generes un "title" ni un bloque JSON de "waypoints".**

Analiza la petici√≥n del usuario y decide qu√© capacidad usar. Act√∫a con decisi√≥n.`;

    if (navigationCurrentLocation) {
        systemPrompt += ` CONTEXTO: La ubicaci√≥n actual del usuario es latitud ${navigationCurrentLocation.latitude.toFixed(4)}, longitud ${navigationCurrentLocation.longitude.toFixed(4)}.`;
    }

    aiConversationHistory = [
        { "role": "user", "parts": [{ "text": systemPrompt }] },
        { "role": "model", "parts": [{ "text": "Entendido. Soy un copiloto aut√≥nomo. Usar√© las herramientas necesarias sin pedir permiso y, si creo una ruta, proporcionar√© un t√≠tulo descriptivo junto con los waypoints en formato JSON." }] }
    ];

    modal.classList.remove('hidden');
    document.getElementById('ai-prompt-input').value = '';
    
    const statusArea = document.getElementById('ai-status-area');
    statusArea.innerHTML = '<div class="ai-message assistant"><p>Hola, soy tu asistente de rutas e informaci√≥n. ¬øEn qu√© te puedo ayudar?</p></div>';
    
    document.getElementById('ai-generate-route-button').onclick = handleAiRouteRequest;
    document.getElementById('ai-cancel-button').onclick = () => modal.classList.add('hidden');
}
    
// ===================================================================
// NOMBRE: renderAiResponse 
// RESUMEN: Procesa la respuesta de la IA. Si se est√° navegando, inserta los nuevos puntos en la ruta actual. Si no, carga una nueva ruta.
function renderAiResponse(aiText, originalUserPrompt) {
    const statusArea = document.getElementById('ai-status-area');
    if (!statusArea) return;

    const oldButtons = document.getElementById('ai-buttons-container');
    if (oldButtons) oldButtons.remove();

    let summaryText = aiText.replace(/```json\n([\s\S]*?)\n```/, '').trim();
    
    let waypoints = null;
    let routeTitle = null;
    
    try {
        const jsonMatch = aiText.match(/```json\n([\s\S]*?)\n```/);
        if (jsonMatch && jsonMatch[1]) {
            const parsedData = JSON.parse(jsonMatch[1]);
            
            if (parsedData.waypoints && Array.isArray(parsedData.waypoints) && parsedData.waypoints.length > 0) {
                waypoints = parsedData.waypoints;
            }
            
            if (parsedData.title && typeof parsedData.title === 'string' && parsedData.title.trim() !== '') {
                routeTitle = parsedData.title.trim().substring(0, 40);
            }
        }
    } catch (e) {
        console.error("Error al parsear el JSON de la IA:", e);
        renderAssistantMessage("He intentado generar la ruta, pero el formato ten√≠a un error. ¬øPodr√≠as pedirme que lo intente de nuevo o aclarar la petici√≥n?", 'error');
        return; 
    }

    if (waypoints && !summaryText) {
        summaryText = `¬°Listo! He preparado la ruta "${routeTitle || 'Sugerida'}". ¬øQuieres cargarla en el mapa?`;
    }

    if (summaryText) {
        renderAssistantMessage(summaryText.replace(/\n/g, '<br>'));
    } else if (!waypoints) {
        renderAssistantMessage("He recibido una respuesta vac√≠a. ¬øPodr√≠as intentarlo de nuevo?", 'error');
        return;
    }

    if (waypoints) {
        const buttonsContainer = document.createElement('div');
        buttonsContainer.id = 'ai-buttons-container';
        buttonsContainer.className = 'ai-modal-buttons';
        buttonsContainer.style.marginTop = '1rem';
        buttonsContainer.innerHTML = `
            <button id="ai-accept-route">Cargar Ruta en Mapa</button>
            <button id="ai-refine-route">Cerrar</button>
        `;
        statusArea.appendChild(buttonsContainer);
        statusArea.scrollTop = statusArea.scrollHeight;

        document.getElementById('ai-accept-route').onclick = async () => {
            const aiModal = document.getElementById('ai-route-modal');
            const hasExistingRoute = navigationWaypoints.filter(wp => wp && !wp.isInternal).length >= 2;

            const handleAppend = async () => {
                showToast("A√±adiendo puntos a la ruta actual...", "info");
                const waypointsFromAI = sanitizeWaypointsForStorage(waypoints);
                navigationWaypoints.push(...waypointsFromAI);
                await updateWaypointTypesAndLabels();
                renderWaypointMarkers();
                await recalculateAndDrawRoute(isNavigating);
            };

            const handleReplace = () => {
                resetNavigationState();
                const finalRouteName = routeTitle ? `Ruta IA: ${routeTitle}` : `Ruta IA: ${new Date().toLocaleDateString()}`;
                const routeObject = { name: finalRouteName, waypoints: waypoints };
                loadRouteFromObject(routeObject, true);
            };

            if (hasExistingRoute) {
                const choiceModal = document.getElementById('route-concat-choice-modal');
                choiceModal.classList.remove('hidden');

                const appendBtn = document.getElementById('concat-choice-append');
                const replaceBtn = document.getElementById('concat-choice-replace');
                const cancelBtn = document.getElementById('concat-choice-cancel');

                const newAppendBtn = appendBtn.cloneNode(true);
                const newReplaceBtn = replaceBtn.cloneNode(true);
                const newCancelBtn = cancelBtn.cloneNode(true);
                
                appendBtn.parentNode.replaceChild(newAppendBtn, appendBtn);
                replaceBtn.parentNode.replaceChild(newReplaceBtn, replaceBtn);
                cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

                const choiceCloseHandler = () => {
                    clearModalAutoCloseTimer(choiceModal, newAppendBtn, 'route-concat-choice-modal');
                    choiceModal.classList.add('hidden');
                };

                newAppendBtn.onclick = async () => {
                    await handleAppend();
                    choiceCloseHandler();
                    if(aiModal) aiModal.classList.add('hidden');
                };

                newReplaceBtn.onclick = () => {
                    handleReplace();
                    choiceCloseHandler();
                    if(aiModal) aiModal.classList.add('hidden');
                };
                
                newCancelBtn.onclick = choiceCloseHandler;

                addModalAutoCloseTimer(choiceModal, newAppendBtn, 'route-concat-choice-modal', 20000);

            } else {
                handleReplace();
                if(aiModal) aiModal.classList.add('hidden');
            }
        };
        
        document.getElementById('ai-refine-route').onclick = () => {
            document.getElementById('ai-route-modal').classList.add('hidden');
        };
    }
}
    
// -------------------------------------------------------------------
// NOMBRE: handleAiRouteRequest (Versi√≥n Copiloto Inteligente)
// -------------------------------------------------------------------
async function handleAiRouteRequest() {
    const promptInput = document.getElementById('ai-prompt-input');
    const prompt = promptInput.value.trim();
    const statusArea = document.getElementById('ai-status-area');
    const generateBtn = document.getElementById('ai-generate-route-button');

    if (!prompt) {
        showToast("Por favor, escribe una petici√≥n.", "warning");
        return;
    }

    statusArea.innerHTML += `<div class="ai-message user"><p>${prompt}</p></div>`;
    promptInput.value = '';
    generateBtn.disabled = true;
    statusArea.scrollTop = statusArea.scrollHeight;

    const currentUserPrompt = { "role": "user", "parts": [{ "text": prompt }] };
    aiConversationHistory.push(currentUserPrompt);

    const tools = [{
        "functionDeclarations": [
            {
                "name": "search_places_with_google",
                "description": "Busca una LISTA de lugares para obtener sus coordenadas para PLANIFICAR UNA RUTA.",
                "parameters": {
                    "type": "OBJECT",
                    "properties": { "queries": { "type": "ARRAY", "description": "Una lista de los lugares a buscar. Ej: ['Museo del Prado', 'Museo Reina Sof√≠a']", "items": { "type": "STRING" } } },
                    "required": ["queries"]
                }
            },
            {
                "name": "get_weather_forecast",
                "description": "Obtiene el pron√≥stico del tiempo para una ubicaci√≥n espec√≠fica.",
                "parameters": {
                    "type": "OBJECT",
                    "properties": {
                        "location": {
                            "type": "STRING",
                            "description": "La ciudad para la cual se solicita el pron√≥stico del tiempo, ej: 'Madrid, Espa√±a'."
                        }
                    },
                    "required": ["location"]
                }
            },
            {
            "name": "get_business_details",
            "description": "Obtiene informaci√≥n espec√≠fica y detallada sobre un negocio o lugar de inter√©s, como rese√±as, horario, tel√©fono, etc.",
            "parameters": {
                "type": "OBJECT",
                "properties": {
                    "place_name": {
                        "type": "STRING",
                        "description": "El nombre del negocio o lugar a buscar, ej: 'Restaurante Bot√≠n', 'Museo del Prado'."
                    },
                    "question": {
                        "type": "STRING",
                        "description": "La pregunta espec√≠fica que el usuario tiene sobre ese lugar, ej: '¬øcu√°l es su horario?', 'dame las rese√±as', '¬øtienen men√∫ vegetariano?'."
                    }
                },
                "required": ["place_name", "question"]
            }
        }
        ]
    }];

    try {
        for (let i = 0; i < 5; i++) {
            const response = await fetch(GAUL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ "contents": aiConversationHistory, "tools": tools })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Error del servidor de IA (${response.status}): ${errorData.error.message}`);
            }
            
            const result = await response.json();
            if (!result.candidates || result.candidates.length === 0) {
                const blockReason = result.promptFeedback?.blockReason || 'desconocida';
                throw new Error(`La respuesta de la IA fue bloqueada por motivo: ${blockReason}. Intenta reformular tu petici√≥n.`);
            }

            const assistantResponsePart = result.candidates[0].content.parts[0];
            aiConversationHistory.push({ "role": "model", "parts": [assistantResponsePart] });

            if (assistantResponsePart.functionCall) {
                const toolCall = assistantResponsePart.functionCall;
                let toolResult;

                switch (toolCall.name) {
                    case "search_places_with_google":
                        renderAssistantMessage(`‚öôÔ∏è Planificando ruta y buscando en Google: <b>${toolCall.args.queries.join(', ')}</b>...`, 'tool');
                        toolResult = await ai_tool_google_search_places(toolCall.args);
                        break;
                    case "get_weather_forecast":
                        renderAssistantMessage(`üå¶Ô∏è Consultando el tiempo para <b>${toolCall.args.location}</b>...`, 'tool');
                        toolResult = await ai_tool_get_weather_forecast(toolCall.args);
                        break;
                    case "get_business_details":
                        renderAssistantMessage(`‚ÑπÔ∏è Buscando detalles de <b>${toolCall.args.place_name}</b>...`, 'tool');
                        toolResult = await ai_tool_get_business_details(toolCall.args);
                        break;
                    default:
                        toolResult = { error: `Herramienta desconocida: ${toolCall.name}` };
                }
                
                aiConversationHistory.push({
                    "role": "user",
                    "parts": [{ "functionResponse": { "name": toolCall.name, "response": { "result": toolResult } } }]
                });

            } else {
                const aiTextResponse = assistantResponsePart.text;
                renderAiResponse(aiTextResponse, prompt);
                return; 
            }
        }
        renderAssistantMessage("Parece que la conversaci√≥n se ha alargado. ¬øPuedes resumir la ruta completa que quieres?", 'error');
    } catch (error) {
        console.error("Error en la IA:", error);
        renderAssistantMessage(`<b>Error:</b> ${error.message}`, 'error');
        aiConversationHistory.pop(); 
        aiConversationHistory.pop();
    } finally {
        generateBtn.disabled = false;
        statusArea.scrollTop = statusArea.scrollHeight;
    }
}

// -------------------------------------------------------------------
// NOMBRE: renderAssistantMessage
// -------------------------------------------------------------------
function renderAssistantMessage(htmlContent, type = 'assistant') {
    const statusArea = document.getElementById('ai-status-area');
    if (!statusArea) return;

    const buttonsContainer = document.getElementById('ai-buttons-container');
    if (buttonsContainer) {
        buttonsContainer.remove();
    }

    const messageDiv = document.createElement('div');
    messageDiv.className = `ai-message ${type}`;
    messageDiv.innerHTML = `<p>${htmlContent}</p>`;
    
    statusArea.appendChild(messageDiv);
    statusArea.scrollTop = statusArea.scrollHeight;
}

// -------------------------------------------------------------------
// NOMBRE: ai_tool_get_weather_forecast (Herramienta de Clima)
async function ai_tool_get_weather_forecast(args) {
    const location = args.location || "la ubicaci√≥n actual";
    console.log(`Herramienta de Clima llamada para: ${location}`);
    
    const temperatures = [15, 18, 22, 25, 23, 19];
    const temp = temperatures[Math.floor(Math.random() * temperatures.length)];
    const conditions = ["soleado", "parcialmente nuboso", "despejado con algunas nubes", "muy agradable"];
    const condition = conditions[Math.floor(Math.random() * conditions.length)];

    return { 
        forecast: `El tiempo para ${location} es ${condition}, con una temperatura aproximada de ${temp}¬∞C.` 
    };
}

// ===================================================================
// NOMBRE: ai_tool_get_business_details (Versi√≥n Agente de Informaci√≥n)
// RESUMEN: Busca un lugar, determina qu√© informaci√≥n se necesita a partir de la
async function ai_tool_get_business_details(args) {
    const placeName = args.place_name;
    const question = (args.question || "").toLowerCase();

    if (!placeName) {
        return { error: "No se especific√≥ el nombre del lugar." };
    }
    console.log(`Herramienta de Detalles Avanzada llamada para: "${placeName}" con la pregunta: "${question}"`);

    try {
        const center = navigationCurrentLocation 
            ? { lat: navigationCurrentLocation.latitude, lng: navigationCurrentLocation.longitude }
            : { lat: 40.416775, lng: -3.703790 }; // Fallback a Madrid

        const placeId = await findGooglePlaceId(placeName, center.lat, center.lng);
        if (!placeId) {
            return { summary: `No pude encontrar un lugar llamado "${placeName}" cerca.` };
        }
        
        const fieldsToFetch = new Set(['displayName', 'formattedAddress']); // Campos b√°sicos siempre
        
        if (question.includes('horario') || question.includes('abre') || question.includes('cierra')) {
            fieldsToFetch.add('regularOpeningHours');
            fieldsToFetch.add('isOpen');
        }
        if (question.includes('rese√±a') || question.includes('opiniones') || question.includes('valoracion') || question.includes('estrellas')) {
            fieldsToFetch.add('rating');
            fieldsToFetch.add('userRatingCount');
            fieldsToFetch.add('reviews');
        }
        if (question.includes('tel√©fono') || question.includes('contacto') || question.includes('llamar')) {
            fieldsToFetch.add('nationalPhoneNumber');
        }
        if (question.includes('web') || question.includes('men√∫') || question.includes('carta') || question.includes('precios')) {
            fieldsToFetch.add('websiteURI');
        }
        if (question.includes('fotos')) {
            fieldsToFetch.add('photos');
        }

        const placeDetails = await getGooglePlaceDetails(placeId, Array.from(fieldsToFetch));
        if (!placeDetails) {
            return { summary: `Encontr√© "${placeName}" pero no pude obtener sus detalles.` };
        }
        
        let summary = `Aqu√≠ tienes la informaci√≥n que encontr√© sobre ${placeDetails.displayName}:`;

        if (fieldsToFetch.has('regularOpeningHours')) {
            if (placeDetails.regularOpeningHours) {
                const today = new Date().getDay();
                const dayIndex = (today === 0) ? 6 : today - 1;
                const isOpenNow = placeDetails.isOpen();
                summary += `\n- Horario: ${placeDetails.regularOpeningHours.weekdayDescriptions[dayIndex]}. Ahora mismo est√° ${isOpenNow ? 'abierto' : 'cerrado'}.`;
            } else {
                summary += "\n- No encontr√© informaci√≥n sobre su horario.";
            }
        }
       if (fieldsToFetch.has('rating')) {
            if (placeDetails.rating) {
                summary += `\n- Valoraci√≥n: Tiene ${placeDetails.rating} estrellas de un total de ${placeDetails.userRatingCount} opiniones.`;
            }
            if (placeDetails.reviews && placeDetails.reviews.length > 0) {
                const topReview = placeDetails.reviews[0];
                summary += `\n- Rese√±a principal: "${topReview.text ? topReview.text.originalText.substring(0, 150) : 'Sin texto'}..." (${topReview.rating} estrellas).`;
            }
        }
        if (fieldsToFetch.has('nationalPhoneNumber') && placeDetails.nationalPhoneNumber) {
            summary += `\n- Tel√©fono: ${placeDetails.nationalPhoneNumber}.`;
        }
        if (fieldsToFetch.has('websiteURI') && placeDetails.websiteURI) {
            summary += `\n- Web (para men√∫s o precios): ${placeDetails.websiteURI}.`;
        }
        
        return { summary: summary };

    } catch (error) {
        return { error: `Ocurri√≥ un error al buscar los detalles: ${error.message}` };
    }
}
// ===================================================================
// FIN: BLOQUE COMPLETO DEL ASISTENTE DE RUTAS IA
// ===================================================================   
    // NOMBRE: updateGridItemUI
    // RESUMEN: Redibuja el grid y los botones para reflejar los cambios realizados en la edici√≥n.
    function updateGridItemUI(indexOrStart, isToggle = false) {
        renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles();adjustButtonPositions();
        if (isAssignmentMode) {
            updateGridAssignmentVisuals();
            if (currentlyAssigningToggleStart !== null && toggleButtonElements[currentlyAssigningToggleStart]) {
                toggleButtonElements[currentlyAssigningToggleStart].classList.add('assigning-selected');
                toggleButtonElements[currentlyAssigningToggleStart].style.opacity = '';
            }
        } else if (isKeywordAssignmentMode) { applyInitialKeywordHighlights(); }
    }  
     
    // ===================================================================
    function performInsertAndSave(sourceIndex, targetIndex) { if (sourceIndex === targetIndex || sourceIndex === null || targetIndex === null) { return false; } const draggedData = currentBookmarks.splice(sourceIndex, 1)[0]; currentBookmarks.splice(targetIndex, 0, draggedData); if (!customData.bookmarks) customData.bookmarks = {}; if (!customData.toggles) customData.toggles = {}; const minIdx = Math.min(sourceIndex, targetIndex); const maxIdx = Math.max(sourceIndex, targetIndex); currentToggleRanges.forEach(range => { if (range.assignedIndexes) {
        range.assignedIndexes = range.assignedIndexes.map(idx => { if (idx === sourceIndex) return targetIndex; else if (idx > sourceIndex && idx <= targetIndex) return idx - 1; else if (idx < sourceIndex && idx >= targetIndex) return idx + 1; else return idx; }).sort((a, b) => a - b); const startKey = range.start.toString(); if (customData.toggles[startKey] && customData.toggles[startKey].hasOwnProperty('assignedIndexes')) { customData.toggles[startKey].assignedIndexes = [...range.assignedIndexes]; } } }); for (let i = minIdx; i <= maxIdx; i++) { const currentItem = currentBookmarks[i]; const originalItem = i < originalBookmarks.length ? originalBookmarks[i] : null; const bookmarksAreEqual = (b1, b2) => { if (b1 === null && b2 === null) return true; if (b1 === null || b2 === null) return false; return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null); }; if (!bookmarksAreEqual(currentItem, originalItem)) { customData.bookmarks[i] = currentItem ? { ...currentItem } : null; } else if (customData.bookmarks.hasOwnProperty(i)) { delete customData.bookmarks[i]; } } saveCustomData(); renderGrid(); loadSavedSettings(); updateButtonStyles(); showToast(`Movido de ${sourceIndex + 1} a ${targetIndex + 1}`, "success", 1500); return true; }
    // ===================================================================
    function handleDragStart(e) { if (!isEditMode) return; draggedItem = e.currentTarget; draggedItemIndex = parseInt(draggedItem.dataset.index); e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', draggedItemIndex); setTimeout(() => { if (draggedItem) draggedItem.classList.add('dragging'); }, 0); }
    // ===================================================================
    function handleDragOver(e) { if (!isEditMode || !draggedItem) return; e.preventDefault(); e.dataTransfer.dropEffect = 'move'; const targetCell = e.target.closest('.grid-cell'); const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetCell && targetIndex !== dragOverIndex) { if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } if (targetIndex !== draggedItemIndex) { targetCell.classList.add('drag-over'); dragOverIndex = targetIndex; } else { dragOverIndex = null; } } else if (!targetCell && dragOverIndex !== null) { if (cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } dragOverIndex = null; } }
    // ===================================================================
    function handleDragLeave(e) { if (!isEditMode || !draggedItem) return; const targetCell = e.target.closest('.grid-cell'); if (targetCell && !targetCell.contains(e.relatedTarget)) { if (parseInt(targetCell.dataset.index) === dragOverIndex) { targetCell.classList.remove('drag-over'); dragOverIndex = null; } } }
    // ===================================================================
    function handleDrop(e) { if (!isEditMode || !draggedItem) return; e.preventDefault(); const targetCell = e.target.closest('.grid-cell'); const sourceIndex = draggedItemIndex; const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetIndex !== null && sourceIndex !== targetIndex) { performInsertAndSave(sourceIndex, targetIndex); } else { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } } handleDragEndCleanup(); }
    // ===================================================================
    function handleDragEndCleanup() { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } draggedItem = null; draggedItemIndex = null; dragOverIndex = null; } 
    // ===================================================================
    function handleTouchStart(e) { if (!isEditMode || e.touches.length !== 1) return; draggedItem = e.currentTarget; draggedItemIndex = parseInt(draggedItem.dataset.index); const touch = e.touches[0]; touchStartX = touch.clientX; touchStartY = touch.clientY; draggedItem.classList.add('dragging'); currentTouchTarget = draggedItem; }
    // ===================================================================
    function handleTouchMove(e) { if (!isEditMode || !draggedItem || e.touches.length !== 1) return; e.preventDefault(); const touch = e.touches[0]; const elementOver = document.elementFromPoint(touch.clientX, touch.clientY); const targetCell = elementOver?.closest('.grid-cell'); const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetCell && targetIndex !== dragOverIndex) { if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } if (targetIndex !== draggedItemIndex) { targetCell.classList.add('drag-over'); dragOverIndex = targetIndex; currentTouchTarget = targetCell; } else { dragOverIndex = null; currentTouchTarget = draggedItem; } } else if (!targetCell && dragOverIndex !== null) { if (cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } dragOverIndex = null; currentTouchTarget = null; } }   
    // ===================================================================
    function handleTouchEnd(e) { if (!isEditMode || !draggedItem) return; if (dragOverIndex !== null && dragOverIndex !== draggedItemIndex) { performInsertAndSave(draggedItemIndex, dragOverIndex); e.preventDefault(); } else { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } } handleTouchEndCleanup(); }   
    // ===================================================================
    function handleTouchEndCleanup() { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } draggedItem = null; draggedItemIndex = null; dragOverIndex = null; currentTouchTarget = null; touchStartX = 0; touchStartY = 0; }
    // ===================================================================
    function normalizeText(text) { if (!text) return ''; return text.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, ''); }
    // ===================================================================
    async function loadNotices() { try { const r = await fetch('https://boardinggate.github.io/Tesla/avisos.txt', { cache: 'no-cache' }); if (!r.ok) throw new Error('Fetch failed'); const txt = await r.text(); notices = txt.split('\n').map(l => l.trim()).filter(l => l.length > 0); if (notices.length === 0) notices = ['No hay avisos.']; } catch (e) { notices = ['Error carga avisos.']; } updateNotice(); }    
    // ===================================================================
    function updateNotice() { const noticeElement = document.getElementById('current-notice'); if (!noticeElement || notices.length === 0) { return; } if (!isActive) { noticeElement.textContent = ''; noticeElement.style.animation = 'none'; return; } noticeElement.textContent = notices[currentNoticeIndex]; noticeElement.style.animation = 'none'; void noticeElement.offsetWidth; noticeElement.style.animation = 'fadeInOut 14s infinite'; currentNoticeIndex = (currentNoticeIndex + 1) % notices.length; } 
    // ===================================================================
    function toggleNotices() { isActive = !isActive; const nC = document.querySelector('.notices-container'); if (nC) nC.style.display = isActive ? 'flex' : 'none'; const fC = document.querySelector('footer'); if (fC) fC.classList.toggle('footer-hidden', !isActive); isFooterVisible = isActive; const nE = document.getElementById('current-notice'); if (nE) { if (!isActive) { nE.textContent = ''; nE.style.animation = 'none'; } else { currentNoticeIndex = 0; updateNotice(); } } saveSettings(); }
    // ===================================================================
    function startNoticeRotation() { if (notices.length === 0) return; if (isActive) updateNotice(); setInterval(updateNotice, 14000); }   
    // ===================================================================
    function adjustButtonPositions() { const scrollToggle = document.getElementById('scroll-toggle'); if (!scrollToggle) { return; }
    const scrollToggleHeight = scrollToggle.offsetHeight; const buttonHeight = 74; const buttonSpacing = 10; const startTop = scrollToggleHeight + 20; const fixedButtons = [ document.getElementById('on-off-toggle'), ...document.querySelectorAll('.range-toggle'), document.getElementById('weather-button'), document.getElementById('reminder-button'), document.getElementById('zoom-button'), document.getElementById('dark-mode-toggle') ].filter(button => button !== null).sort((a, b) => { const startA = parseInt(a.dataset.rangeStart) || Infinity; const startB = parseInt(b.dataset.rangeStart) || Infinity; if (a.id === 'on-off-toggle') return -1; if (b.id === 'on-off-toggle') return 1; if (isFinite(startA) && isFinite(startB)) return startA - startB; if (isFinite(startA)) return -1; if (isFinite(startB)) return 1; const order = ['weather-button', 'reminder-button', 'zoom-button', 'dark-mode-toggle']; return order.indexOf(a.id) - order.indexOf(b.id); }); if (fixedButtons.length < 6) { return; } let currentTop = startTop; fixedButtons.forEach((button) => { button.style.position = 'fixed'; button.style.top = `${currentTop}px`; button.style.left = '10px'; currentTop += buttonHeight + buttonSpacing; }); }
    // ===================================================================
    function getSavedLocations() { try { const locations = localStorage.getItem(SAVED_LOCATIONS_KEY); return locations ? JSON.parse(locations) : Array(MAX_SAVED_LOCATIONS).fill(null); } catch (e) { return Array(MAX_SAVED_LOCATIONS).fill(null); } }   
    // ===================================================================
    function saveLocationsToCache(locationsArray) { try { localStorage.setItem(SAVED_LOCATIONS_KEY, JSON.stringify(locationsArray));} catch (e) { showToast("Error al guardar ubicaciones.", "error"); } }
    // ===================================================================
    function handleDragEnd(e) {     if (!isEditMode) return;  handleDragEndCleanup(); }

    
// ===================================================================
// NOMBRE: DOMContentLoaded (MODIFICADO)
// RESUMEN: Punto de entrada principal. Ahora espera a la sincronizaci√≥n pre-vuelo ANTES de inicializar la app.
document.addEventListener('DOMContentLoaded', async () => {
    preloadGpsLocation(); 
    await preflightSync();
     
     storedPin = localStorage.getItem('password_pin');
     const savedPasswordActive = localStorage.getItem('password_active');
     isPasswordActive = savedPasswordActive ? JSON.parse(savedPasswordActive) : false;
     const initialDirectToNavPref = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
     const tempPreventDirectNav = sessionStorage.getItem(TEMP_PREVENT_DIRECT_NAV_KEY);

     if (isPasswordActive && storedPin && !(initialDirectToNavPref && !tempPreventDirectNav)) {
         promptForPin();
     } else {
         await initializeApp();
     }

    assignMapButtonListeners();
    document.body.addEventListener('click', function(event) {
        const target = event.target;
        const targetId = target.id || (target.closest('[id]') ? target.closest('[id]').id : null);

        if (targetId === 'config-close-modal') {
            const termsAcceptedForClose = localStorage.getItem('termsAccepted_v1') === 'true';
            if (!termsAcceptedForClose) {
                showToast('Debes aceptar las normas de uso para continuar.', 'warning');
                return;
            }
            const modal = document.getElementById('config-modal');
            if (modal && !modal.classList.contains('hidden')) {
                clearModalAutoCloseTimer(modal, target, 'config-modal');
                modal.classList.add('hidden');
                 const mapWasOpenBeforeConfig = sessionStorage.getItem('boardinggate_map_should_reopen_after_config') === 'true';
                 const mapContextToReopen = sessionStorage.getItem('mapContextToReopenAfterConfig');
                 sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');
                 sessionStorage.removeItem('mapContextToReopenAfterConfig');
                 if (mapWasOpenBeforeConfig && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !document.getElementById('reminders-location-map-modal')) {
                    if (mapContextToReopen === 'navigation') {
                        setTimeout(() => openNavigationMap(), 50);
                    }
                }
            }
        }
        if (target.matches('.config-tab-button')) {
            const modal = document.getElementById('config-modal');
            if(modal && modal.classList.contains('hidden') === false) {
                const tabTarget = target.dataset.tabTarget;
                modal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                modal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (modal.querySelector(tabTarget)) {
                    modal.querySelector(tabTarget).classList.add('active');
                }
            }
        }
        if (targetId === 'close-reminders-top' || targetId === 'close-reminders-bottom') {
            const modalTable = document.querySelector('.reminder-table-modal');
            if (modalTable) {
                if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                modalTable.remove();
                const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                const mapContext = sessionStorage.getItem('mapContext');
                sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                sessionStorage.removeItem('mapContext');
                if (fromReminderModal) {
                    fromReminderModal = false;
                    if (mapShouldReopen) {
                        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                        sessionStorage.setItem('mapContext', mapContext);
                    }
                    showReminderModal();
                } else if (mapShouldReopen) {
                     if (mapContext === 'navigation') openNavigationMap();
                }
            }
        }
        if (targetId === 'view-all-locations-map') {
            const modalTable = document.querySelector('.reminder-table-modal');
             if (modalTable && modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
             if (modalTable) modalTable.remove();
            setTimeout(() => {
                openLocationsPreviewMap();
            }, 50);
        }
         if (targetId === 'close-locations-preview') {
            const previewModal = document.getElementById('locations-preview-modal');
            if (previewModal) {
                if (locationsPreviewMap) {
                    try { locationsPreviewMap.remove(); } catch (e) {}
                    locationsPreviewMap = null;
                }
                if (mapLayersControlLocationsPreview) {
                    try {mapLayersControlLocationsPreview.remove();} catch(e){}
                    mapLayersControlLocationsPreview = null;
                }
                clearModalAutoCloseTimer(previewModal, target, 'locations-preview-modal');
                previewModal.classList.add('hidden');
            }
        }
        if (targetId === 'close-address-suggestions-modal') {
            hideAddressSuggestionsModal();
        }
    });
   const configModal = document.getElementById('config-modal');
    if (configModal) {
        configModal.addEventListener('click', function(event) {
            const target = event.target;
            if (target.matches('.config-tab-button')) {
                const tabTarget = target.dataset.tabTarget;
                configModal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                configModal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (configModal.querySelector(tabTarget)) {
                    configModal.querySelector(tabTarget).classList.add('active');
                }
            }
        });
    }
    const bookmarkGrid = document.getElementById('bookmark-grid');
    if (bookmarkGrid) {
        bookmarkGrid.addEventListener('click', function(event) {
            const link = event.target.closest('a.bookmark-item');
            if (link && link.href && link.href.startsWith("map-action:")) {
                event.preventDefault();
                const action = link.href.split(":")[1];
                if (action === "openRemindersMapWithNoRadars") {
                    closeOtherModals();
                    setTimeout(() => {
                        const existingPreviewModal = document.getElementById('locations-preview-modal');
                        if (existingPreviewModal && !existingPreviewModal.classList.contains('hidden')) {
                            showToast("El mapa de ubicaciones (sin radar) ya est√° abierto", "info");
                        } else {
                           openLocationsPreviewMap();
                        }
                    }, 50);
                } else if (action === "openRemindersMap") {
                    closeOtherModals();
                    setTimeout(() => {
                        const mapModalElement = document.getElementById('reminders-location-map-modal');
                        if (mapModalElement && !mapModalElement.classList.contains('hidden')) {
                            showToast("El mapa de navegaci√≥n/ubicaciones ya est√° abierto", "info");
                            if (navigationMapInstance) {
                                requestAnimationFrame(() => {
                                    requestAnimationFrame(() => {
                                        if (navigationMapInstance) {
                                            try {
                                                 navigationMapInstance.resize();
                                             } catch (e) {  }
                                        }
                                    });
                                });
                            }
                        } else {
                           openNavigationMap();
                        }
                    }, 50);
                }
            }
        });
    }
    
    const accidentAlertButton = document.getElementById('accident-alert-button');
    if (accidentAlertButton) {
        accidentAlertButton.addEventListener('click', () => {
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
            openAlertModal();
        });
    }

    if (reminderCheckIntervalId) {
        clearInterval(reminderCheckIntervalId); // Doble seguridad por si acaso
    }
    checkReminders();
    
    window.addEventListener('beforeunload', () => {
         if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
         if (locationWatchId !== null && navigator.geolocation) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
         if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
         const openReminderModal = document.querySelector('.reminder-modal');
         if (openReminderModal && typeof openReminderModal.cleanUpModalTimers === 'function') { openReminderModal.cleanUpModalTimers(true); }
         Object.keys(globalModalTimers).forEach(modalId => {
            const timerData = globalModalTimers[modalId];
            if (timerData) {
                clearModalAutoCloseTimer(timerData.modalElement, timerData.closeButtonElement, modalId);
            }
         });
         globalModalTimers = {};
         const openTableModal = document.querySelector('.reminder-table-modal');
         if(openTableModal && openTableModal.autoCloseInterval) { clearInterval(openTableModal.autoCloseInterval); }
         const openPostponeModal = document.getElementById('postpone-options-modal');
         if(openPostponeModal && openPostponeModal.autoPostponeInterval) { clearInterval(openPostponeModal.autoPostponeInterval); }
         const openSavedLocationsModal = document.querySelector('.saved-locations-modal');
         if (openSavedLocationsModal && locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
         const simModalUnload = document.getElementById('simulation-modal');
         if (simModalUnload && simulationModalTimer) clearTimeout(simulationModalTimer);
         if (autoStartNavTimer) clearTimeout(autoStartNavTimer);
    
         if (!isPerformingControlledReload) {
             if (isNavigationMapActive || navigationMapInstance) {
                closeNavigationMap(true);
             }
         }
    
         if (locationsPreviewMap) {
             try { locationsPreviewMap.remove(); } catch(e){}
             locationsPreviewMap = null;
         }
         if (isAssignmentMode || isEditMode || isKeywordAssignmentMode) { saveCustomData(); }
         const filterInput = document.getElementById('grid-filter-input');
         if (filterInput && filterInput.value.trim()) {
              localStorage.setItem('gridFilterValue', filterInput.value);
         } else {
              localStorage.removeItem('gridFilterValue');
         }
          saveSettings();
          if (reminderModalMap) try {reminderModalMap.remove();} catch(e){}
          Object.values(previewMaps).forEach(map => {try {map?.remove();} catch(e){}});
          if (intersectionPreviewMap) try {intersectionPreviewMap.remove();} catch(e){}
          if (navigationChart) navigationChart.destroy();
          if (graphIntervalTimer) clearInterval(graphIntervalTimer);
    });

    setTimeout(loadGoogleMapsScript, 100);

<!--  SCRIPT DE GUIA -->
    
// ===================================================================
// NOMBRE: iniciarGuiaInteractivaCompleta
// RESUMEN: Lanza la gu√≠a interactiva completa del mapa.
window.iniciarGuiaInteractivaCompleta = function() {
        const driverObj = driver.js.driver({
            showProgress: true,
            popoverClass: 'driver-popover',
            nextBtnText: 'Siguiente', 
            prevBtnText: 'Anterior', 
            doneBtnText: 'Finalizar', 
            steps: [
                { 
                    element: '#reminders-location-map-div', 
                    popover: { title: '¬°Bienvenid@ al Navegador Avanzado BoardingGate!', description: 'Esta gu√≠a te mostrar√° todas las funciones del mapa. Empezaremos con las interacciones b√°sicas. ¬°Vamos all√°!', side: "top", align: 'start' } 
                },
                { 
                    element: '#reminders-location-map-div', 
                    popover: { title: 'Gestos en el Mapa', description: 'Puedes interactuar directamente: <strong>Pellizca para hacer zoom</strong>, <strong>arrastra con dos dedos para inclinar (pitch)</strong> y <strong>gira con dos dedos para rotar</strong>. Un <strong>toque simple</strong> en cualquier sitio fija una ETAPA de la ruta que podr√° arrastrar si necesita resituarlo, si pulsa sobre un POI (punto de inter√©s) se abre una ventana con informaci√≥n. IMPORTANTE, recuerda tambi√©n QUE PUEDES DICTAR en cualquier campo de texto, simplemente seleccion√°ndolo y pulsando el bot√≥n de COMANDOS DE VOZ del volante. Podr√°s forzar la visualizaci√≥n del espacio de la br√∫jula y dem√°s datos asociados dando ah√≠ una pulsaci√≥n. Tambi√©n podr√°s hacer lo mismo con el minimapa del trayecto completo de la ruta, pulsando en la esquina superior derecha.', side: "top", align: 'start' } 
                },
                { 
                    element: '#toggle-map-header-buttons-panel', 
                    popover: { title: 'El Bot√≥n de Acci√≥n R√°pida', description: 'Este bot√≥n es una navaja suiza. Sus funciones cambian seg√∫n el gesto:<br><ul><li><strong>Clic corto:</strong> Muestra/oculta la barra de botones superior y desactiva Modo Inmersivo.</li><li><strong>Deslizar ARRIBA:</strong> Inicia o detiene la navegaci√≥n.</li><li><strong>Deslizar IZQUIERDA:</strong> Activa/desactiva modo inmersivo (con un toque tambi√©n se desactiva). Si est√° oculta la tarjeta de progreso la muestra momentaneamente.</li><li><strong>Deslizar DERECHA/ABAJO:</strong> Carga rutas r√°pidas ("CASA", "TRABAJO").</li><li><strong>Pulsaci√≥n Larga:</strong> Reporta incidencias de tr√°fico (ACCIDENTE, RADAR, etc)</li></ul>', side: "right" } 
                },
                
                { 
                    element: '#map-location-search-input', 
                    popover: { title: '1. Busca tu Destino', description: "Escribe aqu√≠ una direcci√≥n, un negocio o una ciudad. Para acotar las b√∫squedas, puedes usar el campo de al lado como filtro geogr√°fico (ej: 'Madrid').", side: "bottom" } 
                },
                { 
                    element: '#map-location-search-button', 
                    popover: { title: '2. A√±ade el Punto o Explora', description: "Tras escribir, pulsar este bot√≥n y buscar desde tipos de negocios que no est√°n predefinidos o directamente uno, o b√∫squedas de todo tipo, pero con la particularidad de que ya te la situa en el mapa que est√©s viendo en ese momento <strong>¬°Ojo!</strong> Si lo pulsas con el buscador vac√≠o, se abrir√° un men√∫ para encontrar Puntos de Inter√©s (POIs). IMPORTANTE; Si usa esta opci√≥n estando navegando una ruta podr√° a√±adir igualmente nuevas etapas a visitar pulsando este bot√≥n y tras seleccionar un POI o lugar en el mapa, volver a pulsar el bot√≥n (estando en amarillo), lo que har√° que la ruta se recalcule de nuevo, incluso podr√° reordenar la ruta si lo cree conveniente usando el bot√≥n de reordenar. La opci√≥n IA tambi√©n funciona con una ruta cargada y opera igual.", side: "bottom" } 
                },
                { 
                    element: '#reorder-route-stages-button', 
                    popover: { title: '3. Organiza tus Paradas', description: "Si tu ruta tiene varias paradas, este bot√≥n abre un panel donde puedes <strong>arrastrar para cambiar el orden</strong> de las etapas o pulsar la 'X' para eliminar alguna. Funciona tanto antes de iniciar la ruta como despues de √©sta iniciada.", side: "bottom" } 
                },
                { 
                    element: '#load-saved-route-button', 
                    popover: { title: '4. Carga tus Rutas Favoritas', description: "Accede a tus rutas y destinos guardados. Usa el bot√≥n de al lado (<img src='PNG/GUARDARRUTA.PNG' style='height:20px; vertical-align:middle;'>) para guardar la ruta que acabas de planificar. Las rutas se ordenan alfab√©ticamente", side: "bottom" } 
                },
                { 
                    element: '#start-navigation-button', 
                    popover: { title: '5. ¬°Inicia el Viaje!', description: "Cuando todo est√© listo, pulsa aqu√≠ para comenzar la navegaci√≥n guiada. Tambi√©n iniciar√° la ruta autom√°ticamente al detectar que est√°s circulando a m√°s de 40 metros del punto inicial. Esto funcionar√° tanto con navegacion normal como Free Drive (sin ruta). Este mismo bot√≥n te servir√° para finalizar el viaje m√°s tarde.", side: "bottom" } 
                },
                
                // BLOQUE 3: HERRAMIENTAS
                { 
                    element: '#navigation-bottom-progress-bar', 
                    popover: { title: 'Tu Copiloto Digital', description: "La tarjeta de progreso de ruta se ver√° en la parte superior izquierda con: pr√≥xima maniobra, barra de distancia relativa de ruta, en la que encontrar√°s un icono con los radares y recordatorios, o los kms realizados, la hora de inicio del viaje y el tiempo empleado hasta el momento. Debajo pondr√° los datos ETA de la ruta. El icono del candado (<img src='PNG/IMG_4281.png' style='height:18px; vertical-align:middle;'>) te permite fijar el panel para que no se oculte autom√°ticamente en tramos largos sin indicaciones. Si pulsa encima del icono de maniobra se previsualizar√° la pr√≥xima maniobra.", side: "right" } 
                },
                { 
                    element: '.map-control-orientation-altitude', 
                    popover: { title: 'Br√∫jula y Datos del Viaje', description: 'Este panel es otra navaja suiza de control:<br><ul><li><strong>Toque corto:</strong> Muestra/oculta la gr√°fica.</li><li><strong>Toque largo:</strong> Muestra un men√∫ con 5 opciones r√°pidas</li><li><strong>Deslizar ARRIBA:</strong> Asistente IA de rutas.</li><li><strong>Deslizar ABAJO:</strong> Buscar puntos de inter√©s</li><li><strong>Deslizar DERECHA:</strong> Crear recordatorio r√°pido.</li><li><strong>Deslizar IZQUIERDA:</strong> Crear aviso de radar aqu√≠. Este panel se oculta en las maniobras, pero haciendo una pulsaci√≥n larga en esta zona se muestra si lo necesita en un momento dado</li></ul>', side: "right" } 
                },
                { 
                    element: '#pdrs-ruta-button', 
                    popover: { title: 'Encuentra Puntos de Recarga', description: "Busca cargadores en tu ruta. Es un bot√≥n c√≠clico: <strong>1¬∫ Clic:</strong> Abre filtros. <strong>2¬∫ Clic:</strong> Muestra solo los m√°s econ√≥micos. <strong>3¬∫ Clic:</strong> Limpia el mapa. Esta opci√≥n si se llama desde A√ëADIR PUNTOS funciona tambi√©n estando en viaje, a√±adiendo la parada a √©ste.", side: "top" } 
                },
                { 
                    element: '.radares-ruta-control', 
                    popover: { title: 'Activa Avisos en Ruta', description: "Marca estas casillas para ver los <strong>Radares</strong> y tus <strong>Tareas</strong> (recordatorios personales) que se encuentren en tu trayecto.", side: "top" } 
                },
                
                { 
                    element: '#zoom-in-button',
                    popover: { title: 'Zoom Manual', description: "Usa los botones <strong>'+'</strong> y <strong>'-'</strong> para acercar o alejar el mapa manualmente. El n√∫mero del centro indica el nivel de zoom actual. Si pulsas en ese n√∫mero se conmutar√° entre la inclinacion 0 grados y la definida del modo vista del mapa activo y si haces una pulsaci√≥n larga pondr√° el zoom a nivel 5.5 o 11, para acercar o alejar r√°pidamente", side: "top" }
                },
                { 
                    element: '#zoom-auto-button',
                    popover: { title: 'Zoom Autom√°tico', description: "Activa el modo <strong>'AUTO'</strong> para que el zoom se ajuste seg√∫n tu velocidad, o el modo <strong>'RUTA'</strong> para una vista general fija que permite ver la ruta de forma √°mplia. En LIBRE el zoom lo puede ajustar manualmente y MODO ECO, combina modo AUTO (si la maniobra est√° a menos 2 km o la velocidad es inferior a 70 km/h sino pasa a modo RUTA ", side: "top" }
                },
                { 
                    element: '#zoom-locate-me-button',
                    popover: { title: 'Localizar y Seguir', description: "Pulsa este icono para centrarte en el mapa y activar el seguimiento autom√°tico. P√∫lsalo de nuevo para desactivarlo y explorar libremente durante 30 segundos. No obstante si arrastra la pantalla en tiempo de navegaci√≥n autom√°ticamente se desactiva el seguimiento por 30s.", side: "top" }
                },
                { 
                    element: '#zoom-toggle-button',
                    popover: { title: 'Alternar Vista', description: "Este bot√≥n te permite cambiar r√°pidamente entre una vista cercana a tu coche y una vista general que muestra toda la ruta.", side: "top" }
                },
                { 
                    element: '#map-settings-toggle-button',
                    popover: { title: 'Ajustes de Mapa', description: "Abre un panel para cambiar el <strong>estilo del mapa</strong> (H√≠brido, Sat√©lite, Calles) y el <strong>modo de la c√°mara NORTE, AVANCE, 3D y 3D Relieve (recomendado) </strong>.", side: "top" }
                },
                { 
                    element: '#map-offset-toggle-button',
                    popover: { title: 'Ajustes de Posici√≥n', description: "Abre un panel para <strong>desplazar la posici√≥n del coche</strong> en la pantalla y ajustar manualmente la <strong>inclinaci√≥n (pitch), si pulsa encima del n√∫mero de grados autom√°ticamente se va a los grados predefinidos para ese modo </strong> de la c√°mara (estos datos se mantienen entre sesiones)", side: "top" }
                },
                { 
                    element: '#navigation-map-help-button', 
                    popover: { title: 'Configuraci√≥n y Ayuda', description: "Este bot√≥n abre el panel de <strong>configuraci√≥n avanzada</strong> (rendimiento, suavizado, etc.) y te permite <strong>volver a iniciar esta gu√≠a</strong>. ¬°Buen viaje!", side: "left" } 
                }
            ],
            onHighlightStarted: () => {
                localStorage.setItem('boardingGateTourVisto_v6', 'true'); 
            }
        });
        
        driverObj.drive();
    }    
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.attributeName === 'class') {
                const mapModal = mutation.target;
                const isMapVisible = !mapModal.classList.contains('map-modal-hidden');
                const tourVisto = localStorage.getItem('boardingGateTourVisto_v6');

                if (isMapVisible && !tourVisto) {
                    setTimeout(window.iniciarGuiaInteractivaCompleta, 1500);
                    observer.disconnect();
                }
            }
        });
    });
    const mapModalNode = document.getElementById('reminders-location-map-modal');
    if (mapModalNode) {
        observer.observe(mapModalNode, { attributes: true });
    }
});   

</script>
<div id="map-garage" style="display: none;"></div>     
</body>
</html>
