v1
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BoardingGate</title>
    <link rel="icon" href="https://boardinggate.github.io/Tesla/th.jpeg" type="image/jpeg">
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module"> import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js"; import { getFirestore, doc, setDoc, getDoc, getDocs, deleteDoc, collection } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js"; console.log("Firebase Init Script: STARTING initialization."); const firebaseConfig = {apiKey: "AIzaSyCEAWL1Pj1OMBrGnXLOS79W3iDjMkmTQGw",authDomain: "boardinggate-1df74.firebaseapp.com",databaseURL: "https://boardinggate-1df74-default-rtdb.europe-west1.firebaseio.com",projectId: "boardinggate-1df74",storageBucket: "boardinggate-1df74.appspot.com", messagingSenderId: "771541345352",appId: "1:771541345352:web:0447d72b3383875ac5a47d" };try {  const app = initializeApp(firebaseConfig); window.db = getFirestore(app); window.doc = doc; window.setDoc = setDoc; window.getDoc = getDoc; window.collection = collection; window.getDocs = getDocs; window.deleteDoc = deleteDoc; console.log("Firebase Init Script: SUCCESS Firestore initialized and functions exposed globally. window.db is:", window.db); } catch (e) { console.error("Firebase Init Script: ERROR during initialization!", e); } console.log("Firebase Init Script: END of initialization block."); </script>  
   <script src="//cdn.jsdelivr.net/npm/eruda"></script>
    <script>eruda.init();</script>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script src="https://unpkg.com/leaflet-geometryutil@0.10.3/src/leaflet.geometryutil.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>

<style>
 body {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    background-color: #ABAB99;
    margin: 0;
    overflow-x: hidden;
}
body.dark-mode {
    background-color: #92927E;
}
main {
    position: relative;
    margin: 0 auto 0.5rem 60px;
    margin-top: 76px;
    background-color: transparent;
    border-radius: 0.75rem;
    padding: 16px;
    min-height: 400px;
    max-width: 984px;
    width: 100%;
    transition: margin-top 0.5s ease-in-out;
}
footer {
    margin: 0.5rem auto;
    text-align: center;
    max-width: 984px;
    width: 100%;
    display: block;
    background-color: #ABAB99;
    margin-left: 145px;
    transition: margin-top 0.5s ease-in-out;
}
body.dark-mode footer {
    background-color: #92927E;
}
.footer-content {
    color: #5C5C47;
    padding: 0.5rem;
    margin: 0 auto;
    max-width: 100%;
    position: relative;
}
.footer-subtext {
    font-size: 0.75rem;
    color: #5C5C47;
    margin-top: 0.25rem;
    text-align: center;
}
.footer-link-green {
    color: #5C5C47;
    text-decoration: none;
    transition: color 0.2s ease;
}
.footer-link-green:hover {
    color: #5C5C47;
}
.footer-line {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
}
.hidden {
    display: none !important;
}
.footer-hidden {
    display: none !important;
}
.header-container {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    background-color: #ABAB99;
    padding: 0.5rem;
}
body.dark-mode .header-container {
    background-color: #92927E;
}
.header-logo {
    width: 100px;
    height: 70px;
    transition: filter 0.2s ease;
}
body.dark-mode .header-logo {
    filter: brightness(85%);
}
.title-container {
    background-color: #ABAB99;
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    display: inline-block;
}
body.dark-mode .title-container {
    background-color: #92927E;
}
.header-container h1 {
    color: #5C5C47;
}
.version-text {
    font-size: 0.75rem;
    color: #5C5C47;
    font-weight: normal;
}
#bookmark-grid {
    display: grid;
    grid-template-columns: repeat(6, minmax(120px, 1fr));
    gap: 15px;
    background-color: transparent;
    border-radius: 0.75rem;
    position: relative;
    width: 100%;
    max-width: 984px;
    margin: 0 auto 0 85px;
    transition: all 0.3s ease;
}
#bookmark-grid > div {
    height: auto;
    aspect-ratio: 16 / 9;
    transition: all 0.3s ease;
}
.bookmark-item {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border-radius: 0.5rem;
    transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease;
    box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1);
    position: relative;
    cursor: pointer;
}
.bookmark-item:hover:not(.editing-active *):not(.assignment-active *):not(.dragging *):not(.editing-target *):not(.keyword-assignment-active *) {
    transform: scale(1.05) translateY(-1px);
    box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.6), -6px -6-12px rgba(255, 255, 255, 0.15);
}
.bookmark-item img {
    image-rendering: crisp-edges;
    width: 36px;
    height: auto;
    max-width: 40px;
    border-radius: 0.25rem;
}
.bookmark-name {
    font-size: clamp(0.85rem, 1.5vw, 1.15rem);
    font-weight: bold;
    color: #333;
    text-align: center;
    margin-top: 4px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
}
body.dark-mode .bookmark-item {
    filter: brightness(60%);
}
.empty-slot {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    border: 1px dashed #ccc;
    border-radius: 0.5rem;
    background-color: rgba(200, 200, 200, 0.1);
    color: #aaa;
    transition: background-color 0.2s ease, outline 0.2s ease, box-shadow 0.2s ease;
    cursor: default;
}
.empty-slot span {
    font-size: 2rem;
    pointer-events: none;
}
body.dark-mode .empty-slot {
    border-color: #666;
    color: #777;
    background-color: rgba(100, 100, 100, 0.2);
}
.toggle-image, .toggle-sign {
    width: 135px;
    height: 74px;
    margin-bottom: 2px;
    box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.4);
    border: 1px solid #7c7c68;
    left: 10px;
    z-index: 1000;
    transition: background-color 0.2s ease, filter 0.2s ease, top 0.3s ease, border 0.2s ease;
    border-radius: 35px;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    display: flex;
    position: fixed;
    top: 90px;
    background-color: #ABAB99;
}
.toggle-sign {
    font-weight: bold;
    font-size: 1.25rem;
    color: #000000;
    text-align: center;
}
.toggle-sign .sign {
    font-size: 1.5rem;
    margin-right: 2px;
}
.toggle-sign img, .toggle-image img {
    max-width: 70%;
    max-height: 70%;
    object-fit: contain;
}
.toggle-sign:not(.range-toggle):not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *):hover {
    background-color: #D9A066;
}
.toggle-sign.range-toggle:not([data-state="hidden"]):not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *):hover {
    background-color: #D9A066;
}
.toggle-image:hover {
    filter: brightness(80%);
}
.toggle-sign.range-toggle[data-state="hidden"] {
    background-color: #ABAB99;
    color: #7F7F7F;
}
body.dark-mode .toggle-sign.range-toggle[data-state="hidden"] {
    background-color: #ABAB99;
    color: #A0A0A0;
}
body.dark-mode .toggle-sign:not(.range-toggle):not(#password-toggle-button), body.dark-mode .toggle-image, body.dark-mode .toggle-sign.range-toggle:not([data-state="hidden"]) {
    filter: brightness(85%);
    background-color: #ABAB99;
}
body.dark-mode .toggle-sign:not(.range-toggle):hover:not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *), body.dark-mode .toggle-sign.range-toggle:not([data-state="hidden"]):hover:not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *) {
    background-color: #ABAB99;
}
.scroll-toggle-button {
    position: fixed;
    width: 110px !important;
    height: clamp(75px, 20vw, 130px) !important;
    background-color: #ABAB99;
    border-radius: 60px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    padding: clamp(10px, 2vw, 20px);
    cursor: pointer;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.4) !important;
    border: 1px solid #808080 !important;
    z-index: 1001;
    transition: background-color 0.2s ease;
    left: 10px;
    top: 10px;
}
.scroll-toggle-button:hover {
    background-color: #668B8B;
}
.scroll-toggle-button svg {
    width: clamp(24px, 4vw, 32px);
    height: clamp(24px, 4vw, 32px);
    stroke: #E6E6DC;
}
.arrow-button {
    width: clamp(36px, 6vw, 48px);
    height: clamp(36px, 6vw, 48px);
    background-color: #668B8B;
    border-radius: 50%;
    display: flex;
    align-items: right;
    justify-content: center;
    cursor: pointer;
    box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    transition: background-color 0.2s ease;
}
.arrow-button:hover {
    background-color: #5C5C47;
}
.arrow-button svg {
    stroke: #E6E6DC;
}
#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button {
    width: auto !important;
    height: auto !important;
    background-color: transparent !important;
    border: none !important;
    box-shadow: none !important;
    padding: 5px !important;
    position: absolute !important;
    top: 37px !important;
    z-index: 900 !important;
    cursor: pointer;
    border-radius: 50%;
    transition: transform 0.1s ease, background-color 0.2s ease, box-shadow 0.2s ease, border 0.2s ease;
}
#config-button {
    left: 185px !important;
}
#personal-button {
    left: 260px !important;
}
#radar-button {
    left: 330px !important;
}
#home-button {
    left: 400px !important;
}
#reload-button {
    left: 470px !important;
}
#keyword-assignment-button {
    left: 555px !important;
}
#password-toggle-button {
    left: 1080px !important;
    top: 25px;
}
#info-button {
    left: 1027px !important;
    max-width: 30px !important;
    max-height: 30px !important;
}
#versions-button {
    left: 969px !important;
    max-width: 30px !important;
    max-height: 30px !important;
}
#config-button img {
    max-width: 52px !important;
    max-height: 52px !important;
    width: 52px;
    height: 52px;
    object-fit: contain;
    display: block;
    filter: none !important;
}
#personal-button img, #radar-button img, #home-button img, #reload-button img, #keyword-assignment-button img {
    max-width: 46px !important;
    max-height: 46px !important;
    width: 46px;
    height: 46px;
    object-fit: contain;
    display: block;
    filter: none !important;
}
#versions-button img, #info-button img, #password-toggle-button img {
    max-width: 53px !important;
    max-height: 37px !important;
    width: 40px;
    height: 37px;
    object-fit: contain;
    display: block;
}
#password-toggle-button img {
    filter: brightness(85%) !important;
    top: 25px;
}
#versions-button img {
    transition: opacity 0.5s ease;
}
#config-button:hover, #personal-button:hover, #radar-button:hover, #home-button:hover, #reload-button:hover, #keyword-assignment-button:hover:not(.active), #password-toggle-button:hover, #versions-button:hover:not(.versions-icon-dimmed), #info-button:hover {
    transform: scale(1.1);
    background-color: rgba(255, 255, 255, 0.2);
}
#personal-button.editing {
    border: 3px solid yellow !important;
    box-shadow: 0 0 10px yellow !important;
}
#personal-button.assigning {
    border: 3px solid cyan !important;
    box-shadow: 0 0 10px cyan !important;
}
#keyword-assignment-button.active {
    border: 3px solid yellow !important;
    box-shadow: 0 0 10px yellow !important;
    transform: scale(1.05);
    background-color: transparent !important;
}
body.dark-mode #keyword-assignment-button.active {
    border-color: yellow !important;
    box-shadow: 0 0 10px yellow !important;
}
.keyword-assignment-active .grid-cell:hover:not(.editing-active *):not(.assignment-active *):not(.dragging *):not(.editing-target *):not(.keyword-assigned-highlight) {
    transform: scale(1.05) translateY(-1px);
    box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.6), -6px -6-12px rgba(255, 255, 255, 0.15);
    outline: 3px dashed #10B981;
    cursor: crosshair;
}
.keyword-assignment-active .grid-cell.editing-target {
    outline: 3px solid #10B981 !important;
    outline-offset: 1px;
    box-shadow: 0 0 8px #10B981;
}
.keyword-assignment-active .grid-cell.keyword-assigned-highlight {
    outline: 3px solid yellow !important;
    outline-offset: 1px;
    box-shadow: 0 0 8px yellow;
    cursor: crosshair;
}
#grid-filter-container {
    position: absolute;
    top: 43px;
    left: 615px;
    display: flex;
    align-items: center;
    z-index: 900;
}
#grid-filter-input {
    padding: 8px 12px;
    border: 1px solid #7c7c68;
    border-radius: 4px;
    font-size: 1.3rem;
    font-weight: bold;
    height: 45px;
    width: 160px;
    background-color: #f0f0e0;
}
body.dark-mode #grid-filter-input {
    background-color: #a0a090;
    color: #e0e0e0;
    border-color: #666;
}
#clear-filter-button {
    background: none;
    border: none;
    cursor: pointer;
    padding: 0 8px;
    margin-left: -35px;
    font-size: 1.6rem;
    color: #555;
    height: 40px;
    line-height: 40px;
    z-index: 901;
    display: none;
}
body.dark-mode #clear-filter-button {
    color: #bbb;
}
#user-id-display {
    position: absolute;
    top: -25px;
    right: -69px;
    font-weight: bold;
    font-size: 1.1rem;
    color: #5C5C47;
    padding: 4px 4px;
    background-color: rgba(171, 171, 153, 0.7);
    border-radius: 1px;
    z-index: 800;
    white-space: nowrap;
    text-align: right;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4);
}
body.dark-mode #user-id-display {
    color: #E6E6DC;
    background-color: rgba(146, 146, 126, 0.7);
    opacity: 0.7;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6);
}
.notices-icon-container {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    max-width: 984px;
    margin: 0 auto;
    margin-left: 165px;
    position: relative;
    transition: margin-top 0.5s ease-in-out;
}
.notices-container {
    flex-grow: 1;
    padding: 0.5rem;
    border: none;
    border-radius: 0.5rem;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0;
    margin-left: 2px;
    height: 3rem;
}
.notice-wrapper {
    padding: 0.5rem;
    height: 1.5rem;
    flex-grow: 1;
    overflow: hidden;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
}
.notice {
    color: #E6E6DC;
    font-size: 1.3rem;
    font-weight: bold;
    white-space: nowrap;
    text-align: center;
    opacity: 0;
    animation: fadeInOut 14s infinite;
}
@keyframes fadeInOut {
    0% {
        opacity: 1;
    }
    10% {
        opacity: 1;
    }
    90% {
        opacity: 1;
    }
    100% {
        opacity: 0;
    }
}
.notice-off-icon {
    width: auto;
    height: clamp(2rem, 5vw, 3rem);
    margin-right: 10px;
    align-self: center;
    cursor: pointer;
    transition: filter 0.3s ease;
}
body.dark-mode .notice-off-icon {
    filter: brightness(85%);
}
#reminder-button {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: fixed;
    background-color: #ABAB99;
}
#reminder-button img {
    object-fit: contain;
}
#reminder-button .reminder-count {
    position: absolute;
    top: 6px;
    left: 8px;
    background-color: #EF4444;
    color: #FFFFFF;
    border-radius: 55%;
    padding: 4px 10px;
    font-size: 1.1rem;
    font-weight: bold;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1500;
    min-width: 1.9rem;
    max-width: 2.5rem;
    text-align: center;
}
.reminder-count-globe {
    position: fixed;
    top: 10px;
    left: 10px;
    background-color: #2563EB;
    color: white;
    border-radius: 65%;
    padding: 10px 15px;
    font-size: 1.3rem;
    font-weight: bold;
    z-index: 1500;
    transition: margin-top 0.5s ease-in-out;
}
#unified-reminder-window {
    position: fixed;
    top: 35px;
    left: 180px;
    transform: none;
    background-color: #FFFF99;
    border-radius: 1.5rem;
    border: 2px solid #ABAB99;
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
    z-index: 7000;
    max-width: 550px;
    width: 95%;
    max-height: 85vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    transition: opacity 0.3s ease-out, transform 0.3s ease-out;
}
#unified-reminder-window:not(.visible) {
    opacity: 0;
    transform: scale(0.9);
    pointer-events: none;
}
#unified-reminder-window.visible {
    opacity: 1;
    transform: scale(1);
    pointer-events: auto;
}
.reminder-count-header {
    padding: 0.8rem 1.5rem;
    text-align: center;
    font-weight: bold;
    color: #0000FF;
    border-bottom: 1px solid #ABAB99;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 0px 10px;
    position: relative;
}
.reminder-title-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    flex-grow: 1;
}
.reminder-title-container > span:first-child {
    font-size: 1.3rem;
}
.reminder-title-container .swipe-hint {
    font-size: smaller;
}
#reminder-swiper-container {
    display: flex;
    overflow-x: auto;
    scroll-snap-type: x mandatory;
    -webkit-overflow-scrolling: touch;
    scroll-behavior: smooth;
    flex-grow: 1;
    touch-action: pan-x;
}
.reminder-slide {
    flex: 0 0 100%;
    scroll-snap-align: start;
    padding: 1.5rem;
    box-sizing: border-box;
    display: flex;
    flex-direction: row;
    gap: 1rem;
    overflow-y: auto;
    align-items: flex-start;
    max-height: calc(85vh - 60px);
}
.reminder-slide-content {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    min-width: 0;
}
.reminder-slide .reminder-content-scrollable {
    max-height: 30vh;
    overflow-y: auto;
    margin-bottom: 1rem;
    word-wrap: break-word;
    overflow-wrap: break-word;
    text-align: left;
    padding-right: 5px;
    flex-grow: 1;
}
.reminder-slide .reminder-text {
    margin: 0 0 0.5rem 0;
    font-size: 1.6rem;
    font-weight: bold;
    color: #0000FF;
}
.reminder-slide .reminder-details {
    margin: 0.2rem 0;
    font-size: 1.15rem;
    font-weight: bold;
    color: #0000FF;
}
.reminder-slide .button-group {
    display: flex;
    flex-direction: column;
    justify-content: center;
    gap: 0.5rem;
    margin-top: auto;
    padding-top: 1rem;
    flex-shrink: 0;
}
.reminder-slide button {
    padding: 0.5rem 1rem;
    border-radius: 0.25rem;
    cursor: pointer;
    font-size: 0.9rem;
    width: 100%;
    background-color: #D1D5DB;
}
.reminder-slide button.cancel {
    background-color: #EF4444;
    color: #FFFFFF;
    font-weight: bold;
    height: 70px;
    font-size: 1.2rem;
    order: 1;
}
.reminder-slide button.modify {
    background-color: #10B981;
    font-weight: bold;
    height: 60px;
    font-size: 1.2rem;
    color: #FFFFFF;
    order: 5;
}
.reminder-slide button.postpone {
    background-color: #F59E0B;
    font-weight: bold;
    height: 60px;
    font-size: 1.2rem;
    color: #FFFFFF;
    order: 3;
}
.reminder-slide button.adjust-time-0001 {
    background-color: #4F4F4F;
    color: #FFFFFF;
    font-weight: bold;
    height: 60px;
    font-size: 1.2rem;
    order: 2;
    margin-top: 0.5rem;
}
.reminder-slide button.cancel-cyclic {
    background-color: #8B0000;
    color: #FFFFFF;
    font-weight: bold;
    height: 60px;
    font-size: 1.2rem;
    order: 4;
    margin-top: 0.5rem;
}
.reminder-map-preview-container {
    flex-shrink: 0;
    width: 150px;
    display: flex;
    align-items: center;
    justify-content: center;
    align-self: stretch;
}
.reminder-map-preview {
    width: 100%;
    height: 100%;
    min-height: 100px;
    max-height: 25vh;
    border-radius: 0.5rem;
}
#hide-all-reminders-button {
    background: none;
    border: none;
    color: #0000FF;
    font-size: 1rem;
    font-weight: bold;
    cursor: pointer;
    padding: 0.2rem 0.5rem;
    position: absolute;
    right: 1rem;
    top: 50%;
    transform: translateY(-50%);
    z-index: 3001;
}
#hide-all-reminders-button:hover {
    text-decoration: underline;
}
.modal-top-buttons {
    display: flex;
    justify-content: space-between;
    gap: 1rem;
    margin-bottom: 1.5rem;
    flex-wrap: wrap;
}
.modal-top-buttons button {
    flex: 1 1 auto;
    min-width: 100px;
    background-color: #D1D5DB;
}
.reminder-modal, .help-modal, .edit-info-modal, .choice-modal, .edit-modal, .reminder-table-modal, .postpone-options, .saved-locations-modal, #reorder-stages-modal, #simulation-modal, #locations-preview-modal, #deviation-modal, #arrival-stats-modal, #simulation-speed-modal {
    z-index: 2000;
    background-color: #DAC8A0;
    padding: 1.0rem;
    border-radius: 0.3rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
}
#arrival-stats-modal {
    top: 5px;
    transform: translateX(-50%);
    z-index: 12000;
}
#arrival-stats-modal .eta-deviation {
    font-size: 2.1em;
    font-weight: bold;
    margin-left: 8px;
    vertical-align: middle;
}
#arrival-stats-modal .eta-deviation.positive {
    color: #EF4444;
}
#arrival-stats-modal .eta-deviation.negative {
    color: #013220;
}
#deviation-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #E6D6A8;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 0 15px rgba(0,0,0,0.5);
    z-index: 9000;
    text-align: center;
    max-width: 450px;
    width: 90%;
}
#deviation-modal p#deviation-modal-message {
    margin-bottom: 15px;
    font-size: 1.1rem;
    color: #333;
}
#deviation-modal button {
    padding: 10px 15px;
    margin: 0 5px;
    border-radius: 5px;
    font-size: 1rem;
    font-weight: bold;
    cursor: pointer;
    border: none;
}
#deviation-modal button#deviation-accept {
    background-color: #28a745;
    color: white;
}
#deviation-modal button#deviation-delete-stage {
    background-color: #EF4444;
    color: white;
}
#address-suggestions-modal {
    position: fixed;
    left: 5%;
    width: 90%;
    transform: none;
    background-color: #E6D6A8;
    padding: 1rem;
    border-radius: 0.5rem;
    box-shadow: 0 4px 10px rgba(0,0,0,0.25);
    z-index: 9000;
    display: flex;
    flex-direction: column;
    border: 1px solid #C0B080;
}
#address-suggestions-modal h2 {
    font-size: 1.1rem;
    font-weight: bold;
    text-align: center;
    margin-bottom: 0.75rem;
    color: #333;
}
#address-suggestions-list {
    list-style: none;
    padding: 0;
    margin: 0 0 0.75rem 0;
    overflow-y: auto;
    border: 1px solid #B0A898;
    border-radius: 4px;
    background-color: #D8CEC0;
}
#address-suggestions-list li {
    padding: 8px 12px;
    border-bottom: 1px solid #C8B890;
    cursor: pointer;
    font-size: 1.1rem;
    font-weight: bold;
    color: #F5F5DC;
    background-color: #5C5C47;
}
#address-suggestions-list li:last-child {
    border-bottom: none;
}
#address-suggestions-list li:hover {
    background-color: #6B6B56;
}
#locations-preview-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90vw;
    height: 90vh;
    max-width: none;
    max-height: none;
    display: flex;
    flex-direction: column;
    z-index: 7000;
}
#locations-preview-map-container {
    flex-grow: 1;
    border: 1px solid #ccc;
    border-radius: 0.5rem;
    margin-bottom: 1rem;
}
#locations-preview-modal h2 {
    font-size: 1.3rem;
    font-weight: bold;
    text-align: center;
    margin-bottom: 1rem;
    color: #333;
}
#close-locations-preview {
    padding: 0.7rem 1rem;
    font-size: 1.1rem;
    background-color: #4A5568;
    color: white;
    border: 1px solid #2D3748;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
}
#close-locations-preview:hover {
    background-color: #2D3748;
}
#address-suggestions-modal .modal-top-buttons button#close-address-suggestions-modal {
    background-color: #4A5568 !important;
    color: white !important;
    border: 1px solid #2D3748 !important;
    font-weight: bold !important;
}
#address-suggestions-modal .modal-top-buttons button#close-address-suggestions-modal:hover {
    background-color: #2D3748 !important;
}
#reorder-stages-modal {
    position: fixed !important;
    top: 30px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    width: 80vw !important;
    height: 90vh !important;
    max-width: none !important;
    max-height: none !important;
    z-index: 8600 !important;
    display: flex;
    flex-direction: column;
    background-color: #DAC8A0;
}
#saved-routes-modal, #save-route-prompt-modal {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    width: 90%;
    z-index: 8600;
    max-height: calc(100vh - 20px);
    overflow-y: auto;
}
#simulation-modal {
    position: fixed;
    top: 10px;
    right: 40px;
    left: auto;
    transform: none;
    background-color: #E6D6A8;
    padding: 1.5rem;
    border-radius: 1rem;
    box-shadow: 0 6px 15px rgba(0,0,0,0.3);
    z-index: 8800;
    max-width: 450px;
    width: calc(100% - 80px);
    max-height: calc(100vh - 20px);
    display: flex;
    flex-direction: column;
}
#simulation-speed-modal {
    position: fixed;
    top: 50px;
    left: 50%;
    transform: translateX(-50%);
    width: 90%;
    max-width: 400px;
    z-index: 9100;
    background-color: #F5E1A9;
    padding: 1.5rem;
    border-radius: 1rem;
    box-shadow: 0 6px 15px rgba(0,0,0,0.3);
    text-align: center;
}
#simulation-speed-modal h2 {
    font-size: 1.2rem;
    font-weight: bold;
    margin-bottom: 1rem;
    color: #333;
}
#simulation-speed-modal input {
    width: 100px;
    padding: 0.5rem;
    margin-bottom: 1rem;
    font-size: 1.2rem;
    text-align: center;
    border: 1px solid #ccc;
    border-radius: 4px;
}
#reorder-stages-modal button {
    background-color: #D1D5DB;
}
#reorder-stages-modal #confirm-reorder-stages {
    background-color: #28a745;
    color: white;
}
#reorder-stages-modal #cancel-reorder-stages {
    background-color: #6c757d;
    color: white;
}
#saved-routes-modal {
    max-width: 500px;
    z-index: 8000;
}
#save-route-prompt-modal {
    max-width: 800px;
    z-index: 8500;
}
#simulation-modal #close-simulation-modal {
    background-color: #2563EB;
    color: white;
    position: absolute;
    top: 10px;
    left: 10px;
    height: 35px;
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
    min-height: unset;
    min-width: unset;
    width: auto;
    line-height: 1;
}
.postpone-options {
    background-color: #F5E1A9 !important;
    z-index: 7500 !important;
    top: 10px !important;
    transform: translateX(-50%) !important;
}
.versions-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    display: flex;
    justify-content: center;
    align-items: flex-start;
    z-index: 5000;
    padding-top: 50px;
}
.versions-modal-content {
    background-color: #DAC8A0;
    padding: 1.5rem;
    border-radius: 0.5rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
    width: 85%;
    max-width: 900px;
    max-height: 85vh;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
}
.versions-modal-content h2 {
    font-size: 1.5rem;
    font-weight: bold;
    margin-bottom: 1rem;
    color: #111827;
    text-align: center;
}
.versions-modal-content .modal-top-buttons {
    margin-bottom: 1rem;
}
.versions-modal-content pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow-wrap: break-word;
    font-size: 1rem;
    line-height: 1.4;
    color: #333;
    margin-bottom: 1.5rem;
    padding: 0.8rem;
    background-color: #f0f0e0;
    border-radius: 0.25rem;
    max-height: calc(85vh - 150px);
    overflow-y: auto;
}
.versions-modal-content button {
    display: block;
    width: 100%;
    padding: 0.75rem 1rem;
    border-radius: 0.25rem;
    cursor: pointer;
    font-size: 1.1rem;
    text-align: center;
    border: none;
    background-color: #2563EB;
    color: white;
}
.versions-modal-content button:hover {
    background-color: #1D4ED8;
}
.reminder-modal {
    position: fixed;
    top: 1%;
    left: 50%;
    transform: translate(-50%, 0);
    max-width: 96%;
    width: 95%;
    max-height: 95vh;
    overflow-y: auto;
    font-weight: bold;
    font-size: 1.3rem;
}
.reminder-table-modal button.visto-prox {
    background-color: #EF4444;
    font-size: 0.9rem;
    color: #FFFFFF;
    border: 1px solid #A00000;
    font-weight: bold;
}
.reminder-table-modal button.visto-prox:hover {
    background-color: #D00000;
}
.help-modal, .edit-info-modal {
    position: fixed;
    top: 1%;
    left: 50%;
    transform: translate(-50%, 1%);
    max-width: 910px;
    width: 98%;
    max-height: 96vh;
    overflow-y: auto;
    font-size: 1.10rem;
    z-index: 5500;
}
#reminders-map-help-modal-instance {
    z-index: 7000 !important;
    top: 10px !important;
    transform: translateX(-50%) !important;
}
.choice-modal {
    position: fixed;
    top: 1%;
    left: 50%;
    transform: translate(-50%, 1%);
    max-width: 540px;
    width: 95%;
    max-height: 98vh;
    overflow-y: auto;
    font-size: 1.10rem;
    z-index: 5500;
}
.reminder-table-modal {
    position: fixed;
    top: 30px;
    left: 35px;
    transform: translateY(0);
    max-width: 99%;
    width: 1090px;
    max-height: 90vh;
    overflow-y: auto;
    background-color: #E6D6A8;
    border-radius: 1.5rem;
}
.reminder-table-modal h2 {
    font-size: 1.8rem !important;
    font-weight: bold !important;
}
.reminder-table-modal #view-all-locations-map {
    white-space: nowrap !important;
}
.edit-modal {
    position: fixed;
    top: 5%;
    left: 50%;
    transform: translate(-50%, 0);
    width: 75%;
    max-width: 900px;
    border: 5px solid #A0522D;
    background-color: #EADDCA;
    z-index: 6000;
}
.modal h2, .modal h3 {
    font-weight: bold;
    margin-bottom: 1rem;
    color: #111827;
}
.reminder-modal h2, .help-modal h2, .edit-info-modal h2, .choice-modal h2, .edit-modal h2, .saved-locations-modal h2, #reorder-stages-modal h2, #simulation-modal h2, #deviation-modal h2, #arrival-stats-modal h2, #simulation-speed-modal h2 {
    font-size: 1.5rem;
}
.reminder-modal label, .help-modal label, .edit-info-modal label, .choice-modal label, .edit-modal label, .saved-locations-modal label {
    display: block;
    margin-bottom: 0.25rem;
    font-weight: 500;
    color: #374151;
    font-size: 1.1rem;
}
.reminder-modal button, .help-modal button, .edit-info-modal button, .choice-modal button, .edit-modal button, .reminder-table-modal button, .versions-modal-content button, .saved-locations-modal button, #reorder-stages-modal button, #simulation-modal button, #address-suggestions-modal button, #deviation-modal button, #arrival-stats-modal button, #simulation-speed-modal button {
    padding: 0.75rem 1rem;
    border-radius: 0.25rem;
    cursor: pointer;
    font-size: 1.1rem;
    flex: 1;
    text-align: center;
    min-width: 100px;
    border: none;
    background-color: #D1D5DB;
    min-height: 60px;
}
.reminder-modal .modal-top-buttons button {
    height: 70px;
    min-height: 70px;
}
.edit-info-modal #close-edit-info, .help-modal #close-help, #reminders-map-help-modal-instance #close-reminders-map-help-instance, #simulation-modal #close-simulation-modal {
    background-color: #2563EB;
    color: white;
}
.edit-info-modal #close-edit-info:hover, .help-modal #close-help:hover, #reminders-map-help-modal-instance #close-reminders-map-help-instance:hover, #simulation-modal #close-simulation-modal:hover {
    background-color: #1D4ED8;
}
.reminder-modal textarea#reminder-text {
    width: 100%;
    padding: 0.5rem;
    margin-bottom: 0.3rem;
    border: 1px solid #D1D5DB;
    border-radius: 0.25rem;
    font-size: 1.4rem;
    font-weight: bold;
    text-transform: uppercase;
}
.reminder-modal input#reminder-time {
    max-width: 120px;
    width: auto;
}
.reminder-modal input#reminder-date {
    max-width: 160px;
    width: auto;
}
.reminder-modal input#reminder-interval {
    max-width: 100px;
    width: auto;
}
.reminder-modal input#reminder-radius {
    max-width: 120px;
    width: auto;
}
.reminder-modal input[type="text"], .reminder-modal input[type="number"] {
    padding: 0.5rem;
    margin-bottom: 0.3rem;
    border: 1px solid #D1D5DB;
    border-radius: 0.25rem;
    font-size: 1.5rem;
    text-align: center;
}
.reminder-modal .form-grid {
    display: grid;
    grid-template-columns: auto auto auto 1fr;
    gap: 1rem;
    align-items: end;
    margin-bottom: 1rem;
}
label[for="reminder-interval"] {
    line-height: 1.2;
}
.location-controls-group {
    grid-column: 4 / 5;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: flex-start;
    gap: 0.5rem;
    margin-top: 0;
}
.location-controls-group label {
    margin-bottom: 0;
}
.location-controls-group input[type="checkbox"] {
    margin-right: 0.2rem;
}
.location-controls-group label[for="reminder-radius"] {
    margin-left: 0;
}
#expand-map-button {
    padding: 0.3rem 0.6rem !important;
    font-size: 1.3rem !important;
    height: auto !important;
    flex-shrink: 0;
    background-color: #668B8B !important;
    color: white !important;
    border: none !important;
    border-radius: 0.25rem !important;
    min-width: unset !important;
    flex: unset !important;
    margin-left: 0.5rem;
}
#expand-map-button:hover {
    background-color: #5C5C47 !important;
}
#location-map-container {
    grid-column: 1 / -1;
    width: 100%;
    border: 1px solid #ccc;
    border-radius: 0.25rem;
    background-color: #eee;
    position: relative;
    margin-top: 0.5rem;
    display: none;
    transition: height 0.3s ease-in-out;
}
#location-map-container.preview {
    display: block !important;
    height: 65px;
}
#location-map-container.expanded {
    display: block !important;
    height: 360px;
}
#reduce-map-button, #locate-me-button {
    position: absolute;
    top: 5px;
    z-index: 1001;
    padding: 0.8rem 1rem;
    font-size: 1rem;
    font-weight: bold;
    background-color: rgba(255, 255, 255, 0.9);
    border: 1px solid #777;
    border-radius: 4px;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0,0,0,0.25);
    transition: background-color 0.2s ease;
}
#reduce-map-button:hover, #locate-me-button:hover {
    background-color: rgba(230, 230, 230, 0.95);
}
#reduce-map-button {
    right: 5px;
}
#locate-me-button {
    right: calc(5px + 135px + 15px);
}
.reminder-modal .full-width {
    grid-column: 1 / -1;
}
.reminder-modal .days-group {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
    grid-column: 1 / -1;
    margin-top: 1rem;
}
.reminder-modal .days-group label {
    font-size: 1.1rem;
    flex: 0 0 auto;
}
.reminder-modal button[type="submit"] {
    background-color: #2563EB;
    color: #FFFFFF;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.6rem;
}
.reminder-modal button[type="submit"] span#countdown-save {
    font-size: 1.6rem;
    font-weight: bold;
    justify-content: right;
    color: #e6e6dc;
}
.reminder-modal button[type="button"] {
    background-color: #D1D5DB;
    color: #111827;
}
#saved-routes-modal #close-saved-routes-modal, #config-modal #config-close-modal, #save-route-prompt-modal #cancel-save-route, #simulation-speed-modal #cancel-simulation-speed, .postpone-options #cancel-postpone {
    background-color: blue !important;
    color: white !important;
    border: 1px solid #2D3748 !important;
    font-weight: bold !important;
}
#saved-routes-modal #close-saved-routes-modal:hover, #config-modal #config-close-modal:hover, #save-route-prompt-modal #cancel-save-route:hover, #simulation-speed-modal #cancel-simulation-speed:hover, .postpone-options #cancel-postpone:hover {
    background-color: #2D3748 !important;
}
#simulation-speed-modal #confirm-simulation-speed {
    background-color: #28a745 !important;
    color: white !important;
}
.speech-button {
    background-color: #668B8B;
    color: white;
    border: none;
    border-radius: 0.25rem;
    padding: 0.5rem;
    cursor: pointer;
    margin-left: 0.5rem;
    font-size: 1rem;
    vertical-align: top;
}
.speech-button:hover {
    background-color: #5C5C47;
}
.speech-status {
    font-size: 0.85rem;
    color: #ABAB99;
    margin-top: 0.1rem;
    min-height: 1em;
}
#auto-save-timer {
    color: #1E40AF;
    grid-column: 1 / -1;
    text-align: center;
}
.reminder-table-modal table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 1rem;
}
.reminder-table-modal tbody tr {
    cursor: pointer;
    transition: background-color: 0.1s ease;
}
.reminder-table-modal tbody tr:hover {
    background-color: rgba(0, 0, 0, 0.05) !important;
}
.reminder-table-modal th, .reminder-table-modal td {
    padding: 0.5rem;
    border: 1px solid #1E3A8A;
    font-size: 1.1rem;
    text-align: center;
    vertical-align: middle;
}
.reminder-table-modal td.text-column {
    text-align: left;
}
.reminder-table-modal th {
    background-color: #E5E7EB;
    font-weight: bold;
}
.reminder-table-modal td.date-column {
    white-space: nowrap;
}
.reminder-table-modal td:first-child {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.3rem;
    border: none;
}
.reminder-table-modal td:first-child button {
    padding: 0.6rem;
    font-size: 0.9rem;
    width: 90%;
    flex: 0 0 auto;
    margin: 0;
    height: 60px;
    min-height: unset;
    line-height: 1.2;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #D1D5DB;
    border: 1px solid #4A5568;
}
.reminder-table-modal button.modify {
    background-color: #10B981;
    font-size: 1rem;
    color: #FFFFFF;
    height: 60px;
    border: 1px solid #008000;
    font-weight: bold;
}
.reminder-table-modal button.modify:hover {
    background-color: #008000;
}
.reminder-table-modal button.delete {
    background-color: #EF4444;
    font-size: 0.9rem;
    color: #FFFFFF;
    border: 1px solid #A00000;
    font-weight: bold;
}
.reminder-table-modal button.delete:hover {
    background-color: #D00000;
}
.reminder-table-modal button.postpone {
    background-color: #F59E0B;
    font-size: 0.9rem;
    color: #FFFFFF;
    border: 1px solid #D97706;
    font-weight: bold;
}
.reminder-table-modal button.postpone:hover {
    background-color: #D97706;
}
.reminder-table-modal button.cancel-cyclic-table {
    background-color: #8B0000;
    font-size: 0.9rem;
    color: #FFFFFF;
    border: 1px solid #580000;
    font-weight: bold;
}
.reminder-table-modal button.cancel-cyclic-table:hover {
    background-color: #580000;
}
.reminder-table-modal #close-reminders-bottom, .reminder-table-modal #close-reminders-top {
    padding-left: 3rem;
    padding-right: 3rem;
    background-color: #2563EB;
    color: white;
    padding: 0.75rem 3rem;
    border-radius: 0.5rem;
    font-size: 1.25rem;
    font-weight: bold;
    border: 2px solid #1E3A8A;
    cursor: pointer;
    transition: background-color 0.2s ease;
    display: inline-flex;
    align-items: center;
}
.reminder-table-modal #close-reminders-bottom:hover, .reminder-table-modal #close-reminders-top:hover {
    background-color: #1D4ED8;
}
.reminder-table-modal .bottom-button-container {
    display: flex;
    justify-content: flex-end;
    margin-top: 1rem;
}
.choice-modal .personalization-options {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    align-items: stretch;
    margin-bottom: 1.5rem;
}
.choice-modal .personalization-options button {
    font-weight: bold;
    width: 100%;
    background-color: #D1D5DB;
}
.choice-modal button.choice-edit {
    background-color: #ffc107;
    color: #333;
}
.choice-modal button.choice-assign {
    background-color: #17a2b8;
    color: white;
}
.choice-modal button.choice-help {
    background-color: #007bff;
    color: white;
}
.choice-modal button.choice-cancel {
    background-color: #6c757d;
    color: white;
}
.choice-modal .footer-buttons {
    display: flex;
    justify-content: center;
    gap: 1rem;
    margin-top: 1rem;
}
.choice-modal .footer-buttons button {
    flex: 0 1 auto;
    min-width: 120px;
    background-color: #D1D5DB;
}
.edit-modal h2 {
    font-size: 1.4rem;
    margin-bottom: 1rem;
    color: #333;
    font-weight: bold;
    text-align: center;
}
.edit-modal .modal-top-buttons {
    margin-bottom: 1.2rem;
}
.edit-modal label {
    display: block;
    margin-bottom: 0.3rem;
    font-weight: 500;
    color: #444;
    font-size: 1rem;
}
.edit-modal input[type="text"], .edit-modal input[type="url"] {
    width: 100%;
    padding: 0.6rem;
    margin-bottom: 0.8rem;
    border: 1px solid #BDB7AB;
    border-radius: 0.25rem;
    font-size: 1rem;
}
.edit-modal .input-with-button {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.8rem;
}
.edit-modal .input-with-button input {
    flex-grow: 1;
    margin-bottom: 0;
}
.edit-modal .search-button {
    padding: 0.4rem 0.6rem;
    font-size: 0.8rem;
    background-color: #668B8B;
    color: white;
    border: none;
    border-radius: 0.25rem;
    cursor: pointer;
    line-height: 1;
    height: fit-content;
}
.edit-modal .search-button:hover {
    background-color: #5C5C47;
}
.edit-modal button {
    padding: 0.7rem 1rem;
    font-size: 1.3rem;
    border-radius: 0.25rem;
    cursor: pointer;
    border: none;
    flex: 1 1 auto;
    min-width: 90px;
    background-color: #D1D5DB;
}
.edit-modal button.save {
    background-color: #28a745;
    color: white;
}
.edit-modal button.save:hover {
    background-color: #218838;
}
.edit-modal button.cancel {
    background-color: #6c757d;
    color: white;
}
.edit-modal button.cancel:hover {
    background-color: #5a6268;
}
.edit-modal button.reset {
    background-color: #ffc107;
    color: #333;
}
.edit-modal button.reset:hover {
    background-color: #e0a800;
}
.edit-modal button.empty {
    background-color: #fd7e14;
    color: white;
}
.edit-modal button.empty:hover {
    background-color: #e66b04;
}
.editing-active .bookmark-item:hover, .editing-active .range-toggle:hover, .editing-active .empty-slot:hover {
    transform: none;
    box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1);
    outline: 3px solid yellow;
    cursor: crosshair;
}
.editing-active .grid-cell.editing-target, .editing-active .range-toggle.editing-target {
    outline: 3px solid yellow !important;
    outline-offset: 1px;
    box-shadow: 0 0 8px yellow;
}
.editing-active .grid-cell {
    cursor: grab;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}
.editing-active .grid-cell:active {
    cursor: grabbing;
}
.grid-cell.dragging {
    opacity: 0.4;
    border: 2px dashed #aaa;
    cursor: grabbing;
    transform: scale(0.95);
    z-index: 10;
}
.grid-cell.drag-over {
    border: 3px solid #3498db !important;
    background-color: rgba(52, 152, 219, 0.1);
    box-shadow: inset 0 0 10px rgba(52, 152, 219, 0.3);
}
.empty-slot.drag-over {
    border: 3px solid #3498db !important;
    background-color: rgba(52, 152, 219, 0.2);
}
.empty-slot.dragging {
    opacity: 0.4;
    border: 2px dashed #aaa !important;
    cursor: grabbing;
}
.assignment-active .range-toggle.assigning-selected {
    outline: 4px solid cyan;
    box-shadow: 0 0 12px cyan;
    transform: scale(1.03);
}
.assignment-active .range-toggle:not(.assigning-selected) {
    opacity: 0.7;
    cursor: pointer;
}
.assignment-active .grid-cell.assigned-to-current {
    outline: 3px solid cyan;
    box-shadow: inset 0 0 8px rgba(0, 255, 255, 0.6);
    background-color: hsla(180, 70%, 80%, 0.3);
    opacity: 1;
}
.assignment-active .grid-cell:not(.assigned-to-current) {
    opacity: 0.6;
    outline: 1px dashed #aaa;
}
.assignment-active .grid-cell {
    cursor: pointer;
}
body.dark-mode .assignment-active .grid-cell.assigned-to-current {
    box-shadow: inset 0 0 10px rgba(0, 200, 200, 0.7);
    background-color: hsla(180, 60%, 30%, 0.4);
}
body.dark-mode .assignment-active .grid-cell:not(.assigned-to-current) {
    opacity: 0.5;
    outline-color: #555;
}
#pin-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    display: flex;
    justify-content: center;
    align-items: flex-start;
    z-index: 9998;
}
#pin-modal-content {
    background-color: #DAC8A0;
    padding: 2rem;
    border-radius: 0.75rem;
    box-shadow: 0 5px 20px rgba(0,0,0,0.4);
    text-align: center;
    border: 1px solid #A0522D;
    margin-top: 50px;
}
#pin-modal-content h2 {
    font-size: 1.5rem;
    font-weight: bold;
    color: #333;
    margin-bottom: 1rem;
}
#pin-modal-content .modal-top-buttons {
    margin-bottom: 1.5rem;
}
#pin-modal-content label {
    display: block;
    font-size: 1.1rem;
    color: #444;
    margin-bottom: 0.8rem;
}
#pin-input {
    width: 150px;
    padding: 0.8rem;
    font-size: 1.8rem;
    text-align: center;
    border: 2px solid #A0522D;
    border-radius: 0.25rem;
    margin-bottom: 1.5rem;
    letter-spacing: 0.5em;
    background-color: #f0f0e0;
}
#pin-submit-button {
    padding: 0.8rem 2rem;
    font-size: 1.2rem;
    background-color: #28a745;
    color: white;
    border: none;
    border-radius: 0.25rem;
    cursor: pointer;
    transition: background-color 0.2s;
}
#pin-submit-button:hover {
    background-color: #218838;
}
#pin-error-message {
    color: #dc3545;
    font-weight: bold;
    margin-top: 1rem;
    min-height: 1.2em;
}
#config-modal {
    position: fixed;
    top: 15px;
    left: 50%;
    transform: translate(-50%, 0);
    background-color: #ECEFE8;
    padding: 1.5rem;
    border-radius: .75rem;
    box-shadow: 0 8px 16px rgba(0,0,0,.25);
    z-index: 5000;
    max-width: 1000px;
    width: 95%;
    max-height: calc(83vh + 190px);
    display: flex;
    flex-direction: column;
}
#config-modal .modal-top-buttons {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
}
#config-modal .modal-top-buttons h2 {
    margin-bottom: 0;
}
.config-tab-content {
    max-height: calc(83vh + 130px - 190px);
}
.config-tab-button {
    padding: .7rem 1.2rem;
    cursor: pointer;
    border: 1px solid #ccc;
    border-bottom: none;
    background-color: #e0e0d0;
    margin-right: .3rem;
    border-radius: .5rem .5rem 0 0;
    font-size: 1rem;
    font-weight: 500;
    color: #555;
    transition: background-color .2s ease,color .2s ease;
    outline: none;
}
.config-tab-button:hover {
    background-color: #d8d8c0;
}
.config-tab-button.active {
    background-color: #ECEFE8;
    border-color: #ccc;
    border-bottom: 1px solid #ECEFE8;
    font-weight: bold;
    color: #2F4F4F;
    position: relative;
    top: 1px;
    z-index: 2;
}
.tab-buttons {
    margin-bottom: -1px;
    flex-shrink: 0;
    border-bottom: 1px solid #ccc;
    padding-left: 1rem;
    display: flex;
    overflow-x: auto;
}
.tab-contents {
    flex-grow: 1;
    overflow-y: auto;
    position: relative;
    z-index: 1;
    border-top: none;
    min-height: 200px;
}
.config-tab-content {
    display: none;
    padding: 1.8rem;
    border: 1px solid #ccc;
    border-top: none;
    border-radius: 0 0 .5rem .5rem;
    background-color: #ECEFE8;
}
.config-tab-content.active {
    display: block;
}
#config-modal h2 {
    font-size: 1.6rem;
    margin-bottom: 0;
    color: #2F4F4F;
    text-align: center;
    flex-shrink: 0;
}
#config-modal h3 {
    font-size: 1.3rem;
    margin-bottom: .8rem;
    color: #4682B4;
}
#config-modal p, #config-modal label {
    font-size: 1rem;
    line-height: 1.5;
    color: #333;
}
#config-modal em {
    font-size: .85rem;
}
#config-modal button:not(.config-tab-button) {
    font-size: 1.05rem;
    padding: .8rem 1.5rem;
    background-color: #D1D5DB;
}
#config-modal textarea {
    font-size: .9rem;
    height: 110px;
    width: 100%;
    border: 1px solid #ccc;
    border-radius: .25rem;
    padding: .5rem;
    resize: vertical;
}
#config-modal input[type=text], #config-modal input[type=number], #config-modal input[type=password] {
    font-size: 1rem;
    padding: .6rem;
    width: 100%;
    border: 1px solid #ccc;
    border-radius: .25rem;
}
#config-modal .status-message {
    font-size: .9rem;
    min-height: 1.1em;
    font-weight: 500;
    text-align: center;
    margin-top: .5rem;
}
.user-data-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit,minmax(180px,1fr));
    gap: 1.2rem 1.8rem;
    align-items: start;
    margin-bottom: 1rem;
}
.user-data-grid label {
    margin-bottom: .3rem;
    display: block;
    font-weight: 500;
}
.user-data-grid .checkbox-container {
    grid-column: 1 / -1;
    display: flex;
    align-items: center;
    gap: .5rem;
    justify-content: center;
    margin-top: .5rem;
}
.user-data-grid .checkbox-container input {
    width: 1.2rem;
    height: 1.2rem;
}
.user-data-grid .checkbox-container label {
    margin-bottom: 0;
}
.user-buttons-container {
    display: flex;
    justify-content: space-around;
    gap: 1.5rem;
    margin-top: 1.5rem;
    margin-bottom: 1rem;
}
.user-buttons-container button {
    border: none;
    border-radius: .25rem;
    cursor: pointer;
    flex-grow: 1;
}
#config-user-status {
    min-height: 1.2em;
}
.backup-restore-container {
    display: flex;
    gap: 2.5rem;
    flex-wrap: wrap;
}
.backup-restore-container > div {
    flex: 1;
    min-width: 250px;
}
.backup-restore-container p {
    margin-bottom: 1.2rem;
}
.backup-restore-container textarea {
    margin-bottom: 1rem;
    background-color: #f9f9f9;
}
.backup-restore-container button {
    margin-bottom: 1rem;
    border: none;
    border-radius: .25rem;
    cursor: pointer;
    width: 100%;
}
#config-restore-grid-button {
    background-color: #E65100;
    color: black;
    margin-top: 10px;
}
#config-restore-grid-button:hover {
    background-color: #D84315;
}
.backup-restore-container .status-message {
    margin-top: .6rem;
}
.borrar-container h3 {
    margin-bottom: .8rem;
}
.borrar-container p {
    margin-top: .6rem;
}
.borrar-container button {
    margin-top: 1.5rem;
    border: none;
    border-radius: .25rem;
    cursor: pointer;
    width: 100%;
}
.borrar-container button#config-clear-cache {
    background-color: #EF4444;
    color: white;
}
#config-close-modal-container {
    text-align: center;
    margin-top: 1rem;
    flex-shrink: 0;
}
#config-close-modal {
    font-size: 1.15rem;
    padding: .8rem 2.5rem;
    background-color: #4A5568;
    color: white;
    border: 1px solid #2D3748;
    font-weight: bold;
}
#config-close-modal:hover {
    background-color: #2D3748;
}
.pin-config-section {
    border-top: 1px solid #ccc;
    margin-top: 2rem;
    padding-top: 1.5rem;
}
.pin-config-layout {
    display: grid;
    grid-template-columns: minmax(200px, 1fr) minmax(200px, 1fr);
    gap: 1rem 1.5rem;
    align-items: end;
}
.pin-config-layout .pin-input-group {
    grid-column: span 1;
    display: flex;
    flex-direction: column;
}
.pin-config-layout .pin-input-group label {
    margin-bottom: 0.3rem;
}
.pin-config-layout .pin-buttons-container {
    grid-column: 1 / 3;
    grid-row: 2;
    display: flex;
    justify-content: flex-start;
    gap: 1rem;
    margin-top: 0.5rem;
}
.pin-config-layout .pin-buttons-container button {
    flex-grow: 0;
    min-width: 120px;
    max-width: 180px;
}
#tab-content-pin .checkbox-container {
    grid-column: 1 / -1;
    display: flex;
    align-items: center;
    gap: .5rem;
    justify-content: flex-start;
    margin-top: 1.5rem;
    border-top: 1px solid #ccc;
    padding-top: 1rem;
}
#tab-content-pin .checkbox-container input {
    width: 1.2rem;
    height: 1.2rem;
}
#tab-content-pin .checkbox-container label {
    margin-bottom: 0;
}
.toast-notification {
    position: fixed;
    top: 180px;
    right: 15px;
    transform: none;
    padding: 15px 30px;
    border-radius: 8px;
    color: white;
    font-size: 1rem;
    font-weight: bold;
    z-index: 9999;
    opacity: 0;
    transition: opacity 0.4s ease-in-out, top 0.4s ease-in-out;
    box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    text-align: center;
    min-width: 250px;
    max-width: 70%;
}
.toast-notification.show {
    opacity: 1;
}
.toast-success {
    background-color: #28a745;
}
.toast-error {
    background-color: #dc3545;
}
.toast-warning {
    background-color: #ffc107;
    color: #333;
}
.toast-info {
    background-color: #17a2b8;
}
.toast-debug {
    background-color: #663399;
    color: white;
    font-size: 0.9rem;
    text-align: left;
    max-width: 90%;
    white-space: pre-wrap;
    max-height: 80vh;
    overflow-y: auto;
    line-height: 1.3;
}
.toast-debug button {
    display: block;
    margin-top: 10px;
    padding: 5px 10px;
    background-color: rgba(255,255,255,0.2);
    color: white;
    border: 1px solid white;
    border-radius: 3px;
    cursor: pointer;
}
.toast-error.not-found {
    background-color: #a02020;
    border: 2px solid #ffdddd;
    font-size: 1.3rem;
    box-shadow: 0 8px 16px rgba(0,0,0,0.4);
}
.leaflet-container {
    cursor: default !important;
}
#location-map-container.expanded .leaflet-container, #location-picker-map-container.expanded .leaflet-container, #reminders-location-map-div #leaflet-map-actual-container .leaflet-container {
    cursor: crosshair !important;
}
#reminders-location-map-div.simulating-gps-click-mode #leaflet-map-actual-container .leaflet-container {
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="%23FF0000" stroke="white" stroke-width="1"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>') 14 28, crosshair !important;
}
#reminders-location-map-div.navigating #leaflet-map-actual-container .leaflet-container {
    cursor: default !important;
}
#reminders-location-map-div.add-reminder-mode #leaflet-map-actual-container .leaflet-container {
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="%23008000" stroke="white" stroke-width="1"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle><line x1="12" y1="7" x2="12" y2="13"></line><line x1="9" y1="10" x2="15" y2="10"></line></svg>') 14 28, crosshair !important;
}
#location-map-container.expanded .leaflet-touch .leaflet-container, #location-picker-map-container.expanded .leaflet-touch .leaflet-container, #reminders-location-map-div #leaflet-map-actual-container .leaflet-touch .leaflet-container {
    cursor: pointer !important;
}
#reminders-location-map-div.navigating #leaflet-map-actual-container .leaflet-touch .leaflet-container {
    cursor: default !important;
}
#reminders-location-map-div.add-reminder-mode #leaflet-map-actual-container .leaflet-touch .leaflet-container {
    cursor: pointer !important;
}
.leaflet-top.leaflet-right .leaflet-control-layers {
    margin-top: 10px;
    margin-right: 10px;
}
.leaflet-control-layers {
    border-radius: 4px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.65);
    background-color: rgba(0,0,0,0.6) !important;
    color: white !important;
}
.leaflet-control-layers-expanded {
    max-height: 200px;
    overflow-y: auto;
    background-color: rgba(0,0,0,0.509) !important;
}
.leaflet-control-layers-selector {
    color: white !important;
}
.leaflet-control-layers-selector:hover {
    background-color: rgba(255,255,255,0.2) !important;
}
#average-speed-display {
    color: #CBDDB5 !important;
}
#max-speed-display {
    color: #FFA420 !important;
}
#compass-rose-icon {
    width: 57px;
    height: 59px;
    display: block;
    margin: 0 auto 2px auto;
    transition: transform 0.3s ease-out;
}
#orientation-text {
    display: block;
    font-size: 1.4em;
    font-weight: bold;
    line-height: 1.2;
    margin-bottom: 2px;
}
#altitude-display {
    display: block;
    font-size: 1.2em;
    line-height: 1.1;
}
#current-speed-display, #average-speed-display, #max-speed-display {
    display: block;
    font-size: 1.2em;
    line-height: 1.2;
    margin-top: 2px;
}
#navigation-graph-card.enlarged {
    position: fixed;
    background-color: rgba(0, 0, 0, 0.85);
    z-index: 2000;
    border: 1px solid #888;
}
#navigation-graph-card.enlarged #navigation-graph-container {
    flex-grow: 1;
}
#enlarge-graph-button {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 28px;
    height: 28px;
    cursor: pointer;
    z-index: 5;
    opacity: 0.7;
    transition: opacity 0.2s;
}
#enlarge-graph-button:hover {
    opacity: 1;
}
#navigation-graph-title {
    font-size: 1.1em;
    font-weight: bold;
    padding: 1px 5px;
    color: #cb9a01;
    flex-shrink: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}
#navigation-graph-container {
    width: 100%;
    flex-grow: 1;
    position: relative;
    min-height: 0;
}
#navigation-chart {
    display: block;
    width: 100%;
    height: 100%;
}
#reminders-location-map-div {
    position: relative;
    overflow: hidden;
}
#leaflet-map-actual-container {
    width: 100%;
    height: 100%;
    position: relative;
}
#location-map-container:not(.expanded) .leaflet-control-zoom, #location-picker-map-container:not(.expanded) .leaflet-control-zoom {
    display: none !important;
}
.saved-locations-modal {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #E6D6A8;
    padding: 1.5rem;
    border-radius: 1rem;
    box-shadow: 0 6px 15px rgba(0,0,0,0.3);
    z-index: 3500;
    max-width: 700px;
    width: 95%;
    max-height: calc(100vh - 20px);
    display: flex;
    flex-direction: column;
}
.saved-locations-modal h2 {
    font-size: 1.5rem;
    font-weight: bold;
    text-align: center;
    margin-bottom: 1rem;
    color: #333;
}
.saved-locations-modal .modal-top-buttons {
    margin-bottom: 1rem;
}
.saved-locations-modal #saved-locations-list {
    max-height: calc(90vh - 200px - 50px);
    overflow-y: auto;
    margin-bottom: 1rem;
    padding-right: 5px;
}
.saved-locations-modal .location-slot {
    display: flex;
    align-items: center;
    margin-bottom: 0.75rem;
    gap: 0.5rem;
}
.saved-locations-modal .location-slot input[type="text"] {
    flex-grow: 1;
    padding: 0.5rem;
    border: 1px solid #ccc;
    border-radius: 0.25rem;
    font-size: 1rem;
}
.saved-locations-modal .location-slot button.map-button {
    padding: 0.5rem 0.75rem;
    font-size: 0.9rem;
    background-color: #668B8B;
    color: white;
    border: none;
    border-radius: 0.25rem;
    cursor: pointer;
    flex-shrink: 0;
}
.saved-locations-modal .location-slot button.map-button:hover {
    background-color: #5C5C47;
}
.saved-locations-modal .location-slot .coords-display {
    font-size: 0.8rem;
    color: #555;
    min-width: 120px;
    text-align: right;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.saved-locations-modal #save-all-user-locations {
    background-color: #2563EB;
    color: white;
}
.saved-locations-modal #close-saved-locations-modal {
    background-color: #D1D5DB;
    color: #111827;
}
.saved-locations-modal .location-slot button.select-location-button {
    padding: 0.5rem 0.75rem;
    font-size: 0.9rem;
    background-color: #34D399;
    color: white;
    border: none;
    border-radius: 0.25rem;
    cursor: pointer;
    flex-shrink: 0;
    margin-left: 5px;
}
.saved-locations-modal .location-slot button.select-location-button:hover {
    background-color: #10B981;
}
#location-picker-map-container {
    height: 300px;
    border: 1px solid #ccc;
    position: relative;
    margin-top: 1rem;
    border-radius: 0.25rem;
    background-color: #eee;
    display: none;
}
#location-picker-map-container.expanded {
    display: block !important;
}
#location-picker-map-container button {
    padding: 0.5rem 0.8rem;
    font-size: 0.9rem;
    font-weight: bold;
    background-color: rgba(255, 255, 255, 0.9);
    border: 1px solid #777;
    border-radius: 4px;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0,0,0,0.25);
    position: absolute;
    z-index: 1001;
}
#picker-ok-map-button {
    top: 5px;
    right: 5px;
}
#picker-locate-me-button {
    top: 5px;
    right: calc(5px + 90px + 10px);
}
#reminders-location-map-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: #D8D8D0;
    z-index: 6500;
    display: flex;
    flex-direction: column;
    padding: 2px;
    box-sizing: border-box;
}
#reminders-location-map-content-wrapper {
    background-color: #F0EFE4;
    width: 100%;
    height: 100%;
    border-radius: 0.75rem;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}
#reminders-location-map-header {
    display: flex;
    flex-direction: column;
    padding: 2px 0rem;
    border-bottom: 0px solid #D8D8D0;
    flex-shrink: 0;
    background-color: #D8D8D0;
}
#search-row-map-header .reminders-map-button-action {
    height: 57px;
}
#search-row-map-header > #reorder-route-stages-button, #search-row-map-header > #map-location-search-button, #search-row-map-header > #clear-map-search-input-button, #search-row-map-header > #map-location-search-input, #search-row-map-header > #filter-input, #search-row-map-header > #navigation-map-help-button {
    height: 57px !important;
}
#reminders-location-map-header .button-row.hidden-map-header {
    opacity: 0;
    visibility: hidden;
    max-height: 0 !important;
    min-height: 0 !important;
    overflow: hidden !important;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    margin-bottom: 0 !important;
    border-bottom: none !important;
}
#reminders-location-map-header .button-row:first-child {
    margin-bottom: 10px;
}
#reminders-location-map-header h2 {
    display: none;
}
#reminders-location-map-header .reminders-map-button-action img, #reminders-location-map-header .reminders-map-button-action svg {
    width: 100%;
    height: 100%;
    object-fit: contain;
}
#reminders-location-map-header .reminders-map-button-action:hover {
    opacity: 0.88;
}
#toggle-map-header-buttons-panel {
    position: fixed;
    left: 15px;
    top: 50%;
    transform: translateY(-50%);
    width: calc(120px);
    height: calc(120px);
    background-color: rgba(100, 100, 100, 0.45);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 1010;
    box-shadow: 1px 1px 3px rgba(0,0,0,0.45);
    touch-action: none;
}
#toggle-map-header-buttons-panel img {
    width: 60%;
    height: 60%;
    object-fit: contain;
}
#load-route-button, #save-route-button {
    background-color: #0000CD !important;
}
#navigation-map-help-button {
    margin-right: 10px;
    margin-left: 10px;
    background-color: #4A5568 !important;
    box-shadow: 2px 2px 5px rgba(0,0,0,0.50);
}
#add-reminder-at-location-button {
    background-color: #FFA500 !important;
    width: 60px;
    height: 60px;
    padding: 5px;
    gap: 0;
}
#add-reminder-at-location-button.active-reminder-mode {
    background-color: #EF4444 !important;
}
#add-reminder-at-location-button svg {
    width: 100%;
    height: 100%;
    object-fit: contain;
}
.radares-ruta-control {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.3rem 0.6rem;
    background-color: rgba(200,200,180,0.7);
    border-radius: 5px;
    height: 60px;
    min-width: 70px;
    box-sizing: border-box;
    gap: 4px;
}
#radares-ruta-checkbox {
    margin-right: 0px;
    margin-bottom: 0px;
    transform: scale(1.1);
}
.radares-ruta-label-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}
#radares-ruta-checkbox + .radares-ruta-label-container > label {
    font-weight: bold;
    font-size: 0.85rem;
    color: #333;
    cursor: pointer;
    text-align: center;
    line-height: 1.1;
    margin-bottom: 1px;
}
#radares-ruta-count {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
    background-color: #6600a1;
    color: white;
    border-radius: 50%;
    font-size: 0.75rem;
    font-weight: bold;
    line-height: 1;
    margin-top: 2px;
}
.tareas-ruta-control {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.3rem 0.6rem;
    background-color: rgba(200,200,180,0.7);
    border-radius: 5px;
    height: 60px;
    min-width: 70px;
    box-sizing: border-box;
    gap: 4px;
}
#tareas-ruta-checkbox {
    margin-right: 0px;
    margin-bottom: 0px;
    transform: scale(1.1);
}
.tareas-ruta-label-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}
#tareas-ruta-checkbox + .tareas-ruta-label-container > label {
    font-weight: bold;
    font-size: 0.85rem;
    color: #333;
    cursor: pointer;
    text-align: center;
    line-height: 1.1;
    margin-bottom: 1px;
}
#tareas-ruta-count {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
    background-color: #008f39;
    color: white;
    border-radius: 50%;
    font-size: 0.75rem;
    font-weight: bold;
    line-height: 1;
    margin-top: 2px;
}
#reorder-route-stages-button {
    height: 60px;
    width: 60px;
    border: 1px solid #777;
    box-shadow: 2px 3px 5px rgba(0,0,0,0.70);
    padding: 2px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 0.9rem;
    font-weight: bold;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    flex-shrink: 0;
    white-space: nowrap;
    background-color: white !important;
    margin-right: 4px;
}
#reorder-route-stages-button img {
    max-height: 90%;
    max-width: 90%;
    object-fit: contain;
}
#map-location-search-button {
    height: 60px;
    width: 60px;
    border: 1px solid #777;
    box-shadow: 2px 3px 5px rgba(0,0,0,0.70);
    padding: 3px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 0.9rem;
    font-weight: bold;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    flex-shrink: 0;
    white-space: nowrap;
    background-color: white !important;
    margin-left: 2px;
}
#map-location-search-button img {
    max-height: 80%;
    max-width: 90%;
    object-fit: contain;
}
#map-location-search-input::placeholder {
    color: #CDCDCD;
    opacity: 1;
}
#::placeholder {
    color: #CDCDCD;
    opacity: 1;
}
#map-location-search-input::-webkit-input-placeholder {
    color: #CDCDCD;
}
#map-location-search-input::-moz-placeholder {
    color: #CDCDCD;
    opacity: 1;
}
#map-location-search-input:-ms-input-placeholder {
    color: #CDCDCD;
}
#map-location-search-input::-ms-input-placeholder {
    color: #CDCDCD;
}
body.dark-mode #map-location-search-input {
    background-color: #a0a090;
    color: #e0e0e0;
    border-color: #666;
}
body.dark-mode #map-location-search-input::placeholder {
    color: #A0A0A0;
}
#clear-map-search-input-button {
    height: 60px !important;
    width: 50px !important;
    background-color: #e0e0e0;
    border: 1px solid #ccc;
    box-shadow: 2px 3px 5px rgba(0,0,0,0.70);
    border-radius: 4px;
    cursor: pointer;
    flex-shrink: 0;
    padding: 0;
    z-index: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-left: 2px;
}
#clear-map-search-input-button svg {
    width: 60%;
    height: 60%;
    stroke: red;
    stroke-width: 3;
}
body.dark-mode #clear-map-search-input-button {
    background-color: #555;
    border-color: #444;
}
body.dark-mode #clear-map-search-input-button svg {
    stroke: #ff6666;
}
#toggle-simulate-gps-button {
    background-color: #DAA520 !important;
    width: 60px;
    height: 60px;
    padding: 5px !important;
}
#toggle-simulate-gps-button.active-simulate-gps-mode {
    background-color: #B22222 !important;
    box-shadow: 0 0 8px #FF4500;
}
#toggle-simulate-gps-button img {
    width: 100%;
    height: 100%;
    object-fit: contain;
}
#simulate-route-button {
    padding: 5px;
}
#simulate-route-button img {
    width: 100%;
    height: 100%;
    object-fit: contain;
}
#view-all-locations-map {
    padding: 0.75rem 1.2rem;
    font-size: 1.1rem;
    font-weight: bold;
    border-radius: 0.5rem;
    cursor: pointer;
    border: 2px solid #506C6C;
    color: white;
    background-color: #668B8B;
    margin-left: 10px;
    transition: background-color 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    height: auto;
    min-height: 46px;
    white-space: nowrap;
}
#view-all-locations-map:hover {
    background-color: #5C7A7A;
}
#reminders-location-map-div {
    flex-grow: 1;
    background-color: #E0E0E0;
    position: relative;
    overflow: hidden;
}
#map-info-overlay {
    position: absolute;
    top: 10px;
    right: 90px;
    left: auto;
    transform: none;
    z-index: 1002;
    background: rgba(0,0,0,0.1);
    color: white;
    padding: 8px 15px;
    border-radius: 8px;
    font-size: 0.8em;
    font-weight: bold;
    text-align: right;
    display: none;
    max-width: 55%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    line-height: 1.3;
}
#map-info-overlay span {
}
#tab-content-radares .radar-filter-group {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-bottom: 1rem;
    align-items: end;
}
#tab-content-radares .radar-filter-group label {
    margin-bottom: 0.25rem;
    font-weight: 500;
    font-size: 0.9rem;
}
#tab-content-radares .radar-filter-group input {
    padding: 0.5rem;
    font-size: 1rem;
    border: 1px solid #ccc;
    border-radius: 0.25rem;
}
#tab-content-radares .radar-import-options {
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}
#tab-content-radares .radar-import-options input[type=checkbox] {
    width: 1.1rem;
    height: 1.1rem;
}
#tab-content-radares .radar-import-options label {
    margin-bottom: 0;
    font-size: 0.9rem;
}
#tab-content-radares .radar-action-buttons {
    display: flex;
    justify-content: space-around;
    gap: 1rem;
    margin-top: 1rem;
    margin-bottom: 1.5rem;
}
#tab-content-radares .radar-action-buttons button {
    flex: 1;
    padding: 0.8rem 1rem;
    font-size: 1.1rem;
    border-radius: 0.3rem;
    background-color: #D1D5DB;
}
#import-radars-button, #delete-filtered-radars-button {
    background-color: #F59E0B !important;
    color: white !important;
    border: 1px solid #D97706 !important;
}
#import-radars-button:hover, #delete-filtered-radars-button:hover {
    background-color: #D97706 !important;
}
#radar-import-progress-container {
    margin-top: 1rem;
    padding: 0.8rem;
    border: 1px solid #ccc;
    border-radius: 0.25rem;
    background-color: #f9f9f9;
}
#radar-import-progress-bar {
    width: 100%;
    height: 20px;
    margin-bottom: 0.5rem;
}
#radar-import-status {
    font-size: 0.9rem;
    color: #333;
    min-height: 1.2em;
    text-align: center;
}
.navigation-waypoint-marker {
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    color: white;
    font-weight: bold;
    text-align: center;
    box-shadow: 0 0 3px rgba(0,0,0,0.5);
    opacity: 0.85;
    position: relative;
}
.navigation-waypoint-marker.start-point {
    background-color: rgba(0, 128, 0, 0.80);
}
.navigation-waypoint-marker.finish-point {
    background-color: rgba(0, 0, 255, 0.80);
}
.navigation-waypoint-marker.intermediate-point {
    background-color: rgba(230, 140, 0, 0.80);
}
.waypoint-delete-button {
    position: absolute;
    background-color: rgba(255, 0, 0, 0.85);
    color: white;
    border-radius: 50%;
    text-align: center;
    cursor: pointer;
    border: 1px solid white;
    z-index: 10;
}
#navigation-bottom-progress-bar {
    position: absolute;
    top: 10px;
    left: 10px;
    transform: none;
    width: auto;
    max-width: 500px;
    min-width: 480px;
    background-color: rgba(0, 0, 0, 0.6);
    padding: 8px;
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    z-index: 1001;
    color: white;
    display: none;
}
#navigation-top-info-bar {
    margin-bottom: 8px;
    font-size: 1.2em;
    display: flex;
    align-items: center;
    position: relative;
    cursor: pointer;
}
#navigation-bottom-progress-bar hr {
    border: none;
    border-top: 1px solid rgba(229, 209, 193, 0.5);
    margin: 10px 0;
}
#navigation-top-info-bar .turn-icon-display img {
    width: 95% !important;
    height: 95% !important;
    background-size: contain;
    background-position: center;
    display: block;
    margin: auto;
    object-fit: contain;
}


#turn-icon-container-styled {
    position: relative;
    background-color: white;
    padding: 2px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 60px;
    height: 60px;
    box-sizing: border-box;
    z-index: 1;
    flex-shrink: 0;
    margin-right: 8px;
    overflow: hidden; 
}

#navigation-top-info-bar .turn-icon-display .leaflet-routing-icon {
    width: 100%;
    height: 100%;
    background-image: url('https://cdnjs.cloudflare.com/ajax/libs/leaflet-routing-machine/3.2.12/leaflet.routing.icons.png');
    background-repeat: no-repeat;
    image-rendering: pixelated; /* Mantiene la nitidez al escalar */
  }

#simulation-modal .turn-icon-sim .leaflet-routing-icon {
    width: 24px !important;
    height: 24px !important;
    transform: none !important;
    display: block;
    object-fit: contain;
    background-image: url('https://cdnjs.cloudflare.com/ajax/libs/leaflet-routing-machine/3.2.12/leaflet.routing.icons.png');
    background-repeat: no-repeat;
   }

    
#navigation-top-info-bar .maneuver-text-container {
    flex-grow: 1;
    text-align: center;
    max-width: calc(100% - 60px);
}
#navigation-top-info-bar .maneuver-text, #navigation-top-info-bar .street-name {
    font-weight: bold;
    font-size: 1.33em
    color: white;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    white-space: normal;
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.2;
}
#navigation-top-info-bar .maneuver-text {
    font-size: 1.2em;
    margin-right: 8px;
    display: inline;
}
#navigation-top-info-bar .street-name {
    font-size: 0.8em;
    display: inline;
}
#distance-to-turn-formatted {
    text-align: center;
    font-weight: bold;
    font-size: 1.5em;
    margin-top: 4px;
}
#distance-progress-bar-to-turn-container {
    width: 100%;
    height: 7px;
    background-color: #e0e0e0;
    border-radius: 4px;
    margin-top: 5px;
    overflow: hidden;
}
#distance-progress-bar-to-turn {
    width: 100%;
    height: 100%;
    background: linear-gradient(to right, #680000 0%, #FF0000 50%, #FA8072 97%);
    border-radius: 4px;
    transition: width 0.3s linear;
}
#route-overall-progress-container {
    width: 100%;
    height: 18px;
    background-color: #e0e0e0;
    border-radius: 9px;
    margin-bottom: 9px;
    position: relative;
    overflow: visible;
}
#route-overall-progress {
    width: 0%;
    height: 100%;
    z-index: 3;
    background-color: #4CAF50;
    background: linear-gradient(to right, #006600 30%, #258D19 92%, #b4ff9a 99%);
    border-radius: 9px;
    transition: width 0.5s linear;
    position: relative;
}
.radar-marker-on-progress-bar {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 0;
    height: 0;
    z-index: 1;
    border-left: 11px solid transparent;
    border-right: 11px solid transparent;
    border-bottom: 14px solid white;
}
.radar-marker-on-progress-bar::after {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    z-index: 2;
    border-left: 9px solid transparent;
    border-right: 9px solid transparent;
    border-bottom: 12px solid #8A36D2;
    top: 1px;
    left: -9px;
}
.task-marker-on-progress-bar {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 0;
    height: 0;
    z-index: 1;
    border-left: 11px solid transparent;
    border-right: 11px solid transparent;
    border-bottom: 14px solid white;
}
.task-marker-on-progress-bar::after {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    z-index: 2;
    border-left: 9px solid transparent;
    border-right: 9px solid transparent;
    border-bottom: 12px solid #608414;
    top: 1px;
    left: -9px;
}
#route-progress-icon {
    position: absolute;
    height: 100%;
    width: auto;
    max-height: 18px;
    left: 100%;
    top: 50%;
    transform: translate(-50%, -50%);
    z-index: 4;
    display: none;
}
#route-progress-text {
    position: absolute;
    text-align: left;
    top: 50%;
    left: 10px;
    transform: translateY(-50%);
    font-family: 'Arial', 'Helvetica Neue', Helvetica, sans-serif;
    font-weight: bold;
    color: yellow;
    -webkit-text-stroke-width: 2px;
    -webkit-text-stroke-color: #006400;
    paint-order: stroke fill;
    font-size: clamp(0.85em, 3vw, 0.95em);
    line-height: 1;
    pointer-events: none;
    z-index: 3;
    background-color: transparent;
    padding: 2px;
    white-space: nowrap;
}
.waypoint-dot-on-progress-bar {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 13px;
    height: 13px;
    background-color: #3498db;
    border-radius: 50%;
    border: 1px solid white;
    z-index: 2;
}
#navigation-eta-info {
    display: flex;
    justify-content: space-between;
    margin-top: 6px;
    font-size: 1em;
}
#navigation-eta-info.single-destination {
    justify-content: center;
}
#navigation-eta-info > div {
    flex-basis: 48%;
    text-align: center;
}
#final-destination-info.single-destination-layout {
    text-align: center;
    flex-basis: auto !important;
}
#final-destination-info.single-destination-layout strong {
    font-size: 0.7em !important;
}
#final-destination-info.single-destination-layout span {
    font-size: 1.1em !important;
}
#navigation-eta-info strong {
    display: block;
    font-size: 0.7em;
    margin-bottom: 2px;
}
#navigation-eta-info span {
    font-size: 1.1em;
    font-weight: bold;
}
#next-stage-info {
    display: block;
}
#navigation-eta-info #next-stage-distance, #navigation-eta-info #final-destination-distance {
    margin-right: 3px;
}
#navigation-eta-info #next-stage-time, #navigation-eta-info #final-destination-time {
    margin-left: 3px;
    margin-right: 3px;
}
#navigation-eta-info #next-stage-eta, #navigation-eta-info #final-destination-eta {
    margin-left: 3px;
}
.eta-deviation {
    font-size: 0.9em !important;
    font-weight: bold;
    margin-left: 6px !important;
}
.eta-deviation.positive {
    color: #FF7C39;
}
.eta-deviation.negative {
    color: #10B981;
}
#next-stage-info .eta-deviation {
    font-size: 0.9em !important;
    font-weight: bold;
    margin-left: 6px;
}
#final-destination-info .eta-deviation {
    font-size: 0.9em !important;
    font-weight: bold;
    margin-left: 6px;
}
#simulation-modal .modal-top-buttons {
    margin-bottom: 1rem;
}
#simulation-content-area {
    overflow-y: auto;
    margin-bottom: 1rem;
    padding: 0.5rem;
    background-color: #fff;
    border: 1px solid #ccc;
    border-radius: 0.5rem;
    min-height: 150px;
    font-size: 0.9rem;
    line-height: 1.4;
    flex-grow: 1;
}
#simulation-content-area ul {
    list-style-type: none;
    padding-left: 0;
}
#simulation-content-area li {
    padding: 0.3rem 0;
    border-bottom: 1px solid #eee;
    display: flex;
    align-items: center;
}
#simulation-content-area li:last-child {
    border-bottom: none;
}
#simulation-modal .turn-icon-sim {
    margin-right: 8px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    flex-shrink: 0;
    vertical-align: middle;
}
#simulation-modal .turn-icon-sim img {
    width: 24px !important;
    height: 24px !important;
    object-fit: contain;
}
#saved-routes-modal {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #E6D6A8;
    padding: 1.5rem;
    border-radius: 1rem;
    box-shadow: 0 6px 15px rgba(0,0,0,0.3);
    z-index: 8000;
    max-width: 750px;
    width: 95%;
    max-height: calc(100vh - 10px);
    display: flex;
    flex-direction: column;
}
#saved-routes-modal h2 {
    font-size: 1.3rem;
    font-weight: bold;
    text-align: center;
    margin-bottom: 1rem;
    color: #333;
}
#saved-routes-modal .modal-top-buttons {
    margin-bottom: 1rem;
    display: flex;
    justify-content: flex-start;
    align-items: center;
}
#saved-routes-modal #close-saved-routes-modal {
    background-color: #C0392B !important;
    color: white !important;
    border: 1px solid #A93226 !important;
    padding: 0.9rem 1.8rem !important;
    font-size: 1.15rem !important;
    font-weight: bold !important;
    border-radius: 0.3rem;
    min-width: 130px;
    flex-grow: 0;
    flex-shrink: 0;
    flex-basis: flex-start;
}
#saved-routes-modal #close-saved-routes-modal:hover {
    background-color: #A93226 !important;
}
#saved-routes-modal .filter-container {
    display: flex;
    margin-bottom: 1rem;
    gap: 5px;
}
#saved-routes-modal input#filter-saved-routes {
    flex-grow: 1;
    padding: 8px 12px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 1.5rem;
    font-weight: bold !important;
    text-transform: uppercase !important;
}
#saved-routes-modal button#clear-filter-saved-routes {
    padding: 8px 12px;
    background-color: #e0e0e0;
    border: 1px solid #ccc;
    border-radius: 4px;
    cursor: pointer;
    color: #EF4444;
    font-weight: bold;
    font-size: 1.5rem;
    line-height: 1;
}
#saved-routes-list {
    list-style: none;
    padding: 0;
    margin: 0 0 1rem 0;
    max-height: calc(60vh - 80px - 50px);
    overflow-y: auto;
    border: 1px solid #A9A18C;
    border-radius: 5px;
    background-color: #D3CBB8;
}
#saved-routes-list li {
    padding: 10px 15px;
    border-bottom: 1px solid #ddd;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 1.1rem;
    font-weight: bold;
    background-color: #F5F5DC;
}
#saved-routes-list li:last-child {
    border-bottom: none;
}
#saved-routes-list li:hover {
    background-color: #FFD700;
}
#saved-routes-list .delete-route-btn {
    background-color: #ef4444;
    color: white;
    border: none;
    border-radius: 3px;
    padding: 3px 7px;
    font-size: 0.8rem;
    cursor: pointer;
}
#save-route-prompt-modal {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #E6D6A8;
    padding: 1.5rem;
    border-radius: 1rem;
    box-shadow: 0 6px 15px rgba(0,0,0,0.3);
    z-index: 8500;
    max-width: 800px;
    width: 90%;
    display: flex;
    flex-direction: column;
    max-height: calc(100vh - 20px);
}
#save-route-prompt-modal h2 {
    font-size: 1.3rem;
    font-weight: bold;
    text-align: center;
    margin-bottom: 1rem;
    color: #333;
}
#save-route-prompt-modal .modal-top-buttons {
    margin-bottom: 1rem;
}
#save-route-prompt-modal label {
    margin-bottom: 0.5rem;
    font-weight: 500;
    display: block;
}
#save-route-prompt-modal input[type="text"]#route-name-input {
    padding: 0.5rem;
    border: 1px solid #ccc;
    border-radius: 0.25rem;
    margin-bottom: 1rem;
    width: 100%;
    font-weight: bold !important;
    text-transform: uppercase !important;
    font-size: 1.3rem !important;
}
#save-route-prompt-modal button {
    padding: 0.7rem 1rem;
    font-size: 1.1rem;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    flex: 1;
    background-color: #D1D5DB;
}
#save-route-prompt-modal #confirm-save-route {
    background-color: #2563EB;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
}
#save-route-prompt-modal #cancel-save-route {
    background-color: #4A5568;
    color: white;
    border: 1px solid #2D3748;
    font-weight: bold;
}
#save-route-prompt-modal #cancel-save-route:hover {
    background-color: #2D3748;
}
.leaflet-control-attribution {
    opacity: 0.2;
    background-color: rgba(255, 255, 255, 0.3) !important;
}
.leaflet-routing-icon {
    background-image: url('https://cdnjs.cloudflare.com/ajax/libs/leaflet-routing-machine/3.2.12/leaflet.routing.icons.png');
    background-repeat: no-repeat;
    display: inline-block;
    width: 24px;
    height: 24px;
    vertical-align: middle;
    background-size: 288px 24px;
    overflow: visible;
}
.leaflet-routing-icon-continue {
    --bg-pos-x: 0;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-sharp-right {
    --bg-pos-x: -24px;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-turn-right {
    --bg-pos-x: -48px;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-bear-right {
    --bg-pos-x: -72px;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-sharp-left {
    --bg-pos-x: -96px;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-turn-left {
    --bg-pos-x: -120px;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-bear-left {
    --bg-pos-x: -144px;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-u-turn {
    --bg-pos-x: -168px;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-depart {
    --bg-pos-x: -192px;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-arrive {
    --bg-pos-x: -216px;
    --bg-pos-y: 0;
}
.leaflet-routing-icon-roundabout {
    --bg-pos-x: -24px;
    --bg-pos-y: -24px;
}
.favicon-red {
    filter: hue-rotate(0deg) saturate(200%) brightness(80%);
}
.favicon-blue {
    filter: hue-rotate(200deg) saturate(150%) brightness(90%);
}
.button-countdown-timer {
    margin-left: 5px;
    font-weight: normal;
    font-size: 1em;
    opacity: 0.9;
}
#sortable-stages-list {
    max-height: calc(100% - 130px);
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    touch-action: pan-y;
    padding: 0;
    margin: 0;
    list-style-type: none;
    background-color: #C8BBA0;
}
#sortable-stages-list li {
    padding: 15px;
    min-height: 60px;
    border-bottom: 1px solid #ddd;
    transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    cursor: grab;
    user-select: none;
    display: flex;
    align-items: center;
    gap: 12px;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    margin-bottom: 10px;
    color: #333;
}
#sortable-stages-list li:hover:not(.dragging) {
    background-color: #f0e6c8;
    color: #FFFF00;
    box-shadow: 0 3px 7px rgba(0,0,0,0.15);
}
.drag-handle {
    cursor: grab;
    padding: 0 10px;
    align-self: stretch;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 8px;
    touch-action: none;
}
.drag-handle:hover {
}
.drag-handle img {
    width: 24px;
    height: 24px;
    object-fit: contain;
}
#sortable-stages-list li.dragging .drag-handle, .drag-handle:active {
    cursor: grabbing;
}
#sortable-stages-list li:hover:not(.dragging) {
    background-color: #E0D8C8;
    color: #FFFF00;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}
#sortable-stages-list li:hover:not(.dragging) .drag-handle {
}
#sortable-stages-list li:hover:not(.dragging) .stage-label-badge {
    color: white;
}
#sortable-stages-list li:hover:not(.dragging) .delete-stage-button {
    color: #EF4444;
}
#sortable-stages-list li:hover:not(.dragging) .delete-stage-button:hover {
    color: #B91C1C;
}
#sortable-stages-list li:hover:not(.dragging) .stage-name-text {
    color: #FFFF00;
}
#sortable-stages-list li:last-child {
    border-bottom: none;
    margin-bottom: 0;
}
#sortable-stages-list li.dragging {
    opacity: 0.7;
    background-color: #4a4a3b;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}
.stage-label-badge {
    background-color: #555;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.85rem;
    min-width: 25px;
    text-align: center;
    flex-shrink: 0;
    font-weight: bold;
}
.stage-name-text {
    flex-grow: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    font-size: 1rem;
    color: #333;
}
.delete-stage-button {
    cursor: pointer;
    margin-left: auto;
    padding: 0 10px;
    font-size: 1.8rem;
    color: #EF4444;
    font-weight: bold;
    line-height: 1;
    flex-shrink: 0;
}
.delete-stage-button:hover {
    color: #B91C1C;
}
#vehicle-icon-wrapper {
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    transform-origin: center center;
    position: relative;
}
#vehicle-icon-wrapper img {
    width: 100%;
    height: 100%;
    display: block;
    object-fit: contain;
    position: absolute;
    top: 0px;
    left: 0px;
}
.vehicle-icon-minimap {
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    transform-origin: center center;
    position: relative;
}
.vehicle-icon-minimap img {
    width: 100%;
    height: 100%;
    display: block;
    object-fit: contain;
    position: absolute;
    top: 0px;
    left: 0px;
}
#intersection-preview-map-container {
    width: 100%;
    height: 100%;
}
#reminders-location-map-modal.immersive-mode-active #reminders-location-map-header, #reminders-location-map-modal.immersive-mode-active #navigation-bottom-progress-bar, #reminders-location-map-modal.immersive-mode-active .leaflet-control-custom-map-controls, #reminders-location-map-modal.immersive-mode-active #map-info-overlay {
    display: none !important;
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
}
#search-row-map-header {
    height: 70px;
    min-height: 70px;
    max-height: 70px;
    margin-bottom: 2px;
}

.leaflet-bottom.leaflet-left {
    display: flex;
    align-items: flex-start;
    left: 5px;
    bottom: 5px;
}
#reminders-location-map-header .reminders-map-button-action {
    padding: 5px;
    font-size: 0.9rem;
    height: 60px;
    min-height: 60px;
    font-weight: bold;
    border-radius: 0.375rem;
    cursor: pointer;
    border: 1px solid #777;
    color: white;
    transition: background-color 0.2s ease, opacity 0.2s ease;
    box-shadow: 2px 5px 4px rgba(0,0,0,0.65);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    flex-shrink: 0;
    white-space: nowrap;
    background-color: white !important;
    min-width: 60px;
    width: 60px;
    margin-bottom: 5px;
}
.leaflet-control-custom-map-controls {
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap !important;
    align-items: flex-end;
    gap: 7px;
    z-index: 1001;
    min-width: 0;
}
    
.leaflet-control-custom-map-controls > * {
    flex-shrink: 0 !important;
    min-width: 0 !important;
}
    
.leaflet-control-orientation-altitude {
    transform: none !important;
    background-color: rgba(0,0,0,0.5);
    color: white;
    padding: 8px;
    border-radius: 3px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.40);
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
    box-sizing: border-box;
    cursor: pointer;
    width: 125px;
    min-width: 125px;
    flex-shrink: 0;
    height: 160px;
}
    
#navigation-graph-card {
    width: 395px;
    height: 160px;
    background-color: rgba(0, 0, 0, 0.50);
    color: white;
    border-radius: 5px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.45);
    z-index: auto;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    padding: 5px;
    position: relative;
    transition: all 0.4s ease-in-out;
}
    
#reminders-location-map-header .button-row {
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap !important;
    align-items: center;
    width: 100%;
    height: 65px;
    min-height: 65px;
    padding-bottom: 5px;
    box-sizing: content-box;
    overflow-x: auto;
    overflow-y: hidden;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    transition: opacity 0.3s ease, visibility 0.3s ease, max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
}
#reminders-location-map-header .button-row::-webkit-scrollbar {
    display: none;
}
#reminders-location-map-header .button-row > *:not(:last-child) {
    margin-right: 10px;
}
#intersection-preview-map-window {
    position: absolute;
    background-color: rgba(0, 0, 0, 0.75);
    border: 6px solid #bf875d;
    border-radius: 7px;
    z-index: 7000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    overflow: hidden;
}
@media (min-width: 768px) {
    #intersection-preview-map-window {
        height: 480px;
    }
}
body.mobile-view #intersection-preview-map-window {
    width: 90vw;
    height: 50vh;
    max-width: 500px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
body.mobile-view #reminders-location-map-modal {
    display: flex;
    flex-direction: column;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100dvh;
    padding: 0;
    border: none;
    border-radius: 0;
    box-sizing: border-box;
    z-index: 10000;
}
body.mobile-view #reminders-location-map-content-wrapper {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
    border-radius: 0;
    overflow: hidden;
}
body.mobile-view #reminders-location-map-header {
    flex-shrink: 0;
    padding: 5px;
    background-color: #C8C8C0;
}
body.mobile-view #reminders-location-map-header .button-row {
    height: auto;
    min-height: 0;
    flex-wrap: wrap;
    justify-content: center;
    gap: 5px;
    padding: 5px 0;
}
body.mobile-view #reminders-location-map-header .reminders-map-button-action,
body.mobile-view #reminders-location-map-header #reorder-route-stages-button {
    height: 48px;
    min-height: 48px;
    width: 48px;
    min-width: 48px;
    max-width: 60px;
    padding: 2px;
    font-size: 0.7rem;
}
body.mobile-view #reminders-location-map-header #map-location-search-input {
    font-size: 1.1rem;
    height: 48px;
    flex-grow: 1;
    min-width: 150px;
}
body.mobile-view #reminders-location-map-header #filter-input {
    height: 48px;
    width: 100px;
    font-size: 0.9rem;
}
body.mobile-view #reminders-location-map-div {
    flex-grow: 1;
    position: relative;
}
body.mobile-view #leaflet-map-actual-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
body.mobile-view #toggle-map-header-buttons-panel {
    width: 60px;
    height: 60px;
    left: 10px;
}
body.mobile-view #map-info-overlay {
    max-width: 80%;
    top: 10px;
    right: 10px;
    font-size: 0.9em;
}
body.mobile-view .leaflet-control-custom-map-controls {
    flex-direction: column;
    align-items: flex-start;
    gap: 5px;
}
body.mobile-view .reminder-modal,
body.mobile-view .help-modal,
body.mobile-view .edit-info-modal,
body.mobile-view .choice-modal,
body.mobile-view .edit-modal,
body.mobile-view .reminder-table-modal,
body.mobile-view .postpone-options,
body.mobile-view .saved-locations-modal,
body.mobile-view #reorder-stages-modal,
body.mobile-view #simulation-modal,
body.mobile-view #locations-preview-modal,
body.mobile-view #deviation-modal,
body.mobile-view #arrival-stats-modal,
body.mobile-view #simulation-speed-modal,
body.mobile-view #saved-routes-modal,
body.mobile-view #save-route-prompt-modal,
body.mobile-view #address-suggestions-modal,
body.mobile-view #pin-modal-overlay,
body.mobile-view #versions-modal-overlay
body.mobile-view #reminders-map-help-modal-instance,
body.mobile-view #intersection-preview-map-window {
    z-index: 10001 !important;
}
#reminders-map-help-modal-instance {
    z-index: 10002 !important;
}
#map-location-search-input {
    flex-grow: 1;
    padding: 8px 12px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background-color: #fff;
    min-width: 300px;
    height: 60px;
    font-weight: bold;
    text-transform: uppercase;
    font-size: 1rem;
    box-sizing: border-box;
    margin-right: 0 !important;
    margin-left: 5px;
}
#filter-input {
    max-width: 200px;
    font-size: 0.9rem;
    padding: 8px 5px;
    margin-left: 2PX;
    border: 1px solid #7c7c68;
    border-radius: 4px;
    font-weight: bold;
    height: 60px;
    background-color: #f0f0e0;
    box-sizing: border-box;
}
#nav-map-zoomtoggle-button {
    width: 60px;
    min-width: 60px;
    height: 60px;
    padding: 5px;
}
#reminders-location-map-header .button-row {
    display: flex;
    margin-left: 5px;
    flex-direction: row;
    flex-wrap: nowrap !important;
    align-items: center;
    width: 100%;
    height: 70px;
    min-height: 70px;
    padding-bottom: 5px;
    box-sizing: content-box;
    overflow-x: auto;
    overflow-y: hidden;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    transition: opacity 0.3s ease, visibility 0.3s ease, max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
}  




.direction-warning-card {
    position: absolute;
    /* Aplicamos la transparencia y el fondo al contenedor principal */
    background-color: rgba(100, 100, 100, 0.70);
    color: white;
    font-weight: bold;
    font-size: 1.1rem;
    padding: 8px 12px;
    border-radius: 5px;
    z-index: 1005;
    display: none; /* Se mostrará con JavaScript */
    /* El text-shadow se aplica al texto dentro de la tarjeta */
    text-shadow: 1px 1px 2px rgba(0,0,0,0.45);
    /* Añadimos flexbox para alinear texto e icono */
    display: flex;
    align-items: center;
    gap: 8px; /* Espacio entre icono y texto */
}

/* Nueva regla para estilizar los iconos dentro de las tarjetas */
.direction-card-icon {
    width: 28px;
    height: 28px;
    display: inline-block;
    vertical-align: middle;
    /* La magia está aquí: aplicamos un filtro para que el icono se vea integrado */
    filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.45));
}



    


/* ======================================= */
/* === INICIO: CÓDIGO CSS PARA ALERTAS === */
/* ======================================= */

#alert-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.75);
    z-index: 8000;
    /* Quitamos flex para posicionar el contenido de forma absoluta */
}

#alert-modal-content {
    position: fixed; /* Posicionamiento fijo */
    top: 25px;       /* A 25px del borde superior */
    left: 25px;      /* A 25px del borde izquierdo */
    background-color: #E6D6A8;
    padding: 1rem;
    border-radius: 1rem;
    box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    border: 2px solid #C0B080;
}

#alert-columns-container {
    display: flex;
    gap: 1rem; /* Espacio entre las columnas */
}

.alert-column {
    display: flex;
    flex-direction: column;
    gap: 0.8rem; /* Espacio entre los botones de una misma columna */
}

.alert-option, #alert-cancel-button {
    display: flex;
    align-items: center;
    padding: 0.75rem 1.25rem;
    background-color: #F5F5DC;
    border: 1px solid #A9A18C;
    border-radius: 0.5rem;
    cursor: pointer;
    transition: background-color 0.2s ease, transform 0.1s ease;
    width: 100%; /* Para que ocupen el ancho de la columna */
}

.alert-option:hover {
    background-color: #FFD700;
    transform: translateY(-2px);
}

.alert-option img {
    width: 80px;
    height: 50px;
    margin-right: 1rem;
    object-fit: contain;
}

.alert-option span {
    font-size: 1.4rem ; color: white;
    font-weight: bold;
    color: #333;
}


#alert-cancel-button {
    background-color: #2563EB;
    justify-content: center;
    margin-top: auto;
}

#alert-cancel-button:hover {
    background-color: #1D4ED8;
}

#alert-cancel-button span {
    color: white !important;
    font-weight: bold !important;
}


    
    
#accident-alert-button-map {
    background-color: white !important; /* Estilo para el botón en el mapa */
}

#proximity-alert-modal {
    position: fixed;
    top: 25px; 
    left: 25px; 
    background-color: white;
    border: 2px solid black; border-radius: 0.75rem;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4); z-index: 8500;
    padding: 0.8rem; display: flex; align-items: center;
    gap: 0.8rem; max-width: 450px; 
}
#proximity-alert-modal img {
    width: 110px; 
    height: 85px;
    object-fit: contain;
}
#proximity-alert-modal .content {
    display: flex; flex-direction: column; gap: 0.5rem;
}
#proximity-alert-modal .alert-text {
    font-size: 1.3rem; 
    font-weight: bold; color: #111827;
}
#proximity-alert-modal button {
    padding: 0.6rem 1.2rem; font-size: 1rem;
    background-color: #2563EB;
    color: white; font-weight: bold; 
    border: none; border-radius: 0.25rem; cursor: pointer;
    align-self: flex-start; min-width: 120px; 
}

#flashing-border-overlay {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    box-sizing: border-box; pointer-events: none; z-index: 8499;
    border: 15px solid transparent; animation: flash-yellow-border 1s infinite;
}
@keyframes flash-yellow-border {
    0%, 100% { border-color: transparent; }
    50% { border-color: #FFFF00; }
}


/* ================================================= */
/* === INICIO: CSS PARA ICONOS DE ALERTA EN MAPA === */
/* ================================================= */
.traffic-alert-icon-container {
    width: 55px;  
    height: 55px;
    border-radius: 50%;
    background-color: white;
    border: 3px solid red;
    box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden; 
    transition: width 0.2s ease, height 0.2s ease; /* Transición suave */
}

.traffic-alert-icon-container.small {
    width: 27px; 
    height: 27px;
    border-width: 2px; 
}

.traffic-alert-icon-container img {
    width: 85%;
    height: 85%;
    object-fit: contain;
}

/* =========================================================== */
/* === FIN: CSS PARA ICONOS DE ALERTA EN MAPA (CORREGIDO) === */
/* =========================================================== */

.reminder-slide .radar-icon {
    display: block;
    margin: 0 auto 0.5rem auto; 
    width: 90px;
    height: 70px;
    object-fit: contain;
}    


/* ============================================================ */
/* === INICIO: NUEVOS ESTILOS PARA PUNTOS DE RECARGA (OCM) === */
/* ============================================================ */

.filter-modal-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: 9000;
    display: flex;
    justify-content: flex-start; 
    align-items: flex-start;    
    padding-top: 10px;          
    padding-left: 10px;         
}

.filter-modal-content {
    background-color: #E6D6A8;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    width: 90%;
    max-width: 500px;
    text-align: center;
}

.filter-modal-content h2 {
    font-size: 1.5rem;
    font-weight: bold;
    color: #333;
    margin-bottom: 20px;
}

.filter-group {
    margin-bottom: 25px;
}

.filter-group label {
    display: block;
    font-weight: bold;
    margin-bottom: 15px;
    font-size: 1.1rem;
}

.slider-container {
    position: relative;
    width: 90%;
    margin: 0 auto;
    height: 30px;
}

.slider-track, .slider-range {
    position: absolute;
    height: 5px;
    border-radius: 3px;
    top: 12.5px;
    width: 100%;
}

.slider-track {
    background-color: #ccc;
    z-index: 1;
}

.slider-range {
    background-color: #2563EB;
    z-index: 2;
}

.slider-thumb {
    position: absolute;
    width: 25px;
    height: 25px;
    background-color: white;
    border: 2px solid #2563EB;
    border-radius: 50%;
    top: 2.5px;
    z-index: 3;
    cursor: pointer;
    box-shadow: 0 0 5px rgba(0,0,0,0.2);
}
  
.slider-thumb.left {
    left: 0%;
    transform: translateX(-50%);
}
.slider-thumb.right {
    right: 0%;
    transform: translateX(50%);
}

.filter-modal-content button#accept-filters-btn {
    background-color: #2563EB;
    color: white;
    font-weight: bold;
    padding: 10px 30px;
    border-radius: 5px;
    border: none;
    font-size: 1.1rem;
    cursor: pointer;
    transition: background-color 0.2s;
}

.filter-modal-content button#accept-filters-btn:hover {
    background-color: #1D4ED8;
}

.single-slider-container .slider-range {
    left: 0;
}

.single-slider-container .slider-thumb {
    transform: translateX(-50%);
}

.filter-help-text {
    font-size: 0.8rem; 
    color: #555; 
    margin-top: 15px; 
    padding-top: 10px; 
    border-top: 1px solid #ccc; 
    text-align: left;
}

/* === INICIO: CORRECCIÓN PARA ICONO DE PDR EN ZOOM ALEJADO === */
  .charging-point-card {
    width: 90px;
    height: 90px;
    background-color: rgb(30, 144, 255);
    color: white;
    border: 2px solid white;
    border-radius: 50%;
    padding: 5px;
    box-sizing: border-box;
    font-family: sans-serif;
    text-align: center;
    box-shadow: 0 2px 6px rgba(0,0,0,0.6);
    cursor: pointer;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 1px;
}

/* Regla general para los textos dentro del círculo */
.charging-point-card p, .charging-point-card span {
    margin: 0;
    padding: 0;
    line-height: 1.1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.charging-point-card .power,
.charging-point-card .price {
    display: inline-flex;
    align-items: baseline; 
    gap: 0.2em;            
}

.charging-point-card .power {
    font-size: 1.1rem;
    font-weight: bold;
    color: #ffd700;
    order: 1;
}

.charging-point-card .operator {
    font-size: 0.8rem;
    font-weight: bold;
    order: 2;
    width: 90%;        
    padding: 0 2px;    
    box-sizing: border-box; 
 }

.charging-point-card .price {
    font-size: 0.9rem;
    font-weight: bold;
    color: #90ee90;
    order: 3;
}

.charging-point-card .availability {
    font-size: 0.75rem;
    font-weight: bold
    color: #e0e0e0;
    order: 4;
}

.charging-point-card .unit-text {
    font-size: 0.85rem;
    font-weight: bold;
}  
    
  
.charging-point-icon-simple {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: rgb(30, 144, 255); /* Mismo color que el grande */
    border: 2px solid white;
    box-shadow: 0 1px 4px rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
}
.charging-point-icon-simple img {
    width: 75%;
    height: 75%;
    object-fit: contain;
}
/* === FIN: CORRECCIÓN PARA ICONO DE PDR EN ZOOM ALEJADO === */    
    
.charging-point-popup .leaflet-popup-content-wrapper {
    background-color: #E6D6A8;
    color: #333;
    border-radius: 8px;
    border: 1px solid #C0B080;
}
.charging-point-popup .leaflet-popup-content {
    font-family: sans-serif;
    font-size: 1rem;
    line-height: 1.4;
    padding: 10px;
    width: 300px !important;
}
.charging-point-popup h3 {
    font-size: 1.2rem;
    font-weight: bold;
    margin-bottom: 8px;
    color: #1E3A8A;
}
.charging-point-popup h4 {
    font-size: 1.1rem;
    font-weight: bold;
    margin-top: 10px;
    margin-bottom: 5px;
    border-top: 1px solid #ccc;
    padding-top: 8px;
}
.charging-point-popup p {
    margin: 4px 0;
}
.charging-point-popup .ocm-connection-list {
    list-style: none;
    padding: 0;
    margin: 0;
}
.charging-point-popup .ocm-connection-list li {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
    border-bottom: 1px solid #D8CEC0;
}
.charging-point-popup .ocm-connection-list li:last-child {
    border-bottom: none;
}
.charging-point-popup .conn-type {
    font-weight: 500;
    flex-basis: 45%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.charging-point-popup .conn-power {
    flex-basis: 20%;
    text-align: center;
}
.charging-point-popup .conn-status {
    flex-basis: 35%;
    text-align: center;
    color: white;
    padding: 2px 5px;
    border-radius: 3px;
    font-size: 0.8rem;
    font-weight: bold;
}
.charging-point-popup .popup-buttons {
    display: flex;
    justify-content: space-around;
    margin-top: 12px;
}
.charging-point-popup button {
    padding: 6px 12px;
    font-size: 1rem;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
}
.charging-point-popup .add-to-route-btn {
    background-color: #28a745;
    color: white;
}
.charging-point-popup .cancel-btn {
    background-color: #6c757d;
    color: white;
}
/* ========================================================== */
/* === FIN: NUEVOS ESTILOS PARA PUNTOS DE RECARGA (OCM) === */
/* ========================================================== */


/* =================================================================== */
/* === INICIO: CSS PARA AYUDAS DE GIRO EN ORIENTACIÓN SUR (V3) === */
/* =================================================================== */

.intersection-turn-helper {
    position: absolute;
    width: 60px; 
    height: 60px;
    background-color: white;
    border: 2px solid #333;
    border-radius: 6px;
    z-index: 7001; 
    display: none; 
    justify-content: center;
    align-items: center;
    box-shadow: 0 4px 8px rgba(0,0,0,0.4);
   }
.intersection-turn-helper img {
    width: 90%;
    height: 90%;
    object-fit: contain;
    image-rendering: pixelated;
}

/* =================================================================== */
/* === FIN: CSS PARA AYUDAS DE GIRO EN ORIENTACIÓN SUR (V3) === */
/* =================================================================== */    


/* ================================================== */
/* === INICIO: ESTILOS PARA EL MODAL DE PDR (OCM) === */
/* ================================================== */

.ocm-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.75);
    z-index: 9500;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 15px;
}

.ocm-modal-content {
    background-color: #2c2c2e;
    color: #f0f0f0;
    border-radius: 12px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.5);
    width: 100%;
    max-width: 550px;
    height: 90vh;
    max-height: 700px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    border: 1px solid #444;
}

.ocm-modal-header {
    height: 180px;
    background-size: cover;
    background-position: center;
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding: 12px;
    color: white;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
}

.ocm-modal-header::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 40%, rgba(0,0,0,0.1) 70%, rgba(0,0,0,0) 100%);
}

.ocm-modal-address {
    font-size: 1.2rem;
    font-weight: bold;
    position: relative;
    z-index: 1;
    
}

.ocm-modal-operator-wrapper {
    position: relative;
    z-index: 1;
    align-self: flex-start;
}

.ocm-modal-operator {
    font-size: 1.3rem;
    font-weight: bold;
    background-color: rgba(0, 0, 0, 0.6);
    padding: 4px 10px;
    border-radius: 6px;
    display: inline-block;
    box-shadow: 0 2px 4px rgba(0,0,0,0.4);
}

.ocm-modal-tabs {
    display: flex;
    background-color: #1c1c1e;
    border-bottom: 1px solid #444;
}

.ocm-modal-tab {
    flex: 1;
    padding: 12px;
    text-align: center;
    font-weight: bold;
    cursor: pointer;
    border-bottom: 3px solid transparent;
    transition: background-color 0.2s, border-color 0.2s;
    color: #a0a0a0;
}

.ocm-modal-tab:hover {
    background-color: #3a3a3c;
}

.ocm-modal-tab.active {
    border-bottom-color: #007aff;
    color: white;
}

.ocm-modal-body {
    flex-grow: 1;
    overflow-y: auto;
    padding: 15px;
}

.ocm-modal-panel {
    display: none;
}

.ocm-modal-panel.active {
    display: block;
}

.ocm-modal-panel h4 {
    font-size: 1.1rem;
    font-weight: bold;
    color: #007aff;
    margin-top: 15px;
    margin-bottom: 8px;
    border-bottom: 1px solid #444;
    padding-bottom: 5px;
}
.ocm-modal-panel h4:first-child {
    margin-top: 0;
}

.ocm-modal-panel p, .ocm-modal-panel li {
    font-size: 0.95rem;
    line-height: 1.5;
    margin-bottom: 5px;
}

.ocm-modal-panel a {
    color: #0a84ff;
    text-decoration: none;
}
.ocm-modal-panel a:hover {
    text-decoration: underline;
}

.ocm-photo-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 10px;
}
.ocm-photo-grid img {
    width: 100%;
    height: 120px;
    object-fit: cover;
    border-radius: 8px;
    cursor: pointer;
    transition: transform 0.2s;
}
.ocm-photo-grid img:hover {
    transform: scale(1.05);
}

.ocm-comment-list {
    list-style: none;
    padding: 0;
}
.ocm-comment {
    background-color: #3a3a3c;
    padding: 12px;
    border-radius: 8px;
    margin-bottom: 10px;
}
.ocm-comment-header {
    display: flex;
    justify-content: space-between;
    font-size: 0.8rem;
    color: #a0a0a0;
    margin-bottom: 5px;
}
.ocm-comment-header .user {
    font-weight: bold;
}

.ocm-modal-footer {
    padding: 15px;
    border-top: 1px solid #444;
    display: flex;
    gap: 15px;
}

.ocm-modal-footer button {
    flex: 1;
    padding: 12px;
    font-size: 1.1rem;
    font-weight: bold;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    transition: background-color 0.2s, opacity 0.2s;
}

#ocm-add-route-btn {
    background-color: #34c759;
    color: white;
}
#ocm-add-route-btn:hover {
    background-color: #2fb350;
}

#ocm-close-btn {
    background-color: #5856d6;
    color: white;
}
#ocm-close-btn:hover {
    background-color: #4f4dbf;
}

.ocm-modal-station-name-wrapper {
    align-self: flex-start;
    width: 100%;
    text-align: left;
}
.ocm-modal-station-name {
    font-size: 1.4rem;
    font-weight: bold;
    background-color: rgba(0, 0, 0, 0.6);
    padding: 4px 10px;
    border-radius: 6px;
    display: inline-block;
    box-shadow: 0 2px 4px rgba(0,0,0,0.4);
    margin-bottom: auto; /* Empuja hacia arriba */
    color: #fdfbd4;   
}
.ocm-modal-address {
    font-size: 1.1rem;
    font-weight: bold;
    position: relative;
    z-index: 1;
    padding: 5px 5px;
    align-self: flex-start; /* Alinea a la izquierda */
    margin-top: auto; /* Empuja hacia abajo */
}   

/* ========================================================= */
/* === INICIO: ESTILOS ADICIONALES PARA MODAL DE PDR V2 === */
/* ========================================================= */

.ocm-connection-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
    border-bottom: 1px solid #3a3a3c;
}
.ocm-connection-item:last-child {
    border-bottom: none;
}
.ocm-connection-type {
    flex-basis: 50%;
    font-weight: 500;
}
.ocm-connection-power-status {
    flex-basis: 50%;
    text-align: right;
    color: #b0b0b0;
    color: #fdfbd4;
    font-weight: bold;
}
p.ocm-price-info {
    margin-top: 12px;
    font-size: 1.1rem;
    color: #fdfbd4; /* Color amarillo para el precio */
    text-align: center;
}

/* Modal para visualizar fotos */
.ocm-photo-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    z-index: 9600; /* Por encima del modal principal */
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
}
.ocm-photo-modal-content {
    position: relative;
    max-width: 90vw;
    max-height: 90vh;
}
.ocm-photo-modal-content img {
    max-width: 100%;
    max-height: 100%;
    border-radius: 8px;
    box-shadow: 0 0 30px rgba(0,0,0,0.5);
}
.ocm-photo-modal-close-btn {
    position: absolute;
    top: -15px;
    right: -15px;
    width: 35px;
    height: 35px;
    background-color: white;
    color: black;
    border-radius: 50%;
    border: 2px solid #333;
    font-size: 24px;
    font-weight: bold;
    line-height: 32px;
    text-align: center;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}    
/* ================================================ */
/* === FIN: ESTILOS PARA EL MODAL DE PDR (OCM) === */
/* ================================================ */
.pdr-search-highlight {
    border: 3px solid yellow !important;
    box-shadow: 0 0 10px yellow, 2px 5px 4px rgba(0,0,0,0.65) !important;
    transform: scale(1.05);
}

/* ========================================================= */
/* === INICIO: ESTILOS PARA MODAL ELECTROVERSE (IFRAME) === */
/* ========================================================= */

.electroverse-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    z-index: 9600; /* Superior al modal del PDR */
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    box-sizing: border-box;
}

.electroverse-modal-content {
    position: relative;
    width: 95%;
    height: 95%;
    background: #1c1c1e; /* Color de fondo por si tarda en cargar */
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    overflow: hidden; /* Para que el iframe no se salga de los bordes redondeados */
}

.electroverse-modal-content iframe {
    width: 100%;
    height: 100%;
    border: none;
}

.electroverse-modal-close-btn {
    position: absolute;
    top: -15px;
    right: -15px;
    width: 35px;
    height: 35px;
    background-color: #f0f0f0;
    color: #333;
    border-radius: 50%;
    border: 2px solid #555;
    font-size: 24px;
    font-weight: bold;
    line-height: 32px;
    text-align: center;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    z-index: 10;
}

.electroverse-verify-button {
    display: block;
    width: calc(100% - 10px);
    margin: 15px 5px 5px 5px;
    padding: 10px;
    font-size: 0.9rem;
    font-weight: bold;
    color: white;
    background-color: #007aff;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    text-align: center;
}
.electroverse-verify-button:hover {
    background-color: #0a84ff;
}
    
</style>

    
</head>
<body class="min-h-screen bg-[#ABAB99] flex flex-col items-center p-6">

    <div class="reminder-count-globe" id="reminder-count-globe" style="display: none;"></div>

    <div id="unified-reminder-window" role="alertdialog" aria-labelledby="reminder-window-title" aria-describedby="reminder-window-desc">
        <div class="reminder-count-header" id="reminder-window-title">
            <div class="reminder-title-container">
                <span style="font-size: 1.3rem;" id="reminder-count-text-container">
                    <span id="current-reminder-index">1</span> de <span id="total-reminder-count">X</span> Recordatorios
                </span>
                <span class="swipe-hint" id="reminder-swipe-hint" style="font-size: smaller;">
                    (deslice lateralmente)
              </span>
            </div>
            <button id="hide-all-reminders-button" title="Posponer 1 minuto todos los recordatorios visibles">OCULTAR</button>
        </div>
        <div id="reminder-swiper-container" aria-live="polite">
        </div>
        <span id="reminder-window-desc" class="hidden">Deslice para ver los recordatorios vencidos. Use los botones para gestionar cada recordatorio.</span>
    </div>

    <div id="grid-filter-container">
        <input type="text" id="grid-filter-input" placeholder="Filtrar grid...">
        <button id="clear-filter-button" title="Limpiar filtro">×</button>
    </div>

<main>
    <div id="user-id-display"></div>
    <div id="bookmark-grid">
    </div>
</main>

<div class="notices-icon-container">
    <img src="https://boardinggate.github.io/Tesla/IMG_4194.jpg" alt="Toggle Avisos" class="notice-off-icon" id="notice-toggle-icon">
    <div class="notices-container">
        <div class="notice-wrapper">
            <span class="notice" id="current-notice"></span>
        </div>
    </div>
</div>

<footer>
    <div class="footer-content">
        <div class="header-container">
            <img src="https://boardinggate.github.io/Tesla/LOGOTESLA.jpg" class="header-logo">
            <div class="title-container">
                <h1 class="text-2xl font-bold inline">
                    <span class="text-2xl">BoardingGate</span>
                    <span class="text-base">Lanzador</span>
                    <span id="version" class="version-text"></span>
                </h1>
            </div>
        </div>
        <div class="footer-line">
          <a href="https://x.com/boardinggate/status/1857325553742721116?s=46" class="footer-link-green" target="_blank" rel="noopener noreferrer">Ahorremos un dinero con mis REFERIDOS</a>
        </div>

        <div class="statcounter-container">
          <div style="display: inline-flex; align-items: center; gap: 10px;">
            <script type="text/javascript">
              var sc_project=13126275;
              var sc_invisible=0;
              var sc_security="0fc568cc";
              var scJsHost = "https://";
              document.write("<sc"+"ript type='text/javascript' src='" +
              scJsHost+
              "statcounter.com/counter/counter.js'>"+"<"+"/script>");
            </script>
            <noscript><div class="statcounter"><a title="Web Analytics"
            href="https://statcounter.com/" target="_blank"><img
            class="statcounter"
            src="https://c.statcounter.com/13126275/0/0fc568cc/0/"
            alt="Web Analytics"
            referrerPolicy="no-referrer-when-downgrade"></a></div></noscript>
            <a href="https://statcounter.com/p13126275/?guest=1" class="footer-subtext">Legionarios de Elon</a>
          </div>
        </div>

        <p class="footer-subtext">La inteligencia tiene ciertos limites. La locura, casi ninguno 🫶 🤟</p>
    </div>
</footer>

<div id="pin-modal-overlay" class="hidden">
    <div id="pin-modal-content">
        <h2>Introducir Clave de Acceso</h2>
        <div class="modal-top-buttons" style="justify-content: center;">
            <button id="pin-submit-button">Entrar</button>
        </div>
        <label for="pin-input">Clave (4 cifras):</label>
        <input type="password" id="pin-input" maxlength="4" pattern="\d{4}" inputmode="numeric" required>
        <p id="pin-error-message"></p>
    </div>
</div>

<div id="versions-modal-overlay" class="versions-modal-overlay hidden">
    <div class="versions-modal-content">
        <h2>Histórico de versiones y recomendaciones</h2>
        <div class="modal-top-buttons" style="justify-content: flex-end;">
             <button id="close-versions-modal" style="flex: 0 1 auto; min-width: 120px;">Salir</button>
        </div>
        <pre id="versions-content">Cargando...</pre>
    </div>
</div>

<div id="reorder-stages-modal" class="hidden">
    <h2>Ordenar Etapas de Ruta</h2>
    <div class="modal-top-buttons">
        <button id="confirm-reorder-stages">Aceptar <span class="button-countdown-timer"></span></button>
        <button id="cancel-reorder-stages">Cancelar</button>
    </div>
    <p style="font-size: 0.9rem; color: #555; margin-bottom: 1rem;">Arrastra y suelta las etapas para cambiar su orden. Pulsa el aspa (X) para eliminar una etapa.</p>
    <ul id="sortable-stages-list">
    </ul>
</div>

<div id="scroll-toggle" class="scroll-toggle-button" title="Ir al inicio o fin">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M19 12l-7 7-7-7"/></svg>
</div>


<div id="config-modal" class="hidden">
    <div class="modal-top-buttons">
        <h2>Configuración y Datos</h2>
        <button id="config-close-modal" style="padding: 0.5rem 1rem; font-size:1rem;">Cerrar</button>
    </div>
    <div class="tab-buttons">
        <button class="config-tab-button active" data-tab-target="#tab-content-usuario">Usuario</button>
        <button class="config-tab-button" data-tab-target="#tab-content-pin">Clave Acceso</button>
        <button class="config-tab-button" data-tab-target="#tab-content-radares">RADARES</button>
        <button class="config-tab-button" data-tab-target="#tab-content-backup-restore">Backup/Restore</button>
        <button class="config-tab-button" data-tab-target="#tab-content-borrar">Borrar Datos</button>
        <button class="config-tab-button" data-tab-target="#tab-content-normas">Normas uso</button>
    </div>
    <div class="tab-contents">
        <div id="tab-content-usuario" class="config-tab-content active">
            <h3>Datos de Usuario y Sincronización</h3>
            <p style="font-size:.9rem;color:#555;margin-bottom:1.5rem;text-align:center;">
                Introduce un nombre de usuario único para guardar y recuperar tus datos en la nube.
            </p>
            <p style="font-size: .95rem; color: #005A9C; margin-bottom: 1.5rem; text-align: left; background-color: #e6f7ff; padding: 10px; border-radius: 5px; border-left: 5px solid #007bff;">
                <strong>Modo Compañero (Móvil):</strong> Para sincronizar datos desde tu móvil, usa tu nombre de usuario seguido de <strong>@MOVIL o MÓVIL</strong> (ej: `MI_USUARIO@MOVIL`).
                Al iniciar sesión, se cargarán los ÚLTIMOS DATOS que el coche haya GUARDADO EN LA NUBE. Cada cambio que hagas en el móvil (crear rutas, etc.) se guardará automáticamente en la nube para que esté disponible en el coche al CARGAR. 
                 -----IMPORTANTE!!!!---- SI QUIERES ENVIAR DATOS DESDE EL MÓVIL RECUERDA ANTES FORZAR UNA RECARGA DE LA PÁGINA EN EL COCHE (debes tener el check activo de copias automáticas) O REALIZAR MANUALMENTE UN BACKUP</p>
            <div class="user-data-grid">
                <div><label for="user-id">* ID Usuario (Único, no se puede cambiar):</label><input type="text" id="user-id" name="userId" required></div>
                <div><label for="tesla-model">Modelo Tesla:</label><input type="text" id="tesla-model" name="teslaModel"></div>
                <div><label for="tesla-year">Año Modelo:</label><input type="number" id="tesla-year" name="teslaYear" min="2012" max="2099"></div>
                <div><label for="tesla-province">Provincia:</label><input type="text" id="tesla-province" name="teslaProvince"></div>
                <div class="checkbox-container">
                    <input type="checkbox" id="allow-dms" name="allowDMs"><label for="allow-dms">Permitir MDs (vía admin)</label>
                </div>
                <div class="checkbox-container" style="border-top: 1px solid #ccc; padding-top: 1rem; margin-top: 1rem;">
                    <input type="checkbox" id="config-auto-backup-on-load" name="autoBackup">
                    <label for="config-auto-backup-on-load">Sincronizar/Hacer copia de seguridad automática al cargar la página (en el coche)</label>
                </div>
            </div>
            <div class="user-buttons-container" style="margin-top:1.5rem;">
                <button id="config-save-user-firebase" style="background-color:#16A34A;color:white;">Validar usuario y/o Sincronizar/Guardar en la nube</button>
            </div>
            <p id="config-user-status" class="status-message"></p>
            </div>
         <div id="tab-content-pin" class="config-tab-content">
             <h3>Clave de Acceso (Local)</h3>
             <div class="pin-buttons-container" style="margin-bottom: 1rem;">
                 <button id="config-save-pin" style="background-color:#2563EB;color:white;">Guardar Clave y Preferencias</button>
                 <button id="config-remove-pin" style="background-color:#dc3545;color:white;">Quitar Clave</button>
             </div>
             <p style="font-size: 0.9rem; color: #555; margin-bottom: 1rem;">Establece una clave de 4 cifras para proteger el acceso inicial a la página</p>
             <div class="pin-config-layout">
                 <div class="pin-input-group">
                     <label for="config-pin-set">Establecer/Cambiar Clave:</label>
                     <input type="password" id="config-pin-set" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="4 cifras">
                 </div>
                 <div class="pin-input-group">
                     <label for="config-pin-confirm">Confirmar Clave:</label>
                     <input type="password" id="config-pin-confirm" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="Repetir 4 cifras">
                 </div>
             </div>
             <div class="checkbox-container" style="margin-top: 1.5rem; border-top: 1px solid #ccc; padding-top: 1rem;">
                <input type="checkbox" id="config-direct-to-nav" name="directToNav">
                <label for="config-direct-to-nav">Entrar directamente al Navegador de rutas</label>
            </div>
             <p id="config-pin-status" class="status-message"></p>
         </div>
         <div id="tab-content-radares" class="config-tab-content">
            <h3>Importar / Borrar Radares y Otros POIs</h3>
            <div class="radar-action-buttons" style="margin-bottom: 1rem;">
                <button id="import-radars-button">IMPORTAR RADARES y otros</button>
                <button id="delete-filtered-radars-button">BORRAR CACHÉ (según filtro)</button>
            </div>
            <p style="font-size:0.85rem; color:#444; margin-bottom:0.5rem;">
                Para <strong>importar</strong>, el filtro de "Palabras Clave" buscará coincidencias (OR) en el nombre del POI (ej: provincia, población, tipo).
                Los filtros de Lat/Lon pueden ser un valor único (aprox.) o un rango (ej: "<code>40.1 40.5</code>" para buscar entre esas latitudes). Si un filtro está vacío, no se aplica.
            </p>
             <p style="font-size:0.85rem; color:#444; margin-bottom:1rem;">
                 Los POIs importados (RADARES) se guardarán con un radio de <strong>400 metros</strong> y excluidos de la lista por defecto.
             </p>
            <p style="font-size:0.85rem; color:#444; margin-bottom:1.5rem;">
                Para <strong>borrar</strong>: Si NO se especifica NINGÚN filtro, se borrarán TODOS los recordatorios de tipo "RADAR:" o excluidos de lista. Si se especifica algún filtro, se borrarán los que cumplan TODAS las condiciones activas (Palabras Clave OR, Latitud Y Longitud).
            </p>
            <div class="radar-filter-group">
                <div>
                    <label for="radar-filter-lat">Latitud (valor o "min max"):</label>
                    <input type="text" id="radar-filter-lat" placeholder="Ej: 40.123 o 40.0 40.5">
                </div>
                <div>
                    <label for="radar-filter-lon">Longitud (valor o "min max"):</label>
                    <input type="text" id="radar-filter-lon" placeholder="Ej: -3.567 o -4.0 -3.0">
                </div>
                <div style="grid-column: span 2;">
                    <label for="radar-filter-keywords">Palabras Clave (en nombre POI, separadas por espacio, condición OR):</label>
                    <input type="text" id="radar-filter-keywords" placeholder="Ej: FIJO CAMUFLADO MADRID">
                </div>
            </div>
            <div class="radar-import-options">
                <input type="checkbox" id="import-extra-radars-checkbox">
                <label for="import-extra-radars-checkbox">Importar también radares móviles, semáforo, etc (usa ficheros KLM adicionales)</label>
            </div>
             <div id="radar-import-progress-container" style="display:none;">
                 <progress id="radar-import-progress-bar" value="0" max="100"></progress>
                 <p id="radar-import-status" class="status-message"></p>
             </div>
         </div>
        <div id="tab-content-backup-restore" class="config-tab-content">
            <h3>Recuperar Backup / Hacer Copia en la Nube</h3>
            <p style="margin-bottom:1.2rem;">
                Para <strong>Recuperar</strong>, introduce tu ID de usuario y pulsa el botón naranja.<br>
                Para <strong>Hacer una Copia de Seguridad</strong>, asegúrate de que tu ID está introducido en la pestaña "Usuario" y pulsa el botón verde.
            </p>
            
            <div class="user-data-grid" style="grid-template-columns: 1fr auto; align-items: end; gap: 1rem;">
                <div style="grid-column: 1 / 2;">
                    <label for="restore-user-id">ID Usuario a recuperar:</label>
                    <input type="text" id="restore-user-id" placeholder="Tu apodo único (el que está en la pestaña usuario)...">
                </div>
                <div style="grid-column: 2 / 3; display: flex; flex-direction: column; gap: 0.5rem;">
                    <button id="config-restore-backup-firebase" style="background-color:#E65100;color:white;width:100%;padding: 0.6rem 1rem;">Recuperar Backup de la nube</button>
                    <button id="config-save-user-firebase-from-backup-tab" style="background-color:#16A34A;color:white;width:100%;padding: 0.6rem 1rem;">Hacer la copia de seguridad en la nube</button>
                </div>
            </div>
            <p id="config-restore-status" class="status-message"></p>
            <hr style="margin: 2rem 0;">
            <h3>Backup/Restore Local (Manual)</h3>
            <p style="font-size:.85rem; color:#555;">Esto es para copias manuales de texto. No interactúa con la nube</p>
            <div class="backup-restore-container" style="margin-top:1rem;">
                 <div>
                    <h4>Crear Backup Local</h4>
                     <button id="config-generate-backup" style="background-color:#2563EB;color:white; margin-bottom: 1rem;">Generar Código</button>
                    <textarea id="config-backup-display" readonly style="display:none;"></textarea>
                    <p id="config-backup-status" class="status-message"></p>
                </div>
                <div>
                    <h4>Restaurar Copia Local</h4>
                    <button id="config-restore-backup" style="background-color:#10B981;color:white; margin-bottom: 1rem;">Restaurar</button>
                    <textarea id="config-restore-input" placeholder="Pega el código de backup local aquí..."></textarea>
                </div>
            </div>
        </div>
        
        <div id="tab-content-borrar" class="config-tab-content borrar-container">
            <h3>Borrar Datos Locales</h3>
             <button id="config-restore-grid-button">RESTAURAR EL GRID ORIGINAL DE BOTONES</button>
             <p id="config-restore-grid-status" class="status-message" style="margin-bottom: 1.5rem;"></p>
            <h3 style="border-top: 1px solid #ccc; padding-top: 1.5rem; margin-top:1.5rem;">Acción Irreversible</h3>
            <button id="config-clear-cache" style="margin-bottom: 0.5rem;">Borrar TODO</button>
            <p>Elimina TODOS los datos locales.</p>
            <p><strong style="color:red;">¡Sin deshacer!</strong> Ten backup.</p>
        </div>
        <div id="tab-content-normas" class="config-tab-content">
             <h3 style="text-align: center; font-size: 1.4rem; color: #c0392b; margin-bottom: 1rem;">Aviso Importante: Uso de la Aplicación de Navegación</h3>
             <div style="text-align: left; font-size: 0.95rem; line-height: 1.5; color: #333; max-height: 45vh; overflow-y: auto; padding-right: 10px;">
                 <p>¡Bienvenido/a a nuestra aplicación de navegación de rutas para coche! Hemos diseñado esta herramienta con la mejor intención de ayudarte a planificar tus viajes.</p>
                 <p style="margin-top: 1rem;">Sin embargo, es fundamental que entiendas que el uso de esta aplicación es <strong>bajo tu propia y exclusiva responsabilidad</strong>. Al utilizar nuestra web, aceptas plenamente las siguientes condiciones:</p>
                 <ul style="list-style-type: disc; margin-left: 20px; margin-top: 1rem; space-y: 0.5rem;">
                     <li><strong>Responsabilidad del usuario:</strong> Eres el único/a responsable de la toma de decisiones al volante. Nuestra aplicación es una herramienta de apoyo y nunca debe sustituir tu juicio, la observación directa de las condiciones de la vía, las señales de tráfico o la normativa de circulación vigente.</li>
                     <li><strong>Supervisión constante:</strong> La aplicación debe ser utilizada siempre bajo tu supervisión activa. La información proporcionada (cartografía, trazados, indicaciones, etc.) puede no estar actualizada en tiempo real o contener imprecisiones. Las condiciones de la carretera, el tráfico o las regulaciones pueden cambiar sin previo aviso.</li>
                     <li><strong>Conducción segura:</strong> Prioriza siempre la seguridad. Evita manipular la aplicación mientras conduces y presta toda tu atención a la carretera. Detente en un lugar seguro para consultar la ruta si es necesario.</li>
                     <li><strong>Errores y fallos:</strong> Aunque nos esforzamos por ofrecer un servicio fiable, no podemos garantizar que la aplicación esté libre de errores, interrupciones o fallos. No nos hacemos responsables de ningún daño, perjuicio o incidente que pueda derivarse del uso o la imposibilidad de uso de esta aplicación.</li>
                     <li><strong>Actualizaciones:</strong> Te recomendamos mantener tu navegador y sistema operativo actualizados para el mejor funcionamiento de la aplicación, aunque no podemos garantizar la compatibilidad total con todos los dispositivos y versiones.</li>
                 </ul>
                 <p style="margin-top: 1rem;">Al continuar utilizando esta aplicación, confirmas que has leído, entendido y aceptado este descargo de responsabilidad. ¡Disfruta de tu viaje con precaución!</p>
             </div>
             <div style="text-align: center; margin-top: 1.5rem;">
                 <button id="accept-terms-button" style="background-color:#28a745; color:white; padding: 0.8rem 2rem; font-size: 1.2rem; border-radius: 0.25rem;">Acepto</button>
             </div>
         </div>
    </div>
</div>


    
<div id="simulation-modal" class="hidden">
</div>

<div id="simulation-speed-modal" class="hidden">
</div>

<div id="locations-preview-modal" class="hidden">
    <h2 id="locations-preview-title">Ubicaciones (filtrado según tabla)</h2>
    <div id="locations-preview-map-container" style="height: calc(100% - 100px); width: 100%;"></div>
    <div class="modal-top-buttons" style="justify-content: center; margin-top: 1rem;">
        <button id="close-locations-preview">Salir</button>
    </div>
</div>

<div id="address-suggestions-modal" class="hidden">
    <h2 id="address-suggestions-title">Sugerencias de Dirección</h2>
    <ul id="address-suggestions-list"></ul>
    <div class="modal-top-buttons" style="justify-content: flex-end; margin-top: 1rem;">
        <button id="close-address-suggestions-modal" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
    </div>
</div>

<div id="deviation-modal" class="hidden">
</div>

<div id="arrival-stats-modal" class="hidden">
</div>

<div id="intersection-preview-map-window" class="hidden">
    <div id="intersection-preview-map-container"></div>
</div>

<div id="alert-modal-overlay" class="hidden">
    <div id="alert-modal-content">
        <!-- Las opciones se generarán dinámicamente con JavaScript -->
    </div>
</div>

<div id="proximity-alert-modal" class="hidden">
    <!-- El contenido se generará dinámicamente con JavaScript -->
</div>

<div id="flashing-border-overlay" class="hidden"></div>
    
<script>
    const originalToFixed = Number.prototype.toFixed;
    Number.prototype.toFixed = function(digits) {
        if (this === undefined || this === null || isNaN(this)) {
            try {
                throw new Error("Debug toFixed Call");
            } catch (e) {
            }
            return "NaN";
        }
        return originalToFixed.call(this, digits);
    };

   const OCM_API_KEY = "be9a78f7-0f5e-4f28-b742-4b7ab4b7eb5a";
    
    let pdrSearchState = 'initial'; // Estados: 'initial', 'results_shown', 'cheapest_shown'
    let lastPdrSearchResults = []; // Para guardar los resultados completos de la última búsqueda
    
    let chargingPointsLayer = null;
    let currentChargingPointsOnRoute = [];
 
    let trafficAlertsCache = [];
    let trafficAlertsLayer = null;
    let lastAlertCheckTimestamp = 0;
    const ALERT_CHECK_INTERVAL = 15 * 60 * 1000;
    let currentlyDisplayedProximityAlerts = new Set();
    let alertModalTimer = null;
    let proximityAlertTimer = null;

    let tripStartLocationForStats = null; // Guardará la ubicación al pulsar "Iniciar Navegación"
    
    let stageScrollTimeout;
    let locationsPreviewMap = null;
    let globalModalTimers = {};
    const originalBookmarks = [ { name: "YouTube", url: "https://www.youtube.com" }, { name: "Google", url: "https://www.google.com" }, { name: "GDrive", url: "https://drive.google.com", favicon: "./IMG_4172.png" }, { name: "GMail", url: "https://mail.google.com/mail/mu/mp/603/#tl/Recibidos", favicon: "./IMG_4171.png"}, { name: "Google Fotos", url: "https://photos.google.com" }, { name: "iCloud", url: "https://www.icloud.com/", favicon: "https://www.google.com/s2/favicons?domain=icloud.com&sz=64t" }, { name: "ABRP", url: "https://abetterrouteplanner.com" }, { name: "ElectroMaps", url: "https://map.electromaps.com/es/", favicon: "https://www.google.com/s2/favicons?domain=electromaps.com&sz=64" }, { name: "REVE PdR España", url: "https://www.mapareve.es/mapa-puntos-recarga", favicon: "https://www.google.com/s2/favicons?domain=mapareve.es&sz=64" }, { name: "Ver ubicaciones", url: "map-action:openRemindersMapWithNoRadars", favicon: "https://www.google.com/s2/favicons?domain=google.com/maps&sz=64" }, { name: "Google Maps", url: "https://maps.google.com" }, { name: "WhatsApp", url: "https://web.whatsapp.com/" }, { name: "TESSIE", url: "https://dash.tessie.com/signin", favicon: "https://www.google.com/s2/favicons?domain=tessie.com&sz=64" }, { name: "Mis Updates", url: "https://dash.tessie.com/software", favicon: "https://cdn-icons-png.flaticon.com/512/148/148767.png" }, { name: "Olas Updates", url: "https://es.stats.tessie.com/", favicon: "https://cdn-icons-png.flaticon.com/512/5815/5815902.png" }, { name: "NotaTeslaApp", url: "https://www.notateslaapp.com/software-updates/" }, { name: "ENHAUTO", url: "https://www.enhauto.com" }, { name: "MAREAS", url: "https://www.meteogalicia.gal/web/predicion/mareas-e-luas" }, { name: "ELECTROVERSE", url: "https://electroverse.com/es/map", favicon: "https://www.google.com/s2/favicons?domain=electroverse.com&sz=64" }, { name: "ACCIONA", url: "https://www.google.com/maps/search/recarga+Acciona", favicon: "https://www.google.com/s2/favicons?domain=acciona.com&sz=64" }, { name: "IBERDROLA", url: "https://www.google.com/maps/search/recarga+IBERDROLA", favicon: "https://www.google.com/s2/favicons?domain=iberdrola.com&sz=64" }, { name: "WAYLET Repsol", url: "https://www.google.com/maps/search/recarga+REPSOL+Waylet", favicon: "https://www.google.com/s2/favicons?domain=repsol.com&sz=64" }, { name: "ENDESA xWay", url: "https://www.google.com/maps/search/recarga+ENDESA+XWAY", favicon: "https://www.google.com/s2/favicons?domain=endesa.com&sz=64" }, { name: "ZUNDER", url: "https://www.google.com/maps/search/recarga+ZUNDER", favicon: "https://www.google.com/s2/favicons?domain=zunder.com&sz=64" }, { name: "IONITY", url: "https://www.google.com/maps/search/recarga+IONITY", favicon: "https://www.google.com/s2/favicons?domain=ionity.eu&sz=64" }, { name: "WENEA", url: "https://www.google.com/maps/search/recarga+WENEA", favicon: "https://www.google.com/s2/favicons?domain=wenea.com&sz=64" }, { name: "T.ENERGIES", url: "https://www.google.com/maps/search/recarga+TOTAL+ENERGIES", favicon: "https://www.google.com/s2/favicons?domain=totalenergies.com&sz=64" }, { name: "GALP", url: "https://www.google.com/maps/search/recarga+GALP", favicon: "https://www.google.com/s2/favicons?domain=galp.com&sz=64" }, { name: "MIIO", url: "https://miio.com", favicon: "https://www.google.com/s2/favicons?domain=miio.com&sz=64" }, { name: "EVDC", url: "https://evdc.network", favicon: "https://www.google.com/s2/favicons?domain=evdc.network&sz=64" }, { name: "GROK", url: "https://grok.com/?referrer=website" }, { name: "CHATGPT", url: "https://chat.openai.com" }, { name: "CLAUDE", url: "https://claude.ai/new" }, { name: "GEMINI", url: "https://gemini.google.com" }, { name: "NOTEBOOKLM", url: "https://notebooklm.google.com" }, { name: "Batería", url: "https://docs.google.com/spreadsheets/d/1bLZmgVGTBqg2bS2E45JpORjs9eK2nb05AWXYLLDY-RI/edit?gid=1398548891#gid=1398548891", favicon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='10'/><polyline points='12 6 12 12 16 14'/></svg>" }, { name: "TeslaParaTodos", url: "https://teslaparatodos.com/cine/" }, { name: "BetterTheater", url: "https://abettertheater.com", favicon: "https://www.google.com/s2/favicons?domain=abettertheater.com&sz=64" }, { name: "Filmin", url: "https://www.filmin.es/catalogo/peliculas" }, { name: "Octopus", url: "https://octopusenergy.es/login" }, { name: "App MCE", url: "https://www.oscarabilleira.com/app-mi-coche-electrico/#ayuda" }, { name: "Patrón Luz", url: "https://docs.google.com/spreadsheets/d/1R7UUZ9i4BAYWAGAX6PQT1WGd12GEZ4Ja/edit?usp=sharing&ouid=108345701896498198132&rtpof=true&sd=true" }, { name: "TradingView", url: "https://es.tradingview.com/chart/t5g9UFG0/" }, { name: "Telegram", url: "https://web.telegram.org/a/" }, { name: "Twitter", url: "https://x.com" }, { name: "Maesal Detailer", url: "https://www.maesaldetailer.es/" }, { name: "Superchargers", url: "https://www.tesla.com/es_es/findus?bounds=45.41107111786193%2C19.27853056943938%2C29.703668286784747%2C-16.64676239931062" }, { name: "TESLA web", url: "https://www.tesla.com/es_es" }, { name: "Manual M3", url: "https://www.tesla.com/ownersmanual/model3/es_es/" }, { name: "de Servicio", url: "https://service.tesla.com/docs/Model3/ServiceManual/2024/es-es/" }, { name: "de Despiece", url: "https://epc.tesla.com/es-MX/catalogs/e0e07c3d-272f-4d06-b8b6-9e92f857e5f3" }, { name: "de Usted Mismo", url: "https://www.tesla.com/es_es/support/do-it-yourself-guides" }, { name: "de Filtro Cabina", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-DB0A1E3C-926E-498C-A2FD-A27B8421A471.html" }, { name: "de Móvil remoto", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-53651B16-A2E3-4118-933E-B5F41C74D433.html" }, { name: "Waze (consultas)", url: "https://www.waze.com/es/live-map/", favicon: "https://www.google.com/s2/favicons?domain=waze.com&sz=64" }, { name: "AMAZON", url: "https://www.amazon.es" }, { name: "BIP&DRIVE", url: "https://areaprivada.bipdrive.com/login" }, { name: "ITV Cita", url: "https://www.sycitv.com/es/cita-previa-particulares/", favicon: "https://boardinggate.github.io/Tesla/itv.png" }, { name: "Deportes", url: "https://www.sofascore.com/es/tenis" }, null, { name: "Jaime Odena", url: "https://www.youtube.com/@Jaimeodena", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Eduardo Arcos", url: "https://www.youtube.com/@earcos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "AutoIngenium", url: "https://www.youtube.com/@AutoIngenium", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Gallego en Munich", url: "https://www.youtube.com/@ungallegoenmunich", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Electromiaumiau", url: "https://www.youtube.com/@electromiaumiau", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Manuel Martos", url: "https://www.youtube.com/@Manuel_Martos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Todos Electricos", url: "https://www.youtube.com/@TodosElectricos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Juan Vidal Haces", url: "https://www.youtube.com/@JuanVidalHaces", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Ruedana", url: "https://www.youtube.com/@ruedana", favicon: "https://www.youtube.com/favicon.ico" }, { name: "STR-600", url: "https://www.youtube.com/@STR-600", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Juanjo T. Aventuras", url: "https://www.youtube.com/@juanjoteslaventuras", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Carlos Cuezva", url: "https://www.youtube.com/@CarlosCuezva", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Javi Manzanoo", url: "https://www.youtube.com/@javimanzanoo", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Crifedi", url: "https://www.youtube.com/@Crifedi", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Tescno Tesla", url: "https://www.youtube.com/@TecnoTesla", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Full Electric Mex", url: "https://www.youtube.com/@FullElectricMexico", favicon: "https://www.youtube.com/favicon.ico" }, null, null, { name: "La iA Jon", url: "https://www.youtube.com/@la_inteligencia_artificial", favicon: "https://www.youtube.com/favicon.ico" }, { name: "JF Ccalero", url: "https://www.youtube.com/@jfcalero", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Visual Politik", url: "https://www.youtube.com/@VisualPolitik", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Fabian Barrio", url: "https://www.youtube.com/@fabiancbarrio", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Loquetudigas", url: "https://www.youtube.com/@Loquetudigas", favicon: "https://www.youtube.com/favicon.ico" }, { name: "David Antunes", url: "https://www.youtube.com/@davidantunesmusic", favicon: "https://www.youtube.com/favicon.ico" }, { name: "TheWildProject", url: "https://www.youtube.com/@TheWildProject", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Estas Tonne", url: "https://www.youtube.com/@Estastonne", favicon: "https://www.youtube.com/favicon.ico" }, { name: "BBC6 Music", url: "https://www.youtube.com/@BBC6Music", favicon: "https://www.youtube.com/favicon.ico" }, null, null ];
    const originalToggleRanges = [ { start: 18, end: 29, name: "ELECTROVERSE", label: "PdR,s" }, { start: 30, end: 41, name: "GROK", label: "iAs" }, { start: 42, end: 59, name: "TradingView", label: "Útil" }, { start: 60, end: 95, name: "Jaimeodena", label: "Varios" } ];
    const sectionColors = { 18: '#F0E0D3', 30: '#D8D4E0', 42: '#D9E5DB', 60: '#F2ECD0', unassigned: '#C5C8B8', off: '#ABAB99' };
    const darkModeGenericButtonColor = '#ABAB99';
    const DEFAULT_LOCATION_RADIUS = 450;
    let snoozedRouteRadars = new Map();
    const MAP_SEARCH_INPUT_KEY = 'boardinggate_map_search_value';
    let gpsRetryTimeoutId = null;
    let gpsRetryAttempt = 0;
    const MAX_GPS_RETRIES = 10;
    const GPS_RETRY_DELAY_MS = 5000;
    let isMapImmersiveModeActive = false;
    let isArrivalSequenceStarted = false;
    let maxSpeedCoordinates = null;
    let progressiveZoomState = 'none';
    let mapPreviousZoomLevelForProgressive = null;
    let lastProcessedStepIdentifier = null;
    const PROGRESSIVE_ZOOM_START_DISTANCE = 180;
    const PROGRESSIVE_ZOOM_PEAK_DISTANCE = 50;
    const PROGRESSIVE_ZOOM_EXIT_START_DISTANCE = 60;
    const PROGRESSIVE_ZOOM_EXIT_END_DISTANCE = 150;
    let isZoomedForManeuver = false;
    let isFlying = false;
    let navigationTargetZoom = null;
    let currentSmoothedMapCenter = null;
    let lastMobileSyncTimestamp = 0;
    const TOTAL_CELLS = 96; const COLS = 6; const grid = document.getElementById('bookmark-grid');
    let isDarkMode = false; let pressStartTime = null; let reminderPressStartTime = null; let isActive = true; let isFooterVisible = true; let notices = []; let currentNoticeIndex = 0; let fromReminderModal = false;
    let isEditMode = false; let isAssignmentMode = false;
    let isKeywordAssignmentMode = false;
    let currentlyAssigningToggleStart = null;
    let customData = { bookmarks: {}, toggles: {} };
    let cellElements = []; let toggleButtonElements = {}; let currentBookmarks = []; let currentToggleRanges = [];
    let onOffToggle, weatherButton, reminderButton, zoomButton, darkModeToggle, versionsButton, infoButton;
    let radarButton;
    let initialUserLocationCircle = null;
    let firstPersonalizationSession = !sessionStorage.getItem('personalizationHelpShown');
    let editingTargetElement = null; let draggedItem = null; let draggedItemIndex = null; let dragOverIndex = null;
    let touchStartX = 0; let touchStartY = 0; let currentTouchTarget = null;
    let isPasswordActive = false; let storedPin = null;
    let reminderCheckIntervalId = null;
    let currentCheckIntervalDuration = 3000;
    let lastUpdatesCheckDate = localStorage.getItem('lastUpdatesCheckDate');
    let currentNotificationSlideIndex = 0;
    let isUnifiedWindowVisibleByLogic = false;
    let reminderModalMap = null;
    let reminderMarker = null;
    let reminderCircle = null;
    let previewMaps = {};
    const MAX_SAVED_LOCATIONS = 15;
    const SAVED_LOCATIONS_KEY = 'boardinggate_saved_locations';
    const SHOW_EXCLUDED_REMINDERS_KEY = 'boardinggate_showExcludedRemindersInTable';
    const RADARES_RUTA_CHECKED_KEY = 'boardinggate_radaresRutaCheckboxChecked';
    const TAREAS_RUTA_CHECKED_KEY = 'boardinggate_tareasRutaCheckboxChecked';
    const ACTIVE_MAP_LAYER_KEY = 'boardinggate_activeMapLayer';
    const DIRECT_TO_NAVIGATION_KEY = 'boardinggate_directToNavigation';
    const MAP_ENTRY_OVERRIDE_KEY = 'boardinggate_map_entry_override';
    const TEMP_PREVENT_DIRECT_NAV_KEY = 'tempPreventDirectNavAfterMapExit';
    const GRAPH_STATE_KEY = 'boardinggate_graphState';
    let locationPickerMap = null;
    let locationPickerMarker = null;
    let currentEditingLocationSlotIndex = -1;
    let tempSavedLocations = [];
    let navigationMapInstance = null;
    let isNavigationMapActive = false;
    let completedRouteSegmentsLayer = null;
    let initialUserLocationMarker = null;
    let initialUserLocationMarkerLat = null;
    let initialUserLocationMarkerLng = null;
    let navigationCurrentLocation = null;
    let locationWatchId = null;
    let shouldCenterOnUser = false;
    let navigationFollowUser = false;
    let mapPreviousZoomLevel = null;
    const MIN_MANEUVER_ZOOM_LEVEL = 17;
    let currentMapBearing = 0;
    let currentMapRotationAngle = 0;
    let currentMapCenterOffset = { x: 0, y: 0 };
    let targetMapCenterOffset = { x: 0, y: 0 };
    let mapOffsetAnimationId = null;
    let miniMapOffsetActive = { x: 0, y: 0 };
    let lastHeadingForTilt = 0;
    let compassAndModeControl = null;
    let navigationWaypoints = [];
    let navigationRouteLayer = null;
    let navigationCurrentRouteData = null;
    let isNavigating = false;
    let routeStartTime = null;
    let navigationStartTimeForStats = null;
    let totalDistanceTravelledForStats = 0;
    let accumulatedDistanceBeforeCurrentSegment = 0;
    let lastPositionForStats = null;
    let maxDistanceReachedOnRoute = 0; 
    let maxSpeedDuringTrip = 0;
    let maxAltitudeDuringTrip = -Infinity;
    let minAltitudeDuringTrip = Infinity;
    window.lastPositionForSpeedCalc = null;
    window.currentSpeedKmh = 0;
    window.averageSpeedKmh = 0;
    let isSimulatingGpsLocation = false;
    let simulatedGpsLocation = null;
    let automatedSimulationIntervalId = null;
    let simulatedDistanceAlongRoute = 0;
    let simulationSpeedKmph = 85;
    let currentSimulationSpeedKmph = 85; 
    const SIMULATION_TICK_INTERVAL_MS = 300;
    let maxSpeedMarkerLayer = null; 
    let speedMilestoneLayer = null;
    let lastSpeedMilestone = 0;
    const SPEED_MILESTONES = [50, 60, 80, 100, 110, 120, 130, 150];
    const OSRM_SERVICE_URL = 'https://router.project-osrm.org/route/v1';
    const SAVED_ROUTES_KEY = 'boardinggate_saved_routes';
    const MAX_SAVED_ROUTES = 100;
    let currentRouteNameForSaving = null;
    let navigationMapClickHandler = null;
    let draggedStageLi = null;
    const DEVIATION_THRESHOLD_METERS = 100;
    const DEVIATION_MIN_TIME_SECONDS = 5;
    let deviationStartTime = 0;
    let isRecalculatingRoute = false;
    let deviationModalTimerId = null;
    let isDeviationModalActive = false;
    const WAYPOINT_VISITED_THRESHOLD_METERS = 100;
    let currentLegIndexNav = 0;
    let currentStepIndexNav = 0;
    let lastCarDistanceAlongRouteForNavLogic = 0;
    let lastValidCarDistanceForDisplay = 0;
    let lastProcessedStepManeuverLocation = null;
    let recalculationRetryTimeoutId = null;
    let recalculationAttempts = 0;
    let isAddReminderAtLocationModeActive = false;
    let addReminderAtLocationButton = null;
    let simulationModalTimer = null;
    let autoStartNavTimer = null;
    let mapLayersControl = null;
    let searchToastShown = false;
    let pendingPositionToProcess = null;
    const KML_FILES_LIST_STANDARD = './KLM/KLMFILES.TXT';
    const KML_FILES_LIST_EXTRA = './KLM/KLMFILES2.TXT';
    const KML_BASE_PATH = './KLM/';
    const COORD_EPSILON = 0.00001;
    const RUTA_RADAR_PROXIMITY_THRESHOLD = 75;
    let reminderMapObjects = [];
    let radaresEnRutaActual = [];
    let tareasEnRutaActual = [];
    const STATIC_MODAL_IDS = ['config-modal', 'versions-modal-overlay', 'pin-modal-overlay', 'reorder-stages-modal', 'simulation-modal', 'locations-preview-modal', 'address-suggestions-modal', 'deviation-modal', 'arrival-stats-modal', 'simulation-speed-modal'];
    let activeToasts = [];
    let intersectionPreviewMap = null;
    let intersectionPreviewRouteLayer = null;
    let intersectionPreviewManeuverMarker = null;
    let intersectionPreviewCarMarker = null;
    let intersectionPreviewTimer = null;
    let lastAutoShownManeuverId = null;
    let directToNavOnLoad = false;
    let mapLayersControlReminder = null;
    let mapLayersControlLocationsPreview = null;
    let directionCardDerecha = null;
    let directionCardIzquierda = null;
    let navigationChart = null;
    let currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviación Ruta';
    let graphPlotState = { lastPlotTime: null, lastPlotCoords: null };
    let graphIntervalDuration = 0; 
    let graphIntervalTimer = null;
    let graphDataPoints = { speed: [], altitude: [] };
    let graphLabels = [];
    let graphExpectedAvgSpeed = 0;
    let isCarStoppedForGraph = false; 
    const GRAPH_PIXELS_PER_DATAPOINT = 2; 
    const GRAPH_BUFFER_PERCENTAGE = 0.15;
    const managedKeys = [ 'reminders','darkMode','toggleStates','zoomState','onOffState','noticesActive', 'footerVisible','teslaHtmlLastModified','teslaHtmlLastModifiedTimestamp', 'userData_userId','userData_teslaModel','userData_teslaYear','userData_teslaProvince', 'userData_allowDMs', 'customGridData', 'personalizationHelpShown', 'gridFilterValue',  'password_pin', 'password_active', 'lastUpdatesCheckDate', SAVED_LOCATIONS_KEY,  SHOW_EXCLUDED_REMINDERS_KEY, SAVED_ROUTES_KEY, RADARES_RUTA_CHECKED_KEY,  TAREAS_RUTA_CHECKED_KEY, ACTIVE_MAP_LAYER_KEY, DIRECT_TO_NAVIGATION_KEY, GRAPH_STATE_KEY, 'boardinggate_autoBackupOnLoad', 'userData_backupPassword', MAP_SEARCH_INPUT_KEY ];
    const MAP_FILTER_INPUT_KEY = 'boardinggate_map_filter_value';
    const managedDesc = managedKeys.map(k => {
            switch(k){
                case 'reminders':return 'Recordatorios'; case 'darkMode':return 'Modo Oscuro'; case 'toggleStates':return 'Visibilidad Secc.';
                case 'zoomState':return 'Zoom Grid'; case 'onOffState':return 'On/Off Gral'; case 'noticesActive':return 'Avisos/Footer';
                case 'footerVisible':return 'Vis. Footer'; case 'teslaHtmlLastModified':return 'Cache Versión'; case 'teslaHtmlLastModifiedTimestamp':return 'TS Cache';
                case 'userData_userId':return 'ID Usuario'; case 'userData_teslaModel':return 'Modelo'; case 'userData_teslaYear':return 'Año';
                case 'userData_teslaProvince':return 'Provincia'; case 'userData_allowDMs':return 'Permitir DMs'; case 'customGridData': return 'Grid Pers.';
                case 'personalizationHelpShown': return 'Ayuda Pers. Vista'; case 'gridFilterValue': return 'Filtro Grid';
                case 'password_pin': return 'PIN Acceso'; case 'password_active': return 'PIN Activo'; case 'lastUpdatesCheckDate': return 'Cache Fecha Updates';
                case SAVED_LOCATIONS_KEY: return 'Ubicaciones Guardadas';
                case SHOW_EXCLUDED_REMINDERS_KEY: return 'Mostrar Excluidos Tabla';
                case SAVED_ROUTES_KEY: return 'Rutas Guardadas';
                case RADARES_RUTA_CHECKED_KEY: return 'Check Radares Ruta';
                case TAREAS_RUTA_CHECKED_KEY: return 'Check Tareas Ruta';
                case ACTIVE_MAP_LAYER_KEY: return 'Capa de Mapa Activa';
                case DIRECT_TO_NAVIGATION_KEY: return 'Directo a Navegación';
                case GRAPH_STATE_KEY: return 'Estado Gráfica';
                case MAP_SEARCH_INPUT_KEY: return 'Buscador Mapa (Principal)';
                case MAP_FILTER_INPUT_KEY: return 'Buscador Mapa (Filtro)';
                default:return k;
            }
        }).join(', ');
    const vehicleIcon = L.divIcon({
        html: `<div id="vehicle-icon-wrapper"><img src="AVANCE.PNG" alt="Coche"></div>`,
        className: 'vehicle-icon-leaflet-container',
        iconSize: [48, 48],
        iconAnchor: [24, 24]
    });
    const vehicleIconMiniMap = L.divIcon({
        html: `<div class="vehicle-icon-minimap"><img src="AVANCE.PNG" alt="Coche Mini"></div>`,
        className: 'vehicle-icon-minimap-leaflet-container',
        iconSize: [24, 24],
        iconAnchor: [12, 12]
    });
    const smallRadarMarkerIcon = L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-violet.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [13, 21], iconAnchor: [6, 21], popupAnchor: [1, -18], shadowSize: [21, 21]
    });
    const largeGreenLocationMarkerIcon = L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [17, 28], iconAnchor: [8, 28], popupAnchor: [1, -24], shadowSize: [28, 28]
    });
    const defaultLocationMarkerIconBlue = L.icon({ iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png', shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png', iconSize: [15, 25], iconAnchor: [7, 25], popupAnchor: [1, -20], shadowSize: [25, 25] });
    const maneuverTexts = { 'turn-sharp right': 'Giro brusco a la derecha', 'turn-right': 'Gira a la derecha', 'bear-right': 'Mantente a la derecha', 'turn-sharp left': 'Giro brusco a la izquierda', 'turn-left': 'Gira a la izquierda', 'bear-left': 'Mantente a la izquierda', 'turn-': 'Gira', 'straight-straight': 'Sigue recto', 'straight-': 'Sigue recto', 'roundabout-': 'Entra en la rotonda', 'roundabout turn-': 'Toma la salida de la rotonda', 'rotary-': 'Entra en la glorieta', 'roundabout turn-left': 'En la rotonda, toma la salida hacia la izquierda', 'roundabout turn-right': 'En la rotonda, toma la salida hacia la derecha', 'roundabout turn-straight': 'En la rotonda, sigue recto', 'destination-left': 'Has llegado a tu destino  (a la izquierda)', 'destination-right': 'Has llegado a tu destino (a la derecha)', 'destination-': ' tu destino ', 'depart-': 'Inicia la ruta', 'arrive-left': 'Has llegado a tu destino (a la izquierda)', 'arrive-right': 'Has llegado a tu destino  (a la derecha)', 'arrive-': 'Has llegado a tu destino', 'continue-straight': 'Continúa recto', 'continue-': 'Continúa', 'new name-': 'Continúa por', 'fork-right': 'En la bifurcación, mantente a la derecha', 'fork-left': 'En la bifurcación, mantente a la izquierda', 'fork-': 'En la bifurcación', 'merge-left': 'Incorpórate por la izquierda', 'merge-right': 'Incorpórate por la derecha', 'merge-straight': 'Incorpórate', 'merge-': 'Incorpórate', 'end of road-left': 'Al final de la vía, gira a la izquierda', 'end of road-right': 'Al final de la vía, gira a la derecha', 'end of road-': 'Fin de la vía', 'u turn-left': 'Haz un cambio de sentido (hacia la izquierda)', 'u turn-right': 'Haz un cambio de sentido (hacia la derecha)', 'u turn-': 'Haz un cambio de sentido', 'use lane-': 'Usa el carril indicado', 'notification-': 'Atención', 'exit roundabout-': 'Sal de la rotonda', 'exit rotary-': 'Sal de la glorieta', 'off ramp-': 'Vía de salida', 'on ramp-': 'Incorporate a la vía de Entrada',};
    const SMOOTH_ZOOM_DURATION = 5.0;

    let lastPreciseRecalcTime = 0;
    const PRECISE_RECALC_INTERVAL = 120000;
    let distanceToNextManeuverOSRM = Infinity;
 
    let mapHeaderButtonsVisible = true;
    let mapHeaderToggleDragStartPos = null;
    let mapHeaderToggleIsDragging = false;
   
    





// ===================================================================
// NOMBRE: getChargingPointColorByPower
// RESUMEN: Devuelve un color hexadecimal basado en el rango de potencia del PDR.
// ===================================================================
function getChargingPointColorByPower(power) {
    if (isNaN(power)) {
        return '#5e5e5e'; // Gris por defecto si no hay datos
    }
    if (power >= 0 && power <= 50) {
        return '#5e5e5e'; // Gris
    } else if (power > 50 && power <= 100) {
        return '#007863'; // Verde
    } else if (power > 100 && power <= 250) {
        return 'rgb(30, 144, 255)'; // Azul (el actual)
    } else if (power > 250 && power <= 2000) {
        return '#de2e03'; // Rojo/Naranja
    }
    return '#5e5e5e'; // Fallback a gris
}  





// ===================================================================
// NOMBRE: positionTurnHelpers
// RESUMEN: Calcula y aplica la posición de los iconos de ayuda para giros.
// ===================================================================
function positionTurnHelpers() {
    const mapDiv = document.getElementById('reminders-location-map-div');
    const helperLeft = document.getElementById('intersection-helper-left');
    const helperRight = document.getElementById('intersection-helper-right');
    const compassCard = document.querySelector('.leaflet-control-orientation-altitude');
    const graphCard = document.getElementById('navigation-graph-card');

    if (!mapDiv || !helperLeft || !helperRight || !compassCard || !graphCard) {
        return;
    }

    const mapRect = mapDiv.getBoundingClientRect();

    const compassRect = compassCard.getBoundingClientRect();
    if (compassRect.width > 0) {
        const leftPos = (compassRect.left - mapRect.left) + (compassRect.width / 2) - (helperLeft.offsetWidth / 2);
        const bottomPos = (mapRect.height - compassRect.top) + 4;
        
        helperLeft.style.left = `${leftPos}px`;
        helperLeft.style.bottom = `${bottomPos}px`;
    }

    const graphRect = graphCard.getBoundingClientRect();
    if (graphRect.width > 0 && graphCard.style.display !== 'none' && !graphCard.classList.contains('hidden')) {
        const leftPos = (graphRect.left - mapRect.left) + (graphRect.width / 2) - (helperRight.offsetWidth / 2);
        const bottomPos = (mapRect.height - graphRect.top) + 4;
        
        helperRight.style.left = `${leftPos}px`;
        helperRight.style.bottom = `${bottomPos}px`;
    }
}




// ===================================================================
// NOMBRE: showPhotoModal
// RESUMEN: Muestra una imagen en un modal superpuesto.
// ===================================================================
function showPhotoModal(imageUrl) {
    const existingModal = document.querySelector('.ocm-photo-modal-overlay');
    if (existingModal) existingModal.remove();

    const overlay = document.createElement('div');
    overlay.className = 'ocm-photo-modal-overlay';
    
    overlay.innerHTML = `
        <div class="ocm-photo-modal-content">
            <img src="${imageUrl}" alt="Vista ampliada del punto de recarga">
            <div class="ocm-photo-modal-close-btn" title="Cerrar imagen">×</div>
        </div>
    `;

    document.body.appendChild(overlay);

    const close = () => {
        if (overlay.parentNode) {
            overlay.remove();
        }
    };

    overlay.querySelector('.ocm-photo-modal-close-btn').addEventListener('click', close);
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            close();
        }
    });
}

    



// ===================================================================
// NOMBRE: showElectroverseModal
// RESUMEN: Muestra la web de Electroverse en un modal con un iframe.
// ===================================================================
function showElectroverseModal(stationName, address) {
    const existingModal = document.querySelector('.electroverse-modal-overlay');
    if (existingModal) existingModal.remove();

    const query = `${stationName} ${address}`.trim();
    const url = `https://electroverse.com/map?query=${encodeURIComponent(query)}`;

    const overlay = document.createElement('div');
    overlay.className = 'electroverse-modal-overlay';
    
    overlay.innerHTML = `
        <div class="electroverse-modal-content">
            <div class="electroverse-modal-close-btn" title="Cerrar vista de Electroverse">×</div>
            <iframe src="${url}"></iframe>
        </div>
    `;

    document.body.appendChild(overlay);

    const close = () => {
        if (overlay.parentNode) {
            overlay.remove();
        }
    };

    overlay.querySelector('.electroverse-modal-close-btn').addEventListener('click', close);
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            close();
        }
    });
}


    


    
// ===================================================================
// NOMBRE: openAlertModal
// RESUMEN: Abre el modal para que el usuario seleccione una incidencia de tráfico.
// ===================================================================
function openAlertModal() {
    const alertModalOverlay = document.getElementById('alert-modal-overlay');
    const alertModalContent = document.getElementById('alert-modal-content');
    if (!alertModalOverlay || !alertModalContent) return;

    // --- INICIO DE LA CORRECCIÓN ---
    // Se han intercambiado los códigos 8 y 9 para que coincidan con la lógica de procesamiento.
    // "YA NO HAY NADA" debe tener el código 9 para que funcione la eliminación de alertas.
    const alertOptions = [
        { code: 1, text: 'ACCIDENTE TRÁFICO', icon: 'AACCIDENTE.png' },
        { code: 2, text: 'COCHE AVERIADO', icon: 'AAVERIADO.png' },
        { code: 3, text: 'CONTROL TRÁFICO / RADAR', icon: 'AGUARDIA.png' },
        { code: 4, text: 'ATASCO', icon: 'AATASCO.png' },
        { code: 5, text: 'PELIGRO INDETERMINADO', icon: 'APELIGRO.png' },
        { code: 6, text: 'CARRETERA MAL ESTADO', icon: 'ARESVALAR.png' },
        { code: 7, text: 'OBRAS', icon: 'AOBRAS.png' },
        { code: 8, text: 'VÍA / CARRETERA CERRADA', icon: 'ACERRADA.png' }, // <-- CÓDIGO CORREGIDO A 8
        { code: 9, text: 'YA NO HAY NADA', icon: 'AANULAR.png' }           // <-- CÓDIGO CORREGIDO A 9
    ];
    // --- FIN DE LA CORRECCIÓN ---

    alertModalContent.innerHTML = '<div id="alert-columns-container"></div>';
    const columnsContainer = document.getElementById('alert-columns-container');

    const column1 = document.createElement('div');
    column1.className = 'alert-column';
    const column2 = document.createElement('div');
    column2.className = 'alert-column';

    alertOptions.forEach((option, index) => {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'alert-option';
        optionDiv.onclick = () => sendTrafficAlert(option.code, option.text);
        optionDiv.innerHTML = `<img src="${option.icon}" alt="${option.text}"><span>${option.text}</span>`;

        if (index < 5) {
            column1.appendChild(optionDiv);
        } else {
            column2.appendChild(optionDiv);
        }
    });

    const cancelButton = document.createElement('div');
    cancelButton.id = 'alert-cancel-button';
    cancelButton.innerHTML = '<span>CANCELAR <span id="alert-timer">(10)</span></span>';
    cancelButton.onclick = closeAlertModal;
    column2.appendChild(cancelButton); // Añadimos el botón cancelar a la segunda columna

    columnsContainer.appendChild(column1);
    columnsContainer.appendChild(column2);

    alertModalOverlay.classList.remove('hidden');

    let countdown = 10;
    const timerSpan = document.getElementById('alert-timer');
    if (alertModalTimer) clearInterval(alertModalTimer);
    alertModalTimer = setInterval(() => {
        countdown--;
        if (timerSpan) timerSpan.textContent = `(${countdown})`;
        if (countdown <= 0) {
            closeAlertModal();
        }
    }, 1000);
}




    

// ===================================================================
// NOMBRE: formatOCMPoint
// RESUMEN: Convierte un punto de recarga del formato OCM a un formato interno estandarizado.
// ===================================================================
function formatOCMPoint(point) {
    if (!point || !point.AddressInfo) {
        return null;
    }

    let maxPower = 0;
    if (point.Connections && Array.isArray(point.Connections)) {
        point.Connections.forEach(conn => {
            if (conn.PowerKW && conn.PowerKW > maxPower) {
                maxPower = conn.PowerKW;
            }
        });
    }

    const totalPoints = point.NumberOfPoints || (point.Connections ? point.Connections.length : 0);
    const availabilityText = `${totalPoints} Poste${totalPoints !== 1 ? 's' : ''}`;

    let priceText = 'N/D';
    if (point.UsageCost) {
        const priceMatch = point.UsageCost.match(/(\d[\d,.]*)/);
        if (priceMatch && priceMatch[1]) {
            let priceNum = parseFloat(priceMatch[1].replace(',', '.'));
            if (!isNaN(priceNum) && priceNum > 0 && priceNum < 10) { 
                 priceText = `${priceNum.toFixed(2)} €/kWh`;
            }
        }
    }

    return {
        ocmId: point.ID,
        lat: point.AddressInfo.Latitude,
        lon: point.AddressInfo.Longitude,
        address: point.AddressInfo.Title || 'Dirección no disponible',
        availabilityText: availabilityText,
        price: priceText,
        fullPriceInfo: point.UsageCost || 'N/D',
        power: maxPower > 0 ? maxPower.toFixed(0) : 'N/A',
        operator: point.OperatorInfo ? point.OperatorInfo.Title : 'Desconocido',
        usageType: point.UsageType ? point.UsageType.Title : 'No especificado',
        accessInfo: point.AddressInfo.AccessComments || 'No especificado',
        connections: point.Connections || []
    };
}




    

    
    
    



// ===================================================================
// NOMBRE: closeAlertModal
// RESUMEN: Cierra el modal de selección de incidencias y limpia su temporizador.
// ===================================================================
function closeAlertModal() {
    const alertModalOverlay = document.getElementById('alert-modal-overlay');
    if (alertModalOverlay) {
        alertModalOverlay.classList.add('hidden');
    }
    if (alertModalTimer) {
        clearInterval(alertModalTimer);
        alertModalTimer = null;
    }
}

// ===================================================================
// NOMBRE: sendTrafficAlert
// RESUMEN: Envía una alerta de tráfico a Firebase usando la ubicación real o simulada.
// ===================================================================
function sendTrafficAlert(alertCode, alertName) {
    const userId = localStorage.getItem('userData_userId');
    if (!userId) {
        showToast("Debes configurar un ID de Usuario para enviar alertas.", "warning");
        closeAlertModal();
        return;
    }

    closeAlertModal();

    // --- MODIFICACIÓN CLAVE: Lógica para usar coordenadas simuladas ---
    const sendData = async (coords) => {
        if (!window.db || !window.doc || !window.setDoc || !window.collection) {
            showToast("Error: Firebase no está inicializado.", "error");
            return;
        }
        const alertData = {
            user: userId,
            code: alertCode,
            latitude: coords.latitude,
            longitude: coords.longitude,
            timestamp: new Date().toISOString()
        };

        try {
            const alertsCollectionRef = window.collection(window.db, "users", "ALERTAS", "events");
            const docId = `${Date.now()}_${userId.replace(/[^a-zA-Z0-9]/g, '_')}`;
            const newAlertRef = window.doc(alertsCollectionRef, docId);
            await window.setDoc(newAlertRef, alertData);
            showToast(`Alerta "${alertName}" enviada correctamente.`, "success");
            forceProcessTrafficAlerts();
        } catch (error) {
            showToast(`Error al enviar alerta a Firebase: ${error.message}`, "error");
        }
    };

    if (isSimulatingGpsLocation && simulatedGpsLocation) {
        // Si estamos en modo simulación y hay una ubicación simulada, la usamos.
        showToast("Enviando alerta desde ubicación simulada...", "info");
        sendData(simulatedGpsLocation);
    } else {
        // Si no, usamos el GPS real como antes.
        showToast("Obteniendo ubicación para la alerta...", "info");
        getCurrentLocation(
            (realCoords) => {
                sendData(realCoords);
            },
            (errorMsg) => {
                showToast(`No se pudo obtener la ubicación: ${errorMsg}`, "error");
            }
        );
    }
  }
    

// ===================================================================
// NOMBRE: processTrafficAlerts
// RESUMEN: Lógica principal que lee, limpia y actualiza las alertas desde Firebase.
// ===================================================================
async function processTrafficAlerts() {
    if (!window.db || !window.getDocs || !window.deleteDoc || !window.collection) {
        return;
    }
    
    try {
        const alertsCollectionRef = window.collection(window.db, "users", "ALERTAS", "events");
        const querySnapshot = await window.getDocs(alertsCollectionRef);
        
        let allAlerts = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        const now = new Date();
        const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
        
        const removals = allAlerts.filter(alert => alert.code === 9);
        let activeAlerts = allAlerts.filter(alert => alert.code !== 9);

        for (const removal of removals) {
            const removalCoords = { lat: removal.latitude, lon: removal.longitude };
            const alertsToDelete = new Set();
            
            activeAlerts.forEach(alert => {
                if(alert.latitude && alert.longitude){
                    const alertCoords = { lat: alert.latitude, lon: alert.longitude };
                    if (calculateDistance(removalCoords.lat, removalCoords.lon, alertCoords.lat, alertCoords.lon) <= 800) {
                        alertsToDelete.add(alert.id);
                    }
                }
            });

            for (const idToDelete of alertsToDelete) {
                const docRef = window.doc(window.db, "users", "ALERTAS", "events", idToDelete);
                await window.deleteDoc(docRef);
            }
            
            const removalDocRef = window.doc(window.db, "users", "ALERTAS", "events", removal.id);
            await window.deleteDoc(removalDocRef);
        }

        activeAlerts = activeAlerts.filter(alert => {
            if (!alert.timestamp || new Date(alert.timestamp) < twentyFourHoursAgo) {
                const docRef = window.doc(window.db, "users", "ALERTAS", "events", alert.id);
                window.deleteDoc(docRef);
                return false;
            }
            return true;
        });
        
        trafficAlertsCache = activeAlerts.filter(alert => alert.latitude && alert.longitude).map(alert => ({
            id: alert.id,
            code: alert.code,
            coordinates: { lat: alert.latitude, lon: alert.longitude }
        }));
        
        // --- LÍNEA CORREGIDA ---
        // Aseguramos que la llamada es a la función correcta "displayAlertsOnMap"
        displayAlertsOnMap(); 
        checkAlertsProximity();
        // -----------------------

    } catch (error) {
        console.error("Error procesando alertas de tráfico: ", error);
    }
}








// ===================================================================
// NOMBRE: closeNavigationMap
// RESUMEN: Cierra el mapa de navegación y limpia todos sus componentes y estados.
// ===================================================================
function closeNavigationMap(force = false) {
    lastAutoShownManeuverId = null;
    const wasInDirectToMapModeSession = sessionStorage.getItem('isInDirectToMapMode') === 'true';
    const userPrefersDirectToNav = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
    if (wasInDirectToMapModeSession && userPrefersDirectToNav && !force) {
        sessionStorage.removeItem('isInDirectToMapMode');
        sessionStorage.setItem(TEMP_PREVENT_DIRECT_NAV_KEY, 'true');
        location.reload();
        return;
    }
    directToNavOnLoad = false;
    sessionStorage.removeItem('isInDirectToMapMode');
    isNavigationMapActive = false;
    sessionStorage.removeItem('mapContext');
    if (locationWatchId !== null && navigator.geolocation) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
    if (gpsRetryTimeoutId) {
        clearTimeout(gpsRetryTimeoutId);
        gpsRetryTimeoutId = null;
    }
    gpsRetryAttempt = 0;
    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresRutaCheckbox) {
        localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked));
        if (radaresRutaCheckbox.checked) {
             eliminarRadaresDeRuta();
        }
    }
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasRutaCheckbox) {
        localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
        if (tareasRutaCheckbox.checked) {
            eliminarTareasDeBarraProgreso();
        }
    }
    actualizarContadorRadares(0);
    actualizarContadorTareas(0);
    clearChargingPoints();
    if (isAddReminderAtLocationModeActive) { toggleAddReminderAtLocationMode(); }
    if (isSimulatingGpsLocation) { stopAutomatedRouteSimulation(); isSimulatingGpsLocation = false; }
    clearAllWaypointMarkersFromMap();
    navigationWaypoints = [];
    if (navigationMapInstance) {
        const toggleMapHeaderButton = document.getElementById('toggle-map-header-buttons-panel');
        if (toggleMapHeaderButton && toggleMapHeaderButton.parentNode) {
            toggleMapHeaderButton.parentNode.removeChild(toggleMapHeaderButton);
        }
        if (compassAndModeControl && navigationMapInstance._controlContainer && navigationMapInstance._controlContainer.contains(compassAndModeControl.getContainer())) { try { navigationMapInstance.removeControl(compassAndModeControl); } catch(e) {} }
        if (mapLayersControl && navigationMapInstance._controlContainer && navigationMapInstance._controlContainer.contains(mapLayersControl.getContainer())) {
             try {mapLayersControl.remove();} catch(e){}
             mapLayersControl = null;
        }
        if (navigationMapClickHandler) { navigationMapInstance.off('click', navigationMapClickHandler); navigationMapClickHandler = null; }
        if (completedRouteSegmentsLayer) { completedRouteSegmentsLayer.clearLayers(); completedRouteSegmentsLayer.remove(); completedRouteSegmentsLayer = null; }
        if (maxSpeedMarkerLayer) { maxSpeedMarkerLayer.clearLayers(); maxSpeedMarkerLayer.remove(); maxSpeedMarkerLayer = null; }
        if (speedMilestoneLayer) { speedMilestoneLayer.clearLayers(); speedMilestoneLayer.remove(); speedMilestoneLayer = null; }
        if (navigationRouteLayer) { try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch(e){} navigationRouteLayer = null; }
        try { navigationMapInstance.remove(); } catch (e) {} navigationMapInstance = null;
    }
    navigationCurrentRouteData = null; isNavigating = false; navigationFollowUser = false;
    routeStartTime = null; navigationStartTimeForStats = null; totalDistanceTravelledForStats = 0; lastPositionForStats = null;
    tripInitialOverallEtaTime = null; currentStageInitialExpectedEtaTime = null; accumulatedDeviationMs = 0;
    currentMapRotationAngle = 0; lastValidCarDistanceForDisplay = 0;
    accumulatedDistanceBeforeCurrentSegment = 0;
    initialUserLocationMarker = null; initialUserLocationMarkerLat = null; initialUserLocationMarkerLng = null;
    if (initialUserLocationCircle) { try {initialUserLocationCircle.remove();} catch(e){} initialUserLocationCircle = null; }
    navigationCurrentLocation = null; compassAndModeControl = null;
    maxSpeedDuringTrip = 0;
    maxSpeedCoordinates = null;
    lastSpeedMilestone = 0;
    maxAltitudeDuringTrip = -Infinity; 
    minAltitudeDuringTrip = Infinity; 
    if (window.compassAndModeControl) { 
        window.compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip); 
    }
    const mapModalElement = document.getElementById('reminders-location-map-modal'); if (mapModalElement) { mapModalElement.remove(); }
    const helpModalInstance = document.getElementById('reminders-map-help-modal-instance'); if (helpModalInstance) { const helpCloseButton = helpModalInstance.querySelector('#close-reminders-map-help-instance'); if(helpCloseButton) clearModalAutoCloseTimer(helpModalInstance, helpCloseButton, 'reminders-map-help-modal-instance'); helpModalInstance.remove(); }
    const savedRoutesModal = document.getElementById('saved-routes-modal'); if (savedRoutesModal) { const closeBtnSRM = savedRoutesModal.querySelector('#close-saved-routes-modal'); if(closeBtnSRM) clearModalAutoCloseTimer(savedRoutesModal, closeBtnSRM, 'saved-routes-modal'); savedRoutesModal.remove(); }
    const saveRoutePromptModal = document.getElementById('save-route-prompt-modal'); if (saveRoutePromptModal) { const closeBtnSRPM = saveRoutePromptModal.querySelector('#cancel-save-route'); if(closeBtnSRPM) clearModalAutoCloseTimer(saveRoutePromptModal, closeBtnSRPM, 'save-route-prompt-modal'); saveRoutePromptModal.remove(); }
    const reorderStagesModalElement = document.getElementById('reorder-stages-modal'); if (reorderStagesModalElement && !reorderStagesModalElement.classList.contains('hidden')) {
        const cancelBtnReorder = reorderStagesModalElement.querySelector('#cancel-reorder-stages');
        if(cancelBtnReorder) clearModalAutoCloseTimer(reorderStagesModalElement, cancelBtnReorder, 'reorder-stages-modal');
        reorderStagesModalElement.classList.add('hidden');
    }
    const simModal = document.getElementById('simulation-modal');
    if (simModal && !simModal.classList.contains('hidden')) {
        if (simulationModalTimer) clearTimeout(simulationModalTimer);
        const simCloseBtn = simModal.querySelector('#close-simulation-modal');
        if (simCloseBtn) clearModalAutoCloseTimer(simModal, simCloseBtn, 'simulation-modal');
        simModal.classList.add('hidden');
        hideIntersectionPreviewMap();
    }
    hideMapInfoOverlay();
    sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
    sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
    sessionStorage.removeItem('boardinggate_map_was_open_before_table');
    sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');
    hideUnifiedReminderWindow();
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    checkReminders();
    const generalTopButtonsPanel = document.getElementById('toggle-top-buttons-panel-general');
    if (generalTopButtonsPanel) generalTopButtonsPanel.classList.remove('hidden');

    if (!directToNavOnLoad) {
        const mainContent = document.querySelector('main');
        if (mainContent) mainContent.style.display = 'block';
        const footer = document.querySelector('footer');
        if (footer) footer.style.display = 'block';
        const noticesContainer = document.querySelector('.notices-icon-container');
        if (noticesContainer) noticesContainer.style.display = 'flex';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button');
        sideControls.forEach(el => el.style.display = 'flex');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'block');
        const gridFilter = document.getElementById('grid-filter-container');
        if (gridFilter) gridFilter.style.display = 'flex';
        renderGrid();
        renderToggleButtons();
        updateButtonStyles();
        filterGridItems();
        setTimeout(adjustButtonPositions, 100);
    }

    hideIntersectionPreviewMap();
    updateDirectionWarningCardsVisibility();
    
    clearNavigationGraph();
}






    



    

    

// ===================================================================
// NOMBRE: displayAlertsOnMap
// RESUMEN: Dibuja los iconos de las alertas de tráfico en el mapa, con tamaño dinámico según el zoom.
// ===================================================================
function displayAlertsOnMap() {
    if (!navigationMapInstance || !navigationMapInstance.getPane) {
        return;
    }
    
    const currentZoom = navigationMapInstance.getZoom();
    const ZOOM_THRESHOLD = 16; // Nivel de zoom a partir del cual el icono se hace grande
    const isSmall = currentZoom < ZOOM_THRESHOLD;

    // Estos tamaños deben coincidir con tu CSS para que el anclaje sea correcto
    const largeIconTotalSize = 55; // 55px del .traffic-alert-icon-container
    const smallIconTotalSize = 27; // 27px del .traffic-alert-icon-container.small

    const iconSize = isSmall ? smallIconTotalSize : largeIconTotalSize;
    const iconAnchor = iconSize / 2;

    if (trafficAlertsLayer && navigationMapInstance.hasLayer(trafficAlertsLayer)) {
        trafficAlertsLayer.clearLayers();
    } else {
        trafficAlertsLayer = L.layerGroup().addTo(navigationMapInstance);
    }
    
    const alertIcons = {
        1: 'AACCIDENTE.png', 2: 'AAVERIADO.png', 3: 'AGUARDIA.png',
        4: 'AATASCO.png', 5: 'APELIGRO.png', 6: 'ARESVALAR.png',
        7: 'AOBRAS.png', 8: 'ACERRADA.png', 9: 'AANULAR.png'
    };

    trafficAlertsCache.forEach(alert => {
        if (alertIcons[alert.code]) {
            const extraClass = isSmall ? ' small' : '';
            const iconHtml = `<div class="traffic-alert-icon-container${extraClass}"><img src="${alertIcons[alert.code]}" alt="Alerta"></div>`;

            const divIcon = L.divIcon({
                html: iconHtml,
                className: '', // La clase principal ya está en el HTML
                iconSize: [iconSize, iconSize],
                iconAnchor: [iconAnchor, iconAnchor]
            });
            
            L.marker([alert.coordinates.lat, alert.coordinates.lon], { icon: divIcon, zIndexOffset: 950 }).addTo(trafficAlertsLayer);
        }
    });
}


    
// ===================================================================
// NOMBRE: checkAlertsProximity
// RESUMEN: Comprueba la proximidad del vehículo a las alertas y muestra un aviso si es necesario.
// ===================================================================
function checkAlertsProximity() {
    if (!navigationCurrentLocation || trafficAlertsCache.length === 0) {
        return;
    }

    const carLat = navigationCurrentLocation.latitude;
    const carLon = navigationCurrentLocation.longitude;

    trafficAlertsCache.forEach(alert => {
        const distance = calculateDistance(carLat, carLon, alert.coordinates.lat, alert.coordinates.lon);
        if (distance <= 500 && !currentlyDisplayedProximityAlerts.has(alert.id)) {
            showProximityAlert(alert);
            currentlyDisplayedProximityAlerts.add(alert.id);
        }
    });
}

    
// ===================================================================
// NOMBRE: hideProximityAlert
// RESUMEN: Oculta el modal de aviso de proximidad.
// ===================================================================
function hideProximityAlert(alertId) {
    const proximityModal = document.getElementById('proximity-alert-modal');
    if (proximityModal) proximityModal.classList.add('hidden');
    document.getElementById('flashing-border-overlay').classList.add('hidden');
    
    if (proximityAlertTimer) {
        clearInterval(proximityAlertTimer);
        proximityAlertTimer = null;
    }
}


// ===================================================================
// NOMBRE: forceProcessTrafficAlerts
// RESUMEN: Lanza el proceso de actualización de alertas inmediatamente.
// ===================================================================
function forceProcessTrafficAlerts() {
    console.log("-> Forzando actualización inmediata de alertas de tráfico...");
    // Reseteamos el timestamp para que el próximo ciclo de 15 min empiece a contar desde ahora
    lastAlertCheckTimestamp = Date.now();
    processTrafficAlerts();
}    


// ===================================================================
// NOMBRE: showProximityAlert
// RESUMEN: Muestra el modal de aviso de proximidad a una alerta de tráfico.
// ===================================================================
function showProximityAlert(alert) {
    const proximityModal = document.getElementById('proximity-alert-modal');
    if (!proximityModal) return;

    const alertDetails = [
        null, 
        { text: 'ACCIDENTE TRÁFICO', icon: 'AACCIDENTE.png' },
        { text: 'COCHE AVERIADO', icon: 'AAVERIADO.png' },
        { text: 'CONTROL TRÁFICO / RADAR', icon: 'AGUARDIA.png' },
        { text: 'ATASCO', icon: 'AATASCO.png' },
        { text: 'PELIGRO INDETERMINADO', icon: 'APELIGRO.png' },
        { text: 'CARRETERA MAL ESTADO', icon: 'ARESVALAR.png' },
        { text: 'OBRAS', icon: 'AOBRAS.png' },
        null, // Espacio para el código 8 que no se muestra aquí
        { text: 'VÍA / CARRETERA CERRADA', icon: 'ACERRADA.png' } // <-- NUEVA OPCIÓN AÑADIDA
    ][alert.code];

    if (!alertDetails) return;

    proximityModal.innerHTML = `
        <img src="${alertDetails.icon}" alt="${alertDetails.text}">
        <div class="content">
            <span class="alert-text">${alertDetails.text}</span>
            <button id="proximity-ok-button">ENTERADO <span id="proximity-timer">(10)</span></button>
        </div>
    `;

    document.getElementById('flashing-border-overlay').classList.remove('hidden');
    proximityModal.classList.remove('hidden');

    const okButton = document.getElementById('proximity-ok-button');
    const timerSpan = document.getElementById('proximity-timer');
    let countdown = 15;
    
    if (proximityAlertTimer) clearInterval(proximityAlertTimer);
    proximityAlertTimer = setInterval(() => {
        countdown--;
        if (timerSpan) timerSpan.textContent = `(${countdown})`;
        if (countdown <= 0) {
            hideProximityAlert(alert.id);
        }
    }, 1000);
    
    okButton.onclick = () => hideProximityAlert(alert.id);
}
    



    







// ===================================================================
// NOMBRE: loadRouteByName
// RESUMEN: Carga una ruta guardada por su nombre y la dibuja en el mapa.
// ===================================================================
function loadRouteByName(routeName, autoStartNavigation = false) {
    const savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
    const routeToLoad = savedRoutes.find(r => r.name.toUpperCase() === routeName.toUpperCase());
    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (!routeToLoad) {
        showToast(`No se pudo cargar la ruta "${routeName}". No encontrada`, "error");
        if (radaresRutaCheckbox) {
           localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked));
        }
        if (tareasRutaCheckbox) {
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
        }
        return;
    }
    clearAllWaypointMarkersFromMap();
    if (navigationMapInstance) {
        if (navigationRouteLayer) {
            try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch(e) {}
        }
        if (completedRouteSegmentsLayer) {
            completedRouteSegmentsLayer.clearLayers();
        }
    }
    navigationWaypoints = [];
    navigationRouteLayer = null;
    navigationCurrentRouteData = null;
    isNavigating = false;
    routeStartTime = null; 
    navigationStartTimeForStats = null; 
    totalDistanceTravelledForStats = 0; 
    lastPositionForStats = null;
    tripInitialOverallEtaTime = null; 
    currentStageInitialExpectedEtaTime = null; 
    accumulatedDeviationMs = 0;
    lastValidCarDistanceForDisplay = 0;
    accumulatedDistanceBeforeCurrentSegment = 0;
    maxSpeedDuringTrip = 0; 
    maxAltitudeDuringTrip = -Infinity; 
    minAltitudeDuringTrip = Infinity;
    if (compassAndModeControl) { 
        compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip); 
    }
    eliminarRadaresDeRuta();
    actualizarContadorRadares(0);
    eliminarTareasDeBarraProgreso();
    actualizarContadorTareas(0);
    clearChargingPoints();
    clearNavigationGraph();
    currentRouteNameForSaving = routeToLoad.name;
    const isSavedLocationRoute = routeToLoad.name.startsWith("UBICACIÓN: ");
    if (isSavedLocationRoute && routeToLoad.waypoints.length === 1 && navigationCurrentLocation) {
        const startPoint = {
            id: Date.now() -1,
            lat: navigationCurrentLocation.latitude,
            lng: navigationCurrentLocation.longitude,
            type: 'S',
            marker: null,
            label: 'S',
            address: 'Posición Actual (GPS)',
            visited: true,
            isCriticalForRecalc: true,
            isRecalculatedStart: false
        };
        navigationWaypoints.push(startPoint);
    }
    routeToLoad.waypoints.forEach(wpData => {
        if (wpData) {
            navigationWaypoints.push({
                id: wpData.id || Date.now() + Math.random(),
                lat: wpData.lat,
                lng: wpData.lng,
                type: wpData.type,
                label: wpData.label,
                marker: null,
                address: wpData.address || '',
                visited: wpData.visited || false,
                isCriticalForRecalc: wpData.isCriticalForRecalc !== false,
                isRecalculatedStart: false
            });
        }
    });
    if (navigationCurrentLocation && navigationWaypoints.length > 0) {
        const firstWp = navigationWaypoints[0];
        const distanceToFirstWp = calculateDistance(
            navigationCurrentLocation.latitude, navigationCurrentLocation.longitude,
            firstWp.lat, firstWp.lng
        );
        if (distanceToFirstWp < 15000) {
            if (firstWp.type === 'S') {
                navigationWaypoints.shift();
            }
            const newStartPoint = {
                id: Date.now() -1,
                lat: navigationCurrentLocation.latitude,
                lng: navigationCurrentLocation.longitude,
                type: 'S', marker: null, label: 'S',
                address: 'Posición Actual (GPS)',
                visited: true, isCriticalForRecalc: true,
                isRecalculatedStart: false
            };
            navigationWaypoints.unshift(newStartPoint);
        } else {
             const newStartPoint = {
                id: Date.now() -1,
                lat: navigationCurrentLocation.latitude,
                lng: navigationCurrentLocation.longitude,
                type: 'S', marker: null, label: 'S',
                address: 'Posición Actual (GPS)',
                visited: true, isCriticalForRecalc: true,
                isRecalculatedStart: false
            };
            navigationWaypoints.unshift(newStartPoint);
        }
    }
    updateWaypointTypesAndLabels();
    renderWaypointMarkers();
    if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2) {
        recalculateAndDrawRoute(false).then(() => {
            showToast(`Ruta "${routeToLoad.name}" cargada y recalculada`, "success");
            if (navigationMapInstance && navigationRouteLayer) {
                navigationMapInstance.fitBounds(navigationRouteLayer.getBounds().pad(0.1));
            }
             if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
                let carDistAlongRouteLoad = 0;
                const currentCarPosForLoad = navigationCurrentLocation;
                 if (currentCarPosForLoad && navigationMapInstance && navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
                    try {
                        const carPointTurf = turf.point([currentCarPosForLoad.longitude, currentCarPosForLoad.latitude]);
                        const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                        const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                        const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                        carDistAlongRouteLoad = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                    } catch (e) {  }
                 }
                updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], carDistAlongRouteLoad);
                updateTurnByTurnDisplay(navigationCurrentRouteData.routes[0], carDistAlongRouteLoad);
                showNavigationUIElementsForPlanning();
                if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                    toggleRadaresRuta(true);
                }
                 if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                    toggleTareasRuta(true);
                }
                if (autoStartNavigation) {
                    if (autoStartNavTimer) clearTimeout(autoStartNavTimer);
                    let countdown = 3;
                    const startNavToastId = `start-nav-toast-${Date.now()}`;
                    const updateNavToast = () => {
                        showToast(`Iniciando navegación automática en ${countdown} segundos... <button onclick="cancelAutoStartNav('${startNavToastId}')" style="background:rgba(255,255,255,0.2);border:1px solid white;padding:2px 5px;margin-left:10px;border-radius:3px;">Cancelar</button>`, 'info', countdown * 1000 + 500, false, startNavToastId);
                    };
                    updateNavToast();
                    autoStartNavTimer = setInterval(() => {
                        countdown--;
                        if (countdown > 0) {
                            updateNavToast();
                        } else {
                            clearInterval(autoStartNavTimer);
                            autoStartNavTimer = null;
                            const existingToast = document.getElementById(startNavToastId);
                            if (existingToast) existingToast.remove();
                            if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2 && !isNavigating) {
                                toggleNavigationState();
                            }
                        }
                    }, 1000);
                }
            }
        }).catch(error => {
            showToast(`Error al recalcular la ruta "${routeToLoad.name}": ${error.message}`, "error");
        });
    } else {
        showToast(`Ruta "${routeToLoad.name}" cargada (solo waypoints, no hay suficientes para una ruta)`, "info");
        hideNavigationUI();
         if (radaresRutaCheckbox) {
           localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked));
        }
         if (tareasRutaCheckbox) {
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
        }
    }
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    actualizarContadorRadares(radaresEnRutaActual.length);
    actualizarContadorTareas(tareasEnRutaActual.length);
}

















    
    


// ===================================================================
// NOMBRE: handleStageSelectionFromDeviationModal
// RESUMEN: Gestiona la selección de una etapa específica desde el modal de desvío.
// ===================================================================
function handleStageSelectionFromDeviationModal(selectedWaypointId) {
const selectedIndex = navigationWaypoints.findIndex(wp => wp.id === selectedWaypointId);
if (selectedIndex === -1) {
showToast("Error: No se encontró la etapa seleccionada.", "error");
closeModalAndProceed();
return;
}
for (let i = 0; i < selectedIndex; i++) {
const wp = navigationWaypoints[i];
if (wp && !wp.isInternal && wp.type !== 'S' && wp.type !== 'S_Recalc') {
wp.visited = true;
}
}
navigationWaypoints[selectedIndex].visited = false;
closeModalAndProceed();
recalculateAndDrawRoute(true);
renderWaypointMarkers();
}


    


    








// ===================================================================
// NOMBRE: showArrivalStatsModal
// RESUMEN: Muestra un modal con las estadísticas del viaje al llegar al destino.
// ===================================================================
function showArrivalStatsModal() {
    closeOtherModals('arrival-stats-modal');
    let modal = document.getElementById('arrival-stats-modal');
    if (modal) {
        clearModalAutoCloseTimer(modal, modal.querySelector('#arrival-stats-accept-button'), 'arrival-stats-modal');
        modal.remove();
    }
    modal = document.createElement('div');
    modal.id = 'arrival-stats-modal';
    modal.style.cssText = `
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background-color: #E6D6A8; padding: 25px; border-radius: 10px;
        box-shadow: 0 0 20px rgba(0,0,0,0.5); z-index: 10000; text-align: center;
        max-width: 550px; width: 90%;
    `;
    const destinationWp = navigationWaypoints[navigationWaypoints.length - 1];
    const destinationName = destinationWp?.address || "";
    const startTime = navigationStartTimeForStats ? new Date(navigationStartTimeForStats) : new Date();
    const arrivalTime = new Date();
    const durationMs = arrivalTime - startTime;
    const durationHours = Math.floor(durationMs / (1000 * 60 * 60));
    const durationMinutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
    const durationSeconds = Math.floor((durationMs % (1000 * 60)) / 1000);
    let kmRealizados;
    if (isSimulatingGpsLocation && automatedSimulationIntervalId) {
        kmRealizados = (simulatedDistanceAlongRoute / 1000).toFixed(2);
    } else {
        kmRealizados = (totalDistanceTravelledForStats / 1000).toFixed(2);
    }
    const velocidadMedia = window.averageSpeedKmh.toFixed(1);
    const velocidadMaxima = maxSpeedDuringTrip.toFixed(1);
    const altitudMaxima = maxAltitudeDuringTrip !== -Infinity ? maxAltitudeDuringTrip.toFixed(0) + ' m' : 'N/D';
    const altitudMinima = minAltitudeDuringTrip !== Infinity ? minAltitudeDuringTrip.toFixed(0) + ' m' : 'N/D';
    let altitudMediaHtml = '';
    if (graphDataPoints && graphDataPoints.altitude && graphDataPoints.altitude.length > 0) {
        const sum = graphDataPoints.altitude.reduce((a, b) => a + b, 0);
        const avg = sum / graphDataPoints.altitude.length;
        altitudMediaHtml = `
            <div style="text-align: center;">
                <span style="font-size: 1.1rem; color: black; font-weight: bold;">(Media:</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;"> ${avg.toFixed(0)} m)</span>
            </div>
        `;
    }
    let deviationHtml = "";
    let finalDeviationMs = 0;
    if (tripInitialOverallEtaTime) {
        finalDeviationMs = arrivalTime.getTime() - tripInitialOverallEtaTime.getTime();
        deviationHtml = formatDeviation(finalDeviationMs);
    }
    let initialEtaDetailsHtml = '';
    const initialRoute = navigationCurrentRouteData?.routes?.[0];
    if (initialRoute && tripInitialOverallEtaTime && Math.abs(finalDeviationMs) < 5000) { 
        const realEtaTime = arrivalTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const realDurationTotalMinutes = Math.round(durationMs / (1000 * 60));
        const realDurationHours = Math.floor(realDurationTotalMinutes / 60);
        const realDurationMins = realDurationTotalMinutes % 60;
        const realDurationFormatted = `${String(realDurationHours).padStart(2,'0')}:${String(realDurationMins).padStart(2,'0')}`;
        const realAvgSpeed = velocidadMedia;
        initialEtaDetailsHtml = `
        <div id="initial-eta-details" style="font-size: 0.9rem; color: #333; margin-top: 8px; padding-top: 8px; border-top: 1px solid #ccc; text-align: center; font-weight: bold; line-height: 1.4;">
            <strong>Previsión (coincide con real):</strong><br>
            Hora llegada: ${realEtaTime} | Tiempo: ${realDurationFormatted} h. | Vel. media: ${realAvgSpeed} Km/h
        </div>
        `;
    } else if (initialRoute && tripInitialOverallEtaTime) {
        const initialEtaTime = tripInitialOverallEtaTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const initialDurationTotalMinutes = Math.round(initialRoute.duration / 60);
        const initialDurationHours = Math.floor(initialDurationTotalMinutes / 60);
        const initialDurationMins = initialDurationTotalMinutes % 60;
        const initialDurationFormatted = `${String(initialDurationHours).padStart(2,'0')}:${String(initialDurationMins).padStart(2,'0')}`;
        const initialAvgSpeed = ((initialRoute.distance / initialRoute.duration) * 3.6).toFixed(1);
        initialEtaDetailsHtml = `
        <div id="initial-eta-details" style="font-size: 0.9rem; color: #555; margin-top: 8px; padding-top: 8px; border-top: 1px solid #ccc; text-align: center; font-weight: bold; line-height: 1.4;">
            <strong>Previsión inicial:</strong><br>
            Hora llegada: ${initialEtaTime} | Tiempo: ${initialDurationFormatted} h. | Vel. media: ${initialAvgSpeed} Km/h
        </div>
        `;
    }
    modal.innerHTML = `
        <h2 style="font-size: 1.6rem; color: #006400; font-weight: bold; margin-bottom: 15px; display: flex; align-items: center; justify-content: center;">
            <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path></svg>
            ¡HA LLEGADO A !
        </h2>
        <div style="font-size: 1.1rem; color: #006400; font-weight: bold; text-align: center; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #ccc; display: flex; align-items: center; justify-content: center;">
             <img src="arrive.png" alt="Destino" style="width: 5em; height: 5em; margin-right: 5px; vertical-align: middle;">
             <span style="font-size: 1.5em; vertical-align: middle;">${destinationName}</span>
        </div>
        <div style="display: flex; justify-content: space-around; align-items: center; margin-bottom: 15px; font-size: 1.1rem;">
            <div style="text-align: center;">
                <span style="font-size: 1.1rem; color: black; font-weight: bold; display: block;">Hora Salida</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;">${startTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
            </div>
            <div style="font-size: 4rem; color: black;">→</div>
            <div style="text-align: center;">
                <span style="font-size: 1.1rem; color: black; font-weight: bold; display: block;">Hora Llegada</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;">${arrivalTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
            </div>
        </div>
        <div style="text-align: center; margin-bottom: 20px;">
            <span style="font-size: 1.1rem; color: black; font-weight: bold; display: block;">Tiempo Viaje</span>
            <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;">${String(durationHours).padStart(2,'0')}:${String(durationMinutes).padStart(2,'0')}:${String(durationSeconds).padStart(2,'0')}</span>
         </div>
          <div style="text-align: center; margin-bottom: 10px;">
            <span style="font-size: 1.1rem; color: blue; font-weight: bold;">Desviación ETA: ${deviationHtml}</span>
            ${initialEtaDetailsHtml}
         </div>
        </div>
        <div style="display: flex; justify-content: space-around; margin-bottom: 10px; font-size: 1.1rem; border-top: 1px solid #ccc; padding-top: 10px; margin-top:10px;">
            <div>
                <span style="font-size: 1.1rem; color: black; font-weight: bold;">Km realizados:</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;"> ${kmRealizados} km</span>
            </div>
            <div>
                <span style="font-size: 1.1rem; color: black; font-weight: bold;">Vel. media:</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;"> ${velocidadMedia} km/h</span>
            </div>
        </div>
        <div style="display: flex; justify-content: center; align-items: center; gap: 10px; margin-bottom: 20px; font-size: 1.1rem;">
            <div>
                <span style="font-size: 1.1rem; color: black; font-weight: bold;">Vel. máxima:</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;"> ${velocidadMaxima} km/h</span>
            </div>
            <button id="show-max-speed-location-button" style="padding: 0; font-size: 1rem; background-color: #f59e0b; color: white; border: 1px solid #d97706; border-radius: 4px; cursor: pointer; max-width: 12px; max-height: 8px;">¿Dónde?</button>
        </div>
        <div style="display: flex; justify-content: space-around; align-items: center; margin-bottom: 20px; font-size: 1.1rem; border-top: 1px solid #ccc; padding-top: 15px; margin-top:15px;">
            <div>
                <span style="font-size: 1.1rem; color: black; font-weight: bold;">Altitud Máx:</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;"> ${altitudMaxima}</span>
            </div>
            ${altitudMediaHtml}
            <div>
                <span style="font-size: 1.1rem; color: black; font-weight: bold;">Altitud Mín:</span>
                <span style="font-size: 1.3rem; color: #0000CD; font-weight: bold;"> ${altitudMinima}</span>
            </div>
        </div>
        <button id="arrival-stats-accept-button" style="background-color: #007bff; color: white; padding: 12px 25px; font-size: 1.2rem; border-radius: 5px; border: none; cursor: pointer;">ACEPTAR</button>
    `;
    document.body.appendChild(modal);
    const coordsAreValid = maxSpeedCoordinates &&
                            typeof maxSpeedCoordinates.lat === 'number' && !isNaN(maxSpeedCoordinates.lat) &&
                            typeof maxSpeedCoordinates.lng === 'number' && !isNaN(maxSpeedCoordinates.lng);
    if (coordsAreValid && navigationMapInstance) {
        const maxSpeedIcon = L.divIcon({
            className: 'max-speed-marker-icon',
            html: `<div style="background-color: red; color: white; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; border: 2px solid white; box-shadow: 0 0 5px black;">${Math.round(velocidadMaxima)}</div>`,
            iconSize: [44, 44],
            iconAnchor: [22, 22]
        });
        const markerPosition = [maxSpeedCoordinates.lat, maxSpeedCoordinates.lng];
        if (!maxSpeedMarkerLayer) {
            maxSpeedMarkerLayer = L.layerGroup().addTo(navigationMapInstance);
        } else {
            maxSpeedMarkerLayer.clearLayers();
        }
        L.marker(markerPosition, { 
            icon: maxSpeedIcon,
            zIndexOffset: 2000
        }).addTo(maxSpeedMarkerLayer);
    }
    const acceptButton = modal.querySelector('#arrival-stats-accept-button');

    // --- INICIO DE LA CORRECCIÓN ---
    acceptButton.addEventListener('click', () => {
        clearModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal');
        if (modal.parentNode) modal.remove();

        // 1. Finaliza el estado de navegación de forma controlada
        isNavigating = false;
        navigationFollowUser = false;
        tripStartLocationForStats = null;
        isArrivalSequenceStarted = false;
        
        // 2. Limpia la gráfica y la UI de navegación
        clearNavigationGraph();
        hideNavigationUI();
        
        // 3. Muestra de nuevo los botones de la cabecera del mapa
        mapHeaderButtonsVisible = true;
        toggleMapHeaderRowsVisibility(true);

        // 4. Actualiza el estado visual de los botones de navegación
        updateStartNavigationButtonState();
        updateNavigationButtonColor();

        // 5. Muestra el mensaje final en el overlay del mapa
        showMapInfoOverlay("HA LLEGADO AL : " + destinationName);
        
        // 6. ¡IMPORTANTE! NO detenemos el startGpsWatching(). El icono del coche
        // seguirá actualizando su posición mientras el mapa esté abierto.
    });
    // --- FIN DE LA CORRECCIÓN ---
    
    const showLocationButton = modal.querySelector('#show-max-speed-location-button');
    showLocationButton.addEventListener('click', () => {
        const coordsAreValid = maxSpeedCoordinates &&
                              typeof maxSpeedCoordinates.lat === 'number' && !isNaN(maxSpeedCoordinates.lat) &&
                              typeof maxSpeedCoordinates.lng === 'number' && !isNaN(maxSpeedCoordinates.lng);
        if (!coordsAreValid || !navigationMapInstance) {
            showToast("No se han registrado coordenadas válidas para la velocidad máxima.", "warning");
            return;
        }
        clearModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal');
        if (modal.parentNode) modal.remove();
        const markerPosition = [maxSpeedCoordinates.lat, maxSpeedCoordinates.lng];
        navigationMapInstance.setView(markerPosition, 16);
        showToast("Mapa centrado en el punto de velocidad máxima.", "info");
        mapHeaderButtonsVisible = true;
        toggleMapHeaderRowsVisibility(true);
    });
    addModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal', 60000);
}







    


// ===================================================================
// NOMBRE: saveCurrentRoute
// RESUMEN: Muestra el modal para guardar la ruta actualmente planificada en el mapa.
// ===================================================================
async function saveCurrentRoute() {
    if (navigationWaypoints.length < 2) {
        showToast("No hay ruta activa para guardar (se necesitan al menos 2 puntos)", "warning");
        return;
    }
    const isMultiStage = navigationWaypoints.length > 2;
    const lastWp = navigationWaypoints[navigationWaypoints.length - 1];
    let defaultRouteName = await getSuggestedRouteName(lastWp.lat, lastWp.lng, isMultiStage, navigationWaypoints.length);
    currentRouteNameForSaving = null;
    const existingModal = document.getElementById('save-route-prompt-modal');
    if (existingModal) existingModal.remove();
    const modal = document.createElement('div');
    modal.id = 'save-route-prompt-modal';
    modal.innerHTML = `
        <h2>Guardar Ruta</h2>
        <div class="modal-top-buttons">
            <button id="confirm-save-route">Guardar <span class="button-countdown-timer"></span></button>
            <button id="cancel-save-route">Cancelar</button>
        </div>
        <label for="route-name-input">Nombre de la Ruta:</label>
        <input type="text" id="route-name-input" value="${defaultRouteName.toUpperCase()}">
    `;
    document.body.appendChild(modal);
    const nameInput = modal.querySelector('#route-name-input');
    nameInput.style.textTransform = 'uppercase';
    const confirmButton = modal.querySelector('#confirm-save-route');
    const cancelButton = modal.querySelector('#cancel-save-route');
    nameInput.focus();
    const textLength = nameInput.value.length;
    nameInput.setSelectionRange(textLength, textLength);
    const closePrompt = () => {
        clearModalAutoCloseTimer(modal, confirmButton, 'save-route-prompt-modal');
        if (modal.parentNode) modal.remove();
    };
    const saveAction = () => {
        let routeName = nameInput.value.trim().toUpperCase();
        if (!routeName) {
            showToast("El nombre de la ruta no puede estar vacío", "warning");
            addModalAutoCloseTimer(modal, confirmButton, 'save-route-prompt-modal', 15000);
            return;
        }
        currentRouteNameForSaving = routeName;
        let waypointsToSave = navigationWaypoints.map(wp => (wp ? { id: wp.id, lat: wp.lat, lng: wp.lng, label:wp.label, type:wp.type, address: wp.address || '', visited: wp.visited || false, isCriticalForRecalc: wp.isCriticalForRecalc !== false, isInternal: wp.isInternal || false, isRecalculatedStart: wp.isRecalculatedStart || false } : null)).filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
       if (waypointsToSave.length === 2 && !isMultiStage) {
            const startPoint = waypointsToSave.find(wp => wp.type === 'S');
            const endPoint = waypointsToSave.find(wp => wp.type === 'F');
            if (startPoint && endPoint) {
                 waypointsToSave = [endPoint];
            }
        }
        const routeToSave = {
            name: routeName,
            waypoints: waypointsToSave,
            createdAt: new Date().toISOString()
        };
        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        const existingRouteIndex = savedRoutes.findIndex(r => r.name === routeName);
        if (existingRouteIndex !== -1) {
            if (!confirm(`Ya existe una ruta llamada "${routeName}". ¿Sobreescribir?`)) {
                showToast("Guardado cancelado", "info");
                addModalAutoCloseTimer(modal, confirmButton, 'save-route-prompt-modal', 15000);
                return;
            }
            savedRoutes[existingRouteIndex] = routeToSave;
        } else {
            savedRoutes.push(routeToSave);
        }
        if (savedRoutes.length > MAX_SAVED_ROUTES) {
            savedRoutes.sort((a,b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
            savedRoutes = savedRoutes.slice(0, MAX_SAVED_ROUTES);
        }
        localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes));
        localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
        markCacheAsDirty(); 
        showToast(`Ruta "${routeName}" guardada`, "success");
        closePrompt();
    };
    confirmButton.addEventListener('click', saveAction);
    cancelButton.addEventListener('click', () => {
        closePrompt();
    });
    addModalAutoCloseTimer(modal, confirmButton, 'save-route-prompt-modal', 15000);
}






    

// ===================================================================
// NOMBRE: generateBackup
// RESUMEN: Genera un código de backup con todos los datos locales y lo copia al portapapeles.
// ===================================================================
function generateBackup() {
    const backupData = {};
    managedKeys.forEach(key => {
        const value = localStorage.getItem(key);
        if (value !== null) {
            backupData[key] = value;
        }
    });
    const backupString = JSON.stringify(backupData);
    const backupDisplay = document.getElementById('config-backup-display');
    backupDisplay.value = btoa(unescape(encodeURIComponent(backupString)));
    backupDisplay.style.display = 'block';
    backupDisplay.select();
    try {
        document.execCommand('copy');
        showToast('Backup copiado al portapapeles', 'success');
         document.getElementById('config-backup-status').textContent = '¡Copiado! Guarda este código en un lugar seguro.';
         document.getElementById('config-backup-status').style.color = '#28a745';
    } catch (err) {
        showToast('Error al copiar. Por favor, copia manualmente', 'warning');
        document.getElementById('config-backup-status').textContent = 'Copia este código manualmente y guárdalo.';
        document.getElementById('config-backup-status').style.color = '#ffc107';
    }
}






    






    


 // ===================================================================
// NOMBRE: updateStartNavigationButtonState
// RESUMEN: Actualiza la visibilidad y estado de los botones de navegación según si hay una ruta activa.
// ===================================================================
function updateStartNavigationButtonState() {
    const startNavButton = document.getElementById('start-navigation-button');
    const saveRouteButton = document.getElementById('save-route-button');
    const reorderBtn = document.getElementById('reorder-route-stages-button');
    const startNavImg = startNavButton ? startNavButton.querySelector('img') : null;
    const simulateBtn = document.getElementById('simulate-route-button');
    const deleteRouteBtn = document.getElementById('delete-current-route-button');
    const loadRouteBtn = document.getElementById('load-saved-route-button'); 
    const toggleSimulateGpsBtn = document.getElementById('toggle-simulate-gps-button');
    const graphCard = document.getElementById('navigation-graph-card');
    if (!startNavButton || !saveRouteButton || !reorderBtn || !simulateBtn || !loadRouteBtn || !deleteRouteBtn || !toggleSimulateGpsBtn || !graphCard) return;
    const hasEnoughWaypointsForRoute = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2;
    const hasRouteData = navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0];
    const canDisplayRoute = hasEnoughWaypointsForRoute && hasRouteData;
    const hasAtLeastOneWaypoint = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 1;
    startNavButton.classList.toggle('hidden', !(hasEnoughWaypointsForRoute || isNavigating));
    saveRouteButton.classList.toggle('hidden', !(!isNavigating && canDisplayRoute));
    if (reorderBtn) reorderBtn.style.display = (!isNavigating && canDisplayRoute) ? 'inline-flex' : 'none';
    const canSimulate = (canDisplayRoute || (isNavigating && hasRouteData));
    if(simulateBtn) simulateBtn.style.display = canSimulate ? 'inline-flex' : 'none';
    if(toggleSimulateGpsBtn) toggleSimulateGpsBtn.style.display = hasAtLeastOneWaypoint ? 'inline-flex' : 'none';
    if (deleteRouteBtn) {
        deleteRouteBtn.classList.remove('hidden');
    }
    if (loadRouteBtn) {
        loadRouteBtn.classList.remove('hidden');
    }
    const hasGraphData = graphDataPoints && (graphDataPoints.speed.length > 0 || graphDataPoints.altitude.length > 0);
    graphCard.classList.toggle('hidden', !hasGraphData || currentGraphMode === 'Gráfica off');
    if (isNavigating) {
        if(reorderBtn) reorderBtn.style.display = 'none';
        if(startNavImg) startNavImg.src = "TERMINARNAVEGACION.PNG";
    } else {
        if (hasEnoughWaypointsForRoute) {
            if(startNavImg) startNavImg.src = "INICIARNAVEGACION.PNG";
        } else {
            if (navigationRouteLayer && navigationMapInstance) { try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch(e){} navigationRouteLayer = null; }
            if (completedRouteSegmentsLayer && navigationMapInstance) completedRouteSegmentsLayer.clearLayers();
            navigationCurrentRouteData = null;
            hideNavigationUI();
            hideMapInfoOverlay();
        }
    }
    updateNavigationGraphVisibilityAndMode();
}





// ===================================================================
// NOMBRE: restoreOriginalGrid
// RESUMEN: Restaura el grid de marcadores a su estado original de fábrica.
// ===================================================================
function restoreOriginalGrid() {
    if (confirm('¿Restaurar el grid de botones a su estado original? Perderás tu personalización del grid (URLs, nombres, orden).')) {
        localStorage.removeItem('customGridData');
        localStorage.removeItem('gridFilterValue');
        loadCustomData();
        renderGrid();
        renderToggleButtons();
        loadSavedSettings();
        updateButtonStyles();
        filterGridItems();
        document.getElementById('config-restore-grid-status').textContent = 'Grid restaurado al original. Recargando...';
        document.getElementById('config-restore-grid-status').style.color = '#28a745';
        showToast('Grid restaurado. Recargando...', 'success');
        setTimeout(() => location.reload(), 1500);
    }
}











 





    





// ===================================================================
// NOMBRE: getManeuverIconFilename
// RESUMEN: Devuelve el nombre del fichero de imagen para una maniobra.
// ===================================================================
function getManeuverIconFilename(maneuver) {
    if (!maneuver) return 'continue.png';
    const type = maneuver.type || '';
    const modifier = maneuver.modifier || '';

    // Salidas de rotonda específicas
    if (type.includes('roundabout') && maneuver.exit && maneuver.exit >= 1 && maneuver.exit <= 5 && getManeuverInstructionText(maneuver).toLowerCase().includes("salida")) {
        return `S${maneuver.exit}.PNG`;
    }
    
    // Casos únicos
    if (type === 'depart') return 'depart.png';
    if (type === 'arrive') return 'arrive.png';
    if (type.includes('roundabout') || type.includes('rotary')) return 'roundabout.png';
    
    // Casos con modificador (ordenados de más específico a más general)
    if (modifier.includes('uturn')) return 'uturn.png';
    if (modifier.includes('sharp right')) return 'sharp-right.png';
    if (modifier.includes('sharp left')) return 'sharp-left.png';
    if (modifier.includes('slight right') || modifier.includes('bear right')) return 'bear-right.png';
    if (modifier.includes('slight left') || modifier.includes('bear left')) return 'bear-left.png';
    if (modifier.includes('right')) return 'turn-right.png';
    if (modifier.includes('left')) return 'turn-left.png';
    if (modifier.includes('ramp')) return 'ramp.png';
    
    return 'continue.png'; 
}






    


  // ===================================================================
// NOMBRE: getSuggestedRouteName
// RESUMEN: Sugiere un nombre de ruta por defecto basado en la ubicación final.
// ===================================================================
async function getSuggestedRouteName(lat, lng, isMultiStage = false, totalWaypoints = 0) {
    let baseName = `RUTA: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
    try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=1&accept-language=es`);
        if (response.ok) {
            const data = await response.json();
            if (data.address) {
                const road = data.address.road;
                const city = data.address.city || data.address.town || data.address.village || data.address.hamlet;
                if (road && city) baseName = `${road}, ${city}`;
                else if (city) baseName = city;
                else if (road) baseName = road;
            }
        }
    } catch (e) {
    }
    if (isMultiStage) {
        const numStages = Math.max(0, totalWaypoints - 1);
        return `${numStages} ETAPAS: ${baseName}`;
    } else {
        return `  ${baseName}`;
    }
}
    









    
    






    
// ===================================================================
// NOMBRE: initializeConfigModalListeners
// RESUMEN: Asigna los listeners a todos los elementos interactivos del modal de configuración.
// ===================================================================
function initializeConfigModalListeners() {
    document.getElementById('config-save-user-firebase')?.addEventListener('click', validateAndSaveUserToFirebase);
    document.getElementById('config-save-user-firebase-from-backup-tab')?.addEventListener('click', validateAndSaveUserToFirebase);
    document.getElementById('config-restore-backup-firebase')?.addEventListener('click', restoreBackupFromFirebase);
    document.getElementById('config-save-pin')?.addEventListener('click', savePinSettings);
    document.getElementById('config-remove-pin')?.addEventListener('click', removePinSettings);
    document.getElementById('config-generate-backup')?.addEventListener('click', generateBackup);
    document.getElementById('config-restore-backup')?.addEventListener('click', restoreBackup);
    document.getElementById('config-restore-grid-button')?.addEventListener('click', restoreOriginalGrid);
    document.getElementById('config-clear-cache')?.addEventListener('click', clearAllLocalData);

    const importBtn = document.getElementById('import-radars-button');
    if (importBtn && !importBtn.dataset.listenerAttached) {
        importBtn.addEventListener('click', importRadars);
        importBtn.dataset.listenerAttached = "true";
    }

    const deleteBtn = document.getElementById('delete-filtered-radars-button');
    if (deleteBtn && !deleteBtn.dataset.listenerAttached) {
        deleteBtn.addEventListener('click', deleteFilteredRadars);
        deleteBtn.dataset.listenerAttached = "true";
    }

    const acceptTermsButton = document.getElementById('accept-terms-button');
    if (acceptTermsButton && !acceptTermsButton.dataset.listenerAttached) {
        acceptTermsButton.addEventListener('click', () => {
            localStorage.setItem('termsAccepted_v1', 'true');
            showToast('Normas aceptadas. Gracias.', 'success');
            const modal = document.getElementById('config-modal');
            if (modal) {
                modal.querySelectorAll('.config-tab-button').forEach(btn => {
                    btn.disabled = false;
                    btn.style.cursor = 'pointer';
                    btn.style.opacity = '1';
                });
                // Cambiar a la primera pestaña (Usuario)
                modal.querySelector('.config-tab-button[data-tab-target="#tab-content-normas"]').classList.remove('active');
                modal.querySelector('#tab-content-normas').classList.remove('active');
                modal.querySelector('.config-tab-button[data-tab-target="#tab-content-usuario"]').classList.add('active');
                modal.querySelector('#tab-content-usuario').classList.add('active');
            }
        });
        acceptTermsButton.dataset.listenerAttached = "true";
    }
    
    const directToNavCheckbox = document.getElementById('config-direct-to-nav');
    if (directToNavCheckbox && !directToNavCheckbox.dataset.listenerAttached) {
        directToNavCheckbox.addEventListener('change', () => {
            localStorage.setItem(DIRECT_TO_NAVIGATION_KEY, JSON.stringify(directToNavCheckbox.checked));
            showToast('Preferencia de inicio directo al mapa guardada.', 'success', 2000);
        });
        directToNavCheckbox.dataset.listenerAttached = "true";
    }

    const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
    if (autoBackupCheckbox && !autoBackupCheckbox.dataset.listenerAttached) {
        autoBackupCheckbox.addEventListener('change', () => {
            localStorage.setItem('boardinggate_autoBackupOnLoad', JSON.stringify(autoBackupCheckbox.checked));
            showToast(`Copia de seguridad automática al inicio: ${autoBackupCheckbox.checked ? 'Activada' : 'Desactivada'}`, 'info', 3000);
        });
        autoBackupCheckbox.dataset.listenerAttached = "true";
    }
}
    








    
// ===================================================================
// NOMBRE: startGpsWatching
// RESUMEN: Inicia el seguimiento GPS del dispositivo y gestiona los reintentos.
// ===================================================================
function startGpsWatching() {
    if (gpsRetryTimeoutId) {
        clearTimeout(gpsRetryTimeoutId);
        gpsRetryTimeoutId = null;
    }
    if (locationWatchId !== null) {
        return;
    }
    if (!('geolocation' in navigator) || !('watchPosition' in navigator.geolocation)) {
        showToast("Geolocalización no soportada por este navegador.", "error", 5000);
        return;
    }
    if (gpsRetryAttempt >= MAX_GPS_RETRIES) {
        showToast("Error persistente: No se pudo conectar al GPS. Revisa la configuración del dispositivo.", "error", 0, false, "gps-persistent-error");
        return;
    }
    gpsRetryAttempt++;
    showToast(`Intentando conectar al GPS (Intento ${gpsRetryAttempt}/${MAX_GPS_RETRIES})...`, "info", GPS_RETRY_DELAY_MS, false, "gps-attempt-toast");
    locationWatchId = navigator.geolocation.watchPosition(
        (position) => {
            if (isSimulatingGpsLocation) return;
            const attemptToast = document.getElementById("gps-attempt-toast");
            if (attemptToast) attemptToast.remove();
            activeToasts = activeToasts.filter(t => t.id !== "gps-attempt-toast");
            gpsRetryAttempt = 0;
            const persistentErrorToast = document.getElementById("gps-persistent-error");
            if (persistentErrorToast) persistentErrorToast.remove();
            const coordsForUpdate = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                heading: position.coords.heading,
                speed: position.coords.speed,
                altitude: position.coords.altitude
            };
            navigationCurrentLocation = coordsForUpdate;

            // <-- LÍNEA CORREGIDA: ¡AQUÍ ESTABA EL ERROR! -->
            // Se llama a la función que actualiza el icono y la vista del mapa.
            // ANTES (INCORRECTO): (coordsForUpdate, navigationMapInstance);
            updateInitialUserPosition(coordsForUpdate, navigationMapInstance);

            if (isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0] && coordsForUpdate) {
                const routeForDistCalc = navigationCurrentRouteData.routes[0];
                let carDistTurf = 0;
                if (navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
                    try {
                        const carPointTurf = turf.point([coordsForUpdate.longitude, coordsForUpdate.latitude]);
                        const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                        const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                        const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                        carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                    } catch (e) { }
                }
                const totalRouteLength = routeForDistCalc.distance;
                if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                    if (carDistTurf > lastCarDistanceAlongRouteForNavLogic - 100) {
                         lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                    }
                } else if (carDistTurf > totalRouteLength + 500) {
                    lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
                }

                let cumulativeDistance = 0;
                navigationWaypoints.forEach((wp, index) => {
                    if (wp) {
                        const isStartPoint = wp.type === 'S' || wp.isRecalculatedStart;
                        const isIntermediate = wp.type === 'intermediate';
                        const isFinal = wp.type === 'F';

                        if (isStartPoint) {
                            wp.visited = true;
                        } else if (isIntermediate && routeForDistCalc.legs && (index - 1) < routeForDistCalc.legs.length) {
                            const leg = routeForDistCalc.legs[index - 1];
                            if (leg) {
                                cumulativeDistance += (leg.distance || 0);
                                if (carDistTurf >= cumulativeDistance - WAYPOINT_VISITED_THRESHOLD_METERS) {
                                    wp.visited = true;
                                }
                            }
                        } else if (isFinal) {
                            if (carDistTurf >= routeForDistCalc.distance - WAYPOINT_VISITED_THRESHOLD_METERS) {
                                wp.visited = true;
                            }
                        }
                    }
                });
                renderWaypointMarkers();
                
                updateTurnByTurnDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                updateNavigationProgressDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
            }
        },
        (error) => {
            showToast(`Error GPS: ${error.message}`, "warning");
            if (locationWatchId !== null) {
                navigator.geolocation.clearWatch(locationWatchId);
                locationWatchId = null;
            }
            gpsRetryTimeoutId = setTimeout(startGpsWatching, GPS_RETRY_DELAY_MS);
        },
        { enableHighAccuracy: true, timeout: 15000, maximumAge: 2000, distanceFilter: 3 }
    );
}

    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: parseUserId
    // RESUMEN: Analiza el ID de usuario para detectar si es un usuario móvil y extrae el ID principal.
    // ===================================================================
    function parseUserId(rawUserId) {
        if (!rawUserId) {
            return { primaryId: null, isMobile: false, originalId: null };
        }
        const mobileRegex = /^(.*?)@(MÓVIL|MOVIL)$/i;
        const match = rawUserId.trim().match(mobileRegex);
        if (match && match[1]) {
            return {
                primaryId: match[1].trim(),
                isMobile: true,
                originalId: rawUserId.trim()
            };
        } else {
            return {
                primaryId: rawUserId.trim(),
                isMobile: false,
                originalId: rawUserId.trim()
            };
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: markCacheAsDirty
    // RESUMEN: Actualiza un timestamp para marcar que la caché local ha sido modificada.
    // ===================================================================
    function markCacheAsDirty() {
        localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: promptForBackupPassword
    // RESUMEN: Muestra un modal para que el usuario introduzca un PIN de seguridad para backups.
    // ===================================================================
    function promptForBackupPassword(message, onConfirm, onCancel, isSettingPassword = false) {
        const existingModal = document.getElementById('backup-password-modal-overlay');
        if (existingModal) existingModal.remove();
        const modalOverlay = document.createElement('div');
        modalOverlay.id = 'backup-password-modal-overlay';
        modalOverlay.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85); display: flex; justify-content: center;
            align-items: center; z-index: 9999;
        `;
        const modalContent = document.createElement('div');
        modalContent.id = 'backup-password-modal-content';
        modalContent.style.cssText = `
            background-color: #DAC8A0; padding: 2rem; border-radius: 0.75rem;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4); text-align: center; border: 1px solid #A0522D;
            margin-top: -50px;
            max-width: 350px; width: 90%;
        `;
        modalContent.innerHTML = `
            <h2 style="font-size: 1.5rem; font-weight: bold; color: #333; margin-bottom: 1rem;">${message}</h2>
            <input type="password" id="backup-password-input" maxlength="6" pattern="\\d{6}" inputmode="numeric" style="
                width: 150px; padding: 0.8rem; font-size: 1.8rem; text-align: center;
                border: 2px solid #A0522D; border-radius: 0.25rem; margin-bottom: 1.5rem;
                letter-spacing: 0.5em; background-color: #f0f0e0;
            " required>
            ${isSettingPassword ? `
                <label for="backup-password-confirm" style="display: block; font-size: 1.1rem; color: #444; margin-bottom: 0.8rem;">Confirmar PIN:</label>
                <input type="password" id="backup-password-confirm" maxlength="6" pattern="\\d{6}" inputmode="numeric" style="
                    width: 150px; padding: 0.8rem; font-size: 1.8rem; text-align: center;
                    border: 2px solid #A0522D; border-radius: 0.25rem; margin-bottom: 1.5rem;
                    letter-spacing: 0.5em; background-color: #f0f0e0;
                " required>
            ` : ''}
            <p id="backup-password-error" style="color: #dc3545; font-weight: bold; margin-top: -0.5rem; margin-bottom: 1rem; min-height: 1.2em;"></p>
            <div style="display:flex; justify-content: space-around; gap:1rem;">
                <button id="backup-password-submit" style="padding: 0.8rem 1.5rem; font-size: 1.2rem; background-color: #28a745; color: white; border: none; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; flex: 1;">Aceptar</button>
                <button id="backup-password-cancel" style="padding: 0.8rem 1.5rem; font-size: 1.2rem; background-color: #6c757d; color: white; border: none; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; flex: 1;">Cancelar</button>
            </div>
        `;
        document.body.appendChild(modalOverlay);
        modalOverlay.appendChild(modalContent);
        const pinInput = document.getElementById('backup-password-input');
        const pinConfirmInput = document.getElementById('backup-password-confirm');
        const errorEl = document.getElementById('backup-password-error');
        const submitBtn = document.getElementById('backup-password-submit');
        const cancelBtn = document.getElementById('backup-password-cancel');
        pinInput.focus();
        const validateAndSubmit = () => {
            errorEl.textContent = '';
            const pin = pinInput.value;
            if (!/^\d{6}$/.test(pin)) {
                errorEl.textContent = 'El PIN debe ser de 6 dígitos numéricos.';
                if (navigator.vibrate) navigator.vibrate(100);
                return;
            }
            if (isSettingPassword) {
                const confirmPin = pinConfirmInput.value;
                if (pin !== confirmPin) {
                    errorEl.textContent = 'Los PINs no coinciden.';
                    if (navigator.vibrate) navigator.vibrate(100);
                    return;
                }
            }
            modalOverlay.remove();
            onConfirm(pin);
        };
        submitBtn.addEventListener('click', validateAndSubmit);
        cancelBtn.addEventListener('click', () => {
            modalOverlay.remove();
            onCancel();
        });
        pinInput.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                if (isSettingPassword && pinConfirmInput) {
                    pinConfirmInput.focus();
                } else {
                    validateAndSubmit();
                }
            }
        });
        if (isSettingPassword && pinConfirmInput) {
            pinConfirmInput.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') {
                    validateAndSubmit();
                }
            });
        }
        addModalAutoCloseTimer(modalOverlay, submitBtn, 'backup-password-modal', isSettingPassword ? 90000 : 30000);
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: callFirebase
    // RESUMEN: Encapsula las llamadas a Firebase Firestore para guardar, obtener o verificar datos de usuario.
    // ===================================================================
    async function callFirebase(action, data) {
        if (!window.db || !window.doc || !window.setDoc || !window.getDoc || !window.collection) {
            console.error("Firebase Firestore SDK functions no están expuestas globalmente.");
            return { status: "error", message: "Error interno: Funciones de Firebase no están disponibles." };
        }
        const userId = data.userId;
        if (!userId) {
            return { status: "error", message: "ID de Usuario es obligatorio para las operaciones de Firebase." };
        }
        try {
            const userDocRef = window.doc(window.db, "user_data", userId);
            if (action === 'saveUser') {
                const documentData = {
                    usuario: data.usuario,
                    modelo: data.modelo || '',
                    anio: data.anio || '',
                    provincia: data.provincia || '',
                    rss: data.rss || false,
                    contenidoCacheCompleto: JSON.stringify(data.datosCache),
                    fechaBackup: new Date().toISOString(),
                    backupPassword: data.backupPassword || null
                };
                await window.setDoc(userDocRef, documentData);
                return { status: "success", message: "Datos guardados en Firebase." };
            } else if (action === 'getUserData') {
                const docSnap = await window.getDoc(userDocRef);
                if (docSnap.exists()) {
                    const firebaseData = docSnap.data();
                    try {
                        firebaseData.contenidoCacheCompleto = JSON.parse(firebaseData.contenidoCacheCompleto);
                    } catch (e) {
                        console.error("Error al parsear contenidoCacheCompleto de Firebase:", e);
                    }
                    return { status: "success", message: "Datos recuperados de Firebase.", data: firebaseData };
                } else {
                    return { status: "not_found", message: "No se encontró ningún backup para ese ID de Usuario." };
                }
            } else if (action === 'checkUserExists') {
                 const docSnap = await window.getDoc(userDocRef);
                 return { status: "success", exists: docSnap.exists() };
            } else {
                return { status: "error", message: "Acción de Firebase no reconocida." };
            }
        } catch (error) {
            console.error("Error en la operación de Firebase:", error);
            return { status: "error", message: `Error de Firebase: ${error.message}` };
        }
    }
    
    
    
    
    
    
    
    
    // ===================================================================
// NOMBRE: validateAndSaveUserToFirebase
// RESUMEN: Valida el usuario, pide PIN si es necesario y guarda los datos locales en Firebase.
// ===================================================================
async function validateAndSaveUserToFirebase() {
    const statusEl = document.getElementById('config-user-status');
    const userIdInput = document.getElementById('user-id');
    const { primaryId, isMobile, originalId } = parseUserId(userIdInput.value);

    // <-- AÑADIDO: Comprobación para proteger el usuario 'ALERTAS' -->
    if (primaryId && primaryId.toUpperCase() === 'ALERTAS') {
        statusEl.textContent = 'El nombre de usuario "ALERTAS" está reservado para el sistema. Por favor, elige otro.';
        statusEl.style.color = '#EF4444';
        showToast('Nombre de usuario no permitido', 'error');
        return; // Detiene la ejecución de la función
    }
    // <-- FIN DE LA MODIFICACIÓN -->

    if (!primaryId) {
        statusEl.textContent = 'El ID de Usuario es obligatorio.';
        statusEl.style.color = '#EF4444';
        return;
    }
    statusEl.textContent = 'Validando y preparando guardado...';
    statusEl.style.color = '#17a2b8';
    const toastId = "firebase-save-toast";
    showToast('Validando en la nube...', 'info', 0, false, toastId);
    const currentLocalUserId = localStorage.getItem('userData_userId');
    const localBackupPassword = localStorage.getItem('userData_backupPassword');
    const hasChangedUser = originalId.toLowerCase() !== (currentLocalUserId || '').toLowerCase();
    const completeSaveProcess = async (finalBackupPin) => {
        localStorage.setItem('userData_userId', originalId);
        localStorage.setItem('userData_teslaModel', document.getElementById('tesla-model').value.trim());
        localStorage.setItem('userData_teslaYear', document.getElementById('tesla-year').value.trim());
        localStorage.setItem('userData_teslaProvince', document.getElementById('tesla-province').value.trim());
        localStorage.setItem('userData_allowDMs', JSON.stringify(document.getElementById('allow-dms').checked));
        localStorage.setItem('boardinggate_autoBackupOnLoad', JSON.stringify(document.getElementById('config-auto-backup-on-load').checked));
        localStorage.setItem('userData_backupPassword', finalBackupPin);
        updateUserIdDisplay();
        const cacheData = {};
        managedKeys.forEach(key => {
            const value = localStorage.getItem(key);
            if (value !== null) cacheData[key] = value;
        });
        const saveData = {
            userId: primaryId,
            usuario: primaryId,
            modelo: localStorage.getItem('userData_teslaModel') || '',
            anio: localStorage.getItem('userData_teslaYear') || '',
            provincia: localStorage.getItem('userData_teslaProvince') || '',
            rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
            datosCache: cacheData,
            backupPassword: finalBackupPin,
            fechaBackup: new Date().toISOString()
        };
        const saveResult = await callFirebase('saveUser', saveData);
        const existingToast = document.getElementById(toastId);
        if (existingToast) existingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== toastId);
        if (saveResult.status === 'success') {
            const successMsg = isMobile ?
                `Datos sincronizados con el usuario "${primaryId}".` :
                "Datos guardados en la nube y localmente.";
            statusEl.textContent = successMsg;
            statusEl.style.color = '#28a745';
            showToast(successMsg, 'success');
            localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
        } else {
            statusEl.textContent = `Error al guardar: ${saveResult.message}. (Datos guardados localmente).`;
            statusEl.style.color = '#EF4444';
            showToast(`Error al guardar: ${saveResult.message}`, 'error');
        }
    };
    if (!hasChangedUser && localBackupPassword) {
        await completeSaveProcess(localBackupPassword);
    } else {
        const checkResult = await callFirebase('checkUserExists', { userId: primaryId });
        if (checkResult.status === 'error') {
            statusEl.textContent = `Error al verificar usuario en la nube: ${checkResult.message}.`;
            statusEl.style.color = '#EF4444';
            return;
        }
        if (checkResult.exists) {
            promptForBackupPassword(
                `Introduce el PIN para "${primaryId}":`,
                async (enteredPin) => {
                    const retrieveResult = await callFirebase('getUserData', { userId: primaryId });
                    if (retrieveResult.status === 'success' && retrieveResult.data && retrieveResult.data.backupPassword === enteredPin) {
                        await completeSaveProcess(enteredPin);
                    } else {
                        statusEl.textContent = 'PIN incorrecto. Guardado cancelado.';
                        statusEl.style.color = '#EF4444';
                        showToast('PIN incorrecto. Acceso denegado.', 'error');
                    }
                },
                () => { }
            );
        } else {
            if(isMobile) {
                statusEl.textContent = `El usuario primario "${primaryId}" no existe. No se puede sincronizar.`;
                statusEl.style.color = '#EF4444';
                return;
            }
            promptForBackupPassword(
                'Nuevo usuario. Establece un PIN de 6 dígitos:',
                (pin) => completeSaveProcess(pin),
                () => { },
                true
            );
        }
    }
}


    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: autoSaveFromMobile
    // RESUMEN: Realiza un guardado automático en Firebase, llamado por checkReminders para usuarios móviles.
    // ===================================================================
    async function autoSaveFromMobile(primaryId, backupPassword) {
        showToast(`Sincronizando cambios con "${primaryId}"...`, 'info', 0, false, 'mobile-autosave');
        const cacheData = {};
        managedKeys.forEach(key => {
            const value = localStorage.getItem(key);
            if (value !== null) cacheData[key] = value;
        });
        const saveData = {
            userId: primaryId,
            usuario: primaryId,
            modelo: localStorage.getItem('userData_teslaModel') || '',
            anio: localStorage.getItem('userData_teslaYear') || '',
            provincia: localStorage.getItem('userData_teslaProvince') || '',
            rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
            datosCache: cacheData,
            backupPassword: backupPassword,
            fechaBackup: new Date().toISOString()
        };
        const saveResult = await callFirebase('saveUser', saveData);
        const toast = document.getElementById('mobile-autosave');
        if(toast) toast.remove();
        if (saveResult.status === 'success') {
            showToast('Cambios sincronizados con la nube.', 'success');
            lastMobileSyncTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');
        } else {
            showToast(`Error al sincronizar: ${saveResult.message}`, 'error');
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: syncDataOnLoad
    // RESUMEN: Sincroniza datos al cargar, descargando o subiendo a Firebase según timestamps.
    // ===================================================================
    async function syncDataOnLoad() {
        const autoSyncEnabled = JSON.parse(localStorage.getItem('boardinggate_autoBackupOnLoad') || 'false');
        const { primaryId, isMobile } = parseUserId(localStorage.getItem('userData_userId'));
        const backupPassword = localStorage.getItem('userData_backupPassword');
        if (!autoSyncEnabled || !primaryId || isMobile || !backupPassword) {
            return;
        }
        showToast(`Sincronizando datos del coche para ${primaryId}...`, 'info', 4000, false, "auto-sync-toast");
        const result = await callFirebase('getUserData', { userId: primaryId });
        const existingToast = document.getElementById("auto-sync-toast");
        if (existingToast) existingToast.remove();
        if (result.status === 'success' && result.data) {
            const cloudTimestamp = new Date(result.data.fechaBackup || 0).getTime();
            const localTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');
            if (cloudTimestamp > localTimestamp + 10000) {
                showToast(`Nuevos datos encontrados en la nube. Aplicando...`, 'info', 5000);
                const backupCacheData = result.data.contenidoCacheCompleto;
                if (backupCacheData) {
                    const currentUserIdentity = localStorage.getItem('userData_userId');
                    for (const key in backupCacheData) {
                        if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                            localStorage.setItem(key, backupCacheData[key]);
                        }
                    }
                    if (currentUserIdentity) {
                        localStorage.setItem('userData_userId', currentUserIdentity);
                    }
                    localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
                    showToast('Datos sincronizados desde la nube. La página se recargará.', 'success', 3000);
                    setTimeout(() => location.reload(), 2500);
                } else {
                    showToast('Los datos en la nube están corruptos.', 'error');
                }
            }
            else if (localTimestamp > cloudTimestamp + 10000) {
                showToast('Realizando copia de seguridad automática...', 'info', 3000);
                const cacheData = {};
                managedKeys.forEach(key => {
                    const value = localStorage.getItem(key);
                    if (value !== null) cacheData[key] = value;
                });
                const requestData = {
                    userId: primaryId, usuario: primaryId,
                    modelo: localStorage.getItem('userData_teslaModel') || '',
                    anio: localStorage.getItem('userData_teslaYear') || '',
                    provincia: localStorage.getItem('userData_teslaProvince') || '',
                    rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
                    datosCache: cacheData,
                    backupPassword: backupPassword,
                    fechaBackup: new Date().toISOString()
                };
                await callFirebase('saveUser', requestData);
            }
        } else if (result.status === 'not_found') {
            showToast(`Creando primera copia de seguridad para ${primaryId}...`, 'info', 3000);
            const cacheData = {};
            managedKeys.forEach(key => {
                const value = localStorage.getItem(key);
                if (value !== null) cacheData[key] = value;
            });
            const requestData = {
                userId: primaryId, usuario: primaryId,
                modelo: localStorage.getItem('userData_teslaModel') || '',
                anio: localStorage.getItem('userData_teslaYear') || '',
                provincia: localStorage.getItem('userData_teslaProvince') || '',
                rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
                datosCache: cacheData,
                backupPassword: backupPassword,
                fechaBackup: new Date().toISOString()
            };
            await callFirebase('saveUser', requestData);
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: restoreBackupFromFirebase
    // RESUMEN: Recupera y aplica un backup de datos desde Firebase, pidiendo PIN para confirmar.
    // ===================================================================
    async function restoreBackupFromFirebase(isAutoLoad = false) {
        const statusEl = document.getElementById('config-restore-status');
        const { primaryId, isMobile, originalId } = parseUserId(document.getElementById('restore-user-id').value || localStorage.getItem('userData_userId'));
        if (!primaryId) {
            if (!isAutoLoad) statusEl.textContent = 'Introduce un ID de Usuario para recuperar.';
            if (!isAutoLoad) statusEl.style.color = '#EF4444';
            return;
        }
        if (!isAutoLoad) {
            statusEl.textContent = `Buscando backup para "${primaryId}"...`;
            statusEl.style.color = '#17a2b8';
            showToast(`Recuperando backup de "${primaryId}"...`, 'info', 0, false, "firebase-restore-toast");
        }
        const result = await callFirebase('getUserData', { userId: primaryId });
        if (!isAutoLoad) {
            const existingToast = document.getElementById("firebase-restore-toast");
            if (existingToast) existingToast.remove();
            activeToasts = activeToasts.filter(t => t.id !== "firebase-restore-toast");
        }
        if (result.status === 'success' && result.data) {
            const firebaseData = result.data;
            const backupCacheData = firebaseData.contenidoCacheCompleto;
            if (!backupCacheData) {
                if (!isAutoLoad) {
                    statusEl.textContent = `El backup para "${primaryId}" no contiene datos de caché.`;
                    statusEl.style.color = '#EF4444';
                    showToast('Backup incompleto.', 'error');
                }
                return;
            }
            const applyChanges = () => {
                const currentUserIdentity = localStorage.getItem('userData_userId') || originalId;
                for (const key in backupCacheData) {
                    if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                        localStorage.setItem(key, backupCacheData[key]);
                    }
                }
                localStorage.setItem('userData_userId', currentUserIdentity);
                const newTimestamp = Date.now().toString();
                localStorage.setItem('lastCacheUpdateTimestamp', newTimestamp);
                if (isMobile) {
                    lastMobileSyncTimestamp = parseInt(newTimestamp);
                }
                showToast('Restauración completada. Recargando...', 'success', 3000);
                setTimeout(() => location.reload(), 2500);
            };
            if (isAutoLoad) {
                applyChanges();
            } else {
                 promptForBackupPassword(
                    `Introduce el PIN para "${primaryId}":`,
                    (enteredPin) => {
                        if (enteredPin === firebaseData.backupPassword) {
                            if (confirm(`Se encontró un backup para "${primaryId}". ¿Estás seguro de que quieres restaurar estos datos?`)) {
                                applyChanges();
                            } else {
                                statusEl.textContent = 'Restauración cancelada.';
                                statusEl.style.color = '#6c757d';
                            }
                        } else {
                            statusEl.textContent = 'PIN incorrecto. Restauración cancelada.';
                            statusEl.style.color = '#EF4444';
                            showToast('PIN incorrecto.', 'error');
                        }
                    },
                    () => {
                        statusEl.textContent = 'Restauración cancelada.';
                        statusEl.style.color = '#6c757d';
                    }
                );
            }
        } else if (result.status === 'not_found' && !isAutoLoad) {
            statusEl.textContent = `No se encontró backup para "${primaryId}".`;
            statusEl.style.color = '#EF4444';
            showToast('Backup no encontrado.', 'error not-found');
        } else if (!isAutoLoad) {
            statusEl.textContent = `Error al recuperar: ${result.message}`;
            statusEl.style.color = '#EF4444';
            showToast(`Error de recuperación: ${result.message}`, 'error');
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getRandomSpeedMultiplierForManeuver
    // RESUMEN: Devuelve un multiplicador aleatorio de velocidad para simular variaciones en las maniobras.
    // ===================================================================
    function getRandomSpeedMultiplierForManeuver(maneuver) {
        const type = maneuver.type || '';
        const modifier = maneuver.modifier || '';
        let min, max;
        if (type === 'roundabout' || type === 'rotary' || modifier.includes('sharp') || modifier.includes('uturn')) {
            min = -0.30;
            max = 0.10;
        } else if (type === 'turn' || type === 'fork' || type === 'merge' || type === 'end of road') {
            min = -0.20;
            max = 0.20;
        } else {
            min = -0.05;
            max = 0.25;
        }
        return Math.random() * (max - min) + min;
    }
    
    
    
    





// ===================================================================
// NOMBRE: hideIntersectionPreviewMap
// RESUMEN: Oculta el minimapa de previsualización de la intersección.
// ===================================================================
function hideIntersectionPreviewMap() {
    const card = document.getElementById('intersection-preview-map-window');
    if (card) {
        card.classList.add('hidden');
        const rotator = card.querySelector('#intersection-rotator');
        if (rotator) {
            rotator.style.transform = 'rotate(0deg)';
        }
        miniMapOffsetActive.x = 0;
        targetMapCenterOffset.x -= miniMapOffsetActive.x;
    }
    if (intersectionPreviewTimer) {
        clearTimeout(intersectionPreviewTimer);
        intersectionPreviewTimer = null;
    }
}



    
    




// ===================================================================
// NOMBRE: checkReminders
// RESUMEN: Comprueba periódicamente los recordatorios y las alertas de tráfico.
// ===================================================================
function checkReminders() {
    // Control de tiempo para las alertas de tráfico
    if (Date.now() - lastAlertCheckTimestamp >= ALERT_CHECK_INTERVAL) {
        lastAlertCheckTimestamp = Date.now();
        processTrafficAlerts();
    }
    
    // El resto de tu lógica de recordatorios...
    if (isRecalculatingRoute && recalculationAttempts > 0) {
        return;
    }
    let currentReminders = []; try { currentReminders = JSON.parse(localStorage.getItem('reminders') || '[]'); } catch (e) { localStorage.setItem('reminders_backup_error', localStorage.getItem('reminders') || '[]'); localStorage.removeItem('reminders'); showToast("Error al cargar recordatorios. Backup intentado.", "error", 5000); return; }
    const now = new Date(); let overdueReminders = []; const validRemindersForStorage = []; let storageNeedsUpdate = false; const processedIds = new Set(); let newOverdueFound = false; let isAnyReminderNearby = false;
    new Promise((resolve) => {
        if (isSimulatingGpsLocation && simulatedGpsLocation) {
            resolve(simulatedGpsLocation);
        } else if (navigationCurrentLocation) {
            resolve(navigationCurrentLocation);
        } else if ('geolocation' in navigator) {
             getCurrentLocation( (coordsParam) => resolve(coordsParam), (errorMsg) => { resolve(null); } );
        } else {
            resolve(null);
        }
    }).then(async coords => {
        let allRemindersToCheck = [...currentReminders];
        const radaresRutaActivos = document.getElementById('radares-ruta-checkbox')?.checked;
        if (isNavigating && radaresRutaActivos && reminderMapObjects && reminderMapObjects.length > 0) {
            reminderMapObjects.forEach(mapObj => {
                if (mapObj.isFromRuta) {
                    const tempReminderFromMap = {
                        id: mapObj.reminderId, text: mapObj.marker.options.title || "RADAR RUTA", type: 'simple',
                        time: '00:00', date: new Date().toISOString().split('T')[0], createdAt: new Date().toISOString(),
                        managedByUser: false, isLocationEnabled: true,
                        locationCoordinates: { latitude: mapObj.marker.getLatLng().lat, longitude: mapObj.marker.getLatLng().lng },
                        radiusMeters: mapObj.circle ? mapObj.circle.getRadius() : 600,
                        excludeFromList: true, isFromRuta: true
                    };
                    allRemindersToCheck.push(tempReminderFromMap);
                }
            });
        }
        allRemindersToCheck.forEach(reminder => {
            if (!reminder || typeof reminder.id !== 'number' || typeof reminder.managedByUser === 'undefined' || !reminder.type || !reminder.time || !reminder.date || !reminder.createdAt) {
                if (!reminder.isFromRuta) storageNeedsUpdate = true;
                return;
            }
            if (processedIds.has(reminder.id)) {
                if (!reminder.isFromRuta) storageNeedsUpdate = true;
                return;
            }
            processedIds.add(reminder.id);
            if (reminder.isFromRuta && snoozedRouteRadars.has(reminder.id)) {
                const snoozeEndTime = snoozedRouteRadars.get(reminder.id);
                if (Date.now() < snoozeEndTime) { return; } else { snoozedRouteRadars.delete(reminder.id); }
            }
            const isManagedByUser = reminder.managedByUser === true; let keepInStorage = true; let isOverdue = false; let locationConditionMet = true;
            if (!isManagedByUser) {
                let reminderLocalDueTime = null; try { const [year, month, day] = reminder.date.split('-').map(Number); const [hour, minute] = reminder.time.split(':').map(Number); reminderLocalDueTime = new Date(year, month - 1, day, hour, minute);
                    if (isNaN(reminderLocalDueTime.getTime())) { throw new Error("Invalid date/time components"); }
                    if (reminderLocalDueTime <= now) {
                        isOverdue = true;
                        if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                            if (coords) {
                                const distance = calculateDistance( coords.latitude, coords.longitude, reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude );
                                locationConditionMet = distance <= (reminder.radiusMeters || DEFAULT_LOCATION_RADIUS);
                                if (locationConditionMet && distance < 1500) { isAnyReminderNearby = true; }
                            } else { locationConditionMet = false; }
                        }
                    } else if (reminder.isLocationEnabled && reminder.locationCoordinates && coords) {
                        const distance = calculateDistance( coords.latitude, coords.longitude, reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude );
                        if (distance < 1500) { isAnyReminderNearby = true; }
                    }
                } catch (error) {
                    if (!reminder.isFromRuta) storageNeedsUpdate = true;
                    keepInStorage = false; isOverdue = false; locationConditionMet = false;
                }
            }
             if (isOverdue && locationConditionMet) {
                overdueReminders.push(reminder);
                if (!isUnifiedWindowVisibleByLogic || !document.querySelector(`#unified-reminder-window .reminder-slide[data-id="${reminder.id}"]`)) {
                    newOverdueFound = true;
                }
            }
            if (keepInStorage && !reminder.isFromRuta) { validRemindersForStorage.push(reminder); }
        });
        if (storageNeedsUpdate) { try { const oldStorageString = localStorage.getItem('reminders') || '[]'; const newStorageString = JSON.stringify(validRemindersForStorage); if (oldStorageString !== newStorageString) { localStorage.setItem('reminders', newStorageString); } } catch (e) { showToast("Error al actualizar recordatorios tras limpieza.", "error", 5000); } }
        let shouldDisplayWindow = false;
        if (overdueReminders.length > 0) {
            if (!isUnifiedWindowVisibleByLogic || newOverdueFound) {
                shouldDisplayWindow = true;
                currentNotificationSlideIndex = 0;
                if (newOverdueFound) showYellowBorder();
            } else {
                const currentDisplayedIds = Array.from(document.querySelectorAll('#unified-reminder-window .reminder-slide')).map(el => parseInt(el.dataset.id));
                const newOverdueIds = overdueReminders.map(r => r.id);
                if (currentDisplayedIds.length !== newOverdueIds.length || !currentDisplayedIds.every(id => newOverdueIds.includes(id))) {
                    shouldDisplayWindow = true;
                }
            }
        }
        if (shouldDisplayWindow) {
             displayUnifiedReminderWindow(overdueReminders);
        } else if (overdueReminders.length === 0 && isUnifiedWindowVisibleByLogic) {
             hideUnifiedReminderWindow();
             currentNotificationSlideIndex = 0;
        }
        if (isNavigating && navigationCurrentLocation && !isRecalculatingRoute && !isDeviationModalActive && !isAddReminderAtLocationModeActive) {
            const currentCoords = navigationCurrentLocation;
            if (navigationMapInstance && navigationRouteLayer && navigationRouteLayer.getLatLngs().length > 0 && typeof L.GeometryUtil !== 'undefined' && L.GeometryUtil.closestLayerSnap) {
                const closestPointInfo = L.GeometryUtil.closestLayerSnap(navigationMapInstance, [navigationRouteLayer], L.latLng(currentCoords.latitude, currentCoords.longitude), DEVIATION_THRESHOLD_METERS * 2 , false);
                if (closestPointInfo) {
                    const distanceToRoute = closestPointInfo.distance;
                    if (distanceToRoute > DEVIATION_THRESHOLD_METERS) {
                        if (deviationStartTime === 0) {
                            deviationStartTime = Date.now();
                        } else if ((Date.now() - deviationStartTime) / 1000 > DEVIATION_MIN_TIME_SECONDS) {
                            showDeviationModal();
                            deviationStartTime = 0;
                        }
                    } else { deviationStartTime = 0; }
                } else {
                    if (deviationStartTime === 0) {
                         deviationStartTime = Date.now();
                    } else if ((Date.now() - deviationStartTime) / 1000 > DEVIATION_MIN_TIME_SECONDS) {
                         showDeviationModal();
                         deviationStartTime = 0;
                    }
                }
            }
        } else {
            deviationStartTime = 0;
        }
        updateReminderCount(); updateButtonStyles();
        let newInterval = isNavigating ? 1000 : 3000;
        if (isNavigating) {
            const distToNextManeuver = distanceToNextManeuverOSRM || Infinity;
             if (distToNextManeuver < 500 && distToNextManeuver > 0) {
                newInterval = 1000;
            } else if (distToNextManeuver < 1000 && distToNextManeuver > 0) {
                newInterval = 1500;
            } else {
                newInterval = 3000;
            }
        } else if (isAnyReminderNearby) {
             newInterval = 5000;
        }
        const unifiedWindowCurrentlyVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible');
        if (unifiedWindowCurrentlyVisible && (isNavigationMapActive)) {
            newInterval = Math.min(newInterval, 5000);
        }
        if (newInterval !== currentCheckIntervalDuration) {
            currentCheckIntervalDuration = newInterval;
            if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
            reminderCheckIntervalId = setInterval(checkReminders, currentCheckIntervalDuration);
        }
        const swiperContainer = document.getElementById('reminder-swiper-container');
        const windowElement = document.getElementById('unified-reminder-window');
        if (swiperContainer && overdueReminders.length > 0 && windowElement.classList.contains('visible') && newInterval !== 1000 && newInterval !== 5000) {
            const totalSlides = overdueReminders.length; let nextSlideIndex = currentNotificationSlideIndex;
            if (totalSlides > 1) { nextSlideIndex = (currentNotificationSlideIndex + 1) % totalSlides; } else { nextSlideIndex = 0; }
            if (totalSlides === 1 || nextSlideIndex !== currentNotificationSlideIndex) { currentNotificationSlideIndex = nextSlideIndex; const targetScrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth; swiperContainer.scrollTo({ left: targetScrollLeft, behavior: 'smooth' }); setTimeout(updateReminderIndexDisplay, 400); }
        }
        const { isMobile, primaryId } = parseUserId(localStorage.getItem('userData_userId'));
        if (isMobile) {
            const localTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');
            const backupPassword = localStorage.getItem('userData_backupPassword');
            if (backupPassword && localTimestamp > lastMobileSyncTimestamp) {
                autoSaveFromMobile(primaryId, backupPassword);
            }
        }
    });
}




    

    
    
// ===================================================================
// NOMBRE: showDeviationModal
// RESUMEN: Muestra un modal cuando se detecta un desvío de la ruta.
// ===================================================================
function showDeviationModal() {
    closeOtherModals('deviation-modal');
    isDeviationModalActive = true;
    let modal = document.getElementById('deviation-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'deviation-modal';
        document.body.appendChild(modal);
    }

    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    const unvisitedSelectableStages = actualWaypoints.filter(wp => !wp.visited && wp.type !== 'S' && wp.type !== 'S_Recalc' && wp.type !== 'F');

    const iconHtml = `<img src="APELIGRO.png" alt="Icono de Peligro" style="width: 115px; height: 70px; margin: 0 auto 10px auto; display: block;">`;

    if (unvisitedSelectableStages.length === 0 && actualWaypoints.length <= 2) {
        modal.innerHTML = `
            <style>
                #deviation-modal {
                    position: fixed; top: 10px; left: 10px; transform: none; max-width: 480px; width: calc(100% - 20px);
                    background-color: #E6D6A8; padding: 20px; border-radius: 10px; box-shadow: 0 0 15px rgba(0,0,0,0.5); z-index: 9000; text-align: center;
                    display: flex;
                    flex-direction: column;
                    max-height: 85vh;
                }
                #deviation-modal h2 { font-size: 1.5rem; margin-bottom: 10px; color: #333; flex-shrink: 0; }
                #deviation-modal p { font-size: 1.1rem; line-height: 1.4; margin-bottom: 15px; flex-shrink: 0; font-weight: bold; } /* Texto en negrita */
                #deviation-modal button { 
                    padding: 12px 15px; border: none; border-radius: 5px; font-size: 1.1rem; font-weight: bold; cursor: pointer; transition: background-color 0.2s ease;
                    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
                    flex-shrink: 0;
                }
                #deviation-modal #deviation-accept-simple { background-color: #28a745; color: white; }
            </style>
            <h2>Desvío Detectado</h2>
            ${iconHtml}
            <p id="deviation-modal-message">Se ha detectado un desvío de ruta.</p>
            <div class="modal-top-buttons" style="justify-content: center;">
                <button id="deviation-accept-simple">Aceptar <span class="button-countdown-timer"></span></button>
            </div>
        `;
        modal.classList.remove('hidden');
        const acceptButton = modal.querySelector('#deviation-accept-simple');
        acceptButton.addEventListener('click', (e) => {
            e.stopPropagation();
            closeModalAndProceed();
        });
        addModalAutoCloseTimer(modal, acceptButton, 'deviation-modal', 3000);
        recalculateAndDrawRoute(true);
        return;
    }

    const finalDestination = actualWaypoints[actualWaypoints.length - 1];
    const stageButtonsHtml = unvisitedSelectableStages.map(wp => {
        const addressSummary = wp.address ? (wp.address.split(',')[0].trim()) : `Etapa ${wp.label}`;
        return `<button class="deviation-stage-button" data-waypoint-id="${wp.id}">ETAPA ${wp.label}: ${addressSummary}</button>`;
    }).join('');

    modal.innerHTML = `
        <style>
            #deviation-modal {
                position: fixed; top: 10px; left: 10px; transform: none; max-width: 480px; width: calc(100% - 20px);
                background-color: #E6D6A8; padding: 20px; border-radius: 10px; box-shadow: 0 0 15px rgba(0,0,0,0.5); z-index: 9000; text-align: center;
                display: flex;
                flex-direction: column;
                max-height: 85vh;
            }
            #deviation-modal h2 { font-size: 1.5rem; margin-bottom: 10px; color: #333; flex-shrink: 0; }
            #deviation-modal p { font-size: 1rem; line-height: 1.4; margin-bottom: 15px; flex-shrink: 0; font-weight: bold; } /* Texto en negrita */
            #deviation-modal .deviation-options-container {
                display: flex;
                flex-direction: column;
                flex-grow: 1;
                overflow: hidden;
            }
            #deviation-modal .stage-list-scroll-container {
                overflow-y: auto;
                display: flex;
                flex-direction: column;
                gap: 10px;
                padding: 10px;
                margin: 5px 0;
                border-top: 2px solid #C0B080;
                border-bottom: 2px solid #C0B080;
                background-color: black;
                border-radius: 6px;
            }
            #deviation-modal #scroll-hint-text {
                font-size: 0.85rem;
                font-style: italic;
                color: #555;
                margin-top: 5px;
                margin-bottom: -5px;
                display: none;
            }
            #deviation-modal button { 
                padding: 12px 15px; border: none; border-radius: 5px; font-size: 1.1rem; font-weight: bold; cursor: pointer; transition: background-color 0.2s ease;
                white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
                flex-shrink: 0;
            }
            #deviation-modal #deviation-go-to-final { background-color: #28a745; color: white; margin-bottom: 5px; }
            #deviation-modal .deviation-stage-button { background-color: #007bff; color: white; }
            #deviation-modal #deviation-cancel { background-color: #6c757d; color: white; margin-top: 5px; }
        </style>
        <h2>Desvío Detectado</h2>
        ${iconHtml}
        <p>Elige tu próximo destino. <strong>Nota:</strong> Al seleccionar una etapa, las anteriores se marcarán como visitadas y se omitirán.</p>
        <div class="deviation-options-container">
            <button id="deviation-go-to-final">Ir a Destino Final (${finalDestination.address.split(',')[0].trim()})</button>
            <p id="scroll-hint-text"></p>
            <div class="stage-list-scroll-container">
                ${stageButtonsHtml}
            </div>
            <button id="deviation-cancel">Cancelar (Seguir Desviado)</button>
        </div>
    `;
    modal.classList.remove('hidden');
    const scrollContainer = modal.querySelector('.stage-list-scroll-container');
    const scrollHint = modal.querySelector('#scroll-hint-text');
    if (scrollContainer && scrollHint) {
        requestAnimationFrame(() => {
            if (scrollContainer.scrollHeight > scrollContainer.clientHeight) {
                const stageCount = scrollContainer.querySelectorAll('.deviation-stage-button').length;
                scrollHint.textContent = `Hay ${stageCount} etapas sin visitar (deslice para verlas todas y seleccione)`;
                scrollHint.style.display = 'block';
            }
        });
    }
    document.getElementById('deviation-go-to-final').addEventListener('click', (e) => {
        e.stopPropagation();
        handleFinalDestinationSelection();
    });
    document.querySelectorAll('.deviation-stage-button').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const waypointId = parseInt(e.currentTarget.dataset.waypointId);
            handleStageSelectionFromDeviationModal(waypointId);
        });
    });
    document.getElementById('deviation-cancel').addEventListener('click', (e) => {
        e.stopPropagation();
        isDeviationModalActive = false;
        deviationStartTime = 0;
        modal.classList.add('hidden');
    });
    addModalAutoCloseTimer(modal, document.getElementById('deviation-go-to-final'), 'deviation-modal', 30000);
}    
    
    
    
    





    


    


    

    
    
    

// ===================================================================
// NOMBRE: showLoadRouteModal
// RESUMEN: Muestra el modal para cargar o borrar rutas guardadas.
// ===================================================================
function showLoadRouteModal() {
    clearAllWaypointMarkersFromMap();
    if (navigationMapInstance) {
        if (navigationRouteLayer) navigationMapInstance.removeLayer(navigationRouteLayer);
        if (completedRouteSegmentsLayer) completedRouteSegmentsLayer.clearLayers();
    }
    navigationWaypoints = [];
    navigationRouteLayer = null;
    navigationCurrentRouteData = null;
    isNavigating = false;
    lastValidCarDistanceForDisplay = 0;
    tripInitialOverallEtaTime = null; currentStageInitialExpectedEtaTime = null; accumulatedDeviationMs = 0;
    accumulatedDistanceBeforeCurrentSegment = 0;
    totalDistanceTravelledForStats = 0;
    maxSpeedDuringTrip = 0; maxAltitudeDuringTrip = -Infinity; minAltitudeDuringTrip = Infinity;


    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    hideNavigationUI();
    hideMapInfoOverlay();

    eliminarRadaresDeRuta();
    actualizarContadorRadares(0);
    eliminarTareasDeBarraProgreso();
    actualizarContadorTareas(0);


    const existingModal = document.getElementById('saved-routes-modal');
    if (existingModal) existingModal.remove();

    const modal = document.createElement('div');
    modal.id = 'saved-routes-modal';
    modal.innerHTML = `
        <h2>Cargar/Borrar Rutas Guardadas (Máx. ${MAX_SAVED_ROUTES})</h2>
        <div class="modal-top-buttons" style="justify-content: flex-end;">
             <button id="close-saved-routes-modal" style="flex: 0 1 auto; min-width: 120px;">Cerrar</button>
        </div>
        <div class="filter-container">
            <input type="text" id="filter-saved-routes" placeholder="FILTRAR RUTAS...">
            <button id="clear-filter-saved-routes" title="Limpiar filtro">X</button>
        </div>
        <ul id="saved-routes-list"></ul>
    `;
    document.body.appendChild(modal);

    const listElement = modal.querySelector('#saved-routes-list');
    const closeButton = modal.querySelector('#close-saved-routes-modal');
    const filterInput = modal.querySelector('#filter-saved-routes');
    const clearFilterButton = modal.querySelector('#clear-filter-saved-routes');

    if(closeButton){
        closeButton.style.backgroundColor = '#4A5568';
        closeButton.style.color = 'white';
        closeButton.style.border = '1px solid #2D3748';
        closeButton.style.fontWeight = 'bold';
        closeButton.onmouseover = () => closeButton.style.backgroundColor = '#2D3748';
        closeButton.onmouseout = () => closeButton.style.backgroundColor = '#4A5568';
    }


    let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
    savedRoutes.sort((a,b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

    function displayRoutes(routesToDisplay) {
        listElement.innerHTML = '';
        if (routesToDisplay.length === 0) {
            listElement.innerHTML = '<li>No hay rutas que coincidan con el filtro.</li>';
        } else {
            routesToDisplay.forEach(route => {
                const li = document.createElement('li');
                li.textContent = route.name;
                li.dataset.routeName = route.name;

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Borrar';
                deleteBtn.className = 'delete-route-btn';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    let currentSavedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
                    currentSavedRoutes = currentSavedRoutes.filter(r => r.name !== route.name);
                    localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(currentSavedRoutes));
                    savedRoutes = currentSavedRoutes;
                    filterRoutes();
                    markCacheAsDirty()
                    showToast(`Ruta "${route.name}" borrada`, "info");
                };
                li.appendChild(deleteBtn);

                li.addEventListener('click', () => {
                    loadRouteByName(route.name, true);
                    clearModalAutoCloseTimer(modal, closeButton, 'saved-routes-modal');
                    if (modal.parentNode) modal.remove();
                });
                listElement.appendChild(li);
            });
        }
    }

    function filterRoutes() {
        const filterText = filterInput.value.toUpperCase().trim();
        if (!filterText) {
            displayRoutes(savedRoutes);
            clearFilterButton.style.display = 'none';
            return;
        }
        clearFilterButton.style.display = 'inline-block';
        const filtered = savedRoutes.filter(route => route.name.toUpperCase().includes(filterText));
        displayRoutes(filtered);
    }

    filterInput.addEventListener('input', filterRoutes);
    clearFilterButton.addEventListener('click', () => {
        filterInput.value = '';
        filterRoutes();
    });
    filterRoutes();

    const closeHandler = () => {
        clearModalAutoCloseTimer(modal, closeButton, 'saved-routes-modal');
        if (modal.parentNode) modal.remove();
    };
    closeButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(modal, closeButton, 'saved-routes-modal', 30000);
}


    

    
    
    
    


// ===================================================================
// NOMBRE: toggleNavigationState (MODIFICADA)
// RESUMEN: Inicia o detiene el modo de navegación, implementando la lógica de "inicio de viaje diferido".
// ===================================================================
function toggleNavigationState(isRecalculationStop = false) {
    const startNavButton = document.getElementById('start-navigation-button');
    const startNavImg = startNavButton ? startNavButton.querySelector('img') : null;
    const mapContainer = document.getElementById('reminders-location-map-div');

    if (isNavigating) {
        // --- Lógica para DETENER la navegación ---
        isNavigating = false;
        navigationFollowUser = false;
        tripStartLocationForStats = null; // Limpiar la ubicación de inicio
        if(startNavImg) startNavImg.src = "INICIARNAVEGACION.PNG";
        if(startNavButton) startNavButton.classList.remove('navigating');
        if (mapContainer) mapContainer.classList.remove('navigating');
        setNavigationMapClickHandler();
        navigationWaypoints.forEach(wp => { if (wp && wp.marker && wp.marker.dragging) wp.marker.dragging.enable(); });
        showToast("Navegación finalizada", "info", 3000);
        if (!isRecalculationStop && !isArrivalSequenceStarted) {
            if (!document.getElementById('arrival-stats-modal') || document.getElementById('arrival-stats-modal').classList.contains('hidden')) {
                showArrivalStatsModal();
            }
        }
        mapHeaderButtonsVisible = true; 
        toggleMapHeaderRowsVisibility(true); 
        if (locationWatchId !== null) {
            navigator.geolocation.clearWatch(locationWatchId);
            locationWatchId = null;
        }
        if (gpsRetryTimeoutId) {
            clearTimeout(gpsRetryTimeoutId);
            gpsRetryTimeoutId = null;
        }
        gpsRetryAttempt = 0;
    } else {
        // --- Lógica para INICIAR la navegación ---
        if (!navigationCurrentRouteData || !navigationCurrentRouteData.routes || navigationCurrentRouteData.routes.length === 0 || navigationWaypoints.filter(wp => !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
            showToast("No hay ruta calculada para iniciar la navegación", "warning");
            return;
        }
        clearNavigationGraph();
        if(startNavImg) startNavImg.src = "TERMINARNAVEGACION.PNG";
        showToast("Iniciando GPS para comenzar navegación...", "info", 0, false, "gps-init-toast");
        navigationWaypoints.forEach(wp => {
            if(wp) {
                if (wp.type === 'S' || wp.type === 'S_Recalc') {
                    wp.visited = true; 
                } else {
                    wp.visited = false; 
                }
                if (wp.marker && wp.marker.dragging) wp.marker.dragging.disable();
            }
        });
        renderWaypointMarkers();
        getCurrentLocation(
            (initialCoords) => {
                navigationCurrentLocation = initialCoords;
                updateInitialUserPosition(initialCoords, navigationMapInstance);
            },
            (errorMsg) => {
                showToast(`No se pudo obtener tu ubicación inicial: ${errorMsg}. El mapa se centrará cuando el GPS esté listo.`, "warning", 5000);
            }
        );
        startGpsWatching();
        const loadingToast = document.getElementById("gps-init-toast");
        if (loadingToast) loadingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== "gps-init-toast");
        isNavigating = true;
        shouldCenterOnUser = true; 
        navigationFollowUser = true; 
        const locateMeButton = document.getElementById('locate-me-on-reminders-map');
        const locateMeImg = locateMeButton ? locateMeButton.querySelector('img') : null;
        if(locateMeImg) locateMeImg.src = "DEJARSEGUIR.PNG";
        if(locateMeButton) locateMeButton.title = "Dejar de centrar el mapa automáticamente en mi posición";
        if (navigationMapInstance && navigationCurrentLocation) {
            const mapSize = navigationMapInstance.getSize();
            const progressBar = document.getElementById('navigation-bottom-progress-bar');
            let progressBarHeight = 0;
            if (progressBar && progressBar.offsetParent !== null && progressBar.style.display !== 'none') {
                progressBarHeight = progressBar.offsetHeight;
            }
            const offsetFactor = 0.25; 
            const minMapDimension = Math.min(mapSize.x, mapSize.y);
            const offsetDistance = minMapDimension * offsetFactor;
            const effectiveHeading = (navigationCurrentLocation && typeof navigationCurrentLocation.heading === 'number' && navigationCurrentLocation.heading !== null) ? navigationCurrentLocation.heading : (currentMapBearing || 0);
            const headingRad = (effectiveHeading % 360) * Math.PI / 180;
            let calculatedInitialMapCenterOffset = { x: 0, y: 0 };
            calculatedInitialMapCenterOffset.x = -offsetDistance * Math.sin(headingRad);
            calculatedInitialMapCenterOffset.y = offsetDistance * Math.cos(headingRad);
            const isGoingNorth = (effectiveHeading <= 60 || effectiveHeading >= 300);
            const isGoingSouth = effectiveHeading > 120 && effectiveHeading < 240;
            if (progressBarHeight > 0) { 
                if (isGoingNorth) {
                    calculatedInitialMapCenterOffset.y -= progressBarHeight * 1.4; 
                } else if (isGoingSouth) {
                    calculatedInitialMapCenterOffset.y += progressBarHeight * 1.3; 
                }
            }
            const vehicleLatLng = L.latLng(navigationCurrentLocation.latitude, navigationCurrentLocation.longitude);
            const vehicleScreenPos = navigationMapInstance.project(vehicleLatLng);
            const idealInitialMapCenterScreenPos = L.point(
                vehicleScreenPos.x - calculatedInitialMapCenterOffset.x,
                vehicleScreenPos.y - calculatedInitialMapCenterOffset.y
            );
            const idealInitialMapCenterLatLng = navigationMapInstance.unproject(idealInitialMapCenterScreenPos);
            const targetZoom = Math.min(navigationMapInstance.getMaxZoom() || 19, 17); 
            navigationMapInstance.setView(idealInitialMapCenterLatLng, targetZoom, {
                animate: true,
                duration: 0.8,
                easeLinearity: 0.75
            });
            targetMapCenterOffset = { ...calculatedInitialMapCenterOffset };
        }
        mapHeaderButtonsVisible = false;
        toggleMapHeaderRowsVisibility(false);
        if(startNavButton) startNavButton.classList.add('navigating');
        if (mapContainer) mapContainer.classList.add('navigating');
        setNavigationMapClickHandler();

        // --- LÓGICA DE INICIO DIFERIDO ---
        // 1. Guardamos la ubicación de inicio, pero no la hora.
        tripStartLocationForStats = { ...navigationCurrentLocation };
        navigationStartTimeForStats = null; // Se pone a null para indicar que el viaje "real" no ha empezado.
        
        // 2. Reseteamos las demás estadísticas.
        totalDistanceTravelledForStats = 0;
        maxDistanceReachedOnRoute = 0; 
        maxSpeedDuringTrip = 0; 
        maxSpeedCoordinates = null; 
        maxAltitudeDuringTrip = -Infinity; 
        minAltitudeDuringTrip = Infinity; 
        lastPositionForStats = {...navigationCurrentLocation};
        tripInitialOverallEtaTime = null; 
        currentStageInitialExpectedEtaTime = null;
        accumulatedDeviationMs = 0;

        if (speedMilestoneLayer) speedMilestoneLayer.clearLayers();
        lastSpeedMilestone = 0;
        if (compassAndModeControl) {
            compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip); 
        }
        
        // El resto de la inicialización de la navegación
        navigationWaypoints.forEach(wp => { if (wp && wp.marker && wp.marker.dragging) wp.marker.dragging.disable(); });
        showToast("Navegación iniciada. Esperando movimiento...", "success");
        currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviación ETA';
        initializeNavigationGraph();
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        updateDirectionWarningCardsVisibility();
    } 
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    actualizarContadorRadares(radaresEnRutaActual.length);
    actualizarContadorTareas(tareasEnRutaActual.length);
    updateDirectionWarningCardsVisibility();
}

// ===================================================================
// NOMBRE: updateInitialUserPosition (MODIFICADA)
// RESUMEN: Actualiza el icono del coche y gestiona el auto-inicio y el inicio "real" del viaje.
// ===================================================================
function updateInitialUserPosition(coords, mapInstanceToUse) {
    if (!mapInstanceToUse || !coords || typeof coords.latitude !== 'number' || typeof coords.longitude !== 'number') {
        return;
    }
    const latLng = L.latLng(coords.latitude, coords.longitude);
    initialUserLocationMarkerLat = coords.latitude; initialUserLocationMarkerLng = coords.longitude;
    if (!initialUserLocationMarker) {
        initialUserLocationMarker = L.marker(latLng, { icon: vehicleIcon, zIndexOffset: 1000, interactive: false });
        if (mapInstanceToUse && mapInstanceToUse.getPane) { try { initialUserLocationMarker.addTo(mapInstanceToUse); } catch (e) { return; } } else { return; }
    } else { initialUserLocationMarker.setLatLng(latLng); }
    const currentHeading = (coords && typeof coords.heading === 'number' && coords.heading !== null) ? coords.heading : (currentMapBearing || 0);
    const vehicleWrapper = initialUserLocationMarker.getElement()?.querySelector('#vehicle-icon-wrapper');
    if (vehicleWrapper) { let iconRotationAngle = currentHeading - 90; vehicleWrapper.style.transform = `rotate(${iconRotationAngle}deg)`; }
    if (compassAndModeControl) {
        compassAndModeControl.updateOrientation(currentHeading); compassAndModeControl.updateAltitude(coords.altitude);
        if (window.lastPositionForSpeedCalc && typeof coords.latitude === 'number' && typeof coords.longitude === 'number' && typeof coords.speed === 'number' && coords.speed !== null) { const distM = calculateDistance(window.lastPositionForSpeedCalc.latitude, window.lastPositionForSpeedCalc.longitude, coords.latitude, coords.longitude); const timeS = (Date.now() - window.lastPositionForSpeedCalc.time) / 1000; if (timeS > 0 && distM >= 0) { let speedMs = coords.speed; if (typeof speedMs !== 'number' || speedMs === null || speedMs < 0) { speedMs = distM / timeS; } window.currentSpeedKmh = speedMs * 3.6; } else { window.currentSpeedKmh = 0; } } else { if (typeof coords.speed === 'number' && coords.speed !== null && coords.speed >= 0) { window.currentSpeedKmh = coords.speed * 3.6; } else { window.currentSpeedKmh = 0; } }
        window.lastPositionForSpeedCalc = { latitude: coords.latitude, longitude: coords.longitude, time: Date.now() };
        if (isNavigating || (isSimulatingGpsLocation && automatedSimulationIntervalId)) { if (window.currentSpeedKmh > maxSpeedDuringTrip) { maxSpeedDuringTrip = window.currentSpeedKmh; if (coords) { maxSpeedCoordinates = { lat: coords.latitude, lng: coords.longitude }; } } const currentSpeed = window.currentSpeedKmh; for (const milestone of SPEED_MILESTONES) { if (currentSpeed >= milestone && lastSpeedMilestone < milestone) { const milestoneIcon = L.divIcon({ className: 'speed-milestone-icon', html: `<div style="background-color: #007bff; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; border: 2px solid white; box-shadow: 0 0 4px black;">${milestone}</div>`, iconSize: [36, 36], iconAnchor: [18, 18] }); if (speedMilestoneLayer) { L.marker([coords.latitude, coords.longitude], { icon: milestoneIcon }).addTo(speedMilestoneLayer); } lastSpeedMilestone = milestone; break; } } if (currentSpeed < lastSpeedMilestone) { let newMilestone = 0; for (let i = SPEED_MILESTONES.length - 1; i >= 0; i--) { if (currentSpeed >= SPEED_MILESTONES[i]) { newMilestone = SPEED_MILESTONES[i]; break; } } lastSpeedMilestone = newMilestone; } if (coords.altitude !== null && !isNaN(coords.altitude)) { maxAltitudeDuringTrip = Math.max(maxAltitudeDuringTrip, coords.altitude); minAltitudeDuringTrip = Math.min(minAltitudeDuringTrip, coords.altitude); } }
        
        // --- LÓGICA DE VELOCIDAD MEDIA ---
        if (isNavigating && navigationStartTimeForStats && typeof totalDistanceTravelledForStats === 'number') {
            if (lastPositionForStats && coords) {
                const distanceIncrement = calculateDistance(lastPositionForStats.latitude, lastPositionForStats.longitude, coords.latitude, coords.longitude);
                if (distanceIncrement > 0 && distanceIncrement < 5000) {
                    totalDistanceTravelledForStats += distanceIncrement;
                }
            }
            lastPositionForStats = { ...coords };
            if (totalDistanceTravelledForStats > 300) {
                const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000;
                if (timeElapsedS > 0) {
                    const avgSpeedMs = totalDistanceTravelledForStats / timeElapsedS;
                    window.averageSpeedKmh = avgSpeedMs * 3.6;
                } else {
                    window.averageSpeedKmh = 0;
                }
            } else {
                 window.averageSpeedKmh = 0;
            }
        } else if (isSimulatingGpsLocation && automatedSimulationIntervalId && navigationStartTimeForStats && typeof simulatedDistanceAlongRoute === 'number') {
            const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000;
            if (timeElapsedS > 0 && simulatedDistanceAlongRoute > 50) { 
                const avgSpeedMs = simulatedDistanceAlongRoute / timeElapsedS;
                window.averageSpeedKmh = avgSpeedMs * 3.6;
            } else {
                window.averageSpeedKmh = 0;
            }
        } else {
            window.averageSpeedKmh = 0;
        }

        compassAndModeControl.updateCurrentSpeed(window.currentSpeedKmh);
        compassAndModeControl.updateAverageSpeed(window.averageSpeedKmh);
        compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip);
    }

    // --- LÓGICA DE AUTO-INICIO DE NAVEGACIÓN ---
    if (!isNavigating && navigationWaypoints.length >= 2) {
        const startWp = navigationWaypoints.find(wp => wp.type === 'S');
        const finalWp = navigationWaypoints.find(wp => wp.type === 'F');
        if (startWp && finalWp && !finalWp.visited) {
            const distanceFromStart = calculateDistance(coords.latitude, coords.longitude, startWp.lat, startWp.lng);
            if (distanceFromStart > 50) {
                showToast("Movimiento detectado. Iniciando navegación...", "info", 3000);
                toggleNavigationState(); 
            }
        }
    }

    // --- LÓGICA DE INICIO DE VIAJE "REAL" ---
    if (isNavigating && !navigationStartTimeForStats && tripStartLocationForStats) {
        const distanceFromTripStart = calculateDistance(
            coords.latitude, coords.longitude,
            tripStartLocationForStats.latitude, tripStartLocationForStats.longitude
        );
        if (distanceFromTripStart > 50) {
            navigationStartTimeForStats = new Date(); // ¡El viaje "real" empieza AHORA!
            totalDistanceTravelledForStats = 0; // Reiniciamos el contador de distancia
            lastPositionForStats = { ...coords };
            
            // Recalculamos los ETAs desde este punto
            const route = navigationCurrentRouteData.routes[0];
            const remainingDistance = Math.max(0, route.distance - lastCarDistanceAlongRouteForNavLogic);
            const remainingDuration = route.distance > 0 ? route.duration * (remainingDistance / route.distance) : 0;
            tripInitialOverallEtaTime = new Date(Date.now() + remainingDuration * 1000);

            if (route.legs && route.legs.length > 0) {
                const leg = route.legs[currentLegIndexNav];
                if (leg) {
                    const distanceIntoCurrentLeg = Math.max(0, lastCarDistanceAlongRouteForNavLogic - calculateDistanceToEndOfStep(route, currentLegIndexNav - 1, -1));
                    const remainingDistanceThisLeg = Math.max(0, leg.distance - distanceIntoCurrentLeg);
                    const remainingDurationThisLeg = leg.distance > 0 ? leg.duration * (remainingDistanceThisLeg / leg.distance) : 0;
                    currentStageInitialExpectedEtaTime = new Date(Date.now() + remainingDurationThisLeg * 1000);
                }
            }
            showToast("¡Viaje iniciado! Calculando ETA...", "success", 3000);
        }
    }
    
    // El resto de la función (lógica de seguimiento del mapa) no cambia
    const shouldFollow = shouldCenterOnUser || navigationFollowUser;
    if (shouldFollow && navigationMapInstance && !isFlying) {
        const finalZoom = navigationTargetZoom !== null ? navigationTargetZoom : navigationMapInstance.getZoom();
        const effectiveHeading = (coords && typeof coords.heading === 'number' && coords.heading !== null) ? coords.heading : (currentMapBearing || 0);
        const mapSize = mapInstanceToUse.getSize();
        const offsetFactor = 0.25;
        const minMapDimension = Math.min(mapSize.x, mapSize.y);
        const offsetDistance = minMapDimension * offsetFactor;
        const headingRad = (effectiveHeading % 360) * Math.PI / 180;
        targetMapCenterOffset = { x: -offsetDistance * Math.sin(headingRad), y: offsetDistance * Math.cos(headingRad) };
        const vehicleLatLng = L.latLng(coords.latitude, coords.longitude);
        const vehicleScreenPos = navigationMapInstance.project(vehicleLatLng);
        const idealMapCenterScreenPos = L.point(vehicleScreenPos.x - targetMapCenterOffset.x, vehicleScreenPos.y - targetMapCenterOffset.y);
        const idealMapCenterLatLng = navigationMapInstance.unproject(idealMapCenterScreenPos);
        if (currentSmoothedMapCenter === null) {
            currentSmoothedMapCenter = idealMapCenterLatLng;
        }
        const lerpFactor = 0.1;
        currentSmoothedMapCenter = L.latLng(
            currentSmoothedMapCenter.lat + (idealMapCenterLatLng.lat - currentSmoothedMapCenter.lat) * lerpFactor,
            currentSmoothedMapCenter.lng + (idealMapCenterLatLng.lng - currentSmoothedMapCenter.lng) * lerpFactor
        );
        const currentZoom = navigationMapInstance.getZoom();
        const zoomDifference = Math.abs(currentZoom - finalZoom);
        if (zoomDifference > 0.05 || currentSmoothedMapCenter.distanceTo(navigationMapInstance.getCenter()) > 1) {
            isFlying = true;
            navigationMapInstance.flyTo(currentSmoothedMapCenter, finalZoom, {
                animate: true,
                duration: 1.0,
                easeLinearity: 0.5
            });
            setTimeout(() => { isFlying = false; }, 1050);
        }
    } else {
        currentSmoothedMapCenter = null;
    }
    navigationTargetZoom = null;
    updateDirectionWarningCardsVisibility();
}



    

    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: smoothZoomAnimation
    // RESUMEN: Realiza una animación de zoom suave usando requestAnimationFrame.
    // ===================================================================
    function smoothZoomAnimation(startZoom, endZoom, duration = 1200) {
        if (isAnimatingZoom || !navigationMapInstance) return;
        isAnimatingZoom = true;
        const startTime = performance.now();
        function animate(currentTime) {
            const elapsedTime = currentTime - startTime;
            const progress = Math.min(elapsedTime / duration, 1);
            const currentZoom = startZoom + (endZoom - startZoom) * progress;
            let targetCenter = navigationMapInstance.getCenter();
            if (navigationCurrentLocation) {
                const vehicleLatLng = L.latLng(navigationCurrentLocation.latitude, navigationCurrentLocation.longitude);
                const vehicleScreenPos = navigationMapInstance.project(vehicleLatLng);
                const idealMapCenterScreenPos = L.point(
                    vehicleScreenPos.x - targetMapCenterOffset.x,
                    vehicleScreenPos.y - targetMapCenterOffset.y
                );
                targetCenter = navigationMapInstance.unproject(idealMapCenterScreenPos);
            }
            navigationMapInstance.setView(targetCenter, currentZoom, { animate: false });
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                isAnimatingZoom = false;
            }
        }
        requestAnimationFrame(animate);
    }
    
    
    
    





// ===================================================================
// NOMBRE: addModalAutoCloseTimer
// RESUMEN: Añade un temporizador de autocierre a un modal.
// ===================================================================
function addModalAutoCloseTimer(modalElement, closeButtonElement, modalId, duration = 60000) {
    if (!modalElement || !closeButtonElement || !modalId) {
        return;
    }
    modalElement.dataset.modalTimerId = modalId;
    clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId);
    let countdown = duration / 1000;
    const originalButtonText = closeButtonElement.textContent.split(' (')[0];
    const countdownSpanId = `modal-countdown-${modalId}`;
    let countdownSpan = closeButtonElement.querySelector(`.button-countdown-timer`);
    if (!countdownSpan) {
        countdownSpan = document.createElement('span');
        countdownSpan.className = 'button-countdown-timer';
        countdownSpan.style.marginLeft = '5px';
        countdownSpan.style.fontWeight = 'normal';
        closeButtonElement.appendChild(countdownSpan);
    }
    countdownSpan.textContent = ` (${countdown})`;
    const intervalId = setInterval(() => {
        countdown--;
        if (countdownSpan && document.body.contains(countdownSpan)) {
          countdownSpan.textContent = ` (${countdown})`;
        }
        if (countdown <= 0) {
            if (globalModalTimers[modalId]) {
                clearInterval(globalModalTimers[modalId].intervalId);
                delete globalModalTimers[modalId];
            }
            if (closeButtonElement && document.body.contains(closeButtonElement)) {
                closeButtonElement.click();
            } else if (modalElement && modalElement.parentNode) {
                 if (!STATIC_MODAL_IDS.includes(modalElement.id)) {
                    modalElement.parentNode.removeChild(modalElement);
                 } else {
                    modalElement.classList.add('hidden');
                 }
            }
        }
    }, 1000);
    const resetTimerHandler = () => {
        if (!globalModalTimers[modalId] || !globalModalTimers[modalId].intervalId) return;
        clearInterval(globalModalTimers[modalId].intervalId);
        countdown = duration / 1000;
        if (countdownSpan && document.body.contains(countdownSpan)) {
           countdownSpan.textContent = ` (${countdown})`;
        }
        const newIntervalId = setInterval(() => {
            countdown--;
            if (countdownSpan && document.body.contains(countdownSpan)) {
                countdownSpan.textContent = ` (${countdown})`;
            }
            if (countdown <= 0) {
                if (globalModalTimers[modalId]) {
                    clearInterval(globalModalTimers[modalId].intervalId);
                    delete globalModalTimers[modalId];
                }
                if (closeButtonElement && document.body.contains(closeButtonElement)) {
                    closeButtonElement.click();
                } else if (modalElement && modalElement.parentNode) {
                    if (!STATIC_MODAL_IDS.includes(modalElement.id)) {
                       modalElement.parentNode.removeChild(modalElement);
                    } else {
                       modalElement.classList.add('hidden');
                    }
                }
            }
        }, 1000);
        globalModalTimers[modalId].intervalId = newIntervalId;
    };
    modalElement.addEventListener('click', resetTimerHandler);
    modalElement.addEventListener('touchstart', resetTimerHandler, { passive: true });
    modalElement.addEventListener('input', resetTimerHandler);
    modalElement.addEventListener('scroll', resetTimerHandler, { passive: true });
    globalModalTimers[modalId] = {
        intervalId: intervalId,
        resetHandler: resetTimerHandler,
        modalElement: modalElement,
        closeButtonElement: closeButtonElement,
        countdownSpan: countdownSpan
    };
}


    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: proceedWithRecalculation
    // RESUMEN: Gestiona la lógica de recálculo de ruta según la acción del usuario.
    // ===================================================================
    async function proceedWithRecalculation(action) {
        if (!isNavigating || !navigationCurrentLocation) {
            showToast("No se puede recalcular: no se está navegando o la ubicación es desconocida.", "error");
            return;
        }
        if (action === 'skip_one') {
            const nextUnvisitedStageIndex = navigationWaypoints.findIndex(wp => wp && !wp.isInternal && !wp.isRecalculatedStart && !wp.visited && wp.type !== 'S' && wp.type !== 'S_Recalc');
            if (nextUnvisitedStageIndex !== -1) {
                navigationWaypoints[nextUnvisitedStageIndex].visited = true;
                showToast(`Omitiendo etapa: ${navigationWaypoints[nextUnvisitedStageIndex].address || 'Siguiente' }`, "info");
            } else {
                showToast("No hay próximas etapas para omitir. Recalculando a destino.", "info");
            }
        } else if (action === 'skip_multiple') {
            const stagesToSkip = [];
            const currentHeading = navigationCurrentLocation.heading;
            navigationWaypoints.forEach(wp => {
                if (wp.visited || wp.type === 'S' || wp.type === 'S_Recalc') return;
                const bearingToWp = turf.bearing(
                    turf.point([navigationCurrentLocation.longitude, navigationCurrentLocation.latitude]),
                    turf.point([wp.lng, wp.lat])
                );
                let angleDiff = Math.abs(currentHeading - (bearingToWp < 0 ? bearingToWp + 360 : bearingToWp));
                if (angleDiff > 180) angleDiff = 360 - angleDiff;
                if (angleDiff > 110) {
                    stagesToSkip.push(wp.id);
                }
            });
            if (stagesToSkip.length > 0) {
                navigationWaypoints.forEach(wp => {
                    if (stagesToSkip.includes(wp.id)) wp.visited = true;
                });
                showToast(`Saltando ${stagesToSkip.length} etapas que han quedado atrás.`, "info");
            }
        }
        await recalculateAndDrawRoute(true);
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: closeModalAndProceed
    // RESUMEN: Cierra el modal de desvío y ejecuta la acción de recálculo seleccionada.
    // ===================================================================
    function closeModalAndProceed(action) {
        if (deviationModalTimerId) {
            clearInterval(deviationModalTimerId);
            deviationModalTimerId = null;
        }
        const modal = document.getElementById('deviation-modal');
        if (modal) {
            const primaryButton = modal.querySelector('#deviation-primary') || modal.querySelector('button');
            clearModalAutoCloseTimer(modal, primaryButton, 'deviation-modal');
            modal.classList.add('hidden');
        }
        isDeviationModalActive = false;
        deviationStartTime = 0;
        proceedWithRecalculation(action);
    }
    
    
    
    



// ===================================================================
// NOMBRE: restoreBackup
// RESUMEN: Restaura los datos locales desde un código de backup manual.
// ===================================================================
function restoreBackup() {
    const restoreInput = document.getElementById('config-restore-input');
    const backupStringBase64 = restoreInput.value.trim();
    const statusEl = document.getElementById('config-restore-status');
    statusEl.textContent = '';
    if (!backupStringBase64) {
        statusEl.textContent = 'Pega el código de backup primero.';
        statusEl.style.color = '#EF4444';
        return;
    }
    try {
        const backupString = decodeURIComponent(escape(atob(backupStringBase64)));
        const backupData = JSON.parse(backupString);
        let restoredCount = 0;
        let incompatibleCount = 0;
        if (confirm('Esto sobreescribirá tus datos actuales con los del backup. ¿Estás seguro?')) {
            Object.keys(backupData).forEach(key => {
                if (managedKeys.includes(key)) {
                    localStorage.setItem(key, backupData[key]);
                    restoredCount++;
                } else {
                    incompatibleCount++;
                }
            });
            loadCustomData();
            loadSavedSettings();
            updateUserIdDisplay();
            checkReminders();
            statusEl.textContent = `Restauración completada. ${restoredCount} claves restauradas. ${incompatibleCount} claves ignoradas (incompatibles). La página se recargará.`;
            statusEl.style.color = '#28a745';
            showToast('Restauración completada. Recargando...', 'success');
            setTimeout(() => location.reload(), 2500);
        } else {
             statusEl.textContent = 'Restauración cancelada.';
             statusEl.style.color = '#6c757d';
        }
    } catch (e) {
        statusEl.textContent = 'Error: Código de backup inválido o corrupto.';
        statusEl.style.color = '#EF4444';
        showToast('Error en el código de backup', 'error');
    }
}





    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: clearNavigationGraph
    // RESUMEN: Limpia y oculta la gráfica de navegación.
    // ===================================================================
    function clearNavigationGraph() {
        if (graphIntervalTimer) {
            clearInterval(graphIntervalTimer);
            graphIntervalTimer = null;
        }
        if (navigationChart) {
            navigationChart.destroy();
            navigationChart = null;
        }
        const graphCard = document.getElementById('navigation-graph-card');
        if (graphCard) {
            graphCard.classList.add('hidden');
        }
        graphDataPoints = { speed: [], altitude: [] };
        graphLabels = [];
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: hideNavigationUI
    // RESUMEN: Oculta los elementos de la interfaz de usuario de navegación.
    // ===================================================================
    function hideNavigationUI() {
        const topInfoBar = document.getElementById('navigation-top-info-bar');
        const bottomProgressBar = document.getElementById('navigation-bottom-progress-bar');
        const startNavButton = document.getElementById('start-navigation-button');
        const saveRouteButton = document.getElementById('save-route-button');
        const reorderBtn = document.getElementById('reorder-route-stages-button');
        const simulateBtn = document.getElementById('simulate-route-button');
        const toggleSimulateGpsBtn = document.getElementById('toggle-simulate-gps-button');
        const graphCard = document.getElementById('navigation-graph-card');
        if (topInfoBar) topInfoBar.style.display = 'none';
        if (bottomProgressBar) bottomProgressBar.style.display = 'none';
        if (startNavButton) startNavButton.classList.add('hidden');
        if (saveRouteButton) saveRouteButton.classList.add('hidden');
        if (reorderBtn) reorderBtn.style.display = 'none';
        if (simulateBtn) simulateBtn.style.display = 'none';
        if (graphCard) graphCard.classList.add('hidden');
        if (toggleSimulateGpsBtn && isSimulatingGpsLocation) {
        } else if (toggleSimulateGpsBtn) {
            toggleSimulateGpsBtn.style.display = 'none';
        }
        hideIntersectionPreviewMap();
        updateDirectionWarningCardsVisibility();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showNavigationUIElementsForPlanning
    // RESUMEN: Muestra los elementos de la UI para la planificación de rutas.
    // ===================================================================
    function showNavigationUIElementsForPlanning() {
        const topInfoBar = document.getElementById('navigation-top-info-bar');
        const bottomProgressBar = document.getElementById('navigation-bottom-progress-bar');
        if (!navigationCurrentRouteData || !navigationCurrentRouteData.routes || navigationCurrentRouteData.routes.length === 0 || navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
            if (topInfoBar) topInfoBar.style.display = 'none';
            if (bottomProgressBar) bottomProgressBar.style.display = 'none';
            hideMapInfoOverlay();
            hideIntersectionPreviewMap();
        } else {
            if (topInfoBar) topInfoBar.style.display = 'flex';
            if (bottomProgressBar) bottomProgressBar.style.display = 'flex';
            let carDistAlongRoutePlan = 0;
            const currentCarPosForShowUI = navigationCurrentLocation;
            if (currentCarPosForShowUI && navigationMapInstance && navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
                try {
                    const carPointTurf = turf.point([currentCarPosForShowUI.longitude, currentCarPosForShowUI.latitude]);
                    const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                    const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                    const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                    carDistAlongRoutePlan = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                } catch(e){  }
             }
            updateTurnByTurnDisplay(navigationCurrentRouteData.routes[0], carDistAlongRoutePlan);
            showDestinationName();
        }
        updateDirectionWarningCardsVisibility();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getManeuverInstructionText
    // RESUMEN: Convierte una maniobra de OSRM en un texto legible.
    // ===================================================================
    function getManeuverInstructionText(maneuver) {
        if (!maneuver) return '';
        const type = maneuver.type || '';
        const modifier = maneuver.modifier || '';
        let exit = maneuver.exit;
        let key = `${type}-${modifier}`;
        let text = maneuverTexts[key];
        if (!text) {
            key = `${type}-`;
            text = maneuverTexts[key];
        }
        if (!text && type === 'turn' && !modifier) {
            text = maneuverTexts['turn-'] || type.replace(/-/g, ' ');
        } else if (!text) {
            text = type.replace(/-/g, ' ');
        }
        const roundaboutExitTypes = ['roundabout turn', 'exit roundabout', 'rotary', 'roundabout'];
        if (roundaboutExitTypes.includes(type) && typeof exit === 'number' && exit > 0) {
             const ordinals = ["", "primera", "segunda", "tercera", "cuarta", "quinta"];
             const ordinalText = (exit >= 1 && exit <= 5) ? ordinals[exit] : `${exit}ª`;
             text = `Sal en la rotonda en la ${ordinalText} salida`;
        }
        let baseText = text.charAt(0).toUpperCase() + text.slice(1);
        return baseText;
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: formatDeviation
    // RESUMEN: Formatea la desviación de tiempo ETA con signo y color.
    // ===================================================================
    function formatDeviation(milliseconds) {
        if (typeof milliseconds !== 'number' || isNaN(milliseconds)) {
            return '';
        }
        const totalSeconds = Math.round(Math.abs(milliseconds) / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const sign = milliseconds >= 0 ? '+' : '-';
        const colorClass = milliseconds >= 0 ? 'positive' : 'negative';
        const formattedTime = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        return `<span class="eta-deviation ${colorClass}">[${sign}${formattedTime}]</span>`;
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateRouteAndCarIconStyle
    // RESUMEN: Ajusta el estilo de la línea de ruta según la capa de mapa activa.
    // ===================================================================
    function updateRouteAndCarIconStyle() {
        if (!navigationMapInstance) return;
        let activeLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "satélite + calles";
        activeLayerName = activeLayerName.toLowerCase();
        if (!localStorage.getItem(ACTIVE_MAP_LAYER_KEY) && mapLayersControl && mapLayersControl._map && mapLayersControl._map._layers) {
            const layersArray = Object.values(mapLayersControl._map._layers);
            const baseLayerMapObject = layersArray.find(l => l._map && l.options && !l.options.pane && l.options.attribution);
            if (baseLayerMapObject) {
                const activeLayerEntry = mapLayersControl._layers.find(l => l.layer === baseLayerMapObject);
                 if (activeLayerEntry && activeLayerEntry.name) {
                    activeLayerName = activeLayerEntry.name.toLowerCase();
                }
            }
        }
        if (navigationRouteLayer) {
            const isSatelliteViewForRoute = activeLayerName.includes('satélite') || activeLayerName.includes('satellite');
            if (isSatelliteViewForRoute) {
                navigationRouteLayer.setStyle({ 
                    color: 'yellow', 
                    weight: 10,
                    opacity: 1.0 
                });
            } else {
                navigationRouteLayer.setStyle({ 
                    color: 'blue', 
                    weight: 10,
                    opacity: 0.5
                });
            }
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: parseCoordinateFilter
    // RESUMEN: Parsea y aplica un filtro de coordenadas (valor único o rango).
    // ===================================================================
    function parseCoordinateFilter(filterValue, coordinate) {
        if (!filterValue) return true;
        const parts = filterValue.trim().split(/\s+/).map(s => parseFloat(s.replace(',','.'))).filter(n => !isNaN(n));
        if (parts.length === 1) {
            return Math.abs(coordinate - parts[0]) < COORD_EPSILON;
        } else if (parts.length === 2) {
            const minVal = Math.min(parts[0], parts[1]);
            const maxVal = Math.max(parts[0], parts[1]);
            return coordinate >= minVal && coordinate <= maxVal;
        } else if (parts.length === 0 && filterValue.trim() !== "") {
            return false;
        }
        return true;
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: closeOtherModals
    // RESUMEN: Cierra todos los modales abiertos, excepto el especificado.
    // ===================================================================
    function closeOtherModals(modalToKeepOpenId = null) {
        STATIC_MODAL_IDS.forEach(id => {
            if (id === modalToKeepOpenId) return;
            const modal = document.getElementById(id);
            if (modal && !modal.classList.contains('hidden')) {
                if (id === 'reorder-stages-modal') {
                    const listElement = modal.querySelector('#sortable-stages-list');
                    if (listElement) {
                        listElement.removeEventListener('dragstart', handleDragStartReorder);
                        listElement.removeEventListener('dragend', handleDragEndReorder);
                        listElement.removeEventListener('dragover', handleDragOverReorder);
                        listElement.removeEventListener('touchstart', handleStageTouchStart);
                        listElement.removeEventListener('touchmove', handleStageTouchMove);
                        listElement.removeEventListener('touchend', handleStageTouchEnd);
                        listElement.removeEventListener('touchcancel', handleStageTouchEnd);
                    }
                    if (draggedStageLi) {
                        draggedStageLi.classList.remove('dragging');
                        draggedStageLi = null;
                    }
                    clearTimeout(stageScrollTimeout);
                    document.body.style.overflow = '';
                }
                 if (id === 'deviation-modal') {
                    if (deviationModalTimerId) clearInterval(deviationModalTimerId);
                    deviationModalTimerId = null;
                    isDeviationModalActive = false;
                }
                 if (id === 'arrival-stats-modal') {
                    const acceptButton = modal.querySelector('#arrival-stats-accept-button');
                    if (acceptButton) clearModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal');
                 }
                 if (id === 'simulation-speed-modal') {
                    const confirmBtn = modal.querySelector('#confirm-simulation-speed');
                    if(confirmBtn) clearModalAutoCloseTimer(modal, confirmBtn, 'simulation-speed-modal');
                 }
                modal.classList.add('hidden');
                const closeBtn = modal.querySelector('button[id^="close-"], button[id*="-close"], #cancel-postpone, #close-saved-routes-modal, #cancel-reorder-stages, #config-close-modal, #close-versions-modal, #pin-submit-button, #close-simulation-modal, #close-locations-preview, #close-address-suggestions-modal, #deviation-accept, #arrival-stats-accept-button, #cancel-simulation-speed');
                if (closeBtn) clearModalAutoCloseTimer(modal, closeBtn, id.replace(/-/g, '_') || `modal_timer_${Date.now()}`);
                 if (id === 'simulation-modal') {
                     if (simulationModalTimer) {
                         clearTimeout(simulationModalTimer);
                         simulationModalTimer = null;
                     }
                     hideIntersectionPreviewMap();
                 }
            }
        });
        document.querySelectorAll(
            '.choice-modal, .edit-modal, .edit-info-modal, .help-modal, .reminder-modal, .reminder-table-modal, #postpone-options-modal, .saved-locations-modal, #reminders-map-help-modal-instance'
        ).forEach(m => {
            if (m.id === modalToKeepOpenId) return;
            if (m.parentNode) {
                 const closeBtn = m.querySelector('button[id^="close-"], button[id*="-close"], #cancel-postpone');
                 if(closeBtn) clearModalAutoCloseTimer(m, closeBtn, m.id.replace(/-/g, '_') || `modal_timer_${Date.now()}`);
                 m.remove();
            }
        });
         if (modalToKeepOpenId !== 'unified-reminder-window') {
            hideUnifiedReminderWindow();
         }
    }
    
    
    
    
    
    
    
    // ===================================================================
// NOMBRE: showConfigModal
// RESUMEN: Muestra el modal de configuración principal, reseteando y gestionando la pestaña de normas.
// ===================================================================
function showConfigModal() {
    closeOtherModals('config-modal');
    const modal = document.getElementById('config-modal');
    if (!modal) return;

    // Lógica para forzar la aceptación de normas
    const termsAccepted = localStorage.getItem('termsAccepted_v1') === 'true';
    const tabButtons = modal.querySelectorAll('.config-tab-button');
    const tabContents = modal.querySelectorAll('.config-tab-content');

    if (!termsAccepted) {
        // Forzar la vista de la pestaña de normas
        tabButtons.forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.tabTarget !== '#tab-content-normas') {
                btn.disabled = true; // Deshabilitar otras pestañas
                btn.style.cursor = 'not-allowed';
                btn.style.opacity = '0.5';
            }
        });
        tabContents.forEach(content => content.classList.remove('active'));
        
        modal.querySelector('.config-tab-button[data-tab-target="#tab-content-normas"]').classList.add('active');
        modal.querySelector('#tab-content-normas').classList.add('active');
    } else {
        // Comportamiento normal: mostrar la primera pestaña y habilitar todas
        tabButtons.forEach(btn => {
            btn.disabled = false;
            btn.style.cursor = 'pointer';
            btn.style.opacity = '1';
            btn.classList.toggle('active', btn.dataset.tabTarget === '#tab-content-usuario');
        });
        tabContents.forEach(content => {
            content.classList.toggle('active', content.id === 'tab-content-usuario');
        });
    }

    // Resetear campos y mensajes
    modal.querySelectorAll('.status-message').forEach(msg => msg.textContent = '');
    modal.querySelectorAll('input[type="text"], input[type="number"], textarea').forEach(input => {
        if (!['user-id', 'config-pin-set', 'config-pin-confirm'].includes(input.id)) {
            input.value = '';
        }
    });
    modal.querySelector('#config-pin-set').value = '';
    modal.querySelector('#config-pin-confirm').value = '';
    modal.querySelector('#config-backup-display').value = '';
    modal.querySelector('#config-restore-input').value = '';
    if(modal.querySelector('#config-backup-display')) modal.querySelector('#config-backup-display').style.display = 'none';

    // Cargar datos guardados en los campos
    const userIdInput = modal.querySelector('#user-id');
    const storedUserId = localStorage.getItem('userData_userId');
    if (userIdInput) userIdInput.value = storedUserId || '';
    
    const teslaModelInput = modal.querySelector('#tesla-model');
    if (teslaModelInput) teslaModelInput.value = localStorage.getItem('userData_teslaModel') || '';
    const teslaYearInput = modal.querySelector('#tesla-year');
    if (teslaYearInput) teslaYearInput.value = localStorage.getItem('userData_teslaYear') || '';
    const teslaProvinceInput = modal.querySelector('#tesla-province');
    if (teslaProvinceInput) teslaProvinceInput.value = localStorage.getItem('userData_teslaProvince') || '';
    const allowDmsCheckbox = modal.querySelector('#allow-dms');
    if (allowDmsCheckbox) allowDmsCheckbox.checked = JSON.parse(localStorage.getItem('userData_allowDMs')) || false;
    
    const directToNavCheckbox = document.getElementById('config-direct-to-nav');
    if (directToNavCheckbox) directToNavCheckbox.checked = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;

    const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
    if (autoBackupCheckbox) {
        const savedAutoBackup = localStorage.getItem('boardinggate_autoBackupOnLoad');
        autoBackupCheckbox.checked = savedAutoBackup === null ? true : JSON.parse(savedAutoBackup);
    }

    modal.classList.remove('hidden');
    const closeButtonConfig = modal.querySelector('#config-close-modal');
    addModalAutoCloseTimer(modal, closeButtonConfig, 'config-modal', 120000);
}
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: loadNotices
    // RESUMEN: Carga los avisos desde un archivo de texto externo.
    // ===================================================================
    async function loadNotices() { try { const r = await fetch('https://boardinggate.github.io/Tesla/avisos.txt', { cache: 'no-cache' }); if (!r.ok) throw new Error('Fetch failed'); const txt = await r.text(); notices = txt.split('\n').map(l => l.trim()).filter(l => l.length > 0); if (notices.length === 0) notices = ['No hay avisos.']; } catch (e) { notices = ['Error carga avisos.']; } updateNotice(); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateNotice
    // RESUMEN: Actualiza el texto del aviso visible en la pantalla.
    // ===================================================================
    function updateNotice() { const noticeElement = document.getElementById('current-notice'); if (!noticeElement || notices.length === 0) { return; } if (!isActive) { noticeElement.textContent = ''; noticeElement.style.animation = 'none'; return; } noticeElement.textContent = notices[currentNoticeIndex]; noticeElement.style.animation = 'none'; void noticeElement.offsetWidth; noticeElement.style.animation = 'fadeInOut 14s infinite'; currentNoticeIndex = (currentNoticeIndex + 1) % notices.length; }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleNotices
    // RESUMEN: Activa o desactiva la visualización de los avisos y el pie de página.
    // ===================================================================
    function toggleNotices() { isActive = !isActive; const nC = document.querySelector('.notices-container'); if (nC) nC.style.display = isActive ? 'flex' : 'none'; const fC = document.querySelector('footer'); if (fC) fC.classList.toggle('footer-hidden', !isActive); isFooterVisible = isActive; const nE = document.getElementById('current-notice'); if (nE) { if (!isActive) { nE.textContent = ''; nE.style.animation = 'none'; } else { currentNoticeIndex = 0; updateNotice(); } } saveSettings(); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: startNoticeRotation
    // RESUMEN: Inicia la rotación periódica de los avisos.
    // ===================================================================
    function startNoticeRotation() { if (notices.length === 0) return; if (isActive) updateNotice(); setInterval(updateNotice, 14000); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: adjustButtonPositions
    // RESUMEN: Ajusta dinámicamente la posición de los botones laterales fijos.
    // ===================================================================
    function adjustButtonPositions() { const scrollToggle = document.getElementById('scroll-toggle'); if (!scrollToggle) { return; }
    const scrollToggleHeight = scrollToggle.offsetHeight; const buttonHeight = 74; const buttonSpacing = 10; const startTop = scrollToggleHeight + 20; const fixedButtons = [ document.getElementById('on-off-toggle'), ...document.querySelectorAll('.range-toggle'), document.getElementById('weather-button'), document.getElementById('reminder-button'), document.getElementById('zoom-button'), document.getElementById('dark-mode-toggle') ].filter(button => button !== null).sort((a, b) => { const startA = parseInt(a.dataset.rangeStart) || Infinity; const startB = parseInt(b.dataset.rangeStart) || Infinity; if (a.id === 'on-off-toggle') return -1; if (b.id === 'on-off-toggle') return 1; if (isFinite(startA) && isFinite(startB)) return startA - startB; if (isFinite(startA)) return -1; if (isFinite(startB)) return 1; const order = ['weather-button', 'reminder-button', 'zoom-button', 'dark-mode-toggle']; return order.indexOf(a.id) - order.indexOf(b.id); }); if (fixedButtons.length < 6) { return; } let currentTop = startTop; fixedButtons.forEach((button) => { button.style.position = 'fixed'; button.style.top = `${currentTop}px`; button.style.left = '10px'; currentTop += buttonHeight + buttonSpacing; }); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: saveSettings
    // RESUMEN: Guarda la configuración actual de la UI en localStorage.
    // ===================================================================
    function saveSettings() {
        localStorage.setItem('darkMode', JSON.stringify(isDarkMode));
        const tS = {};
        document.querySelectorAll('.range-toggle').forEach(t => {
            const start = t.dataset.rangeStart;
            if (start) tS[start] = t.dataset.state;
        });
        localStorage.setItem('toggleStates', JSON.stringify(tS));
        const zoomButton = document.getElementById('zoom-button');
        if (zoomButton) localStorage.setItem('zoomState', zoomButton.dataset.zoomState);
        const onOffBtn = document.getElementById('on-off-toggle');
        if (onOffBtn) localStorage.setItem('onOffState', onOffBtn.dataset.state);
        localStorage.setItem('noticesActive', JSON.stringify(isActive));
        localStorage.setItem('footerVisible', JSON.stringify(isFooterVisible));
        localStorage.setItem('password_active', JSON.stringify(isPasswordActive));
        localStorage.setItem('lastUpdatesCheckDate', lastUpdatesCheckDate);
        localStorage.setItem(GRAPH_STATE_KEY, currentGraphMode);
        const radaresCheckboxElement = document.getElementById('radares-ruta-checkbox');
        if (radaresCheckboxElement) {
            localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckboxElement.checked));
        }
        const tareasCheckboxElement = document.getElementById('tareas-ruta-checkbox');
        if (tareasCheckboxElement) { 
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckboxElement.checked));
        }
        const mainSearchInputGrid = document.getElementById('main-search-input'); 
        if (mainSearchInputGrid) {
            localStorage.setItem('gridFilterValue', mainSearchInputGrid.value);
        }
        const mapFilterInput = document.getElementById('filter-input'); 
        if (mapFilterInput) {
            localStorage.setItem(MAP_FILTER_INPUT_KEY, mapFilterInput.value);
        }
        if (mapLayersControl && mapLayersControl._map && mapLayersControl._map._layers) {
            const layersArray = Object.values(mapLayersControl._map._layers);
            const baseLayerMapObject = layersArray.find(l => l._map && l.options && !l.options.pane && l.options.attribution);
            if (baseLayerMapObject) {
                const activeLayerEntry = mapLayersControl._layers.find(l => l.layer === baseLayerMapObject);
                if (activeLayerEntry && activeLayerEntry.name) {
                    localStorage.setItem(ACTIVE_MAP_LAYER_KEY, activeLayerEntry.name);
                }
            }
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: saveCustomData
    // RESUMEN: Guarda la personalización del grid y los toggles en localStorage, optimizando el espacio.
    // ===================================================================
    function saveCustomData() {
        try {
            if (customData.bookmarks) {
                Object.keys(customData.bookmarks).forEach(indexKey => {
                    const index = parseInt(indexKey);
                    const custom = customData.bookmarks[index];
                    const original = index < originalBookmarks.length ? originalBookmarks[index] : null;
                    const bookmarksAreEqual = (b1, b2) => {
                        if (b1 === null && b2 === null) return true;
                        if (b1 === null || b2 === null) return false;
                        return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null);
                    };
                    if (bookmarksAreEqual(custom, original)) {
                        delete customData.bookmarks[index];
                    }
                });
                if (Object.keys(customData.bookmarks).length === 0) {
                    delete customData.bookmarks;
                }
            }
            if (customData.toggles) {
                Object.keys(customData.toggles).forEach(startKey => {
                    const customToggle = customData.toggles[startKey];
                    const originalRange = originalToggleRanges.find(r => r.start == startKey);
                    if (customToggle && customToggle.assignedIndexes && originalRange) {
                        const originalDefaultIndexes = [];
                        for (let i = originalRange.start; i <= originalRange.end; i++) {
                            originalDefaultIndexes.push(i);
                        }
                        if (customToggle.assignedIndexes.length === originalDefaultIndexes.length &&
                            customToggle.assignedIndexes.every((val, idx) => val === originalDefaultIndexes[idx])) {
                            delete customToggle.assignedIndexes;
                        }
                    }
                    if (customToggle && originalRange && customToggle.label === originalRange.label) {
                        delete customToggle.label;
                    }
                    if (customData.toggles[startKey] && Object.keys(customData.toggles[startKey]).length === 0) {
                        delete customData.toggles[startKey];
                    }
                });
                if (Object.keys(customData.toggles).length === 0) {
                    delete customData.toggles;
                }
            }
            localStorage.setItem('customGridData', JSON.stringify(customData));
            markCacheAsDirty();
        } catch (e) {
            showToast("Error al guardar personalización", "error");
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: loadCustomData
    // RESUMEN: Carga los datos de personalización del grid desde localStorage.
    // ===================================================================
    function loadCustomData() { const savedData = localStorage.getItem('customGridData'); currentBookmarks = []; currentToggleRanges = []; customData = { bookmarks: {}, toggles: {} }; if (savedData) { try { customData = JSON.parse(savedData) || { bookmarks: {}, toggles: {} }; } catch (e) { customData = { bookmarks: {}, toggles: {} }; } } if (!customData.bookmarks) customData.bookmarks = {}; if (!customData.toggles) customData.toggles = {}; currentBookmarks = Array.from({ length: TOTAL_CELLS }).map((_, index) => { if (customData.bookmarks.hasOwnProperty(index)) { return customData.bookmarks[index] ? { ...customData.bookmarks[index] } : null; } else { const original = index < originalBookmarks.length ? originalBookmarks[index] : null; return original ? { ...original } : null; } }); currentToggleRanges = originalToggleRanges.map(originalRange => { const customToggle = customData.toggles[originalRange.start]; const rangeCopy = { ...originalRange }; if (customToggle) { if (typeof customToggle.label === 'string') rangeCopy.label = customToggle.label; if (Array.isArray(customToggle.assignedIndexes)) rangeCopy.assignedIndexes = [...customToggle.assignedIndexes]; } if (!rangeCopy.assignedIndexes) rangeCopy.assignedIndexes = Array.from({ length: rangeCopy.end - originalRange.start + 1 }, (_, i) => originalRange.start + i); return rangeCopy; }); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: loadSavedSettings
    // RESUMEN: Carga toda la configuración guardada desde localStorage.
    // ===================================================================
    function loadSavedSettings() {
        const savedDarkMode = localStorage.getItem('darkMode');
        isDarkMode = savedDarkMode ? JSON.parse(savedDarkMode) : false;
        if (isDarkMode) document.body.classList.add('dark-mode');
        const savedZoomState = localStorage.getItem('zoomState');
        const zoomButtonElem = document.getElementById('zoom-button');
        if (zoomButtonElem) {
            zoomButtonElem.dataset.zoomState = savedZoomState || 'off';
            applyZoom(zoomButtonElem.dataset.zoomState);
        }
        const savedPasswordActive = localStorage.getItem('password_active');
        isPasswordActive = savedPasswordActive ? JSON.parse(savedPasswordActive) : false;
        storedPin = localStorage.getItem('password_pin');
        lastUpdatesCheckDate = localStorage.getItem('lastUpdatesCheckDate');
        const savedNoticesActive = localStorage.getItem('noticesActive');
        const savedFooterVisible = localStorage.getItem('footerVisible');
        isActive = savedNoticesActive ? JSON.parse(savedNoticesActive) : true;
        isFooterVisible = savedFooterVisible ? JSON.parse(savedFooterVisible) : true;
        const noticeContainer = document.querySelector('.notices-container');
        if (noticeContainer) noticeContainer.style.display = isActive ? 'flex' : 'none';
        const footerElement = document.querySelector('footer');
        if (footerElement) footerElement.classList.toggle('footer-hidden', !isFooterVisible);
        const onOffBtn = document.getElementById('on-off-toggle');
        if (onOffBtn) {
            const savedOnOffState = localStorage.getItem('onOffState');
            onOffBtn.dataset.state = savedOnOffState ? savedOnOffState : 'on';
        }
        const toggleStatesFromCache = JSON.parse(localStorage.getItem('toggleStates') || '{}');
        document.querySelectorAll('.range-toggle').forEach(toggle => {
            const start = parseInt(toggle.dataset.rangeStart);
            const savedState = toggleStatesFromCache[start] || 'visible';
            toggle.dataset.state = savedState;
        });
        const mainSearchInputGrid = document.getElementById('main-search-input'); 
        if (mainSearchInputGrid) {
            const savedMainFilter = localStorage.getItem('gridFilterValue');
            if (savedMainFilter !== null) {
                mainSearchInputGrid.value = savedMainFilter;
            } else {
                mainSearchInputGrid.value = '';
            }
        }
        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox) {
            const savedCheckState = localStorage.getItem(RADARES_RUTA_CHECKED_KEY);
            radaresRutaCheckbox.checked = savedCheckState === 'true';
        }
        const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasRutaCheckbox) {
            const savedTareasCheckState = localStorage.getItem(TAREAS_RUTA_CHECKED_KEY);
            tareasRutaCheckbox.checked = savedTareasCheckState === 'true';
        }
        currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviación ETA';
        const userIdInput = document.getElementById('user-id');
        const modelInput = document.getElementById('tesla-model');
        const yearInput = document.getElementById('tesla-year');
        const provinceInput = document.getElementById('tesla-province');
        const dmsCheckbox = document.getElementById('allow-dms');
        const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
        if (userIdInput) userIdInput.value = localStorage.getItem('userData_userId') || '';
        if (modelInput) modelInput.value = localStorage.getItem('userData_teslaModel') || '';
        if (yearInput) yearInput.value = localStorage.getItem('userData_teslaYear') || '';
        if (provinceInput) provinceInput.value = localStorage.getItem('userData_teslaProvince') || '';
        if (dmsCheckbox) dmsCheckbox.checked = JSON.parse(localStorage.getItem('userData_allowDMs') || 'false');
        if (autoBackupCheckbox) {
            const savedAutoBackup = localStorage.getItem('boardinggate_autoBackupOnLoad');
            autoBackupCheckbox.checked = savedAutoBackup === null ? true : JSON.parse(savedAutoBackup);
        }
        actualizarContadorRadares(0);
        actualizarContadorTareas(0);
        updateUserIdDisplay();
        updateReminderCount();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: loadReminders
    // RESUMEN: Carga los recordatorios y actualiza el contador.
    // ===================================================================
    function loadReminders() { updateReminderCount(); }
    
    
    
    




// ===================================================================
// NOMBRE: actualizarContadorRadares
// RESUMEN: Actualiza el contador numérico de radares en la UI del mapa.
// ===================================================================
function actualizarContadorRadares(count) {
    const contadorElement = document.getElementById('radares-ruta-count');
    if (contadorElement) {
        contadorElement.textContent = count;
        const checkbox = document.getElementById('radares-ruta-checkbox');
        contadorElement.classList.toggle('hidden', count === 0 && (!checkbox || !checkbox.checked));
    }
}
    



// ===================================================================
// NOMBRE: actualizarContadorTareas
// RESUMEN: Actualiza el contador numérico de tareas en la UI del mapa.
// ===================================================================
function actualizarContadorTareas(count) {
    const contadorElement = document.getElementById('tareas-ruta-count');
    if (contadorElement) {
        contadorElement.textContent = count;
        const checkbox = document.getElementById('tareas-ruta-checkbox');
        contadorElement.classList.toggle('hidden', count === 0 && (!checkbox || !checkbox.checked));
    }
}    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateUserIdDisplay
    // RESUMEN: Muestra el ID de usuario en la pantalla si existe.
    // ===================================================================
    function updateUserIdDisplay() { const userIdDisplay = document.getElementById('user-id-display'); const userId = localStorage.getItem('userData_userId'); if (userIdDisplay) { if (userId) { userIdDisplay.textContent = userId.trim(); userIdDisplay.style.display = 'block'; } else { userIdDisplay.textContent = ''; userIdDisplay.style.display = 'none'; } } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: applyZoom
    // RESUMEN: Aplica el estado de zoom (acercado o alejado) al grid de marcadores.
    // ===================================================================
    function applyZoom(state) { const originalWidth = 984; const adjustedWidth = 935; const originalCols = 6; const zoomedCols = 4; const gap = 15; const zoomButton = document.getElementById('zoom-button'); if (state === 'on') { grid.style.gridTemplateColumns = `repeat(${zoomedCols}, 1fr)`; grid.style.gap = `${gap}px`; grid.style.maxWidth = `${adjustedWidth}px`; document.querySelectorAll('.bookmark-item img').forEach(i => { i.style.width = '48px'; i.style.maxWidth = '56px'; }); document.querySelectorAll('.bookmark-name').forEach(n => { n.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)'; }); document.querySelectorAll('.small-bookmark img').forEach(i => { i.style.width = '48px'; i.style.maxWidth = '56px'; }); document.querySelectorAll('.small-bookmark .bookmark-name').forEach(n => { n.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)'; }); if (zoomButton) zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/zoon+.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; } else { grid.style.gridTemplateColumns = `repeat(${originalCols}, minmax(120px, 1fr))`; grid.style.gap = `${gap}px`; grid.style.maxWidth = `${originalWidth}px`; document.querySelectorAll('.bookmark-item img').forEach(i => { i.style.width = '36px'; i.style.maxWidth = '40px'; }); document.querySelectorAll('.bookmark-name').forEach(n => { n.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)'; }); document.querySelectorAll('.small-bookmark img').forEach(i => { i.style.width = '24px'; i.style.maxWidth = '28px'; }); document.querySelectorAll('.small-bookmark .bookmark-name').forEach(n => { n.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)'; }); if (zoomButton) zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getSectionForIndex
    // RESUMEN: Devuelve la configuración de la sección a la que pertenece un índice del grid.
    // ===================================================================
    function getSectionForIndex(index) { return currentToggleRanges.find(range => range.assignedIndexes.includes(index)); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getColorForSection
    // RESUMEN: Obtiene el color de fondo para una sección, considerando el modo oscuro.
    // ===================================================================
    function getColorForSection(sectionStart, state = 'visible') { if (state === 'hidden') { return sectionColors.off; } if (isDarkMode) { return darkModeGenericButtonColor; } else { return sectionColors[sectionStart] || sectionColors.unassigned; } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateButtonStyles
    // RESUMEN: Actualiza los estilos visuales de todos los botones de la UI.
    // ===================================================================
    function updateButtonStyles() {
        const darkModeToggleElem = document.getElementById('dark-mode-toggle');
        const onOffToggleElem = document.getElementById('on-off-toggle');
        const rangeToggleButtonsElems = document.querySelectorAll('.toggle-sign.range-toggle');
        const reminderButtonElem = document.getElementById('reminder-button');
        if (onOffToggleElem) {
            onOffToggleElem.src = `https://boardinggate.github.io/Tesla/${onOffToggleElem.dataset.state === 'on' ? 'IMG_4192.jpg' : 'IMG_4191.jpg'}`;
            onOffToggleElem.alt = `Toggle ${onOffToggleElem.dataset.state === 'on' ? 'On' : 'Off'}`;
            onOffToggleElem.style.backgroundColor = sectionColors.off;
            if (isDarkMode) {
                onOffToggleElem.style.filter = 'brightness(85%)';
                 if (onOffToggleElem.dataset.state === 'on') {
                    onOffToggleElem.style.backgroundColor = darkModeGenericButtonColor;
                 }
            } else {
                onOffToggleElem.style.filter = '';
            }
        }
        if (darkModeToggleElem) {
            darkModeToggleElem.src = `https://boardinggate.github.io/Tesla/${isDarkMode ? 'oscuro2.png' : 'claro2.png'}`;
            darkModeToggleElem.alt = `Toggle ${isDarkMode ? 'Oscuro' : 'Claro'}`;
            darkModeToggleElem.style.backgroundColor = sectionColors.off;
            if (isDarkMode) darkModeToggleElem.style.filter = 'brightness(85%)'; else darkModeToggleElem.style.filter = '';
        }
        let reminders = [];
        try {
            reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        } catch(e) {
            reminders = [];
        }
        const showExcludedInTable = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
        let remindersForButtonStyleCount = reminders;
        if (!showExcludedInTable) {
            remindersForButtonStyleCount = reminders.filter(r => !r.excludeFromList);
        }
        const totalPendingCount = remindersForButtonStyleCount.length;
        if (reminderButtonElem) {
            reminderButtonElem.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4197.jpg" alt="Recordatorio" style="max-width: 70%; max-height: 70%; object-fit: contain;">${totalPendingCount > 0 ? `<span class="reminder-count">${totalPendingCount}</span>` : ''}`;
            reminderButtonElem.style.backgroundColor = sectionColors.off;
            if (isDarkMode) reminderButtonElem.style.filter = 'brightness(85%)'; else reminderButtonElem.style.filter = '';
        }
        rangeToggleButtonsElems.forEach(toggle => {
            const start = parseInt(toggle.dataset.rangeStart);
            const state = toggle.dataset.state || 'visible';
            const rangeConfig = currentToggleRanges.find(r => r.start === start);
            if (rangeConfig) {
                toggle.innerHTML = `<span class="sign">${state === 'visible' ? '-' : '+'}</span>${rangeConfig.label}`;
            }
            toggle.style.backgroundColor = getColorForSection(start, state);
            if (isDarkMode && state === 'visible') {
                toggle.style.filter = 'brightness(85%)';
            } else {
                toggle.style.filter = '';
            }
        });
        updatePasswordToggleIcon();
        const zoomButtonElem = document.getElementById('zoom-button');
        if (zoomButtonElem && zoomButtonElem.dataset.zoomState) {
            applyZoom(zoomButtonElem.dataset.zoomState);
        }
        if (cellElements && cellElements.length > 0) {
            cellElements.forEach((cell, index) => {
                const bookmarkItem = cell.querySelector('.bookmark-item');
                const emptySlot = cell.classList.contains('empty-slot');
                const section = getSectionForIndex(index);
                const color = sectionColors[section ? section.start : null] || sectionColors.unassigned;
                if (bookmarkItem) {
                    bookmarkItem.style.backgroundColor = color;
                } else if (emptySlot) {
                    cell.style.backgroundColor = color;
                }
            });
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: formatVersionDate
    // RESUMEN: Formatea una fecha a un formato de versión específico (YY.MM.DDHH).
    // ===================================================================
    function formatVersionDate(date) { const y = date.getUTCFullYear().toString().slice(-2); const m = String(date.getUTCMonth() + 1).padStart(2, '0'); const d = String(date.getUTCDate()).padStart(2, '0'); const h = String(date.getUTCHours()).padStart(2, '0'); return `${y}.${m}.${d}${h}`; }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getLastModifiedDate
    // RESUMEN: Obtiene la fecha de la última modificación desde un archivo remoto, con caché local.
    // ===================================================================
    async function getLastModifiedDate() {
        const k = 'teslaHtmlLastModified';
        const tk = 'teslaHtmlLastModifiedTimestamp';
        const dur = 86400000;
        const cd = localStorage.getItem(k);
        const ct = localStorage.getItem(tk);
        const now = Date.now();
        if (cd && ct && (now - parseInt(ct)) < dur) {
            return new Date(cd);
        }
        try {
            const r = await fetch('https://boardinggate.github.io/Tesla/version.txt', { cache: 'no-cache' });
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const txt = await r.text();
            const lmd = new Date(txt.trim());
            if (isNaN(lmd.getTime())) throw new Error('Invalid date format');
            localStorage.setItem(k, lmd.toISOString());
            localStorage.setItem(tk, now.toString());
            return lmd;
        } catch (e) {
            if (cd) return new Date(cd);
            return new Date('2024-01-01T00:00:00Z');
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateVersion
    // RESUMEN: Actualiza el texto de la versión en la UI.
    // ===================================================================
    async function updateVersion() { try { const lmd = await getLastModifiedDate(); const v = formatVersionDate(lmd); const el = document.getElementById('version'); if (el) el.textContent = `versión: ${v}`; } catch (e) { const el = document.getElementById('version'); if (el) el.textContent = 'versión: error'; } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getFaviconUrl
    // RESUMEN: Obtiene la URL del favicon para un marcador, usando un servicio externo como fallback.
    // ===================================================================
    const getFaviconUrl = (bookmarkData) => { try { const urlToParse = bookmarkData?.url || ''; const customFavicon = bookmarkData?.favicon; if (customFavicon && (customFavicon.startsWith('data:image') || customFavicon.startsWith('http') || customFavicon.startsWith('./'))) return customFavicon; if (urlToParse) { const domain = new URL(urlToParse).hostname; return `https://www.google.com/s2/favicons?domain=${domain}&sz=64`; } } catch (e) { } return 'https://via.placeholder.com/64'; };
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: renderGrid
    // RESUMEN: Dibuja o redibuja el grid completo de marcadores.
    // ===================================================================
    function renderGrid() { grid.innerHTML = ''; cellElements = []; Array.from({ length: TOTAL_CELLS }).forEach((_, index) => { const cellContainer = document.createElement('div'); cellContainer.classList.add('grid-cell'); cellContainer.dataset.index = index; const bookmarkData = currentBookmarks[index]; const section = getSectionForIndex(index); const bgColor = sectionColors[section ? section.start : null] || sectionColors.unassigned; if (bookmarkData) { const link = document.createElement('a'); link.className = 'bookmark-item'; link.title = bookmarkData.name; link.style.backgroundColor = bgColor; link.href = bookmarkData.url || "#"; link.dataset.index = index;
        if (isKeywordAssignmentMode || (bookmarkData.name && bookmarkData.name === "Inicio Tesla") || !bookmarkData.url || bookmarkData.url === '#') { } else { link.target = "_blank"; link.rel = "noopener noreferrer"; }
        const img = document.createElement('img'); img.src = getFaviconUrl(bookmarkData); img.alt = `Favicon ${bookmarkData.name}`; img.loading = "lazy"; img.onerror = function() { this.src = 'https://via.placeholder.com/64'; this.onerror = null; }; if (bookmarkData.name === "Mis Updates") img.classList.add('favicon-red'); else if (bookmarkData.name === "Olas Updates") img.classList.add('favicon-blue'); const nameSpan = document.createElement('span'); nameSpan.className = 'bookmark-name'; nameSpan.textContent = bookmarkData.name; link.appendChild(img); link.appendChild(nameSpan); cellContainer.appendChild(link); } else { cellContainer.classList.add('empty-slot'); const addIcon = document.createElement('span'); addIcon.textContent = '+'; cellContainer.appendChild(addIcon); cellContainer.style.backgroundColor = bgColor; }
        cellContainer.addEventListener('click', handleGridCellClick);
        if (isEditMode) {
             cellContainer.draggable = true;
             cellContainer.addEventListener('dragstart', handleDragStart); cellContainer.addEventListener('dragover', handleDragOver);
             cellContainer.addEventListener('dragleave', handleDragLeave);
             cellContainer.addEventListener('drop', handleDrop);
             cellContainer.addEventListener('dragend', handleDragEnd);
             cellContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
             cellContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
             cellContainer.addEventListener('touchend', handleTouchEnd);
             cellContainer.addEventListener('touchcancel', handleTouchCancel);
             cellContainer.classList.add('editable');
        } else {
             cellContainer.draggable = false;
             cellContainer.removeEventListener('dragstart', handleDragStart);
             cellContainer.removeEventListener('dragover', handleDragOver);
             cellContainer.removeEventListener('dragleave', handleDragLeave);
             cellContainer.removeEventListener('drop', handleDrop);
             cellContainer.removeEventListener('dragend', handleDragEnd);
             cellContainer.removeEventListener('touchstart', handleTouchStart);
             cellContainer.removeEventListener('touchmove', handleTouchMove);
             cellContainer.removeEventListener('touchend', handleTouchEnd);
             cellContainer.removeEventListener('touchcancel', handleTouchCancel);
             cellContainer.classList.remove('editable');
        }
        grid.appendChild(cellContainer); cellElements.push(cellContainer); }); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: renderToggleButtons
    // RESUMEN: Dibuja los botones laterales para ocultar/mostrar secciones del grid.
    // ===================================================================
    function renderToggleButtons() {
        document.querySelectorAll('.range-toggle').forEach(btn => btn.remove());
        toggleButtonElements = {};
        const toggleStatesFromCache = JSON.parse(localStorage.getItem('toggleStates') || '{}');
        currentToggleRanges.forEach((range) => {
            const toggle = document.createElement('span');
            toggle.className = 'toggle-sign range-toggle';
            toggle.dataset.rangeStart = range.start;
            toggle.dataset.rangeEnd = range.end;
            toggle.style.position = 'fixed';
            toggle.style.top = '100px';
            toggle.style.left = '10px';
            const initialState = toggleStatesFromCache[range.start] || 'visible';
            toggle.dataset.state = initialState;
            toggle.addEventListener('click', handleToggleClick);
            document.body.appendChild(toggle);
            toggleButtonElements[range.start] = toggle;
        });
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: createOtherButtons
    // RESUMEN: Crea y añade a la UI los botones de acción fijos.
    // ===================================================================
    function createOtherButtons() {
        if (!document.getElementById('on-off-toggle')) {
            onOffToggle = document.createElement('img');
            onOffToggle.className = 'toggle-image';
            onOffToggle.id = 'on-off-toggle';
            const savedOnOffState = localStorage.getItem('onOffState');
            onOffToggle.dataset.state = savedOnOffState ? savedOnOffState : 'on';
            document.body.appendChild(onOffToggle);
            onOffToggle.addEventListener('mousedown', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) pressStartTime = Date.now(); });
            onOffToggle.addEventListener('mouseup', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) handleOnOffAction(); });
            onOffToggle.addEventListener('mouseleave', () => { pressStartTime = null; });
            onOffToggle.addEventListener('touchstart', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); pressStartTime = Date.now(); } });
            onOffToggle.addEventListener('touchend', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); handleOnOffAction(); } });
        }
        if (!document.getElementById('weather-button')) { weatherButton = document.createElement('span'); weatherButton.className = 'toggle-sign'; weatherButton.id = 'weather-button'; weatherButton.innerHTML = `<img src="https://www.google.com/s2/favicons?domain=accuweather.com&sz=64" alt="Tiempo" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; document.body.appendChild(weatherButton); weatherButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; window.open('https://www.ventusky.com/?p=40.2;-4.7;5&l=rain-3h', '_blank'); }); }
        if (!document.getElementById('reminder-button')) { reminderButton = document.createElement('span'); reminderButton.className = 'toggle-sign'; reminderButton.id = 'reminder-button'; document.body.appendChild(reminderButton); reminderButton.addEventListener('mousedown', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) reminderPressStartTime = Date.now(); }); reminderButton.addEventListener('mouseup', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) handleReminderLongPress(); }); reminderButton.addEventListener('mouseleave', () => { reminderPressStartTime = null; }); reminderButton.addEventListener('touchstart', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); reminderPressStartTime = Date.now(); } }); reminderButton.addEventListener('touchend', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); handleReminderLongPress(); } }); }
        if (!document.getElementById('zoom-button')) { zoomButton = document.createElement('span'); zoomButton.className = 'toggle-sign'; zoomButton.id = 'zoom-button'; zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; zoomButton.dataset.zoomState = localStorage.getItem('zoomState') || 'off'; document.body.appendChild(zoomButton); zoomButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const cS = zoomButton.dataset.zoomState; const nS = cS === 'off' ? 'on' : 'off'; applyZoom(nS); zoomButton.dataset.zoomState = nS; updateButtonStyles(); saveSettings(); adjustButtonPositions(); }); }
        if (!document.getElementById('dark-mode-toggle')) { darkModeToggle = document.createElement('img'); darkModeToggle.className = 'toggle-image'; darkModeToggle.id = 'dark-mode-toggle'; document.body.appendChild(darkModeToggle); darkModeToggle.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; isDarkMode = !isDarkMode; document.body.classList.toggle('dark-mode', isDarkMode); updateButtonStyles(); saveSettings(); }); }
        if (!document.getElementById('config-button')) {
            const configButton = document.createElement('span');
            configButton.id = 'config-button';
            configButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/config.jpg" alt="Configuración">`;
            document.body.appendChild(configButton);
            configButton.addEventListener('click', () => {
                if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) {
                    const mapIsCurrentlyOpen = isNavigationMapActive;
                    const currentMapContext = sessionStorage.getItem('mapContext');
                    if (mapIsCurrentlyOpen && currentMapContext) {
                        sessionStorage.setItem('boardinggate_map_should_reopen_after_config', 'true');
                        sessionStorage.setItem('mapContextToReopenAfterConfig', currentMapContext);
                        closeNavigationMap(true);
                    }
                    showConfigModal();
                }
            });
        }
        if (!document.getElementById('personal-button')) {
            const personalButton = document.createElement('span');
            personalButton.id = 'personal-button';
            personalButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/personal.png" alt="Personal">`;
            document.body.appendChild(personalButton);
            personalButton.addEventListener('click', handlePersonalizationClick);
        }
        if (!document.getElementById('radar-button')) {
            radarButton = document.createElement('span');
            radarButton.id = 'radar-button';
            radarButton.innerHTML = `<img src="RADAR.PNG" alt="Radar/Ubicaciones/Navegación">`;
            document.body.appendChild(radarButton);
            radarButton.addEventListener('click', () => {
                if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
                openNavigationMap();
            });
        }
        if (!document.getElementById('home-button')) {
            const homeButton = document.createElement('span');
            homeButton.id = 'home-button';
            homeButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/home.webp" alt="Inicio">`;
            document.body.appendChild(homeButton);
            homeButton.addEventListener('click', (e) => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) { e.preventDefault(); return; } window.history.back(); });
        }
        if (!document.getElementById('reload-button')) {
            const reloadButton = document.createElement('span');
            reloadButton.id = 'reload-button';
            reloadButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/reload.webp" alt="Recargar">`;
            document.body.appendChild(reloadButton);
            reloadButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; location.reload(); });
        }
        if (!document.getElementById('keyword-assignment-button')) {
             const keywordButton = document.createElement('span');
             keywordButton.id = 'keyword-assignment-button';
             keywordButton.title = "Asignar/Quitar palabra clave filtro";
             keywordButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4314.PNG" alt="Asignar Keyword">`;
             document.body.appendChild(keywordButton);
             keywordButton.addEventListener('click', () => { toggleKeywordAssignmentMode(!isKeywordAssignmentMode); });
        }
        if (!document.getElementById('password-toggle-button')) {
            const passwordButton = document.createElement('span');
            passwordButton.id = 'password-toggle-button';
            passwordButton.innerHTML = `<img src="" alt="Clave">`;
            document.body.appendChild(passwordButton);
            passwordButton.addEventListener('click', handlePasswordToggleClick);
        }
        if (!document.getElementById('versions-button')) {
             versionsButton = document.createElement('span');
             versionsButton.id = 'versions-button';
             versionsButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4309.PNG" alt="Versiones">`;
             document.body.appendChild(versionsButton);
             versionsButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; showVersionsModal(); });
        }
        if (!document.getElementById('info-button')) {
             infoButton = document.createElement('span');
             infoButton.id = 'info-button';
             infoButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4326.PNG" alt="Info">`;
             document.body.appendChild(infoButton);
             infoButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; window.open('https://boardinggate.github.io/Tesla/manual.html', '_blank'); });
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleGridCellClick
    // RESUMEN: Gestiona los clics en las celdas del grid, según el modo activo.
    // ===================================================================
    function handleGridCellClick(event) {
        const cellContainer = event.currentTarget; const index = parseInt(cellContainer.dataset.index);
        if (isEditMode) { const link = cellContainer.querySelector('a.bookmark-item'); if (link) event.preventDefault(); showEditModal(index, false); }
        else if (isAssignmentMode) { event.preventDefault(); handleGridCellClickForAssignment(index); }
        else if (isKeywordAssignmentMode) { event.preventDefault(); handleKeywordAssignmentClick(index); }
        else { const link = cellContainer.querySelector('a.bookmark-item'); const bookmarkData = currentBookmarks[index];
            if (!link || !link.href || link.href === '#') {
                event.preventDefault();
                if (bookmarkData && bookmarkData.url && bookmarkData.url.startsWith("map-action:")) {
                    const action = bookmarkData.url.split(":")[1];
                    if (action === "openRemindersMapWithNoRadars") {
                        openLocationsPreviewMap();
                    } else if (action === "openRemindersMap") {
                        openNavigationMap();
                    }
                }
            } else {
                if (!link.target && bookmarkData && bookmarkData.name !== "Inicio Tesla") {
                    link.target = "_blank"; link.rel = "noopener noreferrer";
                }
            }
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleToggleClick
    // RESUMEN: Gestiona los clics en los botones laterales de sección, según el modo activo.
    // ===================================================================
    function handleToggleClick(event) { const toggle = event.currentTarget; if (isEditMode) { event.preventDefault(); const start = parseInt(toggle.dataset.rangeStart); showEditModal(start, true); } else if (isAssignmentMode) { event.preventDefault(); handleToggleClickForAssignment(toggle); } else if (isKeywordAssignmentMode) { event.preventDefault(); } else { updateToggleState(toggle); } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateToggleState
    // RESUMEN: Cambia el estado (visible/oculto) de un botón de sección.
    // ===================================================================
    function updateToggleState(toggle) { if (!toggle || isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const start = parseInt(toggle.dataset.rangeStart); if (isNaN(start)) return; const rangeConfig = currentToggleRanges.find(r => r.start === start); if (!rangeConfig) return; const currentState = toggle.dataset.state; const newState = currentState === 'visible' ? 'hidden' : 'visible'; toggle.dataset.state = newState; const savedStates = JSON.parse(localStorage.getItem('toggleStates') || '{}'); savedStates[start] = newState; localStorage.setItem('toggleStates', JSON.stringify(savedStates)); updateButtonStyles(); filterGridItems(); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateAllToggles
    // RESUMEN: Cambia el estado de todos los toggles a la vez (on/off general).
    // ===================================================================
    function updateAllToggles(newState) { const onOffToggleElem = document.getElementById('on-off-toggle'); if (!onOffToggleElem) return; onOffToggleElem.dataset.state = newState; localStorage.setItem('onOffState', newState); updateButtonStyles(); filterGridItems(); saveSettings(); }
    const scrollToggle = document.getElementById('scroll-toggle'); if (scrollToggle) scrollToggle.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const sP = window.scrollY; const mS = document.body.scrollHeight - window.innerHeight; window.scrollTo({ top: sP < 100 ? mS : 0, behavior: 'smooth' }); });
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleOnOffAction
    // RESUMEN: Maneja la acción del botón de on/off general.
    // ===================================================================
    function handleOnOffAction() { if (pressStartTime !== null) { const t = document.getElementById('on-off-toggle'); if (t) { const nS = t.dataset.state === 'on' ? 'off' : 'on'; updateAllToggles(nS); } } pressStartTime = null; }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleReminderLongPress
    // RESUMEN: Maneja el clic corto/largo en el botón de recordatorios.
    // ===================================================================
    function handleReminderLongPress() { if (reminderPressStartTime === null) return; const dur = Date.now() - reminderPressStartTime; if (dur >= 2000) showAllReminders(); else showReminderModal(); reminderPressStartTime = null; }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handlePersonalizationClick
    // RESUMEN: Gestiona el clic en el botón de personalización, mostrando el menú de opciones.
    // ===================================================================
    function handlePersonalizationClick() {
        const personalButton = document.getElementById('personal-button'); const wasEditing = isEditMode; const wasAssigning = isAssignmentMode; const wasKeywordAssigning = isKeywordAssignmentMode;
        if (wasKeywordAssigning) { toggleKeywordAssignmentMode(false); }
        if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
        if (wasEditing) { toggleEditMode(false); } else if (wasAssigning) { toggleAssignmentMode(false); } else if (!wasKeywordAssigning) { showPersonalizationChoice(); }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showPersonalizationChoice
    // RESUMEN: Muestra el modal para elegir el tipo de personalización.
    // ===================================================================
    function showPersonalizationChoice() {
        const existingModal = document.querySelector('.choice-modal'); if (existingModal) existingModal.remove();
        const modal = document.createElement('div'); modal.className = 'choice-modal'; modal.setAttribute('aria-label', 'Elegir tipo de personalización');
        modal.innerHTML = `
            <h2>¿Qué quieres personalizar?</h2>
            <div class="modal-top-buttons">
                <button class="choice-cancel">Cancelar</button>
            </div>
            <p class="mb-6">Elige una opción:</p>
            <div class="personalization-options">
                <button class="choice-edit">URLs / Etiquetas / Reordenar</button>
                <button class="choice-assign">Asignar Botones Ocultación</button>
                <button class="choice-help">Ver Ayuda</button>
            </div>
        `;
        modal.querySelector('.choice-edit').addEventListener('click', () => { modal.remove(); toggleEditMode(true); });
        modal.querySelector('.choice-assign').addEventListener('click', () => { modal.remove(); toggleAssignmentMode(true); });
        modal.querySelector('.choice-help').addEventListener('click', () => { modal.remove(); showEditInfoModal(); });
        modal.querySelector('.choice-cancel').addEventListener('click', () => { modal.remove(); });
        document.body.appendChild(modal);
        addModalAutoCloseTimer(modal, modal.querySelector('.choice-cancel'), 'choice-modal', 30000);
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleEditMode
    // RESUMEN: Activa o desactiva el modo de edición (URLs, etiquetas, arrastrar).
    // ===================================================================
    function toggleEditMode(activate) {
        const personalButton = document.getElementById('personal-button'); isEditMode = activate; personalButton.classList.toggle('editing', isEditMode); document.body.classList.toggle('editing-active', isEditMode);
        if (isEditMode) {
            if (isAssignmentMode) toggleAssignmentMode(false); if (isKeywordAssignmentMode) toggleKeywordAssignmentMode(false);
            if (firstPersonalizationSession) { showEditInfoModal(); firstPersonalizationSession = false; sessionStorage.setItem('personalizationHelpShown', 'true'); }
            showToast("Modo Edición (URLs/Etiquetas/Arrastrar) Activado", "info", 4000);
        } else {
            showToast("Modo Edición Desactivado", "info", 2000);
            cellElements.forEach(cell => cell.classList.remove('dragging', 'drag-over')); draggedItem = null; draggedItemIndex = null; currentTouchTarget = null; dragOverIndex = null;
            if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
        } renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles(); adjustButtonPositions();
        document.querySelectorAll('.range-toggle').forEach(el => { el.classList.toggle('editable', isEditMode); }); filterGridItems();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleAssignmentMode
    // RESUMEN: Activa o desactiva el modo de asignación de botones a secciones.
    // ===================================================================
    function toggleAssignmentMode(activate) {
        const personalButton = document.getElementById('personal-button'); isAssignmentMode = activate; personalButton.classList.toggle('assigning', isAssignmentMode); document.body.classList.toggle('assignment-active', isAssignmentMode);
        if (isAssignmentMode) {
            if (isEditMode) toggleEditMode(false); if (isKeywordAssignmentMode) toggleKeywordAssignmentMode(false);
            if (firstPersonalizationSession) { showEditInfoModal(); firstPersonalizationSession = false; sessionStorage.setItem('personalizationHelpShown', 'true'); }
            showToast("Modo Asignación Botones Activado", "info", 4000);
            const firstToggle = document.querySelector('.range-toggle');
            if (firstToggle) { handleToggleClickForAssignment(firstToggle); } else { currentlyAssigningToggleStart = null; updateGridAssignmentVisuals(); }
        } else {
            showToast("Modo Asignación Botones Desactivado", "info", 2000); saveCustomData();
            document.querySelectorAll('.range-toggle.assigning-selected').forEach(t => t.classList.remove('assigning-selected'));
            document.querySelectorAll('.grid-cell.assigned-to-current').forEach(c => { c.classList.remove('assigned-to-current'); c.style.opacity = ''; c.style.outline=''; c.style.boxShadow=''; c.style.backgroundColor = ''; });
            document.querySelectorAll('.range-toggle').forEach(t => t.style.opacity = '');
            currentlyAssigningToggleStart = null;
        } renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles(); adjustButtonPositions(); filterGridItems(); 
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleKeywordAssignmentMode
    // RESUMEN: Activa o desactiva el modo de asignación de palabras clave a los nombres de los marcadores.
    // ===================================================================
    function toggleKeywordAssignmentMode(activate) {
         const keywordButton = document.getElementById('keyword-assignment-button'); const filterInput = document.getElementById('grid-filter-input'); isKeywordAssignmentMode = activate;
         if (keywordButton) { keywordButton.classList.toggle('active', isKeywordAssignmentMode); }
        document.body.classList.toggle('keyword-assignment-active', isKeywordAssignmentMode);
         if (isKeywordAssignmentMode) {
              if (isEditMode) toggleEditMode(false); if (isAssignmentMode) toggleAssignmentMode(false);
              const toastMessage = "Modo activo: Escribe palabra(s) en el campo filtro grid (separadas por espacio si son varias). Pulsa ICONO FILTRO para añadir/quitar esa(s) palabra(s) al nombre del botón(es) que vaya seleccionando. Pulsa el icono para salir de este modo.";
              showToast(toastMessage, "info", 15000); filterGridItems(); applyInitialKeywordHighlights();
         } else {
              showToast("Modo Asignación de Palabras Clave Desactivado", "info", 2000); cellElements.forEach(cell => cell.classList.remove('keyword-assigned-highlight')); filterGridItems();
         }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: applyInitialKeywordHighlights
    // RESUMEN: Resalta los marcadores que ya contienen la palabra clave del filtro al activar el modo.
    // ===================================================================
    function applyInitialKeywordHighlights() { const filterInput = document.getElementById('grid-filter-input'); const keyword = filterInput.value.trim().replace(/\s+/g, '').toUpperCase(); if (!keyword) return; const keywordTag = `[${keyword}]`; cellElements.forEach((cell, index) => { const bookmark = currentBookmarks[index]; if (bookmark && bookmark.name && bookmark.name.includes(keywordTag)) { cell.classList.add('keyword-assigned-highlight'); } else { cell.classList.remove('keyword-assigned-highlight'); } }); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleKeywordAssignmentClick
    // RESUMEN: Añade o quita la palabra clave del filtro al nombre de un marcador.
    // ===================================================================
    function handleKeywordAssignmentClick(index) {
        const filterInput = document.getElementById('grid-filter-input'); const keyword = filterInput.value.trim().replace(/\s+/g, '').toUpperCase();
        if (!keyword) { showToast("Escribe una palabra en el campo filtro primero.", "warning"); return; }
        const bookmark = currentBookmarks[index]; const cellElement = cellElements[index];
        if (!bookmark || !cellElement) { showToast(`No hay un marcador en la posición ${index + 1}.`, "warning"); return; }
        const keywordTag = `[${keyword}]`; const currentName = bookmark.name || ""; const nameSpan = cellElement.querySelector('.bookmark-name');
        let newName = currentName; let actionTaken = '';
        if (currentName.includes(keywordTag)) { newName = currentName.replace(keywordTag, '').replace(/\s{2,}/g, ' ').trim(); cellElement.classList.remove('keyword-assigned-highlight'); actionTaken = 'removed'; }
        else { newName = currentName.trim(); const lastBracketIndex = newName.lastIndexOf(']'); const endsWithBracket = lastBracketIndex !== -1 && lastBracketIndex === newName.length - 1;
            if (endsWithBracket) { newName += '  ' + keywordTag; } else { newName += '          ' + keywordTag; } cellElement.classList.add('keyword-assigned-highlight'); actionTaken = 'added'; }
        bookmark.name = newName; currentBookmarks[index] = { ...bookmark }; if (!customData.bookmarks) customData.bookmarks = {}; customData.bookmarks[index] = { ...bookmark }; saveCustomData();
        if (nameSpan) { nameSpan.textContent = newName; }
        if (actionTaken === 'added') { showToast(`"${keyword}" añadido. Nombre: ${newName}`, "success", 2500); } else if (actionTaken === 'removed') { showToast(`"${keyword}" quitado. Nombre: ${newName}`, "info", 2500); }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleToggleClickForAssignment
    // RESUMEN: Selecciona un botón de sección para empezar a asignarle marcadores.
    // ===================================================================
    function handleToggleClickForAssignment(toggleElement) { const start = parseInt(toggleElement.dataset.rangeStart); if (isNaN(start)) return; currentlyAssigningToggleStart = start; document.querySelectorAll('.range-toggle').forEach(t => { t.classList.toggle('assigning-selected', t === toggleElement); t.style.opacity = t === toggleElement ? '' : '0.7'; }); updateGridAssignmentVisuals(); showToast(`Asignando botones para: ${toggleElement.textContent.substring(1)}`, "info", 2500); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleGridCellClickForAssignment
    // RESUMEN: Asigna o desasigna un marcador a la sección actualmente seleccionada.
    // ===================================================================
    function handleGridCellClickForAssignment(cellIndex) {
        if (currentlyAssigningToggleStart === null) { showToast("Selecciona primero un botón lateral (PdR,s, iAs, etc.)", "warning"); return; }
        const startKey = currentlyAssigningToggleStart.toString(); if (!customData.toggles[startKey]) { const currentRange = currentToggleRanges.find(r => r.start == startKey); customData.toggles[startKey] = { label: currentRange ? currentRange.label : `Rango ${startKey}`, assignedIndexes: currentRange ? [...currentRange.assignedIndexes] : [] }; }
        else if (!customData.toggles[startKey].assignedIndexes) { const currentRange = currentToggleRanges.find(r => r.start == startKey); customData.toggles[startKey].assignedIndexes = currentRange ? [...currentRange.assignedIndexes] : []; }
        const assigned = customData.toggles[startKey].assignedIndexes; const indexInArray = assigned.indexOf(cellIndex);
        if (indexInArray > -1) { assigned.splice(indexInArray, 1); } else { assigned.push(cellIndex); assigned.sort((a, b) => a - b); }
        const currentRangeIndex = currentToggleRanges.findIndex(r => r.start == startKey); if (currentRangeIndex > -1) { currentToggleRanges[currentRangeIndex].assignedIndexes = [...assigned]; }
        updateGridAssignmentVisuals(); saveCustomData(); showToast('Asignación guardada', 'success', 500);
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateGridAssignmentVisuals
    // RESUMEN: Actualiza la apariencia visual del grid durante el modo de asignación.
    // ===================================================================
    function updateGridAssignmentVisuals() { if (!isAssignmentMode || currentlyAssigningToggleStart === null) { cellElements.forEach(cell => { cell.classList.remove('assigned-to-current'); cell.style.opacity = ''; cell.style.outline = ''; cell.style.boxShadow = ''; }); return; } const startKey = currentlyAssigningToggleStart.toString(); let assignedIndexesForCurrentToggle = []; if (customData.toggles[startKey] && customData.toggles[startKey].assignedIndexes) { assignedIndexesForCurrentToggle = customData.toggles[startKey].assignedIndexes; } else { const currentRange = currentToggleRanges.find(r => r.start == startKey); if (currentRange?.assignedIndexes) { assignedIndexesForCurrentToggle = currentRange.assignedIndexes; } } cellElements.forEach((cell, index) => { const isAssigned = assignedIndexesForCurrentToggle.includes(index); cell.classList.toggle('assigned-to-current', isAssigned); if (isAssigned) { cell.style.opacity = ''; cell.style.outline = '3px solid cyan'; cell.style.boxShadow = document.body.classList.contains('dark-mode') ? 'inset 0 0 10px rgba(0, 200, 200, 0.7)' : 'inset 0 0 8px rgba(0, 255, 255, 0.6)'; } else { cell.style.opacity = document.body.classList.contains('dark-mode') ? '0.5' : '0.6'; cell.style.outline = `1px dashed ${document.body.classList.contains('dark-mode') ? '#555' : '#aaa'}`; cell.style.boxShadow = ''; } }); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showEditInfoModal
    // RESUMEN: Muestra el modal con la ayuda sobre los modos de personalización.
    // ===================================================================
    function showEditInfoModal() {
        const existingModal = document.querySelector('.edit-info-modal'); if (existingModal) existingModal.remove();
        const modal = document.createElement('div'); modal.className = 'edit-info-modal'; modal.setAttribute('aria-label', 'Ayuda Personalización');
        modal.innerHTML = `
            <h2 class="text-xl font-bold mb-4">Ayuda de Personalización</h2>
            <div class="modal-top-buttons" style="justify-content: flex-end;">
                <button type="button" id="close-edit-info" class="px-6 py-2" style="flex: 0 1 auto; min-width: 120px;">Entendido</button>
            </div>
            <p class="mb-3">Al pulsar el botón <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (personalizar) o el icono <img src="https://boardinggate.github.io/Tesla/IMG_4314.PNG" alt="Key" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (llave) puedes elegir entre varios modos:</p>
            <div class="mb-4 p-3 bg-yellow-100 border border-yellow-300 rounded">
                 <h3 class="font-semibold text-lg mb-2">1. Editar URLs / Etiquetas / Reordenar (Botón Personalizar Amarillo)</h3>
                 <ul class="list-disc pl-5 space-y-1 text-sm">
                    <li><strong>Activar:</strong> Elige "URLs / Etiquetas / Reordenar" en el menú inicial. El botón <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> se pondrá amarillo.</li>
                    <li><strong>Editar Marcador/Botón Lateral:</strong> Haz clic en un marcador del grid o en un botón lateral (PdR,s, iAs, etc.). Se abrirá una ventana para editar su nombre, URL (si es marcador) o etiqueta (si es botón lateral). <strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                    <li><strong>Arrastrar y Soltar:</strong> Mantén pulsado un marcador del grid y arrástralo a otra posición (incluso vacía) para reordenarlos.</li>
                    <li><strong>Guardar Cambios:</strong> Los cambios en nombre/URL/etiqueta se guardan al pulsar "Guardar" en la ventana de edición. El reordenamiento se guarda automáticamente al soltar.</li>
                    <li><strong>Vaciar Casilla:</strong> En la ventana de edición de un marcador, pulsa "Vaciar" para eliminarlo.</li>
                    <li><strong>Resetear:</strong> En la ventana de edición, pulsa "Resetear" para volver a los valores originales (si los tenía).</li>
                 </ul>
            </div>
            <div class="mb-4 p-3 bg-cyan-100 border border-cyan-300 rounded">
                <h3 class="font-semibold text-lg mb-2">2. Asignar Botones Ocultación (Botón Personalizar Cian)</h3>
                <ul class="list-disc pl-5 space-y-1 text-sm">
                    <li><strong>Activar:</strong> Elige "Asignar Botones Ocultación" en el menú inicial. El botón <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> se pondrá cian.</li>
                    <li><strong>Seleccionar Botón Lateral:</strong> Haz clic en el botón lateral (PdR,s, iAs, etc.) cuyos marcadores quieres definir. Se resaltará.</li>
                    <li><strong>Asignar/Desasignar Marcadores:</strong> Haz clic en cualquier marcador de la rejilla. Si estaba asignado, se desasignará (atenuado). Si no lo estaba, se asignará (resaltado). <strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                    <li><strong>Cambiar Botón Lateral:</strong> Haz clic en otro botón lateral para asignar sus marcadores.</li>
                    <li><strong>Guardar:</strong> Los cambios se guardan automáticamente al salir de este modo (pulsando el botón <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> cian).</li>
                    <li><strong>Visibilidad por defecto:</strong> Marcadores no asignados a <i>ningún</i> botón lateral siempre serán visibles (salvo que el botón general <img src="https://boardinggate.github.io/Tesla/IMG_4191.jpg" alt="OFF" style="width:20px; height:11px; display:inline; vertical-align:middle;"> esté desactivado).</li>
                </ul>
            </div>
            <div class="mb-4 p-3 bg-green-100 border border-green-300 rounded">
            <h3 class="font-semibold text-lg mb-2">3. Asignar Palabra Clave Filtro (Icono Llave Verde)</h3>
            <ul class="list-disc pl-5 space-y-1 text-sm">
                <li><strong>Activar:</strong> Pulsa el icono de la llave <img src="https://boardinggate.github.io/Tesla/IMG_4314.PNG" alt="Key" style="width:16px; height:16px; display:inline; vertical-align:middle;"> junto al campo de filtro. El icono se pondrá verde. Si vuelves a pulsar, se desactivará.</li>
                <li><strong>Escribe la Palabra:</strong> Escribe la palabra que quieres añadir al nombre de los botones en el campo de filtro. Se eliminarán los espacios automáticamente.</li>
                <li><strong>Asignar:</strong> Haz clic en el botón del grid al que quieres añadir la palabra clave. La palabra (en corchetes) se añadirá a su nombre (si no existe ya).</li>
                <li><strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                <li><strong>Guardar:</strong> Los cambios se guardan automáticamente cada vez que asignas una palabra clave a un botón.</li>
                <li><strong>Mostrar Todo:</strong> Al activar este modo, se limpiará el filtro y se mostrarán todos los botones para facilitar la asignación.</li>
            </ul>
            </div>
            <p class="mb-4"><strong>Salir de Personalización:</strong> Pulsa el botón activo <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (amarillo o cian) o el icono de la llave <img src="https://boardinggate.github.io/Tesla/IMG_4314.PNG" alt="Key" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (verde) para desactivar el modo actual y volver al uso normal.</p>
        `;
        document.body.appendChild(modal);
        const closeEditInfoButton = modal.querySelector('#close-edit-info');
        const closeHandler = () => { clearModalAutoCloseTimer(modal, closeEditInfoButton, 'edit-info-modal'); if (modal.parentNode) modal.parentNode.removeChild(modal); };
        closeEditInfoButton.addEventListener('click', closeHandler); addModalAutoCloseTimer(modal, closeEditInfoButton, 'edit-info-modal');
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showEditModal
    // RESUMEN: Muestra el modal para editar los detalles de un marcador o de un botón de sección.
    // ===================================================================
    function showEditModal(targetIndexOrStart, isToggle = false) { if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); } const existingModal = document.querySelector('.edit-modal'); if (existingModal) existingModal.remove(); const modal = document.createElement('div'); modal.className = 'edit-modal'; if (isToggle) { editingTargetElement = toggleButtonElements[targetIndexOrStart]; } else { editingTargetElement = cellElements[targetIndexOrStart]; } if (editingTargetElement) { editingTargetElement.classList.add('editing-target'); } else { } let currentItemData = {}; let originalItemData = {}; let title = ''; let isNewBookmark = false; const targetIndex = isToggle ? -1 : targetIndexOrStart; if (isToggle) { const targetStart = targetIndexOrStart; const currentRange = currentToggleRanges.find(r => r.start === targetStart); const originalRange = originalToggleRanges.find(r => r.start === targetStart); const currentLabel = customData.toggles[targetStart]?.label ?? currentRange?.label ?? ''; currentItemData = { label: currentLabel }; originalItemData = { label: originalRange?.label || '' }; title = `Editar Etiqueta Sección`;
        modal.innerHTML = `
            <h2>${title}</h2>
            <div class="modal-top-buttons" style="margin-bottom: 1.2rem;">
                <button class="save">Guardar</button>
                <button class="reset">Resetear</button>
                <button class="cancel">Cancelar</button>
            </div>
            <div><label for="edit-label">Etiqueta (máx 7):</label><input type="text" id="edit-label" value="${currentItemData.label}" maxlength="7"></div>
        `;
    } else { const currentBookmark = currentBookmarks[targetIndex]; const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null; currentItemData = currentBookmark ? { ...currentBookmark } : { name: '', url: '', favicon: '' }; originalItemData = originalBookmark ? { ...originalBookmark } : { name: '', url: '', favicon: '' }; isNewBookmark = !currentBookmark; title = currentBookmark ? `Editar Marcador: ${currentItemData?.name || `Índice ${targetIndex}`}` : `Añadir Marcador (Posición ${targetIndex + 1})`;
        modal.innerHTML = `
            <h2>${title}</h2>
            <div class="modal-top-buttons" style="margin-bottom: 1.2rem;">
                <button class="save">Guardar</button>
                <button class="reset">Resetear</button>
                <button class="empty">Vaciar</button>
                <button class="cancel">Cancelar</button>
            </div>
            <div><label for="edit-name">Nombre:</label><input type="text" id="edit-name" value="${currentItemData.name || ''}"></div>
            <div><label for="edit-url">URL:</label><div class="input-with-button"><input type="url" id="edit-url" value="${currentItemData.url || ''}" placeholder="https://ejemplo.com"><button class="search-button" id="search-url-button" title="Buscar URL en Google (basado en URL/Nombre)">🔍</button></div></div>
            <div><label for="edit-favicon">URL Favicon (Opcional):</label><div class="input-with-button"><input type="text" id="edit-favicon" value="${currentItemData.favicon || ''}" placeholder="Dejar vacío para auto"><button class="search-button" id="search-favicon-button" title="Buscar Favicon en Google Images (basado en Favicon/Nombre)">🖼️</button></div></div>
        `;
    } document.body.appendChild(modal); const cleanupEditModal = () => { if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; } if (modal.parentNode) modal.parentNode.removeChild(modal); }; modal.querySelector('.save').addEventListener('click', () => { let dataChanged = false; if (isToggle) { const targetStart = targetIndexOrStart; const newLabel = modal.querySelector('#edit-label').value.trim(); if (!newLabel) { showToast("La etiqueta no puede estar vacía.", "warning"); return; } if (newLabel.length > 7) { showToast("La etiqueta no puede exceder 7 caracteres.", "warning"); return; } const originalLabel = originalToggleRanges.find(r => r.start === targetStart)?.label || ''; if (newLabel !== originalLabel) { if (!customData.toggles[targetStart]) customData.toggles[targetStart] = {}; customData.toggles[targetStart].label = newLabel; dataChanged = true; } else { if (customData.toggles[targetStart] && customData.toggles[targetStart].hasOwnProperty('label')) { delete customData.toggles[targetStart].label; if (Object.keys(customData.toggles[targetStart]).length === 0) delete customData.toggles[targetStart]; dataChanged = true; } } const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetStart); if (rangeIdx > -1) currentToggleRanges[rangeIdx].label = newLabel; } else { const nameInput = modal.querySelector('#edit-name'); const urlInput = modal.querySelector('#edit-url'); const faviconInput = modal.querySelector('#edit-favicon');
                const newName = nameInput.value.trim();
                const newUrl = urlInput.value.trim();
                const newFavicon = faviconInput.value.trim() || null;
                const isEmpty = !newName && !newUrl && !newFavicon;
                const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                if (isEmpty) {
                    if (originalBookmark !== null && originalBookmark !== undefined) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = null;
                        dataChanged = true;
                    } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = null;
                } else {
                    if (!newName || !newUrl) {
                        showToast("Nombre y URL son obligatorios.", "warning");
                        return;
                    }
                    try { new URL(newUrl); } catch (_) {
                        showToast("URL inválida.", "warning");
                        return;
                    }
                    const bookmarkUpdate = { name: newName, url: newUrl, favicon: newFavicon };
                    const originalData = originalBookmark ? { name: originalBookmark.name, url: originalBookmark.url, favicon: originalBookmark.favicon || null } : null;
                    const bookmarksAreEqual = (b1, b2) => { if (b1 === null && b2 === null) return true; if (b1 === null || b2 === null) return false; return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null); };
                    if (!bookmarksAreEqual(bookmarkUpdate, originalData)) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = bookmarkUpdate;
                        dataChanged = true;
                   } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = bookmarkUpdate;
                }
            }
            if (dataChanged) {
                saveCustomData();
                showToast("Cambios guardados", "success");
            } else {
                showToast("No se detectaron cambios", "info");
            }
            updateGridItemUI(targetIndexOrStart, isToggle);
            cleanupEditModal();
        });
        modal.querySelector('.reset').addEventListener('click', () => {
            let dataChanged = false;
            if (isToggle) {
                const targetStart = targetIndexOrStart;
                const originalRange = originalToggleRanges.find(r => r.start === targetStart);
                const originalLabel = originalRange?.label || '';
                modal.querySelector('#edit-label').value = originalLabel;
                if (customData.toggles && customData.toggles[targetStart] && customData.toggles[targetStart].hasOwnProperty('label')) {
                    delete customData.toggles[targetStart].label;
                    if (Object.keys(customData.toggles[targetStart]).length === 0) delete customData.toggles[targetStart];
                    dataChanged = true;
                }
                const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetStart);
                if (rangeIdx > -1) currentToggleRanges[rangeIdx].label = originalLabel;
            } else {
                const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                modal.querySelector('#edit-name').value = originalBookmark?.name || '';
                modal.querySelector('#edit-url').value = originalBookmark?.url || '';
                modal.querySelector('#edit-favicon').value = originalBookmark?.favicon || '';
                if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                    delete customData.bookmarks[targetIndex];
                    dataChanged = true;
                }
                currentBookmarks[targetIndex] = originalBookmark ? { ...originalBookmark } : null;
            }
            if (dataChanged) {
                saveCustomData();
                showToast("Valores reseteados al original y guardados", "info");
            } else {
                showToast("Ya estaba con los valores originales", "info");
            }
            updateGridItemUI(targetIndexOrStart, isToggle);
            cleanupEditModal();
        });
        modal.querySelector('.cancel').addEventListener('click', cleanupEditModal);
        if (!isToggle) {
            const emptyBtn = modal.querySelector('.empty');
            if (emptyBtn) {
                emptyBtn.addEventListener('click', () => {
                    modal.querySelector('#edit-name').value = '';
                    modal.querySelector('#edit-url').value = '';
                    modal.querySelector('#edit-favicon').value = '';
                    const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                    let dataChanged = false;
                    if (originalBookmark !== null && originalBookmark !== undefined) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = null;
                        dataChanged = true;
                    } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = null;
                    if(dataChanged) {
                        saveCustomData();
                        showToast("Marcador vaciado y guardado.", "success");
                    } else {
                        showToast("Marcador ya estaba vacío.", "info");
                    }
                    updateGridItemUI(targetIndex, false);
                    cleanupEditModal();
                });
            }
            const searchUrlBtn = modal.querySelector('#search-url-button');
            const searchFaviconBtn = modal.querySelector('#search-favicon-button');
            const nameInput = modal.querySelector('#edit-name');
            const urlInputSearch = modal.querySelector('#edit-url');
            const faviconInputSearch = modal.querySelector('#edit-favicon');
            if (searchUrlBtn) {
                searchUrlBtn.addEventListener('click', () => {
                    const urlValue = urlInputSearch.value.trim();
                    const nameValue = nameInput.value.trim();
                    const query = urlValue || nameValue;
                    if (query) { window.open(`https://www.google.com/search?q=${encodeURIComponent(query)}`, '_blank'); }
                    else { showToast("Escribe un Nombre o URL para buscar.", "warning"); }
                });
            }
            if (searchFaviconBtn) {
                searchFaviconBtn.addEventListener('click', () => {
                    const faviconValue = faviconInputSearch.value.trim();
                    const nameValue = nameInput.value.trim();
                    const query = faviconValue || nameValue;
                    if (query) { window.open(`https://www.google.com/search?tbm=isch&q=${encodeURIComponent(`"${query}" favicon logo icon`)}`, '_blank'); }
                    else { showToast("Escribe un Nombre o URL de Favicon para buscar.", "warning"); }
                });
            }
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateGridItemUI
    // RESUMEN: Redibuja el grid y los botones para reflejar los cambios realizados en la edición.
    // ===================================================================
    function updateGridItemUI(indexOrStart, isToggle = false) {
        renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles();adjustButtonPositions();
        if (isAssignmentMode) {
            updateGridAssignmentVisuals();
            if (currentlyAssigningToggleStart !== null && toggleButtonElements[currentlyAssigningToggleStart]) {
                toggleButtonElements[currentlyAssigningToggleStart].classList.add('assigning-selected');
                toggleButtonElements[currentlyAssigningToggleStart].style.opacity = '';
            }
        } else if (isKeywordAssignmentMode) { applyInitialKeywordHighlights(); }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: performInsertAndSave
    // RESUMEN: Realiza la lógica de mover un marcador en el grid y guarda los cambios.
    // ===================================================================
    function performInsertAndSave(sourceIndex, targetIndex) { if (sourceIndex === targetIndex || sourceIndex === null || targetIndex === null) { return false; } const draggedData = currentBookmarks.splice(sourceIndex, 1)[0]; currentBookmarks.splice(targetIndex, 0, draggedData); if (!customData.bookmarks) customData.bookmarks = {}; if (!customData.toggles) customData.toggles = {}; const minIdx = Math.min(sourceIndex, targetIndex); const maxIdx = Math.max(sourceIndex, targetIndex); currentToggleRanges.forEach(range => { if (range.assignedIndexes) {
        range.assignedIndexes = range.assignedIndexes.map(idx => { if (idx === sourceIndex) return targetIndex; else if (idx > sourceIndex && idx <= targetIndex) return idx - 1; else if (idx < sourceIndex && idx >= targetIndex) return idx + 1; else return idx; }).sort((a, b) => a - b); const startKey = range.start.toString(); if (customData.toggles[startKey] && customData.toggles[startKey].hasOwnProperty('assignedIndexes')) { customData.toggles[startKey].assignedIndexes = [...range.assignedIndexes]; } } }); for (let i = minIdx; i <= maxIdx; i++) { const currentItem = currentBookmarks[i]; const originalItem = i < originalBookmarks.length ? originalBookmarks[i] : null; const bookmarksAreEqual = (b1, b2) => { if (b1 === null && b2 === null) return true; if (b1 === null || b2 === null) return false; return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null); }; if (!bookmarksAreEqual(currentItem, originalItem)) { customData.bookmarks[i] = currentItem ? { ...currentItem } : null; } else if (customData.bookmarks.hasOwnProperty(i)) { delete customData.bookmarks[i]; } } saveCustomData(); renderGrid(); loadSavedSettings(); updateButtonStyles(); showToast(`Movido de ${sourceIndex + 1} a ${targetIndex + 1}`, "success", 1500); return true; }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleDragStart
    // RESUMEN: Maneja el inicio del arrastre de un elemento del grid.
    // ===================================================================
    function handleDragStart(e) { if (!isEditMode) return; draggedItem = e.currentTarget; draggedItemIndex = parseInt(draggedItem.dataset.index); e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', draggedItemIndex); setTimeout(() => { if (draggedItem) draggedItem.classList.add('dragging'); }, 0); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleDragOver
    // RESUMEN: Maneja el evento cuando un elemento arrastrado pasa sobre otro.
    // ===================================================================
    function handleDragOver(e) { if (!isEditMode || !draggedItem) return; e.preventDefault(); e.dataTransfer.dropEffect = 'move'; const targetCell = e.target.closest('.grid-cell'); const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetCell && targetIndex !== dragOverIndex) { if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } if (targetIndex !== draggedItemIndex) { targetCell.classList.add('drag-over'); dragOverIndex = targetIndex; } else { dragOverIndex = null; } } else if (!targetCell && dragOverIndex !== null) { if (cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } dragOverIndex = null; } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleDragLeave
    // RESUMEN: Maneja el evento cuando un elemento arrastrado sale de una celda destino.
    // ===================================================================
    function handleDragLeave(e) { if (!isEditMode || !draggedItem) return; const targetCell = e.target.closest('.grid-cell'); if (targetCell && !targetCell.contains(e.relatedTarget)) { if (parseInt(targetCell.dataset.index) === dragOverIndex) { targetCell.classList.remove('drag-over'); dragOverIndex = null; } } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleDrop
    // RESUMEN: Maneja el evento de soltar un elemento arrastrado.
    // ===================================================================
    function handleDrop(e) { if (!isEditMode || !draggedItem) return; e.preventDefault(); const targetCell = e.target.closest('.grid-cell'); const sourceIndex = draggedItemIndex; const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetIndex !== null && sourceIndex !== targetIndex) { performInsertAndSave(sourceIndex, targetIndex); } else { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } } handleDragEndCleanup(); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleDragEnd
    // RESUMEN: Maneja la finalización de una operación de arrastre.
    // ===================================================================
    function handleDragEnd(e) { if (!isEditMode) return; handleDragEndCleanup(); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleDragEndCleanup
    // RESUMEN: Limpia las variables y estilos de la operación de arrastre.
    // ===================================================================
    function handleDragEndCleanup() { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } draggedItem = null; draggedItemIndex = null; dragOverIndex = null; }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleTouchStart
    // RESUMEN: Maneja el inicio de un toque para el arrastre en dispositivos táctiles.
    // ===================================================================
    function handleTouchStart(e) { if (!isEditMode || e.touches.length !== 1) return; draggedItem = e.currentTarget; draggedItemIndex = parseInt(draggedItem.dataset.index); const touch = e.touches[0]; touchStartX = touch.clientX; touchStartY = touch.clientY; draggedItem.classList.add('dragging'); currentTouchTarget = draggedItem; }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleTouchMove
    // RESUMEN: Maneja el movimiento del dedo durante el arrastre táctil.
    // ===================================================================
    function handleTouchMove(e) { if (!isEditMode || !draggedItem || e.touches.length !== 1) return; e.preventDefault(); const touch = e.touches[0]; const elementOver = document.elementFromPoint(touch.clientX, touch.clientY); const targetCell = elementOver?.closest('.grid-cell'); const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetCell && targetIndex !== dragOverIndex) { if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } if (targetIndex !== draggedItemIndex) { targetCell.classList.add('drag-over'); dragOverIndex = targetIndex; currentTouchTarget = targetCell; } else { dragOverIndex = null; currentTouchTarget = draggedItem; } } else if (!targetCell && dragOverIndex !== null) { if (cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } dragOverIndex = null; currentTouchTarget = null; } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleTouchEnd
    // RESUMEN: Maneja la finalización de un arrastre táctil.
    // ===================================================================
    function handleTouchEnd(e) { if (!isEditMode || !draggedItem) return; if (dragOverIndex !== null && dragOverIndex !== draggedItemIndex) { performInsertAndSave(draggedItemIndex, dragOverIndex); e.preventDefault(); } else { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } } handleTouchEndCleanup(); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleTouchCancel
    // RESUMEN: Maneja la cancelación de un arrastre táctil.
    // ===================================================================
    function handleTouchCancel(e) { if (!isEditMode) return; handleTouchEndCleanup(); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleTouchEndCleanup
    // RESUMEN: Limpia las variables y estilos de la operación de arrastre táctil.
    // ===================================================================
    function handleTouchEndCleanup() { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } draggedItem = null; draggedItemIndex = null; dragOverIndex = null; currentTouchTarget = null; touchStartX = 0; touchStartY = 0; }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: normalizeText
    // RESUMEN: Normaliza un texto (minúsculas, sin acentos) para facilitar comparaciones.
    // ===================================================================
    function normalizeText(text) { if (!text) return ''; return text.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, ''); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: filterGridItems
    // RESUMEN: Filtra los elementos del grid según el texto del filtro y los toggles de sección.
    // ===================================================================
    function filterGridItems() {
        const filterInput = document.getElementById('grid-filter-input');
        const clearButton = document.getElementById('clear-filter-button');
        if (!filterInput || !clearButton || !cellElements || cellElements.length === 0) { return; }
        if (isKeywordAssignmentMode) {
            cellElements.forEach(cellContainer => { cellContainer.classList.remove('hidden'); });
            clearButton.style.display = filterInput.value.trim() ? 'inline-block' : 'none';
            return;
        }
        const rawFilterText = filterInput.value.trim();
        clearButton.style.display = rawFilterText ? 'inline-block' : 'none';
        const filterWords = rawFilterText.split(/\s+/).filter(word => word.length > 0).map(word => normalizeText(word));
        const onOffToggleElem = document.getElementById('on-off-toggle');
        const masterState = onOffToggleElem ? (onOffToggleElem.dataset.state || 'on') : 'on';
        cellElements.forEach((cellContainer, index) => {
            const isMasterOff = masterState === 'off';
            if (isMasterOff) {
                cellContainer.classList.add('hidden');
                return;
            }
            const bookmark = currentBookmarks[index];
            const bookmarkName = bookmark ? normalizeText(bookmark.name) : '';
            const isEmptySlot = !bookmark;
            let matchesFilter = true;
            if (filterWords.length > 0) {
                if (isEmptySlot) {
                    matchesFilter = false;
                } else {
                    matchesFilter = filterWords.every(word => bookmarkName.includes(word));
                }
            }
            const shouldBeHiddenByFilter = filterWords.length > 0 && !matchesFilter;
            let shouldBeHiddenByToggles = false;
            const containingRange = getSectionForIndex(index);
            if (containingRange) {
                const toggleButton = toggleButtonElements[containingRange.start] || document.querySelector(`.range-toggle[data-range-start="${containingRange.start}"]`);
                if (toggleButton) {
                    const toggleState = toggleButton.dataset.state || 'visible';
                    shouldBeHiddenByToggles = toggleState === 'hidden';
                }
            } else {
                shouldBeHiddenByToggles = false;
            }
            const shouldBeHidden = shouldBeHiddenByToggles || shouldBeHiddenByFilter;
            cellContainer.classList.toggle('hidden', shouldBeHidden);
        });
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: promptForPin
    // RESUMEN: Muestra el modal para introducir el PIN de acceso.
    // ===================================================================
    function promptForPin() { const pinModal = document.getElementById('pin-modal-overlay'); const pinInput = document.getElementById('pin-input'); const pinSubmit = document.getElementById('pin-submit-button'); const pinError = document.getElementById('pin-error-message'); pinModal.classList.remove('hidden');
        pinInput.value = ''; pinError.textContent = ''; pinInput.focus(); const newPinSubmit = pinSubmit.cloneNode(true); pinSubmit.parentNode.replaceChild(newPinSubmit, pinSubmit); newPinSubmit.addEventListener('click', checkPin); pinInput.addEventListener('keyup', (event) => { if (event.key === 'Enter') { checkPin(); } }); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: checkPin
    // RESUMEN: Verifica el PIN introducido por el usuario.
    // ===================================================================
    function checkPin() { const pinModal = document.getElementById('pin-modal-overlay'); const pinInput = document.getElementById('pin-input'); const pinError = document.getElementById('pin-error-message'); const enteredPin = pinInput.value; if (enteredPin === storedPin) { pinModal.classList.add('hidden'); initializeApp(); } else { pinError.textContent = 'Clave incorrecta.'; pinInput.value = ''; pinInput.focus(); if (navigator.vibrate) navigator.vibrate(100); } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handlePasswordToggleClick
    // RESUMEN: Activa o desactiva la solicitud de PIN al inicio.
    // ===================================================================
    function handlePasswordToggleClick() { if (!storedPin) { showToast('Primero establece una clave en Configuración -> Usuario.', 'warning'); return; } isPasswordActive = !isPasswordActive; updatePasswordToggleIcon(); saveSettings(); showToast(`Solicitar clave al inicio: ${isPasswordActive ? 'Activado' : 'Desactivado'}`, 'info'); }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updatePasswordToggleIcon
    // RESUMEN: Actualiza el icono del candado según si el PIN está activo o no.
    // ===================================================================
    function updatePasswordToggleIcon() { const passwordButton = document.getElementById('password-toggle-button'); if (passwordButton) { const img = passwordButton.querySelector('img'); if(img) { const iconPath = isPasswordActive ? 'IMG_4281.png' : 'IMG_4280.png'; img.src = `https://boardinggate.github.io/Tesla/${iconPath}`;
        img.alt = isPasswordActive ? 'Clave Activada' : 'Clave Desactivada'; passwordButton.title = `Clave al inicio: ${isPasswordActive ? 'Activada' : 'Desactivada'}`; } } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: savePinSettings
    // RESUMEN: Guarda las nuevas configuraciones de PIN y preferencias de inicio.
    // ===================================================================
    function savePinSettings() {
        const pinSetInput = document.getElementById('config-pin-set');
        const pinConfirmInput = document.getElementById('config-pin-confirm');
        const pinStatus = document.getElementById('config-pin-status');
        const directToNavCheckbox = document.getElementById('config-direct-to-nav');
        const newPin = pinSetInput.value;
        const confirmPin = pinConfirmInput.value;
        pinStatus.textContent = '';
        let keySaved = false;
        let prefSaved = false;
        if (newPin || confirmPin) {
            if (!/^\d{4}$/.test(newPin)) {
                pinStatus.textContent = 'La clave debe tener exactamente 4 cifras.';
                pinStatus.style.color = '#EF4444';
                return;
            }
            if (newPin !== confirmPin) {
                pinStatus.textContent = 'Las claves no coinciden.';
                pinStatus.style.color = '#EF4444';
                return;
            }
            try {
                localStorage.setItem('password_pin', newPin);
                storedPin = newPin;
                if (!localStorage.getItem('password_active') || isPasswordActive) {
                    isPasswordActive = true;
                    localStorage.setItem('password_active', 'true');
                }
                pinStatus.textContent = 'Clave guardada. ';
                pinStatus.style.color = '#28a745';
                pinSetInput.value = '';
                pinConfirmInput.value = '';
                updatePasswordToggleIcon();
                keySaved = true;
            } catch (e) {
                pinStatus.textContent ='Error al guardar la clave.';
                pinStatus.style.color = '#EF4444';
                showToast('Error al guardar la clave.', 'error');
            }
        }
        const directToNavChecked = directToNavCheckbox.checked;
        localStorage.setItem(DIRECT_TO_NAVIGATION_KEY, JSON.stringify(directToNavChecked));
        prefSaved = true;
        if (keySaved && prefSaved) {
            showToast('Clave y preferencia de inicio guardadas.', 'success');
            pinStatus.textContent += (pinStatus.textContent ? "Y " : "") + "Preferencia de inicio guardada.";
             pinStatus.style.color = '#28a745';
        } else if (keySaved) {
            showToast('Clave guardada. Preferencia de inicio también actualizada.', 'success');
             pinStatus.textContent += (pinStatus.textContent ? " " : "") + "Preferencia de inicio guardada.";
             pinStatus.style.color = '#28a745';
        } else if (prefSaved) {
            showToast('Preferencia de inicio guardada.', 'success');
            pinStatus.textContent = "Preferencia de inicio guardada.";
            pinStatus.style.color = '#28a745';
        } else if (!newPin && !confirmPin) {
             pinStatus.textContent = "No se realizaron cambios en la clave. Preferencia de inicio no cambió.";
             pinStatus.style.color = '#17a2b8';
        }
        saveSettings();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: removePinSettings
    // RESUMEN: Elimina la configuración de PIN de acceso.
    // ===================================================================
    function removePinSettings() { const pinStatus = document.getElementById('config-pin-status'); if (confirm('¿Estás seguro de que deseas eliminar la clave de acceso? Ya no se solicitará al inicio.')) { try { localStorage.removeItem('password_pin'); localStorage.setItem('password_active', 'false'); storedPin = null; isPasswordActive = false; pinStatus.textContent = 'Clave eliminada.'; pinStatus.style.color = '#17a2b8'; document.getElementById('config-pin-set').value = ''; document.getElementById('config-pin-confirm').value = ''; updatePasswordToggleIcon(); saveSettings(); showToast('Clave eliminada.', 'info'); } catch (e) { pinStatus.textContent = 'Error al eliminar la clave.'; pinStatus.style.color = '#EF4444'; showToast('Error al eliminar la clave.', 'error'); } } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getRemoteUpdatesDate
    // RESUMEN: Obtiene la fecha de la última actualización de un archivo remoto.
    // ===================================================================
    async function getRemoteUpdatesDate() { try { const response = await fetch('https://boardinggate.github.io/Tesla/updates.txt', { cache: 'no-cache' }); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const text = await response.text(); const firstLine = text.split('\n')[0].trim(); const dateMatch = firstLine.match(/^\d{4}-\d{2}-\d{2}/); if (dateMatch) { const [year, month, day] = dateMatch[0].split('-').map(Number); const remoteDate = new Date(Date.UTC(year, month - 1, day)); if (!isNaN(remoteDate.getTime())) { return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`; } } return null; } catch (e) { return null; } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: isRemoteDateNewer
    // RESUMEN: Compara si una fecha remota es más reciente que una fecha en caché.
    // ===================================================================
    function isRemoteDateNewer(remoteDateStr, cachedDateStr) { if (!remoteDateStr) return false; if (!cachedDateStr) return true; try { return remoteDateStr > cachedDateStr; } catch (e) { return false; } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: checkVersionsIconOpacity
    // RESUMEN: Ajusta la opacidad del icono de versiones si hay actualizaciones nuevas.
    // ===================================================================
    async function checkVersionsIconOpacity() { const versionsIcon = document.getElementById('versions-button'); const versionsImg = versionsIcon ? versionsIcon.querySelector('img') : null; if (!versionsImg) return;
        let showAsNew = false; const remoteDateStr = await getRemoteUpdatesDate();
        if (remoteDateStr) { showAsNew = isRemoteDateNewer(remoteDateStr, lastUpdatesCheckDate); } versionsImg.style.opacity = showAsNew ? '1.0' : '0.1';
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showVersionsModal
    // RESUMEN: Muestra el modal con el historial de versiones.
    // ===================================================================
    async function showVersionsModal() {
        const versionsModalOverlay = document.getElementById('versions-modal-overlay');
        const versionsContent = document.getElementById('versions-content');
        const closeButton = document.getElementById('close-versions-modal');
        if (!versionsModalOverlay || !versionsContent || !closeButton) return;
        const newCloseButton = closeButton.cloneNode(true);
        closeButton.parentNode.replaceChild(newCloseButton, closeButton);
        const closeHandler = () => {
            versionsModalOverlay.classList.add('hidden');
            clearModalAutoCloseTimer(versionsModalOverlay, newCloseButton, 'versions-modal');
        };
        newCloseButton.addEventListener('click', closeHandler);
        versionsContent.textContent = 'Cargando histórico...';
        versionsModalOverlay.classList.remove('hidden');
        addModalAutoCloseTimer(versionsModalOverlay, newCloseButton, 'versions-modal');
        try {
            const response = await fetch('https://boardinggate.github.io/Tesla/updates.txt', { cache: 'no-cache' });
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const text = await response.text();
            versionsContent.textContent = text;
            const firstLine = text.split('\n')[0].trim();
            const dateMatch = firstLine.match(/^\d{4}-\d{2}-\d{2}/);
            let dateToStore = null;
            if (dateMatch) {
                const [year, month, day] = dateMatch[0].split('-').map(Number);
                const checkDate = new Date(Date.UTC(year, month - 1, day));
                if (!isNaN(checkDate.getTime())) {
                    dateToStore = dateMatch[0];
                }
            }
            if (dateToStore) {
                lastUpdatesCheckDate = dateToStore;
            } else {
                const today = new Date();
                lastUpdatesCheckDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
            }
            saveSettings();
            await checkVersionsIconOpacity();
        } catch (e) {
            versionsContent.textContent = `Error al cargar el histórico:\n${e.message}`;
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getCurrentLocation
    // RESUMEN: Obtiene la ubicación actual del dispositivo a través de la API de Geolocalización.
    // ===================================================================
    function getCurrentLocation(callback, errorCallback) {
        if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    callback({
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy,
                        altitude: position.coords.altitude,
                        heading: position.coords.heading,
                        speed: position.coords.speed
                    });
                },
                (error) => {
                    let message = "No se pudo obtener la ubicación.";
                    switch (error.code) {
                        case error.PERMISSION_DENIED:
                            message = "Permiso de ubicación denegado.";
                            break;
                        case error.POSITION_UNAVAILABLE:
                            message = "Información de ubicación no disponible.";
                            break;
                        case error.TIMEOUT:
                            message = "Timeout obteniendo ubicación.";
                            break;
                    }
                    if (errorCallback) errorCallback(message);
                    else showToast(message, "error");
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        } else {
            const message = "Geolocalización no soportada por este navegador.";
            if (errorCallback) errorCallback(message);
            else showToast(message, "error");
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: calculateDistance
    // RESUMEN: Calcula la distancia en metros entre dos coordenadas geográficas.
    // ===================================================================
    function calculateDistance(lat1, lon1, lat2, lon2) {
        if (typeof lat1 !== 'number' || typeof lon1 !== 'number' || typeof lat2 !== 'number' || typeof lon2 !== 'number' || isNaN(lat1) || isNaN(lon1) || isNaN(lat2) || isNaN(lon2)) {
             return Infinity;
        }
        const R = 6371e3; const φ1 = lat1 * Math.PI / 180; const φ2 = lat2 * Math.PI / 180; const Δφ = (lat2 - lat1) * Math.PI / 180; const Δλ = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return R * c;
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: parseReminderText
    // RESUMEN: Parsea el texto de un recordatorio para extraer fecha, hora, repetición, etc.
    // ===================================================================
    function parseReminderText(text, elementsToUpdate = null) {
        const result = { text: `<b>${text.trim().toUpperCase()}</b>`, time: null, date: null, repeatDays: [], intervalDays: null, type: null, isLocationEnabled: false, locationCoordinates: null, radiusMeters: 350, excludeFromList: false };
        let norm = text.toUpperCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        const numW = { 'UNA': 1, 'UNO': 1, 'DOS': 2, 'TRES': 3, 'CUATRO': 4, 'CINCO': 5, 'SEIS': 6, 'SIETE': 7, 'OCHO': 8, 'NUEVE': 9, 'DIEZ': 10, 'ONCE': 11, 'DOCE': 12, 'TRECE': 13, 'CATORCE': 14, 'QUINCE': 15, 'DIECISEIS': 16, 'DIECISIETE': 17, 'DIECIOCHO': 18, 'DIECINUEVE': 19, 'VEINTE': 20, 'VEINTIUNO': 21, 'VEINTIDOS': 22, 'VEINTITRES': 23, 'VEINTICUATRO': 24, 'VEINTICINCO': 25, 'VEINTISEIS': 26, 'VEINTISIETE': 27, 'VEINTIOCHO': 28, 'VEINTINUEVE': 29, 'TREINTA': 30, 'TREINTAYUNO': 31 }; const tRgx = /\b(\d{1,2}):(\d{2})\b/; const ttRgx = /.*\bA\s*LAS?\s*(\d+|\w+)\s*(?:Y\s*(CUARTO|MEDIA|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA)|MENOS\s*(CUARTO|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA))?\s*(DE\s*LA\s*(MANANA|TARDE|NOCHE))?/i; const tM = norm.match(tRgx); if (tM) { let h = parseInt(tM[1]); let m = parseInt(tM[2]); if (h >= 0 && h <= 23 && m >= 0 && m <= 59) result.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`; } else { const ttM = norm.match(ttRgx); if (ttM) { let h = numW[ttM[1].toUpperCase()] || parseInt(ttM[1]); if (!isNaN(h)) { const minTxt = ttM[2]?.toUpperCase() || ''; const minus = ttM[3]?.toUpperCase() || ''; const period = ttM[5]?.toUpperCase() || null; let m = 0; if (minTxt) m = minTxt === 'CUARTO' ? 15 : minTxt === 'MEDIA' ? 30 : numW[minTxt] || parseInt(minTxt) || 0; else if (minus) { m = minus === 'CUARTO' ? 15 : numW[minus] || parseInt(minus) || 0; h = (h - 1 + 24) % 24; m = (60 - m + 60) % 60; } if (period) { if (period === 'TARDE' && h >= 1 && h <= 11) h += 12; if (period === 'NOCHE' && h >= 1 && h <= 11) h += 12; if (period === 'MANANA' && h === 12) h = 0; if (period === 'TARDE' && h === 12) h = 12; if (period === 'NOCHE' && h === 12) h = 0; } else if (h >= 1 && h <= 5) h += 12; if (h >= 0 && h <= 23 && m >= 0 && m <= 59) result.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`; } } } const daysMap = { 'LUNES': 1, 'MARTES': 2, 'MIERCOLES': 3, 'MIÉRCOLES': 3, 'JUEVES': 4, 'VIERNES': 5, 'SABADO': 6, 'SÁBADO': 6, 'DOMINGO': 0 }; const wRgx = /(TODOS\s+LOS|LOS|CADA)?\s*(LUNES|MARTES|MIERCOLES|MIÉRCOLES|JUEVES|VIERNES|SABADO|SÁBADO|DOMINGO)/g; let wM; while ((wM = wRgx.exec(norm)) !== null) { const day = daysMap[wM[2]]; if (day !== undefined && !result.repeatDays.includes(day)) result.repeatDays.push(day); }
        const now = new Date(); const manDRgx = /(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{2}|\d{4})\b/; const manDM = norm.match(manDRgx);
        if (manDM && !result.date) { let d = parseInt(manDM[1]); let m = parseInt(manDM[2]); let y = parseInt(manDM[3]); if (y >= 0 && y <= 99) y += 2000; if (d >= 1 && d <= 31 && m >= 1 && m <= 12 && y >= 2000 && y <= 2099) { const tD = new Date(Date.UTC(y, m - 1, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() + 1 === m && tD.getUTCFullYear() === y) { result.date = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } } }
        const todayRgx = /\bHOY\b/; const tomRgx = /\bMANANA\b/; const dayAftRgx = /\bPASADO\s*MANANA\b/;
        if (!result.date) { if (norm.match(todayRgx)) { result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (norm.match(dayAftRgx)) { const tD = new Date(now); tD.setDate(now.getDate() + 2); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } else if (norm.match(tomRgx)) { const tD = new Date(now); tD.setDate(now.getDate() + 1); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } }
        const dndRgx = /(?:EL\s*(PROXIMO)?\s*)?(LUNES|MARTES|MIERCOLES|MIÉRCOLES|JUEVES|VIERNES|SABADO|SÁBADO|DOMINGO)/i; const dndM = norm.match(dndRgx);
        if (dndM && !result.date) { const tDN = dndM[2].toUpperCase(); const tD = daysMap[tDN]; if (tD !== undefined) { const curD = now.getDay(); let dU = (tD - curD + 7) % 7; if (dU === 0) dU = 7; if (dndM[1]?.toUpperCase() === 'PROXIMO') dU += 7; const target = new Date(now); target.setDate(now.getDate() + dU); result.date = `${target.getFullYear()}-${(target.getMonth() + 1).toString().padStart(2, '0')}-${target.getDate().toString().padStart(2, '0')}`; } }
        const didRgx = /DENTRO\s*DE\s*(\d+)\s*DIAS?/; const didM = norm.match(didRgx);
        if (didM && !result.date) { const d = parseInt(didM[1]); if (!isNaN(d) && d > 0) { const tD = new Date(now); tD.setDate(now.getDate() + d); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } }
        const dsdRgx = /\bEL\s*DIA\s*(\d{1,2})\b/; const dsdM = norm.match(dsdRgx);
        if (dsdM && !result.date) { const d = parseInt(dsdM[1]); if (!isNaN(d) && d >= 1 && d <= 31) { let tM = now.getMonth(); let tY = now.getFullYear(); if (d < now.getDate()) { tM++; if (tM > 11) { tM = 0; tY++; } } const tD = new Date(Date.UTC(tY, tM, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() === tM) { result.date = `${tY}-${(tM + 1).toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } } }
        const intRgx = /CADA\s*(\d+)\s*DIAS?/; const intM = norm.match(intRgx);
        if (intM) { result.intervalDays = parseInt(intM[1]); if (!result.date) { result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } }
        const timRgx = /(ALARMA|AVISO|AVISAR|AVISARME|AVÍSAME|TEMPORIZADOR|TIMER|RECORDAR|RECORDARME|RECUÉRDAME)\b.*?\b(\d+|\w+)\s*(MINUTOS?|HORAS?|MINS?|HRS?)/i; const timM = norm.match(timRgx);
        if (timM) { const valStr = timM[2]; const unit = timM[3]?.toUpperCase(); let val = numW[valStr.toUpperCase()] || parseInt(valStr); if (!isNaN(val) && val > 0 && unit) { let tmc = 0; if (unit.startsWith('HORA') || unit.startsWith('HR')) { tmc = val * 60; } else if (unit.startsWith('MINUTO') || unit.startsWith('MIN')) { tmc = val; }
                if (tmc > 0) { const endT = new Date(Date.now() + tmc * 60000); result.date = `${endT.getFullYear()}-${(endT.getMonth() + 1).toString().padStart(2, '0')}-${endT.getDate().toString().padStart(2, '0')}`; result.time = `${endT.getHours().toString().padStart(2, '0')}:${endT.getMinutes().toString().padStart(2, '0')}`; result.repeatDays = []; result.intervalDays = null; result.type = 'simple'; } } }
        const locationPhrases = ["EN EL LUGAR", "EN EL SITIO", "EN LA UBICACION", "EN LA LOCALIZACION"]; if (locationPhrases.some(phrase => norm.includes(phrase))) { result.isLocationEnabled = true; }
        const radiusRgx = /(?:RADIO|MARGEN)\s*DE\s*(\d+)\s*METROS?/i; const radiusMatch = norm.match(radiusRgx);
        if (radiusMatch && radiusMatch[1]) { const parsedRadius = parseInt(radiusMatch[1]); if (!isNaN(parsedRadius) && parsedRadius > 0) { result.radiusMeters = parsedRadius; result.isLocationEnabled = true; } }
        const excludePhrases = ["NO LISTAR", "NO MOSTRAR EN LISTA", "EXCLUIR LISTA", "OCULTAR LISTA", "RADAR"]; if (excludePhrases.some(phrase => norm.includes(phrase))) { result.excludeFromList = true; }
        if (norm.toUpperCase().startsWith("<b>RADAR:") && result.radiusMeters === 350 && !radiusMatch) {
            result.radiusMeters = 350;
        } else if (result.radiusMeters === 350 && !norm.toUpperCase().startsWith("<b>RADAR:") && !radiusMatch && !excludePhrases.some(phrase => norm.includes(phrase))) {
            result.radiusMeters = 350;
        }
        if (result.type === null) {
            if (result.intervalDays !== null && result.date) { result.type = 'interval'; } else if (result.repeatDays.length > 0 && result.time) { result.type = 'weekly'; } else if (result.date && result.time) { result.type = 'daily'; } else if (result.time) { result.type = 'daily'; if (!result.date) result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (result.date) { result.type = 'daily'; } else { result.type = 'simple'; } }
        if (!result.time && (result.type === 'daily' || result.type === 'weekly' || result.type === 'interval' )) { result.time = '00:01'; }
        if (elementsToUpdate) {
             if (elementsToUpdate.locationCheckbox) { const shouldBeChecked = result.isLocationEnabled; if (elementsToUpdate.locationCheckbox.checked !== shouldBeChecked && !elementsToUpdate.mapExpandedManually) { elementsToUpdate.locationCheckbox.checked = shouldBeChecked; } }
             if (elementsToUpdate.radiusInput) { elementsToUpdate.radiusInput.value = result.radiusMeters; }
             if (!elementsToUpdate.manualTimeInput && elementsToUpdate.timeInput && result.time) { elementsToUpdate.timeInput.value = result.time; }
             if (elementsToUpdate.dateInput && result.date) { const dateParts = result.date.split('-');
             if(dateParts.length === 3) { elementsToUpdate.dateInput.value = `${dateParts[2]}/${dateParts[1]}/${dateParts[0]}`; } else { elementsToUpdate.dateInput.value = ''; } } else if (elementsToUpdate.dateInput) { elementsToUpdate.dateInput.value = ''; }
             if (elementsToUpdate.intervalInput) { elementsToUpdate.intervalInput.value = result.intervalDays || ''; }
             if (elementsToUpdate.repeatCheckboxes && result.repeatDays && result.repeatDays.length > 0) { elementsToUpdate.repeatCheckboxes.forEach(input => { input.checked = result.repeatDays.includes(parseInt(input.value)); }); } else if (elementsToUpdate.repeatCheckboxes) { elementsToUpdate.repeatCheckboxes.forEach(input => { input.checked = false; }); }
             if (elementsToUpdate.excludeFromListCheckbox) { elementsToUpdate.excludeFromListCheckbox.checked = result.excludeFromList; }
        } return result;
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showHelpModal
    // RESUMEN: Muestra el modal de ayuda con ejemplos de uso para crear recordatorios.
    // ===================================================================
    function showHelpModal(options = {}) {
        const modal = document.createElement('div'); modal.className = 'help-modal'; modal.setAttribute('aria-label', 'Ayuda recordatorios');
        modal.innerHTML = `
            <h2 class="text-2xl font-bold">Ayuda Recordatorios</h2>
            <div class="modal-top-buttons" style="justify-content: flex-end;">
                <button type="button" id="close-help" style="flex: 0 1 auto; min-width: 120px;">Cerrar</button>
            </div>
            <p class="mb-4">Ejemplos:</p>
            <ul class="list-disc pl-6 mb-4">
                <li><strong>Texto:</strong> "Recordar cita", "Llamar mamá"</li>
                <li><strong>Hora:</strong> "A LAS DIEZ Y CUARTO" → 10:15, "A LAS CINCO Y MEDIA TARDE" → 17:30</li>
                <li><strong>Fecha:</strong> "HOY", "MAÑANA", "DENTRO DE 15 DÍAS", "EL DÍA 22", "PRÓXIMO LUNES", "25/05/2025"</li>
                <li><strong>Repetición:</strong> "CADA LUNES", "TODOS LOS VIERNES Y SÁBADOS"</li>
                <li><strong>Intervalo:</strong> "CADA 7 DÍAS"</li>
                <li><strong>Alarma:</strong> "ALARMA EN 30 MINUTOS", "RECORDAR EN 2 HORAS". Crea recordatorio para fecha/hora exacta.</li>
                <li><strong>Excluir de Lista/Radar:</strong> Añadir "NO LISTAR", "EXCLUIR LISTA" o "RADAR" para ocultarlo de la lista general y que aparezca con chincheta morada en el mapa de ubicaciones.</li>
            </ul>
            <p class="mb-4">Formatos fecha: DD/MM/YYYY, DD-MM-YY, etc.</p>
            <p class="mb-4">Nota: Combina hora, fecha, días, intervalo. Palabra Alarma/Aviso/sar/Recordar/torio/dame,Timer crean alarmas.</p>
            <h3 class="text-xl font-bold mt-6 mb-2">Recordatorios por Ubicación</h3>
            <ul class="list-disc pl-6 mb-4">
                <li><strong>Activar:</strong>
                    <ul>
                        <li>Marca la casilla "Ubicación".</li>
                        <li>O escribe frases como: "EN EL LUGAR", "EN EL SITIO", "EN LA UBICACION", "EN LA LOCALIZACION".</li>
                    </ul>
                </li>
                <li><strong>Ver/Ampliar Mapa (Formulario):</strong>
                    <ul>
                        <li>Pulsa el botón "Ampliar Mapa" que aparece junto al check "Ubicación".</li>
                        <li>Si la ubicación está activa y fijada, verás un pequeño mapa de previsualización debajo.</li>
                    </ul>
                </li>
                <li><strong>Fijar Punto (Formulario):</strong>
                    <ul>
                        <li>Una vez ampliado el mapa, pulsa en él para fijar la ubicación deseada.</li>
                        <li>El mapa ampliado mostrará tu ubicación actual por defecto si concedes permiso y está disponible.</li>
                        <li>Usa el botón <strong style="color:green;">ESTÁS AQUÍ</strong> (en el mapa ampliado del formulario) para centrar rápidamente en tu posición actual y <strong>fijar esa posición como la del recordatorio</strong>. Si pulsas de nuevo vuelves a la anterior.</li>
                    </ul>
                </li>
                <li><strong>Radio de Acción:</strong>
                    <ul>
                        <li>Indica el radio en metros (por defecto ${DEFAULT_LOCATION_RADIUS}m para normales, 350m para "RADAR:") en el campo correspondiente.</li>
                        <li>Puedes escribir "RADIO DE 200 METROS" o "MARGEN DE 500 METROS" en el texto para ajustarlo automáticamente.</li>
                    </ul>
                </li>
                <li><strong>Funcionamiento:</strong> El recordatorio solo saltará si, además de cumplirse la hora/fecha, te encuentras DENTRO del radio de la ubicación guardada.</li>
                <li><strong>Reducir Mapa (Formulario):</strong> Pulsa el botón "REDUCIR MAPA" (visible en el mapa ampliado del formulario) para volver a la vista pequeña de previsualización.</li>
                <li><strong>Ubicaciones Guardadas:</strong> Puedes guardar hasta ${MAX_SAVED_LOCATIONS} ubicaciones frecuentes desde el botón "Ubicaciones" en este formulario. Luego, para usarlas, ve a "Ubicaciones", busca la deseada y pulsa "Seleccionar".</li>
                <li><strong>Mapa General de Ubicaciones/Navegación:</strong>
                    <ul>
                        <li>Accede a él pulsando el icono <img src="RADAR.PNG" alt="Radar Icon" style="width:1em; height:1em; vertical-align:middle; display:inline;"> en la barra superior.</li>
                        <li>Desde aquí puedes gestionar recordatorios con ubicación (como antes) o planificar y seguir rutas GPS.</li>
                        <li>Al entrar, el mapa está en modo "Planificación de Ruta". Pulsa en el mapa para añadir puntos.
                            Si quieres añadir un punto buscando por dirección, usa el campo de búsqueda <img src="./IMG_4400.png" alt="Campo búsqueda" style="height:1.2em; display:inline; vertical-align:middle;">.
                            El botón de añadir punto de ruta <img src="./ANADIRPUNTO.PNG" alt="Añadir punto" style="height:1.2em; display:inline; vertical-align:middle;"> estará visible si hay texto en el campo de búsqueda y está antes pegado a él.
                            El botón de ordenar etapas <img src="./MOVER.PNG" alt="Ordenar etapas" style="height:1.2em; display:inline; vertical-align:middle;"> está a la izquierda del de añadir punto de ruta.
                        </li>
                        <li>Consulta la ayuda específica del "Mapa de Navegación" (botón AYUDA <img src="./IMG_4326.PNG" alt="Ayuda" style="height:1.2em; display:inline; vertical-align:middle;"> en ese mapa) para más detalles sobre la planificación de rutas y navegación.</li>
                         <li>En la barra de progreso de la navegación, pulsa el icono de la maniobra para mostrar una vista de minimapa detallada de la próxima intersección.</li>
                    </ul>
                </li>
            </ul>
            <p class="mb-4">Usa micrófono para voz.</p>
        `;
        const parent = options.parentContainer || document.body;
        parent.appendChild(modal);
        const closeHelpButton = modal.querySelector('#close-help');
        const closeHandler = () => { clearModalAutoCloseTimer(modal, closeHelpButton, 'help-modal'); if (modal.parentNode) modal.parentNode.removeChild(modal); };
        closeHelpButton.addEventListener('click', closeHandler); addModalAutoCloseTimer(modal, closeHelpButton, 'help-modal');
    }
    
    
    
    
    
    
    








    



    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: markReminderAsManaged
    // RESUMEN: Marca un recordatorio como "gestionado" por el usuario para ocultarlo temporalmente.
    // ===================================================================
    function markReminderAsManaged(reminderId, managedState = true) {
         if (typeof reminderId !== 'number') { return; } try { let reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); const index = reminders.findIndex(r => r.id === reminderId); if (index !== -1) { if (reminders[index].managedByUser !== managedState) { reminders[index].managedByUser = managedState; localStorage.setItem('reminders', JSON.stringify(reminders)); markCacheAsDirty(); } } } catch (e) { }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: addSlideButtonListeners
    // RESUMEN: Añade los listeners a los botones de un slide de recordatorio en la ventana unificada.
    // ===================================================================
    function addSlideButtonListeners(slideElement, reminder) {
        const reminderId = reminder.id;
        const cancelButton = slideElement.querySelector('.cancel');
        const adjustTimeButton = slideElement.querySelector('.adjust-time-0001');
        const cancelCyclicButton = slideElement.querySelector('.cancel-cyclic');
        const modifyButton = slideElement.querySelector('.modify');
        const postponeButton = slideElement.querySelector('.postpone');
        const routeRadarVistoButton = slideElement.querySelector('.route-radar-seen');
        const handleInteraction = (actionFn) => {
            markReminderAsManaged(reminderId, true);
            actionFn();
            updateUnifiedWindowUI(processedReminderId);
        };
        let processedReminderId = reminderId;
        if (routeRadarVistoButton) {
            routeRadarVistoButton.addEventListener('click', () => {
                const minutesToSnooze = 5;
                const snoozeEndTime = Date.now() + minutesToSnooze * 60 * 1000;
                snoozedRouteRadars.set(reminderId, snoozeEndTime);
                markReminderAsManaged(reminderId, true);
                showToast(`Radar pospuesto ${minutesToSnooze} minutos`, 'info');
                updateUnifiedWindowUI(reminderId);
            });
        }
        if (cancelButton) {
            cancelButton.addEventListener('click', () => { 
                if (reminder.isFromRuta === true) { 
                    showToast(`Radar en ruta "${reminder.text.replace(/<[^>]*>/g, '')}" marcado como visto para esta alerta.`, 'info');
                    updateUnifiedWindowUI(reminder.id); 
                    markReminderAsManaged(reminder.id, true); 
                } else { 
                    handleInteraction(() => { 
                        let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                        const index = rems.findIndex(r => r.id === processedReminderId); 
                        if (index === -1) {
                            showToast("Error: No se encontró el recordatorio en localStorage para actualizar.", "error");
                            return;
                        }
                        const currentReminder = rems[index];
                        let needsSave = false;
                        const isRadarTypeStored = currentReminder.text.toUpperCase().includes("RADAR:") || currentReminder.excludeFromList;
                        if (isRadarTypeStored) { 
                           const minutesToPostponeRadar = 15;
                           const { newDateISO, newTime } = calculatePostponedDateTime(minutesToPostponeRadar);
                           rems[index].date = newDateISO;
                           rems[index].time = newTime;
                           rems[index].managedByUser = false;
                           needsSave = true;
                           showToast(`Radar guardado pospuesto ${minutesToPostponeRadar} minutos`, 'info');
                        } else if (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval')) {
                           const minutesToPostponeLocation = 15; 
                           const { newDateISO, newTime } = calculatePostponedDateTime(minutesToPostponeLocation);
                           rems[index].date = newDateISO;
                           rems[index].time = newTime;
                           rems[index].managedByUser = false;
                           needsSave = true;
                           showToast(`Recordatorio de ubicación pospuesto ${minutesToPostponeLocation} minutos`, 'info');
                        } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                            let referenceDateForNext = new Date();
                            try {
                                const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                                const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                                const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                                if (!isNaN(reminderDateTime.getTime())) {
                                    referenceDateForNext = new Date(reminderDateTime.getTime() + 60000); 
                                }
                            } catch(er) {  }
                            const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                            if (nextOcc) {
                                rems[index].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                                rems[index].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                                rems[index].managedByUser = false;
                                needsSave = true;
                                showToast('Recordatorio actualizado al próximo ciclo', 'info');
                            } else {
                                rems.splice(index, 1); needsSave = true;
                                showToast('Error calculando siguiente ciclo. Recordatorio eliminado.', 'error');
                            }
                        } else {
                           rems.splice(index, 1);
                           needsSave = true;
                           showToast('Recordatorio inmediato marcado como visto y eliminado.', 'info');
                        }
                        if (needsSave) localStorage.setItem('reminders', JSON.stringify(rems)); 
                    }); 
                } 
            });
        }
        if (adjustTimeButton) {
            adjustTimeButton.addEventListener('click', () => handleInteraction(() => {
                let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                const index = rems.findIndex(r => r.id === processedReminderId);
                if (index === -1) return;
                const currentReminder = rems[index];
                let needsSave = false;
                if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                     let referenceDateForNext = new Date();
                     try {
                         const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                         const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, 0, 1)); 
                         if (!isNaN(reminderDateTime.getTime())) {
                             referenceDateForNext = new Date(reminderDateTime.getTime() + 60000); 
                         }
                     } catch(e) {  }
                    const reminderForCalc = { ...currentReminder, time: '00:01' };
                    const nextOcc = calculateNextOccurrence(reminderForCalc, referenceDateForNext);
                    if (nextOcc) {
                        rems[index].date= `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                        rems[index].time = '00:01';
                        rems[index].managedByUser = false;
                        needsSave = true;
                        showToast('Recordatorio ajustado a 00:01 y actualizado', 'info');
                    } else {
                        rems.splice(index, 1); needsSave = true;
                        showToast('Error calculando siguiente ciclo (ajuste 00:01). Eliminado.', 'error');
                    }
                } else { 
                    rems.splice(index, 1); needsSave = true;
                    showToast('Recordatorio no cíclico eliminado (acción "Ajustar 00:01")', 'info');
                }
                if (needsSave) localStorage.setItem('reminders', JSON.stringify(rems)); 
            }));
        }
        if (cancelCyclicButton) {
            cancelCyclicButton.addEventListener('click', () => handleInteraction(() => {
                if (confirm('¿Estás seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE?')) {
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const initialLength = rems.length;
                    rems = rems.filter(r => r.id !== processedReminderId);
                    if (rems.length < initialLength) {
                       localStorage.setItem('reminders', JSON.stringify(rems)); 
                       showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                    } else {
                        showToast('Error: No se encontró el ciclo para anular.', 'warning');
                    }
                } else {
                    markReminderAsManaged(processedReminderId, false); 
                }
            }));
        }
        if (modifyButton) {
            modifyButton.addEventListener('click', () => {
                markReminderAsManaged(reminder.id, true);
                let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                let reminderToModify = remindersFromStorage.find(r => r.id === reminder.id);
                if (!reminderToModify && reminder.isFromRuta) {
                   reminderToModify = { ...reminder };
                   reminderToModify.isFromRuta = false;
                }
                const mapIsVisible = document.getElementById('reminders-location-map-modal') && !document.getElementById('reminders-location-map-modal').classList.contains('hidden');
                const mapShouldReopenWhenUnifiedCloses = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                const mapContextBeforeUnified = sessionStorage.getItem('mapContext');
                hideUnifiedReminderWindow();
                if (reminderToModify) {
                    if (mapShouldReopenWhenUnifiedCloses) {
                         sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                         if (mapContextBeforeUnified) {
                           sessionStorage.setItem('mapContext', mapContextBeforeUnified);
                         }
                    }
                    showReminderModal(reminderToModify, { onTopOfMap: mapIsVisible });
                }
                else {
                    showToast("Error: no se pudo encontrar el recordatorio para modificar.", "error");
                    updateUnifiedWindowUI(reminder.id);
                    if (mapShouldReopenWhenUnifiedCloses &&
                        sessionStorage.getItem('boardinggate_map_should_reopen_after_form') !== 'true' &&
                        !document.getElementById('reminders-location-map-modal')
                       ) {
                        if (mapContextBeforeUnified === 'navigation') openNavigationMap();
                         sessionStorage.removeItem('mapContext');
                    }
                }
                sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
            });
        }
        if (postponeButton) {
            postponeButton.addEventListener('click', () => {
                markReminderAsManaged(processedReminderId, true); 
                let reminderToPostpone;
                if (reminder.isFromRuta) {
                    showToast(`Radar en ruta "${reminder.text.replace(/<[^>]*>/g, '')}" marcado como visto (acción Posponer).`, 'info');
                    updateUnifiedWindowUI(reminder.id);
                    return; 
                } else {
                    let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                    reminderToPostpone = remindersFromStorage.find(r => r.id === processedReminderId);
                }
                if (reminderToPostpone) {
                    showPostponeOptionsModal(reminderToPostpone, 'unified');
                }
                else {
                    showToast("Error: no se pudo encontrar el recordatorio para posponer", "error");
                    updateUnifiedWindowUI(processedReminderId); 
                }
            });
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: restoreCacheForMobile
    // RESUMEN: Descarga silenciosamente la caché de Firebase al iniciar en móvil.
    // ===================================================================
    async function restoreCacheForMobile() {
        const { primaryId } = parseUserId(localStorage.getItem('userData_userId'));
        if (!primaryId) return;
        const result = await callFirebase('getUserData', { userId: primaryId });
        if (result.status === 'success' && result.data) {
            const backupCacheData = result.data.contenidoCacheCompleto;
            if (backupCacheData) {
                showToast('Sincronizando datos desde la nube...', 'info', 2000);
                const currentUserIdentity = localStorage.getItem('userData_userId');
                for (const key in backupCacheData) {
                    if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                        localStorage.setItem(key, backupCacheData[key]);
                    }
                }
                if (currentUserIdentity) {
                    localStorage.setItem('userData_userId', currentUserIdentity);
                }
                loadCustomData();
                loadSavedSettings();
                updateUserIdDisplay();
                checkReminders();
            }
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: hideUnifiedReminderWindow
    // RESUMEN: Oculta la ventana unificada de recordatorios y limpia sus elementos.
    // ===================================================================
    function hideUnifiedReminderWindow() {
        const windowElement = document.getElementById('unified-reminder-window');
        if (windowElement && windowElement.classList.contains('visible')) {
            windowElement.classList.remove('visible');
            isUnifiedWindowVisibleByLogic = false;
            const swiperContainer = document.getElementById('reminder-swiper-container');
            Object.values(previewMaps).forEach(map => {
                if (map && typeof map.remove === 'function') {
                    map.remove();
                }
            });
            previewMaps = {};
            if (swiperContainer) {
                swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay);
                setTimeout(() => {
                    if (swiperContainer && !windowElement.classList.contains('visible')) {
                        swiperContainer.innerHTML = '';
                    }
                }, 600);
            }
            const hideAllButton = document.getElementById('hide-all-reminders-button');
            if (hideAllButton) { const newHideAllButton = hideAllButton.cloneNode(true); hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton); }
            const mapShouldReopen = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
            const mapContextToReopen = sessionStorage.getItem('mapContext');
            sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
            if (mapShouldReopen &&
                !document.querySelector('.reminder-modal') &&
                !document.querySelector('.reminder-table-modal') &&
                !document.getElementById('reminders-location-map-modal')
               ) {
                 if (mapContextToReopen === 'navigation') openNavigationMap();
                  sessionStorage.removeItem('mapContext');
            }
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: postponeAllVisibleReminders
    // RESUMEN: Pospone todos los recordatorios actualmente visibles en la ventana unificada.
    // ===================================================================
    function postponeAllVisibleReminders() {
        const swiperContainer = document.getElementById('reminder-swiper-container'); if (!swiperContainer) return;
        const visibleSlides = swiperContainer.querySelectorAll('.reminder-slide'); if (visibleSlides.length === 0) return;
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        let updated = false;
        const idsToUpdate = [];
        visibleSlides.forEach(slide => {
            const reminderId = parseInt(slide.dataset.id);
            if (isNaN(reminderId)) return;
            idsToUpdate.push(reminderId);
            const index = reminders.findIndex(r => r.id === reminderId);
            if (index !== -1) {
                const { newDateISO, newTime } = calculatePostponedDateTime(1);
                reminders[index].date = newDateISO;
                reminders[index].time = newTime;
                reminders[index].managedByUser = false;
                updated = true;
            }
        });
        if (updated) {
            localStorage.setItem('reminders', JSON.stringify(reminders));
            showToast(`${idsToUpdate.length} recordatorio(s) pospuesto(s) 1 minuto`, 'info');
            idsToUpdate.forEach(id => updateUnifiedWindowUI(id));
            updateReminderCount();
            updateButtonStyles();
        }
        if (idsToUpdate.length > 0 && document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
           hideUnifiedReminderWindow();
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateReminderIndexDisplay
    // RESUMEN: Actualiza el contador de índice del slide actual en la ventana unificada.
    // ===================================================================
    function updateReminderIndexDisplay() {
        const swiperContainer = document.getElementById('reminder-swiper-container');
        const currentIndexSpan = document.getElementById('current-reminder-index');
        if (!swiperContainer || !currentIndexSpan) return;
        const totalSlides = swiperContainer.querySelectorAll('.reminder-slide').length;
        if (totalSlides === 0) {
            currentIndexSpan.textContent = '0';
            return;
        }
        const containerWidth = swiperContainer.offsetWidth;
        if (containerWidth <= 0) {
           return;
        }
        const currentScroll = swiperContainer.scrollLeft;
        const currentIndex = Math.round(currentScroll / containerWidth);
        currentNotificationSlideIndex = currentIndex;
        const displayIndex = Math.max(1, Math.min(currentIndex + 1, totalSlides));
        currentIndexSpan.textContent = displayIndex;
         const currentSlideElement = swiperContainer.querySelectorAll('.reminder-slide')[currentIndex];
         if (currentSlideElement && !isNavigationMapActive) {
            const mapId = currentSlideElement.querySelector('.reminder-map-preview')?.id;
            if (mapId) {
                 const reminderId = parseInt(mapId.replace('map-preview-', ''));
                 if (previewMaps[reminderId]) {
                     setTimeout(() => { if(previewMaps[reminderId]) previewMaps[reminderId].invalidateSize(); }, 50);
                 }
            }
         }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateUnifiedWindowUI
    // RESUMEN: Actualiza la UI de la ventana unificada después de que un recordatorio es gestionado.
    // ===================================================================
    function updateUnifiedWindowUI(processedReminderId) {
        const windowElement = document.getElementById('unified-reminder-window');
        const swiperContainer = document.getElementById('reminder-swiper-container');
        const slideToRemove = swiperContainer ? swiperContainer.querySelector(`.reminder-slide[data-id="${processedReminderId}"]`) : null;
        if (previewMaps[processedReminderId]) {
           if (typeof previewMaps[processedReminderId].remove === 'function') {
               previewMaps[processedReminderId].remove();
           }
           delete previewMaps[processedReminderId];
        }
        if (slideToRemove && slideToRemove.parentNode === swiperContainer) {
            swiperContainer.removeChild(slideToRemove);
        }
        const remainingSlides = swiperContainer ? swiperContainer.querySelectorAll('.reminder-slide') : [];
        const remainingCount = remainingSlides.length;
        if (remainingCount === 0) {
            hideUnifiedReminderWindow();
        }
        else {
            const countHeader = windowElement.querySelector('.reminder-count-header');
            const countSpan = document.getElementById('total-reminder-count');
            const countTextContainer = document.getElementById('reminder-count-text-container');
            const swipeHint = document.getElementById('reminder-swipe-hint');
            countSpan.textContent = remainingCount;
            updateReminderIndexDisplay();
            if (remainingCount > 1) {
                countTextContainer.style.display = 'inline';
                swipeHint.style.display = 'block';
                document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = 'calc(85vh - 60px)');
            } else {
                countTextContainer.style.display = 'none';
                swipeHint.style.display = 'none';
                document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = '85vh');
            }
            const maxScrollIndex = remainingCount - 1;
            if (currentNotificationSlideIndex > maxScrollIndex) {
                 currentNotificationSlideIndex = maxScrollIndex;
                 swiperContainer.scrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
                 updateReminderIndexDisplay();
            }
        }
        updateReminderCount();
        updateButtonStyles();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: setupReminderTableListeners
    // RESUMEN: Añade los listeners a los botones de la tabla de recordatorios.
    // ===================================================================
    function setupReminderTableListeners(modalTable) {
        modalTable.querySelectorAll('.visto-prox').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#EF4444';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #B91C1C';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true);
                let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderIndex = rems.findIndex(r => r.id === id);
                let needsSave = false;
                const row = newButton.closest('tr');
                if (reminderIndex > -1 && row) {
                     const currentReminder = rems[reminderIndex];
                     if (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval')) {
                        const { newDateISO, newTime } = calculatePostponedDateTime(15);
                        rems[reminderIndex].date = newDateISO;
                        rems[reminderIndex].time = newTime;
                        rems[reminderIndex].managedByUser = false;
                        needsSave = true;
                        const dateCell = row.cells[3]; const timeCell = row.cells[2];
                        if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date);
                        if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                        showToast('Recordatorio con ubicación pospuesto 15 min', 'info');
                    } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                         let referenceDateForNext = new Date();
                         try {
                             const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                             const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                             const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                             if (!isNaN(reminderDateTime.getTime())) {
                                 referenceDateForNext = new Date(reminderDateTime.getTime() + 60000);
                             }
                         } catch(er) { }
                        const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                        if (nextOcc) {
                            rems[reminderIndex].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                            rems[reminderIndex].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                            rems[reminderIndex].managedByUser = false;
                            needsSave = true;
                            const dateCell = row.cells[3]; const timeCell = row.cells[2];
                            if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date);
                            if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                            showToast('Actualizado al próximo periodo', 'info');
                        } else {
                            rems.splice(reminderIndex, 1); needsSave = true;
                            row.remove(); showToast('Error calculando siguiente ciclo. Eliminado.', 'error');
                        }
                    } else {
                        rems.splice(reminderIndex, 1); needsSave = true;
                        row.remove(); showToast('Recordatorio borrado', 'info');
                    }
                    if (needsSave) localStorage.setItem('reminders', JSON.stringify(rems)); 
                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios.</td></tr>`;
                    }
                } else {
                    showToast('Error: Recordatorio no encontrado para actualizar/borrar.', 'error');
                    if(row) row.remove();
                }
                updateReminderCount(); updateButtonStyles(); checkReminders();
            });
        });
        modalTable.querySelectorAll('.postpone').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#F59E0B';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #B45309';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true);
                const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderToPostpone = reminders.find(r => r.id === id);
                if (reminderToPostpone) {
                    if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                    modalTable.remove();
                    showPostponeOptionsModal(reminderToPostpone, 'table');
                } else {
                    showToast('Error: Recordatorio no encontrado para posponer.', 'error');
                    markReminderAsManaged(id, false);
                }
            });
        });
        modalTable.querySelectorAll('.cancel-cyclic-table').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#8B0000';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #580000';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                if (confirm('¿Estás seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE?')) {
                    markReminderAsManaged(id, true);
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const initialLength = rems.length;
                    rems = rems.filter(r => r.id !== id);
                    if (rems.length < initialLength) {
                        localStorage.setItem('reminders', JSON.stringify(rems)); 
                        showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                    } else {
                        showToast('Error: No se encontró el ciclo para anular', 'warning');
                    }
                    const row = newButton.closest('tr');
                    if (row) row.remove();
                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios.</td></tr>`;
                    }
                    updateReminderCount(); updateButtonStyles(); checkReminders();
                }
            });
        });
        const tableBody = modalTable.querySelector('#reminder-table-body');
        if (tableBody) {
            const newTableBody = tableBody.cloneNode(false);
            while(tableBody.firstChild) newTableBody.appendChild(tableBody.firstChild);
            tableBody.parentNode.replaceChild(newTableBody, tableBody);
            newTableBody.addEventListener('click', (e) => {
                if (e.target.closest('td:first-child button')) return;
               const row = e.target.closest('tr[data-id]');
                if (row?.dataset.id) {
                    const id = parseInt(row.dataset.id); if (isNaN(id)) return;
                    markReminderAsManaged(id, true);
                    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const reminderToModify = reminders.find(r => r.id === id);
                    if (reminderToModify) {
                        const mapWasOpenBeforeTable = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                        const mapContextBeforeTable = sessionStorage.getItem('mapContext');
                        if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                        modalTable.remove();
                        if (mapWasOpenBeforeTable) {
                            sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                            if (mapContextBeforeTable) {
                                sessionStorage.setItem('mapContext', mapContextBeforeTable);
                            }
                        }
                        sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                        showReminderModal(reminderToModify);
                    } else {
                        showToast('Error: Recordatorio no encontrado para modificar', 'error');
                        markReminderAsManaged(id, false);
                    }
                }
            });
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showAllReminders
    // RESUMEN: Muestra una tabla con todos los recordatorios.
    // ===================================================================
    function showAllReminders(options = {}) {
         const mapWasOpenBeforeThisTable = isNavigationMapActive;
         if (mapWasOpenBeforeThisTable) {
             sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
             sessionStorage.setItem('mapContext', 'navigation');
         } else {
             sessionStorage.removeItem('boardinggate_map_was_open_before_table');
             sessionStorage.removeItem('mapContext');
         }
         closeOtherModals();
         let allReminders = []; try { allReminders = JSON.parse(localStorage.getItem('reminders') || '[]').map(r => ({ ...r })); } catch(e) { showToast("Error al cargar lista de recordatorios.", "error"); return; }
         const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false; let remindersToDisplay = allReminders;
         if (!showExcluded) { remindersToDisplay = allReminders.filter(r => !r.excludeFromList); }
         remindersToDisplay.sort((a, b) => {
             const nowForSort = new Date(); const nextA = calculateNextOccurrence(a, nowForSort); const nextB = calculateNextOccurrence(b, nowForSort);
             if (nextA && nextB) { const timeDiff = nextA.getTime() - nextB.getTime(); if (timeDiff !== 0) return timeDiff; } else if (nextA) { return -1; } else if (nextB) { return 1; }
             const typeOrder = { 'simple': 1, 'hourly': 2, 'daily': 3, 'weekly': 4, 'interval': 5 }; const typeDiff = (typeOrder[a.type] ?? 99) - (typeOrder[b.type] ?? 99); if (typeDiff !== 0) return typeDiff;
             const createdAtA = a.createdAt ? new Date(a.createdAt).getTime() : 0; const createdAtB = b.createdAt ? new Date(b.createdAt).getTime() : 0; return createdAtA - createdAtB;
         });
         const existingModal = document.querySelector('.reminder-table-modal');
         if (existingModal) { if (existingModal.autoCloseInterval) clearInterval(existingModal.autoCloseInterval); if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal); }
         const modalTable = document.createElement('div');
         modalTable.className = 'reminder-table-modal';
         modalTable.setAttribute('aria-label', 'Tabla recordatorios');
         modalTable.innerHTML = `
            <div class="modal-top-buttons" style="justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <div style="display: flex; align-items: center;">
                    <input type="checkbox" id="show-excluded-reminders" ${showExcluded ? 'checked' : ''} style="transform: scale(1.3);">
                    <label for="show-excluded-reminders" style="margin-left: 0.5rem; font-size: 1.1rem;">MOSTRAR RADARES u OTROS</label>
                </div>
                <h2 style="text-align:center; font-size:1.8rem;color:#333; flex-grow:1; font-weight:bold;">Recordatorios</h2>
                <div style="display: flex; align-items: center;">
                    <button type="button" id="view-all-locations-map" style="white-space: nowrap;">VER UBICACIONES</button>
                    <button type="button" id="close-reminders-top" style="margin-left:10px;">SALIR <span class="button-countdown"></span></button>
                </div>
            </div>
            <table>
                <thead>
                    <tr>
                        <th style="width:12%;">Acciones</th> <th>Texto</th> <th style="width:8%;">Hora</th>
                        <th style="width:10%;">Fecha Prox.</th> <th style="width:15%;">Días Rep.</th>
                        <th style="width:8%;">Cada x días</th> <th style="width:8%;">Geoloc.</th>
                        <th style="width:10%;">Creado</th>
                    </tr>
                </thead>
                <tbody id="reminder-table-body">
                    ${remindersToDisplay.length === 0 ? `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios ${showExcluded ? ' (incluyendo excluidos)' : ''}.</td></tr>` : remindersToDisplay.map(r => { const isCyclic = r.type === 'weekly' || r.type === 'interval'; const rowBackgroundColor = isCyclic ? (r.excludeFromList ? '#C0D8C0' : '#D9E5DB') : (r.excludeFromList ? '#D8BFBF' : '#EAD9D9'); const nextOccurrenceDate = calculateNextOccurrence(r, new Date()); const formattedNextDate = nextOccurrenceDate ? formatDateToDDMMMYY(nextOccurrenceDate.toISOString().split('T')[0]) : formatDateToDDMMMYY(r.date); const timeDisplay = r.time ? r.time : '-'; const geoIndicator = r.isLocationEnabled ? '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#008000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>' : '-'; return `<tr data-id="${r.id}" style="background-color: ${rowBackgroundColor};"> <td> <button class="visto-prox" data-id="${r.id}" title="${isCyclic ? 'Marcar Visto y Avanzar al Próximo Ciclo' : 'Marcar Visto y Borrar'}">Visto/Prox</button> <button class="postpone" data-id="${r.id}" title="Posponer">Posponer</button> ${isCyclic ? `<button class="cancel-cyclic-table" data-id="${r.id}" title="Anular Ciclo Permanente">Anular Ciclo</button>` : ''} </td> <td class="text-column" title="Modificar">${r.text}</td> <td class="time-column">${timeDisplay}</td> <td class="date-column">${formattedNextDate}</td> <td>${r.type === 'weekly' && r.repeatDays?.length > 0 ? r.repeatDays.map(d => ['Dom','Lun','Mar','Mié','Jue','Vie','Sáb'][d]).join(', ') : '-'}</td> <td>${r.type === 'interval' ? r.intervalDays || '-' : '-'}</td> <td>${geoIndicator}</td> <td class="date-column">${r.createdAt ? formatDateToDDMMMYY(r.createdAt.split('T')[0]) : '-'}</td> </tr>`; }).join('')}
                </tbody>
            </table>
             <div class="bottom-button-container" style="margin-top: 1rem; display:flex; justify-content:flex-end;">
                <button type="button" id="close-reminders-bottom">SALIR <span class="button-countdown"></span></button>
            </div>
        `;
         const parent = options.parentContainer || document.body;
         parent.appendChild(modalTable);
         const showExcludedCheckbox = modalTable.querySelector('#show-excluded-reminders');
         if (showExcludedCheckbox) { 
             showExcludedCheckbox.addEventListener('change', () => { 
                 localStorage.setItem(SHOW_EXCLUDED_REMINDERS_KEY, JSON.stringify(showExcludedCheckbox.checked)); 
                 markCacheAsDirty();
                 if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval); 
                 modalTable.remove(); 
                 showAllReminders(); 
            }); 
        }
         const viewLocationsMapButton = modalTable.querySelector('#view-all-locations-map');
         if (viewLocationsMapButton) {
            viewLocationsMapButton.addEventListener('click', () => {
                if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                if (modalTable.parentNode) modalTable.remove();
                setTimeout(() => {
                    openLocationsPreviewMap();
                }, 50);
            });
        }
         let count = 60; const countdownSpans = modalTable.querySelectorAll('.button-countdown'); countdownSpans.forEach(span => span.textContent = `(${count})`);
         const closeClean = () => { clearInterval(modalTable.autoCloseInterval); modalTable.autoCloseInterval = null; if (modalTable.parentNode) modalTable.parentNode.removeChild(modalTable);
             const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true'; sessionStorage.removeItem('boardinggate_map_was_open_before_table');
             const mapContext = sessionStorage.getItem('mapContext'); sessionStorage.removeItem('mapContext');
             if (fromReminderModal) { fromReminderModal = false; if (mapShouldReopen) { sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true'); sessionStorage.setItem('mapContext', mapContext); } showReminderModal(); }
             else if (mapShouldReopen) { if (mapContext === 'navigation') openNavigationMap(); }
         };
         modalTable.autoCloseInterval = setInterval(() => { count--; countdownSpans.forEach(span => span.textContent = `(${count})`); if (count <= 0) { closeClean(); } }, 1000);
         const resetTimer = () => { if (!modalTable.autoCloseInterval) return; clearInterval(modalTable.autoCloseInterval); count = 60; countdownSpans.forEach(span => span.textContent = `(${count})`); modalTable.autoCloseInterval = setInterval(() => { count--; countdownSpans.forEach(span => span.textContent = `(${count})`); if (count <= 0) { closeClean(); } }, 1000); };
         modalTable.addEventListener('click', resetTimer); modalTable.addEventListener('touchstart', resetTimer, { passive: true }); modalTable.addEventListener('input', resetTimer);
         modalTable.querySelector('#close-reminders-top').addEventListener('click', closeClean);
         modalTable.querySelector('#close-reminders-bottom').addEventListener('click', closeClean);
         setupReminderTableListeners(modalTable);
     }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateReminderCount
    // RESUMEN: Actualiza los contadores de recordatorios en la UI.
    // ===================================================================
    function updateReminderCount() {
         let reminders = []; try { reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); } catch (e) { reminders = []; }
         const showExcludedInTable = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false; let remindersForCount = reminders;
         if (!showExcludedInTable) { remindersForCount = reminders.filter(r => !r.excludeFromList); }
         const totalCount = remindersForCount.length; const nonCyclicReminders = remindersForCount.filter(r => r.type !== 'weekly' && r.type !== 'interval'); const nonCyclicCount = nonCyclicReminders.length;
         const countElGlobe = document.getElementById('reminder-count-globe'); if (countElGlobe) { countElGlobe.textContent = nonCyclicCount > 0 ? nonCyclicCount : ''; countElGlobe.style.display = nonCyclicCount > 0 ? 'flex' : 'none'; }
         const reminderButtonElem = document.getElementById('reminder-button'); if (reminderButtonElem) { let countSpanSide = reminderButtonElem.querySelector('.reminder-count'); if (totalCount > 0) { if (!countSpanSide) { countSpanSide = document.createElement('span'); countSpanSide.className = 'reminder-count'; reminderButtonElem.appendChild(countSpanSide); } countSpanSide.textContent = totalCount; } else { if (countSpanSide) { countSpanSide.remove(); } } }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: calculateNextOccurrence
    // RESUMEN: Calcula la próxima fecha de vencimiento de un recordatorio cíclico.
    // ===================================================================
    function calculateNextOccurrence(reminder, referenceDate) {
          if (!reminder || !reminder.type || !reminder.time || !reminder.date) { return null; } try {
              let [year, month, day] = reminder.date.split('-').map(Number); let [hour, minute] = reminder.time.split(':').map(Number);
              let baseDate = new Date(Date.UTC(year, month - 1, day, hour, minute)); if (isNaN(baseDate.getTime())) { return null; }
              const refDateUTC = new Date(referenceDate.getTime()); if (baseDate > refDateUTC) return baseDate;
              if (reminder.type === 'simple') { return null; }
              if (reminder.type === 'daily' || reminder.type === 'hourly') { let next = new Date(baseDate); while (next <= refDateUTC) { next.setUTCDate(next.getUTCDate() + 1); } return next; }
              if (reminder.type === 'weekly' && reminder.repeatDays && reminder.repeatDays.length > 0) {
                  let next = new Date(refDateUTC); next.setUTCHours(hour, minute, 0, 0);
                  if (next <= refDateUTC || !reminder.repeatDays.includes(next.getUTCDay())) { next.setUTCDate(next.getUTCDate() + 1); }
                  for (let i = 0; i < 7; i++) { if (reminder.repeatDays.includes(next.getUTCDay())) { return next; } next.setUTCDate(next.getUTCDate() + 1); } return null;
              }
              if (reminder.type === 'interval' && reminder.intervalDays && reminder.intervalDays > 0) { let next = new Date(baseDate); while (next <= refDateUTC) { next.setUTCDate(next.getUTCDate() + reminder.intervalDays); } return next; }
              return null; } catch (e) { return null; }
     }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: calculatePostponedDateTime
    // RESUMEN: Calcula la fecha y hora para posponer un recordatorio.
    // ===================================================================
    function calculatePostponedDateTime(mins) {
          const now = new Date(); const postponedDate = new Date(now.getTime() + mins * 60000);
          const newDateISO = `${postponedDate.getFullYear()}-${(postponedDate.getMonth() + 1).toString().padStart(2, '0')}-${postponedDate.getDate().toString().padStart(2, '0')}`;
          const newTime = `${postponedDate.getHours().toString().padStart(2, '0')}:${postponedDate.getMinutes().toString().padStart(2, '0')}`; return { newDateISO, newTime };
     }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showPostponeOptionsModal
    // RESUMEN: Muestra un modal con opciones para posponer un recordatorio.
    // ===================================================================
    function showPostponeOptionsModal(reminder, source = 'unified') {
         const existingModal = document.getElementById('postpone-options-modal'); if (existingModal) { if (existingModal.autoPostponeInterval) clearInterval(existingModal.autoPostponeInterval); if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal); }
         const modal = document.createElement('div'); modal.id = 'postpone-options-modal'; modal.className = 'postpone-options';
         modal.style.cssText = `position:fixed; top:10px; left:50%; transform:translateX(-50%); width:90%; max-width:480px; max-height:calc(100vh - 20px); overflow-y:auto; background-color:#F5E1A9; padding:1.5rem; border-radius:1rem; box-shadow:0 10px 25px rgba(0,0,0,0.2); z-index:7500; `;
         modal.setAttribute('aria-label', 'Posponer recordatorio');
         let countdown = 10; const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval'; const defaultMinutes = 15;
         let buttonHtml = ` <button data-minutes="15" class="postpone-option">15 Minutos</button> <button data-minutes="60" class="postpone-option">1 Hora</button> <button data-minutes="180" class="postpone-option">3 Horas</button> `;
         if (!isCyclic) { buttonHtml += ` <button data-minutes="1440" class="postpone-option">1 Día</button> <button data-minutes="4320" class="postpone-option">3 Días</button> `; }
         modal.innerHTML = `
            <style>
                .postpone-options .reminder-text { color:#333; font-size:1.2rem; margin-bottom:.5rem; word-wrap:break-word; }
                .postpone-options .reminder-details { color:#555; font-size:1rem; margin-bottom:1.5rem; }
                .postpone-options .button-group { display:flex; flex-direction:column; gap:1rem; align-items:stretch; }
                .postpone-options button.postpone-option { font-size:1.3rem; font-weight:bold; padding:.8rem 1rem; background-color:#F59E0B; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                .postpone-options button.postpone-option:hover { background-color:#D97706; }
                #postpone-countdown { text-align:center; margin-top:1.8rem; font-size:1.1rem; font-weight:500; color:#444; }
                #postpone-timer-value { font-weight:bold; font-size:1.2rem; }
                #cancel-postpone { margin-top:1.2rem; width:100%; padding:.7rem 1rem; font-size:1.1rem; background-color:#EF4444; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                #cancel-postpone:hover { background-color:#DC2626; }
            </style>
            <div class="modal-top-buttons" style="justify-content: flex-end; margin-bottom: 1rem;">
                 <button id="cancel-postpone" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
            </div>
            <p class="reminder-text">Posponer: ${reminder.text.replace(/<[^>]*>/g, '')}</p>
            <p class="reminder-details">Selecciona tiempo:</p>
            <div class="button-group">
                ${buttonHtml}
            </div>
            <p id="postpone-countdown">Autom&aacute;tico en <span id="postpone-timer-value">${countdown}</span>s (${defaultMinutes} min)</p>
         `;
         document.body.appendChild(modal);
         const countdownDisplay = modal.querySelector('#postpone-timer-value');
         const handlePostpone = (minutes) => {
             if (modal.autoPostponeInterval) clearInterval(modal.autoPostponeInterval); modal.autoPostponeInterval = null;
             updateUnifiedWindowUI(reminder.id);
             let reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); const index = reminders.findIndex(r => r.id === reminder.id);
             if (index === -1) { showToast("Error: Recordatorio no encontrado", "error"); checkReminders(); if (modal.parentNode) document.body.removeChild(modal); return; }
             const { newDateISO, newTime } = calculatePostponedDateTime(minutes); reminders[index].date = newDateISO; reminders[index].time = newTime; reminders[index].managedByUser = false;
             if (!isCyclic) { reminders[index].type = 'daily'; reminders[index].repeatDays = []; reminders[index].intervalDays = null; }
             localStorage.setItem('reminders', JSON.stringify(reminders)); updateReminderCount(); updateButtonStyles(); 
             const durationText = minutes >= 1440 ? `${minutes / 1440} día(s)` : (minutes >= 60 ? `${minutes / 60} hora(s)` : `${minutes} minutos`);
             showToast(`Pospuesto ${durationText}`, 'info');
             if (modal.parentNode) document.body.removeChild(modal);
             if (source === 'table') { setTimeout(showAllReminders, 100); }
             else { const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                 const mapContextToReopen = sessionStorage.getItem('mapContext');
                 if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) { sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); if (!document.getElementById('reminders-location-map-modal')) { if (mapContextToReopen === 'navigation') openNavigationMap(); sessionStorage.removeItem('mapContext');} } } };
         modal.autoPostponeInterval = setInterval(() => { countdown--; if (countdownDisplay) countdownDisplay.textContent = countdown; if (countdown <= 0) { handlePostpone(defaultMinutes); } }, 1000);
         modal.querySelectorAll('.postpone-option').forEach(button => { button.addEventListener('click', () => { const minutes = parseInt(button.dataset.minutes); if (!isNaN(minutes)) { handlePostpone(minutes); } }); });
         modal.querySelector('#cancel-postpone').addEventListener('click', () => {
             clearInterval(modal.autoPostponeInterval); modal.autoPostponeInterval = null; markReminderAsManaged(reminder.id, false); if (modal.parentNode) document.body.removeChild(modal);
             if (source === 'table') { setTimeout(showAllReminders, 100); }
             else { const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                  const mapContextToReopen = sessionStorage.getItem('mapContext');
                 if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) { sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); if (!document.getElementById('reminders-location-map-modal')) { if (mapContextToReopen === 'navigation') openNavigationMap(); sessionStorage.removeItem('mapContext');} } } showToast('Posposición cancelada', 'info'); });
     }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showYellowBorder
    // RESUMEN: Muestra un borde amarillo intermitente en toda la pantalla como alerta visual.
    // ===================================================================
    function showYellowBorder() {
        const borderDiv = document.createElement('div'); borderDiv.style.position = 'fixed'; borderDiv.style.top = '0'; borderDiv.style.left = '0'; borderDiv.style.width = '100vw'; borderDiv.style.height = '100vh'; borderDiv.style.boxSizing = 'border-box'; borderDiv.style.border = '25px solid #FFFF00'; borderDiv.style.zIndex = '99999'; borderDiv.style.pointerEvents = 'none'; borderDiv.style.opacity = '1'; borderDiv.style.transition = 'opacity 0.5s ease-out'; document.body.appendChild(borderDiv);
        setTimeout(() => { borderDiv.style.opacity = '0'; setTimeout(() => { if (borderDiv.parentNode) { borderDiv.parentNode.removeChild(borderDiv); } }, 500); }, 3500);
    }
    
    
    
    

// ===================================================================
// NOMBRE: formatTimeWithPeriod
// RESUMEN: Formatea una hora (HH:MM) para añadir un período del día (Mañana, Tarde, etc.).
// ===================================================================
function formatTimeWithPeriod(timeString) {
     if (!timeString || !timeString.match(/^\d{2}:\d{2}$/)) return '-';
     try {
         const [hourStr, minuteStr] = timeString.split(':');
         const hour = parseInt(hourStr);
         const minute = parseInt(minuteStr);
         if (isNaN(hour) || isNaN(minute) || hour < 0 || hour > 23 || minute < 0 || minute > 59) {
             return timeString;
         }
         let period = '';
         if (hour >= 22 || hour < 5) { period = 'de la Noche'; }
         else if (hour >= 5 && hour < 12) { period = 'de la Mañana'; }
         else if (hour >= 12 && hour < 14) { period = 'del Mediodía'; }
         else { period = 'de la Tarde'; }
         return `${hourStr}:${minuteStr} (${period})`;
     } catch (e) {
         return timeString;
     }
}











// ===================================================================
// NOMBRE: formatDateDetailed
// RESUMEN: Formatea una fecha (YYYY-MM-DD) a un formato más legible (DD-Mes-YYYY).
// ===================================================================
function formatDateDetailed(dateString) {
    if (!dateString || !dateString.match(/^\d{4}-\d{2}-\d{2}$/)) return '-';
    try {
        const [year, month, day] = dateString.split('-').map(Number);
        const date = new Date(Date.UTC(year, month - 1, day));
        if (isNaN(date.getTime())) return dateString;
        const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
        const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
        const monthName = monthNames[date.getUTCMonth()];
        const fullYear = date.getUTCFullYear();
        return `${dayOfMonth}-${monthName}-${fullYear}`;
    } catch (e) {
        return dateString;
    }
}

    
    
    
    
    
    
    
// ===================================================================
// NOMBRE: displayUnifiedReminderWindow
// RESUMEN: Muestra y rellena la ventana unificada de recordatorios con los que están vencidos.
// ===================================================================
function displayUnifiedReminderWindow(overdueReminders) {
    const windowElement = document.getElementById('unified-reminder-window');
    const swiperContainer = document.getElementById('reminder-swiper-container');
    const countHeader = windowElement.querySelector('.reminder-count-header');
    const countSpan = document.getElementById('total-reminder-count');
    const currentIndexSpan = document.getElementById('current-reminder-index');
    const countTextContainer = document.getElementById('reminder-count-text-container');
    const swipeHint = document.getElementById('reminder-swipe-hint');
    const hideAllButton = document.getElementById('hide-all-reminders-button');
     Object.values(previewMaps).forEach(map => {
       if (map && typeof map.remove === 'function') {
           map.remove();
       }
     });
     previewMaps = {};
    if (!windowElement || !swiperContainer || !countHeader || !countSpan || !currentIndexSpan || !countTextContainer || !swipeHint || !hideAllButton) {
        return;
    }
    swiperContainer.innerHTML = '';
    overdueReminders.sort((a, b) => { try { const dateA = new Date(`${a.date}T${a.time}:00Z`); const dateB = new Date(`${b.date}T${b.time}:00Z`); return dateA - dateB; } catch (e) { return 0; } });
    if (!isUnifiedWindowVisibleByLogic) {
        currentNotificationSlideIndex = 0;
    }
    overdueReminders.forEach((reminder, index) => {
        const slide = document.createElement('div');
        slide.className = 'reminder-slide';
        slide.dataset.id = reminder.id;
        slide.setAttribute('role', 'group');
        slide.setAttribute('aria-label', `Recordatorio: ${reminder.text.replace(/<[^>]*>/g, '')}`);
        
        let slideContentHtml = '';
        const isRadarAlert = reminder.text.toUpperCase().includes("RADAR");

        if (isRadarAlert) {
            slideContentHtml = `
                <div class="reminder-slide-content">
                    <img src="https://boardinggate.github.io/Tesla/AGUARDIA.png" alt="Icono Radar" class="radar-icon">
                    <div class="reminder-content-scrollable">
                        <p class="reminder-text" style="text-align: center;">${reminder.text}</p>
                    </div>
                    <div class="button-group">
                        <button class="route-radar-seen" style="background-color: #2563EB; color: white; font-weight: bold; height: 70px; font-size: 1.2rem;">VISTO (Posponer 5 min)</button>
                        <button class="modify">Modificar</button>
                    </div>
                </div>
            `;
        } else {
            let detailsHtml = '';
            if (reminder.time) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Hora: ${formatTimeWithPeriod(reminder.time)}</p>`;
            if (reminder.date) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Fecha: ${formatDateDetailed(reminder.date)}</p>`;
            if (reminder.type === 'weekly' && reminder.repeatDays?.length > 0) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Repite: ${reminder.repeatDays.map(d => ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'][d]).join(', ')}</p>`;
            if (reminder.type === 'interval' && reminder.intervalDays) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Cada: ${reminder.intervalDays} días</p>`;
            if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Ubicación: Activada (Radio ${reminder.radiusMeters || DEFAULT_LOCATION_RADIUS}m)</p>`;
            }
            const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval';
            const showAdjustButton = isCyclic && reminder.time !== '00:01';
            const adjustButtonHtml = showAdjustButton ? `<button class="adjust-time-0001">Ajustar Hora 00:01 y Visto</button>` : '';
            const cyclicCancelButtonHtml = isCyclic ? `<button class="cancel-cyclic">Anular Ciclo</button>` : '';
            
            const buttonsHtml = `
                <div class="button-group">
                    <button class="cancel">Visto / Próximo</button>
                    <button class="postpone">Posponer</button>
                    <button class="modify">Modificar</button>
                    ${adjustButtonHtml}
                    ${cyclicCancelButtonHtml}
                </div>`;

            const mapPreviewHtml = (reminder.isLocationEnabled && reminder.locationCoordinates && !isNavigationMapActive) ? `
                <div class="reminder-map-preview-container">
                    <div id="map-preview-${reminder.id}" class="reminder-map-preview"></div>
                </div>
            ` : '';

            slideContentHtml = `
                <div class="reminder-slide-content">
                    <div class="reminder-content-scrollable">
                        <p class="reminder-text">${reminder.text}</p>
                        ${detailsHtml}
                    </div>
                    ${buttonsHtml} 
                </div>
                ${mapPreviewHtml}
            `;
        }
        
        slide.innerHTML = slideContentHtml;
        // --- FIN DE LA MODIFICACIÓN ---

        addSlideButtonListeners(slide, reminder);
        swiperContainer.appendChild(slide);

        if (reminder.isLocationEnabled && reminder.locationCoordinates && !isNavigationMapActive && !isRadarAlert) {
             const mapPreviewElement = slide.querySelector(`#map-preview-${reminder.id}`);
             if (mapPreviewElement) {
                setTimeout(() => {
                    try {
                        if (!document.getElementById(mapPreviewElement.id)) return;
                        if (previewMaps[reminder.id] && typeof previewMaps[reminder.id].remove === 'function') {
                           previewMaps[reminder.id].remove();
                        }
                        const isRadarType = reminder.text.toUpperCase().includes("RADAR:") || reminder.excludeFromList;
                        const circleColor = isRadarType ? 'rgba(255, 165, 0, 0.2)' : 'blue';
                        const circleFillColor = isRadarType ? 'rgba(255, 165, 0, 0.2)' : '#ADD8E6';
                        const circleFillOpacity = isRadarType ? 0.2 : 0.05;
                        const circleWeight = 1;
                        const map = L.map(mapPreviewElement, {
                            dragging: false, touchZoom: false, scrollWheelZoom: false, doubleClickZoom: false,
                            boxZoom: false, keyboard: false, tap: false, zoomControl: false
                        }).setView([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude], 14);
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        }).addTo(map);
                        L.marker([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude]).addTo(map);
                        L.circle([reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude], {
                            color: circleColor, fillColor: circleFillColor, weight: circleWeight, fillOpacity: circleFillOpacity, radius: reminder.radiusMeters || DEFAULT_LOCATION_RADIUS
                        }).addTo(map);
                        map.invalidateSize();
                        previewMaps[reminder.id] = map;
                    } catch (mapError) {
                         if (mapPreviewElement) mapPreviewElement.innerHTML = `<p style="font-size:0.8rem; color: red; text-align: center; padding: 5px;">Error al cargar mapa</p>`;
                    }
                }, 100);
             }
        }
    });
    const count = overdueReminders.length;
    countSpan.textContent = count;
    if (count > 0) {
         if (currentNotificationSlideIndex >= count) {
             currentNotificationSlideIndex = 0;
         }
         swiperContainer.scrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
         updateReminderIndexDisplay();
         countHeader.classList.remove('hidden');
         if (count > 1) {
            countTextContainer.style.display = 'inline';
            swipeHint.style.display = 'block';
            document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = 'calc(85vh - 60px)');
         } else {
            countTextContainer.style.display = 'none';
            swipeHint.style.display = 'none';
            document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = '85vh');
         }
          hideAllButton.classList.remove('hidden');
          const newHideAllButton = hideAllButton.cloneNode(true);
          hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton);
          newHideAllButton.addEventListener('click', postponeAllVisibleReminders);
    } else {
        countHeader.classList.add('hidden');
        hideAllButton.classList.add('hidden');
        currentNotificationSlideIndex = 0;
    }
    windowElement.classList.add('visible');
    isUnifiedWindowVisibleByLogic = true;
    swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay);
    swiperContainer.addEventListener('scroll', updateReminderIndexDisplay);
}    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getSavedLocations
    // RESUMEN: Obtiene las ubicaciones guardadas desde localStorage.
    // ===================================================================
    function getSavedLocations() { try { const locations = localStorage.getItem(SAVED_LOCATIONS_KEY); return locations ? JSON.parse(locations) : Array(MAX_SAVED_LOCATIONS).fill(null); } catch (e) { return Array(MAX_SAVED_LOCATIONS).fill(null); } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: saveLocationsToCache
    // RESUMEN: Guarda el array de ubicaciones en localStorage.
    // ===================================================================
    function saveLocationsToCache(locationsArray) { try { localStorage.setItem(SAVED_LOCATIONS_KEY, JSON.stringify(locationsArray));} catch (e) { showToast("Error al guardar ubicaciones.", "error"); } }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: showSavedLocationsModal
    // RESUMEN: Muestra el modal para gestionar las ubicaciones guardadas.
    // ===================================================================
    function showSavedLocationsModal(callbackOnClose, callbackOnSelectLocation, options = {}) {
        const existingModal = document.querySelector('.saved-locations-modal');
        if (existingModal) { if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; } clearModalAutoCloseTimer(existingModal, existingModal.querySelector('#close-saved-locations-modal'), 'saved-locations-modal'); existingModal.remove(); }
        tempSavedLocations = getSavedLocations().map(loc => loc ? {...loc} : null);
        const modal = document.createElement('div'); modal.className = 'saved-locations-modal';
        modal.innerHTML = `
            <h2>Gestionar Ubicaciones Guardadas (Máx. ${MAX_SAVED_LOCATIONS})</h2>
            <div class="modal-top-buttons">
                <button id="save-all-user-locations">Guardar Cambios</button>
                <button id="close-saved-locations-modal">Cerrar</button>
            </div>
            <div id="saved-locations-list"> </div>
            <div id="location-picker-map-container">
                <button id="picker-ok-map-button" title="Confirmar esta posición">OK</button>
                <button id="picker-locate-me-button" title="Ir a mi posición actual">Mi Ubic.</button>
            </div>
        `;
        const parent = options.parentContainer || document.body;
        parent.appendChild(modal);
        const listElement = modal.querySelector('#saved-locations-list'); const mapPickerContainer = modal.querySelector('#location-picker-map-container');
        const okMapBtn = modal.querySelector('#picker-ok-map-button'); const locateMeMapBtn = modal.querySelector('#picker-locate-me-button');
        const saveAllButton = modal.querySelector('#save-all-user-locations'); const closeButton = modal.querySelector('#close-saved-locations-modal');
        function loadAndDisplaySlots() {
            listElement.innerHTML = '';
            for (let i = 0; i < MAX_SAVED_LOCATIONS; i++) {
                const location = tempSavedLocations[i]; const slotDiv = document.createElement('div'); slotDiv.className = 'location-slot';
                slotDiv.innerHTML = ` <span style="width: 25px; text-align: right; font-weight: bold;">${i + 1}.</span> <input type="text" placeholder="Nombre Ubicación" value="${location?.name || ''}" data-index="${i}"> <button class="map-button" data-index="${i}" title="Fijar en Mapa">📍 Mapa</button> <button class="select-location-button" data-index="${i}" title="Seleccionar esta ubicación para el recordatorio actual">Seleccionar</button> <span class="coords-display">${location?.lat && location?.lng ? `${parseFloat(location.lat).toFixed(4)}, ${parseFloat(location.lng).toFixed(4)}` : 'No fijada'}</span> `;
                listElement.appendChild(slotDiv);
                slotDiv.querySelector('input[type="text"]').addEventListener('input', (e) => { if (!tempSavedLocations[i]) tempSavedLocations[i] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS }; tempSavedLocations[i].name = e.target.value; });
                slotDiv.querySelector('.map-button').addEventListener('click', () => {
                    currentEditingLocationSlotIndex = i; mapPickerContainer.classList.add('expanded'); initializeLocationPickerMap('location-picker-map-container', i);
                    const currentSlotLocation = tempSavedLocations[i]; const initialCoords = currentSlotLocation?.lat && currentSlotLocation?.lng ? { latitude: currentSlotLocation.lat, longitude: currentSlotLocation.lng } : null;
                    if (locationPickerMap && initialCoords) { locationPickerMap.setView([initialCoords.latitude, initialCoords.longitude], 15); if (locationPickerMarker) locationPickerMarker.setLatLng([initialCoords.latitude, initialCoords.longitude]); }
                    else if (locationPickerMap) { getCurrentLocation( (coords) => { locationPickerMap.setView([coords.latitude, coords.longitude], 15); if(locationPickerMarker) locationPickerMarker.setLatLng([coords.latitude, coords.longitude]); else { locationPickerMarker = L.marker([coords.latitude, coords.longitude], {draggable: true}).addTo(locationPickerMap); locationPickerMarker.on('dragend', (event) => { const pos = event.target.getLatLng(); if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS }; tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat; tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng; }); } }, () => { } ); } });
                const selectButton = slotDiv.querySelector('.select-location-button');
                selectButton.addEventListener('click', () => { const selectedIndex = parseInt(selectButton.dataset.index); const selectedLocData = tempSavedLocations[selectedIndex];
                    if (selectedLocData && selectedLocData.lat && selectedLocData.lng) {
                        if (callbackOnSelectLocation && typeof callbackOnSelectLocation === 'function') { callbackOnSelectLocation({ name: selectedLocData.name, lat: selectedLocData.lat, lng: selectedLocData.lng, radius: selectedLocData.radius || DEFAULT_LOCATION_RADIUS }); }
                        if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; } clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal'); modal.remove();
                    } else { showToast("Ubicación no fijada. Fíjala en el mapa primero", "warning"); } }); } }
        loadAndDisplaySlots();
        okMapBtn.addEventListener('click', () => { if (locationPickerMarker && currentEditingLocationSlotIndex !== -1) { const pos = locationPickerMarker.getLatLng(); if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS }; tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat; tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng;
                const slotInput = listElement.querySelector(`.location-slot input[dataindex="${currentEditingLocationSlotIndex}"]`); if (slotInput) { const coordsDisplay = slotInput.closest('.location-slot').querySelector('.coords-display'); if (coordsDisplay) { coordsDisplay.textContent = `${pos.lat.toFixed(4)}, ${pos.lng.toFixed(4)}`; } } }
            mapPickerContainer.classList.remove('expanded'); if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; } currentEditingLocationSlotIndex = -1; });
        locateMeMapBtn.addEventListener('click', () => { if (locationPickerMap) { locateMeMapBtn.disabled = true; locateMeMapBtn.textContent = 'Buscando...';
                getCurrentLocation( (coords) => { locationPickerMap.setView([coords.latitude, coords.longitude], 16); if (locationPickerMarker) locationPickerMarker.setLatLng([coords.latitude, coords.longitude]); if (currentEditingLocationSlotIndex !== -1) { if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS }; tempSavedLocations[currentEditingLocationSlotIndex].lat = coords.latitude; tempSavedLocations[currentEditingLocationSlotIndex].lng = coords.longitude; } locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.'; }, (errorMsg) => { showToast(`Error localización: ${errorMsg}`, 'error'); locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.'; } ); } });
        saveAllButton.addEventListener('click', () => {
            const locationsToSave = tempSavedLocations.map(loc => { if (loc && (!loc.name || loc.name.trim() === '') && (loc.lat === null || loc.lng === null)) { return null; } if (loc && (loc.lat !== null && loc.lng !== null) && typeof loc.radius !== 'number') { loc.radius = DEFAULT_LOCATION_RADIUS; } return loc; });
            saveLocationsToCache(locationsToSave);
            let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
            savedRoutes = savedRoutes.filter(r => !r.name.startsWith("UBICACIÓN: "));
            locationsToSave.forEach(loc => {
                if (loc && loc.name && loc.lat && loc.lng) {
                    const routeName = `UBICACIÓN: ${loc.name.toUpperCase()}`;
                    const routeWaypoint = {
                        id: Date.now() + Math.random(),
                        lat: loc.lat,
                        lng: loc.lng,
                        type: 'F',
                        label: 'F',
                        address: loc.name,
                        visited: false,
                        isCriticalForRecalc: true
                    };
                    const existingRouteIndex = savedRoutes.findIndex(r => r.name === routeName);
                    const routeToSave = {
                        name: routeName,
                        waypoints: [routeWaypoint],
                        createdAt: new Date().toISOString()
                    };
                    if (existingRouteIndex !== -1) {
                        savedRoutes[existingRouteIndex] = routeToSave;
                    } else {
                        savedRoutes.push(routeToSave);
                    }
                }
            });
            if (savedRoutes.length > MAX_SAVED_ROUTES) {
                 savedRoutes.sort((a,b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
                 savedRoutes = savedRoutes.slice(0, MAX_SAVED_ROUTES);
            }
            localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes)); 
            showToast("Ubicaciones guardadas y sincronizadas como s.", "success");
            if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose();
            if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; } clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal'); modal.remove(); });
        const closeHandler = () => { clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal'); if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; } if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose(); modal.remove(); };
        closeButton.addEventListener('click', closeHandler); addModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
    }
    
    
    
    
    
    
    
    
    
    




    
    
    
    






// ===================================================================
// NOMBRE: updateNavigationGraphVisibilityAndMode
// RESUMEN: Actualiza la visibilidad y modo de la gráfica de navegación.
// ===================================================================
function updateNavigationGraphVisibilityAndMode() {
    const graphCard = document.getElementById('navigation-graph-card');
    const graphContainer = document.getElementById('navigation-graph-container');
    const graphTitleElement = document.getElementById('navigation-graph-title');
    const compassControl = document.querySelector('.leaflet-control-orientation-altitude');
    if (!graphCard || !graphContainer || !graphTitleElement) {
        return;
    }
    if (compassControl && compassControl._updateGraphTitle) {
        compassControl._updateGraphTitle();
    }
    const isEnlarged = graphCard.classList.contains('enlarged');
    if (navigationCurrentRouteData && currentGraphMode !== 'Gráfica off') {
        graphCard.classList.remove('hidden');
        if (!isEnlarged) {
            const compassHeight = compassControl ? compassControl.offsetHeight : 0;
            graphCard.style.height = compassHeight > 0 ? `${compassHeight}px` : '157px';
        }
        if (navigationChart) {
            updateChartData(); 
        } else if (isNavigating) {
            ; 
        }
    } else {
        graphCard.classList.add('hidden');
    }
}





    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: initializeLocationPickerMap
    // RESUMEN: Inicializa el mapa selector de ubicaciones en el modal correspondiente.
    // ===================================================================
    function initializeLocationPickerMap(mapContainerId, slotIndex) {
        if (locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
        const mapDiv = document.createElement('div'); mapDiv.style.width = '100%'; mapDiv.style.height = '100%';
        const container = document.getElementById(mapContainerId); while (container.firstChild && container.firstChild.id !== 'picker-ok-map-button' && container.firstChild.id !== 'picker-locate-me-button') { container.removeChild(container.firstChild); } container.insertBefore(mapDiv, container.firstChild);
        const initialLocation = tempSavedLocations[slotIndex] || {}; const centerLat = initialLocation.lat || 40.416775; const centerLng = initialLocation.lng || -3.703790; const initialZoom = (initialLocation.lat && initialLocation.lng) ? 15 : 6;
        locationPickerMap = L.map(mapDiv, { zoomControl: false }).setView([centerLat, centerLng], initialZoom);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap contributors' }).addTo(locationPickerMap);
        locationPickerMarker = L.marker([centerLat, centerLng], { draggable: true }).addTo(locationPickerMap);
        locationPickerMarker.on('dragend', (event) => { const pos = event.target.getLatLng(); if (!tempSavedLocations[slotIndex]) tempSavedLocations[slotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS }; tempSavedLocations[slotIndex].lat = pos.lat; tempSavedLocations[slotIndex].lng = pos.lng; });
        locationPickerMap.on('click', (e) => handlePickerMapClick(e, slotIndex));
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                if (locationPickerMap) {
                     try { locationPickerMap.invalidateSize(); } catch(e){}
                }
            });
        });
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handlePickerMapClick
    // RESUMEN: Maneja el clic en el mapa selector de ubicaciones para fijar coordenadas.
    // ===================================================================
    function handlePickerMapClick(e, slotIndex) {
        const latlng = e.latlng; if (locationPickerMarker) { locationPickerMarker.setLatLng(latlng); }
        if (!tempSavedLocations[slotIndex]) tempSavedLocations[slotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
        tempSavedLocations[slotIndex].lat = latlng.lat; tempSavedLocations[slotIndex].lng = latlng.lng;
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleMapHeaderRowsVisibility
    // RESUMEN: Muestra u oculta las filas de botones en la cabecera del mapa.
    // ===================================================================
    function toggleMapHeaderRowsVisibility(show) {
        const header = document.getElementById('reminders-location-map-header');
        if (!header) return;
        mapHeaderButtonsVisible = show;
        header.querySelectorAll('.button-row').forEach(row => {
            row.classList.toggle('hidden-map-header', !show);
        });
        if (navigationMapInstance) {
            setTimeout(() => {
                if (navigationMapInstance) {
                    try {
                        navigationMapInstance.invalidateSize();
                    } catch(e) {
                        console.error("Error al invalidar el tamaño del mapa:", e);
                    }
                }
            }, 350);
        }
    }
    
    
    
    
    
    
    
    
    
    
    
    
    













    
// ===================================================================
// NOMBRE: showToast
// RESUMEN: Muestra una notificación temporal (toast) en la pantalla.
// ===================================================================
function showToast(message, type = 'info', duration = 3000, isErrorNotFound = false, toastId = null) {
    const uniqueToastId = toastId || 'toast-notification-element' + (type === 'debug' ? '-debug' : '') + `-${Date.now()}`;
    let currentTopOffset = 180;
    const toastSpacing = 10;
    activeToasts.forEach(activeToast => {
        const toastElement = document.getElementById(activeToast.id);
        if (toastElement) {
             currentTopOffset += toastElement.offsetHeight + toastSpacing;
        }
    });
    const existingToast = document.getElementById(uniqueToastId);
    if (existingToast && !toastId) {
        existingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
    } else if (existingToast && toastId) {
         existingToast.remove();
         activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
         currentTopOffset = 180;
         activeToasts.forEach(activeToast => {
            const toastElement = document.getElementById(activeToast.id);
            if (toastElement) {
                currentTopOffset += toastElement.offsetHeight + toastSpacing;
            }
         });
    }
    const toast = document.createElement('div');
    toast.id = uniqueToastId;
    toast.className = `toast-notification toast-${type}`;
    if (isErrorNotFound && type === 'error') {
        toast.classList.add('not-found');
    }
    const messageSpan = document.createElement('span');
    messageSpan.innerHTML = message.replace(/\n/g, '<br>');
    toast.appendChild(messageSpan);
    if (type === 'debug') {
        toast.style.top = 'auto';
        toast.style.bottom = '20px';
        toast.style.right = '20px';
        toast.style.left = 'auto';
        toast.style.transform = 'none';
        toast.style.maxWidth = 'calc(100% - 40px)';
        const closeButtonToast = document.createElement('button');
        closeButtonToast.textContent = 'Cerrar Info Debug';
        closeButtonToast.style.cssText = "display: block; margin-top: 10px; padding: 5px 10px; background-color: rgba(255,255,255,0.2); color: white; border: 1px solid white; border-radius: 3px; cursor: pointer;";
        closeButtonToast.onclick = () => {
            if (toast.parentNode) toast.parentNode.removeChild(toast);
             activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
        };
        toast.appendChild(closeButtonToast);
    }
    toast.style.top = `${currentTopOffset}px`;
    document.body.appendChild(toast);
    activeToasts.push({ id: uniqueToastId, element: toast });
    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            toast.classList.add('show');
        });
    });
    if (duration > 0 && type !== 'debug') {
        setTimeout(() => {
            if (toast.classList.contains('show')) {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => {
                     if (toast.parentNode) { toast.parentNode.removeChild(toast); }
                     activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
                }, { once: true });
            } else {
                 if (toast.parentNode) { toast.parentNode.removeChild(toast); }
                 activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
            }
        }, duration);
    }
}







    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleMapImmersiveMode
    // RESUMEN: Activa o desactiva el modo inmersivo del mapa para ocultar los controles.
    // ===================================================================
    function toggleMapImmersiveMode() {
        isMapImmersiveModeActive = !isMapImmersiveModeActive;
        const mapModal = document.getElementById('reminders-location-map-modal');
        if (mapModal) {
            mapModal.classList.toggle('immersive-mode-active', isMapImmersiveModeActive);
            showToast(isMapImmersiveModeActive ? 'Modo Inmersivo Activado' : 'Modo Inmersivo Desactivado', 'info');
            if (navigationMapInstance) {
                setTimeout(() => {
                    try {
                        navigationMapInstance.invalidateSize();
                    } catch(e) { console.error("Error al invalidar tamaño de mapa en modo inmersivo:", e); }
                }, 350);
            }
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateNavigationButtonColor
    // RESUMEN: Actualiza el color del botón de inicio de navegación según el estado.
    // ===================================================================
    function updateNavigationButtonColor() {
        const startNavButton = document.getElementById('start-navigation-button');
        if (startNavButton) {
            if (isNavigating) {
                startNavButton.style.setProperty('background-color', '#000000', 'important');
            } else {
                startNavButton.style.backgroundColor = 'white';
                startNavButton.style.boxShadow = '2px 3px 5px rgba(0,0,0,0.60)';
            }
        }
    }
    
    
    


    

    
    
    


// ===================================================================
// NOMBRE: initDirectionWarningCards (MODIFICADA SIN ICONOS)
// RESUMEN: Inicializa y añade al DOM las tarjetas de advertencia de dirección.
// ===================================================================
function initDirectionWarningCards() {
    const mapContainer = document.getElementById('leaflet-map-actual-container');
    if (!mapContainer) return;

    // --- Tarjeta de la DERECHA ---
    if (!directionCardDerecha) {
        directionCardDerecha = document.createElement('div');
        directionCardDerecha.id = 'direction-card-derecha';
        directionCardDerecha.className = 'direction-warning-card';
        directionCardDerecha.innerHTML = `<span style="vertical-align: middle;">← DERECHA</span>`;
        directionCardDerecha.style.left = '170px';
        directionCardDerecha.style.bottom = '200px';
        mapContainer.appendChild(directionCardDerecha);
    }

    // --- Tarjeta de la IZQUIERDA ---
    if (!directionCardIzquierda) {
        directionCardIzquierda = document.createElement('div');
        directionCardIzquierda.id = 'direction-card-izquierda';
        directionCardIzquierda.className = 'direction-warning-card';
        directionCardIzquierda.innerHTML = `<span style="vertical-align: middle;">IZQUIERDA →</span>`;
        directionCardIzquierda.style.right = '170px';
        directionCardIzquierda.style.bottom = '200px';
        mapContainer.appendChild(directionCardIzquierda);
    }
}


// ===================================================================
// NOMBRE: updateTurnByTurnDisplay (VERSIÓN CORREGIDA 3)
// RESUMEN: Actualiza la barra de información de giro en la navegación.
// ===================================================================
function updateTurnByTurnDisplay(route, carDistanceAlongTheRoute = 0) {
    const topInfoBar = document.getElementById('navigation-top-info-bar');
    const intersectionPreviewWindow = document.getElementById('intersection-preview-map-window');
    const helperLeft = document.getElementById('intersection-helper-left');
    const helperRight = document.getElementById('intersection-helper-right');

    if (helperLeft) helperLeft.style.display = 'none';
    if (helperRight) helperRight.style.display = 'none';
    
    if (!route || !topInfoBar || !route.legs || route.legs.length === 0) {
        if (topInfoBar) topInfoBar.style.display = 'none';
        if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
        updateDirectionWarningCardsVisibility();
        return;
    }
    if (!isNavigating && (!navigationCurrentRouteData || navigationWaypoints.length < 2)) {
         if (topInfoBar) topInfoBar.style.display = 'none';
         if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
         updateDirectionWarningCardsVisibility();
         return;
    }

    topInfoBar.style.display = 'flex';
    const turnIconDisplayEl = document.getElementById('turn-icon-display');
    const maneuverTextEl = document.getElementById('maneuver-text-display');
    const distanceFormattedEl = document.getElementById('distance-to-turn-formatted');
    const streetEl = document.getElementById('street-name-display');
    const progressBarEl = document.getElementById('distance-progress-bar-to-turn');
    
    if (turnIconDisplayEl) {
        turnIconDisplayEl.style.width = '100%';
        turnIconDisplayEl.style.height = '100%';
        turnIconDisplayEl.style.display = 'flex';
        turnIconDisplayEl.style.alignItems = 'center';
        turnIconDisplayEl.style.justifyContent = 'center';
    }

    const carDistance = Math.min(Math.max(0, carDistanceAlongTheRoute), route.distance);
    let distanceCoveredInRoute = 0;
    let currentLegIndex = -1, currentStepIndex = -1;
    let nextStepToDisplay = null, distanceToEndOfCurrentStepForProgress = 0;
    let previousStepForPath = null;

    for (let i = 0; i < route.legs.length; i++) {
        const leg = route.legs[i];
        for (let j = 0; j < leg.steps.length; j++) {
            const step = leg.steps[j];
            if (carDistance < distanceCoveredInRoute + step.distance) {
                currentLegIndex = i; currentStepIndex = j;
                distanceToEndOfCurrentStepForProgress = distanceCoveredInRoute + step.distance;
                if (j > 0) {
                    previousStepForPath = leg.steps[j - 1];
                } else if (i > 0) {
                    previousStepForPath = route.legs[i-1].steps[route.legs[i-1].steps.length - 1];
                }
                break;
            }
            distanceCoveredInRoute += step.distance;
        }
        if (currentLegIndex !== -1) break;
    }

    if (currentLegIndex === -1) {
        currentLegIndex = route.legs.length - 1;
        currentStepIndex = route.legs[currentLegIndex].steps.length - 1;
    }
    
    currentLegIndexNav = currentLegIndex;
    currentStepIndexNav = currentStepIndex;
    const currentLeg = route.legs[currentLegIndex];
    if (currentStepIndex + 1 < currentLeg.steps.length) {
        nextStepToDisplay = currentLeg.steps[currentStepIndex + 1];
    } else if (currentLegIndex + 1 < route.legs.length) {
        nextStepToDisplay = route.legs[currentLegIndex + 1].steps[0];
    } else {
        nextStepToDisplay = currentLeg.steps[currentStepIndex];
    }
    const currentStepForProgress = currentLeg.steps[currentStepIndex];
    const distanceToNextManeuver = Math.max(0, distanceToEndOfCurrentStepForProgress - carDistance);
    navigationTargetZoom = handleProgressiveManeuverZoom(currentStepForProgress, distanceToNextManeuver);

    if (nextStepToDisplay && nextStepToDisplay.maneuver) {
        const maneuver = nextStepToDisplay.maneuver;
        const type = maneuver.type || '';
        const maneuverText = getManeuverInstructionText(maneuver);

        if (turnIconDisplayEl) {
            const iconFilename = getManeuverIconFilename(maneuver);
            const iconUrl = `https://boardinggate.github.io/Tesla/${iconFilename}`;
            turnIconDisplayEl.innerHTML = `<img src="${iconUrl}" alt="${maneuverText}" style="width: 95%; height: 95%; object-fit: contain; ">`;  //image-rendering: pixelated;
        }

        let streetNameText = nextStepToDisplay.name || '';
        if (type === 'arrive' || type === 'depart' || type.includes('roundabout') || type === 'end of road') { streetNameText = ''; }
        
        maneuverTextEl.textContent = maneuverText ? `${maneuverText} ` : '';
        streetEl.textContent = streetNameText;
        
        distanceToNextManeuverOSRM = distanceToNextManeuver;
        distanceFormattedEl.textContent = distanceToNextManeuver < 1000 ? `${Math.round(distanceToNextManeuver / 5) * 5} m` : `${(distanceToNextManeuver / 1000).toFixed(1)} km`;

        const distanceCoveredInCurrentStep = (currentStepForProgress.distance || 0) - distanceToNextManeuver;
        const progressPercent = (currentStepForProgress.distance > 0) ? (distanceCoveredInCurrentStep / currentStepForProgress.distance) * 100 : (distanceToNextManeuver === 0 ? 100 : 0);
        if(progressBarEl) progressBarEl.style.width = `${Math.min(100, Math.max(0, progressPercent))}%`;

        if (isNavigating && previousStepForPath && completedRouteSegmentsLayer && navigationCurrentLocation) {
             if (previousStepForPath.maneuver && previousStepForPath.maneuver.location && previousStepForPath.maneuver.location.length === 2) {
                const prevManeuverLocLatLng = L.latLng(previousStepForPath.maneuver.location[1], previousStepForPath.maneuver.location[0]);
                 if (!lastProcessedStepManeuverLocation || (lastProcessedStepManeuverLocation.lat.toFixed(5) !== prevManeuverLocLatLng.lat.toFixed(5) || lastProcessedStepManeuverLocation.lng.toFixed(5) !== prevManeuverLocLatLng.lng.toFixed(5))) {
                    if (previousStepForPath.geometry && previousStepForPath.geometry.coordinates) {
                        const segmentCoords = previousStepForPath.geometry.coordinates.map(c => [c[1], c[0]]);
                        if (segmentCoords.length >= 2) {
                            if (completedRouteSegmentsLayer) L.polyline(segmentCoords, { color: 'green', weight: 6, opacity: 0.8 }).addTo(completedRouteSegmentsLayer);
                            lastProcessedStepManeuverLocation = prevManeuverLocLatLng;
                        }
                    }
                }
            }
        }
        
        const isRelevantIntersectionManeuver = type !== 'continue' && type !== 'new name' && type !== 'depart' && type !== 'straight';
        if (isNavigating && distanceToNextManeuver < 800 && distanceToNextManeuver >= 100 && isRelevantIntersectionManeuver && (!intersectionPreviewWindow || intersectionPreviewWindow.classList.contains('hidden') || intersectionPreviewWindow.dataset.source !== 'click') && (currentLegIndex + '_' + currentStepIndex) !== lastAutoShownManeuverId) {
            showIntersectionPreviewMap(nextStepToDisplay, route, false, 6000);
            lastAutoShownManeuverId = currentLegIndex + '_' + currentStepIndex;
        } else if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click' && (distanceToNextManeuver >= 800 || distanceToNextManeuver < 100 || !isRelevantIntersectionManeuver)) {
            hideIntersectionPreviewMap();
        }

        const heading = navigationCurrentLocation?.heading;
        const isSouthOriented = heading >= 145 && heading <= 215;
        // const isNearIntersection = distanceToNextManeuver < 400;
        const isNearIntersection = distanceToNextManeuver < 180;
        if (isSouthOriented && isNearIntersection && isNavigating) {
            positionTurnHelpers();
            const iconFilename = getManeuverIconFilename(maneuver);
            const iconUrl = `https://boardinggate.github.io/Tesla/${iconFilename}`;
            const lowerManeuverText = maneuverText.toLowerCase();

            if (lowerManeuverText.includes('izquierd')) {
                if (helperRight) {
                    const img = helperRight.querySelector('img');
                    if (img) img.src = iconUrl;
                    helperRight.style.display = 'flex';
                }
            } else if (lowerManeuverText.includes('derech')) {
                if (helperLeft) {
                    const img = helperLeft.querySelector('img');
                    if (img) img.src = iconUrl;
                    helperLeft.style.display = 'flex';
                }
            }
        }

    } else {
        if (turnIconDisplayEl) {
            turnIconDisplayEl.innerHTML = `<img src="https://boardinggate.github.io/Tesla/arrive.png" style="width:95%; height:95%; object-fit:contain;">`;
        }
        maneuverTextEl.textContent = '';
        streetEl.textContent = 'Has llegado a tu destino';
        distanceFormattedEl.textContent = '0 m';
        if(progressBarEl) progressBarEl.style.width = '100%';
        distanceToNextManeuverOSRM = Infinity;
        if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
    }
    
    updateDirectionWarningCardsVisibility();
}


// ===================================================================
// NOMBRE: toggleEnlargedGraph
// RESUMEN: Amplía o reduce la gráfica de navegación.
// ===================================================================
function toggleEnlargedGraph() {
    const graphCard = document.getElementById('navigation-graph-card');
    const enlargeButton = document.getElementById('enlarge-graph-button');
    const compassControlContainer = document.querySelector('.leaflet-control-orientation-altitude');
    const mapModal = document.getElementById('reminders-location-map-modal');
    if (!graphCard || !enlargeButton || !compassControlContainer || !mapModal) return;
    const isCurrentlyEnlarged = graphCard.classList.contains('enlarged');
    if (!isCurrentlyEnlarged) {
        graphCard.classList.add('enlarged');
        const compassRect = compassControlContainer.getBoundingClientRect();
        const fixedWidth = 995; 
        const fixedHeight = 600; 
        const newLeft = compassRect.left;
        const distanceFromBottom = window.innerHeight - compassRect.bottom;
        const newBottom = distanceFromBottom;
        graphCard.style.left = `${newLeft}px`;
        graphCard.style.bottom = `${newBottom}px`;
        graphCard.style.width = `${fixedWidth}px`;
        graphCard.style.height = `${fixedHeight}px`;
        enlargeButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        `;
        enlargeButton.title = 'Reducir gráfica';
    } else {
        graphCard.classList.remove('enlarged');
        graphCard.style.left = '';
        graphCard.style.bottom = '';
        graphCard.style.width = '';
        graphCard.style.height = '';
        graphCard.style.top = '';
        graphCard.style.right = '';
        graphCard.style.transform = '';
        enlargeButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="11" y1="8" x2="11" y2="14"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        `;
        enlargeButton.title = 'Ampliar gráfica';
    }
    if (navigationChart) {
        updateChartData(); 
        setTimeout(() => {
            navigationChart.resize();
        }, 200);
    }
    updateNavigationGraphVisibilityAndMode();

    setTimeout(positionTurnHelpers, 450);
}


// ===================================================================
// NOMBRE: initializeApp
// RESUMEN: Función principal que inicializa la aplicación al cargar la página.
// ===================================================================
async function initializeApp() {
    loadCustomData();
    loadSavedSettings();
    const { isMobile, primaryId } = parseUserId(localStorage.getItem('userData_userId'));
    if (isMobile) {
        document.body.classList.add('mobile-view');
        await restoreCacheForMobile();
    } else {
        await syncDataOnLoad();
    }
    lastMobileSyncTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');
    
    const termsAccepted = localStorage.getItem('termsAccepted_v1') === 'true';
    const shouldDirectToNav = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
    const tempPreventDirectNav = sessionStorage.getItem(TEMP_PREVENT_DIRECT_NAV_KEY);
    
    if (shouldDirectToNav && !tempPreventDirectNav && termsAccepted) {
        sessionStorage.setItem('isInDirectToMapMode', 'true');
        directToNavOnLoad = true;
        const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'none';
        const footerContent = document.querySelector('footer'); if (footerContent) footerContent.style.display = 'none';
        const noticesIconContainer = document.querySelector('.notices-icon-container'); if (noticesIconContainer) noticesIconContainer.style.display = 'none';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'none');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'none');
        document.getElementById('grid-filter-container').style.display = 'none';
        createOtherButtons();
        renderToggleButtons();
        openNavigationMap();
    } else {
        sessionStorage.removeItem('isInDirectToMapMode');
        directToNavOnLoad = false;
        const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'block';
        const footerContent = document.querySelector('footer'); if (footerContent) footerContent.style.display = 'block';
        const noticesIconContainer = document.querySelector('.notices-icon-container'); if (noticesIconContainer) noticesIconContainer.style.display = 'flex';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'flex');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'block');
        document.getElementById('grid-filter-container').style.display = 'flex';
        renderGrid();
        createOtherButtons();
        renderToggleButtons();
        updateButtonStyles();
        filterGridItems();
    }

    initializeConfigModalListeners();
    try { await updateVersion(); } catch (e) { }
    try { await loadNotices(); startNoticeRotation(); } catch (e) { }
    if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
    checkReminders();
    currentCheckIntervalDuration = 3000;
    reminderCheckIntervalId = setInterval(checkReminders, currentCheckIntervalDuration);
    
    if (!termsAccepted) {
        showConfigModal();
    }

    const noticeToggleIcon = document.getElementById('notice-toggle-icon');
    if (noticeToggleIcon) noticeToggleIcon.addEventListener('click', toggleNotices);
    const countEl = document.getElementById('reminder-count-globe');
    if (countEl) {
         const openTable = (e) => {
             if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
             e.preventDefault(); e.stopPropagation();
             showAllReminders();
         };
         countEl.addEventListener('click', openTable);
         countEl.style.cursor = 'pointer';
    }
    const filterInput = document.getElementById('grid-filter-input');
    const clearButton = document.getElementById('clear-filter-button');
    if (filterInput) {
        const savedFilter = localStorage.getItem('gridFilterValue');
        if (savedFilter !== null) filterInput.value = savedFilter;
        filterInput.addEventListener('input', () => {
             localStorage.setItem('gridFilterValue', filterInput.value);
             filterGridItems();
             if(isKeywordAssignmentMode) applyInitialKeywordHighlights();
        });
    }
    if (clearButton) {
        clearButton.addEventListener('click', () => {
             if (filterInput) filterInput.value = '';
             localStorage.removeItem('gridFilterValue');
             filterGridItems();
             if(isKeywordAssignmentMode) applyInitialKeywordHighlights();
        });
    }
    adjustButtonPositions();
    window.addEventListener('resize', adjustButtonPositions);
    window.addEventListener('resize', positionTurnHelpers);

    await checkVersionsIconOpacity();

    document.body.addEventListener('click', function(event) {
        const target = event.target;
        const targetId = target.id || (target.closest('[id]') ? target.closest('[id]').id : null);
        if (targetId === 'config-close-modal') {
            const termsAcceptedForClose = localStorage.getItem('termsAccepted_v1') === 'true';
            if (!termsAcceptedForClose) {
                showToast('Debes aceptar las normas de uso para continuar.', 'warning');
                return;
            }
            const modal = document.getElementById('config-modal');
            if (modal && !modal.classList.contains('hidden')) {
                clearModalAutoCloseTimer(modal, target, 'config-modal');
                modal.classList.add('hidden');
                 const mapWasOpenBeforeConfig = sessionStorage.getItem('boardinggate_map_should_reopen_after_config') === 'true';
                 const mapContextToReopen = sessionStorage.getItem('mapContextToReopenAfterConfig');
                 sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');
                 sessionStorage.removeItem('mapContextToReopenAfterConfig');
                 if (mapWasOpenBeforeConfig && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !document.getElementById('reminders-location-map-modal')) {
                    if (mapContextToReopen === 'navigation') {
                        setTimeout(() => openNavigationMap(), 50);
                    }
                }
            }
        }
        if (target.matches('.config-tab-button')) {
            const modal = document.getElementById('config-modal');
            if(modal && modal.classList.contains('hidden') === false) {
                const tabTarget = target.dataset.tabTarget;
                modal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                modal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (modal.querySelector(tabTarget)) {
                    modal.querySelector(tabTarget).classList.add('active');
                }
            }
        }
        if (targetId === 'close-reminders-top' || targetId === 'close-reminders-bottom') {
            const modalTable = document.querySelector('.reminder-table-modal');
            if (modalTable) {
                if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                modalTable.remove();
                const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                const mapContext = sessionStorage.getItem('mapContext');
                sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                sessionStorage.removeItem('mapContext');
                if (fromReminderModal) {
                    fromReminderModal = false;
                    if (mapShouldReopen) {
                        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                        sessionStorage.setItem('mapContext', mapContext);
                    }
                    showReminderModal();
                } else if (mapShouldReopen) {
                     if (mapContext === 'navigation') openNavigationMap();
                }
            }
        }
        if (targetId === 'view-all-locations-map') {
            const modalTable = document.querySelector('.reminder-table-modal');
             if (modalTable && modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
             if (modalTable) modalTable.remove();
            setTimeout(() => {
                openLocationsPreviewMap();
            }, 50);
        }
         if (targetId === 'close-locations-preview') {
            const previewModal = document.getElementById('locations-preview-modal');
            if (previewModal) {
                if (locationsPreviewMap) {
                    try { locationsPreviewMap.remove(); } catch (e) {}
                    locationsPreviewMap = null;
                }
                if (mapLayersControlLocationsPreview) {
                    try {mapLayersControlLocationsPreview.remove();} catch(e){}
                    mapLayersControlLocationsPreview = null;
                }
                clearModalAutoCloseTimer(previewModal, target, 'locations-preview-modal');
                previewModal.classList.add('hidden');
            }
        }
        if (targetId === 'close-address-suggestions-modal') {
            hideAddressSuggestionsModal();
        }
    });
    const bookmarkGrid = document.getElementById('bookmark-grid');
    if (bookmarkGrid) {
        bookmarkGrid.addEventListener('click', function(event) {
            const link = event.target.closest('a.bookmark-item');
            if (link && link.href && link.href.startsWith("map-action:")) {
                event.preventDefault();
                const action = link.href.split(":")[1];
                if (action === "openRemindersMapWithNoRadars") {
                    closeOtherModals();
                    setTimeout(() => {
                        const existingPreviewModal = document.getElementById('locations-preview-modal');
                        if (existingPreviewModal && !existingPreviewModal.classList.contains('hidden')) {
                            showToast("El mapa de ubicaciones (sin radar) ya está abierto", "info");
                        } else {
                           openLocationsPreviewMap();
                        }
                    }, 50);
                } else if (action === "openRemindersMap") {
                    closeOtherModals();
                    setTimeout(() => {
                        const mapModalElement = document.getElementById('reminders-location-map-modal');
                        if (mapModalElement && !mapModalElement.classList.contains('hidden')) {
                            showToast("El mapa de navegación/ubicaciones ya está abierto", "info");
                            if (navigationMapInstance) {
                                requestAnimationFrame(() => {
                                    requestAnimationFrame(() => {
                                        if (navigationMapInstance) {
                                            try {
                                                 navigationMapInstance.invalidateSize({debounceMoveend: true});
                                             } catch (e) {  }
                                        }
                                    });
                                });
                            }
                        } else {
                           openNavigationMap();
                        }
                    }, 50);
                }
            }
        });
    }

    const accidentAlertButton = document.getElementById('accident-alert-button');
    if (accidentAlertButton) {
        accidentAlertButton.addEventListener('click', () => {
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
            openAlertModal();
        });
    }
}












    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateDirectionWarningCardsVisibility
    // RESUMEN: Muestra u oculta las tarjetas de advertencia según el rumbo y el modo.
    // ===================================================================
    function updateDirectionWarningCardsVisibility() {
        if (!directionCardDerecha || !directionCardIzquierda) {
            return;
        }
        const heading = navigationCurrentLocation?.heading;
        const isStrictlySouth = (heading >= 145 && heading <= 215);
        const showCards = isStrictlySouth && navigationFollowUser && isZoomedForManeuver;
        directionCardDerecha.style.display = showCards ? 'block' : 'none';
        directionCardIzquierda.style.display = showCards ? 'block' : 'none';
    }
    
    
    
    
    
    
    
    
    
    
    L.Control.CompassAndMode = L.Control.extend({
        options: {
            position: 'bottomleft'
        },
        onAdd: function(map) {
            const container = L.DomUtil.create('div', 'leaflet-control-custom-map-controls leaflet-bar');
            const compassContainer = L.DomUtil.create('div', 'leaflet-control-orientation-altitude', container);
            compassContainer.innerHTML = `
                <img id="compass-rose-icon" src="ROSA.PNG" alt="Orientación">
                <span id="orientation-text">---</span>
                <span id="altitude-display">--- m</span>
                <span id="current-speed-display">--- km/h</span>
                <span id="average-speed-display" class="speed-stats-text">Med: --- km/h</span>
                <span id="max-speed-display" class="speed-stats-text">Máx: --- km/h</span>
            `;
            L.DomEvent.disableClickPropagation(compassContainer);
            L.DomEvent.on(compassContainer, 'click', this._toggleGraphMode, this);
            const graphCard = L.DomUtil.create('div', 'hidden', container);
            graphCard.id = 'navigation-graph-card';
            graphCard.style.position = 'relative'; 
            graphCard.style.cursor = 'pointer';
            L.DomEvent.on(graphCard, 'click', toggleEnlargedGraph, this);
            const graphTitle = L.DomUtil.create('div', '', graphCard);
            graphTitle.id = 'navigation-graph-title';
            const enlargeButton = L.DomUtil.create('div', '', graphCard);
            enlargeButton.id = 'enlarge-graph-button';
            enlargeButton.title = 'Ampliar/Reducir gráfica';
            enlargeButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    <line x1="11" y1="8" x2="11" y2="14"></line>
                    <line x1="8" y1="11" x2="14" y2="11"></line>
                </svg>
            `;
            L.DomEvent.disableClickPropagation(enlargeButton);
            L.DomEvent.on(enlargeButton, 'click', (e) => {
                e.stopPropagation(); 
                toggleEnlargedGraph();
            });
            const graphCanvasContainer = L.DomUtil.create('div', '', graphCard);
            graphCanvasContainer.id = 'navigation-graph-container';
            graphCanvasContainer.style.width = '100%';
            graphCanvasContainer.style.height = '100%';
            const canvas = L.DomUtil.create('canvas', '', graphCanvasContainer);
            canvas.id = 'navigation-chart';
            L.DomEvent.disableClickPropagation(graphCard);
            this._updateGraphTitle();
            return container;
        },
        _toggleGraphMode: function(e) {
            if (e) L.DomEvent.stopPropagation(e);
            if (!navigationCurrentRouteData) {
                showToast("La gráfica estará disponible cuando se calcule una ruta.", "info");
                return;
            }
            const modes = ['Desviación ETA', 'Altitud', 'Gráfica off'];
            let currentIndex = modes.indexOf(currentGraphMode);
            currentIndex = (currentIndex + 1) % modes.length;
            currentGraphMode = modes[currentIndex];
            localStorage.setItem(GRAPH_STATE_KEY, currentGraphMode); 
            updateNavigationGraphVisibilityAndMode();
            if (currentGraphMode !== 'Gráfica off') {
                showToast(`Gráfica cambiada a: ${currentGraphMode}`, 'info');
            } else {
                showToast(`Gráfica desactivada`, 'info');
            }
        },
        _updateGraphTitle: function() {
            const graphTitleElement = document.getElementById('navigation-graph-title');
            if (graphTitleElement) {
                if (currentGraphMode === 'Desviación ETA') {
                    graphTitleElement.textContent = 'Desviación ETA';
                } else if (currentGraphMode === 'Altitud') {
                    graphTitleElement.textContent = 'Desnivel Ruta';
                } else {
                    graphTitleElement.textContent = ''; 
                }
            }
        },
        onRemove: function(map) { },
        updateOrientation: function(heading) {
            const compassRoseIcon = document.getElementById('compass-rose-icon');
            const orientationText = document.getElementById('orientation-text');
            if (compassRoseIcon && orientationText) {
                if (heading !== null && !isNaN(heading) && heading >= 0 && heading <= 360) {
                    compassRoseIcon.style.transform = `rotate(${heading}deg)`;
                    currentMapBearing = heading;
                    const directions = ["N", "NE", "E", "SE", "S", "SO", "O", "NO", "N"];
                    const index = Math.round(heading / 45) % 8;
                    orientationText.textContent = `${directions[index]}`;
                } else {
                    compassRoseIcon.style.transform = 'rotate(0deg)';
                    orientationText.textContent = '---';
                    currentMapBearing = 0;
                }
            }
        },
        updateAltitude: function(altitude) {
            const altitudeDisplay = document.getElementById('altitude-display');
            if (altitudeDisplay) {
                let displayText = '--- m';
                if (altitude !== null && !isNaN(altitude)) {
                    displayText = `${altitude.toFixed(0)} m`;
                    if (maxAltitudeDuringTrip !== -Infinity && isNavigating) {
                        displayText += ` \u2261 ${maxAltitudeDuringTrip.toFixed(0)} m`;
                    }
                } else if (isNavigating && maxAltitudeDuringTrip !== -Infinity) {
                     displayText = `-- m \u2261 ${maxAltitudeDuringTrip.toFixed(0)} m`;
                }
                altitudeDisplay.textContent = displayText;
            }
        },
        updateCurrentSpeed: function(speedKmh) {
            const speedDisplay = document.getElementById('current-speed-display');
            if (speedDisplay) {
                if (speedKmh !== null && !isNaN(speedKmh)) {
                    speedDisplay.textContent = `${speedKmh.toFixed(1)} km/h`;
                } else {
                    speedDisplay.textContent = '--- km/h';
                }
            }
        },
        updateAverageSpeed: function(avgSpeedKmh) {
            const avgSpeedDisplay = document.getElementById('average-speed-display');
            if (avgSpeedDisplay) {
                let displayText = 'Med: --- km/h';
                if (avgSpeedKmh !== null && !isNaN(avgSpeedKmh) && (isNavigating || (isSimulatingGpsLocation && automatedSimulationIntervalId))) {
                     displayText = `Med: ${avgSpeedKmh.toFixed(1)} km/h`;
                }
                avgSpeedDisplay.textContent = displayText;
            }
        },
        updateMaxSpeed: function(currentSpeedKmh, currentCoords) {
            if (typeof currentSpeedKmh === 'number' && currentSpeedKmh > maxSpeedDuringTrip) {
                maxSpeedDuringTrip = currentSpeedKmh;
                if (currentCoords) {
                    maxSpeedCoordinates = { lat: currentCoords.latitude, lng: currentCoords.longitude };
                }
            }
            const maxSpeedDisplay = document.getElementById('max-speed-display');
            if (maxSpeedDisplay) {
                let displayText = 'Máx: --- km/h'; 
                if (typeof maxSpeedDuringTrip === 'number' && !isNaN(maxSpeedDuringTrip)) {
                    if (maxSpeedDuringTrip > 0) {
                        displayText = `Máx: ${maxSpeedDuringTrip.toFixed(1)} km/h`;
                    } else if ((isNavigating || (isSimulatingGpsLocation && automatedSimulationIntervalId)) && maxSpeedDuringTrip === 0) {
                        displayText = `Máx: 0.0 km/h`;
                    }
                }
                maxSpeedDisplay.textContent = displayText;
            }
        }
    });
    L.control.compassAndMode = function(opts) {
        return new L.Control.CompassAndMode(opts);
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleMapHeaderRowsVisibility
    // RESUMEN: Muestra u oculta las filas de botones en la cabecera del mapa.
    // ===================================================================
    function toggleMapHeaderRowsVisibility(show) {
        const header = document.getElementById('reminders-location-map-header');
        if (!header) return;
        mapHeaderButtonsVisible = show;
        header.querySelectorAll('.button-row').forEach(row => {
            row.classList.toggle('hidden-map-header', !show);
        });
        if (navigationMapInstance) {
            setTimeout(() => {
                if (navigationMapInstance) {
                    try {
                        navigationMapInstance.invalidateSize();
                    } catch(e) {
                        console.error("Error al invalidar el tamaño del mapa:", e);
                    }
                }
            }, 350);
        }
    }
    
    
    
    
    
    
    
    // ===================================================================
// NOMBRE: handleLocateMeClick
// RESUMEN: Maneja el clic en el botón de "Estás Aquí" para centrar o dejar de seguir al usuario.
// ===================================================================
function handleLocateMeClick(locateMeButton) {
    if (!navigationMapInstance || !locateMeButton) return;
    
    if (window.followMeReactivationTimer) {
        clearTimeout(window.followMeReactivationTimer);
        window.followMeReactivationTimer = null;
        showToast('Seguimiento manual gestionado.', 'info');
    }

    const locateMeImg = locateMeButton.querySelector('img');
    const isSatelliteWithLabelsLayer = (localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "").toLowerCase().includes("satélite + calles");
    const targetZoom = isSatelliteWithLabelsLayer ? 17 : 19;

    if (locateMeButton.title.includes("Mostrar mi posición")) {
        shouldCenterOnUser = true; navigationFollowUser = true;
        if(locateMeImg) locateMeImg.src = "DEJARSEGUIR.PNG";
        locateMeButton.title = "Dejar de centrar el mapa en mi posición";
        if (navigationCurrentLocation) {
            navigationMapInstance.setView([navigationCurrentLocation.latitude, navigationCurrentLocation.longitude], targetZoom);
        } else {
            getCurrentLocation(coords => {
                if (navigationMapInstance) navigationMapInstance.setView([coords.latitude, coords.longitude], targetZoom);
                updateInitialUserPosition(coords, navigationMapInstance);
            }, () => showToast("No se pudo obtener tu ubicación.", "warning"));
        }
    } else {
        shouldCenterOnUser = false; navigationFollowUser = false;
        if(locateMeImg) locateMeImg.src = "ESTASAQUI.PNG";
        locateMeButton.title = "Mostrar mi posición actual y activar seguimiento";
        targetMapCenterOffset = { x: 0, y: 0 };
        if (navigationMapInstance) navigationMapInstance.panTo(navigationMapInstance.getCenter(), { animate: false });
    }
    updateStartNavigationButtonState(); updateNavigationButtonColor(); updateDirectionWarningCardsVisibility();
}
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleZoomToggleButtonClick
    // RESUMEN: Alterna el zoom del mapa entre la vista completa de la ruta y la vista del coche.
    // ===================================================================
    function handleZoomToggleButtonClick(zoomButton) {
        if (!navigationMapInstance || !zoomButton) return;
        const currentState = zoomButton.dataset.zoomState;
        const img = zoomButton.querySelector('img');
        if (!img) return;
        if (currentState === 'waypoints' || currentState === 'no_route_zoom_out') {
            if (navigationCurrentLocation) {
                const targetZoom = (navigationMapInstance.getMaxZoom() || 19) - 1;
                zoomButton.dataset.zoomState = 'car';
                img.src = 'ZOOM-.PNG';
                zoomButton.title = "Zoom para ver la ruta completa";
                navigationMapInstance.setView([navigationCurrentLocation.latitude, navigationCurrentLocation.longitude], targetZoom, { animate: true, duration: 0.5 });
            }
        } else {
            if (navigationRouteLayer?.getBounds().isValid()) {
                navigationMapInstance.fitBounds(navigationRouteLayer.getBounds().pad(0.15), { animate: true, duration: 0.5 });
                zoomButton.dataset.zoomState = 'waypoints';
            } else {
                navigationMapInstance.setView(navigationMapInstance.getCenter(), 10, { animate: true, duration: 0.5 });
                zoomButton.dataset.zoomState = 'no_route_zoom_out';
            }
            img.src = 'ZOOM+.PNG';
            zoomButton.title = "Zoom a la ubicación del coche";
        }
    }
    
    
    
    
    
    
    


// ===================================================================
// NOMBRE: handleLoadOrDeleteRouteClick
// RESUMEN: Borra la ruta actual del mapa.
// ===================================================================
function handleLoadOrDeleteRouteClick(button) {
    lastAutoShownManeuverId = null;
    if (isNavigating) {
        toggleNavigationState();
    }
    if (isSimulatingGpsLocation) {
        stopAutomatedRouteSimulation();
    }
    clearNavigationGraph();
    clearAllWaypointMarkersFromMap();
    navigationWaypoints = [];
    if (navigationRouteLayer) { 
        try { 
            navigationMapInstance.removeLayer(navigationRouteLayer); 
        } catch (e) {} 
        navigationRouteLayer = null; 
    }
    if (completedRouteSegmentsLayer) completedRouteSegmentsLayer.clearLayers();
    if (maxSpeedMarkerLayer) maxSpeedMarkerLayer.clearLayers();
    if (speedMilestoneLayer) speedMilestoneLayer.clearLayers();
    navigationCurrentRouteData = null;
    hideNavigationUI();
    hideMapInfoOverlay();
    eliminarRadaresDeRuta();
    eliminarTareasDeBarraProgreso();
    clearChargingPoints();
    actualizarContadorRadares(0);
    actualizarContadorTareas(0);
    showToast("Ruta actual borrada del mapa", "info");
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}
    
    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleAddRadarHereClick
    // RESUMEN: Crea un recordatorio de tipo RADAR en la ubicación actual del usuario.
    // ===================================================================
    function handleAddRadarHereClick(button) {
        button.disabled = true;
        const radarImg = button.querySelector('img');
        if (radarImg) radarImg.src = "MARCANDO.PNG";
        getCurrentLocation(
            (coords) => {
                const now = new Date();
                const newRadarReminder = {
                    id: Date.now(),
                    text: '<b>RADAR: EN ESTA UBICACION (Añadido manualmente)</b>',
                    type: 'simple',
                    time: `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`,
                    date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                    createdAt: now.toISOString(),
                    managedByUser: false,
                    isLocationEnabled: true,
                    locationCoordinates: { latitude: coords.latitude, longitude: coords.longitude },
                    radiusMeters: 350,
                    excludeFromList: true
                };
                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                reminders.push(newRadarReminder);
                localStorage.setItem('reminders', JSON.stringify(reminders));
                showToast("Recordatorio RADAR creado en tu ubicación (radio 350m)", "success");
                updateReminderCount();
                updateButtonStyles();
                if (navigationMapInstance) {
                    plotSingleReminderOnMap(newRadarReminder, navigationMapInstance);
                    navigationMapInstance.setView([coords.latitude, coords.longitude], 15);
                }
                button.disabled = false;
                if (radarImg) radarImg.src = "RADARAQUI.PNG";
            },
            (errorMsg) => {
                showToast(`Error al obtener ubicación para RADAR: ${errorMsg}`, "error");
                button.disabled = false;
                if (radarImg) radarImg.src = "RADARAQUI.PNG";
            }
        );
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleSimulateGpsPositionClick
    // RESUMEN: Maneja el clic en el mapa durante la simulación GPS manual.
    // ===================================================================
    function handleSimulateGpsPositionClick(e, forceExactPosition = false) {
        if (!isSimulatingGpsLocation || !navigationMapInstance) return;
        if (automatedSimulationIntervalId) {
            stopAutomatedRouteSimulationInternal();
            showToast("Simulación automática detenida. Posición GPS fijada manualmente.", "info");
        }
        let latLngToUse = e.latlng;
        if (!forceExactPosition && navigationRouteLayer && navigationRouteLayer.getLatLngs().length > 0 && typeof L.GeometryUtil !== 'undefined' && L.GeometryUtil.closest) {
            const closestPointOnRoute = L.GeometryUtil.closest(navigationMapInstance, navigationRouteLayer, e.latlng);
            if (closestPointOnRoute && closestPointOnRoute.distance < 50) { 
                latLngToUse = L.latLng(closestPointOnRoute.lat, closestPointOnRoute.lng);
            }
        }
        simulatedGpsLocation = {
            latitude: latLngToUse.lat,
            longitude: latLngToUse.lng,
            accuracy: 10,
            heading: navigationCurrentLocation ? navigationCurrentLocation.heading : 0,
            altitude: navigationCurrentLocation ? navigationCurrentLocation.altitude : 0,
            speed: 0
        };
        processSimulatedGpsPosition(true); 
        setNavigationMapClickHandler(); 
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: stopAutomatedRouteSimulationInternal
    // RESUMEN: Detiene la simulación automática de ruta sin cambiar el estado general.
    // ===================================================================
    function stopAutomatedRouteSimulationInternal() {
        if (automatedSimulationIntervalId) {
            clearInterval(automatedSimulationIntervalId);
            automatedSimulationIntervalId = null;
        }
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) {
        }
        setNavigationMapClickHandler();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleGpsSimulationToggle
    // RESUMEN: Activa/desactiva el modo de simulación GPS.
    // ===================================================================
    function handleGpsSimulationToggle() {
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        const mapDiv = document.getElementById('reminders-location-map-div');
        if (isSimulatingGpsLocation) { 
            stopAutomatedRouteSimulationInternal(); 
            isSimulatingGpsLocation = false;
            reactivateRealGpsAfterSimulation();
            if (mapDiv) mapDiv.classList.remove('simulating-gps-click-mode');
            if (simulateGpsButton) {
                simulateGpsButton.classList.remove('active-simulate-gps-mode'); 
                simulateGpsButton.title = "Activar Simulación GPS (recorrido automático o clic manual)";
            }
            showToast("Modo simulación GPS desactivado. Volviendo a GPS real.", "info");
        } else { 
            isSimulatingGpsLocation = true;
            if (locationWatchId !== null && navigator.geolocation) {
                navigator.geolocation.clearWatch(locationWatchId);
                locationWatchId = null;
            }
            if (simulateGpsButton) {
                simulateGpsButton.classList.add('active-simulate-gps-mode'); 
                simulateGpsButton.title = "Desactivar Simulación GPS (Volver a GPS Real)";
            }
            if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0] && navigationWaypoints.length >= 2) {
                showSimulationSpeedModal(simulationSpeedKmph, (newSpeed) => {
                    simulationSpeedKmph = newSpeed;
                    startAutomatedRouteSimulation(simulationSpeedKmph); 
                    if (mapDiv) mapDiv.classList.remove('simulating-gps-click-mode'); 
                });
            } else {
                if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode'); 
                showToast("Modo simulación GPS por clic ACTIVADO. Carga una ruta para recorrido automático o toca el mapa.", "info", 6000);
            }
        }
        setNavigationMapClickHandler();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: startAutomatedRouteSimulation
    // RESUMEN: Inicia la simulación automática de una ruta a una velocidad determinada.
    // ===================================================================
    function startAutomatedRouteSimulation(speedKmph) {
        if (!isSimulatingGpsLocation) {
            showToast("Error: El modo de simulación GPS no está activo.", "error");
            return;
        }
        if (!navigationRouteLayer || !navigationCurrentRouteData || !navigationCurrentRouteData.routes[0] || navigationWaypoints.length < 2) {
            showToast("No hay ruta válida para simular.", "warning");
            stopAutomatedRouteSimulationInternal();
            if (isSimulatingGpsLocation) { 
                const mapDiv = document.getElementById('reminders-location-map-div');
                if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode');
                setNavigationMapClickHandler();
            }
            return;
        }
        if (automatedSimulationIntervalId) clearInterval(automatedSimulationIntervalId);
        if (!isNavigating) {
            toggleNavigationState(); 
        }
        simulationSpeedKmph = speedKmph;
        currentSimulationSpeedKmph = speedKmph;
        const routeLine = navigationRouteLayer.getLatLngs();
        const route = navigationCurrentRouteData.routes[0];
        const startWaypoint = navigationWaypoints.find(wp => wp.type === 'S' || wp.isRecalculatedStart) || navigationWaypoints[0];
        let initialHeading = 0;
        if (routeLine.length >= 2) {
            const firstPoint = turf.point([routeLine[0].lng, routeLine[0].lat]);
            const secondPoint = turf.point([routeLine[1].lng, routeLine[1].lat]);
            initialHeading = turf.bearing(firstPoint, secondPoint);
            if (initialHeading < 0) initialHeading += 360;
        }
        simulatedGpsLocation = {
            latitude: startWaypoint.lat,
            longitude: startWaypoint.lng,
            accuracy: 5,
            heading: initialHeading,
            altitude: (navigationCurrentLocation?.altitude) ?? 0,
            speed: 0
        };
        simulatedDistanceAlongRoute = 0;
        lastCarDistanceAlongRouteForNavLogic = 0;
        lastValidCarDistanceForDisplay = 0;
        totalDistanceTravelledForStats = 0;
        if (!navigationStartTimeForStats || !isNavigating) {
            navigationStartTimeForStats = new Date();
        }
        maxSpeedDuringTrip = 0;
        maxSpeedCoordinates = { lat: startWaypoint.lat, lng: startWaypoint.lng };
        processSimulatedGpsPosition(true); 
        const totalRouteDistance = route.distance;
        showToast(`Simulación automática de ruta iniciada a ${speedKmph.toFixed(0)} km/h (velocidad variable).`, "info");
        setNavigationMapClickHandler(); 
        let simulationStepIndex = 0;
        let simulationLegIndex = 0;
        let distanceToEndOfCurrentStep = calculateDistanceToEndOfStep(route, 0, 0);
        automatedSimulationIntervalId = setInterval(() => {
            const speedMps = (currentSimulationSpeedKmph * 1000) / 3600;
            const distanceIncrement = speedMps * (SIMULATION_TICK_INTERVAL_MS / 1000);
            simulatedDistanceAlongRoute += distanceIncrement;
            totalDistanceTravelledForStats = simulatedDistanceAlongRoute;
            if (simulatedDistanceAlongRoute > distanceToEndOfCurrentStep) {
                simulationStepIndex++;
                if (simulationStepIndex >= route.legs[simulationLegIndex].steps.length) {
                    simulationStepIndex = 0;
                    simulationLegIndex++;
                }
                if (simulationLegIndex < route.legs.length) {
                    const currentStep = route.legs[simulationLegIndex].steps[simulationStepIndex];
                    const multiplier = getRandomSpeedMultiplierForManeuver(currentStep.maneuver);
                    let newSpeed = simulationSpeedKmph * (1 + multiplier);
                    currentSimulationSpeedKmph = Math.max(20, Math.min(160, newSpeed));
                    distanceToEndOfCurrentStep = calculateDistanceToEndOfStep(route, simulationLegIndex, simulationStepIndex);
                }
            }
            if (simulatedDistanceAlongRoute >= totalRouteDistance) {
                stopAutomatedRouteSimulationInternal();
                const endPointCoords = routeLine[routeLine.length - 1];
                simulatedGpsLocation = {
                    ...simulatedGpsLocation,
                    latitude: endPointCoords.lat,
                    longitude: endPointCoords.lng,
                    speed: 0
                };
                processSimulatedGpsPosition(true);
                showToast("Simulación de ruta completada. Modo simulación por clic activo.", "success");
                const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
                const mapDiv = document.getElementById('reminders-location-map-div');
                if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode'); 
                if (isNavigating || (!isNavigating && navigationWaypoints.length > 0)) {
                     showArrivalStatsModal();
                }
                setNavigationMapClickHandler();
                return;
            }
            const turfLine = turf.lineString(routeLine.map(p => [p.lng, p.lat]));
            const pointOnLine = turf.along(turfLine, simulatedDistanceAlongRoute / 1000, { units: 'kilometers' });
            if (pointOnLine && pointOnLine.geometry && pointOnLine.geometry.coordinates) {
                const [lng, lat] = pointOnLine.geometry.coordinates;
                let headingSim = 0;
                const lookAheadDistance = Math.min(distanceIncrement * 2, totalRouteDistance - simulatedDistanceAlongRoute);
                if (simulatedDistanceAlongRoute + lookAheadDistance <= totalRouteDistance && lookAheadDistance > 0) {
                    const nextPointOnLine = turf.along(turfLine, (simulatedDistanceAlongRoute + lookAheadDistance) / 1000, { units: 'kilometers' });
                    if (nextPointOnLine && nextPointOnLine.geometry && nextPointOnLine.geometry.coordinates) {
                        headingSim = turf.bearing(pointOnLine, nextPointOnLine);
                        if (headingSim < 0) headingSim += 360;
                    }
                } else {
                    if (simulatedGpsLocation && typeof simulatedGpsLocation.heading === 'number' && simulatedGpsLocation.heading !== null) {
                        headingSim = simulatedGpsLocation.heading;
                    }
                }
                simulatedGpsLocation = {
                    latitude: lat,
                    longitude: lng,
                    accuracy: 5,
                    heading: headingSim,
                    altitude: (navigationCurrentLocation?.altitude) ?? 0,
                    speed: speedMps
                };
                processSimulatedGpsPosition(false);
            }
        }, SIMULATION_TICK_INTERVAL_MS);
    }
    
    
    
    
    
    
    



// ===================================================================
// NOMBRE: processSimulatedGpsPosition
// RESUMEN: Procesa la posición GPS simulada y actualiza el estado de la navegación.
// ===================================================================
function processSimulatedGpsPosition(forceExactPosition = false) {
    if (!isSimulatingGpsLocation || !simulatedGpsLocation) return;
    navigationCurrentLocation = { ...simulatedGpsLocation };
    updateInitialUserPosition(navigationCurrentLocation, navigationMapInstance);
    if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
        const route = navigationCurrentRouteData.routes[0];
        let carDistTurf = 0;
        if (navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
            try {
                const carPointTurf = turf.point([simulatedGpsLocation.longitude, simulatedGpsLocation.latitude]);
                const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                let nearestPointOnLineTurf;
                if (forceExactPosition) {
                     nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                } else {
                    nearestPointOnLineTurf = carPointTurf;
                }
                const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
            } catch (turfError) {
            }
         }
        
        // ----- INICIO DE LA CORRECCIÓN -----
        // Se asegura que una etapa marcada como 'visitada' no pueda volver a 'no visitada'.
        let cumulativeDistance = 0;
        navigationWaypoints.forEach((wp, index) => {
            if (wp && !wp.visited) { // Solo se evalúan las etapas que NO han sido visitadas.
                const isStartPoint = wp.type === 'S' || wp.isRecalculatedStart;
                const isIntermediate = wp.type === 'intermediate';
                const isFinal = wp.type === 'F';
        
                if (isStartPoint) {
                    wp.visited = true;
                } else if (isIntermediate && route.legs && (index - 1) < route.legs.length) {
                    const leg = route.legs[index - 1];
                    if (leg) {
                        cumulativeDistance += (leg.distance || 0);
                        if (carDistTurf >= cumulativeDistance - WAYPOINT_VISITED_THRESHOLD_METERS) {
                            wp.visited = true;
                        }
                    }
                } else if (isFinal) {
                    if (carDistTurf >= route.distance - WAYPOINT_VISITED_THRESHOLD_METERS) {
                        wp.visited = true;
                    }
                }
            } else if (wp && wp.visited && wp.type === 'intermediate') {
                // Si ya está visitada, solo actualizamos la distancia acumulada para los siguientes cálculos
                if (route.legs && (index - 1) < route.legs.length) {
                    const leg = route.legs[index - 1];
                    if (leg) {
                        cumulativeDistance += (leg.distance || 0);
                    }
                }
            }
        });
        renderWaypointMarkers();
        // ----- FIN DE LA CORRECCIÓN -----

        lastCarDistanceAlongRouteForNavLogic = carDistTurf;
        updateTurnByTurnDisplay(route, carDistTurf);
        updateNavigationProgressDisplay(route, carDistTurf);
    }
    if (!automatedSimulationIntervalId) { 
        showToast(`Posición GPS simulada: ${simulatedGpsLocation.latitude.toFixed(4)}, ${simulatedGpsLocation.longitude.toFixed(4)}`, "info");
    }
}


    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: setNavigationMapClickHandler
    // RESUMEN: Asigna el manejador de clics correcto al mapa según el modo actual.
    // ===================================================================
    function setNavigationMapClickHandler() {
        if (!navigationMapInstance) return;
        if (navigationMapClickHandler) {
            navigationMapInstance.off('click', navigationMapClickHandler);
            navigationMapClickHandler = null;
        }
        const mapDiv = document.getElementById('reminders-location-map-div');
        if (mapDiv) {
            mapDiv.classList.remove('add-reminder-mode', 'simulating-gps-click-mode', 'navigating');
        }
        if (isAddReminderAtLocationModeActive) {
            navigationMapClickHandler = handleMapClickToAddReminder;
            if (mapDiv) mapDiv.classList.add('add-reminder-mode');
        } else if (isSimulatingGpsLocation) {
            navigationMapClickHandler = (e) => {
                if (automatedSimulationIntervalId) {
                    stopAutomatedRouteSimulationInternal();
                    showToast("Simulación automática detenida. Posición GPS fijada manualmente.", "info");
                }
                handleSimulateGpsPositionClick(e, true);
            };
            if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode');
        } else if (!isNavigating) {
            navigationMapClickHandler = (e) => addWaypoint(e.latlng);
        } else {
            if (mapDiv) mapDiv.classList.add('navigating');
            navigationMapClickHandler = null;
        }
        if (navigationMapClickHandler) {
            navigationMapInstance.on('click', navigationMapClickHandler);
        }
    }
    
    
    
    
    
    
    
    
// ===================================================================
// NOMBRE: showSimulationSpeedModal
// RESUMEN: Muestra un modal para que el usuario introduzca la velocidad de simulación.
// ===================================================================
function showSimulationSpeedModal(defaultSpeed, callback) {
    closeOtherModals('simulation-speed-modal');
    let modal = document.getElementById('simulation-speed-modal');
    if (modal) modal.remove();
    modal = document.createElement('div');
    modal.id = 'simulation-speed-modal';
    // --- HTML del modal actualizado con el slider ---
    modal.innerHTML = `
        <h2>Velocidad de Simulación</h2>
        <div class="filter-group" style="margin-bottom: 20px;">
            <label id="speed-range-label">Velocidad: ${defaultSpeed} km/h</label>
            <div class="slider-container single-slider-container" style="height: 25px;">
                <div class="slider-track"></div>
                <div class="slider-range" id="speed-slider-range"></div>
                <div class="slider-thumb" id="speed-thumb" style="left: 0%;"></div>
            </div>
        </div>
        <div class="modal-top-buttons">
            <button id="confirm-simulation-speed">Aceptar <span class="button-countdown-timer"></span></button>
            <button id="cancel-simulation-speed">Cancelar</button>
        </div>
    `;
    document.body.appendChild(modal);

    // --- LÓGICA DEL SLIDER DE VELOCIDAD ---
    const speedSliderContainer = modal.querySelector('#speed-thumb').parentElement;
    const speedThumb = modal.querySelector('#speed-thumb');
    const speedRange = modal.querySelector('#speed-slider-range');
    const speedLabel = modal.querySelector('#speed-range-label');
    const minSpeed = 1;
    const maxSpeed = 5000;
    let currentSpeed = defaultSpeed || 90;

    const updateSpeedVisuals = () => {
        const minLog = Math.log(minSpeed);
        const maxLog = Math.log(maxSpeed);
        const percent = (Math.log(currentSpeed) - minLog) / (maxLog - minLog);
        
        speedThumb.style.left = `${percent * 100}%`;
        speedRange.style.width = `${percent * 100}%`;
        speedLabel.textContent = `Velocidad: ${Math.round(currentSpeed)} km/h`;
    };

    const onSpeedDrag = (e) => {
        const rect = speedSliderContainer.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        let percent = (clientX - rect.left) / rect.width;
        percent = Math.max(0, Math.min(1, percent));
        
        const minLog = Math.log(minSpeed);
        const maxLog = Math.log(maxSpeed);
        currentSpeed = Math.exp(minLog + percent * (maxLog - minLog));
        
        updateSpeedVisuals();
    };

    const startSpeedDrag = (e) => {
        const moveHandler = (moveEvent) => onSpeedDrag(moveEvent);
        const endDrag = () => {
            document.removeEventListener('mousemove', moveHandler);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchmove', moveHandler);
            document.removeEventListener('touchend', endDrag);
        };
        document.addEventListener('mousemove', moveHandler);
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchmove', moveHandler);
        document.addEventListener('touchend', endDrag);
    };
    
    speedThumb.addEventListener('mousedown', startSpeedDrag);
    speedThumb.addEventListener('touchstart', startSpeedDrag);
    updateSpeedVisuals();
    
    // --- Lógica de los botones ---
    const confirmBtn = modal.querySelector('#confirm-simulation-speed');
    const cancelBtn = modal.querySelector('#cancel-simulation-speed');
    const closeHandler = () => {
        clearModalAutoCloseTimer(modal, confirmBtn, 'simulation-speed-modal');
        if (modal.parentNode) modal.remove();
    };

    confirmBtn.addEventListener('click', () => {
        callback(Math.round(currentSpeed));
        closeHandler();
    });

    cancelBtn.addEventListener('click', () => {
        showToast("Inicio de simulación cancelado", "info");
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) simulateGpsButton.classList.remove('active-simulate-gps-mode');
        isSimulatingGpsLocation = false;
        reactivateRealGpsAfterSimulation();
        setNavigationMapClickHandler();
        closeHandler();
    });

    addModalAutoCloseTimer(modal, confirmBtn, 'simulation-speed-modal', 30000);
}


    
    
    
    
    




// ===================================================================
// NOMBRE: showReminderModal
// RESUMEN: Muestra el modal para crear o modificar un recordatorio.
// ===================================================================
function showReminderModal(reminder = null, options = {}) {
    const mapShouldReopenAfterForm = sessionStorage.getItem('boardinggate_map_should_reopen_after_form') === 'true';
    const mapContextBeforeThisModal = sessionStorage.getItem('mapContext');
    closeOtherModals();
    let autoSaveInterval = null; let parseTimeout = null; let restartTimeout = null; let focusTimeout = null; let countdownSave = 25; let manualTimeInput = false; let lastInputWasSpeech = false;
    let currentReminderLocation = null;
    let locationEnabledByUser = false;
    let mapExpandedManually = false;
    let mapMoveDebounceTimer = null;
    function cleanUpModalTimers(clearAll = true) {
        if (autoSaveInterval) { clearInterval(autoSaveInterval); autoSaveInterval = null; }
        if (clearAll) {
            if (parseTimeout) clearTimeout(parseTimeout);
            if (restartTimeout) clearTimeout(restartTimeout);
            if (focusTimeout) clearTimeout(focusTimeout);
            parseTimeout = null; restartTimeout = null; focusTimeout = null;
        }
    }
    const existingModal = document.querySelector('.reminder-modal');
    if (existingModal && typeof existingModal.cleanUpModalTimers === 'function') {
        existingModal.cleanUpModalTimers(true);
        if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal);
    }
    let isNew = true;
    let parsed = {
         id: null, text: '', time: null, date: null, repeatDays: [], intervalDays: null, type: 'simple',
         createdAt: new Date().toISOString(), managedByUser: false,
         isLocationEnabled: false, locationCoordinates: null, radiusMeters: DEFAULT_LOCATION_RADIUS,
         excludeFromList: false
    };
    if (reminder && typeof reminder.id === 'number' && reminder.id !== null) {
        const remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
        const foundReminder = remindersFromStorage.find(r => r.id === reminder.id);
        if (foundReminder) {
            parsed = { ...foundReminder };
            isNew = false;
        } else {
            parsed = { ...reminder, id: null, createdAt: new Date().toISOString(), managedByUser: false };
            isNew = true;
            if(reminder.text && reminder.text.toUpperCase().includes("RADAR RUTA:")) {
                 parsed.text = reminder.text.replace("RADAR RUTA:", "RADAR:");
                 parsed.excludeFromList = true;
                 parsed.radiusMeters = 350;
            }
        }
    } else if (reminder) {
        parsed = { ...reminder, id: null, createdAt: new Date().toISOString(), managedByUser: false };
        isNew = true;
         if(reminder.text && reminder.text.toUpperCase().includes("RADAR RUTA:")) {
            parsed.text = reminder.text.replace("RADAR RUTA:", "RADAR:");
            parsed.excludeFromList = true;
            parsed.radiusMeters = 350;
        }
    }
    if (parsed.text && parsed.text.toUpperCase().startsWith("<b>RADAR:") && (parsed.radiusMeters === DEFAULT_LOCATION_RADIUS || !parsed.radiusMeters)) {
        parsed.radiusMeters = 350;
    }
    if (!isNew && !parsed.createdAt) { parsed.createdAt = new Date(0).toISOString(); }
    locationEnabledByUser = parsed.isLocationEnabled;
    currentReminderLocation = parsed.locationCoordinates;
    let fmtDate = '';
    if (parsed.date?.match(/^\d{4}-\d{2}-\d{2}$/)) {
        try {
            const [y,m,d] = parsed.date.split('-');
            const dt=new Date(Date.UTC(y,m-1,d));
            if(!isNaN(dt.getTime())&&dt.getUTCDate()==d&&dt.getUTCMonth()==m-1) {
                fmtDate=`${d.toString().padStart(2,'0')}/${m.toString().padStart(2,'0')}/${y}`;
            }
        } catch(e){}
    }
    const modal = document.createElement('div');
    modal.className = 'reminder-modal';
    modal.setAttribute('aria-label','Formulario recordatorio');
    const titleHtml = `
        <div style="display: flex; align-items: center; justify-content: space-between; width: 100%; flex-wrap: wrap;">
            <span class="font-bold" style="font-size: 1.5rem; margin-right: auto;">${isNew ? 'NUEVO RECORDATORIO' : 'MODIFICAR RECORDATORIO'}</span>
            <div style="display: flex; align-items: center; margin-left: 35px; white-space: nowrap;">
                <input type="checkbox" id="reminder-exclude-from-list" ${parsed.excludeFromList ? 'checked' : ''} style="transform: scale(1.1); margin-right: 5px;">
                <label for="reminder-exclude-from-list" style="font-size: 0.9rem; font-weight: normal; color: #555;">NO INCLUIRLO EN LA LISTA (radares, etc)</label>
            </div>
        </div>`;
    modal.innerHTML = `
         <h2 style="display: flex; align-items: center; justify-content: center; text-align: center;">${titleHtml}</h2>
         <div class="modal-top-buttons full-width" style="margin-top: 1rem; margin-bottom: 0.8rem;">
            <button type="submit" id="save-reminder">Aceptar <span id="countdown-save">25</span></button>
            <button type="button" id="cancel-reminder">Cancelar</button>
            <button type="button" id="delete-reminder" title="Borrar este recordatorio permanentemente">Borrar</button>
            <button type="button" id="view-reminders">Ver Recordatorios</button>
            <button type="button" id="manage-saved-locations">Ubicaciones</button>
            <button type="button" id="help-reminder">Ayuda</button>
         </div>
         <p id="parse-status" class="text-sm mt-1"></p>
         <form id="reminder-form">
             <div class="full-width">
                <div style="display:flex;align-items:center;gap:.5rem;">
                    <button type="button" id="clear-fields" class="speech-button" title="Limpiar" style="background-color:#D1D5DB;color:#111827;flex-shrink:0;">Limpiar</button>
                    <textarea id="reminder-text" rows="4" required style="flex-grow:1;">${parsed.text.replace(/<b>|<\/b>/gi,'')}</textarea>
                    <button type="button" id="start-speech" class="speech-button" title="Voz" style="flex-shrink:0;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                    </button>
                </div>
                <p id="speech-status" class="speech-status"></p>
             </div>
             <div class="form-grid">
                 <div>
                     <label for="reminder-time">Hora:</label>
                     <input type="text" id="reminder-time" placeholder="HH:MM" pattern="\\d{2}:\\d{2}" value="${parsed.time||''}">
                 </div>
                 <div>
                     <label for="reminder-date">Fecha:</label>
                     <input type="text" id="reminder-date" placeholder="DD/MM/AAAA" pattern="\\d{2}/\\d{2}/\\d{4}" value="${fmtDate}">
                 </div>
                 <div style="display: flex; flex-direction: column; align-items: flex-start;">
                     <label for="reminder-interval" style="margin-bottom: 0.25rem; line-height: 1.2;">Intervalo<br>(días):</label>
                     <div style="display: flex; align-items: center; gap: 0.5rem;">
                         <input type="number" id="reminder-interval" min="1" max="9999" value="${parsed.intervalDays||''}" style="width: 90px;">
                         <input type="checkbox" id="location-enabled" ${parsed.isLocationEnabled ? 'checked' : ''} style="margin-left: 8px; transform: scale(1.2); margin-right: 0.2rem;">
                         <label for="location-enabled" style="font-weight: bold; white-space: nowrap; font-size: 1.1rem; color: #374151;">Ubicación</label>
                     </div>
                 </div>
                 <div class="location-controls-group" style="justify-content: flex-start; margin-top: 0; align-items: center;">
                    <button type="button" id="expand-map-button">Ampliar Mapa</button>
                 </div>
             </div>
             
             <div id="radius-slider-group" class="filter-group" style="grid-column: 1 / -1; margin-bottom: 10px; margin-top: 10px;">
                 <label id="radius-range-label">RADIO ACCIÓN (si marca ubicación): ${parsed.radiusMeters || 350} metros</label>
                 <div class="slider-container single-slider-container" style="height: 25px; width: 100%;">
                     <div class="slider-track"></div>
                     <div class="slider-range" id="radius-slider-range"></div>
                     <div class="slider-thumb" id="radius-thumb" style="left: 0%;"></div>
                 </div>
             </div>
    
             <div id="location-map-container" class="full-width">
                 <button type="button" id="reduce-map-button" class="hidden">REDUCIR MAPA</button>
                 <button type="button" id="locate-me-button" class="hidden">ESTÁS AQUÍ</button>
             </div>
             <div class="days-group full-width">
                 <label>Días repetición:</label>
                 ${['Lun ','Mar ','Mié ','Jue ','Vie ','Sáb ','Dom '].map((d,i)=>`<label style="flex:0 0 auto;"><input type="checkbox" name="repeat" value="${(i+1)%7}" ${parsed.repeatDays?.includes((i+1)%7)?'checked':''}> ${d}</label>`).join('')}
             </div>
             <p id="auto-save-timer" class="text-sm text-gray-600 mt-2 full-width"></p>
         </form>`;
    if (options.onTopOfMap) {
        const mapContainerEl = document.getElementById('reminders-location-map-modal');
        if (mapContainerEl) {
            mapContainerEl.appendChild(modal);
        } else {
            document.body.appendChild(modal);
        }
    } else {
        document.body.appendChild(modal);
    }
    modal.cleanUpModalTimers = cleanUpModalTimers;
    const parseStatus = modal.querySelector('#parse-status');
    const speechStatus = modal.querySelector('#speech-status');
    const autoSaveTimerLabel = modal.querySelector('#auto-save-timer');
    let countdownSaveElement = modal.querySelector('#countdown-save');
    const textInput = modal.querySelector('#reminder-text');
    const timeInput = modal.querySelector('#reminder-time');
    const dateInput = modal.querySelector('#reminder-date');
    const intervalInput = modal.querySelector('#reminder-interval');
    const speechButton = modal.querySelector('#start-speech');
    const saveButton = modal.querySelector('#save-reminder');
    const clearButton = modal.querySelector('#clear-fields');
    const locationCheckbox = modal.querySelector('#location-enabled');
    const mapContainer = modal.querySelector('#location-map-container');
    const expandMapButton = modal.querySelector('#expand-map-button');
    const reduceMapButton = modal.querySelector('#reduce-map-button');
    const locateMeButton = modal.querySelector('#locate-me-button');
    const manageLocationsBtn = modal.querySelector('#manage-saved-locations');
    const excludeFromListCheckbox = modal.querySelector('#reminder-exclude-from-list');
    const deleteButton = modal.querySelector('#delete-reminder');
    
    // --- INICIO DE LA MODIFICACIÓN ---
    // 2. Se selecciona el contenedor del slider y se añade la lógica de visibilidad.
    const radiusSliderGroup = modal.querySelector('#radius-slider-group');

    function toggleRadiusVisibility() {
        if (radiusSliderGroup) {
            radiusSliderGroup.style.display = locationCheckbox.checked ? 'block' : 'none';
        }
    }
    
    // Se añade el listener al checkbox para ejecutar la función cuando cambie
    locationCheckbox.addEventListener('change', toggleRadiusVisibility);
    
    // Se ejecuta una vez al inicio para establecer el estado inicial correcto
    toggleRadiusVisibility();
    // --- FIN DE LA MODIFICACIÓN ---

    // --- LÓGICA PARA EL SLIDER DE RADIO ---
    const radiusSliderContainer = modal.querySelector('#radius-thumb')?.parentElement;
    const radiusThumb = modal.querySelector('#radius-thumb');
    const radiusRange = modal.querySelector('#radius-slider-range');
    const radiusLabel = modal.querySelector('#radius-range-label');
    const minRadius = 1;
    const maxRadius = 5000;
    let currentRadius = parsed.radiusMeters || 350;

    const updateRadiusVisuals = () => {
        if (!radiusThumb || !radiusRange || !radiusLabel) return;
        const minLog = Math.log(minRadius);
        const maxLog = Math.log(maxRadius);
        const percent = (Math.log(currentRadius) - minLog) / (maxLog - minLog);
        
        radiusThumb.style.left = `${percent * 100}%`;
        radiusRange.style.width = `${percent * 100}%`;
        radiusLabel.textContent = `Radio (si es por ubicación): ${Math.round(currentRadius)} metros`;
    };

    if (radiusSliderContainer && radiusThumb) {
        const onRadiusDrag = (e) => {
            const rect = radiusSliderContainer.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let percent = (clientX - rect.left) / rect.width;
            percent = Math.max(0, Math.min(1, percent));
            
            const minLog = Math.log(minRadius);
            const maxLog = Math.log(maxRadius);
            currentRadius = Math.exp(minLog + percent * (maxLog - minLog));
            currentRadius = Math.max(minRadius, Math.min(maxRadius, currentRadius));
            
            updateRadiusVisuals();
            resetAndStartCountdown();
        };

        const startRadiusDrag = (e) => {
            const moveHandler = (moveEvent) => onRadiusDrag(moveEvent);
            const endDrag = () => {
                document.removeEventListener('mousemove', moveHandler);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchmove', moveHandler);
                document.removeEventListener('touchend', endDrag);
            };
            document.addEventListener('mousemove', moveHandler);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchmove', moveHandler);
            document.addEventListener('touchend', endDrag);
        };
        
        radiusThumb.addEventListener('mousedown', startRadiusDrag);
        radiusThumb.addEventListener('touchstart', startRadiusDrag);
        updateRadiusVisuals();
    }

    function initializeOrUpdateMap(centerCoords, radius, isInteractive = false) {
        const mapDivId = 'reminder-modal-map-div';
        let mapDiv = document.getElementById(mapDivId);
        const effectiveLocationEnabled = locationCheckbox.checked;
        const showMap = effectiveLocationEnabled || isInteractive;

        if (!showMap) {
            destroyMap();
            return;
        }

        mapContainer.style.display = 'block';
        mapContainer.classList.toggle('preview', !isInteractive && effectiveLocationEnabled && centerCoords);
        mapContainer.classList.toggle('expanded', isInteractive && effectiveLocationEnabled);

        const effectiveCoords = centerCoords || { latitude: 40.416775, longitude: -3.703790 };
        const effectiveRadius = parseInt(radius) || DEFAULT_LOCATION_RADIUS;

        if (!isInteractive && !centerCoords && effectiveLocationEnabled) {
             destroyMap();
             return;
        }

        const zoomLevel = isInteractive ? 13 : 11;

        const setupMapInteractions = (mapInstance) => {
            mapInstance.off('click', handleMapClick);
            mapInstance.off('movestart', handleMapMoveStart);
            mapInstance.off('moveend', handleMapMoveEnd);

            if (isInteractive && effectiveLocationEnabled) {
                mapInstance.dragging.enable(); mapInstance.touchZoom.enable(); mapInstance.scrollWheelZoom.enable();
                mapInstance.doubleClickZoom.enable(); mapInstance.tap?.enable();
                mapInstance.on('click', handleMapClick);
                mapInstance.on('movestart', handleMapMoveStart);
                mapInstance.on('moveend', handleMapMoveEnd);
            } else {
                mapInstance.dragging.disable(); mapInstance.touchZoom.disable(); mapInstance.scrollWheelZoom.disable();
                mapInstance.doubleClickZoom.disable(); mapInstance.tap?.disable();
            }
        };

        const activeLayerKeyReminder = 'boardinggate_activeMapLayer_reminderModal';

        if (!reminderModalMap) {
            if (!mapDiv) {
                mapDiv = document.createElement('div');
                mapDiv.id = mapDivId;
                mapDiv.style.width = '100%'; mapDiv.style.height = '100%';
                mapContainer.insertBefore(mapDiv, reduceMapButton);
            }

            reminderModalMap = L.map(mapDivId, {
                 scrollWheelZoom: (isInteractive && effectiveLocationEnabled),
                 doubleClickZoom: (isInteractive && effectiveLocationEnabled),
                 touchZoom: (isInteractive && effectiveLocationEnabled),
                 dragging: (isInteractive && effectiveLocationEnabled),
                 tap: (isInteractive && effectiveLocationEnabled),
                 zoomControl: isInteractive && effectiveLocationEnabled
            }).setView([effectiveCoords.latitude, effectiveCoords.longitude], zoomLevel);

            const osmLayerRem = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: (isInteractive && effectiveLocationEnabled) ? '© <a href="https://www.openstreetmap.org/copyright">OSM</a>' : null });
            const satelliteLayerRem = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' });
            const satelliteWithLabelsRem = L.layerGroup([
                L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' }),
                L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', { attribution: '© OSM © CARTO', pane: 'labels_reminder' })
            ]);

            if (!reminderModalMap.getPane('labels_reminder')) {
                reminderModalMap.createPane('labels_reminder');
                reminderModalMap.getPane('labels_reminder').style.zIndex = 650;
                reminderModalMap.getPane('labels_reminder').style.pointerEvents = 'none';
            }

            const baseMapsRem = { "Mapa Normal": osmLayerRem, "Satélite Puro": satelliteLayerRem, "Satélite + Calles": satelliteWithLabelsRem };
            const savedLayerNameRem = localStorage.getItem(activeLayerKeyReminder) || "Satélite + Calles";
            let initialLayerRem = baseMapsRem[savedLayerNameRem] || satelliteWithLabelsRem;
            initialLayerRem.addTo(reminderModalMap);

            if (mapLayersControlReminder) mapLayersControlReminder.remove();
            mapLayersControlReminder = L.control.layers(baseMapsRem, null, { position: 'topright', collapsed: true });
            if (isInteractive && effectiveLocationEnabled) {
               mapLayersControlReminder.addTo(reminderModalMap);
            }

            reminderModalMap.on('baselayerchange', function(e) {
                localStorage.setItem(activeLayerKeyReminder, e.name);
                markCacheAsDirty();
            });

            setupMapInteractions(reminderModalMap);
            updateMarkerAndCircle(effectiveCoords, effectiveRadius);

        } else {
             reminderModalMap.setView([effectiveCoords.latitude, effectiveCoords.longitude], zoomLevel);
             updateMarkerAndCircle(effectiveCoords, effectiveRadius);
             setupMapInteractions(reminderModalMap);
             if (mapLayersControlReminder && reminderModalMap) { 
                 if (isInteractive && effectiveLocationEnabled && !reminderModalMap.hasControl(mapLayersControlReminder)) {
                     mapLayersControlReminder.addTo(reminderModalMap);
                 } else if ((!isInteractive || !effectiveLocationEnabled) && reminderModalMap.hasControl(mapLayersControlReminder)) {
                    mapLayersControlReminder.remove();
                 }
             }
             if (reminderModalMap.zoomControl) {
                if (isInteractive && effectiveLocationEnabled) reminderModalMap.zoomControl.addTo(reminderModalMap);
                else reminderModalMap.zoomControl.remove();
             }
        }
        if (reduceMapButton) reduceMapButton.classList.toggle('hidden', !(isInteractive && effectiveLocationEnabled));
        if (locateMeButton) locateMeButton.classList.toggle('hidden', !(isInteractive && effectiveLocationEnabled));
        if (mapContainer.classList.contains('expanded') || mapContainer.classList.contains('preview')) {
             requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    if (reminderModalMap && mapContainer.offsetHeight > 0) {
                        try {
                            reminderModalMap.invalidateSize();
                        } catch (e) {}
                    }
                });
            });
        }
    }
    
    function handleMapClick(e) {
         const latlng = e.latlng;
         currentReminderLocation = { latitude: latlng.lat, longitude: latlng.lng };
         updateMarkerAndCircle(currentReminderLocation, Math.round(currentRadius));
         resetAndStartCountdown();
    }
 
    function updateMarkerAndCircle(coords, radius) {
        if (!reminderModalMap || !coords) return;
        const latlng = L.latLng(coords.latitude, coords.longitude);
        const radiusMeters = parseInt(radius) || DEFAULT_LOCATION_RADIUS;
        const isDraggable = mapContainer.classList.contains('expanded') && locationCheckbox.checked;
        const currentCarIcon = vehicleIcon;
        if (!reminderMarker) {
            reminderMarker = L.marker(latlng, { icon: currentCarIcon, draggable: isDraggable }).addTo(reminderModalMap);
            if (isDraggable) reminderMarker.on('dragend', handleMarkerDragEnd);
        } else {
            reminderMarker.setLatLng(latlng);
            reminderMarker.setIcon(vehicleIcon);
            reminderMarker.options.draggable = isDraggable;
            reminderMarker.off('dragend', handleMarkerDragEnd);
            if (isDraggable) reminderMarker.on('dragend', handleMarkerDragEnd);
        }
        const markerElementContainer = reminderMarker.getElement();
        if(markerElementContainer) {
             const vehicleWrapper = markerElementContainer.querySelector('#vehicle-icon-wrapper');
             if (vehicleWrapper) {
                const currentHeading = (navigationCurrentLocation && typeof navigationCurrentLocation.heading === 'number') ? navigationCurrentLocation.heading : (currentMapBearing || 0);
                const rotationAngle = currentHeading - 90;
                vehicleWrapper.style.transform = `rotate(${rotationAngle}deg)`;
             }
        }
        const isRadar = textInput.value.toUpperCase().includes("RADAR:");
        const circleColor = isRadar ? 'rgba(255, 165, 0, 0.2)' : 'blue';
        const circleFillColor = isRadar ? 'rgba(255, 165, 0, 0.2)' : '#ADD8E6';
        const circleFillOpacity = isRadar ? 0.2 : 0.05;
        const circleWeight = isRadar ? 1 : 1;
        if (!reminderCircle) {
            reminderCircle = L.circle(latlng, { color: circleColor, fillColor: circleFillColor, weight: circleWeight, fillOpacity: circleFillOpacity, radius: radiusMeters }).addTo(reminderModalMap);
        } else {
            reminderCircle.setLatLng(latlng);
            reminderCircle.setRadius(radiusMeters);
             reminderCircle.setStyle({ color: circleColor, fillColor: circleFillColor, weight: circleWeight, fillOpacity: circleFillOpacity });
            if (!mapContainer.classList.contains('expanded') || (mapMoveDebounceTimer === null)) {
                 reminderCircle.setStyle({ stroke: true });
            }
        }
    }
    
    function handleMarkerDragEnd(event) {
         const marker = event.target;
         const position = marker.getLatLng();
         currentReminderLocation = { latitude: position.lat, longitude: position.lng };
         updateMarkerAndCircle(currentReminderLocation, Math.round(currentRadius));
         resetAndStartCountdown();
    }
    
    function destroyMap() {
        if (reminderModalMap) {
             reminderModalMap.off('click', handleMapClick);
             reminderModalMap.off('movestart', handleMapMoveStart);
             reminderModalMap.off('moveend', handleMapMoveEnd);
             if (reminderMarker) reminderMarker.off('dragend', handleMarkerDragEnd);
             if (mapLayersControlReminder) mapLayersControlReminder.remove();
             mapLayersControlReminder = null;
             try { reminderModalMap.remove(); } catch(e) { }
             reminderModalMap = null; reminderMarker = null; reminderCircle = null;
        }
        mapContainer.style.display = 'none';
        mapContainer.classList.remove('preview', 'expanded');
        if (reduceMapButton) reduceMapButton.classList.add('hidden');
        if (locateMeButton) locateMeButton.classList.add('hidden');
        const mapDiv = document.getElementById('reminder-modal-map-div');
        if(mapDiv && mapDiv.parentNode === mapContainer) {
             mapContainer.removeChild(mapDiv);
        }
    }
    
    function handleLocationCheckboxChange() {
        const wasEnabled = locationEnabledByUser;
        locationEnabledByUser = locationCheckbox.checked;
        if (locationEnabledByUser) {
            if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && currentReminderLocation) {
                initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false);
            } else if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && !currentReminderLocation) {
                destroyMap();
            }
             if (!currentReminderLocation && !wasEnabled) {
                getCurrentLocation(
                    (coords) => {
                        currentReminderLocation = coords;
                        if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && currentReminderLocation) {
                            initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false);
                        }
                    }
                );
            }
        } else {
            destroyMap();
        }
        resetAndStartCountdown();
    }
    
    if (deleteButton) {
        deleteButton.style.backgroundColor = '#8B0000';
        deleteButton.style.color = '#FFFFFF';
        deleteButton.style.fontWeight = 'bold';
        deleteButton.style.fontSize = '1.2rem';
        deleteButton.style.border = '1px solid #580000';
        deleteButton.style.height = '70px';
        deleteButton.addEventListener('click', () => {
            cleanUpModalTimers(true);
            const mapShouldReopen = mapShouldReopenAfterForm;
            const mapContextToReopen = mapContextBeforeThisModal;

            if (isNew) {
                destroyMap();
                if (modal.parentNode) modal.parentNode.removeChild(modal);
                showToast('Creación de recordatorio cancelada', 'info');

                if (mapShouldReopen && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
                    if (mapContextToReopen === 'navigation') openNavigationMap();
                } else if (mapShouldReopen) {
                    sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
                    if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen);
                }
                 sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
                return;
            }

            let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
            const initialLength = reminders.length;
            reminders = reminders.filter(r => r.id !== parsed.id);

            if (reminders.length < initialLength) {
                localStorage.setItem('reminders', JSON.stringify(reminders));
                markCacheAsDirty();
                showToast('Recordatorio borrado.', 'success');
            } else {
                showToast('Recordatorio no encontrado para borrar', 'warning');
            }

            destroyMap();
            if (modal.parentNode) modal.parentNode.removeChild(modal);
            updateReminderCount();
            updateButtonStyles();
            checkReminders();

             if (mapShouldReopen && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
                if (mapContextToReopen === 'navigation') openNavigationMap();
            } else if (mapShouldReopen) {
                 sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
                 if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen);
            }
            sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
        });
    }

    modal.querySelectorAll('.modal-top-buttons button').forEach(btn => {
        if (btn.id !== 'save-reminder' && btn.id !== 'delete-reminder') {
            btn.style.height = '70px';
        }

        const defaultBgColor = window.getComputedStyle(btn).backgroundColor;
        const defaultTextColor = window.getComputedStyle(btn).color;
    
        if ((defaultTextColor === 'rgb(255, 255, 255)' || defaultTextColor.toLowerCase() === '#ffffff') &&
            (defaultBgColor === 'rgb(209, 213, 219)' || defaultBgColor.toLowerCase() === '#d1d5db') &&
             btn.id !== 'save-reminder' &&
             btn.id !== 'delete-reminder' &&
             !btn.style.backgroundColor.includes('rgb(37, 99, 235)') &&
             !btn.style.backgroundColor.includes('rgb(139, 0, 0)') ) {

            btn.style.backgroundColor = '#4A5568';
            btn.style.border = '1px solid #2D3748';
            btn.style.fontWeight = 'bold';
             btn.onmouseover = () => btn.style.backgroundColor = '#2D3748';
             btn.onmouseout = () => btn.style.backgroundColor = '#4A5568';
        }
    });

    if (manageLocationsBtn) {
        manageLocationsBtn.addEventListener('click', () => {
            showSavedLocationsModal(
                () => { },
                (selectedLocationData) => {
                    if (selectedLocationData && typeof selectedLocationData.lat === 'number' && typeof selectedLocationData.lng === 'number') {
                        currentReminderLocation = { latitude: selectedLocationData.lat, longitude: selectedLocationData.lng };
                        locationCheckbox.checked = true;
                        locationEnabledByUser = true;

                        currentRadius = typeof selectedLocationData.radius === 'number' && selectedLocationData.radius > 0 ? selectedLocationData.radius : DEFAULT_LOCATION_RADIUS;
                        updateRadiusVisuals();

                        if (mapContainer.classList.contains('expanded')) {
                            initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), true);
                        } else {
                            initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false);
                        }
                        showToast(`Ubicación "${selectedLocationData.name || 'Seleccionada'}" aplicada.`, "success");
                        resetAndStartCountdown();
                    } else {
                        showToast("Error: Datos de ubicación seleccionada no válidos.", "error");
                    }
                },
                { parentContainer: modal } 
            );
        });
    }

    const handleMapMoveStart = () => {
        if (reminderCircle && mapContainer.classList.contains('expanded')) {
            clearTimeout(mapMoveDebounceTimer);
            reminderCircle.setStyle({ stroke: false, fill: false });
        }
    };

    const handleMapMoveEnd = () => {
        clearTimeout(mapMoveDebounceTimer);
        mapMoveDebounceTimer = setTimeout(() => {
            if (reminderCircle && mapContainer.classList.contains('expanded')) {
                const effectiveRadius = Math.round(currentRadius) || DEFAULT_LOCATION_RADIUS;
                const isRadar = textInput.value.toUpperCase().includes("RADAR:");
                const circleColor = isRadar ? 'rgba(255, 165, 0, 0.2)' : 'blue';
                const circleFillColor = isRadar ? 'rgba(255, 165, 0, 0.2)' : '#ADD8E6';
                const circleFillOpacity = isRadar ? 0.2 : 0.05;
                const circleWeight = isRadar ? 1 : 1;
                reminderCircle.setStyle({ stroke: true, color: circleColor, fill: true, fillColor: circleFillColor, fillOpacity: circleFillOpacity, weight: circleWeight });
            }
        }, 200);
    };   

    locationCheckbox.addEventListener('change', handleLocationCheckboxChange);

    if (parsed.isLocationEnabled && parsed.locationCoordinates) {
        initializeOrUpdateMap(parsed.locationCoordinates, parsed.radiusMeters, false);
    } else if (parsed.isLocationEnabled && !parsed.locationCoordinates) {
        destroyMap();
    } else {
        destroyMap();
    }

    if (expandMapButton) {
        expandMapButton.addEventListener('click', () => {
            if (!locationCheckbox.checked) {
                locationCheckbox.checked = true;
                toggleRadiusVisibility(); // Asegurarse de que el slider aparezca
            }
            locationEnabledByUser = true;
            mapExpandedManually = true;

            if (!currentReminderLocation) {
                locateMeButton.disabled = true;
                locateMeButton.textContent = 'Buscando...';
                getCurrentLocation(
                    (gpsCoords) => {
                        currentReminderLocation = { latitude: gpsCoords.latitude, longitude: gpsCoords.longitude };
                        initializeOrUpdateMap(gpsCoords, Math.round(currentRadius), true);
                        if (reminderModalMap) {
                             reminderModalMap.setZoom(16);
                        }
                        showToast("Mapa centrado en tu ubicación GPS. Pulsa en el mapa para ajustar si es necesario", "info");
                        locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ';
                    },
                    (errorMsg) => {
                        initializeOrUpdateMap(null, Math.round(currentRadius), true);
                        if (reminderModalMap) {
                            reminderModalMap.setZoom(6);
                        }
                        showToast(`Error GPS: ${errorMsg}. Mapa centrado por defecto`, "warning", 3000);
                        locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ';
                    }
                );
            } else {
                initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), true);
            }

            resetAndStartCountdown();
            setTimeout(() => { mapExpandedManually = false; }, 100);
        });
    }

    if (reduceMapButton) {
        reduceMapButton.addEventListener('click', () => {
             if (locationEnabledByUser && currentReminderLocation) {
                 initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false);
             } else {
                 destroyMap();
             }
             resetAndStartCountdown();
        });
    }

    if (locateMeButton) {
        locateMeButton.addEventListener('click', () => {
             if (!reminderModalMap || !mapContainer.classList.contains('expanded')) return;
             resetAndStartCountdown();
             locateMeButton.disabled = true; locateMeButton.textContent = 'Buscando...';
             getCurrentLocation(
                 (coords) => {
                     currentReminderLocation = { latitude: coords.latitude, longitude: coords.longitude };
                     if (reminderModalMap) {
                        reminderModalMap.setView([coords.latitude, coords.longitude], 16);
                        updateMarkerAndCircle(coords, Math.round(currentRadius));
                     }
                     showToast('Ubicación actual fijada para el recordatorio', 'success');
                     locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ';
                 },
                 (errorMsg) => {
                     showToast(`Error al localizar: ${errorMsg}`, 'error');
                     locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ';
                 }
             );
        });
    }

    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = new SpeechRecognition();
        recognition.continuous = false;
        recognition.interimResults = false;
        recognition.lang = 'es-ES';
        speechButton.addEventListener('click', () => {
            cleanUpModalTimers(false);
            try {
                recognition.start();
            } catch (e) {
                speechStatus.textContent = `Error inicio: ${e.message}`;
                speechStatus.style.color = '#EF4444';
                resetAndStartCountdown();
            }
        });
        recognition.onstart = () => {
            speechStatus.textContent = 'Escuchando...';
            speechStatus.style.color = '#10B981';
        };
        recognition.onresult = (event) => {
            const transcript = event.results[event.results.length - 1][0].transcript.trim();
            textInput.value = textInput.value + transcript;
            speechStatus.textContent = '';
            lastInputWasSpeech = true;
            const inputEvent = new Event('input', { bubbles: true });
            textInput.dispatchEvent(inputEvent);
            textInput.focus();
            textInput.selectionStart = textInput.selectionEnd = textInput.value.length;
        };
        recognition.onerror = (event) => {
            speechStatus.textContent = `Error voz: ${event.error}`;
            speechStatus.style.color = '#EF4444';
            resetAndStartCountdown();
        };
        recognition.onend = () => {
            if (speechStatus.textContent === 'Escuchando...') {
                setTimeout(() => {
                    if (speechStatus.textContent === 'Escuchando...') speechStatus.textContent = '';
                }, 1500);
            }
            if (!lastInputWasSpeech) {
                resetAndStartCountdown();
            }
        };
    } else {
        speechStatus.textContent = 'Voz no soportada.';
        speechStatus.style.color = '#EF4444';
        speechButton.disabled = true;
        speechButton.style.opacity = 0.5;
    }

    function startCountdown() {
        autoSaveInterval = setInterval(() => {
            if (!document.body.contains(modal)) {
                clearInterval(autoSaveInterval);
                autoSaveInterval = null;
                return;
            }
            countdownSave--;
            if (countdownSaveElement) countdownSaveElement.textContent = countdownSave;
            if (countdownSave === 23) {
                if (document.activeElement === textInput) {
                    textInput.value += ' ';
                    textInput.selectionStart = textInput.selectionEnd = textInput.value.length;
                }
            }
            if (countdownSave <= 0) {
                clearInterval(autoSaveInterval);
                autoSaveInterval = null;
                if (saveButton) saveButton.click();
            }
        }, 1000);
    }

    function resetAndStartCountdown() {
        countdownSave = 25;
        if (countdownSaveElement) countdownSaveElement.textContent = countdownSave;
        if (autoSaveInterval) {
            clearInterval(autoSaveInterval);
            autoSaveInterval = null;
        }
        startCountdown();
    }

    timeInput.addEventListener('input', (e) => {
        manualTimeInput = true;
        let v = e.target.value.replace(/\D/g, '');
        let fV = '';
        if (v.length >= 2) fV = v.slice(0, 2);
        if (v.length > 2) fV += ':' + v.slice(2, 4);
        else if (v.length < 2) fV = v;
        e.target.value = fV;
        if (fV.match(/^\d{2}:\d{2}$/)) {
            const [h, m] = fV.split(':').map(Number);
            parseStatus.textContent = (h > 23 || m > 59) ? 'Hora inválida' : '';
            parseStatus.classList.toggle('text-red-600', h > 23 || m > 59);
            parseStatus.classList.remove('text-green-600');
        } else if (fV.length > 0) {
            parseStatus.textContent = 'Formato HH:MM';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        } else {
            parseStatus.textContent = '';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        }
        resetAndStartCountdown();
    });

    dateInput.addEventListener('input', (e) => {
        let v = e.target.value.replace(/\D/g, '');
        let fV = '';
        if (v.length >= 2) fV = v.slice(0, 2);
        if (v.length > 2) fV += '/' + v.slice(2, 4);
        if (v.length > 4) fV += '/' + v.slice(4, 8);
        else if (v.length < 2) fV = v;
        e.target.value = fV;
        if (fV.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
            const [d, m, y] = fV.split('/').map(Number);
            const dt = new Date(Date.UTC(y, m - 1, d));
            const ok = !isNaN(dt.getTime()) && dt.getUTCDate() === d && dt.getUTCMonth() + 1 === m && y >= 2000 && y <= 2099;
            parseStatus.textContent = ok ? '' : 'Fecha inválida';
            parseStatus.classList.toggle('text-red-600', !ok);
            parseStatus.classList.remove('text-green-600');
        } else if (fV.length > 0) {
            parseStatus.textContent = 'Formato DD/MM/AAAA';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        } else {
            parseStatus.textContent = '';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        }
        resetAndStartCountdown();
    });

    intervalInput.addEventListener('input', resetAndStartCountdown);
    modal.querySelectorAll('input[name="repeat"]').forEach(chk => chk.addEventListener('change', resetAndStartCountdown));
    autoSaveTimerLabel.style.display = 'block';
    if (countdownSaveElement) countdownSaveElement.textContent = countdownSave;

    function startFocusCheck() {
        if (restartTimeout) clearTimeout(restartTimeout);
        restartTimeout = setTimeout(() => {
            if (document.activeElement !== textInput && document.activeElement !== timeInput && document.activeElement !== dateInput && document.activeElement !== intervalInput && !Array.from(modal.querySelectorAll('input[name="repeat"]')).includes(document.activeElement) && document.activeElement !== speechButton && document.activeElement !== saveButton && document.activeElement !== modal.querySelector('#cancel-reminder') && document.activeElement !== modal.querySelector('#help-reminder') && document.activeElement !== clearButton && document.activeElement !== modal.querySelector('#view-reminders') && document.activeElement !== locationCheckbox && document.activeElement !== radiusThumb && document.activeElement !== expandMapButton && document.activeElement !== reduceMapButton && document.activeElement !== locateMeButton && !(reminderModalMap && reminderModalMap.getContainer().contains(document.activeElement))) {
                resetAndStartCountdown();
                restartTimeout = null;
            } else {
                restartTimeout = null;
            }
        }, 500);
    }

    resetAndStartCountdown();
    startFocusCheck();
    modal.addEventListener('input', resetAndStartCountdown);
    modal.addEventListener('click', resetAndStartCountdown);
    modal.addEventListener('touchstart', resetAndStartCountdown, { passive: true });
    modal.addEventListener('focusin', () => {
        resetAndStartCountdown();
        if (focusTimeout) clearTimeout(focusTimeout);
        focusTimeout = null;
    });
    modal.addEventListener('focusout', () => {
        if (!focusTimeout) {
            startFocusCheck();
        }
    });

    textInput.addEventListener('input', (e) => {
        lastInputWasSpeech = false;
        const txt = e.target.value || '';
        parseStatus.textContent = 'Parseando...';
        parseStatus.classList.remove('text-green-600', 'text-red-600');
        if (parseTimeout) clearTimeout(parseTimeout);
        parseTimeout = setTimeout(() => {
            if (!document.body.contains(modal)) return;
            try {
                const uiElements = {
                    timeInput: timeInput,
                    dateInput: dateInput,
                    intervalInput: intervalInput,
                    repeatCheckboxes: modal.querySelectorAll('input[name="repeat"]'),
                    locationCheckbox: locationCheckbox,
                    radiusInput: null, // Ya no usamos el input de radio
                    manualTimeInput: manualTimeInput,
                    mapExpandedManually: mapExpandedManually,
                    excludeFromListCheckbox: excludeFromListCheckbox
                };
                if (!manualTimeInput) uiElements.timeInput.value = '';
                uiElements.dateInput.value = '';
                uiElements.intervalInput.value = '';
                uiElements.repeatCheckboxes.forEach(chk => chk.checked = false);
                const pD = parseReminderText(txt, uiElements);
                
                // Actualizamos el slider con el radio parseado
                if(pD.radiusMeters) {
                    currentRadius = pD.radiusMeters;
                    updateRadiusVisuals();
                }

                if (isNew && (pD.type === 'weekly' || pD.type === 'interval')) {
                    const tempReminderForCalc = { type: pD.type, time: pD.time, date: pD.date, repeatDays: pD.repeatDays, intervalDays: pD.intervalDays };
                    const nowForCalc = new Date();
                    if (!tempReminderForCalc.date) tempReminderForCalc.date = `${nowForCalc.getFullYear()}-${(nowForCalc.getMonth() + 1).toString().padStart(2, '0')}-${nowForCalc.getDate().toString().padStart(2, '0')}`;
                    if (!tempReminderForCalc.time) tempReminderForCalc.time = '00:01';
                    const firstOcc = calculateNextOccurrence(tempReminderForCalc, new Date());
                    if (firstOcc) {
                        const firstOccISO = `${firstOcc.getUTCFullYear()}-${(firstOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOcc.getUTCDate().toString().padStart(2, '0')}`;
                        const firstOccTime = `${firstOcc.getUTCHours().toString().padStart(2, '0')}:${firstOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                        pD.date = firstOccISO;
                        pD.time = firstOccTime;
                        const datePartsCalc = pD.date.split('-');
                        if (datePartsCalc.length === 3) dateInput.value = `${datePartsCalc[2]}/${datePartsCalc[1]}/${datePartsCalc[0]}`;
                        if (!manualTimeInput) timeInput.value = pD.time;
                    } else {
                        if (!pD.date) { const today = new Date(); pD.date = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}-${today.getDate().toString().padStart(2, '0')}`; }
                        if (!pD.time) pD.time = '00:01';
                        const datePartsFb = pD.date.split('-');
                        if (datePartsFb.length === 3) dateInput.value = `${datePartsFb[2]}/${datePartsFb[1]}/${datePartsFb[0]}`;
                        if (!manualTimeInput) timeInput.value = pD.time;
                    }
                }
                parseStatus.textContent = 'Parseado OK';
                parseStatus.classList.add('text-green-600');
                parseStatus.classList.remove('text-red-600');
                handleLocationCheckboxChange();
            } catch (error) {
                parseStatus.textContent = `Error parse: ${error.message.substring(0, 100)}`;
                parseStatus.classList.add('text-red-600');
                parseStatus.classList.remove('text-green-600');
            }
            parseTimeout = null;
        }, 1000);
        resetAndStartCountdown();
    });

    saveButton.addEventListener('click', (e) => {
        e.preventDefault();
        const form = modal.querySelector('#reminder-form');
        if (form.checkValidity && !form.checkValidity()) {
            form.reportValidity();
            return;
        }
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        const mapContextToReopen = mapContextBeforeThisModal;
        const text = textInput.value.trim();
        if (!text) {
            parseStatus.textContent = 'Texto obligatorio.';
            parseStatus.classList.add('text-red-600');
            resetAndStartCountdown();
            return;
        }
        let time = timeInput.value.trim();
        let dateStr = dateInput.value.trim();
        const repeatDays = Array.from(modal.querySelectorAll('input[name="repeat"]:checked')).map(input => parseInt(input.value));
        const intervalDays = parseInt(intervalInput.value) || null;
        const isLocationChecked = locationCheckbox.checked;
        const radius = Math.round(currentRadius);
        const locationCoords = currentReminderLocation;
        const excludeFromListVal = excludeFromListCheckbox.checked;
        if (isLocationChecked && !locationCoords) {
            parseStatus.textContent = 'Ubicación activada pero no fijada en el mapa.';
            parseStatus.classList.add('text-red-600');
            resetAndStartCountdown();
            return;
        }
        let dateISO = null;
        let finalTime = time;
        let reminderType = 'simple';
        if (dateStr) {
            if (dateStr.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                const [d, m, y] = dateStr.split('/').map(Number);
                const tD = new Date(Date.UTC(y, m - 1, d));
                if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() + 1 === m && y >= 2000 && y <= 2099) {
                    dateISO = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`;
                } else {
                    parseStatus.textContent = 'Fecha inválida'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return;
                }
            } else {
                parseStatus.textContent = 'Formato DD/MM/AAAA'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return;
            }
        }
        if (finalTime && !finalTime.match(/^\d{2}:\d{2}$/)) {
            parseStatus.textContent = 'Formato HH:MM'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return;
        } else if (finalTime) {
            const [h, m] = finalTime.split(':').map(Number);
            if (h > 23 || m > 59) {
                parseStatus.textContent = 'Hora inválida'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return;
            }
        }
        if (intervalDays !== null && intervalDays > 0) {
            reminderType = 'interval';
            if (!dateISO) { const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; }
            if (!finalTime) finalTime = '00:01';
        } else if (repeatDays.length > 0) {
            reminderType = 'weekly';
            if (!dateISO) {
                const tempCalc = { type: 'weekly', time: finalTime || '00:01', date: null, repeatDays: repeatDays, intervalDays: null };
                const firstOcc = calculateNextOccurrence(tempCalc, new Date());
                if (firstOcc) {
                    dateISO = `${firstOcc.getUTCFullYear()}-${(firstOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOcc.getUTCDate().toString().padStart(2, '0')}`;
                    finalTime = finalTime || `${firstOcc.getUTCHours().toString().padStart(2, '0')}:${firstOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                } else {
                    const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
                    if (!finalTime) finalTime = '00:01';
                }
            } else { if (!finalTime) finalTime = '00:01'; }
        } else if (dateISO && finalTime) {
            reminderType = 'daily';
        } else if (finalTime) {
            reminderType = 'daily';
            const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
        } else if (dateISO) {
            reminderType = 'daily';
            finalTime = '00:01';
        } else {
            reminderType = 'simple';
            const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
            finalTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
        }
        const now = new Date();
        const finalCreatedAt = isNew ? now.toISOString() : (parsed.createdAt || now.toISOString());
        let finalDateISO = dateISO;
        if (isNew && (reminderType === 'weekly' || reminderType === 'interval')) {
            let needsRecalc = false;
            if (!dateInput.value.trim()) { needsRecalc = true; } 
            else { try { const [d, m, y] = dateStr.split('/').map(Number); const inputDate = new Date(Date.UTC(y, m - 1, d)); const todayForCompare = new Date(now.getFullYear(), now.getMonth(), now.getDate()); if (inputDate < todayForCompare) { needsRecalc = true; } } catch (e) { needsRecalc = true; } }
            if (needsRecalc) {
                const tempCalcForNewCyclic = { type: reminderType, time: finalTime || '00:01', date: null, repeatDays: reminderType === 'weekly' ? repeatDays : [], intervalDays: reminderType === 'interval' ? intervalDays : null };
                const firstOccurrence = calculateNextOccurrence(tempCalcForNewCyclic, new Date());
                if (firstOccurrence) { finalDateISO = `${firstOccurrence.getUTCFullYear()}-${(firstOccurrence.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOccurrence.getUTCDate().toString().padStart(2, '0')}`; } 
                else { if (!finalDateISO) { finalDateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } }
            }
        }
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        const newReminder = {
            id: isNew ? Date.now() : parsed.id,
            text: `<b>${text.toUpperCase()}</b>`,
            type: reminderType,
            time: finalTime || null,
            date: finalDateISO,
            repeatDays: reminderType === 'weekly' ? repeatDays : [],
            intervalDays: reminderType === 'interval' ? intervalDays : null,
            createdAt: finalCreatedAt,
            managedByUser: false,
            isLocationEnabled: isLocationChecked,
            locationCoordinates: isLocationChecked ? locationCoords : null,
            radiusMeters: isLocationChecked ? radius : (parsed.radiusMeters || (text.toUpperCase().startsWith("RADAR:") ? 350 : DEFAULT_LOCATION_RADIUS)),
            excludeFromList: excludeFromListVal,
            isFromRuta: parsed.isFromRuta || false
        };
        if (!newReminder.date || !newReminder.time || !newReminder.createdAt) { showToast("Error GRAVE: Fechas/Hora inválidas al guardar", "error"); resetAndStartCountdown(); return; }
        if (!isNew) {
            const index = reminders.findIndex(r => r.id === parsed.id);
            if (index !== -1) { reminders[index] = newReminder; } 
            else { newReminder.id = Date.now() + Math.random(); reminders.push(newReminder); }
        } else { reminders.push(newReminder); }
        localStorage.setItem('reminders', JSON.stringify(reminders));
        markCacheAsDirty();
        showToast('Recordatorio guardado', 'success');
        destroyMap();
        if (modal.parentNode) modal.parentNode.removeChild(modal);
        updateReminderCount();
        updateButtonStyles();
        checkReminders();
        const unifiedWindowIsVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible');
        if (mapShouldReopen && !unifiedWindowIsVisible) {
            if (mapContextToReopen === 'navigation') openNavigationMap();
        } else if (mapShouldReopen && unifiedWindowIsVisible) {
             sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
             if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen);
        }
        sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
        sessionStorage.removeItem('mapContext');
    });

    modal.querySelector('#cancel-reminder').addEventListener('click', () => {
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        const mapContextToReopen = mapContextBeforeThisModal;
        destroyMap();
        if (modal.parentNode) modal.parentNode.removeChild(modal);
        if (mapShouldReopen) {
             if (mapContextToReopen === 'navigation') openNavigationMap();
        }
        sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
        sessionStorage.removeItem('mapContext');
    });

    modal.querySelector('#help-reminder').addEventListener('click', () => {
        showHelpModal({ parentContainer: modal }); 
    });

    clearButton.addEventListener('click', () => {
        textInput.value=''; timeInput.value=''; dateInput.value='';
        modal.querySelectorAll('input[name="repeat"]').forEach(i=>i.checked=false);
        intervalInput.value='';
        locationCheckbox.checked = false;
        // --- INICIO DE LA MODIFICACIÓN ---
        toggleRadiusVisibility(); // Asegurarse de que el slider se oculta al limpiar
        // --- FIN DE LA MODIFICACIÓN ---
        currentRadius = parsed.radiusMeters || DEFAULT_LOCATION_RADIUS;
        updateRadiusVisuals();
        currentReminderLocation = null;
        destroyMap();
        excludeFromListCheckbox.checked = false;
        parseStatus.textContent='';
        speechStatus.textContent='';
        manualTimeInput=false;
        resetAndStartCountdown();
        textInput.focus();
    });

    modal.querySelector('#view-reminders').addEventListener('click', () => {
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        const mapContextToReopen = mapContextBeforeThisModal;
        destroyMap();
        if (modal.parentNode) document.body.removeChild(modal);
        fromReminderModal = true;
        if (mapShouldReopen) {
            sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
            if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen);
        }
        showAllReminders({ parentContainer: document.getElementById('reminders-location-map-modal') }); 
    });
    
    textInput.focus();
}


    







    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: stopAutomatedRouteSimulation
    // RESUMEN: Detiene completamente el modo de simulación y vuelve al GPS real.
    // ===================================================================
    function stopAutomatedRouteSimulation() {
        stopAutomatedRouteSimulationInternal();
        isSimulatingGpsLocation = false;
        const mapDiv = document.getElementById('reminders-location-map-div');
        if (mapDiv) {
            mapDiv.classList.remove('simulating-gps-click-mode');
        }
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) {
            simulateGpsButton.classList.remove('active-simulate-gps-mode');
            simulateGpsButton.title = "Activar Simulación GPS (recorrido automático o clic manual)";
        }
        startGpsWatching();
        setNavigationMapClickHandler();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: reactivateRealGpsAfterSimulation
    // RESUMEN: Reactiva el seguimiento del GPS real después de una simulación.
    // ===================================================================
    function reactivateRealGpsAfterSimulation() {
        if (locationWatchId === null && 'geolocation' in navigator && 'watchPosition' in navigator.geolocation) {
            locationWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    if (isSimulatingGpsLocation) return;
                    const coordsForUpdate = {
                         latitude: position.coords.latitude, longitude: position.coords.longitude,
                         accuracy: position.coords.accuracy, heading: position.coords.heading,
                         altitude: position.coords.altitude, speed: position.coords.speed
                    };
                    navigationCurrentLocation = coordsForUpdate;
                    updateInitialUserPosition(coordsForUpdate, navigationMapInstance);
                     if(isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
                        const routeForDistCalc = navigationCurrentRouteData.routes[0];
                        let carDistTurf = 0;
                        if (navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
                            try {
                                const carPointTurf = turf.point([coordsForUpdate.longitude, coordsForUpdate.latitude]);
                                const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                                const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                                const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                                carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                            } catch(e){
                            }
                        }
                        const totalRouteLength = routeForDistCalc.distance;
                         if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                            if (carDistTurf < lastCarDistanceAlongRouteForNavLogic - 100 && lastCarDistanceAlongRouteForNavLogic > 100) {
                            } else {
                                lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                            }
                        } else if (carDistTurf > totalRouteLength + 500) {
                            lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
                        }
                        updateTurnByTurnDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                        updateNavigationProgressDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                        console.log('Turf Log (reactivateRealGpsAfterSimulation):', {
                            lat: coordsForUpdate.latitude.toFixed(4),
                            lng: coordsForUpdate.longitude.toFixed(4),
                            speed: coordsForUpdate.speed ? coordsForUpdate.speed.toFixed(1) : 'N/A',
                            distanceAlongRoute: carDistTurf.toFixed(2)
                        });
                    }
                },
                (error) => {
                    showToast(`Error al reactivar GPS: ${error.message}`, "warning");
                },
                { enableHighAccuracy: true, timeout: 15000, maximumAge: 3000, distanceFilter: 3 }
            );
            getCurrentLocation(coords => {
                if (!isSimulatingGpsLocation) {
                    navigationCurrentLocation = coords;
                    updateInitialUserPosition(coords, navigationMapInstance);
                    if (isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
                        const routeForDistCalc = navigationCurrentRouteData.routes[0];
                        let carDistTurf = 0;
                         if (navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
                            try {
                                const carPointTurf = turf.point([coords.longitude, coords.latitude]);
                                const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                                const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                                const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                                carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                            } catch(e){
                            }
                         }
                        const totalRouteLength = routeForDistCalc.distance;
                         if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                            if (carDistTurf < lastCarDistanceAlongRouteForNavLogic - 100 && lastCarDistanceAlongRouteForNavLogic > 100) {
                            }
                            lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                        } else if (carDistTurf > totalRouteLength + 500) {
                            lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
                        }
                        updateTurnByTurnDisplay(routeForDistCalc, carDistTurf);
                        updateNavigationProgressDisplay(routeForDistCalc, carDistTurf);
                    }
                }
            });
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleAddReminderAtLocationMode
    // RESUMEN: Activa/desactiva el modo para añadir un recordatorio haciendo clic en el mapa.
    // ===================================================================
    function toggleAddReminderAtLocationMode() {
        isAddReminderAtLocationModeActive = !isAddReminderAtLocationModeActive;
        const mapDiv = document.getElementById('reminders-location-map-div');
        const button = document.getElementById('add-reminder-at-location-button');
        if (button) {
            if (isAddReminderAtLocationModeActive) {
                button.classList.add('active-reminder-mode');
                if (mapDiv) mapDiv.classList.add('add-reminder-mode');
                showToast("Modo 'Añadir Recordatorio en Mapa' ACTIVADO. Pulsa en el mapa para crear un recordatorio.", "info", 5000);
            } else {
                button.classList.remove('active-reminder-mode');
                if (mapDiv) mapDiv.classList.remove('add-reminder-mode');
                showToast("Modo 'Añadir Recordatorio en Mapa' DESACTIVADO.", "info");
            }
        }
        setNavigationMapClickHandler();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleMapClickToAddReminder
    // RESUMEN: Maneja el clic para añadir un recordatorio en el mapa.
    // ===================================================================
    function handleMapClickToAddReminder(e) {
        if (!isAddReminderAtLocationModeActive || !navigationMapInstance) return;
        const latlng = e.latlng;
        toggleAddReminderAtLocationMode(); 
        const mapContextBeforeModal = sessionStorage.getItem('mapContext');
        closeNavigationMap(true); 
        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
        if (mapContextBeforeModal) {
          sessionStorage.setItem('mapContext', mapContextBeforeModal);
        }
        showReminderModal({
            isLocationEnabled: true,
            locationCoordinates: { latitude: latlng.lat, longitude: latlng.lng },
            radiusMeters: DEFAULT_LOCATION_RADIUS,
            text: 'Recordatorio en mapa: ',
            excludeFromList: false
        });
    }
    
    
    
    
    
    


// ===================================================================
// NOMBRE: openNavigationMap
// RESUMEN: Abre y inicializa el mapa principal de navegación.
// ===================================================================
function openNavigationMap() {
    const mainContent = document.querySelector('main');
    if (mainContent) mainContent.style.display = 'none';
    const footer = document.querySelector('footer');
    if (footer) footer.style.display = 'none';
    const noticesContainer = document.querySelector('.notices-icon-container');
    if (noticesContainer) noticesContainer.style.display = 'none';
    const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button');
    sideControls.forEach(el => el.style.display = 'none');
    document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button, #accident-alert-button').forEach(el => el.style.display = 'none');
    const gridFilter = document.getElementById('grid-filter-container');
    if (gridFilter) gridFilter.style.display = 'none';

    isNavigationMapActive = true;
    sessionStorage.setItem('mapContext', 'navigation');

    closeOtherModals('reminders-location-map-modal');
    
    const mapModal = document.createElement('div');
    mapModal.id = 'reminders-location-map-modal';
    mapModal.innerHTML = `
        <div id="toggle-map-header-buttons-panel">
             <img src="Coche_Sat.PNG" alt="Toggle Panel Mapa">
        </div>
        <div id="reminders-location-map-content-wrapper">
            <div id="reminders-location-map-header">
                 <div class="button-row">
                    <button id="close-reminders-location-map" class="reminders-map-button-action" title="Cerrar mapa y navegación"><img src="SALIR.PNG" alt="Salir"></button>
                    <button id="locate-me-on-reminders-map" class="reminders-map-button-action" title="Mostrar mi posición actual y activar seguimiento"><img src="ESTASAQUI.PNG" alt="Estás Aquí"></button>
                    <button id="nav-map-zoomtoggle-button" class="reminders-map-button-action" style="background-color: white;" data-zoom-state="waypoints" title="Alternar zoom entre vista de ruta y coche"><img src="ZOOM+.PNG" alt="Zoom" style="width:30px; height:30px;"></button>
                    <button id="start-navigation-button" class="reminders-map-button-action hidden" title="Iniciar/Terminar Navegación"><img src="INICIARNAVEGACION.PNG" alt="Iniciar Navegación"></button>
                    <button id="save-route-button" class="reminders-map-button-action hidden" title="Guardar Ruta Actual"><img src="GUARDARRUTA.PNG" alt="Guardar Ruta"></button>
                    <button id="load-saved-route-button" class="reminders-map-button-action" title="Cargar Ruta Guardada"><img src="CARGARRUTA.PNG" alt="Cargar Ruta"></button>
                    <button id="delete-current-route-button" class="reminders-map-button-action hidden" title="Borrar Ruta Actual del Mapa"><img src="BORRARRUTA.PNG" alt="Borrar Ruta"></button>
                    <button id="add-radar-here" class="reminders-map-button-action" title="Crear RADAR en mi posición actual (radio 350m)"><img src="RADARAQUI.PNG" alt="Radar Aquí"></button>
                    <button id="accident-alert-button-map" class="reminders-map-button-action" title="Informar de una incidencia de tráfico"><img src="https://boardinggate.github.io/Tesla/AACCIDENTE.png" alt="Informar Incidencia"></button>
                    <button id="pdrs-ruta-button" class="reminders-map-button-action" title="Buscar Puntos de Recarga en Ruta"><img src="pdrs.png" alt="PDRs"></button>
                     <div class="radares-ruta-control">
                        <input type="checkbox" id="radares-ruta-checkbox">
                        <div class="radares-ruta-label-container">
                            <label for="radares-ruta-checkbox">Radares<br>Ruta</label>
                            <span id="radares-ruta-count" class="hidden">0</span>
                        </div>
                    </div>
                    <div class="tareas-ruta-control">
                        <input type="checkbox" id="tareas-ruta-checkbox">
                        <div class="tareas-ruta-label-container">
                            <label for="tareas-ruta-checkbox">Tareas<br>Ruta</label>
                            <span id="tareas-ruta-count" class="hidden">0</span>
                        </div>
                    </div>
                    <button id="add-reminder-at-location-button" class="reminders-map-button-action" title="Añadir recordatorio en punto del mapa">
                        <img src="https://boardinggate.github.io/Tesla/IMG_4197.jpg" alt="Añadir Recordatorio">
                    </button>
                     <button id="toggle-simulate-gps-button" class="reminders-map-button-action" title="Activar/Desactivar Simulación GPS (recorrido o clic)"><img src="GPS.PNG" alt="Simular Recorrido"></button>
                    <button id="simulate-route-button" class="reminders-map-button-action" title="Simular interacciones de ruta"><img src="SIMULAR.PNG" alt="Simular Ruta"></button>
                 </div>
                 <div class="button-row" id="search-row-map-header">
                    <button id="reorder-route-stages-button" title="Ordenar Etapas de Ruta"><img src="./MOVER.PNG" alt="Ordenar Etapas"></button>
                    <button id="map-location-search-button" class="reminders-map-button-action"><img src="./ANADIRPUNTO.PNG" alt="Añadir Punto Ruta"></button>
                    <button id="clear-map-search-input-button" title="Limpiar búsqueda">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="red" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    </button>
                    <input type="text" id="map-location-search-input" placeholder="Dirección,sitio,zona /Negocio /Ciudad /CP+Provincia (28001 Madrid /Lidl Lugo)">
                    <input type="text" id="filter-input" placeholder="Filtro"> 
                    <button id="navigation-map-help-button" class="reminders-map-button-action" title="Ayuda del mapa de navegación/radares"><img src="IMG_4326.PNG" alt="Ayuda"></button>
                 </div>
            </div>
             <div id="reminders-location-map-div">
                <div id="leaflet-map-actual-container"></div>
                <!-- INICIO: Helpers de giro para orientación Sur -->
                <div id="intersection-helper-left" class="intersection-turn-helper">
                    <img src="" alt="Ayuda giro">
                </div>
                <div id="intersection-helper-right" class="intersection-turn-helper">
                    <img src="" alt="Ayuda giro">
                </div>
                <!-- FIN: Helpers de giro para orientación Sur -->
                 <div id="map-info-overlay"></div>
                 <div id="navigation-bottom-progress-bar" style="display: none;">
                    <div style="flex-grow: 1; margin-left: 8px;">
                        <div id="navigation-top-info-bar">
                            <div id="turn-icon-container-styled">
                                <span id="turn-icon-display" class="turn-icon-display"></span>
                            </div>
                            <div class="maneuver-text-container">
                               <div>
                                   <span id="maneuver-text-display" class="maneuver-text"></span>
                                   <span id="street-name-display" class="street-name"></span>
                               </div>
                               <div id="distance-to-turn-formatted"></div>
                            </div>
                        </div>
                        <div id="distance-progress-bar-to-turn-container"> <div id="distance-progress-bar-to-turn"></div> </div>
                        <hr>
                        <div id="route-overall-progress-container">
                             <div id="route-overall-progress">
                                 <img id="route-progress-icon" src="AVANCE.PNG" alt="Avance" style="display:none;">
                                 <span id="route-progress-text"></span>
                             </div>
                        </div>
                        <div id="navigation-eta-info">
                            <div id="next-stage-info">
                                <strong>Próxima Etapa</strong>
                                <span id="next-stage-distance">-- km</span>   |  
                                <span id="next-stage-time">-- min</span>   |   ETA:
                                <span id="next-stage-eta">--:--</span>
                                <span id="next-stage-eta-deviation" class="eta-deviation"></span>
                            </div>
                            <div id="final-destination-info">
                                <strong> Final</strong>
                                <span id="final-destination-distance">-- km</span>   |  
                                <span id="final-destination-time">-- min</span>   |   ETA:
                                <span id="final-destination-eta">--:--</span>
                                <span id="final-destination-eta-deviation" class="eta-deviation"></span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(mapModal);

    const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresCheckbox) radaresCheckbox.checked = localStorage.getItem(RADARES_RUTA_CHECKED_KEY) === 'true';
    const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasCheckbox) tareasCheckbox.checked = localStorage.getItem(TAREAS_RUTA_CHECKED_KEY) === 'true';
    currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviación ETA';

    toggleMapHeaderRowsVisibility(mapHeaderButtonsVisible);

    requestAnimationFrame(() => {
        const mapActualContainer = document.getElementById('leaflet-map-actual-container');
        if (!mapActualContainer) {
            isNavigationMapActive = false;
            sessionStorage.removeItem('mapContext');
            if (mapModal.parentNode) mapModal.remove();
            showToast("Error crítico: No se pudo crear el contenedor del mapa.", "error");
            return;
        }

        initDirectionWarningCards();
        assignMapButtonListeners();

        const mapLocationSearchInput = document.getElementById('map-location-search-input');
        const mapFilterInput = document.getElementById('filter-input');
        if (mapLocationSearchInput) mapLocationSearchInput.value = '';
        if (mapFilterInput) mapFilterInput.value = localStorage.getItem(MAP_FILTER_INPUT_KEY) || 'España';
        if (mapLocationSearchInput) mapLocationSearchInput.dispatchEvent(new Event('input'));

        try {
            if (navigationMapInstance) navigationMapInstance.remove();
            if (mapLayersControl) mapLayersControl.remove();
            if (compassAndModeControl) compassAndModeControl.remove();

            navigationMapInstance = L.map(mapActualContainer, { zoomControl: false, attributionControl: false }).setView([40.416775, -3.703790], 6);
            
            L.control.attribution({ prefix: '<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>', position: 'bottomright' }).addTo(navigationMapInstance);

            const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© <a href="https://www.openstreetmap.org/copyright">OSM</a>' });
            const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' });
            const satelliteWithLabels = L.layerGroup([
                L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' }),
                L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', { attribution: '© OSM © CARTO', pane: 'labels' })
            ]);
            if (!navigationMapInstance.getPane('labels')) {
                navigationMapInstance.createPane('labels');
                navigationMapInstance.getPane('labels').style.zIndex = 650;
                navigationMapInstance.getPane('labels').style.pointerEvents = 'none';
            }
            const baseMaps = { "Mapa Normal": osmLayer, "Satélite Puro": satelliteLayer, "Satélite + Calles": satelliteWithLabels };
            const savedLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "Satélite + Calles";
            let initialLayer = baseMaps[savedLayerName] || satelliteWithLabels;
            initialLayer.addTo(navigationMapInstance);
            mapLayersControl = L.control.layers(baseMaps, null, { position: 'topright', collapsed: true }).addTo(navigationMapInstance);
            compassAndModeControl = L.control.compassAndMode({ position: 'bottomleft' }).addTo(navigationMapInstance);
            completedRouteSegmentsLayer = L.layerGroup().addTo(navigationMapInstance);
            maxSpeedMarkerLayer = L.layerGroup().addTo(navigationMapInstance);
            speedMilestoneLayer = L.layerGroup().addTo(navigationMapInstance);

            navigationMapInstance.on('baselayerchange', function(e) {
                localStorage.setItem(ACTIVE_MAP_LAYER_KEY, e.name);
                updateRouteAndCarIconStyle();
                updateNavigationGraphVisibilityAndMode();
            });

            navigationMapInstance.on('zoomend', () => {
                displayAlertsOnMap();
                renderWaypointMarkers();
                updateDirectionWarningCardsVisibility();
                displayChargingPointsOnMap(); 
            });
            
            let centerAction = null;

            navigationMapInstance.on('load', function() {
                toggleMapHeaderRowsVisibility(mapHeaderButtonsVisible); 
                const loadingToast = document.getElementById("map-loading-toast");
                if (loadingToast) {
                    loadingToast.remove();
                    activeToasts = activeToasts.filter(t => t.id !== "map-loading-toast");
                }
                if(centerAction) {
                    centerAction();
                }
            });

            getCurrentLocation(
                (currentPos) => {
                    navigationCurrentLocation = currentPos;
                    updateInitialUserPosition(currentPos, navigationMapInstance);
                    const gpsCenterAction = () => {
                         if (navigationWaypoints.length === 0) {
                            navigationMapInstance.setView([currentPos.latitude, currentPos.longitude], 15);
                        }
                    };
                    if (navigationMapInstance._loaded) {
                        gpsCenterAction();
                    } else {
                        centerAction = gpsCenterAction;
                    }
                    startGpsWatching(); 
                },
                (errorMsg) => {
                    showToast("No se pudo obtener tu ubicación actual. Algunas funciones pueden estar limitadas", "warning");
                    if (compassAndModeControl) { compassAndModeControl.updateOrientation(null); compassAndModeControl.updateAltitude(null); }
                    
                    const fallbackCenterAction = () => {
                        const remindersWithLocation = JSON.parse(localStorage.getItem('reminders') || '[]').filter(r => r.isLocationEnabled && r.locationCoordinates);
                        if (navigationWaypoints.length === 0 && remindersWithLocation.length > 0) {
                            const bounds = L.latLngBounds(remindersWithLocation.map(r => [r.locationCoordinates.latitude, r.locationCoordinates.longitude]));
                            if (bounds.isValid()) {
                                 navigationMapInstance.fitBounds(bounds.pad(0.15));
                            }
                        }
                    };

                    if (navigationMapInstance._loaded) {
                        fallbackCenterAction();
                    } else {
                        centerAction = fallbackCenterAction;
                    }
                    startGpsWatching(); 
                }
            );
            
            updateRouteAndCarIconStyle();
            plotRemindersOnNavigationMap();
            forceProcessTrafficAlerts();
            setNavigationMapClickHandler();
        } catch (error) {
             const errorContainer = document.getElementById('leaflet-map-actual-container') || mapActualContainer;
             if (errorContainer) errorContainer.innerHTML = `<p style="color:red; text-align:center; padding:20px;">Error al cargar el mapa: ${error.message}</p>`;
             isNavigationMapActive = false;
        }

        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        toggleMapLocationSearchVisibility(!isNavigating);
        actualizarContadorRadares(radaresEnRutaActual.length);
        actualizarContadorTareas(tareasEnRutaActual.length);
        updateNavigationGraphVisibilityAndMode();
    });
}






    



    

    


    
// ===================================================================
// NOMBRE: assignMapButtonListeners
// RESUMEN: Asigna todos los listeners a los botones de acción del mapa de navegación.
// ===================================================================
function assignMapButtonListeners() {
    const header = document.getElementById('reminders-location-map-header');
    const togglePanelButton = document.getElementById('toggle-map-header-buttons-panel');
    if (!header || !togglePanelButton) return;

    let swipeStartX = 0;
    let swipeStartY = 0;
    let isSwiping = false;
    let pressTimer = null;

    const handleGestureStart = (e) => {
        isSwiping = false;
        swipeStartX = e.touches ? e.touches[0].clientX : e.clientX;
        swipeStartY = e.touches ? e.touches[0].clientY : e.clientY;
        
        clearTimeout(pressTimer);
        pressTimer = setTimeout(() => {
            openAlertModal();
            swipeStartX = 0;
            swipeStartY = 0;
        }, 800);

        if(e.type === 'touchstart') e.preventDefault();
    };

    const handleGestureMove = (e) => {
        if (swipeStartX === 0) return;
        const moveX = e.touches ? e.touches[0].clientX : e.clientX;
        const moveY = e.touches ? e.touches[0].clientY : e.clientY;
        if (Math.abs(moveX - swipeStartX) > 10 || Math.abs(moveY - swipeStartY) > 10) {
            isSwiping = true;
            clearTimeout(pressTimer);
        }
    };

    const handleGestureEnd = (e) => {
        clearTimeout(pressTimer);
        if (swipeStartX === 0) return;

        const endX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
        const endY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
        const deltaX = endX - swipeStartX;
        const deltaY = endY - swipeStartY;
        const swipeThreshold = 50;

        if (!isSwiping) {
            toggleMapHeaderRowsVisibility(!mapHeaderButtonsVisible);
        } else {
            if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > swipeThreshold) {
                if (deltaY < 0) {
                    toggleNavigationState();
                } else {
                    loadRouteByName("TRABAJO", true);
                }
            } else if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > swipeThreshold) {
                if (deltaX < 0) {
                    toggleMapImmersiveMode();
                } else {
                    loadRouteByName("CASA", true);
                }
            }
        }
        
        swipeStartX = 0;
        swipeStartY = 0;
        isSwiping = false;
    };

    togglePanelButton.removeEventListener('mousedown', handleGestureStart);
    togglePanelButton.removeEventListener('mousemove', handleGestureMove);
    togglePanelButton.removeEventListener('mouseup', handleGestureEnd);
    togglePanelButton.removeEventListener('mouseleave', handleGestureEnd);
    togglePanelButton.removeEventListener('touchstart', handleGestureStart);
    togglePanelButton.removeEventListener('touchmove', handleGestureMove);
    togglePanelButton.removeEventListener('touchend', handleGestureEnd);
    togglePanelButton.addEventListener('mousedown', handleGestureStart);
    togglePanelButton.addEventListener('mousemove', handleGestureMove);
    togglePanelButton.addEventListener('mouseup', handleGestureEnd);
    togglePanelButton.addEventListener('mouseleave', handleGestureEnd);
    togglePanelButton.addEventListener('touchstart', handleGestureStart, { passive: false });
    togglePanelButton.addEventListener('touchmove', handleGestureMove, { passive: false });
    togglePanelButton.addEventListener('touchend', handleGestureEnd);
    header.addEventListener('click', (event) => {
        const button = event.target.closest('button');
        if (!button) return;
        if (button.id !== 'toggle-map-header-buttons-panel') {
            event.stopPropagation();
        }
        switch (button.id) {
            case 'close-reminders-location-map':
                closeNavigationMap(false);
                break;
            case 'locate-me-on-reminders-map':
                handleLocateMeClick(button);
                break;
            case 'nav-map-zoomtoggle-button':
                handleZoomToggleButtonClick(button);
                break;
            case 'start-navigation-button':
                toggleNavigationState();
                break;
            case 'save-route-button':
                saveCurrentRoute();
                break;
            case 'delete-current-route-button':
                handleLoadOrDeleteRouteClick(button);
                break;
            case 'load-saved-route-button':
                showLoadRouteModal();
                break;
            case 'add-radar-here':
                handleAddRadarHereClick(button);
                break;
            case 'accident-alert-button-map':
                openAlertModal();
                break;
            case 'pdrs-ruta-button':
                handlePdrSearchButtonClick();
                break;
            case 'add-reminder-at-location-button':
                toggleAddReminderAtLocationMode();
                break;
            case 'toggle-simulate-gps-button':
                handleGpsSimulationToggle();
                break;
            case 'simulate-route-button':
                showSimulationModal();
                break;
            case 'reorder-route-stages-button':
                showReorderStagesModal();
                break;
            case 'navigation-map-help-button':
                showNavigationMapHelpModal();
                break;
            case 'map-location-search-button':
                const mapSearchInput = document.getElementById('map-location-search-input');
                const mapFilterInput = document.getElementById('filter-input');
                const mainTerm = mapSearchInput?.value.trim() || '';
                if (!mainTerm) {
                    showToast("El campo de búsqueda principal no puede estar vacío.", "warning");
                    return;
                }
                const filterTerm = mapFilterInput?.value.trim() || '';
                let combinedSearchTerm = mainTerm;
                if (filterTerm) {
                    combinedSearchTerm += ' ' + filterTerm;
                }
                searchAndAddWaypoint(combinedSearchTerm);
                break;
            case 'clear-map-search-input-button':
                const mapSearchInputToClear = document.getElementById('map-location-search-input');
                if (mapSearchInputToClear) {
                    mapSearchInputToClear.value = '';
                }
                mapSearchInputToClear?.dispatchEvent(new Event('input'));
                mapSearchInputToClear?.focus();
                hideAddressSuggestionsModal();
                break;
        }
    });
    document.getElementById('radares-ruta-checkbox')?.addEventListener('change', (e) => toggleRadaresRuta(e.target.checked));
    document.getElementById('tareas-ruta-checkbox')?.addEventListener('change', (e) => toggleTareasRuta(e.target.checked));
    const mapLocationSearchInput = document.getElementById('map-location-search-input');
    const mapFilterInput = document.getElementById('filter-input');
    if (mapLocationSearchInput) {
        let searchDebounceTimer;
        const handleSearchInput = () => {
            const hasMainText = mapLocationSearchInput.value.trim() !== '';
            document.getElementById('map-location-search-button').style.display = hasMainText ? 'inline-flex' : 'none';
            document.getElementById('clear-map-search-input-button').style.display = hasMainText ? 'inline-flex' : 'none';
            clearTimeout(searchDebounceTimer);
            const mainTerm = mapLocationSearchInput.value.trim();
            if (mainTerm) {
                const filterTerm = mapFilterInput.value.trim();
                let combinedSearchTerm = mainTerm;
                if (filterTerm) {
                    combinedSearchTerm += ' ' + filterTerm;
                }
                searchDebounceTimer = setTimeout(() => fetchAddressSuggestions(combinedSearchTerm), 300);
            } else {
                hideAddressSuggestionsModal();
            }
            localStorage.setItem(MAP_FILTER_INPUT_KEY, mapFilterInput.value);
        };
        mapLocationSearchInput.addEventListener('input', handleSearchInput);
        if (mapFilterInput) {
            mapFilterInput.addEventListener('input', handleSearchInput);
        }
        mapLocationSearchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                const mainTerm = mapLocationSearchInput.value.trim();
                if (!mainTerm) {
                    showToast("El campo de búsqueda principal no puede estar vacío.", "warning");
                    return;
                }
                const filterTerm = mapFilterInput?.value.trim() || '';
                let combinedSearchTerm = mainTerm;
                if (filterTerm) {
                    combinedSearchTerm += ' ' + filterTerm;
                }
                hideAddressSuggestionsModal();
                searchAndAddWaypoint(combinedSearchTerm);
            }
        });
    }
    document.getElementById('turn-icon-container-styled')?.addEventListener('click', (event) => {
        event.stopPropagation();
        if (navigationCurrentRouteData?.routes?.[0]) {
            const route = navigationCurrentRouteData.routes[0];
            const currentLeg = route.legs?.[currentLegIndexNav];
            let nextStep = null;
            if (currentLeg && currentStepIndexNav + 1 < currentLeg.steps.length) {
                nextStep = currentLeg.steps[currentStepIndexNav + 1];
            } else if (route.legs && currentLegIndexNav + 1 < route.legs.length) {
                nextStep = route.legs[currentLegIndexNav + 1].steps[0];
            } else {
                nextStep = currentLeg?.steps?.[currentStepIndexNav];
            }
            if (nextStep) {
                showIntersectionPreviewMap(nextStep, route, true, 7000);
            } else {
                showToast("No hay maniobra siguiente para mostrar detalle.", "info");
            }
        }
    });
}


// ===================================================================
// NOMBRE: handlePdrSearchButtonClick
// RESUMEN: Gestiona los 3 estados del botón de búsqueda de PDRs.
// ===================================================================
function handlePdrSearchButtonClick() {
    const pdrButton = document.getElementById('pdrs-ruta-button');

    switch (pdrSearchState) {
        case 'initial':
        case 'cheapest_shown':
            // Al abrir el modal, el botón vuelve a su estado normal.
            if (pdrButton) {
                pdrButton.classList.remove('pdr-search-highlight');
            }
            showPDRsFilterModal();
            pdrSearchState = 'initial';
            break;
            
        case 'results_shown':
            // Al filtrar por los más baratos, resaltamos el botón.
            if (pdrButton) {
                pdrButton.classList.add('pdr-search-highlight');
            }
            filterForCheapestPDRs();
            pdrSearchState = 'cheapest_shown';
            break;
    }
}






// ===================================================================
// NOMBRE: filterForCheapestPDRs
// RESUMEN: Filtra los resultados de PDRs para mostrar solo el más barato de cada rango de potencia.
// ===================================================================
function filterForCheapestPDRs() {
    if (lastPdrSearchResults.length === 0) {
        showToast("No hay resultados previos para filtrar. Realiza una nueva búsqueda.", "info");
        pdrSearchState = 'initial';
        return;
    }
    showToast("Mostrando solo los PDRs más económicos por rango de potencia...", "info");

    const cheapestBySegment = {
        '#5e5e5e': { price: Infinity, point: null }, // Gris (0-50 kW)
        '#007863': { price: Infinity, point: null }, // Verde (51-100 kW)
        'rgb(30, 144, 255)': { price: Infinity, point: null }, // Azul (101-250 kW)
        '#de2e03': { price: Infinity, point: null }  // Rojo (>250 kW)
    };

    const parsePrice = (priceString) => {
        if (priceString && typeof priceString === 'string') {
            const priceMatch = priceString.match(/(\d[\d,.]*)/);
            if (priceMatch && priceMatch[1]) {
                const priceNum = parseFloat(priceMatch[1].replace(',', '.'));
                if (!isNaN(priceNum) && priceNum > 0 && priceNum < 10) {
                    return priceNum;
                }
            }
        }
        return Infinity;
    };

    lastPdrSearchResults.forEach(point => {
        const power = parseFloat(point.power);
        const segmentColor = getChargingPointColorByPower(power);
        const price = parsePrice(point.price);
        
        if (cheapestBySegment[segmentColor] && price < cheapestBySegment[segmentColor].price) {
            cheapestBySegment[segmentColor].price = price;
            cheapestBySegment[segmentColor].point = point;
        }
    });

    currentChargingPointsOnRoute = Object.values(cheapestBySegment)
        .map(item => item.point)
        .filter(p => p !== null);

    currentChargingPointsOnRoute.forEach(p => { p.isCheapest = true; });

    displayChargingPointsOnMap();
}    




// ===================================================================
// NOMBRE: addChargingPointToRoute (VERSIÓN CORREGIDA)
// RESUMEN: Añade un PDR como etapa. Si no hay ruta, crea una nueva. Si se navega, preserva estadísticas.
// ===================================================================
async function addChargingPointToRoute(pointIndex) {
    const point = currentChargingPointsOnRoute[pointIndex];
    if (!point) return;

    const noRouteLoaded = navigationWaypoints.length === 0;

    if (noRouteLoaded) {
        if (!navigationCurrentLocation) {
            showToast("No se puede añadir el punto de carga sin una ubicación GPS inicial.", "error");
            return;
        }

        const startPoint = {
            id: Date.now() - 1,
            lat: navigationCurrentLocation.latitude,
            lng: navigationCurrentLocation.longitude,
            type: 'S',
            marker: null,
            label: 'S',
            address: 'Posición Actual (GPS)',
            visited: true,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false
        };

        const newWaypoint = {
            id: Date.now(),
            lat: point.lat,
            lng: point.lon,
            type: '',
            marker: null,
            label: '',
            address: point.address || 'Punto de Recarga',
            visited: false,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false
        };

        navigationWaypoints.push(startPoint, newWaypoint);
        showToast("Ruta creada desde tu posición hasta el punto de recarga.", "success");

    } else {
        let lastVisitedIndex = -1;
        navigationWaypoints.forEach((wp, index) => {
            if (wp.visited) {
                lastVisitedIndex = index;
            }
        });
        const insertIndex = lastVisitedIndex + 1;
        
        const newWaypoint = {
            id: Date.now(),
            lat: point.lat,
            lng: point.lon,
            type: '', 
            marker: null,
            label: '',
            address: point.address || 'Punto de Recarga',
            visited: false,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false
        };

        navigationWaypoints.splice(insertIndex, 0, newWaypoint);
        showToast(`'${newWaypoint.address}' añadido como etapa. Recalculando...`, "success");
    }
    
    updateWaypointTypesAndLabels();
    renderWaypointMarkers();

    try {
        await recalculateAndDrawRoute(true);
        
        clearChargingPoints();

        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
            toggleRadaresRuta(true);
        }
    } catch (e) {
        showToast("Error recalculando la ruta tras añadir el punto de recarga.", "error");
    }

    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}


    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: calculateDistanceToEndOfStep
    // RESUMEN: Calcula la distancia acumulada hasta el final de un paso específico de la ruta.
    // ===================================================================
    function calculateDistanceToEndOfStep(route, targetLegIndex, targetStepIndex) {
        let totalDistance = 0;
        if (!route || !route.legs) return 0;
        for (let legIdx = 0; legIdx <= targetLegIndex; legIdx++) {
            const leg = route.legs[legIdx];
            if (!leg || !leg.steps) continue;
            const limitStepIndex = (legIdx === targetLegIndex) ? targetStepIndex : leg.steps.length - 1;
            for (let stepIdx = 0; stepIdx <= limitStepIndex; stepIdx++) {
                const step = leg.steps[stepIdx];
                if (step && typeof step.distance === 'number') {
                    totalDistance += step.distance;
                }
            }
        }
        return totalDistance;
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: plotRemindersOnNavigationMap
    // RESUMEN: Dibuja todos los recordatorios con ubicación en el mapa de navegación.
    // ===================================================================
    function plotRemindersOnNavigationMap() {
        if (!navigationMapInstance) return;
        reminderMapObjects.forEach(obj => {
            if (obj.marker && navigationMapInstance.hasLayer(obj.marker)) obj.marker.remove();
            if (obj.circle && navigationMapInstance.hasLayer(obj.circle)) obj.circle.remove();
        });
        reminderMapObjects = [];
        const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        const remindersWithLocation = reminders.filter(r => r.isLocationEnabled && r.locationCoordinates?.latitude && r.locationCoordinates?.longitude && !r.isFromRuta);
        remindersWithLocation.forEach(reminder => {
            const mapObject = plotSingleReminderOnMap(reminder, navigationMapInstance);
            if (mapObject) reminderMapObjects.push(mapObject);
        });
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: plotSingleReminderOnMap
    // RESUMEN: Dibuja un único recordatorio (marcador y círculo) en un mapa.
    // ===================================================================
    function plotSingleReminderOnMap(reminder, mapInstance) {
        if (!mapInstance || !reminder.isLocationEnabled || !reminder.locationCoordinates) return null;
        const latLng = [reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude];
        const isRadarType = reminder.text.toUpperCase().includes("RADAR:") || reminder.excludeFromList;
        let markerIconToUse;
        let circleColor, circleFillColor, circleFillOpacity, circleWeight;
        if (isRadarType) {
            markerIconToUse = smallRadarMarkerIcon;
            circleColor = '#f1d7ff';
            circleFillColor = '#f1d7ff';
            circleFillOpacity = 0.25;
            circleWeight = 0.5;
        } else {
            markerIconToUse = largeGreenLocationMarkerIcon;
            circleColor = '#c7eb7a';
            circleFillColor = '#c7eb7a';
            circleFillOpacity = 0.35;
            circleWeight = 0.5;
        }
        const marker = L.marker(latLng, { icon: markerIconToUse, title: reminder.text.replace(/<[^>]*>/g, '').substring(0, 50) }).addTo(mapInstance);
        const circle = L.circle(latLng, { radius: reminder.radiusMeters || DEFAULT_LOCATION_RADIUS, color: circleColor, fillColor: circleFillColor, weight: circleWeight, fillOpacity: circleFillOpacity }).addTo(mapInstance);
        let popupContent = ` <div style="max-width: 250px; font-family: sans-serif; font-size: 0.9rem;"> <strong style="font-size: 1rem; color: #333; display: block; margin-bottom: 5px;">${reminder.text.replace(/<b>|<\/b>/gi,'')}</strong> <hr style="margin: 4px 0;"> ${reminder.time ? `<p style="margin: 3px 0;"><strong>Hora:</strong> ${formatTimeWithPeriod(reminder.time)}</p>` : ''} ${reminder.date ? `<p style="margin: 3px 0;"><strong>Fecha:</strong> ${formatDateDetailed(reminder.date)}</p>` : ''} <p style="margin: 3px 0;"><strong>Radio (si es por ubicacion):</strong> ${reminder.radiusMeters || DEFAULT_LOCATION_RADIUS}m</p> <button data-reminder-id="${reminder.id}" class="modify-reminder-from-map" style="margin-top: 8px; padding: 4px 8px; font-size: 0.8rem; background-color: #10B981; color: white; border: none; border-radius: 3px; cursor: pointer;">Modificar</button> </div>`;
        marker.bindPopup(popupContent);
        marker.on('popupopen', () => {
            const modifyButton = marker.getPopup().getElement().querySelector('.modify-reminder-from-map');
            if (modifyButton) {
                const newModifyButton = modifyButton.cloneNode(true); modifyButton.parentNode.replaceChild(newModifyButton, modifyButton);
                newModifyButton.addEventListener('click', (e) => {
                    const id = parseInt(e.target.dataset.reminderId);
                    let remToMod = null;
                    if (!isNaN(id)) {
                        const rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                        remToMod = rems.find(r => r.id === id);
                    }
                    if (!remToMod && reminder) {
                        remToMod = {...reminder};
                        if (typeof remToMod.id !== 'number') remToMod.id = null;
                    }
                    if (remToMod) {
                        const mapContextBeforeModal = sessionStorage.getItem('mapContext');
                        closeNavigationMap(true);
                        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                        if (mapContextBeforeModal) {
                            sessionStorage.setItem('mapContext', mapContextBeforeModal);
                        }
                        showReminderModal(remToMod);
                    } else {
                        showToast("Error: No se pudo encontrar el recordatorio para modificar", "error");
                    }
                });
            }
        });
        return { reminderId: reminder.id, marker, circle, isFromRuta: reminder.isFromRuta || false };
    }
    
    
    
    
    
    
    


// ===================================================================
// NOMBRE: showNavigationMapHelpModal
// RESUMEN: Muestra el modal de ayuda específico para el mapa de navegación.
// ===================================================================
function showNavigationMapHelpModal() {
    const existingHelpModal = document.getElementById('reminders-map-help-modal-instance');
    if (existingHelpModal) {
        clearModalAutoCloseTimer(existingHelpModal, existingHelpModal.querySelector('#close-reminders-map-help-instance'), 'reminders-map-help-modal-instance');
        existingHelpModal.remove();
    }

    const helpModal = document.createElement('div');
    helpModal.id = 'reminders-map-help-modal-instance';
    helpModal.className = 'help-modal';
    helpModal.setAttribute('aria-label', 'Ayuda Mapa de Navegación/Radares');
    
    helpModal.innerHTML = `
        <h2 class="text-xl font-bold mb-4">Ayuda del Mapa de Navegación y Ubicaciones</h2>
        <div class="modal-top-buttons" style="justify-content: flex-end;">
            <button type="button" id="close-reminders-map-help-instance" style="flex: 0 1 auto; min-width: 120px;">Entendido</button>
        </div>
        <p class="mb-2">Este mapa permite ver recordatorios con ubicación y planificar/seguir rutas GPS.</p>
        
        <h3 class="font-semibold text-lg mt-3 mb-1">Controles Principales:</h3>
        <ul class="list-disc pl-5 space-y-1 text-sm">
            <li><strong>Botón de Alerta de Tráfico <img src="https://boardinggate.github.io/Tesla/AACCIDENTE.png" alt="Alerta" style="height:1.2em; display:inline; vertical-align:middle;">:</strong> Pulsa este botón para abrir un menú y notificar una incidencia (accidente, obras, etc.) en tu ubicación actual. La alerta será visible para otros usuarios.</li>
            <li><strong>Botón Lateral <img src="Coche_Sat.PNG" alt="Toggle Panel Mapa" style="height:1.2em; display:inline; vertical-align:middle; background:rgba(128,128,128,0.3); border-radius:50%; padding:2px;"> :</strong> Este botón tiene múltiples funciones gestuales:
                <ul>
                    <li><strong>Clic Simple:</strong> Muestra/Oculta la barra de botones superior.</li>
                    <li><strong>Pulsación Larga:</strong> Abre el menú de Alertas de Tráfico.</li>
                    <li><strong>Deslizar hacia ARRIBA:</strong> Inicia o detiene la navegación de la ruta actual.</li>
                    <li><strong>Deslizar hacia ABAJO:</strong> Carga y navega a la ruta "TRABAJO".</li>
                    <li><strong>Deslizar a la DERECHA:</strong> Carga y navega a la ruta "CASA".</li>
                    <li><strong>Deslizar a la IZQUIERDA:</strong> Activa/Desactiva el modo inmersivo (solo mapa).</li>
                </ul>
             </li>
        </ul>

        <h3 class="font-semibold text-lg mt-3 mb-1">Planificación de Ruta:</h3>
        <ul class="list-disc pl-5 space-y-1 text-sm">
            <li><strong>Añadir Puntos Manualmente:</strong> Pulsa en el mapa para añadir puntos de ruta (Salida, Fin, Etapas).</li>
            <li><strong>Añadir Puntos por Búsqueda:</strong> Utiliza el campo de texto <img src="./IMG_4400.png" alt="Campo búsqueda" style="height:1.2em; display:inline; vertical-align:middle;"> y pulsa <img src="./ANADIRPUNTO.PNG" alt="Añadir punto" style="height:1.2em; display:inline; vertical-align:middle;">.</li>
            <li><strong>Reordenar Etapas:</strong> Pulsa el botón <img src="./MOVER.PNG" alt="Ordenar etapas" style="height:1.2em; display:inline; vertical-align:middle;"> para abrir la ventana de reordenación.</li>
            <li><strong>Eliminar Punto:</strong> Pulsa el aspa (X) roja en un marcador de etapa.</li>
        </ul>

        <h3 class="font-semibold text-lg mt-3 mb-1">Durante la Navegación:</h3>
         <ul class="list-disc pl-5 space-y-1 text-sm">
            <li><strong>Barra de Progreso (superior izquierda):</strong> Muestra indicaciones, ETA, etc. <strong>Pulsa el ICONO DE GIRO para ver un mapa detallado de la maniobra.</strong></li>
            <li><strong>Radares/Tareas en Ruta:</strong> Activa los checkboxes para ver en el mapa y en la barra de progreso los radares o tus tareas personales que se encuentren en la ruta.</li>
             <li><strong>Simular Recorrido <img src="./GPS.PNG" alt="Simular Recorrido" style="height:1.2em; display:inline; vertical-align:middle;">:</strong> Activa para que el coche recorra la ruta automáticamente.</li>
        </ul>
    `;

    const mapModal = document.getElementById('reminders-location-map-modal');
    if (mapModal) {
        mapModal.style.zIndex = 6400;
    }

    document.body.appendChild(helpModal); 
    
    const closeButtonHelp = helpModal.querySelector('#close-reminders-map-help-instance');
    
    const closeHandlerHelp = () => { 
        clearModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance'); 
        if (helpModal.parentNode) {
            helpModal.parentNode.removeChild(helpModal); 
        }
        if (mapModal) {
            mapModal.style.zIndex = '';
        }
    };
    
    closeButtonHelp.addEventListener('click', closeHandlerHelp); 
    addModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance', 90000);
}

    

    
    
    
    
    
    
    
    // ===================================================================
// NOMBRE: addWaypoint
// RESUMEN: Añade un punto de ruta al array de waypoints y actualiza el mapa.
// ===================================================================
async function addWaypoint(latlng, displayName = null) {
    if (!navigationMapInstance || isNavigating) return;

    let address = displayName;
    if (!address) {
        // Si no tenemos un nombre, lo buscamos. 'await' es clave aquí.
        address = await getAddressForWaypoint(latlng.lat, latlng.lng);
    }

    const newWaypoint = {
        id: Date.now(),
        lat: latlng.lat,
        lng: latlng.lng,
        type: '', // Se determinará en updateWaypointTypesAndLabels
        marker: null,
        label: '', // Se determinará en updateWaypointTypesAndLabels
        address: address, // Guardamos la dirección resuelta
        visited: false,
        isCriticalForRecalc: true,
        isInternal: false,
        isRecalculatedStart: false
    };

    if (navigationWaypoints.length === 0 && navigationCurrentLocation) {
        const startPoint = {
            id: Date.now() - 1,
            lat: navigationCurrentLocation.latitude,
            lng: navigationCurrentLocation.longitude,
            type: 'S',
            marker: null,
            label: 'S',
            address: 'Posición Actual (GPS)',
            visited: true,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false
        };
        navigationWaypoints.push(startPoint);
    }

    navigationWaypoints.push(newWaypoint);
    updateWaypointTypesAndLabels();
    renderWaypointMarkers();

    // El recálculo ahora siempre funcionará con waypoints que tienen dirección
    try {
        await recalculateAndDrawRoute();
        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
            toggleRadaresRuta(true);
        }
        const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
            toggleTareasRuta(true);
        }
    } catch (e) {
        showToast("Error recalculando la ruta tras añadir el punto.", "error");
    }

    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}
    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: formatPhotonFeatureName
    // RESUMEN: Formatea el nombre de una ubicación obtenida del servicio Photon.
    // ===================================================================
    function formatPhotonFeatureName(feature) {
        if (!feature || !feature.properties) return "Ubicación desconocida";
        const props = feature.properties;
        let nameParts = [];
        if (props.name) nameParts.push(props.name);
        if (props.street) { let streetPart = props.street; if (props.housenumber) streetPart += ` ${props.housenumber}`; nameParts.push(streetPart); }
        if (props.postcode) nameParts.push(props.postcode);
        if (props.city && (!props.name || props.name.toLowerCase() !== props.city.toLowerCase())) nameParts.push(props.city);
        else if (props.county && (!props.name || props.name.toLowerCase() !== props.county.toLowerCase())) nameParts.push(props.county);
        else if (props.state && (!props.name || props.name.toLowerCase() !== props.state.toLowerCase())) nameParts.push(props.state);
        if (props.country && nameParts.length > 0 && props.country.toLowerCase() !== nameParts[nameParts.length - 1].toLowerCase()) nameParts.push(props.country);
        else if (props.country && nameParts.length === 0) nameParts = [props.country];
        let formattedName = nameParts.filter((value, index, self) => self.map(v => v.toLowerCase()).indexOf(value.toLowerCase()) === index).join(', ');
        if (!formattedName && feature.geometry && feature.geometry.coordinates) { formattedName = `(${feature.geometry.coordinates[1].toFixed(4)}, ${feature.geometry.coordinates[0].toFixed(4)})`; }
        return formattedName || "Ubicación desconocida";
    }
    
    
    
    
    
   
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: fetchAddressSuggestions
    // RESUMEN: Obtiene sugerencias de direcciones mientras el usuario escribe.
    // ===================================================================
    async function fetchAddressSuggestions(query) {
        if (!query || query.length < 3) {
            hideAddressSuggestionsModal();
            return;
        }
        try {
            let queryToSearch = query;
            if (typeof queryToSearch === 'string') {
                queryToSearch = queryToSearch.replace(/,/g, '');
            }
            const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(queryToSearch)}&limit=60&accept-language=es&addressdetails=1`;
            const response = await fetch(url);
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Error de red: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            if (data && data.length > 0) {
                const results = data.map(item => {
                    if (item.lat && item.lon) {
                        return {
                            display_name: item.display_name || "Ubicación desconocida",
                            lat: parseFloat(item.lat),
                            lon: parseFloat(item.lon)
                        };
                    }
                    return null;
                }).filter(Boolean);
                if (results.length === 0) {
                     hideAddressSuggestionsModal();
                     if (query.length >=3 && !searchToastShown) {
                        searchToastShown = true;
                        showToast("Búsqueda de palabras tecleadas no encontradas... (de todas las palabras, da igual el orden)", "error not-found", 3000);
                        setTimeout(() => { searchToastShown = false; }, 3500);
                     }
                     return;
                }
                displayAddressSuggestionsModal(results.slice(0, 60));
            } else {
                hideAddressSuggestionsModal();
                if (query.length >=3 && !searchToastShown) {
                    searchToastShown = true;
                    showToast("Búsqueda de palabras tecleadas no encontradas... (de todas las palabras, da igual el orden)", "error not-found", 3000);
                    setTimeout(() => { searchToastShown = false; }, 3500);
                }
            }
        } catch (error) {
            showToast(`Error buscando sugerencias: ${error.message}`, "error");
            hideAddressSuggestionsModal();
        }
    }
    
    
    
    
    





// ===================================================================
// NOMBRE: snapCoordsToRoad (NUEVA FUNCIÓN)
// RESUMEN: Toma coordenadas y devuelve las coordenadas del punto más cercano en la red de carreteras.
// ===================================================================
async function snapCoordsToRoad(lat, lon) {
    try {
        const nearestUrl = `${OSRM_SERVICE_URL}/nearest/v1/driving/${lon},${lat}?number=1`;
        const nearestResponse = await fetch(nearestUrl);
        if (!nearestResponse.ok) {
            console.warn(`OSRM /nearest falló, se usarán coordenadas originales.`);
            return L.latLng(lat, lon);
        }
        const nearestData = await nearestResponse.json();
        if (nearestData.code === "Ok" && nearestData.waypoints && nearestData.waypoints.length > 0) {
            const snappedCoords = nearestData.waypoints[0].location;
            // OSRM devuelve [longitude, latitude]
            return L.latLng(snappedCoords[1], snappedCoords[0]);
        } else {
            console.warn("OSRM /nearest no encontró un punto válido, se usarán coordenadas originales.");
            return L.latLng(lat, lon);
        }
    } catch (error) {
        console.error("Error en snapCoordsToRoad:", error);
        return L.latLng(lat, lon); // Devuelve las originales como fallback
    }
}

// ===================================================================
// NOMBRE: searchAndAddWaypoint (MODIFICADA)
// RESUMEN: Busca una dirección, la transforma en coordenadas, las ajusta a la carretera y la añade como waypoint.
// ===================================================================
async function searchAndAddWaypoint(addressQuery = null) {
    const searchInput = document.getElementById('map-location-search-input');
    const address = addressQuery || searchInput.value.trim();
    if (!address) {
        showToast("Por favor, introduce una dirección para buscar", "warning");
        return;
    }

    const searchButton = document.getElementById('map-location-search-button');
    if (searchButton) {
        searchButton.disabled = true;
        searchButton.innerHTML = `<img src="BUSCANDO.PNG" alt="Buscando...">`;
    }

    try {
        showToast("Buscando dirección...", "info", 3000);
        const searchUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address.replace(/,/g, ''))}&limit=1&accept-language=es&addressdetails=1`;
        
        const searchResponse = await fetch(searchUrl);
        if (!searchResponse.ok) throw new Error(`Error de red en Nominatim: ${searchResponse.status}`);
        
        const searchData = await searchResponse.json();
        if (!searchData || searchData.length === 0) throw new Error("Dirección no encontrada");
        
        const result = searchData[0];
        const initialLat = parseFloat(result.lat);
        const initialLon = parseFloat(result.lon);
        const displayName = result.display_name || `Ubicación (${initialLat.toFixed(3)}, ${initialLon.toFixed(3)})`;
        if (isNaN(initialLat) || isNaN(initialLon)) throw new Error("Coordenadas no válidas de Nominatim");

        showToast("Ajustando a la carretera más cercana...", "info", 3000);
        const snappedLatLng = await snapCoordsToRoad(initialLat, initialLon);
        
        await addWaypoint(snappedLatLng, displayName);
        
        if (navigationMapInstance) navigationMapInstance.setView(L.latLng(initialLat, initialLon), 15);
        if (searchInput) {
            searchInput.value = '';
            searchInput.dispatchEvent(new Event('input'));
        }
        showToast("Ubicación añadida a la ruta", "success");

    } catch (error) {
        showToast(`Error al buscar dirección: ${error.message}`, "error", 4000, true);
    } finally {
        if (searchButton) {
            searchButton.disabled = false;
            searchButton.innerHTML = `<img src="ANADIRPUNTO.PNG" alt="Añadir Punto Ruta">`;
            if (searchInput && searchInput.value.trim() === '') {
                searchButton.style.display = 'none';
                const clearMapSearchBtn = document.getElementById('clear-map-search-input-button');
                if (clearMapSearchBtn) clearMapSearchBtn.style.display = 'none';
            }
        }
    }
}

// ===================================================================
// NOMBRE: displayAddressSuggestionsModal (MODIFICADA)
// RESUMEN: Muestra el modal con la lista de sugerencias de direcciones.
// ===================================================================
function displayAddressSuggestionsModal(suggestions) {
    const searchInput = document.getElementById('map-location-search-input');
    if (!searchInput) return;
    const modalId = 'address-suggestions-modal';
    closeOtherModals(modalId);
    let modal = document.getElementById(modalId);
    if (suggestions.length === 0) {
        hideAddressSuggestionsModal();
        return;
    }
    if (!modal) {
        modal = document.createElement('div');
        modal.id = modalId;
        modal.className = 'address-suggestions-modal';
        modal.innerHTML = `
            <h2 id="address-suggestions-title"></h2>
            <ul id="address-suggestions-list"></ul>
            <div class="modal-top-buttons" style="justify-content: flex-end; margin-top: 1rem;">
                <button id="close-address-suggestions-modal" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
            </div>
        `;
        document.body.appendChild(modal);
        const closeButton = modal.querySelector('#close-address-suggestions-modal');
        closeButton.addEventListener('click', hideAddressSuggestionsModal);
    }
    const titleElement = modal.querySelector('#address-suggestions-title');
    const listElement = modal.querySelector('#address-suggestions-list');
    const closeButton = modal.querySelector('#close-address-suggestions-modal');
    titleElement.textContent = `${suggestions.length} coincidencia${suggestions.length !== 1 ? 's' : ''} encontrada${suggestions.length !== 1 ? 's' : ''}`;
    listElement.innerHTML = '';
    suggestions.forEach(suggestion => {
        const li = document.createElement('li');
        li.textContent = suggestion.display_name;
        li.dataset.lat = suggestion.lat;
        li.dataset.lon = suggestion.lon;
        
        // --- LÓGICA DE CLIC CORREGIDA ---
        li.addEventListener('click', async () => {
            const lat = parseFloat(li.dataset.lat);
            const lon = parseFloat(li.dataset.lon);
            const displayName = li.textContent;
            
            if (isNaN(lat) || isNaN(lon)) {
                showToast("Error: Coordenadas de sugerencia no válidas.", "error");
                return;
            }

            hideAddressSuggestionsModal();
            showToast("Ajustando a la carretera más cercana...", "info", 3000);
            
            const snappedLatLng = await snapCoordsToRoad(lat, lon);
            await addWaypoint(snappedLatLng, displayName);

            if (navigationMapInstance) navigationMapInstance.setView(L.latLng(lat, lon), 15);
            if (searchInput) {
                searchInput.value = '';
                searchInput.dispatchEvent(new Event('input'));
            }
            showToast("Ubicación añadida a la ruta", "success");
        });
        // --- FIN DE LA CORRECCIÓN ---

        listElement.appendChild(li);
    });
    const searchInputRect = searchInput.getBoundingClientRect();
    modal.style.top = `${searchInputRect.bottom + 5}px`;
    const viewportHeight = window.innerHeight;
    const modalTop = searchInputRect.bottom + 5;
    const availableHeight = viewportHeight - modalTop - 20;
    modal.style.maxHeight = `${availableHeight}px`;
    const titleHeight = titleElement.offsetHeight;
    const buttonsHeight = modal.querySelector('.modal-top-buttons').offsetHeight;
    const listMaxHeight = availableHeight - titleHeight - buttonsHeight - 30;
    listElement.style.maxHeight = `${Math.max(100, listMaxHeight)}px`;
    modal.classList.remove('hidden');
    addModalAutoCloseTimer(modal, closeButton, 'address-suggestions-modal', 30000);
}
    
    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: hideAddressSuggestionsModal
    // RESUMEN: Oculta el modal de sugerencias de direcciones.
    // ===================================================================
    function hideAddressSuggestionsModal() {
        const modal = document.getElementById('address-suggestions-modal');
        if (modal && !modal.classList.contains('hidden')) {
            clearModalAutoCloseTimer(modal, modal.querySelector('#close-address-suggestions-modal'), 'address-suggestions-modal');
            modal.classList.add('hidden');
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: toggleMapLocationSearchVisibility
    // RESUMEN: Muestra u oculta la fila de búsqueda del mapa.
    // ===================================================================
    function toggleMapLocationSearchVisibility(show) {
        const searchRow = document.getElementById('search-row-map-header');
        const reorderButton = document.getElementById('reorder-route-stages-button');
        if (show) {
            if (searchRow) searchRow.style.display = 'flex';
            if (reorderButton && navigationWaypoints.length >= 2) reorderButton.style.display = 'inline-flex';
            else if (reorderButton) reorderButton.style.display = 'none';
        } else {
            if (searchRow) searchRow.style.display = 'none';
            if (reorderButton) reorderButton.style.display = 'none';
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getAddressForWaypoint
    // RESUMEN: Obtiene la dirección de un punto de ruta usando geocodificación inversa.
    // ===================================================================
    async function getAddressForWaypoint(lat, lng) {
        if (typeof lat !== 'number' || typeof lng !== 'number' || isNaN(lat) || isNaN(lng)) {
            return "Ubicación Desconocida";
        }
        try {
            const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=0&accept-language=es`);
            if (response.ok) {
                const data = await response.json();
                return data.display_name || `(${lat.toFixed(3)}, ${lng.toFixed(3)})`;
            } else {
                return `Etapa (${lat.toFixed(3)}, ${lng.toFixed(3)})`;
            }
        } catch (err) {
            return `Etapa (${lat.toFixed(3)}, ${lng.toFixed(3)})`;
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: updateWaypointTypesAndLabels
    // RESUMEN: Actualiza los tipos (inicio/fin/intermedio) y etiquetas de los puntos de ruta.
    // ===================================================================
    function updateWaypointTypesAndLabels() {
        const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
        if (actualWaypoints.length === 0) return;
        actualWaypoints.forEach(async (wp, index) => {
            if (!wp) return;
            if (actualWaypoints.length === 1) {
                wp.type = 'S';
                wp.label = 'S';
            } else if (index === 0) {
                wp.type = 'S';
                wp.label = 'S';
            } else if (index === actualWaypoints.length - 1) {
                wp.type = 'F';
                wp.label = 'F';
            } else {
                wp.type = 'intermediate';
                wp.label = String(index);
            }
            if (!wp.address) {
                if (typeof wp.lat === 'number' && typeof wp.lng === 'number') {
                     getAddressForWaypoint(wp.lat, wp.lng).then(addr => {
                        wp.address = addr;
                        if (wp.marker && wp.marker.getPopup()) {
                        }
                    });
                } else {
                    wp.address = "Coordenadas no disponibles para dirección";
                }
            }
        });
        navigationWaypoints.forEach(wp => {
            if(wp && (wp.isInternal || wp.isRecalculatedStart)) {
                wp.label = '';
            }
        });
    }
    
    
    
    
    
    
   // ===================================================================
// NOMBRE: createWaypointMarkerIcon
// RESUMEN: Crea un icono de marcador de punto de ruta personalizado.
// ===================================================================
function createWaypointMarkerIcon(label, type, visited, currentZoomLevel = null) {
    let className = 'navigation-waypoint-marker';
    let visitedStyle = '';
    if (visited) {
        visitedStyle = 'background-color: #888 !important; opacity: 0.7; border: 2px solid #555;';
    } else {
        if (type === 'S' || type === 'S_Recalc') {
            className += ' start-point';
        } else if (type === 'F') {
            className += ' finish-point';
        } else {
            className += ' intermediate-point';
        }
    }

    let baseIconSize = [35, 35]; // Original: [30, 30] -> 30 * 1.15 ≈ 34.5 -> 35
    let baseFontSize = 16;       // Original: 14 -> 14 * 1.15 ≈ 16.1 -> 16
    let baseDeleteButtonSize = [21, 21]; // Original: [18, 18] -> 18 * 1.15 ≈ 20.7 -> 21
    let baseDeleteButtonFontSize = 16;   // Original: 14 -> 14 * 1.15 ≈ 16.1 -> 16
    let baseDeleteButtonOffset = [-10, -10]; // Original: [-8, -8] -> -8 * 1.15 ≈ -9.2 -> -10
 
    let scale = 1;
    let iconSize = [Math.round(baseIconSize[0] * scale), Math.round(baseIconSize[1] * scale)];
    let fontSize = Math.round((baseFontSize * scale) * 10) / 10;
    let deleteButtonSize = [Math.round(baseDeleteButtonSize[0] * scale), Math.round(baseDeleteButtonSize[1] * scale)];
    let deleteButtonFontSize = Math.round(baseDeleteButtonFontSize * scale);
    let deleteButtonOffsetTop = Math.round(baseDeleteButtonOffset[0] * scale);
    let deleteButtonOffsetRight = Math.round(baseDeleteButtonOffset[1] * scale);
    let iconAnchor = [iconSize[0] / 2, iconSize[1] / 2];
    const showDelete = type !== 'S_Recalc';
    const iconHtml = `<div class="${className}" style="width: ${iconSize[0]}px; height: ${iconSize[1]}px; font-size: ${fontSize}px; line-height: ${iconSize[1]}px; ${visitedStyle}">
            ${label}
            ${showDelete ? `<div class="waypoint-delete-button" title="Eliminar este punto" style="width: ${deleteButtonSize[0]}px; height: ${deleteButtonSize[1]}px; font-size: ${deleteButtonFontSize}px; line-height: ${deleteButtonSize[1]}px; top: ${deleteButtonOffsetTop}px; right: ${deleteButtonOffsetRight}px;">×</div>` : ''}
        </div>`;
    return L.divIcon({
        html: iconHtml,
        className: '',
        iconSize: iconSize,
        iconAnchor: iconAnchor
    });
} 
    
    
    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: getRouteForSingleLeg
    // RESUMEN: Obtiene la distancia y duración de un solo tramo de ruta.
    // ===================================================================
    async function getRouteForSingleLeg(lon1, lat1, lon2, lat2) {
        const url = `${OSRM_SERVICE_URL}/driving/${lon1},${lat1};${lon2},${lat2}?overview=false&alternatives=false&steps=false&annotations=false`;
        try {
            const response = await fetch(url);
            if (!response.ok) {
                return { distance: 0, duration: 0 };
            }
            const data = await response.json();
            if (data.routes && data.routes.length > 0 && data.routes[0]) {
                return {
                    distance: data.routes[0].distance || 0,
                    duration: data.routes[0].duration || 0
                };
            }
            return { distance: 0, duration: 0 };
        } catch (error) {
            return { distance: 0, duration: 0 };
        }
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: clearAllWaypointMarkersFromMap
    // RESUMEN: Elimina todos los marcadores de puntos de ruta del mapa.
    // ===================================================================
    function clearAllWaypointMarkersFromMap() {
        if (!navigationMapInstance) {
            navigationWaypoints.forEach(wp => { wp.marker = null; }); 
            return;
        }
        navigationWaypoints.forEach(wp => {
            if (wp && wp.marker) {
                try {
                    if (navigationMapInstance.hasLayer(wp.marker)) {
                        navigationMapInstance.removeLayer(wp.marker);
                    }
                } catch (e) {
                }
                wp.marker = null;
            }
        });
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: renderWaypointMarkers
    // RESUMEN: Dibuja o redibuja todos los marcadores de puntos de ruta en el mapa.
    // ===================================================================
    function renderWaypointMarkers() {
        if (!navigationMapInstance) return;
        clearAllWaypointMarkersFromMap();
        const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
        actualWaypoints.forEach(async (wp) => {
            if (!wp) return;
            const waypointIcon = createWaypointMarkerIcon(wp.label, wp.type, wp.visited, null);
            wp.marker = L.marker([wp.lat, wp.lng], {
                icon: waypointIcon,
                draggable: !isNavigating,
                zIndexOffset: 1001
            });
            try {
                wp.marker.addTo(navigationMapInstance);
            } catch(e) {
                 return;
            }
            const markerElement = wp.marker.getElement();
            if (markerElement) {
                const deleteButton = markerElement.querySelector('.waypoint-delete-button');
                if (deleteButton) {
                    L.DomEvent.on(deleteButton, 'click', function(ev) {
                        L.DomEvent.stopPropagation(ev);
                        handleDeleteWaypointClick(wp.id);
                    });
                }
            }
            let popupContent = `<strong>Punto ${wp.label}</strong><br>Cargando datos...`;
            const popup = L.popup({ maxWidth: 250, autoPanPadding: L.point(50, 50), closeButton: true }).setContent(popupContent);
            wp.marker.bindPopup(popup);
            wp.marker.on('click', async (e) => {
                if (!navigationMapInstance) return;
                const waypoint = navigationWaypoints.find(w => w && w.id === wp.id);
                if (!waypoint) return;
                let address = waypoint.address || "Calculando dirección...";
                if (!waypoint.address) {
                     if (typeof waypoint.lat === 'number' && typeof waypoint.lng === 'number') {
                        waypoint.address = await getAddressForWaypoint(waypoint.lat, waypoint.lng);
                     } else {
                        waypoint.address = "Coordenadas no disponibles para dirección";
                     }
                     address = waypoint.address;
                }
                let distanceToWaypoint = 0;
                let timeToWaypoint = 0;
                let etaToWaypoint = "--:--";
                const currentCarPosForPopup = navigationCurrentLocation;
                const currentActualWaypointsForPopup = navigationWaypoints.filter(w => w && !w.isInternal && !w.isRecalculatedStart);
                const actualWaypointIndexInRoute = currentActualWaypointsForPopup.findIndex(awp => awp.id === wp.id);
                if (currentCarPosForPopup && navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
                    const route = navigationCurrentRouteData.routes[0];
                    let cumulativeDistanceToThisWp = 0;
                    let cumulativeDurationToThisWp = 0;
                    if (actualWaypointIndexInRoute === 0) {
                        if (isNavigating) {
                            distanceToWaypoint = 0;
                            timeToWaypoint = 0;
                        } else {
                             if (typeof waypoint.lat === 'number' && typeof waypoint.lng === 'number') {
                                const tempRouteToS = await getRouteForSingleLeg(currentCarPosForPopup.longitude, currentCarPosForPopup.latitude, waypoint.lng, waypoint.lat);
                                if (tempRouteToS) {
                                    distanceToWaypoint = tempRouteToS.distance;
                                    timeToWaypoint = tempRouteToS.duration;
                                }
                            }
                        }
                    } else if (actualWaypointIndexInRoute > 0) {
                        for (let i = 0; i < actualWaypointIndexInRoute && i < route.legs.length; i++) {
                            if (route.legs[i]) {
                               cumulativeDistanceToThisWp += (route.legs[i].distance || 0);
                               cumulativeDurationToThisWp += (route.legs[i].duration || 0);
                            }
                        }
                        distanceToWaypoint = cumulativeDistanceToThisWp;
                        timeToWaypoint = cumulativeDurationToThisWp;
                        if (isNavigating && navigationMapInstance && typeof L.GeometryUtil !== 'undefined' && L.GeometryUtil) {
                            let distanceCoveredOnRoute = lastCarDistanceAlongRouteForNavLogic;
                            distanceToWaypoint = Math.max(0, cumulativeDistanceToThisWp - distanceCoveredOnRoute);
                            if (route.distance && route.distance > 0) {
                                timeToWaypoint = route.duration * (distanceToWaypoint / route.distance);
                            } else {
                                timeToWaypoint = 0;
                            }
                        }
                    }
                     if (typeof timeToWaypoint === 'number' && !isNaN(timeToWaypoint)) {
                        etaToWaypoint = new Date(Date.now() + timeToWaypoint * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    }
                } else if (currentCarPosForPopup) {
                     if (typeof waypoint.lat === 'number' && typeof waypoint.lng === 'number') {
                        const tempRoute = await getRouteForSingleLeg(currentCarPosForPopup.longitude, currentCarPosForPopup.latitude, waypoint.lng, waypoint.lat);
                        if (tempRoute) {
                            distanceToWaypoint = tempRoute.distance;
                            timeToWaypoint = tempRoute.duration;
                            if (typeof timeToWaypoint === 'number' && !isNaN(timeToWaypoint)) {
                               etaToWaypoint = new Date(Date.now() + timeToWaypoint * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                            }
                        }
                    }
                }
                let distanciaTexto = "-- km";
                if (typeof distanceToWaypoint === 'number' && !isNaN(distanceToWaypoint)) {
                    distanciaTexto = `${(distanceToWaypoint / 1000).toFixed(1)} km`;
                }
                let tiempoTexto = "--:--";
                if (typeof timeToWaypoint === 'number' && !isNaN(timeToWaypoint)) {
                    const waypointTotalMinutes = Math.round(timeToWaypoint / 60);
                    const waypointHours = Math.floor(waypointTotalMinutes / 60);
                    const waypointMinutes = waypointTotalMinutes % 60;
                    tiempoTexto = `${String(waypointHours).padStart(2, '0')}:${String(waypointMinutes).padStart(2, '0')}`;
                }
                const showDeleteButtonInPopup = waypoint.type !== 'S_Recalc';
                const finalPopupContent = `
                    <div style="font-family: sans-serif; font-size: 0.9rem; max-width: 230px;">
                        <strong style="font-size: 1rem; color: #333; display: block; margin-bottom: 3px;">Punto ${waypoint.label}: ${address || 'Dirección no disponible'}</strong>
                        <hr style="margin: 3px 0;">
                        <p style="margin: 2px 0;"><strong>Distancia:</strong> ${distanciaTexto}</p>
                        <p style="margin: 2px 0;"><strong>Tiempo:</strong> ${tiempoTexto}</p>
                        <p style="margin: 2px 0;"><strong>Llegada (ETA):</strong> ${etaToWaypoint || '--:--'}</p>
                        ${showDeleteButtonInPopup ? `<button data-waypoint-id="${waypoint.id}" class="delete-waypoint-from-popup" style="margin-top: 8px; padding: 4px 8px; font-size: 0.8rem; background-color: #EF4444; color: white; border: none; border-radius: 3px; cursor: pointer;">BORRAR PUNTO</button>` : ''}
                    </div>`;
                popup.setContent(finalPopupContent).update();
                const deleteButtonPopup = popup.getElement().querySelector('.delete-waypoint-from-popup');
                if (deleteButtonPopup) {
                    L.DomEvent.on(deleteButtonPopup, 'click', function(ev) {
                        L.DomEvent.stopPropagation(ev);
                        const wpIdToDelete = parseInt(this.dataset.waypointId);
                        if (!isNaN(wpIdToDelete)) {
                             if(popup.isOpen()) popup.remove();
                             handleDeleteWaypointClick(wpIdToDelete);
                        }
                    });
                }
            });
            wp.marker.on('dragstart', function() {
                if (isNavigating) return;
                if(this.isPopupOpen()) this.closePopup();
            });
            wp.marker.on('dragend', function(event) {
                if (isNavigating) return;
                const newLatLng = event.target.getLatLng();
                wp.lat = newLatLng.lat;
                wp.lng = newLatLng.lng;
                wp.address = '';
                recalculateAndDrawRoute().then(() => {
                    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
                    if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                        toggleRadaresRuta(true);
                    }
                    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
                    if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                        toggleTareasRuta(true);
                    }
                });
            });
        });
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleDeleteWaypointClick
    // RESUMEN: Elimina un punto de ruta de la ruta actual.
    // ===================================================================
    function handleDeleteWaypointClick(waypointId) {
        if (isNavigating) {
            showToast("No se pueden borrar puntos mientras se navega.", "warning");
            return;
        }
        const waypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
        if (waypointIndex === -1) {
            return;
        }
        const waypointToDelete = navigationWaypoints[waypointIndex];
        if (waypointToDelete.marker && navigationMapInstance) {
            try { navigationMapInstance.removeLayer(waypointToDelete.marker); } catch (e) {}
            waypointToDelete.marker = null;
        }
        navigationWaypoints.splice(waypointIndex, 1);
        if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 1) { 
            clearAllWaypointMarkersFromMap(); 
            navigationWaypoints = [];
            if (navigationRouteLayer && navigationMapInstance) {
                try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch (e) {}
                navigationRouteLayer = null;
            }
            if (completedRouteSegmentsLayer && navigationMapInstance ) completedRouteSegmentsLayer.clearLayers();
            navigationCurrentRouteData = null;
            hideNavigationUI();
            hideMapInfoOverlay();
            const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
            if (radaresRutaCheckbox) {
                eliminarRadaresDeRuta();
                actualizarContadorRadares(0);
                localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked)); 
            }
             const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
            if (tareasRutaCheckbox) {
                eliminarTareasDeBarraProgreso();
                actualizarContadorTareas(0);
                localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
            }
        } else {
            updateWaypointTypesAndLabels();
            renderWaypointMarkers();
            if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
                if (navigationRouteLayer && navigationMapInstance) {
                    try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch (e) {}
                    navigationRouteLayer = null;
                }
                 if (completedRouteSegmentsLayer && navigationMapInstance ) completedRouteSegmentsLayer.clearLayers();
                navigationCurrentRouteData = null;
                hideMapInfoOverlay();
                 const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
                if (radaresRutaCheckbox) {
                    eliminarRadaresDeRuta();
                    actualizarContadorRadares(0);
                    localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked));
                }
                const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
                if (tareasRutaCheckbox) {
                    eliminarTareasDeBarraProgreso();
                    actualizarContadorTareas(0);
                    localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
                }
            } else {
                recalculateAndDrawRoute().then(() => {
                    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
                    if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                        toggleRadaresRuta(true);
                    }
                    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
                    if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                        toggleTareasRuta(true);
                    }
                });
            }
            showToast("Etapa eliminada.", "info");
        }
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
    }
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: drawRouteOnMap
    // RESUMEN: Dibuja la geometría de la ruta en el mapa.
    // ===================================================================
    function drawRouteOnMap(route) {
        if (!navigationMapInstance) return;
        if (navigationRouteLayer) {
            try {
                navigationMapInstance.removeLayer(navigationRouteLayer);
            } catch(e) {
            }
            navigationRouteLayer = null;
        }
        if (!route || !route.geometry || !route.geometry.coordinates || route.geometry.coordinates.length < 2) {
            showToast("Geometría de ruta inválida para dibujar.", "warning");
            navigationRouteLayer = null;
            return;
        }
        const routeCoords = route.geometry.coordinates.map(coord => [coord[1], coord[0]]);
        navigationRouteLayer = L.polyline(routeCoords, {
            color: 'yellow',
            weight: 10,
            opacity: 1.0
        }).addTo(navigationMapInstance);
        if (navigationMapInstance.attributionControl) {
             navigationMapInstance.attributionControl.addAttribution('Rutas © <a href="http://project-osrm.org/">OSRM</a>');
        }
    }
    
    
    
    
    
    
 // ===================================================================
// NOMBRE: translateOcmTerm
// RESUMEN: Traduce términos comunes de OCM del inglés al castellano.
// ===================================================================
function translateOcmTerm(term) {
    if (!term) return 'No especificado';
     const translations = {
        'Parking': 'Parking de pago',
        'Operational': 'Operativo',
        'Non-Operational': 'No operativo',
        'Not Operational': 'No operativo',   
        'Partly-Operational': 'Parcialmente operativo',
        'Planned For Future Date': 'Planificado',
        'Decommissioned': 'Fuera de servicio',
        'Public - Membership Required': 'Público - Requiere Membresía',
        'Public - Pay At Location': 'Público - Pago en el sitio',
        'Public': 'Público',
        'Privately Owned - For Staff, Visitors or Customers': 'Privado - Para personal o clientes',
        'Private - For Staff, Visitors or Customers': 'Privado - Para personal o clientes',
        'Private - Restricted Access': 'Privado - Acceso restringido'
    };
    return translations[term] || term;
}   
    
    


// ===================================================================
// NOMBRE: showChargingPointModal
// RESUMEN: Crea y muestra un modal detallado para un punto de recarga OCM.
// ===================================================================
function showChargingPointModal(point, index) {
    const existingModal = document.querySelector('.ocm-modal-overlay');
    if (existingModal) existingModal.remove();

    const overlay = document.createElement('div');
    overlay.className = 'ocm-modal-overlay';

    const photoUrl = (point.MediaItems && point.MediaItems.length > 0 && point.MediaItems[0].ItemURL) 
        ? point.MediaItems[0].ItemURL 
        : 'https://boardinggate.github.io/Tesla/PDREJEMPLO.PNG';
    
    const addressInfo = point.AddressInfo || {};
    const stationName = addressInfo.Title || 'Punto de Recarga';
    
    let addressParts = [];
    if (addressInfo.AddressLine1) addressParts.push(addressInfo.AddressLine1);
    
    const locationName = addressInfo.Town || addressInfo.StateOrProvince;
    if (addressInfo.Postcode && locationName) {
        addressParts.push(`${addressInfo.Postcode} - ${locationName}`);
    } else if (addressInfo.Postcode) {
        addressParts.push(addressInfo.Postcode);
    } else if (locationName) {
        addressParts.push(locationName);
    }
    const addressHtml = addressParts.join('<br>');

    const operatorInfo = point.OperatorInfo || {};

    let detailsHtml = '<h4>Detalles de Ubicación</h4>';
    detailsHtml += `<p><strong>Dirección Completa:</strong> ${addressInfo.Title}</p>`;
    detailsHtml += `<p><strong>Lat/Lon:</strong> ${addressInfo.Latitude.toFixed(5)}, ${addressInfo.Longitude.toFixed(5)}</p>`;
    // --- INICIO: BOTÓN ELECTROVERSE AÑADIDO ---
    const escapedStationName = stationName.replace(/'/g, "\\'");
    const escapedAddressTitle = addressInfo.Title.replace(/'/g, "\\'");
    detailsHtml += `<button class="electroverse-verify-button" onclick="showElectroverseModal('${escapedStationName}', '${escapedAddressTitle}')">VER EN ELECTROVERSE...</button>`;
    // --- FIN: BOTÓN ELECTROVERSE AÑADIDO ---

    detailsHtml += '<h4>Equipamiento / Tarifa</h4>';
    if (point.Connections && point.Connections.length > 0) {
        point.Connections.forEach(conn => {
            const connType = conn.ConnectionType ? conn.ConnectionType.Title.replace(' (Socket)', '').replace(' (Connector)', '') : 'Desconocido';
            const power = conn.PowerKW ? `${conn.PowerKW.toFixed(0)} kW` : '';
            const status = conn.StatusType ? `(${translateOcmTerm(conn.StatusType.Title)})` : '';
            detailsHtml += `
                <div class="ocm-connection-item">
                    <span class="ocm-connection-type">• ${connType}</span>
                    <span class="ocm-connection-power-status">${power} ${status}</span>
                </div>`;
        });
    } else {
        detailsHtml += '<p>No hay información de conectores.</p>';
    }
    if (point.UsageCost) detailsHtml += `<p class="ocm-price-info"><strong>${point.UsageCost}</strong></p>`;

    detailsHtml += '<h4>Restricciones de Uso</h4>';
    detailsHtml += `<p><strong>Estado:</strong> ${translateOcmTerm(point.StatusType?.Title)}</p>`;
    detailsHtml += `<p><strong>Uso:</strong> ${translateOcmTerm(point.UsageType?.Title)}</p>`;

    detailsHtml += '<h4>Operador/Red</h4>';
    detailsHtml += `<p><strong>Nombre:</strong> ${operatorInfo.Title || 'No especificado'}</p>`;
    if (operatorInfo.WebsiteURL) detailsHtml += `<p><strong>Web:</strong> <a href="${operatorInfo.WebsiteURL}" target="_blank" rel="noopener noreferrer">${operatorInfo.WebsiteURL}</a></p>`;
    if (operatorInfo.PhonePrimaryContact) detailsHtml += `<p><strong>Teléfono:</strong> <a href="tel:${operatorInfo.PhonePrimaryContact}">${operatorInfo.PhonePrimaryContact}</a></p>`;

    let photosHtml = '<div class="ocm-photo-grid">';
    if (point.MediaItems && point.MediaItems.length > 0) {
        point.MediaItems.forEach(item => {
            if (item.ItemURL) {
                 photosHtml += `<img src="${item.ItemURL}" alt="${item.Comment || 'Foto del punto de recarga'}" data-full-url="${item.ItemURL}">`;
            }
        });
    } else {
        photosHtml += '<p>No hay fotografías disponibles para este punto.</p>';
    }
    photosHtml += '</div>';

    let commentsHtml = '<ul class="ocm-comment-list">';
    if (point.UserComments && point.UserComments.length > 0) {
        point.UserComments.forEach(comment => {
            commentsHtml += `
                <li class="ocm-comment">
                    <div class="ocm-comment-header">
                        <span class="user">${comment.UserName || 'Anónimo'}</span>
                        <span class="date">${comment.DateCreated ? formatDateToDDMMMYY(comment.DateCreated.split('T')[0]) : ''}</span>
                    </div>
                    <p class="comment-text">${comment.Comment}</p>
                </li>`;
        });
    } else {
        commentsHtml += '<p>No hay comentarios para este punto.</p>';
    }
    commentsHtml += '</ul>';

    overlay.innerHTML = `
        <div class="ocm-modal-content">
            <div class="ocm-modal-header" style="background-image: url('${photoUrl}')">
                <div class="ocm-modal-station-name-wrapper">
                    <span class="ocm-modal-station-name">${stationName}</span>
                </div>
                <div class="ocm-modal-address">${addressHtml}</div>
            </div>
            <div class="ocm-modal-tabs">
                <div class="ocm-modal-tab active" data-panel="details">DETALLES</div>
                <div class="ocm-modal-tab" data-panel="photos">FOTOS (${point.MediaItems?.length || 0})</div>
                <div class="ocm-modal-tab" data-panel="comments">COMENTARIOS (${point.UserComments?.length || 0})</div>
            </div>
            <div class="ocm-modal-body">
                <div id="ocm-panel-details" class="ocm-modal-panel active">${detailsHtml}</div>
                <div id="ocm-panel-photos" class="ocm-modal-panel">${photosHtml}</div>
                <div id="ocm-panel-comments" class="ocm-modal-panel">${commentsHtml}</div>
            </div>
            <div class="ocm-modal-footer">
                <button id="ocm-add-route-btn" data-index="${index}">Añadir a la Ruta</button>
                <button id="ocm-close-btn">Salir</button>
            </div>
        </div>
    `;

    document.body.appendChild(overlay);

    const closeBtn = overlay.querySelector('#ocm-close-btn');
    let modalTimer = null; // Mover la declaración del timer aquí

    const closeHandler = () => {
        if (modalTimer) clearInterval(modalTimer);
        if (overlay.parentNode) {
            overlay.remove();
        }
    };
    closeBtn.addEventListener('click', closeHandler);
    
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            closeHandler();
        }
    });
    
    overlay.querySelector('#ocm-add-route-btn').addEventListener('click', (e) => {
        const pointIndex = parseInt(e.target.dataset.index);
        addChargingPointToRoute(pointIndex);
        closeHandler();
    });

    overlay.querySelectorAll('.ocm-modal-tab').forEach(tab => {
        tab.addEventListener('click', () => {
            overlay.querySelectorAll('.ocm-modal-tab').forEach(t => t.classList.remove('active'));
            overlay.querySelectorAll('.ocm-modal-panel').forEach(p => p.classList.remove('active'));
            tab.classList.add('active');
            overlay.querySelector(`#ocm-panel-${tab.dataset.panel}`).classList.add('active');
        });
    });

    overlay.querySelectorAll('.ocm-photo-grid img').forEach(img => {
        img.addEventListener('click', () => {
            showPhotoModal(img.dataset.fullUrl);
        });
    });

    let countdown = 40;
    const countdownSpan = document.createElement('span');
    countdownSpan.className = 'button-countdown-timer';
    countdownSpan.textContent = ` (${countdown})`;
    closeBtn.appendChild(countdownSpan);

    modalTimer = setInterval(() => {
        countdown--;
        countdownSpan.textContent = ` (${countdown})`;
        if (countdown <= 0) {
            closeHandler();
        }
    }, 1000);
}    
    








    
    



// ===================================================================
// NOMBRE: clearChargingPoints
// RESUMEN: Elimina del mapa y de la memoria los puntos de recarga temporales.
// ===================================================================
function clearChargingPoints() {
    currentChargingPointsOnRoute = [];
    if (chargingPointsLayer) {
        chargingPointsLayer.clearLayers();
    }
}





// ===================================================================
// NOMBRE: displayChargingPointsOnMap
// RESUMEN: Dibuja los PDRs en el mapa, con color por potencia y brillo por precio.
// ===================================================================
function displayChargingPointsOnMap() {
    if (!navigationMapInstance) return;

    // --- INICIO DE LA LÓGICA ROBUSTA ---
    // 1. Aseguramos que la capa exista y esté en el mapa antes de usarla.
    if (chargingPointsLayer) {
        // Si la capa existe, la vaciamos de marcadores antiguos.
        chargingPointsLayer.clearLayers();
        // Comprobación de seguridad: si por alguna razón fue eliminada del mapa, la volvemos a añadir.
        if (!navigationMapInstance.hasLayer(chargingPointsLayer)) {
            chargingPointsLayer.addTo(navigationMapInstance);
        }
    } else {
        // Si la capa no existe, la creamos y la añadimos al mapa.
        chargingPointsLayer = L.layerGroup().addTo(navigationMapInstance);
    }
    // --- FIN DE LA LÓGICA ROBUSTA ---
    
    const currentZoom = navigationMapInstance.getZoom();
    const ZOOM_THRESHOLD = 14;

    currentChargingPointsOnRoute.forEach((point, index) => {
        let icon;
        const pointPower = parseFloat(point.power);
        const bgColor = getChargingPointColorByPower(pointPower);
        const glowStyle = point.isCheapest ? 'box-shadow: 0 0 15px 5px yellow, inset 0 0 5px 2px yellow; border-color: yellow;' : '';
        const smallGlowStyle = point.isCheapest ? 'box-shadow: 0 0 10px 3px yellow; border-color: yellow;' : '';

        if (currentZoom > ZOOM_THRESHOLD) {
            const operatorText = point.operator.length > 15 ? point.operator.substring(0, 14) + '...' : point.operator;
            const priceValue = point.price.replace(/€\/kWh/i, '').trim();
            
            const cardHtml = `
                <div class="charging-point-card" style="background-color: ${bgColor}; ${glowStyle}">
                    <span class="power">${point.power} <span class="unit-text">kW</span></span>
                    <p class="operator">${operatorText}</p>
                    <span class="price"><strong>${priceValue} <span class="unit-text">€/kWh</span></strong></span>
                    <p class="availability">${point.availabilityText}</p>
                </div>
            `;
            icon = L.divIcon({
                html: cardHtml,
                className: '',
                iconSize: [90, 90],
                iconAnchor: [45, 45]
            });
        } else {
            const simpleIconHtml = `
                <div class="charging-point-icon-simple" style="background-color: ${bgColor}; ${smallGlowStyle}">
                    <img src="pdrs.png" alt="Punto de Recarga">
                </div>
            `;
            icon = L.divIcon({
                html: simpleIconHtml,
                className: '',
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
        }

        const marker = L.marker([point.lat, point.lon], { icon: icon, zIndexOffset: 900 }).addTo(chargingPointsLayer);
        marker.on('click', () => {
            const fullPointData = window.lastOcmApiResponse.find(p => p.ID === point.ocmId);
            if (fullPointData) {
                showChargingPointModal(fullPointData, index);
            } else {
                showToast('Error: No se encontraron los datos completos del punto.', 'error');
            }
        });
    });
}
    



    

// ===================================================================
// NOMBRE: showPDRsFilterModal
// RESUMEN: Muestra un modal de filtro que se adapta si hay o no una ruta cargada.
// ===================================================================
function showPDRsFilterModal() {
    const mapContainer = document.getElementById('reminders-location-map-modal');
    if (!mapContainer || !navigationMapInstance) {
        showToast("El mapa de navegación debe estar abierto para usar los filtros.", "error");
        return;
    }

    const hasRoute = navigationRouteLayer && navigationRouteLayer.getLatLngs().length > 1;

    // --- INICIO: Definición de claves y lectura de valores guardados ---
    const PDR_MIN_POWER_KEY = 'boardinggate_pdrFilterMinPower';
    const PDR_MAX_POWER_KEY = 'boardinggate_pdrFilterMaxPower';
    const PDR_DISTANCE_KEY = 'boardinggate_pdrFilterDistance'; // Se usa para distancia y radio
    const PDR_RADIUS_KEY = 'boardinggate_pdrFilterRadius';     // Clave específica para el radio

    // Leer valores guardados o usar defaults
    const savedMinPower = parseInt(localStorage.getItem(PDR_MIN_POWER_KEY)) || 30;
    const savedMaxPower = parseInt(localStorage.getItem(PDR_MAX_POWER_KEY)) || 600;
    const savedDistance = parseInt(localStorage.getItem(PDR_DISTANCE_KEY)) || 20;
    const savedRadius = parseInt(localStorage.getItem(PDR_RADIUS_KEY)) || 15;
    let distanceControlHtml;
    if (hasRoute) {
        distanceControlHtml = `
            <div id="distance-slider-container" class="filter-group">
                <label id="distance-range-label">Distancia Máxima a la Ruta: ${savedDistance} km</label> 
                <div class="slider-container single-slider-container">
                    <div class="slider-track"></div>
                    <div class="slider-range" id="distance-slider-range"></div>
                    <div class="slider-thumb" id="distance-thumb"></div>
                </div>
            </div>`;
    } else {
        distanceControlHtml = `
            <div id="radius-slider-container" class="filter-group">
                <label id="radius-range-label">Radio de Búsqueda: ${savedRadius} km</label> 
                <div class="slider-container single-slider-container">
                    <div class="slider-track"></div>
                    <div class="slider-range" id="radius-slider-range"></div>
                    <div class="slider-thumb" id="radius-thumb"></div>
                </div>
            </div>`;
    }

    const existingModal = document.getElementById('pdrs-filter-modal-overlay');
    if (existingModal) existingModal.remove();

    const savedOperatorFilter = localStorage.getItem('boardinggate_operator_filter') || '';
    const modalOverlay = document.createElement('div');
    modalOverlay.id = 'pdrs-filter-modal-overlay';
    modalOverlay.className = 'filter-modal-overlay';
    // Dentro de la función showPDRsFilterModal...
// ...
    modalOverlay.innerHTML = `
        <div class="filter-modal-content">
            <h2>FILTRO PUNTOS DE CARGA</h2>
            <div class="filter-group">
                <label for="operator-filter-input">Filtrar operadores:</label>
                <div style="position: relative; width: 90%; margin: 5px auto 0 auto;">
                    <input type="text" id="operator-filter-input" value="${savedOperatorFilter}" placeholder="Ej: Zunder Iberdrola" style="width: 100%; padding: 8px 30px 8px 8px; font-size: 1rem; border-radius: 4px; border: 1px solid #ccc;">
                    <button id="clear-operator-filter" title="Limpiar filtro de operadores" style="position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 1.5rem; color: #888; cursor: pointer; padding: 0 5px; display: none;">×</button>
                </div>
            </div>
            <div class="filter-group">
                <label id="power-range-label">Potencia: ${savedMinPower} kW - ${savedMaxPower} kW</label> 
                <div class="slider-container">
                    <div class="slider-track"></div>
                    <div class="slider-range" id="power-slider-range"></div>
                    <div class="slider-thumb left" id="power-thumb-min"></div>
                    <div class="slider-thumb right" id="power-thumb-max"></div>
                </div>
            </div>
            ${distanceControlHtml}
            
            <div class="filter-group" style="text-align: left; margin-top: 20px; padding-top: 15px; border-top: 1px solid #ccc;">
                <label id="search-in-view-label" style="display: flex; align-items: center; cursor: pointer; font-size: 1.1rem; user-select: none; transition: opacity 0.3s;">
                    <input type="checkbox" id="search-in-view-checkbox" style="width: 1.2rem; height: 1.2rem; margin-right: 10px; flex-shrink: 0;">
                    Buscar en la zona del mapa que estés viendo ahora
                </label>
            </div>

            <button id="accept-filters-btn">Aceptar</button>
            <div class="filter-help-text">
                <center>
                <p><strong>(*)</strong> Si hay ruta cargada se buscará en el trazado, sino en el radio desde el centro del mapa.</p>
                <!-- INICIO: NOTA AÑADIDA -->
                <p style="margin-top:5px;"><strong>(*)</strong> Tras una búsqueda, si vuelve a pulsar BUSCAR Pdrs, se mostrarán solo los más económicos de cada rango de potencia. Tras una segunda pulsación, se abrirá de nuevo esta ventana.</p>
                <!-- FIN: NOTA AÑADIDA -->
                <p style="margin-top:5px; font-style:italic;">Datos proporcionados por <a href="https://openchargemap.org" target="_blank" style="color:#0056b3; text-decoration:underline;">Open Charge Map</a>.</p>
              </center>
            </div>
        </div>
    `;
// ... resto de la función
    mapContainer.appendChild(modalOverlay);
    
    // --- LÓGICA DE INTERACCIÓN DE CONTROLES (Sin cambios) ---
    // ... (el código de updateControlsState y los listeners del checkbox se mantienen igual)
    const PDR_SEARCH_IN_VIEW_KEY = 'boardinggate_pdrSearchInView';
    const searchInViewCheckbox = document.getElementById('search-in-view-checkbox');
    const searchInViewLabel = document.getElementById('search-in-view-label');
    const distanceSliderContainer = document.getElementById('distance-slider-container') || document.getElementById('radius-slider-container');
    
    const updateControlsState = () => {
        if (hasRoute) {
            searchInViewCheckbox.checked = false;
            searchInViewCheckbox.disabled = true;
            searchInViewLabel.style.opacity = '0.5';
            searchInViewLabel.style.cursor = 'not-allowed';
            distanceSliderContainer.style.opacity = '1';
            distanceSliderContainer.style.pointerEvents = 'auto';
        } else {
            searchInViewCheckbox.disabled = false;
            searchInViewLabel.style.opacity = '1';
            searchInViewLabel.style.cursor = 'pointer';
            
            if (searchInViewCheckbox.checked) {
                distanceSliderContainer.style.opacity = '0.5';
                distanceSliderContainer.style.pointerEvents = 'none';
            } else {
                distanceSliderContainer.style.opacity = '1';
                distanceSliderContainer.style.pointerEvents = 'auto';
            }
        }
    };
    
    const savedSearchInView = localStorage.getItem(PDR_SEARCH_IN_VIEW_KEY) === 'true';
    searchInViewCheckbox.checked = savedSearchInView;
    searchInViewCheckbox.addEventListener('change', () => {
        localStorage.setItem(PDR_SEARCH_IN_VIEW_KEY, searchInViewCheckbox.checked);
        updateControlsState();
    });
    
    updateControlsState();

    const operatorInput = document.getElementById('operator-filter-input');
    const clearOperatorButton = document.getElementById('clear-operator-filter');
    
    const toggleClearButtonVisibility = () => {
        clearOperatorButton.style.display = operatorInput.value.trim() ? 'block' : 'none';
    };

    operatorInput.addEventListener('input', toggleClearButtonVisibility);
    clearOperatorButton.addEventListener('click', () => {
        operatorInput.value = '';
        toggleClearButtonVisibility();
        operatorInput.focus();
    });
    toggleClearButtonVisibility();

    // --- MODIFICADO: Se pasan los valores guardados a setupSlider ---
    const setupSlider = (idPrefix, minVal, maxVal, defaultMin, defaultMax, unit, isRange = true) => {
        const thumbMax = document.getElementById(`${idPrefix}-thumb` + (isRange ? '-max' : ''));
        if (!thumbMax) return () => ({ min: 0, max: 0 });
        const container = thumbMax.parentElement;
        const range = document.getElementById(`${idPrefix}-slider-range`);
        const label = document.getElementById(`${idPrefix}-range-label`);
        const thumbMin = isRange ? document.getElementById(`${idPrefix}-thumb-min`) : null;
        // Usa los valores guardados como `currentMin` y `currentMax`
        let currentMin = defaultMin; 
        let currentMax = defaultMax;

        const updateVisuals = () => {
            const minPercent = isRange ? ((currentMin - minVal) / (maxVal - minVal)) * 100 : 0;
            const maxPercent = ((currentMax - minVal) / (maxVal - minVal)) * 100;
            
            if (isRange && thumbMin) thumbMin.style.left = `${minPercent}%`;
            thumbMax.style.left = `${maxPercent}%`;
            range.style.left = `${minPercent}%`;
            range.style.width = `${maxPercent - minPercent}%`;
            
            if(isRange){
                label.textContent = `Potencia: ${Math.round(currentMin)} ${unit} - ${Math.round(currentMax)} ${unit}`;
            } else {
                label.textContent = `${hasRoute ? 'Distancia Máxima a la Ruta' : 'Radio de Búsqueda'}: ${Math.round(currentMax)} ${unit}`;
            }
        };

        const onDrag = (e, thumb) => {
            const rect = container.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let percent = ((clientX - rect.left) / rect.width) * 100;
            percent = Math.max(0, Math.min(100, percent));
            
            let value = minVal + (percent / 100) * (maxVal - minVal);
            
            if (isRange && thumb === thumbMin) {
                currentMin = Math.min(value, currentMax);
            } else {
                currentMax = isRange ? Math.max(value, currentMin) : value;
            }
            updateVisuals();
        };

        const thumbsToSetup = isRange ? [thumbMin, thumbMax] : [thumbMax];
        thumbsToSetup.forEach(thumb => {
            const startDrag = (e) => {
                const moveHandler = (moveEvent) => onDrag(moveEvent, thumb);
                const endDrag = () => {
                    document.removeEventListener('mousemove', moveHandler);
                    document.removeEventListener('mouseup', endDrag);
                    document.removeEventListener('touchmove', moveHandler);
                    document.removeEventListener('touchend', endDrag);
                };
                document.addEventListener('mousemove', moveHandler);
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchmove', moveHandler);
                document.addEventListener('touchend', endDrag);
            };
            thumb.addEventListener('mousedown', startDrag);
            thumb.addEventListener('touchstart', startDrag);
        });
        
        updateVisuals();
        return () => ({ min: isRange ? currentMin : minVal, max: currentMax });
    };

    // Pasa los valores guardados al inicializar los sliders
    const getPowerValues = setupSlider('power', 7, 2000, savedMinPower, savedMaxPower, 'kW', true);
    const getDistanceValues = hasRoute ? setupSlider('distance', 0, 50, 0, savedDistance, 'km', false) : () => ({});
    const getRadiusValues = !hasRoute ? setupSlider('radius', 1, 100, 1, savedRadius, 'km', false) : () => ({});
    // --- FIN MODIFICACIÓN ---

    const acceptButton = document.getElementById('accept-filters-btn');
    acceptButton.addEventListener('click', () => {
        const operatorFilterValue = document.getElementById('operator-filter-input').value;
        localStorage.setItem('boardinggate_operator_filter', operatorFilterValue);

        const powerFilters = getPowerValues();
        // --- INICIO: Guardar valores de los sliders al aceptar ---
        localStorage.setItem(PDR_MIN_POWER_KEY, Math.round(powerFilters.min));
        localStorage.setItem(PDR_MAX_POWER_KEY, Math.round(powerFilters.max));
        // --- FIN: Guardar valores ---

        let searchConfig;
        if (hasRoute) {
            const distanceFilters = getDistanceValues();
            // --- INICIO: Guardar valor de distancia ---
            localStorage.setItem(PDR_DISTANCE_KEY, Math.round(distanceFilters.max));
            // --- FIN: Guardar valor ---
            searchConfig = { type: 'route', distanceFilters };
        } else {
            const radiusFilters = getRadiusValues();
            // --- INICIO: Guardar valor de radio ---
            localStorage.setItem(PDR_RADIUS_KEY, Math.round(radiusFilters.max));
            // --- FIN: Guardar valor ---
            searchConfig = { type: 'radius', radiusKm: radiusFilters.max, center: navigationMapInstance.getCenter() };
        }
        
        if (navigationFollowUser) {
            const locateMeButton = document.getElementById('locate-me-on-reminders-map');
            if (locateMeButton) {
                handleLocateMeClick(locateMeButton);
                showToast('Seguimiento pausado por 1 minuto para explorar el mapa.', 'info', 4000);
                if (window.followMeReactivationTimer) {
                    clearTimeout(window.followMeReactivationTimer);
                }
                window.followMeReactivationTimer = setTimeout(() => {
                    if (!navigationFollowUser) {
                        handleLocateMeClick(locateMeButton);
                        showToast('Seguimiento automático reactivado.', 'info');
                    }
                    window.followMeReactivationTimer = null;
                }, 60000);
            }
        }

        modalOverlay.remove();
        findChargingPointsOnRoute(powerFilters, searchConfig);
    });

    addModalAutoCloseTimer(modalOverlay, acceptButton, 'pdrs-filter-modal', 20000);
}



    


    

// ===================================================================
// NOMBRE: findChargingPointsOnRoute
// RESUMEN: Busca PDRs de OCM y gestiona el estado de la búsqueda.
// ===================================================================
async function findChargingPointsOnRoute(powerFilters, searchConfig) {
    const pdrButton = document.getElementById('pdrs-ruta-button');
    if (pdrButton) pdrButton.classList.remove('pdr-search-highlight');

    clearChargingPoints();
    lastPdrSearchResults = []; // Limpiamos resultados anteriores
    
    showToast("Buscando puntos de recarga...", "info", 0, false, "pdrs-search");

    const PDR_SEARCH_IN_VIEW_KEY = 'boardinggate_pdrSearchInView';
    const hasRoute = searchConfig.type === 'route';
    const searchInCurrentView = !hasRoute && (localStorage.getItem(PDR_SEARCH_IN_VIEW_KEY) === 'true');
    
    let apiUrl;

    if (searchInCurrentView) {
        const bounds = navigationMapInstance.getBounds();
        if (!bounds.isValid()) {
            showToast("No se pudo determinar el área del mapa visible.", "error");
            const existingToast = document.getElementById("pdrs-search");
            if (existingToast) existingToast.remove();
            return;
        }
        apiUrl = `https://api.openchargemap.io/v3/poi/?output=json&key=${OCM_API_KEY}&countrycode=ES&boundingbox=(${bounds.getNorthWest().lat},${bounds.getNorthWest().lng}),(${bounds.getSouthEast().lat},${bounds.getSouthEast().lng})&maxresults=1500&compact=false&verbose=true`;
        showToast("Buscando en la vista actual del mapa...", "info", 2000);

    } else if (hasRoute) {
        const allWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal);
        let routePointsForBounds = [];
        if (allWaypoints.length > 0) {
            routePointsForBounds = allWaypoints.map(wp => L.latLng(wp.lat, wp.lng));
        }
        
        if (routePointsForBounds.length < 1) {
             const mapBounds = navigationMapInstance.getBounds();
             if (mapBounds.isValid()) {
                routePointsForBounds.push(mapBounds.getNorthWest(), mapBounds.getSouthEast());
            } else {
                 showToast("No se pudo determinar el área de la ruta.", "error");
                 return;
            }
        }
        const bounds = L.latLngBounds(routePointsForBounds).pad(0.2);
        apiUrl = `https://api.openchargemap.io/v3/poi/?output=json&key=${OCM_API_KEY}&countrycode=ES&boundingbox=(${bounds.getNorthWest().lat},${bounds.getNorthWest().lng}),(${bounds.getSouthEast().lat},${bounds.getSouthEast().lng})&maxresults=1500&compact=false&verbose=true`;
    
    } else if (searchConfig.type === 'radius') {
        apiUrl = `https://api.openchargemap.io/v3/poi/?output=json&key=${OCM_API_KEY}&countrycode=ES&latitude=${searchConfig.center.lat}&longitude=${searchConfig.center.lng}&distance=${searchConfig.radiusKm}&distanceunit=km&maxresults=1000&compact=false&verbose=true`;
    
    } else {
        showToast("Tipo de búsqueda no válido.", "error");
        pdrSearchState = 'initial'; // Resetear estado en error
        return;
    }
    
    try {
        const response = await fetch(apiUrl);
        if (!response.ok) throw new Error(`Error de red de OCM: ${response.statusText}`);
        const data = await response.json();
        if (!data || !Array.isArray(data)) throw new Error("Respuesta de OCM no válida.");

        window.lastOcmApiResponse = data;

        const operatorFilterText = (document.getElementById('operator-filter-input')?.value || localStorage.getItem('boardinggate_operator_filter') || '').toLowerCase().trim();
        const operatorFilterWords = operatorFilterText ? operatorFilterText.split(/\s+/).filter(w => w) : [];
        
        const routeLineForDistanceCheck = (searchConfig.type === 'route' && navigationRouteLayer) ? turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat])) : null;
        
        let filteredPoints = [];

        data.forEach(point => {
            const formattedPoint = formatOCMPoint(point);
            if (!formattedPoint) return;
            const power = parseFloat(formattedPoint.power);
            if (isNaN(power) || power < powerFilters.min || power > powerFilters.max) return;

            if (operatorFilterWords.length > 0) {
                const pointOperator = (formattedPoint.operator || '').toLowerCase();
                const pointAddress = (formattedPoint.address || '').toLowerCase();
                const operatorMatch = operatorFilterWords.some(word => 
                    pointOperator.includes(word) || pointAddress.includes(word)
                );
                if (!operatorMatch) return;
            }

            if (hasRoute && routeLineForDistanceCheck) {
                const pointTurf = turf.point([formattedPoint.lon, formattedPoint.lat]);
                const distanceKm = turf.pointToLineDistance(pointTurf, routeLineForDistanceCheck, { units: 'kilometers' });
                if (distanceKm <= searchConfig.distanceFilters.max) {
                    filteredPoints.push(formattedPoint);
                }
            } else { 
                filteredPoints.push(formattedPoint);
            }
        });
        
        lastPdrSearchResults = [...filteredPoints]; // Guardamos los resultados completos
        currentChargingPointsOnRoute = [...filteredPoints]; // Mostramos todos inicialmente

        const cheapestBySegment = {
            '#5e5e5e': { price: Infinity, point: null },
            '#007863': { price: Infinity, point: null },
            'rgb(30, 144, 255)': { price: Infinity, point: null },
            '#de2e03': { price: Infinity, point: null }
        };

        const parsePrice = (priceString) => {
            if (priceString && typeof priceString === 'string') {
                const priceMatch = priceString.match(/(\d[\d,.]*)/);
                if (priceMatch && priceMatch[1]) {
                    const priceNum = parseFloat(priceMatch[1].replace(',', '.'));
                    if (!isNaN(priceNum) && priceNum > 0 && priceNum < 10) {
                        return priceNum;
                    }
                }
            }
            return Infinity;
        };

        currentChargingPointsOnRoute.forEach(point => {
            point.isCheapest = false;
            const power = parseFloat(point.power);
            const segmentColor = getChargingPointColorByPower(power);
            const price = parsePrice(point.price);
            
            if (cheapestBySegment[segmentColor] && price < cheapestBySegment[segmentColor].price) {
                cheapestBySegment[segmentColor].price = price;
                cheapestBySegment[segmentColor].point = point;
            }
        });

        for (const color in cheapestBySegment) {
            const cheapest = cheapestBySegment[color];
            if (cheapest.point) {
                cheapest.point.isCheapest = true;
            }
        }

        const existingToast = document.getElementById("pdrs-search");
        if (existingToast) existingToast.remove();
        showToast(`${currentChargingPointsOnRoute.length} PDRs encontrados.`, "success");
        displayChargingPointsOnMap();

        pdrSearchState = 'results_shown'; // Actualizamos el estado tras una búsqueda exitosa

    } catch (error) {
        const existingToast = document.getElementById("pdrs-search");
        if (existingToast) existingToast.remove();
        showToast(`Error al buscar PDRs: ${error.message}`, "error");
        pdrSearchState = 'initial'; // Resetear estado en error
    }
}




    

 







// ===================================================================
// NOMBRE: updateNavigationProgressDisplay (VERSIÓN FINAL)
// RESUMEN: Actualiza la barra de progreso, gestionando el estado "Stop" desde la planificación.
// ===================================================================
function updateNavigationProgressDisplay(route, carDistanceAlongTheRoute = 0) {
    const progressBarContainer = document.getElementById('navigation-bottom-progress-bar');
    if (!progressBarContainer) return;

    if (!route || typeof route.distance !== 'number' || typeof route.duration !== 'number' || navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
        return;
    }

    const overallProgressFill = document.getElementById('route-overall-progress');
    const overallProgressContainer = document.getElementById('route-overall-progress-container');
    const routeProgressTextEl = document.getElementById('route-progress-text');
    const routeProgressIconEl = document.getElementById('route-progress-icon');
    const nextStageDistEl = document.getElementById('next-stage-distance');
    const nextStageTimeEl = document.getElementById('next-stage-time');
    const nextStageEtaEl = document.getElementById('next-stage-eta');
    const nextStageDeviationEl = document.getElementById('next-stage-eta-deviation');
    const finalDestDistEl = document.getElementById('final-destination-distance');
    const finalDestTimeEl = document.getElementById('final-destination-time');
    const finalDestEtaEl = document.getElementById('final-destination-eta');
    const finalDestDeviationEl = document.getElementById('final-destination-eta-deviation');
    const nextStageInfoDiv = document.getElementById('next-stage-info');
    const finalDestInfoDiv = document.getElementById('final-destination-info');
    const etaInfoContainer = document.getElementById('navigation-eta-info');

    const totalJourneyDistanceForBar = (accumulatedDistanceBeforeCurrentSegment || 0) + route.distance;
    const currentJourneyDistanceForBar = (accumulatedDistanceBeforeCurrentSegment || 0) + carDistanceAlongTheRoute;
    const progressPercent = totalJourneyDistanceForBar > 0 ? (currentJourneyDistanceForBar / totalJourneyDistanceForBar) * 100 : 0;
    
    overallProgressFill.style.width = `${Math.min(100, progressPercent)}%`;

    if (routeProgressIconEl) {
        if (progressPercent > 0 && progressPercent < 100) {
            routeProgressIconEl.style.display = 'block';
        } else {
            routeProgressIconEl.style.display = 'none';
        }
    }

    if (routeProgressTextEl) {
        let kmRecorridosTexto = "-- km";
        let timeInfoString = ""; 
        
        // --- LÓGICA DE VISUALIZACIÓN DE TIEMPO REESTRUCTURADA ---
        if (navigationCurrentRouteData) { // Condición principal: hay una ruta planificada
            
            // Caso 1: Navegación activa y el viaje "real" ya ha comenzado.
            if (isNavigating && navigationStartTimeForStats) {
                kmRecorridosTexto = `${(totalDistanceTravelledForStats / 1000).toFixed(1)} km`;
                const startTimeFormatted = `${navigationStartTimeForStats.getHours().toString().padStart(2, '0')}:${navigationStartTimeForStats.getMinutes().toString().padStart(2, '0')}`;
                const nowForTravelTime = new Date();
                const durationMs = nowForTravelTime - navigationStartTimeForStats;
                const totalTravelMinutes = Math.floor(durationMs / (1000 * 60));
                const travelHours = Math.floor(totalTravelMinutes / 60);
                const travelMinutes = totalTravelMinutes % 60;
                const travelTimeFormatted = `${String(travelHours).padStart(2, '0')}:${String(travelMinutes).padStart(2, '0')}`;
                timeInfoString = ` (${startTimeFormatted} • ${travelTimeFormatted})`;
            
            // Caso 2: Ruta planificada, pero o no se ha iniciado la navegación, o se ha iniciado pero aún no nos hemos movido 50m.
            } else { 
                kmRecorridosTexto = "0.0 km";
                timeInfoString = ` (Stop)`;
            }
        
        // Caso 3: No hay ninguna ruta planificada.
        } else { 
            kmRecorridosTexto = "-- km";
            timeInfoString = " (--:-- • --:--)";
        }
        // --- FIN DE LA REESTRUCTURACIÓN ---

        routeProgressTextEl.innerHTML = `${kmRecorridosTexto}${timeInfoString}`;
    }

    const remainingDistanceTotal = Math.max(0, route.distance - carDistanceAlongTheRoute);
    const remainingDurationTotal = route.distance > 0 ? route.duration * (remainingDistanceTotal / route.distance) : 0;

    finalDestDistEl.textContent = `${(remainingDistanceTotal / 1000).toFixed(1)} km`;
    const finalDestTotalMinutes = Math.round(remainingDurationTotal / 60);
    const finalDestHours = Math.floor(finalDestTotalMinutes / 60);
    const finalDestMinutes = finalDestTotalMinutes % 60;
    finalDestTimeEl.textContent = `${String(finalDestHours).padStart(2, '0')}:${String(finalDestMinutes).padStart(2, '0')}`;
    const currentFinalEta = new Date(Date.now() + remainingDurationTotal * 1000);
    finalDestEtaEl.textContent = currentFinalEta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    
    // Solo mostramos la desviación si el viaje "real" ha comenzado
    if (tripInitialOverallEtaTime && isNavigating && navigationStartTimeForStats) {
        const finalDeviationMs = currentFinalEta.getTime() - tripInitialOverallEtaTime.getTime();
        finalDestDeviationEl.innerHTML = formatDeviation(finalDeviationMs);
    } else {
        finalDestDeviationEl.innerHTML = "";
    }

    let currentLegIndexForNextStageDisplay = currentLegIndexNav;
    let cumulativeDistanceToStartOfCurrentLegOSRM = 0;
    if (route.legs) {
        for (let i = 0; i < currentLegIndexNav; i++) {
            if (route.legs[i] && typeof route.legs[i].distance === 'number') {
                cumulativeDistanceToStartOfCurrentLegOSRM += route.legs[i].distance;
            }
        }
    }

    const isMultiStageRoute = route.legs && route.legs.length > 1;
    if (isMultiStageRoute && currentLegIndexForNextStageDisplay < route.legs.length) {
        etaInfoContainer.classList.remove('single-destination');
        finalDestInfoDiv.classList.remove('single-destination-layout');
        nextStageInfoDiv.style.display = 'block';
        const totalEtapas = route.legs.length;
        const etapaActualUsuario = currentLegIndexNav + 1;
        const strongTagNextStage = nextStageInfoDiv.querySelector('strong');
        const waypointsInRoute = navigationWaypoints.filter(wp => !wp.isInternal && !wp.visited);
        const stageDestinationWaypoint = waypointsInRoute[1];
        let stageLabel = `Etapa ${etapaActualUsuario} de ${totalEtapas}`;
        if (stageDestinationWaypoint && stageDestinationWaypoint.address) {
             const addressParts = stageDestinationWaypoint.address.split(',');
             const shortAddress = addressParts[0];
             stageLabel += `: ${shortAddress}`;
        }
        if (strongTagNextStage) {
            strongTagNextStage.innerHTML = stageLabel;
        }

        const distanceIntoCurrentLegDisplay = Math.max(0, carDistanceAlongTheRoute - cumulativeDistanceToStartOfCurrentLegOSRM);
        const legForDisplay = route.legs[currentLegIndexForNextStageDisplay];
        const remainingDistanceThisLegDisplay = Math.max(0, (legForDisplay.distance || 0) - distanceIntoCurrentLegDisplay);
        const remainingDurationThisLegDisplay = (legForDisplay.distance > 0 && typeof legForDisplay.duration === 'number') ? legForDisplay.duration * (remainingDistanceThisLegDisplay / legForDisplay.distance) : 0;
        
        nextStageDistEl.textContent = `${(remainingDistanceThisLegDisplay / 1000).toFixed(1)} km`;
        const nextStageTotalMinutes = Math.round(remainingDurationThisLegDisplay / 60);
        const nextStageHours = Math.floor(nextStageTotalMinutes / 60);
        const nextStageMinutes = nextStageTotalMinutes % 60;
        nextStageTimeEl.textContent = `${String(nextStageHours).padStart(2, '0')}:${String(nextStageMinutes).padStart(2, '0')}`;
        
        const currentNextStageEta = new Date(Date.now() + remainingDurationThisLegDisplay * 1000);
        nextStageEtaEl.textContent = currentNextStageEta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

        // Solo mostramos la desviación si el viaje "real" ha comenzado
        if (currentStageInitialExpectedEtaTime && isNavigating && navigationStartTimeForStats) {
           const deviationStageMs = currentNextStageEta.getTime() - currentStageInitialExpectedEtaTime.getTime();
           nextStageDeviationEl.innerHTML = formatDeviation(accumulatedDeviationMs + deviationStageMs);
        } else {
           nextStageDeviationEl.innerHTML = "";
        }
    } else {
        etaInfoContainer.classList.add('single-destination');
        finalDestInfoDiv.classList.add('single-destination-layout');
        nextStageInfoDiv.style.display = 'none';
        if(nextStageDeviationEl) nextStageDeviationEl.innerHTML = "";
    }

    overallProgressContainer.querySelectorAll('.waypoint-dot-on-progress-bar, .radar-marker-on-progress-bar, .task-marker-on-progress-bar').forEach(dot => dot.remove());

    if (navigationWaypoints.length > 2 && totalJourneyDistanceForBar > 0 && route.legs) {
        let distanceLegOsrm = 0;
        for (let i = 0; i < route.legs.length - 1; i++) { 
            if (route.legs[i] && typeof route.legs[i].distance === 'number') {
                distanceLegOsrm += route.legs[i].distance; 
                const totalDistanceToWaypoint = (accumulatedDistanceBeforeCurrentSegment || 0) + distanceLegOsrm;
                const percent = (totalDistanceToWaypoint / totalJourneyDistanceForBar) * 100;

                if (percent < 100 && percent > 0) { 
                    const dot = document.createElement('div');
                    dot.className = 'waypoint-dot-on-progress-bar';
                    dot.style.left = `calc(${percent}% - 7px)`;
                    const stageIndex = navigationWaypoints.filter(wp => wp && !wp.isInternal).findIndex(wp => wp.type === 'intermediate' && parseInt(wp.label) === i + 1);
                    if(stageIndex !== -1) dot.title = `Etapa ${navigationWaypoints.filter(wp => wp && !wp.isInternal)[stageIndex].label}`;
                    overallProgressContainer.appendChild(dot);
                }
            }
        }
    }

    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresRutaCheckbox && radaresRutaCheckbox.checked && radaresEnRutaActual.length > 0 && totalJourneyDistanceForBar > 0) {
        radaresEnRutaActual.forEach(radar => {
            if (radar.distanceOnRoute !== undefined) {
                const totalDistanceToRadar = (accumulatedDistanceBeforeCurrentSegment || 0) + radar.distanceOnRoute;
                if(totalDistanceToRadar <= totalJourneyDistanceForBar) {
                    const percent = (totalDistanceToRadar / totalJourneyDistanceForBar) * 100;
                     if (percent >= 0 && percent <= 100) {
                        const radarMarker = document.createElement('div');
                        radarMarker.className = 'radar-marker-on-progress-bar';
                        radarMarker.style.left = `${percent}%`;
                        radarMarker.title = radar.text.replace(/<b>|<\/b>/gi, '');
                        overallProgressContainer.appendChild(radarMarker);
                    }
                }
            }
        });
    }

    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasRutaCheckbox && tareasRutaCheckbox.checked && tareasEnRutaActual.length > 0 && totalJourneyDistanceForBar > 0) {
        tareasEnRutaActual.forEach(tarea => {
            if (tarea.distanceOnRoute !== undefined) {
                const totalDistanceToTask = (accumulatedDistanceBeforeCurrentSegment || 0) + tarea.distanceOnRoute;
                if(totalDistanceToTask <= totalJourneyDistanceForBar) {
                    const percent = (totalDistanceToTask / totalJourneyDistanceForBar) * 100;
                    if (percent >= 0 && percent <= 100) {
                        const taskMarker = document.createElement('div');
                        taskMarker.className = 'task-marker-on-progress-bar';
                        taskMarker.style.left = `${percent}%`;
                        taskMarker.title = tarea.text.replace(/<b>|<\/b>/gi, '');
                        overallProgressContainer.appendChild(taskMarker);
                    }
                }
            }
        });
    }

    if (isNavigating && !isArrivalSequenceStarted && remainingDistanceTotal < WAYPOINT_VISITED_THRESHOLD_METERS) {
        isArrivalSequenceStarted = true;
        setTimeout(() => {
            if (!document.getElementById('arrival-stats-modal') || document.getElementById('arrival-stats-modal').classList.contains('hidden')) {
                showArrivalStatsModal();
            }
        }, 7000);
        let countdown = 7;
        const toastId = `arrival-toast-${Date.now()}`;
        showToast(`FIN DEL VIAJE (${countdown})`, 'success', 10000, false, toastId);
        const countdownInterval = setInterval(() => {
            countdown--;
            const arrivalToast = document.getElementById(toastId);
            if (arrivalToast) {
                const span = arrivalToast.querySelector('span');
                if (span) span.innerHTML = `FIN DEL VIAJE (${countdown})`;
            }
            if (countdown <= 0) {
                clearInterval(countdownInterval);
            }
        }, 1000);
    } else if (isNavigating) {
        const destinationWp = navigationWaypoints[navigationWaypoints.length - 1];
        if (destinationWp && destinationWp.address) {
            const mapOverlay = document.getElementById('map-info-overlay');
            if (mapOverlay && !mapOverlay.textContent.startsWith("HA LLEGADO AL ")) {
                 showDestinationName();
            }
        }
    }
}    



    



    
    
    
    
    
    
    
    
    
    
    
    // ===================================================================
    // NOMBRE: handleProgressiveManeuverZoom
    // RESUMEN: Calcula el nivel de zoom progresivo para una maniobra, acercando y alejando suavemente.
    // ===================================================================
    function handleProgressiveManeuverZoom(currentStep, distanceToManeuver) {
        if (!isNavigating || !navigationMapInstance || !currentStep) {
            if (isZoomedForManeuver) isZoomedForManeuver = false;
            return null;
        }
        const maxZoomForMap = navigationMapInstance.getMaxZoom() || 19;
        const currentMapLayerName = (localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "satélite + calles").toLowerCase();
        const isSatelliteWithLabels = currentMapLayerName.includes("satélite + calles");
        const MANEUVER_PEAK_ZOOM_LEVEL = isSatelliteWithLabels 
            ? Math.min(17.5, maxZoomForMap) 
            : Math.min(18.5, maxZoomForMap);
        const currentStepIdentifier = `${currentLegIndexNav}_${currentStepIndexNav}`;
        if (lastProcessedStepIdentifier !== null && lastProcessedStepIdentifier !== currentStepIdentifier) {
            if (progressiveZoomState === 'zooming-in' || progressiveZoomState === 'holding') {
                progressiveZoomState = 'zooming-out';
            }
        }
        lastProcessedStepIdentifier = currentStepIdentifier;
        const distanceIntoCurrentStep = currentStep.distance - distanceToManeuver;
        let targetZoom = null;
        switch (progressiveZoomState) {
            case 'zooming-out':
                isZoomedForManeuver = true;
                if (distanceIntoCurrentStep > PROGRESSIVE_ZOOM_EXIT_END_DISTANCE || mapPreviousZoomLevelForProgressive === null) {
                    targetZoom = mapPreviousZoomLevelForProgressive;
                    progressiveZoomState = 'none';
                    mapPreviousZoomLevelForProgressive = null;
                    isZoomedForManeuver = false;
                } else if (distanceIntoCurrentStep >= PROGRESSIVE_ZOOM_EXIT_START_DISTANCE) {
                    const progress = (distanceIntoCurrentStep - PROGRESSIVE_ZOOM_EXIT_START_DISTANCE) / (PROGRESSIVE_ZOOM_EXIT_END_DISTANCE - PROGRESSIVE_ZOOM_EXIT_START_DISTANCE);
                    targetZoom = MANEUVER_PEAK_ZOOM_LEVEL - (MANEUVER_PEAK_ZOOM_LEVEL - mapPreviousZoomLevelForProgressive) * Math.min(1, progress);
                } else {
                    targetZoom = MANEUVER_PEAK_ZOOM_LEVEL;
                }
                break;
            default:
                if (distanceToManeuver <= PROGRESSIVE_ZOOM_START_DISTANCE && distanceToManeuver > PROGRESSIVE_ZOOM_PEAK_DISTANCE) {
                    if (progressiveZoomState !== 'zooming-in' && progressiveZoomState !== 'holding') {
                        mapPreviousZoomLevelForProgressive = navigationMapInstance.getZoom();
                    }
                    progressiveZoomState = 'zooming-in';
                    const progress = (PROGRESSIVE_ZOOM_START_DISTANCE - distanceToManeuver) / (PROGRESSIVE_ZOOM_START_DISTANCE - PROGRESSIVE_ZOOM_PEAK_DISTANCE);
                    targetZoom = mapPreviousZoomLevelForProgressive + (MANEUVER_PEAK_ZOOM_LEVEL - mapPreviousZoomLevelForProgressive) * progress;
                    isZoomedForManeuver = true;
                } else if (distanceToManeuver <= PROGRESSIVE_ZOOM_PEAK_DISTANCE) {
                    if (progressiveZoomState !== 'holding' && mapPreviousZoomLevelForProgressive === null) {
                        mapPreviousZoomLevelForProgressive = navigationMapInstance.getZoom();
                    }
                    progressiveZoomState = 'holding';
                    targetZoom = MANEUVER_PEAK_ZOOM_LEVEL;
                    isZoomedForManeuver = true;
                } else {
                    if (progressiveZoomState !== 'none' && mapPreviousZoomLevelForProgressive !== null) {
                        targetZoom = mapPreviousZoomLevelForProgressive;
                    }
                    progressiveZoomState = 'none';
                    mapPreviousZoomLevelForProgressive = null;
                    isZoomedForManeuver = false;
                }
                break;
        }
        return targetZoom;
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    





    

    
    
    


// ===================================================================
// NOMBRE: showReorderStagesModal
// RESUMEN: Muestra el modal para reordenar las etapas de la ruta.
// ===================================================================
function showReorderStagesModal() {
    if (isNavigating) {
        showToast("No se puede reordenar etapas mientras se navega.", "warning");
        return;
    }
    const actualWaypointsForReorder = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    if (actualWaypointsForReorder.length < 2) {
        showToast("Se necesitan al menos 2 puntos para reordenar", "warning");
        return;
    }
    const modal = document.getElementById('reorder-stages-modal');
    if (!modal) {
        showToast("Error interno: No se pudo mostrar el modal de reordenamiento.", "error");
        return;
    }
    const listElement = modal.querySelector('#sortable-stages-list');
    if (!listElement) {
         showToast("Error interno: No se pudo encontrar la lista de etapas", "error");
         return;
    }
    listElement.innerHTML = '';
    actualWaypointsForReorder.forEach(async (wp) => {
        const li = document.createElement('li');
        li.dataset.id = wp.id;
        const dragHandle = document.createElement('span');
        dragHandle.className = 'drag-handle';
        dragHandle.innerHTML = '<img src="MOVER.PNG" alt="Mover etapa">';
        dragHandle.title = 'Arrastrar para reordenar';
        dragHandle.draggable = true;
        const badge = document.createElement('span');
        badge.className = 'stage-label-badge';
        badge.textContent = wp.label;
        const nameSpan = document.createElement('span');
        nameSpan.className = 'stage-name-text';
        nameSpan.textContent = wp.address || `Cargando dirección para (${wp.lat.toFixed(3)}, ${wp.lng.toFixed(3)})...`;
        if (!wp.address) {
             wp.address = await getAddressForWaypoint(wp.lat, wp.lng);
             nameSpan.textContent = wp.address;
        }
        const deleteButton = document.createElement('span');
        deleteButton.className = 'delete-stage-button';
        deleteButton.innerHTML = '×';
        deleteButton.title = 'Eliminar esta etapa';
        deleteButton.addEventListener('click', (e) => {
            e.stopPropagation();
            const listItem = e.target.closest('li');
            if (listItem) {
                const waypointIdToDelete = parseInt(listItem.dataset.id);
                const waypointIndexInNavigationArray = navigationWaypoints.findIndex(wp => wp && wp.id === waypointIdToDelete);
                if (waypointIndexInNavigationArray !== -1) {
                    const waypointObjectToDelete = navigationWaypoints[waypointIndexInNavigationArray];
                    if (waypointObjectToDelete.marker && navigationMapInstance) {
                        try {
                            navigationMapInstance.removeLayer(waypointObjectToDelete.marker);
                        } catch (mapError) {
                        }
                        waypointObjectToDelete.marker = null;
                    }
                }
                listItem.remove();
                navigationWaypoints = navigationWaypoints.filter(wayP => wayP.id !== waypointIdToDelete);
                updateWaypointTypesAndLabels();
                const remainingListItems = listElement.querySelectorAll('li');
                const currentActualWaypointsAfterDelete = navigationWaypoints.filter(w => w && !w.isInternal && !w.isRecalculatedStart);
                remainingListItems.forEach((remainingLi) => {
                     const currentWpIdInModal = parseInt(remainingLi.dataset.id);
                     const correspondingWp = currentActualWaypointsAfterDelete.find(w => w.id === currentWpIdInModal);
                     if(correspondingWp){
                        const badgeSpan = remainingLi.querySelector('.stage-label-badge');
                        if(badgeSpan) badgeSpan.textContent = correspondingWp.label;
                     }
                });
                const confirmBtn = modal.querySelector('#confirm-reorder-stages');
                const canConfirm = remainingListItems.length >= 2;
                if (confirmBtn) confirmBtn.disabled = !canConfirm;
                if (!canConfirm && remainingListItems.length > 0) {
                    showToast("Se necesitan al menos 2 puntos para una ruta.", "warning", 3000);
                } else if (remainingListItems.length === 0){
                    showToast("No quedan etapas. La ruta se eliminará al confirmar.", "info", 3000);
                }
            }
        });
        li.appendChild(dragHandle);
        li.appendChild(badge);
        li.appendChild(nameSpan);
        li.appendChild(deleteButton);
        listElement.appendChild(li);
    });
    modal.classList.remove('hidden');
    const confirmButton = modal.querySelector('#confirm-reorder-stages');
    const cancelButton = modal.querySelector('#cancel-reorder-stages');
    if (confirmButton) confirmButton.disabled = listElement.querySelectorAll('li').length < 2;
    const newConfirmButton = confirmButton.cloneNode(true);
    confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
    const newCancelButton = cancelButton.cloneNode(true);
    cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);
    const closeReorderModal = () => {
        clearModalAutoCloseTimer(modal, newConfirmButton, 'reorder-stages-modal');
        modal.classList.add('hidden');
        listElement.querySelectorAll('.drag-handle').forEach(handle => {
            handle.removeEventListener('dragstart', handleDragStartReorder);
            handle.removeEventListener('touchstart', handleStageTouchStart);
        });
        listElement.removeEventListener('dragend', handleDragEndReorder);
        listElement.removeEventListener('dragover', handleDragOverReorder);
        listElement.removeEventListener('touchmove', handleStageTouchMove);
        listElement.removeEventListener('touchend', handleStageTouchEnd);
        listElement.removeEventListener('touchcancel', handleStageTouchEnd);
        document.body.style.overflow = '';
    };
    newConfirmButton.addEventListener('click', async () => {
        const orderedLiElements = Array.from(listElement.children);
        const finalWaypointIds = orderedLiElements.map(li => parseInt(li.dataset.id));
        clearAllWaypointMarkersFromMap();
        if (finalWaypointIds.length < 2) {
            showToast("Se necesitan al menos 2 etapas para formar una ruta. Ruta actual eliminada.", "warning");
            navigationWaypoints = [];
            if (navigationRouteLayer && navigationMapInstance) {
                navigationMapInstance.removeLayer(navigationRouteLayer);
                navigationRouteLayer = null;
            }
            if (completedRouteSegmentsLayer && navigationMapInstance) completedRouteSegmentsLayer.clearLayers();
            navigationCurrentRouteData = null;
            updateStartNavigationButtonState();
            updateNavigationButtonColor();
            hideNavigationUI();
            hideMapInfoOverlay();
            eliminarRadaresDeRuta();
            actualizarContadorRadares(0);
             eliminarTareasDeBarraProgreso();
            actualizarContadorTareas(0);
            const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
            if (radaresCheckbox) {
                 localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckbox.checked));
            }
            const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
            if (tareasCheckbox) {
                localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckbox.checked));
            }
            closeReorderModal();
            return;
        }
        try {
            const newWaypointsOrdered = [];
            finalWaypointIds.forEach(id => {
                const foundWp = navigationWaypoints.find(wp => wp && wp.id === id);
                if(foundWp) newWaypointsOrdered.push(foundWp);
            });
            navigationWaypoints = newWaypointsOrdered;
            updateWaypointTypesAndLabels();
            renderWaypointMarkers();
            await recalculateAndDrawRoute();
            const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
            if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                toggleRadaresRuta(true);
            }
            const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
            if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                toggleTareasRuta(true);
            }
            showToast("Etapas reordenadas y ruta recalculada", "success");
        } catch (error) {
            showToast("Error recalculando ruta tras reordenar: " + error.message, "error");
        } finally {
             closeReorderModal();
             updateStartNavigationButtonState();
             updateNavigationButtonColor();
        }
    });
    newCancelButton.addEventListener('click', () => {
        showToast("Reordenación cancelada. Los marcadores eliminados se restaurarán al recalcular/cargar ruta.", "info");
        closeReorderModal();
        if (navigationWaypoints.length >= 2) {
            renderWaypointMarkers();
            recalculateAndDrawRoute().then(() => {
                const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
                if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                    toggleRadaresRuta(true);
                }
                 const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
                if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                    toggleTareasRuta(true);
                }
            });
        } else {
            clearAllWaypointMarkersFromMap();
            navigationWaypoints = [];
             if (navigationRouteLayer && navigationMapInstance) {
                navigationMapInstance.removeLayer(navigationRouteLayer);
                navigationRouteLayer = null;
            }
            if (completedRouteSegmentsLayer && navigationMapInstance) completedRouteSegmentsLayer.clearLayers();
            navigationCurrentRouteData = null;
            hideNavigationUI();
            hideMapInfoOverlay();
            eliminarRadaresDeRuta();
            actualizarContadorRadares(0);
            eliminarTareasDeBarraProgreso();
            actualizarContadorTareas(0);
            const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
            if (radaresCheckbox) {
                localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckbox.checked));
            }
             const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
            if (tareasCheckbox) {
                localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckbox.checked));
            }
        }
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
    });
    addModalAutoCloseTimer(modal, newConfirmButton, 'reorder-stages-modal', 60000);
    listElement.querySelectorAll('.drag-handle').forEach(handle => {
        handle.addEventListener('dragstart', handleDragStartReorder);
        handle.addEventListener('touchstart', handleStageTouchStart, { passive: false });
    });
    listElement.addEventListener('dragend', handleDragEndReorder);
    listElement.addEventListener('dragover', handleDragOverReorder);
    listElement.addEventListener('touchmove', handleStageTouchMove, { passive: false });
    listElement.addEventListener('touchend', handleStageTouchEnd);
    listElement.addEventListener('touchcancel', handleStageTouchEnd);
}

// ===================================================================
// NOMBRE: handleDragStartReorder
// RESUMEN: Maneja el inicio de un arrastre en la lista de reordenación.
// ===================================================================
function handleDragStartReorder(e) {
    if (e.target.closest('.drag-handle')) { 
        draggedStageLi = e.target.closest('li');
        if (!draggedStageLi) return;
        setTimeout(() => {
            if (draggedStageLi) draggedStageLi.classList.add('dragging');
        }, 0);
        if (e.dataTransfer) {
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedStageLi.dataset.id);
        }
    } else {
        e.preventDefault();
    }
}

// ===================================================================
// NOMBRE: handleStageTouchStart
// RESUMEN: Maneja el inicio de un toque en una etapa para reordenar (táctil).
// ===================================================================
function handleStageTouchStart(e) {
    if (e.touches.length === 1 && e.target.closest('.drag-handle')) {
        draggedStageLi = e.target.closest('li');
        if (!draggedStageLi) return;
        const touch = e.touches[0];
        stageTouchStartX = touch.clientX;
        stageTouchStartY = touch.clientY;
        clearTimeout(stageScrollTimeout);
        stageScrollTimeout = setTimeout(() => {
            if (draggedStageLi) {
                draggedStageLi.classList.add('dragging');
                document.body.style.overflow = 'hidden';
            }
        }, 150);
    }
}

// ===================================================================
// NOMBRE: handleStageTouchMove
// RESUMEN: Maneja el movimiento de un toque en una etapa para reordenar (táctil).
// ===================================================================
function handleStageTouchMove(e) {
    if (!draggedStageLi || e.touches.length !== 1) return;
    e.preventDefault();
    clearTimeout(stageScrollTimeout);
    if (!draggedStageLi.classList.contains('dragging')) {
        draggedStageLi.classList.add('dragging');
         document.body.style.overflow = 'hidden';
    }
    const touch = e.touches[0];
    const listElement = document.getElementById('sortable-stages-list');
    if (!listElement) return;
    const afterElement = getDragAfterElement(listElement, touch.clientY);
     if (afterElement == null) {
        listElement.appendChild(draggedStageLi);
    } else {
        listElement.insertBefore(draggedStageLi, afterElement);
    }
}

// ===================================================================
// NOMBRE: handleStageTouchEnd
// RESUMEN: Maneja el final de un toque en una etapa para reordenar (táctil).
// ===================================================================
function handleStageTouchEnd(e) {
    clearTimeout(stageScrollTimeout);
    if (draggedStageLi) {
        draggedStageLi.classList.remove('dragging');
        draggedStageLi = null;
    }
    document.body.style.overflow = '';
}





    





    


 //-----------------------




// ===================================================================
// NOMBRE: clearAllLocalData
// RESUMEN: Borra todos los datos guardados en el almacenamiento local del navegador.
// ===================================================================
function clearAllLocalData() {
    if (confirm('¡ATENCIÓN! Esto borrará TODOS los datos locales (marcadores personalizados, recordatorios, configuración de usuario, PIN, etc.). Esta acción NO SE PUEDE DESHACER. ¿Estás seguro?')) {
        if (confirm('DE VERDAD, ¿ESTÁS COMPLETAMENTE SEGURO? SE BORRARÁ TODO.')) {
            managedKeys.forEach(key => localStorage.removeItem(key));
            localStorage.removeItem('personalizationHelpShown');
            localStorage.removeItem('gridFilterValue');
            showToast('Todos los datos locales borrados. Recargando...', 'success');
            setTimeout(() => location.reload(), 1500);
        } else {
            showToast('Borrado cancelado', 'info');
        }
    } else {
        showToast('Borrado cancelado', 'info');
    }
}













// ===================================================================
// NOMBRE: importRadars
// RESUMEN: Importa radares y otros POIs desde archivos KML externos.
// ===================================================================
async function importRadars() {
    const latFilterValue = document.getElementById('radar-filter-lat').value.trim();
    const lonFilterValue = document.getElementById('radar-filter-lon').value.trim();
    const keywordsFilterRaw = document.getElementById('radar-filter-keywords').value.trim().toUpperCase();
    const keywordsFilter = keywordsFilterRaw ? keywordsFilterRaw.split(/\s+/).filter(k => k) : [];
    const importExtra = document.getElementById('import-extra-radars-checkbox').checked;
    const progressBar = document.getElementById('radar-import-progress-bar');
    const statusMessage = document.getElementById('radar-import-status');
    const progressContainer = document.getElementById('radar-import-progress-container');
    progressContainer.style.display = 'block';
    progressBar.value = 0;
    statusMessage.textContent = 'Iniciando importación...';
    statusMessage.style.color = '';
    try {
        let filesToProcess = await fetchKMLFilesList(KML_FILES_LIST_STANDARD);
        if (importExtra) {
            const extraFiles = await fetchKMLFilesList(KML_FILES_LIST_EXTRA);
            filesToProcess = filesToProcess.concat(extraFiles.filter(f => !filesToProcess.includes(f)));
        }
        if (filesToProcess.length === 0) {
            statusMessage.textContent = 'No se encontraron listas de archivos KML para procesar.';
            progressBar.value = 100;
            showToast('No hay archivos KML en las listas.', 'warning');
            setTimeout(() => { progressContainer.style.display = 'none'; }, 3000);
            return;
        }
        statusMessage.textContent = `Encontrados ${filesToProcess.length} archivos KML. Procesando...`;
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        let newRadarsCount = 0;
        let totalFilesProcessed = 0;
        for (const kmlFileName of filesToProcess) {
            try {
                statusMessage.textContent = `Procesando ${kmlFileName}... (${totalFilesProcessed + 1}/${filesToProcess.length})`;
                const placemarks = await fetchAndParseKML(KML_BASE_PATH + kmlFileName);
                placemarks.forEach(placemark => {
                    const name = placemark.name.toUpperCase();
                    const coords = placemark.coordinates;
                    const matchesKeywords = keywordsFilter.length === 0 || keywordsFilter.some(kw => name.includes(kw));
                    if (coords && matchesKeywords) {
                        const [lonStr, latStr] = coords.split(',');
                        const lon = parseFloat(lonStr);
                        const lat = parseFloat(latStr);
                        if (isNaN(lat) || isNaN(lon)) return;
                        const matchesLat = parseCoordinateFilter(latFilterValue, lat);
                        const matchesLon = parseCoordinateFilter(lonFilterValue, lon);
                        if (matchesLat && matchesLon) {
                            const existingRadar = reminders.find(r =>
                                r.isLocationEnabled &&
                                r.locationCoordinates &&
                                Math.abs(r.locationCoordinates.latitude - lat) < COORD_EPSILON &&
                                Math.abs(r.locationCoordinates.longitude - lon) < COORD_EPSILON &&
                                (r.text.toUpperCase().includes("RADAR:") || r.excludeFromList)
                            );
                            if (!existingRadar) {
                                const now = new Date();
                                const newRadar = {
                                    id: Date.now() + Math.random() + newRadarsCount,
                                    text: `<b>RADAR: ${placemark.name}</b>`,
                                    type: 'simple',
                                    time: '00:01',
                                    date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                                    createdAt: now.toISOString(),
                                    managedByUser: false,
                                    isLocationEnabled: true,
                                    locationCoordinates: { latitude: lat, longitude: lon },
                                    radiusMeters: 400,
                                    excludeFromList: true
                                };
                                reminders.push(newRadar);
                                newRadarsCount++;
                            }
                        }
                    }
                });
            } catch (fileError) {
                statusMessage.textContent = `Error en ${kmlFileName}: ${fileError.message}. Continuando...`;
                statusMessage.style.color = 'orange';
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
            totalFilesProcessed++;
            progressBar.value = (totalFilesProcessed / filesToProcess.length) * 100;
        }
        localStorage.setItem('reminders', JSON.stringify(reminders));
        statusMessage.textContent = `Importación completa. ${newRadarsCount} nuevos radares/POIs añadidos.`;
        statusMessage.style.color = '#28a745';
        showToast(`${newRadarsCount} nuevos radares/POIs añadidos.`, 'success');
        updateReminderCount();
        updateButtonStyles();
        checkReminders();
    } catch (error) {
        statusMessage.textContent = `Error general: ${error.message}`;
        statusMessage.style.color = 'red';
        showToast('Error durante la importación.', 'error');
    } finally {
         setTimeout(() => {
            progressContainer.style.display = 'none';
            statusMessage.style.color = '';
        }, 5000);
    }
}





// ===================================================================
// NOMBRE: fetchKMLFilesList
// RESUMEN: Obtiene la lista de archivos KML a procesar desde una URL.
// ===================================================================
async function fetchKMLFilesList(listUrl) {
    try {
        const response = await fetch(listUrl, { cache: 'no-cache' });
        if (!response.ok) throw new Error(`Error HTTP ${response.status} obteniendo lista KML: ${listUrl}`);
        const text = await response.text();
        return text.split('\n').map(f => f.trim()).filter(f => f.length > 0 && f.toLowerCase().endsWith('.kml'));
    } catch (error) {
        showToast(`Error cargando lista ${listUrl.split('/').pop()}`, 'error');
        return [];
    }
}





// ===================================================================
// NOMBRE: fetchAndParseKML
// RESUMEN: Descarga y decodifica un archivo KML.
// ===================================================================
async function fetchAndParseKML(kmlFileUrl) {
    try {
        const response = await fetch(kmlFileUrl, { cache: 'no-cache' });
        if (!response.ok) throw new Error(`Error HTTP ${response.status} obteniendo KML: ${kmlFileUrl}`);
        const buffer = await response.arrayBuffer();
        const decoder = new TextDecoder('iso-8859-1');
        const kmlText = decoder.decode(buffer);
        return parseKML(kmlText);
    } catch (error) {
        throw error;
    }
}





// ===================================================================
// NOMBRE: parseKML
// RESUMEN: Parsea el texto de un archivo KML para extraer los Placemarks.
// ===================================================================
function parseKML(kmlText) {
    const placemarks = [];
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(kmlText, "application/xml");
    const parserErrorNode = xmlDoc.querySelector("parsererror");
    if (parserErrorNode) {
        let errorMessage = "Error de parseo XML desconocido.";
        if (parserErrorNode.textContent) {
            const match = parserErrorNode.textContent.match(/error on line \d+ at column \d+: ([^\n]+)/);
            if (match && match[1]) {
                errorMessage = match[1];
            } else {
                errorMessage = parserErrorNode.textContent.split('\n')[0] || parserErrorNode.textContent;
            }
        } else if (parserErrorNode.innerText) {
             errorMessage = parserErrorNode.innerText.split('\n')[0] || parserErrorNode.innerText;
        }
        throw new Error("KML parsing error: " + errorMessage);
    }
    const KML_NS_GOOGLE = "http://earth.google.com/kml/2.0";
    const KML_NS_OGC = "http://www.opengis.net/kml/2.2";
    let placemarkNodes = xmlDoc.getElementsByTagNameNS(KML_NS_GOOGLE, 'Placemark');
    if (placemarkNodes.length === 0) {
        placemarkNodes = xmlDoc.getElementsByTagNameNS(KML_NS_OGC, 'Placemark');
    }
     if (placemarkNodes.length === 0) {
        placemarkNodes = xmlDoc.getElementsByTagName('Placemark');
    }
    for (let i = 0; i < placemarkNodes.length; i++) {
        const node = placemarkNodes[i];
        let nameNode, coordinatesNode;
        nameNode = node.getElementsByTagNameNS(KML_NS_GOOGLE, 'name')[0] || node.getElementsByTagNameNS(KML_NS_OGC, 'name')[0] || node.getElementsByTagName('name')[0];
        coordinatesNode = node.getElementsByTagNameNS(KML_NS_GOOGLE, 'coordinates')[0] || node.getElementsByTagNameNS(KML_NS_OGC, 'coordinates')[0] || node.getElementsByTagName('coordinates')[0];
        if (nameNode && coordinatesNode) {
            const name = nameNode.textContent.trim();
            const coordinatesRaw = coordinatesNode.textContent.trim();
            const coordPartsMatch = coordinatesRaw.match(/^(-?\d+\.?\d*)[,\s]+(-?\d+\.?\d*)/);
            if (name && coordPartsMatch && coordPartsMatch.length >= 3) {
                const lonStr = coordPartsMatch[1];
                const latStr = coordPartsMatch[2];
                const coordinates = `${lonStr},${latStr}`;
                const lon = parseFloat(lonStr);
                const lat = parseFloat(latStr);
                if (!isNaN(lon) && !isNaN(lat)) {
                    if (name.startsWith("Radares BBS www.laradiobbs.net") && lon === 0 && lat === 0) {
                        continue;
                    }
                    placemarks.push({ name, coordinates });
                }
            }
        }
    }
    return placemarks;
}





// ===================================================================
// NOMBRE: deleteFilteredRadars
// RESUMEN: Borra los recordatorios de tipo RADAR/POI según los filtros especificados.
// ===================================================================
async function deleteFilteredRadars() {
    const latFilterValue = document.getElementById('radar-filter-lat').value.trim();
    const lonFilterValue = document.getElementById('radar-filter-lon').value.trim();
    const keywordsFilterRaw = document.getElementById('radar-filter-keywords').value.trim().toUpperCase();
    const keywordsFilter = keywordsFilterRaw ? keywordsFilterRaw.split(/\s+/).filter(k => k) : [];
    const statusMessage = document.getElementById('radar-import-status');
    const progressContainer = document.getElementById('radar-import-progress-container');
    const noFiltersProvided = !latFilterValue && !lonFilterValue && keywordsFilter.length === 0;
    let confirmationMessage = "";
    if (noFiltersProvided) {
        confirmationMessage = "¿Estás seguro de que quieres borrar TODOS los recordatorios tipo RADAR/POI (ya que no has especificado ningún filtro)? Esta acción no se puede deshacer.";
    } else {
        confirmationMessage = "¿Estás seguro de que quieres borrar los recordatorios tipo RADAR/POI que coincidan con los filtros actuales? Esta acción no se puede deshacer.";
    }
    if (!confirm(confirmationMessage)) {
        showToast("Borrado cancelado", "info");
        return;
    }
    progressContainer.style.display = 'block';
    const progressBar = document.getElementById('radar-import-progress-bar');
    if(progressBar) progressBar.style.display = 'none';
    statusMessage.textContent = 'Borrando recordatorios...';
    statusMessage.style.color = '';
    try {
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        let originalLength = reminders.length;
        reminders = reminders.filter(r => {
            const isRadarType = r.isLocationEnabled && (r.text.toUpperCase().includes("RADAR:") || r.excludeFromList);
            if (!isRadarType) return true;
            if (noFiltersProvided) {
                return false;
            }
            let matchesKeywords = true;
            if (keywordsFilter.length > 0) {
                matchesKeywords = keywordsFilter.some(kw => r.text.toUpperCase().includes(kw));
            }
            let matchesLat = true;
            if (latFilterValue) {
                if (r.locationCoordinates) {
                    matchesLat = parseCoordinateFilter(latFilterValue, r.locationCoordinates.latitude);
                } else {
                    matchesLat = false;
                }
            }
            let matchesLon = true;
            if (lonFilterValue) {
                if (r.locationCoordinates) {
                    matchesLon = parseCoordinateFilter(lonFilterValue, r.locationCoordinates.longitude);
                } else {
                    matchesLon = false;
                }
            }
            return !(matchesKeywords && matchesLat && matchesLon);
        });
        localStorage.setItem('reminders', JSON.stringify(reminders));
        const numDeleted = originalLength - reminders.length;
        statusMessage.textContent = `Borrado completo. ${numDeleted} recordatorios eliminados.`;
        statusMessage.style.color = '#28a745';
        showToast(`${numDeleted} recordatorios eliminados`, 'success');
        updateReminderCount();
        updateButtonStyles();
        checkReminders();
    } catch (error) {
        statusMessage.textContent = `Error: ${error.message}`;
        statusMessage.style.color = 'red';
        showToast('Error durante el borrado', 'error');
    } finally {
        setTimeout(() => {
            progressContainer.style.display = 'none';
            if(progressBar) progressBar.style.display = 'block';
            statusMessage.style.color = '';
        }, 3000);
    }
}





// ===================================================================
// NOMBRE: toggleRadaresRuta
// RESUMEN: Activa/desactiva la visualización de radares en la ruta actual.
// ===================================================================
async function toggleRadaresRuta(activo) {
    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(activo));
    if (actualWaypoints.length < 2) {
        if (activo) {
            showToast("Ruta inválida o inexistente. No se pueden buscar radares.", "warning");
        }
        eliminarRadaresDeRuta();
        actualizarContadorRadares(0);
        return;
    }
    eliminarRadaresDeRuta();
    radaresEnRutaActual = [];
    if (activo && navigationMapInstance && navigationRouteLayer) {
        try {
            const routeLineString = turf.lineString(navigationRouteLayer.getLatLngs().map(latlng => [latlng.lng, latlng.lat]));
            let filesToProcess = await fetchKMLFilesList(KML_FILES_LIST_STANDARD);
            const extraFiles = await fetchKMLFilesList(KML_FILES_LIST_EXTRA);
            filesToProcess = filesToProcess.concat(extraFiles.filter(f => !filesToProcess.includes(f)));
            for (const kmlFileName of filesToProcess) {
                const placemarks = await fetchAndParseKML(KML_BASE_PATH + kmlFileName);
                placemarks.forEach(placemark => {
                    const coords = placemark.coordinates;
                    if (coords) {
                        const [lonStr, latStr] = coords.split(',');
                        const lon = parseFloat(lonStr);
                        const lat = parseFloat(latStr);
                        if (isNaN(lat) || isNaN(lon)) return;
                        const radarPoint = turf.point([lon, lat]);
                        const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, radarPoint, { units: 'meters' });
                        if (nearestPointOnRoute && nearestPointOnRoute.properties.dist !== undefined && nearestPointOnRoute.properties.dist <= RUTA_RADAR_PROXIMITY_THRESHOLD) {
                            const existingMapObject = reminderMapObjects.find(obj =>
                                obj.isFromRuta &&
                                Math.abs(obj.marker.getLatLng().lat - lat) < COORD_EPSILON &&
                                Math.abs(obj.marker.getLatLng().lng - lon) < COORD_EPSILON
                            );
                            if (!existingMapObject) {
                                const now = new Date();
                                const radarData = {
                                    id: Date.now() + Math.random() + radaresEnRutaActual.length,
                                    text: `<b>RADAR RUTA: ${placemark.name}</b>`,
                                    type: 'simple', time: '00:00',
                                    date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                                    createdAt: now.toISOString(),
                                    managedByUser: false, isLocationEnabled: true,
                                    locationCoordinates: { latitude: lat, longitude: lon },
                                    radiusMeters: 350, excludeFromList: true,
                                    isFromRuta: true,
                                    distanceOnRoute: nearestPointOnRoute.properties.location
                                };
                                const mapObject = plotSingleReminderOnMap(radarData, navigationMapInstance);
                                if (mapObject) {
                                    reminderMapObjects.push(mapObject);
                                    radaresEnRutaActual.push(radarData);
                                }
                            }
                        }
                    }
                });
            }
            if (radaresEnRutaActual.length === 0 && activo) {
            }
        } catch (error) {
        }
    }
    actualizarContadorRadares(radaresEnRutaActual.length);
    if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
    if (radaresRutaCheckbox) {
        radaresRutaCheckbox.checked = activo;
    }
}





// ===================================================================
// NOMBRE: toggleTareasRuta
// RESUMEN: Activa/desactiva la visualización de tareas personales en la ruta.
// ===================================================================
async function toggleTareasRuta(activo) {
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(activo));
    if (actualWaypoints.length < 2) {
        if (activo) {
            showToast("Ruta inválida o inexistente. No se pueden buscar tareas en ruta.", "warning");
        }
        eliminarTareasDeBarraProgreso();
        actualizarContadorTareas(0);
        return;
    }
    eliminarTareasDeBarraProgreso();
    tareasEnRutaActual = [];
    if (activo && navigationMapInstance && navigationRouteLayer) {
        try {
            const routeLineString = turf.lineString(navigationRouteLayer.getLatLngs().map(latlng => [latlng.lng, latlng.lat]));
            const allReminders = JSON.parse(localStorage.getItem('reminders') || '[]');
            const locationReminders = allReminders.filter(r => r.isLocationEnabled && r.locationCoordinates);
            locationReminders.forEach(reminder => {
                const taskPoint = turf.point([reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]);
                const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, taskPoint, { units: 'meters' });
                const radius = reminder.radiusMeters || DEFAULT_LOCATION_RADIUS;
                if (nearestPointOnRoute && nearestPointOnRoute.properties.dist !== undefined && nearestPointOnRoute.properties.dist <= radius) {
                    tareasEnRutaActual.push({
                        ...reminder,
                        distanceOnRoute: nearestPointOnRoute.properties.location
                    });
                }
            });
        } catch (error) {
             showToast("Error al procesar tareas en ruta: " + error.message, "error");
        }
    }
    actualizarContadorTareas(tareasEnRutaActual.length);
    if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
    if (tareasRutaCheckbox) {
        tareasRutaCheckbox.checked = activo;
    }
}





// ===================================================================
// NOMBRE: eliminarRadaresDeRuta
// RESUMEN: Elimina del mapa los radares que se habían añadido dinámicamente a la ruta.
// ===================================================================
function eliminarRadaresDeRuta() {
    reminderMapObjects = reminderMapObjects.filter(obj => {
        if (obj.isFromRuta) {
            if (obj.marker && navigationMapInstance && navigationMapInstance.hasLayer(obj.marker)) obj.marker.remove();
            if (obj.circle && navigationMapInstance && navigationMapInstance.hasLayer(obj.circle)) obj.circle.remove();
            return false;
        }
        return true;
    });
    radaresEnRutaActual = [];
    actualizarContadorRadares(0);
    if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
         updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
}





// ===================================================================
// NOMBRE: eliminarTareasDeBarraProgreso
// RESUMEN: Limpia las tareas de la barra de progreso de la ruta.
// ===================================================================
function eliminarTareasDeBarraProgreso() {
    tareasEnRutaActual = [];
    actualizarContadorTareas(0);
    if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
}








    // ===================================================================
// NOMBRE: showSimulationModal
// RESUMEN: Muestra un modal con la lista de maniobras de la ruta.
// ===================================================================
async function showSimulationModal() {
    const canSimulate = (navigationWaypoints.filter(wp => !wp.isInternal && !wp.isRecalculatedStart).length >= 2 && navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) ||
                    (isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]);
    if (!canSimulate) {
        showToast("Se necesitan al menos 2 puntos y una ruta calculada para mostrar las intersecciones.", "warning");
        return;
    }
    const route = navigationCurrentRouteData.routes[0];
    if (!route || !route.legs || route.legs.length === 0) {
        showToast("Datos de ruta incompletos para mostrar intersecciones.", "error");
        return;
    }
    closeOtherModals('simulation-modal');
    
    // Mostramos un modal con placeholders primero
    let modal = document.getElementById('simulation-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'simulation-modal';
        document.body.appendChild(modal);
    }
    modal.innerHTML = `
        <h2 style="font-size: 1.3rem; font-weight: bold; text-align: center; margin-bottom: 1rem; color: #333;">Maniobras de la Ruta</h2>
        <div class="modal-top-buttons" style="justify-content: flex-start; margin-bottom: 1rem;">
            <button id="close-simulation-modal" style="flex: 0 0 auto; width: auto; min-width: unset;">Salir <span class="button-countdown-timer"></span></button>
        </div>
        <div id="simulation-content-area"><p>Cargando maniobras...</p></div>
    `;
    modal.classList.remove('hidden');

    const closeButton = modal.querySelector('#close-simulation-modal');
    const closeSimulationModalHandler = () => {
        if (simulationModalTimer) clearTimeout(simulationModalTimer);
        clearModalAutoCloseTimer(modal, closeButton, 'simulation-modal');
        modal.classList.add('hidden');
        hideIntersectionPreviewMap();
    };
    closeButton.addEventListener('click', closeSimulationModalHandler);
    addModalAutoCloseTimer(modal, closeButton, 'simulation-modal', 50000);

    // Ahora generamos el contenido asíncronamente
    const carDist = lastCarDistanceAlongRouteForNavLogic;
    let simulationList = document.createElement('ul');
    let stepsShown = 0;
    let currentStageNumber = 1;
    let displayedStageHeader = false;
    let firstVisibleLegIndex = isNavigating ? currentLegIndexNav : 0;
    let firstVisibleStepIndex = isNavigating ? currentStepIndexNav : 0;
    
    for (let legIdx = firstVisibleLegIndex; legIdx < route.legs.length; legIdx++) {
        const leg = route.legs[legIdx];
        if (!leg || !leg.steps) continue;
        let startStepThisLegLoop = (legIdx === firstVisibleLegIndex) ? firstVisibleStepIndex : 0;
        if (!displayedStageHeader || legIdx > firstVisibleLegIndex) {
             const stageAddress = navigationWaypoints[legIdx + 1] ? navigationWaypoints[legIdx+1].address : "";
             const stageDistance = leg.distance ? (leg.distance / 1000).toFixed(1) + " km" : "Dist. desc.";
             const headerLi = document.createElement('li');
             headerLi.style.cssText = "background-color: #e0e0e0; font-weight: bold; padding: 5px; margin-top:5px;";
             headerLi.textContent = `ETAPA ${currentStageNumber}: ${stageAddress} (Total ${stageDistance})`;
             simulationList.appendChild(headerLi);
             currentStageNumber++;
             displayedStageHeader = true;
             if (legIdx > firstVisibleLegIndex) displayedStageHeader = false;
        }
        for (let stepIdx = startStepThisLegLoop; stepIdx < leg.steps.length; stepIdx++) {
            const step = leg.steps[stepIdx];
            if (!step || !step.maneuver) continue;
            const distanceToEndOfThisStep = calculateDistanceToEndOfStep(route, legIdx, stepIdx);
            const distanceToThisStepManeuver = Math.max(0, distanceToEndOfThisStep - carDist);
            if (distanceToEndOfThisStep > carDist || (legIdx === route.legs.length - 1 && stepIdx === leg.steps.length - 1 && distanceToThisStepManeuver <= 10) ) {
                const maneuver = step.maneuver;
                const type = maneuver.type || '';
                
                const maneuverText = getManeuverInstructionText(maneuver);
                let streetNameText = step.name || '';
                if (type === 'arrive' || type === 'depart' || type === 'end of road' || type === 'roundabout' || type === 'rotary') {
                    streetNameText = '';
                } else if (streetNameText.toLowerCase() === 'continúa' && maneuverText.toLowerCase() !== 'continúa') {
                    streetNameText = '';
                }
                
                let distanceFormatted = (distanceToThisStepManeuver >= 1000) ? `${(distanceToThisStepManeuver / 1000).toFixed(1)} km` : `${Math.round(distanceToThisStepManeuver)} m`;
                
                const li = document.createElement('li');
                li.dataset.legIndex = legIdx;
                li.dataset.stepIndex = stepIdx;
                li.style.cursor = 'pointer';
                
                const iconContainer = document.createElement('span');
                iconContainer.className = 'turn-icon-sim';
                
                const textContainer = document.createElement('span');
                textContainer.innerHTML = `${maneuverText}${streetNameText ? ` <strong>${streetNameText}</strong>` : ''} (${distanceFormatted})`;
                
                li.appendChild(iconContainer);
                li.appendChild(textContainer);
                simulationList.appendChild(li);

                // --- INICIO DE LA CORRECCIÓN ---
                // Se reemplaza la llamada a la función inexistente por la lógica correcta.
                const iconFilename = getManeuverIconFilename(maneuver);
                const iconUrl = `https://boardinggate.github.io/Tesla/${iconFilename}`;
                iconContainer.innerHTML = `<img src="${iconUrl}" alt="Maniobra" style="width:24px; height:24px; object-fit:contain;">`;
                // --- FIN DE LA CORRECCIÓN ---
                
                stepsShown++;
                if (stepsShown >= 15 && isNavigating) break;
            }
        }
        if (stepsShown >= 15 && isNavigating) break;
    }
    
    const contentArea = modal.querySelector('#simulation-content-area');
    if (stepsShown > 0) {
        contentArea.innerHTML = '';
        contentArea.appendChild(simulationList);
        contentArea.removeEventListener('click', handleSimulationItemClick);
        contentArea.addEventListener('click', handleSimulationItemClick);
    } else {
        contentArea.innerHTML = "<p>No hay más interacciones futuras en la ruta o estás muy cerca del final.</p>";
    }
}
    

    





// ===================================================================
// NOMBRE: showIntersectionPreviewMap (VERSIÓN CORREGIDA Y ROBUSTA)
// RESUMEN: Muestra un minimapa detallado de la intersección, asegurando su correcta inicialización.
// ===================================================================
function showIntersectionPreviewMap(step, route, isSimulationContextOrClick = false, timerDurationMs = null) {
    const previewWindow = document.getElementById('intersection-preview-map-window');
    const progressBarEl = document.getElementById('navigation-bottom-progress-bar');
    if (!previewWindow || !step || !step.geometry || !route || !navigationMapInstance) {
        hideIntersectionPreviewMap();
        return;
    }
    const DISTANCE_BEFORE_MANEUVER_METERS = 110;
    const DISTANCE_AFTER_MANEUVER_METERS = 90;
    const CAR_POSITION_BEFORE_MANEUVER_METERS = 25;
    if (!previewWindow.querySelector('#intersection-rotator')) {
        previewWindow.innerHTML = `
            <div id="intersection-rotator" style="width: 100%; height: 100%; transition: transform 0.3s ease-out;">
                <div id="intersection-preview-map-container" style="width: 100%; height: 100%;"></div>
            </div>
        `;
    }
    const rotatorDiv = previewWindow.querySelector('#intersection-rotator');
    const mapContainerEl = previewWindow.querySelector('#intersection-preview-map-container');
    const isProgressBarVisible = progressBarEl && progressBarEl.offsetParent !== null;

    if (isProgressBarVisible) {
        const progressBarRect = progressBarEl.getBoundingClientRect();
        previewWindow.style.width = `${progressBarRect.width}px`;
        previewWindow.style.top = `${progressBarRect.bottom + 5}px`;
        previewWindow.style.left = `${progressBarRect.left}px`;
        previewWindow.style.transform = 'none';
    } else if (isSimulationContextOrClick) {
        previewWindow.style.width = '90%';
        previewWindow.style.maxWidth = '500px';
        previewWindow.style.left = '50%';
        previewWindow.style.top = '50%';
        previewWindow.style.transform = 'translate(-50%, -50%)';
    } else {
        hideIntersectionPreviewMap();
        return;
    }

    previewWindow.classList.remove('hidden');
    previewWindow.dataset.source = isSimulationContextOrClick ? 'click' : 'auto';
    if (intersectionPreviewTimer) clearTimeout(intersectionPreviewTimer);

    try {
        // --- INICIO DE LA CORRECCIÓN CLAVE ---
        // Destruimos la instancia del mapa anterior si existe. Esto fuerza a Leaflet
        // a reinicializarse y medir correctamente el contenedor cada vez.
        if (intersectionPreviewMap) {
            try {
                intersectionPreviewMap.remove();
            } catch(e) {}
            intersectionPreviewMap = null;
        }
        // --- FIN DE LA CORRECCIÓN CLAVE ---

        // Ahora, siempre creamos una nueva instancia del mapa
        intersectionPreviewMap = L.map(mapContainerEl, {
            zoomControl: false, dragging: false, touchZoom: false, scrollWheelZoom: false,
            doubleClickZoom: false, boxZoom: false, keyboard: false, attributionControl: false
        });

        if (rotatorDiv) {
            rotatorDiv.style.transition = 'none';
            rotatorDiv.style.transform = 'rotate(0deg)';
        }

        const currentMapLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "Satélite + Calles";
        let tileLayerInstance;
        if (currentMapLayerName.toLowerCase().includes("satélite puro")) {
            tileLayerInstance = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' });
        } else if (currentMapLayerName.toLowerCase().includes("satélite + calles")) {
            const labelsPaneName = 'intersection_labels_pane_unique';
            tileLayerInstance = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' });
            if (!intersectionPreviewMap.getPane(labelsPaneName)) {
                intersectionPreviewMap.createPane(labelsPaneName);
                intersectionPreviewMap.getPane(labelsPaneName).style.zIndex = 650;
                intersectionPreviewMap.getPane(labelsPaneName).style.pointerEvents = 'none';
            }
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', { attribution: '© OSM © CARTO', pane: labelsPaneName }).addTo(intersectionPreviewMap);
        } else {
            tileLayerInstance = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap' });
        }
        tileLayerInstance.addTo(intersectionPreviewMap);

        const maneuverPoint = L.latLng(step.maneuver.location[1], step.maneuver.location[0]);
        const fullRouteLineString = turf.lineString(route.geometry.coordinates);
        const maneuverPointOnRoute = turf.nearestPointOnLine(fullRouteLineString, step.maneuver.location, { units: 'kilometers' });
        const maneuverDistanceKm = maneuverPointOnRoute.properties.location;
        const startSliceDistanceKm = Math.max(0, maneuverDistanceKm - (DISTANCE_BEFORE_MANEUVER_METERS / 1000));
        const endSliceDistanceKm = Math.min(turf.length(fullRouteLineString), maneuverDistanceKm + (DISTANCE_AFTER_MANEUVER_METERS / 1000));
        const startSlicePoint = turf.along(fullRouteLineString, startSliceDistanceKm);
        const endSlicePoint = turf.along(fullRouteLineString, endSliceDistanceKm);
        const routeSlice = turf.lineSlice(startSlicePoint, endSlicePoint, fullRouteLineString);
        const routeSegmentCoords = routeSlice.geometry.coordinates.map(c => [c[1], c[0]]);

        intersectionPreviewRouteLayer = L.polyline(routeSegmentCoords, { color: 'orange', weight: 10, opacity: 1 }).addTo(intersectionPreviewMap);
        intersectionPreviewManeuverMarker = L.circleMarker(maneuverPoint, { radius: 5, color: 'white', weight: 1, fillColor: 'blue', fillOpacity: 1, zIndexOffset: 1000 }).addTo(intersectionPreviewMap);
        
        const lineStringToPlaceCar = turf.lineString(routeSegmentCoords.map(c => [c[1], c[0]]));
        const distanceForCarOnSegment = Math.max(0, DISTANCE_BEFORE_MANEUVER_METERS - CAR_POSITION_BEFORE_MANEUVER_METERS);
        const carPositionPointTurf = turf.along(lineStringToPlaceCar, distanceForCarOnSegment, { units: 'meters' });
        const carPositionLatLng = L.latLng(carPositionPointTurf.geometry.coordinates[1], carPositionPointTurf.geometry.coordinates[0]);
        intersectionPreviewCarMarker = L.marker(carPositionLatLng, { icon: vehicleIconMiniMap, zIndexOffset: 1001 }).addTo(intersectionPreviewMap);

        const bounds = L.latLngBounds(routeSegmentCoords).pad(0.5);

        requestAnimationFrame(() => {
            if (intersectionPreviewMap && document.body.contains(mapContainerEl)) {
                intersectionPreviewMap.invalidateSize();
                
                const maneuverType = step.maneuver.type || '';
                const maneuverModifier = step.maneuver.modifier || '';
                const isShortManeuver = maneuverType.includes('roundabout') || maneuverType.includes('rotary') || maneuverModifier.includes('sharp') || maneuverModifier.includes('uturn');
                const mapMaxZoom = intersectionPreviewMap.getMaxZoom() || 19;
                let targetZoom;
                if (isShortManeuver) {
                    targetZoom = mapMaxZoom;
                } else {
                    const zoomThatFitsBounds = intersectionPreviewMap.getBoundsZoom(bounds);
                    targetZoom = Math.max(16, zoomThatFitsBounds - 0.5);
                }
                targetZoom = Math.min(targetZoom, mapMaxZoom);
                intersectionPreviewMap.fitBounds(bounds, { animate: false, paddingTopLeft: [0, 50], paddingBottomRight: [0, 50], maxZoom: targetZoom });
                
                requestAnimationFrame(() => {
                    let segmentBearing = 0;
                    const lookAheadPointTurf = turf.along(lineStringToPlaceCar, distanceForCarOnSegment + 5, { units: 'meters' });
                    if (lookAheadPointTurf) {
                        segmentBearing = turf.bearing(carPositionPointTurf, lookAheadPointTurf);
                        if (segmentBearing < 0) segmentBearing += 360;
                    } else {
                        segmentBearing = (navigationCurrentLocation && typeof navigationCurrentLocation.heading === 'number') ? navigationCurrentLocation.heading : currentMapBearing;
                    }
                    const shouldRotateMap = (segmentBearing > 135 && segmentBearing < 225);
                    const mapRotation = shouldRotateMap ? 180 : 0;
                    if (rotatorDiv) {
                        rotatorDiv.style.transition = 'transform 0.3s ease-out';
                        rotatorDiv.style.transform = `rotate(${mapRotation}deg)`;
                    }
                    const finalIconRotation = segmentBearing - 90;
                    if (intersectionPreviewCarMarker && intersectionPreviewCarMarker.getElement()) {
                        const carWrapperMini = intersectionPreviewCarMarker.getElement().querySelector('.vehicle-icon-minimap');
                        if (carWrapperMini) {
                            carWrapperMini.style.transform = `rotate(${finalIconRotation}deg)`;
                        }
                    }
                });
            }
        });

        if (timerDurationMs && timerDurationMs > 0) {
            intersectionPreviewTimer = setTimeout(hideIntersectionPreviewMap, timerDurationMs);
        }
    } catch (error) {
        console.error("Error al mostrar el mapa de intersección:", error);
        hideIntersectionPreviewMap();
    }
}













    
    
    







// ===================================================================
// NOMBRE: handleSimulationItemClick (VERSIÓN CORREGIDA)
// RESUMEN: Maneja el clic en un elemento de la lista de maniobras para mostrar el detalle del mapa.
// ===================================================================
function handleSimulationItemClick(event) {
    const listItem = event.target.closest('li[data-leg-index][data-step-index]');
    if (!listItem) {
        return;
    }
    if (!navigationCurrentRouteData || !navigationCurrentRouteData.routes || navigationCurrentRouteData.routes.length === 0) {
        showToast("No hay datos de ruta actuales para mostrar el detalle de la maniobra.", "warning", 3000);
        return;
    }
    const legIndex = parseInt(listItem.dataset.legIndex);
    const stepIndex = parseInt(listItem.dataset.stepIndex);
    const route = navigationCurrentRouteData.routes[0];
    if (route.legs && legIndex < route.legs.length && route.legs[legIndex].steps && stepIndex < route.legs[legIndex].steps.length) {
        const step = route.legs[legIndex].steps[stepIndex];
        // La llamada a la función corregida se encargará de todo.
        showIntersectionPreviewMap(step, route, true, 7000);
    } else {
        showToast("No se pudo encontrar la maniobra seleccionada en los datos de la ruta.", "error", 3000);
        hideIntersectionPreviewMap();
    }
}





    

    









// ===================================================================
// NOMBRE: showMapInfoOverlay
// RESUMEN: Muestra un mensaje de información sobre el mapa de navegación.
// ===================================================================
function showMapInfoOverlay(message, isError = false) {
    const overlay = document.getElementById('map-info-overlay');
    if (overlay) {
        let finalMessage = message;
        if (message.startsWith(" ")) {
            const destName = message.substring(" ".length).trim().replace(/<br>/gi, ' ');
            finalMessage = " " + (destName.length > 55 ? destName.substring(0, 52) + "..." : destName);
        } else if (message.startsWith("ETAPA ")) {
            const stageInfo = message.substring("ETAPA ".length).trim().replace(/<br>/gi, ' ');
            finalMessage = "ETAPA " + (stageInfo.length > 55 ? stageInfo.substring(0, 52) + "..." : stageInfo);
        } else if (message.startsWith("HA LLEGADO AL ")) {
            const destinationName = message.substring("HA LLEGADO AL : ".length).trim().replace(/<br>/gi, ' ');
            finalMessage = "HA LLEGADO A: " + (destinationName.length > 55 ? destinationName.substring(0, 52) + "..." : destinationName);
        }
        overlay.innerHTML = `<span>${finalMessage}</span>`;
        overlay.style.display = 'block';
        overlay.style.backgroundColor = isError ? 'rgba(220, 50, 50, 0.5)' : 'rgba(0,0,0,0.5)';
    }
}





// ===================================================================
// NOMBRE: hideMapInfoOverlay
// RESUMEN: Oculta el mensaje de información del mapa.
// ===================================================================
function hideMapInfoOverlay() {
    const overlay = document.getElementById('map-info-overlay');
    if (overlay) {
        overlay.textContent = '';
        overlay.style.display = 'none';
    }
}





// ===================================================================
// NOMBRE: showDestinationName
// RESUMEN: Muestra el nombre del destino o de la siguiente etapa en el overlay del mapa.
// ===================================================================
function showDestinationName() {
    if (!navigationWaypoints || navigationWaypoints.length === 0) {
        hideMapInfoOverlay();
        return;
    }
    let message = "";
    let nextUnvisitedStageWp = null;
    if (isNavigating) {
        const totalEtapas = navigationCurrentRouteData?.routes?.[0]?.legs?.length || 0;
        const etapaActualUsuario = currentLegIndexNav + 1;
        for(let i = currentLegIndexNav; i < navigationWaypoints.length; i++) {
            const waypointToCheck = navigationWaypoints[i];
            if (waypointToCheck && !waypointToCheck.isInternal && !waypointToCheck.visited && waypointToCheck.type !== 'S' && waypointToCheck.type !== 'S_Recalc') {
                nextUnvisitedStageWp = waypointToCheck;
                break;
            }
        }
         if (!nextUnvisitedStageWp && navigationWaypoints.length > 0) {
            const lastWaypoint = navigationWaypoints[navigationWaypoints.length -1];
            if (lastWaypoint.type === 'F' && !lastWaypoint.visited) {
                 nextUnvisitedStageWp = lastWaypoint;
            }
        }
        if (nextUnvisitedStageWp) {
            if (nextUnvisitedStageWp.type === 'F') {
                message = ` ${nextUnvisitedStageWp.address || ' Final'}`;
            } else if (nextUnvisitedStageWp.type === 'intermediate' && totalEtapas > 1) {
                message = `ETAPA ${etapaActualUsuario} de ${totalEtapas}: ${nextUnvisitedStageWp.address || `Etapa ${nextUnvisitedStageWp.label}`}`;
            } else {
                 message = ` ${nextUnvisitedStageWp.address || 'Siguiente Punto'}`;
            }
        } else {
            const finalDestination = navigationWaypoints[navigationWaypoints.length - 1];
            if (finalDestination && !finalDestination.isInternal) {
                 message = ` ${finalDestination.address || ' Final'}`;
            } else {
                 message = "RUTA NO DEFINIDA";
            }
        }
    } else {
        const finalDestination = navigationWaypoints[navigationWaypoints.length - 1];
        if (finalDestination && !finalDestination.isInternal) {
             message = ` ${finalDestination.address || ' Final'}`;
        } else {
             message = "RUTA NO DEFINIDA";
        }
    }
    showMapInfoOverlay(message);
}





// ===================================================================
// NOMBRE: openLocationsPreviewMap
// RESUMEN: Abre un mapa modal que muestra todos los recordatorios con ubicación.
// ===================================================================
function openLocationsPreviewMap() {
    closeOtherModals('locations-preview-modal');
     let modal = document.getElementById('locations-preview-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'locations-preview-modal';
        modal.innerHTML = `
            <h2 id="locations-preview-title">Ubicaciones con Recordatorios</h2>
            <div id="locations-preview-map-container" style="height: calc(100% - 100px); width: 100%;"></div>
            <div class="modal-top-buttons" style="justify-content: center; margin-top: 1rem;">
                <button id="close-locations-preview">Salir</button>
            </div>
        `;
        document.body.appendChild(modal);
    }
    modal.classList.remove('hidden');
    const mapContainer = modal.querySelector('#locations-preview-map-container');
    const closeButton = modal.querySelector('#close-locations-preview');
    const titleElement = modal.querySelector('#locations-preview-title');
    const closeHandler = () => {
        if (locationsPreviewMap) {
            try { locationsPreviewMap.remove(); } catch (e) {}
            locationsPreviewMap = null;
        }
        if (mapLayersControlLocationsPreview) {
            try {mapLayersControlLocationsPreview.remove();} catch(e){}
            mapLayersControlLocationsPreview = null;
        }
        clearModalAutoCloseTimer(modal, closeButton, 'locations-preview-modal');
        modal.classList.add('hidden');
    };
    const newCloseButton = closeButton.cloneNode(true);
    closeButton.parentNode.replaceChild(newCloseButton, closeButton);
    newCloseButton.addEventListener('click', closeHandler);
    newCloseButton.style.backgroundColor = '#4A5568';
    newCloseButton.style.color = 'white';
    newCloseButton.style.border = '1px solid #2D3748';
    newCloseButton.style.fontWeight = 'bold';
    newCloseButton.onmouseover = () => newCloseButton.style.backgroundColor = '#2D3748';
    newCloseButton.onmouseout = () => newCloseButton.style.backgroundColor = '#4A5568';
    addModalAutoCloseTimer(modal, newCloseButton, 'locations-preview-modal', 120000);
    if (locationsPreviewMap) {
        try { locationsPreviewMap.remove(); } catch (e) {}
        if(mapLayersControlLocationsPreview) { try {mapLayersControlLocationsPreview.remove();} catch(e){} mapLayersControlLocationsPreview = null;}
    }
    locationsPreviewMap = L.map(mapContainer, { zoomControl: true }).setView([40.416775, -3.703790], 6);
    const osmLayerLP = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© <a href="https://www.openstreetmap.org/copyright">OSM</a>' });
    const satelliteLayerLP = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' });
    const satelliteWithLabelsLP = L.layerGroup([
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' }),
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', { attribution: '© OSM © CARTO', pane: 'labels_locations_preview' })
    ]);
    if (!locationsPreviewMap.getPane('labels_locations_preview')) {
        locationsPreviewMap.createPane('labels_locations_preview');
        locationsPreviewMap.getPane('labels_locations_preview').style.zIndex = 650;
        locationsPreviewMap.getPane('labels_locations_preview').style.pointerEvents = 'none';
    }
    const baseMapsLP = { "Mapa Normal": osmLayerLP, "Satélite Puro": satelliteLayerLP, "Satélite + Calles": satelliteWithLabelsLP };
    const savedLayerNameLP = localStorage.getItem(ACTIVE_MAP_LAYER_KEY + '_locations_preview') || "Satélite + Calles";
    let initialLayerLP = baseMapsLP[savedLayerNameLP] || satelliteWithLabelsLP;
    initialLayerLP.addTo(locationsPreviewMap);
    mapLayersControlLocationsPreview = L.control.layers(baseMapsLP, null, {position: 'topright', collapsed: true}).addTo(locationsPreviewMap);
    locationsPreviewMap.on('baselayerchange', function(e) {
        localStorage.setItem(ACTIVE_MAP_LAYER_KEY + '_locations_preview', e.name);
    });
    const allReminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
    const locationsToPlot = allReminders.filter(r => {
        const hasLocation = r.isLocationEnabled && r.locationCoordinates?.latitude && r.locationCoordinates?.longitude;
        if (!hasLocation) return false;
        const isRadarText = r.text && r.text.toUpperCase().includes("RADAR:");
        if (showExcluded) {
            return true;
        } else {
            return !isRadarText;
        }
    });
    if (titleElement) {
        titleElement.textContent = `Ubicaciones con Recordatorios ${showExcluded ? '(incluyendo "RADAR")' : '(sin "RADAR")'}`;
    }
    const markers = [];
    locationsToPlot.forEach(reminder => {
        const latLng = [reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude];
         const isRadarTypeForIcon = reminder.text.toUpperCase().includes("RADAR:") || reminder.excludeFromList;
        const markerIconToUse = isRadarTypeForIcon ? smallRadarMarkerIcon : largeGreenLocationMarkerIcon;
        const isRadar = reminder.text.toUpperCase().includes("RADAR:");
        const circleColor = isRadar ? 'rgba(255, 165, 0, 0.2)' : 'blue';
        const circleFillColor = isRadar ? 'rgba(255, 165, 0, 0.2)' : '#ADD8E6';
        const circleFillOpacity = isRadar ? 0.2 : 0.05;
        const circleWeight = 1;
        const marker = L.marker(latLng, { icon: markerIconToUse })
            .addTo(locationsPreviewMap)
            .bindPopup(`<b>${reminder.text.replace(/<b>|<\/b>/gi,'')}</b><br>${reminder.time || ''} ${reminder.date ? formatDateDetailed(reminder.date) : ''}<br><button data-reminder-id="${reminder.id}" class="edit-reminder-from-preview-map" style="margin-top:5px;padding:3px 6px;background-color:#10B981;color:white;border:none;border-radius:3px;cursor:pointer;">Ver/Editar</button>`);
         L.circle(latLng, { radius: reminder.radiusMeters || DEFAULT_LOCATION_RADIUS, color: circleColor, fillColor: circleFillColor, weight: circleWeight, fillOpacity: circleFillOpacity }).addTo(locationsPreviewMap);
        marker.on('popupopen', () => {
            const editButton = marker.getPopup().getElement().querySelector('.edit-reminder-from-preview-map');
            if (editButton) {
                const newEditButton = editButton.cloneNode(true);
                editButton.parentNode.replaceChild(newEditButton, editButton);
                newEditButton.addEventListener('click', () => {
                    const id = parseInt(newEditButton.dataset.reminderId);
                    const remToEdit = allReminders.find(r => r.id === id);
                    if (remToEdit) {
                        closeHandler();
                        showReminderModal(remToEdit);
                    }
                });
            }
        });
        markers.push(marker);
    });
    if (markers.length > 0) {
        const group = new L.featureGroup(markers);
        locationsPreviewMap.fitBounds(group.getBounds().pad(0.2));
    } else {
        showToast(`No hay recordatorios con ubicación para mostrar según el filtro actual.`, "info");
    }
     requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            if(locationsPreviewMap) locationsPreviewMap.invalidateSize();
        });
    });
}





// ===================================================================
// NOMBRE: closeModalAndProceed (para desvíos)
// RESUMEN: Cierra el modal de desvío de ruta.
// ===================================================================
function closeModalAndProceed() {
    if (deviationModalTimerId) {
        clearInterval(deviationModalTimerId);
        deviationModalTimerId = null;
    }
    const modal = document.getElementById('deviation-modal');
    if (modal) {
        const anyButton = modal.querySelector('button');
        if (anyButton) {
            clearModalAutoCloseTimer(modal, anyButton, 'deviation-modal');
        }
        modal.classList.add('hidden');
    }
    isDeviationModalActive = false;
    deviationStartTime = 0;
}







// ===================================================================
// NOMBRE: handleFinalDestinationSelection
// RESUMEN: Gestiona la selección de "Ir a Destino Final" desde el modal de desvío.
// ===================================================================
function handleFinalDestinationSelection() {
    const finalDestination = navigationWaypoints.find(wp => wp.type === 'F');
    if (!finalDestination) {
        showToast("Error: No se encontró el destino final.", "error");
        closeModalAndProceed();
        return;
    }
    navigationWaypoints.forEach(wp => {
        if (wp.type === 'intermediate') {
            wp.visited = true;
        }
    });
    closeModalAndProceed();
    recalculateAndDrawRoute(true); // CORREGIDO: Se pasa 'true' para preservar estadísticas
    renderWaypointMarkers();
}

// ===================================================================
// NOMBRE: handleStageSelectionFromDeviationModal
// RESUMEN: Gestiona la selección de una etapa específica desde el modal de desvío.
// ===================================================================
function handleStageSelectionFromDeviationModal(selectedWaypointId) {
    const selectedIndex = navigationWaypoints.findIndex(wp => wp.id === selectedWaypointId);
    if (selectedIndex === -1) {
        showToast("Error: No se encontró la etapa seleccionada.", "error");
        closeModalAndProceed();
        return;
    }
    for (let i = 0; i < selectedIndex; i++) {
        const wp = navigationWaypoints[i];
        if (wp && !wp.isInternal && wp.type !== 'S' && wp.type !== 'S_Recalc') {
            wp.visited = true;
        }
    }
    navigationWaypoints[selectedIndex].visited = false;
    closeModalAndProceed();
    recalculateAndDrawRoute(true); // CORREGIDO: Se pasa 'true' para preservar estadísticas
    renderWaypointMarkers();
}





    






    


 // ===================================================================
// NOMBRE: clearModalAutoCloseTimer
// RESUMEN: Limpia un temporizador de autocierre de un modal.
// ===================================================================
function clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId) {
    const timerIdToClear = modalId || (modalElement ? modalElement.dataset.modalTimerId : null);
    if (timerIdToClear && globalModalTimers[timerIdToClear]) {
        clearInterval(globalModalTimers[timerIdToClear].intervalId);
        const timerData = globalModalTimers[timerIdToClear];
        if (timerData.modalElement && timerData.resetHandler) {
            timerData.modalElement.removeEventListener('click', timerData.resetHandler);
            timerData.modalElement.removeEventListener('touchstart', timerData.resetHandler);
            timerData.modalElement.removeEventListener('input', timerData.resetHandler);
            timerData.modalElement.removeEventListener('scroll', timerData.resetHandler);
        }
        if (timerData.countdownSpan && timerData.countdownSpan.parentNode) {
            timerData.countdownSpan.remove();
        }
        delete globalModalTimers[timerIdToClear];
    }
    if(closeButtonElement){
        const orphanSpans = closeButtonElement.querySelectorAll('.button-countdown-timer');
        orphanSpans.forEach(s => s.remove());
    }
     if(modalElement && modalElement.dataset.modalTimerId) {
        delete modalElement.dataset.modalTimerId;
    }
}

// ===================================================================
// NOMBRE: formatDateToDDMMMYY
// RESUMEN: Formatea una fecha (YYYY-MM-DD) a un formato legible (DD Mes Abreviado YY).
// ===================================================================
function formatDateToDDMMMYY(dateString) {
     if (!dateString) return '-';
     try {
         const [year, month, day] = dateString.split('-').map(Number);
         const date = new Date(Date.UTC(year, month - 1, day));
         if (isNaN(date.getTime())) return '-';
         const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
         const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
         const monthName = monthNames[date.getUTCMonth()];
         const yearShort = String(date.getUTCFullYear()).slice(-2);
         return `${dayOfMonth} ${monthName} ${yearShort}`;
     } catch (e) {
         return '-';
     }
}

// ===================================================================
// NOMBRE: calculateNextOccurrence
// RESUMEN: Calcula la próxima fecha de vencimiento de un recordatorio cíclico.
// ===================================================================
function calculateNextOccurrence(reminder, referenceDate) {
      if (!reminder || !reminder.type || !reminder.time || !reminder.date) { return null; } try {
          let [year, month, day] = reminder.date.split('-').map(Number); let [hour, minute] = reminder.time.split(':').map(Number);
          let baseDate = new Date(Date.UTC(year, month - 1, day, hour, minute)); if (isNaN(baseDate.getTime())) { return null; }
          const refDateUTC = new Date(referenceDate.getTime()); if (baseDate > refDateUTC) return baseDate;
          if (reminder.type === 'simple') { return null; }
          if (reminder.type === 'daily' || reminder.type === 'hourly') { let next = new Date(baseDate); while (next <= refDateUTC) { next.setUTCDate(next.getUTCDate() + 1); } return next; }
          if (reminder.type === 'weekly' && reminder.repeatDays && reminder.repeatDays.length > 0) {
              let next = new Date(refDateUTC); next.setUTCHours(hour, minute, 0, 0);
              if (next <= refDateUTC || !reminder.repeatDays.includes(next.getUTCDay())) { next.setUTCDate(next.getUTCDate() + 1); }
              for (let i = 0; i < 7; i++) { if (reminder.repeatDays.includes(next.getUTCDay())) { return next; } next.setUTCDate(next.getUTCDate() + 1); } return null;
          }
          if (reminder.type === 'interval' && reminder.intervalDays && reminder.intervalDays > 0) { let next = new Date(baseDate); while (next <= refDateUTC) { next.setUTCDate(next.getUTCDate() + reminder.intervalDays); } return next; }
          return null; } catch (e) { return null; }
 }

// ===================================================================
// NOMBRE: calculatePostponedDateTime
// RESUMEN: Calcula la fecha y hora para posponer un recordatorio.
// ===================================================================
function calculatePostponedDateTime(mins) {
      const now = new Date(); const postponedDate = new Date(now.getTime() + mins * 60000);
      const newDateISO = `${postponedDate.getFullYear()}-${(postponedDate.getMonth() + 1).toString().padStart(2, '0')}-${postponedDate.getDate().toString().padStart(2, '0')}`;
      const newTime = `${postponedDate.getHours().toString().padStart(2, '0')}:${postponedDate.getMinutes().toString().padStart(2, '0')}`; return { newDateISO, newTime };
 }

// ===================================================================
// NOMBRE: handleDragEndReorder
// RESUMEN: Maneja la finalización de una operación de arrastre en la lista de etapas.
// ===================================================================
function handleDragEndReorder(e) {
    if (draggedStageLi) {
        draggedStageLi.classList.remove('dragging');
    }
    draggedStageLi = null;
}

// ===================================================================
// NOMBRE: handleDragOverReorder
// RESUMEN: Maneja el evento de pasar por encima al arrastrar en la lista de etapas.
// ===================================================================
function handleDragOverReorder(e) {
    e.preventDefault();
    if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
    const listElement = document.getElementById('sortable-stages-list');
    if (!listElement || !draggedStageLi) return;
    const afterElement = getDragAfterElement(listElement, e.clientY);
    const currentLi = e.target.closest('li');
    if (draggedStageLi && currentLi && draggedStageLi !== currentLi) {
        if (afterElement == null) {
            listElement.appendChild(draggedStageLi);
        } else {
            listElement.insertBefore(draggedStageLi, afterElement);
        }
    } else if (draggedStageLi && !currentLi && afterElement == null) {
         listElement.appendChild(draggedStageLi);
    } else if (draggedStageLi && !currentLi && afterElement) {
         listElement.insertBefore(draggedStageLi, afterElement);
    }
}

// ===================================================================
// NOMBRE: handleStageTouchStart
// RESUMEN: Maneja el inicio de un toque en una etapa para reordenar.
// ===================================================================
function handleStageTouchStart(e) {
    if (e.touches.length === 1 && e.target.closest('.drag-handle')) {
        draggedStageLi = e.target.closest('li');
        if (!draggedStageLi) return;
        const touch = e.touches[0];
        stageTouchStartX = touch.clientX;
        stageTouchStartY = touch.clientY;
        clearTimeout(stageScrollTimeout);
        stageScrollTimeout = setTimeout(() => {
            if (draggedStageLi) {
                draggedStageLi.classList.add('dragging');
                document.body.style.overflow = 'hidden';
            }
        }, 150);
    }
}


    

// ===================================================================
// NOMBRE: handleStageTouchMove
// RESUMEN: Maneja el movimiento de un toque en una etapa para reordenar.
// ===================================================================
function handleStageTouchMove(e) {
    if (!draggedStageLi || e.touches.length !== 1) return;
    e.preventDefault();
    clearTimeout(stageScrollTimeout);
    if (!draggedStageLi.classList.contains('dragging')) {
        draggedStageLi.classList.add('dragging');
         document.body.style.overflow = 'hidden';
    }
    const touch = e.touches[0];
    const listElement = document.getElementById('sortable-stages-list');
    if (!listElement) return;
    const afterElement = getDragAfterElement(listElement, touch.clientY);
     if (afterElement == null) {
        listElement.appendChild(draggedStageLi);
    } else {
        listElement.insertBefore(draggedStageLi, afterElement);
    }
}


    
// ===================================================================
// NOMBRE: handleStageTouchEnd
// RESUMEN: Maneja el final de un toque en una etapa para reordenar.
// ===================================================================
function handleStageTouchEnd(e) {
    clearTimeout(stageScrollTimeout);
    if (draggedStageLi) {
        draggedStageLi.classList.remove('dragging');
        draggedStageLi = null;
    }
    document.body.style.overflow = '';
}

// ===================================================================
// NOMBRE: getDragAfterElement
// RESUMEN: Encuentra el elemento después del cual se debe soltar el elemento arrastrado.
// ===================================================================
function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('li:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}









// ===================================================================
// NOMBRE: recalculateAndDrawRoute (VERSIÓN CORREGIDA)
// RESUMEN: Recalcula la ruta y reinicia la simulación si está activa.
// ===================================================================
async function recalculateAndDrawRoute(preserveAccumulatedStats = false) {
    isRecalculatingRoute = true;
    lastAutoShownManeuverId = null;

    if (preserveAccumulatedStats) {
        accumulatedDistanceBeforeCurrentSegment = totalDistanceTravelledForStats;
    } else {
        isArrivalSequenceStarted = false;
        accumulatedDistanceBeforeCurrentSegment = 0;
        totalDistanceTravelledForStats = 0;
        maxDistanceReachedOnRoute = 0;
        lastPositionForStats = null;
        if (isNavigating) navigationStartTimeForStats = new Date();
        tripInitialOverallEtaTime = null;
        currentStageInitialExpectedEtaTime = null;
        accumulatedDeviationMs = 0;
        maxSpeedDuringTrip = 0;
        maxSpeedCoordinates = null;
        maxAltitudeDuringTrip = -Infinity;
        minAltitudeDuringTrip = Infinity;
        // INICIO: Inicialización de variables para la nueva gráfica
        minAverageSpeedInTrip = Infinity;
        maxAverageSpeedInTrip = -Infinity;
        // FIN: Inicialización de variables para la nueva gráfica
        if (compassAndModeControl) {
            compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip);
        }
    }

    const recalculateToastId = "recalculating-route-toast";
    showToast("Recalculando ruta...", "info", 0, false, recalculateToastId);
    
    lastCarDistanceAlongRouteForNavLogic = 0;
    lastValidCarDistanceForDisplay = 0;

    let waypointsForRouteCalculation = [];
    if (navigationCurrentLocation) {
        const currentPositionAsWaypoint = { lat: navigationCurrentLocation.latitude, lng: navigationCurrentLocation.longitude };
        waypointsForRouteCalculation.push(currentPositionAsWaypoint);
    } else {
        const firstUnvisited = navigationWaypoints.find(wp => wp && !wp.visited);
        if (firstUnvisited) {
            waypointsForRouteCalculation.push(firstUnvisited);
        }
    }
    const remainingWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.visited);
    waypointsForRouteCalculation.push(...remainingWaypoints);

    if (waypointsForRouteCalculation.length < 2) {
        const existingRecalcToast = document.getElementById(recalculateToastId);
        if (existingRecalcToast) existingRecalcToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== recalculateToastId);
        showToast("No hay suficientes etapas restantes para calcular una nueva ruta.", "warning");
        if (navigationRouteLayer && navigationMapInstance) { try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch (e) {} navigationRouteLayer = null; }
        if (completedRouteSegmentsLayer && navigationMapInstance ) completedRouteSegmentsLayer.clearLayers();
        navigationCurrentRouteData = null;
        hideMapInfoOverlay();
        isRecalculatingRoute = false;
        return;
    }

    const coordsString = waypointsForRouteCalculation.map(wp => {
        if (typeof wp.lng !== 'number' || typeof wp.lat !== 'number' || isNaN(wp.lng) || isNaN(wp.lat) ) return null;
        return `${wp.lng},${wp.lat}`;
    }).filter(Boolean).join(';');

    if (!coordsString || waypointsForRouteCalculation.filter(wp => wp && typeof wp.lng === 'number' && typeof wp.lat === 'number').length < 2) {
        const existingRecalcToast = document.getElementById(recalculateToastId);
        if (existingRecalcToast) existingRecalcToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== recalculateToastId);
        showToast("No hay suficientes waypoints válidos para calcular la ruta.", "warning");
        if (navigationRouteLayer && navigationMapInstance) { try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch (e) {} navigationRouteLayer = null; }
        if (completedRouteSegmentsLayer && navigationMapInstance ) completedRouteSegmentsLayer.clearLayers();
        navigationCurrentRouteData = null;
        hideMapInfoOverlay();
        isRecalculatingRoute = false;
        recalculationAttempts = 0;
        if (recalculationRetryTimeoutId) clearTimeout(recalculationRetryTimeoutId);
        recalculationRetryTimeoutId = null;
        updateStartNavigationButtonState();
        return;
    }

    const url = `${OSRM_SERVICE_URL}/driving/${coordsString}?overview=full&geometries=geojson&steps=true&alternatives=false&annotations=true`;
    try {
        const response = await fetch(url);
        if (!response.ok) {
            let errorData = { message: `HTTP error ${response.status}` };
            try { errorData = await response.json(); } catch (e) { errorData.message = response.statusText || errorData.message; }
            throw new Error(`OSRM Error: ${errorData.code || errorData.message || response.statusText}`);
        }
        const data = await response.json();
        const existingRecalcToastSuccess = document.getElementById(recalculateToastId);
        if (existingRecalcToastSuccess) existingRecalcToastSuccess.remove();
        activeToasts = activeToasts.filter(t => t.id !== recalculateToastId);

        if (data.routes && data.routes.length > 0) {
            navigationCurrentRouteData = data;
            if (completedRouteSegmentsLayer && navigationMapInstance ) completedRouteSegmentsLayer.clearLayers();
            drawRouteOnMap(data.routes[0]);
            currentLegIndexNav = 0;
            currentStepIndexNav = 0;
            lastProcessedStepManeuverLocation = null;
            
            if (preserveAccumulatedStats && data.routes[0]) {
                tripInitialOverallEtaTime = new Date(Date.now() + (data.routes[0].duration * 1000));
                if (data.routes[0].legs && data.routes[0].legs.length > 0) {
                     currentStageInitialExpectedEtaTime = new Date(Date.now() + (data.routes[0].legs[0].duration * 1000));
                }
            }

            if (data.routes[0]) {
                 const currentCarPosForRecalc = navigationCurrentLocation;
                 let carDistanceAlongRouteForInternalUse = 0;
                 if (currentCarPosForRecalc && navigationMapInstance && navigationRouteLayer && typeof turf !== 'undefined' && navigationRouteLayer.getLatLngs().length > 0) {
                    try {
                        const carPointTurf = turf.point([currentCarPosForRecalc.longitude, currentCarPosForRecalc.latitude]);
                        const routeLineStringTurf = turf.lineString(navigationRouteLayer.getLatLngs().map(ll => [ll.lng, ll.lat]));
                        const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                        const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                        carDistanceAlongRouteForInternalUse = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                    } catch (turfError) {}
                 }
                 lastCarDistanceAlongRouteForNavLogic = carDistanceAlongRouteForInternalUse;
                 updateNavigationProgressDisplay(data.routes[0], carDistanceAlongRouteForInternalUse);
                 updateTurnByTurnDisplay(data.routes[0], carDistanceAlongRouteForInternalUse);
                 showDestinationName();
            }
            showNavigationUIElementsForPlanning();
            recalculationAttempts = 0;
            if (recalculationRetryTimeoutId) clearTimeout(recalculationRetryTimeoutId);
            recalculationRetryTimeoutId = null;

            if (automatedSimulationIntervalId) {
                stopAutomatedRouteSimulationInternal();
                showToast("Ruta recalculada. Reiniciando simulación automática.", "info");
                startAutomatedRouteSimulation(simulationSpeedKmph);
            }

        } else {
            throw new Error("No se encontraron rutas.");
        }
    } catch (error) {
        const existingRecalcToastError = document.getElementById(recalculateToastId);
        if (existingRecalcToastError) existingRecalcToastError.remove();
        activeToasts = activeToasts.filter(t => t.id !== recalculateToastId);
        let errorMessageForToast = `Error al calcular ruta: ${error.message}`;
        showToast(errorMessageForToast, "error");
        if (navigationRouteLayer && navigationMapInstance) { try { navigationMapInstance.removeLayer(navigationRouteLayer); } catch(e) {} navigationRouteLayer = null; }
        if (completedRouteSegmentsLayer && navigationMapInstance ) completedRouteSegmentsLayer.clearLayers();
        navigationCurrentRouteData = null;
        lastValidCarDistanceForDisplay = 0;
        hideMapInfoOverlay();
        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox) { eliminarRadaresDeRuta(); actualizarContadorRadares(0); localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked)); }
        const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasRutaCheckbox) { eliminarTareasDeBarraProgreso(); actualizarContadorTareas(0); localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked)); }
        if (recalculationRetryTimeoutId) clearTimeout(recalculationRetryTimeoutId);
        recalculationRetryTimeoutId = setTimeout(() => recalculateAndDrawRoute(preserveAccumulatedStats), 2000);
    }
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    if (!recalculationRetryTimeoutId) {
        isRecalculatingRoute = false;
    }
}




    
// ===================================================================
// NOMBRE: plotIntervalData
// RESUMEN: Añade un nuevo punto de datos a la gráfica a intervalos regulares.
// ===================================================================
function plotIntervalData() {
    if (!isNavigating || !navigationChart || !navigationStartTimeForStats || !navigationCurrentLocation) {
        return;
    }

    let currentAverageSpeed = 0;
    const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000;

    if (timeElapsedS > 0 && totalDistanceTravelledForStats > 0) {
        const avgSpeedMs = totalDistanceTravelledForStats / timeElapsedS;
        currentAverageSpeed = avgSpeedMs * 3.6;
    }
    
    if (currentAverageSpeed > 0) { // Solo registrar cuando hay movimiento
        minAverageSpeedInTrip = Math.min(minAverageSpeedInTrip, currentAverageSpeed);
        maxAverageSpeedInTrip = Math.max(maxAverageSpeedInTrip, currentAverageSpeed);
    }
    
    const currentAltitude = navigationCurrentLocation.altitude || 0;

    const timeLabel = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    graphLabels.push(timeLabel);
    graphDataPoints.speed.push(currentAverageSpeed); // Se usa la media acumulada real
    graphDataPoints.altitude.push(currentAltitude);
    
    updateChartData();

    const isCurrentlyStopped = (window.currentSpeedKmh || 0) < 1;
    if (isCurrentlyStopped) {
        if (isCarStoppedForGraph) return; 
        isCarStoppedForGraph = true;
    } else {
        isCarStoppedForGraph = false;
    }
}




 // ===================================================================
// NOMBRE: initializeNavigationGraph
// RESUMEN: Inicializa el gráfico de Chart.js para la navegación.
// ===================================================================
function initializeNavigationGraph() {
    const graphCard = document.getElementById('navigation-graph-card');
    const graphContainer = document.getElementById('navigation-graph-container');
    const graphTitleElement = document.getElementById('navigation-graph-title');
    if (!graphCard || !graphContainer || !graphTitleElement || !isNavigating || currentGraphMode === 'Gráfica off') {
        if (graphCard) graphCard.classList.add('hidden');
        if (navigationChart) { navigationChart.destroy(); navigationChart = null; }
        return;
    }
    graphCard.classList.remove('hidden');
    const compassElement = document.querySelector('.leaflet-control-orientation-altitude');
    graphCard.style.height = compassElement ? (compassElement.offsetHeight + 'px') : '157px';
    isCarStoppedForGraph = false;
    graphDataPoints = { speed: [], altitude: [] };
    graphLabels = [];
    minAverageSpeedInTrip = Infinity;
    maxAverageSpeedInTrip = -Infinity;
    graphPlotState = { 
        lastPlotTime: Date.now(), 
        lastPlotCoords: navigationCurrentLocation ? { ...navigationCurrentLocation } : null 
    };
    if (navigationChart) {
        navigationChart.destroy();
        navigationChart = null;
    }
    const ctx = document.getElementById('navigation-chart')?.getContext('2d');
    if (!ctx || !ctx.canvas) {
        showToast("Error crítico: Canvas para gráfica no encontrado.", "error");
        if (graphCard) graphCard.classList.add('hidden');
        return;
    }
    graphIntervalDuration = 30000; 

    const initialRouteDurationSec = navigationCurrentRouteData?.routes?.[0]?.duration || 0;
    const initialRouteDistance = navigationCurrentRouteData?.routes?.[0]?.distance || 0;
    
    graphExpectedAvgSpeed = (initialRouteDurationSec > 0 && initialRouteDistance > 0) ? (initialRouteDistance / initialRouteDurationSec) * 3.6 : 0;
    
    navigationChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'Velocidad Media Real', data: [],
                    borderColor: 'rgba(75, 192, 192, 1)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    tension: 0.1, yAxisID: 'yPrimary', 
                    pointRadius: 0, 
                    order: 3, // Prioridad de dibujado
                    fill: false
                },
                {
                    label: 'Área Desnivel', data: [],
                    borderColor: 'rgba(255, 165, 0, 0.5)', 
                    backgroundColor: 'rgba(255, 165, 0, 0.2)', 
                    fill: 'origin',
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: true, order: 4
                },
                {
                    // --- MODIFICACIÓN 1: Estilo de la línea ETA inicial ---
                    label: 'Media ETA Inicial', data: [], 
                    borderColor: '#D29BFD', // Nuevo color solicitado
                    borderWidth: 3,          // Aumentamos el grosor
                    fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 2
                },
                {
                    label: 'Media Mínima', data: [], borderColor: '#FFA500',
                    borderWidth: 1.5, borderDash: [5, 5], fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 1
                },
                {
                    label: 'Media Máxima', data: [], borderColor: '#28a745',
                    borderWidth: 1.5, borderDash: [5, 5], fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 0
                },
                // --- AÑADIDO: Nueva línea para la media en tiempo real ---
                {
                    label: 'Media Acumulada Real', data: [], 
                    borderColor: 'yellow', // Color amarillo solicitado
                    borderWidth: 3,        // Mismo grosor que la ETA inicial
                    fill: false,
                    pointRadius: 0, 
                    yAxisID: 'yPrimary', 
                    hidden: false, 
                    order: 2 // Misma prioridad que la ETA para que se vea bien
                }
            ]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            layout: {
                padding: { top: 5, bottom: 2, left: 0, right: 2 }
            },
            scales: {
                x: {
                    type: 'category',
                    ticks: {
                        display: false 
                    },
                    grid: {
                        drawOnChartArea: false
                    }
                },
                yPrimary: {
                    type: 'linear', position: 'left',
                    grace: '5%',
                    min: 0,
                    ticks: { color: 'white', font: { size: 11 }, callback: (v) => Math.round(Number(v)).toString(), stepSize: 2 },
                    grid: { color: 'rgba(255,255,255,0.1)' }, title: { display: false }
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: { 
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) { label += ': '; }
                            if (context.parsed.y !== null) {
                                label += context.parsed.y.toFixed(1);
                                if (currentGraphMode === 'Desviación ETA') label += ' km/h';
                                else if (currentGraphMode === 'Altitud') label += ' m';
                            }
                            return label;
                        }
                    }
                 }
            },
            animation: { duration: 250 }
        }
    });
    startGraphIntervalTimer();
    updateNavigationGraphVisibilityAndMode();
}   

    





    


// ===================================================================
// NOMBRE: updateChartData
// RESUMEN: Actualiza los datos y la configuración de la gráfica de navegación.
// ===================================================================
function updateChartData() {
    if (!navigationChart) return;
    const graphCard = document.getElementById('navigation-graph-card');
    const isEnlarged = graphCard ? graphCard.classList.contains('enlarged') : false;
    const valueStyle = "font-size: 1.2em; opacity: 1.0; line-height: 1.4; font-weight: bold; text-align: right; padding-right: 22px;";
    const etaColor = "#D29BFD"; // Actualizado al nuevo color
    const avgColor = "yellow";   // Actualizado al nuevo color
    const maxColor = "#FFA420";
    const minAvgLineColor = '#FFA500';
    const maxAvgLineColor = '#28a745';

    const mainDataset = navigationChart.data.datasets[0];
    const altitudeFillDataset = navigationChart.data.datasets[1];
    const referenceDataset = navigationChart.data.datasets[2];
    const minAvgSpeedDataset = navigationChart.data.datasets[3];
    const maxAvgSpeedDataset = navigationChart.data.datasets[4];
    // --- AÑADIDO: Referencia al nuevo dataset de la media acumulada ---
    const accumulatedAvgSpeedDataset = navigationChart.data.datasets[5];

    if (currentGraphMode === 'Desviación ETA') {
        navigationChart.options.scales.yPrimary.ticks.callback = function(value) { return Math.round(value) + ' km/h'; };
        navigationChart.options.scales.yPrimary.min = 0; 
        
        mainDataset.borderColor = 'rgba(129, 216, 208, 1)'; 
        mainDataset.backgroundColor = 'rgba(37, 99, 235, 0.2)';
        mainDataset.fill = false;
        mainDataset.pointRadius = 0;

        altitudeFillDataset.hidden = true; 
        altitudeFillDataset.data = []; 
        
        const allRelevantSpeedValues = [
            ...(graphDataPoints.speed.length > 0 ? graphDataPoints.speed : [0]),
            graphExpectedAvgSpeed || 0
        ];
        const timeSinceStartMs = navigationStartTimeForStats ? Date.now() - navigationStartTimeForStats.getTime() : Infinity;
        if (timeSinceStartMs > 60000) {
            allRelevantSpeedValues.push(window.averageSpeedKmh || 0);
        }
        
        const currentMaxDataValue = Math.max(...allRelevantSpeedValues);
        const yAxisMax = Math.min(250, Math.max(50, currentMaxDataValue + 15));
        navigationChart.options.scales.yPrimary.max = yAxisMax;
        
        const yAxisRange = yAxisMax - 0; 
        const targetTickCount = isEnlarged ? 15 : 8;
        const rawStep = yAxisRange > 0 ? yAxisRange / targetTickCount : 10;
        const niceIntervals = [2, 5, 10, 20, 25, 50];
        let stepSize = niceIntervals[niceIntervals.length - 1];
        for (const interval of niceIntervals) {
            if (rawStep <= interval) { stepSize = interval; break; }
        }
        navigationChart.options.scales.yPrimary.ticks.stepSize = stepSize;

        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            const etaVal = (graphExpectedAvgSpeed || 0).toFixed(1);
            const avgVal = (window.averageSpeedKmh || 0).toFixed(1);
            const maxVal = (maxSpeedDuringTrip || 0).toFixed(1);
            graphTitleElement.innerHTML = `
                <span style="font-size: 0.7em;">DATOS ETA</span> 
                <small style="${valueStyle}">
                    <span style="color:${etaColor};">ETA: ${etaVal}</span> 
                    <span style="color:${avgColor};">   |  Med: ${avgVal}</span> 
                    <span style="color:${maxColor};">   |  Máx: ${maxVal} Km/h</span>
                </small>`;
        }
        
        mainDataset.data = graphDataPoints.speed;
        mainDataset.label = 'Velocidad Media Real';
        
        referenceDataset.data = graphLabels.map(() => graphExpectedAvgSpeed);
        referenceDataset.label = 'Media ETA Inicial';
        
        minAvgSpeedDataset.data = graphLabels.map(() => minAverageSpeedInTrip === Infinity ? null : minAverageSpeedInTrip);
        minAvgSpeedDataset.label = 'Media Mínima';
        minAvgSpeedDataset.borderColor = minAvgLineColor;
        
        maxAvgSpeedDataset.data = graphLabels.map(() => maxAverageSpeedInTrip === -Infinity ? null : maxAverageSpeedInTrip);
        maxAvgSpeedDataset.label = 'Media Máxima';
        maxAvgSpeedDataset.borderColor = maxAvgLineColor;

        // --- AÑADIDO: Actualizar los datos de la nueva línea ---
        // La línea se rellenará con el valor actual de la velocidad media acumulada.
        accumulatedAvgSpeedDataset.data = graphLabels.map(() => window.averageSpeedKmh);
        accumulatedAvgSpeedDataset.hidden = false;

    } else if (currentGraphMode === 'Altitud') {
        // ... (el código de la gráfica de altitud no cambia, pero se asegura de ocultar la nueva línea)
        
        // --- AÑADIDO: Ocultar la línea de media acumulada en modo Altitud ---
        accumulatedAvgSpeedDataset.hidden = true;
        accumulatedAvgSpeedDataset.data = [];

        navigationChart.options.scales.yPrimary.ticks.callback = function(value) { return Math.round(value) + ' m'; };
        navigationChart.options.scales.yPrimary.max = undefined;
        navigationChart.options.scales.yPrimary.min = undefined;
        
        mainDataset.borderColor = 'rgba(129, 216, 208, 1)'; 
        mainDataset.backgroundColor = 'transparent';
        mainDataset.fill = false;
        mainDataset.pointRadius = 0;

        altitudeFillDataset.data = graphDataPoints.altitude;
        altitudeFillDataset.hidden = false;
        
        const altitudeValues = graphDataPoints.altitude.length > 0 ? graphDataPoints.altitude : [0];
        const minAlt = Math.min(...altitudeValues);
        const maxAlt = Math.max(...altitudeValues);
        const altRange = maxAlt - minAlt;
        const targetTickCountAlt = isEnlarged ? 10 : 5;

        if (altRange > 0) {
            const rawStepAlt = altRange / targetTickCountAlt;
            const niceIntervalsAlt = [2, 5, 10, 20, 50, 100];
            let stepSizeAlt = niceIntervalsAlt[niceIntervalsAlt.length - 1];
            for (const interval of niceIntervalsAlt) { if(rawStepAlt <= interval) { stepSizeAlt = interval; break; } }
            navigationChart.options.scales.yPrimary.ticks.stepSize = stepSizeAlt;
        } else {
             navigationChart.options.scales.yPrimary.ticks.stepSize = undefined;
        }
        
        const altitudePoints = graphDataPoints.altitude;
        const avgAltitudeValue = altitudePoints.length > 0 ? altitudePoints.reduce((a, b) => a + b, 0) / altitudePoints.length : 0;
        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            const maxAltVal = (maxAltitudeDuringTrip !== -Infinity ? maxAltitudeDuringTrip : 0).toFixed(0);
            const avgAltVal = avgAltitudeValue.toFixed(0);
            const minAltVal = (minAltitudeDuringTrip !== Infinity ? minAltitudeDuringTrip : 0).toFixed(0);
            graphTitleElement.innerHTML = `
                <span style="font-size: 0.7em;">DESNIVEL RUTA</span>
                <small style="${valueStyle}">
                    <span style="color:${maxColor};">Máx: ${maxAltVal}</span> 
                    <span style="color:${etaColor};">   |  Med: ${avgAltVal}</span> 
                    <span style="color:${avgColor};">   |  Mín: ${minAltVal}m</span>
                </small>`;
        }
        
        mainDataset.data = graphDataPoints.altitude;
        mainDataset.label = 'Altitud';
        
        referenceDataset.data = graphLabels.map(() => avgAltitudeValue);
        referenceDataset.label = 'Media';
        
        minAvgSpeedDataset.data = graphLabels.map(() => minAltitudeDuringTrip !== Infinity ? minAltitudeDuringTrip : null);
        minAvgSpeedDataset.label = 'Mínima';
        minAvgSpeedDataset.borderColor = '#FFA500';
        
        maxAvgSpeedDataset.data = graphLabels.map(() => maxAltitudeDuringTrip !== -Infinity ? maxAltitudeDuringTrip : null);
        maxAvgSpeedDataset.label = 'Máxima';
        maxAvgSpeedDataset.borderColor = '#28a745';
    }
    navigationChart.data.labels = graphLabels; 
    navigationChart.update('none');
}



    









// ===================================================================
// NOMBRE: startGraphIntervalTimer
// RESUMEN: Inicia el temporizador para añadir datos a la gráfica.
// ===================================================================
function startGraphIntervalTimer() {
    if (graphIntervalTimer) clearInterval(graphIntervalTimer);
    if (isNavigating && currentGraphMode !== 'Gráfica off' && graphIntervalDuration > 0) { 
        graphIntervalTimer = setInterval(plotIntervalData, graphIntervalDuration);
    }
}












document.addEventListener('DOMContentLoaded', async () => {
     storedPin = localStorage.getItem('password_pin');
     const savedPasswordActive = localStorage.getItem('password_active');
     isPasswordActive = savedPasswordActive ? JSON.parse(savedPasswordActive) : false;
     const initialDirectToNavPref = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
     const tempPreventDirectNav = sessionStorage.getItem(TEMP_PREVENT_DIRECT_NAV_KEY);
     if (isPasswordActive && storedPin && !(initialDirectToNavPref && !tempPreventDirectNav)) {
         promptForPin();
     } else {
         await initializeApp();
     }
    window.addEventListener('beforeunload', () => {
         if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
         if (locationWatchId !== null && navigator.geolocation) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
         if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
         const openReminderModal = document.querySelector('.reminder-modal');
         if (openReminderModal && typeof openReminderModal.cleanUpModalTimers === 'function') { openReminderModal.cleanUpModalTimers(true); }
         Object.keys(globalModalTimers).forEach(modalId => {
            const timerData = globalModalTimers[modalId];
            if (timerData) {
                clearModalAutoCloseTimer(timerData.modalElement, timerData.closeButtonElement, modalId);
            }
         });
         globalModalTimers = {};
         const openTableModal = document.querySelector('.reminder-table-modal');
         if(openTableModal && openTableModal.autoCloseInterval) { clearInterval(openTableModal.autoCloseInterval); }
         const openPostponeModal = document.getElementById('postpone-options-modal');
         if(openPostponeModal && openPostponeModal.autoPostponeInterval) { clearInterval(openPostponeModal.autoPostponeInterval); }
         const openSavedLocationsModal = document.querySelector('.saved-locations-modal');
         if (openSavedLocationsModal && locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
         const simModalUnload = document.getElementById('simulation-modal');
         if (simModalUnload && simulationModalTimer) clearTimeout(simulationModalTimer);
         if (autoStartNavTimer) clearTimeout(autoStartNavTimer);
         if (isNavigationMapActive || navigationMapInstance) {
            closeNavigationMap(true);
         }
         if (locationsPreviewMap) {
             try { locationsPreviewMap.remove(); } catch(e){}
             locationsPreviewMap = null;
         }
         if (isAssignmentMode || isEditMode || isKeywordAssignmentMode) { saveCustomData(); }
         const filterInput = document.getElementById('grid-filter-input');
         if (filterInput && filterInput.value.trim()) {
              localStorage.setItem('gridFilterValue', filterInput.value);
         } else {
              localStorage.removeItem('gridFilterValue');
         }
          saveSettings();
          if (reminderModalMap) try {reminderModalMap.remove();} catch(e){}
          Object.values(previewMaps).forEach(map => {try {map?.remove();} catch(e){}});
          if (intersectionPreviewMap) try {intersectionPreviewMap.remove();} catch(e){}
          if (navigationChart) navigationChart.destroy();
          if (graphIntervalTimer) clearInterval(graphIntervalTimer);
     });
    document.body.addEventListener('click', function(event) {
        const target = event.target;
        const targetId = target.id || (target.closest('[id]') ? target.closest('[id]').id : null);
        if (targetId === 'config-close-modal') {
            const modal = document.getElementById('config-modal');
            if (modal && !modal.classList.contains('hidden')) {
                clearModalAutoCloseTimer(modal, target, 'config-modal');
                modal.classList.add('hidden');
                 const mapWasOpenBeforeConfig = sessionStorage.getItem('boardinggate_map_should_reopen_after_config') === 'true';
                 const mapContextToReopen = sessionStorage.getItem('mapContextToReopenAfterConfig');
                 sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');
                 sessionStorage.removeItem('mapContextToReopenAfterConfig');
                 if (mapWasOpenBeforeConfig && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !document.getElementById('reminders-location-map-modal')) {
                    if (mapContextToReopen === 'navigation') {
                        setTimeout(() => openNavigationMap(), 50);
                    }
                }
            }
        }
        if (target.matches('.config-tab-button')) {
            const modal = document.getElementById('config-modal');
            if(modal && modal.classList.contains('hidden') === false) {
                const tabTarget = target.dataset.tabTarget;
                modal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                modal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (modal.querySelector(tabTarget)) {
                    modal.querySelector(tabTarget).classList.add('active');
                }
            }
        }
        if (targetId === 'close-reminders-top' || targetId === 'close-reminders-bottom') {
            const modalTable = document.querySelector('.reminder-table-modal');
            if (modalTable) {
                if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                modalTable.remove();
                const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                const mapContext = sessionStorage.getItem('mapContext');
                sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                sessionStorage.removeItem('mapContext');
                if (fromReminderModal) {
                    fromReminderModal = false;
                    if (mapShouldReopen) {
                        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                        sessionStorage.setItem('mapContext', mapContext);
                    }
                    showReminderModal();
                } else if (mapShouldReopen) {
                     if (mapContext === 'navigation') openNavigationMap();
                }
            }
        }
        if (targetId === 'view-all-locations-map') {
            const modalTable = document.querySelector('.reminder-table-modal');
             if (modalTable && modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
             if (modalTable) modalTable.remove();
            setTimeout(() => {
                openLocationsPreviewMap();
            }, 50);
        }
         if (targetId === 'close-locations-preview') {
            const previewModal = document.getElementById('locations-preview-modal');
            if (previewModal) {
                if (locationsPreviewMap) {
                    try { locationsPreviewMap.remove(); } catch (e) {}
                    locationsPreviewMap = null;
                }
                if (mapLayersControlLocationsPreview) {
                    try {mapLayersControlLocationsPreview.remove();} catch(e){}
                    mapLayersControlLocationsPreview = null;
                }
                clearModalAutoCloseTimer(previewModal, target, 'locations-preview-modal');
                previewModal.classList.add('hidden');
            }
        }
        if (targetId === 'close-address-suggestions-modal') {
            hideAddressSuggestionsModal();
        }
    });
    const bookmarkGrid = document.getElementById('bookmark-grid');
    if (bookmarkGrid) {
        bookmarkGrid.addEventListener('click', function(event) {
            const link = event.target.closest('a.bookmark-item');
            if (link && link.href && link.href.startsWith("map-action:")) {
                event.preventDefault();
                const action = link.href.split(":")[1];
                if (action === "openRemindersMapWithNoRadars") {
                    closeOtherModals();
                    setTimeout(() => {
                        const existingPreviewModal = document.getElementById('locations-preview-modal');
                        if (existingPreviewModal && !existingPreviewModal.classList.contains('hidden')) {
                            showToast("El mapa de ubicaciones (sin radar) ya está abierto", "info");
                        } else {
                           openLocationsPreviewMap();
                        }
                    }, 50);
                } else if (action === "openRemindersMap") {
                    closeOtherModals();
                    setTimeout(() => {
                        const mapModalElement = document.getElementById('reminders-location-map-modal');
                        if (mapModalElement && !mapModalElement.classList.contains('hidden')) {
                            showToast("El mapa de navegación/ubicaciones ya está abierto", "info");
                            if (navigationMapInstance) {
                                requestAnimationFrame(() => {
                                    requestAnimationFrame(() => {
                                        if (navigationMapInstance) {
                                            try {
                                                 navigationMapInstance.invalidateSize({debounceMoveend: true});
                                             } catch (e) {  }
                                        }
                                    });
                                });
                            }
                        } else {
                           openNavigationMap();
                        }
                    }, 50);
                }
            }
        });
    }

    const accidentAlertButton = document.getElementById('accident-alert-button');
    if (accidentAlertButton) {
        accidentAlertButton.addEventListener('click', () => {
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
            openAlertModal();
        });
    }
});
       
</script> 
</body>
</html>  
