<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BoardingGate Lanzador (Debug v8)</title>
    <link rel="icon" href="https://boardinggate.github.io/Tesla/IMG_4157.jpeg" type="image/jpeg">
    <script src="https://cdn.tailwindcss.com"></script>

<style>
    /* --- ESTILOS ORIGINALES (Restaurados) --- */
    /* ... (COPIA AQUÍ TODOS los estilos CSS originales del PRIMER mensaje que me enviaste) ... */
    /* Asegúrate de incluir TODOS los estilos, incluyendo los de .bookmark-item, botones, minimal-mode, etc. */
    /* Ejemplo de inicio (pega el resto): */
    .bookmark-item {
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1);
        position: relative;
    }
    .bookmark-item:hover { /* ... */ }
    .bookmark-item img { image-rendering: crisp-edges; -ms-interpolation-mode: nearest-neighbor; }
    /* ... PEGA TODOS LOS ESTILOS ORIGINALES HASTA EL FINAL DE LA ETIQUETA </style> ... */

    /* --- Añadidos/Ajustes Menores para Debug --- */
    /* Asegurar visibilidad base de contenedores principales */
    main, footer, .notices-icon-container, .counter-wrapper {
        visibility: visible !important;
        opacity: 1 !important;
    }
    /* Borde suave para ver botones si tienen problemas */
    /* .button-lateral { border: 1px dashed rgba(0,0,0,0.2); } */

</style>
</head>
<body class="">
    <!-- Contenido HTML Original -->
    <div class="top-text-container"> <div class="arrow-button" id="back-button"><svg><!-- ... --></svg></div> <span>[...]</span> <div class="arrow-button" id="forward-button"><svg><!-- ... --></svg></div> </div>
    <main> <div id="bookmark-grid"></div> </main>
    <div class="notices-icon-container"> <img src="https://boardinggate.github.io/Tesla/IMG_4194.jpg" alt="Toggle Avisos" class="notice-off-icon" id="notice-toggle-icon"> <div class="notices-container"><div class="notice-wrapper"><span class="notice" id="current-notice"></span></div></div> </div>
    <footer> <div class="header-container"> <!-- ... --> </div> <div class="footer-content"> <!-- ... --> </div> </footer>
    <div class="counter-wrapper"> <!-- ... --> </div>
    <div id="scroll-toggle" class="scroll-toggle-button button-lateral" title="Ir al inicio o fin"> <svg><!-- Icono Up --></svg> <svg><!-- Icono Down --></svg> </div>
    <div id="reminder-notifications"></div>
    <!-- Botones dinámicos se añadirán por JS -->

    <script>
        // === Constants & Globals ===
        const bookmarks = [ /* ... Tu lista original ... */ ];
        const TOTAL_CELLS = 96; const COLS = 6;
        const grid = document.getElementById('bookmark-grid');
        const cellElements = []; let createdToggleButtons = []; let sideButtons = [];
        let isDarkMode = false; let isMinimalMode = false; let isConfigMode = false;
        // Simplificar: Footer visible por defecto, oculto solo por minimal mode
        // let isActive = true; let isFooterVisible = true;
        let pressStartTime = null; let reminderPressStartTime = null;
        let notices = []; let currentNoticeIndex = 0;
        let customToggleConfigs = {};
        const toggleRanges = [ { start: 18, end: 29, label: "PdR,s" }, { start: 30, end: 41, label: "iAs" }, { start: 42, end: 59, label: "Útil" }, { start: 60, end: 95, label: "Varios" } ];

        // === Helper Functions ===
        const checkDarkModeTime = () => { const h = new Date().getHours(); return h >= 21 || h < 7; };
        const getFaviconUrl = (b) => { try { if(b?.favicon) return b.favicon; if (b?.url) { const d = new URL(b.url).hostname; if (d && d.includes('.')) return `https://www.google.com/s2/favicons?domain=${d}&sz=64`; } } catch (e) { console.warn(`Favicon URL error for ${b?.name}: ${e.message}`); } return 'https://via.placeholder.com/32/eee/aaa?text=X'; };
        function generateBrightColor() { const h=Math.floor(Math.random()*360); const s=50+Math.floor(Math.random()*25); const l=75+Math.floor(Math.random()*15); return `hsla(${h}, ${s}%, ${l}%, 0.75)`; }
        function formatVersionDate(d){ if(!d || isNaN(d.getTime())) return "?"; const y=d.getUTCFullYear().toString().slice(-2); const m=String(d.getUTCMonth()+1).padStart(2,'0'); const day=String(d.getUTCDate()).padStart(2,'0'); const h=String(d.getUTCHours()).padStart(2,'0'); return `${y}.${m}.${day}${h}`; }
        async function getLastModifiedDate(){ try { const r = await fetch('https://boardinggate.github.io/Tesla/version.txt', {cache:'no-cache'}); if(!r.ok) throw 'Fetch fail'; const t = await r.text(); const d = new Date(t.trim()); if(isNaN(d.getTime())) throw 'Invalid date'; return d; } catch(e){ console.error("Version fetch err:", e); return new Date(0); }}

        // === Core UI Creation ===
        function createGridItems() {
            console.log("[Init] FN: createGridItems START");
            if (!grid) { console.error("Grid element not found!"); return; }
            grid.innerHTML = ''; cellElements.length = 0;
            const colors = []; for(let i=0; i<TOTAL_CELLS; i++) colors.push(generateBrightColor());

            Array.from({ length: TOTAL_CELLS }).forEach((_, index) => {
                const cell = document.createElement('div');
                const bookmark = (index < bookmarks.length) ? bookmarks[index] : null;
                const isEmpty = !(bookmark && bookmark.name !== undefined);

                if (!isEmpty) {
                    try {
                        const link = document.createElement('a');
                        link.className = 'bookmark-item' + (index >= 60 ? ' small-bookmark' : ''); // Apply original classes
                        link.title = bookmark.name || `Item ${index}`;
                        // Apply original color logic
                        if (colors[index]) { try { const [h, s, l] = colors[index].match(/\d+/g).map(Number); link.style.setProperty('--hue', h); link.style.setProperty('--saturation', `${s}%`); link.style.setProperty('--lightness', `${l}%`); } catch(e){ link.style.backgroundColor = '#EEE'; } } else { link.style.backgroundColor = '#EEE'; }
                        link.href = bookmark.url || "#";
                        if (bookmark.url && bookmark.name !== "Inicio Tesla") { link.target = "_blank"; link.rel = "noopener noreferrer"; }

                        // --- RESTAURAR Icono ---
                        let iconAdded = false;
                        if(bookmark && (bookmark.url || bookmark.name === "Inicio Tesla" || bookmark.favicon)) {
                             const img = document.createElement('img');
                             img.src = getFaviconUrl(bookmark); // Use original function
                             img.alt = ''; img.loading="lazy";
                             img.onerror=(e)=>{ e.target.style.display='none'; console.warn(`Favicon error for ${bookmark?.name || index}`);};
                             if (bookmark.name === "Mis Updates") img.classList.add('favicon-red'); else if (bookmark.name === "Olas Updates") img.classList.add('favicon-blue');
                             link.appendChild(img);
                             iconAdded = true;
                             // console.log(`[Grid ${index}] Icon added for ${bookmark.name}`);
                        } else {
                            // console.log(`[Grid ${index}] No icon condition for ${bookmark.name}`);
                        }

                        // --- RESTAURAR Nombre ---
                        if (bookmark.name !== undefined && bookmark.name !== null) { // Check exists
                            const name = document.createElement('span');
                            name.className = 'bookmark-name'; // Original class
                            name.textContent = bookmark.name || ""; // Show name or empty string if ""
                            link.appendChild(name);
                            // console.log(`[Grid ${index}] Name added: ${name.textContent}`);
                        } else {
                            link.classList.add('no-name');
                            // console.log(`[Grid ${index}] No name added.`);
                        }
                        cell.appendChild(link);

                    } catch (e) {
                        console.error(`Error creating bookmark item at index ${index}:`, bookmark, e);
                        cell.innerHTML = `<span style="color:red; font-size:10px;">Error ${index}</span>`; cell.style.backgroundColor = 'pink';
                    }
                } else { cell.className = 'config-empty-cell'; }
                grid.appendChild(cell); cellElements.push(cell);
            });
            console.log(`[Init] FN: createGridItems END (${cellElements.length} cells).`);
        }

        function createSideButtons() {
             console.log("[Init] FN: createSideButtons START");
             const btnCont = document.body; createdToggleButtons = []; const newBtns = [];
             // --- Helper to create buttons with ORIGINAL classes ---
             const addBtn = (tag, id, originalClasses, html='', data={}) => {
                 try {
                     const el=document.createElement(tag); el.id=id;
                     // Apply original classes + the base class for selection
                     el.className = [...originalClasses, 'button-lateral'].join(' ');
                     if(html)el.innerHTML=html; Object.entries(data).forEach(([k,v])=>el.dataset[k]=v);
                     btnCont.appendChild(el); newBtns.push(el); return el;
                 } catch (e) { console.error(`Error creating button ${id}:`, e); return null; }
             };

             // --- Create buttons using ORIGINAL classes ---
             addBtn('img','on-off-toggle',['toggle-image'],'',{state:'on'}); // Class 'button-lateral' added by helper
             toggleRanges.forEach((range, index) => { const id = `filter-toggle-${index}`; const t = addBtn('span', id, ['toggle-sign', 'range-toggle'], '', { toggleId: id, rangeStart: range.start, rangeEnd: range.end, state: 'visible', label: range.label }); if(t) createdToggleButtons.push(t); });
             addBtn('span','weather-button',['toggle-sign'], `<img src="https://www.google.com/s2/favicons?domain=ventusky.com&sz=64" alt="Tiempo">`);
             addBtn('span','reminder-button',['toggle-sign'], `<img src="https://boardinggate.github.io/Tesla/IMG_4197.jpg" alt="Recordatorio">`);
             addBtn('span','zoom-button',['toggle-sign'], `<img src="./zoon-.png" alt="Zoom">`,{zoomState:'off'});
             addBtn('img','dark-mode-toggle',['toggle-image']);
             addBtn('span','reload-button',['toggle-sign'], `<img src="./reload.webp" alt="Recargar">`);
             addBtn('span','home-button',['toggle-sign'], `<img src="./home.webp" alt="Inicio">`);
             addBtn('span','config-button',['toggle-sign'], `<img src="https://boardinggate.github.io/Tesla/config.jpg" alt="Configuración">`);

             const scroll = document.getElementById('scroll-toggle'); // Static button ALREADY has its class
             if(scroll && !scroll.classList.contains('button-lateral')) scroll.classList.add('button-lateral'); // Ensure base class
             sideButtons = [scroll, ...newBtns].filter(Boolean); // Combine
             console.log(`[Init] FN: createSideButtons END (${sideButtons.length} buttons found/created).`);
        }

        // === State Loading & Saving ===
        function loadStateFromStorage() { /* ... (same) ... */ }
        function saveSettings() { /* ... (same) ... */ }

        // === Visual Updates ===
        function applyTheme() { document.body.classList.toggle('dark-mode', isDarkMode); /* ... */ updateButtonStyles(); }
        function applyZoomState() { /* ... (same) ... */ }
        function applyToggleStates() { /* ... (same) ... */ }
        function applySingleToggleConfig(btn) { /* ... (same) ... */ }
        function updateButtonStyles() { /* ... (same, ensure icons/counts update) ... */ }
        async function updateVersionDisplay() { /* ... (same) ... */ }
        function applyCurrentThemeToElements() { document.body.classList.toggle('dark-mode', isDarkMode); /* ... */ updateButtonStyles(); }

        // === Positioning & Visibility ===
        function adjustButtonPositions() {
            console.log(`[Layout] FN: adjustButtonPositions (Minimal: ${isMinimalMode}) START - ${sideButtons.length} buttons`);
            let top = 10; const space = 4; const btnH_fixed = 54; const scrollH_fixed = 100; // Use fixed heights

            if (!sideButtons || sideButtons.length === 0) { console.warn("No side buttons array found for positioning."); return; }

            // --- Force initial visibility ---
            sideButtons.forEach(button => {
                 if (!button) return;
                 button.style.visibility = 'visible';
                 button.style.opacity = '1';
                 button.style.display = button.classList.contains('toggle-sign') ? 'flex' : 'block'; // Default display
            });

            // Ensure correct order before positioning
            const expectedOrder = [ 'scroll-toggle', 'on-off-toggle', ...toggleRanges.map((r, i) => `filter-toggle-${i}`), 'weather-button', 'reminder-button', 'zoom-button', 'dark-mode-toggle', 'reload-button', 'home-button', 'config-button' ];
            sideButtons.sort((a, b) => { const iA = expectedOrder.indexOf(a?.id); const iB = expectedOrder.indexOf(b?.id); if(iA===-1)return 1; if(iB===-1)return -1; return iA - iB; });
            console.log(`[Layout] Button order for positioning: ${sideButtons.map(b=>b?.id).join(', ')}`);

            sideButtons.forEach((button) => {
                if (!button || !button.id) { console.warn(`Invalid button found`); return; }
                const isScroll = button.id === 'scroll-toggle';
                const isEx = (button.id==='config-button'||button.id==='on-off-toggle');
                const shouldBeVisible = !isMinimalMode || isEx;
                const elemHeight = isScroll ? scrollH_fixed : btnH_fixed; // Use FIXED height

                // Set position first
                button.style.top = `${top}px`;

                // Then set visibility/display based on minimal mode
                if (shouldBeVisible) {
                    // Visibility/Opacity already set above
                    console.log(` - Visible: ${button.id}, Top: ${button.style.top}`);
                    top += elemHeight + space; // Increment top for next visible button
                } else {
                    button.style.visibility = 'hidden'; button.style.opacity = '0';
                    button.style.display = 'none';
                    console.log(` - Hidden: ${button.id}`);
                }
            });
            console.log("[Layout] FN: adjustButtonPositions END");
        }
        function toggleFooterVisibility() { // Simplified - footer only hidden by minimal mode now
             const show = !isMinimalMode; // Directly use minimal mode state
             console.log(`[Layout] toggleFooterVisibility: Should Show = ${show}`);
             document.querySelector('footer')?.classList.toggle('hidden', !show);
             document.querySelector('.counter-wrapper')?.classList.toggle('hidden', !show);
             document.querySelector('.notices-icon-container')?.classList.toggle('hidden', !show);
             // No need to save flags here anymore
        }
        function applyMinimalModeVisuals() {
             console.log("[Layout] FN: applyMinimalModeVisuals", isMinimalMode);
             document.body.classList.toggle('minimal-mode', isMinimalMode);
             const msg = document.getElementById('minimal-mode-message'); if(isMinimalMode && !msg) { const m=document.createElement('div'); m.id='minimal-mode-message'; m.className='minimal-mode-message'; m.textContent='Pulse ON/OFF 2s...'; document.body.appendChild(m); } else if (!isMinimalMode && msg) { msg.remove(); }
             adjustButtonPositions(); // Re-run positioning AFTER class is applied/removed
             toggleFooterVisibility(); // Re-run footer visibility based on new minimal state
        }

        // === Event Listeners Setup ===
        function setupEventListeners() { /* ... (Same as v5) ... */ }

        // === Stubs for Complex Functions ===
        function updateToggleState(toggle) { /* ... (Same as v5) ... */ }
        function updateAllToggles(targetState) { /* ... (Same as v5) ... */ }
        function showConfigMenu() { alert("Configuración Deshabilitada"); }
        function handleReminderLongPress() { alert("Acción Recordatorios Deshabilitada"); }
        async function loadNotices() { try {const r=await fetch('...');notices=(await r.text()).split('\n')...;}catch(e){} updateNotice(); startNoticeRotation();}
        function updateNotice() { const el=document.getElementById('current-notice'); if(el) el.textContent = notices[currentNoticeIndex] || 'Aviso...'; }
        function startNoticeRotation() { /* ... */ }
        function loadReminders() { console.log("Load reminders stub"); updateButtonStyles();}
        function handleSwipe() { /* ... */ }

        // === Initialization Sequence ===
        document.addEventListener('DOMContentLoaded', async () => {
            console.log("=== Initializing Application (v8 - Restore Content) ===");
            try {
                document.body.classList.remove('minimal-mode', 'dark-mode'); isMinimalMode = false; isDarkMode = false;

                console.log("Step 1: Creating UI Elements..."); createGridItems(); createSideButtons();
                console.log("Step 2: Loading Async Data..."); await updateVersionDisplay(); await loadNotices();
                console.log("Step 3: Loading State Variables..."); loadStateFromStorage();

                requestAnimationFrame(async () => {
                    try {
                        console.log("Step 4 (rAF): Applying Initial Visual State...");
                        applyTheme(); applyZoomState(); applyToggleStates();

                        console.log("Step 5 (rAF): Setting Up Event Listeners...");
                        setupEventListeners();

                        console.log("Step 6 (rAF): Applying Minimal Mode Class & Final Positions...");
                        applyMinimalModeVisuals(); // Applies class, calls adjustButtons, toggleFooter

                        // Ensure footer is visible by default if not minimal
                        if (!isMinimalMode) {
                             console.log("Step 7 (rAF): Ensuring non-minimal footer visibility...");
                             toggleFooterVisibility(); // Call again to be sure
                        }

                        console.log("=== Init Complete ===");
                    } catch (rAFError) { console.error("FATAL rAF ERROR:", rAFError); document.body.innerHTML = `<div class="error-message"><h1>Error Fatal (rAF Init)</h1><pre>${rAFError.stack || ''}</pre></div>`; }
                });

            } catch (error) { console.error("FATAL INIT ERROR:", error); document.body.innerHTML = `<div class="error-message"><h1>Error Fatal</h1><pre>${error.stack || ''}</pre></div>`; }
        });

    </script>

</body>
</html>