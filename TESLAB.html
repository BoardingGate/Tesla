<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BoardingGate Lanzador</title>
    <link rel="icon" href="https://boardinggate.github.io/Tesla/IMG_4157.jpeg" type="image/jpeg">
    <script src="https://cdn.tailwindcss.com"></script>

<style>
    .bookmark-item {
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1);
        position: relative;
    }
    .bookmark-item:hover {
        transform: scale(1.1) translateY(-2px);
        box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.6), -6px -6px 12px rgba(255, 255, 255, 0.15);
    }
    .bookmark-item img {
        image-rendering: crisp-edges;
    }
    .bookmark-name {
        font-weight: bold;
        color: #333;
        text-align: center;
        margin-top: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
    }
    #bookmark-grid {
        display: grid;
        grid-template-columns: repeat(6, minmax(120px, 1fr));
        gap: 15px;
        background-color: transparent;
        border-radius: 0.75rem;
        position: relative;
        width: 100%;
        max-width: 984px;
        margin: 0 auto 0 60px; /* Ajustado para margen izquierdo */
        transition: all 0.3s ease;
    }
    #bookmark-grid > div {
        height: auto;
        aspect-ratio: 16 / 9;
        transition: all 0.3s ease;
        border: 2px solid transparent; /* Añadido para modo config */
    }
    .bookmark-item {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        border-radius: 0.5rem;
        transition: all 0.3s ease;
        background-color: hsla(var(--hue), var(--saturation), var(--lightness), 0.64);
    }
    .bookmark-item img {
        width: 36px;
        height: auto;
        max-width: 40px;
        border-radius: 0.25rem;
    }
    .bookmark-name {
        font-size: clamp(0.85rem, 1.5vw, 1.15rem);
    }
    .small-bookmark img {
        width: 24px;
        max-width: 28px;
    }
    .small-bookmark .bookmark-name {
        font-size: clamp(0.85rem, 1.5vw, 1.15rem);
    }
    @media (max-width: 768px) {
        #bookmark-grid {
            grid-template-columns: repeat(3, minmax(100px, 1fr));
            gap: 10px;
            margin-left: 60px; /* Asegurar margen en pantallas pequeñas */
        }
    }
    @media (max-width: 480px) {
        #bookmark-grid {
            grid-template-columns: repeat(2, minmax(80px, 1fr));
            gap: 8px;
            margin-left: 60px; /* Asegurar margen en pantallas muy pequeñas */
        }
    }
    .header-container {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        background-color: #ABAB99;
        padding: 0.5rem;
    }
    body.dark-mode .header-container {
        background-color: #92927E;
    }
    .header-logo {
        width: 100px;
        height: 70px;
        transition: filter 0.2s ease;
    }
    body.dark-mode .header-logo {
        filter: brightness(85%);
    }
    .title-container {
        background-color: #ABAB99;
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        display: inline-block;
    }
    body.dark-mode .title-container {
        background-color: #92927E;
    }
    .header-container h1 {
        color: #5C5C47;
    }
    .version-text {
        font-size: 0.75rem;
        color: #5C5C47;
        font-weight: normal;
    }
    body {
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        background-color: #ABAB99;
        margin: 0;
        overflow-x: hidden;
    }
    body.dark-mode {
        background-color: #92927E;
    }
    header {
        margin-bottom: 0.5rem;
    }
    main {
        margin: 0.5rem auto 0.5rem 60px; /* Ajustado para margen izquierdo */
        background-color: transparent;
        border-radius: 0.75rem;
        padding: 16px;
        min-height: 400px;
        transition: background-color 0.3s ease;
        max-width: 984px;
        width: calc(100% - 60px); /* Ajusta ancho restando margen */
    }
    footer {
        margin: 0.5rem auto;
        text-align: center;
        max-width: 984px;
        width: calc(100% - 60px); /* Ajusta ancho restando margen */
        display: block;
        background-color: #ABAB99;
        margin-left: 60px; /* Ajustado para margen izquierdo */
    }
    body.dark-mode footer {
        background-color: #92927E;
    }
    .footer-content {
        color: #5C5C47;
        padding: 0.5rem;
        margin: 0 auto;
        max-width: 100%;
        position: relative;
    }
    .footer-subtext {
        font-size: 0.75rem;
        color: #5C5C47;
        margin-top: 0.25rem;
        text-align: center;
    }
    .footer-link-green {
        color: #5C5C47;
        text-decoration: none;
        transition: color 0.2s ease;
    }
    .footer-link-green:hover {
        color: #5C5C47;
    }
    .footer-line {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
    }
    .scroll-toggle-button {
        position: fixed;
        width: 91px;
        height: clamp(78.2px, 19.55vw, 175.95px);
        background-color: #668B8B;
        border-radius: 60px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
        padding: clamp(10px, 2vw, 20px);
        cursor: pointer;
        box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        transition: background-color 0.2s ease;
        left: 10px;
        top: 10px;
    }
    .scroll-toggle-button:hover {
        background-color: #D9A066;
    }
    .scroll-toggle-button svg {
        width: clamp(24px, 4vw, 32px);
        height: clamp(24px, 4vw, 32px);
        stroke: #E6E6DC;
    }
    .top-text-container {
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: clamp(0.6rem, 1.5vw, 0.75rem);
        color: #5C5C47;
        background-color: #D1D5DB;
        margin-top: 0.25rem;
        margin-left: 60px; /* Ajustado para margen izquierdo */
        gap: 0.5rem;
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
        animation: fadeOut 6s forwards;
        max-width: 984px; /* Asegura que no exceda el ancho del grid */
        width: calc(100% - 60px); /* Ajusta ancho restando margen */
    }
    body.dark-mode .top-text-container {
        background-color: #6B7280;
    }
    .top-text-container span {
        color: #D9A066;
        font-size: clamp(0.9rem, 2vw, 1.2rem);
    }
    @keyframes fadeOut {
        0% { opacity: 1; }
        80% { opacity: 1; }
        100% { opacity: 0; display: none; }
    }
    .arrow-button {
        width: clamp(36px, 6vw, 48px);
        height: clamp(36px, 6vw, 48px);
        background-color: #D9A066;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        transition: background-color 0.2s ease;
    }
    .arrow-button:hover {
        background-color: #5C5C47;
    }
    .arrow-button svg {
        stroke: #E6E6DC;
    }
    .counter-container {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        margin-top: 1rem;
        text-align: center;
    }
    .favicon-red {
        filter: hue-rotate(0deg) saturate(200%) brightness(80%);
    }
    .favicon-blue {
        filter: hue-rotate(200deg) saturate(150%) brightness(90%);
    }
    .notices-icon-container {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        max-width: 984px;
        margin: 0 auto; /* Centrado horizontal */
        margin-left: 60px; /* Ajustado para margen izquierdo */
        position: relative;
        width: calc(100% - 60px); /* Ajusta ancho restando margen */
    }
    .notices-container {
        flex-grow: 1;
        padding: 0.5rem;
        border: none;
        border-radius: 0.5rem;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0;
        height: 3rem;
         margin-left: 10px; /* Espacio respecto al icono */
    }
    .notice-wrapper {
        padding: 0.5rem;
        height: 1.5rem;
        flex-grow: 1;
        overflow: hidden;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .notice {
        color: #00ff00;
        font-weight: bold;
        white-space: nowrap;
        text-align: center;
        opacity: 0;
        animation: fadeInOut 14s infinite;
    }
    @keyframes fadeInOut {
        0% { opacity: 0; }
        10% { opacity: 1; }
        90% { opacity: 1; }
        100% { opacity: 0; }
    }
    .notice-off-icon {
        width: auto;
        height: clamp(2rem, 5vw, 3rem);
        /* margin-right: 10px; */ /* Eliminado para alinear a la izquierda del contenedor */
        align-self: center;
        cursor: pointer;
        transition: filter 0.3s ease;
        flex-shrink: 0; /* Evita que el icono se encoja */
    }
    body.dark-mode .notice-off-icon {
        filter: brightness(85%);
    }
    .toggle-sign {
        position: fixed;
        width: 91px;
        height: 54px;
        border-radius: 20px;
        background-color: #668B8B;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 1.25rem;
        color: #E6E6DC;
        text-align: center;
        cursor: pointer;
        z-index: 1000;
        transition: background-color 0.2s ease, filter 0.2s ease;
        left: 10px;
    }
    .toggle-sign .sign {
        font-size: 1.5rem;
        margin-right: 2px;
        min-width: 12px; /* Asegura espacio para el signo */
        display: inline-block; /* Para que el min-width funcione */
        text-align: center;
    }
    .toggle-sign:hover {
        background-color: #D9A066;
    }
    .toggle-sign img {
        max-width: 80px;
        max-height: 48px;
        object-fit: contain;
    }
    body.dark-mode .toggle-sign#config-button {
        filter: brightness(85%);
    }
    body.dark-mode .toggle-sign#config-button img {
        filter: brightness(85%);
    }
    .toggle-image {
        position: fixed;
        width: 91px;
        height: 54px;
        cursor: pointer;
        z-index: 1000;
        transition: filter 0.2s ease;
    }
    .toggle-image:hover {
        filter: brightness(80%);
    }
    body.dark-mode .toggle-image#on-off-toggle {
        filter: brightness(85%);
    }
    #reminder-button {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        position: fixed;
        background-color: #668B8B; /* Color base */
    }
    #reminder-button img {
        max-width: 80px;
        max-height: 48px;
        object-fit: contain;
    }
    #reminder-button .reminder-count {
        position: absolute;
        top: 4px;
        left: 4px;
        font-size: 0.65rem;
        color: #FFFFFF; /* Color blanco para contraste */
        background-color: #EF4444; /* Fondo rojo para destacar */
        border-radius: 50%;
        width: 18px;
        height: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        box-shadow: 0 0 3px rgba(0,0,0,0.5);
    }
    .hidden {
        display: none !important; /* Asegura que se oculte */
        visibility: hidden;
        opacity: 0;
        pointer-events: none;
    }
    .footer-hidden {
        display: none !important;
    }
    body.dark-mode .bookmark-item {
        filter: brightness(60%);
    }
    body.dark-mode .bg-gray-50.border.border-dashed.border-gray-200.rounded-lg {
        filter: brightness(60%);
    }
    body.dark-mode .scroll-toggle-button {
        background-color: #5C5C47;
    }
    body.dark-mode .scroll-toggle-button:hover {
        background-color: #D9A066;
    }
    body.dark-mode .toggle-sign {
        background-color: #5C5C47;
    }
    body.dark-mode .toggle-sign:hover {
        background-color: #D9A066;
    }
    /* Estilo específico para botones toggle en dark mode según estado */
    body.dark-mode .toggle-sign.range-toggle[data-state="visible"] {
        background-color: #166534; /* Verde oscuro cuando visible */
    }
    body.dark-mode .toggle-sign.range-toggle[data-state="hidden"] {
        background-color: #4B5563; /* Gris oscuro cuando oculto */
    }
    /* Estilo específico para botones toggle en light mode según estado */
    body:not(.dark-mode) .toggle-sign.range-toggle[data-state="visible"] {
        background-color: #006400; /* Verde normal cuando visible */
    }
    body:not(.dark-mode) .toggle-sign.range-toggle[data-state="hidden"] {
        background-color: #696969; /* Gris normal cuando oculto */
    }

    body.dark-mode #reload-button {
        background-color: #0e7490; /* Cyan oscuro */
    }
    body:not(.dark-mode) #reload-button {
        background-color: #5DA8D6; /* Cyan claro */
    }

    body.dark-mode #home-button {
        background-color: #0e7490; /* Cyan oscuro */
    }
    body:not(.dark-mode) #home-button {
        background-color: #5DA8D6; /* Cyan claro */
    }

    body.dark-mode #weather-button {
        background-color: #b45309; /* Naranja oscuro */
    }
    body:not(.dark-mode) #weather-button {
         background-color: #FBBF24; /* Naranja claro */
    }

    body.dark-mode #zoom-button {
        background-color: #c2410c; /* Naranja más oscuro */
    }
    body:not(.dark-mode) #zoom-button {
        background-color: #F97316; /* Naranja brillante */
    }
    body.dark-mode #zoom-button.zoomed {
         background-color: #7c2d12; /* Naranja muy oscuro (zoomed) */
    }
    body:not(.dark-mode) #zoom-button.zoomed {
        background-color: #C2410C; /* Naranja oscuro (zoomed) */
    }

    body.dark-mode #reminder-button {
        background-color: #4DA7A7; /* Verde azulado oscuro */
    }
     body:not(.dark-mode) #reminder-button {
        background-color: #4DA7A7; /* Mantenemos el mismo color, o ajustar si se prefiere */
    }

    body.dark-mode #config-button {
        background-color: #92927E; /* Color base oscuro */
    }
     body:not(.dark-mode) #config-button {
         background-color: #ABAB99; /* Color base claro */
    }


    .minimal-mode {
        background-color: #ABAB99;
    }
    body.dark-mode.minimal-mode {
        background-color: #92927E;
    }
    .minimal-mode main,
    .minimal-mode .notices-icon-container, /* Oculta contenedor de avisos */
    .minimal-mode footer, /* Oculta footer completo */
    .minimal-mode .top-text-container,
    .minimal-mode .scroll-toggle-button,
    .minimal-mode .toggle-sign:not(#config-button), /* Mantiene config visible */
    .minimal-mode #reminder-notifications,
    .minimal-mode .counter-wrapper,
    .minimal-mode .notice-off-icon,
    .minimal-mode #dark-mode-toggle,
    .minimal-mode #zoom-button,
    .minimal-mode #reminder-button,
    .minimal-mode #weather-button,
    .minimal-mode #home-button,
    .minimal-mode #reload-button,
    .minimal-mode .range-toggle /* Oculta botones de filtro */
     {
        display: none !important;
    }
    .minimal-mode .header-container, /* Esto ya está dentro de footer, pero por si acaso */
    .minimal-mode .header-logo {
        display: none !important;
    }
    .minimal-mode #on-off-toggle {
        filter: none;
        opacity: 0.3;
    }
    .minimal-mode-message {
        color: #000000;
        font-size: 1rem;
        font-weight: bold;
        position: fixed;
        top: 70px;
        left: 10px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.7);
        padding: 5px;
        border-radius: 5px;
    }
    body.dark-mode .minimal-mode-message {
        color: #FFFFFF;
        background: rgba(0, 0, 0, 0.7);
    }

    .reminder-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #F3F4F6; /* Fondo claro por defecto */
        padding: 1.5rem;
        border-radius: 0.5rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 2000;
        max-width: 400px;
        width: 90%;
        color: #111827; /* Texto oscuro */
    }
    body.dark-mode .reminder-modal {
        background-color: #4B5563; /* Fondo gris oscuro */
        color: #F3F4F6; /* Texto claro */
    }

    .reminder-modal h2 {
        font-size: 1.25rem;
        font-weight: bold;
        margin-bottom: 1rem;
         /* El color se hereda de .reminder-modal */
    }
    .reminder-modal label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: 500;
    }
    .reminder-modal input,
    .reminder-modal textarea {
        width: 100%;
        padding: 0.5rem;
        margin-bottom: 1rem;
        border: 1px solid #D1D5DB;
        border-radius: 0.25rem;
        background-color: #FFFFFF; /* Fondo blanco input */
        color: #111827; /* Texto negro input */
        box-sizing: border-box; /* Incluye padding en el width */
    }
     body.dark-mode .reminder-modal input,
     body.dark-mode .reminder-modal textarea {
         background-color: #6B7280; /* Fondo gris input */
         color: #F3F4F6; /* Texto blanco input */
         border-color: #9CA3AF;
     }

    .reminder-modal .button-group {
        display: flex;
        justify-content: flex-end;
        gap: 1rem;
    }
    .reminder-modal button {
        padding: 0.5rem 1rem;
        border-radius: 0.25rem;
        cursor: pointer;
        border: none; /* Quita borde por defecto */
    }
    .reminder-modal button[type="submit"] {
        background-color: #2563EB; /* Azul */
        color: #FFFFFF;
    }
     body.dark-mode .reminder-modal button[type="submit"] {
        background-color: #3B82F6; /* Azul más claro */
    }
    .reminder-modal button[type="button"] {
        background-color: #D1D5DB; /* Gris claro */
        color: #111827;
    }
     body.dark-mode .reminder-modal button[type="button"] {
        background-color: #4B5563; /* Gris oscuro */
        color: #F3F4F6;
    }
    .reminder-modal button.delete-reminder {
        background-color: #EF4444; /* Rojo */
        color: #FFFFFF;
        margin-left: 0.5rem;
        padding: 0.25rem 0.5rem;
    }
     body.dark-mode .reminder-modal button.delete-reminder {
         background-color: #DC2626; /* Rojo más oscuro */
     }
     .reminder-modal button.modify-reminder {
        background-color: #10B981; /* Verde */
        color: #FFFFFF;
        margin-left: 0.5rem;
        padding: 0.25rem 0.5rem;
    }
     body.dark-mode .reminder-modal button.modify-reminder {
        background-color: #059669; /* Verde más oscuro */
    }


    #reminder-notifications {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1500;
        max-width: 300px;
        width: 90%;
    }
    .reminder-notification {
        background-color: #FFFF99; /* Amarillo claro */
        padding: 1rem;
        margin-bottom: 0.5rem;
        border-radius: 0.25rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        color: #333; /* Texto oscuro por defecto */
    }
     body.dark-mode .reminder-notification {
        background-color: #FDE047; /* Amarillo más intenso */
        color: #1F2937; /* Texto más oscuro para contraste */
    }
     body.dark-mode .reminder-notification.dark-mode { /* Asegura aplicación en dark mode */
        background-color: #FDE047;
        color: #1F2937;
     }


    .reminder-notification p {
        margin: 0;
        font-size: 1rem; /* Ajustado */
        color: #1E40AF; /* Azul para texto principal */
    }
    body.dark-mode .reminder-notification p {
        color: #172554; /* Azul muy oscuro */
    }

    .reminder-notification .button-group {
        display: flex;
        justify-content: flex-end;
        gap: 0.5rem;
        margin-top: 0.5rem; /* Espacio arriba */
    }
    .reminder-notification button {
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
        cursor: pointer;
        font-size: 0.8rem; /* Más pequeño */
        border: none;
        color: #FFFFFF; /* Texto blanco por defecto para botones */
    }
    .reminder-notification button.cancel {
        background-color: #EF4444; /* Rojo */
    }
    .reminder-notification button.modify {
        background-color: #10B981; /* Verde */
    }
    .reminder-notification button.postpone {
        background-color: #F59E0B; /* Naranja */
    }
     body.dark-mode .reminder-notification button.cancel { background-color: #DC2626; }
     body.dark-mode .reminder-notification button.modify { background-color: #059669; }
     body.dark-mode .reminder-notification button.postpone { background-color: #D97706; }

    .counter-wrapper {
        margin: 0.5rem auto 0 60px; /* Ajustado para margen izquierdo */
        text-align: center;
        max-width: 984px;
        width: calc(100% - 60px); /* Ajusta ancho restando margen */
        display: block;
        opacity: 0.5;
    }

/* --- Estilos para el Modo Configuración --- */
body.config-mode {
    /* No oscurecer el fondo globalmente para ver bien el grid */
}

.config-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7); /* Fondo semitransparente */
    z-index: 2500;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    color: white;
}

.config-modal {
    background-color: #ABAB99; /* Color base claro */
    padding: 2rem;
    border-radius: 0.75rem;
    box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
    max-width: 90%;
    max-height: 90vh;
    overflow-y: auto;
    text-align: center;
    color: #333; /* Texto oscuro por defecto */
}
body.dark-mode .config-modal {
    background-color: #92927E; /* Color base oscuro */
    color: #E6E6DC; /* Texto claro */
}

.config-modal h2 {
    /* El color se hereda */
    margin-bottom: 1.5rem;
    font-size: 1.5rem;
    font-weight: bold;
}
.config-modal p {
    margin-bottom: 1rem;
}

.config-modal button, .config-modal .config-toggle-button {
    background-color: #668B8B; /* Botón normal claro */
    color: #E6E6DC;
    padding: 0.75rem 1.25rem; /* Un poco más grandes */
    border: none;
    border-radius: 0.375rem;
    cursor: pointer;
    margin: 0.5rem;
    transition: background-color 0.2s ease;
    font-size: 1rem;
}
.config-modal button:hover, .config-modal .config-toggle-button:hover {
    background-color: #D9A066; /* Hover claro */
}
body.dark-mode .config-modal button, body.dark-mode .config-modal .config-toggle-button {
     background-color: #5C5C47; /* Botón normal oscuro */
}
body.dark-mode .config-modal button:hover, body.dark-mode .config-modal .config-toggle-button:hover {
    background-color: #D9A066; /* Hover oscuro (mismo color) */
}
.config-modal .cancel-button {
    background-color: #EF4444; /* Rojo claro */
}
body.dark-mode .config-modal .cancel-button {
    background-color: #B91C1C; /* Rojo oscuro */
}
.config-modal .save-button { /* Estilo para botón Guardar */
    background-color: #10B981; /* Verde claro */
}
body.dark-mode .config-modal .save-button {
    background-color: #059669; /* Verde oscuro */
}


/* Estilos para la selección de items del grid */
body.selecting-items-mode #bookmark-grid {
    border: 3px dashed #D9A066 !important; /* Borde naranja para indicar modo selección */
    /* padding: 10px; */ /* Puede causar problemas de layout */
    background-color: rgba(217, 160, 102, 0.1); /* Fondo ligero naranja */
    position: relative; /* Asegura que el overlay de config esté encima */
    z-index: 1; /* Debajo del modal */
}

body.selecting-items-mode #bookmark-grid > div {
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.3s ease, border-color 0.2s ease;
    opacity: 0.6; /* Atenúa los no seleccionables o no seleccionados */
    border-width: 2px;
    border-style: solid;
    border-color: transparent; /* Borde inicial transparente */
}
body.dark-mode.selecting-items-mode #bookmark-grid > div {
     opacity: 0.5;
}

body.selecting-items-mode #bookmark-grid > div:not(.config-empty-cell):hover {
     transform: scale(1.05);
     opacity: 0.8;
}
body.dark-mode.selecting-items-mode #bookmark-grid > div:not(.config-empty-cell):hover {
     opacity: 0.7;
}

body.selecting-items-mode #bookmark-grid > div.config-selected {
    opacity: 1 !important; /* Siempre visible si está seleccionado */
    border-color: #2563EB !important; /* Borde azul para seleccionados */
    box-shadow: 0 0 10px rgba(37, 99, 235, 0.7);
    transform: scale(1.02); /* Ligero realce */
}
body.dark-mode.selecting-items-mode #bookmark-grid > div.config-selected {
     border-color: #60A5FA !important; /* Borde azul claro en modo oscuro */
     box-shadow: 0 0 10px rgba(96, 165, 250, 0.7);
}

body.selecting-items-mode #bookmark-grid > div.config-empty-cell {
     opacity: 0.2 !important; /* Muy atenuado si está vacío */
     cursor: not-allowed;
     background-color: rgba(128, 128, 128, 0.3) !important; /* Fondo grisáceo, importante para sobreescribir */
}
body.dark-mode.selecting-items-mode #bookmark-grid > div.config-empty-cell {
     background-color: rgba(0, 0, 0, 0.3) !important; /* Fondo más oscuro */
}


/* Oculta botones laterales en modo configuración */
body.config-mode .scroll-toggle-button,
body.config-mode .toggle-image:not(#dark-mode-toggle), /* Permite cambiar dark mode */
body.config-mode .toggle-sign:not(#config-button), /* Permite usar el de config */
body.config-mode #reminder-notifications,
body.config-mode .top-text-container /* Oculta también el texto superior */
{
    display: none !important;
    visibility: hidden;
}
body.config-mode #dark-mode-toggle {
    z-index: 2600; /* Asegura que esté sobre el overlay */
}


</style>
</head>
<body class="min-h-screen bg-[#ABAB99] flex flex-col items-center p-6">
    <!-- Contenedor de Texto Superior (se oculta en modo config) -->
    <div class="top-text-container">
        <div class="arrow-button" id="back-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
        </div>
        <span>[ Web anterior o posterior arrastre hacia los bordes ]</span>
        <div class="arrow-button" id="forward-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14M12 5l7 7-7 7"/></svg>
        </div>
    </div>

    <!-- Contenido Principal -->
    <main>
        <div id="bookmark-grid">
            <!-- Grid populated by JavaScript -->
        </div>
    </main>

     <!-- Avisos y Footer (se ocultan si isActive o isFooterVisible son false) -->
    <div class="notices-icon-container">
        <img src="https://boardinggate.github.io/Tesla/IMG_4194.jpg" alt="Toggle Avisos" class="notice-off-icon" id="notice-toggle-icon">
        <div class="notices-container">
            <div class="notice-wrapper">
                <span class="notice" id="current-notice"></span>
            </div>
        </div>
    </div>

    <footer>
        <div class="footer-content">
            <div class="header-container">
                <img src="https://boardinggate.github.io/Tesla/LOGOTESLA.jpg" class="header-logo">
                <div class="title-container">
                    <h1 class="text-2xl font-bold inline">
                        <span class="text-2xl">BoardingGate</span>
                        <span class="text-base">Lanzador</span>
                        <span id="version" class="version-text"></span>
                    </h1>
                </div>
            </div>
            <div class="footer-line">
                <a href="https://x.com/boardinggate?s=21" class="footer-link-green" target="_blank" rel="noopener noreferrer">@BoardingGate</a>
                <span class="text-green-200" style="font-size: 1.5rem;">🤝</span>
                <a href="https://x.com/boardinggate/status/1857325553742721116?s=46" class="footer-link-green" target="_blank" rel="noopener noreferrer">Ahorremos un dinero con mis REFERIDOS</a>
            </div>
            <p class="footer-subtext">La inteligencia tiene ciertas limitaciones. La locura, casi ninguna 🫶 🤟</p>
        </div>
    </footer>

    <!-- Contador (se oculta en modo minimal) -->
    <div class="counter-wrapper">
        <div class="counter-container">
            <div id="sfcg896pbr68y2dejczgbn1ys664xjxdf2d"></div>
            <script type="text/javascript" src="https://counter4.optistats.ovh/private/counter.js?c=g896pbr68y2dejczgbn1ys664xjxdf2d&down=async" async></script>
        </div>
    </div>

     <!-- Botones Laterales (se gestionan y posicionan con JS) -->
    <div id="scroll-toggle" class="scroll-toggle-button" title="Ir al inicio o fin">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M19 12l-7 7-7-7"/></svg>
    </div>
    <!-- El resto de botones se crean dinámicamente con JS -->

    <!-- Contenedor para Notificaciones de Recordatorios -->
    <div id="reminder-notifications"></div>

    <!-- Script Principal -->
    <script>
        const bookmarks = [
            { name: "YouTube", url: "https://www.youtube.com" },
            { name: "Google", url: "https://www.google.com" },
            { name: "GDrive", url: "https://drive.google.com", favicon: "./IMG_4172.png" },
            { name: "GMail", url: "https://mail.google.com/mail/mu/mp/603/#tl/Recibidos", favicon: "./IMG_4171.png"},
            { name: "Google Fotos", url: "https://photos.google.com" },
            { name: "iCloud", url: "https://www.icloud.com/", favicon: "https://www.google.com/s2/favicons?domain=icloud.com&sz=64" },
            { name: "ABRP", url: "https://abetterrouteplanner.com" },
            { name: "ElectroMaps", url: "https://map.electromaps.com/es/", favicon: "https://www.google.com/s2/favicons?domain=electromaps.com&sz=64" },
            { name: "REVE PdR España", url: "https://www.mapareve.es/mapa-puntos-recarga", favicon: "https://www.google.com/s2/favicons?domain=mapareve.es&sz=64" },
            { name: "PdR,s", url: "https://www.google.com/maps/search/puntos+recarga+veh%C3%ADculos+el%C3%A9ctricos", favicon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 18h8v2h-8v-2z'/><path d='M12 14h8v2h-8v-2z'/><path d='M12 10h8v2h-8v-2z'/><path d='M12 6h8v2h-8V6z'/><path d='M4 18h4v-2H4v2zM4 14h4v-2H4v2zM4 10h4v-2H4v2zM4 6h4V4H4v2z'/></svg>" },
            { name: "Google Maps", url: "https://maps.google.com" },
            { name: "", url: "https://www.ventusky.com/?p=40.2;-4.7;5&l=rain-3h" }, // Ventusky (sin nombre)
            { name: "TESSIE", url: "https://dash.tessie.com/signin", favicon: "https://www.google.com/s2/favicons?domain=tessie.com&sz=64" },
            { name: "Mis Updates", url: "https://dash.tessie.com/software", favicon: "https://cdn-icons-png.flaticon.com/512/148/148767.png" },
            { name: "Olas Updates", url: "https://es.stats.tessie.com/", favicon: "https://cdn-icons-png.flaticon.com/512/5815/5815902.png" },
            { name: "NotaTeslaApp", url: "https://www.notateslaapp.com/software-updates/" },
            { name: "ENHAUTO", url: "https://www.enhauto.com" },
            { name: "MAREAS", url: "https://www.meteogalicia.gal/web/predicion/mareas-e-luas" },
            { name: "ELECTROVERSE", url: "https://electroverse.com/es/map", favicon: "https://www.google.com/s2/favicons?domain=electroverse.com&sz=64" }, // ÍNDICE 18
            { name: "ACCIONA", url: "https://www.google.com/maps/search/recarga+Acciona", favicon: "https://www.google.com/s2/favicons?domain=acciona.com&sz=64" },
            { name: "IBERDROLA", url: "https://www.google.com/maps/search/recarga+IBERDROLA", favicon: "https://www.google.com/s2/favicons?domain=iberdrola.com&sz=64" },
            { name: "WAYLET Repsol", url: "https://www.google.com/maps/search/recarga+REPSOL+Waylet", favicon: "https://www.google.com/s2/favicons?domain=repsol.com&sz=64" },
            { name: "ENDESA xWay", url: "https://www.google.com/maps/search/recarga+ENDESA+XWAY", favicon: "https://www.google.com/s2/favicons?domain=endesa.com&sz=64" },
            { name: "ZUNDER", url: "https://www.google.com/maps/search/recarga+ZUNDER", favicon: "https://www.google.com/s2/favicons?domain=zunder.com&sz=64" },
            { name: "IONITY", url: "https://www.google.com/maps/search/recarga+IONITY", favicon: "https://www.google.com/s2/favicons?domain=ionity.eu&sz=64" },
            { name: "WENEA", url: "https://www.google.com/maps/search/recarga+WENEA", favicon: "https://www.google.com/s2/favicons?domain=wenea.com&sz=64" },
            { name: "T.ENERGIES", url: "https://www.google.com/maps/search/recarga+TOTAL+ENERGIES", favicon: "https://www.google.com/s2/favicons?domain=totalenergies.com&sz=64" },
            { name: "GALP", url: "https://www.google.com/maps/search/recarga+GALP", favicon: "https://www.google.com/s2/favicons?domain=galp.com&sz=64" },
            { name: "MIIO", url: "https://miio.com", favicon: "https://www.google.com/s2/favicons?domain=miio.com&sz=64" }, // ÍNDICE 29
            { name: "EVDC", url: "https://evdc.network", favicon: "https://www.google.com/s2/favicons?domain=evdc.network&sz=64" }, // ÍNDICE 30
            { name: "GROK", url: "https://grok.com/?referrer=website" },
            { name: "CHATGPT", url: "https://chat.openai.com" },
            { name: "CLAUDE", url: "https://claude.ai/new" },
            { name: "GEMINI", url: "https://gemini.google.com" },
            { name: "NOTEBOOKLM", url: "https://notebooklm.google.com" }, // ÍNDICE 35
            { name: "Batería", url: "https://docs.google.com/spreadsheets/d/1bLZmgVGTBqg2bS2E45JpORjs9eK2nb05AWXYLLDY-RI/edit?gid=1398548891#gid=1398548891", favicon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='10'/><polyline points='12 6 12 12 16 14'/></svg>" },
             null, null, null, null, null, // ÍNDICE 41
            { name: "TeslaParaTodos", url: "https://teslaparatodos.com/cine/" }, // ÍNDICE 42
            { name: "BetterTheater", url: "https://abettertheater.com", favicon: "https://www.google.com/s2/favicons?domain=abettertheater.com&sz=64" },
            { name: "Filmin", url: "https://www.filmin.es/catalogo/peliculas" },
            { name: "Octopus", url: "https://octopus.energy/dashboard" },
            { name: "App MCE", url: "https://www.oscarabilleira.com/app-mi-coche-electrico/#ayuda" },
            { name: "Patrón Luz", url: "https://docs.google.com/spreadsheets/d/1R7UUZ9i4BAYWAGAX6PQT1WGd12GEZ4Ja/edit?usp=sharing&ouid=108345701896498198132&rtpof=true&sd=true" },
            { name: "TradingView", url: "https://es.tradingview.com/chart/t5g9UFG0/" },
            { name: "Inicio Tesla" }, // Placeholder, sin URL
            { name: "Twitter", url: "https://x.com" },
            { name: "Maesal Detailer", url: "https://www.maesaldetailer.es/" },
            { name: "Superchargers", url: "https://www.tesla.com/es_es/findus?bounds=45.41107111786193%2C19.27853056943938%2C29.703668286784747%2C-16.64676239931062" },
            { name: "TESLA web", url: "https://www.tesla.com/es_es" },
            { name: "Manual M3", url: "https://www.tesla.com/ownersmanual/model3/es_es/" },
            { name: "de Servicio", url: "https://service.tesla.com/docs/Model3/ServiceManual/2024/es-es/" },
            { name: "de Despiece", url: "https://epc.tesla.com/es-MX/catalogs/e0e07c3d-272f-4d06-b8b6-9e92f857e5f3" },
            { name: "de Usted Mismo", url: "https://www.tesla.com/es_es/support/do-it-yourself-guides" },
            { name: "de Filtro Cabina", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-DB0A1E3C-926E-498C-A2FD-A27B8421A471.html" }, // ÍNDICE 59
            { name: "de Móvil remoto", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-53651B16-A2E3-4118-933E-B5F41C74D433.html" }, // ÍNDICE 60
            { name: "Waze (consultas)", url: "https://www.waze.com/es/live-map/", favicon: "https://www.google.com/s2/favicons?domain=waze.com&sz=64" },
            { name: "AMAZON", url: "https://www.amazon.es" },
            { name: "BIP&DRIVE", url: "https://areaprivada.bipdrive.com/login" },
            { name: "ITV Cita", url: "https://www.sycitv.com/es/cita-previa-particulares/", favicon: "https://boardinggate.github.io/Tesla/itv.png" },
            null, null,
            { name: "Jaime Odena", url: "https://www.youtube.com/@JOdena", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "Eduardo Arcos", url: "https://www.youtube.com/@earcos", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "AutoIngenium", url: "https://www.youtube.com/@AutoIngenium", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "Gallego en Munich", url: "https://www.youtube.com/@ungallegoenmunich", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "Electromiaumiau", url: "https://www.youtube.com/@electromiaumiau", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "Manuel Martos", url: "https://www.youtube.com/@Manuel_Martos", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "Todos Electricos", url: "https://www.youtube.com/@TodosElectricos", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "Juan Vidal Haces", url: "https://www.youtube.com/@JuanVidalHaces", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "Ruedana", url: "https://www.youtube.com/@ruedana", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "STR-600", url: "https://www.youtube.com/@STR-600", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "Juanjo T. Aventuras", url: "https://www.youtube.com/@juanjoteslaventuras", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "Carlos Cuezva", url: "https://www.youtube.com/@CarlosCuezva", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "Javi Manzanoo", url: "https://www.youtube.com/@javimanzanoo", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "Crifedi", url: "https://www.youtube.com/@Crifedi", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "Tescno Tesla", url: "https://www.youtube.com/@TecnoTesla", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "Full Electric Mex", url: "https://www.youtube.com/@FullElectricMexico", favicon: "https://www.youtube.com/favicon.ico" },
            null,
            null,
            { name: "La iA Jon", url: "https://www.youtube.com/@la_inteligencia_artificial", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "JF Ccalero", url: "https://www.youtube.com/@jfcalero", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "Visual Politik", url: "https://www.youtube.com/@VisualPolitik", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "Fabian Barrio", url: "https://www.youtube.com/@fabiancbarrio", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "Loquetudigas", url: "https://www.youtube.com/@Loquetudigas", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "David Antunes", url: "https://www.youtube.com/@davidantunesmusic", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "TheWildProject", url: "https://www.youtube.com/@TheWildProject", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "Estas Tonne", url: "https://www.youtube.com/@Estastonne", favicon: "https://www.youtube.com/favicon.ico" },
            { name: "BBC6 Music", url: "https://www.youtube.com/@BBC6Music", favicon: "https://www.youtube.com/favicon.ico" }, // ÍNDICE 94
            null // ÍNDICE 95
        ];
        const TOTAL_CELLS = 96;
        const COLS = 6;
        const grid = document.getElementById('bookmark-grid');
        let isDarkMode = false;
        let isMinimalMode = false;
        let pressStartTime = null;
        let reminderPressStartTime = null;
        let isActive = true; // Para avisos
        let isFooterVisible = true; // Para el footer
        let notices = [];
        let currentNoticeIndex = 0;
        const cellElements = []; // Array para guardar las celdas del grid
        let createdToggleButtons = []; // Array para guardar los botones toggle creados

        // --- Variables para Configuración ---
        let customToggleConfigs = {}; // Objeto para guardar las configuraciones personalizadas { toggleId: { label: 'xxx', itemIndices: [y,z,...] } }
        let isConfigMode = false;     // Flag para saber si estamos en modo configuración
        let currentConfiguringToggle = null; // Qué toggle (por ID) estamos configurando
        let currentConfigIndices = []; // Índices seleccionados temporalmente durante la config

        // --- Definición de los Toggles Personalizables ---
        const toggleRanges = [
            // ID único, rango original (para default), etiqueta default
            { id: "toggle-pdr", start: 18, end: 29, defaultLabel: "PdR,s" },
            { id: "toggle-ias", start: 30, end: 41, defaultLabel: "iAs" },
            { id: "toggle-util", start: 42, end: 59, defaultLabel: "Útil" },
            { id: "toggle-varios", start: 60, end: 95, defaultLabel: "Varios" }
        ];

        // --- Funciones Auxiliares ---
        function clamp(min, val, max) {
            return Math.min(Math.max(val, min), max);
        }

        // --- Funciones de Carga/Guardado de Ajustes ---

        function loadCustomToggleConfigs() {
            const savedConfigs = localStorage.getItem('customToggleConfigs');
            if (savedConfigs) {
                try {
                    customToggleConfigs = JSON.parse(savedConfigs);
                    if (typeof customToggleConfigs !== 'object' || customToggleConfigs === null) {
                         customToggleConfigs = {};
                    }
                } catch (e) {
                    console.error("Error parsing customToggleConfigs from localStorage", e);
                    customToggleConfigs = {};
                }
            } else {
                customToggleConfigs = {};
            }
             console.log("Loaded custom toggle configs:", JSON.stringify(customToggleConfigs));
        }

        function saveCustomToggleConfigs() {
            localStorage.setItem('customToggleConfigs', JSON.stringify(customToggleConfigs));
             console.log("Saved custom toggle configs:", JSON.stringify(customToggleConfigs));
        }

        function saveSettings() {
            localStorage.setItem('darkMode', JSON.stringify(isDarkMode));
            localStorage.setItem('minimalMode', JSON.stringify(isMinimalMode));

            const toggleStates = {};
             // Usamos los botones creados para asegurar que capturamos el estado correcto
             createdToggleButtons.forEach(toggle => {
                 if (toggle.dataset.toggleId) { // Asegura que es un botón de filtro configurable
                     toggleStates[toggle.dataset.toggleId] = toggle.dataset.state;
                 }
            });
            localStorage.setItem('toggleStates', JSON.stringify(toggleStates));

            const zoomButton = document.getElementById('zoom-button');
            if (zoomButton) localStorage.setItem('zoomState', zoomButton.dataset.zoomState);

            const onOffToggle = document.getElementById('on-off-toggle');
            if(onOffToggle) localStorage.setItem('onOffState', onOffToggle.dataset.state);

            localStorage.setItem('noticesActive', JSON.stringify(isActive));
            localStorage.setItem('footerVisible', JSON.stringify(isFooterVisible));
        }

        function loadSavedSettings() {
            const savedDarkMode = localStorage.getItem('darkMode');
            isDarkMode = savedDarkMode ? JSON.parse(savedDarkMode) : checkDarkModeTime();
            if (isDarkMode) {
                document.body.classList.add('dark-mode');
            }

            const savedMinimalMode = localStorage.getItem('minimalMode');
            isMinimalMode = savedMinimalMode ? JSON.parse(savedMinimalMode) : false;

            // Cargar configuraciones de toggle personalizadas ANTES de aplicar estados
            loadCustomToggleConfigs();

            // Estado de Zoom
            const savedZoomState = localStorage.getItem('zoomState');
            const zoomButton = document.getElementById('zoom-button'); // Buscar el botón
             if (zoomButton) { // Comprobar si existe
                zoomButton.dataset.zoomState = savedZoomState || 'off'; // Default a 'off'
                applyZoom(zoomButton.dataset.zoomState);
            }


            // Esperar un ciclo para asegurar que los botones toggle existen
            setTimeout(() => {
                 console.log("Applying saved settings...");
                const savedToggleStates = localStorage.getItem('toggleStates');
                const savedOnOffState = localStorage.getItem('onOffState');
                const savedNoticesActive = localStorage.getItem('noticesActive');
                const savedFooterVisible = localStorage.getItem('footerVisible');
                const onOffToggle = document.getElementById('on-off-toggle');

                // Aplicar estados guardados a los botones toggle
                if (savedToggleStates) {
                    try {
                        const toggleStates = JSON.parse(savedToggleStates);
                         console.log("Loaded toggle states:", toggleStates);
                         createdToggleButtons.forEach(toggle => {
                            const toggleId = toggle.dataset.toggleId;
                            if (toggleId && toggleStates[toggleId]) {
                                toggle.dataset.state = toggleStates[toggleId];
                                 console.log(`Setting state for ${toggleId} to ${toggleStates[toggleId]}`);
                            }
                             // Aplicar configuración (label, indices) Y visibilidad inicial basada en el estado
                            applyToggleConfiguration(toggleId);
                        });
                    } catch(e) {
                        console.error("Error parsing toggleStates", e);
                         // Si hay error, aplicar config por defecto a todos
                         createdToggleButtons.forEach(toggle => applyToggleConfiguration(toggle.dataset.toggleId));
                    }
                } else {
                    // Si no hay estados guardados, aplicar config inicial (default o custom) a todos
                     console.log("No saved toggle states found, applying initial config.");
                     createdToggleButtons.forEach(toggle => applyToggleConfiguration(toggle.dataset.toggleId));
                }


                if (savedOnOffState && onOffToggle) {
                    onOffToggle.dataset.state = savedOnOffState;
                     // No llamar a updateAllToggles aquí, el estado ya se aplicó individualmente
                }

                // Aplicar estado de avisos y footer
                isActive = savedNoticesActive ? JSON.parse(savedNoticesActive) : true;
                isFooterVisible = savedFooterVisible ? JSON.parse(savedFooterVisible) : true;

                if (isMinimalMode) {
                    toggleMinimalMode(true); // Activa modo minimal (oculta cosas)
                } else {
                    // Asegura visibilidad correcta de footer/avisos si no es minimal
                    toggleFooterVisibility();
                }

                updateButtonStyles(); // Aplica estilos visuales finales
                loadReminders();      // Carga recordatorios
                adjustButtonPositions(); // Ajusta posiciones finales
                 console.log("Finished applying saved settings.");
            }, 0); // Fin de setTimeout
        }


        // --- Lógica del Modo Minimal ---
        function toggleMinimalMode(enable) {
            if (enable) {
                document.body.classList.add('minimal-mode');
                const message = document.createElement('div');
                message.id = 'minimal-mode-message';
                message.className = 'minimal-mode-message';
                message.textContent = 'Pulse ON/OFF 2 seg. para reactivar'; // Instrucción más clara
                document.body.appendChild(message);
                 // Oculta elementos específicos del modo minimal
                toggleFooterVisibility(); // Asegura que footer/avisos se oculten
            } else {
                document.body.classList.remove('minimal-mode');
                const message = document.getElementById('minimal-mode-message');
                if (message) message.remove();
                 // Restaura visibilidad normal (footer/avisos dependerá de sus flags)
                toggleFooterVisibility();
                 // Reajusta y actualiza todo
                adjustButtonPositions();
                updateButtonStyles();
            }
            saveSettings();
        }

        // --- Lógica de Zoom ---
        function applyZoom(state) {
            const originalWidth = 984;
            const adjustedWidth = 935;
            const originalCols = 6;
            const zoomedCols = 4;
            const gap = 15;
            const originalCellWidthPx = (originalWidth - (originalCols - 1) * gap) / originalCols;
            const zoomedCellWidthPx = (adjustedWidth - (zoomedCols - 1) * gap) / zoomedCols;

            const zoomButton = document.getElementById('zoom-button');
            if (!zoomButton) return; // Salir si el botón no existe aún

             // Selecciona todas las celdas (divs directos dentro del grid)
             const gridCells = document.querySelectorAll('#bookmark-grid > div');
             const bookmarkItems = document.querySelectorAll('.bookmark-item'); // Contenido dentro de la celda
             const bookmarkImages = document.querySelectorAll('.bookmark-item img');
             const bookmarkNames = document.querySelectorAll('.bookmark-name');
             const smallBookmarkImages = document.querySelectorAll('.small-bookmark img');
             const smallBookmarkNames = document.querySelectorAll('.small-bookmark .bookmark-name');

            if (state === 'on') {
                grid.style.gridTemplateColumns = `repeat(${zoomedCols}, ${zoomedCellWidthPx}px)`;
                grid.style.maxWidth = `${adjustedWidth}px`;
                gridCells.forEach(cell => {
                    // Ajusta el aspect ratio directamente en la celda contenedora
                    cell.style.aspectRatio = '16 / 9'; // Mantener proporción
                });
                // Ajustar tamaño de imágenes y texto DENTRO de .bookmark-item
                bookmarkImages.forEach(img => {
                    img.style.width = '48px';
                    img.style.maxWidth = '56px';
                });
                bookmarkNames.forEach(name => {
                    name.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)';
                });
                 smallBookmarkImages.forEach(img => {
                    img.style.width = '48px'; // Mismo tamaño grande
                    img.style.maxWidth = '56px';
                });
                smallBookmarkNames.forEach(name => {
                    name.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)'; // Mismo tamaño grande
                });
                zoomButton.innerHTML = `<img src="./zoon+.png" alt="Zoom In" class="max-w-[80px] max-h-[48px] object-contain">`;
                zoomButton.classList.add('zoomed');
            } else { // state === 'off'
                grid.style.gridTemplateColumns = `repeat(${originalCols}, minmax(120px, 1fr))`;
                grid.style.maxWidth = `${originalWidth}px`;
                 gridCells.forEach(cell => {
                    cell.style.aspectRatio = '16 / 9'; // Mantener proporción
                });
                 // Restaurar tamaño original
                 bookmarkImages.forEach(img => {
                    img.style.width = '36px';
                    img.style.maxWidth = '40px';
                });
                bookmarkNames.forEach(name => {
                    name.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)';
                });
                smallBookmarkImages.forEach(img => {
                    img.style.width = '24px'; // Tamaño pequeño original
                    img.style.maxWidth = '28px';
                });
                smallBookmarkNames.forEach(name => {
                    name.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)'; // Tamaño pequeño original
                });
                zoomButton.innerHTML = `<img src="./zoon-.png" alt="Zoom Out" class="max-w-[80px] max-h-[48px] object-contain">`;
                zoomButton.classList.remove('zoomed');
            }
        }

        // --- Estilos de Botones y Versión ---
        function updateButtonStyles() {
            const darkModeToggle = document.getElementById('dark-mode-toggle');
            const onOffToggle = document.getElementById('on-off-toggle');
            const reloadButton = document.getElementById('reload-button');
            const homeButton = document.getElementById('home-button');
            const weatherButton = document.getElementById('weather-button');
            const zoomButton = document.getElementById('zoom-button');
            const reminderButton = document.getElementById('reminder-button');
            const configButton = document.getElementById('config-button');
            const allToggleButtons = document.querySelectorAll('.range-toggle'); // Botones de filtro

            // Actualizar imágenes on/off y dark/light si existen
            if (onOffToggle) {
                onOffToggle.src = `https://boardinggate.github.io/Tesla/${
                    onOffToggle.dataset.state === 'on' ? 'IMG_4192.jpg' : 'IMG_4191.jpg'
                }`;
                onOffToggle.alt = `Toggle ${onOffToggle.dataset.state === 'on' ? 'On' : 'Off'}`;
            }
            if (darkModeToggle) {
                 darkModeToggle.src = `https://boardinggate.github.io/Tesla/${
                    isDarkMode ? 'IMG_4189.jpg' : 'IMG_4190.jpg'
                }`;
                darkModeToggle.alt = `Toggle ${isDarkMode ? 'Oscuro' : 'Claro'}`;
            }

            // Actualizar contador de recordatorios si existe
            if (reminderButton) {
                const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const pendingCount = reminders.length; // Simplemente contamos todos por ahora
                let countElement = reminderButton.querySelector('.reminder-count'); // Re-seleccionar por si se recreó
                if (pendingCount > 0) {
                     if(countElement) {
                         countElement.textContent = pendingCount;
                         countElement.style.display = 'flex'; // Asegura que sea visible
                     } else {
                         // Crear si no existe
                        const newCount = document.createElement('span');
                        newCount.className = 'reminder-count';
                        newCount.textContent = pendingCount;
                        reminderButton.appendChild(newCount);
                        countElement = newCount; // Actualizar referencia
                     }
                } else {
                    if (countElement) {
                        countElement.style.display = 'none'; // Ocultar si es 0
                    }
                }
                // El color base del botón Reminder se establece en CSS
            }

             // Aplicar estilos base (hover se maneja en CSS)
             // Los colores específicos por estado (visible/hidden) o modo (dark/light)
             // también se gestionan principalmente en CSS usando selectores de atributos.
             // Esta función principalmente asegura que las clases/estados base estén correctos.
            if(zoomButton) {
                zoomButton.classList.toggle('zoomed', zoomButton.dataset.zoomState === 'on');
            }

            // Nota: Los colores de fondo de los botones se definen en CSS
            // basados en el modo (dark/light) y el estado (data-state, .zoomed).
            // No es necesario establecerlos explícitamente aquí a menos que haya lógica compleja.
        }

        function formatVersionDate(date) {
            if (!date || isNaN(date.getTime())) {
                 console.error("Invalid date provided to formatVersionDate");
                 return "?.?.?"; // Valor por defecto o indicativo de error
            }
            const year = date.getUTCFullYear().toString().slice(-2);
            const month = String(date.getUTCMonth() + 1).padStart(2, '0');
            const day = String(date.getUTCDate()).padStart(2, '0');
            const hours = String(date.getUTCHours()).padStart(2, '0');
            return `${year}.${month}.${day}${hours}`;
        }

        async function getLastModifiedDate() {
            const cacheKey = 'teslaHtmlLastModified';
            const cacheTimestampKey = 'teslaHtmlLastModifiedTimestamp';
            const cacheDuration = 1 * 60 * 60 * 1000; // Reducido a 1 hora para actualizaciones más frecuentes

            const cachedDate = localStorage.getItem(cacheKey);
            const cachedTimestamp = localStorage.getItem(cacheTimestampKey);
            const now = new Date().getTime();

            if (cachedDate && cachedTimestamp && now - parseInt(cachedTimestamp) < cacheDuration) {
                console.log("Using cached version date:", cachedDate);
                return new Date(cachedDate);
            }

            try {
                 console.log("Fetching version.txt...");
                const response = await fetch('https://boardinggate.github.io/Tesla/version.txt', {
                    cache: 'no-cache', // Siempre busca la última versión del txt
                    headers: {
                        'Cache-Control': 'no-cache',
                        'Pragma': 'no-cache'
                    }
                });

                if (!response.ok) {
                    throw new Error(`Error HTTP ${response.status}: ${response.statusText}`);
                }

                const text = await response.text();
                const lastModifiedDate = new Date(text.trim());

                if (isNaN(lastModifiedDate.getTime())) {
                    throw new Error('Formato de fecha inválido en version.txt');
                }

                 console.log("Fetched version date:", lastModifiedDate.toISOString());
                localStorage.setItem(cacheKey, lastModifiedDate.toISOString());
                localStorage.setItem(cacheTimestampKey, now.toString());

                return lastModifiedDate;
            } catch (error) {
                console.error('Error al obtener la fecha de version.txt:', error);
                 // Si falla, intenta usar la caché antigua si existe, si no, una fecha por defecto
                if (cachedDate) {
                    console.warn("Using stale cached version date due to fetch error.");
                    return new Date(cachedDate);
                }
                 console.warn("Returning default date due to fetch error and no cache.");
                return new Date('2024-01-01T00:00:00Z'); // Fecha por defecto muy antigua
            }
        }


        async function updateVersion() {
             try {
                const lastModifiedDate = await getLastModifiedDate();
                const version = formatVersionDate(lastModifiedDate);
                const versionElement = document.getElementById('version');
                if(versionElement) {
                     versionElement.textContent = `v${version}`; // Añade "v"
                } else {
                     console.warn("Version element not found");
                }
             } catch (error) {
                 console.error("Failed to update version:", error);
                  const versionElement = document.getElementById('version');
                  if(versionElement) versionElement.textContent = 'v?.?.?';
             }
        }

        // --- Creación del Grid ---
        const getFaviconUrl = (bookmark) => {
             // Prioriza favicon definido en el objeto bookmark
             if (bookmark.favicon) return bookmark.favicon;
             // Intenta construir URL de Google Favicon si hay URL válida
            try {
                if (bookmark.url) {
                    const domain = new URL(bookmark.url).hostname;
                     // Evita pedir favicon para dominios genéricos o locales si es necesario
                    if (domain && domain !== 'localhost' && domain.includes('.')) {
                        return `https://www.google.com/s2/favicons?domain=${domain}&sz=64`;
                    }
                }
            } catch (e) {
                 console.warn(`Could not parse URL for favicon: ${bookmark.url}`, e);
            }
            // Fallback a un placeholder si no hay favicon definido ni URL válida
            return 'https://via.placeholder.com/64/E0E0E0/AAAAAA?text=+'; // Placeholder gris claro
        };

        function generateBrightColor() {
            const hue = Math.floor(Math.random() * 360);
            const saturation = 50 + Math.floor(Math.random() * 25); // Rango 50-75
            const lightness = 75 + Math.floor(Math.random() * 15); // Rango 75-90
            return `hsla(${hue}, ${saturation}%, ${lightness}%, 0.75)`; // Un poco más opaco
        }

        function areColorsSimilar(color1, color2, threshold = 45) { // Umbral más pequeño
            if (!color1 || !color2) return false;
            try {
                const parseHsla = (c) => c.match(/\d+/g).map(Number);
                const [h1, s1, l1] = parseHsla(color1);
                const [h2, s2, l2] = parseHsla(color2);

                // Diferencia de tono (circular)
                const hueDiff = Math.min(Math.abs(h1 - h2), 360 - Math.abs(h1 - h2));
                // Diferencia de saturación y luminosidad
                const satLightDiff = Math.sqrt(Math.pow(s1 - s2, 2) + Math.pow(l1 - l2, 2));

                // Considerar similar si el tono está cerca Y la saturación/luminosidad también
                // O si la diferencia de tono es muy pequeña independientemente de lo demás
                return hueDiff < threshold || (hueDiff < threshold * 1.5 && satLightDiff < threshold * 1.5);

            } catch (e) {
                 console.warn("Error comparing colors:", color1, color2, e);
                return false; // Asumir no similares si hay error
            }
        }

        function createGridItems() {
             grid.innerHTML = ''; // Limpiar grid existente
             cellElements.length = 0; // Vaciar array de referencias
             const colors = Array(TOTAL_CELLS).fill(null);

            // Generar colores asegurando contraste con vecinos
             for (let i = 0; i < TOTAL_CELLS; i++) {
                 if (bookmarks[i] !== null) { // Solo generar color si hay bookmark
                     let color;
                     let attempts = 0;
                     const maxAttempts = 20;
                     do {
                         color = generateBrightColor();
                         attempts++;
                         // Comprobar vecinos (arriba, izquierda)
                         const topNeighborColor = (i >= COLS) ? colors[i - COLS] : null;
                         const leftNeighborColor = (i % COLS !== 0) ? colors[i - 1] : null;
                         // Condición de salida del bucle: color generado no es similar a vecinos O se alcanzó max intentos
                     } while (
                         (areColorsSimilar(color, topNeighborColor) || areColorsSimilar(color, leftNeighborColor))
                         && attempts < maxAttempts
                     );
                     if(attempts >= maxAttempts) console.warn(`Could not find contrasting color for cell ${i} after ${maxAttempts} attempts.`);
                     colors[i] = color;
                 }
             }


            // Crear celdas
            Array.from({ length: TOTAL_CELLS }).forEach((_, index) => {
                const cell = document.createElement('div');
                const bookmark = (index < bookmarks.length) ? bookmarks[index] : null;

                if (bookmark !== null && bookmark.name !== undefined) { // Asegurar que bookmark no es null y tiene 'name'
                    const link = document.createElement('a');
                    link.className = index >= 60 ? 'bookmark-item small-bookmark' : 'bookmark-item'; // Clase 'small-bookmark' para la sección "Varios" (índices >= 60)
                    link.title = bookmark.name || `Enlace ${index + 1}`; // Título por defecto si falta nombre

                     // Aplicar el color generado
                     if (colors[index]) {
                         // Extraer H, S, L del color generado para usar en variables CSS
                         try {
                            const [hue, saturation, lightness] = colors[index].match(/\d+/g).map(Number);
                            link.style.setProperty('--hue', hue);
                            link.style.setProperty('--saturation', `${saturation}%`);
                            link.style.setProperty('--lightness', `${lightness}%`);
                         } catch(e) {
                             console.warn("Failed to parse generated color:", colors[index], e);
                             link.style.backgroundColor = '#E0E0E0'; // Fallback color gris
                         }
                     } else {
                         link.style.backgroundColor = '#E0E0E0'; // Fallback si no se generó color
                     }


                    link.href = bookmark.url || "#"; // Enlace '#' si no hay URL

                    // Abrir en nueva pestaña excepto si es "Inicio Tesla" o no tiene URL
                    if (bookmark.url && bookmark.name !== "Inicio Tesla") {
                        link.target = "_blank";
                        link.rel = "noopener noreferrer";
                    }

                    // Favicon (si no es celda vacía placeholder)
                    if (bookmark.name !== "") { // Solo añadir imagen y nombre si no es placeholder intencional sin nombre
                        const img = document.createElement('img');
                        img.src = getFaviconUrl(bookmark);
                        img.alt = `Favicon ${bookmark.name || ''}`;
                        img.loading = "lazy";
                        img.onerror = (e) => {
                             // Si falla la carga (incluido placeholder), intenta un favicon genérico o nada
                             console.warn(`Failed to load favicon for ${bookmark.name}: ${e.target.src}`);
                             e.target.src = 'https://via.placeholder.com/64/CCCCCC/FFFFFF?text=?'; // Placeholder de fallback final
                             e.target.onerror = null; // Evitar bucle si el fallback también falla
                        };


                        if (bookmark.name === "Mis Updates") img.classList.add('favicon-red');
                        else if (bookmark.name === "Olas Updates") img.classList.add('favicon-blue');

                        link.appendChild(img);
                    }

                    // Nombre (si no es celda vacía placeholder)
                     if (bookmark.name !== "") {
                         const name = document.createElement('span');
                         name.className = 'bookmark-name';
                         name.textContent = bookmark.name;
                         link.appendChild(name);
                     } else {
                         // Si el nombre es "" (placeholder Ventusky), no añadir span de nombre
                         link.classList.add('no-name'); // Añadir clase por si se necesita estilo específico
                     }

                    cell.appendChild(link);
                } else {
                    // Celda vacía (null en el array o índice fuera de rango)
                    cell.className = 'bg-gray-50 border border-dashed border-gray-200 rounded-lg config-empty-cell'; // Clase para identificarla en modo config
                    // Aplicar estilo de celda vacía directamente
                     cell.style.backgroundColor = 'rgba(249, 250, 251, 0.8)'; // Fondo gris claro semi-transparente
                     cell.style.borderColor = '#E5E7EB';
                     if (isDarkMode) {
                         cell.style.backgroundColor = 'rgba(55, 65, 81, 0.6)'; // Fondo gris oscuro semi-transparente
                         cell.style.borderColor = '#4B5563';
                     }
                }
                grid.appendChild(cell);
                cellElements.push(cell); // Guardar referencia a la celda
            });
        }

        // --- Creación de Botones Laterales Dinámicamente ---
        function createSideButtons() {
            const buttonContainer = document.body; // Añadir directamente al body
             createdToggleButtons = []; // Limpiar array antes de crear

             // Botón ON/OFF
             const onOffToggle = document.createElement('img');
             onOffToggle.className = 'toggle-image';
             onOffToggle.id = 'on-off-toggle';
             onOffToggle.dataset.state = 'on'; // Estado inicial
             // La imagen se actualiza en updateButtonStyles
             onOffToggle.style.left = `10px`;
             buttonContainer.appendChild(onOffToggle);
             // Listeners ON/OFF (con soporte long press)
             onOffToggle.addEventListener('mousedown', () => { pressStartTime = Date.now(); });
             onOffToggle.addEventListener('mouseup', handleOnOffLongPress);
             onOffToggle.addEventListener('touchstart', (e) => { e.preventDefault(); pressStartTime = Date.now(); });
             onOffToggle.addEventListener('touchend', (e) => { e.preventDefault(); handleOnOffLongPress(); });


            // Botones Toggle de Filtro (usando toggleRanges)
             toggleRanges.forEach((range) => {
                 const toggle = document.createElement('span');
                 toggle.className = 'toggle-sign range-toggle';
                 toggle.dataset.toggleId = range.id; // Asigna el ID único
                 toggle.dataset.state = 'visible';   // Estado inicial por defecto
                 toggle.style.left = `10px`;

                 // applyToggleConfiguration establecerá la etiqueta, índices y estado inicial
                 // Se llamará desde loadSavedSettings o al final de la inicialización

                 buttonContainer.appendChild(toggle);

                 // Añade el listener (se llamará a updateToggleState)
                 toggle.addEventListener('click', () => {
                     if (isMinimalMode || isConfigMode) return;
                     updateToggleState(toggle); // Pasa el elemento del botón
                 });
                 createdToggleButtons.push(toggle); // Guarda referencia
            });

            // Botón Weather
            const weatherButton = document.createElement('span');
            weatherButton.className = 'toggle-sign';
            weatherButton.id = 'weather-button';
            weatherButton.innerHTML = `<img src="https://www.google.com/s2/favicons?domain=ventusky.com&sz=64" alt="Tiempo" class="max-w-[80px] max-h-[48px] object-contain">`; // Favicon Ventusky
            weatherButton.style.left = `10px`;
            buttonContainer.appendChild(weatherButton);
             weatherButton.addEventListener('click', () => {
                 if (isMinimalMode || isConfigMode) return;
                 window.open('https://www.ventusky.com/?p=40.2;-4.7;5&l=rain-3h', '_blank');
             });

            // Botón Reminder
            const reminderButton = document.createElement('span');
            reminderButton.className = 'toggle-sign';
            reminderButton.id = 'reminder-button';
            // El contenido (imagen y contador) se actualiza en updateButtonStyles
             reminderButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4197.jpg" alt="Recordatorio" class="max-w-[80px] max-h-[48px] object-contain">`; // Imagen base
            reminderButton.style.left = `10px`;
            buttonContainer.appendChild(reminderButton);
             // Listeners Reminder (con soporte long press)
             reminderButton.addEventListener('mousedown', () => { reminderPressStartTime = Date.now(); });
             reminderButton.addEventListener('mouseup', handleReminderLongPress);
             reminderButton.addEventListener('touchstart', (e) => { e.preventDefault(); reminderPressStartTime = Date.now(); });
             reminderButton.addEventListener('touchend', (e) => { e.preventDefault(); handleReminderLongPress(); });


             // Botón Zoom
            const zoomButton = document.createElement('span');
            zoomButton.className = 'toggle-sign';
            zoomButton.id = 'zoom-button';
            zoomButton.dataset.zoomState = 'off'; // Estado inicial
             // El icono se cambia en applyZoom
             zoomButton.innerHTML = `<img src="./zoon-.png" alt="Zoom" class="max-w-[80px] max-h-[48px] object-contain">`;
            zoomButton.style.left = `10px`;
            buttonContainer.appendChild(zoomButton);
             zoomButton.addEventListener('click', () => {
                 if (isMinimalMode || isConfigMode) return;
                 const currentState = zoomButton.dataset.zoomState;
                 const newState = currentState === 'off' ? 'on' : 'off';
                 zoomButton.dataset.zoomState = newState; // Actualiza estado ANTES de aplicar
                 applyZoom(newState);
                 updateButtonStyles(); // Actualiza color/clase
                 saveSettings();
                 // adjustButtonPositions(); // No suele ser necesario reajustar por zoom
             });


            // Botón Dark Mode
            const darkModeToggle = document.createElement('img');
            darkModeToggle.className = 'toggle-image';
            darkModeToggle.id = 'dark-mode-toggle';
            // La imagen se actualiza en updateButtonStyles
            darkModeToggle.style.left = `10px`;
            buttonContainer.appendChild(darkModeToggle);
             darkModeToggle.addEventListener('click', () => {
                 // Permitir cambio de modo incluso en modo config
                 if (isMinimalMode) return;
                 isDarkMode = !isDarkMode;
                 document.body.classList.toggle('dark-mode', isDarkMode);
                  // Re-aplicar estilos a elementos afectados (grid, modales si están abiertos, etc.)
                 applyCurrentThemeToElements();
                 updateButtonStyles();
                 saveSettings();
             });


            // Botón Reload
            const reloadButton = document.createElement('span');
            reloadButton.className = 'toggle-sign';
            reloadButton.id = 'reload-button';
            reloadButton.innerHTML = `<img src="./reload.webp" alt="Recargar" class="max-w-[80px] max-h-[48px] object-contain">`;
            reloadButton.style.left = `10px`;
            buttonContainer.appendChild(reloadButton);
             reloadButton.addEventListener('click', () => {
                 if (isMinimalMode || isConfigMode) return;
                 location.reload();
             });


            // Botón Home (Atrás)
            const homeButton = document.createElement('span');
            homeButton.className = 'toggle-sign';
            homeButton.id = 'home-button';
            homeButton.innerHTML = `<img src="./home.webp" alt="Inicio" class="max-w-[80px] max-h-[48px] object-contain">`;
            homeButton.style.left = `10px`;
            buttonContainer.appendChild(homeButton);
             homeButton.addEventListener('click', (e) => {
                 if (isMinimalMode || isConfigMode) return;
                 e.preventDefault();
                 window.history.back();
             });


            // Botón Configuración
            const configButton = document.createElement('span');
            configButton.className = 'toggle-sign';
            configButton.id = 'config-button';
            configButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/config.jpg" alt="Configuración" class="max-w-[80px] max-h-[48px] object-contain">`;
            configButton.style.left = `10px`;
            // El color base se establece en CSS
            buttonContainer.appendChild(configButton);
             // Listener para abrir menú de configuración
             configButton.addEventListener('click', () => {
                 if (isMinimalMode || isConfigMode) return; // No abrir si ya está en config
                 showConfigMenu();
             });


             // Lista ordenada de botones para adjustButtonPositions
             // El scrollToggle ya existe en HTML
            const buttonsInOrder = [
                document.getElementById('scroll-toggle'),
                onOffToggle,
                 ...createdToggleButtons, // Los botones de filtro
                weatherButton,
                reminderButton,
                zoomButton,
                darkModeToggle,
                reloadButton,
                homeButton,
                configButton
            ];

            // Devolver la lista para usar en adjustButtonPositions
            return buttonsInOrder.filter(btn => btn !== null); // Filtrar nulos si alguno falla en crearse
        }

        // Función para aplicar tema actual (dark/light) a elementos dinámicos o que cambian
        function applyCurrentThemeToElements() {
            // Re-aplicar estilos a celdas vacías del grid
             document.querySelectorAll('.config-empty-cell').forEach(cell => {
                 if (isDarkMode) {
                     cell.style.backgroundColor = 'rgba(55, 65, 81, 0.6)';
                     cell.style.borderColor = '#4B5563';
                 } else {
                     cell.style.backgroundColor = 'rgba(249, 250, 251, 0.8)';
                     cell.style.borderColor = '#E5E7EB';
                 }
             });
             // Si el modal de config está abierto, forzar re-renderizado de estilos (ej. cambiando clase)
             const configModal = document.querySelector('.config-modal');
             if (configModal) {
                 configModal.classList.toggle('dark-mode', isDarkMode);
             }
             // Si el modal de recordatorios está abierto
             const reminderModal = document.querySelector('.reminder-modal');
             if (reminderModal) {
                  reminderModal.classList.toggle('dark-mode', isDarkMode);
             }
             // Si hay notificaciones de recordatorios visibles
             document.querySelectorAll('.reminder-notification').forEach(notif => {
                 notif.classList.toggle('dark-mode', isDarkMode);
             });

            // Actualizar estilos de botones
             updateButtonStyles();
        }

        // --- Posicionamiento de Botones Laterales ---
        let sideButtons = []; // Guardar referencia a los botones creados
        function adjustButtonPositions() {
            const scrollToggle = document.getElementById('scroll-toggle');
            if (!scrollToggle || sideButtons.length === 0) return; // Asegurarse de que los botones existen

             const scrollToggleHeight = scrollToggle.offsetHeight; // Usar altura real
             const buttonHeight = 54; // Altura fija de los botones toggle
             const spacing = 4; // Espacio vertical reducido entre botones
             let currentTop = 10; // Posición inicial del primer botón (Scroll Toggle)

             scrollToggle.style.top = `${currentTop}px`;
             currentTop += scrollToggleHeight + spacing;

             // Posicionar el resto de botones en el orden definido
             sideButtons.forEach((button, index) => {
                 if (index > 0) { // Saltar el scrollToggle que ya está posicionado
                      // Verificar si el botón debe ser visible (no en modo minimal, excepto config/on-off)
                      const shouldBeVisible = !isMinimalMode ||
                                              (button.id === 'config-button') ||
                                              (button.id === 'on-off-toggle');

                      if (button && shouldBeVisible) {
                          button.style.top = `${currentTop}px`;
                          // Determinar altura real del botón (puede ser img o span)
                          const currentButtonHeight = button.offsetHeight || buttonHeight;
                          // Asegurarse de que la altura sea razonable
                          const validHeight = currentButtonHeight > 20 ? currentButtonHeight : buttonHeight;
                          currentTop += validHeight + spacing;
                          button.style.display = ''; // Asegurar que sea visible si corresponde
                          button.style.visibility = 'visible';
                      } else if (button) {
                           button.style.display = 'none'; // Ocultar si está en modo minimal y no es excepción
                           button.style.visibility = 'hidden';
                      }
                 } else if (button) { // Para el scroll-toggle (index 0)
                    button.style.display = isMinimalMode ? 'none' : ''; // Ocultar en minimal
                    button.style.visibility = isMinimalMode ? 'hidden' : 'visible';
                 }
             });
        }


        // --- Lógica de los Toggles de Filtro ---

        function getDefaultIndices(rangeInfo) {
            const indices = [];
            if (rangeInfo && typeof rangeInfo.start === 'number' && typeof rangeInfo.end === 'number') {
                for (let i = rangeInfo.start; i <= rangeInfo.end; i++) {
                    // Incluir solo si el índice es válido y la celda NO está marcada como vacía
                    if (i < cellElements.length && cellElements[i] && !cellElements[i].classList.contains('config-empty-cell')) {
                         indices.push(i);
                    }
                }
            } else {
                 console.warn("Invalid rangeInfo provided to getDefaultIndices:", rangeInfo);
            }
            return indices;
        }

        function applyToggleConfiguration(toggleId) {
             if (!toggleId) return;
            const toggleButton = createdToggleButtons.find(btn => btn.dataset.toggleId === toggleId);
            if (!toggleButton) {
                console.warn("Could not find toggle button for id:", toggleId);
                return;
            }

            const rangeInfo = toggleRanges.find(r => r.id === toggleId);
            const config = customToggleConfigs[toggleId];

            let label, itemIndices;

            // Determinar qué configuración usar: custom o default
            if (config && config.label && Array.isArray(config.itemIndices)) {
                label = config.label;
                itemIndices = config.itemIndices;
                 // console.log(`Applying custom config for ${toggleId}: Label=${label}, Indices=${itemIndices.join(',')}`);
            } else {
                 // Si no hay config custom válida, usar default
                label = rangeInfo.defaultLabel;
                itemIndices = getDefaultIndices(rangeInfo);
                // console.log(`Applying default config for ${toggleId}: Label=${label}, Indices=${itemIndices.join(',')}`);
                 // Si no existía, crear entrada en customToggleConfigs para guardar estado futuro si se cambia
                 if (!customToggleConfigs[toggleId]) {
                    // customToggleConfigs[toggleId] = { label: label, itemIndices: itemIndices };
                    // No guardar la config default en customToggleConfigs para saber que es default
                 }
            }

            // Almacenar la etiqueta base y los índices en el botón
            toggleButton.dataset.itemIndices = itemIndices.join(',');
            toggleButton.dataset.label = label;

            // Actualizar el texto visible del botón según su estado actual
            const currentState = toggleButton.dataset.state || 'visible'; // Asume visible si no está definido
            const sign = currentState === 'visible' ? '-' : '+';
            toggleButton.innerHTML = `<span class="sign">${sign}</span>${label}`;

            // Aplicar visibilidad inicial a los items controlados
            const hideItems = currentState === 'hidden';
            itemIndices.forEach(index => {
                 if (index < cellElements.length && cellElements[index]) {
                     cellElements[index].classList.toggle('hidden', hideItems);
                 } else {
                    // console.warn(`Item at index ${index} not found or invalid for toggle ${label}`);
                 }
            });
        }


        function updateToggleState(toggle) { // Recibe el elemento del botón
            if (!toggle || !toggle.dataset || !toggle.dataset.toggleId) return;

            const currentState = toggle.dataset.state;
            const itemIndicesString = toggle.dataset.itemIndices || '';
            const itemIndices = itemIndicesString.split(',').filter(s => s !== '').map(Number);
            const label = toggle.dataset.label;

            const newState = currentState === 'visible' ? 'hidden' : 'visible';
            const hideItems = newState === 'hidden';
            const sign = newState === 'visible' ? '-' : '+';

             console.log(`Toggling ${label} (${toggle.dataset.toggleId}) to ${newState}. Indices: ${itemIndices.join(',')}`);

            itemIndices.forEach(index => {
                 if (index < cellElements.length && cellElements[index]) {
                     // Usamos toggle con el segundo argumento booleano
                     cellElements[index].classList.toggle('hidden', hideItems);
                 } else {
                     console.warn(`Item at index ${index} not found for toggle ${label}`);
                 }
            });

            // Actualizar estado y texto del botón
            toggle.dataset.state = newState;
            toggle.innerHTML = `<span class="sign">${sign}</span>${label}`;

            updateButtonStyles(); // Actualiza colores basados en el nuevo data-state
            saveSettings(); // Guarda el nuevo estado del toggle
        }

        function updateAllToggles(targetState) { // 'on' (visible) or 'off' (hidden)
            createdToggleButtons.forEach(toggle => {
                 const toggleId = toggle.dataset.toggleId;
                 if (!toggleId) return; // Saltar si no tiene ID (no debería pasar)

                 const currentState = toggle.dataset.state; // 'visible' or 'hidden'
                 const shouldBeVisible = targetState === 'on';

                 // Cambiar estado solo si es diferente al deseado
                 if ((shouldBeVisible && currentState === 'hidden') || (!shouldBeVisible && currentState === 'visible')) {
                     updateToggleState(toggle); // Llama a la función que maneja la lógica y guarda
                 }
            });
             // Actualizar estado visual del botón ON/OFF maestro
             const onOffToggle = document.getElementById('on-off-toggle');
             if (onOffToggle) {
                onOffToggle.dataset.state = targetState;
                updateButtonStyles(); // Actualiza imagen on/off
             }
             // No es necesario llamar a saveSettings aquí, ya se llama dentro de updateToggleState
        }


        // --- Lógica del Botón ON/OFF (incluye Minimal Mode) ---
        function handleOnOffLongPress() {
            const pressDuration = pressStartTime ? Date.now() - pressStartTime : 0;
            const onOffToggle = document.getElementById('on-off-toggle');

            if (pressDuration >= 2000) { // Más de 2 segundos -> Minimal Mode Toggle
                isMinimalMode = !isMinimalMode;
                toggleMinimalMode(isMinimalMode);
            } else if (!isMinimalMode && onOffToggle) { // Click corto y no en modo minimal -> Toggle All Filters
                const currentState = onOffToggle.dataset.state;
                updateAllToggles(currentState === 'on' ? 'off' : 'on');
                 // updateAllToggles ya guarda el estado individual y llama a updateButtonStyles
                 // Solo necesitamos guardar el estado del botón maestro
                 saveSettings(); // Guarda el estado general onOffState
            }
            pressStartTime = null; // Resetear tiempo de inicio
        }


        // --- Lógica de Configuración ---

        function showConfigMenu() {
             if (isConfigMode) return; // Evitar abrir múltiples veces
             isConfigMode = true;
             document.body.classList.add('config-mode');

             const overlay = document.createElement('div');
             overlay.className = 'config-overlay';
             overlay.id = 'config-overlay';
             // Hacer que el overlay se cierre al hacer clic fuera del modal
             overlay.addEventListener('click', (e) => {
                 if (e.target === overlay) { // Solo si se hace clic en el fondo del overlay
                     exitConfigurationMode();
                 }
             });


             const modal = document.createElement('div');
             modal.className = 'config-modal';
             if (isDarkMode) modal.classList.add('dark-mode'); // Aplicar tema
             // Evitar que el clic en el modal cierre el overlay
              modal.addEventListener('click', (e) => e.stopPropagation());

             modal.innerHTML = `
                 <h2>Configuración</h2>
                 <p>Seleccione una opción:</p>
                 <button id="config-customize-toggles">Personalizar Filtros</button>
                 <button id="config-reset-toggles">Restaurar Filtros Predeterminados</button>
                 <hr style="margin: 1.5rem 0; border-color: rgba(128,128,128,0.5);">
                 <button id="config-clear-cache">Borrar Caché y Recargar</button>
                 <button id="config-cancel" class="cancel-button">Cerrar</button>
             `;

             overlay.appendChild(modal);
             document.body.appendChild(overlay);
             // Ajustar overflow del body para evitar scroll de fondo
             document.body.style.overflow = 'hidden';


             document.getElementById('config-customize-toggles').onclick = showToggleSelectionMenu;
             document.getElementById('config-clear-cache').onclick = () => {
                  if (confirm('¿Está seguro de que desea borrar TODOS los datos guardados (ajustes, recordatorios, configuración de filtros) y recargar la página?')) {
                    localStorage.clear();
                    location.reload();
                 }
             };
             document.getElementById('config-reset-toggles').onclick = () => {
                 if (confirm('¿Está seguro de que desea restaurar TODOS los filtros a sus etiquetas e iconos predeterminados?')) {
                     customToggleConfigs = {}; // Borra las configuraciones personalizadas
                     saveCustomToggleConfigs(); // Guarda el objeto vacío
                     alert('Filtros restaurados a los valores predeterminados. Los cambios se aplicarán ahora.');
                      // Re-aplicar configuración a todos los botones para que tomen los defaults
                     createdToggleButtons.forEach(toggle => applyToggleConfiguration(toggle.dataset.toggleId));
                     updateButtonStyles(); // Refrescar estilos si es necesario
                     exitConfigurationMode(); // Cerrar menú config
                     // No es necesario recargar la página
                 }
             };
             document.getElementById('config-cancel').onclick = exitConfigurationMode;
        }

        function showToggleSelectionMenu() {
            const modal = document.querySelector('.config-modal');
            if (!modal) return;
            if (isDarkMode) modal.classList.add('dark-mode'); // Asegurar tema

            // Generar botones para cada filtro configurable
            let toggleButtonsHTML = createdToggleButtons.map(toggle => {
                 const toggleId = toggle.dataset.toggleId;
                 if (!toggleId) return ''; // Saltar si no tiene ID (no debería pasar)
                 const currentLabel = toggle.dataset.label || toggleRanges.find(r => r.id === toggleId)?.defaultLabel || '???';
                return `<button class="config-toggle-button" data-toggle-id="${toggleId}">${currentLabel}</button>`;
            }).join('');

            modal.innerHTML = `
                <h2>Personalizar Filtros</h2>
                <p>Seleccione el filtro que desea modificar:</p>
                <div style="display: flex; flex-wrap: wrap; justify-content: center;">
                    ${toggleButtonsHTML}
                </div>
                <hr style="margin: 1.5rem 0; border-color: rgba(128,128,128,0.5);">
                <button id="config-back" class="cancel-button">Volver</button>
            `;

            modal.querySelectorAll('.config-toggle-button').forEach(button => {
                button.onclick = () => startToggleConfiguration(button.dataset.toggleId);
            });
            document.getElementById('config-back').onclick = showConfigMenu; // Vuelve al menú anterior
        }

        function startToggleConfiguration(toggleId) {
            currentConfiguringToggle = toggleId;
            const toggleButton = createdToggleButtons.find(btn => btn.dataset.toggleId === toggleId);
            if (!toggleButton) return;

            const rangeInfo = toggleRanges.find(r => r.id === toggleId); // Info original/default
            const currentConfig = customToggleConfigs[toggleId]; // Configuración custom guardada (si existe)

            // Determinar etiqueta e índices actuales (custom o default)
            const currentLabel = currentConfig?.label || rangeInfo.defaultLabel;
            const currentIndices = currentConfig?.itemIndices || getDefaultIndices(rangeInfo);

            currentConfigIndices = [...currentIndices]; // Copia para edición temporal

            // 1. Pedir nueva etiqueta
            const newLabel = prompt(`Editar etiqueta para "${currentLabel}" (máx 6 letras):`, currentLabel);

            if (newLabel === null) return; // El usuario canceló

            const validatedLabel = newLabel.trim().substring(0, 6);
            if (!validatedLabel) {
                alert("La etiqueta no puede estar vacía.");
                return; // Reintentar o volver? Por ahora, solo aborta
            }

            // 2. Preparar interfaz de selección de items
             const modal = document.querySelector('.config-modal');
            if (!modal) return;
            if (isDarkMode) modal.classList.add('dark-mode'); // Asegurar tema

            modal.innerHTML = `
                <h2>Configurando: ${validatedLabel}</h2>
                <p>Pulse sobre los iconos del grid para AÑADIR o QUITAR elementos de este grupo.</p>
                <p style="margin-top:0.5rem; font-size: 0.9em; color: ${isDarkMode ? '#B0B0B0' : '#666'};">(Los elementos seleccionados se marcan en azul. Los vacíos no son seleccionables).</p>
                <div style="margin-top: 1.5rem;">
                     <button id="config-save-group" class="save-button">Guardar Grupo "${validatedLabel}"</button>
                     <button id="config-cancel-group" class="cancel-button">Cancelar Cambios</button>
                </div>
            `;

             // Activar modo visual de selección en el grid
             document.body.classList.add('selecting-items-mode');
             // Ocultar el overlay para poder interactuar con el grid, pero mantener el modal
             const overlay = document.getElementById('config-overlay');
             if (overlay) overlay.style.backgroundColor = 'transparent'; // Hacer overlay transparente
             modal.style.position = 'fixed'; // Asegurar que el modal quede fijo
             modal.style.bottom = '20px'; // Posicionar modal abajo
             modal.style.left = '50%';
             modal.style.transform = 'translateX(-50%)';
             modal.style.zIndex = '3000'; // Encima del grid


             grid.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

            // Configurar celdas para selección
            cellElements.forEach((cell, index) => {
                cell.classList.remove('config-selected'); // Limpia selecciones previas
                const isEmpty = cell.classList.contains('config-empty-cell');

                if (!isEmpty) {
                    // Resaltar si está en la selección actual
                    if (currentConfigIndices.includes(index)) {
                        cell.classList.add('config-selected');
                    }
                    // Añadir listener (asegurando que solo haya uno)
                    cell.removeEventListener('click', handleGridItemClickInConfig); // Previene duplicados
                    cell.addEventListener('click', handleGridItemClickInConfig);
                    cell.dataset.gridIndex = index; // Guardamos el índice para fácil acceso
                    cell.style.cursor = 'pointer'; // Indicar que es clickeable
                    cell.classList.remove('config-empty-cell'); // Asegurarse que no tenga esta clase
                } else {
                     // Marcar celdas vacías para que CSS las atenúe más
                     cell.classList.add('config-empty-cell'); // Asegurar clase
                     cell.style.cursor = 'not-allowed';
                     cell.removeEventListener('click', handleGridItemClickInConfig); // No debe ser clickeable
                }
            });

            // Listeners para botones del modal
            document.getElementById('config-save-group').onclick = () => saveToggleConfiguration(toggleId, validatedLabel);
            document.getElementById('config-cancel-group').onclick = () => {
                 // Vuelve a la pantalla de selección de toggles sin guardar cambios
                 exitItemSelectionMode();
                 showToggleSelectionMenu(); // Muestra de nuevo el menú de selección de filtros
            };
        }

        function handleGridItemClickInConfig(event) {
            // Prevenir navegación si el item es un enlace
            event.preventDefault();
            event.stopPropagation();

            const cell = event.currentTarget;
            // Ignorar celdas que accidentalmente tengan el listener pero sean vacías
            if (!cell || !cell.dataset || cell.classList.contains('config-empty-cell')) return;

            const index = parseInt(cell.dataset.gridIndex);
            if (isNaN(index)) return;

            // Alternar selección visual
            cell.classList.toggle('config-selected');

            // Actualizar el array temporal de índices seleccionados
            const isSelected = cell.classList.contains('config-selected');
            if (isSelected) {
                if (!currentConfigIndices.includes(index)) {
                    currentConfigIndices.push(index);
                }
            } else {
                currentConfigIndices = currentConfigIndices.filter(i => i !== index);
            }
             console.log("Indices seleccionados temporalmente:", currentConfigIndices.sort((a,b)=>a-b));
        }

        function saveToggleConfiguration(toggleId, newLabel) {
            // Guardar la configuración personalizada
            customToggleConfigs[toggleId] = {
                label: newLabel,
                // Guardar copia ordenada de los índices seleccionados
                itemIndices: [...currentConfigIndices].sort((a, b) => a - b)
            };
            saveCustomToggleConfigs(); // Persistir en localStorage

            // Limpiar estado de selección y volver al menú de selección de filtros
            exitItemSelectionMode();
            // Aplicar inmediatamente la nueva configuración al botón afectado
            applyToggleConfiguration(toggleId);
            showToggleSelectionMenu();
            alert(`Filtro "${newLabel}" guardado con ${currentConfigIndices.length} elementos.`);
        }

        function exitItemSelectionMode() {
             document.body.classList.remove('selecting-items-mode');
             // Restaurar overlay
             const overlay = document.getElementById('config-overlay');
             if (overlay) overlay.style.backgroundColor = ''; // Restaurar fondo oscuro

             // Quitar listeners y estilos de selección de los items del grid
             cellElements.forEach(cell => {
                 cell.removeEventListener('click', handleGridItemClickInConfig);
                 cell.classList.remove('config-selected');
                 cell.style.cursor = ''; // Restaura cursor por defecto
                 cell.classList.remove('config-empty-cell'); // Quitar clase de celda vacía si se añadió
                 delete cell.dataset.gridIndex;
             });
             currentConfiguringToggle = null; // Limpiar toggle en configuración
             currentConfigIndices = [];       // Limpiar índices temporales
        }

        function exitConfigurationMode() {
            if (document.body.classList.contains('selecting-items-mode')) {
                exitItemSelectionMode(); // Asegura limpiar modo selección si estaba activo
            }
            const overlay = document.getElementById('config-overlay');
            if (overlay) {
                document.body.removeChild(overlay);
            }
            document.body.classList.remove('config-mode');
            document.body.style.overflow = ''; // Restaurar scroll del body
            isConfigMode = false;
        }


        // --- Lógica de Avisos y Footer ---

        async function loadNotices() {
             try {
                 const response = await fetch('https://boardinggate.github.io/Tesla/avisos.txt', {
                     cache: 'no-cache', // Siempre buscar la versión más reciente
                     headers: {
                         'Cache-Control': 'no-cache',
                         'Pragma': 'no-cache'
                     }
                 });
                 if (!response.ok) {
                     throw new Error(`No se pudo cargar avisos.txt (status: ${response.status})`);
                 }
                 const text = await response.text();
                 notices = text.split('\n')
                              .map(line => line.trim())
                              .filter(line => line.length > 0 && !line.startsWith('#')); // Ignorar vacías y comentarios #
                 if (notices.length === 0) {
                     notices = ['BoardingGate Lanzador']; // Mensaje por defecto si no hay avisos
                 }
             } catch (error) {
                 console.error('Error al cargar avisos.txt:', error);
                 notices = ['Error al cargar avisos.']; // Mensaje de error
             }
             currentNoticeIndex = 0; // Empezar desde el primer aviso
             updateNotice(); // Mostrar el primer aviso
             startNoticeRotation(); // Iniciar rotación si hay más de uno
        }

        function updateNotice() {
            const noticeElement = document.getElementById('current-notice');
             const noticeWrapper = document.querySelector('.notice-wrapper');
            if (!noticeElement || !noticeWrapper) return;

            if (notices.length > 0) {
                 // Forzar reinicio de animación (eliminando y re-añadiendo la clase)
                 noticeElement.style.animation = 'none';
                 noticeElement.offsetHeight; // Trigger reflow
                 noticeElement.style.animation = '';

                 noticeElement.textContent = notices[currentNoticeIndex];
                 noticeElement.style.animationName = 'fadeInOut'; // Asegura que la animación se aplique

            } else {
                noticeElement.textContent = ''; // Vacío si no hay avisos
            }
        }

         function startNoticeRotation() {
             // Limpiar intervalo existente si lo hubiera
             if (window.noticeIntervalId) {
                 clearInterval(window.noticeIntervalId);
             }
             // Iniciar nuevo intervalo solo si hay más de 1 aviso
             if (notices.length > 1) {
                 window.noticeIntervalId = setInterval(() => {
                     // Rotar solo si los avisos están activos y visibles
                     if (!isMinimalMode && isActive && isFooterVisible) {
                         currentNoticeIndex = (currentNoticeIndex + 1) % notices.length;
                         updateNotice();
                     }
                 }, 14000); // 14 segundos por aviso
             }
         }

        function toggleFooterVisibility() {
            // const noticesContainer = document.querySelector('.notices-container'); // Ya dentro de notices-icon-container
            // const noticeIcon = document.querySelector('#notice-toggle-icon'); // Ya dentro de notices-icon-container
            // const footerContent = document.querySelector('.footer-content'); // Ya dentro de footer
            const footerElement = document.querySelector('footer'); // El elemento <footer>
            const counterElement = document.querySelector('.counter-wrapper'); // El contador
            const noticeIconContainer = document.querySelector('.notices-icon-container'); // Contenedor de icono + avisos

            const shouldBeVisible = !isMinimalMode && isActive && isFooterVisible;

             // Toggle visibilidad del contenedor principal de avisos+icono
            if (noticeIconContainer) noticeIconContainer.classList.toggle('hidden', !shouldBeVisible);
            // Toggle visibilidad del footer completo
            if (footerElement) footerElement.classList.toggle('hidden', !shouldBeVisible);
             // Toggle visibilidad del contador
            if (counterElement) counterElement.classList.toggle('hidden', !shouldBeVisible);


            // Guardar estado solo si no estamos en modo minimal (que fuerza la ocultación)
             if (!isMinimalMode) {
                saveSettings();
             }
        }

        document.getElementById('notice-toggle-icon').addEventListener('click', () => {
            if (isMinimalMode || isConfigMode) return;
             // Este botón ahora controla ambos flags
            isActive = !isActive;
            isFooterVisible = isActive;
            toggleFooterVisibility(); // Aplica la visibilidad a avisos y footer
            // La rotación de avisos se detendrá/reiniciará automáticamente porque comprueba estas flags
        });

        // --- Lógica de Recordatorios ---

        function checkDarkModeTime() {
            const now = new Date();
            const hours = now.getHours();
            return (hours >= 21 || hours < 7); // Modo oscuro de 9 PM a 7 AM
        }

        function parseTimeOrTimerFromText(text) {
            // Regex mejorada para HH:MM (am/pm opcional) o X min/h
            const timeRegex = /(\d{1,2}):(\d{2})\s*(am|pm)?/i;
            const timerRegex = /(\d+)\s*(minutos?|mins?|m|horas?|hrs?|h)/i;

            let match = text.match(timeRegex);
            if (match) {
                let hours = parseInt(match[1]);
                const minutes = match[2]; // Mantener como string con padding
                const period = match[3] ? match[3].toLowerCase() : null;

                if (hours < 0 || hours > 23 || parseInt(minutes) < 0 || parseInt(minutes) > 59) return null; // Hora inválida

                if (period) {
                    if (period === 'pm' && hours < 12) hours += 12;
                    if (period === 'am' && hours === 12) hours = 0; // 12 AM es 00
                }

                return {
                    time: `${hours.toString().padStart(2, '0')}:${minutes}`,
                    isTimer: false
                };
            }

            match = text.match(timerRegex);
            if (match) {
                const value = parseInt(match[1]);
                if (value <= 0) return null; // Valor inválido

                const unit = match[2].toLowerCase();
                let minutesToAdd = value;

                if (unit.startsWith('h')) {
                    minutesToAdd = value * 60;
                }

                const now = new Date();
                now.setMinutes(now.getMinutes() + minutesToAdd);
                return {
                    time: `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`,
                    isTimer: true
                };
            }

            return null; // No se encontró formato de hora o temporizador
        }

        function showReminderModal(reminder = null) {
             // Cerrar modal existente si lo hay
             const existingModal = document.querySelector('.reminder-modal');
             if (existingModal) document.body.removeChild(existingModal);

            const modal = document.createElement('div');
            modal.className = 'reminder-modal';
            // Aplicar clase dark-mode si es necesario
            if (isDarkMode) modal.classList.add('dark-mode');

            modal.setAttribute('role', 'dialog');
            modal.setAttribute('aria-modal', 'true');
            modal.setAttribute('aria-labelledby', 'reminder-modal-title');

            modal.innerHTML = `
                <h2 id="reminder-modal-title">${reminder ? 'Editar' : 'Nuevo'} Recordatorio</h2>
                <form id="reminder-form">
                    <div>
                        <label for="reminder-text">Texto (puede incluir hora ej. "14:30" o temporizador ej. "en 10 min"):</label>
                        <textarea id="reminder-text" rows="3" required aria-required="true">${reminder ? reminder.text : ''}</textarea>
                    </div>
                    <div style="margin-top: 1rem;">
                        <label for="reminder-time">Hora específica (HH:MM, opcional):</label>
                        <input type="time" id="reminder-time" value="${reminder && reminder.time ? reminder.time : ''}">
                    </div>
                    <div style="margin-top: 1rem;">
                        <label>Repetir los días:</label>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: space-between;">
                            ${['Do', 'Lu', 'Ma', 'Mi', 'Ju', 'Vi', 'Sá'].map((day, i) => `
                                <label style="flex-basis: calc(100% / 7 - 1rem); text-align: center;">
                                    <input type="checkbox" name="repeat" value="${i}" ${reminder && reminder.repeatDays && reminder.repeatDays.includes(i) ? 'checked' : ''} style="margin-right: 0.25rem;"> ${day}
                                </label>
                            `).join('')}
                        </div>
                    </div>
                    <div class="button-group" style="margin-top: 1.5rem;">
                        <button type="submit">${reminder ? 'Guardar Cambios' : 'Añadir Recordatorio'}</button>
                        <button type="button" id="cancel-reminder">Cancelar</button>
                    </div>
                </form>
            `;
            document.body.appendChild(modal);
            document.body.style.overflow = 'hidden'; // Evitar scroll de fondo

            // Enfocar el primer campo
             modal.querySelector('#reminder-text').focus();


            modal.querySelector('#reminder-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    const text = modal.querySelector('#reminder-text').value.trim();
                    const explicitTime = modal.querySelector('#reminder-time').value;
                    const repeatDays = Array.from(modal.querySelectorAll('input[name="repeat"]:checked')).map(input => parseInt(input.value));

                    if (!text) {
                        alert('El texto del recordatorio no puede estar vacío.');
                        return;
                    }

                    let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                    let finalTime = explicitTime || null; // Priorizar hora explícita

                    // Si no hay hora explícita, intentar extraer del texto
                    if (!finalTime) {
                        const timeInfo = parseTimeOrTimerFromText(text);
                        if (timeInfo) {
                            finalTime = timeInfo.time;
                            // Si es un temporizador ('en X min'), no debe repetirse
                            if (timeInfo.isTimer) {
                                repeatDays.length = 0; // Borrar días de repetición
                            }
                        }
                    }

                    if (reminder) { // Editando existente
                        const index = reminders.findIndex(r => r.id === reminder.id);
                        if (index !== -1) {
                            reminders[index] = {
                                ...reminders[index],
                                text,
                                time: finalTime,
                                repeatDays,
                                lastShown: null // Resetear última vez mostrado al editar
                            };
                             console.log("Reminder updated:", reminders[index]);
                        } else {
                             console.warn("Reminder to update not found, ID:", reminder.id);
                        }
                    } else { // Creando nuevo
                        const newReminder = {
                            id: Date.now(),
                            text,
                            time: finalTime,
                            repeatDays,
                            createdAt: Date.now(), // Guardar fecha de creación
                            lastShown: null // Aún no se ha mostrado
                        };
                        reminders.push(newReminder);
                         console.log("Reminder added:", newReminder);
                    }

                    // Ordenar recordatorios: primero los que tienen hora, luego por creación
                     reminders.sort((a, b) => {
                         if (a.time && !b.time) return -1;
                         if (!a.time && b.time) return 1;
                         if (a.time && b.time) return a.time.localeCompare(b.time);
                         return (a.createdAt || 0) - (b.createdAt || 0); // Por fecha de creación si no hay hora
                     });


                    localStorage.setItem('reminders', JSON.stringify(reminders));
                    document.body.removeChild(modal);
                    document.body.style.overflow = ''; // Restaurar scroll
                    updateButtonStyles(); // Actualizar contador
                     checkReminders(); // Comprobar inmediatamente si el nuevo/editado debe mostrarse
                });

                modal.querySelector('#cancel-reminder').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    document.body.style.overflow = ''; // Restaurar scroll
                });
            } // Fin showReminderModal

            function showReminderNotification(reminder) {
                 // Evitar mostrar la misma notificación repetidamente muy rápido
                 const now = Date.now();
                 if (reminder.lastShown && (now - reminder.lastShown < 55000)) { // Menos de 55 seg
                    // console.log(`Skipping notification for reminder ${reminder.id}, shown recently.`);
                     return;
                 }

                 // Marcar como mostrado ahora
                 updateReminderLastShown(reminder.id, now);


                const notificationContainer = document.getElementById('reminder-notifications');
                if (!notificationContainer) return;

                 // Eliminar notificación existente para el mismo recordatorio si la hubiera
                 const existingNotification = notificationContainer.querySelector(`.reminder-notification[data-id="${reminder.id}"]`);
                 if (existingNotification) {
                     notificationContainer.removeChild(existingNotification);
                 }

                const notification = document.createElement('div');
                notification.className = 'reminder-notification';
                if (isDarkMode) notification.classList.add('dark-mode'); // Aplicar estilo dark si es necesario
                notification.dataset.id = reminder.id; // Guardar ID para referencia

                notification.setAttribute('role', 'alert');
                notification.setAttribute('aria-live', 'assertive');

                notification.innerHTML = `
                    <p>${reminder.text}</p>
                    ${reminder.time ? `<p style="font-size: 0.8em; opacity: 0.8;">Hora programada: ${reminder.time}</p>` : ''}
                    ${reminder.repeatDays && reminder.repeatDays.length > 0 ? `
                        <p style="font-size: 0.8em; opacity: 0.8;">Repite: ${reminder.repeatDays.map(day => ['Do', 'Lu', 'Ma', 'Mi', 'Ju', 'Vi', 'Sá'][day]).join(', ')}</p>
                    ` : ''}
                    <div class="button-group">
                        <button class="postpone" title="Aplazar 10 minutos">Aplazar</button>
                        <button class="modify" title="Modificar recordatorio">Editar</button>
                        <button class="cancel" title="Descartar recordatorio">OK</button>
                    </div>
                `;
                // Añadir al principio para que las nuevas aparezcan arriba
                notificationContainer.insertBefore(notification, notificationContainer.firstChild);

                // Auto-cierre después de un tiempo si no se interactúa? (Opcional)
                 // setTimeout(() => {
                 //     if (notification.parentNode === notificationContainer) { // Solo si aún existe
                 //          notificationContainer.removeChild(notification);
                 //         // Si se cierra automáticamente, ¿debería eliminarse de localStorage? Probablemente no.
                 //     }
                 // }, 30000); // 30 segundos


                notification.querySelector('.cancel').addEventListener('click', () => {
                    notificationContainer.removeChild(notification);
                    // Solo descartar la notificación, NO eliminar el recordatorio de localStorage
                    // a menos que no sea repetitivo.
                    if (!reminder.repeatDays || reminder.repeatDays.length === 0) {
                         deleteReminder(reminder.id); // Eliminar si no se repite
                    }
                });

                notification.querySelector('.modify').addEventListener('click', () => {
                    notificationContainer.removeChild(notification);
                    // Buscar el recordatorio actualizado por si acaso
                    const currentReminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const reminderToEdit = currentReminders.find(r => r.id === reminder.id);
                    if (reminderToEdit) {
                        showReminderModal(reminderToEdit);
                    } else {
                        alert("El recordatorio ya no existe.");
                    }
                });

                notification.querySelector('.postpone').addEventListener('click', () => {
                     notificationContainer.removeChild(notification);
                     postponeReminder(reminder.id, 10); // Aplazar 10 minutos
                 });
            } // Fin showReminderNotification

             function deleteReminder(reminderId) {
                 let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                 reminders = reminders.filter(r => r.id !== reminderId);
                 localStorage.setItem('reminders', JSON.stringify(reminders));
                 updateButtonStyles(); // Actualizar contador
                 console.log("Reminder deleted:", reminderId);
             }

             function postponeReminder(reminderId, minutes) {
                 let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                 const index = reminders.findIndex(r => r.id === reminderId);
                 if (index !== -1) {
                     const now = new Date();
                     now.setMinutes(now.getMinutes() + minutes);
                     const newTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
                     reminders[index].time = newTime;
                     reminders[index].repeatDays = []; // Aplazar elimina la repetición para esta instancia
                     reminders[index].lastShown = null; // Permitir que se muestre a la nueva hora
                     localStorage.setItem('reminders', JSON.stringify(reminders));
                     console.log(`Reminder ${reminderId} postponed to ${newTime}`);
                     updateButtonStyles();
                 }
             }

             function updateReminderLastShown(reminderId, timestamp) {
                 let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                 const index = reminders.findIndex(r => r.id === reminderId);
                 if (index !== -1) {
                     reminders[index].lastShown = timestamp;
                     localStorage.setItem('reminders', JSON.stringify(reminders));
                 }
             }


            function showAllReminders() {
                 // Cerrar modal existente si lo hay
                 const existingModal = document.querySelector('.reminder-modal');
                 if (existingModal) document.body.removeChild(existingModal);

                const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                 // Ordenar para mostrar: primero con hora, luego sin hora por creación
                 reminders.sort((a, b) => {
                         if (a.time && !b.time) return -1;
                         if (!a.time && b.time) return 1;
                         if (a.time && b.time) return a.time.localeCompare(b.time);
                         return (a.createdAt || 0) - (b.createdAt || 0);
                 });


                const modal = document.createElement('div');
                modal.className = 'reminder-modal';
                 if (isDarkMode) modal.classList.add('dark-mode');
                modal.setAttribute('role', 'dialog');
                modal.setAttribute('aria-modal', 'true');
                modal.setAttribute('aria-labelledby', 'all-reminders-title');

                modal.innerHTML = `
                    <h2 id="all-reminders-title">Todos los Recordatorios (${reminders.length})</h2>
                    <ul style="max-height: 60vh; overflow-y: auto; margin-bottom: 1rem; padding: 0; list-style: none;">
                        ${reminders.length === 0 ? '<li style="text-align: center; opacity: 0.7;">No hay recordatorios guardados.</li>' : reminders.map(r => `
                            <li style="padding: 0.75rem 0.5rem; border-bottom: 1px solid ${isDarkMode ? '#6B7280' : '#D1D5DB'}; display: flex; justify-content: space-between; align-items: center; gap: 0.5rem;">
                                <div style="flex-grow: 1;">
                                    <span>${r.text}</span>
                                    ${r.time ? `<br><small style="opacity: 0.8;">Hora: ${r.time}</small>` : ''}
                                    ${r.repeatDays && r.repeatDays.length > 0 ? `<br><small style="opacity: 0.8;">
                                    Repite: ${r.repeatDays.map(day => ['Do', 'Lu', 'Ma', 'Mi', 'Ju', 'Vi', 'Sá'][day]).join(', ')}</small>` : ''}
                                </div>
                                <div style="flex-shrink: 0; display: flex; gap: 0.5rem;">
                                    <button class="modify-reminder" data-id="${r.id}" title="Modificar este recordatorio" style="padding: 0.25rem 0.5rem; font-size:0.8rem;">Editar</button>
                                    <button class="delete-reminder" data-id="${r.id}" title="Eliminar este recordatorio" style="padding: 0.25rem 0.5rem; font-size:0.8rem;">Borrar</button>
                                </div>
                            </li>
                        `).join('')}
                    </ul>
                    <div class="button-group" style="margin-top: 1.5rem;">
                        <button type="button" id="add-new-reminder">Añadir Nuevo</button>
                        <button type="button" id="close-reminders">Cerrar</button>
                    </div>
                `;
                document.body.appendChild(modal);
                document.body.style.overflow = 'hidden'; // Evitar scroll de fondo

                modal.querySelectorAll('.modify-reminder').forEach(button => {
                    button.addEventListener('click', () => {
                        const id = parseInt(button.dataset.id);
                        const reminderToEdit = JSON.parse(localStorage.getItem('reminders') || '[]').find(r => r.id === id);
                        if (reminderToEdit) {
                             // No cerrar este modal, abrir el de edición encima o reemplazarlo
                             showReminderModal(reminderToEdit);
                        } else {
                             alert("El recordatorio ya no existe.");
                             showAllReminders(); // Recargar la lista
                        }
                    });
                });

                modal.querySelectorAll('.delete-reminder').forEach(button => {
                    button.addEventListener('click', () => {
                        const id = parseInt(button.dataset.id);
                         if (confirm("¿Está seguro de que desea eliminar este recordatorio permanentemente?")) {
                             deleteReminder(id);
                             // Eliminar el elemento li de la lista visualmente sin recargar todo el modal
                             const listItem = button.closest('li');
                             if (listItem) listItem.remove();
                              // Actualizar título con el nuevo contador
                             const titleElement = modal.querySelector('#all-reminders-title');
                             const currentCount = modal.querySelectorAll('ul li').length;
                             if (titleElement) titleElement.textContent = `Todos los Recordatorios (${currentCount})`;
                             if (currentCount === 0) {
                                 modal.querySelector('ul').innerHTML = '<li style="text-align: center; opacity: 0.7;">No hay recordatorios guardados.</li>';
                             }
                         }
                    });
                });

                modal.querySelector('#add-new-reminder').addEventListener('click', () => {
                     // No cerrar este modal, abrir el de añadir nuevo
                    showReminderModal();
                });

                modal.querySelector('#close-reminders').addEventListener('click', () => {
                    document.body.removeChild(modal);
                     document.body.style.overflow = ''; // Restaurar scroll
                });
            } // Fin showAllReminders


            function checkReminders() {
                 if (isMinimalMode || isConfigMode) return; // No mostrar notificaciones en estos modos

                const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const now = new Date();
                const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
                const currentDay = now.getDay(); // 0 = Domingo, 1 = Lunes, ...

                reminders.forEach(reminder => {
                     // Solo procesar si el recordatorio tiene una hora definida
                    if (reminder.time) {
                         // Comprobar si la hora coincide
                         if (reminder.time === currentTime) {
                             // Comprobar si es repetitivo y si coincide el día O si no es repetitivo
                             const shouldShowToday = (reminder.repeatDays && reminder.repeatDays.length > 0 && reminder.repeatDays.includes(currentDay));
                             const isOneTime = (!reminder.repeatDays || reminder.repeatDays.length === 0);

                             if (shouldShowToday || isOneTime) {
                                 showReminderNotification(reminder);
                                 // Si es de una sola vez y ya se mostró, ¿eliminarlo?
                                 // Se elimina al pulsar OK en la notificación si es one-time.
                             }
                         }
                    }
                });
            } // Fin checkReminders

            function loadReminders() {
                 // Ejecutar comprobación inicial
                 setTimeout(checkReminders, 1000); // Pequeño retraso inicial
                 // Configurar intervalo para comprobaciones periódicas (cada minuto)
                 setInterval(checkReminders, 60000); // 60 * 1000 ms = 1 minuto
                 // Actualizar contador inicial
                 updateButtonStyles();
            }

             function handleReminderLongPress() {
                 const pressDuration = reminderPressStartTime ? Date.now() - reminderPressStartTime : 0;

                 if (pressDuration >= 1500) { // Pulsación larga (1.5 seg) -> Mostrar todos
                      if (isMinimalMode || isConfigMode) return; // No hacer nada en estos modos
                     showAllReminders();
                 } else { // Pulsación corta -> Añadir nuevo
                      if (isMinimalMode || isConfigMode) return; // No hacer nada en estos modos
                     showReminderModal();
                 }
                 reminderPressStartTime = null; // Resetear tiempo
             }


        // --- Navegación y Swipe ---

        document.getElementById('back-button').addEventListener('click', () => {
            if (isMinimalMode || isConfigMode) return;
            window.history.back();
        });

        document.getElementById('forward-button').addEventListener('click', () => {
            if (isMinimalMode || isConfigMode) return;
            window.history.forward();
        });

        let touchStartX = 0;
        let touchEndX = 0;

        document.addEventListener('touchstart', e => {
             // Ignorar swipes si estamos en modo config o minimal
             if (isMinimalMode || isConfigMode) return;
             // Ignorar swipes si se inician sobre los botones laterales o el grid interactivo
             const targetElement = e.target;
             if (targetElement.closest('.toggle-sign, .toggle-image, .scroll-toggle-button, #bookmark-grid, .reminder-modal, .config-overlay')) {
                touchStartX = 0; // Resetear para invalidar swipe
                return;
             }
            touchStartX = e.changedTouches[0].screenX;
        });

        document.addEventListener('touchend', e => {
             if (touchStartX === 0) return; // Swipe invalidado o no iniciado correctamente
             if (isMinimalMode || isConfigMode) return; // Ignorar

            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
            touchStartX = 0; // Resetear después de procesar
        });

        function handleSwipe() {
            const swipeDistance = touchEndX - touchStartX;
            const minSwipeDistance = 80; // Umbral de distancia para considerar swipe

            if (swipeDistance > minSwipeDistance) {
                console.log("Swipe Right (Back)");
                window.history.back();
            } else if (swipeDistance < -minSwipeDistance) {
                 console.log("Swipe Left (Forward)");
                window.history.forward();
            }
        }


        // --- Inicialización ---
        window.addEventListener('resize', () => {
             if (!isMinimalMode && !isConfigMode) { // No reajustar en modo minimal o config
                adjustButtonPositions();
             }
        });

         document.addEventListener('DOMContentLoaded', async () => {
             console.log("DOM Content Loaded. Initializing...");

              // 1. Crear elementos del Grid
             createGridItems();

             // 2. Crear botones laterales (aún no posicionados)
             sideButtons = createSideButtons(); // Guarda la referencia a los botones creados

             // 3. Cargar versión
             await updateVersion();

              // 4. Cargar ajustes (incluye dark mode, minimal, estados de toggle, zoom, etc.)
             // loadSavedSettings llamará internamente a loadCustomToggleConfigs,
             // applyToggleConfiguration, applyZoom, etc. y actualizará estilos iniciales.
             loadSavedSettings(); // Esta función ahora es más compleja y maneja la carga inicial

             // 5. Cargar avisos
             await loadNotices(); // Carga y muestra el primer aviso

             // 6. Posicionar botones laterales (después de que todo esté cargado y se sepa si es minimal)
             // adjustButtonPositions se llama dentro de loadSavedSettings (al final del setTimeout)
             // y también se llama si se sale del modo minimal.

             // 7. Cargar recordatorios (inicia comprobaciones periódicas)
             // Se llama dentro de loadSavedSettings

              console.log("Initialization complete.");
         });

    </script>
</body>
</html>
