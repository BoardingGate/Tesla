
<!DOCTYPE dhtml>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BoardingGate Lanzador</title>
    <link rel="icon" href="https://boardinggate.github.io/Tesla/th.jpeg" type="image/jpeg">
    <script src="https://cdn.tailwindcss.com"></script>
<style>
    /* --- START OF CSS (No changes from previous version) --- */
    /* Mantengo el CSS como indicaste, aunque la clase .footer-hidden ya no se usa */
    .bookmark-item { transition: transform 0.2s ease, box-shadow 0.2s ease; box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1); position: relative; cursor: pointer; background-color: hsla(var(--hue, 0), var(--saturation, 0%), var(--lightness, 90%), 0.64); }
    .bookmark-item:hover:not(.editing-active) { transform: scale(1.05) translateY(-1px); box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.6), -6px -6px 12px rgba(255, 255, 255, 0.15); }
    .bookmark-item img { image-rendering: crisp-edges; }
    .bookmark-name { font-weight: bold; color: #333; text-align: center; margin-top: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; }
    #bookmark-grid { display: grid; grid-template-columns: repeat(6, minmax(120px, 1fr)); gap: 15px; background-color: transparent; border-radius: 0.75rem; position: relative; width: 100%; max-width: 984px; margin: 0 auto 0 85px; transition: all 0.3s ease; }
    #bookmark-grid > div { height: auto; aspect-ratio: 16 / 9; transition: all 0.3s ease; }
    .bookmark-item { width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; border-radius: 0.5rem; transition: all 0.3s ease; }
    .bookmark-item img { width: 36px; height: auto; max-width: 40px; border-radius: 0.25rem; }
    .bookmark-name { font-size: clamp(0.85rem, 1.5vw, 1.15rem); }
    .small-bookmark img { width: 24px; max-width: 28px; } .small-bookmark .bookmark-name { font-size: clamp(0.85rem, 1.5vw, 1.15rem); }
    @media (max-width: 768px) { #bookmark-grid { grid-template-columns: repeat(3, minmax(100px, 1fr)); gap: 10px; } }
    @media (max-width: 480px) { #bookmark-grid { grid-template-columns: repeat(2, minmax(80px, 1fr)); gap: 8px; } }
    .header-container { display: flex; align-items: center; justify-content: center; gap: 0.5rem; background-color: #ABAB99; padding: 0.5rem; } body.dark-mode .header-container { background-color: #92927E; } .header-logo { width: 100px; height: 70px; transition: filter 0.2s ease; } body.dark-mode .header-logo { filter: brightness(85%); } .title-container { background-color: #ABAB99; padding: 0.5rem 1rem; border-radius: 0.5rem; display: inline-block; } body.dark-mode .title-container { background-color: #92927E; } .header-container h1 { color: #5C5C47; } .version-text { font-size: 0.75rem; color: #5C5C47; font-weight: normal; }
    body { display: flex; flex-direction: column; min-height: 100vh; background-color: #ABAB99; margin: 0; overflow-x: hidden; } body.dark-mode { background-color: #92927E; } header { margin-bottom: 0.5rem; }
    main { position: relative; margin: 10px auto 0.5rem 60px; background-color: transparent; border-radius: 0.75rem; padding: 16px; min-height: 400px; max-width: 984px; width: 100%; transition: margin-top 0.5s ease-in-out; position: relative; }
    footer { margin: 0.5rem auto; text-align: center; max-width: 984px; width: 100%; display: block; background-color: #ABAB99; margin-left: 145px; } body.dark-mode footer { background-color: #92927E; } .footer-content { color: #5C5C47; padding: 0.5rem; margin: 0 auto; max-width: 100%; position: relative; } .footer-subtext { font-size: 0.75rem; color: #5C5C47; margin-top: 0.25rem; text-align: center; } .footer-link-green { color: #5C5C47; text-decoration: none; transition: color 0.2s ease; } .footer-link-green:hover { color: #5C5C47; } .footer-line { display: flex; justify-content: center; align-items: center; gap: 0.5rem; flex-wrap: wrap; }
    .toggle-image, .toggle-sign { width: 135px; height: 74px; margin-bottom: 2px; box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.4); border: 1px solid #7c7c68; left: 10px; z-index: 1000; transition: background-color 0.2s ease, filter 0.2s ease, top 0.3s ease, border 0.2s ease; border-radius: 35px; align-items: center; justify-content: center; cursor: pointer; display: flex; position: fixed; top: 90px; }
    .scroll-toggle-button { position: fixed; width: 110px !important; height: clamp(75px, 20vw, 130px) !important; background-color: #ABAB99; border-radius: 60px; display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: clamp(10px, 2vw, 20px); cursor: pointer; box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.4) !important; border: 1px solid #808080 !important; z-index: 1001; transition: background-color 0.2s ease; left: 10px; top: 10px; } .scroll-toggle-button:hover { background-color: #668B8B; } .scroll-toggle-button svg { width: clamp(24px, 4vw, 32px); height: clamp(24px, 4vw, 32px); stroke: #E6E6DC; }
    #config-button, #personal-button, #home-button, #reload-button { width: auto !important; height: auto !important; background-color: transparent !important; border: none !important; box-shadow: none !important; padding: 5px !important; position: absolute !important; top: 27px !important; z-index: 900 !important; cursor: pointer; border-radius: 50%; transition: transform 0.1s ease, background-color 0.2s ease; }
    #config-button { left: 185px !important; } #personal-button { left: 250px !important; } #home-button { left: 315px !important; } #reload-button { left: 380px !important; }
    #config-button img { max-width: 41px !important; max-height: 41px !important; width: 41px; height: 41px; object-fit: contain; display: block; filter: none !important; } #personal-button img, #home-button img, #reload-button img { max-width: 37px !important; max-height: 37px !important; width: 37px; height: 37px; object-fit: contain; display: block; filter: none !important; }
    #config-button:hover, #personal-button:hover, #home-button:hover, #reload-button:hover { transform: scale(1.1); background-color: rgba(255, 255, 255, 0.2); }
    #personal-button.editing { border: 3px solid yellow !important; box-shadow: 0 0 10px yellow !important; }
    body.dark-mode #config-button img { filter: brightness(65%); } body.dark-mode #personal-button img { filter: brightness(65%); }
    #user-id-display { position: absolute; top: -25px; right: 0px; margin-right: 60px; font-weight: bold; font-size: 1.1rem; color: #5C5C47; padding: 4px 8px; background-color: rgba(171, 171, 153, 0.7); border-radius: 4px; z-index: 800; white-space: nowrap; text-align: right; } body.dark-mode #user-id-display { color: #E6E6DC; background-color: rgba(146, 146, 126, 0.7); opacity: 0.7; }
    .top-text-container { display: flex; align-items: center; justify-content: center; font-size: clamp(0.6rem, 1.5vw, 0.75rem); color: #5C5C47; background-color: #ABAB98; margin-top: 0.25rem; margin-left: 70px; gap: 0.5rem; padding: 0.25rem 0.5rem; border-radius: 0.25rem; animation: fadeOut 4s forwards; position: relative; height: 2rem; transition: opacity 0.5s ease-in-out; box-sizing: border-box; z-index: 1900; } body.dark-mode .top-text-container { background-color: #6B7280; } .top-text-container span { color: #5C5C47; font-size: clamp(0.9rem, 2vw, 1.2rem); } @keyframes fadeOut { 0% { opacity: 1; height: 2rem; } 75% { opacity: 1; height: 2rem; } 100% { opacity: 0; height: 2rem; pointer-events: none; } }
    .arrow-button { width: clamp(36px, 6vw, 48px); height: clamp(36px, 6vw, 48px); background-color: #668B8B; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3); transition: background-color 0.2s ease; } .arrow-button:hover { background-color: #5C5C47; } .arrow-button svg { stroke: #E6E6DC; }
    .counter-container { display: flex; justify-content: center; align-items: center; flex-direction: column; margin-top: 1rem; text-align: center; opacity: 0.2; margin-left: 145px; }
    .favicon-red { filter: hue-rotate(0deg) saturate(200%) brightness(80%); } .favicon-blue { filter: hue-rotate(200deg) saturate(150%) brightness(90%); }
    .notices-icon-container { display: flex; align-items: center; justify-content: center; width: 100%; max-width: 984px; margin: 0 auto; margin-left: 165px; position: relative; } .notices-container { flex-grow: 1; padding: 0.5rem; border: none; border-radius: 0.5rem; overflow: hidden; display: flex; align-items: center; justify-content: center; gap: 0; margin-left: 2px; height: 3rem; } .notice-wrapper { padding: 0.5rem; height: 1.5rem; flex-grow: 1; overflow: hidden; position: relative; display: flex; align-items: center; justify-content: center; } .notice { color: #E6E6DC; font-size: 1.3rem; font-weight: bold; white-space: nowrap; text-align: center; opacity: 0; animation: fadeInOut 14s infinite; } @keyframes fadeInOut { 0% { opacity: 1; } 10% { opacity: 1; } 90% { opacity: 1; } 100% { opacity: 0; } } .notice-off-icon { width: auto; height: clamp(2rem, 5vw, 3rem); margin-right: 10px; align-self: center; cursor: pointer; transition: filter 0.3s ease; } body.dark-mode .notice-off-icon { filter: brightness(85%); }
    .toggle-sign { background-color: #ABAB99; font-weight: bold; font-size: 1.25rem; color: #000000; text-align: center; } .toggle-sign .sign { font-size: 1.5rem; margin-right: 2px; } .toggle-sign:hover:not(#config-button):not(#personal-button):not(#home-button):not(#reload-button) { background-color: #D9A066; } .toggle-sign img, .toggle-image img { max-width: 70%; max-height: 70%; object-fit: contain; } body.dark-mode .toggle-sign#config-button { filter: brightness(85%); background-color: transparent !important; }
    .toggle-image {} .toggle-image:hover { filter: brightness(80%); } body.dark-mode .toggle-image#on-off-toggle { filter: brightness(85%); }
    #reminder-button { display: flex; flex-direction: column; justify-content: center; align-items: center; position: fixed; background-color: #ABAB99; } #reminder-button img { object-fit: contain; } #reminder-button .reminder-count { position: absolute; top: 6px; left: 8px; background-color: #EF4444; color: #FFFFFF; border-radius: 55%; padding: 4px 10px; font-size: 1.1rem; font-weight: bold; line-height: 1; display: flex; align-items: center; justify-content: center; z-index: 1500; min-width: 1.9rem; max-width: 2.5rem; text-align: center; }
    .hidden { display: none !important; } .footer-hidden { display: none; } body.dark-mode .bookmark-item { filter: brightness(60%); } body.dark-mode .bg-gray-50.border.border-dashed.border-gray-200.rounded-lg { filter: brightness(60%); } body.dark-mode .scroll-toggle-button { background-color: #ABAB99; } body.dark-mode .scroll-toggle-button:hover { background-color: #ABAB99; } body.dark-mode .toggle-sign:not(#config-button):not(#personal-button):not(#home-button):not(#reload-button) { background-color: #ABAB99; } body.dark-mode .toggle-sign:not(#config-button):not(#personal-button):not(#home-button):not(#reload-button):hover { background-color: #ABAB99; } body.dark-mode .toggle-sign.range-toggle[data-state="visible"] { background-color: #ABAB99; } body.dark-mode .toggle-sign.range-toggle[data-state="hidden"] { background-color: #ABAB99; } .toggle-sign.range-toggle[data-state="hidden"] { color: #7F7F7F; } body.dark-mode #reload-button {} body.dark-mode #home-button {} body.dark-mode #personal-button {} body.dark-mode #weather-button { background-color: #ABAB99; } body.dark-mode #zoom-button:not(.zoomed) { background-color: #ABAB99; } body.dark-mode #zoom-button.zoomed { background-color: #ABAB99; } body.dark-mode #reminder-button { background-color: #ABAB99; }
    .reminder-modal { position: fixed; top: 2%; left: 3%; transform: translateY(-1%); background-color: #D2B48C; padding: 1rem; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); z-index: 2000; max-width: 1050px; width: 98%; max-height: 700px; overflow-y: auto; font-weight: bold; font-size: 1.3rem; }
    .help-modal, .edit-info-modal { position: fixed; top: 10%; left: 35px; transform: translateY(-10%); background-color: #DAC8A0; padding: 2rem; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); z-index: 2000; max-width: 1020px; width: 98%; max-height: 80vh; overflow-y: auto; font-size: 1.10rem; }
    .reminder-modal h2, .help-modal h2, .edit-info-modal h2 { font-size: 1.5rem; font-weight: bold; margin-bottom: 0.5rem; color: #111827; }
    .reminder-modal label, .help-modal label, .edit-info-modal label { display: block; margin-bottom: 0.25rem; font-weight: 500; color: #374151; font-size: 1.1rem; }
    .reminder-modal textarea#reminder-text { width: 100%; padding: 0.5rem; margin-bottom: 0.5rem; border: 1px solid #D1D5DB; border-radius: 0.25rem; font-size: 1.4rem; font-weight: bold; text-transform: uppercase; }
    .reminder-modal input[type="text"], .reminder-modal input[type="number"] { width: 100%; padding: 0.5rem; margin-bottom: 0.5rem; border: 1px solid #D1D5DB; border-radius: 0.25rem; font-size: 2rem; text-align: center; }
    .reminder-modal .form-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; }
    .reminder-modal .full-width { grid-column: span 3; } .reminder-modal .days-group { display: flex; gap: 2rem; flex-wrap: wrap; }
    .reminder-modal .button-group { display: flex; justify-content: space-between; gap: 0.5rem; flex-wrap: nowrap; margin-top: 1rem; }
    .reminder-modal .days-group label { font-size: 1.3rem; }
    .reminder-modal button, .help-modal button, .edit-info-modal button { padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-size: 1.3rem; flex: 1; text-align: center; min-width: 100px; }
    .reminder-modal button[type="submit"] { background-color: #2563EB; height:70px; font-weight: bold; font-size: 1.5rem; color: #FFFFFF; display: flex; align-items: center; justify-content: center; gap: 0.6rem; }
    .reminder-modal button[type="submit"] span#countdown-save { font-size: 1.6rem; font-weight: bold; justify-content: right; color: #e6e6dc; }
    .reminder-modal button[type="button"] { background-color: #D1D5DB; color: #111827; }
    .help-modal button#close-help, .edit-info-modal button#close-edit-info { background-color: #2563EB; color: #FFFFFF; font-size: 1.5rem; padding: 1rem 2rem; height:70px; }
    .reminder-notification { position: fixed; top: 45%; left: 55%; transform: translate(-85%, -85%); background-color: #FFFF99; padding: 1.5rem; border-radius: 2.5rem; border: 2px solid #ABAB99; box-shadow: 0 6px 6px rgba(1, 0, 0, 0.3); z-index: 3000; max-width: 470px; width: 95%; text-align: center; }
    .reminder-notification .reminder-text { margin: 0.5rem 0; font-size: 1.8rem; font-weight: bold; color: #0000FF; } .reminder-notification .reminder-details { margin: 0.5rem 0; font-size: 1.0rem; font-weight: bold; color: #0000FF; } .reminder-notification .button-group { display: flex; justify-content: center; gap: 0.5rem; margin-top: 1rem; } .reminder-notification button { padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.9rem; } .reminder-notification button.cancel { background-color: #EF4444; color: #FFFFFF; font-weight: bold; width: 150px; height:70px; font-size: 1.2rem; } .reminder-notification button.modify { background-color: #10B981; font-weight: bold; width: 150px; height:60px; font-size: 1.2rem; color: #FFFFFF; } .reminder-notification button.postpone { background-color: #F59E0B; width: 150px; font-weight: bold; height:60px; font-size: 1.2rem; color: #FFFFFF; }
    .reminder-table-modal { position: fixed; top: 30px; left: 35px; transform: translateY(10%); background-color: #E6D6A8; padding: 1.5rem; border-radius: 1.5rem; box-shadow: 0 4px 6px rgba(1, 1, 0, 0.1); z-index: 2000; max-width: 99%; width: 1090px; max-height: 80vh; overflow-y: auto; }
    .reminder-table-modal table { width: 100%; border-collapse: collapse; margin-bottom: 1rem; } .reminder-table-modal tbody tr { cursor: pointer; } .reminder-table-modal tbody tr:hover { background-color: rgba(0, 0, 0, 0.05); } .reminder-table-modal th, .reminder-table-modal td { padding: 0.5rem; border: 1px solid #1E3A8A; font-size: 1.1rem; text-align: center; vertical-align: middle; } .reminder-table-modal td.text-column { text-align: left; } .reminder-table-modal th { background-color: #E5E7EB; font-weight: bold; } .reminder-table-modal td.date-column { white-space: nowrap; } .reminder-table-modal td:first-child { display: flex; justify-content: space-around; align-items: center; gap: 0.5rem; padding: 0.3rem 0.5rem; border: none; } .reminder-table-modal td:first-child button { padding: 0.5rem 0.8rem; font-size: 0.85rem; flex: 0 1 auto; margin: 0; } .reminder-table-modal button.modify { background-color: #10B981; font-size: 1rem; height:70px; color: #000000; } .reminder-table-modal button.delete { background-color: #EF4444; font-size: 1.2rem; height:65px; color: #FFFFFF; } .reminder-table-modal button.postpone { background-color: #F59E0B; font-size: 1.2rem; height:65px; color: #FFFFFF; } .reminder-table-modal .button-group { display: flex; margin-top: 1rem; } .reminder-table-modal #close-reminders, .reminder-table-modal #close-reminders-top { padding-left: 3rem; padding-right: 3rem; background-color: #2563EB; color: white; padding: 0.75rem 3rem; border-radius: 0.5rem; font-size: 1.25rem; font-weight: bold; border: 2px solid #1E3A8A; cursor: pointer; transition: background-color 0.2s ease; display: inline-flex; align-items: center; } .reminder-table-modal #close-reminders:hover, .reminder-table-modal #close-reminders-top:hover { background-color: #1D4ED8; } .reminder-table-modal .top-button-container { display: flex; justify-content: flex-end; margin-bottom: 1rem; }
    .button-countdown { margin-left: 8px; font-weight: bold; font-size: 1.1em; opacity: 0.85; }
    .reminder-count-globe { position: fixed; top: 10px; left: 10px; background-color: #EF4444; color: white; border-radius: 65%; padding: 10px 15px; font-size: 1.3rem; font-weight: bold; z-index: 1500; }
    .reminder-count-globe, #reminder-notifications, .notices-icon-container, footer { transition: margin-top 0.5s ease-in-out; }
    .speech-button { background-color: #668B8B; color: white; border: none; border-radius: 0.25rem; padding: 0.5rem; cursor: pointer; margin-left: 0.5rem; font-size: 1rem; vertical-align: top; } .speech-button:hover { background-color: #668B8B; } .speech-status { font-size: 0.85rem; color: #ABAB99; margin-top: 0.25rem; min-height: 1.2em; } #auto-save-timer { color: #1E40AF; }
    .statcounter-container { display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 0.25rem; }
    .toast-notification { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 25px; border-radius: 25px; color: white; font-size: 1rem; font-weight: 500; z-index: 9999; opacity: 0; transition: opacity 0.4s ease-in-out, bottom 0.4s ease-in-out; box-shadow: 0 4px 10px rgba(0,0,0,0.2); text-align: center; min-width: 250px; max-width: 80%; } .toast-notification.show { opacity: 1; bottom: 40px; } .toast-success { background-color: #28a745; } .toast-error { background-color: #dc3545; } .toast-warning { background-color: #ffc107; color: #333; } .toast-info { background-color: #17a2b8; }
    /* Edit Mode Styles */ .editable:hover { outline: 2px dashed yellow; outline-offset: 2px; } .editing-active .bookmark-item:hover, .editing-active .range-toggle:hover { transform: none; box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1); outline: 3px solid yellow; cursor: crosshair; } .edit-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #EADDCA; padding: 2rem; border-radius: 0.75rem; box-shadow: 0 5px 15px rgba(0,0,0,0.3); z-index: 6000; width: 90%; max-width: 500px; border: 1px solid #A0522D; } .edit-modal h2 { font-size: 1.4rem; margin-bottom: 1rem; color: #333; font-weight: bold; text-align: center; } .edit-modal label { display: block; margin-bottom: 0.3rem; font-weight: 500; color: #444; font-size: 1rem; } .edit-modal input[type="text"], .edit-modal input[type="url"] { width: 100%; padding: 0.6rem; margin-bottom: 0.8rem; border: 1px solid #BDB7AB; border-radius: 0.25rem; font-size: 1rem; } .edit-modal .button-group { display: flex; justify-content: space-between; gap: 1rem; margin-top: 1.5rem; } .edit-modal button { padding: 0.7rem 1rem; font-size: 1rem; border-radius: 0.25rem; cursor: pointer; border: none; flex: 1; } .edit-modal button.save { background-color: #28a745; color: white; } .edit-modal button.save:hover { background-color: #218838; } .edit-modal button.cancel { background-color: #6c757d; color: white; } .edit-modal button.cancel:hover { background-color: #5a6268; } .edit-modal button.reset { background-color: #ffc107; color: #333; } .edit-modal button.reset:hover { background-color: #e0a800; }
    /* --- END OF CSS --- */
</style>
</head>
<body class="min-h-screen bg-[#ABAB99] flex flex-col items-center p-6">

    <div class="top-text-container">
        <div class="arrow-button" id="back-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
        </div>
        <span>[ Web anterior o posterior arrastre ]</span>
        <div class="arrow-button" id="forward-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14M12 5l7 7-7 7"/></svg>
        </div>
    </div>
    <div class="reminder-count-globe" id="reminder-count-globe"></div>
    <div id="reminder-notifications"></div>
<main>
    <div id="user-id-display"></div>
    <div id="bookmark-grid">
        <!-- Grid items will be generated by JavaScript -->
    </div>
</main>

<div class="notices-icon-container">
    <img src="https://boardinggate.github.io/Tesla/IMG_4194.jpg" alt="Toggle Avisos/Pie" class="notice-off-icon" id="notice-toggle-icon">
    <div class="notices-container">
        <div class="notice-wrapper">
            <span class="notice" id="current-notice"></span>
        </div>
    </div>
</div>
<!-- El contenedor del contador no estaba en el HTML original, si existe en otra versión, añadelo aquí.
     Asegúrate de que tenga la clase 'counter-wrapper' si quieres que lo controle el toggleNotices -->
<div class="counter-container">
    <!-- Posible contenido del contador -->
</div>


<footer>
    <div class="footer-content">
        <div class="header-container">
            <img src="https://boardinggate.github.io/Tesla/LOGOTESLA.jpg" class="header-logo">
            <div class="title-container">
                <h1 class="text-2xl font-bold inline">
                    <span class="text-2xl">BoardingGate</span>
                    <span class="text-base">Lanzador</span>
                    <span id="version" class="version-text"></span>
                </h1>
            </div>
        </div>
        <div class="footer-line">
            <a href="https://x.com/boardinggate?s=21" class="footer-link-green" target="_blank" rel="noopener noreferrer">@BoardingGate</a>
            <span class="text-green-200" style="font-size: 1.5rem;">🤝</span>
            <a href="https://x.com/boardinggate/status/1857325553742721116?s=46" class="footer-link-green" target="_blank" rel="noopener noreferrer">Ahorremos un dinero con mis REFERIDOS</a>
        </div>

        <div class="statcounter-container">
          <div style="display: inline-flex; align-items: center; gap: 10px;">
            <script type="text/javascript">
              var sc_project=13126275;
              var sc_invisible=0;
              var sc_security="0fc568cc";
              var scJsHost = "https://";
              document.write("<sc"+"ript type='text/javascript' src='" +
              scJsHost+
              "statcounter.com/counter/counter.js'></"+"script>");
            </script>
            <noscript><div class="statcounter"><a title="Web Analytics"
            href="https://statcounter.com/" target="_blank"><img
            class="statcounter"
            src="https://c.statcounter.com/13126275/0/0fc568cc/0/"
            alt="Web Analytics"
            referrerPolicy="no-referrer-when-downgrade"></a></div></noscript>
            <a href="https://statcounter.com/p13126275/?guest=1" class="footer-subtext">Legionarios de Elon</a>
          </div>
        </div>

        <p class="footer-subtext">La inteligencia tiene ciertas limitations. La locura, casi ninguna 🫶 🤟</p>
    </div>
</footer>


<div id="scroll-toggle" class="scroll-toggle-button" title="Ir al inicio o fin">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M19 12l-7 7-7-7"/></svg>
</div>

<script>
    // --- Original Data ---
    const originalBookmarks = [ { name: "YouTube", url: "https://www.youtube.com" }, { name: "Google", url: "https://www.google.com" }, { name: "GDrive", url: "https://drive.google.com", favicon: "./IMG_4172.png" }, { name: "GMail", url: "https://mail.google.com/mail/mu/mp/603/#tl/Recibidos", favicon: "./IMG_4171.png"}, { name: "Google Fotos", url: "https://photos.google.com" }, { name: "iCloud", url: "https://www.icloud.com/", favicon: "https://www.google.com/s2/favicons?domain=icloud.com&sz=64" }, { name: "ABRP", url: "https://abetterrouteplanner.com" }, { name: "ElectroMaps", url: "https://map.electromaps.com/es/", favicon: "https://www.google.com/s2/favicons?domain=electromaps.com&sz=64" }, { name: "REVE PdR España", url: "https://www.mapareve.es/mapa-puntos-recarga", favicon: "https://www.google.com/s2/favicons?domain=mapareve.es&sz=64" }, { name: "PdR,s", url: "https://www.google.com/maps/search/puntos+recarga+veh%C3%ADculos+el%C3%A9ctricos", favicon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 18h8v2h-8v-2z'/><path d='M12 14h8v2h-8v-2z'/><path d='M12 10h8v2h-8v-2z'/><path d='M12 6h8v2h-8V6z'/><path d='M4 18h4v-2H4v2zM4 14h4v-2H4v2zM4 10h4v-2H4v2zM4 6h4V4H4v2z'/></svg>" }, { name: "Google Maps", url: "https://maps.google.com" }, { name: "WhatsApp", url: "https://web.whatsapp.com/" }, { name: "TESSIE", url: "https://dash.tessie.com/signin", favicon: "https://www.google.com/s2/favicons?domain=tessie.com&sz=64" }, { name: "Mis Updates", url: "https://dash.tessie.com/software", favicon: "https://cdn-icons-png.flaticon.com/512/148/148767.png" }, { name: "Olas Updates", url: "https://es.stats.tessie.com/", favicon: "https://cdn-icons-png.flaticon.com/512/5815/5815902.png" }, { name: "NotaTeslaApp", url: "https://www.notateslaapp.com/software-updates/" }, { name: "ENHAUTO", url: "https://www.enhauto.com" }, { name: "MAREAS", url: "https://www.meteogalicia.gal/web/predicion/mareas-e-luas" }, { name: "ELECTROVERSE", url: "https://electroverse.com/es/map", favicon: "https://www.google.com/s2/favicons?domain=electroverse.com&sz=64" }, { name: "ACCIONA", url: "https://www.google.com/maps/search/recarga+Acciona", favicon: "https://www.google.com/s2/favicons?domain=acciona.com&sz=64" }, { name: "IBERDROLA", url: "https://www.google.com/maps/search/recarga+IBERDROLA", favicon: "https://www.google.com/s2/favicons?domain=iberdrola.com&sz=64" }, { name: "WAYLET Repsol", url: "https://www.google.com/maps/search/recarga+REPSOL+Waylet", favicon: "https://www.google.com/s2/favicons?domain=repsol.com&sz=64" }, { name: "ENDESA xWay", url: "https://www.google.com/maps/search/recarga+ENDESA+XWAY", favicon: "https://www.google.com/s2/favicons?domain=endesa.com&sz=64" }, { name: "ZUNDER", url: "https://www.google.com/maps/search/recarga+ZUNDER", favicon: "https://www.google.com/s2/favicons?domain=zunder.com&sz=64" }, { name: "IONITY", url: "https://www.google.com/maps/search/recarga+IONITY", favicon: "https://www.google.com/s2/favicons?domain=ionity.eu&sz=64" }, { name: "WENEA", url: "https://www.google.com/maps/search/recarga+WENEA", favicon: "https://www.google.com/s2/favicons?domain=wenea.com&sz=64" }, { name: "T.ENERGIES", url: "https://www.google.com/maps/search/recarga+TOTAL+ENERGIES", favicon: "https://www.google.com/s2/favicons?domain=totalenergies.com&sz=64" }, { name: "GALP", url: "https://www.google.com/maps/search/recarga+GALP", favicon: "https://www.google.com/s2/favicons?domain=galp.com&sz=64" }, { name: "MIIO", url: "https://miio.com", favicon: "https://www.google.com/s2/favicons?domain=miio.com&sz=64" }, { name: "EVDC", url: "https://evdc.network", favicon: "https://www.google.com/s2/favicons?domain=evdc.network&sz=64" }, { name: "GROK", url: "https://grok.com/?referrer=website" }, { name: "CHATGPT", url: "https://chat.openai.com" }, { name: "CLAUDE", url: "https://claude.ai/new" }, { name: "GEMINI", url: "https://gemini.google.com" }, { name: "NOTEBOOKLM", url: "https://notebooklm.google.com" }, { name: "Batería", url: "https://docs.google.com/spreadsheets/d/1bLZmgVGTBqg2bS2E45JpORjs9eK2nb05AWXYLLDY-RI/edit?gid=1398548891#gid=1398548891", favicon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='10'/><polyline points='12 6 12 12 16 14'/></svg>" }, { name: "TeslaParaTodos", url: "https://teslaparatodos.com/cine/" }, { name: "BetterTheater", url: "https://abettertheater.com", favicon: "https://www.google.com/s2/favicons?domain=abettertheater.com&sz=64" }, { name: "Filmin", url: "https://www.filmin.es/catalogo/peliculas" }, { name: "Octopus", url: "https://octopusenergy.es/login" }, { name: "App MCE", url: "https://www.oscarabilleira.com/app-mi-coche-electrico/#ayuda" }, { name: "Patrón Luz", url: "https://docs.google.com/spreadsheets/d/1R7UUZ9i4BAYWAGAX6PQT1WGd12GEZ4Ja/edit?usp=sharing&ouid=108345701896498198132&rtpof=true&sd=true" }, { name: "TradingView", url: "https://es.tradingview.com/chart/t5g9UFG0/" }, { name: "Telegram", url: "https://web.telegram.org/a/" }, { name: "Twitter", url: "https://x.com" }, { name: "Maesal Detailer", url: "https://www.maesaldetailer.es/" }, { name: "Superchargers", url: "https://www.tesla.com/es_es/findus?bounds=45.41107111786193%2C19.27853056943938%2C29.703668286784747%2C-16.64676239931062" }, { name: "TESLA web", url: "https://www.tesla.com/es_es" }, { name: "Manual M3", url: "https://www.tesla.com/ownersmanual/model3/es_es/" }, { name: "de Servicio", url: "https://service.tesla.com/docs/Model3/ServiceManual/2024/es-es/" }, { name: "de Despiece", url: "https://epc.tesla.com/es-MX/catalogs/e0e07c3d-272f-4d06-b8b6-9e92f857e5f3" }, { name: "de Usted Mismo", url: "https://www.tesla.com/es_es/support/do-it-yourself-guides" }, { name: "de Filtro Cabina", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-DB0A1E3C-926E-498C-A2FD-A27B8421A471.html" }, { name: "de Móvil remoto", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-53651B16-A2E3-4118-933E-B5F41C74D433.html" }, { name: "Waze (consultas)", url: "https://www.waze.com/es/live-map/", favicon: "https://www.google.com/s2/favicons?domain=waze.com&sz=64" }, { name: "AMAZON", url: "https://www.amazon.es" }, { name: "BIP&DRIVE", url: "https://areaprivada.bipdrive.com/login" }, { name: "ITV Cita", url: "https://www.sycitv.com/es/cita-previa-particulares/", favicon: "https://boardinggate.github.io/Tesla/itv.png" }, { name: "Deportes", url: "https://www.sofascore.com/es/tenis" }, null, { name: "Jaime Odena", url: "https://www.youtube.com/@JOdena", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Eduardo Arcos", url: "https://www.youtube.com/@earcos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "AutoIngenium", url: "https://www.youtube.com/@AutoIngenium", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Gallego en Munich", url: "https://www.youtube.com/@ungallegoenmunich", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Electromiaumiau", url: "https://www.youtube.com/@electromiaumiau", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Manuel Martos", url: "https://www.youtube.com/@Manuel_Martos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Todos Electricos", url: "https://www.youtube.com/@TodosElectricos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Juan Vidal Haces", url: "https://www.youtube.com/@JuanVidalHaces", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Ruedana", url: "https://www.youtube.com/@ruedana", favicon: "https://www.youtube.com/favicon.ico" }, { name: "STR-600", url: "https://www.youtube.com/@STR-600", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Juanjo T. Aventuras", url: "https://www.youtube.com/@juanjoteslaventuras", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Carlos Cuezva", url: "https://www.youtube.com/@CarlosCuezva", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Javi Manzanoo", url: "https://www.youtube.com/@javimanzanoo", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Crifedi", url: "https://www.youtube.com/@Crifedi", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Tescno Tesla", url: "https://www.youtube.com/@TecnoTesla", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Full Electric Mex", url: "https://www.youtube.com/@FullElectricMexico", favicon: "https://www.youtube.com/favicon.ico" }, null, null, { name: "La iA Jon", url: "https://www.youtube.com/@la_inteligencia_artificial", favicon: "https://www.youtube.com/favicon.ico" }, { name: "JF Ccalero", url: "https://www.youtube.com/@jfcalero", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Visual Politik", url: "https://www.youtube.com/@VisualPolitik", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Fabian Barrio", url: "https://www.youtube.com/@fabiancbarrio", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Loquetudigas", url: "https://www.youtube.com/@Loquetudigas", favicon: "https://www.youtube.com/favicon.ico" }, { name: "David Antunes", url: "https://www.youtube.com/@davidantunesmusic", favicon: "https://www.youtube.com/favicon.ico" }, { name: "TheWildProject", url: "https://www.youtube.com/@TheWildProject", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Estas Tonne", url: "https://www.youtube.com/@Estastonne", favicon: "https://www.youtube.com/favicon.ico" }, { name: "BBC6 Music", url: "https://www.youtube.com/@BBC6Music", favicon: "https://www.youtube.com/favicon.ico" }, null, null ];
    const originalToggleRanges = [ { start: 18, end: 29, name: "ELECTROVERSE", label: "PdR,s" }, { start: 30, end: 41, name: "GROK", label: "iAs" }, { start: 42, end: 59, name: "TradingView", label: "Útil" }, { start: 60, end: 95, name: "JOdena", label: "Varios" } ];

    // --- Global Variables ---
    const TOTAL_CELLS = 96; const COLS = 6; const grid = document.getElementById('bookmark-grid');
    let isDarkMode = false; let pressStartTime = null; let reminderPressStartTime = null; let isActive = true; let notices = []; let currentNoticeIndex = 0; let fromReminderModal = false; let isEditMode = false;
    let customData = { bookmarks: {}, toggles: {} };
    let cellElements = [];
    let currentBookmarks = []; // Inicializar vacío, se carga en loadCustomData
    let currentToggleRanges = []; // Inicializar vacío, se carga en loadCustomData
    let onOffToggle, weatherButton, reminderButton, zoomButton, darkModeToggle;

    // --- Helper Functions ---
    function clamp(min, val, max) { return Math.min(Math.max(val, min), max); }
    function formatDateToDDMMMYY(dateStr) {
        if (!dateStr || typeof dateStr !== 'string') return '-';
        const parts = dateStr.split('-'); // Espera YYYY-MM-DD
        if (parts.length !== 3) {
             // Intenta parsear DD/MM/YYYY si no es YYYY-MM-DD
            const parts2 = dateStr.split('/');
             if (parts2.length === 3) {
                 dateStr = `${parts2[2]}-${parts2[1]}-${parts2[0]}`;
             } else {
                // Si no es ninguno de los formatos esperados, intenta con Date parse
                try {
                    const d = new Date(dateStr);
                    if (!isNaN(d.getTime())) {
                         dateStr = `${d.getFullYear()}-${(d.getMonth() + 1).toString().padStart(2, '0')}-${d.getDate().toString().padStart(2, '0')}`;
                    } else {
                         return '-';
                    }
                } catch (e) {
                     return '-';
                }
             }
        }
        try {
            const [y, m, d] = dateStr.split('-');
            // Usar Date.UTC para crear la fecha en UTC y evitar problemas de zona horaria
            const date = new Date(Date.UTC(parseInt(y), parseInt(m) - 1, parseInt(d)));
            if (isNaN(date.getTime())) return '-';
            const day = date.getUTCDate(); // Usar getUTCDate
            const monthNames = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
            const month = monthNames[date.getUTCMonth()]; // Usar getUTCMonth
            const year = date.getUTCFullYear().toString().slice(-2); // Usar getUTCFullYear
            return `${day} ${month} ${year}`;
        } catch (e) {
            console.error("Error formatting date:", dateStr, e);
            return '-';
        }
    }


    function calculatePostponedDateTime(mins) {
        const now = new Date();
        const pDate = new Date(now.getTime() + mins * 60000);
        const iso = `${pDate.getFullYear()}-${(pDate.getMonth() + 1).toString().padStart(2, '0')}-${pDate.getDate().toString().padStart(2, '0')}`;
        const time = `${pDate.getHours().toString().padStart(2, '0')}:${pDate.getMinutes().toString().padStart(2, '0')}`;
        return { newDateISO: iso, newTime: time };
    }

    function cleanUpModalTimers(clearAll = true) {
        console.log("Clean timers:", clearAll);
        const modal = document.querySelector('.reminder-modal');
        if (modal) {
            if (modal.autoSaveInterval) clearInterval(modal.autoSaveInterval);
            if (modal.parseTimeout) clearTimeout(modal.parseTimeout);
            // restartTimeout ya no se usa
            // if (modal.restartTimeout) clearTimeout(modal.restartTimeout);
            if (clearAll && modal.focusTimeout) clearTimeout(modal.focusTimeout);
            delete modal.autoSaveInterval;
            delete modal.parseTimeout;
            // delete modal.restartTimeout;
            if (clearAll) delete modal.focusTimeout;
        }
         const tableModal = document.querySelector('.reminder-table-modal');
         if (tableModal && tableModal.autoCloseInterval) {
             clearInterval(tableModal.autoCloseInterval);
             delete tableModal.autoCloseInterval;
         }
         const postponeModal = document.getElementById('postpone-options-modal');
         if (postponeModal && postponeModal.autoPostponeInterval) {
             clearInterval(postponeModal.autoPostponeInterval);
             delete postponeModal.autoPostponeInterval;
         }
    }


    // --- Core Functions ---

    async function loadNotices() { try { const r = await fetch('https://boardinggate.github.io/Tesla/avisos.txt', { cache: 'no-cache' }); if (!r.ok) throw new Error('Fetch failed'); const txt = await r.text(); notices = txt.split('\n').map(l => l.trim()).filter(l => l.length > 0); if (notices.length === 0) notices = ['No hay avisos.']; } catch (e) { console.error('Avisos load err:', e); notices = ['Error carga avisos.']; } updateNotice(); }
    function updateNotice() { const noticeElement = document.getElementById('current-notice'); if (!noticeElement || notices.length === 0) { return; } if (!isActive) { noticeElement.textContent = ''; noticeElement.style.animation = 'none'; return; } noticeElement.textContent = notices[currentNoticeIndex]; noticeElement.style.animation = 'none'; void noticeElement.offsetWidth; noticeElement.style.animation = 'fadeInOut 14s infinite'; currentNoticeIndex = (currentNoticeIndex + 1) % notices.length; }
    // Corregida la función toggleNotices para usar display: block para el footer-content
    function toggleNotices() {
        isActive = !isActive;
        console.log('Toggling notices/footer block:', isActive);
        const nC = document.querySelector('.notices-container');
        const fC = document.querySelector('.footer-content');
        const cW = document.querySelector('.counter-container'); // Asegúrate de que este elemento existe con esta clase si quieres controlarlo
        const nE = document.getElementById('current-notice');

        if(nC) nC.style.display = isActive ? 'flex' : 'none'; // notices-container usa flex
        if(fC) fC.style.display = isActive ? 'block' : 'none'; // footer-content usa block (corregido)
        if (cW) cW.style.display = isActive ? 'flex' : 'none'; // counter-container usa flex

        if (nE) {
            if (!isActive) {
                nE.textContent = '';
                nE.style.animation = 'none';
            } else {
                currentNoticeIndex = 0; // Reiniciar para mostrar el primer aviso al activar
                startNoticeRotation(); // Reiniciar la rotación para empezar con el primer aviso
            }
        }
        saveSettings(); // Guardar el estado de isActive
    }

    function startNoticeRotation() {
         if (notices.length === 0 || !isActive) return; // Solo rotar si hay avisos y está activo
         // Limpiar cualquier intervalo existente antes de empezar uno nuevo
         if (window._noticeInterval) clearInterval(window._noticeInterval);
         updateNotice(); // Muestra el primer aviso al iniciar
         window._noticeInterval = setInterval(updateNotice, 14000); // Guarda la referencia del intervalo
     }

    function adjustButtonPositions() { const scrollToggle = document.getElementById('scroll-toggle'); if (!scrollToggle) { console.warn("Scroll toggle not found for positioning."); return; } const scrollToggleHeight = scrollToggle.offsetHeight; const buttonHeight = 74; const buttonSpacing = 4; const startTop = scrollToggleHeight + 13; const fixedButtons = [ document.getElementById('on-off-toggle'), ...document.querySelectorAll('.range-toggle'), document.getElementById('weather-button'), document.getElementById('reminder-button'), document.getElementById('zoom-button'), document.getElementById('dark-mode-toggle') ].filter(button => button !== null); // Filtra para asegurar que los botones existan if (fixedButtons.length === 0) { console.warn("No fixed side buttons found to position."); return; } let currentTop = startTop; fixedButtons.forEach((button) => { button.style.position = 'fixed'; button.style.top = `${currentTop}px`; button.style.left = '10px'; // Todos están a la izquierda currentTop += buttonHeight + buttonSpacing; }); console.log(`Adjusted positions for ${fixedButtons.length} side buttons.`); }

    function checkDarkModeTime() { const n = new Date(); const h = n.getHours(); const m = n.getMinutes(); return (h >= 21 || h < 7 || (h === 7 && m <= 30)); }
    function saveSettings() {
         localStorage.setItem('darkMode', JSON.stringify(isDarkMode));
         const tS = {};
         document.querySelectorAll('.range-toggle').forEach(t => {
             // Solo guardar si el estado es diferente del estado por defecto 'visible'
             if (t.dataset.state !== 'visible') {
                  tS[t.dataset.rangeStart] = t.dataset.state;
             }
         });
         // Si hay estados guardados, guárdalos, si no, elimina la clave
         if (Object.keys(tS).length > 0) {
             localStorage.setItem('toggleStates', JSON.stringify(tS));
         } else {
             localStorage.removeItem('toggleStates');
         }

         const zoomBtn = document.getElementById('zoom-button');
         if (zoomBtn) {
             // Solo guardar si el estado es 'on'
             if (zoomBtn.dataset.zoomState === 'on') {
                 localStorage.setItem('zoomState', zoomBtn.dataset.zoomState);
             } else {
                 localStorage.removeItem('zoomState');
             }
         }

         const onOffBtn = document.getElementById('on-off-toggle');
         if (onOffBtn) {
             // Solo guardar si el estado es 'off'
             if (onOffBtn.dataset.state === 'off') {
                 localStorage.setItem('onOffState', onOffBtn.dataset.state);
             } else {
                 localStorage.removeItem('onOffState');
             }
         }
         // Siempre guardar el estado de los avisos/footer, ya que el estado por defecto es 'activo'
         localStorage.setItem('noticesActive', JSON.stringify(isActive));

         // isFooterVisible y toggleFooterVisibility ya no se usan para el toggle interactivo
         // localStorage.setItem('footerVisible', JSON.stringify(isFooterVisible));

         console.log('UI Settings saved.');
     }

    function saveCustomData() {
         try {
             // Limpiar customData de entradas que son idénticas a los originales
             const cleanedCustomBookmarks = {};
             originalBookmarks.forEach((originalB, index) => {
                 const customB = customData.bookmarks[index];
                 // Verificar si customB existe y es diferente del original
                 if (customB !== undefined && ( // customB exists (even if null)
                     (originalB === null && customB !== null) || // Original was null but custom is not null
                     (originalB !== null && customB === null) || // Original was not null but custom is null
                     (originalB === undefined && customB !== null) || // Original index didn't exist, but custom exists (new addition)
                     (originalB !== null && customB !== null && ( // Both not null, compare properties
                         originalB.name !== customB.name ||
                         originalB.url !== customB.url ||
                         (originalB.favicon || '') !== (customB.favicon || '') // Compare favicons (treat null/undefined as '')
                     ))
                 )) {
                      cleanedCustomBookmarks[index] = customB; // Keep the custom data (can be null for deletion)
                 } else if (originalB !== undefined && customB === undefined && customData.bookmarks.hasOwnProperty(index)) {
                      // Handle the case where there was a customization explicitly set (even if null)
                      // but now it's "undefined" in the current customData structure, meaning it was deleted.
                      // This case shouldn't add to cleanedCustomBookmarks, effectively removing it.
                 }
             });

             const cleanedCustomToggles = {};
             originalToggleRanges.forEach(originalT => {
                  const customT = customData.toggles[originalT.start];
                  if (customT && originalT.label !== customT.label) {
                       cleanedCustomToggles[originalT.start] = customT;
                  }
             });

             // Solo guardar si hay datos personalizados que no son los originales
             if (Object.keys(cleanedCustomBookmarks).length > 0 || Object.keys(cleanedCustomToggles).length > 0) {
                 customData = { bookmarks: cleanedCustomBookmarks, toggles: cleanedCustomToggles };
                 localStorage.setItem('customGridData', JSON.stringify(customData));
                 console.log("Custom grid data saved.", customData);
             } else {
                 // Si no hay personalizaciones efectivas, eliminar la clave
                 localStorage.removeItem('customGridData');
                 customData = { bookmarks: {}, toggles: {} }; // Reset customData in memory
                 console.log("No custom grid data to save. Removed key.");
             }

         } catch (e) {
             console.error("Error saving custom grid data:", e);
             showToast("Error al guardar personalización", "error");
         }
     }


     function loadCustomData() {
         const savedData = localStorage.getItem('customGridData');
         if (savedData) {
             try {
                 customData = JSON.parse(savedData);
                 console.log("Parsed custom data:", customData);

                 // Aplicar personalizaciones a originalBookmarks para crear currentBookmarks
                 currentBookmarks = originalBookmarks.slice(); // Start with a copy of originalBookmarks array
                 while (currentBookmarks.length < TOTAL_CELLS) {
                      currentBookmarks.push(null); // Ensure the array has enough slots, fill with null initially
                 }

                 // Apply custom bookmarks, potentially replacing original ones or filling null slots
                 if (customData.bookmarks) {
                      Object.keys(customData.bookmarks).forEach(indexStr => {
                           const index = parseInt(indexStr);
                           if (!isNaN(index) && index >= 0 && index < TOTAL_CELLS) {
                                currentBookmarks[index] = customData.bookmarks[index]; // Can be null if deleted via customisation
                           } else {
                                console.warn(`Invalid custom bookmark index: ${indexStr}. Skipping.`);
                           }
                      });
                 }


                 // Apply personalizations to originalToggleRanges for creating currentToggleRanges
                 currentToggleRanges = originalToggleRanges.map(range => {
                     // If there is a customization for this section (using the start as key)
                     if (customData.toggles?.[range.start]?.label) {
                         // Create a new object range with the personalized label
                         return { ...range, label: customData.toggles[range.start].label };
                     }
                     // If no personalization, use the original
                     return range;
                 });

                 console.log("Custom grid data loaded. currentBookmarks:", currentBookmarks, "currentToggleRanges:", currentToggleRanges);
             } catch (e) {
                 console.error("Error parsing custom grid data:", e);
                 // In case of error, reset to original data and delete customData
                 customData = { bookmarks: {}, toggles: {} };
                 currentBookmarks = originalBookmarks.slice();
                 while (currentBookmarks.length < TOTAL_CELLS) {
                      currentBookmarks.push(null); // Rellenar con null si es necesario
                 }
                 currentToggleRanges = JSON.parse(JSON.stringify(originalToggleRanges));
                 localStorage.removeItem('customGridData'); // Clear corrupted data
                 showToast("Error al cargar personalización. Reestablecido a original.", "error", 5000);
             }
         } else {
             // If no data saved, use the originals
             currentBookmarks = originalBookmarks.slice();
              while (currentBookmarks.length < TOTAL_CELLS) {
                   currentBookmarks.push(null); // Rellenar con null si es necesario
              }
             currentToggleRanges = JSON.parse(JSON.stringify(originalToggleRanges));
             console.log("No custom grid data found. Using original data.");
         }
     }


    function loadSavedSettings() {
         const savedDarkMode = localStorage.getItem('darkMode');
         isDarkMode = savedDarkMode ? JSON.parse(savedDarkMode) : checkDarkModeTime();
         if (isDarkMode) document.body.classList.add('dark-mode');

         const savedZoomState = localStorage.getItem('zoomState');
         const zoomButton = document.getElementById('zoom-button');
         if (savedZoomState && zoomButton) {
             zoomButton.dataset.zoomState = savedZoomState;
             applyZoom(savedZoomState);
         }

         // Usar setTimeout(..., 0) permite que el DOM termine de renderizarse antes de aplicar visibilidad
         setTimeout(() => {
             const savedToggleStates = localStorage.getItem('toggleStates');
             const savedOnOffState = localStorage.getItem('onOffState');
             const savedNoticesActive = localStorage.getItem('noticesActive');
             // isFooterVisible y footerVisible ya no se usan para el toggle interactivo, solo isActive
             // const savedFooterVisible = localStorage.getItem('footerVisible');

             const onOffToggle = document.getElementById('on-off-toggle');
             if (onOffToggle) {
                 // Establecer estado On/Off general
                 onOffToggle.dataset.state = savedOnOffState || 'on';
             }
             const masterState = onOffToggle?.dataset.state || 'on';

             // Aplicar visibilidad inicial a las primeras celdas
             for (let i = 0; i <= 17; i++) {
                 if (cellElements[i]) {
                     cellElements[i].classList.toggle('hidden', masterState === 'off');
                 }
             }

             // Establecer estado de los toggles de rango y aplicar visibilidad
             const savedToggleStatesParsed = savedToggleStates ? JSON.parse(savedToggleStates) : {};
             document.querySelectorAll('.range-toggle').forEach(toggle => {
                 const start = parseInt(toggle.dataset.rangeStart);
                 const range = currentToggleRanges.find(r => r.start === start); // Usar currentToggleRanges
                 if (!range) {
                      console.warn(`Range config not found for toggle with start ${start}. Skipping visibility.`);
                      return; // Asegurarse de que el rango existe
                 }

                 const currentState = savedToggleStatesParsed[start] || 'visible';
                 toggle.dataset.state = currentState;
                 toggle.innerHTML = `<span class="sign">${currentState === 'visible' ? '-' : '+'}</span>${range.label}`; // Usar label de currentToggleRanges

                 const end = parseInt(toggle.dataset.rangeEnd);
                 if (!isNaN(start) && !isNaN(end)) {
                      const shouldHide = masterState === 'off' || currentState === 'hidden';
                      for (let i = start; i <= end; i++) {
                           if (cellElements[i]) {
                                cellElements[i].classList.toggle('hidden', shouldHide);
                           }
                      }
                 } else {
                     console.warn(`Invalid start/end range for toggle with start ${start}. Cannot apply visibility.`);
                 }
             });

             // Establecer estado de avisos/footer y aplicarlo
             isActive = savedNoticesActive ? JSON.parse(savedNoticesActive) : true;
             // Llamar a toggleNotices para aplicar el estado inicial de avisos/footer
             // La función toggleNotices invierte el estado. Para aplicar un estado cargado,
             // debemos simular la lógica de la función o llamar a las partes internas.
             // Llamemos a las partes internas para evitar la inversión:
             const nC = document.querySelector('.notices-container');
             const fC = document.querySelector('.footer-content');
             const cW = document.querySelector('.counter-container'); // Usar .counter-container

             if(nC) nC.style.display = isActive ? 'flex' : 'none';
             if(fC) fC.style.display = isActive ? 'block' : 'none'; // Corregido aquí también para la carga inicial
             if (cW) cW.style.display = isActive ? 'flex' : 'none';

              // La actualización del aviso actual se manejará por startNoticeRotation en DOMContentLoaded


             // isFooterVisible ya no se usa para el toggle interactivo
             // isFooterVisible = savedFooterVisible ? JSON.parse(savedFooterVisible) : true;
             // toggleFooterVisibility(); // Esta función ya no es necesaria para el toggle interactivo

             updateButtonStyles(); // Actualizar estilos de todos los botones según estados
             loadReminders(); // Cargar recordatorios guardados y chequear
             adjustButtonPositions(); // Posicionar todos los botones
             updateUserIdDisplay(); // Mostrar ID de usuario si existe

         }, 0); // Ejecutar después de que el DOM esté listo
     }


    function loadReminders() {
         console.log('Loading reminders...');
        updateReminderCount(); // Cargar el contador inicial
        // checkReminders se llamará en DOMContentLoaded para manejar el lastClosedTimestamp correctamente.
    }


    function updateUserIdDisplay() { const userIdDisplay = document.getElementById('user-id-display'); const userId = localStorage.getItem('userData_userId'); if (userIdDisplay) { if (userId) { userIdDisplay.textContent = userId.trim(); userIdDisplay.style.display = 'block'; } else { userIdDisplay.textContent = ''; userIdDisplay.style.display = 'none'; } } }
    function applyZoom(state) { const originalWidth = 984; const adjustedWidth = 935; const originalCols = 6; const zoomedCols = 4; const gap = 15; // No cambiar el gap let gridWidth, numCols; if (state === 'on') { gridWidth = adjustedWidth; numCols = zoomedCols; } else { gridWidth = originalWidth; numCols = originalCols; } // Calcular el ancho de columna basado en el ancho total y el gap grid.style.gridTemplateColumns = `repeat(${numCols}, minmax(120px, 1fr))`; // Usar minmax o auto si es necesario grid.style.gap = `${gap}px`; grid.style.maxWidth = `${gridWidth}px`; // Asegurarse de que el ancho de celda se adapte al grid CSS // No establecer ancho/alto fijo a las celdas, dejar que el grid lo maneje document.querySelectorAll('#bookmark-grid > div').forEach(c => { c.style.width = ''; c.style.height = ''; }); // Ajustar tamaño de iconos y texto independientemente del tamaño de celda document.querySelectorAll('.bookmark-item img').forEach(i => { i.style.width = state === 'on' ? '48px' : '36px'; i.style.maxWidth = state === 'on' ? '56px' : '40px'; }); document.querySelectorAll('.bookmark-name').forEach(n => { n.style.fontSize = state === 'on' ? 'clamp(1.05rem, 1.8vw, 1.35rem)' : 'clamp(0.85rem, 1.5vw, 1.15rem)'; }); document.querySelectorAll('.small-bookmark img').forEach(i => { i.style.width = state === 'on' ? '48px' : '24px'; i.style.maxWidth = state === 'on' ? '56px' : '28px'; }); document.querySelectorAll('.small-bookmark .bookmark-name').forEach(n => { n.style.fontSize = state === 'on' ? 'clamp(1.05rem, 1.8vw, 1.35rem)' : 'clamp(0.85rem, 1.5vw, 1.15rem)'; }); const zoomButton = document.getElementById('zoom-button'); if (zoomButton) { zoomButton.innerHTML = `<img src="./zoon-${state === 'on' ? '+' : '-'}.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; } adjustButtonPositions(); // Ajustar posición de botones laterales después del zoom }
    function updateButtonStyles() { const darkModeToggle = document.getElementById('dark-mode-toggle'); const onOffToggle = document.getElementById('on-off-toggle'); const toggleButtons = document.querySelectorAll('.toggle-sign.range-toggle'); const weatherButton = document.getElementById('weather-button'); const zoomButton = document.getElementById('zoom-button'); const reminderButton = document.getElementById('reminder-button'); if (onOffToggle) { onOffToggle.src = `https://boardinggate.github.io/Tesla/${onOffToggle.dataset.state === 'on' ? 'IMG_4192.jpg' : 'IMG_4191.jpg'}`; onOffToggle.alt = `Toggle ${onOffToggle.dataset.state === 'on' ? 'On' : 'Off'}`; } if (darkModeToggle) { darkModeToggle.src = `https://boardinggate.github.io/Tesla/${isDarkMode ? 'oscuro2.png' : 'claro2.png'}`; darkModeToggle.alt = `Toggle ${isDarkMode ? 'Oscuro' : 'Claro'}`; } const reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); const pendingCount = reminders.length; if (reminderButton) { reminderButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4197.jpg" alt="Recordatorio" style="max-width: 70%; max-height: 70%; object-fit: contain;">${pendingCount > 0 ? `<span class="reminder-count">${pendingCount}</span>` : ''}`; reminderButton.style.backgroundColor = '#ABAB99'; } // Los botones laterales siempre tienen el mismo fondo base, el modo oscuro se maneja en CSS if (isDarkMode) { document.querySelectorAll('.toggle-sign, .toggle-image').forEach(btn => { if (btn.id !== 'config-button' && btn.id !== 'personal-button' && btn.id !== 'home-button' && btn.id !== 'reload-button') { // Excluir botones superiores si tienen estilos diferentes btn.style.backgroundColor = '#ABAB99'; // Aplicar color base oscuro si es necesario, aunque el filtro CSS lo haría } }); } else { document.querySelectorAll('.toggle-sign, .toggle-image').forEach(btn => { if (btn.id !== 'config-button' && btn.id !== 'personal-button' && btn.id !== 'home-button' && btn.id !== 'reload-button') { btn.style.backgroundColor = '#ABAB99'; // Aplicar color base claro } }); } }
    function formatVersionDate(date) { const y = date.getUTCFullYear().toString().slice(-2); const m = String(date.getUTCMonth() + 1).padStart(2, '0'); const d = String(date.getUTCDate()).padStart(2, '0'); const h = String(date.getUTCHours()).padStart(2, '0'); return `${y}.${m}.${d}${h}`; }
    async function getLastModifiedDate() { const k = 'teslaHtmlLastModified'; const tk = 'teslaHtmlLastModifiedTimestamp'; const dur = 86400000; // 24 horas const cd = localStorage.getItem(k); const ct = localStorage.getItem(tk); const now = Date.now(); if (cd && ct && now - ct < dur) return new Date(cd); try { const r = await fetch('https://boardinggate.github.io/Tesla/version.txt', { cache: 'no-cache' }); if (!r.ok) throw new Error(`HTTP ${r.status}`); const txt = await r.text(); const lmd = new Date(txt.trim()); if (isNaN(lmd.getTime())) throw new Error('Invalid date format'); localStorage.setItem(k, lmd.toISOString()); localStorage.setItem(tk, now.toString()); return lmd; } catch (e) { console.error('Error fetching version.txt:', e); if (cd) return new Date(cd); return new Date('2024-01-01T00:00:00Z'); // Fecha de fallback } }
    async function updateVersion() { try { const lmd = await getLastModifiedDate(); const v = formatVersionDate(lmd); const el = document.getElementById('version'); if (el) el.textContent = `versión: ${v}`; } catch (e) { console.error("Failed update version:", e); const el = document.getElementById('version'); if (el) el.textContent = 'versión: error'; } }
    const getFaviconUrl = (bookmarkData) => { try { const urlToParse = bookmarkData?.url || ''; const customFavicon = bookmarkData?.favicon; if (customFavicon && (customFavicon.startsWith('data:image') || customFavicon.startsWith('http') || customFavicon.startsWith('./'))) return customFavicon; if (urlToParse) { const domain = new URL(urlToParse).hostname; return `https://www.google.com/s2/favicons?domain=${domain}&sz=64`; } } catch (e) { console.warn(`Invalid URL for favicon: ${bookmarkData?.url}`, e); } return 'https://via.placeholder.com/64'; }; // Fallback genérico si la URL es inválida o no hay URL asociada
    function generateBrightColor() { const h = Math.floor(Math.random() * 360); const s = 40 + Math.floor(Math.random() * 30); const l = 80 + Math.floor(Math.random() * 15); return `hsla(${h}, ${s}%, ${l}%, 0.64)`; }
    function areColorsSimilar(c1, c2) { if (!c1 || !c2) return false; try { const [h1] = c1.match(/\d+/g).map(Number); const [h2] = c2.match(/\d+/g).map(Number); const d = Math.abs(h1 - h2); return Math.min(d, 360 - d) < 60; // Considerar similar si la diferencia de tono es menor a 60 grados } catch (e) { console.error("Color compare error:", c1, c2, e); return false; } }

    // --- Render Grid ---
     function renderGrid() {
         grid.innerHTML = '';
         cellElements.length = 0; // Limpiar la lista de elementos de celda
         const colors = Array(TOTAL_CELLS).fill(null);

         // Generar colores asegurando que no haya colores similares adyacentes (simple check)
         for (let i = 0; i < TOTAL_CELLS; i++) {
             if (currentBookmarks[i] !== null && currentBookmarks[i] !== undefined) {
                 let color;
                 let attempts = 0;
                 do {
                     color = generateBrightColor();
                     attempts++;
                 } while (
                     attempts < 20 && // Limitar intentos para evitar bucles infinitos
                     (
                          // Check celda superior
                         (i >= COLS && colors[i - COLS] !== null && areColorsSimilar(color, colors[i - COLS])) ||
                         // Check celda izquierda
                         (i % COLS !== 0 && colors[i - 1] !== null && areColorsSimilar(color, colors[i - 1]))
                     )
                 );
                 if(attempts >= 20) console.warn(`Could not find non-similar color for cell ${i}. Using last attempt.`);
                 colors[i] = color;
             } else {
                  colors[i] = null; // Asegurarse de que las celdas vacías no tengan color
             }
         }

         Array.from({ length: TOTAL_CELLS }).forEach((_, index) => {
             const cell = document.createElement('div');
             const bookmarkData = currentBookmarks[index]; // Usar currentBookmarks

             if (index < currentBookmarks.length && bookmarkData !== null && bookmarkData !== undefined) {
                 const link = document.createElement('a');
                 link.className = 'bookmark-item';
                 link.title = bookmarkData.name || ''; // Asegurarse de que title no es undefined
                 link.dataset.index = index; // Guardar el índice original para edición

                 const colorValues = colors[index]?.match(/hsla\((\d+),\s*(\d+)%,\s*(\d+)%/);
                 if(colorValues) {
                      link.style.setProperty('--hue', colorValues[1]);
                      link.style.setProperty('--saturation', colorValues[2] + '%');
                      link.style.setProperty('--lightness', colorValues[3] + '%');
                 } else {
                     // Si no se generó color (ej. celda originalmente null), usar color por defecto del CSS
                      link.style.backgroundColor = ''; // Eliminar estilo inline si existía
                 }

                 if (bookmarkData.url) { // Solo crear link si hay URL
                     link.href = bookmarkData.url;
                     if (bookmarkData.name !== "Inicio Tesla" && bookmarkData.name !== "") { // Permitir apertura en nueva pestaña excepto para los nombres específicos
                         link.target = "_blank";
                         link.rel = "noopener noreferrer";
                     }
                     const img = document.createElement('img');
                     img.src = getFaviconUrl(bookmarkData);
                     img.alt = `Favicon ${bookmarkData.name || ''}`;
                     img.loading = "lazy";
                     img.onerror = () => {
                          console.warn(`Favicon load failed for: ${bookmarkData.name || 'Unnamed'} at ${img.src}`);
                          img.src = 'https://via.placeholder.com/64'; // Fallback a imagen genérica
                          img.onerror = null; // Evitar bucle infinito
                      };

                     // Aplicar filtros especiales si existen
                     if (bookmarkData.name === "Mis Updates") img.classList.add('favicon-red');
                     else if (bookmarkData.name === "Olas Updates") img.classList.add('favicon-blue');

                     const nameSpan = document.createElement('span');
                     nameSpan.className = 'bookmark-name';
                     nameSpan.textContent = bookmarkData.name || ''; // Asegurarse de que textContent no es undefined

                     link.appendChild(img);
                     link.appendChild(nameSpan);

                     // Listener para el modo edición
                     link.addEventListener('click', (event) => {
                         if (isEditMode) {
                             event.preventDefault(); // Evitar ir a la URL
                             showEditModal(index); // Mostrar modal de edición para este índice
                         }
                         // Si no está en modo edición, el enlace funciona normalmente por defecto
                     });

                 } else {
                      // Si no hay URL, sigue siendo clickeable en modo edición pero no tiene href
                      link.href = "#"; // Evitar error de link vacío
                       link.addEventListener('click', (event) => {
                         if (isEditMode) {
                             event.preventDefault(); // Evitar ir a la URL (aunque sea #)
                             showEditModal(index); // Mostrar modal de edición
                         }
                     });
                      // Crear solo el nombre si no hay URL? O dejarlo vacío como estaba?
                      // Basado en la implementación original, si no hay URL, no se crea contenido dentro del <a>
                      // Para mantener la edición, necesitamos el <a>, pero sin contenido visible si no hay URL/nombre?
                      // Vamos a mantener la estructura de link clickeable en edición, incluso si está "vacío"
                       const img = document.createElement('img'); // Poner un placeholder o icono genérico
                       img.src = 'https://via.placeholder.com/64'; // Placeholder gris
                       img.alt = `Celda vacía ${index}`;
                       const nameSpan = document.createElement('span');
                       nameSpan.className = 'bookmark-name';
                       nameSpan.textContent = bookmarkData.name || ''; // Si hay nombre pero no URL

                       if (bookmarkData.name || bookmarkData.favicon) { // Si tiene nombre o favicon pero no URL, mostrar eso
                            if (bookmarkData.favicon) img.src = getFaviconUrl(bookmarkData); // Intentar cargar favicon si hay URL/dato
                            link.appendChild(img);
                            if (bookmarkData.name) link.appendChild(nameSpan);
                            // Opcional: añadir clase para celdas incompletas para estilizar
                            cell.classList.add('incomplete-bookmark');
                       } else {
                           // Celda completamente vacía pero editable? Dejar <a> vacío
                           // La clase bg-gray-50 border border-dashed ya indica que está vacío
                       }
                 }

                 cell.appendChild(link);

             } else {
                 // Si el bookmarkData es null o undefined para este índice
                 cell.className = 'bg-gray-50 border border-dashed border-gray-200 rounded-lg'; // Clases para celda vacía
                 cell.style.backgroundColor = 'transparent'; // Asegurarse de que no tenga color de bookmark
                 // Hacer la celda vacía clickeable en modo edición para añadir un bookmark
                 if (isEditMode) {
                     cell.dataset.index = index;
                     cell.addEventListener('click', function() { // Usar function() para 'this'
                          if (isEditMode && this.classList.contains('editable')) {
                               showEditModal(parseInt(this.dataset.index));
                          }
                     });
                      // Opcional: añadir un icono + o texto para indicar que es editable
                      cell.style.display = 'flex'; // Asegurar display flex para centrar
                      cell.style.alignItems = 'center';
                      cell.style.justifyContent = 'center';
                       cell.textContent = '+'; // Indicador visual
                        cell.style.fontSize = '2em';
                        cell.style.color = '#ccc';
                        cell.style.cursor = 'crosshair';
                        cell.classList.add('editable'); // Añadir clase editable también
                 }
             }

             grid.appendChild(cell);
             cellElements.push(cell); // Añadir la celda al array global
         });
         applyToggleVisibility(); // Aplicar visibilidad después de renderizar todas las celdas
     }

    // --- Render Toggle Buttons ---
     function renderToggleButtons() {
         // Eliminar botones de rango existentes antes de renderizar de nuevo
         document.querySelectorAll('.range-toggle').forEach(btn => btn.remove());

         const masterState = document.getElementById('on-off-toggle')?.dataset.state || 'on';
         const savedToggleStates = JSON.parse(localStorage.getItem('toggleStates') || '{}');

         // Usar currentToggleRanges para renderizar
         currentToggleRanges.forEach((range) => {
             const toggle = document.createElement('span');
             toggle.className = 'toggle-sign range-toggle';
             toggle.dataset.rangeStart = range.start;
             toggle.dataset.rangeEnd = range.end;

             // Cargar estado guardado o usar 'visible' por defecto
             const currentState = savedToggleStates[range.start] || 'visible';
             toggle.dataset.state = currentState;

             // Usar la etiqueta del rango (puede ser personalizada o original)
             toggle.innerHTML = `<span class="sign">${currentState === 'visible' ? '-' : '+'}</span>${range.label}`;

             // Posición inicial (será ajustada por adjustButtonPositions)
             toggle.style.position = 'fixed';
             toggle.style.top = '100px'; // Posición temporal
             toggle.style.left = '10px'; // Posición temporal

             // Añadir listener de click
             toggle.addEventListener('click', (event) => {
                 if (isEditMode) {
                     event.preventDefault(); // Prevenir acción normal en modo edición
                     showEditModal(range.start, true); // Mostrar modal de edición para toggle
                 } else {
                     // Si no está en modo edición, actualizar el estado
                     updateToggleState(toggle);
                 }
             });

             document.body.appendChild(toggle);
         });

         // Llamar a adjustButtonPositions después de añadir los botones
         adjustButtonPositions();
     }

     // Function to create OTHER buttons (not section toggles)
     function createOtherButtons() {
         // Botón On/Off General
         if (!document.getElementById('on-off-toggle')) {
             onOffToggle = document.createElement('img');
             onOffToggle.className = 'toggle-image'; // o toggle-sign si quieres texto
             onOffToggle.id = 'on-off-toggle';
             onOffToggle.dataset.state = 'on'; // Estado por defecto
             onOffToggle.src = `https://boardinggate.github.io/Tesla/IMG_4192.jpg`; // Imagen por defecto (ON)
             onOffToggle.alt = 'Toggle On';
             document.body.appendChild(onOffToggle);
             // Listeners para detectar pulsación larga
             onOffToggle.addEventListener('mousedown', () => { pressStartTime = Date.now(); });
             onOffToggle.addEventListener('mouseup', handleOnOffAction);
             onOffToggle.addEventListener('mouseleave', () => { pressStartTime = null; }); // Cancelar si el ratón sale
             onOffToggle.addEventListener('touchstart', (e) => { e.preventDefault(); pressStartTime = Date.now(); });
             onOffToggle.addEventListener('touchend', (e) => { e.preventDefault(); handleOnOffAction(); });
         }

         // Botón Tiempo
         if (!document.getElementById('weather-button')) {
             weatherButton = document.createElement('span'); // Usar span para el texto o imagen dentro
             weatherButton.className = 'toggle-sign'; // o toggle-image si solo es imagen
             weatherButton.id = 'weather-button';
             weatherButton.innerHTML = `<img src="https://www.google.com/s2/favicons?domain=ventusky.com&sz=64" alt="Tiempo" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; // Usar favicon de ventusky.com
             document.body.appendChild(weatherButton);
             weatherButton.addEventListener('click', () => {
                 if (isEditMode) return; // No hacer nada en modo edición
                 window.open('https://www.ventusky.com/?p=40.2;-4.7;5&l=rain-3h', '_blank'); // Abrir en nueva pestaña
             });
         }

         // Botón Recordatorios (con globo de contador)
         if (!document.getElementById('reminder-button')) {
             reminderButton = document.createElement('span'); // Usar span para poder añadir el contador dentro
             reminderButton.className = 'toggle-sign';
             reminderButton.id = 'reminder-button';
              // El contenido (imagen y contador) se actualiza en updateButtonStyles
             document.body.appendChild(reminderButton);
             // Listeners para detectar pulsación larga (para ver tabla)
             reminderButton.addEventListener('mousedown', () => { reminderPressStartTime = Date.now(); });
             reminderButton.addEventListener('mouseup', handleReminderLongPress);
             reminderButton.addEventListener('mouseleave', () => { reminderPressStartTime = null; }); // Cancelar si el ratón sale
             reminderButton.addEventListener('touchstart', (e) => { e.preventDefault(); reminderPressStartTime = Date.now(); });
             reminderButton.addEventListener('touchend', (e) => { e.preventDefault(); handleReminderLongPress(); });
         }

         // Botón Zoom Grid
         if (!document.getElementById('zoom-button')) {
             zoomButton = document.createElement('span');
             zoomButton.className = 'toggle-sign';
             zoomButton.id = 'zoom-button';
             zoomButton.innerHTML = `<img src="./zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; // Icono por defecto (zoom out)
             zoomButton.dataset.zoomState = 'off'; // Estado por defecto
             document.body.appendChild(zoomButton);
             zoomButton.addEventListener('click', () => {
                 if (isEditMode) return; // No hacer nada en modo edición
                 const currentState = zoomButton.dataset.zoomState;
                 const newState = currentState === 'off' ? 'on' : 'off';
                 applyZoom(newState); // Aplicar el nuevo estado de zoom
                 zoomButton.dataset.zoomState = newState; // Guardar el nuevo estado en el dataset
                 updateButtonStyles(); // Actualizar icono del botón
                 saveSettings(); // Guardar el estado del zoom
                 adjustButtonPositions(); // Ajustar posiciones después del zoom
             });
         }

         // Botón Modo Oscuro/Claro
         if (!document.getElementById('dark-mode-toggle')) {
             darkModeToggle = document.createElement('img'); // Usar img si solo es imagen
             darkModeToggle.className = 'toggle-image'; // o toggle-sign
             darkModeToggle.id = 'dark-mode-toggle';
             // La src y alt se actualizan en updateButtonStyles
             document.body.appendChild(darkModeToggle);
             darkModeToggle.addEventListener('click', () => {
                 isDarkMode = !isDarkMode; // Cambiar el estado del modo oscuro
                 document.body.classList.toggle('dark-mode', isDarkMode); // Aplicar/remover clase al body
                 updateButtonStyles(); // Actualizar icono del botón
                 saveSettings(); // Guardar el estado del modo oscuro
             });
         }

         // Botones Superiores (Config, Personal, Home, Reload) - Ya existían en el HTML original
         // Solo asegúrate de que los IDs coinciden y que los listeners se añadan
         const configButton = document.getElementById('config-button');
         if (configButton) {
             configButton.addEventListener('click', () => showConfigModal());
         }
         const personalButton = document.getElementById('personal-button');
         if (personalButton) {
             personalButton.addEventListener('click', toggleEditMode);
         }
         const homeButton = document.getElementById('home-button');
         if (homeButton) {
             homeButton.addEventListener('click', (e) => {
                 if (isEditMode) { e.preventDefault(); return; }
                 window.history.back(); // O podrías poner una URL específica si 'home' no es 'atrás'
             });
         }
         const reloadButton = document.getElementById('reload-button');
         if (reloadButton) {
             reloadButton.addEventListener('click', () => {
                  if (isEditMode) return;
                  location.reload();
              });
         }

         // Llamar a adjustButtonPositions para posicionar todos los botones creados
         adjustButtonPositions();
     }


     // Helper to apply visibility after rendering/loading
     function applyToggleVisibility() {
         const onOffToggle = document.getElementById('on-off-toggle');
         const masterState = onOffToggle?.dataset.state || 'on'; // Estado general ON/OFF

         // Aplicar visibilidad a las primeras 18 celdas
         for (let i = 0; i <= 17; i++) {
             if (cellElements[i]) {
                 // Si el masterState es 'off', ocultar siempre
                 cellElements[i].classList.toggle('hidden', masterState === 'off');
             }
         }

         // Aplicar visibilidad a los rangos controlados por los toggles específicos
         document.querySelectorAll('.range-toggle').forEach(toggle => {
             const start = parseInt(toggle.dataset.rangeStart);
             const end = parseInt(toggle.dataset.rangeEnd);
             const state = toggle.dataset.state; // Estado individual del rango (visible/hidden)

             if (!isNaN(start) && !isNaN(end)) {
                 // Ocultar si el masterState es 'off' O si el estado individual del rango es 'hidden'
                 const shouldHide = masterState === 'off' || state === 'hidden';
                 for (let i = start; i <= end; i++) {
                     if (cellElements[i]) {
                         cellElements[i].classList.toggle('hidden', shouldHide);
                     }
                 }
             }
         });
     }


    // --- Event Listeners ---

    function updateToggleState(toggle) {
        if (!toggle || isEditMode) return; // No hacer nada en modo edición

        const start = parseInt(toggle.dataset.rangeStart);
        const end = parseInt(toggle.dataset.rangeEnd);
        if (isNaN(start) || isNaN(end)) {
             console.error("Invalid range data on toggle", toggle);
             return;
        }

        const currentState = toggle.dataset.state;
        const newState = currentState === 'visible' ? 'hidden' : 'visible';

        const rangeConfig = currentToggleRanges.find(r => r.start === start);
        const label = rangeConfig?.label || `Rango ${start}`; // Usar la etiqueta actual

        toggle.dataset.state = newState;
        toggle.innerHTML = `<span class="sign">${newState === 'visible' ? '-' : '+'}</span>${label}`;

        const masterState = document.getElementById('on-off-toggle')?.dataset.state || 'on';

        // Aplicar la visibilidad a las celdas dentro de este rango
        const shouldHide = masterState === 'off' || newState === 'hidden';
        for (let i = start; i <= end; i++) {
            if (cellElements[i]) {
                cellElements[i].classList.toggle('hidden', shouldHide);
            }
        }

        // Guardar el estado de este toggle
        const savedStates = JSON.parse(localStorage.getItem('toggleStates') || '{}');
         if (newState === 'visible') {
             delete savedStates[start]; // Si vuelve al estado por defecto, no guardar
         } else {
             savedStates[start] = newState; // Guardar solo si es 'hidden'
         }

         if (Object.keys(savedStates).length > 0) {
             localStorage.setItem('toggleStates', JSON.stringify(savedStates));
         } else {
              localStorage.removeItem('toggleStates'); // Eliminar la clave si está vacía
         }


        updateButtonStyles(); // Actualizar estilos si es necesario (ej. color del toggle)
    }

     function updateAllToggles(newState) {
         const onOffToggle = document.getElementById('on-off-toggle');
         if (!onOffToggle) return;

         onOffToggle.dataset.state = newState;

         // Aplicar visibilidad a las primeras 18 celdas
         for (let i = 0; i <= 17; i++) {
             if (cellElements[i]) {
                 cellElements[i].classList.toggle('hidden', newState === 'off');
             }
         }

         // Aplicar visibilidad a los rangos controlados por los toggles específicos
         document.querySelectorAll('.toggle-sign.range-toggle').forEach(toggle => {
             const start = parseInt(toggle.dataset.rangeStart);
             const end = parseInt(toggle.dataset.rangeEnd);
             if (isNaN(start) || isNaN(end)) return;

             const individualState = toggle.dataset.state; // Estado individual del rango
             const rangeConfig = currentToggleRanges.find(r => r.start === start);
             const label = rangeConfig?.label || `Rango ${start}`;

             // La visibilidad depende del estado general (newState) Y del estado individual
             const shouldHide = newState === 'off' || individualState === 'hidden';
             for (let i = start; i <= end; i++) {
                 if (cellElements[i]) {
                     cellElements[i].classList.toggle('hidden', shouldHide);
                 }
             }

             // El icono del toggle de rango no cambia, solo su visibilidad efectiva si el general está OFF
             // pero su etiqueta sigue mostrando su estado individual (+/-)
             toggle.innerHTML = `<span class="sign">${individualState === 'visible' ? '-' : '+'}</span>${label}`;
             // Opcional: Podrías añadir un estilo al toggle de rango si el general está OFF para indicarlo
             // toggle.classList.toggle('master-off', newState === 'off');
         });

         updateButtonStyles(); // Actualizar iconos de los botones principales
         saveSettings(); // Guardar el estado general (onOffState)
     }


    const scrollToggle = document.getElementById('scroll-toggle');
    if (scrollToggle) {
        scrollToggle.addEventListener('click', () => {
            const scrollPosition = window.scrollY;
            const maxScroll = document.body.scrollHeight - window.innerHeight;

            // Si estamos cerca del inicio (menos de 100px), ir al final
            // De lo contrario, ir al inicio
            if (scrollPosition < 100) {
                window.scrollTo({ top: maxScroll, behavior: 'smooth' });
            } else {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        });
    }


    // Listener para el icono de avisos/pie
    const noticeToggleIcon = document.getElementById('notice-toggle-icon');
     if (noticeToggleIcon) {
          noticeToggleIcon.addEventListener('click', toggleNotices); // Llama a la función corregida
     } else {
         console.error("Notice toggle icon not found!");
     }


    function handleOnOffAction() {
        // Solo actuamos si se ha registrado un tiempo de inicio de pulsación
        if (pressStartTime !== null) {
            const duration = Date.now() - pressStartTime;
            const onOffToggle = document.getElementById('on-off-toggle');

            // Definir umbral para pulsación larga (ej. 500ms)
            const longPressThreshold = 500; // ms

            if (duration >= longPressThreshold) {
                // Pulsación larga: No hace nada específico aquí según el código previo,
                // pero podrías añadir una acción si fuera necesario.
                console.log("Long press on On/Off toggle detected.");
            } else {
                // Pulsación corta: Cambiar estado ON/OFF general
                console.log("Short press on On/Off toggle detected.");
                if (onOffToggle) {
                    const currentState = onOffToggle.dataset.state;
                    const newState = currentState === 'on' ? 'off' : 'on';
                    updateAllToggles(newState); // Actualiza el estado general y la visibilidad
                }
            }
        }
        // Resetear el tiempo de inicio de pulsación
        pressStartTime = null;
    }


    function handleReminderLongPress() {
        if (reminderPressStartTime === null) return; // No hacer nada si no hubo pulsación

        const duration = Date.now() - reminderPressStartTime;
        const longPressThreshold = 500; // ms

        if (duration >= longPressThreshold) {
            // Pulsación larga: Mostrar tabla de todos los recordatorios
            console.log("Long press on Reminder button detected.");
            showAllReminders();
        } else {
            // Pulsación corta: Mostrar modal de creación/edición de recordatorio
            console.log("Short press on Reminder button detected.");
            showReminderModal();
        }

        // Resetear el tiempo de inicio de pulsación
        reminderPressStartTime = null;
    }


    // --- Edit Mode Logic ---
    function toggleEditMode() {
        const personalButton = document.getElementById('personal-button');
        isEditMode = !isEditMode;
        if(personalButton) personalButton.classList.toggle('editing', isEditMode);
        document.body.classList.toggle('editing-active', isEditMode);

        if (isEditMode) {
            if (!sessionStorage.getItem('editModeExplained')) {
                showEditInfoModal(); // Mostrar info solo la primera vez por sesión
            }
            showToast("Modo Edición Activado", "info", 4000);

            // Añadir clase editable a todos los elementos relevantes
            grid.querySelectorAll('.bookmark-item').forEach(el => el.classList.add('editable'));
            document.querySelectorAll('.range-toggle').forEach(el => el.classList.add('editable'));
            grid.querySelectorAll('.bg-gray-50.border').forEach(el => el.classList.add('editable')); // Hacer celdas vacías editables

            // Añadir listener a las celdas vacías si están en modo edición
            grid.querySelectorAll('.bg-gray-50.border').forEach(cell => {
                 cell.dataset.index = Array.from(cell.parentNode.children).indexOf(cell); // Obtener índice
                 cell.addEventListener('click', function() { // Usar function() para 'this'
                      if (isEditMode && this.classList.contains('editable')) {
                           showEditModal(parseInt(this.dataset.index));
                      }
                 });
                  // Añadir indicador visual a celdas vacías en modo edición
                    cell.style.display = 'flex';
                    cell.style.alignItems = 'center';
                    cell.style.justifyContent = 'center';
                    cell.textContent = '+';
                    cell.style.fontSize = '2em';
                    cell.style.color = '#ccc';
                    cell.style.cursor = 'crosshair';
             });


        } else {
            showToast("Modo Edición Desactivado", "info", 2000);

            // Remover clase editable y listeners adicionales de celdas vacías
            grid.querySelectorAll('.bookmark-item').forEach(el => el.classList.remove('editable'));
            document.querySelectorAll('.range-toggle').forEach(el => el.classList.remove('editable'));
             grid.querySelectorAll('.bg-gray-50.border').forEach(cell => {
                cell.classList.remove('editable');
                // Remover listener específico añadido para edición en celda vacía
                 const newCell = cell.cloneNode(true); // Clonar para remover listeners
                 cell.parentNode.replaceChild(newCell, cell);
                 // Remover indicador visual
                 newCell.textContent = '';
                 newCell.style.cssText = ''; // Limpiar estilos inline añadidos para el "+"
                 // No re-añadir listener click normal porque las celdas vacías no lo tienen por defecto
            });
            // Re-renderizar la grid podría ser más limpio para asegurar listeners y estilos correctos?
            // renderGrid(); // Podría ser una alternativa, pero puede ser costoso. Dejar listeners específicos es mejor.
        }
    }

    function showEditInfoModal() {
        const modal = document.createElement('div');
        modal.className = 'edit-info-modal';
        modal.setAttribute('aria-label', 'Ayuda Modo Edición'); // Accesibilidad
        modal.innerHTML = `<h2>Modo Edición</h2><p>Has entrado en modo edición.</p><ul class="list-disc pl-6 mb-4"><li>Clic en un <strong>marcador</strong> (icono con nombre) para cambiar Nombre, URL o Favicon.</li><li>Clic en una <strong>celda vacía</strong> (+) para añadir un nuevo marcador.</li><li>Clic en una <strong>etiqueta de sección</strong> (PdR,s, etc.) para cambiar su nombre (máx 7 caract.).</li><li>En el editor: Guarda, Cancela o Resetea al original (o borra en celdas vacías).</li><li>Pulsa <img src="./personal.png" alt="P" style="width:20px;height:20px;display:inline;vertical-align:middle;"> de nuevo para <strong>salir</strong>.</li></ul><div class="flex justify-end"><button type="button" id="close-edit-info">Aceptar</button></div>`;
        document.body.appendChild(modal);

        // Añadir listener para cerrar
        modal.querySelector('#close-edit-info').addEventListener('click', () => {
            sessionStorage.setItem('editModeExplained', 'true'); // Mark as seen
            if (modal.parentNode) modal.parentNode.removeChild(modal); // Remove modal
        });
    }

    function showEditModal(targetIndex, isToggle = false) {
        // Eliminar cualquier modal de edición existente
        const existingModal = document.querySelector('.edit-modal');
        if (existingModal) existingModal.remove();

        const modal = document.createElement('div');
        modal.className = 'edit-modal';
        modal.setAttribute('aria-label', 'Editar elemento'); // Accesibilidad

        let currentItemData;
        let originalItemData; // This will be the reference to the original data if it exists
        let title = '';
        let isNewItem = false;

        if (isToggle) {
            // If it's a toggle range
            currentItemData = currentToggleRanges.find(r => r.start === targetIndex) || {};
            originalItemData = originalToggleRanges.find(r => r.start === targetIndex) || {};
            title = `Editar Etiqueta Sección: ${originalItemData.label || `Inicio ${targetIndex}`}`; // Use original label if none

            modal.innerHTML = `
                <h2>${title}</h2>
                <div>
                    <label for="edit-label">Etiqueta (máx 7):</label>
                    <input type="text" id="edit-label" value="${currentItemData.label || ''}" maxlength="7">
                </div>
                <div class="button-group">
                    <button class="save">Guardar</button>
                    <button class="reset">Resetear</button>
                    <button class="cancel">Cancelar</button>
                </div>
            `;
        } else {
            // If it's a bookmark (cell)
             currentItemData = currentBookmarks[targetIndex];
             // Find the original data for this index. It might be undefined or null if the index is beyond the original list length.
             const originalBookmarkAtIndex = originalBookmarks[targetIndex] !== undefined ? originalBookmarks[targetIndex] : null;


             isNewItem = currentItemData === null || currentItemData === undefined; // It's a new item if it was null/undefined in currentBookmarks
             if (isNewItem) {
                  currentItemData = { name: '', url: '', favicon: '' }; // Initialize empty for the form
                  // originalItemData = null; // No original data to reset to for a new item
                  title = `Añadir Marcador en Índice ${targetIndex}`;
             } else {
                  title = `Editar Marcador: ${currentItemData?.name || `Índice ${targetIndex}`}`; // Use current name
             }


            modal.innerHTML = `
                <h2>${title}</h2>
                <div>
                    <label for="edit-name">Nombre:</label>
                    <input type="text" id="edit-name" value="${currentItemData.name || ''}">
                </div>
                <div>
                    <label for="edit-url">URL:</label>
                    <input type="url" id="edit-url" value="${currentItemData.url || ''}" placeholder="https://ejemplo.com">
                </div>
                <div>
                    <label for="edit-favicon">URL Favicon (Opcional):</label>
                    <input type="text" id="edit-favicon" value="${currentItemData.favicon || ''}" placeholder="Dejar vacío para auto">
                </div>
                <div class="button-group">
                    <button class="save">Guardar</button>
                     ${originalBookmarkAtIndex !== null ? '<button class="reset">Resetear al original</button>' : '<button class="reset" style="background-color:#EF4444; color:white;">Borrar marcador</button>'} <!-- Show reset to original or delete button if no original -->
                    <button class="cancel">Cancelar</button>
                </div>
            `;
             // If there's no original bookmark at this index (it's beyond the original list)
             if (originalBookmarkAtIndex === null) {
                 const resetButton = modal.querySelector('.reset');
                 if (resetButton) resetButton.textContent = 'Borrar marcador'; // Ensure button text is correct
             }


        }

        document.body.appendChild(modal);

        // Listener for Save
        modal.querySelector('.save').addEventListener('click', () => {
            if (isToggle) {
                // Save toggle label
                const newLabel = modal.querySelector('#edit-label').value.trim();
                if (!newLabel) {
                    showToast("Etiqueta vacía", "warning");
                    return;
                }
                if (newLabel.length > 7) {
                    showToast("La etiqueta no puede exceder 7 caracteres.", "warning");
                    return;
                }

                // Update customData and currentToggleRanges
                if (!customData.toggles) customData.toggles = {};
                customData.toggles[targetIndex] = { label: newLabel }; // Store the custom label

                const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetIndex);
                if (rangeIdx > -1) {
                     currentToggleRanges[rangeIdx].label = newLabel; // Update the object in memory
                 } else {
                      console.warn(`Toggle range with start ${targetIndex} not found in currentToggleRanges.`);
                 }


            } else {
                // Save bookmark data
                const newName = modal.querySelector('#edit-name').value.trim();
                const newUrl = modal.querySelector('#edit-url').value.trim();
                const newFavicon = modal.querySelector('#edit-favicon').value.trim(); // Allow empty string to remove custom favicon

                if (!newName || !newUrl) {
                    showToast("Nombre y URL son obligatorios.", "warning");
                    return;
                }
                try {
                    new URL(newUrl); // Validate URL format
                } catch (_) {
                    showToast("URL inválida.", "warning");
                    return;
                }

                // Update customData and currentBookmarks
                if (!customData.bookmarks) customData.bookmarks = {};
                customData.bookmarks[targetIndex] = { name: newName, url: newUrl, favicon: newFavicon || null }; // Use null if empty

                // Update currentBookmarks array in memory
                // Ensure the array has enough slots if adding to a previously null/undefined index
                 while (currentBookmarks.length <= targetIndex) {
                      currentBookmarks.push(null);
                 }
                 currentBookmarks[targetIndex] = { name: newName, url: newUrl, favicon: newFavicon || null };


            }

            saveCustomData(); // Save personalized data
            updateGridItemUI(targetIndex, isToggle); // Update the UI of the modified element
            if (modal.parentNode) modal.parentNode.removeChild(modal); // Close modal
            showToast("Actualizado", "success");
            // renderGrid(); // Re-render the grid to reflect changes (empty cell becomes filled, etc.)
        });

        // Listener for Reset / Delete
        const resetButton = modal.querySelector('.reset');
        if (resetButton) {
            resetButton.addEventListener('click', () => {
                 // Find the original data for this index.
                 const originalBookmarkAtIndex = originalBookmarks[targetIndex] !== undefined ? originalBookmarks[targetIndex] : null;


                if (isToggle) {
                    // Reset toggle label to original
                     const originalLabel = originalToggleRanges.find(r => r.start === targetIndex)?.label || `Rango ${targetIndex}`;

                    // Remove the customization from customData
                    if (customData.toggles?.[targetIndex]) {
                        delete customData.toggles[targetIndex];
                        // If the toggles object becomes empty, delete the entire key
                         if (Object.keys(customData.toggles).length === 0) {
                             delete customData.toggles;
                         }
                    }

                    // Update currentToggleRanges to the original value
                     const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetIndex);
                     if (rangeIdx > -1) {
                         currentToggleRanges[rangeIdx].label = originalLabel;
                     }

                     saveCustomData(); // Save personalized data (will remove the reset entry)
                     updateGridItemUI(targetIndex, isToggle); // Update the UI of the reset element
                     if (modal.parentNode) modal.parentNode.removeChild(modal); // Close modal
                     showToast("Etiqueta reseteada al original", "info");

                } else { // It's a bookmark (cell)
                     if (originalBookmarkAtIndex !== null && originalBookmarkAtIndex !== undefined) {
                         // If there was an original (it's in originalBookmarks), reset to that
                         if (!confirm('¿Resetear este marcador al original?')) return;

                        // Remove the customization from customData for this index
                         if (customData.bookmarks?.[targetIndex]) {
                            delete customData.bookmarks[targetIndex];
                             if (Object.keys(customData.bookmarks).length === 0) {
                                 delete customData.bookmarks;
                             }
                        }
                        // Restore the bookmark in currentBookmarks to the original value
                        currentBookmarks[targetIndex] = { ...originalBookmarkAtIndex }; // Use a copy of original

                        saveCustomData(); // Save personalized data
                        showToast("Marcador reseteado al original", "info");

                     } else {
                         // If there was no original (it was an empty cell where something was added), delete the bookmark
                          if (!confirm('¿Borrar este marcador personalizado?')) return;

                         // Remove the customization from customData for this index
                         if (customData.bookmarks?.[targetIndex]) {
                            delete customData.bookmarks[targetIndex];
                             if (Object.keys(customData.bookmarks).length === 0) {
                                 delete customData.bookmarks;
                             }
                        }
                        // Set the cell in currentBookmarks to null
                         currentBookmarks[targetIndex] = null;
                         saveCustomData(); // Save personalized data
                         showToast("Marcador borrado", "info");
                     }

                     if (modal.parentNode) modal.parentNode.removeChild(modal); // Close modal
                     renderGrid(); // Re-render to reflect the change (empty cell or restored)
                }
            });
        }


        // Listener for Cancel
        modal.querySelector('.cancel').addEventListener('click', () => {
            if (modal.parentNode) modal.parentNode.removeChild(modal); // Close modal
        });
    }

    function updateGridItemUI(indexOrStart, isToggle = false) {
        if (isToggle) {
            // Actualizar un toggle de rango
            const toggleButton = document.querySelector(`.range-toggle[data-range-start="${indexOrStart}"]`);
            const rangeData = currentToggleRanges.find(r => r.start === indexOrStart); // Buscar en currentToggleRanges

            if (toggleButton && rangeData) {
                const state = toggleButton.dataset.state || 'visible';
                // Asegurarse de usar la etiqueta actualizada del rangeData
                toggleButton.innerHTML = `<span class="sign">${state === 'visible' ? '-' : '+'}</span>${rangeData.label}`;
            } else {
                 console.warn(`Toggle button or data not found for start index ${indexOrStart}. Cannot update UI.`);
            }
        } else {
            // Actualizar un bookmark item (celda)
            // Re-renderizar la grid es la forma más sencilla y robusta de actualizar una celda
            // ya que puede cambiar su contenido, su estado (de vacío a lleno o viceversa), etc.
            renderGrid();
             // console.log(`Attempted to update grid item UI at index ${indexOrStart}. Re-rendered grid.`);
        }
    }


    // --- Reminder Functions ---
    function parseReminderText(text) {
        // Esta función ya parece estar implementada en el código original, la extraemos y aseguramos su funcionamiento.
        // Normalizar texto, quitar tildes y pasar a mayúsculas para facilitar el matching
        const result = { text: `<b>${text.trim().toUpperCase()}</b>`, time: null, date: null, repeatDays: [], intervalDays: null };
        let norm = text.toUpperCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');

        // Mapa para convertir números escritos a dígitos
        const numW = { 'UNA': 1, 'UNO': 1, 'DOS': 2, 'TRES': 3, 'CUATRO': 4, 'CINCO': 5, 'SEIS': 6, 'SIETE': 7, 'OCHO': 8, 'NUEVE': 9, 'DIEZ': 10, 'ONCE': 11, 'DOCE': 12, 'TRECE': 13, 'CATORCE': 14, 'QUINCE': 15, 'DIECISEIS': 16, 'DIECISIETE': 17, 'DIECIOCHO': 18, 'DIECINUEVE': 19, 'VEINTE': 20, 'VEINTIUNO': 21, 'VEINTIDOS': 22, 'VEINTITRES': 23, 'VEINTICUATRO': 24, 'VEINTICINCO': 25, 'VEINTISEIS': 26, 'VEINTISIETE': 27, 'VEINTIOCHO': 28, 'VEINTINUEVE': 29, 'TREINTA': 30, 'TREINTAYUNO': 31 };

        // --- Parsear Hora ---
        const timeRegex = /\b(\d{1,2})[:\.](\d{2})\b/; // hh:mm o hh.mm
        const textTimeRegex = /.*\bA\s*LAS?\s*(\d+|\w+)\s*(?:Y\s*(CUARTO|MEDIA|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA)|MENOS\s*(CUARTO|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA))?\s*(DE\s*LA\s*(MANANA|TARDE|NOCHE))?/i;

        const timeMatch = norm.match(timeRegex);
        if (timeMatch) {
            let h = parseInt(timeMatch[1]);
            let m = parseInt(timeMatch[2]);
            if (h >= 0 && h <= 23 && m >= 0 && m <= 59) {
                result.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
            }
        } else {
            const textTimeMatch = norm.match(textTimeRegex);
            if (textTimeMatch) {
                let h = numW[textTimeMatch[1]] || parseInt(textTimeMatch[1]);
                if (!isNaN(h)) {
                    const minuteText = textTimeMatch[2];
                    const minusText = textTimeMatch[3];
                    const period = textTimeMatch[5]; // MANANA, TARDE, NOCHE

                    let m = 0;
                    if (minuteText) {
                         // Y CUARTO, Y MEDIA, Y DIEZ, etc.
                         m = minuteText === 'CUARTO' ? 15 : minuteText === 'MEDIA' ? 30 : numW[minuteText] || parseInt(minuteText) || 0;
                    } else if (minusText) {
                         // MENOS CUARTO, MENOS DIEZ, etc.
                         m = minusText === 'CUARTO' ? 15 : numW[minusText] || parseInt(minusText) || 0;
                         h = (h - 1 + 24) % 24; // Restar una hora y asegurar que no sea negativo
                         m = (60 - m + 60) % 60; // Minutos restantes para la hora completa
                    }


                    // Ajustar hora por periodo (MAÑANA, TARDE, NOCHE)
                    if (period) {
                        if (period === 'TARDE' && h >= 1 && h <= 11) h += 12; // 1 PM a 11 PM
                        if (period === 'NOCHE' && h >= 1 && h <= 11) h += 12; // Similar a tarde, depende del contexto, aquí asumimos lo mismo
                        if (period === 'MANANA' && h === 12) h = 0; // 12 AM (medianoche)
                         // 12 PM (mediodía) es 12
                    } else {
                         // Si no hay periodo, asumir tarde/noche si la hora es pequeña (1-5 aprox)
                        if (h >= 1 && h <= 5) h += 12;
                    }


                    if (h >= 0 && h <= 23 && m >= 0 && m <= 59) {
                        result.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
                    }
                }
            }
        }


        // --- Parsear Días de Repetición (Semanal) ---
        const daysMap = { 'LUNES': 1, 'MARTES': 2, 'MIERCOLES': 3, 'MIÉRCOLES': 3, 'JUEVES': 4, 'VIERNES': 5, 'SABADO': 6, 'SÁBADO': 6, 'DOMINGO': 0 };
        const weeklyRegex = /(?:(?:TODOS\s+LOS|LOS|CADA)\s*)?(LUNES|MARTES|MIERCOLES|MIÉRCOLES|JUEVES|VIERNES|SABADO|SÁBADO)/gi;
        let weeklyMatch;
        while ((weeklyMatch = weeklyRegex.exec(norm)) !== null) {
            const dayOfWeek = daysMap[weeklyMatch[1]];
            if (dayOfWeek !== undefined && !result.repeatDays.includes(dayOfWeek)) {
                result.repeatDays.push(dayOfWeek);
            }
        }
        // Asegurarse de que los días de la semana están en orden numérico
        result.repeatDays.sort((a, b) => a - b);


        // --- Parsear Fecha ---
        const now = new Date();
        const manualDateRegex = /(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{2}|\d{4})\b/; // DD/MM/YYYY, DD-MM-YY, etc.
        const manualDateMatch = norm.match(manualDateRegex);
        if (manualDateMatch && !result.date) {
            let d = parseInt(manualDateMatch[1]);
            let m = parseInt(manualDateMatch[2]);
            let y = parseInt(manualDateMatch[3]);

            // Convertir año corto a largo
            if (y >= 0 && y <= 99) y += 2000; // Asumir siglo 21

            // Validar fecha
            const testDate = new Date(Date.UTC(y, m - 1, d)); // Usar UTC para evitar problemas de zona horaria con validación de día/mes
            if (!isNaN(testDate.getTime()) && testDate.getUTCDate() === d && testDate.getUTCMonth() + 1 === m && y >= 2000 && y <= 2099) {
                 result.date = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; // Formato YYYY-MM-DD
            }
        }

        // Fechas relativas (HOY, MAÑANA, PASADO MAÑANA, EL DÍA X, PRÓXIMO LUNES, DENTRO DE X DÍAS)
        const todayRegex = /\bHOY\b/;
        const tomorrowRegex = /\bMANANA\b|\bMAÑANA\b/;
        const dayAfterTomorrowRegex = /\bPASADO\s*MANANA\b|\bPASADO\s*MAÑANA\b/;
        const dayOfMonthRegex = /\bEL\s*DIA\s*(\d{1,2})\b/; // EL DIA 22
        const nextDayOfWeekRegex = /\b(?:EL\s*)?(PROXIMO\s*)?(LUNES|MARTES|MIERCOLES|MIÉRCOLES|JUEVES|VIERNES|SABADO|SÁBADO|DOMINGO)\b/i; // PRÓXIMO LUNES o EL LUNES
        const inXDaysRegex = /DENTRO\s*DE\s*(\d+)\s*DIAS?/; // DENTRO DE 15 DIAS

        if (!result.date) {
            if (norm.match(todayRegex)) {
                result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
            } else if (norm.match(dayAfterTomorrowRegex)) {
                const targetDate = new Date(now);
                targetDate.setDate(now.getDate() + 2);
                result.date = `${targetDate.getFullYear()}-${(targetDate.getMonth() + 1).toString().padStart(2, '0')}-${targetDate.getDate().toString().padStart(2, '0')}`;
            } else if (norm.match(tomorrowRegex)) {
                const targetDate = new Date(now);
                targetDate.setDate(now.getDate() + 1);
                result.date = `${targetDate.getFullYear()}-${(targetDate.getMonth() + 1).toString().padStart(2, '0')}-${targetDate.getDate().toString().padStart(2, '0')}`;
            } else {
                 const nextDayOfWeekMatch = norm.match(nextDayOfWeekRegex);
                 if (nextDayOfWeekMatch) {
                     const targetDayName = nextDayOfWeekMatch[2].toUpperCase();
                     const targetDayUTC = daysMap[targetDayName]; // Día de la semana (0=Dom, 1=Lun...)
                     const isNext = nextDayOfWeekMatch[1]?.toUpperCase() === 'PROXIMO';

                     if (targetDayUTC !== undefined) {
                         const currentDayUTC = now.getUTCDay(); // Día de hoy (UTC)
                         let daysUntilTarget = (targetDayUTC - currentDayUTC + 7) % 7;

                         // Si es "próximo" y cae hoy, o si no es "próximo" y cae hoy, ir a la siguiente semana
                         if (daysUntilTarget === 0) {
                              // Si hoy es el día, ir a la próxima semana si no se dijo "próximo"
                              // Si se dijo "próximo", ir a la próxima semana de todas formas.
                              daysUntilTarget = 7;
                          } else if (isNext && daysUntilTarget <= 7) {
                               // Si se dijo "próximo" y no es hoy, pero es esta semana, ir a la próxima semana
                               daysUntilTarget += 7;
                           }


                         const targetDate = new Date(now);
                         targetDate.setDate(now.getDate() + daysUntilTarget);
                         result.date = `${targetDate.getFullYear()}-${(targetDate.getMonth() + 1).toString().padStart(2, '0')}-${targetDate.getDate().toString().padStart(2, '0')}`;
                     }
                 } else {
                      const inXDaysMatch = norm.match(inXDaysRegex);
                      if (inXDaysMatch) {
                          const days = parseInt(inXDaysMatch[1]);
                          if (!isNaN(days) && days > 0) {
                              const targetDate = new Date(now);
                              targetDate.setDate(now.getDate() + days);
                              result.date = `${targetDate.getFullYear()}-${(targetDate.getMonth() + 1).toString().padStart(2, '0')}-${targetDate.getDate().toString().padStart(2, '0')}`;
                          }
                      } else {
                          const dayOfMonthMatch = norm.match(dayOfMonthRegex);
                           if (dayOfMonthMatch) {
                               const day = parseInt(dayOfMonthMatch[1]);
                               if (!isNaN(day) && day >= 1 && day <= 31) {
                                   let targetMonth = now.getMonth();
                                   let targetYear = now.getFullYear();
                                    // Si el día del mes es menor que el día actual, asumir el próximo mes
                                   if (day <= now.getDate()) { // Usar <= para incluir hoy si se especifica "el día x"
                                       targetMonth++;
                                       if (targetMonth > 11) {
                                           targetMonth = 0;
                                           targetYear++;
                                       }
                                   }
                                   const targetDate = new Date(Date.UTC(targetYear, targetMonth, day));
                                    // Validar que la fecha construida es correcta (ej. no 31 de Febrero)
                                   if (!isNaN(targetDate.getTime()) && targetDate.getUTCDate() === day && targetDate.getUTCMonth() === targetMonth) {
                                        result.date = `${targetYear}-${(targetMonth + 1).toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
                                   }
                               }
                           }
                      }
                 }
            }
        }

        // --- Parsear Intervalo (CADA X DÍAS) ---
        const intervalRegex = /CADA\s*(\d+)\s*DIAS?/;
        const intervalMatch = norm.match(intervalRegex);
        if (intervalMatch) {
            result.intervalDays = parseInt(intervalMatch[1]);
            // Si se especifica un intervalo pero no una fecha inicial, usar hoy como fecha inicial
            if (!result.date) {
                 result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
             }
        }

         // --- Parsear Alarma/Temporizador (EN X MINUTOS/HORAS) ---
         // Este tipo anula repetición/intervalo y fija una fecha/hora exacta
         const timerRegex = /(ALARMA|AVISO|AVISAR|AVISARME|TEMPORIZADOR|TIMER|RECORDAR|RECORDARME)\b.*?\bEN\s*(\d+|\w+)\s*(MINUTOS?|HORAS?|MINS?|HRS?)/i;
         const timerMatch = norm.match(timerRegex);
         if (timerMatch) {
             const valueStr = timerMatch[2];
             const unit = timerMatch[3]?.toUpperCase();
             let value = numW[valueStr] || parseInt(valueStr);

             if (!isNaN(value) && value > 0 && unit) {
                 let totalMinutes = 0;
                 if (unit.startsWith('HORA') || unit.startsWith('HR')) {
                     totalMinutes = value * 60;
                 } else if (unit.startsWith('MINUTO') || unit.startsWith('MIN')) {
                     totalMinutes = value;
                 }

                 if (totalMinutes > 0) {
                     const endTime = new Date(Date.now() + totalMinutes * 60000);
                     result.date = `${endTime.getFullYear()}-${(endTime.getMonth() + 1).toString().padStart(2, '0')}-${endTime.getDate().toString().padStart(2, '0')}`;
                     result.time = `${endTime.getHours().toString().padStart(2, '0')}:${endTime.getMinutes().toString().padStart(2, '0')}`;
                     // Resetear repetición/intervalo para alarmas/timers
                     result.repeatDays = [];
                     result.intervalDays = null;
                 }
             }
         }


        // Si no hay tiempo pero sí fecha o repetición, asumir medianoche o 00:01
        if (!result.time && (result.date || result.repeatDays.length > 0 || result.intervalDays !== null)) {
            result.time = '00:01';
        }

        console.log("Parsed text:", text, "Result:", result);
        return result;
    }


    function showHelpModal() {
         // Eliminar otros modales si existen
         cleanUpModalTimers(true);
         document.querySelectorAll('.reminder-modal, .reminder-table-modal, #postpone-options-modal, #config-modal, .edit-modal, .edit-info-modal').forEach(m => m.parentNode?.removeChild(m));


        const modal = document.createElement('div');
        modal.className = 'help-modal';
        modal.setAttribute('aria-label', 'Ayuda recordatorios'); // Accesibilidad
        modal.innerHTML = `<h2 class="text-2xl font-bold">Ayuda Recordatorios</h2><p class="mb-4">Ejemplos:</p><ul class="list-disc pl-6 mb-4"><li><strong>Texto:</strong> "Recordar cita", "Llamar mamá"</li><li><strong>Hora:</strong> "A LAS DIEZ Y CUARTO" → 10:15, "A LAS CINCO Y MEDIA TARDE" → 17:30, "14:30", "9.05"</li><li><strong>Fecha:</strong> "HOY", "MAÑANA", "PASADO MAÑANA", "DENTRO DE 15 DÍAS", "EL DÍA 22", "PRÓXIMO LUNES", "LUNES", "25/05/2025", "01-01-24"</li><li><strong>Repetición:</strong> "CADA LUNES", "TODOS LOS VIERNES Y SÁBADOS"</li><li><strong>Intervalo:</strong> "CADA 7 DÍAS"</li><li><strong>Alarma/Temporizador:</strong> "ALARMA EN 30 MINUTOS", "RECORDAR EN 2 HORAS". Crea recordatorio para fecha/hora exacta, anulando repetición/intervalo.</li></ul><p class="mb-4">Formatos fecha manual: DD/MM/YYYY, DD-MM-YY, etc.</p><p class="mb-4">Nota: Combina hora, fecha, días, intervalo. Una "Alarma/Aviso/Timer" en texto anula repetición/intervalo y fija fecha/hora.</p><p class="mb-4">Usa micrófono para voz.</p><div class="flex justify-end"><button type="button" id="close-help">Cerrar</button></div>`;
        document.body.appendChild(modal);

        modal.querySelector('#close-help').addEventListener('click', () => {
            if (modal.parentNode) modal.parentNode.removeChild(modal);
            // Si venimos de la modal de recordatorios, volver a abrirla
            if (fromReminderModal) {
                 fromReminderModal = false; // Reset flag
                 showReminderModal();
             }
        });

        // Si venimos de la modal de recordatorios, establecer el flag
        const reminderModalOpen = document.querySelector('.reminder-modal');
        if (reminderModalOpen) fromReminderModal = true;
    }


    function showReminderModal(reminder = null) {
         // Eliminar otros modales si existen
         cleanUpModalTimers(true); // Asegura que se limpian los timers de cualquier modal previa
         document.querySelectorAll('.reminder-modal, .reminder-table-modal, #postpone-options-modal, #config-modal, .edit-modal, .edit-info-modal').forEach(m => m.parentNode?.removeChild(m));


        // Inicializar datos para el formulario
        const parsed = reminder ? reminder : { id: null, text: '', time: null, date: null, repeatDays: [], intervalDays: null, type: 'simple', createdAt: null };

        // Formatear la fecha a DD/MM/AAAA para el input si existe y está en formato YYYY-MM-DD
        let fmtDate = '';
        if (parsed.date && typeof parsed.date === 'string' && parsed.date.match(/^\d{4}-\d{2}-\d{2}$/)) {
            try {
                const [y,m,d] = parsed.date.split('-');
                // Usar Date.UTC para evitar problemas de zona horaria
                const dt = new Date(Date.UTC(parseInt(y), parseInt(m) - 1, parseInt(d)));
                if (!isNaN(dt.getTime()) && dt.getUTCDate() == parseInt(d) && dt.getUTCMonth() == parseInt(m) - 1) {
                     fmtDate = `${d.padStart(2, '0')}/${m.padStart(2, '0')}/${y}`; // Asegurar formato DD/MM/YYYY con padding
                } else {
                     console.warn("Invalid date in reminder data:", parsed.date);
                }
            } catch(e){
                console.error("Error parsing reminder date for input:", e);
            }
        }

        const modal = document.createElement('div');
        modal.className = 'reminder-modal';
        modal.setAttribute('aria-label','Formulario recordatorio'); // Accesibilidad

        modal.innerHTML = `
            <h2 class="font-bold">${reminder ? 'EDITAR RECORDATORIO' : 'NUEVO RECORDATORIO'}</h2>
            <form id="reminder-form">
                <div class="form-grid">
                    <div class="full-width">
                        <div style="display:flex;align-items:center;gap:.5rem;">
                            <button type="button" id="clear-fields" class="speech-button" title="Limpiar campos" style="background-color:#D1D5DB;color:#111827;flex-shrink:0;">Limpiar</button>
                            <textarea id="reminder-text" rows="4" required style="flex-grow:1;" placeholder="Escribe aquí tu recordatorio...">${parsed.text.replace(/<b>|<\/b>/gi,'')}</textarea>
                            <button type="button" id="start-speech" class="speech-button" title="Voz" style="flex-shrink:0;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                            </button>
                        </div>
                        <p id="speech-status" class="speech-status"></p>
                        <p id="parse-status" class="text-sm mt-1"></p>
                    </div>
                    <div>
                        <label for="reminder-time">Hora (HH:MM):</label>
                        <input type="text" id="reminder-time" placeholder="HH:MM" pattern="\\d{2}:\\d{2}" value="${parsed.time||''}" inputmode="numeric" maxlength="5">
                    </div>
                    <div>
                        <label for="reminder-date">Fecha (DD/MM/AAAA):</label>
                        <input type="text" id="reminder-date" placeholder="DD/MM/AAAA" pattern="\\d{2}/\\d{2}/\\d{4}" value="${fmtDate}" inputmode="numeric" maxlength="10">
                    </div>
                     <div>
                        <label for="reminder-interval">Intervalo (días):</label>
                        <input type="number" id="reminder-interval" min="1" value="${parsed.intervalDays||''}" placeholder="Ej: 7">
                    </div>
                    <div class="full-width">
                        <label>Días repetición:</label>
                        <div class="days-group">
                            ${['Lun ','Mar ','Mié ','Jue ','Vie ','Sáb ','Dom '].map((d,i)=>
                                `<label style="flex:0 0 auto;"><input type="checkbox" name="repeat" value="${(i+1)%7}" ${parsed.repeatDays.includes((i+1)%7)?'checked':''}> ${d}</label>`
                            ).join('')}
                        </div>
                    </div>
                    <div class="full-width button-group">
                        <button type="submit" id="save-reminder">Aceptar <span id="countdown-save">25</span></button>
                        <button type="button" id="cancel-reminder">Cancelar</button>
                         <button type="button" id="view-reminders">Ver Recordatorios</button>
                        <button type="button" id="help-reminder">Ayuda</button>
                    </div>
                </div>
                <p id="auto-save-timer" class="text-sm text-gray-600 mt-2" style="text-align: center;">Guardado automático en <span id="countdown-save-status">25</span> segundos.</p>
            </form>
        `;

        document.body.appendChild(modal);

        const parseStatus = modal.querySelector('#parse-status');
        const speechStatus = modal.querySelector('#speech-status');
        const autoSaveTimerLabel = modal.querySelector('#auto-save-timer');
        const countdownSaveStatusElement = modal.querySelector('#countdown-save-status'); // Elemento para el contador
        const textInput = modal.querySelector('#reminder-text');
        const timeInput = modal.querySelector('#reminder-time');
        const dateInput = modal.querySelector('#reminder-date');
        const intervalInput = modal.querySelector('#reminder-interval');
        const speechButton = modal.querySelector('#start-speech');
        const saveButton = modal.querySelector('#save-reminder');
        const clearButton = modal.querySelector('#clear-fields');

        let manualTimeInput = timeInput.value.trim() !== ''; // Flag inicial basado en si el campo ya tiene valor
        let manualDateInput = dateInput.value.trim() !== ''; // Flag inicial basado en si el campo ya tiene valor


        // Timers asociados a esta modal específica
        modal.autoSaveInterval = null;
        modal.parseTimeout = null;
        modal.focusTimeout = null;
        let countdownSave = 25;


        // --- Speech Recognition ---
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();
            recognition.continuous = false; // Parar tras una pausa
            recognition.interimResults = false; // No mostrar resultados provisionales
            recognition.lang = 'es-ES'; // Idioma español

            speechButton.addEventListener('click', () => {
                 cleanUpModalTimers(false); // Limpiar timers pero no el de focus
                 // Asegurar que el modal tiene foco antes de empezar
                 // modal.focus(); // Podría ser necesario en algunos navegadores
                 recognition.start();
             });

            recognition.onstart = () => {
                speechStatus.textContent = 'Escuchando...';
                speechStatus.style.color = '#10B981'; // Verde
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                const currentText = textInput.value;
                 // Añadir el transcript al campo de texto, con un espacio si ya había texto
                if (currentText.trim().length > 0) {
                    textInput.value = currentText.trimEnd() + ' ' + transcript;
                } else {
                    textInput.value = transcript;
                }
                 // Disparar el evento 'input' en el textarea para activar el parseo
                 const inputEvent = new Event('input', { bubbles: true });
                 textInput.dispatchEvent(inputEvent);
            };

            recognition.onerror = (event) => {
                speechStatus.textContent = `Error voz: ${event.error}`;
                speechStatus.style.color = '#EF4444'; // Rojo
                console.error('Speech recognition error:', event.error, event.message);
                resetAndStartCountdown(); // Reiniciar contador al finalizar la interacción de voz
            };

            recognition.onend = () => {
                 // Si no hubo error, limpiar el estado de voz después de un tiempo
                 if (!speechStatus.textContent.startsWith('Error')) {
                    setTimeout(() => {
                        if (speechStatus.textContent === 'Escuchando...') { // Solo si no se reemplazó por error/resultado
                           speechStatus.textContent = '';
                        }
                    }, 1500); // Esperar un poco antes de limpiar el estado
                 }
                 resetAndStartCountdown(); // Reiniciar contador al finalizar la interacción de voz
            };

        } else {
            // Navegador no soporta Speech Recognition
            speechStatus.textContent = 'Reconocimiento de voz no soportado en este navegador.';
            speechStatus.style.color = '#EF4444'; // Rojo
            speechButton.disabled = true;
            speechButton.style.opacity = 0.5;
        }

        // --- Input Validation and Parsing ---
        timeInput.addEventListener('input', (e) => {
             manualTimeInput = true; // Usuario editó manualmente la hora
             let value = e.target.value.replace(/\D/g, ''); // Eliminar no dígitos
             let formattedValue = '';
             if (value.length >= 2) formattedValue = value.slice(0, 2);
             if (value.length > 2) formattedValue += ':' + value.slice(2, 4);
             e.target.value = formattedValue; // Aplicar formato HH:MM

             // Validar hora
             if (formattedValue.match(/^\d{2}:\d{2}$/)) {
                 const [h, m] = formattedValue.split(':').map(Number);
                 const isValid = !(h > 23 || m > 59);
                 parseStatus.textContent = isValid ? '' : 'Hora inválida (HH:MM).';
                 parseStatus.classList.toggle('text-red-600', !isValid);
                 parseStatus.classList.toggle('text-green-600', isValid && parseStatus.textContent === '');
             } else if (formattedValue.length > 0) {
                 parseStatus.textContent = 'Formato esperado HH:MM';
                 parseStatus.classList.remove('text-red-600', 'text-green-600');
             } else {
                 parseStatus.textContent = ''; // Campo vacío
                 parseStatus.classList.remove('text-red-600', 'text-green-600');
             }
             resetAndStartCountdown(); // Reiniciar contador en cada cambio
         });

        dateInput.addEventListener('input', (e) => {
            manualDateInput = true; // Usuario editó manualmente la fecha
            let value = e.target.value.replace(/\D/g, ''); // Eliminar no dígitos
            let formattedValue = '';
            if (value.length >= 2) formattedValue = value.slice(0, 2);
            if (value.length > 2) formattedValue += '/' + value.slice(2, 4);
            if (value.length > 4) formattedValue += '/' + value.slice(4, 8);
            e.target.value = formattedValue; // Aplicar formato DD/MM/AAAA

            // Validar fecha
            if (formattedValue.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                const [d, m, y] = formattedValue.split('/').map(Number);
                const testDate = new Date(Date.UTC(y, m - 1, d)); // Usar UTC para validación
                const isValid = !isNaN(testDate.getTime()) && testDate.getUTCDate() === d && testDate.getUTCMonth() + 1 === m && y >= 2000 && y <= 2099;

                parseStatus.textContent = isValid ? '' : 'Fecha inválida (DD/MM/AAAA).';
                parseStatus.classList.toggle('text-red-600', !isValid);
                parseStatus.classList.toggle('text-green-600', isValid && parseStatus.textContent === '');
            } else if (formattedValue.length > 0) {
                 parseStatus.textContent = 'Formato esperado DD/MM/AAAA';
                 parseStatus.classList.remove('text-red-600', 'text-green-600');
            } else {
                 parseStatus.textContent = ''; // Campo vacío
                 parseStatus.classList.remove('text-red-600', 'text-green-600');
            }
            resetAndStartCountdown(); // Reiniciar contador en cada cambio
        });

         // Resetear flags manuales si se vacían los campos
         timeInput.addEventListener('change', () => { if (timeInput.value.trim() === '') manualTimeInput = false; });
         dateInput.addEventListener('change', () => { if (dateInput.value.trim() === '') manualDateInput = false; });


        // --- Auto-Save Countdown ---
        autoSaveTimerLabel.style.display = 'block'; // Asegurarse de que el timer es visible
        if (countdownSaveStatusElement) countdownSaveStatusElement.textContent = countdownSave; // Mostrar valor inicial

        function resetAndStartCountdown() {
            clearInterval(modal.autoSaveInterval); // Limpiar intervalo existente
            modal.autoSaveInterval = null;
            // clearTimeout(modal.parseTimeout); // No limpiar parseTimeout aquí, se limpia al finalizar parse
            // clearTimeout(modal.restartTimeout); // No limpiar restartTimeout aquí, ya no se usa

            countdownSave = 25; // Resetear contador
            if (countdownSaveStatusElement) countdownSaveStatusElement.textContent = countdownSave; // Actualizar UI

            startCountdown(); // Iniciar nuevo contador
        }

        function startCountdown() {
             // Evitar iniciar múltiples intervalos
            if (modal.autoSaveInterval) return;

            modal.autoSaveInterval = setInterval(() => {
                countdownSave--;
                if (countdownSaveStatusElement) countdownSaveStatusElement.textContent = countdownSave;

                if (countdownSave <= 0) {
                    clearInterval(modal.autoSaveInterval);
                    modal.autoSaveInterval = null;

                    // Disparar el submit del formulario si el modal todavía está abierto
                    const form = modal.querySelector('#reminder-form');
                    if (form && document.body.contains(modal)) {
                        const submitEvent = new Event('submit', { bubbles: true, cancelable: true });
                         // Prevent default submit to handle it manually below
                        if (form.dispatchEvent(submitEvent)) {
                             console.log("Auto-saving reminder via submit.");
                             // The save logic is in the form's submit listener
                        } else {
                            console.log("Auto-save submit prevented.");
                        }
                    } else {
                        // If the modal is no longer in the DOM, clean up timers completely
                        cleanUpModalTimers(true);
                        console.log("Auto-save triggered but modal not in DOM, cleaning up.");
                    }
                }
            }, 1000); // Update every second
        }

         // --- Focus Check (mantener foco en textarea) ---
         function startFocusCheck() {
             clearTimeout(modal.focusTimeout);
             modal.focusTimeout = setTimeout(() => {
                 // Check if the modal is still open and focus is not on the textarea
                 if (document.body.contains(modal) && document.activeElement !== textInput) {
                     console.log("Inactivity detected, attempting to refocus on textarea.");
                     textInput.focus();
                 }
                 // If modal is still open, continue checking
                 if (document.body.contains(modal)) {
                     startFocusCheck(); // Recursive call
                 } else {
                     console.log("Modal closed, stopping focus check.");
                     modal.focusTimeout = null; // Ensure reference is cleared
                 }
             }, 7000); // Check every 7 seconds of inactivity
         }


        // --- Event Listeners para resetear contador/timers ---
        // Reset countdown on any interaction inside the modal
        modal.addEventListener('input', resetAndStartCountdown);
        modal.addEventListener('click', resetAndStartCountdown); // Clicks also reset
        modal.addEventListener('focusin', () => {
            resetAndStartCountdown(); // Reset if an element inside the modal gets focus
            clearTimeout(modal.focusTimeout); // Stop focus check when focus is inside
            modal.focusTimeout = null;
        });
         modal.addEventListener('focusout', () => {
             // If focus leaves the modal, restart the focus check after a small delay
             // to allow for focus moving between elements within the modal
             setTimeout(() => {
                  if (document.body.contains(modal) && !modal.contains(document.activeElement)) {
                      console.log("Focus left modal, restarting focus check.");
                      startFocusCheck();
                  } else if (!document.body.contains(modal)) {
                       // Modal is no longer in the DOM, ensure cleanup
                       console.log("Focusout detected but modal not in DOM, cleaning up.");
                       cleanUpModalTimers(true);
                  }
             }, 10); // Small delay
        });


        // --- Text Input Auto-Parsing ---
        textInput.addEventListener('input', (e) => {
            const txt = e.target.value || '';
            parseStatus.textContent = 'Parseando...';
            parseStatus.classList.remove('text-green-600', 'text-red-600');

            // Clear previous parse timeout to avoid parsing on every keystroke
            if (modal.parseTimeout) clearTimeout(modal.parseTimeout);

            modal.parseTimeout = setTimeout(() => {
                 // Only parse if the modal is still open
                if (!document.body.contains(modal)) {
                    console.log("Modal closed during parse timeout, cancelling parse.");
                    modal.parseTimeout = null;
                    return;
                }

                try {
                    const parsedData = parseReminderText(txt);

                    // Update fields if they haven't been manually edited
                    // Check if the input value is currently empty before auto-filling,
                    // or if the flag says it wasn't manually set.
                    if (!manualTimeInput && parsedData.time && timeInput.value.trim() === '') {
                         console.log("Auto-filling time:", parsedData.time);
                        timeInput.value = parsedData.time;
                    }
                    if (!manualDateInput && parsedData.date && dateInput.value.trim() === '') {
                        // Convert YYYY-MM-DD to DD/MM/YYYY for the date input
                        const [y, m, d] = parsedData.date.split('-');
                         const formattedDate = `${d.padStart(2, '0')}/${m.padStart(2, '0')}/${y}`;
                         console.log("Auto-filling date:", formattedDate);
                        dateInput.value = formattedDate;
                    }

                    // Update repeat days checkboxes based on parse result
                    modal.querySelectorAll('input[name="repeat"]').forEach(input => {
                        input.checked = (parsedData.repeatDays || []).includes(parseInt(input.value));
                    });

                    // Update interval field based on parse result
                    intervalInput.value = parsedData.intervalDays || '';


                    parseStatus.textContent = 'Parseado OK';
                    parseStatus.classList.add('text-green-600');
                    parseStatus.classList.remove('text-red-600');

                    // Flags manuales se resetean en los event listeners de change si se vacían los campos.
                    // Si el usuario escribe algo, la bandera manual se activa y previene el auto-llenado hasta que borre el campo.


                } catch (error) {
                    console.error('Parsing error:', error);
                    parseStatus.textContent = `Error parseando: ${error.message.substring(0, 100)}`; // Show part of the error message
                    parseStatus.classList.add('text-red-600');
                    parseStatus.classList.remove('text-green-600');
                } finally {
                     modal.parseTimeout = null; // Clear the timeout reference
                     resetAndStartCountdown(); // Reset the countdown after parsing
                }
            }, 1500); // Wait 1.5 seconds after the last keystroke to parse
        });


        // --- Form Submission ---
        const form = modal.querySelector('#reminder-form');
        form.addEventListener('submit', (e) => {
            e.preventDefault(); // Prevent default form submission

            cleanUpModalTimers(true); // Clear all timers when submitting

            const text = textInput.value.trim();
            if (!text) {
                parseStatus.textContent = 'El texto del recordatorio es obligatorio.';
                parseStatus.classList.add('text-red-600');
                 // Show the error for a few seconds and then clear
                 setTimeout(() => { parseStatus.textContent = ''; parseStatus.classList.remove('text-red-600'); }, 3000);
                resetAndStartCountdown(); // Restart countdown to give time to correct
                return; // Stop the save process
            }

            let time = timeInput.value.trim();
            let dateStr = dateInput.value.trim();
            const repeatDays = Array.from(modal.querySelectorAll('input[name="repeat"]:checked')).map(input => parseInt(input.value));
            const intervalDays = parseInt(intervalInput.value) || null;

            let dateISO = null;
            let finalTime = time;
            let reminderType = 'simple'; // Default type

            // Validate and format date if entered
            if (dateStr) {
                if (dateStr.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                    const [d, m, y] = dateStr.split('/').map(Number);
                    const testDate = new Date(Date.UTC(y, m - 1, d)); // Use UTC for validation
                    if (!isNaN(testDate.getTime()) && testDate.getUTCDate()===d && testDate.getUTCMonth()+1===m && y>=2000 && y<=2099) {
                         dateISO = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; // Convert to YYYY-MM-DD
                    } else {
                        parseStatus.textContent = 'Fecha inválida (DD/MM/AAAA).';
                        parseStatus.classList.add('text-red-600');
                         setTimeout(() => { parseStatus.textContent = ''; parseStatus.classList.remove('text-red-600'); }, 3000);
                        resetAndStartCountdown(); // Restart countdown to give time to correct
                        return;
                    }
                } else {
                     parseStatus.textContent = 'Formato de fecha esperado DD/MM/AAAA.';
                     parseStatus.classList.add('text-red-600');
                     setTimeout(() => { parseStatus.textContent = ''; parseStatus.classList.remove('text-red-600'); }, 3000);
                     resetAndStartCountdown();
                     return;
                }
            }

            // Validate and format time if entered
            if (finalTime && !finalTime.match(/^\d{2}:\d{2}$/)) {
                parseStatus.textContent = 'Formato de hora esperado HH:MM.';
                parseStatus.classList.add('text-red-600');
                setTimeout(() => { parseStatus.textContent = ''; parseStatus.classList.remove('text-red-600'); }, 3000);
                resetAndStartCountdown();
                return;
            } else if (finalTime) {
                 const [h, m] = finalTime.split(':').map(Number);
                 if (h > 23 || m > 59) {
                     parseStatus.textContent = 'Hora inválida (HH:MM).';
                     parseStatus.classList.add('text-red-600');
                     setTimeout(() => { parseStatus.textContent = ''; parseStatus.classList.remove('text-red-600'); }, 3000);
                     resetAndStartCountdown();
                     return;
                 }
            }

            // Determine reminder type based on filled fields and text parsing
            const parsedForType = parseReminderText(text); // Re-parse to look for alarm keywords

             // Type priority:
             // 1. Alarm/Timer in text: parsedForType has date/time and no repeat/interval, AND text contains alarm keywords.
             // 2. Interval: intervalDays is not null and dateISO is present
             // 3. Weekly: repeatDays has elements and finalTime is present
             // 4. Daily: dateISO is present (with or without time)
             // 5. Simple: text only (will be assigned creation date/time)

             let determinedType = 'simple'; // Start with lowest priority
             if (parsedForType.date && parsedForType.time && !parsedForType.repeatDays.length && parsedForType.intervalDays === null && parsedForType.text !== `<b>${text.toUpperCase()}</b>`) {
                  // Check if text content triggered date/time parse without recurrence/interval
                  // AND the original text *contains* alarm keywords (heuristic: check if parsed text is different from simple text formatting)
                 determinedType = 'daily'; // Treat as single-shot alarm for specific date/time
                 console.log("Determined type: daily (from alarm text)");
             } else if (intervalDays !== null && dateISO) {
                 determinedType = 'interval';
                 console.log("Determined type: interval");
             } else if (repeatDays.length > 0 && finalTime) {
                 determinedType = 'weekly';
                 console.log("Determined type: weekly");
             } else if (dateISO) { // This includes date + time OR date only
                 determinedType = 'daily';
                 console.log("Determined type: daily (from date)");
             } else if (finalTime) {
                  // Time only without date/repeat/interval. Treat as daily for today at that time.
                 const now = new Date();
                 dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
                 determinedType = 'daily';
                 console.log("Determined type: daily (from time only, assigned today)");
             }
             // If none of the above, type remains 'simple'


             reminderType = determinedType; // Assign the determined type


            // Create the new reminder object
            const newReminder = {
                id: reminder ? reminder.id : Date.now(), // Use existing ID if editing, or new timestamp if new
                text: `<b>${text.toUpperCase()}</b>`, // Save text in uppercase and bold
                type: reminderType,
                 // Save values from form inputs, overriding if type logic implies otherwise
                time: (reminderType === 'weekly' || reminderType === 'interval' || (reminderType === 'daily' && finalTime)) ? finalTime || '00:01' : null, // Save time if relevant type, default to 00:01 if missing but needed
                date: (reminderType === 'daily' || reminderType === 'interval') ? dateISO || null : null, // Save date if relevant type
                repeatDays: reminderType === 'weekly' ? repeatDays.sort((a,b)=>a-b) : [], // Save days or empty array
                intervalDays: reminderType === 'interval' ? intervalDays : null, // Save interval or null
                createdAt: reminder?.createdAt || new Date().toISOString() // Keep creation date if editing, or new
            };

            // --- Final check for Simple type: ensure no date/time/recurrence fields are saved ---
            if (newReminder.type === 'simple') {
                 newReminder.date = null;
                 newReminder.time = null;
                 newReminder.repeatDays = [];
                 newReminder.intervalDays = null;
                 // Simple reminders use their createdAt for their single occurrence check
            }


            let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');

            if (reminder) {
                // If editing, find and replace the existing reminder
                const index = reminders.findIndex(r => r.id === reminder.id);
                if (index !== -1) {
                    reminders[index] = newReminder;
                    console.log("Updated reminder:", newReminder);
                } else {
                     console.error("Reminder to update not found in storage:", reminder.id);
                     // If not found, add as new just in case (shouldn't happen with timestamp IDs)
                     reminders.push(newReminder);
                     console.log("Added as new reminder instead.");
                }
            } else {
                // If it's a new reminder, just add it
                reminders.push(newReminder);
                console.log("Saved new reminder:", newReminder);
            }

            localStorage.setItem('reminders', JSON.stringify(reminders)); // Save to localStorage

            if (modal.parentNode) document.body.removeChild(modal); // Close modal

            updateReminderCount(); // Update the globe/button count
            updateButtonStyles(); // Ensure reminder button style updates
            checkReminders(); // Re-check reminders to see if the new one should be notified immediately
            showToast('Recordatorio guardado', 'success'); // Show success notification
        });

        // Listener for Cancel
        modal.querySelector('#cancel-reminder').addEventListener('click', () => {
            cleanUpModalTimers(true); // Clear all timers
            if (modal.parentNode) document.body.removeChild(modal); // Close modal
            showToast('Recordatorio cancelado', 'info');
        });

        // Listener for Help
        modal.querySelector('#help-reminder').addEventListener('click', showHelpModal);

        // Listener for Clear Fields
        clearButton.addEventListener('click', () => {
            textInput.value = '';
            timeInput.value = '';
            dateInput.value = '';
            modal.querySelectorAll('input[name="repeat"]').forEach(i => i.checked = false);
            intervalInput.value = '';
            parseStatus.textContent = ''; // Clear parse status
            speechStatus.textContent = ''; // Clear speech status
            manualTimeInput = false; // Reset manual flags
            manualDateInput = false;
            resetAndStartCountdown(); // Reset countdown and start over
            textInput.focus(); // Return focus to the text field
        });

        // Listener for View Reminders (from the create/edit modal)
        modal.querySelector('#view-reminders').addEventListener('click', () => {
            cleanUpModalTimers(true); // Clear all timers
            if (modal.parentNode) document.body.removeChild(modal); // Close the edit modal
            fromReminderModal = true; // Set flag to know we came from here
            showAllReminders(); // Show the reminder table
        });


        // Start the auto-save countdown and focus check
        resetAndStartCountdown();
        startFocusCheck(); // Start focus verification
         textInput.focus(); // Set focus on the text field when opening

    }


    function showReminderNotification(reminder) {
        // Prevent showing the same notification if it already exists in the DOM
        const existing = document.querySelector(`.reminder-notification[data-id="${reminder.id}"]`);
        if (existing) {
            console.log(`Notification for reminder ID ${reminder.id} already exists. Skipping.`);
            return;
        }

        console.log("Showing reminder notification for ID:", reminder.id);

        const notificationElement = document.createElement('div');
        notificationElement.className = 'reminder-notification';
        notificationElement.setAttribute('data-id', reminder.id);
        notificationElement.setAttribute('aria-label', 'Notificación de Recordatorio'); // Accessibility

        let details = '';
        if (reminder.time) details += `<p class="reminder-details">Hora: ${reminder.time}</p>`;
        if (reminder.date) details += `<p class="reminder-details">Fecha: ${formatDateToDDMMMYY(reminder.date)}</p>`;
        if (reminder.type === 'weekly' && reminder.repeatDays.length > 0) {
            details += `<p class="reminder-details">Repite: ${reminder.repeatDays.map(d => ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'][d]).join(', ')}</p>`;
        }
        if (reminder.type === 'interval' && reminder.intervalDays) {
            details += `<p class="reminder-details">Cada: ${reminder.intervalDays} días</p>`;
        }
         // For debugging, show type
         // details += `<p class="reminder-details" style="font-size:.8em;">Tipo: ${reminder.type}</p>`;


        notificationElement.innerHTML = `
            <p class="reminder-text">${reminder.text}</p>
            ${details}
            <div class="button-group">
                <button class="cancel">Borrar</button>
                <button class="modify">Modificar</button>
                <button class="postpone">Posponer</button>
            </div>
        `;

        document.getElementById('reminder-notifications').appendChild(notificationElement);

        // Listeners for the notification buttons
        notificationElement.querySelector('.cancel').addEventListener('click', () => {
            if (notificationElement.parentNode) notificationElement.parentNode.removeChild(notificationElement);

            // Eliminar el recordatorio del localStorage
            let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
            reminders = reminders.filter(r => r.id !== reminder.id);
            localStorage.setItem('reminders', JSON.stringify(reminders));

            // Eliminar el timestamp de la última notificación para este reminder si existía
             sessionStorage.removeItem(`reminder_last_notified_${reminder.id}`);

            updateReminderCount(); // Update the count
            updateButtonStyles(); // Ensure reminder button style updates
            showToast('Recordatorio borrado', 'info');
             console.log("Reminder ID deleted from notification:", reminder.id);
        });

        notificationElement.querySelector('.modify').addEventListener('click', () => {
             if (notificationElement.parentNode) notificationElement.parentNode.removeChild(notificationElement);
             // Eliminar el timestamp de la última notificación si existía
             sessionStorage.removeItem(`reminder_last_notified_${reminder.id}`);
             showReminderModal(reminder); // Open edit modal with reminder data
         });


        notificationElement.querySelector('.postpone').addEventListener('click', () => {
             // Don't remove the notification here, it will be done in showPostponeOptionsModal if postponed
             showPostponeOptionsModal(reminder, 'notification'); // Open postpone options modal
        });
    }


    function showAllReminders() {
         // Remove other modals if they exist
         cleanUpModalTimers(true); // Ensure timers from any previous modal are cleaned
         document.querySelectorAll('.reminder-modal, .reminder-table-modal, #postpone-options-modal, #config-modal, .edit-modal, .edit-info-modal').forEach(m => m.parentNode?.removeChild(m));


        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]').map(r => ({ ...r })); // Get a copy
        console.log("Reminders loaded for table:", reminders); // Debug log

        // Sort reminders
        reminders.sort((a, b) => {
            const now = new Date();

            // Calculate the next occurrence relative to NOW for sorting
            const nextA = calculateNextOccurrence(a, now);
            const nextB = calculateNextOccurrence(b, now);

            if (nextA && nextB) {
                const timeDiff = nextA.getTime() - nextB.getTime();
                if (timeDiff !== 0) return timeDiff; // Sort by next occurrence
            } else if (nextA) {
                return -1; // A comes first if it has a next occurrence and B doesn't
            } else if (nextB) {
                return 1; // B comes first if it has a next occurrence and A doesn't
            }

            // If they don't have a next occurrence (e.g., past, single-shot reminders), sort by type or creation date
            const typeOrder = { 'interval': 1, 'weekly': 2, 'daily': 3, 'hourly': 4, 'simple': 5 }; // Define an order for types
            const typeComparison = (typeOrder[a.type] ?? 99) - (typeOrder[b.type] ?? 99);
            if (typeComparison !== 0) return typeComparison; // Sort by type if next occurrences are equal or null

            // Finally, sort by creation date if everything else is equal
            const createdAtA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
            const createdAtB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
            return createdAtA - createdAtB;
        });


        const modal = document.createElement('div');
        modal.className = 'reminder-table-modal';
         modal.setAttribute('aria-label', 'Tabla de Recordatorios Guardados'); // Accessibility

        modal.innerHTML = `
            <h2 style="text-align:center;margin-bottom:1rem;font-size:1.5rem;color:#333;">Recordatorios Guardados</h2>
            <div class="top-button-container">
                 <button type="button" id="close-reminders-top">SALIR <span class="button-countdown"></span></button>
            </div>
            <table>
                <thead>
                    <tr>
                        <th style="width:15%;">Acciones</th>
                        <th>Texto</th>
                        <th style="width:10%;">Hora</th>
                        <th style="width:10%;">Fecha</th>
                        <th style="width:15%;">Días Rep.</th>
                        <th style="width:10%;">Cada x días</th>
                        <th style="width:10%;">Creado</th>
                    </tr>
                </thead>
                <tbody>
                    ${reminders.length === 0 ?
                        '<tr><td colspan="7" style="text-align:center;padding:1rem;">No hay recordatorios guardados.</td></tr>' :
                        reminders.map(r => `
                            <tr data-id="${r.id}" title="Clic para modificar">
                                <td>
                                    <button class="delete" data-id="${r.id}" title="Borrar recordatorio">Borrar</button>
                                    <button class="postpone" data-id="${r.id}" title="Posponer recordatorio">Posponer</button>
                                </td>
                                <td class="text-column">${r.text || '-'}</td>
                                <td>${r.time || '-'}</td>
                                <td class="date-column">${formatDateToDDMMMYY(r.date)}</td>
                                <td>${r.type === 'weekly' && r.repeatDays.length > 0 ? r.repeatDays.map(d => ['Dom','Lun','Mar','Mié','Jue','Vie','Sáb'][d]).join(', ') : '-'}</td>
                                <td>${r.type === 'interval' ? r.intervalDays || '-' : '-'}</td>
                                <td class="date-column">${r.createdAt ? formatDateToDDMMMYY(r.createdAt.split('T')[0]) : '-'}</td>
                            </tr>
                        `).join('')
                    }
                </tbody>
            </table>
            <div class="button-group flex justify-start">
                 <button type="button" id="close-reminders">SALIR <span class="button-countdown"></span></button>
            </div>
        `;

        document.body.appendChild(modal);

        // --- Auto-close countdown ---
        let count = 60; // Countdown in seconds
        const countdownSpans = modal.querySelectorAll('.button-countdown');
        countdownSpans.forEach(span => span.textContent = `(${count})`); // Display initial count

        const closeClean = () => {
            clearInterval(modal.autoCloseInterval); // Clear interval
            delete modal.autoCloseInterval; // Remove reference

            if (modal.parentNode) document.body.removeChild(modal); // Close modal

            // If we came from the reminder modal, open it again
            if (fromReminderModal) {
                fromReminderModal = false; // Reset flag
                showReminderModal();
            }
             console.log("Reminder table auto-closed or manually closed.");
        };

        // Start auto-close interval
        modal.autoCloseInterval = setInterval(() => {
            count--;
            countdownSpans.forEach(span => span.textContent = `(${count})`);
            if (count <= 0) {
                closeClean(); // Close when reaching 0
            }
        }, 1000); // Update every second


        // Reset countdown on user activity in the modal
        const resetTimer = () => {
            if (modal.autoCloseInterval) { // Only reset if interval is active
                clearInterval(modal.autoCloseInterval);
                count = 60; // Reset count
                countdownSpans.forEach(span => span.textContent = `(${count})`);
                // Restart the interval
                modal.autoCloseInterval = setInterval(() => {
                    count--;
                    countdownSpans.forEach(span => span.textContent = `(${count})`);
                    if (count <= 0) {
                        closeClean();
                    }
                }, 1000);
                 console.log("Reminder table countdown reset.");
            }
        };

        modal.addEventListener('click', resetTimer);
        modal.addEventListener('touchstart', resetTimer, { passive: true }); // Taps also reset
        modal.addEventListener('input', resetTimer); // Input in any field inside resets


        // --- Button Listeners (Delete, Postpone, Close) ---
        modal.querySelectorAll('.delete').forEach(button => {
            button.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent click on button from activating row listener
                const idToDelete = parseInt(button.dataset.id);
                if(isNaN(idToDelete)) {
                     console.error("Invalid reminder ID for deletion:", button.dataset.id);
                     showToast('Error al borrar: ID inválido.', 'error');
                     return;
                 }

                // Remove notification if visible
                const notificationToRemove = document.querySelector(`.reminder-notification[data-id="${idToDelete}"]`);
                if (notificationToRemove) notificationToRemove.remove();

                // Filter and save updated reminders
                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                reminders = reminders.filter(r => r.id !== idToDelete);
                localStorage.setItem('reminders', JSON.stringify(reminders));

                 // Remove the last notified timestamp for this reminder if it existed
                 sessionStorage.removeItem(`reminder_last_notified_${idToDelete}`);

                // Close and re-open the table to reflect the change OR just remove the row
                // Removing the row is visually faster
                 const rowToDelete = button.closest('tr');
                 if(rowToDelete) {
                      rowToDelete.remove();
                      // If no rows left, show "No reminders" message
                      if (modal.querySelectorAll('tbody tr').length === 0) {
                           const tbody = modal.querySelector('tbody');
                           if(tbody) tbody.innerHTML = '<tr><td colspan="7" style="text-align:center;padding:1rem;">No hay recordatorios guardados.</td></tr>';
                      }
                 }


                updateReminderCount(); // Update the count
                updateButtonStyles(); // Ensure reminder button style updates
                showToast('Recordatorio borrado', 'info');
                 console.log("Reminder ID deleted from table:", idToDelete);

                 resetTimer(); // Reset auto-close timer after an action
            });
        });

        modal.querySelectorAll('.postpone').forEach(button => {
             button.addEventListener('click', (e) => {
                 e.stopPropagation(); // Prevent click on button from activating row listener
                 const idToPostpone = parseInt(button.dataset.id);
                  if(isNaN(idToPostpone)) {
                     console.error("Invalid reminder ID for postpone:", button.dataset.id);
                     showToast('Error al posponer: ID inválido.', 'error');
                     return;
                 }
                 const reminderToPostpone = reminders.find(r => r.id === idToPostpone);
                 if (reminderToPostpone) {
                      // Close the table before showing postpone options
                     if (modal.parentNode) document.body.removeChild(modal);
                     showPostponeOptionsModal(reminderToPostpone, 'table'); // Pass 'table' as source
                 } else {
                     console.error("Reminder not found in current list for postpone:", idToPostpone);
                     showToast('Error: Recordatorio no encontrado para posponer.', 'error');
                 }
             });
        });


        modal.querySelector('#close-reminders').addEventListener('click', closeClean);
        modal.querySelector('#close-reminders-top').addEventListener('click', closeClean); // Also the top button

        // --- Row Click Listener (Modify) ---
        const tableBody = modal.querySelector('tbody');
        if(tableBody) {
             tableBody.addEventListener('click', (e) => {
                 // If the click was inside an action button (delete, postpone), do nothing
                 if (e.target.closest('td:first-child button')) {
                     return;
                 }

                 const row = e.target.closest('tr[data-id]'); // Find the parent row with data-id
                 if (row?.dataset.id) {
                     const idToModify = parseInt(row.dataset.id);
                      if(isNaN(idToModify)) {
                         console.error("Invalid reminder ID on row click:", row.dataset.id);
                         return;
                     }
                     const reminderToModify = reminders.find(r => r.id === idToModify); // Find the reminder in the current list

                     if (reminderToModify) {
                          cleanUpModalTimers(true); // Clean timers before closing
                         if (modal.parentNode) document.body.removeChild(modal); // Close the table

                         showReminderModal(reminderToModify); // Open edit modal with reminder data
                         console.log("Opening reminder modal to modify ID:", idToModify);
                     } else {
                         console.error("Reminder not found in current list for modification:", idToModify);
                         showToast('Error: Recordatorio no encontrado para modificar.', 'error');
                     }
                 }
             });
        } else {
             console.warn("Table body not found in reminder table modal.");
        }
    }

    function updateReminderCount() {
         const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        const count = reminders.length;

        const globe = document.getElementById('reminder-count-globe');
        if (globe) {
            globe.textContent = count > 0 ? count : ''; // Show number only if > 0
            globe.style.display = count > 0 ? 'block' : 'none'; // Hide if no reminders
        }

        const reminderButton = document.getElementById('reminder-button');
        if (reminderButton) {
            const existingSpan = reminderButton.querySelector('.reminder-count');

            if (count > 0) {
                if (existingSpan) {
                    existingSpan.textContent = count; // Update if exists
                } else {
                    // Create and add the span if it doesn't exist
                    const newSpan = document.createElement('span');
                    newSpan.className = 'reminder-count';
                    newSpan.textContent = count;
                    reminderButton.appendChild(newSpan);
                }
            } else {
                // Remove the span if it exists and count is 0
                if (existingSpan) {
                    existingSpan.remove();
                }
            }
             // Ensure the main button isn't hidden just because the count is 0
            reminderButton.style.display = 'flex'; // Or the original display of the button
        }
    }

     // Helper: Calculates the FIRST occurrence of a reminder STRICTLY AFTER a given reference date.
     // Crucial for finding the "next" occurrence OR the first "missed" one after the last check.
     function calculateNextOccurrence(reminder, referenceDate) {
         if (!reminder || !reminder.type) return null;

         let refTime = referenceDate instanceof Date ? referenceDate.getTime() : new Date(referenceDate).getTime();
         if (isNaN(refTime)) {
             console.error("Invalid referenceDate for calculateNextOccurrence:", referenceDate, reminder);
             // If the reference date is invalid, calculate from the start of time to find the *first* scheduled occurrence.
             refTime = new Date(0).getTime();
         }
         const referenceDateObj = new Date(refTime);


         try {
             switch (reminder.type) {
                 case 'simple':
                     // Simple reminders occur once at createdAt time.
                     // Return createdAt only if it is strictly after referenceDate.
                     if (reminder.createdAt) {
                         const createdDate = new Date(reminder.createdAt);
                         if (createdDate.getTime() > refTime) {
                              return createdDate;
                         }
                     }
                     return null; // Past or invalid creation date

                 case 'daily': // A specific date and time
                 case 'hourly': // Treat like daily if it ever happens
                     if (reminder.date && reminder.time) {
                          try {
                            const [year, month, day] = reminder.date.split('-').map(Number);
                            const [hour, minute] = reminder.time.split(':').map(Number);
                            // Create a Date object for the scheduled time (using local time assumed by time input)
                            const occurrence = new Date(year, month - 1, day, hour, minute, 0, 0); // Use 0 for seconds and milliseconds

                            // Return the occurrence only if it is strictly after referenceDate.
                            if (occurrence.getTime() > refTime) {
                                return occurrence;
                            }
                           } catch(e) {
                               console.error("Error creating Date for daily/hourly:", reminder.date, reminder.time, e);
                           }
                     }
                     return null; // Date or time missing, or occurrence is in the past relative to referenceDate or date is invalid

                 case 'weekly':
                     if (reminder.time && reminder.repeatDays?.length > 0) {
                         const [hour, minute] = reminder.time.split(':').map(Number);
                         const daysOfWeek = reminder.repeatDays.sort((a, b) => a - b); // Ensure order

                         // Start checking from the day AFTER referenceDate
                         const checkDate = new Date(referenceDateObj.getTime() + 1000); // Start 1 second after ref date to find *strictly* after

                         for (let i = 0; i < 14; i++) { // Check up to 14 days ahead
                             const candidateDate = new Date(checkDate);
                             candidateDate.setDate(checkDate.getDate() + i); // Candidate day

                             const candidateDayOfWeek = candidateDate.getDay(); // Day of the week (0=Sun)

                             // If the candidate day is one of the repeat days
                             if (daysOfWeek.includes(candidateDayOfWeek)) {
                                 // Create a full date/time for the candidate day with the reminder time
                                 const potentialOccurrence = new Date(
                                     candidateDate.getFullYear(),
                                     candidateDate.getMonth(),
                                     candidateDate.getDate(),
                                     hour,
                                     minute,
                                     0, 0 // Seconds, milliseconds
                                 );

                                 // If this potential occurrence is strictly after referenceDate, it's the first one
                                  if (potentialOccurrence.getTime() > refTime) {
                                      return potentialOccurrence;
                                  }
                                 // If not strictly after, it means it falls on the same day as referenceDate but before the referenceDate time,
                                 // or it's an earlier day. Continue searching.

                             }
                         }
                         return null; // Not found occurrence within 14 days (shouldn't happen with valid weekly reminder)
                     }
                     return null; // Time or repeatDays missing

                 case 'interval':
                     if (reminder.date && reminder.intervalDays > 0) {
                         const [hour, minute] = (reminder.time || '00:01').split(':').map(Number);
                         const intervalDays = reminder.intervalDays;

                         // Parse the initial/last occurrence date
                          try {
                            const [year, month, day] = reminder.date.split('-').map(Number);
                            const initialOrLastOccurrenceDate = new Date(year, month - 1, day);
                             // Create a Date object for the scheduled time for that day
                            const initialOrLastOccurrence = new Date(
                                initialOrLastOccurrenceDate.getFullYear(),
                                initialOrLastOccurrenceDate.getMonth(),
                                initialOrLastOccurrenceDate.getDate(),
                                hour,
                                minute,
                                0, 0
                            );

                            let nextOccurrence = new Date(initialOrLastOccurrence);
                            let safetyCounter = 0; // Prevent infinite loops
                            const maxIntervalsToCheck = 365 * 10; // Limit to 10 years in the future

                            // Advance date in intervals until it is strictly AFTER referenceDate
                            while (nextOccurrence.getTime() <= refTime && safetyCounter < maxIntervalsToCheck) {
                                nextOccurrence.setDate(nextOccurrence.getDate() + intervalDays);
                                safetyCounter++;
                            }

                             if (safetyCounter >= maxIntervalsToCheck) {
                                console.warn(`Interval calculation reached limit for reminder ID ${reminder.id}. Date: ${reminder.date}, Interval: ${reminder.intervalDays}, ReferenceDate: ${referenceDateObj.toISOString()}`);
                                return null; // No found a next occurrence within the limit
                             }

                            return nextOccurrence;

                          } catch(e) {
                              console.error("Error creating Date for interval initial date:", reminder.date, reminder.time, e);
                          }
                     }
                     return null; // Date or intervalDays missing or invalid or date is invalid

                 default:
                     console.warn("Unknown reminder type:", reminder.type, "for ID:", reminder.id);
                     return null; // Unknown type
             }
         } catch (e) {
             console.error(`Error calculating next occurrence for reminder ID ${reminder.id} with reference ${referenceDateObj.toISOString()}:`, e, reminder);
             return null;
         }
     }


    function checkReminders() {
        const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        const now = new Date();
        const currentTime = now.getTime();

         // Get the timestamp of the last check/close from localStorage
        const lastCheckTimestampStr = localStorage.getItem('lastClosedTimestamp');

         // Define the window for missed reminders (100 hours)
        const missedWindowMs = 100 * 60 * 60 * 1000; // 100 hours in milliseconds

         // Determine the time to start checking from:
         // If lastCheckTimestamp is stored, use it.
         // If not (first load or cleared), use 100 hours ago.
        const lastCheckTime = new Date(parseInt(lastCheckTimestampStr) || (Date.now() - missedWindowMs));
        // Ensure lastCheckTime is not in the future relative to currentTime (can happen if system clock changes)
        if (lastCheckTime.getTime() > currentTime) {
             console.warn("lastCheckTime was in the future, resetting to current time.");
             lastCheckTime = now;
        }


         // Update the last check timestamp in localStorage to NOW, for the *next* load.
         // This should be done *before* any potential async operations or exiting the function.
         localStorage.setItem('lastClosedTimestamp', currentTime.toString());
        console.log(`Check Reminders started. Now: ${now.toISOString()}. Last check considered from: ${lastCheckTime.toISOString()}.`);


        const remindersToNotify = []; // List of reminders that should trigger a notification THIS check.
        const finalRemindersForStorage = []; // List of reminders that should remain in storage AFTER this check.
        let needsStorageUpdate = false; // Flag to know if we need to save reminders back to localStorage.

         // Define buffer around 'now' for "due now" notification trigger
        const dueNowBufferMs = 15 * 1000; // +/- 15 seconds


         // Get IDs of notifications currently displayed in the DOM
        const currentlyDisplayedIds = Array.from(document.querySelectorAll('#reminder-notifications .reminder-notification'))
                                        .map(el => parseInt(el.dataset.id));


        reminders.forEach(reminder => {
            let reminderCopy = { ...reminder }; // Work on a copy to potentially modify for storage

            let shouldNotifyThisCheck = false;
            let notifyReason = null; // 'dueNow' or 'missed' or 'missedPastWindow'

            // --- 1. Determine Notification Status for THIS check ---

             // Find the first occurrence strictly AFTER the LAST CHECK TIME
            const firstOccurrenceAfterLastCheck = calculateNextOccurrence(reminderCopy, lastCheckTime);

            // If this occurrence exists AND is before or very near NOW
            // This covers both "missed" occurrences and "due now" occurrences.
            if (firstOccurrenceAfterLastCheck && firstOccurrenceAfterLastCheck.getTime() <= (currentTime + dueNowBufferMs)) {
                 // This reminder *could* be notified this check, subject to cooldown.
                 shouldNotifyThisCheck = true;
                 notifyReason = firstOccurrenceAfterLastCheck.getTime() < (currentTime - dueNowBufferMs) ? 'missed' : 'dueNow';
                 console.log(`Reminder ID ${reminderCopy.id} occurrence found at ${firstOccurrenceAfterLastCheck.toISOString()}. Reason: ${notifyReason}`);
            } else if (firstOccurrenceAfterLastCheck) {
                // The first occurrence after last check is in the significant future. Not due/missed now.
                 console.log(`Reminder ID ${reminderCopy.id} next occurrence ${firstOccurrenceAfterLastCheck.toISOString()} is in the future.`);
            } else {
                // No occurrence found after last check. This means the reminder is likely in the past
                // and wasn't cleaned up yet, or is misconfigured.
                 console.log(`Reminder ID ${reminderCopy.id} has no occurrence after last check time ${lastCheckTime.toISOString()}.`);
            }


            // --- 2. Apply Notification Cooldown for recurring types IF it should be notified ---
            if (shouldNotifyThisCheck && ['weekly', 'interval'].includes(reminderCopy.type)) {
                const key = `reminder_last_notified_${reminderCopy.id}`;
                const lastNotifiedTimestamp = parseInt(sessionStorage.getItem(key) || '0');
                const notificationCooldownMs = 90 * 1000; // 90 seconds

                if (Date.now() - lastNotifiedTimestamp < notificationCooldownMs) {
                    console.log(`Notification for recurring reminder ID ${reminderCopy.id} skipped due to cooldown.`);
                    shouldNotifyThisCheck = false; // Don't notify now
                } else {
                   // If not on cooldown, set cooldown for this session
                   sessionStorage.setItem(key, Date.now().toString());
                   console.log(`Notification cooldown set for reminder ID ${reminderCopy.id}. Notification WILL proceed.`);
               }
           }


            // --- 3. Determine Storage Status for this reminder ---
            let shouldKeepInStorage = true; // Assume keep unless decided otherwise

            // Rule 1: Remove single-shot reminders whose occurrence is in the past relative to NOW.
            // Calculate the SINGLE occurrence time for non-recurring types from the very beginning of time (epoch).
            if (['daily', 'simple', 'hourly'].includes(reminderCopy.type)) {
                 const singleOccurrenceTime = calculateNextOccurrence(reminderCopy, new Date(0)); // ReferenceDate 0 ensures it finds the first/only one

                 if (singleOccurrenceTime && singleOccurrenceTime.getTime() < currentTime) {
                     // This single-shot reminder's time is in the past relative to NOW. It should be removed from storage.
                      console.log(`Removing old single-shot ID ${reminderCopy.id} (${reminderCopy.date} ${reminderCopy.time}) as its time is in the past relative to NOW.`);
                     shouldKeepInStorage = false;
                     needsStorageUpdate = true; // Storage needs update because this one is being removed.
                      sessionStorage.removeItem(`reminder_last_notified_${reminderCopy.id}`); // Clear cooldown if exists
                 }
            }
            // Rule 2: If an interval reminder was notified THIS check, update its date for storage.
             if (shouldNotifyThisCheck && reminderCopy.type === 'interval' && reminderCopy.intervalDays > 0) {
                  // Calculate the NEXT occurrence *from NOW* (not from lastCheckTime or occurrence time)
                 const nextIntOccurrenceFromNow = calculateNextOccurrence(reminderCopy, now); // ReferenceDate is NOW

                 if (nextIntOccurrenceFromNow) {
                      reminderCopy.date = `${nextIntOccurrenceFromNow.getFullYear()}-${(nextIntOccurrenceFromNow.getMonth() + 1).toString().padStart(2, '0')}-${nextIntOccurrenceFromNow.getDate().toString().padStart(2, '0')}`;
                      console.log(`Interval ID ${reminderCopy.id} date updated to ${reminderCopy.date} for storage after notification.`);
                      needsStorageUpdate = true; // Storage needs update because this one was modified.
                      // shouldKeepInStorage remains true for interval types that update.
                 } else {
                     console.warn(`Interval ID ${reminderCopy.id} notified but no next occ from NOW. Marking for removal from storage.`);
                     shouldKeepInStorage = false; // Remove if no next occurrence is found from now.
                     needsStorageUpdate = true;
                      sessionStorage.removeItem(`reminder_last_notified_${reminderCopy.id}`); // Clear cooldown
                 }
             }
             // Rule 3: Weekly reminders are always kept (unless manually deleted elsewhere). No date update needed.
             // Rule 4: Future single-shots (whose time is > currentTime) are kept (Rule 1 handles removal).


            // --- 4. Collect Reminders for the Final Storage List ---
            // Add the reminder (potentially updated for interval) to the list that will be saved back,
            // but only if it was NOT marked for removal (`shouldKeepInStorage` check).
            if (shouldKeepInStorage) {
                 finalRemindersForStorage.push(reminderCopy);
            }

            // --- 5. Add to Notification List if it should be notified THIS check ---
            if (shouldNotifyThisCheck) {
                 remindersToNotify.push(reminderCopy); // Add the reminder to the notification list
            }

        }); // End reminders loop


        // --- 6. Save Updated Storage List ---
        // Storage is updated only if any reminder was removed or an interval reminder's date was updated.
        if (needsStorageUpdate) {
           localStorage.setItem('reminders', JSON.stringify(finalRemindersForStorage));
           console.log(`Storage updated. Final reminder count: ${finalRemindersForStorage.length}`);
        } else {
           console.log("No storage update needed.");
        }

        // --- 7. Remove Old Notifications from DOM ---
         // Find notifications in the DOM whose reminder ID is NOT in the list of reminders to NOTIFY *this check*
        const notifiedIdsNow = remindersToNotify.map(r => r.id);
        currentlyDisplayedIds.forEach(displayedId => {
             // If a notification is displayed but the reminder is not in the list for notification *this check*
             // then remove the notification from the UI.
             // The logic in step 6 handles whether the reminder is actually removed from storage.
             const shouldRemoveNotif = !notifiedIdsNow.includes(displayedId);

             if (shouldRemoveNotif) {
                 const notificationElement = document.querySelector(`.reminder-notification[data-id="${displayedId}"]`);
                 if (notificationElement) {
                      console.log(`Removing notification for ID ${displayedId} (not in current notify list).`);
                      notificationElement.remove();
                      // SessionStorage cooldown was already cleared in step 3 if the reminder was removed from storage.
                 }
             }
        });


        // --- 8. Show New Notifications ---
        remindersToNotify.forEach(rem => {
             // Double check against current DOM just in case (a notification might have been created by a prior loop iteration or event)
             if (!document.querySelector(`.reminder-notification[data-id="${rem.id}"]`)) {
                 console.log(`Showing notification for ID ${rem.id}.`);
                 showReminderNotification(rem);
             }
        });

        // --- 9. Update UI ---
        updateReminderCount(); // This should reflect the count in finalRemindersForStorage
        updateButtonStyles(); // Ensure button style is correct (count globe)

    } // End checkReminders


    // --- Config Tab User Data Save Logic Refinement ---
     // In showConfigModal, when saving user data:
     // - If userId has changed or is new, check existence in GAS.
     // - If exists, show error, DO NOT save remotely, DO NOT overwrite local.
     // - If does not exist, save locally, then attempt to delete old remote if old userId existed, then save new remote.
     // - If userId is the SAME as stored, just attempt to update remote.

     // The saveUserButton listener needs refinement based on the API calls.

     // ... (rest of showConfigModal function, specifically the saveUserButton listener)

     // showConfigModal function structure remains the same, only the listener for saveUserButton is revised below.
     // The rest of the config modal logic (tabs, backup/restore, clear) seems okay based on the previous version.


    function showToast(message, type = 'info', duration = 3000) { const ex=document.getElementById('toast-notification-element'); if(ex)ex.remove(); const t=document.createElement('div'); t.id='toast-notification-element'; t.className=`toast-notification toast-${type}`; t.textContent=message; document.body.appendChild(t); requestAnimationFrame(()=>{requestAnimationFrame(()=>{t.classList.add('show');});}); setTimeout(()=>{t.classList.remove('show'); t.addEventListener('transitionend',()=>{if(t.parentNode)t.parentNode.removeChild(t);},{once:true});},duration); }


    // --- Initial Setup ---
    document.addEventListener('DOMContentLoaded', async () => {
        console.log("DOM loaded");

        loadCustomData();       // 1. Load custom data
        renderGrid();           // 2. Render the main grid content (populates cellElements)
        createOtherButtons();   // 3. Create ALL dynamic buttons (top and side) and attach listeners
        renderToggleButtons();  // 4. Render section toggles and attach listeners

        try { await updateVersion(); } catch (e) { console.error("Version update fail", e); }

        loadSavedSettings();    // 5. Load UI states (applies states to existing elements)
                                // loadReminders() is called inside loadSavedSettings

        try { await loadNotices(); startNoticeRotation(); } catch (e) { console.error("Notices fail", e); }

        // 6. Start reminder checks AFTER loading everything and setting up lastClosedTimestamp
        checkReminders(); // Initial check on page load
        const remInterval = setInterval(checkReminders, 60000); // Periodic check every minute

        // Attach listener for notice toggle icon (needs to exist now)
        const noticeToggleIcon = document.getElementById('notice-toggle-icon');
        if (noticeToggleIcon) {
             noticeToggleIcon.addEventListener('click', toggleNotices); // Use the corrected function
        } else {
            console.error("Notice toggle icon not found!");
        }

        const countEl = document.getElementById('reminder-count-globe');
        if (countEl) {
             const openTable = (e) => { e.preventDefault(); e.stopPropagation(); showAllReminders(); };
             countEl.addEventListener('click', openTable);
             countEl.style.cursor = 'pointer'; // Make it visually indicate it's clickable
         }

        adjustButtonPositions(); // 7. Position ALL buttons correctly NOW
        window.addEventListener('resize', adjustButtonPositions); // Reposition on resize

        // Clean up interval when the page is about to be unloaded
        window.addEventListener('beforeunload', () => {
            clearInterval(remInterval);
             // Note: Setting lastClosedTimestamp on beforeunload is ideal but unreliable across browsers/scenarios.
             // We set it at the start of checkReminders as a robust approximation.
        });


        console.log("Setup complete.");
    });

</script>
</body>
</html>