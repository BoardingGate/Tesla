CHECK 46
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <title>BoardingGate</title>
    <link rel="icon" href="https://boardinggate.github.io/Tesla/th.jpeg" type="image/jpeg">
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">                                                                                                                                                                                                                                          import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";   import { getFirestore, doc, setDoc, getDoc, getDocs, deleteDoc, collection, serverTimestamp, where, query, orderBy, limit, addDoc, writeBatch } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js"; console.log("Firebase Init Script: STARTING initialization.");   const firebaseConfig = {apiKey: "AIzaSyCEAWL1Pj1OMBrGnXLOS79W3iDjMkmTQGw",authDomain: "boardinggate-1df74.firebaseapp.com",databaseURL: "https://boardinggate-1df74-default-rtdb.europe-west1.firebaseio.com",projectId: "boardinggate-1df74",storageBucket: "boardinggate-1df74.appspot.com", messagingSenderId: "771541345352",appId: "1:771541345352:web:0447d72b3383875ac5a47d" };    try {    const app = initializeApp(firebaseConfig);     window.db = getFirestore(app);   window.doc = doc;  window.setDoc = setDoc;  window.getDoc = getDoc;  window.collection = collection; window.getDocs = getDocs;  window.deleteDoc = deleteDoc;  window.serverTimestamp = serverTimestamp;  window.where = where; window.query = query; window.orderBy = orderBy;window.limit = limit; window.addDoc = addDoc;  window.writeBatch = writeBatch; console.log("Firebase Init Script: SUCCESS Firestore initialized and functions exposed globally. window.db is:", window.db);  } catch (e) { console.error("Firebase Init Script: ERROR during initialization!", e); }  console.log("Firebase Init Script: END of initialization block.");</script>

<script src="//cdn.jsdelivr.net/npm/eruda"></script>
<script>eruda.init();</script>
   
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://unpkg.com/leaflet-geometryutil@0.10.3/src/leaflet.geometryutil.js"></script>
   
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.css' rel='stylesheet' />
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.js'></script>
    
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>                                                                                                                                                                                                                                               <script async src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCEAWL1PjlOMBrGnXLOS79W3iDJMkmTQGw&v=beta&libraries=places&callback=initMap&loading=async"></script> <script>   function initMap() {} </script>
 </head>
<style>  

body {
    display: flex; flex-direction: column; min-height: 100vh;
    background-color: #ABAB99; margin: 0; overflow-x: hidden;}

body.dark-mode {background-color: #92927E;}

#radar-speed-selection-modal {  z-index: 7500 !important;}
    
main {
    position: relative;
    margin: 0 auto 0.5rem 60px; margin-top: 76px;
    background-color: transparent; border-radius: 0.75rem;
    padding: 16px; min-height: 400px;
    max-width: 984px; width: 100%;
    transition: margin-top 0.5s ease-in-out;}

footer {
    margin: 0.5rem auto; margin-left: 145px;
    text-align: center; max-width: 984px; width: 100%;
    display: block; background-color: #ABAB99;
    transition: margin-top 0.5s ease-in-out;}

body.dark-mode footer {background-color: #92927E;}

.footer-content {
    color: #5C5C47; padding: 0.5rem; margin: 0 auto;
    max-width: 100%; position: relative;}

.footer-subtext {
    font-size: 0.75rem; color: #5C5C47; margin-top: 0.25rem; text-align: center;}

.footer-link-green {color: #5C5C47; text-decoration: none;
    transition: color 0.2s ease;}
.footer-link-green:hover {   color: #5C5C47;}
.footer-line {
    display: flex; justify-content: center; align-items: center;
    gap: 0.5rem; flex-wrap: wrap;}
.hidden, .footer-hidden {    display: none !important;}
.header-container {
    display: flex; align-items: center; justify-content: center;
    gap: 0.5rem; background-color: #ABAB99; padding: 0.5rem;}

body.dark-mode .header-container {  background-color: #92927E;}
.header-logo {
    width: 100px; height: 70px;   transition: filter 0.2s ease;}
body.dark-mode .header-logo {  filter: brightness(85%);}
.title-container {
    background-color: #ABAB99; padding: 0.5rem 1rem;
    border-radius: 0.5rem; display: inline-block;}
body.dark-mode .title-container   background-color: #92927E;}
.header-container h1 {   color: #5C5C47;}

.version-text {
    font-size: 0.75rem; color: #5C5C47;  font-weight: normal;}
#bookmark-grid {
    display: grid; grid-template-columns: repeat(6, minmax(120px, 1fr));
    gap: 15px; background-color: transparent;
    border-radius: 0.75rem; position: relative;
    width: 970px; max-width: 970px;    margin: 0 auto 0 85px;  transition: all 0.3s ease;}
@media (max-width: 1024px) {
    #bookmark-grid {
        width: 100%; margin: 0 auto 0 70px;
        grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));  }}
#bookmark-grid > div {
    height: auto; aspect-ratio: 16 / 9;   transition: all 0.3s ease;}
.bookmark-item {
    width: 100%; height: 100%; position: relative; cursor: pointer;
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    border-radius: 0.5rem;
    box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1);
    transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease;}

.bookmark-item:hover:not(.editing-active *):not(.assignment-active *):not(.dragging *):not(.editing-target *):not(.keyword-assignment-active *) {
    transform: scale(1.05) translateY(-1px);
    box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.6), -6px -6px 12px rgba(255, 255, 255, 0.15);}
.bookmark-item img {
    image-rendering: crisp-edges; width: 36px; height: auto;
    max-width: 40px; border-radius: 0.25rem;}
.bookmark-name {
    font-size: clamp(0.85rem, 1.5vw, 1.15rem); font-weight: bold;
    color: #333; text-align: center; margin-top: 4px;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    max-width: 100%;}
body.dark-mode .bookmark-item {  filter: brightness(60%);}
.empty-slot {
    width: 100%; height: 100%; cursor: default;
    display: flex; justify-content: center; align-items: center;
    border: 1px dashed #ccc; border-radius: 0.5rem;
    background-color: rgba(200, 200, 200, 0.1); color: #aaa;
    transition: background-color 0.2s ease, outline 0.2s ease, box-shadow 0.2s ease;}

.empty-slot span {font-size: 2rem; pointer-events: none;}

body.dark-mode .empty-slot {  border-color: #666; color: #777;
    background-color: rgba(100, 100, 100, 0.2);}
.toggle-image,
.toggle-sign {
    width: 135px; height: 74px; margin-bottom: 2px;
    box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.4);
    border: 1px solid #7c7c68; border-radius: 35px;
    position: fixed; left: 10px; top: 90px;
    z-index: 1000; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    background-color: #ABAB99;
    transition: background-color 0.2s ease, filter 0.2s ease, top 0.3s ease, border 0.2s ease;}
.toggle-sign {
    font-weight: bold; font-size: 1.25rem;    color: #000000; text-align: center;}
.toggle-sign .sign {    font-size: 1.5rem; margin-right: 2px;}
.toggle-sign img,
.toggle-image img {
    max-width: 70%; max-height: 70%;  object-fit: contain;}
.toggle-sign:not(.range-toggle):not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *):hover {
    background-color: #D9A066;}
.toggle-sign.range-toggle:not([data-state="hidden"]):not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *):hover {
    background-color: #D9A066;}
.toggle-image:hover { filter: brightness(80%);}
.toggle-sign.range-toggle[data-state="hidden"] {  background-color: #ABAB99; color: #7F7F7F;}
body.dark-mode .toggle-sign.range-toggle[data-state="hidden"] {
    background-color: #ABAB99; color: #A0A0A0;}
body.dark-mode .toggle-sign:not(.range-toggle):not(#password-toggle-button),
body.dark-mode .toggle-image,
body.dark-mode .toggle-sign.range-toggle:not([data-state="hidden"]) {
    filter: brightness(85%); background-color: #ABAB99;}
body.dark-mode .toggle-sign:not(.range-toggle):hover:not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *),
body.dark-mode .toggle-sign.range-toggle:not([data-state="hidden"]):hover:not(.editing-active *):not(.assignment-active *):not(.keyword-assignment-active *) {
    background-color: #ABAB99;}
.scroll-toggle-button {
    position: fixed; left: 10px; top: 10px;
    width: 110px !important; height: clamp(75px, 20vw, 130px) !important;
    background-color: #ABAB99; border-radius: 60px;
    display: flex; flex-direction: column; align-items: center; justify-content: space-between;
    padding: clamp(10px, 2vw, 20px); cursor: pointer;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.4) !important;
    border: 1px solid #808080 !important; z-index: 1001;
    transition: background-color 0.2s ease;}
.scroll-toggle-button:hover {   background-color: #668B8B;}
.scroll-toggle-button svg {
    width: clamp(24px, 4vw, 32px); height: clamp(24px, 4vw, 32px);
    stroke: #E6E6DC;}
#config-button, #personal-button, #radar-button,
#home-button, #reload-button, #keyword-assignment-button,
#password-toggle-button, #versions-button, #info-button {
    width: auto !important; height: auto !important;
    background-color: transparent !important; border: none !important;
    box-shadow: none !important; padding: 5px !important;
    position: absolute !important; top: 37px !important;
    z-index: 900 !important; cursor: pointer; border-radius: 50%;
    transition: transform 0.1s ease, background-color 0.2s ease, box-shadow 0.2s ease, border 0.2s ease;}
#config-button { left: 185px !important; }
#personal-button { left: 260px !important; }
#radar-button { left: 330px !important; }
#home-button { left: 400px !important; }
#reload-button { left: 470px !important; }
#keyword-assignment-button { left: 555px !important; }
#password-toggle-button { left: 1080px !important; top: 25px; }
#info-button { left: 1027px !important; max-width: 30px !important; max-height: 30px !important; }
#versions-button { left: 969px !important; max-width: 30px !important; max-height: 30px !important; }
#config-button img {
    max-width: 52px !important; max-height: 52px !important;
    width: 52px; height: 52px; object-fit: contain;
    display: block; filter: none !important;}

#personal-button img, #radar-button img,
#home-button img, #reload-button img,
#keyword-assignment-button img {
    max-width: 46px !important; max-height: 46px !important;
    width: 46px; height: 46px; object-fit: contain;
    display: block; filter: none !important;}

#versions-button img, #info-button img,
#password-toggle-button img {
    max-width: 53px !important; max-height: 37px !important;
    width: 40px; height: 37px; object-fit: contain; display: block;}
#password-toggle-button img {  filter: brightness(85%) !important; top: 25px;}
#versions-button img { transition: opacity 0.5s ease;}
#config-button:hover, #personal-button:hover, #radar-button:hover,
#home-button:hover, #reload-button:hover,
#keyword-assignment-button:hover:not(.active),
#password-toggle-button:hover,
#versions-button:hover:not(.versions-icon-dimmed),
#info-button:hover {
    transform: scale(1.1); background-color: rgba(255, 255, 255, 0.2);}
#personal-button.editing {
    border: 3px solid yellow !important;
    box-shadow: 0 0 10px yellow !important;}
#personal-button.assigning {
    border: 3px solid cyan !important;
    box-shadow: 0 0 10px cyan !important;}
#keyword-assignment-button.active {
    border: 3px solid yellow !important;
    box-shadow: 0 0 10px yellow !important;
    transform: scale(1.05); background-color: transparent !important;}
body.dark-mode #keyword-assignment-button.active {
    border-color: yellow !important;
    box-shadow: 0 0 10px yellow !important;}
.keyword-assignment-active .grid-cell:hover:not(.editing-active *):not(.assignment-active *):not(.dragging *):not(.editing-target *):not(.keyword-assigned-highlight) {
    transform: scale(1.05) translateY(-1px);
    box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.6), -6px -6px 12px rgba(255, 255, 255, 0.15);
    outline: 3px dashed #10B981; cursor: crosshair;}
.keyword-assignment-active .grid-cell.editing-target {
    outline: 3px solid #10B981 !important; outline-offset: 1px;
    box-shadow: 0 0 8px #10B981;}
.keyword-assignment-active .grid-cell.keyword-assigned-highlight {
    outline: 3px solid yellow !important; outline-offset: 1px;
    box-shadow: 0 0 8px yellow; cursor: crosshair;}
#grid-filter-container {
    position: absolute; top: 43px; left: 615px;
    display: flex; align-items: center; z-index: 900;}
#grid-filter-input {
    padding: 8px 12px; border: 1px solid #7c7c68;
    border-radius: 4px; font-size: 1.3rem; font-weight: bold;
    height: 45px; width: 160px; background-color: #f0f0e0;}
body.dark-mode #grid-filter-input {
    background-color: #a0a090; color: #e0e0e0;    border-color: #666;}
#clear-filter-button {
    background: none; border: none; cursor: pointer;
    padding: 0 8px; margin-left: -35px;
    font-size: 1.6rem; color: #555; height: 40px;
    line-height: 40px; z-index: 901; display: none;}
body.dark-mode #clear-filter-button {   color: #bbb;}
body.dark-mode #user-id-display {
    color: #E6E6DC; background-color: rgba(146, 146, 126, 0.7);
    opacity: 0.7; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6);}
.notices-icon-container {
    display: flex; align-items: center; justify-content: center;
    width: 100%; max-width: 984px; margin: 0 auto;
    margin-left: 165px; position: relative;
    transition: margin-top 0.5s ease-in-out;}
.notices-container {
    flex-grow: 1; padding: 0.5rem; border: none;
    border-radius: 0.5rem; overflow: hidden;
    display: flex; align-items: center; justify-content: center;
    gap: 0; margin-left: 2px; height: 3rem;}
.notice-wrapper {
    padding: 0.5rem; height: 1.5rem;
    flex-grow: 1; overflow: hidden; position: relative;
    display: flex; align-items: center; justify-content: center;}
.notice {
    color: #E6E6DC; font-size: 1.3rem; font-weight: bold;
    white-space: nowrap; text-align: center;
    opacity: 0; animation: fadeInOut 14s infinite;}
@keyframes fadeInOut {
    0% { opacity: 1; }
    10% { opacity: 1; }
    90% { opacity: 1; }
    100% { opacity: 0; }}
.notice-off-icon {
    width: auto; height: clamp(4rem, 7vw, 6rem);
    margin-right: 10px; align-self: center;
    cursor: pointer; transition: filter 0.3s ease;}
body.dark-mode .notice-off-icon {  filter: brightness(85%);}
#reminder-button {
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;
    position: fixed; background-color: #ABAB99;}
#reminder-button img {  object-fit: contain;}
#reminder-button .reminder-count {
    position: absolute; top: 6px; left: 8px;
    background-color: #EF4444; color: #FFFFFF;
    border-radius: 55%; padding: 4px 10px;
    font-size: 1.1rem; font-weight: bold; line-height: 1;
    display: flex; align-items: center; justify-content: center;
    z-index: 1500; min-width: 1.9rem;
    max-width: 2.5rem; text-align: center;}
.reminder-count-globe {
    position: fixed; top: 10px; left: 10px;
    background-color: #2563EB; color: white;
    border-radius: 65%; padding: 10px 15px;
    font-size: 1.3rem; font-weight: bold;
    z-index: 1500;
    transition: margin-top 0.5s ease-in-out;}
#unified-reminder-window {
    position: fixed; top: 35px; left: 180px; transform: none;
    background-color: #FFFF99; border-radius: 1.5rem;
    border: 2px solid #ABAB99; box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
    z-index: 7000; max-width: 550px; width: 95%;
    max-height: 85vh; overflow: hidden;
    display: flex; flex-direction: column;
    transition: opacity 0.3s ease-out, transform 0.3s ease-out;}
#unified-reminder-window:not(.visible) {
    opacity: 0; transform: scale(0.9);  pointer-events: none;}
#unified-reminder-window.visible {
    opacity: 1; transform: scale(1);pointer-events: auto;}
.reminder-count-header {
    padding: 0.8rem 1.5rem; text-align: center;
    font-weight: bold; color: #0000FF;
    border-bottom: 1px solid #ABAB99; flex-shrink: 0;
    display: flex; align-items: center; justify-content: space-between;
    flex-wrap: wrap; gap: 0px 10px; position: relative;}
.reminder-title-container {
    display: flex; flex-direction: column; align-items: center; flex-grow: 1;}
.reminder-title-container > span:first-child {   font-size: 1.3rem;}
.reminder-title-container .swipe-hint {   font-size: smaller;}
#reminder-swiper-container {
    display: flex; overflow-x: auto;
    scroll-snap-type: x mandatory; -webkit-overflow-scrolling: touch;
    scroll-behavior: smooth; flex-grow: 1;
    touch-action: pan-x;}
.reminder-slide {
    flex: 0 0 100%; scroll-snap-align: start; padding: 1.5rem;
    box-sizing: border-box; display: flex; flex-direction: row;
    gap: 1rem; overflow-y: auto; align-items: flex-start;
    max-height: calc(85vh - 60px);}
.reminder-slide-content {
    display: flex; flex-direction: column; flex-grow: 1; min-width: 0;}

.reminder-slide .reminder-content-scrollable {
    max-height: 30vh; overflow-y: auto; margin-bottom: 1rem;
    word-wrap: break-word; overflow-wrap: break-word;
    text-align: left; padding-right: 5px; flex-grow: 1;}
.reminder-slide .reminder-text {
    margin: 0 0 0.5rem 0; font-size: 1.6rem;
    font-weight: bold; color: #0000FF;}

.reminder-slide .reminder-details {
    margin: 0.2rem 0; font-size: 1.15rem;
    font-weight: bold; color: #0000FF;}
.reminder-slide .button-group {
    display: flex; flex-direction: column;
    justify-content: center; gap: 0.5rem;
    margin-top: auto; padding-top: 1rem; flex-shrink: 0;}
.reminder-slide button {
    padding: 0.5rem 1rem; border-radius: 0.25rem;
    cursor: pointer; font-size: 0.9rem;
    width: 100%; background-color: #D1D5DB;}
.reminder-slide button.cancel {
    background-color: #EF4444; color: #FFFFFF;
    font-weight: bold; height: 70px;
    font-size: 1.2rem; order: 1;}
.reminder-slide button.modify {
    background-color: #10B981; font-weight: bold;
    height: 60px; font-size: 1.2rem;
    color: #FFFFFF; order: 5;}
.reminder-slide button.postpone {
    background-color: #F59E0B; font-weight: bold;
    height: 60px; font-size: 1.2rem;
    color: #FFFFFF; order: 3;}
.reminder-slide button.adjust-time-0001 {
    background-color: #4F4F4F; color: #FFFFFF;
    font-weight: bold; height: 60px;
    font-size: 1.2rem; order: 2; margin-top: 0.5rem;}
.reminder-slide button.cancel-cyclic {
    background-color: #8B0000; color: #FFFFFF;
    font-weight: bold; height: 60px;
    font-size: 1.2rem; order: 4; margin-top: 0.5rem;}
.reminder-map-preview-container {
    flex-shrink: 0; width: 150px;
    display: flex; align-items: center; justify-content: center;
    align-self: stretch;}
.reminder-map-preview {
    width: 100%; height: 100%;
    min-height: 100px; max-height: 25vh;
    border-radius: 0.5rem;}
#hide-all-reminders-button {
    background: none; border: none; color: #0000FF;
    font-size: 1rem; font-weight: bold; cursor: pointer;
    padding: 0.2rem 0.5rem; position: absolute; right: 1rem;
    top: 50%; transform: translateY(-50%); z-index: 3001;}
#hide-all-reminders-button:hover {  text-decoration: underline;}
.modal-top-buttons {
    display: flex; justify-content: space-between;
    gap: 1rem; margin-bottom: 1.5rem; flex-wrap: wrap;}
.modal-top-buttons button {
    flex: 1 1 auto; min-width: 100px; background-color: #D1D5DB;}
.reminder-modal, .help-modal, .edit-info-modal,
.choice-modal, .edit-modal, .reminder-table-modal,
.postpone-options, .saved-locations-modal,
#reorder-stages-modal, #simulation-modal,
#deviation-modal, #arrival-stats-modal,
#simulation-speed-modal {
    z-index: 2000; background-color: #DAC8A0;
    padding: 1.0rem; border-radius: 0.3rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);}
#arrival-stats-modal .eta-deviation {
    font-size: 2.1em; font-weight: bold;
    margin-left: 8px; vertical-align: middle;}
#arrival-stats-modal .eta-deviation.positive { color: #EF4444; }
#arrival-stats-modal .eta-deviation.negative { color: #013220; }
#deviation-modal {
    position: fixed; top: 5px;        
    left: 5px;  transform: none;  background-color: #E6D6A8;
    padding: 20px; border-radius: 10px;
    box-shadow: 0 0 15px rgba(0,0,0,0.5);z-index: 9000;
    text-align: center;max-width: 450px;}
#deviation-modal p#deviation-modal-message {
    margin-bottom: 15px; font-size: 1.1rem; color: #333;}
#deviation-modal button {
    padding: 10px 15px; margin: 0 5px;
    border-radius: 5px; font-size: 1rem; font-weight: bold;
    cursor: pointer; border: none;}
#deviation-modal button#deviation-accept {
    background-color: #28a745; color: white;}
#deviation-modal button#deviation-delete-stage {
    background-color: #EF4444; color: white;}
#address-suggestions-modal h2 {
    font-size: 1.1rem; font-weight: bold; text-align: center;
    margin-bottom: 0.75rem; color: #333;}
#address-suggestions-list {
    list-style: none; padding: 0; margin: 0 0 0.75rem 0;
    overflow-y: auto; border: 1px solid #B0A898;
    border-radius: 4px; background-color: #D8CEC0;}

#address-suggestions-list li {
    padding: 8px 12px; border-bottom: 1px solid #C8B890;
    cursor: pointer; font-size: 1.1rem; font-weight: bold;
    color: #F5F5DC; background-color: #5C5C47;}
#address-suggestions-list li:last-child {  border-bottom: none;}
#address-suggestions-list li:hover { background-color: #6B6B56;}
#address-suggestions-modal .modal-top-buttons button#close-address-suggestions-modal {
    background-color: #4A5568 !important; color: white !important;
    border: 1px solid #2D3748 !important; font-weight: bold !important;}
body.modal-open {  overflow: hidden;}
#locations-preview-modal .modal-top-buttons {
    flex-shrink: 0; display: flex;
    justify-content: center; margin-top: 0;}
#address-suggestions-modal .modal-top-buttons button#close-address-suggestions-modal:hover {
    background-color: #2D3748 !important;}
#reorder-stages-modal {
    position: fixed !important; top: 30px !important; left: 50% !important;
    transform: translateX(-50%) !important; width: 80vw !important;
    height: 90vh !important; max-width: none !important;
    max-height: none !important; z-index: 8600 !important;
    display: flex; flex-direction: column;
    background-color: #DAC8A0;}
#simulation-modal {
    position: fixed; top: 10px; right: 40px;
    left: auto; transform: none; background-color: #E6D6A8;
    padding: 1.5rem; border-radius: 1rem;
    box-shadow: 0 6px 15px rgba(0,0,0,0.3); z-index: 8800;
    max-width: 450px; width: calc(100% - 80px);
    max-height: calc(100vh - 20px); display: flex;
    flex-direction: column;}

#simulation-speed-modal {
    position: fixed; top: 50px; left: 50%;
    transform: translateX(-50%); width: 90%;
    max-width: 400px; z-index: 9100;
    background-color: #F5E1A9; padding: 1.5rem;
    border-radius: 1rem; box-shadow: 0 6px 15px rgba(0,0,0,0.3);
    text-align: center;}
#simulation-speed-modal h2 {
    font-size: 1.2rem; font-weight: bold;
    margin-bottom: 1rem; color: #333;}
#simulation-speed-modal input {
    width: 100px; padding: 0.5rem; margin-bottom: 1rem;
    font-size: 1.2rem; text-align: center;
    border: 1px solid #ccc; border-radius: 4px;}
#reorder-stages-modal button { background-color: #D1D5DB;}
#reorder-stages-modal #confirm-reorder-stages {
    background-color: #28a745; color: white;}
#reorder-stages-modal #cancel-reorder-stages {
    background-color: #6c757d; color: white;}
#simulation-modal #close-simulation-modal {
    background-color: #2563EB; color: white;
    position: absolute; top: 10px; left: 10px;
    height: 35px; padding: 0.5rem 1rem; font-size: 0.9rem;
    min-height: unset; min-width: unset; width: auto;
    line-height: 1;}

.postpone-options {
    background-color: #F5E1A9 !important; z-index: 7500 !important;
    top: 10px !important; transform: translateX(-50%) !important;}
.versions-modal-overlay {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    display: flex; justify-content: center; align-items: flex-start;
    z-index: 5000; padding-top: 50px;}
.versions-modal-content {
    background-color: #DAC8A0; padding: 1.5rem;
    border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
    width: 85%; max-width: 900px; max-height: 85vh;
    overflow-y: auto; display: flex; flex-direction: column;}
.versions-modal-content h2 {
    font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem;
    color: #111827; text-align: center;}
.versions-modal-content .modal-top-buttons { margin-bottom: 1rem;}
.versions-modal-content pre {
    white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word;
    font-size: 1rem; line-height: 1.4; color: #333;
    margin-bottom: 1.5rem; padding: 0.8rem;
    background-color: #f0f0e0; border-radius: 0.25rem;
    max-height: calc(85vh - 150px); overflow-y: auto;}
.versions-modal-content button {
    display: block; width: 100%; padding: 0.75rem 1rem;
    border-radius: 0.25rem; cursor: pointer; font-size: 1.1rem;
    text-align: center; border: none;
    background-color: #2563EB; color: white;}
.versions-modal-content button:hover {  background-color: #1D4ED8;}
.reminder-modal {
    position: fixed; top: 1%; left: 50%;
    transform: translate(-50%, 0); max-width: 96%; width: 95%;
    max-height: 95vh; overflow-y: auto;
    font-weight: bold; font-size: 1.3rem;}
.reminder-table-modal button.visto-prox {
    background-color: #EF4444; font-size: 0.9rem; color: #FFFFFF;
    border: 1px solid #A00000; font-weight: bold;}
.reminder-table-modal button.visto-prox:hover {  background-color: #D00000;}
.help-modal,
.edit-info-modal {
    position: fixed; top: 1%; left: 50%;
    transform: translate(-50%, 1%); max-width: 910px; width: 98%;
    max-height: 96vh; overflow-y: auto; font-size: 1.10rem;
    z-index: 5500;}
#reminders-map-help-modal-instance {
    position: fixed !important; top: 0 !important; left: 0 !important;
    width: 100vw !important; height: 100vh !important;
    max-width: none !important; max-height: none !important;
    transform: none !important; z-index: 7000 !important;
    border-radius: 0 !important; box-sizing: border-box !important;
    padding: 1rem !important;}
#reminders-map-help-modal-instance > div[style*="overflow-y: auto"] {
    padding: 1.5rem !important; flex-grow: 1;
    max-height: none !important;}
.choice-modal {
    position: fixed; top: 1%; left: 50%;
    transform: translate(-50%, 1%); max-width: 540px; width: 95%;
    max-height: 98vh; overflow-y: auto; font-size: 1.10rem;
    z-index: 5500;}
.reminder-table-modal {
    position: fixed; top: 30px; left: 35px;
    transform: translateY(0); max-width: 99%; width: 1090px;
    max-height: 90vh; overflow-y: auto;
    background-color: #E6D6A8; border-radius: 1.5rem;}
.edit-modal {
    position: fixed; top: 5%; left: 50%;
    transform: translate(-50%, 0); width: 75%; max-width: 900px;
    border: 5px solid #A0522D; background-color: #EADDCA;
    z-index: 6000;}
.modal h2,
.modal h3 {
    font-weight: bold; margin-bottom: 1rem; color: #111827;}
.reminder-modal h2, .help-modal h2, .edit-info-modal h2,
.choice-modal h2, .edit-modal h2, .saved-locations-modal h2,
#reorder-stages-modal h2, #simulation-modal h2, #deviation-modal h2,
#arrival-stats-modal h2, #simulation-speed-modal h2 {
    font-size: 1.5rem;}

.reminder-modal label, .help-modal label, .edit-info-modal label,
.choice-modal label, .edit-modal label, .saved-locations-modal label {
    display: block; margin-bottom: 0.25rem; font-weight: 500;
    color: #374151; font-size: 1.1rem;}
.reminder-modal button, .help-modal button, .edit-info-modal button,
.choice-modal button, .edit-modal button, .reminder-table-modal button,
.versions-modal-content button, .saved-locations-modal button,
#reorder-stages-modal button, #simulation-modal button,
#address-suggestions-modal button, #deviation-modal button,
#arrival-stats-modal button, #simulation-speed-modal button {
    padding: 0.75rem 1rem; border-radius: 0.25rem;
    cursor: pointer; font-size: 1.1rem; flex: 1;
    text-align: center; min-width: 100px; border: none;
    background-color: #D1D5DB; min-height: 60px;}
.reminder-modal .modal-top-buttons button {  height: 70px; min-height: 70px;}
.edit-info-modal #close-edit-info,
.help-modal #close-help,
#reminders-map-help-modal-instance #close-reminders-map-help-instance,
#simulation-modal #close-simulation-modal {
    background-color: #2563EB; color: white;}
.edit-info-modal #close-edit-info:hover,
.help-modal #close-help:hover,
#reminders-map-help-modal-instance #close-reminders-map-help-instance:hover,
#simulation-modal #close-simulation-modal:hover {
    background-color: #1D4ED8;
    height: 20px; }
.reminder-modal textarea#reminder-text {
    width: 100%; padding: 0.5rem; margin-bottom: 0.3rem;
    border: 1px solid #D1D5DB; border-radius: 0.25rem;
    font-size: 1.4rem; font-weight: bold;
    text-transform: uppercase;}
.reminder-modal input#reminder-time { max-width: 120px; width: auto; }
.reminder-modal input#reminder-date { max-width: 160px; width: auto; }
.reminder-modal input#reminder-interval { max-width: 100px; width: auto; }
.reminder-modal input#reminder-radius { max-width: 120px; width: auto; }
.reminder-modal input[type="text"],
.reminder-modal input[type="number"] {
    padding: 0.5rem; margin-bottom: 0.3rem;
    border: 1px solid #D1D5DB; border-radius: 0.25rem;
    font-size: 1.5rem; text-align: center;}
.reminder-modal .form-grid {
    display: grid; grid-template-columns: auto auto auto 1fr;
    gap: 1rem; align-items: end; margin-bottom: 1rem;}
label[for="reminder-interval"] { line-height: 1.2;}
.location-controls-group {
    grid-column: 4 / 5; display: flex;  flex-wrap: wrap; align-items: center;
    justify-content: flex-start; gap: 0.5rem;  margin-top: 0;}
.location-controls-group label { margin-bottom: 0; }
.location-controls-group input[type="checkbox"] { margin-right: 0.2rem; }
.location-controls-group label[for="reminder-radius"] { margin-left: 0; }
#expand-map-button {
    padding: 0.3rem 0.6rem !important; font-size: 1.3rem !important;
    height: auto !important; flex-shrink: 0;
    background-color: #668B8B !important; color: white !important;
    border: none !important; border-radius: 0.25rem !important;
    min-width: unset !important; flex: unset !important;
    margin-left: 0.5rem;}
#expand-map-button:hover {  background-color: #5C5C47 !important;}
#location-map-container {
    grid-column: 1 / -1; width: 100%;
    border: 1px solid #ccc; border-radius: 0.25rem;
    background-color: #eee; position: relative;
    margin-top: 0.5rem; display: none;
    transition: height 0.3s ease-in-out;}
#location-map-container.preview { display: block !important; height: 65px;}

#location-map-container.expanded { display: block !important; height: 360px;}
#reduce-map-button,
#locate-me-button {
    position: absolute; top: 5px; z-index: 1001;
    padding: 0.8rem 1rem; font-size: 1rem; font-weight: bold;
    background-color: rgba(255, 255, 255, 0.9);
    border: 1px solid #777; border-radius: 4px;
    cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.25);
    transition: background-color 0.2s ease;}
#reduce-map-button:hover,
#locate-me-button:hover {
    background-color: rgba(230, 230, 230, 0.95);}
#reduce-map-button { right: 5px; }
#locate-me-button { right: calc(5px + 135px + 15px); }
.reminder-modal .full-width {
    grid-column: 1 / -1;}
.reminder-modal .days-group {
    display: flex; gap: 1rem; flex-wrap: wrap;
    grid-column: 1 / -1; margin-top: 1rem;}
.reminder-modal .days-group label {
    font-size: 1.1rem; flex: 0 0 auto;}
.reminder-modal button[type="submit"] {
    background-color: #2563EB; color: #FFFFFF;
    display: flex; align-items: center; justify-content: center;
    gap: 0.6rem;}

.reminder-modal button[type="submit"] span#countdown-save {
    font-size: 1.6rem; font-weight: bold; justify-content: right;
    color: #e6e6dc;}
.reminder-modal button[type="button"] {
    background-color: #D1D5DB; color: #111827;}
#config-modal #config-close-modal,
#simulation-speed-modal #cancel-simulation-speed,
.postpone-options #cancel-postpone {
    background-color: blue !important; color: white !important;
    border: 1px solid #2D3748 !important; font-weight: bold !important;}
#config-modal #config-close-modal:hover,
#simulation-speed-modal #cancel-simulation-speed:hover,
.postpone-options #cancel-postpone:hover {
    background-color: #2D3748 !important;}
#simulation-speed-modal #confirm-simulation-speed {
    background-color: #28a745 !important; color: white !important;}
.speech-button {
    background-color: #668B8B; color: white;
    border: none; border-radius: 0.25rem;
    padding: 0.5rem; cursor: pointer;
    margin-left: 0.5rem; font-size: 1rem;
    vertical-align: top;}
.speech-button:hover { background-color: #5C5C47;}
.speech-status {
    font-size: 0.85rem; color: #ABAB99;
    margin-top: 0.1rem; min-height: 1em;}
#auto-save-timer {
    color: #1E40AF; grid-column: 1 / -1;  text-align: center;}
.reminder-table-modal td.text-column {text-align: left;}
.reminder-table-modal td.date-column {  white-space: nowrap;}
.reminder-table-modal button.modify {
    background-color: #10B981; font-size: 1rem; color: #FFFFFF;
    height: 60px; border: 1px solid #008000; font-weight: bold;}
.reminder-table-modal button.modify:hover {  background-color: #008000;}
.reminder-table-modal button.delete {
    background-color: #EF4444; font-size: 0.9rem; color: #FFFFFF;
    border: 1px solid #A00000; font-weight: bold;}
.reminder-table-modal button.delete:hover { background-color: #D00000;}
.reminder-table-modal button.postpone {
    background-color: #F59E0B; font-size: 0.9rem; color: #FFFFFF;
    border: 1px solid #D97706; font-weight: bold;}
.reminder-table-modal button.postpone:hover {  background-color: #D97706;}
.reminder-table-modal button.cancel-cyclic-table {
    background-color: #8B0000; font-size: 0.9rem; color: #FFFFFF;
    border: 1px solid #580000; font-weight: bold;}

.reminder-table-modal button.cancel-cyclic-table:hover {
    background-color: #580000;}
.reminder-table-modal #close-reminders-bottom, {
    padding-left: 3rem;
    background-color: #2563EB; color: white;
    padding: 0.75rem 3rem; border-radius: 0.5rem;
    font-size: 1.25rem; font-weight: bold;
    border: 2px solid #1E3A8A; cursor: pointer;
    transition: background-color 0.2s ease;
    display: inline-flex; align-items: center;}

.reminder-table-modal #close-reminders-bottom:hover, {
    background-color: #1D4ED8;}
.choice-modal .personalization-options {
    display: flex; flex-direction: column; gap: 1rem;
    align-items: stretch; margin-bottom: 1.5rem;}
.choice-modal .personalization-options button {
    font-weight: bold; width: 100%;  background-color: #D1D5DB;}

.choice-modal button.choice-edit {  background-color: #ffc107; color: #333;}
.input-with-clear-button {
    position: relative; display: flex;  align-items: center;}
.input-with-clear-button input {
    width: 100%; padding-right: 40px !important;}
.clear-input-btn {
    position: absolute; right: 5px; top: 50%;
    transform: translateY(-69%); background: transparent;
    border: none; font-size: 1.8rem; font-weight: bold;
    color: #666; cursor: pointer; padding: 0 5px;
    line-height: 1; display: none;}
.choice-modal button.choice-assign { background-color: #17a2b8; color: white;}
.choice-modal button.choice-help {background-color: #007bff; color: white;}
.choice-modal button.choice-cancel {  background-color: #6c757d; color: white;}
.choice-modal .footer-buttons {
    display: flex; justify-content: center; gap: 1rem; margin-top: 1rem;}
.choice-modal .footer-buttons button {
    flex: 0 1 auto; min-width: 120px; background-color: #D1D5DB;}
.edit-modal h2 {
    font-size: 1.4rem; margin-bottom: 1rem; color: #333;
    font-weight: bold; text-align: center;}
.edit-modal .modal-top-buttons {  margin-bottom: 1.2rem;}
.edit-modal label {
    display: block; margin-bottom: 0.3rem;
    font-weight: 500; color: #444; font-size: 1rem;}
.edit-modal input[type="text"],
.edit-modal input[type="url"] {
    width: 100%; padding: 0.6rem; margin-bottom: 0.8rem;
    border: 1px solid #BDB7AB; border-radius: 0.25rem;
    font-size: 1rem;}
.edit-modal .input-with-button {
    display: flex; align-items: center;
    gap: 0.5rem; margin-bottom: 0.8rem;}

.edit-modal .input-with-button input {  flex-grow: 1; margin-bottom: 0;}
.edit-modal .search-button {
    padding: 0.4rem 0.6rem; font-size: 0.8rem;
    background-color: #668B8B; color: white;
    border: none; border-radius: 0.25rem;
    cursor: pointer; line-height: 1; height: fit-content;}

.edit-modal .search-button:hover { background-color: #5C5C47;}
.edit-modal button {
    padding: 0.7rem 1rem; font-size: 1.3rem;
    border-radius: 0.25rem; cursor: pointer;
    border: none; flex: 1 1 auto; min-width: 90px;
    background-color: #D1D5DB;}

.edit-modal button.save { background-color: #28a745; color: white; }
.edit-modal button.save:hover { background-color: #218838; }
.edit-modal button.cancel { background-color: #6c757d; color: white; }
.edit-modal button.cancel:hover { background-color: #5a6268; }
.edit-modal button.reset { background-color: #ffc107; color: #333; }
.edit-modal button.reset:hover { background-color: #e0a800; }
.edit-modal button.empty { background-color: #fd7e14; color: white; }
.edit-modal button.empty:hover { background-color: #e66b04; }

.editing-active .bookmark-item:hover,
.editing-active .range-toggle:hover,
.editing-active .empty-slot:hover {
    transform: none; outline: 3px solid yellow;
    box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1);
    cursor: crosshair;}

.editing-active .grid-cell.editing-target,
.editing-active .range-toggle.editing-target {
    outline: 3px solid yellow !important; outline-offset: 1px;
    box-shadow: 0 0 8px yellow;}

.editing-active .grid-cell {
    cursor: grab; user-select: none;
    -webkit-user-select: none; -moz-user-select: none;
    -ms-user-select: none;}
.editing-active .grid-cell:active { cursor: grabbing;}
.grid-cell.dragging {
    opacity: 0.4; border: 2px dashed #aaa; cursor: grabbing;
    transform: scale(0.95); z-index: 10;}

.grid-cell.drag-over {
    border: 3px solid #3498db !important;
    background-color: rgba(52, 152, 219, 0.1);
    box-shadow: inset 0 0 10px rgba(52, 152, 219, 0.3);}
.empty-slot.drag-over {
    border: 3px solid #3498db !important;
    background-color: rgba(52, 152, 219, 0.2);}
.empty-slot.dragging {
    opacity: 0.4; border: 2px dashed #aaa !important;
    cursor: grabbing;}
.assignment-active .range-toggle.assigning-selected {
    outline: 4px solid cyan; box-shadow: 0 0 12px cyan;
    transform: scale(1.03);}
.assignment-active .range-toggle:not(.assigning-selected) {
    opacity: 0.7; cursor: pointer;}

.assignment-active .grid-cell.assigned-to-current {
    outline: 3px solid cyan;
    box-shadow: inset 0 0 8px rgba(0, 255, 255, 0.6);
    background-color: hsla(180, 70%, 80%, 0.3);
    opacity: 1;}

.assignment-active .grid-cell:not(.assigned-to-current) {
    opacity: 0.6; outline: 1px dashed #aaa;}
.assignment-active .grid-cell { cursor: pointer;}

body.dark-mode .assignment-active .grid-cell.assigned-to-current {
    box-shadow: inset 0 0 10px rgba(0, 200, 200, 0.7);
    background-color: hsla(180, 60%, 30%, 0.4);}

body.dark-mode .assignment-active .grid-cell:not(.assigned-to-current) {
    opacity: 0.5; outline-color: #555;}
#pin-modal-overlay {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    display: flex; justify-content: center; align-items: flex-start;
    z-index: 9998;}
#pin-modal-content {
    background-color: #DAC8A0; padding: 2rem;
    border-radius: 0.75rem; box-shadow: 0 5px 20px rgba(0,0,0,0.4);
    text-align: center; border: 1px solid #A0522D;
    margin-top: 50px;}
#pin-modal-content h2 {
    font-size: 1.5rem; font-weight: bold;
    color: #333; margin-bottom: 1rem;}
#pin-modal-content .modal-top-buttons { margin-bottom: 1.5rem;}

#pin-modal-content label {
    display: block; font-size: 1.1rem;
    color: #444; margin-bottom: 0.8rem;}
#pin-input {
    width: 150px; padding: 0.8rem; font-size: 1.8rem;
    text-align: center; border: 2px solid #A0522D;
    border-radius: 0.25rem; margin-bottom: 1.5rem;
    letter-spacing: 0.5em; background-color: #f0f0e0;}

#pin-submit-button {
    padding: 0.8rem 2rem; font-size: 1.2rem;
    background-color: #28a745; color: white;
    border: none; border-radius: 0.25rem;
    cursor: pointer; transition: background-color 0.2s;}
#pin-submit-button:hover {  background-color: #218838;}
#pin-error-message {
    color: #dc3545; font-weight: bold; margin-top: 1rem; min-height: 1.2em;}
#config-modal {
    position: fixed; top: 15px; left: 50%;
    transform: translate(-50%, 0); background-color: #ECEFE8;
    padding: 1.5rem; border-radius: .75rem;
    box-shadow: 0 8px 16px rgba(0,0,0,.25); z-index: 5000;
    max-width: 1000px; width: 95%;
    max-height: calc(83vh + 190px); display: flex;
    flex-direction: column;}
#config-modal .modal-top-buttons {
    display: flex; justify-content: space-between;
    align-items: center; margin-bottom: 1rem;}
#config-modal .modal-top-buttons h2 {  margin-bottom: 0;}
.config-tab-content {
    max-height: calc(83vh + 130px - 190px);}

.config-tab-button {
    padding: .7rem 1.2rem; cursor: pointer;
    border: 1px solid #ccc; border-bottom: none;
    background-color: #e0e0d0; margin-right: .3rem;
    border-radius: .5rem .5rem 0 0; font-size: 1rem;
    font-weight: 500; color: #555; outline: none;
    transition: background-color .2s ease,color .2s ease;}
.config-tab-button:hover {  background-color: #d8d8c0;}
.config-tab-button.active {
    background-color: #ECEFE8; border-color: #ccc;
    border-bottom: 1px solid #ECEFE8; font-weight: bold;
    color: #2F4F4F; position: relative; top: 1px;
    z-index: 2;}
.tab-buttons {
    margin-bottom: -1px; flex-shrink: 0;
    border-bottom: 1px solid #ccc; padding-left: 1rem;
    display: flex; overflow-x: auto;}
.tab-contents {
    flex-grow: 1; overflow-y: auto; position: relative;
    z-index: 1; border-top: none; min-height: 200px;}
.config-tab-content { display: none; }

.config-tab-content.active {  display: block; }   
#config-modal h2 {
    font-size: 1.6rem; margin-bottom: 0; color: #2F4F4F;
    text-align: center; flex-shrink: 0;}
#config-modal h3 {
    font-size: 1.3rem; margin-bottom: .8rem; color: #4682B4;}

#config-modal p,
#config-modal label {
    font-size: 1rem; line-height: 1.5; color: #333;}
#config-modal em { font-size: .85rem;}

#config-modal button:not(.config-tab-button) {
    font-size: 1.05rem; padding: .8rem 1.5rem;
    background-color: #D1D5DB;}

#config-modal textarea {
    font-size: .9rem; height: 110px; width: 100%;
    border: 1px solid #ccc; border-radius: .25rem;
    padding: .5rem; resize: vertical;}
#config-modal input[type=text],
#config-modal input[type=number],
#config-modal input[type=password] {
    font-size: 1rem; padding: .6rem; width: 100%;
    border: 1px solid #ccc; border-radius: .25rem;}
#config-modal .status-message {
    font-size: .9rem; min-height: 1.1em;
    font-weight: 500; text-align: center;
    margin-top: .5rem;}
.user-data-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit,minmax(180px,1fr));
    gap: 1.2rem 1.8rem; align-items: start; margin-bottom: 1rem;}

.user-data-grid label {
    margin-bottom: .3rem; display: block; font-weight: 500;}

.user-data-grid .checkbox-container {
    grid-column: 1 / -1; display: flex; align-items: center;
    gap: .5rem; justify-content: center; margin-top: .5rem;}

.user-data-grid .checkbox-container input {
    width: 1.2rem; height: 1.2rem;}

.user-data-grid .checkbox-container label {  margin-bottom: 0;}
.user-buttons-container {
    display: flex; justify-content: space-around;
    gap: 1.5rem; margin-top: 1.5rem; margin-bottom: 1rem;}
.user-buttons-container button {
    border: none; border-radius: .25rem;  cursor: pointer; flex-grow: 1;}
#config-user-status { min-height: 1.2em;}
.backup-restore-container {  display: flex; gap: 2.5rem; flex-wrap: wrap;}
.backup-restore-container > div { flex: 1; min-width: 250px;}
.backup-restore-container p { margin-bottom: 1.2rem;}

.backup-restore-container textarea { margin-bottom: 1rem; background-color: #f9f9f9;}
.backup-restore-container button {
    margin-bottom: 1rem; border: none;
    border-radius: .25rem; cursor: pointer;width: 100%;}
#config-restore-grid-button {
    background-color: #E65100; color: black; margin-top: 10px;}
#config-restore-grid-button:hover {background-color: #D84315;}
.backup-restore-container .status-message {
    margin-top: .6rem;}
.borrar-container h3 {
    margin-bottom: .8rem;}
.borrar-container p {
    margin-top: .6rem;}
.borrar-container button {
    margin-top: 1.5rem; border: none;
    border-radius: .25rem; cursor: pointer; width: 100%;}
.borrar-container button#config-clear-cache {
    background-color: #EF4444; color: white;}
#config-close-modal-container {
    text-align: center; margin-top: 1rem; flex-shrink: 0;}
#config-close-modal {
    font-size: 1.15rem; padding: .8rem 2.5rem;
    background-color: #4A5568; color: white;
    border: 1px solid #2D3748; font-weight: bold;}

#config-close-modal:hover { background-color: #2D3748;}
.pin-config-section {
    border-top: 1px solid #ccc;  margin-top: 2rem; padding-top: 1.5rem;}

.pin-config-layout {
    display: grid;
    grid-template-columns: minmax(200px, 1fr) minmax(200px, 1fr);
    gap: 1rem 1.5rem; align-items: end;}

.pin-config-layout .pin-input-group {
    grid-column: span 1; display: flex;  flex-direction: column;}

.pin-config-layout .pin-input-group label {  margin-bottom: 0.3rem;}

.pin-config-layout .pin-buttons-container {
    grid-column: 1 / 3; grid-row: 2;
    display: flex; justify-content: flex-start;
    gap: 1rem; margin-top: 0.5rem;}

.pin-config-layout .pin-buttons-container button {
    flex-grow: 0; min-width: 120px;max-width: 180px;}

#tab-content-pin .checkbox-container {
    grid-column: 1 / -1; display: flex; align-items: center;
    gap: .5rem; justify-content: flex-start;
    margin-top: 1.5rem; border-top: 1px solid #ccc;
    padding-top: 1rem;}

#tab-content-pin .checkbox-container input { width: 1.2rem; height: 1.2rem;}

#tab-content-pin .checkbox-container label { margin-bottom: 0;}

.toast-notification {
    position: fixed; top: 180px; right: 15px; transform: none;
    padding: 10px 25px; border-radius: 8px; color: white;
    font-size: 0.9rem; font-weight: bold; z-index: 9999;
    opacity: 0; text-align: center;
    transition: opacity 0.4s ease-in-out, top 0.4s ease-in-out;
    box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    min-width: 200px; max-width: 70%;}
.toast-notification.show { opacity: 1;}
.toast-success { background-color: #28a745; }
.toast-error { background-color: #dc3545; }
.toast-warning { background-color: #ffc107; color: #333; }
.toast-info { background-color: #17a2b8; }
.toast-debug {
    background-color: #663399; color: white; font-size: 0.9rem;
    text-align: left; max-width: 90%; white-space: pre-wrap;
    max-height: 80vh; overflow-y: auto; line-height: 1.2;}
.toast-debug button {
    display: block; margin-top: 10px; padding: 5px 10px;
    background-color: rgba(255,255,255,0.2); color: white;
    border: 1px solid white; border-radius: 3px; cursor: pointer;}
.toast-error.not-found {
    background-color: #a02020; border: 2px solid #ffdddd;
    font-size: 1.2rem; box-shadow: 0 8px 16px rgba(0,0,0,0.4);}
#average-speed-display { color: #CBDDB5 !important; }
#max-speed-display { color: #FFA420 !important; }
#compass-rose-icon {
    width: 57px; height: 58px; display: block;
    margin: 0 auto 2px auto;
    transition: transform 0.3s ease-out;}
#orientation-text {
    display: block; font-size: 1.4em; font-weight: bold;
    line-height: 1.2; margin-bottom: 2px;}
#altitude-display {
    display: block; font-size: 1.2em; line-height: 1.1;font-weight: bold;}
#current-speed-display,
#average-speed-display,
#max-speed-display {
    display: block; font-size: 1.2em; font-weight: bold;
    line-height: 1.2; margin-top: 2px;}
#navigation-graph-card.enlarged {
    position: fixed; background-color: rgba(0, 0, 0, 0.85);
    z-index: 2000; border: 1px solid #888;}
#navigation-graph-card.enlarged #navigation-graph-container {
    flex-grow: 1;}
#enlarge-graph-button {
    position: absolute; top: 5px; right: 5px;
    width: 28px; height: 28px; cursor: pointer;
    z-index: 5; opacity: 0.7; transition: opacity 0.2s;}
#enlarge-graph-button:hover {
    opacity: 1;}
#navigation-graph-title {
    font-size: 1.1em; font-weight: bold; padding: 1px 5px;
    color: #cb9a01; flex-shrink: 0;
    display: flex; justify-content: space-between;
    align-items: center; width: 100%;}
#navigation-graph-container {
    width: 100%; flex-grow: 1;
    position: relative; min-height: 0;}
#navigation-chart {
    display: block; width: 100%; height: 100%;}
#location-map-container:not(.expanded) ,
#location-picker-map-container:not(.expanded)  {
    display: none !important;}
.saved-locations-modal .modal-top-buttons {
    margin-bottom: 1rem;}
.saved-locations-modal .location-slot button.map-button:hover {
    background-color: #5C5C47;}
.saved-locations-modal #close-saved-locations-modal {
    background-color: #D1D5DB; color: #111827;}
#location-picker-map-container {
    height: 300px; border: 1px solid #ccc;
    position: relative; margin-top: 1rem;
    border-radius: 0.25rem; background-color: #eee;
    display: none;}
#location-picker-map-container.expanded {  display: block !important;}
#picker-ok-map-button { top: 5px; right: 5px;}
#location-picker-map-container button {
    padding: 0.5rem 0.8rem; font-size: 0.9rem; font-weight: bold;
    background-color: #007bff; /* CAMBIO: Fondo azul */
    color: white; /* CAMBIO: Letra blanca */
    border: 1px solid #0056b3; /* CAMBIO: Borde azul oscuro */
    border-radius: 4px;
    cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.25);
    position: absolute; z-index: 1001;
    transition: background-color 0.2s ease; /* AÑADIDO: Transición suave */}
#location-picker-map-container button:hover {  background-color: #0056b3;}   
#picker-locate-me-button {  top: 5px; right: calc(5px + 90px + 10px);}
#search-row-map-header .reminders-map-button-action { height: 57px;}
#search-row-map-header > #reorder-route-stages-button,
#search-row-map-header > #map-location-search-button,
#search-row-map-header > #clear-map-search-input-button,
#search-row-map-header > #map-location-search-input,
#search-row-map-header > #filter-input,
#search-row-map-header > #navigation-map-help-button {
    height: 57px !important;}
#reminders-location-map-header .button-row.hidden-map-header {
    opacity: 0; visibility: hidden; max-height: 0 !important;
    min-height: 0 !important; overflow: hidden !important;
    padding-top: 0 !important; padding-bottom: 0 !important;
    margin-bottom: 0 !important; border-bottom: none !important;}
#reminders-location-map-header .button-row:first-child {
    margin-bottom: 10px;}
#reminders-location-map-header h2 { display: none;}
#reminders-location-map-header .reminders-map-button-action img,
#reminders-location-map-header .reminders-map-button-action svg {
    width: 100%; height: 100%; object-fit: contain;}
#reminders-location-map-header .reminders-map-button-action:hover {
    opacity: 0.88;}
#toggle-map-header-buttons-panel {
    position: fixed; left: 15px; top: 50%;
    transform: translateY(-50%); width: calc(120px);
    height: calc(120px);
    background-color: rgba(100, 100, 100, 0.45);
    border-radius: 50%; display: flex;
    align-items: center; justify-content: center;
    cursor: pointer; z-index: 1010;
    box-shadow: 1px 1px 3px rgba(0,0,0,0.45);
    touch-action: none;}
#toggle-map-header-buttons-panel img {
    width: 60%; height: 60%; object-fit: contain;}
#load-route-button,
#save-route-button {   background-color: #0000CD !important;}

#navigation-map-help-button {
    margin-right: 10px; margin-left: 10px;
    background-color: #4A5568 !important;
    box-shadow: 2px 2px 5px rgba(0,0,0,0.50);}
#add-reminder-at-location-button {
    background-color: #FFA500 !important; width: 60px;
    height: 60px; padding: 5px; gap: 0;}
#add-reminder-at-location-button.active-reminder-mode {
    background-color: #EF4444 !important;}
#add-reminder-at-location-button svg {
    width: 100%; height: 100%; object-fit: contain;}
.radares-ruta-control {
    display: flex; align-items: center; justify-content: center;
    padding: 0.3rem 0.6rem; background-color: rgba(200,200,180,0.7);
    border-radius: 5px; height: 60px; min-width: 70px;
    box-sizing: border-box; gap: 3px;}
#radares-ruta-checkbox {
    margin-right: 0px; margin-bottom: 0px; transform: scale(1.1);}
.radares-ruta-label-container {
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;}
#radares-ruta-checkbox + .radares-ruta-label-container > label {
    font-weight: bold; font-size: 0.70rem; color: #333;
    cursor: pointer; text-align: center;
    line-height: 1.1; margin-bottom: 1px;}
#radares-ruta-count {
    display: flex; align-items: center; justify-content: center;
    width: 25px; height: 20px; background-color: #6600a1;
    color: white; border-radius: 50%;
    font-size: 0.75rem; font-weight: bold;
    line-height: 1; margin-top: 2px;}
.tareas-ruta-control {
    display: flex; align-items: center; justify-content: center;
    padding: 0.3rem 0.6rem; background-color: rgba(200,200,180,0.7);
    border-radius: 5px; height: 60px; min-width: 70px;
    box-sizing: border-box; gap: 3px;}
#tareas-ruta-checkbox {
    margin-right: 0px; margin-bottom: 0px;
    transform: scale(1.1);}
.tareas-ruta-label-container {
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;}
#tareas-ruta-checkbox + .tareas-ruta-label-container > label {
    font-weight: bold; font-size: 0.70rem; color: #333;
    cursor: pointer; text-align: center;
    line-height: 1.1; margin-bottom: 1px;}
#tareas-ruta-count {
    display: flex; align-items: center; justify-content: center;
    width: 25px; height: 20px; background-color: #008f39;
    color: white; border-radius: 50%;
    font-size: 0.75rem; font-weight: bold;
    line-height: 1; margin-top: 2px;}
#reorder-route-stages-button {
    height: 60px; width: 60px; border: 1px solid #777;
    box-shadow: 2px 3px 5px rgba(0,0,0,0.70);
    padding: 2px; display: inline-flex;
    align-items: center; justify-content: center;
    font-size: 0.9rem; font-weight: bold; color: white;
    border-radius: 4px; cursor: pointer; flex-shrink: 0;
    white-space: nowrap; background-color: white !important;
    margin-right: 4px;}
#reorder-route-stages-button img {
    max-height: 90%; max-width: 90%; object-fit: contain;}
#map-location-search-button {
    height: 60px; width: 60px; border: 1px solid #777;
    box-shadow: 2px 3px 5px rgba(0,0,0,0.70);
    padding: 3px; display: inline-flex;
    align-items: center; justify-content: center;
    font-size: 0.9rem; font-weight: bold; color: white;
    border-radius: 4px; cursor: pointer; flex-shrink: 0;
    white-space: nowrap; background-color: white !important;
    margin-left: 2px;}
#map-location-search-button img {
    max-height: 80%; max-width: 90%; object-fit: contain;}
#map-location-search-input::placeholder,
#::placeholder {    color: #CDCDCD; opacity: 1;}
#map-location-search-input::-webkit-input-placeholder { color: #CDCDCD; }
#map-location-search-input::-moz-placeholder { color: #CDCDCD; opacity: 1; }
#map-location-search-input:-ms-input-placeholder { color: #CDCDCD; }
#map-location-search-input::-ms-input-placeholder { color: #CDCDCD; }
body.dark-mode #map-location-search-input {
    background-color: #a0a090; color: #e0e0e0; border-color: #666;}
body.dark-mode #map-location-search-input::placeholder { color: #A0A0A0;}
#clear-map-search-input-button {
    height: 60px !important; width: 50px !important;
    background-color: #e0e0e0; border: 1px solid #ccc;
    box-shadow: 2px 3px 5px rgba(0,0,0,0.70);
    border-radius: 4px; cursor: pointer; flex-shrink: 0;
    padding: 0; z-index: 1; display: flex;
    align-items: center; justify-content: center;
    margin-left: 2px;}
#clear-map-search-input-button svg {
    width: 60%; height: 60%; stroke: red; stroke-width: 3;}
body.dark-mode #clear-map-search-input-button {
    background-color: #555; border-color: #444;}
body.dark-mode #clear-map-search-input-button svg {  stroke: #ff6666;}
#toggle-simulate-gps-button {
    background-color: #DAA520 !important; width: 60px;
    height: 60px; padding: 5px !important;}
#toggle-simulate-gps-button.active-simulate-gps-mode {
    background-color: #B22222 !important; box-shadow: 0 0 8px #FF4500;}
#toggle-simulate-gps-button img {
    width: 100%; height: 100%; object-fit: contain;}
#simulate-route-button { padding: 5px;}

#simulate-route-button img {
    width: 100%; height: 100%;   object-fit: contain;}
#view-all-locations-map {
    padding: 0.75rem 1.2rem; font-size: 1.1rem;
    font-weight: bold; border-radius: 0.5rem;
    cursor: pointer; border: 2px solid #506C6C;
    color: white; background-color: #668B8B;
    margin-left: 10px; transition: background-color 0.2s ease;
    display: inline-flex; align-items: center;
    justify-content: center; height: auto;
    min-height: 46px; white-space: nowrap;}
#view-all-locations-map:hover {   background-color: #5C7A7A;}
#tab-content-radares .radar-filter-group {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem; margin-bottom: 1rem; align-items: end;}
#tab-content-radares .radar-filter-group label {
    margin-bottom: 0.25rem; font-weight: 500;
    font-size: 0.9rem;}
#tab-content-radares .radar-filter-group input {
    padding: 0.5rem; font-size: 1rem;
    border: 1px solid #ccc; border-radius: 0.25rem;
}
#tab-content-radares .radar-import-options {
    margin-bottom: 1rem; display: flex;
    align-items: center; gap: 0.5rem;}
#tab-content-radares .radar-import-options input[type=checkbox] {
    width: 1.1rem; height: 1.1rem;}
#tab-content-radares .radar-import-options label {
    margin-bottom: 0; font-size: 0.9rem;}
#tab-content-radares .radar-action-buttons {
    display: flex; justify-content: space-around;
    gap: 1rem; margin-top: 1rem; margin-bottom: 1.5rem;}
#tab-content-radares .radar-action-buttons button {
    flex: 1; padding: 0.8rem 1rem; font-size: 1.1rem;
    border-radius: 0.3rem; background-color: #D1D5DB;}
#import-radars-button,
#delete-filtered-radars-button {
    background-color: #F59E0B !important; color: white !important;
    border: 1px solid #D97706 !important;}
#import-radars-button:hover,
#delete-filtered-radars-button:hover { background-color: #D97706 !important;}
#radar-import-progress-container {
    margin-top: 1rem; padding: 0.8rem;
    border: 1px solid #ccc; border-radius: 0.25rem;  background-color: #f9f9f9;}
#radar-import-progress-bar {
    width: 100%; height: 20px; margin-bottom: 0.5rem;}
#radar-import-status {
    font-size: 0.9rem; color: #333;
    min-height: 1.2em; text-align: center;
}
.navigation-waypoint-marker {
    display: flex; align-items: center; justify-content: center;
    border-radius: 50%; color: white; font-weight: bold;
    text-align: center; box-shadow: 0 0 3px rgba(0,0,0,0.5);
    opacity: 0.85;    }
.navigation-waypoint-marker.start-point { background-color: rgba(0, 128, 0, 0.80); }
.navigation-waypoint-marker.finish-point { background-color: rgba(0, 0, 255, 0.80); }
.navigation-waypoint-marker.intermediate-point { background-color: rgba(230, 140, 0, 0.80); }
.waypoint-delete-button {
    position: absolute; background-color: rgba(255, 0, 0, 0.85);
    color: white; border-radius: 50%; text-align: center;
    cursor: pointer; border: 1px solid white; z-index: 10;}
#turn-icon-container-styled {
    position: relative; background-color: white;
    padding: 2px; border-radius: 6px;
    display: flex; align-items: center; justify-content: center;
    width: 60px; height: 60px; box-sizing: border-box;
    z-index: 1; flex-shrink: 0; margin-right: 8px;
    overflow: hidden;}
#simulation-modal .turn-icon-sim .leaflet-routing-icon {
    width: 24px !important; height: 24px !important;
    transform: none !important; display: block; object-fit: contain;
    background-image: url('https://cdnjs.cloudflare.com/ajax/libs/leaflet-routing-machine/3.2.12/leaflet.routing.icons.png');
    background-repeat: no-repeat;}
#navigation-top-info-bar .maneuver-text-container {
    flex-grow: 1; text-align: center;max-width: calc(100% - 60px);}
#navigation-top-info-bar .maneuver-text,
#navigation-top-info-bar .street-name {
    font-weight: bold; font-size: 1.33em; color: white;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    white-space: normal; word-wrap: break-word;
    overflow-wrap: break-word; line-height: 1.2;}
#navigation-top-info-bar .maneuver-text {
    font-size: 1.2em; margin-right: 8px; display: inline;}
#navigation-top-info-bar .street-name { font-size: 0.8em; display: inline;}
#distance-to-turn-formatted {
    text-align: center; font-weight: bold;
    font-size: 1.5em; margin-top: 4px;}
#distance-progress-bar-to-turn-container {
    width: 100%; height: 7px; background-color: #e0e0e0;
    border-radius: 4px; margin-top: 5px; overflow: hidden;}
#distance-progress-bar-to-turn {
    width: 100%; height: 100%;
    background: linear-gradient(to right, #680000 0%, #FF0000 50%, #FA8072 97%);
    border-radius: 4px; transition: width 0.3s linear;}
#route-overall-progress-container {
    width: 100%; height: 18px; background-color: #e0e0e0;
    border-radius: 9px; margin-bottom: 9px;
    position: relative; overflow: visible;}
#route-overall-progress {
    width: 0%; height: 100%; z-index: 3;
    background-color: #4CAF50;
    background: linear-gradient(to right, #006600 30%, #258D19 92%, #b4ff9a 99%);
    border-radius: 9px; transition: width 0.5s linear;
    position: relative;}
.radar-marker-on-progress-bar {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%); width: 0; height: 0;
    z-index: 1; border-left: 7px solid transparent;
    border-right: 7px solid transparent; border-bottom: 10px solid white;}
.radar-marker-on-progress-bar::after {
    content: ''; position: absolute; width: 0; height: 0;
    z-index: 2; border-left: 5px solid transparent;
    border-right: 5px solid transparent; border-bottom: 8px solid #8A36D2;
    top: 1px; left: -5px;}
.task-marker-on-progress-bar {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%); width: 0; height: 0;
    z-index: 1; border-left: 7px solid transparent;
    border-right: 7px solid transparent; border-bottom: 10px solid white;}
.task-marker-on-progress-bar::after {
    content: ''; position: absolute; width: 0; height: 0;
    z-index: 2; border-left: 5px solid transparent;
    border-right: 5px solid transparent; border-bottom: 8px solid #608414;
    top: 1px; left: -5px;}
#route-progress-icon {
    position: absolute; height: 100%; width: auto;
    max-height: 18px; left: 100%; top: 50%;
    transform: translate(-50%, -50%); z-index: 4; display: none;}
#route-progress-text {
    position: absolute; text-align: left; top: 50%; left: 10px;
    transform: translateY(-50%);
    font-family: 'Arial', 'Helvetica Neue', Helvetica, sans-serif;
    font-weight: bold; color: yellow;
    -webkit-text-stroke-width: 2px;
    -webkit-text-stroke-color: #006400;
    paint-order: stroke fill;
    font-size: clamp(0.85em, 3vw, 0.95em);
    line-height: 1; pointer-events: none; z-index: 3;
    background-color: transparent; padding: 2px;
    white-space: nowrap;}
.waypoint-dot-on-progress-bar {
    position: absolute; top: 50%; transform: translateY(-50%);
    width: 13px; height: 13px; background-color: #3498db;
    border-radius: 50%; border: 1px solid white; z-index: 2;}
#navigation-eta-info {
    display: flex; justify-content: space-between;
    margin-top: 6px; font-size: 1em;}
#navigation-eta-info.single-destination {  justify-content: center;}
#navigation-eta-info > div { flex-basis: 48%; text-align: center;}
#final-destination-info.single-destination-layout {
    text-align: center; flex-basis: auto !important;}
#final-destination-info.single-destination-layout strong {
    font-size: 0.7em !important;}
#final-destination-info.single-destination-layout span {
    font-size: 1.1em !important;}
#navigation-eta-info strong {
    display: block; font-size: 0.7em; margin-bottom: 2px;}
#navigation-eta-info span { font-size: 1.1em; font-weight: bold;}
#next-stage-info { display: block;}
#navigation-eta-info #next-stage-distance,
#navigation-eta-info #final-destination-distance { margin-right: 3px;}
#navigation-eta-info #next-stage-time,
#navigation-eta-info #final-destination-time {
    margin-left: 3px; margin-right: 3px;}
#navigation-eta-info #next-stage-eta,
#navigation-eta-info #final-destination-eta {   margin-left: 3px;}
.eta-deviation {
    font-size: 0.9em !important; font-weight: bold;
    margin-left: 6px !important;}
.eta-deviation.positive { color: #FF7C39; }
.eta-deviation.negative { color: #10B981; }
#next-stage-info .eta-deviation {
    font-size: 0.9em !important; font-weight: bold; margin-left: 6px;}
#final-destination-info .eta-deviation {
    font-size: 0.9em !important; font-weight: bold; margin-left: 6px;}
#simulation-modal .modal-top-buttons {  margin-bottom: 1rem;}
#simulation-content-area {
    overflow-y: auto; margin-bottom: 1rem; padding: 0.5rem;
    background-color: #fff; border: 1px solid #ccc;
    border-radius: 0.5rem; min-height: 150px;
    font-size: 0.9rem; line-height: 1.4; flex-grow: 1;}
#simulation-content-area ul { list-style-type: none; padding-left: 0;}
#simulation-content-area li {
    padding: 0.3rem 0; border-bottom: 1px solid #eee;
    display: flex; align-items: center;}
#simulation-content-area li:last-child {  border-bottom: none;}
#simulation-modal .turn-icon-sim {
    margin-right: 8px; display: inline-flex;
    align-items: center; justify-content: center;
    width: 24px; height: 24px;
    flex-shrink: 0; vertical-align: middle;}
#simulation-modal .turn-icon-sim img {
    width: 24px !important; height: 24px !important;
    object-fit: contain;}
.favicon-red {
    filter: hue-rotate(0deg) saturate(200%) brightness(80%);}
.favicon-blue {
    filter: hue-rotate(200deg) saturate(150%) brightness(90%);}
.button-countdown-timer {
    margin-left: 5px; font-weight: normal;font-size: 1em; opacity: 0.9;}
#sortable-stages-list {
    max-height: calc(100% - 130px); overflow-y: auto;
    -webkit-overflow-scrolling: touch; touch-action: pan-y;
    padding: 0; margin: 0; list-style-type: none;
    background-color: #C8BBA0;}
#sortable-stages-list li {
    padding: 15px; min-height: 60px;
    border-bottom: 1px solid #ddd;
    transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    cursor: grab; user-select: none;
    display: flex; align-items: center; gap: 12px;
    border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    margin-bottom: 10px; color: #333;}
#sortable-stages-list li:hover:not(.dragging) {
    background-color: #f0e6c8; color: #FFFF00;
    box-shadow: 0 3px 7px rgba(0,0,0,0.15);}
.drag-handle {
    cursor: grab; padding: 0 10px; align-self: stretch;
    display: flex; align-items: center; justify-content: center;
    margin-right: 8px; touch-action: none;}
.drag-handle img { width: 24px; height: 24px; object-fit: contain;}

#sortable-stages-list li.dragging .drag-handle,
.drag-handle:active {cursor: grabbing;}
#sortable-stages-list li:hover:not(.dragging) {
    background-color: #E0D8C8; color: #FFFF00;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);}
#sortable-stages-list li:hover:not(.dragging) .stage-label-badge { color: white; }
#sortable-stages-list li:hover:not(.dragging) .delete-stage-button { color: #EF4444; }
#sortable-stages-list li:hover:not(.dragging) .delete-stage-button:hover { color: #B91C1C; }
#sortable-stages-list li:hover:not(.dragging) .stage-name-text { color: #FFFF00; }
#sortable-stages-list li:last-child {
    border-bottom: none; margin-bottom: 0;}

#sortable-stages-list li.dragging {
    opacity: 0.7; background-color: #4a4a3b;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}
.stage-label-badge {
    background-color: #555; color: white;
    padding: 4px 8px; border-radius: 4px;
    font-size: 0.85rem; min-width: 25px;
    text-align: center; flex-shrink: 0;
    font-weight: bold;}
.stage-name-text {
    flex-grow: 1; overflow: hidden; text-overflow: ellipsis;
    white-space: nowrap; font-size: 1rem; color: #333;}
.delete-stage-button {
    cursor: pointer; margin-left: auto; padding: 0 10px;
    font-size: 1.8rem; color: #EF4444; font-weight: bold;
    line-height: 1; flex-shrink: 0;}
.delete-stage-button:hover {  color: #B91C1C;}    
#search-row-map-header {
    height: 70px; min-height: 70px; max-height: 70px; margin-bottom: 2px;}   
/* === REGLA FINAL Y DEFINITIVA: OCULTA TODOS LOS CONTROLES SIN EXCEPCIÓN (CORREGIDA) === */
#reminders-location-map-modal.immersive-mode-active #reminders-location-map-header,
#reminders-location-map-modal.immersive-mode-active #navigation-bottom-progress-bar,
#reminders-location-map-modal.immersive-mode-active #map-info-overlay,
#reminders-location-map-modal.immersive-mode-active .map-control-custom-map-controls, /* Esto oculta el control de Brújula/Gráfica */
#reminders-location-map-modal.immersive-mode-active .map-controls-bottom-right { /* Esto oculta el nuevo grupo de /Ajustes */
    display: none !important; opacity: 0;
    visibility: hidden; pointer-events: none;}  
#reminders-location-map-header .reminders-map-button-action {
    padding: 5px; font-size: 0.9rem;
    height: 60px; min-height: 60px; font-weight: bold;
    border-radius: 0.375rem; cursor: pointer;
    border: 1px solid #777; color: white;
    transition: background-color 0.2s ease, opacity 0.2s ease;
    box-shadow: 2px 5px 4px rgba(0,0,0,0.65);
    display: inline-flex; align-items: center;
    justify-content: center; text-align: center;
    flex-shrink: 0; white-space: nowrap;
    background-color: white !important;
    min-width: 60px; width: 60px; margin-bottom: 5px;}
.map-control-custom-map-controls {
    display: flex; flex-direction: row; flex-wrap: nowrap !important;
    align-items: flex-end; gap: 7px; z-index: 1001; min-width: 0;}
#navigation-graph-card {
    width: 395px; height: 160px;
    background-color: rgba(0, 0, 0, 0.60); color: white;
    border-radius: 5px; box-shadow: 0 1px 5px rgba(0,0,0,0.45);
    z-index: auto; box-sizing: border-box;
    display: flex; flex-direction: column; padding: 5px;
    position: relative; transition: all 0.4s ease-in-out;}
#reminders-location-map-header .button-row::-webkit-scrollbar {
    display: none;}
#reminders-location-map-header .button-row > *:not(:last-child) {
    margin-right: 10px;}
@media (min-width: 768px) {
    #intersection-preview-map-window {
        height: 480px;   }}

body.mobile-view #intersection-preview-map-window {
    width: 90vw; height: 50vh; max-width: 500px;
    top: 50%; left: 50%; transform: translate(-50%, -50%);}

body.mobile-view #reminders-location-map-modal {
    display: flex; flex-direction: column; position: fixed;
    top: 0; left: 0; width: 100vw; height: 100dvh;
    padding: 0; border: none; border-radius: 0;
    box-sizing: border-box; z-index: 10000;}

body.mobile-view #reminders-location-map-content-wrapper {
    display: flex; flex-direction: column;
    width: 100%; height: 100%; border-radius: 0;
    overflow: hidden;}

body.mobile-view #reminders-location-map-header {
    flex-shrink: 0; padding: 5px; background-color: #C8C8C0;}
body.mobile-view #reminders-location-map-header .button-row {
    height: auto; min-height: 0; flex-wrap: wrap;
    justify-content: center; gap: 5px; padding: 5px 0;}

body.mobile-view #reminders-location-map-header .reminders-map-button-action,
body.mobile-view #reminders-location-map-header #reorder-route-stages-button {
    height: 48px; min-height: 48px; width: 48px; min-width: 48px;
    max-width: 60px; padding: 2px; font-size: 0.7rem;}
body.mobile-view #reminders-location-map-header #map-location-search-input {
    font-size: 1.1rem; height: 48px;
    flex-grow: 1; min-width: 150px;}
body.mobile-view #reminders-location-map-header #filter-input {
    height: 48px; width: 100px; font-size: 0.9rem;}
body.mobile-view #reminders-location-map-div {
    flex-grow: 1; position: relative;}
body.mobile-view #mapbox-map-actual-container {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;}

body.mobile-view #toggle-map-header-buttons-panel {
    width: 60px; height: 60px; left: 10px;}

body.mobile-view #map-info-overlay {
    max-width: 80%; top: 10px; right: 10px;
    font-size: 0.9em;}
body.mobile-view  {
    flex-direction: column; align-items: flex-start; gap: 5px;}
body.mobile-view .reminder-modal, body.mobile-view .help-modal,
body.mobile-view .edit-info-modal, body.mobile-view .choice-modal,
body.mobile-view .edit-modal, body.mobile-view .reminder-table-modal,
body.mobile-view .postpone-options, body.mobile-view .saved-locations-modal,
body.mobile-view #reorder-stages-modal, body.mobile-view #simulation-modal,
body.mobile-view #locations-preview-modal, body.mobile-view #deviation-modal,
body.mobile-view #arrival-stats-modal, body.mobile-view #simulation-speed-modal,
body.mobile-view #saved-routes-modalsave-route-prompt-modal #cancel-save-route:hover, body.mobile-view #save-route-prompt-modal,
body.mobile-view #pin-modal-overlay,
body.mobile-view #versions-modal-overlay,
body.mobile-view #reminders-map-help-modal-instance,
body.mobile-view #intersection-preview-map-window { z-index: 11000 !important;}

body.mobile-view .route-modal-overlay { z-index: 10001 !important;}
#reminders-map-help-modal-instance { z-index: 10002 !important;}
#map-location-search-input {
    flex-grow: 1; padding: 8px 12px; border: 1px solid #ccc;
    border-radius: 4px; background-color: #fff; min-width: 300px;
    height: 60px; font-weight: bold; text-transform: uppercase;
    font-size: 1rem; box-sizing: border-box;
    margin-right: 0 !important; margin-left: 5px;}
#filter-input {
    max-width: 200px; font-size: 0.9rem; padding: 8px 5px;
    margin-left: 2PX; border: 1px solid #7c7c68;
    border-radius: 4px; font-weight: bold; height: 60px;
    background-color: #f0f0e0; box-sizing: border-box;}
#nav-map-zoomtoggle-button {
    width: 60px; min-width: 60px; height: 60px; padding: 5px;}
#reminders-location-map-header .button-row {
    display: flex; margin-left: 5px; flex-direction: row;
    flex-wrap: nowrap !important; align-items: center;
    width: 100%; height: 70px; min-height: 70px;
    padding-bottom: 5px; box-sizing: content-box;
    overflow-x: auto; overflow-y: hidden;
    -webkit-overflow-scrolling: touch; scrollbar-width: none;
    transition: opacity 0.3s ease, visibility 0.3s ease, max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;}

#alert-modal-overlay {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.75); z-index: 8000;}

#alert-modal-content {
    position: fixed; top: 25px; left: 25px;
    background-color: #E6D6A8; padding: 1rem;
    border-radius: 1rem; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    border: 2px solid #C0B080;}
#alert-columns-container { display: flex; gap: 1rem;}
.alert-column {
    display: flex; flex-direction: column; gap: 0.8rem;}

.alert-option, #alert-cancel-button {
    display: flex; align-items: center; padding: 0.75rem 1.25rem;
    background-color: #F5F5DC; border: 1px solid #A9A18C;
    border-radius: 0.5rem; cursor: pointer;
    transition: background-color 0.2s ease, transform 0.1s ease;
    width: 100%;}
.alert-option:hover {
    background-color: #FFD700; transform: translateY(-2px);}
.alert-option img {
    width: 80px; height: 50px;
    margin-right: 1rem; object-fit: contain;}
.alert-option span {
    font-size: 1.4rem; font-weight: bold; color: #333;}

#alert-cancel-button {
    background-color: #2563EB;
    justify-content: center; margin-top: auto;}

#alert-cancel-button:hover { background-color: #1D4ED8;}
#alert-cancel-button span {
    color: white !important; font-weight: bold !important;}

#accident-alert-button-map {  background-color: white !important;}
#proximity-alert-modal {
    position: fixed; top: 25px; left: 25px;
    background-color: white; border: 2px solid black;
    border-radius: 0.75rem; box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    z-index: 8500; padding: 0.8rem; display: flex;
    align-items: center; gap: 0.8rem; max-width: 450px;}
#proximity-alert-modal img {
    width: 110px; height: 85px; object-fit: contain;}
#proximity-alert-modal .content {
    display: flex; flex-direction: column; gap: 0.5rem;}

#proximity-alert-modal .alert-text {
    font-size: 1.3rem; font-weight: bold; color: #111827;}

#proximity-alert-modal button {
    padding: 0.6rem 1.2rem; font-size: 1rem;
    background-color: #2563EB; color: white;
    font-weight: bold; border: none; border-radius: 0.25rem;
    cursor: pointer; align-self: flex-start; min-width: 120px;}

#flashing-border-overlay {
    position: fixed; top: 0; left: 0;
    width: 100vw; height: 100vh; box-sizing: border-box;
    pointer-events: none; z-index: 8499;
    border: 15px solid transparent;
    animation: flash-yellow-border 1s infinite;}

@keyframes flash-yellow-border {
    0%, 100% { border-color: transparent; }
    50% { border-color: #FFFF00; }}

.traffic-alert-icon-container {
    width: 55px; height: 55px; border-radius: 50%;
    background-color: white; border: 3px solid red;
    box-shadow: 0 2px 5px rgba(0,0,0,0.5); display: flex;
    justify-content: center; align-items: center;
    overflow: hidden;
    transition: width 0.2s ease, height 0.2s ease;}
.traffic-alert-icon-container.small {
    width: 27px; height: 27px; border-width: 2px;}
.traffic-alert-icon-container img {
    width: 85%; height: 85%; object-fit: contain;}
.reminder-slide .radar-icon {
    display: block; margin: 0 auto 0.5rem auto;
    width: 90px; height: 70px; object-fit: contain;}
.filter-modal-overlay {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.7); z-index: 10000;
    display: flex; justify-content: flex-start; align-items: flex-start;
    padding-top: 10px; padding-left: 10px;}

.filter-modal-content {
    background-color: #E6D6A8; padding: 20px;
    border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    width: 90%; max-width: 500px; text-align: center;}
.filter-modal-content h2 {
    font-size: 1.5rem; font-weight: bold;
    color: #333; margin-bottom: 20px;}
.filter-group {  margin-bottom: 25px;}
.filter-group label {
    display: block; font-weight: bold;
    margin-bottom: 15px; font-size: 1.1rem;}

.slider-container {
    position: relative; width: 90%; margin: 0 auto; height: 30px;}
.slider-track,
.slider-range {
    position: absolute; height: 5px;
    border-radius: 3px; top: 12.5px; width: 100%;}

.slider-track {  background-color: #ccc; z-index: 1;}

.slider-range {background-color: #2563EB; z-index: 2;}

.slider-thumb {
    position: absolute; width: 25px; height: 25px;
    background-color: white; border: 2px solid #2563EB;
    border-radius: 50%; top: 2.5px; z-index: 3;
    cursor: pointer; box-shadow: 0 0 5px rgba(0,0,0,0.2);}

.slider-thumb.left { left: 0%; transform: translateX(-50%);}

.slider-thumb.right {  right: 0%; transform: translateX(50%);}

.filter-modal-content button#accept-filters-btn {
    background-color: #2563EB; color: white; font-weight: bold;
    padding: 10px 30px; border-radius: 5px; border: none;
    font-size: 1.1rem; cursor: pointer;
    transition: background-color 0.2s;}

.filter-modal-content button#accept-filters-btn:hover {
    background-color: #1D4ED8;}

.single-slider-container .slider-range {left: 0;}

.single-slider-container .slider-thumb { transform: translateX(-50%);}

.filter-help-text {
    font-size: 0.8rem; color: #555; margin-top: 15px;
    padding-top: 10px; border-top: 1px solid #ccc;
    text-align: left;}

.charging-point-card {
    width: 90px; height: 90px;
    background-color: rgb(30, 144, 255); color: white;
    border: 2px solid white; border-radius: 50%;
    padding: 5px; box-sizing: border-box;
    font-family: sans-serif; text-align: center;
    box-shadow: 0 2px 6px rgba(0,0,0,0.6); cursor: pointer;
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;
    gap: 1px;}

.charging-point-card p,
.charging-point-card span {
    margin: 0; padding: 0; line-height: 1.1;
    white-space: nowrap; overflow: hidden;
    text-overflow: ellipsis;}
.charging-point-card .power,
.charging-point-card .price {
    display: inline-flex; align-items: baseline; gap: 0.2em;}
.charging-point-card .power {
    font-size: 1.1rem; font-weight: bold;
    color: #ffd700; order: 1;}
.charging-point-card .operator {
    font-size: 0.8rem; font-weight: bold; order: 2;
    width: 90%; padding: 0 2px; box-sizing: border-box;}
.charging-point-card .price {
    font-size: 0.9rem; font-weight: bold;
    color: #90ee90; order: 3;}
.charging-point-card .availability {
    font-size: 0.75rem; font-weight: bold;
    color: #e0e0e0; order: 4;}
.charging-point-card .unit-text { font-size: 0.85rem; font-weight: bold;}
.charging-point-icon-simple {
    width: 32px; height: 32px; border-radius: 50%;
    background-color: rgb(30, 144, 255);
    border: 2px solid white; box-shadow: 0 1px 4px rgba(0,0,0,0.5);
    display: flex; align-items: center; justify-content: center;}
.charging-point-icon-simple img {
    width: 75%; height: 75%; object-fit: contain;}
.charging-point-popup .mapboxgl-popup-content-wrapper {
    background-color: #E6D6A8; color: #333;
    border-radius: 8px; border: 1px solid #C0B080;}
.charging-point-popup .mapboxgl-popup-content {
    font-family: sans-serif; font-size: 1rem;
    line-height: 1.4; padding: 10px; width: 300px !important;}
.charging-point-popup h3 {
    font-size: 1.2rem; font-weight: bold;
    margin-bottom: 8px; color: #1E3A8A;}
.charging-point-popup h4 {
    font-size: 1.1rem; font-weight: bold;
    margin-top: 10px; margin-bottom: 5px;
    border-top: 1px solid #ccc; padding-top: 8px;}
.charging-point-popup p {  margin: 4px 0;}
.charging-point-popup .ocm-connection-list {
    list-style: none; padding: 0; margin: 0;}
.charging-point-popup .ocm-connection-list li {
    display: flex; justify-content: space-between; align-items: center;
    padding: 4px 0; border-bottom: 1px solid #D8CEC0;}
.charging-point-popup .ocm-connection-list li:last-child {
    border-bottom: none;}
.charging-point-popup .conn-type {
    font-weight: 500; flex-basis: 45%; white-space: nowrap;
    overflow: hidden; text-overflow: ellipsis;}
.charging-point-popup .conn-power {
    flex-basis: 20%; text-align: center;}
.charging-point-popup .conn-status {
    flex-basis: 35%; text-align: center; color: white;
    padding: 2px 5px; border-radius: 3px;
    font-size: 0.8rem; font-weight: bold;}
.charging-point-popup .popup-buttons {
    display: flex; justify-content: space-around; margin-top: 12px;}
.charging-point-popup button {
    padding: 6px 12px; font-size: 1rem; border: none;
    border-radius: 4px; cursor: pointer; font-weight: bold;}
.charging-point-popup .add-to-route-btn { background-color: #28a745; color: white; }
.charging-point-popup .cancel-btn { background-color: #6c757d; color: white; }
/* === INICIO: ESTILOS PARA EL MODAL DE PDR (OCM) === */
.ocm-modal-overlay {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.60); z-index: 9500;
    display: flex; justify-content: center; align-items: center;
    padding: 15px;}
.ocm-modal-content {
    background-color: #2c2c2e; color: #f0f0f0;
    border-radius: 14px; box-shadow: 0 10px 25px rgba(0,0,0,0.6);
    width: 100%; max-width: 750px; height: 98vh;
    max-height: 850px; display: flex; flex-direction: column;
    overflow: hidden; border: 1px solid #444;}
.ocm-modal-header {
    height: 180px; background-size: cover;
    background-position: center; position: relative;
    display: flex; flex-direction: column;
    justify-content: space-between; padding: 12px;
    color: white; text-shadow: 1px 1px 3px rgba(0,0,0,0.8);}

.ocm-modal-header::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 40%, rgba(0,0,0,0.1) 70%, rgba(0,0,0,0) 100%);}
.ocm-modal-address {
    font-size: 1.25rem; font-weight: bold;
    position: relative; z-index: 1;}

.ocm-modal-operator-wrapper {
    position: relative; z-index: 1; align-self: flex-start;}

.ocm-modal-operator {
    font-size: 1.4rem; font-weight: bold;
    background-color: rgba(0, 0, 0, 0.6);
    padding: 4px 10px; border-radius: 6px;
    display: inline-block; box-shadow: 0 2px 4px rgba(0,0,0,0.4);}

.ocm-modal-tabs {
    display: flex; background-color: #1c1c1e;
    border-bottom: 1px solid #444;}

.ocm-modal-tab {
    flex: 1; padding: 12px; text-align: center;
    font-weight: bold; cursor: pointer;
    border-bottom: 3px solid transparent;
    transition: background-color 0.2s, border-color 0.2s;
    color: #a0a0a0;}
.ocm-modal-tab:hover {   background-color: #3a3a3c;}
.ocm-modal-tab.active {   border-bottom-color: #007aff; color: white;}
.ocm-modal-body {   flex-grow: 1; overflow-y: auto; padding: 15px;}
.ocm-modal-panel { display: none; }
.ocm-modal-panel.active { display: block; }
.ocm-modal-panel h4 {
    font-size: 1.1rem; font-weight: bold; color: #007aff;
    margin-top: 15px; margin-bottom: 8px;
    border-bottom: 1px solid #444; padding-bottom: 5px;}
.ocm-modal-panel h4:first-child {   margin-top: 0;}
.ocm-modal-panel p,
.ocm-modal-panel li {
    font-size: 0.95rem; line-height: 1.5; margin-bottom: 5px;}
.ocm-modal-panel a { color: #0a84ff; text-decoration: none; }
.ocm-modal-panel a:hover { text-decoration: underline; }

.ocm-photo-grid {
    display: grid;  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));  gap: 10px;}

.ocm-photo-grid img {
    width: 100%; height: 120px; object-fit: cover;
    border-radius: 8px; cursor: pointer; transition: transform 0.2s;}
.ocm-photo-grid img:hover {  transform: scale(1.05);}
.ocm-comment-list {   list-style: none; padding: 0;}
.ocm-comment {
    background-color: #3a3a3c; padding: 12px;
    border-radius: 8px; margin-bottom: 10px;}
.ocm-comment-header {
    display: flex; justify-content: space-between;
    font-size: 0.8rem; color: #a0a0a0; margin-bottom: 5px;}
.ocm-comment-header .user {  font-weight: bold;}
.ocm-modal-footer {
    padding: 15px; border-top: 1px solid #444;
    display: flex; gap: 15px;}

.ocm-modal-footer button {
    flex: 1; padding: 12px; font-size: 1.1rem;
    font-weight: bold; border-radius: 8px;
    border: none; cursor: pointer;
    transition: background-color 0.2s, opacity 0.2s;}

#ocm-add-route-btn { background-color: #34c759; color: white; }
#ocm-add-route-btn:hover { background-color: #2fb350; }
#ocm-close-btn { background-color: #5856d6; color: white; }
#ocm-close-btn:hover { background-color: #4f4dbf; }

.ocm-modal-station-name-wrapper {
    align-self: flex-start; width: 100%; text-align: left;}

.ocm-modal-station-name {
    font-size: 1.5rem; font-weight: bold;
    background-color: rgba(0, 0, 0, 0.6); padding: 4px 10px;
    border-radius: 6px; display: inline-block;
    box-shadow: 0 2px 4px rgba(0,0,0,0.4);
    margin-bottom: auto; color: #fdfbd4;}

.ocm-modal-address {
    font-size: 1.1rem; font-weight: bold;
    position: relative; z-index: 1; padding: 5px 5px;
    align-self: flex-start; margin-top: auto;}
.ocm-color-legend-icon {
    width: 24px; height: 24px;
    background-image: url('PNG/pdrs.png');
    background-size: 95%; background-repeat: no-repeat;
    background-position: center; border: 3px solid transparent;
    border-radius: 50%; box-sizing: border-box;
    flex-shrink: 0; box-shadow: 0 0 0 2px white;}

.ocm-color-legend {
    display: flex; justify-content: space-around; align-items: center;
    padding: 10px 0; margin-top: -10px; margin-bottom: 15px;}

.ocm-color-legend-item {
    display: flex; align-items: center; gap: 10px;
    font-size: 0.75rem; color: #333;}

.ocm-modal-info-footer {
    font-size: 0.8rem; color: #555; text-align: left;
    margin-top: 15px; padding-top: 10px;
    border-top: 1px solid #ccc;}

.ocm-modal-info-footer p { margin: 5px 0;}
.ocm-connection-item {
    display: flex; justify-content: space-between; align-items: center;
    padding: 4px 0; border-bottom: 1px solid #3a3a3c;}
.ocm-connection-item:last-child {    border-bottom: none;}
.ocm-connection-type {   flex-basis: 50%; font-weight: 500;}
.ocm-connection-power-status {
    flex-basis: 50%; text-align: right; color: #fdfbd4;  font-weight: bold;}
p.ocm-price-info {
    margin-top: 12px; font-size: 1.1rem;  color: #fdfbd4; text-align: center;}
.ocm-photo-modal-overlay {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.85); z-index: 11000;
    display: flex; justify-content: center; align-items: center;
    padding: 20px;}

.ocm-photo-modal-content {
    position: relative; max-width: 90vw; max-height: 90vh;}

.ocm-photo-modal-content img {
    max-width: 100%; max-height: 100%;
    border-radius: 8px; box-shadow: 0 0 30px rgba(0,0,0,0.5);}

.ocm-photo-modal-close-btn {
    position: absolute; top: -15px; right: -15px;
    width: 35px; height: 35px; background-color: white;
    color: black; border-radius: 50%;
    border: 2px solid #333; font-size: 24px;
    font-weight: bold; line-height: 32px; text-align: center;
    cursor: pointer; box-shadow: 0 4px 8px rgba(0,0,0,0.3);}

.pdr-search-highlight {
    border: 3px solid yellow !important;
    box-shadow: 0 0 10px yellow, 2px 5px 4px rgba(0,0,0,0.65) !important;
    transform: scale(1.05);}
.ocm-external-links-container {
    display: flex; align-items: center; justify-content: space-between;
    margin-top: 15px; padding: 10px;
    background-color: #3a3a3c; border-radius: 8px;}

.ocm-external-links-left-group {   display: flex; align-items: center;}
.ocm-external-links-label {
    font-weight: bold; color: #c7c7cc;
    font-size: 0.9rem; white-space: nowrap;}
.ocm-external-links-note {
    font-size: 0.6rem; color: #8e8e93;
    margin-left: 5rem; white-space: nowrap;}
.ocm-external-links-buttons {  display: flex; gap: 10px;}
.ocm-external-link-btn {
    display: flex; align-items: center; justify-content: center;
    width: 40px; height: 40px; padding: 5px;
    background-color: #f0f0f0; border: none;
    border-radius: 8px; cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;}

.ocm-external-link-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 0 8px rgba(255, 255, 255, 0.7);}

.ocm-external-link-btn img {
    width: 100%; height: 100%; object-fit: contain;}
.btn-modal-cancel {
    background-color: #C0392B; color: white; font-weight: normal;}
#close-saved-routes-modal.btn-modal-action-secondary {
    background-color: #C0392B;}
.btn-modal-action-secondary {
    background-color: red; color: white; font-weight: normal;}
#arrival-stats-modal {
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%); background-color: #2c2c2e;
    color: #f0f0f0; border-radius: 14px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.6);
    width: 99%; max-width: 1050px; max-height: 97vh;
    display: flex; flex-direction: column; overflow: hidden;
    border: 1px solid #444; z-index: 11006;}
.arrival-stats-header {
    height: 150px;
    background-image: url('https://boardinggate.github.io/Tesla/PNG/modal-finish.jpg');
    background-size: cover; background-position: center;
    position: relative; display: flex; flex-direction: column;
    justify-content: space-between; padding: 10px; color: white;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.7); flex-shrink: 0;}
.arrival-stats-header::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.3) 50%, rgba(0,0,0,0) 100%);}
.arrival-stats-header h2 {
    font-size: 1.7rem; font-weight: bold; position: relative;
    z-index: 1; margin: 0; text-shadow: 1px 1px 4px rgba(0,0,0,0.7);}
.arrival-stats-header .destination-name {
    font-size: 1.1rem; font-weight: 500; margin-right: 180px;
    position: relative; z-index: 1; background-color: rgba(0,0,0,0.5);
    padding: 4px 8px; border-radius: 6px; align-self: flex-start;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.6);}
.arrival-stats-body {
    padding: 15px; background-color: #2c2c2e;
    overflow-y: auto; flex-grow: 1;}
.stats-section-header {
    font-size: 1.1rem; font-weight: bold; color: #007aff;
    margin-bottom: 15px; padding-bottom: 8px;
    border-bottom: 1px solid #444;}
.stats-section-header:not(:first-child) {  margin-top: 23px;}
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 13px;}
.stat-card {
    background-color: #3a3a3c; border-radius: 10px;
    padding: 13px; text-align: center;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    gap: 8px; border: 1px solid #4a4a4a;
    min-height: 110px;}
.stat-icon svg {   width: 28px; height: 28px; color: #e0e0e0;}
.stat-label { font-size: 0.9rem; color: #b0b0b0; font-weight: 500;}
.stat-value {
    font-size: 1.5rem; font-weight: bold; color: #f0f0f0;
    line-height: 1.2; text-shadow: 1px 1px 3px rgba(0,0,0,0.5);}
.initial-eta-details {
    grid-column: 1 / -1; background-color: transparent;
    border: 1px dashed #555; padding: 10px;
    font-size: 0.90rem; color: #b0b0b0; text-align: center;
    border-radius: 8px; margin-top: 8px;}
.arrival-stats-footer {
    padding: 8px; border-top: 1px solid #444;
    display: flex; justify-content: center;
    background-color: #1c1c1e; flex-shrink: 0;}
#arrival-stats-modal .eta-deviation.positive { color: #FF6347; }
#arrival-stats-modal .eta-deviation.negative { color: #7CFC00; }
#arrival-stats-modal .stat-value button#show-max-speed-location-button {
    font-size: 0.8rem; padding: 1px 5px; line-height: 1.2;
    height: auto; margin-left: 5px; vertical-align: middle;
    background-color: #D1D5DB; color: blue;
    border: 1px solid #9CA3AF; border-radius: 5px; font-weight: bold;}
.arrival-stats-footer button {
    padding: 12px 10px; font-size: 1.2rem; font-weight: bold;
    border-radius: 8px; border: 1px solid #bbb;
    cursor: pointer; background-color: #FFFFFF;
    color: #1c1c1e; transition: background-color 0.2s;}
.arrival-stats-footer button:hover {
    background-color: #e0e0e0;}
/* === INICIO: CSS PARA EL MODAL DE RECORDATORIOS (DISEÑO MODERNO v5) === */
.reminder-modal {
    background-color: #2c2c2e; color: #f0f0f0;
    border-radius: 14px; box-shadow: 0 10px 25px rgba(0,0,0,0.6);
    border: 1px solid #444; padding: 0;
    display: flex; flex-direction: column; font-size: 1rem;
    position: fixed; top: 1%; left: 50%;
    transform: translate(-50%, 0); max-width: 96%; width: 95%;
    max-height: 95vh; overflow: hidden;}

.reminder-modal-header {
    height: 60px;
    background-image: url('PNG/recordatorios.jpg');
    background-size: cover; background-position: center;
    position: relative; display: flex; align-items: center;
    justify-content: space-between; padding: 0.5rem 1.5rem;
    border-radius: 14px 14px 0 0; flex-shrink: 0;}

.reminder-modal-header::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.3) 50%, rgba(0,0,0,0) 100%);
    border-radius: 14px 14px 0 0;}

.reminder-modal-title {
    font-size: 1.5rem; font-weight: bold; color: white;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8); z-index: 1;}

.reminder-modal .header-options { z-index: 1; }

.reminder-modal .form-label-exclude {
    display: flex; align-items: center; color: #ccc;
    cursor: pointer; font-size: 0.9rem; font-weight: 500;}

.reminder-modal .form-label-exclude input {
    margin-right: 0.5rem; transform: scale(1.1);}

.reminder-modal-body { padding: 0.5rem 1.5rem; flex-grow: 1; overflow-y: auto;}

.reminder-modal-form {  display: flex; flex-direction: column; gap: 0.1rem;}

.reminder-modal .form-section { display: flex; flex-direction: column; gap: 0.3rem;}

.reminder-modal .input-with-buttons {
    display: flex; align-items: stretch; gap: 0.75rem; margin-top: 0.3rem;}

.reminder-modal #reminder-text {
    flex-grow: 1; background-color: #3a3a3c;
    border: 1px solid #555; color: #f0f0f0;
    border-radius: 8px; padding: 0.75rem;
    font-size: 1.1rem; resize: vertical; min-height: 45px;
    text-transform: uppercase;}

.reminder-modal .clear-button {
    width: 45px; height: 45px; background-color: #48484a;
    border: 1px solid #5f5f61; border-radius: 8px;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; flex-shrink: 0;}

.reminder-modal .clear-button svg { width: 22px; height: 22px; stroke: #ff9500;}

.reminder-modal .parse-status {
    font-size: 0.6rem; color: #8e8e93; text-align: right;
    margin-top: -0.2rem; min-height: 1em;}

.reminder-modal .controls-grid {
    display: grid; grid-template-columns: auto auto auto 1fr;
    align-items: end; gap: 15px 30px; margin-top: 4px;}

.reminder-modal .control-item {
    display: flex; flex-direction: column; gap: 0.2rem;}

.reminder-modal .form-label {
    font-size: 0.85rem; color: #a0a0a0; margin-bottom: 0;}

.reminder-modal input[type="text"],
.reminder-modal input[type="number"] {
    background-color: #3a3a3c; border: 1px solid #555;
    color: #f0f0f0; border-radius: 8px; padding: 0.5rem;
    font-size: 1rem; text-align: center; min-width: 80px;}

.days-group-grid-item {
    display: flex; flex-direction: column; gap: 0.2rem; margin-left: 20px;}

.reminder-modal .days-checkbox-container { display: flex; gap: 0.4rem; flex-wrap: nowrap;}

.reminder-modal .days-group-grid-item label {
    display: flex; align-items: center;
    cursor: pointer; user-select: none;}

.reminder-modal .days-group-grid-item input[type="checkbox"] {
    display: none;}
.reminder-modal .days-group-grid-item span {
    padding: 0.35rem 0.8rem; border: 1px solid #555;
    background-color: #3a3a3c; color: white;
    border-radius: 20px; font-size: 0.9rem;}

.reminder-modal .days-group-grid-item input[type="checkbox"]:checked + span {
    background-color: #007aff; border-color: #007aff;
    font-weight: bold;}

.reminder-modal .location-section {
    background-color: rgba(255, 255, 255, 0.05); padding: 0.7rem;
    border-radius: 8px; border: 1px solid #444; margin-top: 20px;}

.reminder-modal .location-header {
    display: flex; justify-content: space-between;
    align-items: center; gap: 1rem;}
.reminder-modal .form-label-location {
    display: flex; align-items: center; font-size: 1rem;
    font-weight: bold; color: #f0f0f0; cursor: pointer;flex-shrink: 0;}
.reminder-modal .form-label-location input[type="checkbox"] {
    width: 1.2rem; height: 1.2rem; margin-right: 0.6rem;}
.reminder-modal .radius-slider-group {
    display: flex; align-items: center; gap: 0.75rem;
    flex-grow: 1;}
.reminder-modal .radius-slider-group .form-label {
    white-space: nowrap; font-size: 0.8rem;}
.reminder-modal .expand-map-button {
    background-color: #007aff; color: white; border: none;
    border-radius: 8px; padding: 0.4rem 0.8rem;
    font-size: 0.9rem; font-weight: bold; display: inline-flex;
    align-items: center; gap: 0.4rem; cursor: pointer;
    flex-shrink: 0;}
.reminder-modal #location-controls-container { margin-top: 0.8rem;}
.reminder-modal .location-map-container {
    height: 65px; border-radius: 8px; background-color: #1c1c1e;
    border: 1px solid #555; position: relative;}
.reminder-modal .location-map-container.expanded { height: 310px;}
.reminder-modal-footer {
    flex-shrink: 0; padding: 0.8rem 1.5rem;
    border-top: 1px solid #444; background-color: #1c1c1e;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(135px, 1fr));
    gap: 0.75rem; border-radius: 0 0 14px 14px;}

.reminder-modal .action-button {
    padding: 0.8rem; font-size: 1rem; font-weight: bold;
    border-radius: 8px; border: none; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    gap: 0.5rem; min-height: 55px;}

.reminder-modal .action-button.primary { background-color: #007aff; color: white; padding: 0.8rem 2.2rem; }
.reminder-modal .action-button.secondary { background-color: #555; color: white; }
.reminder-modal .action-button.danger { background-color: #ff3b30; color: white; }

.reminder-modal #countdown-save {
    font-size: 1rem; font-weight: normal; opacity: 0.8;
    background-color: rgba(255,255,255,0.2);
    padding: 2px 6px; border-radius: 10px; margin-left: 8px;}

.help-modal {
    background-color: #2c2c2e; color: #f0f0f0;
    border-radius: 14px; box-shadow: 0 10px 25px rgba(0,0,0,0.6);
    border: 1px solid #444; padding: 0; height: 80vh;
    display: flex; flex-direction: column;}

.help-modal .reminder-modal-body {    flex-grow: 1; overflow-y: auto;}

.help-modal h2, .help-modal h3 { color: white; }
.help-modal .reminder-modal-body ul { list-style: none; padding-left: 0; }
.help-modal .reminder-modal-body li { padding-left: 1.2rem; position: relative; }

.help-modal .reminder-modal-body li::before {
    content: '•'; color: #007aff; font-weight: bold;
    position: absolute; left: 0; top: 2px;}

.reminder-modal .form-grid,
.reminder-modal .days-group:not(.days-group-grid-item) {  display: none;}
.reminder-modal .full-width { display: contents; }
#arrival-stats-modal .arrival-stats-layout-grid {
    display: grid; grid-template-columns: 2fr 1fr;
    gap: 25px; align-items: start;}
#arrival-stats-modal .main-stats-container,
#arrival-stats-modal .side-stats-container {
    display: flex; flex-direction: column; gap: 20px;}

#arrival-stats-modal .side-stats-container .stats-section-header:not(:first-child) {
    margin-top: 0;}

@media (max-width: 1000px) {
    #arrival-stats-modal .arrival-stats-layout-grid {
        grid-template-columns: 1fr;  }}

.maneuver-highlight, .maneuver-highlight-south {   border-radius: 8px;}

.maneuver-highlight { animation: flash-yellow-halo 1.3s infinite; }
.maneuver-highlight-south { animation: flash-red-halo 1.1s infinite; }

@keyframes flash-yellow-halo {
    0%, 100% { box-shadow: 0 0 0 0 rgba(255, 255, 0, 0); }
    50% { box-shadow: 0 0 21px 9px rgba(255, 255, 0, 1); }}

@keyframes flash-black-halo {
    0%, 100% { box-shadow: 0 0 0 0 rgba(0, 0, 0, 0); }
    50% { box-shadow: 0 0 21px 9px rgba(0, 0, 0, 1); }}

@keyframes flash-red-halo {
    0%, 100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
    50% { box-shadow: 0 0 21px 9px rgba(255, 0, 0, 1); }}
.route-label-marker {
    display: flex; align-items: center; justify-content: center;
    border-radius: 50%; color: white; font-weight: bold;
    font-size: 14px; font-family: Arial, sans-serif;
    text-align: center; box-shadow: 0 0 5px rgba(0,0,0,0.7);
    border: 2px solid white; cursor: pointer;
    transition: transform 0.2s ease; width: 40px; height: 40px;}
.route-label-marker:hover {
    transform: scale(1.1);}
#user-info-header {
    position: absolute !important; top: -30px; left: 1060px;
    transform: translateX(-100%); display: flex;
    align-items: center; gap: 10px; z-index: 800;}

#open-chat-area { cursor: pointer; }
#user-id-display, #user-count-globe, #chat-icon-button {
    position: static; top: auto; right: auto; transform: none;}
#user-id-display {
    font-weight: bold; font-size: 1.1rem; color: #5C5C47;
    padding: 4px 4px; background-color: rgba(171, 171, 153, 0.7);
    border-radius: 1px; white-space: nowrap;
    text-align: right; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4);}

#user-count-globe {
    background-color: #FFA500; color: white;
    border: 2px solid white; border-radius: 50%;
    width: 42px; height: 32px; display: flex;
    align-items: center; justify-content: center;
    font-weight: bold; font-size: 0.9rem; cursor: pointer;
    box-shadow: 1px 1px 3px rgba(0,0,0,0.4);}

#chat-icon-button {
    background-color: #2563EB; color: white;
    border: 2px solid white; border-radius: 50%;
    min-width: 42px; height: 32px; padding: 0 8px;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; box-shadow: 1px 1px 3px rgba(0,0,0,0.4);
    position: relative; font-weight: bold;
    font-size: 0.9rem; line-height: 1;}

/* === INICIO: ESTILOS COMPLETOS PARA EL MODAL DEL CHAT (V5) === */
#chat-modal-overlay {
    position: fixed; inset: 0;
    background-color: rgba(0, 0, 0, 0.85);
    z-index: 9000; display: flex; padding: 0;}
#chat-modal-content {
    background-color: #2c2c2e; color: #f0f0f0;
    border-radius: 0; box-shadow: none; border: none;
    width: 100%; display: flex; flex-direction: row;
    overflow: hidden;}
#chat-messages-container {
    flex-grow: 1; padding: 1rem; overflow-y: auto;
    display: flex; flex-direction: column; gap: 0.75rem;}

#chat-left-column {
    flex-grow: 1; display: flex;
    flex-direction: column; overflow: hidden;}
#chat-right-column {
    flex-shrink: 0; width: 250px;
    background-color: #1c1c1e; border-left: 1px solid #444;
    display: flex; flex-direction: column; overflow: hidden;}

#chat-users-filter-container {
    padding: 0.75rem; background-color: #3a3a3c;
    border-bottom: 1px solid #444; flex-shrink: 0;}

#chat-user-filter-input {
    width: 100%; padding: 0.5rem 0.75rem;
    background-color: #2c2c2e; border: 1px solid #555;
    color: #f0f0f0; border-radius: 6px; font-size: 0.9rem;}

#chat-user-filter-input::placeholder { color: #8e8e93; }
#chat-users-list {
    padding: 0.5rem; overflow-y: auto; flex-grow: 1;}

.chat-user-item {
    padding: 0.5rem; border-bottom: 1px solid #333;
    cursor: pointer; transition: background-color 0.2s}

.chat-user-item:hover { background-color: #3a3a3c; }
.chat-user-name { display: block; font-weight: bold; color: #0a84ff; }
.chat-user-details { display: block; font-size: 0.75rem; color: #a0a0a0; }
.chat-no-users { font-style: italic; color: #8e8e93; text-align: center; margin-top: 1rem; }
#chat-input-area {
    padding: 1rem; border-bottom: 1px solid #444;
    background-color: #1c1c1e; flex-shrink: 0;}

#chat-permission-warning {
    background-color: #b91c1c; color: white;
    padding: 0.5rem; margin-bottom: 0.75rem;
    border-radius: 6px; text-align: center;
    font-size: 0.9rem;}

#chat-message-input {
    width: 100%; background-color: #3a3a3c;
    border: 1px solid #555; color: #f0f0f0;
    border-radius: 8px; padding: 0.75rem; font-size: 1rem;
    resize: none; line-height: 1.4; margin-bottom: 0.75rem;}

#chat-message-input::placeholder { color: #746969; }

#chat-input-footer {
    display: flex; justify-content: space-between; align-items: center;}

#chat-buttons {
    display: flex; gap: 1rem; flex-grow: 1;}

#chat-send-button, #chat-exit-button {
    flex: 1; padding: 0.75rem; font-size: 1.1rem;
    font-weight: bold; border-radius: 8px;
    border: none; cursor: pointer;}

#chat-send-button { background-color: #007aff; color: white; }
#chat-exit-button { background-color: #555; color: white; }
#chat-send-button:disabled { background-color: #444; cursor: not-allowed; }

#chat-char-counter {
    font-size: 0.8rem; color: #8e8e93;
    margin-left: 1rem; flex-shrink: 0;}

.chat-message-bubble {
    max-width: 75%; padding: 0.6rem 0.9rem;
    border-radius: 18px; display: flex; flex-direction: column;}

.chat-message-bubble.sent { align-self: flex-end; border-bottom-right-radius: 4px; }
.chat-message-bubble.received { align-self: flex-start; border-bottom-left-radius: 4px; }
.chat-message-bubble.public-msg { background-color: #2e7d32; }
.chat-message-bubble.private-msg { background-color: #1565c0; }
.chat-message-bubble.private-msg-sent { background-color: #0d47a1; }
.chat-message-bubble.sent.public-msg { background-color: #DF6565 !important; }

.chat-message-sender {
    font-size: 0.9rem; font-weight: bold;
    margin-bottom: 4px; opacity: 0.8;}

.chat-message-content {
    word-wrap: break-word; overflow-wrap: break-word;
    white-space: pre-wrap; line-height: 1.4;}

.chat-message-time {
    font-size: 0.8rem; align-self: flex-end;
    margin-top: 4px; opacity: 0.7; display: flex;
    align-items: center; gap: 8px;}

.chat-system-message {
    text-align: center; font-style: italic;
    color: #8e8e93; padding: 1rem;}

.chat-message-actions {
    display: flex; align-items: center;
    gap: 16px; margin-left: 8px;}

.chat-action-icon {
    width: 30px; height: 30px; cursor: pointer;
    opacity: 0.7; transition: opacity 0.2s;}
.chat-action-icon:hover { opacity: 1; }

/* === INICIO: ESTILOS RESPONSIVE PARA EL CHAT EN MÓVILES === */
@media (max-width: 768px) {
    #chat-left-column { flex-basis: 70%; min-width: 70%; }
    #chat-right-column { flex-basis: 30%; min-width: 100px; }}
.reminder-modal .button-and-status-wrapper {
    display: flex; flex-direction: column;
    align-items: center; gap: 0.2rem; flex-shrink: 0;}
.reminder-modal .speech-status,
.reminder-modal .parse-status {
    font-size: 0.7rem; color: #8e8e93; text-align: center;
    min-height: 1em; width: 100%; margin-top: 0;}
.mapbox-control {
    display: flex; align-items: center; justify-content: center;
    padding: 0.3rem 0.6rem; background-color: rgba(200,200,180,0.7);
    border-radius: 5px; height: 60px; min-width: 70px;
    box-sizing: border-box; gap: 3px;}
#mapbox-primary-checkbox {
    margin-right: 0px; margin-bottom: 0px; transform: scale(1.1);}
.mapbox-label-container {
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;}
#mapbox-primary-checkbox + .mapbox-label-container > label {
    font-weight: bold; font-size: 0.70rem; color: #333;
    cursor: pointer; text-align: center;
    line-height: 1.1; margin-bottom: 1px;}
/* === INICIO: CSS PARA ICONOS CIRCULARES DE RADAR (ESCALABLES) === */
.radar-speed-circle {
    border-radius: 50%; background-color: red;
    border: 3px solid white; box-sizing: border-box;
    display: flex; align-items: center; justify-content: center;
    color: yellow; font-weight: bold;
    font-family: Arial, sans-serif;
    text-shadow: 1px 2px 2px rgba(0,0,0,0.5);
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.7));}

.radar-alert-circle {
    border-radius: 50%; background-color: red;
    border: 3px solid #e905f3; box-sizing: border-box;
    display: flex; align-items: center; justify-content: center;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.7));}

.radar-alert-circle img {
    width: 70%; height: 70%; object-fit: contain;}

/* === INICIO: ESTILOS PARA ENCUESTAS/VOTACIONES EN EL CHAT (V3) === */
.chat-poll-bubble {
    background-color: #3d3a4b; align-self: stretch;
    max-width: 95%; margin: 30px auto;
    border-radius: 12px; border: 1px solid #5a576b;
    position: relative; padding: 0.75rem 1rem 0.5rem 1rem;}

.poll-sender-info {
    display: flex; align-items: baseline; margin-bottom: 0.5rem; gap: 30px;}

.poll-sender-info .chat-message-sender {  color: #f0f0f0; opacity: 1;}

.poll-time { font-size: 0.75rem; color: #a0a0a0; }
.poll-question { font-size: 1.1rem; font-weight: bold; color: #ffd700; margin-bottom: 0.75rem; }
.poll-options-list { list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 0.5rem; }

.poll-option-item {
    display: flex; flex-direction: column; gap: 0.25rem;}

.poll-option-button {
    display: flex; justify-content: space-between; align-items: center;
    padding: 0.5rem 0.75rem; background-color: #4a475a;
    border: 1px solid #6a677a; border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.1s;
    width: 100%;}

.poll-option-button:hover {
    background-color: #5a576a; transform: translateY(-1px);}

.poll-option-button.voted {
    background-color: #007aff; border-color: #0056b3; font-weight: bold;}

.poll-option-text { color: #f0f0f0; flex-grow: 1; text-align: left; }

.poll-vote-count {
    color: #f0f0f0; font-weight: bold;
    background-color: rgba(0,0,0,0.2);
    padding: 2px 8px; border-radius: 10px;
    min-width: 25px; text-align: center;}

.poll-progress-bar {
    width: 100%; height: 6px; background-color: #2c2a3b;
    border-radius: 3px; overflow: hidden;}

.poll-progress-fill {
    height: 100%; background-color: #007aff;
    border-radius: 3px; transition: width 0.3s ease-in-out;}

.poll-voters-container { padding: 4px 8px; margin-top: 2px; }
.poll-voter-list { list-style: none; padding: 0; margin: 0; display: flex; flex-wrap: wrap; gap: 2px 8px; }

.poll-voter-name {
    font-size: 0.7rem; color: #b0b0b0;
    background-color: rgba(0,0,0,0.15);padding: 1px 5px; border-radius: 4px;}

.poll-moderation-icons {
    position: absolute; top: 6px; right: 8px; display: flex; gap: 25px; background-color: transparent;}

.tareas-ruta-control,
.radares-ruta-control,
.mapbox-control {
    margin-right: 5px !important;}
#free-drive-stats-card {
    max-width: 300px;    width: 100%;   margin-left: auto;
    margin-right: auto;   padding: 8px 12px;
    color: white;  text-align: left;
    background-color: transparent;}

#free-drive-stats-card .fd-title {
    font-size: 0.8em; font-weight: bold;
    color: white;  margin: 0;
    padding: 0; line-height: 1.2;
    text-align: center; text-shadow: 1px 1px 3px rgba(0,0,0,0.9);
    margin-bottom: 5px;}

#free-drive-stats-card .fd-subtitle {
    font-size: 0.5em; color: #cccccc;
    margin-bottom: 1px; text-align: center;}

#free-drive-stats-card .fd-stats-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 4px; align-items: center;}

#free-drive-stats-card .fd-label {
    font-size: 0.65em;color: #dddddd;
    font-weight: bold;
    text-align: center;  font-weight: 500; margin-bottom: 0px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); /* <-- LÍNEA AÑADIDA */}    

#free-drive-stats-card .fd-stat-item {
    display: flex; flex-direction: column;
    align-items: center; gap: 0px;}

#free-drive-stats-card .fd-data {
    font-size: 1.1em; font-weight: bold;
    color: #87CEEB;   text-align: center;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.9);}
#location-map-container.expanded .mapboxgl-canvas,
#location-picker-map-container.expanded .mapboxgl-canvas,
#reminders-location-map-div #mapbox-map-actual-container .mapboxgl-canvas {
    cursor: crosshair !important;}
#reminders-location-map-div.simulating-gps-click-mode #mapbox-map-actual-container .mapboxgl-canvas {
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="%23FF0000" stroke="white" stroke-width="1"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>') 14 28, crosshair !important;}
#reminders-location-map-div.navigating #mapbox-map-actual-container .mapboxgl-canvas {
    cursor: default !important;}
#reminders-location-map-div.add-reminder-mode #mapbox-map-actual-container .mapboxgl-canvas {
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="%23008000" stroke="white" stroke-width="1"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle><line x1="12" y1="7" x2="12" y2="13"></line><line x1="9" y1="10" x2="15" y2="10"></line></svg>') 14 28, crosshair !important;}
.mapboxgl-popup {
    max-width: 250px !important;  font-family: sans-serif;font-size: 0.9rem;}
.mapboxgl-popup-content {
    padding: 10px;  z-index: 10001; }
.mapboxgl-popup-close-button {
    font-size: 1.5rem; padding: 0 5px;}
.mapboxgl-marker.dragging {  cursor: grabbing;}

/* === REGLAS NUEVAS Y MODIFICADAS PARA MAPBOX === */
#reminders-location-map-modal {
    position: fixed; top: 0; left: 0;
    width: 100vw; height: 100dvh; /* Usa dvh para compatibilidad móvil */
    background-color: #D8D8D0; z-index: 6500;
    display: flex;
    flex-direction: column;
    padding: 2px; box-sizing: border-box;}

#reminders-location-map-content-wrapper {
    background-color: #F0EFE4; width: 100%;
    border-radius: 0.75rem; box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    display: flex; flex-direction: column;
    flex-grow: 1;
    overflow: hidden;}
#reminders-location-map-header { flex-shrink: 0; }
#reminders-location-map-div { flex-grow: 1;  position: relative; overflow: hidden;}
#mapbox-map-actual-container {  width: 100%;   height: 100%; background-color: #333;}
.mapboxgl-ctrl-top-right .mapboxgl-ctrl {   margin: 10px 10px 0 0;  float: none;}
.mapboxgl-ctrl-bottom-right .mapboxgl-ctrl-attrib,
.mapboxgl-ctrl-logo {   display: none !important;}
.mapboxgl-ctrl-top-left .mapboxgl-ctrl-group {   display: none;}

.map-control-custom-map-controls {
    display: flex;
    flex-direction: row; flex-wrap: nowrap !important;
    align-items: flex-end;
    gap: 7px; z-index: 1001;
    min-width: 0;}
.map-control-custom-map-controls > * {
    flex-shrink: 0 !important;min-width: 0 !important;}

.map-control-orientation-altitude {
    transform: none !important;
    background-color: rgba(0,0,0,0.7);
    color: white;padding: 8px;
    border-radius: 3px; box-shadow: 0 1px 5px rgba(0,0,0,0.40);
    text-align: center;  display: flex; flex-direction: column;
    justify-content: center; box-sizing: border-box;
    cursor: pointer;width: 130px;
    min-width: 130px; flex-shrink: 0; height: 160px; font-weight: bold;}

.vehicle-maneuver-overlay {
    position: absolute;
    top: -25px;    left: 50%;    transform: translateX(-50%);
    width: 40px;   height: 40px;   background-size: contain;
    background-repeat: no-repeat;    background-position: center;
    display: none;}
/* === INICIO: CSS PARA ICONO DE VEHÍCULO EN MINIMAPA (LEAFLET) === */
.vehicle-icon-minimap {
    width: 48px;    height: 48px;    position: relative;}
.vehicle-icon-minimap img {
    width: 100%;   height: 100%;    object-fit: contain;}
.vehicle-maneuver-overlay-minimap {
    position: absolute;  top: -20px;   left: 50%;
    transform: translateX(-50%); width: 32px;    height: 32px;
    background-size: contain;
    background-repeat: no-repeat; background-position: center;
    display: none;}   
.vehicle-icon-minimap-leaflet-container {   position: relative !important;}
.mapboxgl-canary { background-color: transparent !important;}
.map-combined-control-container .map-layer-selector,
.map-combined-control-container .map-view-selector {
    display: flex;   flex-direction: column; gap: 4px;}
.map-combined-control-container .map-view-selector {
    border-top: 1px solid rgba(255,255,255,0.2);
    margin-top: 6px;    padding-top: 6px;}

.map-combined-control-container {
    background: rgba(44, 44, 46, 0.35);
    color: white;
    padding: 8px 10px;    border-radius: 6px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.2);}   
.map-combined-control-container label {
    display: flex;    align-items: center;      cursor: pointer;
    font-weight: bold;   font-size: 0.9rem;
    white-space: nowrap;
    transition: background-color 0.2s;   border-radius: 4px;
    padding: 8px 8px;     }
    
.map-combined-control-container label:hover {
    background-color: rgba(255,255,255,0.15);}
.map-combined-control-container input[type="radio"] {
    margin-right: 8px;
    vertical-align: middle;    appearance: none;
    -webkit-appearance: none;
    background-color: #333;   border: 1px solid #888;
    width: 16px;   height: 16px;
    border-radius: 50%;   position: relative;
    cursor: pointer;}
.map-combined-control-container input[type="radio"]:checked {
    background-color: #2a82e0; border-color: #fff;}
.map-combined-control-container input[type="radio"]:checked::after {
    content: '';
    display: block;    width: 8px;    height: 8px;    border-radius: 50%;
    background: white;    position: absolute;
    top: 50%;    left: 50%;
    transform: translate(-50%, -50%);}

/* === INICIO: CSS PARA MINIMAPA DE INTERSECCIÓN (LEAFLET) === */
#intersection-preview-map-window {
    position: absolute; background-color: rgba(0, 0, 0, 0.75);
    border-radius: 7px; z-index: 7000;
    box-shadow: 0 6px 12px rgba(0,0,0,0.5); overflow: hidden;
    animation: flash-black-halo 1.3s infinite;}
#intersection-rotator {
    width: 100%;     height: 100%; transition: transform 0.3s ease-out;}
#intersection-preview-map-container {
    width: 100%;    height: 100%; filter: contrast(110%) brightness(120%) saturate(125%);}     
/* === INICIO: CSS PARA MODALES DE ACCIÓN DEL MAPA === */
.map-item-modal-overlay {
    position: fixed;    top: 0;    left: 0;
    width: 100%;    height: 100%;
    background-color: rgba(0, 0, 0, 0.4);z-index: 10002;
    display: flex;  justify-content: center;
    align-items: center;}
.map-item-modal-content {
    background-color: #E6D6A8;
    color: #333;   border-radius: 10px;  border: 1px solid #C0B080;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);padding: 15px;
    width: 90%;    max-width: 350px; font-family: sans-serif;}
.map-item-modal-content h3 {
    font-size: 1.2rem;   font-weight: bold;    margin: 0 0 8px 0;
    color: #1E3A8A;  word-wrap: break-word;}
.map-item-modal-content hr {
    border: none;    border-top: 1px solid #C0B080;margin: 10px 0;}
.map-item-modal-content p {margin: 5px 0;    font-size: 0.95rem;}
.map-item-modal-buttons {
    margin-top: 15px; display: flex; flex-wrap: wrap;    gap: 13px;
    justify-content: center;}
.map-item-modal-buttons button {
    padding: 14px 16px;    font-size: 1rem;    border: none;
    border-radius: 4px;    cursor: pointer;   font-weight: bold;
    color: white;    flex-grow: 1;min-width: 100px;}    
#map-info-overlay {
    position: absolute;
    top: 4px;
    right: 4px;
    z-index: 1001;
    background-color: transparent; /* Fondo 100% transparente */
    color: black;                  /* Letra negra */
    font-weight: bold;             /* Letra en negrita */
    text-shadow: 
        -1px -1px 0 #fff,  
         1px -1px 0 #fff,
        -1px  1px 0 #fff,
         1px  1px 0 #fff;
    padding: 4px 8px;
    border-radius: 5px;
    box-shadow: none; /* Quitamos la sombra de la caja */
    max-width: 300px;
    font-size: 0.9em;
    text-align: center;
    display: none;
    transition: opacity 0.3s ease-in-out;
}

#map-info-overlay.error-overlay {
    background-color: rgba(220, 50, 50, 0.75) !important; /* Fondo rojo para errores */
    color: white !important; /* Letra blanca para errores */
    text-shadow: 1px 1px 2px black !important; /* Sombra oscura para letra blanca */
}    
    
#reminders-location-map-modal.map-modal-hidden {
    display: flex;  visibility: hidden;    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease, visibility 0s linear 0.3s;}
#address-suggestions-modal {
    position: fixed; left: 5%; width: 90%; transform: none;
    background-color: #E6D6A8; padding: 1rem;
    border-radius: 0.5rem; box-shadow: 0 4px 10px rgba(0,0,0,0.25);
    z-index: 11005 !important; 
    display: flex; flex-direction: column;
    border: 1px solid #C0B080;}    
.toast-instructional {
    background-color: #CF7C00;     color: white; 
    font-size: 1.3rem;    font-weight: bold;
    border: 2px solid #FFCDD2;
    box-shadow: 0 6px 15px rgba(0,0,0,0.4); max-width: 600px;
    text-align: center;    line-height: 1.4;}  
/* === INICIO: NUEVOS ESTILOS PARA AGRUPAR CONTROLES DEL MAPA === */   
#toggle-progress-bar-lock {
    width: 36px;  height: 36px;
    display: flex; align-items: center;
    justify-content: center;
    background-color: rgba(255, 255, 255, 0.1); border-radius: 50%;
    transition: background-color 0.2s ease; position: absolute;
    top: 3px;  left: 3px; z-index: 2;}
#toggle-progress-bar-lock:hover { background-color: rgba(255, 255, 255, 0.3);}
#toggle-progress-bar-lock img {
    width: 28px;height: 28px;  object-fit: contain;}  
/* === REGLA MODIFICADA: AÑADIR TRANSICIÓN A LA BARRA DE PROGRESO === */
#navigation-bottom-progress-bar {
    position: absolute; top: 5px; left: 5px; transform: none;
    width: auto; max-width: 500px; min-width: 480px;
    background-color: rgba(0, 0, 0, 0.6); padding: 8px;
    border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    z-index: 1001; color: white; display: none;
    transition: opacity 0.4s ease-out, visibility 0.4s ease-out, transform 0.4s ease-out; /* TRANSICIÓN AÑADIDA/MODIFICADA */}

/* === NUEVA REGLA: PARA DESLIZAR PARCIALMENTE LA BARRA DE PROGRESO === */
#navigation-bottom-progress-bar.progress-bar-partially-hidden {
    transform: translateY(-105px) !important;}    
#navigation-top-info-bar {
    margin-bottom: 8px; font-size: 1.2em;
    display: flex; align-items: center;
    position: relative; cursor: pointer;}
#navigation-bottom-progress-bar hr {
    border: none;  border-top: 1px solid rgba(229, 209, 193, 0.5);
    margin: 10px 0;}
#navigation-top-info-bar .turn-icon-display img {
    width: 95% !important; height: 95% !important;
    background-size: contain; background-position: center;
    display: block; margin: auto; object-fit: contain;}
#navigation-bottom-progress-bar.progress-bar-auto-hidden {
    opacity: 0;    visibility: hidden;    transform: translateY(-100%);
    pointer-events: none;}
.mapboxgl-ctrl-bottom-left .mapboxgl-ctrl {  margin: 0 0 5px 5px; }   
.mapboxgl-ctrl-bottom-right .mapboxgl-ctrl { margin: 0 3px 5px 0; }    
/* === INICIO: CSS PARA MEJORAR SATURACIÓN Y CONTRASTE DEL MAPA (CON VARIABLES) === */
:root {
    --map-saturation: 1.6; 
    --map-contrast: 1.2;   }
.mapboxgl-canvas {
    filter: saturate(var(--map-saturation)) contrast(var(--map-contrast));}
/* === INICIO: ESTILOS PARA ESTADÍSTICAS DE ADMIN EN CHAT === */
.chat-admin-stats-header {
    padding: 8px; background-color: #3a3a3c;
    border-bottom: 1px solid #444;
    text-align: center; font-size: 0.9rem;
    font-weight: bold;   color: #ffd700;}
.chat-user-session-stats {
    font-size: 0.75rem;  color: #ffd700;
    margin-left: 8px; font-style: italic;}
#auto-start-nav-modal {
    position: fixed;  bottom: 10px;   left: 10px;
    background-color: #CF7C00;  border: 2px solid white;
    border-radius: 8px;  padding: 15px;
    z-index: 10003; box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    max-width: 320px; color: white;
    font-family: sans-serif;  display: flex;flex-direction: column;
    gap: 10px;}
#auto-start-nav-modal #start-route-now-button {
    padding: 10px 15px;
    font-size: 1.2rem;  font-weight: bold;
    background-color: #28a745; color: white;
    border: 1px solid #FFF;
    border-radius: 5px; cursor: pointer;
    transition: background-color 0.2s ease;}
#auto-start-nav-modal #start-route-now-button:hover {
    background-color: #218838;}
#auto-start-nav-modal .info-text {
    font-size: 0.85rem;line-height: 1.3;   color: #f0f0f0;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);}    
.mapboxgl-ctrl.map-combined-controls-wrapper {
    display: flex;
    flex-direction: row;    align-items: flex-end;  gap: 3px; 
    background-color: transparent !important;
    box-shadow: none !important;}
    
/* === NUEVOS ESTILOS PARA AGRUPAR CONTROLES DEL MAPA === */
.mapboxgl-ctrl.map-combined-controls-wrapper {
    display: flex;
    flex-direction: row;    align-items: flex-end;  gap: 3px; 
    background-color: transparent !important;
    box-shadow: none !important;}
.control-button {
    width: 85px;
    height: 100%; background-color: rgba(42, 130, 224, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.6);  color: white;
    border-radius: 30px;   font-size: 35px;
    text-align: center;  cursor: pointer;  user-select: none;
    -webkit-user-select: none; transition: background-color 0.2s;
    display: flex; align-items: center;justify-content: center; flex-shrink: 0;}
.zoom-control-button {
    height: 100%; 
    aspect-ratio: 1 / 1;  background-color: rgba(42, 130, 224, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.6);  color: white;
    border-radius: 50%;   font-size: 42px; font-height: bold; 
    text-align: center;  cursor: pointer; user-select: none;
    -webkit-user-select: none; transition: background-color 0.2s;
    display: flex; align-items: center;
    justify-content: center;flex-shrink: 0;}    
.zoom-control-button:hover {  background-color: rgba(62, 150, 244, 0.4);}
#zoom-toggle-button img {  width: 30px;height: 30px;  object-fit: contain;}  
#zoom-toggle-button {   background-color: white;}
#zoom-toggle-button:hover {  background-color: #e0e0e0; }    

/* === INICIO: CSS PARA ICONOS DE ALERTA DE TRÁFICO (CORREGIDO) === */
.traffic-alert-marker {
cursor: pointer;
background-color: white; border-radius: 50%;
border: 3px solid red;
box-shadow: 0 2px 5px rgba(0,0,0,0.5);
display: flex;  justify-content: center;align-items: center;
transition: width 0.2s ease, height 0.2s ease;
width: 80px; height: 80px;}
.traffic-alert-marker img {
width: 90%;height: 90%; object-fit: contain;}    
.traffic-alert-icon-container {
    width: 60px; height: 60px; border-radius: 50%;
    background-color: white; border: 3px solid red;
    box-shadow: 0 2px 5px rgba(0,0,0,0.5); display: flex;
    justify-content: center; align-items: center;
    overflow: hidden; cursor: pointer;
    transition: width 0.2s ease, height 0.2s ease, border-width 0.2s ease;}
.traffic-alert-icon-container.small {
    width: 30px; height: 30px; border-width: 2px;}
.traffic-alert-icon-container img {
    width: 90%; height: 90%; object-fit: contain;}

/* === INICIO: NUEVOS ESTILOS PARA MODAL DE UBICACIONES GUARDADAS (TEMA OSCURO) === */
.saved-locations-modal {
    background-color: #2c2c2e;   color: #f0f0f0;    border-radius: 14px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.6);
    border: 1px solid #444;   padding: 1rem;
    height: calc(100dvh - 30px);   max-height: calc(100dvh - 30px);
    display: flex;   flex-direction: column;}
.saved-locations-modal h2 {
    color: white;font-size: 1.5rem;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    border-bottom: 1px solid #444; padding-bottom: 0.75rem;}
.saved-locations-modal #saved-locations-list {
    flex-grow: 1; overflow-y: auto; margin-bottom: 1rem;
    padding-right: 10px;  background-color: transparent; border: none;}
.saved-locations-modal .location-slot {
    display: flex;  align-items: stretch;  gap: 0.75rem; 
    margin-bottom: 0.75rem;
    border-bottom: 1px solid #3a3a3c;
    padding-bottom: 0.75rem;}
.saved-locations-modal .location-slot:last-child { border-bottom: none;}
.saved-locations-modal .location-slot span:first-child {align-self: center;}
.saved-locations-modal .location-slot input[type="text"] {
    background-color: #3a3a3c;   border: 1px solid #555; color: #f0f0f0;
    border-radius: 8px; font-size: 1.1rem; font-weight: bold;
    min-height: 55px; }
.saved-locations-modal .location-slot button {
    height: auto;   min-height: 55px; border-radius: 8px;border: none;
    font-weight: bold;  font-size: 1rem;
    transition: opacity 0.2s;}
.saved-locations-modal .location-slot button:hover {   opacity: 0.85;}
.saved-locations-modal .location-slot button.map-button {
    background-color: #007aff;   color: white;}
.saved-locations-modal .location-slot button.select-location-button {
    background-color: #34c759;  color: white;}
.saved-locations-modal .location-slot .coords-display {
    color: #a0a0a0; align-self: center; font-size: 0.9rem;}
.saved-locations-modal #save-all-user-locations {
    background-color: #007aff;
    color: white;   font-weight: bold; border-radius: 8px;}
.saved-locations-modal #save-all-user-locations:hover {
    background-color: #0056b3;}
.saved-locations-modal #close-saved-locations-modal {
    background-color: #555;   color: white; font-weight: bold;
    border-radius: 8px;}
.saved-locations-modal #close-saved-locations-modal:hover {
    background-color: #444;}

/* === INICIO: CSS PARA MODALES DE RUTA (TEMA OSCURO MODERNO - VERSIÓN CORREGIDA Y DEFINITIVA) === */
#saved-routes-modal,
#save-route-prompt-modal { }
.route-modal-overlay {
    position: fixed;    inset: 0;  width: 100vw;   height: 100vh;
    background-color: rgba(0, 0, 0, 0.4);  backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    z-index: 8400;    display: flex;
    justify-content: center;  align-items: center;
    padding: 10px;}
.route-modal-container {
    background-color: #2c2c2e; color: #f0f0f0; border-radius: 14px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);border: 1px solid #444;
    overflow: hidden;  display: flex;   flex-direction: column;
    width: 100%; max-width: 750px;
    max-height: calc(100vh - 30px);}
.route-modal-header {
    height: 120px;
    background-image: url('https://boardinggate.github.io/Tesla/PNG/modalrutas.png');
    background-size: cover;
    background-position: center;  position: relative;
    display: flex;align-items: flex-start;
    padding: 0;}    
.route-modal-header::before {
    content: '';position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 60%);}
.route-modal-title-card {
    background-color: rgba(0, 0, 0, 0.6);
    padding: 5px 14px;border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);  position: relative;
    z-index: 1;  margin: 15px;}
.route-modal-title {
    font-size: 1.6rem;   font-weight: bold; color: white;}
.route-modal-body {
    padding: 15px 20px;
    flex-grow: 1; overflow-y: hidden;
    display: flex;flex-direction: column;}
.route-modal-controls {
    display: flex; gap: 10px;  margin-bottom: 15px;
    align-items: center; position: relative;}
.route-modal-body p {
    font-size: 1rem; color: #b0b0b0;  margin-bottom: 8px; line-height: 1.5;}
.route-modal-body p strong {color: #f0f0f0;  font-weight: bold;}
.route-modal-body .route-label {
    display: block; margin-bottom: 8px;
    font-weight: 500; color: #a0a0a0; font-size: 1rem;}
.route-filter-input {
    flex-grow: 1;  padding: 12px 40px 12px 15px;
    height: 50px;border: 1px solid #555;  border-radius: 8px;
    font-size: 1.1rem; font-weight: 500;
    background-color: #3a3a3c; color: #f0f0f0;
    display: flex;  align-items: center;}
.route-filter-input::placeholder { color: #8e8e93; }
.route-scroll-container {
    flex-grow: 1; overflow-y: auto; padding-right: 5px;}
.routes-section-title {
    font-size: 1.1rem; font-weight: bold;  color: #007aff;
    margin-top: 15px; margin-bottom: 8px; padding-bottom: 5px;
    border-bottom: 1px solid #444;}
.routes-section-title:first-child { margin-top: 0;}
.route-list {  list-style: none;  padding: 0;    margin: 0;}
.route-list-item {
    background-color: #3a3a3c;padding: 10px 15px;
    border: 1px solid #4a4a4a;display: flex;
    justify-content: space-between; align-items: center;
    border-radius: 8px;margin-bottom: 8px;
    transition: background-color 0.2s;}
.route-list-item:hover {   background-color: #4a4a4a;}
.route-list-empty {
    color: #8e8e93; text-align: center; padding: 20px; font-style: italic;}
.route-name {
    flex-grow: 1;cursor: pointer; font-size: 1.1rem;
    font-weight: bold; color: #f0f0f0;}
.route-actions {
    display: flex;gap: 10px;flex-shrink: 0; margin-left: 15px;}
.btn-return, .btn-delete {
    font-size: 0.95rem;  padding: 6px 14px;
    border-radius: 6px; border: none;
    cursor: pointer; font-weight: bold;
    color: white; transition: transform 0.1s ease, opacity 0.2s;}
.btn-return:hover, .btn-delete:hover {
    transform: scale(1.05); opacity: 0.9;}
.btn-return { background-color: #34c759; }
.btn-delete { background-color: #ff3b30; }
.route-modal-footer {
    display: flex; gap: 1rem; padding: 15px 20px;
    border-top: 1px solid #444;   background-color: #1c1c1e;}
.route-modal-footer button {
    flex: 1;  padding: 12px;
    font-size: 1.1rem; font-weight: bold;border-radius: 8px;
    cursor: pointer;  border: none; transition: opacity 0.2s;
    display: flex;  align-items: center;  justify-content: center;}
.route-modal-footer button .button-countdown-timer {
    margin-left: 8px;font-weight: normal;}
.route-modal-footer button:hover {opacity: 0.85;}
.btn-modal-save,
.btn-modal-action-primary { background-color: #007aff;   color: white;}
.btn-modal-cancel,
.btn-modal-action-secondary {background-color: #555; color: white;}
.btn-modal-favorite { background-color: #ff9500;color: white;}
.btn-modal-danger { background-color: #ff3b30;   color: white;}
.route-label-marker {
    display: flex; align-items: center; justify-content: center;
    border-radius: 50%; color: white; font-weight: bold;
    font-size: 14px; font-family: Arial, sans-serif;
    text-align: center; box-shadow: 0 0 5px rgba(0,0,0,0.7);
    border: 2px solid white; cursor: pointer;
    transition: transform 0.2s ease; width: 40px; height: 40px;}
.route-label-marker:hover {    transform: scale(1.1);}

/* =================================================================== */
/* INICIO: NUEVOS ESTILOS PARA MODAL DE LISTA DE RECORDATORIOS (TEMA OSCURO v2) */
/* =================================================================== */
.reminder-table-modal {
    background-color: #2c2c2e; color: #f0f0f0; border-radius: 14px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.6); border: 1px solid #444;
    padding: 0;
    display: flex; flex-direction: column;
    width: 95%; max-width: 1200px;
    height: 95vh; max-height: 95vh;
    left: 50%; top: 50%; transform: translate(-50%, -50%);
    overflow: hidden;}
.reminder-table-header {
    height: 120px;
    background-image: url('https://boardinggate.github.io/Tesla/PNG/modalrutas.png');
    background-size: cover; background-position: center;
    position: relative; flex-shrink: 0;
    display: flex; flex-direction: column;
    justify-content: space-between;
    padding: 1rem 1.5rem;}
.reminder-table-header::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.3) 50%, rgba(0,0,0,0) 100%);}
.reminder-table-modal .reminder-table-top-controls {
    display: flex; justify-content: space-between; align-items: left;
    position: relative; z-index: 1;}
.reminder-table-modal h2 {
    font-size: 2.2rem !important; font-weight: bold !important; color: white !important;
    text-shadow: 2px 2px 5px rgba(0,0,0,0.8);
    position: relative; z-index: 1;
    text-align: left; margin: 0;
    padding-bottom: 0.5rem;}
.reminder-table-modal .reminder-table-top-controls label {
    color: #e0e0e0; font-weight: bold;}
.reminder-table-modal .reminder-table-top-controls button {
    font-weight: bold; border-radius: 8px;
    transition: background-color 0.2s, opacity 0.2s;
    min-height: 50px;}
.reminder-table-modal #view-all-locations-map {   background-color: #007aff; color: white; border: none;}
.reminder-table-modal #view-all-locations-map:hover { background-color: #0056b3;}
.reminder-table-modal #close-reminders-top {  background-color: #555; color: white; border: none;}
.reminder-table-modal #close-reminders-top:hover {  background-color: #444;}

.reminder-table-body-container {
    flex-grow: 1; overflow-y: auto; padding: 0.5rem 1.5rem 1.5rem 1.5rem;}
.reminder-table-modal table {
    border-collapse: separate; border-spacing: 0;}
.reminder-table-modal th {
    background-color: #3a3a3c; color: #f0f0f0; border-color: #444; border-bottom-width: 2px;}
.reminder-table-modal td {
    border: none;  border-bottom: 1px solid #0fd978;  color: #e0e0e0;}
.reminder-table-modal tbody tr:last-child td {  border-bottom: none;}
.reminder-table-modal tbody tr {transition: background-color 0.15s ease;}
.reminder-table-modal tbody tr:hover {background-color: #48484a !important;}
.reminder-table-modal td:first-child { border: none;}
.reminder-table-modal td:first-child button {
    border-radius: 6px;font-weight: bold;
    color: white;   border: none;
    transition: opacity 0.2s;}
.reminder-table-modal td:first-child button:hover {  opacity: 0.85;}
.reminder-table-modal .visto-prox { background-color: #ff3b30; }
.reminder-table-modal .postpone { background-color: #ff9500; }
.reminder-table-modal .cancel-cyclic-table { background-color: #8B0000; }
.reminder-table-modal button.modify { background-color: #34c759; }
.reminder-table-modal .bottom-button-container {
    display: none;}

/* =================================================================== */
/* INICIO: CSS PARA EL MODAL DE INFORMACIÓN DE PUNTOS DE INTERÉS (POI) */
.poi-modal-overlay {
    position: fixed; inset: 0;
    background-color: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    z-index: 10005;
    display: flex; justify-content: center; align-items: center;
    padding: 15px;}
.poi-modal-content {
    background-color: #2c2c2e; color: #f0f0f0;
    border-radius: 14px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    border: 1px solid #444;
    width: 100%; max-width: 750px; 
    max-height: 95vh; 
    display: flex; flex-direction: column; overflow: hidden;}    

.poi-modal-header {
    height: 140px;
    background-image: url('https://boardinggate.github.io/Tesla/PNG/modal-poi-header.jpg');
    background-size: cover; background-position: center;
    position: relative;
    display: flex; flex-direction: column; justify-content: flex-end;
    padding: 1rem;
    text-shadow: 1px 1px 4px rgba(0,0,0,0.9);}

.poi-modal-header::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.4) 50%, rgba(0,0,0,0) 100%);}
.poi-modal-title {
    font-size: 1.6rem; font-weight: bold; color: white;
    position: relative; z-index: 1; line-height: 1.2;}
.poi-modal-address {
    font-size: 0.9rem; color: #c7c7cc;
    position: relative; z-index: 1; margin-top: 4px;}
.poi-modal-body {
    padding: 1rem;
    max-height: calc(90vh - 300px); /* Ajusta la altura máxima para el scroll */
    overflow-y: auto;}
.poi-modal-info-section {   margin-bottom: 1rem;}

.poi-modal-info-section h4 {
    font-size: 0.8rem; font-weight: bold; color: #8e8e93;
    text-transform: uppercase; margin-bottom: 0.5rem;
    border-bottom: 1px solid #444; padding-bottom: 0.25rem;}
.poi-modal-info-section p,
.poi-modal-info-section a {
    font-size: 1rem; color: #f0f0f0; margin: 0;  line-height: 1.5;}

.poi-modal-info-section a {
    color: #0a84ff; text-decoration: none;  word-break: break-all;}
.poi-modal-info-section a:hover {text-decoration: underline;}
.poi-modal-footer {
    padding: 1rem; border-top: 1px solid #444;
    background-color: #1c1c1e;  display: grid;
    grid-template-columns: 1fr 1fr; gap: 0.75rem;}
.poi-modal-footer button {
    padding: 12px; font-size: 1rem; font-weight: bold;
    border-radius: 8px; border: none; cursor: pointer;
    transition: opacity 0.2s;}
.poi-modal-footer button:hover {opacity: 0.85;}    

/* --- NUEVOS ESTILOS PARA EL CONTROL DE INCLINACIÓN (PITCH) --- */
.pitch-control-button {
    background: none;
    border: none;padding: 0;
    cursor: pointer;
    color: white; opacity: 0.8;
    transition: opacity 0.2s, transform 0.1s;}
.pitch-control-button:hover {opacity: 1;}
.pitch-control-button:active { transform: scale(0.9);}
.pitch-control-button svg {
    width: 32px; height: 24px;  stroke-width: 2.5;}

/* === INICIO: NUEVOS ESTILOS PARA EL PANEL EMERGENTE DE AJUSTES === */
.map-settings-popup {
    display: flex; flex-direction: row;   gap: 10px;padding: 10px;
    background: rgba(44, 44, 46, 0.85);  border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);  backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.25);   opacity: 0;
    visibility: hidden; transform: translateY(10px);
    transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;}

.map-settings-popup.visible {
    opacity: 1;visibility: visible; transform: translateY(0);}
.map-settings-popup .map-layer-selector,
.map-settings-popup .map-view-selector {
    display: flex;flex-direction: column;gap: 5px;}
.map-settings-popup .separator {
    width: 1px;background-color: rgba(255, 255, 255, 0.2);  margin: 0 5px;}

.map-settings-popup label {
    display: flex; align-items: center;  padding: 6px 8px; cursor: pointer;
    font-weight: 500;font-size: 0.9rem;white-space: nowrap;
    transition: background-color 0.2s; border-radius: 4px;  color: #e0e0e0;}
.map-settings-popup label:hover {  background-color: rgba(255,255,255,0.15);}
.map-settings-popup input[type="radio"] {
    margin-right: 8px;
    vertical-align: middle;appearance: none;
    -webkit-appearance: none;
    background-color: #333;border: 1px solid #888;
    width: 16px; height: 16px;  border-radius: 50%;
    position: relative; cursor: pointer;}

.map-settings-popup input[type="radio"]:checked {
    background-color: #2a82e0; border-color: #fff;}

.map-settings-popup input[type="radio"]:checked::after {
    content: '';
    display: block;width: 8px; height: 8px; border-radius: 50%;
    background: white; position: absolute;
    top: 50%; left: 50%; transform: translate(-50%, -50%);}

/* === INICIO: NUEVOS ESTILOS PARA TARJETA DE NAVEGACIÓN MÍNIMA === */
#mini-nav-info-card {
    position: absolute; top: 10px;   left: 10px;  z-index: 1012;
    background-color: rgba(40, 40, 40, 0.3); 
    color: #E0E0E0;  font-weight: bold;
    font-size: 1.5em;  padding: 4px 10px;
    border-radius: 8px; pointer-events: none;   display: none; 
    text-shadow: 1px 1px 4px black;
    border: 1px solid rgba(255, 255, 255, 0.2);  backdrop-filter: blur(3px);
    -webkit-backdrop-filter: blur(3px);text-align: center;}
#post-arrival-action-modal {
    position: fixed;  bottom: 10px;   left: 10px;
    background-color: #3a3a3c;  border: 2px solid #555;
    border-radius: 8px;  padding: 15px;
    z-index: 10003; box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    max-width: 320px; color: white;
    font-family: sans-serif;  display: flex; flex-direction: column;
    gap: 12px;}
#post-arrival-action-modal .post-arrival-title {
    font-size: 1rem; font-weight: bold; text-align: center;
    color: #f0f0f0; margin-bottom: 5px;}
#post-arrival-action-modal .post-arrival-buttons {
    display: flex; flex-direction: column; gap: 8px;}
#post-arrival-action-modal button {
    padding: 10px 15px; font-size: 1.1rem;  font-weight: bold;
    border: 1px solid #FFF; border-radius: 5px; cursor: pointer;
    transition: background-color 0.2s ease, opacity 0.2s;}
#post-arrival-action-modal #return-trip-button {
    background-color: #34c759; color: white;}
#post-arrival-action-modal #return-trip-button:hover {
    background-color: #2fb350;}
#post-arrival-action-modal #clear-completed-route-button {
    background-color: #ff3b30; color: white;}
#post-arrival-action-modal #clear-completed-route-button:hover {
    background-color: #d93128;}   
#route-modal-save-overlay {
    justify-content: flex-start;   align-items: flex-start;   }    

/* === INICIO: NUEVOS ESTILOS PARA LA BARRA DE CONTROLES HORIZONTAL === */
.mapboxgl-ctrl.map-controls-bottom-right {
    display: flex;flex-direction: column;  align-items: flex-end;
    gap: 8px; background-color: transparent !important;
    box-shadow: none !important;}

#zoom-controls-horizontal {
    display: flex;flex-direction: row;align-items: center;
    gap: 6px;  background-color: rgba(0, 0, 0, 0.3);
    border-radius: 28px;  padding: 3px;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);}

.zoom-control-button {
    width: 60px; height: 60px;
    background-color: rgba(42, 130, 224, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.6);
    color: white;border-radius: 50%;font-size: 28px;
    text-align: center;cursor: pointer; user-select: none;
    -webkit-user-select: none;
    transition: background-color 0.2s;display: flex;
    align-items: center;  justify-content: center;  flex-shrink: 0;}
.zoom-control-button:hover { background-color: rgba(62, 150, 244, 0.4);}
#zoom-level-display {
    color: white; font-size: 1.2rem;font-weight: bold;   padding: 0 8px;
    text-shadow: 1px 1px 2px black; min-width: 40px;
    text-align: center;}
#zoom-auto-button {
    font-size: 1rem; font-weight: bold;  line-height: 1;
    background-color: #6c757d;}
#zoom-auto-button.active {
    background-color: #FFDAB9;  color: #333; border-color: white;}

#zoom-toggle-button img,
#map-settings-toggle-button img,
#map-offset-toggle-button img { /* Añadido #map-offset-toggle-button */
    width: 45px; height: 45px; object-fit: contain;}
#zoom-toggle-button { background-color: white; }
#zoom-toggle-button:hover { background-color: #e0e0e0; }
#map-settings-toggle-button { background-color: rgba(236, 255, 173, 0.7);}
#map-settings-toggle-button:hover { background-color: rgba(201, 204, 200, 0.7);   }

/* === INICIO: NUEVOS ESTILOS PARA EL PANEL EMERGENTE DE AJUSTES (v2 - Botones más grandes) === */
.map-settings-popup {
    display: flex; flex-direction: row;   gap: 10px;padding: 10px;
    background: rgba(44, 44, 46, 0.85);  border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);  backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.25);   opacity: 0;
    visibility: hidden; transform: translateY(10px);
    transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;}
.map-settings-popup.visible {
    opacity: 1;visibility: visible; transform: translateY(0);}
.map-settings-popup .map-layer-selector,
.map-settings-popup .map-view-selector {
    display: flex;flex-direction: column;gap: 5px;}
.map-settings-popup .separator {
    width: 1px;background-color: rgba(255, 255, 255, 0.2);  margin: 0 5px;}

.map-settings-popup label {
    display: flex; align-items: center;  padding: 8px 10px; cursor: pointer; /* Aumentado de 6px 8px */
    font-weight: 500;font-size: 1rem;white-space: nowrap; /* Aumentado de 0.9rem */
    transition: background-color 0.2s; border-radius: 4px;  color: #e0e0e0;}

.map-settings-popup label:hover {  background-color: rgba(255,255,255,0.15);}

.map-settings-popup input[type="radio"] {
    margin-right: 8px;
    vertical-align: middle;appearance: none;
    -webkit-appearance: none;
    background-color: #333;border: 1px solid #888;
    width: 19px; height: 19px;  border-radius: 50%; /* Aumentado de 16px */
    position: relative; cursor: pointer;}
.map-settings-popup input[type="radio"]:checked {
    background-color: #2a82e0; border-color: #fff;}
.map-settings-popup input[type="radio"]:checked::after {
    content: '';
    display: block;width: 10px; height: 10px; border-radius: 50%; /* Aumentado de 8px */
    background: white; position: absolute;
    top: 50%; left: 50%; transform: translate(-50%, -50%);}
/* === INICIO: NUEVOS ESTILOS PARA EL PANEL DE OFFSET Y PITCH (v4 - Botones más grandes) === */
#map-offset-toggle-button { background-color: white;}
#map-offset-toggle-button:hover {   background-color: #e0e0e0; }

.map-offset-popup {
    display: flex; flex-direction: row; align-items: center; gap: 0px; padding: 10px;
    background: rgba(44, 44, 46, 0.85);  border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);  backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.25);   opacity: 0;
    visibility: hidden; transform: translateY(10px);
    transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;}
.map-offset-popup.visible {
    opacity: 1;visibility: visible; transform: translateY(0);}
.map-offset-popup .crosshair-container {
    display: grid;
    grid-template-columns: 48px 70px 48px; 
    grid-template-rows: 48px 48px 48px;    
    align-items: center; justify-items: center;}
.map-offset-popup .offset-arrow {
    width: 43px; height: 43px; 
    background-color: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.4);
    border-radius: 50%;cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: background-color 0.2s;}
.map-offset-popup .offset-arrow:hover { background-color: rgba(255, 255, 255, 0.4); }
.map-offset-popup .offset-arrow svg { width: 29px; height: 29px; stroke: white; stroke-width: 2.5; } /* Aumentado de 24px */

.map-offset-popup #offset-arrow-up { grid-column: 2; grid-row: 1; }
.map-offset-popup #offset-arrow-down { grid-column: 2; grid-row: 3; }
.map-offset-popup #offset-arrow-left { grid-column: 1; grid-row: 2; }
.map-offset-popup #offset-arrow-right { grid-column: 3; grid-row: 2; }

.map-offset-popup #minimap-toggle-container {
    grid-column: 2; grid-row: 2;
    display: flex; flex-direction: column; align-items: center;  gap: 4px;}
.map-offset-popup #minimap-toggle-container input {
    width: 20px; height: 20px; margin: 0; }
.map-offset-popup #minimap-toggle-container label {
    font-size: 0.9rem; font-weight: bold; color: white; cursor: pointer; }
.offset-popup-separator {
    width: 1px; align-self: stretch;
    background-color: rgba(255, 255, 255, 0.2); margin: 0 12px;}
.pitch-controls-container {
    display: flex; flex-direction: column;
    justify-content: space-between; align-items: center;
    gap: 10px;  height: 100%;}
.pitch-value-display {
    font-size: 1.1rem;  font-weight: bold; color: white;}
.route-modal-tabs {
    display: flex; background-color: #1c1c1e;
    border-bottom: 1px solid #444;flex-shrink: 0; }
.route-modal-tab {
    flex: 1;  padding: 12px; text-align: center;  font-weight: bold;
    cursor: pointer;
    border: none;    background-color: transparent;  border-bottom: 3px solid transparent;
    transition: background-color 0.2s, border-color 0.2s, color 0.2s;
    color: #a0a0a0;
    font-size: 1rem; }
.route-modal-tab:hover { background-color: #3a3a3c;}
.route-modal-tab.active { border-bottom-color: #007aff;color: white;}
.route-modal-panel { display: none; }
.route-modal-panel.active {display: block; }
/* === INICIO: CORRECCIÓN COMPLETA PARA PERMITIR ARRASTRE Y ZOOM SOBRE CONTROLES === */
.mapboxgl-ctrl.map-controls-bottom-right {
    pointer-events: none;}
.mapboxgl-ctrl.map-controls-bottom-right > * {  pointer-events: auto;}
#zoom-controls-horizontal { pointer-events: auto; }
#zoom-controls-horizontal > .zoom-control-button { pointer-events: auto; }
.offset-value-display {
    position: absolute;
    font-size: 1.1rem;  font-weight: bold;  color: #f0f0f0; 
    white-space: nowrap;
    background-color: rgba(0,0,0,1);  padding: 2px 6px;  border-radius: 4px;
    pointer-events: none; opacity: 0.9; 
    text-shadow: 1px 1px 2px rgba(0,0,0,1); }
.offset-value-display.vertical {
    top: 0;left: 50%;
    transform: translate(-50%, -142%); }
.offset-value-display.horizontal {
    left: 0; top: 50%;
    transform: translate(-117%, -50%);}
/* CSS Exclusivo para el Modal #locations-preview-modal              */
#locations-preview-modal {
    position: fixed; top: 0; left: 0;  width: 100%; height: 100%;
    background-color: #DAC8A0; z-index: 8500;
    display: flex; flex-direction: column;
    padding: 10px; box-sizing: border-box;}
#locations-preview-map-container {
    flex-grow: 1; border: 1px solid #A09888;
    border-radius: 0.5rem; margin-bottom: 10px;min-height: 200px;}
#locations-preview-modal h2 {
    font-size: 1.2rem; font-weight: bold; text-align: center;
    margin-bottom: 10px; color: #333; flex-shrink: 0;}
#locations-preview-modal .modal-top-buttons {
    flex-shrink: 0; display: flex;
    justify-content: center; margin-top: 0;}
#close-locations-preview {
    padding: 0.8rem 2rem; font-size: 1.2rem; background-color: #4A5568; color: white;
    border: 1px solid #2D3748; border-radius: 8px;
    cursor: pointer; font-weight: bold;width: auto; min-width: 150px;}
#close-locations-preview:hover {  background-color: #2D3748;}
body.mobile-view #locations-preview-modal { z-index: 11000 !important;}
/* --- Estilos del Tema Oscuro (Específicos del Modal) --- */
#locations-preview-modal {
    background-color: #2c2c2e; color: #f0f0f0; border: 1px solid #444;}
#locations-preview-modal h2 {
    color: white;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    border-bottom: 1px solid #444; padding-bottom: 10px;}
#locations-preview-map-container {  border: 1px solid #444;}
#close-locations-preview {
    background-color: #555; color: white; border: none;}
#close-locations-preview:hover {
    background-color: #444;}
#zoom-locate-me-button {
    position: relative; background-color: white;}
#zoom-locate-me-button:hover { background-color: #e0e0e0;}
#zoom-locate-me-button img {
    width: 45px;  height: 45px;   object-fit: contain;}
#zoom-locate-me-button .countdown-overlay {
    position: absolute;  top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    color: #FF3333;  font-size: 1.7rem; font-weight: bold;
    text-shadow: 0 0 3px yellow, 0 0 5px yellow, 0 0 8px gold;
    pointer-events: none;  z-index: 10;}    
    
</style>

</head>
<body class="min-h-screen bg-[#ABAB99] flex flex-col items-center p-6">

    <div class="reminder-count-globe" id="reminder-count-globe" style="display: none;"></div>

    <div id="unified-reminder-window" role="alertdialog" aria-labelledby="reminder-window-title" aria-describedby="reminder-window-desc">
        <div class="reminder-count-header" id="reminder-window-title">
            <div class="reminder-title-container">
                <span style="font-size: 1.3rem;" id="reminder-count-text-container">
                    <span id="current-reminder-index">1</span> de <span id="total-reminder-count">X</span> Recordatorios
                </span>
                <span class="swipe-hint" id="reminder-swipe-hint" style="font-size: smaller;">
                    (deslice lateralmente)
              </span>
            </div>
            <button id="hide-all-reminders-button" title="Posponer 1 minuto todos los recordatorios visibles">OCULTAR</button>
        </div>
        <div id="reminder-swiper-container" aria-live="polite">
        </div>
        <span id="reminder-window-desc" class="hidden">Deslice para ver los recordatorios vencidos. Use los botones para gestionar cada recordatorio.</span>
    </div>

    <div id="grid-filter-container">
        <input type="text" id="grid-filter-input" placeholder="Filtrar grid...">
        <button id="clear-filter-button" title="Limpiar filtro">×</button>
    </div>

<main>
    <div id="open-chat-area" style="cursor: pointer;" title="Abrir Chat">
        <div id="user-info-header">
            <span id="user-count-globe"></span>
            <span id="chat-icon-button">
                <span id="chat-message-globe">0</span>
            </span>
            <div id="user-id-display"></div>
        </div>
    </div>
    
    <div id="bookmark-grid">
    </div>
</main>
    
<div class="notices-icon-container">
    <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4194.jpg" alt="Toggle Avisos" class="notice-off-icon" id="notice-toggle-icon">
    <div class="notices-container">
        <div class="notice-wrapper">
            <span class="notice" id="current-notice"></span>
        </div>
    </div>
</div>

<footer>
    <div class="footer-content">
        <div class="header-container">
            <img src="https://boardinggate.github.io/Tesla/PNG/LOGOTESLA.jpg" class="header-logo">
            <div class="title-container">
                <h1 class="text-2xl font-bold inline">
                    <span class="text-2xl">BoardingGate</span>
                    <span class="text-base">Lanzador</span>
                    <span id="version" class="version-text"></span>
                </h1>
            </div>
        </div>
        <div class="footer-line">
          <a href="https://x.com/boardinggate/status/1857325553742721116?s=46" class="footer-link-green" target="_blank" rel="noopener noreferrer">Ahorremos un dinero con mis REFERIDOS</a>
        </div>

        <div class="statcounter-container">
          <div style="display: inline-flex; align-items: center; gap: 10px;">
            <script type="text/javascript">
              var sc_project=13126275;
              var sc_invisible=0;
              var sc_security="0fc568cc";
              var scJsHost = "https://";
              document.write("<sc"+"ript type='text/javascript' src='" +
              scJsHost+
              "statcounter.com/counter/counter.js'>"+"<"+"/script>");
            </script>
            <noscript><div class="statcounter"><a title="Web Analytics"
            href="https://statcounter.com/" target="_blank"><img
            class="statcounter"
            src="https://c.statcounter.com/13126275/0/0fc568cc/0/"
            alt="Web Analytics"
            referrerPolicy="no-referrer-when-downgrade"></a></div></noscript>
            <a href="https://statcounter.com/p13126275/?guest=1" class="footer-subtext">Legionarios de Elon</a>
          </div>
        </div>

        <p class="footer-subtext">La inteligencia tiene ciertos limites. La locura, casi ninguno 🫶 🤟</p>
    </div>
</footer>

<!-- =================================================================== -->
<!-- INICIO: MODAL DEL MAPA PERSISTENTE (SOLUCIÓN A PÉRDIDA DE EVENTOS) -->
<!-- =================================================================== -->
<div id="reminders-location-map-modal" class="map-modal-hidden">

    <div id="toggle-map-header-buttons-panel">
         <img src="PNG/Coche_Sat.PNG" alt="Toggle Panel Mapa">
    </div>
    <div id="reminders-location-map-content-wrapper">
        <div id="reminders-location-map-header">
             <div class="button-row">
                <button id="close-reminders-location-map" class="reminders-map-button-action" title="Cerrar mapa y navegación"><img src="PNG/SALIR.PNG" alt="Salir"></button>
                <button id="locate-me-on-reminders-map" class="reminders-map-button-action" title="Mostrar mi posición actual y activar seguimiento"><img src="PNG/ESTASAQUI.PNG" alt="Estás Aquí"></button>
                <button id="start-navigation-button" class="reminders-map-button-action" title="Iniciar/Terminar Navegación"><img src="PNG/INICIARNAVEGACION.PNG" alt="Iniciar Navegación"></button>
                <button id="save-route-button" class="reminders-map-button-action hidden" title="Guardar Ruta Actual"><img src="PNG/GUARDARRUTA.PNG" alt="Guardar Ruta"></button>
                <button id="load-saved-route-button" class="reminders-map-button-action" title="Cargar Ruta Guardada"><img src="PNG/CARGARRUTA.PNG" alt="Cargar Ruta"></button>
                <button id="delete-current-route-button" class="reminders-map-button-action hidden" title="Borrar Ruta Actual del Mapa"><img src="PNG/BORRARRUTA.PNG" alt="Borrar Ruta"></button>
                <button id="add-radar-here" class="reminders-map-button-action" title="Crear RADAR en mi posición actual (radio 350m)"><img src="PNG/RADARAQUI.PNG" alt="Radar Aquí"></button>
                <button id="accident-alert-button-map" class="reminders-map-button-action" title="Informar de una incidencia de tráfico"><img src="https://boardinggate.github.io/Tesla/PNG/AACCIDENTE.png" alt="Informar Incidencia"></button>
                <button id="pdrs-ruta-button" class="reminders-map-button-action" title="Buscar Puntos de Recarga en Ruta"><img src="PNG/pdrs.png" alt="PDRs"></button>
                 <div class="radares-ruta-control">
                    <input type="checkbox" id="radares-ruta-checkbox">
                    <div class="radares-ruta-label-container">
                        <label for="radares-ruta-checkbox">Radares<br>Ruta</label>
                        <span id="radares-ruta-count" class="hidden">0</span>
                    </div>
                </div>
                <div class="tareas-ruta-control">
                    <input type="checkbox" id="tareas-ruta-checkbox">
                    <div class="tareas-ruta-label-container">
                        <label for="tareas-ruta-checkbox">Tareas<br>Ruta</label>
                        <span id="tareas-ruta-count" class="hidden">0</span>
                    </div>
                </div>
                <div class="mapbox-control">
                    <input type="checkbox" id="mapbox-primary-checkbox">
                    <div class="mapbox-label-container">
                        <label for="mapbox-primary-checkbox">Rutas<br>Mapbox</label>
                    </div>
                </div>
                <button id="add-reminder-at-location-button" class="reminders-map-button-action" title="Añadir recordatorio en punto del mapa">
                    <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4197.jpg" alt="Añadir Recordatorio">
                </button>
                 <button id="toggle-simulate-gps-button" class="reminders-map-button-action" title="Activar/Desactivar Simulación GPS (recorrido o clic)"><img src="PNG/GPS.PNG" alt="Simular Recorrido"></button>
                <button id="simulate-route-button" class="reminders-map-button-action" title="Simular interacciones de ruta"><img src="PNG/SIMULAR.PNG" alt="Simular Ruta"></button>
             </div>
             <div class="button-row" id="search-row-map-header">
                <button id="reorder-route-stages-button" title="Ordenar Etapas de Ruta"><img src="./PNG/MOVER.PNG" alt="Ordenar Etapas"></button>
                <button id="map-location-search-button" class="reminders-map-button-action"><img src="./PNG/ANADIRPUNTO.PNG" alt="Añadir Punto Ruta"></button>
                <button id="clear-map-search-input-button" title="Limpiar búsqueda">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="red" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
                <input type="text" id="map-location-search-input" placeholder="Dirección,sitio,zona /Negocio /Ciudad /CP+Provincia (28001 Madrid /Lidl Lugo)">
                <input type="text" id="filter-input" placeholder="Filtro"> 
                <button id="navigation-map-help-button" class="reminders-map-button-action" title="Ayuda del mapa de navegación/radares"><img src="PNG/IMG_4326.PNG" alt="Ayuda"></button>
             </div>
        </div>
            <div id="reminders-location-map-div">
                    <div id="mapbox-map-actual-container"></div>
                    <div id="mini-nav-info-card"></div>
                     <div id="map-info-overlay"></div>
                      
             <div id="navigation-bottom-progress-bar" style="display: none;">
                <button id="toggle-progress-bar-lock" title="Bloquear/desbloquear panel de progreso" style="position: absolute; top: 0px; left: 0px; z-index: 2; flex-shrink: 0; background: none; border: none; padding: 0; cursor: pointer;">
                    <img src="PNG/IMG_4281.png" alt="Lock" style="width: 28px; height: 28px;">
                </button>
                <div style="flex-grow: 1; margin-left: 5px;">
                    <div id="navigation-top-info-bar" style="padding-left: 30px;">
                        <div id="turn-icon-container-styled">
                            <span id="turn-icon-display" class="turn-icon-display"></span>
                        </div>
                        <div class="maneuver-text-container">
                           <div>
                               <span id="maneuver-text-display" class="maneuver-text"></span>
                               <span id="street-name-display" class="street-name"></span>
                           </div>
                           <div id="distance-to-turn-formatted"></div>
                        </div>
                    </div>
                    <div id="distance-progress-bar-to-turn-container"> <div id="distance-progress-bar-to-turn"></div> </div>
                    <hr>
                    <div id="route-overall-progress-container">
                         <div id="route-overall-progress">
                             <img id="route-progress-icon" src="PNG/AVANCE.PNG" alt="Avance" style="display:none;">
                             <span id="route-progress-text"></span>
                         </div>
                    </div>
                    <div id="navigation-eta-info">
                        <div id="next-stage-info">
                            <strong id="next-stage-label">Próxima Etapa</strong>
                            <span id="next-stage-distance">-- km</span>   |  
                            <span id="next-stage-time">-- min</span>   |   ETA:
                            <span id="next-stage-eta">--:--</span>
                            <span id="next-stage-eta-deviation" class="eta-deviation"></span>
                        </div>
                        <div id="final-destination-info">
                            <strong> Destino</strong>
                            <span id="final-destination-distance">-- km</span>   |  
                            <span id="final-destination-time">-- min</span>   |   ETA:
                            <span id="final-destination-eta">--:--</span>
                            <span id="final-destination-eta-deviation" class="eta-deviation"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- =================================================================== -->

<div id="pin-modal-overlay" class="hidden">
    <div id="pin-modal-content">
        <h2>Introducir Clave de Acceso</h2>
        <div class="modal-top-buttons" style="justify-content: center;">
            <button id="pin-submit-button">Entrar</button>
        </div>
        <label for="pin-input">Clave (4 cifras):</label>
        <input type="password" id="pin-input" maxlength="4" pattern="\d{4}" inputmode="numeric" required>
        <p id="pin-error-message"></p>
    </div>
</div>

<div id="versions-modal-overlay" class="versions-modal-overlay hidden">
    <div class="versions-modal-content">
        <h2>Histórico de versiones y recomendaciones</h2>
        <div class="modal-top-buttons" style="justify-content: flex-end;">
             <button id="close-versions-modal" style="flex: 0 1 auto; min-width: 120px;">Salir</button>
        </div>
        <pre id="versions-content">Cargando...</pre>
    </div>
</div>

<div id="reorder-stages-modal" class="hidden">
    <h2>Ordenar Etapas de Ruta</h2>
    <div class="modal-top-buttons">
        <button id="confirm-reorder-stages">Aceptar <span class="button-countdown-timer"></span></button>
        <button id="cancel-reorder-stages">Cancelar</button>
    </div>
    <p style="font-size: 0.9rem; color: #555; margin-bottom: 1rem;">Arrastra y suelta las etapas para cambiar su orden. Pulsa el aspa (X) para eliminar una etapa.</p>
    <ul id="sortable-stages-list">
    </ul>
</div>

<div id="scroll-toggle" class="scroll-toggle-button" title="Ir al inicio o fin">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M19 12l-7 7-7-7"/></svg>
</div>


<div id="config-modal" class="hidden">
    <div class="modal-top-buttons">
        <h2>Configuración y Datos</h2>
        <button id="config-close-modal" style="padding: 0.5rem 1rem; font-size:1rem;">Cerrar</button>
    </div>
    <div class="tab-buttons">
        <button class="config-tab-button active" data-tab-target="#tab-content-usuario">Usuario</button>
        <button class="config-tab-button" data-tab-target="#tab-content-pin">Clave Acceso</button>
        <button class="config-tab-button" data-tab-target="#tab-content-radares">RADARES</button>
        <button class="config-tab-button" data-tab-target="#tab-content-backup-restore">Backup/Restore</button>
        <button class="config-tab-button" data-tab-target="#tab-content-borrar">Borrar Datos</button>
        <button class="config-tab-button" data-tab-target="#tab-content-normas">Normas uso</button>
    </div>
    <div class="tab-contents">
        <div id="tab-content-usuario" class="config-tab-content active">
            <h3>Datos de Usuario y Sincronización</h3>
            <p style="font-size:.9rem;color:#555;margin-bottom:1.5rem;text-align:center;">
                Introduce un nombre de usuario único para guardar y recuperar tus datos en la nube.
            </p>
            <p style="font-size: .95rem; color: #005A9C; margin-bottom: 1.5rem; text-align: left; background-color: #e6f7ff; padding: 10px; border-radius: 5px; border-left: 5px solid #007bff;">
                <strong>Modo Compañero (Móvil):</strong> Para sincronizar datos desde tu móvil, usa tu nombre de usuario seguido de <strong>@MOVIL o MÓVIL</strong> (ej: `MI_USUARIO@MOVIL`).
                Al iniciar sesión, se cargarán los ÚLTIMOS DATOS que el coche haya GUARDADO EN LA NUBE. Cada cambio que hagas en el móvil (crear rutas, etc.) se guardará automáticamente en la nube para que esté disponible en el coche al CARGAR. 
                 -----IMPORTANTE!!!!---- SI QUIERES ENVIAR DATOS DESDE EL MÓVIL RECUERDA ANTES FORZAR UNA RECARGA DE LA PÁGINA EN EL COCHE (debes tener el check activo de copias automáticas) O REALIZAR MANUALMENTE UN BACKUP</p>
            <div class="user-data-grid">
                <div><label for="user-id">* ID Usuario (Único, no se puede cambiar):</label><input type="text" id="user-id" name="userId" required></div>
                <div><label for="tesla-model">Modelo Tesla:</label><input type="text" id="tesla-model" name="teslaModel"></div>
                <div><label for="tesla-year">Año Modelo:</label><input type="number" id="tesla-year" name="teslaYear" min="2012" max="2099"></div>
                <div><label for="tesla-province">Provincia:</label><input type="text" id="tesla-province" name="teslaProvince"></div>
                <div class="checkbox-container">
                    <input type="checkbox" id="allow-dms" name="allowDMs"><label for="allow-dms">Permitir MDs (vía admin)</label>
                    <span id="map-session-status" style="margin-left: 20px; font-size: 0.85em; color: #555;"></span>
                </div>
                
                <div class="checkbox-container" style="border-top: 1px solid #ccc; padding-top: 1rem; margin-top: 1rem;">
                    <input type="checkbox" id="config-auto-backup-on-load" name="autoBackup">
                    <label for="config-auto-backup-on-load">Sincronizar/Hacer copia de seguridad automática al cargar la página (en el coche)</label>
                </div>
            </div>
            <div class="user-buttons-container" style="margin-top:1.5rem;">
                <button id="config-save-user-firebase" style="background-color:#16A34A;color:white;">Validar usuario y/o Sincronizar/Guardar en la nube</button>
            </div>
            <p id="config-user-status" class="status-message"></p>
            </div>
         <div id="tab-content-pin" class="config-tab-content">
             <h3>Clave de Acceso (Local)</h3>
             <div class="pin-buttons-container" style="margin-bottom: 1rem;">
                 <button id="config-save-pin" style="background-color:#2563EB;color:white;">Guardar Clave y Preferencias</button>
                 <button id="config-remove-pin" style="background-color:#dc3545;color:white;">Quitar Clave</button>
             </div>
             <p style="font-size: 0.9rem; color: #555; margin-bottom: 1rem;">Establece una clave de 4 cifras para proteger el acceso inicial a la página</p>
             <div class="pin-config-layout">
                 <div class="pin-input-group">
                     <label for="config-pin-set">Establecer/Cambiar Clave:</label>
                     <input type="password" id="config-pin-set" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="4 cifras">
                 </div>
                 <div class="pin-input-group">
                     <label for="config-pin-confirm">Confirmar Clave:</label>
                     <input type="password" id="config-pin-confirm" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="Repetir 4 cifras">
                 </div>
             </div>
             <div class="checkbox-container" style="margin-top: 1.5rem; border-top: 1px solid #ccc; padding-top: 1rem;">
                <input type="checkbox" id="config-direct-to-nav" name="directToNav">
                <label for="config-direct-to-nav">Entrar directamente al Navegador de rutas</label>
            </div>
             <p id="config-pin-status" class="status-message"></p>
         </div>
         <div id="tab-content-radares" class="config-tab-content">
            <h3>Importar / Borrar Radares y Otros POIs</h3>
            <div class="radar-action-buttons" style="margin-bottom: 1rem;">
                <button id="import-radars-button">IMPORTAR RADARES y otros</button>
                <button id="delete-filtered-radars-button">BORRAR CACHÉ (según filtro)</button>
            </div>
            <p style="font-size:0.85rem; color:#444; margin-bottom:0.5rem;">
                Para <strong>importar</strong>, el filtro de "Palabras Clave" buscará coincidencias (OR) en el nombre del POI (ej: provincia, población, tipo).
                Los filtros de Lat/Lon pueden ser un valor único (aprox.) o un rango (ej: "<code>40.1 40.5</code>" para buscar entre esas latitudes). Si un filtro está vacío, no se aplica.
            </p>
             <p style="font-size:0.85rem; color:#444; margin-bottom:1rem;">
                 Los POIs importados (RADARES) se guardarán con un radio de <strong>400 metros</strong> y excluidos de la lista por defecto.
             </p>
            <p style="font-size:0.85rem; color:#444; margin-bottom:1.5rem;">
                Para <strong>borrar</strong>: Si NO se especifica NINGÚN filtro, se borrarán TODOS los recordatorios de tipo "RADAR" o excluidos de lista. Si se especifica algún filtro, se borrarán los que cumplan TODAS las condiciones activas (Palabras Clave OR, Latitud Y Longitud).
            </p>
            <div class="radar-filter-group">
                <div>
                    <label for="radar-filter-lat">Latitud (valor o "min max"):</label>
                    <input type="text" id="radar-filter-lat" placeholder="Ej: 40.123 o 40.0 40.5">
                </div>
                <div>
                    <label for="radar-filter-lon">Longitud (valor o "min max"):</label>
                    <input type="text" id="radar-filter-lon" placeholder="Ej: -3.567 o -4.0 -3.0">
                </div>
                <div style="grid-column: span 2;">
                    <label for="radar-filter-keywords">Palabras Clave (en nombre POI, separadas por espacio, condición OR):</label>
                    <input type="text" id="radar-filter-keywords" placeholder="Ej: FIJO CAMUFLADO MADRID">
                </div>
            </div>
            <div class="radar-import-options">
                <input type="checkbox" id="import-extra-radars-checkbox">
                <label for="import-extra-radars-checkbox">Importar también radares móviles, semáforo, etc (usa ficheros KLM adicionales)</label>
            </div>
             <div id="radar-import-progress-container" style="display:none;">
                 <progress id="radar-import-progress-bar" value="0" max="100"></progress>
                 <p id="radar-import-status" class="status-message"></p>
             </div>
         </div>
        <div id="tab-content-backup-restore" class="config-tab-content">
            <h3>Recuperar Backup / Hacer Copia en la Nube</h3>
            <p style="margin-bottom:1.2rem;">
                Para <strong>Recuperar</strong>, introduce tu ID de usuario y pulsa el botón naranja.<br>
                Para <strong>Hacer una Copia de Seguridad</strong>, asegúrate de que tu ID está introducido en la pestaña "Usuario" y pulsa el botón verde.
            </p>
            
            <div class="user-data-grid" style="grid-template-columns: 1fr auto; align-items: end; gap: 1rem;">
                <div style="grid-column: 1 / 2;">
                    <label for="restore-user-id">ID Usuario a recuperar:</label>
                    <input type="text" id="restore-user-id" placeholder="Tu apodo único (el que está en la pestaña usuario)...">
                </div>
                <div style="grid-column: 2 / 3; display: flex; flex-direction: column; gap: 0.5rem;">
                    <button id="config-restore-backup-firebase" style="background-color:#E65100;color:white;width:100%;padding: 0.6rem 1rem;">Recuperar Backup de la nube</button>
                    <button id="config-save-user-firebase-from-backup-tab" style="background-color:#16A34A;color:white;width:100%;padding: 0.6rem 1rem;">Hacer la copia de seguridad en la nube</button>
                </div>
            </div>
            <p id="config-restore-status" class="status-message"></p>
            <hr style="margin: 2rem 0;">
            <h3>Backup/Restore Local (Manual)</h3>
            <p style="font-size:.85rem; color:#555;">Esto es para copias manuales de texto. No interactúa con la nube</p>
            <div class="backup-restore-container" style="margin-top:1rem;">
                 <div>
                    <h4>Crear Backup Local</h4>
                     <button id="config-generate-backup" style="background-color:#2563EB;color:white; margin-bottom: 1rem;">Generar Código</button>
                    <textarea id="config-backup-display" readonly style="display:none;"></textarea>
                    <p id="config-backup-status" class="status-message"></p>
                </div>
                <div>
                    <h4>Restaurar Copia Local</h4>
                    <button id="config-restore-backup" style="background-color:#10B981;color:white; margin-bottom: 1rem;">Restaurar</button>
                    <textarea id="config-restore-input" placeholder="Pega el código de backup local aquí..."></textarea>
                </div>
            </div>
        </div>
        
        <div id="tab-content-borrar" class="config-tab-content borrar-container">
            <h3>Borrar Datos Locales</h3>
             <button id="config-restore-grid-button">RESTAURAR EL GRID ORIGINAL DE BOTONES</button>
             <p id="config-restore-grid-status" class="status-message" style="margin-bottom: 1.5rem;"></p>
            <h3 style="border-top: 1px solid #ccc; padding-top: 1.5rem; margin-top:1.5rem;">Acción Irreversible</h3>
            <button id="config-clear-cache" style="margin-bottom: 0.5rem;">Borrar TODO</button>
            <p>Elimina TODOS los datos locales.</p>
            <p><strong style="color:red;">¡Sin deshacer!</strong> Ten backup.</p>
        </div>
        <div id="tab-content-normas" class="config-tab-content">
             <h3 style="text-align: center; font-size: 1.4rem; color: #c0392b; margin-bottom: 1rem;">Aviso Importante: Uso de la Aplicación de Navegación</h3>
             <div style="text-align: left; font-size: 0.95rem; line-height: 1.5; color: #333; max-height: 45vh; overflow-y: auto; padding-right: 10px;">
                 <p>¡Bienvenido/a a nuestra aplicación de navegación de rutas para coche! Hemos diseñado esta herramienta con la mejor intención de ayudarte a planificar tus viajes.</p>
                 <p style="margin-top: 1rem;">Sin embargo, es fundamental que entiendas que el uso de esta aplicación es <strong>bajo tu propia y exclusiva responsabilidad</strong>. Al utilizar nuestra web, aceptas plenamente las siguientes condiciones:</p>
                 <ul style="list-style-type: disc; margin-left: 20px; margin-top: 1rem; space-y: 0.5rem;">
                     <li><strong>Responsabilidad del usuario:</strong> Eres el único/a responsable de la toma de decisiones al volante. Nuestra aplicación es una herramienta de apoyo y nunca debe sustituir tu juicio, la observación directa de las condiciones de la vía, las señales de tráfico o la normativa de circulación vigente.</li>
                     <li><strong>Supervisión constante:</strong> La aplicación debe ser utilizada siempre bajo tu supervisión activa. La información proporcionada (cartografía, trazados, indicaciones, etc.) puede no estar actualizada en tiempo real o contener imprecisiones. Las condiciones de la carretera, el tráfico o las regulaciones pueden cambiar sin previo aviso.</li>
                     <li><strong>Conducción segura:</strong> Prioriza siempre la seguridad. Evita manipular la aplicación mientras conduces y presta toda tu atención a la carretera. Detente en un lugar seguro para consultar la ruta si es necesario.</li>
                     <li><strong>Errores y fallos:</strong> Aunque nos esforzamos por ofrecer un servicio fiable, no podemos garantizar que la aplicación esté libre de errores, interrupciones o fallos. No nos hacemos responsables de ningún daño, perjuicio o incidente que pueda derivarse del uso o la imposibilidad de uso de esta aplicación.</li>
                     <li><strong>Actualizaciones:</strong> Te recomendamos mantener tu navegador y sistema operativo actualizados para el mejor funcionamiento de la aplicación, aunque no podemos garantizar la compatibilidad total con todos los dispositivos y versiones.</li>
                 </ul>
                 <p style="margin-top: 1rem;">Al continuar utilizando esta aplicación, confirmas que has leído, entendido y aceptado este descargo de responsabilidad. ¡Disfruta de tu viaje con precaución!</p>
             </div>
             <div style="text-align: center; margin-top: 1.5rem;">
                 <button id="accept-terms-button" style="background-color:#28a745; color:white; padding: 0.8rem 2rem; font-size: 1.2rem; border-radius: 0.25rem;">Acepto</button>
             </div>
         </div>
    </div>
</div>   
<div id="simulation-modal" class="hidden">
</div>

<div id="simulation-speed-modal" class="hidden">
</div>

<div id="locations-preview-modal" class="hidden">
    <h2 id="locations-preview-title">Ubicaciones (filtrado según tabla)</h2>
    <div id="locations-preview-map-container" style="height: calc(100% - 100px); width: 100%;"></div>
    <div class="modal-top-buttons" style="justify-content: center; margin-top: 1rem;">
        <button id="close-locations-preview">Salir</button>
    </div>
</div>

<div id="address-suggestions-modal" class="hidden">
    <h2 id="address-suggestions-title">Sugerencias de Dirección</h2>
    <ul id="address-suggestions-list"></ul>
    <div class="modal-top-buttons" style="justify-content: flex-end; margin-top: 1rem;">
        <button id="close-address-suggestions-modal" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
    </div>
</div>

<div id="deviation-modal" class="hidden">
</div>

<div id="arrival-stats-modal" class="hidden">
</div>

<div id="intersection-preview-map-window" class="hidden">
    <div id="intersection-preview-map-container"></div>
</div>

<div id="alert-modal-overlay" class="hidden">
    <div id="alert-modal-content">
      </div>
</div>

<div id="proximity-alert-modal" class="hidden">
</div>

<div id="flashing-border-overlay" class="hidden"></div>

<div id="chat-modal-overlay" class="hidden">
    <div id="chat-modal-content">
        <div id="chat-left-column">
            
            <div id="chat-input-area">
                <div id="chat-permission-warning" class="hidden"></div>
                <textarea id="chat-message-input" rows="4" maxlength="500" placeholder="Escribe un mensaje... (antecede @usuario para mensaje privado, o pulsa en el lateral. Para referirse simplemente nómbralo). Vida de los mensajes 96 horas. En el coche usa los comandos de voz. Elon cree en la humanidad, the White Monkey y yo también, ser educad@s."></textarea>
              
                <div id="chat-input-footer">
                    <div id="chat-buttons">
                        <button id="chat-send-button">Enviar</button>
                        <button id="chat-exit-button">Salir</button>
                    </div>
                    <div id="chat-char-counter">500</div>
                </div>
            </div>
            
            <div id="chat-messages-container"></div>
        </div>

        <div id="chat-right-column">
            <div id="chat-users-filter-container">
                <input type="text" id="chat-user-filter-input" placeholder="Filtrar por cualquier dato...">
            </div>
            <div id="chat-users-list"></div>
        </div>
    </div>
</div>
    
</div>    
<script>

    
//ofu mapbox
                                                                                                    mapboxgl.accessToken = "pk.eyJ1IjoiYm9hcmRpbmdnYXRlMTEiLCJhIjoiY21kOHdtMGU4MDEzaTJpcGh4cng0c3hmMiJ9.hDdGn_5VOMkN_bTuUowtRw";

// ===================================================================
// NOMBRE: findGooglePlaceId (NUEVA VERSIÓN - Places API v2)
// RESUMEN: Busca un lugar usando texto/coordenadas para obtener su place_id.
// ===================================================================
async function findGooglePlaceId(poiName, lat, lng) {
    if (!window.google || !window.google.maps || !window.google.maps.places) {
        console.error("La librería de Google Places no está cargada.");
        showToast("Error: No se pudo cargar el servicio de lugares.", "error");
        return null;
    }

    const request = {
        textQuery: poiName,
        fields: ['id'], // En la nueva API, el campo se llama 'id'
        locationBias: { center: { lat: lat, lng: lng }, radius: 2000 }, // Radio en metros
    };

    try {
        const { places } = await google.maps.places.Place.searchByText(request);
        
        if (places && places.length > 0) {
            return places[0].id; // El ID del lugar
        } else {
            console.warn("No se encontró un place_id de Google para:", poiName);
            return null;
        }
    } catch (error) {
        console.error("Error en la búsqueda de Google Places:", error);
        return null;
    }
}

// ===================================================================
// NOMBRE: getGooglePlaceDetails (NUEVA VERSIÓN - Places API v2)
// RESUMEN: Obtiene los detalles completos de un lugar usando su place_id.
// ===================================================================
async function getGooglePlaceDetails(placeId) {
    if (!window.google || !window.google.maps || !window.google.maps.places) {
        console.error("La librería de Google Places no está cargada.");
        showToast("Error: No se pudo cargar el servicio de lugares.", "error");
        return null;
    }
    
    const place = new google.maps.places.Place({ id: placeId });

    const fieldsToRequest = [
        'displayName', 'formattedAddress', 'websiteURI', 'nationalPhoneNumber',
        'regularOpeningHours', 'photos', 'rating', 'userRatingCount', 'googleMapsURI', 'reviews'
    ];
    
    try {
        await place.fetchFields({ fields: fieldsToRequest });
        
        return place;
    } catch (error) {
        console.error("Error al obtener detalles de Google Places:", error);
        return null;
    }
}
// ===================================================================
// NOMBRE: MapLayerAndViewController (VERSIÓN CORREGIDA Y DEFINITIVA)
// RESUMEN: Gestiona el cambio de estilo de mapa y se asegura de que todas las capas,
//          fuentes e imágenes personalizadas se recarguen y redibujen correctamente.
class MapLayerAndViewController {
    onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.className = 'mapboxgl-ctrl map-combined-control-container';

        this._container.addEventListener('click', e => e.stopPropagation());
        this._container.addEventListener('dblclick', e => e.stopPropagation());

        const layerSelector = document.createElement('div');
        layerSelector.className = 'map-layer-selector';

        const baseMaps = {
            "HÍBRIDO": "mapbox://styles/mapbox/satellite-streets-v12",
            "SATÉLITE": "mapbox://styles/mapbox/satellite-v9",
            "CALLES": "mapbox://styles/mapbox/streets-v12"
        };
        
        const legacyNameMap = {
            "Satélite + Calles": "HÍBRIDO",
            "Satélite Puro": "SATÉLITE",
            "Mapa Normal": "CALLES"
        };

        let savedLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY);

        if (legacyNameMap[savedLayerName]) {
            savedLayerName = legacyNameMap[savedLayerName];
            localStorage.setItem(ACTIVE_MAP_LAYER_KEY, savedLayerName);
        }

        if (!savedLayerName || !baseMaps[savedLayerName]) {
            savedLayerName = "HÍBRIDO";
        }
        
        Object.keys(baseMaps).forEach(name => {
            const label = document.createElement('label');
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = 'map-style-selector';
            input.value = baseMaps[name];
            if (name === savedLayerName) {
                input.checked = true;
            }
            input.onchange = () => {
                this._map.setStyle(input.value);
                localStorage.setItem(ACTIVE_MAP_LAYER_KEY, name);
                
                this._map.once('style.load', () => {
                    reAddCustomMapLayersAndSources(this._map).then(() => {
                        plotRemindersOnNavigationMap();
                        displayChargingPointsOnMap();
                        renderWaypointMarkers();
                    });
                    updateRouteAndCarIconStyle();
                });
              };
            label.appendChild(input);
            label.appendChild(document.createTextNode(` ${name}`));
            layerSelector.appendChild(label);
        });

        const viewSelector = document.createElement('div');
        viewSelector.className = 'map-view-selector';
        const viewModes = {
            'NORTE': {pitch: 0, bearing: 0, mode: 'static'},
            'AVANCE': {pitch: 0, bearing: null, mode: 'heading'},
            '3D': {pitch: 56, bearing: null, mode: 'perspective'}
        };

        const savedViewMode = localStorage.getItem(MAP_VIEW_MODE_KEY) || 'static';
        
        Object.keys(viewModes).forEach(name => {
            const label = document.createElement('label');
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = 'map-view-selector';
            input.value = viewModes[name].mode;

            if (viewModes[name].mode === savedViewMode) {
                input.checked = true;
            }

            input.onchange = () => {
                const selectedModeValue = input.value;
                const modeDetails = Object.values(viewModes).find(m => m.mode === selectedModeValue);
                const modeName = Object.keys(viewModes).find(key => viewModes[key].mode === selectedModeValue);

                if (modeDetails) {
                    mapViewMode = modeDetails.mode;
                    localStorage.setItem(MAP_VIEW_MODE_KEY, mapViewMode);
                    markCacheAsDirty();
                    showToast(`Modo Vista: ${modeName}`, 'info');

                    const easeOptions = { };
                    // --- CORRECCIÓN CLAVE: Usar el pitch guardado para el modo 3D ---
                    if (modeName === '3D') {
                        easeOptions.pitch = mapPitchValue; // Usar el valor persistente
                    } else {
                        easeOptions.pitch = modeDetails.pitch; // Usar 0 para NORTE y AVANCE
                    }

                    if (modeDetails.bearing !== null) {
                        easeOptions.bearing = modeDetails.bearing;
                    } else if (navigationCurrentLocation && navigationCurrentLocation.heading !== null) {
                        easeOptions.bearing = navigationCurrentLocation.heading;
                    }
                    this._map.easeTo(easeOptions);
                    
                    if (navigationCurrentLocation) {
                        updateInitialUserPosition(navigationCurrentLocation, this._map);
                    }
                }
            };
            label.appendChild(input);
            label.appendChild(document.createTextNode(` ${name}`));
            viewSelector.appendChild(label);
        });
        
        this._container.appendChild(layerSelector);
        this._container.appendChild(viewSelector);

        return this._container;
    }

    onRemove() {
        if (this._container && this._container.parentNode) {
            this._container.parentNode.removeChild(this._container);
        }
        this._map = undefined;
    }
}    
// ===================================================================
// NOMBRE: CompassAndStatsControl
// RESUMEN: Control que muestra brújula, altitud y velocidades.
// ===================================================================
class CompassAndStatsControl {
    constructor(options) {
        this.options = options || {};
    }

    onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.className = 'mapboxgl-ctrl map-control-custom-map-controls';
        
        const compassContainer = document.createElement('div');
        compassContainer.className = 'map-control-orientation-altitude';
        compassContainer.innerHTML = `
            <img id="compass-rose-icon" src="PNG/ROSA.PNG" alt="Orientación">
            <span id="orientation-text">---</span>
            <span id="altitude-display">--- m</span>
            <span id="current-speed-display">--- km/h</span>
            <span id="average-speed-display" class="speed-stats-text">Med: --- km/h</span>
            <span id="max-speed-display" class="speed-stats-text">Máx: --- km/h</span>
        `;
        
        compassContainer.addEventListener('click', (e) => {
            e.stopPropagation();
            this._toggleGraphMode(e);
        });
        compassContainer.title = "Clic para cambiar modo de la gráfica";

        const graphCard = document.createElement('div');
        graphCard.className = 'hidden';
        graphCard.id = 'navigation-graph-card';
        graphCard.style.position = 'relative'; 
        graphCard.style.cursor = 'pointer';
        graphCard.addEventListener('click', toggleEnlargedGraph);
        
        const graphTitle = document.createElement('div');
        graphTitle.id = 'navigation-graph-title';
        graphCard.appendChild(graphTitle);

        const enlargeButton = document.createElement('div');
        enlargeButton.id = 'enlarge-graph-button';
        enlargeButton.title = 'Ampliar/Reducir gráfica';
        enlargeButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="11" y1="8" x2="11" y2="14"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        `;
        enlargeButton.addEventListener('click', (e) => {
            e.stopPropagation(); 
            toggleEnlargedGraph();
        });
        graphCard.appendChild(enlargeButton);

        const graphCanvasContainer = document.createElement('div');
        graphCanvasContainer.id = 'navigation-graph-container';
        const canvas = document.createElement('canvas');
        canvas.id = 'navigation-chart';
        graphCanvasContainer.appendChild(canvas);
        graphCard.appendChild(graphCanvasContainer);
        
        this._container.appendChild(compassContainer);
        this._container.appendChild(graphCard);
        this._updateGraphTitle();
        return this._container;
    }

    onRemove() {
        if (this._container && this._container.parentNode) {
            this._container.parentNode.removeChild(this._container);
        }
        this._map = undefined;
    }
    
    _toggleGraphMode(e) {
        if (e) e.stopPropagation();
        if (!navigationCurrentRouteData && !isFreeDriveActive) {
            showToast("La gráfica estará disponible cuando se calcule una ruta o inicies un viaje libre.", "info");
            return;
        }
        const modes = ['Desviación ETA', 'Altitud', 'Gráfica off'];
        let currentIndex = modes.indexOf(currentGraphMode);
        currentIndex = (currentIndex + 1) % modes.length;
        currentGraphMode = modes[currentIndex];
        localStorage.setItem(GRAPH_STATE_KEY, currentGraphMode); 
        updateNavigationGraphVisibilityAndMode();
        if (currentGraphMode !== 'Gráfica off') {
            showToast(`Gráfica cambiada a: ${currentGraphMode}`, 'info');
        } else {
            showToast(`Gráfica desactivada`, 'info');
        }
    }

    _updateGraphTitle() {
        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            if (currentGraphMode === 'Desviación ETA') {
                graphTitleElement.textContent = 'Desviación ETA';
            } else if (currentGraphMode === 'Altitud') {
                graphTitleElement.textContent = 'Desnivel Ruta';
            } else {
                graphTitleElement.textContent = ''; 
            }
        }
    }
    
    updateOrientation(heading) {
        const compassRoseIcon = document.getElementById('compass-rose-icon');
        const orientationText = document.getElementById('orientation-text');
        if (compassRoseIcon && orientationText) {
            if (heading !== null && !isNaN(heading) && heading >= 0 && heading <= 360) {
                compassRoseIcon.style.transform = `rotate(${heading}deg)`;
                currentMapBearing = heading;
                const directions = ["N", "NE", "E", "SE", "S", "SO", "O", "NO", "N"];
                const index = Math.round(heading / 45) % 8;
                orientationText.textContent = `${directions[index]}`;
            } else {
                compassRoseIcon.style.transform = 'rotate(0deg)';
                orientationText.textContent = '---';
                currentMapBearing = 0;
            }
        }
    }

    updateAltitude(altitude) {
        const altitudeDisplay = document.getElementById('altitude-display');
        if (altitudeDisplay) {
            let displayText = '--- m';
            if (altitude !== null && !isNaN(altitude)) {
                displayText = `${altitude.toFixed(0)} m`;
                if (maxAltitudeDuringTrip !== -Infinity && isNavigating) {
                    displayText += ` \u2261 ${maxAltitudeDuringTrip.toFixed(0)} m`;
                }
            } else if (isNavigating && maxAltitudeDuringTrip !== -Infinity) {
                 displayText = `-- m \u2261 ${maxAltitudeDuringTrip.toFixed(0)} m`;
            }
            altitudeDisplay.textContent = displayText;
        }
    }

    updateCurrentSpeed(speedKmh) {
        const speedDisplay = document.getElementById('current-speed-display');
        if (speedDisplay) {
            if (speedKmh !== null && !isNaN(speedKmh)) {
                speedDisplay.textContent = `${speedKmh.toFixed(1)} km/h`;
            } else {
                speedDisplay.textContent = '--- km/h';
            }
        }
    }

    updateAverageSpeed(avgSpeedKmh) {
        const avgSpeedDisplay = document.getElementById('average-speed-display');
        if (avgSpeedDisplay) {
            let displayText = 'Med: --- km/h';
            if (avgSpeedKmh !== null && !isNaN(avgSpeedKmh) && (isNavigating || (isSimulatingGpsLocation && automatedSimulationIntervalId) || isFreeDriveActive)) {
                 displayText = `Med: ${avgSpeedKmh.toFixed(1)} km/h`;
            }
            avgSpeedDisplay.textContent = displayText;
        }
    }

    updateMaxSpeed(currentSpeedKmh, currentCoords) {
        if (typeof currentSpeedKmh === 'number' && currentSpeedKmh > maxSpeedDuringTrip) {
            maxSpeedDuringTrip = currentSpeedKmh;
            if (currentCoords) {
                maxSpeedCoordinates = { lat: currentCoords.latitude, lng: currentCoords.longitude };
            }
        }
        const maxSpeedDisplay = document.getElementById('max-speed-display');
        if (maxSpeedDisplay) {
            let displayText = 'Máx: --- km/h'; 
            if (typeof maxSpeedDuringTrip === 'number' && !isNaN(maxSpeedDuringTrip)) {
                if (maxSpeedDuringTrip > 0) {
                    displayText = `Máx: ${maxSpeedDuringTrip.toFixed(1)} km/h`;
                } else if ((isNavigating || (isSimulatingGpsLocation && automatedSimulationIntervalId) || isFreeDriveActive) && maxSpeedDuringTrip === 0) {
                    displayText = `Máx: 0.0 km/h`;
                }
            }
            maxSpeedDisplay.textContent = displayText;
        }
    }
}
// ===================================================================
// NOMBRE: MapSettingsPanel (NUEVA CLASE)
// RESUMEN: Crea el CONTENIDO del panel emergente de ajustes (capas y vistas).
class MapSettingsPanel {
    constructor(map) {
        this._map = map;
    }

    createPanelContent() {
        const fragment = document.createDocumentFragment();

        // Contenido de la clase MapLayerAndViewController, adaptado
        const layerSelector = document.createElement('div');
        layerSelector.className = 'map-layer-selector';

        const baseMaps = { "HÍBRIDO": "mapbox://styles/mapbox/satellite-streets-v12", "SATÉLITE": "mapbox://styles/mapbox/satellite-v9", "CALLES": "mapbox://styles/mapbox/streets-v12" };
        const legacyNameMap = { "Satélite + Calles": "HÍBRIDO", "Satélite Puro": "SATÉLITE", "Mapa Normal": "CALLES" };
        let savedLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY);
        if (legacyNameMap[savedLayerName]) { savedLayerName = legacyNameMap[savedLayerName]; localStorage.setItem(ACTIVE_MAP_LAYER_KEY, savedLayerName); }
        if (!savedLayerName || !baseMaps[savedLayerName]) { savedLayerName = "HÍBRIDO"; }
        
        Object.keys(baseMaps).forEach(name => {
            const label = document.createElement('label');
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = 'map-style-selector';
            input.value = baseMaps[name];
            if (name === savedLayerName) input.checked = true;
            input.onchange = () => {
                this._map.setStyle(input.value);
                localStorage.setItem(ACTIVE_MAP_LAYER_KEY, name);
                this._map.once('style.load', () => {
                    reAddCustomMapLayersAndSources(this._map).then(() => {
                        plotRemindersOnNavigationMap();
                        displayChargingPointsOnMap();
                        renderWaypointMarkers();
                    });
                    updateRouteAndCarIconStyle();
                });
            };
            label.appendChild(input);
            label.appendChild(document.createTextNode(` ${name}`));
            layerSelector.appendChild(label);
        });

        const viewSelector = document.createElement('div');
        viewSelector.className = 'map-view-selector';
        const viewModes = { 'NORTE': {pitch: 0, bearing: 0, mode: 'static'}, 'AVANCE': {pitch: 0, bearing: null, mode: 'heading'}, '3D': {pitch: 56, bearing: null, mode: 'perspective'} };
        const savedViewMode = localStorage.getItem(MAP_VIEW_MODE_KEY) || 'static';
        
        Object.keys(viewModes).forEach(name => {
            const label = document.createElement('label');
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = 'map-view-selector';
            input.value = viewModes[name].mode;
            if (viewModes[name].mode === savedViewMode) input.checked = true;
            input.onchange = () => {
                const selectedModeValue = input.value;
                const modeDetails = Object.values(viewModes).find(m => m.mode === selectedModeValue);
                const modeName = Object.keys(viewModes).find(key => viewModes[key].mode === selectedModeValue);
                if (modeDetails) {
                    mapViewMode = modeDetails.mode;
                    localStorage.setItem(MAP_VIEW_MODE_KEY, mapViewMode);
                    markCacheAsDirty();
                    showToast(`Modo Vista: ${modeName}`, 'info');
                    const easeOptions = { pitch: modeDetails.pitch };
                    if (modeDetails.bearing !== null) easeOptions.bearing = modeDetails.bearing;
                    else if (navigationCurrentLocation && navigationCurrentLocation.heading !== null) easeOptions.bearing = navigationCurrentLocation.heading;
                    this._map.easeTo(easeOptions);
                    if (navigationCurrentLocation) updateInitialUserPosition(navigationCurrentLocation, this._map);
                }
            };
            label.appendChild(input);
            label.appendChild(document.createTextNode(` ${name}`));
            viewSelector.appendChild(label);
        });
        
        const separator = document.createElement('div');
        separator.className = 'separator';

        fragment.appendChild(layerSelector);
        fragment.appendChild(separator);
        fragment.appendChild(viewSelector);

        return fragment;
    }
}
// ===================================================================
// NOMBRE: CustomMapControlsGroup (VERSIÓN CON RESET DE PITCH)
// RESUMEN: Gestiona la barra horizontal y los paneles emergentes.
class CustomMapControlsGroup {
    onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.className = 'mapboxgl-ctrl map-controls-bottom-right';
        
        this._settingsPopup = document.createElement('div');
        this._settingsPopup.className = 'map-settings-popup';
        const settingsPanel = new MapSettingsPanel(map);
        this._settingsPopup.appendChild(settingsPanel.createPanelContent());
        
        this._offsetPopup = document.createElement('div');
        this._offsetPopup.className = 'map-offset-popup';
        
        this._offsetPopup.innerHTML = `
            <div class="crosshair-container" style="position: relative;">
                <!-- NUEVO: Contenedor para el valor Y (Vertical) -->
                <div id="offset-value-display-y" class="offset-value-display vertical"></div>

                <button id="offset-arrow-up" class="offset-arrow" title="Mover vista hacia arriba">
                    <svg viewBox="0 0 24 24"><path d="M12 19V5M5 12l7-7 7 7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
                <button id="offset-arrow-left" class="offset-arrow" title="Mover vista a la izquierda">
                    <svg viewBox="0 0 24 24"><path d="M19 12H5M12 5l-7 7 7 7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>

                <!-- NUEVO: Contenedor para el valor X (Horizontal) -->
                <div id="offset-value-display-x" class="offset-value-display horizontal"></div>
                
                <div id="minimap-toggle-container">
                    <input type="checkbox" id="minimap-toggle-checkbox">
                    <label for="minimap-toggle-checkbox">Giros</label>
                </div>
                <button id="offset-arrow-right" class="offset-arrow" title="Mover vista a la derecha">
                    <svg viewBox="0 0 24 24"><path d="M5 12h14M12 5l7 7-7 7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
                <button id="offset-arrow-down" class="offset-arrow" title="Mover vista hacia abajo">
                    <svg viewBox="0 0 24 24"><path d="M12 5v14M19 12l-7 7-7-7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
                
            </div>
            <div class="offset-popup-separator"></div>
            <div class="pitch-controls-container">
                <button id="pitch-arrow-up" class="offset-arrow" title="Aumentar inclinación (pitch)">
                    <svg viewBox="0 0 24 24"><path d="M12 19V5M5 12l7-7 7 7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
                <span id="pitch-value-display" class="pitch-value-display">0°</span>
                <button id="pitch-arrow-down" class="offset-arrow" title="Reducir inclinación (pitch)">
                    <svg viewBox="0 0 24 24"><path d="M12 5v14M19 12l-7 7-7-7" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
            </div>
        `;
      
        this.zoomControl = new ZoomControl(this); 
        const zoomControlElement = this.zoomControl.onAdd(map);
        
        this._container.appendChild(this._settingsPopup);
        this._container.appendChild(this._offsetPopup);
        this._container.appendChild(zoomControlElement);
        
        this._popupTimer = null; 
        this._offsetPopupTimer = null;

        this._offsetPopup.querySelector('#offset-arrow-up').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapOffset('y', -1); });
        this._offsetPopup.querySelector('#offset-arrow-down').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapOffset('y', 1); });
        this._offsetPopup.querySelector('#offset-arrow-left').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapOffset('x', -1); });
        this._offsetPopup.querySelector('#offset-arrow-right').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapOffset('x', 1); });
        
        this._offsetPopup.querySelector('#pitch-arrow-up').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapPitch(1); });
        this._offsetPopup.querySelector('#pitch-arrow-down').addEventListener('click', (e) => { e.stopPropagation(); this.adjustMapPitch(-1); });
        
        const pitchDisplay = this._offsetPopup.querySelector('#pitch-value-display');
        pitchDisplay.style.cursor = 'pointer';
        pitchDisplay.title = 'Pulsar para restaurar inclinación por defecto del modo actual';
        pitchDisplay.addEventListener('click', (e) => {
            e.stopPropagation();
            triggerManualMapInteraction();

            let targetPitch = 0;
            let modeName = "Norte/Avance";

            if (mapViewMode === 'perspective') {
                targetPitch = 56;
                modeName = "3D";
            }
            
            mapPitchValue = targetPitch;
            saveSettings();
            this._map.easeTo({ pitch: targetPitch, duration: 500 });

            showToast(`Inclinación restaurada al valor por defecto del modo ${modeName} (${targetPitch}°)`, 'info');
        });
        
        const minimapCheckbox = this._offsetPopup.querySelector('#minimap-toggle-checkbox');
        minimapCheckbox.checked = showMinimapPreference;
        minimapCheckbox.addEventListener('change', (e) => {
            e.stopPropagation();
            showMinimapPreference = e.target.checked;
            saveSettings();
            showToast(`Minimapa de maniobras ${showMinimapPreference ? 'ACTIVADO' : 'DESACTIVADO'}`, 'info');
        });

        this._map.on('pitch', () => this.updatePitchDisplay());

        return this._container;
    }

    updateOffsetDisplay() {
        const displayX = this._offsetPopup.querySelector('#offset-value-display-x');
        const displayY = this._offsetPopup.querySelector('#offset-value-display-y');
        if (displayX) {
            displayX.textContent = `X : ${mapOffsetX}%`;
        }
        if (displayY) {
            displayY.textContent = `Y : ${mapOffsetY}%`;
        }
    }

    updatePitchDisplay() {
        const display = this._offsetPopup.querySelector('#pitch-value-display');
        if (display) {
            display.textContent = `${this._map.getPitch().toFixed(0)}°`;
        }
    }

    adjustMapOffset(axis, amount) {
        triggerManualMapInteraction(); 
        if (axis === 'y') {
            mapOffsetY = Math.max(-75, Math.min(75, mapOffsetY + amount));
        } else if (axis === 'x') {
            mapOffsetX = Math.max(-75, Math.min(75, mapOffsetX + amount));
        }
        this.updateOffsetDisplay();
        saveSettings();
        if (isNavigating && navigationCurrentLocation && navigationMapInstance) {
            updateInitialUserPosition(navigationCurrentLocation, navigationMapInstance);
        }
    }

    adjustMapPitch(amount) {
        triggerManualMapInteraction(); 
        const currentPitch = this._map.getPitch();
        const newPitch = Math.max(0, Math.min(85, currentPitch + amount));
        mapPitchValue = newPitch; 
        saveSettings();
        this._map.easeTo({ pitch: newPitch, duration: 300 });
       }

    toggleSettingsPopup() {
        if (this._offsetPopup.classList.contains('visible')) this.toggleOffsetPopup();
        if (this._settingsPopup.classList.contains('visible')) {
            this._settingsPopup.classList.remove('visible');
            if (this._popupTimer) { clearTimeout(this._popupTimer); this._popupTimer = null; }
        } else {
            this._settingsPopup.classList.add('visible');
            if (this._popupTimer) clearTimeout(this._popupTimer);
            this._popupTimer = setTimeout(() => { this._settingsPopup.classList.remove('visible'); this._popupTimer = null; }, 80000);
        }
    }

    toggleOffsetPopup() {
        if (this._settingsPopup.classList.contains('visible')) this.toggleSettingsPopup();
        if (this._offsetPopup.classList.contains('visible')) {
            this._offsetPopup.classList.remove('visible');
            if (this._offsetPopupTimer) { clearTimeout(this._offsetPopupTimer); this._offsetPopupTimer = null; }
        } else {
            this.updateOffsetDisplay();
            this.updatePitchDisplay();
            this._offsetPopup.classList.add('visible');
            if (this._offsetPopupTimer) clearTimeout(this._offsetPopupTimer);
            this._offsetPopupTimer = setTimeout(() => { this._offsetPopup.classList.remove('visible'); this._offsetPopupTimer = null; }, 80000);
        }
    }

    onRemove() {
        if (this.zoomControl) this.zoomControl.onRemove();
        if (this._popupTimer) clearTimeout(this._popupTimer);
        if (this._offsetPopupTimer) clearTimeout(this._offsetPopupTimer);
        if (this._container && this._container.parentNode) this._container.parentNode.removeChild(this._container);
        this._map = undefined;
    }
} 
// ===================================================================
// NOMBRE: ZoomControl (VERSIÓN FINAL Y CORREGIDA)
// RESUMEN: Su botón de zoom ahora llama a la función maestra externa `handleZoomToggleButtonClick`.
// ===================================================================
class ZoomControl {
    constructor(parentControl) {
        this.parentControl = parentControl;
    }
    onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.id = 'zoom-controls-horizontal';
        
        const zoomInBtn = document.createElement('div');
        zoomInBtn.className = 'zoom-control-button';
        zoomInBtn.textContent = '+';
        zoomInBtn.title = 'Acercar';

        const zoomOutBtn = document.createElement('div');
        zoomOutBtn.className = 'zoom-control-button';
        zoomOutBtn.textContent = '−';
        zoomOutBtn.title = 'Alejar';

        const levelDisplay = document.createElement('div');
        levelDisplay.id = 'zoom-level-display';
        levelDisplay.style.cssText = 'color: white; font-weight: bold; text-shadow: 1px 1px 2px black; min-width: 40px; text-align: center;';
        levelDisplay.textContent = map.getZoom().toFixed(1);

        const autoBtn = document.createElement('div');
        autoBtn.id = 'zoom-auto-button';
        autoBtn.className = 'zoom-control-button';
        
        const locateMeBtn = document.createElement('div');
        locateMeBtn.id = 'zoom-locate-me-button';
        locateMeBtn.className = 'zoom-control-button';
        locateMeBtn.innerHTML = `<img src="PNG/ESTASAQUI.PNG" alt="Localizar">`;
        
        const toggleBtn = document.createElement('div');
        toggleBtn.id = 'zoom-toggle-button';
        toggleBtn.className = 'zoom-control-button';
        toggleBtn.title = 'Alternar entre vista de ruta y coche';
        toggleBtn.innerHTML = `<img src="PNG/ZOOM+.PNG" alt="Toggle Zoom">`;

        const settingsBtn = document.createElement('div');
        settingsBtn.id = 'map-settings-toggle-button';
        settingsBtn.className = 'zoom-control-button';
        settingsBtn.title = 'Ajustes de mapa y vista';
        settingsBtn.innerHTML = `<img src="PNG/GPS.PNG" alt="Ajustes">`;
        
        const offsetBtn = document.createElement('div');
        offsetBtn.id = 'map-offset-toggle-button';
        offsetBtn.className = 'zoom-control-button';
        offsetBtn.title = 'Ajustar posición del coche en pantalla';
        offsetBtn.innerHTML = `<img src="PNG/picht.png" alt="Offset">`;

        this._container.appendChild(zoomInBtn);
        this._container.appendChild(levelDisplay);
        this._container.appendChild(zoomOutBtn);
        this._container.appendChild(autoBtn);
        this._container.appendChild(locateMeBtn);
        this._container.appendChild(toggleBtn);
        this._container.appendChild(settingsBtn);
        this._container.appendChild(offsetBtn);
        
        map.on('zoom', () => { levelDisplay.textContent = map.getZoom().toFixed(1); });
        
        const ZOOM_INCREMENT = 0.3;
        zoomInBtn.addEventListener('click', (e) => { e.stopPropagation(); map.easeTo({ zoom: map.getZoom() + ZOOM_INCREMENT }); });
        zoomOutBtn.addEventListener('click', (e) => { e.stopPropagation(); map.easeTo({ zoom: map.getZoom() - ZOOM_INCREMENT }); });
        
        const zoomModesCycle = { auto: 'off', off: 'route', route: 'auto' };
        let currentMode = localStorage.getItem(AUTO_ZOOM_MODE_KEY) || 'off';

        const updateAutoButtonVisuals = () => {
            autoBtn.classList.remove('active', 'route-mode');
            if (currentMode === 'auto') {
                autoBtn.textContent = 'AUTO';
                autoBtn.classList.add('active');
                autoBtn.title = 'Zoom automático por velocidad (Activado)';
            } else if (currentMode === 'route') {
                autoBtn.textContent = 'RUTA';
                autoBtn.classList.add('active', 'route-mode');
                autoBtn.title = 'Vista general de ruta (Zoom fijo a nivel 13)';
            } else { // 'off'
                autoBtn.textContent = 'AUTO';
                autoBtn.title = 'Zoom automático (Desactivado)';
            }
        };

        autoBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            currentMode = zoomModesCycle[currentMode];
            localStorage.setItem(AUTO_ZOOM_MODE_KEY, currentMode);
            
            updateAutoButtonVisuals();
            
            isManualZoomActive = false;
            if (manualZoomTimeout) clearTimeout(manualZoomTimeout);

            switch (currentMode) {
                case 'auto':
                    handleAutoZoom();
                    break;
                case 'off':
                    break;
                case 'route':
                    map.easeTo({ zoom: 13 });
                    break;
            }
        });
        
        updateAutoButtonVisuals();
        
        toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            handleZoomToggleButtonClick(toggleBtn);
        });
        
        locateMeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            handleLocateMeClick(true);
        });
        
        settingsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.parentControl.toggleSettingsPopup();
        });

        offsetBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.parentControl.toggleOffsetPopup();
        });

        return this._container;
    }
    onRemove() { if (this._container && this._container.parentNode) this._container.parentNode.removeChild(this._container); this._map = undefined; }
}
// ===================================================================
// NOMBRE: CombinedMapControl (NUEVA CLASE)
// RESUMEN: Envuelve los controles de Capas/Vista y Zoom en un único contenedor para que aparezcan juntos.
class CombinedMapControl {
    onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.className = 'mapboxgl-ctrl map-combined-controls-wrapper';

        this.layerAndViewControl = new MapLayerAndViewController();
        const layerControlElement = this.layerAndViewControl.onAdd(map);
        
        this.zoomControl = new ZoomControl();
        const zoomControlElement = this.zoomControl.onAdd(map);
        
        if (layerControlElement) {
            this._container.appendChild(layerControlElement);
        }
        if (zoomControlElement) {
            this._container.appendChild(zoomControlElement);
        }
        
        return this._container;
    }

    onRemove() {
        if (this.layerAndViewControl) this.layerAndViewControl.onRemove();
        if (this.zoomControl) this.zoomControl.onRemove();
        
        if (this._container && this._container.parentNode) {
            this._container.parentNode.removeChild(this._container);
        }
        this._map = undefined;
    }
}
    
//=======================================================        
    
    const originalToFixed = Number.prototype.toFixed;
    Number.prototype.toFixed = function(digits) {
        if (this === undefined || this === null || isNaN(this)) {
            try {
                throw new Error("Debug toFixed Call");
            } catch (e) {
            }
            return "NaN";
        }
        return originalToFixed.call(this, digits);
    };
 
    const MAP_STYLES = {
        "HÍBRIDO": "mapbox://styles/mapbox/satellite-streets-v12",
        "SATÉLITE": "mapbox://styles/mapbox/satellite-v9",
        "CALLES": "mapbox://styles/mapbox/streets-v12"
    };
    const MAP_LEGACY_NAME_MAP = {
        "Satélite + Calles": "HÍBRIDO",
        "Satélite Puro": "SATÉLITE",
        "Mapa Normal": "CALLES"
    };
    const MAP_VIEW_MODES = {
        'NORTE': {pitch: 0, bearing: 0, mode: 'static'},
        'AVANCE': {pitch: 0, bearing: null, mode: 'heading'},
        '3D': {pitch: 62, bearing: null, mode: 'perspective'}
    };
    
    let markerAnimationState = {
        animationFrameId: null,
        currentLngLat: null,
        targetLngLat: null,
        currentIconRotation: 0,
        targetIconRotation: 0,
        currentMapBearing: 0,
        targetMapBearing: 0,
        lastTimestamp: null
    };

    let isMobileSession = false;
    let processedRemindersCache = [];
    let isCacheDirty = true;
    let lastMobileSyncCheck = 0;
    let deviationCheckIntervalId = null;

    let zoomToggleMemory = null;
    let locateMeReactivationTimer = null;
    let locateMeCountdownInterval = null;
    let deviationCheckGracePeriodUntil = 0; 
    let wasSimulatingBeforeRecalc = false;
    const MAP_VIEW_OFFSET_X_KEY = 'mapView_offsetX';
    const MAP_VIEW_OFFSET_Y_KEY = 'mapView_offsetY';
    const MAP_VIEW_SHOW_MINIMAP_KEY = 'mapView_showMinimap';
    let mapOffsetX = 0;
    let mapOffsetY = 30;
    let showMinimapPreference = true;
    const MAP_VIEW_PITCH_KEY = 'mapView_pitch';
    let mapPitchValue = 56;

  
    let lastGpsUpdateTime = 0;
    const maneuverTexts = { 'turn-sharp right': 'Giro brusco a la derecha', 'turn-right': 'Gira a la derecha', 'bear-right': 'Mantente a la derecha', 'turn-sharp left': 'Giro brusco a la izquierda', 'turn-left': 'Gira a la izquierda', 'bear-left': 'Mantente a la izquierda', 'turn-': 'Gira', 'straight-straight': 'Sigue recto', 'straight-': 'Sigue recto', 'roundabout-': 'Entra en la rotonda', 'roundabout turn-': 'Toma la salida de la rotonda', 'rotary-': 'Entra en la glorieta', 'roundabout turn-left': 'En la rotonda, toma la salida hacia la izquierda', 'roundabout turn-right': 'En la rotonda, toma la salida hacia la derecha', 'roundabout turn-straight': 'En la rotonda, sigue recto', 'destination-left': 'Has llegado a tu destino  (a la izquierda)', 'destination-right': 'Has llegado a tu destino (a la derecha)', 'destination-': ' tu destino ', 'depart-': 'Inicia la ruta', 'arrive-left': 'Has llegado a tu destino (a la izquierda)', 'arrive-right': 'Has llegado a tu destino  (a la derecha)', 'arrive-': 'Has llegado a tu destino', 'continue-straight': 'Continúa recto', 'continue-': 'Continúa', 'new name-': 'Continúa por', 'fork-right': 'En la bifurcación, mantente a la derecha', 'fork-left': 'En la bifurcación, mantente a la izquierda', 'fork-': 'En la bifurcación', 'merge-left': 'Incorpórate por la izquierda', 'merge-right': 'Incorpórate por la derecha', 'merge-straight': 'Incorpórate', 'merge-': 'Incorpórate', 'end of road-left': 'Al final de la vía, gira a la izquierda', 'end of road-right': 'Al final de la vía, gira a la derecha', 'end of road-': 'Fin de la vía', 'u turn-left': 'Haz un cambio de sentido (hacia la izquierda)', 'u turn-right': 'Haz un cambio de sentido (hacia la derecha)', 'u turn-': 'Haz un cambio de sentido', 'use lane-': 'Usa el carril indicado', 'notification-': 'Atención', 'exit roundabout-': 'Sal de la rotonda', 'exit rotary-': 'Sal de la glorieta', 'off ramp-': 'Vía de salida', 'on ramp-': 'Incorporate a la vía de Entrada',};
    let distanceToNextManeuverOSRM = Infinity;
    let mapHeaderButtonsVisible = true;
    
    const MAX_SESSIONS_KEY = 'boardinggate_max_map_sessions';
    let autoStartNavModalTimer = null;
    let mapSessionStartTime = null;
    let speedMarkerFeatures = []; 
    let mapPreviousZoomLevelForPDRs = 0;
    const AUTO_ZOOM_MODE_KEY = 'boardinggate_autoZoomMode_v2';
    let isAutoZoomActive = false;
    let isManualZoomActive = false;
    let manualZoomTimeout = null;
    let mapViewMode = 'perspective'; 
    let isSimulatingFreeDrive = false; 
    let isFreeDriveActive = false;
    let isFreeDrivePaused = false;
    let freeDriveStats = null;
    let locationsPreviewMapObjects = [];
    let lastDynamicRadarCheck = 0;
    let isGeolocated = false;
    window.radarsCache = null;
    window.radarsSpatialIndex = null;
    let isRadarCacheInitializing = false;
    let lastDisplayedManeuverIcon = null;
    let chatUpdateInterval = null;
    let selectedStageRoutes = new Map();
    let alternativeRoutesCache = new Map();
    let alternativeRouteLayers = [];
    let realtimeSpeedUpdateInterval = null;
    let tripInitialDurationSec = null;
    let tripInitialDistanceMeters = null;
    let mapHeaderAutohideTimer = null;
    let tripInitialOverallEtaTime = null;
    let currentStageInitialExpectedEtaTime = null;
    let accumulatedDeviationMs = 0;
    let minAverageSpeedInTrip = Infinity;
    let maxAverageSpeedInTrip = -Infinity;

    const OCM_API_KEY = "be9a78f7-0f5e-4f28-b742-4b7ab4b7eb5a";
    const MAPBOX_ACCESS_TOKEN = "pk.eyJ1IjoiYm9hcmRpbmdnYXRlMTEiLCJhIjoiY21kOHdtMGU4MDEzaTJpcGh4cng0c3hmMiJ9.hDdGn_5VOMkN_bTuUowtRw";
    let isGraphingActive = false;
    let pdrSearchState = 'initial'; 
    let lastPdrSearchResults = []; 
    let chargingPointsLayer = null;
    let currentChargingPointsOnRoute = [];
 
    let trafficAlertsCache = [];
    let trafficAlertsMarkers = []; 
    let lastAlertCheckTimestamp = 0;
    const ALERT_CHECK_INTERVAL = 15 * 60 * 1000;
    let currentlyDisplayedProximityAlerts = new Set();
    let alertModalTimer = null;
    let proximityAlertTimer = null;

    let tripStartLocationForStats = null; 
    let stageScrollTimeout;
    let locationsPreviewMap = null;
    let globalModalTimers = {};
    const originalBookmarks = [ { name: "YouTube", url: "https://www.youtube.com" }, { name: "Google", url: "https://www.google.com" }, { name: "GDrive", url: "https://drive.google.com", favicon: "./PNG/IMG_4172.png" }, { name: "GMail", url: "https://mail.google.com/mail/mu/mp/603/#tl/Recibidos", favicon: "./PNG/IMG_4171.png"}, { name: "Google Fotos", url: "https://photos.google.com" }, { name: "iCloud", url: "https://www.icloud.com/"}, { name: "ABRP", url: "https://abetterrouteplanner.com" }, { name: "ElectroMaps", url: "https://map.electromaps.com/es/", favicon: "https://www.google.com/s2/favicons?domain=electromaps.com&sz=64" }, { name: "REVE PdR España", url: "https://www.mapareve.es/mapa-puntos-recarga", favicon: "https://www.google.com/s2/favicons?domain=mapareve.es&sz=64" }, { name: "Ver ubicaciones", url: "map-action:openRemindersMapWithNoRadars", favicon: "https://www.google.com/s2/favicons?domain=google.com/maps&sz=64" }, { name: "Google Maps", url: "https://www.google.com/maps/search/electric+vehicle+charging+stations" }, { name: "WhatsApp", url: "https://web.whatsapp.com/" }, { name: "TESSIE", url: "https://dash.tessie.com/signin", favicon: "https://www.google.com/s2/favicons?domain=tessie.com&sz=64" }, { name: "Mis Updates", url: "https://dash.tessie.com/software", favicon: "https://cdn-icons-png.flaticon.com/512/148/148767.png" }, { name: "Olas Updates", url: "https://es.stats.tessie.com/", favicon: "https://cdn-icons-png.flaticon.com/512/5815/5815902.png" }, { name: "NotaTeslaApp", url: "https://www.notateslaapp.com/software-updates/" }, { name: "ENHAUTO", url: "https://www.enhauto.com" }, { name: "MAREAS", url: "https://www.meteogalicia.gal/web/predicion/mareas-e-luas" }, { name: "ELECTROVERSE", url: "https://electroverse.com/es/map", favicon: "https://www.google.com/s2/favicons?domain=electroverse.com&sz=64" }, { name: "ACCIONA", url: "https://www.google.com/maps/search/recarga+Acciona", favicon: "https://www.google.com/s2/favicons?domain=acciona.com&sz=64" }, { name: "IBERDROLA", url: "https://www.google.com/maps/search/recarga+IBERDROLA", favicon: "https://www.google.com/s2/favicons?domain=iberdrola.com&sz=64" }, { name: "WAYLET Repsol", url: "https://www.google.com/maps/search/recarga+REPSOL+Waylet", favicon: "https://www.google.com/s2/favicons?domain=repsol.com&sz=64" }, { name: "ENDESA xWay", url: "https://www.google.com/maps/search/recarga+ENDESA+XWAY", favicon: "https://www.google.com/s2/favicons?domain=endesa.com&sz=64" }, { name: "ZUNDER", url: "https://www.google.com/maps/search/recarga+ZUNDER", favicon: "https://www.google.com/s2/favicons?domain=zunder.com&sz=64" }, { name: "IONITY", url: "https://www.google.com/maps/search/recarga+IONITY", favicon: "https://www.google.com/s2/favicons?domain=ionity.eu&sz=64" }, { name: "WENEA", url: "https://www.google.com/maps/search/recarga+WENEA", favicon: "https://www.google.com/s2/favicons?domain=wenea.com&sz=64" }, { name: "T.ENERGIES", url: "https://www.google.com/maps/search/recarga+TOTAL+ENERGIES", favicon: "https://www.google.com/s2/favicons?domain=totalenergies.com&sz=64" }, { name: "GALP", url: "https://www.google.com/maps/search/recarga+GALP", favicon: "https://www.google.com/s2/favicons?domain=galp.com&sz=64" }, { name: "MIIO", url: "https://miio.com", favicon: "https://www.google.com/s2/favicons?domain=miio.com&sz=64" }, { name: "EVDC", url: "https://evdc.network", favicon: "https://www.google.com/s2/favicons?domain=evdc.network&sz=64" }, { name: "GROK", url: "https://grok.com/?referrer=website" }, { name: "CHATGPT", url: "https://chat.openai.com" }, { name: "CLAUDE", url: "https://claude.ai/new" }, { name: "GEMINI", url: "https://gemini.google.com" }, { name: "NOTEBOOKLM", url: "https://notebooklm.google.com" }, { name: "Batería", url: "https://docs.google.com/spreadsheets/d/1bLZmgVGTBqg2bS2E45JpORjs9eK2nb05AWXYLLDY-RI/edit?gid=1398548891#gid=1398548891", favicon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='10'/><polyline points='12 6 12 12 16 14'/></svg>" }, { name: "TeslaParaTodos", url: "https://teslaparatodos.com/cine/" }, { name: "BetterTheater", url: "https://abettertheater.com", favicon: "https://www.google.com/s2/favicons?domain=abettertheater.com&sz=64" }, { name: "Filmin", url: "https://www.filmin.es/catalogo/peliculas" }, { name: "Octopus", url: "https://octopusenergy.es/login" }, { name: "App MCE", url: "https://www.oscarabilleira.com/app-mi-coche-electrico/#ayuda" }, { name: "Patrón Luz", url: "https://docs.google.com/spreadsheets/d/1R7UUZ9i4BAYWAGAX6PQT1WGd12GEZ4Ja/edit?usp=sharing&ouid=108345701896498198132&rtpof=true&sd=true" }, { name: "TradingView", url: "https://es.tradingview.com/chart/t5g9UFG0/" }, { name: "Telegram", url: "https://web.telegram.org/a/" }, { name: "Twitter", url: "https://x.com" }, { name: "Maesal Detailer", url: "https://www.maesaldetailer.es/" }, { name: "Superchargers", url: "https://www.tesla.com/es_es/findus?bounds=45.41107111786193%2C19.27853056943938%2C29.703668286784747%2C-16.64676239931062" }, { name: "TESLA web", url: "https://www.tesla.com/es_es" }, { name: "Manual M3", url: "https://www.tesla.com/ownersmanual/model3/es_es/" }, { name: "de Servicio", url: "https://service.tesla.com/docs/Model3/ServiceManual/2024/es-es/" }, { name: "de Despiece", url: "https://epc.tesla.com/es-MX/catalogs/e0e07c3d-272f-4d06-b8b6-9e92f857e5f3" }, { name: "de Usted Mismo", url: "https://www.tesla.com/es_es/support/do-it-yourself-guides" }, { name: "de Filtro Cabina", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-DB0A1E3C-926E-498C-A2FD-A27B8421A471.html" }, { name: "de Móvil remoto", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-53651B16-A2E3-4118-933E-B5F41C74D433.html" }, { name: "Waze (consultas)", url: "https://www.waze.com/es/live-map/", favicon: "https://www.google.com/s2/favicons?domain=waze.com&sz=64" }, { name: "AMAZON", url: "https://www.amazon.es" }, { name: "BIP&DRIVE", url: "https://areaprivada.bipdrive.com/login" }, { name: "ITV Cita", url: "https://www.sycitv.com/es/cita-previa-particulares/", favicon: "https://boardinggate.github.io/Tesla/PNG/itv.png" }, { name: "Deportes", url: "https://www.sofascore.com/es/tenis" }, null, { name: "Jaime Odena", url: "https://www.youtube.com/@Jaimeodena", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Eduardo Arcos", url: "https://www.youtube.com/@earcos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "AutoIngenium", url: "https://www.youtube.com/@AutoIngenium", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Gallego en Munich", url: "https://www.youtube.com/@ungallegoenmunich", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Electromiaumiau", url: "https://www.youtube.com/@electromiaumiau", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Manuel Martos", url: "https://www.youtube.com/@Manuel_Martos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Todos Electricos", url: "https://www.youtube.com/@TodosElectricos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Juan Vidal Haces", url: "https://www.youtube.com/@JuanVidalHaces", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Ruedana", url: "https://www.youtube.com/@ruedana", favicon: "https://www.youtube.com/favicon.ico" }, { name: "STR-600", url: "https://www.youtube.com/@STR-600", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Juanjo T. Aventuras", url: "https://www.youtube.com/@juanjoteslaventuras", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Carlos Cuezva", url: "https://www.youtube.com/@CarlosCuezva", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Javi Manzanoo", url: "https://www.youtube.com/@javimanzanoo", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Crifedi", url: "https://www.youtube.com/@Crifedi", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Tescno Tesla", url: "https://www.youtube.com/@TecnoTesla", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Full Electric Mex", url: "https://www.youtube.com/@FullElectricMexico", favicon: "https://www.youtube.com/favicon.ico" }, null, null, { name: "La iA Jon", url: "https://www.youtube.com/@la_inteligencia_artificial", favicon: "https://www.youtube.com/favicon.ico" }, { name: "JF Ccalero", url: "https://www.youtube.com/@jfcalero", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Visual Politik", url: "https://www.youtube.com/@VisualPolitik", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Fabian Barrio", url: "https://www.youtube.com/@fabiancbarrio", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Loquetudigas", url: "https://www.youtube.com/@Loquetudigas", favicon: "https://www.youtube.com/favicon.ico" }, { name: "David Antunes", url: "https://www.youtube.com/@davidantunesmusic", favicon: "https://www.youtube.com/favicon.ico" }, { name: "TheWildProject", url: "https://www.youtube.com/@TheWildProject", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Estas Tonne", url: "https://www.youtube.com/@Estastonne", favicon: "https://www.youtube.com/favicon.ico" }, { name: "BBC6 Music", url: "https://www.youtube.com/@BBC6Music", favicon: "https://www.youtube.com/favicon.ico" }, null, null ];
    const originalToggleRanges = [ { start: 18, end: 29, name: "ELECTROVERSE", label: "PdR,s" }, { start: 30, end: 41, name: "GROK", label: "iAs" }, { start: 42, end: 59, name: "TradingView", label: "Útil" }, { start: 60, end: 95, name: "Jaimeodena", label: "Varios" } ];
    const sectionColors = { 18: '#F0E0D3', 30: '#D8D4E0', 42: '#D9E5DB', 60: '#F2ECD0', unassigned: '#C5C8B8', off: '#ABAB99' };
    const darkModeGenericButtonColor = '#ABAB99';
    const DEFAULT_LOCATION_RADIUS = 450;
    let snoozedRouteRadars = new Map();
    const MAP_SEARCH_INPUT_KEY = 'boardinggate_map_search_value';
    let gpsRetryTimeoutId = null;
    let gpsRetryAttempt = 0;
    const MAX_GPS_RETRIES = 10;
    const GPS_RETRY_DELAY_MS = 5000;
    let isMapImmersiveModeActive = false;
    let isArrivalSequenceStarted = false;
    let maxSpeedCoordinates = null;
    let progressiveZoomState = 'none';
    let mapPreviousZoomLevelForProgressive = null;
    let lastProcessedStepIdentifier = null;
    const PROGRESSIVE_ZOOM_START_DISTANCE = 180;
    const PROGRESSIVE_ZOOM_PEAK_DISTANCE = 50;
    const PROGRESSIVE_ZOOM_EXIT_START_DISTANCE = 60;
    const PROGRESSIVE_ZOOM_EXIT_END_DISTANCE = 150;
    let isZoomedForManeuver = false;
    let isFlying = false;
    let navigationTargetZoom = null;
    let currentSmoothedMapCenter = null;
    let lastMobileSyncTimestamp = 0;
    const TOTAL_CELLS = 96; const COLS = 6; const grid = document.getElementById('bookmark-grid');
    let isDarkMode = false; let pressStartTime = null; let reminderPressStartTime = null; let isActive = true; let isFooterVisible = true; let notices = []; let currentNoticeIndex = 0; let fromReminderModal = false;
    let isEditMode = false; let isAssignmentMode = false;
    let isKeywordAssignmentMode = false;
    let currentlyAssigningToggleStart = null;
    let customData = { bookmarks: {}, toggles: {} };
    let cellElements = []; let toggleButtonElements = {}; let currentBookmarks = []; let currentToggleRanges = [];
    let onOffToggle, weatherButton, reminderButton, zoomButton, darkModeToggle, versionsButton, infoButton;
    let radarButton;
    let firstPersonalizationSession = !sessionStorage.getItem('personalizationHelpShown');
    let editingTargetElement = null; let draggedItem = null; let draggedItemIndex = null; let dragOverIndex = null;
    let touchStartX = 0; let touchStartY = 0; let currentTouchTarget = null;
    let isPasswordActive = false; let storedPin = null;
    let reminderCheckIntervalId = null;
    let currentCheckIntervalDuration = 3000;
    let lastUpdatesCheckDate = localStorage.getItem('lastUpdatesCheckDate');
    let currentNotificationSlideIndex = 0;
    let isUnifiedWindowVisibleByLogic = false;
    let reminderModalMap = null;
    let reminderMarker = null;
    let reminderCircle = null;
    let previewMaps = {};
    const MAX_SAVED_LOCATIONS = 15;
    const SAVED_LOCATIONS_KEY = 'boardinggate_saved_locations';
    const MAP_VIEW_MODE_KEY = 'mapViewMode_v1';
    const SHOW_EXCLUDED_REMINDERS_KEY = 'boardinggate_showExcludedRemindersInTable';
    const RADARES_RUTA_CHECKED_KEY = 'boardinggate_radaresRutaCheckboxChecked';
    const TAREAS_RUTA_CHECKED_KEY = 'boardinggate_tareasRutaCheckboxChecked';
    const ACTIVE_MAP_LAYER_KEY = 'boardinggate_activeMapLayer';
    const DIRECT_TO_NAVIGATION_KEY = 'boardinggate_directToNavigation';
    const MAP_ENTRY_OVERRIDE_KEY = 'boardinggate_map_entry_override';
    const TEMP_PREVENT_DIRECT_NAV_KEY = 'tempPreventDirectNavAfterMapExit';
    const GRAPH_STATE_KEY = 'boardinggate_graphState';
    let locationPickerMap = null;
    let locationPickerMarker = null;
    let currentEditingLocationSlotIndex = -1;
    let tempSavedLocations = [];
    let navigationMapInstance = null;
    let isNavigationMapActive = false;
    let initialUserLocationMarker = null;
    let initialUserLocationMarkerLat = null;
    let initialUserLocationMarkerLng = null;
    let navigationCurrentLocation = null;
    let locationWatchId = null;
    let shouldCenterOnUser = false;
    let navigationFollowUser = false;
    let mapPreviousZoomLevel = null;
    const MIN_MANEUVER_ZOOM_LEVEL = 17;
    let currentMapBearing = 0;
    let currentMapRotationAngle = 0;
    let currentMapCenterOffset = { x: 0, y: 0 };
    let targetMapCenterOffset = { x: 0, y: 0 };
    let mapOffsetAnimationId = null;
    let miniMapOffsetActive = { x: 0, y: 0 };
    let lastHeadingForTilt = 0;
    let compassAndModeControl = null;
    let navigationWaypoints = [];
    let navigationRouteLayer = null;
    let navigationCurrentRouteData = null;
    let isNavigating = false;
    let routeStartTime = null;
    let navigationStartTimeForStats = null;
    let totalDistanceTravelledForStats = 0;
    let accumulatedDistanceBeforeCurrentSegment = 0;
    let lastPositionForStats = null;
    let maxDistanceReachedOnRoute = 0; 
    let maxSpeedDuringTrip = 0;
    let maxAltitudeDuringTrip = -Infinity;
    let minAltitudeDuringTrip = Infinity;
    window.lastPositionForSpeedCalc = null;
    window.currentSpeedKmh = 0;
    window.averageSpeedKmh = 0;
    let isSimulatingGpsLocation = false;
    let simulatedGpsLocation = null;
    let automatedSimulationIntervalId = null;
    let simulatedDistanceAlongRoute = 0;
    let simulationSpeedKmph = 85;
    let currentSimulationSpeedKmph = 85; 
    const SIMULATION_TICK_INTERVAL_MS = 300;
    const AUTO_ZOOM_ACTIVE_KEY = 'boardinggate_autoZoomActive';
    let completedSegmentsGeoJSON = { type: 'FeatureCollection', features: [] }; 
    let maxSpeedMarkerObjects = []; 
    let speedMilestoneMarkerObjects = []; 
    let lastSpeedMilestone = 0;
    const SPEED_MILESTONES = [55, 65, 125, 135, 150];
    const OSRM_SERVICE_URL = 'https://router.project-osrm.org/route/v1';
    const SAVED_ROUTES_KEY = 'boardinggate_saved_routes';
    const MAX_SAVED_ROUTES = 100;
    let currentRouteNameForSaving = null;
    let navigationMapClickHandler = null;
    let draggedStageLi = null;
    const DEVIATION_THRESHOLD_METERS = 60;
    const DEVIATION_MIN_TIME_SECONDS = 0.3;
    let deviationStartTime = 0;
    let isRecalculatingRoute = false;
    let deviationModalTimerId = null;
    let isDeviationModalActive = false;
    const WAYPOINT_VISITED_THRESHOLD_METERS = 70;
    let currentLegIndexNav = 0;
    let currentStepIndexNav = 0;
    let lastCarDistanceAlongRouteForNavLogic = 0;
    let lastValidCarDistanceForDisplay = 0;
    let lastProcessedStepManeuverLocation = null;
    let recalculationRetryTimeoutId = null;
    let recalculationAttempts = 0;
    let isAddReminderAtLocationModeActive = false;
    let addReminderAtLocationButton = null;
    let simulationModalTimer = null;
    let autoStartNavTimer = null;
    let mapLayersControl = null;
    let searchToastShown = false;
    let pendingPositionToProcess = null;
    const KML_FILES_LIST_STANDARD = './KLM/KLMFILES.TXT';
    const KML_FILES_LIST_EXTRA = './KLM/KLMFILES2.TXT';
    const KML_BASE_PATH = './KLM/';
    const COORD_EPSILON = 0.00001;
    const RUTA_RADAR_PROXIMITY_THRESHOLD = 75;
    let reminderMapObjects = [];
    let radaresEnRutaActual = [];
    let tareasEnRutaActual = [];
    const STATIC_MODAL_IDS = ['config-modal', 'versions-modal-overlay', 'pin-modal-overlay', 'reorder-stages-modal', 'simulation-modal', 'locations-preview-modal', 'deviation-modal', 'arrival-stats-modal', 'simulation-speed-modal'];
    let activeToasts = [];
    let intersectionPreviewMap = null;
    let intersectionPreviewRouteLayer = null;
    let intersectionPreviewManeuverMarker = null;
    let intersectionPreviewCarMarker = null;
    let intersectionPreviewTimer = null;
    let lastAutoShownManeuverId = null;
    let directToNavOnLoad = false;
    let mapLayersControlLocationsPreview = null;
    let navigationChart = null;
    let currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviación Ruta';
    let graphPlotState = { lastPlotTime: null, lastPlotCoords: null };
    let graphIntervalDuration = 0; 
    let graphIntervalTimer = null;
    let graphDataPoints = { speed: [], altitude: [] };
    let graphLabels = [];
    let graphExpectedAvgSpeed = 0;
    let isCarStoppedForGraph = false; 
    const GRAPH_PIXELS_PER_DATAPOINT = 2; 
    const GRAPH_BUFFER_PERCENTAGE = 0.15;
    const MAP_FILTER_INPUT_KEY = 'boardinggate_map_filter_value';
    const PROGRESS_BAR_LOCKED_KEY = 'boardinggate_progressBarLocked';
    let isProgressBarLocked = false;
    let progressBarForceShowUntil = 0;
    let lastProcessedStepForLock = null;
  
    const managedKeys = [ 'reminders','darkMode','toggleStates','zoomState','onOffState','noticesActive', 'footerVisible','teslaHtmlLastModified','teslaHtmlLastModifiedTimestamp', 'userData_userId','userData_teslaModel','userData_teslaYear','userData_teslaProvince', 'userData_allowDMs', 'customGridData', 'personalizationHelpShown', 'gridFilterValue',  'password_pin', 'password_active', 'lastUpdatesCheckDate', SAVED_LOCATIONS_KEY,  SHOW_EXCLUDED_REMINDERS_KEY, SAVED_ROUTES_KEY, RADARES_RUTA_CHECKED_KEY,  TAREAS_RUTA_CHECKED_KEY, ACTIVE_MAP_LAYER_KEY, DIRECT_TO_NAVIGATION_KEY, GRAPH_STATE_KEY, 'boardinggate_autoBackupOnLoad', 'userData_backupPassword', MAP_SEARCH_INPUT_KEY, 'mapViewMode_v1', MAP_FILTER_INPUT_KEY, PROGRESS_BAR_LOCKED_KEY,  MAP_VIEW_OFFSET_X_KEY,MAP_VIEW_OFFSET_Y_KEY,  MAP_VIEW_SHOW_MINIMAP_KEY, MAP_VIEW_PITCH_KEY  ];
    const managedDesc = managedKeys.map(k => {
            switch(k){
                case 'reminders':return 'Recordatorios'; case 'darkMode':return 'Modo Oscuro'; case 'toggleStates':return 'Visibilidad Secc.';
                case 'zoomState':return 'Zoom Grid'; case 'onOffState':return 'On/Off Gral'; case 'noticesActive':return 'Avisos/Footer';
                case 'footerVisible':return 'Vis. Footer'; case 'teslaHtmlLastModified':return 'Cache Versión'; case 'teslaHtmlLastModifiedTimestamp':return 'TS Cache';
                case 'userData_userId':return 'ID Usuario'; case 'userData_teslaModel':return 'Modelo'; case 'userData_teslaYear':return 'Año';
                case 'userData_teslaProvince':return 'Provincia'; case 'userData_allowDMs':return 'Permitir DMs'; case 'customGridData': return 'Grid Pers.';
                case 'personalizationHelpShown': return 'Ayuda Pers. Vista'; case 'gridFilterValue': return 'Filtro Grid';
                case 'password_pin': return 'PIN Acceso'; case 'password_active': return 'PIN Activo'; case 'lastUpdatesCheckDate': return 'Cache Fecha Updates';
                case SAVED_LOCATIONS_KEY: return 'Ubicaciones Guardadas';
                case SHOW_EXCLUDED_REMINDERS_KEY: return 'Mostrar Excluidos Tabla';
                case SAVED_ROUTES_KEY: return 'Rutas Guardadas';
                case RADARES_RUTA_CHECKED_KEY: return 'Check Radares Ruta';
                case TAREAS_RUTA_CHECKED_KEY: return 'Check Tareas Ruta';
                case ACTIVE_MAP_LAYER_KEY: return 'Capa de Mapa Activa';
                case DIRECT_TO_NAVIGATION_KEY: return 'Directo a Navegación';
                case GRAPH_STATE_KEY: return 'Estado Gráfica';
                case MAP_SEARCH_INPUT_KEY: return 'Buscador Mapa (Principal)';
                case MAP_FILTER_INPUT_KEY: return 'Buscador Mapa (Filtro)';
                default:return k;
            }
        }).join(', ');

// ===================================================================
// NOMBRE: updateDynamicRadars (MODIFICADA - Lógica de Navegación vs. Radio)
// RESUMEN: Carga radares dinámicos según el contexto (en ruta o en radio).
async function updateDynamicRadars(isInitialLoadCheck = false) {
    const nowDate = new Date();
    const now = nowDate.getTime();
    const timeSinceLastCheck = now - lastDynamicRadarCheck;
    if (isInitialLoadCheck) {
        const hasExistingDynamicRadars = processedRemindersCache.some(r => r.isDynamicRadar === true);
        if (timeSinceLastCheck < 30 * 60 * 1000 && hasExistingDynamicRadars) return;
    }
    lastDynamicRadarCheck = now;
    if (!isInitialLoadCheck) showToast("Actualizando radares dinámicos...", "info", 3000, false, "radar-update");

    if (!window.radarsCache || !window.radarsSpatialIndex) {
        await initializeRadarCache();
        if (!window.radarsCache) {
            showToast("No se pudo inicializar la base de datos de radares.", "error");
            return;
        }
    }
    
    try {
        let newRadars = [];
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]').filter(r => !r.isDynamicRadar);
        
        const routeSource = navigationMapInstance?.getSource('route');
        if (routeSource && routeSource._data && routeSource._data.geometry && routeSource._data.geometry.coordinates.length > 1) {
            const originalCheckboxState = document.getElementById('radares-ruta-checkbox').checked;
            await toggleRadaresRuta(true); // Forzamos la carga de radares en ruta
            newRadars = [...radaresEnRutaActual];
            
            if (!originalCheckboxState) {
                document.getElementById('radares-ruta-checkbox').checked = false;
                eliminarRadaresDeRuta(); // Limpiamos los marcadores visuales si no se quieren ver
            }
        } else {
            let coords = null;
            if (navigationCurrentLocation && (Date.now() - lastGpsUpdateTime < 30000)) {
                coords = navigationCurrentLocation;
            } else {
                coords = await getCurrentLocationAsync();
            }
            if (!coords) throw new Error("Ubicación del vehículo no disponible.");

            const DYNAMIC_RADAR_SEARCH_RADIUS_KM = 45;
            const candidateRadars = new Set();
            const R = 6371;
            const rad = DYNAMIC_RADAR_SEARCH_RADIUS_KM / R;
            const latRad = coords.latitude * Math.PI / 180;
            const GRID_SIZE = 0.1;

            const latMin = coords.latitude - (rad * 180 / Math.PI);
            const latMax = coords.latitude + (rad * 180 / Math.PI);
            const deltaLon = Math.asin(Math.sin(rad) / Math.cos(latRad));
            const lonMin = coords.longitude - (deltaLon * 180 / Math.PI);
            const lonMax = coords.longitude + (deltaLon * 180 / Math.PI);
            
            const latIndexMin = Math.floor(latMin / GRID_SIZE);
            const latIndexMax = Math.floor(latMax / GRID_SIZE);
            const lonIndexMin = Math.floor(lonMin / GRID_SIZE);
            const lonIndexMax = Math.floor(lonMax / GRID_SIZE);
            
            for (let i = latIndexMin; i <= latIndexMax; i++) {
                for (let j = lonIndexMin; j <= lonIndexMax; j++) {
                    const cellId = `cell_${i}_${j}`;
                    if (window.radarsSpatialIndex[cellId]) {
                        window.radarsSpatialIndex[cellId].forEach(radar => candidateRadars.add(radar));
                    }
                }
            }

            candidateRadars.forEach(radar => {
                const distance = calculateDistance(coords.latitude, coords.longitude, radar.lat, radar.lon);
                if (distance <= (DYNAMIC_RADAR_SEARCH_RADIUS_KM * 1000)) {
                    newRadars.push({
                        id: Date.now() + Math.random() + newRadars.length,
                        text: `<b>RADAR: ${radar.name}</b>`,
                        type: 'simple', time: '00:01',
                        date: `${nowDate.getFullYear()}-${(nowDate.getMonth() + 1).toString().padStart(2, '0')}-${nowDate.getDate().toString().padStart(2, '0')}`,
                        createdAt: nowDate.toISOString(), managedByUser: false,
                        isLocationEnabled: true, locationCoordinates: { latitude: radar.lat, longitude: radar.lon },
                        radiusMeters: 400, excludeFromList: true,
                        isDynamicRadar: true
                    });
                }
            });
        }
        
        reminders.push(...newRadars);
        localStorage.setItem('reminders', JSON.stringify(reminders));
        markRemindersCacheAsDirty();
        
        if (isNavigationMapActive) {
            plotRemindersOnNavigationMap();
        }
        updateReminderCount();
        updateButtonStyles();

    } catch (error) {
        showToast(`Error al actualizar radares: ${error.message}`, "error");
    }
}
// ===================================================================
// NOMBRE: toggleRadaresRuta (VERSIÓN FINAL ANTI-DUPLICADOS Y CON CONTEO COMPLETO)
// RESUMEN: Activa/desactiva la visualización de radares en la ruta, unificando dinámicos y manuales sin duplicados.
async function toggleRadaresRuta(activo) {
    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(activo));

    if (actualWaypoints.length < 2) {
        if (activo) showToast("Ruta inválida o inexistente. No se pueden buscar radares.", "warning");
        eliminarRadaresDeRuta();
        actualizarContadorRadares(0);
        return;
    }
    
    eliminarRadaresDeRuta();
    radaresEnRutaActual = [];

    if (activo && navigationMapInstance && navigationMapInstance.getSource('route') && navigationMapInstance.getSource('route')._data) {
        try {
            if (!window.radarsCache) await initializeRadarCache();
            if (!window.radarsCache) throw new Error("Base de datos de radares no disponible.");

            const routeLineString = turf.lineString(navigationMapInstance.getSource('route')._data.geometry.coordinates);
            
            // --- PASO 1: "Adoptar" todos los radares existentes en la caché que estén en la ruta ---
            processedRemindersCache.forEach(reminder => {
                const isRadarType = (reminder.text.toUpperCase().includes("RADAR") || reminder.excludeFromList);
                if (isRadarType && reminder.isLocationEnabled && reminder.locationCoordinates) {
                    const radarPoint = turf.point([reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]);
                    const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, radarPoint, { units: 'meters' });

                    if (nearestPointOnRoute.properties.dist <= RUTA_RADAR_PROXIMITY_THRESHOLD) {
                        radaresEnRutaActual.push({
                            ...reminder,
                            isFromRuta: true,
                            distanceOnRoute: nearestPointOnRoute.properties.location
                        });
                    }
                }
            });

            // --- PASO 2: Buscar nuevos radares KML que no estén ya en la caché ---
            const intersectingCells = new Set();
            const routeCoords = routeLineString.geometry.coordinates;
            for (let i = 0; i < routeCoords.length; i++) {
                intersectingCells.add(getGridCellId(routeCoords[i][1], routeCoords[i][0]));
            }
            const cellsToSearch = new Set(intersectingCells);
            intersectingCells.forEach(cellId => {
                const [_, latIdx, lonIdx] = cellId.split('_').map(Number);
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        cellsToSearch.add(`cell_${latIdx + i}_${lonIdx + j}`);
                    }
                }
            });

            const candidateRadars = [];
            cellsToSearch.forEach(cellId => {
                if (window.radarsSpatialIndex[cellId]) candidateRadars.push(...window.radarsSpatialIndex[cellId]);
            });
            const uniqueCandidates = [...new Set(candidateRadars)];
            
            let newRadarsAddedToLocalStorage = false;
            let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');

            uniqueCandidates.forEach(radar => {
                const radarPoint = turf.point([radar.lon, radar.lat]);
                const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, radarPoint, { units: 'meters' });

                if (nearestPointOnRoute.properties.dist <= RUTA_RADAR_PROXIMITY_THRESHOLD) {
                    const radarYaExisteEnCache = processedRemindersCache.some(rem => 
                        rem.isLocationEnabled && rem.locationCoordinates &&
                        Math.abs(rem.locationCoordinates.latitude - radar.lat) < COORD_EPSILON &&
                        Math.abs(rem.locationCoordinates.longitude - radar.lon) < COORD_EPSILON
                    );

                    if (!radarYaExisteEnCache) {
                        const now = new Date();
                        const dateStr = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
                        const timeStr = '00:00';
                        
                        // *** INICIO DE LA CORRECCIÓN: Calcular dueTimeUTC al crear ***
                        const dueTimeObject = new Date(`${dateStr}T${timeStr}:00Z`);
                        const dueTimeUTCValue = isNaN(dueTimeObject.getTime()) ? null : dueTimeObject.getTime();
                        // *** FIN DE LA CORRECCIÓN ***

                        const radarData = {
                            id: Date.now() + Math.random() + radaresEnRutaActual.length,
                            text: `<b>RADAR RUTA: ${radar.name}</b>`,
                            type: 'simple', time: timeStr,
                            date: dateStr,
                            createdAt: now.toISOString(),
                            managedByUser: false, isLocationEnabled: true,
                            locationCoordinates: { latitude: radar.lat, longitude: radar.lon },
                            radiusMeters: 350, excludeFromList: true,
                            isFromRuta: true,
                            isDynamicRadar: true,
                            distanceOnRoute: nearestPointOnRoute.properties.location,
                            dueTimeUTC: dueTimeUTCValue // <-- AÑADIR LA PROPIEDAD PRE-CALCULADA
                        };
                        
                        remindersFromStorage.push(radarData);
                        radaresEnRutaActual.push(radarData);
                        newRadarsAddedToLocalStorage = true;

                        const mapObject = plotSingleReminderOnMap(radarData, navigationMapInstance);
                        if (mapObject) reminderMapObjects.push(mapObject);
                    }
                }
            });

            if (newRadarsAddedToLocalStorage) {
                localStorage.setItem('reminders', JSON.stringify(remindersFromStorage));
                markRemindersCacheAsDirty();
            }

        } catch (error) {
            showToast(`Error al procesar radares en ruta: ${error.message}`, "error");
        }
    }

    actualizarContadorRadares(radaresEnRutaActual.length);
    if (navigationCurrentRouteData?.routes?.[0]) {
        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
    if (radaresRutaCheckbox) {
        radaresRutaCheckbox.checked = activo;
    }
}

// ===================================================================
// NOMBRE: checkReminders (VERSIÓN OPTIMIZADA FINAL)
// RESUMEN: Bucle optimizado que usa la caché, la ubicación GPS existente y filtra por relevancia de ruta.
async function checkReminders() {
    const now = Date.now();

    // TAREA 1: Sincronización Móvil (optimizado)
    if (isMobileSession && (now - lastMobileSyncCheck > 6000)) {
        lastMobileSyncCheck = now;
        const { primaryId } = parseUserId(localStorage.getItem('userData_userId'));
        const autoSyncEnabled = JSON.parse(localStorage.getItem('boardinggate_autoBackupOnLoad') || 'false');
        const backupPassword = localStorage.getItem('userData_backupPassword');

        if (autoSyncEnabled && primaryId && backupPassword) {
            const localTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');
            if (localTimestamp > lastMobileSyncTimestamp) {
                autoSaveFromMobile(primaryId, backupPassword);
                lastMobileSyncTimestamp = localTimestamp;
            }
        }
    }

    // TAREA 2: Carga de Radares Dinámicos
    if (!isNavigating) {
        const timeSinceLastCheck = now - lastDynamicRadarCheck;
        const hasExistingDynamicRadars = processedRemindersCache.some(r => r.isDynamicRadar === true);
        if (timeSinceLastCheck > 30 * 60 * 1000 || !hasExistingDynamicRadars) {
            updateDynamicRadars(true);
        }
    }
    
    // TAREA 4: Gestión de la Caché
    if (isCacheDirty) {
        rebuildProcessedRemindersCache();
        // >>> ¡CORRECCIÓN CLAVE! <<<
        // Forzamos la salida del bucle actual. La próxima ejecución de checkReminders
        // (en el siguiente intervalo) ya trabajará con la caché limpia y actualizada.
        return; 
    }
    
    // TAREA 5: Bucle Principal de Comprobación
    const overdueReminders = [];
    let coords = navigationCurrentLocation;

    if (!coords && (processedRemindersCache.some(r => r.isLocationEnabled) || !isNavigating)) {
        coords = await getCurrentLocationAsync().catch(() => null);
    }
    
    const nowTime = now;
    let isNearActiveLocationPoint = false; 
    let remindersToCheck = [];

    // --- LÓGICA DE FILTRADO UNIFICADA ---
    if (isNavigating) {
        remindersToCheck = [...tareasEnRutaActual, ...radaresEnRutaActual];
        processedRemindersCache.forEach(reminder => {
            if (!reminder.isLocationEnabled) {
                remindersToCheck.push(reminder);
            }
        });
        remindersToCheck = remindersToCheck.filter((r, index, self) => 
            index === self.findIndex(t => t.id === r.id)
        );
    } else {
        remindersToCheck = processedRemindersCache;
    }
    
    remindersToCheck.forEach(reminder => {
        if (!reminder) return;
        
        if (coords && reminder.isLocationEnabled && reminder.locationCoordinates) {
            const distance = calculateDistance(coords.latitude, coords.longitude, reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude);
            if (distance <= (reminder.radiusMeters || DEFAULT_LOCATION_RADIUS)) {
                isNearActiveLocationPoint = true;
            }
        }

        if (reminder.managedByUser) return;

        let isOverdue = false;
        let locationConditionMet = true;

        const dueTime = reminder.dueTimeUTC;

        if (dueTime && dueTime <= nowTime) {
            if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                if (coords) {
                    const distance = calculateDistance(coords.latitude, coords.longitude, reminder.locationCoordinates.latitude, reminder.locationCoordinates.longitude);
                    locationConditionMet = distance <= (reminder.radiusMeters || DEFAULT_LOCATION_RADIUS);
                } else {
                    locationConditionMet = false;
                }
            }
            if (locationConditionMet) {
                isOverdue = true;
            }
        }

        if (isOverdue && !overdueReminders.some(r => r.id === reminder.id)) {
            overdueReminders.push(reminder);
        }
    });
    
    if (overdueReminders.length > 0) {
        displayUnifiedReminderWindow(overdueReminders);
    } else if (isUnifiedWindowVisibleByLogic) {
        hideUnifiedReminderWindow();
    }

    // TAREA 6: Actualizar UI y ajustar intervalo
    updateReminderCount();
    updateButtonStyles();

     let newInterval;
    const speed = window.currentSpeedKmh || 0;
        if (isNearActiveLocationPoint) {
        newInterval = 1000;
    } else if (speed > 115) {
        newInterval = 4000;
    } else if (speed > 90) {
        newInterval = 5000;
    } else if (speed > 65) {
        newInterval = 6000;
    } else if (speed > 40) {
        newInterval = 8000;
    } else if (speed > 5) {
        newInterval = 10000;
    } else {
        newInterval = 13000;
    }

    if (newInterval !== currentCheckIntervalDuration) {
        currentCheckIntervalDuration = newInterval;
        if (reminderCheckIntervalId) clearInterval(reminderCheckIntervalId);
        reminderCheckIntervalId = setInterval(checkReminders, currentCheckIntervalDuration);
    }
}

// ===================================================================
// NOMBRE: toggleTareasRuta (VERSIÓN OPTIMIZADA Y CORREGIDA PARA MAPBOX)
// RESUMEN: Muestra tareas en la ruta. Optimizado para evitar recalculos innecesarios.
async function toggleTareasRuta(activo) {
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(activo));
    
    if (actualWaypoints.length < 2) {
        if (activo) {
            showToast("Ruta inválida o inexistente. No se pueden buscar tareas en ruta.", "warning");
        }
        eliminarTareasDeBarraProgreso();
        actualizarContadorTareas(0);
        return;
    }
    
    eliminarTareasDeBarraProgreso();
    tareasEnRutaActual = [];

    if (activo && navigationMapInstance) {
        const routeSource = navigationMapInstance.getSource('route');
        if (!routeSource || !routeSource._data || !routeSource._data.geometry || !routeSource._data.geometry.coordinates || routeSource._data.geometry.coordinates.length < 2) {
            if (activo) showToast("Geometría de ruta no disponible para buscar tareas.", "warning");
            actualizarContadorTareas(0);
            return;
        }

        try {
            const routeLineString = turf.lineString(routeSource._data.geometry.coordinates);
            const allReminders = JSON.parse(localStorage.getItem('reminders') || '[]');
            
            const locationReminders = allReminders.filter(r => {
                if (!r.isLocationEnabled || !r.locationCoordinates) {
                    return false; // Debe tener ubicación
                }
                const isRadarType = r.text.toUpperCase().includes("RADAR") || r.excludeFromList;
                return !isRadarType;
            });
           
            locationReminders.forEach(reminder => {
                const taskPoint = turf.point([reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]);
                const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, taskPoint, { units: 'meters' });
                const radius = reminder.radiusMeters || DEFAULT_LOCATION_RADIUS;
                
                if (nearestPointOnRoute && nearestPointOnRoute.properties.dist !== undefined && nearestPointOnRoute.properties.dist <= radius) {
                    const taskData = {
                        ...reminder,
                        distanceOnRoute: nearestPointOnRoute.properties.location * 1000
                    };
                    tareasEnRutaActual.push(taskData);
                    
                    const isRadarTask = reminder.text.toUpperCase().includes("RADAR");
                    if (isRadarTask) {
                        const existingMapObject = reminderMapObjects.find(obj => obj.reminderId === reminder.id);
                        if (!existingMapObject) {
                           const mapObject = plotSingleReminderOnMap({...reminder, isFromTarea: true}, navigationMapInstance);
                           if (mapObject) reminderMapObjects.push(mapObject);
                        }
                    }
                }
            });
        } catch (error) {
             showToast("Error al procesar tareas en ruta: " + error.message, "error");
        }
    }

    actualizarContadorTareas(tareasEnRutaActual.length);
    if (navigationCurrentRouteData?.routes?.[0]) {
        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
    if (tareasRutaCheckbox) {
        tareasRutaCheckbox.checked = activo;
    }
}





    
    
    
// ===================================================================
// NOMBRE: markRemindersCacheAsDirty (NUEVA FUNCIÓN)
// RESUMEN: Marca la caché de recordatorios en memoria como "sucia" para forzar su reconstrucción.
function markRemindersCacheAsDirty() {
    isCacheDirty = true;
}

// ===================================================================
// NOMBRE: rebuildProcessedRemindersCache (NUEVA FUNCIÓN)
// RESUMEN: Procesa y cachea los recordatorios desde localStorage para optimizar las comprobaciones.
function rebuildProcessedRemindersCache() {
    try {
        const allReminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        const now = new Date();
        processedRemindersCache = allReminders.map(reminder => {
            let dueTimeUTC = null;
            if (reminder.date && reminder.time) {
                try {
                    const [year, month, day] = reminder.date.split('-').map(Number);
                    const [hour, minute] = reminder.time.split(':').map(Number);
                    
                    // --- INICIO DE LA CORRECCIÓN CLAVE: Usar fecha/hora local ---
                    // En lugar de Date.UTC, creamos la fecha directamente en la zona horaria del navegador.
                    // Esto asegura que "16:15" se interprete como "16:15" en tu hora local, no en UTC.
                    const dueDate = new Date(year, month - 1, day, hour, minute);
                    // --- FIN DE LA CORRECCIÓN CLAVE ---

                    if (!isNaN(dueDate.getTime())) {
                        dueTimeUTC = dueDate.getTime();
                    }
                } catch (e) {
                    // Ignorar fechas inválidas
                }
            }
            return { ...reminder, dueTimeUTC: dueTimeUTC };
        });
        isCacheDirty = false;
        console.log(`[CACHE] Caché de recordatorios reconstruida con ${processedRemindersCache.length} elementos.`);
    } catch (e) {
        console.error("Error al reconstruir la caché de recordatorios:", e);
        processedRemindersCache = [];
    }
}
// ===================================================================
// NOMBRE: startDeviationChecker (NUEVA FUNCIÓN)
// RESUMEN: Inicia un temporizador dedicado para la comprobación de desvío de ruta.
function startDeviationChecker() {
    stopDeviationChecker(); // Asegura que no haya intervalos duplicados
    console.log("[DESVÍO] Iniciando comprobador de desvío cada 5 segundos.");
    deviationCheckIntervalId = setInterval(() => {
        if (!isNavigating || !navigationCurrentLocation || isRecalculatingRoute || isDeviationModalActive || isAddReminderAtLocationModeActive) {
            deviationStartTime = 0;
            return;
        }
        if (Date.now() < deviationCheckGracePeriodUntil) {
            return;
        }
        const currentCoords = navigationCurrentLocation;
        const routeSource = navigationMapInstance?.getSource('route');
        if (routeSource && routeSource._data && typeof turf !== 'undefined') {
            try {
                const routeGeoJSON = routeSource._data;
                const routeLineString = turf.lineString(routeGeoJSON.geometry.coordinates);
                const carPoint = turf.point([currentCoords.longitude, currentCoords.latitude]);
                const distanceToRoute = turf.pointToLineDistance(carPoint, routeLineString, { units: 'meters' });

                if (distanceToRoute > DEVIATION_THRESHOLD_METERS) {
                    if (deviationStartTime === 0) {
                        deviationStartTime = Date.now();
                    } else if ((Date.now() - deviationStartTime) / 1000 > DEVIATION_MIN_TIME_SECONDS) {
                        showDeviationModal();
                        deviationStartTime = 0;
                    }
                } else {
                    deviationStartTime = 0;
                }
            } catch (e) {
                // Error en turf, iniciar contador como fallback
                if (deviationStartTime === 0) deviationStartTime = Date.now();
                else if ((Date.now() - deviationStartTime) / 1000 > DEVIATION_MIN_TIME_SECONDS) {
                    showDeviationModal();
                    deviationStartTime = 0;
                }
            }
        }
    }, 5000); // Frecuencia de 5 segundos
}

// ===================================================================
// NOMBRE: stopDeviationChecker (NUEVA FUNCIÓN)
// RESUMEN: Detiene el temporizador de comprobación de desvío.
function stopDeviationChecker() {
    if (deviationCheckIntervalId) {
        console.log("[DESVÍO] Deteniendo comprobador de desvío.");
        clearInterval(deviationCheckIntervalId);
        deviationCheckIntervalId = null;
        deviationStartTime = 0;
    }
}


// ===================================================================
// NOMBRE: toggleNavigationState (MODIFICADA - Inicia/Detiene el checker de desvío)
// RESUMEN: Inicia/detiene la navegación y ahora también el comprobador de desvío.
async function toggleNavigationState(isRecalculationStop = false) {
    const startNavButton = document.getElementById('start-navigation-button');
    const startNavImg = startNavButton ? startNavButton.querySelector('img') : null;
    const mapContainer = document.getElementById('reminders-location-map-div');
    
    if (isNavigating) {
        if (isSimulatingGpsLocation) {
            stopAutomatedRouteSimulation();
        }
        if (!isRecalculationStop && !isArrivalSequenceStarted) {
            if (!document.getElementById('arrival-stats-modal') || document.getElementById('arrival-stats-modal').classList.contains('hidden')) {
                showArrivalStatsModal();
            }
        }
        isNavigating = false;
        navigationFollowUser = false;
        stopDeviationChecker(); // Detiene el comprobador de desvío
    } else if (isFreeDriveActive) {
        stopFreeDrive();
    } else {
        const hasEnoughWaypointsForRoute = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2;
        const hasRouteData = navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0];
        if (hasEnoughWaypointsForRoute && hasRouteData) {
            isArrivalSequenceStarted = false;
            hideAutoStartNavigationModal();
            clearAlternativeRoutesDisplay();
            clearSpeedMarkers();
            
            const waypointsForRecents = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
            await Promise.all(waypointsForRecents.map(async (wp) => {
                if (!wp.address) {
                    wp.address = await getAddressForWaypoint(wp.lat, wp.lng);
                }
            }));
            const lastWpForName = waypointsForRecents[waypointsForRecents.length - 1];
            const isMultiStageForName = waypointsForRecents.length > 2;
            const suggestedName = await getSuggestedRouteName(lastWpForName.lat, lastWpForName.lng, isMultiStageForName, waypointsForRecents.length);
            const routeForRecents = { name: currentRouteNameForSaving || suggestedName, waypoints: waypointsForRecents };
            addRouteToRecents(routeForRecents);
            clearNavigationGraph();
            navigationWaypoints.forEach(wp => { if(wp) { if (wp.type === 'S' || wp.type === 'S_Recalc') { wp.visited = true; } else { wp.visited = false; } if (wp.marker) wp.marker.setDraggable(false); } });
            
            getCurrentLocation(
                (initialCoords) => { navigationCurrentLocation = initialCoords; updateInitialUserPosition(initialCoords, navigationMapInstance); },
                (errorMsg) => { showToast(`No se pudo obtener tu ubicación inicial: ${errorMsg}. El mapa se centrará cuando el GPS esté listo.`, "warning", 5000); }
            );
            startGpsWatching();
            const loadingToast = document.getElementById("gps-init-toast"); if (loadingToast) loadingToast.remove(); activeToasts = activeToasts.filter(t => t.id !== "gps-init-toast");
            
            isNavigating = true;
            startDeviationChecker(); // Inicia el comprobador de desvío
            mapHeaderButtonsVisible = false;
            toggleMapHeaderRowsVisibility(false);
            
            const routeData = navigationCurrentRouteData.routes[0];
            if (routeData) {
                tripInitialDurationSec = routeData.duration;
                tripInitialDistanceMeters = routeData.distance;
                tripInitialOverallEtaTime = new Date(Date.now() + routeData.duration * 1000);
                if (routeData.legs && routeData.legs.length > 0) {
                    currentStageInitialExpectedEtaTime = new Date(Date.now() + routeData.legs[0].duration * 1000);
                }
            }
            tripStartLocationForStats = navigationCurrentLocation ? { ...navigationCurrentLocation } : null;
            navigationStartTimeForStats = null;
            totalDistanceTravelledForStats = 0;
            maxDistanceReachedOnRoute = 0;
            maxSpeedDuringTrip = 0;
            maxSpeedCoordinates = null;
            maxAltitudeDuringTrip = -Infinity;
            minAltitudeDuringTrip = Infinity;
            lastPositionForStats = navigationCurrentLocation ? {...navigationCurrentLocation} : null;
            accumulatedDeviationMs = 0;
            accumulatedDistanceBeforeCurrentSegment = 0;
            showToast("Navegación iniciada. Esperando movimiento...", "success");
            currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviación ETA';
            initializeNavigationGraph();
            const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox'); if (radaresRutaCheckbox && radaresRutaCheckbox.checked) { toggleRadaresRuta(true); }
            const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox'); if (tareasRutaCheckbox && tareasRutaCheckbox.checked) { toggleTareasRuta(true); }
            if (navigationMapInstance) {
                shouldCenterOnUser = true; 
                navigationFollowUser = true;
                const locateMeButton = document.getElementById('locate-me-on-reminders-map');
                if (locateMeButton) {
                    const locateMeImg = locateMeButton.querySelector('img');
                    if (locateMeImg) locateMeImg.src = "PNG/DEJARSEGUIR.PNG";
                    locateMeButton.title = "Dejar de centrar el mapa en mi posición";
                }
                const startCoords = navigationCurrentLocation 
                    ? [navigationCurrentLocation.longitude, navigationCurrentLocation.latitude] 
                    : [navigationWaypoints[0].lng, navigationWaypoints[0].lat];
                const savedViewMode = localStorage.getItem(MAP_VIEW_MODE_KEY) || 'static';
                const modeDetails = MAP_VIEW_MODES[Object.keys(MAP_VIEW_MODES).find(key => MAP_VIEW_MODES[key].mode === savedViewMode)] || MAP_VIEW_MODES.NORTE;
                let pitchToUse = 0;
                if (modeDetails.mode === 'static') {
                    pitchToUse = 0; 
                } else {
                    pitchToUse = mapPitchValue; 
                }
                const initialFlyToOptions = { center: startCoords, zoom: 17.5, pitch: pitchToUse, essential: true, duration: 1500 };
                mapPreviousZoomLevel = null;
                if ((modeDetails.mode === 'heading' || modeDetails.mode === 'perspective') && navigationCurrentLocation && navigationCurrentLocation.heading !== null) {
                    initialFlyToOptions.bearing = navigationCurrentLocation.heading;
                } else {
                    initialFlyToOptions.bearing = modeDetails.bearing;
                }
                navigationMapInstance.flyTo(initialFlyToOptions);
            }
        } else {
            try {
                const initialCoords = await getCurrentLocationAsync();
                startFreeDrive(initialCoords);
            } catch (error) {
                showToast(`No se pudo obtener la ubicación para iniciar el modo libre: ${error.message}`, "error");
            }
        }
    }
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    setNavigationMapClickHandler(); 
    actualizarContadorRadares(radaresEnRutaActual.length);
    actualizarContadorTareas(tareasEnRutaActual.length);
}

// ===================================================================
// NOMBRE: saveCustomData (MODIFICADA - Llama a la nueva función de caché)
// RESUMEN: Guarda la personalización y marca la caché de recordatorios como sucia.
function saveCustomData() {
    try {
        if (customData.bookmarks) {
            Object.keys(customData.bookmarks).forEach(indexKey => {
                const index = parseInt(indexKey);
                const custom = customData.bookmarks[index];
                const original = index < originalBookmarks.length ? originalBookmarks[index] : null;
                const bookmarksAreEqual = (b1, b2) => {
                    if (b1 === null && b2 === null) return true;
                    if (b1 === null || b2 === null) return false;
                    return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null);
                };
                if (bookmarksAreEqual(custom, original)) {
                    delete customData.bookmarks[index];
                }
            });
            if (Object.keys(customData.bookmarks).length === 0) {
                delete customData.bookmarks;
            }
        }
        if (customData.toggles) {
            Object.keys(customData.toggles).forEach(startKey => {
                const customToggle = customData.toggles[startKey];
                const originalRange = originalToggleRanges.find(r => r.start == startKey);
                if (customToggle && customToggle.assignedIndexes && originalRange) {
                    const originalDefaultIndexes = [];
                    for (let i = originalRange.start; i <= originalRange.end; i++) {
                        originalDefaultIndexes.push(i);
                    }
                    if (customToggle.assignedIndexes.length === originalDefaultIndexes.length &&
                        customToggle.assignedIndexes.every((val, idx) => val === originalDefaultIndexes[idx])) {
                        delete customToggle.assignedIndexes;
                    }
                }
                if (customToggle && originalRange && customToggle.label === originalRange.label) {
                    delete customToggle.label;
                }
                if (customData.toggles[startKey] && Object.keys(customData.toggles[startKey]).length === 0) {
                    delete customData.toggles[startKey];
                }
            });
            if (Object.keys(customData.toggles).length === 0) {
                delete customData.toggles;
            }
        }
        localStorage.setItem('customGridData', JSON.stringify(customData));
        markRemindersCacheAsDirty(); // <-- LÍNEA AÑADIDA
    } catch (e) {
        showToast("Error al guardar personalización", "error");
    }
}

// ===================================================================
// NOMBRE: showAllReminders (MODIFICADA - Llama a la nueva función de caché)
// RESUMEN: Muestra la tabla y marca la caché como sucia si se cambia el filtro de excluidos.
function showAllReminders(options = {}) {
     const mapWasOpenBeforeThisTable = isNavigationMapActive;
     if (mapWasOpenBeforeThisTable) {
         sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
         sessionStorage.setItem('mapContext', 'navigation');
     } else {
         sessionStorage.removeItem('boardinggate_map_was_open_before_table');
         sessionStorage.removeItem('mapContext');
     }
     closeOtherModals();
     let allReminders = []; try { allReminders = JSON.parse(localStorage.getItem('reminders') || '[]').map(r => ({ ...r })); } catch(e) { showToast("Error al cargar lista de recordatorios.", "error"); return; }
     const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false; let remindersToDisplay = allReminders;
     if (!showExcluded) { remindersToDisplay = allReminders.filter(r => !r.excludeFromList); }
     remindersToDisplay.sort((a, b) => {
         const nowForSort = new Date(); const nextA = calculateNextOccurrence(a, nowForSort); const nextB = calculateNextOccurrence(b, nowForSort);
         if (nextA && nextB) { const timeDiff = nextA.getTime() - nextB.getTime(); if (timeDiff !== 0) return timeDiff; } else if (nextA) { return -1; } else if (nextB) { return 1; }
         const typeOrder = { 'simple': 1, 'hourly': 2, 'daily': 3, 'weekly': 4, 'interval': 5 }; const typeDiff = (typeOrder[a.type] ?? 99) - (typeOrder[b.type] ?? 99); if (typeDiff !== 0) return typeDiff;
         const createdAtA = a.createdAt ? new Date(a.createdAt).getTime() : 0; const createdAtB = b.createdAt ? new Date(b.createdAt).getTime() : 0; return createdAtA - createdAtB;
     });
     const existingModal = document.querySelector('.reminder-table-modal');
     if (existingModal) { if (existingModal.autoCloseInterval) clearInterval(existingModal.autoCloseInterval); if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal); }
     const modalTable = document.createElement('div');
     modalTable.className = 'reminder-table-modal';
     modalTable.setAttribute('aria-label', 'Tabla recordatorios');
     modalTable.innerHTML = `
        <div class="reminder-table-header">
            <div class="reminder-table-top-controls">
                <div style="display: flex; align-items: center;">
                    <input type="checkbox" id="show-excluded-reminders" ${showExcluded ? 'checked' : ''} style="transform: scale(1.3);">
                    <label for="show-excluded-reminders" style="margin-left: 0.5rem; font-size: 1.1rem;">MOSTRAR RADARES u OTROS</label>
                </div>
                <div style="display: flex; align-items: center;">
                    <button type="button" id="view-all-locations-map">VER UBICACIONES</button>
                    <button type="button" id="close-reminders-top" style="margin-left:10px;">SALIR <span class="button-countdown"></span></button>
                </div>
            </div>
            <h2>Recordatorios</h2>
        </div>
        <div class="reminder-table-body-container">
            <table>
                <thead>
                    <tr>
                        <th style="width:12%;">Acciones</th> <th>Texto</th> <th style="width:8%;">Hora</th>
                        <th style="width:10%;">Fecha Prox.</th> <th style="width:15%;">Días Rep.</th>
                        <th style="width:8%;">Cada x días</th> <th style="width:8%;">Geoloc.</th>
                        <th style="width:10%;">Creado</th>
                    </tr>
                </thead>
                <tbody id="reminder-table-body">
                    ${remindersToDisplay.length === 0 ? `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios ${showExcluded ? ' (incluyendo excluidos)' : ''}.</td></tr>` : remindersToDisplay.map(r => { 
                        const isRadarOrExcluded = r.excludeFromList || r.text.toUpperCase().includes("RADAR");
                        const rowBackgroundColor = isRadarOrExcluded ? 'rgba(52, 199, 89, 0.15)' : 'rgba(88, 86, 214, 0.15)';
                        const nextOccurrenceDate = calculateNextOccurrence(r, new Date()); 
                        const formattedNextDate = nextOccurrenceDate ? formatDateToDDMMMYY(nextOccurrenceDate.toISOString().split('T')[0]) : formatDateToDDMMMYY(r.date); 
                        const timeDisplay = r.time ? r.time : '-'; 
                        const geoIndicator = r.isLocationEnabled ? '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#34c759" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>' : '-'; 
                        const isCyclic = r.type === 'weekly' || r.type === 'interval';
                        const cyclicStyle = isCyclic ? 'style="color: #ffd700; font-weight: bold;"' : '';
                        return `<tr data-id="${r.id}" style="background-color: ${rowBackgroundColor};"> <td> <button class="visto-prox" data-id="${r.id}" title="${isCyclic ? 'Marcar Visto y Avanzar al Próximo Ciclo' : 'Marcar Visto y Borrar'}">Visto/Prox</button> <button class="postpone" data-id="${r.id}" title="Posponer">Posponer</button> ${isCyclic ? `<button class="cancel-cyclic-table" data-id="${r.id}" title="Anular Ciclo Permanente">Anular Ciclo</button>` : ''} </td> <td class="text-column" title="Modificar">${r.text}</td> <td class="time-column">${timeDisplay}</td> <td class="date-column">${formattedNextDate}</td> <td ${cyclicStyle}>${r.type === 'weekly' && r.repeatDays?.length > 0 ? r.repeatDays.map(d => ['Dom','Lun','Mar','Mié','Jue','Vie','Sáb'][d]).join(', ') : '-'}</td> <td ${cyclicStyle}>${r.type === 'interval' ? r.intervalDays || '-' : '-'}</td> <td>${geoIndicator}</td> <td class="date-column">${r.createdAt ? formatDateToDDMMMYY(r.createdAt.split('T')[0]) : '-'}</td> </tr>`; 
                    }).join('')}
                    </tbody>
                </table>
        </div>
        <div class="bottom-button-container" style="display:none;">
            <button type="button" id="close-reminders-bottom">SALIR <span class="button-countdown"></span></button>
        </div>
        `;
         const parent = document.body;
         parent.appendChild(modalTable);
         const showExcludedCheckbox = modalTable.querySelector('#show-excluded-reminders');
         if (showExcludedCheckbox) { 
             showExcludedCheckbox.addEventListener('change', () => { 
                 localStorage.setItem(SHOW_EXCLUDED_REMINDERS_KEY, JSON.stringify(showExcludedCheckbox.checked)); 
                 markRemindersCacheAsDirty();
                 if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval); 
                 modalTable.remove(); 
                 showAllReminders(); 
            }); 
        }
         const viewLocationsMapButton = modalTable.querySelector('#view-all-locations-map');
         if (viewLocationsMapButton) {
            viewLocationsMapButton.addEventListener('click', () => {
                if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                if (modalTable.parentNode) modalTable.remove();
                setTimeout(() => {
                    openLocationsPreviewMap();
                }, 50);
            });
        }
         let count = 60; const countdownSpans = modalTable.querySelectorAll('.button-countdown'); countdownSpans.forEach(span => span.textContent = `(${count})`);
         const closeClean = () => { clearInterval(modalTable.autoCloseInterval); modalTable.autoCloseInterval = null; if (modalTable.parentNode) modalTable.parentNode.removeChild(modalTable);
             const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true'; sessionStorage.removeItem('boardinggate_map_was_open_before_table');
             const mapContext = sessionStorage.getItem('mapContext'); sessionStorage.removeItem('mapContext');
             if (fromReminderModal) { fromReminderModal = false; if (mapShouldReopen) { sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true'); sessionStorage.setItem('mapContext', mapContext); } showReminderModal(); }
             else if (mapShouldReopen) { if (mapContext === 'navigation') openNavigationMap(); }
         };
         modalTable.autoCloseInterval = setInterval(() => { count--; countdownSpans.forEach(span => span.textContent = `(${count})`); if (count <= 0) { closeClean(); } }, 1000);
         const resetTimer = () => { if (!modalTable.autoCloseInterval) return; clearInterval(modalTable.autoCloseInterval); count = 60; countdownSpans.forEach(span => span.textContent = `(${count})`); modalTable.autoCloseInterval = setInterval(() => { count--; countdownSpans.forEach(span => span.textContent = `(${count})`); if (count <= 0) { closeClean(); } }, 1000); };
         modalTable.addEventListener('click', resetTimer); modalTable.addEventListener('touchstart', resetTimer, { passive: true }); modalTable.addEventListener('input', resetTimer);
         modalTable.querySelector('#close-reminders-top').addEventListener('click', closeClean);
         modalTable.querySelector('#close-reminders-bottom').addEventListener('click', closeClean);
         setupReminderTableListeners(modalTable);
}

// ===================================================================
// NOMBRE: setupReminderTableListeners (MODIFICADA - Llama a la nueva función de caché)
// RESUMEN: Añade listeners y marca la caché como sucia en cada modificación.
function setupReminderTableListeners(modalTable) {
        modalTable.querySelectorAll('.visto-prox').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#EF4444';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #B91C1C';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true);
                let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderIndex = rems.findIndex(r => r.id === id);
                let needsSave = false;
                const row = newButton.closest('tr');
                if (reminderIndex > -1 && row) {
                     const currentReminder = rems[reminderIndex];
                     if (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval')) {
                        const { newDateISO, newTime } = calculatePostponedDateTime(15);
                        rems[reminderIndex].date = newDateISO;
                        rems[reminderIndex].time = newTime;
                        rems[reminderIndex].managedByUser = false;
                        needsSave = true;
                        const dateCell = row.cells[3]; const timeCell = row.cells[2];
                        if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date);
                        if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                        showToast('Recordatorio con ubicación pospuesto 15 min', 'info');
                    } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                         let referenceDateForNext = new Date();
                         try {
                             const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                             const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                             const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                             if (!isNaN(reminderDateTime.getTime())) {
                                 referenceDateForNext = new Date(reminderDateTime.getTime() + 60000);
                             }
                         } catch(er) { }
                        const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                        if (nextOcc) {
                            rems[reminderIndex].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                            rems[reminderIndex].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                            rems[reminderIndex].managedByUser = false;
                            needsSave = true;
                            const dateCell = row.cells[3]; const timeCell = row.cells[2];
                            if (dateCell) dateCell.textContent = formatDateToDDMMMYY(rems[reminderIndex].date);
                            if (timeCell) timeCell.textContent = rems[reminderIndex].time;
                            showToast('Actualizado al próximo periodo', 'info');
                        } else {
                            rems.splice(reminderIndex, 1); needsSave = true;
                            row.remove(); showToast('Error calculando siguiente ciclo. Eliminado.', 'error');
                        }
                    } else {
                        rems.splice(reminderIndex, 1); needsSave = true;
                        row.remove(); showToast('Recordatorio borrado', 'info');
                    }
                    if (needsSave) {
                        localStorage.setItem('reminders', JSON.stringify(rems)); 
                        markRemindersCacheAsDirty();
                        if (isNavigationMapActive) { plotRemindersOnNavigationMap(); } // <-- CORRECCIÓN
                    }
                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios.</td></tr>`;
                    }
                } else {
                    showToast('Error: Recordatorio no encontrado para actualizar/borrar.', 'error');
                    if(row) row.remove();
                }
                updateReminderCount(); updateButtonStyles(); checkReminders();
            });
        });
        modalTable.querySelectorAll('.postpone').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#F59E0B';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #B45309';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                markReminderAsManaged(id, true);
                const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const reminderToPostpone = reminders.find(r => r.id === id);
                if (reminderToPostpone) {
                    if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                    modalTable.remove();
                    showPostponeOptionsModal(reminderToPostpone, 'table');
                } else {
                    showToast('Error: Recordatorio no encontrado para posponer.', 'error');
                    markReminderAsManaged(id, false);
                }
            });
        });
        modalTable.querySelectorAll('.cancel-cyclic-table').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.style.backgroundColor = '#8B0000';
            newButton.style.color = '#FFFFFF';
            newButton.style.border = '1px solid #580000';
            newButton.style.fontWeight = 'bold';
            newButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = parseInt(newButton.dataset.id); if (isNaN(id)) return;
                if (confirm('¿Estás seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE?')) {
                    markReminderAsManaged(id, true);
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const initialLength = rems.length;
                    rems = rems.filter(r => r.id !== id);
                    if (rems.length < initialLength) {
                       localStorage.setItem('reminders', JSON.stringify(rems)); 
                       markRemindersCacheAsDirty();
                       if (isNavigationMapActive) { plotRemindersOnNavigationMap(); } // <-- CORRECCIÓN
                       showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                    } else {
                        showToast('Error: No se encontró el ciclo para anular', 'warning');
                    }
                    const row = newButton.closest('tr');
                    if (row) row.remove();
                    const tbody = modalTable.querySelector('#reminder-table-body');
                    if (tbody && tbody.rows.length === 0) {
                        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:1rem;">No hay recordatorios.</td></tr>`;
                    }
                    updateReminderCount(); updateButtonStyles(); checkReminders();
                }
            });
        });
        const tableBody = modalTable.querySelector('#reminder-table-body');
        if (tableBody) {
            const newTableBody = tableBody.cloneNode(false);
            while(tableBody.firstChild) newTableBody.appendChild(tableBody.firstChild);
            tableBody.parentNode.replaceChild(newTableBody, tableBody);
            newTableBody.addEventListener('click', (e) => {
                if (e.target.closest('td:first-child button')) return;
               const row = e.target.closest('tr[data-id]');
                if (row?.dataset.id) {
                    const id = parseInt(row.dataset.id); if (isNaN(id)) return;
                    markReminderAsManaged(id, true);
                    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const reminderToModify = reminders.find(r => r.id === id);
                    if (reminderToModify) {
                        const mapWasOpenBeforeTable = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                        const mapContextBeforeTable = sessionStorage.getItem('mapContext');
                        if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                        modalTable.remove();
                        if (mapWasOpenBeforeTable) {
                            sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                            if (mapContextBeforeTable) {
                                sessionStorage.setItem('mapContext', mapContextBeforeTable);
                            }
                        }
                        sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                        showReminderModal(reminderToModify);
                    } else {
                        showToast('Error: Recordatorio no encontrado para modificar', 'error');
                        markReminderAsManaged(id, false);
                    }
                }
            });
        }
}


// ===================================================================
// NOMBRE: showReminderModal (MODIFICADA - Llama a la nueva función de caché)
// RESUMEN: Muestra el modal de edición/creación y marca la caché como sucia al guardar/borrar.
function showReminderModal(reminder = null, options = {}) {
    const mapShouldReopenAfterForm = sessionStorage.getItem('boardinggate_map_should_reopen_after_form') === 'true';
    const mapContextBeforeThisModal = sessionStorage.getItem('mapContext');
    closeOtherModals();
    let autoSaveInterval = null; let parseTimeout = null; let restartTimeout = null; let focusTimeout = null; let countdownSave = 25; let manualTimeInput = false; let lastInputWasSpeech = false;
    let currentReminderLocation = null;
    let locationEnabledByUser = false;
    let mapExpandedManually = false;
    let mapMoveDebounceTimer = null;

    function cleanUpModalTimers(clearAll = true) {
        if (autoSaveInterval) { clearInterval(autoSaveInterval); autoSaveInterval = null; }
        if (clearAll) {
            if (parseTimeout) clearTimeout(parseTimeout);
            if (restartTimeout) clearTimeout(restartTimeout);
            if (focusTimeout) clearTimeout(focusTimeout);
            parseTimeout = null; restartTimeout = null; focusTimeout = null;
        }
    }

    const existingModal = document.querySelector('.reminder-modal');
    if (existingModal) {
        if (typeof existingModal.cleanUpModalTimers === 'function') existingModal.cleanUpModalTimers(true);
        if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal);
    }
    
    let isNew = true;
    let parsed = {
         id: null, text: '', time: null, date: null, repeatDays: [], intervalDays: null, type: 'simple',
         createdAt: new Date().toISOString(), managedByUser: false,
         isLocationEnabled: false, locationCoordinates: null, radiusMeters: DEFAULT_LOCATION_RADIUS,
         excludeFromList: false
    };
    if (reminder && typeof reminder.id === 'number' && reminder.id !== null) {
        const remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
        const foundReminder = remindersFromStorage.find(r => r.id === reminder.id);
        if (foundReminder) {
            parsed = { ...foundReminder };
            isNew = false;
        } else {
            parsed = { ...reminder, id: null, createdAt: new Date().toISOString(), managedByUser: false };
            isNew = true;
            if(reminder.text && reminder.text.toUpperCase().includes("RADAR RUTA:")) {
                 parsed.text = reminder.text.replace("RADAR RUTA:", "RADAR:");
                 parsed.excludeFromList = true;
                 parsed.radiusMeters = 350;
            }
        }
    } else if (reminder) {
        parsed = { ...reminder, id: null, createdAt: new Date().toISOString(), managedByUser: false };
        isNew = true;
         if(reminder.text && reminder.text.toUpperCase().includes("RADAR RUTA:")) {
            parsed.text = reminder.text.replace("RADAR RUTA:", "RADAR:");
            parsed.excludeFromList = true;
            parsed.radiusMeters = 350;
        }
    }
    if (!isNew && !parsed.createdAt) { parsed.createdAt = new Date(0).toISOString(); }
    locationEnabledByUser = parsed.isLocationEnabled;
    currentReminderLocation = parsed.locationCoordinates;
    let fmtDate = '';
    if (parsed.date?.match(/^\d{4}-\d{2}-\d{2}$/)) {
        try {
            const [y,m,d] = parsed.date.split('-');
            const dt=new Date(Date.UTC(y,m-1,d));
            if(!isNaN(dt.getTime())&&dt.getUTCDate()==d&&dt.getUTCMonth()==m-1) {
                fmtDate=`${d.toString().padStart(2,'0')}/${m.toString().padStart(2,'0')}/${y}`;
            }
        } catch(e){}
    }
    const modal = document.createElement('div');
    modal.className = 'reminder-modal';
    modal.setAttribute('aria-label','Formulario recordatorio');
    const titleText = isNew ? 'NUEVO RECORDATORIO' : 'MODIFICAR RECORDATORIO';
    modal.innerHTML = `
        <div class="reminder-modal-header">
            <h2 class="reminder-modal-title">${titleText}</h2>
             <div class="header-options">
                <label for="reminder-exclude-from-list" class="form-label-exclude">
                    <input type="checkbox" id="reminder-exclude-from-list" ${parsed.excludeFromList ? 'checked' : ''}>
                    <span>No listar (Radares, etc.)</span>
                </label>
            </div>
        </div>

        <div class="reminder-modal-body">
            <form id="reminder-form" class="reminder-modal-form">
                
                <div class="form-section">
                    <div class="input-with-buttons">
                        <div class="button-and-status-wrapper">
                            <button type="button" id="clear-fields" class="clear-button" title="Limpiar todo el formulario">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                            </button>
                            <p id="speech-status" class="speech-status"></p>
                            <p id="parse-status" class="parse-status"></p>
                        </div>
                        <textarea id="reminder-text" rows="2" required placeholder="Escriba o dicte aquí...">${parsed.text.replace(/<b>|<\/b>/gi,'')}</textarea>
                    </div>
                </div>
                
                <div class="form-section controls-grid">
                    <div class="control-item">
                        <label for="reminder-time" class="form-label">Hora:</label>
                        <input type="text" id="reminder-time" placeholder="HH:MM" pattern="\\d{2}:\\d{2}" value="${parsed.time||''}">
                    </div>
                    <div class="control-item">
                        <label for="reminder-date" class="form-label">Fecha:</label>
                        <input type="text" id="reminder-date" placeholder="DD/MM/AAAA" pattern="\\d{2}/\\d{2}/\\d{4}" value="${fmtDate}">
                    </div>
                    <div class="control-item">
                        <label for="reminder-interval" class="form-label">Int.(días):</label>
                        <input type="number" id="reminder-interval" min="1" max="9999" value="${parsed.intervalDays||''}">
                    </div>
                     <div class="control-item days-group-grid-item">
                         <label class="form-label">Días Repet.:</label>
                         <div class="days-checkbox-container">
                            ${['Lun','Mar','Mié','Jue','Vie','Sáb','Dom'].map((d,i)=>`<label><input type="checkbox" name="repeat" value="${(i+1)%7}" ${parsed.repeatDays?.includes((i+1)%7)?'checked':''}><span>${d}</span></label>`).join('')}
                         </div>
                    </div>
                </div>

                <div class="form-section location-section">
                    <div class="location-header">
                        <label for="location-enabled" class="form-label-location">
                             <input type="checkbox" id="location-enabled" ${parsed.isLocationEnabled ? 'checked' : ''}>
                             <span>RECORDATORIO POR UBICACIÓN</span>
                        </label>
                         <div id="radius-slider-group" class="radius-slider-group">
                             <label id="radius-range-label" class="form-label">Radio: ${parsed.radiusMeters || 350}m</label>
                             <div class="slider-container single-slider-container">
                                 <div class="slider-track"></div>
                                 <div class="slider-range" id="radius-slider-range"></div>
                                 <div class="slider-thumb" id="radius-thumb"></div>
                             </div>
                         </div>
                        <button type="button" id="expand-map-button" class="expand-map-button">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
                            <span>MAPA</span>
                        </button>
                    </div>
                    <div id="location-controls-container" style="display: ${parsed.isLocationEnabled ? 'block' : 'none'};">
                         <div id="location-map-container" class="location-map-container">
                            <button type="button" id="reduce-map-button" class="hidden">REDUCIR</button>
                            <button type="button" id="locate-me-button" class="hidden">ESTÁS AQUÍ</button>
                         </div>
                    </div>
                </div>
            </form>
        </div>

        <div class="reminder-modal-footer">
            <button type="submit" id="save-reminder" class="action-button primary">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13H7v8"></polyline><polyline points="7 3 7 8h10"></polyline></svg>
                <span>ACEPTAR</span>
                <span id="countdown-save">${countdownSave}</span>
            </button>
             <button type="button" id="cancel-reminder" class="action-button secondary">Cancelar</button>
             <button type="button" id="delete-reminder" title="Borrar este recordatorio permanentemente" class="action-button danger">Borrar</button>
             <button type="button" id="view-reminders" class="action-button secondary">Ver Lista</button>
             <button type="button" id="manage-saved-locations" class="action-button secondary">Ubicaciones</button>
             <button type="button" id="help-reminder" class="action-button secondary">Ayuda</button>
        </div>
    `;
    
    if (options.onTopOfMap) {
        const mapContainerEl = document.getElementById('reminders-location-map-modal');
        if (mapContainerEl) mapContainerEl.appendChild(modal);
        else document.body.appendChild(modal);
    } else {
        document.body.appendChild(modal);
    }

    modal.cleanUpModalTimers = cleanUpModalTimers;
    
    const mapContainer = modal.querySelector('#location-map-container');
    const reduceMapButton = modal.querySelector('#reduce-map-button');
    const locateMeButton = modal.querySelector('#locate-me-button');
    const expandMapButton = modal.querySelector('#expand-map-button');
    const locationCheckbox = modal.querySelector('#location-enabled');

    function destroyMap() {
        if (reminderModalMap) {
            try { reminderModalMap.remove(); } catch(e) {}
            reminderModalMap = null;
            reminderMarker = null;
        }
        if (mapContainer) {
            mapContainer.style.display = 'none';
            mapContainer.classList.remove('preview', 'expanded');
            const mapDiv = mapContainer.querySelector('#reminder-modal-map-div');
            if (mapDiv) mapDiv.remove();
        }
        if (reduceMapButton) reduceMapButton.classList.add('hidden');
        if (locateMeButton) locateMeButton.classList.add('hidden');
        if (expandMapButton) expandMapButton.style.display = 'block';
    }

    function initializeOrUpdateMap(centerCoords, radius, isInteractive = false) {
        destroyMap(); 

        const effectiveLocationEnabled = locationCheckbox.checked;
        const showMap = effectiveLocationEnabled || isInteractive;
        if (!showMap) return;

        mapContainer.style.display = 'block';
        mapContainer.classList.toggle('preview', !isInteractive && effectiveLocationEnabled && centerCoords);
        mapContainer.classList.toggle('expanded', isInteractive && effectiveLocationEnabled);
        
        expandMapButton.style.display = (isInteractive && effectiveLocationEnabled) ? 'none' : 'block';
        
        const effectiveCoords = centerCoords || { latitude: 40.416775, longitude: -3.703790 };
        const effectiveRadius = parseInt(radius) || DEFAULT_LOCATION_RADIUS;
        const zoomLevel = isInteractive ? 13 : 11;

        const mapDiv = document.createElement('div');
        mapDiv.id = 'reminder-modal-map-div';
        mapDiv.style.width = '100%'; mapDiv.style.height = '100%';
        mapContainer.insertBefore(mapDiv, reduceMapButton);

        reminderModalMap = new mapboxgl.Map({
            container: mapDiv,
            style: 'mapbox://styles/mapbox/satellite-streets-v12',
            center: [effectiveCoords.longitude, effectiveCoords.latitude],
            zoom: zoomLevel,
            interactive: isInteractive && effectiveLocationEnabled
        });
        
        reminderModalMap.on('load', () => {
            updateMarkerAndCircle(effectiveCoords, effectiveRadius);
            
            reminderModalMap.on('click', handleMapClick);
            
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    if (reminderModalMap) {
                        try { reminderModalMap.resize(); } catch (e) {}
                    }
                });
            });
        });
        
        if (reduceMapButton) reduceMapButton.classList.toggle('hidden', !(isInteractive && effectiveLocationEnabled));
        if (locateMeButton) locateMeButton.classList.toggle('hidden', !(isInteractive && effectiveLocationEnabled));
    }
    const parseStatus = modal.querySelector('#parse-status');
    const speechStatus = modal.querySelector('#speech-status');
    let countdownSaveElement = modal.querySelector('#countdown-save');
    const textInput = modal.querySelector('#reminder-text');
    const timeInput = modal.querySelector('#reminder-time');
    const dateInput = modal.querySelector('#reminder-date');
    const intervalInput = modal.querySelector('#reminder-interval');
    const saveButton = modal.querySelector('#save-reminder');
    const clearButton = modal.querySelector('#clear-fields');
    const locationControlsContainer = modal.querySelector('#location-controls-container');
    const manageLocationsBtn = modal.querySelector('#manage-saved-locations');
    const excludeFromListCheckbox = modal.querySelector('#reminder-exclude-from-list');
    const deleteButton = modal.querySelector('#delete-reminder');
    
    const radiusSliderGroup = modal.querySelector('#radius-slider-group');

    function toggleLocationControlsVisibility() {
        const isChecked = locationCheckbox.checked;
        if (locationControlsContainer) {
            locationControlsContainer.style.display = isChecked ? 'block' : 'none';
        }
        if (radiusSliderGroup) {
            radiusSliderGroup.style.display = isChecked ? 'flex' : 'none';
        }
        if(!isChecked) {
           destroyMap();
        }
    }
    
    locationCheckbox.addEventListener('change', toggleLocationControlsVisibility);
    toggleLocationControlsVisibility();

    const radiusSliderContainer = modal.querySelector('#radius-thumb')?.parentElement;
    const radiusThumb = modal.querySelector('#radius-thumb');
    const radiusRange = modal.querySelector('#radius-slider-range');
    const radiusLabel = modal.querySelector('#radius-range-label');
    const minRadius = 1;
    const maxRadius = 5000;
    let currentRadius = parsed.radiusMeters || 350;

    const updateRadiusVisuals = () => {
        if (!radiusThumb || !radiusRange || !radiusLabel) return;
        const minLog = Math.log(minRadius);
        const maxLog = Math.log(maxRadius);
        const percent = (Math.log(currentRadius) - minLog) / (maxLog - minLog);
        
        radiusThumb.style.left = `${percent * 100}%`;
        radiusRange.style.width = `${percent * 100}%`;
        radiusLabel.textContent = `Radio: ${Math.round(currentRadius)}m`;
    };

    if (radiusSliderContainer && radiusThumb) {
        const onRadiusDrag = (e) => {
            const rect = radiusSliderContainer.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let percent = ((clientX - rect.left) / rect.width);
            percent = Math.max(0, Math.min(1, percent));
            const minLog = Math.log(minRadius);
            const maxLog = Math.log(maxRadius);
            let rawRadius = Math.exp(minLog + percent * (maxLog - minLog));
            let step;
            if (rawRadius < 100) step = 5; 
            else if (rawRadius < 500) step = 25; 
            else step = 100;
            currentRadius = Math.round(rawRadius / step) * step;
            currentRadius = Math.max(minRadius, Math.min(maxRadius, currentRadius));
            updateRadiusVisuals();
            // *** INICIO DE LA CORRECCIÓN 1 ***
            if (reminderModalMap && currentReminderLocation) {
                 updateMarkerAndCircle(currentReminderLocation, Math.round(currentRadius));
            }
            // *** FIN DE LA CORRECCIÓN 1 ***
            resetAndStartCountdown();
        };
        const startRadiusDrag = (e) => {
            const moveHandler = (moveEvent) => onRadiusDrag(moveEvent);
            const endDrag = () => {
                document.removeEventListener('mousemove', moveHandler);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchmove', moveHandler);
                document.removeEventListener('touchend', endDrag);
            };
            document.addEventListener('mousemove', moveHandler);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchmove', moveHandler);
            document.addEventListener('touchend', endDrag);
        };
        radiusThumb.addEventListener('mousedown', startRadiusDrag);
        radiusThumb.addEventListener('touchstart', startRadiusDrag);
        updateRadiusVisuals();
    }
    
    function handleMapClick(e) {
        const lngLat = e.lngLat;
        currentReminderLocation = { latitude: lngLat.lat, longitude: lngLat.lng };
        updateMarkerAndCircle(currentReminderLocation, Math.round(currentRadius));
        resetAndStartCountdown();
    }
    
    function updateMarkerAndCircle(coords, radius) {
        if (!reminderModalMap || !coords) return;
        const lngLat = [coords.longitude, coords.latitude];
        
        if (!reminderMarker) {
            const vehicleEl = document.createElement('div');
            vehicleEl.innerHTML = `<div style="width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;"><img src="PNG/AVANCE.PNG" style="width: 100%; height: 100%; object-fit: contain;"></div>`;
            reminderMarker = new mapboxgl.Marker({ element: vehicleEl, draggable: true })
                .setLngLat(lngLat)
                .addTo(reminderModalMap);
            reminderMarker.on('dragend', handleMarkerDragEnd);
        } else {
            reminderMarker.setLngLat(lngLat);
        }
        
        const circleId = 'reminder-circle';
        const circlePolygon = turf.circle(lngLat, radius, { steps: 64, units: 'meters' });

        if (reminderModalMap.getSource(circleId)) {
            reminderModalMap.getSource(circleId).setData(circlePolygon);
        } else {
            reminderModalMap.addSource(circleId, { 'type': 'geojson', 'data': circlePolygon });
            
            const isRadarType = textInput.value.toUpperCase().includes("RADAR") || excludeFromListCheckbox.checked;
            
            // *** INICIO DE LA CORRECCIÓN 2 ***
            const circleFillColor = isRadarType ? 'rgba(255, 255, 0, 0.3)' : 'rgba(37, 99, 235, 0.3)';
            const circleStrokeColor = isRadarType ? '#FFD700' : '#2563EB';

            reminderModalMap.addLayer({
                'id': circleId,
                'type': 'fill',
                'source': circleId,
                'paint': {
                    'fill-color': circleFillColor,
                    'fill-outline-color': circleStrokeColor
                }
            });
            // *** FIN DE LA CORRECCIÓN 2 ***
        }
    }
    
    function handleMarkerDragEnd(event) {
        const lngLat = event.target.getLngLat();
        currentReminderLocation = { latitude: lngLat.lat, longitude: lngLat.lng };
        updateMarkerAndCircle(currentReminderLocation, Math.round(currentRadius));
        resetAndStartCountdown();
    }
    
    function handleLocationCheckboxChange() {
        const wasEnabled = locationEnabledByUser;
        locationEnabledByUser = locationCheckbox.checked;
        if (locationEnabledByUser) {
            if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && currentReminderLocation) {
                initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false);
            } else if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && !currentReminderLocation) {
                destroyMap();
            }
             if (!currentReminderLocation && !wasEnabled) {
                getCurrentLocation( (coords) => { currentReminderLocation = coords; if (!mapExpandedManually && !mapContainer.classList.contains('expanded') && currentReminderLocation) { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false); } });
            }
        } else {
            destroyMap();
        }
        resetAndStartCountdown();
    }
    
    if (deleteButton) {
        deleteButton.addEventListener('click', () => {
            cleanUpModalTimers(true);
            const mapShouldReopen = mapShouldReopenAfterForm;
            const mapContextToReopen = mapContextBeforeThisModal;
            
            if (!isNew) {
                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const initialLength = reminders.length;
                reminders = reminders.filter(r => r.id !== parsed.id);
                if (reminders.length < initialLength) {
                    localStorage.setItem('reminders', JSON.stringify(reminders));
                    markRemindersCacheAsDirty();
                    if (isNavigationMapActive) {
                        plotRemindersOnNavigationMap(); // <-- CORRECCIÓN
                    }
                } else { 
                    showToast('Recordatorio no encontrado para borrar.', 'warning');
                }
            }

            destroyMap();
            if (modal.parentNode) modal.parentNode.removeChild(modal);
            updateReminderCount(); 
            updateButtonStyles(); 
            checkReminders();

            if (mapShouldReopen && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !isNavigationMapActive) {
                if (mapContextToReopen === 'navigation') openNavigationMap();
            } else if (mapShouldReopen) {
                 sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true');
                 if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen);
            }
            sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
        });
    }

    if (manageLocationsBtn) {
        manageLocationsBtn.addEventListener('click', () => {
            showSavedLocationsModal( () => { }, (selectedLocationData) => {
                    if (selectedLocationData && typeof selectedLocationData.lat === 'number' && typeof selectedLocationData.lng === 'number') {
                        currentReminderLocation = { latitude: selectedLocationData.lat, longitude: selectedLocationData.lng };
                        locationCheckbox.checked = true; locationEnabledByUser = true;
                        toggleLocationControlsVisibility();
                        currentRadius = typeof selectedLocationData.radius === 'number' && selectedLocationData.radius > 0 ? selectedLocationData.radius : DEFAULT_LOCATION_RADIUS;
                        updateRadiusVisuals();
                        if (mapContainer.classList.contains('expanded')) { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), true); } 
                        else { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false); }
                        showToast(`Ubicación "${selectedLocationData.name || 'Seleccionada'}" aplicada.`, "success");
                        resetAndStartCountdown();
                    } else { showToast("Error: Datos de ubicación seleccionada no válidos.", "error"); }
                }, { parentContainer: modal } 
            );
        });
    }

    locationCheckbox.addEventListener('change', handleLocationCheckboxChange);
    if (parsed.isLocationEnabled && parsed.locationCoordinates) { initializeOrUpdateMap(parsed.locationCoordinates, parsed.radiusMeters, false); } 
    else if (parsed.isLocationEnabled && !parsed.locationCoordinates) { destroyMap(); } 
    else { destroyMap(); }

    if (expandMapButton) {
        expandMapButton.addEventListener('click', () => {
            if (!locationCheckbox.checked) { locationCheckbox.checked = true; toggleLocationControlsVisibility(); }
            locationEnabledByUser = true; mapExpandedManually = true;
            if (!currentReminderLocation) {
                locateMeButton.disabled = true; locateMeButton.textContent = 'Buscando...';
                getCurrentLocation(
                    (gpsCoords) => {
                        currentReminderLocation = { latitude: gpsCoords.latitude, longitude: gpsCoords.longitude };
                        initializeOrUpdateMap(gpsCoords, Math.round(currentRadius), true);
                        if (reminderModalMap) { reminderModalMap.flyTo({ zoom: 16 }); }
                        locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ';
                    }, (errorMsg) => {
                        initializeOrUpdateMap(null, Math.round(currentRadius), true);
                        if (reminderModalMap) { reminderModalMap.flyTo({ zoom: 6 }); }
                        showToast(`Error GPS: ${errorMsg}. Mapa centrado por defecto`, "warning", 3000);
                        locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ';
                    }
                );
            } else { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), true); }
            resetAndStartCountdown();
            setTimeout(() => { mapExpandedManually = false; }, 100);
        });
    }

    if (reduceMapButton) { reduceMapButton.addEventListener('click', () => { if (locationEnabledByUser && currentReminderLocation) { initializeOrUpdateMap(currentReminderLocation, Math.round(currentRadius), false); } else { destroyMap(); } resetAndStartCountdown(); }); }
    if (locateMeButton) {
        locateMeButton.addEventListener('click', () => {
             if (!reminderModalMap || !mapContainer.classList.contains('expanded')) return;
             resetAndStartCountdown(); locateMeButton.disabled = true; locateMeButton.textContent = 'Buscando...';
             getCurrentLocation(
                 (coords) => {
                     currentReminderLocation = { latitude: coords.latitude, longitude: coords.longitude };
                     if (reminderModalMap) { reminderModalMap.flyTo({center: [coords.longitude, coords.latitude], zoom: 16}); updateMarkerAndCircle(coords, Math.round(currentRadius)); }
                     locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ';
                 }, (errorMsg) => { showToast(`Error al localizar: ${errorMsg}`, 'error'); locateMeButton.disabled = false; locateMeButton.textContent = 'ESTÁS AQUÍ'; }
             );
        });
    }

    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) { } 
    else { speechStatus.textContent = 'Dictado no soportado.'; speechStatus.style.color = '#EF4444'; }

    function startCountdown() { autoSaveInterval = setInterval(() => { if (!document.body.contains(modal)) { clearInterval(autoSaveInterval); autoSaveInterval = null; return; } countdownSave--; if (countdownSaveElement) countdownSaveElement.textContent = countdownSave; if (countdownSave === 23) { if (document.activeElement === textInput) { textInput.value += ' '; textInput.selectionStart = textInput.selectionEnd = textInput.value.length; } } if (countdownSave <= 0) { clearInterval(autoSaveInterval); autoSaveInterval = null; if (saveButton) saveButton.click(); } }, 1000); }
    function resetAndStartCountdown() { countdownSave = 25; if (countdownSaveElement) countdownSaveElement.textContent = countdownSave; if (autoSaveInterval) { clearInterval(autoSaveInterval); autoSaveInterval = null; } startCountdown(); }
    
    timeInput.addEventListener('input', (e) => {
        manualTimeInput = true;
        let v = e.target.value.replace(/\D/g, '');
        let fV = '';
        if (v.length >= 2) fV = v.slice(0, 2);
        if (v.length > 2) fV += ':' + v.slice(2, 4);
        else if (v.length < 2) fV = v;
        e.target.value = fV;
        if (fV.match(/^\d{2}:\d{2}$/)) {
            const [h, m] = fV.split(':').map(Number);
            parseStatus.textContent = (h > 23 || m > 59) ? 'Hora inválida' : '';
            parseStatus.classList.toggle('text-red-600', h > 23 || m > 59);
            parseStatus.classList.remove('text-green-600');
        } else if (fV.length > 0) {
            parseStatus.textContent = 'Formato HH:MM';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        } else {
            parseStatus.textContent = '';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        }
        resetAndStartCountdown();
    });

    dateInput.addEventListener('input', (e) => {
        let v = e.target.value.replace(/\D/g, '');
        let fV = '';
        if (v.length >= 2) fV = v.slice(0, 2);
        if (v.length > 2) fV += '/' + v.slice(2, 4);
        if (v.length > 4) fV += '/' + v.slice(4, 8);
        else if (v.length < 2) fV = v;
        e.target.value = fV;
        if (fV.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
            const [d, m, y] = fV.split('/').map(Number);
            const dt = new Date(Date.UTC(y, m - 1, d));
            const ok = !isNaN(dt.getTime()) && dt.getUTCDate() === d && dt.getUTCMonth() + 1 === m && y >= 2000 && y <= 2099;
            parseStatus.textContent = ok ? '' : 'Fecha inválida';
            parseStatus.classList.toggle('text-red-600', !ok);
            parseStatus.classList.remove('text-green-600');
        } else if (fV.length > 0) {
            parseStatus.textContent = 'Formato DD/MM/AAAA';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        } else {
            parseStatus.textContent = '';
            parseStatus.classList.remove('text-red-600', 'text-green-600');
        }
        resetAndStartCountdown();
    });

    intervalInput.addEventListener('input', resetAndStartCountdown);
    modal.querySelectorAll('input[name="repeat"]').forEach(chk => chk.addEventListener('change', resetAndStartCountdown));
    
    if (countdownSaveElement) countdownSaveElement.textContent = countdownSave;

    function startFocusCheck() {
        if (restartTimeout) clearTimeout(restartTimeout);
        restartTimeout = setTimeout(() => {
            if (document.activeElement !== textInput && document.activeElement !== timeInput && document.activeElement !== dateInput && document.activeElement !== intervalInput && !Array.from(modal.querySelectorAll('input[name="repeat"]')).includes(document.activeElement) && document.activeElement !== saveButton && document.activeElement !== modal.querySelector('#cancel-reminder') && document.activeElement !== modal.querySelector('#help-reminder') && document.activeElement !== clearButton && document.activeElement !== modal.querySelector('#view-reminders') && document.activeElement !== locationCheckbox && document.activeElement !== radiusThumb && document.activeElement !== expandMapButton && document.activeElement !== reduceMapButton && document.activeElement !== locateMeButton && !(reminderModalMap && reminderModalMap.getCanvasContainer().contains(document.activeElement))) {
                resetAndStartCountdown();
                restartTimeout = null;
            } else {
                restartTimeout = null;
            }
        }, 500);
    }

    resetAndStartCountdown();
    startFocusCheck();
    modal.addEventListener('input', resetAndStartCountdown);
    modal.addEventListener('click', resetAndStartCountdown);
    modal.addEventListener('touchstart', resetAndStartCountdown, { passive: true });
    modal.addEventListener('focusin', () => {
        resetAndStartCountdown();
        if (focusTimeout) clearTimeout(focusTimeout);
        focusTimeout = null;
    });
    modal.addEventListener('focusout', () => {
        if (!focusTimeout) {
            startFocusCheck();
        }
    });

    textInput.addEventListener('input', (e) => {
        lastInputWasSpeech = false;
        const txt = e.target.value || '';
        parseStatus.textContent = 'Analizando...';
        parseStatus.classList.remove('text-green-600', 'text-red-600');
        if (parseTimeout) clearTimeout(parseTimeout);
        parseTimeout = setTimeout(() => {
            if (!document.body.contains(modal)) return;
            try {
                const uiElements = {
                    timeInput: timeInput,
                    dateInput: dateInput,
                    intervalInput: intervalInput,
                    repeatCheckboxes: modal.querySelectorAll('input[name="repeat"]'),
                    locationCheckbox: locationCheckbox,
                    radiusInput: null,
                    manualTimeInput: manualTimeInput,
                    mapExpandedManually: mapExpandedManually,
                    excludeFromListCheckbox: excludeFromListCheckbox
                };
                if (!manualTimeInput) uiElements.timeInput.value = '';
                uiElements.dateInput.value = '';
                uiElements.intervalInput.value = '';
                uiElements.repeatCheckboxes.forEach(chk => chk.checked = false);
                const pD = parseReminderText(txt, uiElements);
                
                if(pD.radiusMeters) {
                    currentRadius = pD.radiusMeters;
                    updateRadiusVisuals();
                }

                if (isNew && (pD.type === 'weekly' || pD.type === 'interval')) {
                    const tempReminderForCalc = { type: pD.type, time: pD.time, date: pD.date, repeatDays: pD.repeatDays, intervalDays: pD.intervalDays };
                    const nowForCalc = new Date();
                    if (!tempReminderForCalc.date) tempReminderForCalc.date = `${nowForCalc.getFullYear()}-${(nowForCalc.getMonth() + 1).toString().padStart(2, '0')}-${nowForCalc.getDate().toString().padStart(2, '0')}`;
                    if (!tempReminderForCalc.time) tempReminderForCalc.time = '00:01';
                    const firstOcc = calculateNextOccurrence(tempReminderForCalc, new Date());
                    if (firstOcc) {
                        const firstOccISO = `${firstOcc.getUTCFullYear()}-${(firstOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOcc.getUTCDate().toString().padStart(2, '0')}`;
                        const firstOccTime = `${firstOcc.getUTCHours().toString().padStart(2, '0')}:${firstOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                        pD.date = firstOccISO;
                        pD.time = firstOccTime;
                        const datePartsCalc = pD.date.split('-');
                        if (datePartsCalc.length === 3) dateInput.value = `${datePartsCalc[2]}/${datePartsCalc[1]}/${datePartsCalc[0]}`;
                        if (!manualTimeInput) timeInput.value = pD.time;
                    } else {
                        if (!pD.date) { const today = new Date(); pD.date = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}-${today.getDate().toString().padStart(2, '0')}`; }
                        if (!pD.time) pD.time = '00:01';
                        const datePartsFb = pD.date.split('-');
                        if (datePartsFb.length === 3) dateInput.value = `${datePartsFb[2]}/${datePartsFb[1]}/${datePartsFb[0]}`;
                        if (!manualTimeInput) timeInput.value = pD.time;
                    }
                }
                parseStatus.textContent = 'OK';
                parseStatus.classList.add('text-green-600');
                parseStatus.classList.remove('text-red-600');
                toggleLocationControlsVisibility();
                handleLocationCheckboxChange();
            } catch (error) {
                parseStatus.textContent = `Error: ${error.message.substring(0, 100)}`;
                parseStatus.classList.add('text-red-600');
                parseStatus.classList.remove('text-green-600');
            }
            parseTimeout = null;
        }, 1000);
        resetAndStartCountdown();
    });

    saveButton.addEventListener('click', (e) => {
        e.preventDefault();
        const form = modal.querySelector('#reminder-form');
        if (form.checkValidity && !form.checkValidity()) { form.reportValidity(); return; }
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        const mapContextToReopen = mapContextBeforeThisModal;
        const text = textInput.value.trim();
        if (!text) { parseStatus.textContent = 'Texto obligatorio.'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; }
        let time = timeInput.value.trim();
        let dateStr = dateInput.value.trim();
        const repeatDays = Array.from(modal.querySelectorAll('input[name="repeat"]:checked')).map(input => parseInt(input.value));
        const intervalDays = parseInt(intervalInput.value) || null;
        const isLocationChecked = locationCheckbox.checked;
        const radius = Math.round(currentRadius);
        const locationCoords = currentReminderLocation;
        const excludeFromListVal = excludeFromListCheckbox.checked;
        if (isLocationChecked && !locationCoords) { parseStatus.textContent = 'Ubicación activada pero no fijada en el mapa.'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; }
        let dateISO = null; let finalTime = time; let reminderType = 'simple';
        if (dateStr) { if (dateStr.match(/^\d{2}\/\d{2}\/\d{4}$/)) { const [d, m, y] = dateStr.split('/').map(Number); const tD = new Date(Date.UTC(y, m - 1, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() + 1 === m && y >= 2000 && y <= 2099) { dateISO = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } else { parseStatus.textContent = 'Fecha inválida'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } } else { parseStatus.textContent = 'Formato DD/MM/AAAA'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } }
        if (finalTime && !finalTime.match(/^\d{2}:\d{2}$/)) { parseStatus.textContent = 'Formato HH:MM'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } else if (finalTime) { const [h, m] = finalTime.split(':').map(Number); if (h > 23 || m > 59) { parseStatus.textContent = 'Hora inválida'; parseStatus.classList.add('text-red-600'); resetAndStartCountdown(); return; } }
        if (intervalDays !== null && intervalDays > 0) { reminderType = 'interval'; if (!dateISO) { const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } if (!finalTime) finalTime = '00:01'; } 
        else if (repeatDays.length > 0) { reminderType = 'weekly'; if (!dateISO) { const tempCalc = { type: 'weekly', time: finalTime || '00:01', date: null, repeatDays: repeatDays, intervalDays: null }; const firstOcc = calculateNextOccurrence(tempCalc, new Date()); if (firstOcc) { dateISO = `${firstOcc.getUTCFullYear()}-${(firstOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOcc.getUTCDate().toString().padStart(2, '0')}`; finalTime = finalTime || `${firstOcc.getUTCHours().toString().padStart(2, '0')}:${firstOcc.getUTCMinutes().toString().padStart(2, '0')}`; } else { const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; if (!finalTime) finalTime = '00:01'; } } else { if (!finalTime) finalTime = '00:01'; } } 
        else if (dateISO && finalTime) { reminderType = 'daily'; } else if (finalTime) { reminderType = 'daily'; const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (dateISO) { reminderType = 'daily'; finalTime = '00:01'; } 
        else { reminderType = 'simple'; const now = new Date(); dateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; finalTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`; }
        const now = new Date(); const finalCreatedAt = isNew ? now.toISOString() : (parsed.createdAt || now.toISOString()); let finalDateISO = dateISO;
        if (isNew && (reminderType === 'weekly' || reminderType === 'interval')) { let needsRecalc = false; if (!dateInput.value.trim()) { needsRecalc = true; } else { try { const [d, m, y] = dateStr.split('/').map(Number); const inputDate = new Date(Date.UTC(y, m - 1, d)); const todayForCompare = new Date(now.getFullYear(), now.getMonth(), now.getDate()); if (inputDate < todayForCompare) { needsRecalc = true; } } catch (e) { needsRecalc = true; } } if (needsRecalc) { const tempCalcForNewCyclic = { type: reminderType, time: finalTime || '00:01', date: null, repeatDays: reminderType === 'weekly' ? repeatDays : [], intervalDays: reminderType === 'interval' ? intervalDays : null }; const firstOccurrence = calculateNextOccurrence(tempCalcForNewCyclic, new Date()); if (firstOccurrence) { finalDateISO = `${firstOccurrence.getUTCFullYear()}-${(firstOccurrence.getUTCMonth() + 1).toString().padStart(2, '0')}-${firstOccurrence.getUTCDate().toString().padStart(2, '0')}`; } else { if (!finalDateISO) { finalDateISO = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } } } }
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        const newReminder = { id: isNew ? Date.now() : parsed.id, text: `<b>${text.toUpperCase()}</b>`, type: reminderType, time: finalTime || null, date: finalDateISO, repeatDays: reminderType === 'weekly' ? repeatDays : [], intervalDays: reminderType === 'interval' ? intervalDays : null, createdAt: finalCreatedAt, managedByUser: false, isLocationEnabled: isLocationChecked, locationCoordinates: isLocationChecked ? locationCoords : null, radiusMeters: isLocationChecked ? radius : (parsed.radiusMeters || (text.toUpperCase().startsWith("RADAR") ? 350 : DEFAULT_LOCATION_RADIUS)), excludeFromList: excludeFromListVal, isFromRuta: parsed.isFromRuta || false };
        if (!newReminder.date || !newReminder.time || !newReminder.createdAt) { showToast("Error GRAVE: Fechas/Hora inválidas al guardar", "error"); resetAndStartCountdown(); return; }
        if (options.onTopOfMap) { const mapObjectIndex = reminderMapObjects.findIndex(obj => obj.reminderId === newReminder.id); if (mapObjectIndex !== -1) { const { marker, circleId } = reminderMapObjects[mapObjectIndex]; if (marker) marker.remove(); if (circleId && navigationMapInstance.getLayer(circleId)) navigationMapInstance.removeLayer(circleId); if (circleId && navigationMapInstance.getSource(circleId)) navigationMapInstance.removeSource(circleId); reminderMapObjects.splice(mapObjectIndex, 1); } if(navigationMapInstance) { const newMapObject = plotSingleReminderOnMap(newReminder, navigationMapInstance); if(newMapObject) reminderMapObjects.push(newMapObject); } }
        if (!isNew) { const index = reminders.findIndex(r => r.id === parsed.id); if (index !== -1) { reminders[index] = newReminder; } else { newReminder.id = Date.now() + Math.random(); reminders.push(newReminder); } } else { reminders.push(newReminder); }
        localStorage.setItem('reminders', JSON.stringify(reminders)); 
        markRemindersCacheAsDirty();
        destroyMap();
        if (modal.parentNode) modal.parentNode.removeChild(modal);
        updateReminderCount(); updateButtonStyles(); checkReminders();
        if (!options.onTopOfMap) { const unifiedWindowIsVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible'); if (mapShouldReopen && !unifiedWindowIsVisible && !isNavigationMapActive) { if (mapContextToReopen === 'navigation') openNavigationMap(); } else if (mapShouldReopen && unifiedWindowIsVisible) { sessionStorage.setItem('boardinggate_map_should_reopen_when_unified_closes', 'true'); if (mapContextToReopen) sessionStorage.setItem('mapContext', mapContextToReopen); } }
        sessionStorage.removeItem('boardinggate_map_should_reopen_after_form'); sessionStorage.removeItem('mapContext');
    });

    modal.querySelector('#cancel-reminder').addEventListener('click', () => {
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        const mapContextToReopen = mapContextBeforeThisModal;
        destroyMap();
        if (modal.parentNode) modal.parentNode.removeChild(modal);
        const unifiedWindowIsVisible = document.getElementById('unified-reminder-window')?.classList.contains('visible');
        if (mapShouldReopen && !unifiedWindowIsVisible && !isNavigationMapActive) { if (mapContextToReopen === 'navigation') openNavigationMap(); }
        sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
        sessionStorage.removeItem('mapContext');
    });

    modal.querySelector('#help-reminder').addEventListener('click', () => { showHelpModal({ parentContainer: modal }); });

    clearButton.addEventListener('click', () => {
        textInput.value=''; timeInput.value=''; dateInput.value='';
        modal.querySelectorAll('input[name="repeat"]').forEach(i=>i.checked=false);
        intervalInput.value=''; locationCheckbox.checked = false; toggleLocationControlsVisibility();
        currentRadius = parsed.radiusMeters || DEFAULT_LOCATION_RADIUS; updateRadiusVisuals();
        currentReminderLocation = null; destroyMap();
        excludeFromListCheckbox.checked = false; parseStatus.textContent=''; speechStatus.textContent=''; manualTimeInput=false;
        resetAndStartCountdown(); textInput.focus();
    });

    modal.querySelector('#view-reminders').addEventListener('click', () => {
        cleanUpModalTimers(true);
        const mapShouldReopen = mapShouldReopenAfterForm;
        const mapContextToReopen = mapContextBeforeThisModal;
        destroyMap();
        if (modal.parentNode) modal.parentNode.removeChild(modal);
        fromReminderModal = true;
        if (mapShouldReopen) {
            sessionStorage.setItem('boardinggate_map_was_open_before_table', 'true');
            if (mapContextToReopen) {
                sessionStorage.setItem('mapContext', mapContextToReopen);
            }
        }
        showAllReminders();
    });
    
    textInput.focus();
}

// ===================================================================
// NOMBRE: markReminderAsManaged (MODIFICADA - Llama a la nueva función de caché)
// RESUMEN: Marca un recordatorio como gestionado y marca la caché como sucia.
function markReminderAsManaged(reminderId, managedState = true) {
     if (typeof reminderId !== 'number') { return; } try { let reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); const index = reminders.findIndex(r => r.id === reminderId); if (index !== -1) { if (reminders[index].managedByUser !== managedState) { reminders[index].managedByUser = managedState; localStorage.setItem('reminders', JSON.stringify(reminders)); 
     markRemindersCacheAsDirty(); } } } catch (e) { }
}

    
// ===================================================================
// NOMBRE: addSlideButtonListeners (MODIFICADA - Llama a la nueva función de caché)
// RESUMEN: Añade listeners a los botones del slide y marca la caché como sucia en cada modificación.
function addSlideButtonListeners(slideElement, reminder) {
        const reminderId = reminder.id;
        const cancelButton = slideElement.querySelector('.cancel');
        const adjustTimeButton = slideElement.querySelector('.adjust-time-0001');
        const cancelCyclicButton = slideElement.querySelector('.cancel-cyclic');
        const modifyButton = slideElement.querySelector('.modify');
        const postponeButton = slideElement.querySelector('.postpone');
        const routeRadarVistoButton = slideElement.querySelector('.route-radar-seen');
        const handleInteraction = (actionFn) => {
            markReminderAsManaged(reminderId, true);
            actionFn();
            updateUnifiedWindowUI(processedReminderId);
        };
        let processedReminderId = reminderId;
        if (routeRadarVistoButton) {
            routeRadarVistoButton.addEventListener('click', () => {
                const minutesToSnooze = 5;
                markReminderAsManaged(reminder.id, true);
                
                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                const index = reminders.findIndex(r => r.id === reminder.id);

                if (index !== -1) {
                    const { newDateISO, newTime } = calculatePostponedDateTime(minutesToSnooze);
                    
                    // Actualizamos localStorage
                    reminders[index].date = newDateISO;
                    reminders[index].time = newTime;
                    reminders[index].managedByUser = false;
                    localStorage.setItem('reminders', JSON.stringify(reminders));
                    
                    // >>> INICIO DE LA CORRECCIÓN CLAVE <<<
                    // Buscamos el mismo radar en el array de ruta activo y lo actualizamos en memoria.
                    const radarEnRutaIndex = radaresEnRutaActual.findIndex(r => r.id === reminder.id);
                    if (radarEnRutaIndex !== -1) {
                        const newDueTime = new Date(`${newDateISO}T${newTime}:00Z`).getTime();
                        console.log(`[POSTPONE] Antes: Radar en ruta ID ${reminder.id}, Vence: ${new Date(radaresEnRutaActual[radarEnRutaIndex].dueTimeUTC).toLocaleTimeString()}`);
                        
                        radaresEnRutaActual[radarEnRutaIndex].date = newDateISO;
                        radaresEnRutaActual[radarEnRutaIndex].time = newTime;
                        radaresEnRutaActual[radarEnRutaIndex].dueTimeUTC = newDueTime; // ¡Actualización crucial!
                        
                        console.log(`[POSTPONE] Después: Radar en ruta ID ${reminder.id}, Vence AHORA: ${new Date(radaresEnRutaActual[radarEnRutaIndex].dueTimeUTC).toLocaleTimeString()}`);
                    }
                    // >>> FIN DE LA CORRECCIÓN CLAVE <<<

                    markRemindersCacheAsDirty();
                    showToast(`Radar pospuesto ${minutesToSnooze} minutos`, 'info');
                } else {
                    showToast("Error: No se pudo encontrar el radar para posponer.", "error");
                }
                
                updateUnifiedWindowUI(reminder.id);
            });
        }
        if (cancelButton) {
            cancelButton.addEventListener('click', () => { 
                if (reminder.isFromRuta === true) { 
                    showToast(`Radar en ruta "${reminder.text.replace(/<[^>]*>/g, '')}" marcado como visto para esta alerta.`, 'info');
                    updateUnifiedWindowUI(reminder.id); 
                    markReminderAsManaged(reminder.id, true); 
                } else { 
                    handleInteraction(() => { 
                        let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                        const index = rems.findIndex(r => r.id === processedReminderId); 
                        if (index === -1) {
                            showToast("Error: No se encontró el recordatorio en localStorage para actualizar.", "error");
                            return;
                        }
                        const currentReminder = rems[index];
                        let needsSave = false;
                        const isRadarTypeStored = currentReminder.text.toUpperCase().includes("RADAR") || currentReminder.excludeFromList;
                        if (isRadarTypeStored) { 
                           const minutesToPostponeRadar = 15;
                           const { newDateISO, newTime } = calculatePostponedDateTime(minutesToPostponeRadar);
                           rems[index].date = newDateISO;
                           rems[index].time = newTime;
                           rems[index].managedByUser = false;
                           needsSave = true;
                           showToast(`Radar guardado pospuesto ${minutesToPostponeRadar} minutos`, 'info');
                        } else if (currentReminder.isLocationEnabled && (currentReminder.type !== 'weekly' && currentReminder.type !== 'interval')) {
                           const minutesToPostponeLocation = 15; 
                           const { newDateISO, newTime } = calculatePostponedDateTime(minutesToPostponeLocation);
                           rems[index].date = newDateISO;
                           rems[index].time = newTime;
                           rems[index].managedByUser = false;
                           needsSave = true;
                           showToast(`Recordatorio de ubicación pospuesto ${minutesToPostponeLocation} minutos`, 'info');
                        } else if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                            let referenceDateForNext = new Date();
                            try {
                                const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                                const [ch, cmin] = (currentReminder.time || '00:01').split(':').map(Number);
                                const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, ch, cmin));
                                if (!isNaN(reminderDateTime.getTime())) {
                                    referenceDateForNext = new Date(reminderDateTime.getTime() + 60000); 
                                }
                            } catch(er) {  }
                            const nextOcc = calculateNextOccurrence(currentReminder, referenceDateForNext);
                            if (nextOcc) {
                                rems[index].date = `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                                rems[index].time = `${nextOcc.getUTCHours().toString().padStart(2, '0')}:${nextOcc.getUTCMinutes().toString().padStart(2, '0')}`;
                                rems[index].managedByUser = false;
                                needsSave = true;
                                showToast('Recordatorio actualizado al próximo ciclo', 'info');
                            } else {
                                rems.splice(index, 1); needsSave = true;
                                showToast('Error calculando siguiente ciclo. Recordatorio eliminado.', 'error');
                            }
                        } else {
                           rems.splice(index, 1);
                           needsSave = true;
                           showToast('Recordatorio inmediato marcado como visto y eliminado.', 'info');
                        }
                        if (needsSave) {
                            localStorage.setItem('reminders', JSON.stringify(rems));
                            markRemindersCacheAsDirty();
                        }
                    }); 
                } 
            });
        }
        if (adjustTimeButton) {
            adjustTimeButton.addEventListener('click', () => handleInteraction(() => {
                let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                const index = rems.findIndex(r => r.id === processedReminderId);
                if (index === -1) return;
                const currentReminder = rems[index];
                let needsSave = false;
                if (currentReminder.type === 'weekly' || currentReminder.type === 'interval') {
                     let referenceDateForNext = new Date();
                     try {
                         const [cy, cm, cd] = currentReminder.date.split('-').map(Number);
                         const reminderDateTime = new Date(Date.UTC(cy, cm - 1, cd, 0, 1)); 
                         if (!isNaN(reminderDateTime.getTime())) {
                             referenceDateForNext = new Date(reminderDateTime.getTime() + 60000); 
                         }
                     } catch(e) {  }
                    const reminderForCalc = { ...currentReminder, time: '00:01' };
                    const nextOcc = calculateNextOccurrence(reminderForCalc, referenceDateForNext);
                    if (nextOcc) {
                        rems[index].date= `${nextOcc.getUTCFullYear()}-${(nextOcc.getUTCMonth() + 1).toString().padStart(2, '0')}-${nextOcc.getUTCDate().toString().padStart(2, '0')}`;
                        rems[index].time = '00:01';
                        rems[index].managedByUser = false;
                        needsSave = true;
                        showToast('Recordatorio ajustado a 00:01 y actualizado', 'info');
                    } else {
                        rems.splice(index, 1); needsSave = true;
                        showToast('Error calculando siguiente ciclo (ajuste 00:01). Eliminado.', 'error');
                    }
                } else { 
                    rems.splice(index, 1); needsSave = true;
                    showToast('Recordatorio no cíclico eliminado (acción "Ajustar 00:01")', 'info');
                }
                if (needsSave) {
                    localStorage.setItem('reminders', JSON.stringify(rems));
                    markRemindersCacheAsDirty();
                }
            }));
        }
        if (cancelCyclicButton) {
            cancelCyclicButton.addEventListener('click', () => handleInteraction(() => {
                if (confirm('¿Estás seguro de ANULAR este ciclo de recordatorio PERMANENTEMENTE?')) {
                    let rems = JSON.parse(localStorage.getItem('reminders') || '[]');
                    const initialLength = rems.length;
                    rems = rems.filter(r => r.id !== processedReminderId);
                    if (rems.length < initialLength) {
                       localStorage.setItem('reminders', JSON.stringify(rems)); 
                       markRemindersCacheAsDirty();
                       showToast('Ciclo de recordatorio anulado permanentemente', 'success');
                    } else {
                        showToast('Error: No se encontró el ciclo para anular.', 'warning');
                    }
                } else {
                    markReminderAsManaged(processedReminderId, false); 
                }
            }));
        }
        if (modifyButton) {
            modifyButton.addEventListener('click', () => {
                markReminderAsManaged(reminder.id, true);
                let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                let reminderToModify = remindersFromStorage.find(r => r.id === reminder.id);
                if (!reminderToModify && reminder.isFromRuta) {
                   reminderToModify = { ...reminder };
                   reminderToModify.isFromRuta = false;
                }
                const mapIsVisible = document.getElementById('reminders-location-map-modal') && !document.getElementById('reminders-location-map-modal').classList.contains('hidden');
                const mapShouldReopenWhenUnifiedCloses = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                const mapContextBeforeUnified = sessionStorage.getItem('mapContext');
                hideUnifiedReminderWindow();
                if (reminderToModify) {
                    if (mapShouldReopenWhenUnifiedCloses) {
                         sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                         if (mapContextBeforeUnified) {
                           sessionStorage.setItem('mapContext', mapContextBeforeUnified);
                         }
                    }
                    showReminderModal(reminderToModify, { onTopOfMap: mapIsVisible });
                }
                else {
                    showToast("Error: no se pudo encontrar el recordatorio para modificar.", "error");
                    updateUnifiedWindowUI(reminder.id);
                    if (mapShouldReopenWhenUnifiedCloses &&
                        sessionStorage.getItem('boardinggate_map_should_reopen_after_form') !== 'true' &&
                        !document.getElementById('reminders-location-map-modal')
                       ) {
                        if (mapContextBeforeUnified === 'navigation') openNavigationMap();
                         sessionStorage.removeItem('mapContext');
                    }
                }
                sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
            });
        }
        if (postponeButton) {
            postponeButton.addEventListener('click', () => {
                markReminderAsManaged(processedReminderId, true); 
                let reminderToPostpone;
                if (reminder.isFromRuta) {
                    showToast(`Radar en ruta "${reminder.text.replace(/<[^>]*>/g, '')}" marcado como visto (acción Posponer).`, 'info');
                    updateUnifiedWindowUI(reminder.id);
                    return; 
                } else {
                    let remindersFromStorage = JSON.parse(localStorage.getItem('reminders') || '[]');
                    reminderToPostpone = remindersFromStorage.find(r => r.id === processedReminderId);
                }
                if (reminderToPostpone) {
                    showPostponeOptionsModal(reminderToPostpone, 'unified');
                }
                else {
                    showToast("Error: no se pudo encontrar el recordatorio para posponer", "error");
                    updateUnifiedWindowUI(processedReminderId); 
                }
            });
        }
    }


    
    










    

    
// ===================================================================
// NOMBRE: checkAndIncrementPoiCount (VERSIÓN CORREGIDA PARA CLIENTE)
// RESUMEN: Verifica el límite global y actualiza el contador del usuario
//          usando operaciones de lectura y escritura separadas.
// ===================================================================
async function checkAndIncrementPoiCount() {
    const { primaryId: userId } = parseUserId(localStorage.getItem('userData_userId'));
    if (!userId || !window.db) return false;

    const GLOBAL_POI_LIMIT = 7000;

    try {
        // 1. Obtener estadísticas globales para comprobar el límite total
        const globalStats = await getGlobalPoiStats();
        if (globalStats.totalMonth >= GLOBAL_POI_LIMIT) {
            showToast("Servicio de POI temporalmente inactivo (límite mensual alcanzado).", "warning");
            return false; // Bloquear si se ha alcanzado el límite global
        }

        // 2. Si el límite global está bien, proceder a actualizar el contador del usuario
        const userDocRef = window.doc(window.db, "user_data", userId);
        const userDocSnap = await window.getDoc(userDocRef);
        
        const now = new Date();
        const monthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        let dataToUpdate = {};

        if (!userDocSnap.exists()) {
            // Si el usuario no existe en la BD, se crea con el primer clic
            dataToUpdate = {
                poi_clicks_last_month: monthStr,
                poi_clicks_month: 1
            };
        } else {
            const userData = userDocSnap.data();
            let newMonthCount = 1;
            if (userData.poi_clicks_last_month === monthStr) {
                newMonthCount = (userData.poi_clicks_month || 0) + 1;
            }
            
            dataToUpdate = {
                poi_clicks_last_month: monthStr,
                poi_clicks_month: newMonthCount
            };
        }

        // Realizamos la escritura en la base de datos
        await window.setDoc(userDocRef, dataToUpdate, { merge: true });

        return true; // Permitir la llamada a la API

    } catch (error) {
        console.error("Error al verificar/incrementar el contador de POIs:", error);
        showToast("Error al verificar límite de POIs. Inténtalo de nuevo.", "error");
        return false; // Bloquear por seguridad en caso de error
    }
}    
// ===================================================================
// NOMBRE: createRadarSpeedIcon (VERSIÓN FINAL DE ESCALADO DIRECTO)
// RESUMEN: Crea un icono de radar que se escala correctamente de pequeño a grande al hacer zoom.
// ===================================================================
function createRadarSpeedIcon(speed, currentZoomLevel = null, isFromTarea = false) {
    const container = document.createElement('div');
    
    // UMBRALES DE ZOOM
    const ZOOM_PEQUENO = 11.5;  // Por debajo de este zoom, el tamaño es mínimo
    const ZOOM_GRANDE = 16.5;   // Por encima de este zoom, el tamaño es máximo

    // TAMAÑOS DEL ICONO EN PÍXELES
    const TAMANO_MINIMO = 18;
    const TAMANO_MAXIMO = 48; // Puedes ajustar este valor si lo quieres más grande

    let finalSize = TAMANO_MINIMO;
    if (currentZoomLevel !== null) {
        if (currentZoomLevel <= ZOOM_PEQUENO) {
            finalSize = TAMANO_MINIMO;
        } else if (currentZoomLevel >= ZOOM_GRANDE) {
            finalSize = TAMANO_MAXIMO;
        } else {
            // Interpolar linealmente entre los dos umbrales
            const progress = (currentZoomLevel - ZOOM_PEQUENO) / (ZOOM_GRANDE - ZOOM_PEQUENO);
            finalSize = TAMANO_MINIMO + (TAMANO_MAXIMO - TAMANO_MINIMO) * progress;
        }
    }
    
    finalSize = Math.round(finalSize);
    const finalFontSize = Math.round(finalSize * 0.45);
    const finalBorderSize = Math.max(2, Math.round(finalSize * 0.07));

    const validSpeeds = [20, 30, 50, 60, 70, 80, 90, 100, 110, 120];
    const isStandardSpeed = speed !== null && validSpeeds.includes(speed);
    const borderColor = isFromTarea ? '#00FF00' : 'white';

    container.className = 'radar-speed-circle';
    container.style.width = `${finalSize}px`;
    container.style.height = `${finalSize}px`;
    container.style.fontSize = `${finalFontSize}px`;
    container.style.borderWidth = `${finalBorderSize}px`;
    container.style.borderColor = borderColor;
    
    if (isStandardSpeed) {
        container.textContent = speed;
    } else {
        const imageSize = Math.round(finalSize * 0.65);
        container.innerHTML = `<img src="PNG/RADARAQUI.PNG" alt="Radar" style="width:${imageSize}px; height:${imageSize}px; object-fit:contain;">`;
    }
    
    return container;
}

// ===================================================================
// NOMBRE: initializeLocationPickerMap (VERSIÓN OPTIMIZADA CON REUTILIZACIÓN)
// RESUMEN: Inicializa el mapa selector de ubicaciones una sola vez y lo reutiliza,
//          moviéndolo y actualizando su contenido según sea necesario.
// ===================================================================
function initializeLocationPickerMap(mapContainerId, slotIndex) {
    const container = document.getElementById(mapContainerId);
    if (!container) return; // Salir si el contenedor no existe

    const initialLocation = tempSavedLocations[slotIndex] || {};
    const centerLat = initialLocation.lat || 40.416775;
    const centerLng = initialLocation.lng || -3.703790;
    const initialZoom = (initialLocation.lat && initialLocation.lng) ? 15 : 6;

    if (!locationPickerMap) {
        const mapGarage = document.getElementById('map-garage');
        const mapDiv = document.createElement('div');
        mapDiv.style.width = '100%';
        mapDiv.style.height = '100%';
        mapGarage.appendChild(mapDiv); // Lo guardamos en el "garaje"

        locationPickerMap = new mapboxgl.Map({
            container: mapDiv,
            style: 'mapbox://styles/mapbox/satellite-streets-v12',
            center: [centerLng, centerLat],
            zoom: initialZoom,
            interactive: true
        });

        locationPickerMap.on('load', () => {
            locationPickerMarker = new mapboxgl.Marker({ draggable: true })
                .setLngLat([centerLng, centerLat])
                .addTo(locationPickerMap);

            locationPickerMarker.on('dragend', (event) => {
                const activeSlotIndex = locationPickerMap.activeSlotIndex; // Usamos una propiedad personalizada
                if (typeof activeSlotIndex !== 'number') return;

                const pos = event.target.getLngLat();
                if (!tempSavedLocations[activeSlotIndex]) {
                    tempSavedLocations[activeSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
                }
                tempSavedLocations[activeSlotIndex].lat = pos.lat;
                tempSavedLocations[activeSlotIndex].lng = pos.lng;
            });

            // El listener de 'click' también necesita el slot activo.
            locationPickerMap.on('click', (e) => {
                const activeSlotIndex = locationPickerMap.activeSlotIndex;
                if (typeof activeSlotIndex !== 'number') return;
                handlePickerMapClick(e, activeSlotIndex);
            });
        });
    }

    const mapDiv = locationPickerMap.getContainer();
    container.insertBefore(mapDiv, container.firstChild); // Movemos el div del mapa al modal visible.

    locationPickerMap.activeSlotIndex = slotIndex;

    locationPickerMap.flyTo({
        center: [centerLng, centerLat],
        zoom: initialZoom,
        duration: 0 // Sin animación para que sea instantáneo
    });

    if (locationPickerMarker) {
        locationPickerMarker.setLngLat([centerLng, centerLat]);
    }

    setTimeout(() => {
        if (locationPickerMap) {
            try {
                locationPickerMap.resize();
            } catch(e) { console.error("Error al redimensionar mapa reutilizado:", e); }
        }
    }, 50);
}    
// ===================================================================
// NOMBRE: applyMapVisualSettings (NUEVA FUNCIÓN)
// RESUMEN: Carga los ajustes de saturación y contraste del mapa desde localStorage y los aplica como variables CSS.
function applyMapVisualSettings() {
    const savedSaturation = localStorage.getItem('boardinggate_map_saturation') || '1.6';
    const savedContrast = localStorage.getItem('boardinggate_map_contrast') || '1.2';
    
    document.documentElement.style.setProperty('--map-saturation', savedSaturation);
    document.documentElement.style.setProperty('--map-contrast', savedContrast);
}
 
// ===================================================================
// NOMBRE: clearSpeedMarkers (NUEVA FUNCIÓN)
// RESUMEN: Limpia los marcadores de velocidad del mapa y reinicia las variables relacionadas.
function clearSpeedMarkers() {
    speedMarkerFeatures = [];
    lastSpeedMilestone = 0;
    if (navigationMapInstance && navigationMapInstance.getSource('speed-markers-source')) {
        navigationMapInstance.getSource('speed-markers-source').setData({
            type: 'FeatureCollection',
            features: []
        });
    }
} 

// ===================================================================
// NOMBRE: showReminderActionModal (NUEVA FUNCIÓN)
// RESUMEN: Muestra un modal personalizado para las acciones de un recordatorio/radar.
function showReminderActionModal(reminderId) {
    const rems = JSON.parse(localStorage.getItem('reminders') || '[]');
    const reminder = rems.find(r => r.id === reminderId);
    if (!reminder) return;

    const overlay = document.createElement('div');
    overlay.className = 'map-item-modal-overlay';

    overlay.innerHTML = `
        <div class="map-item-modal-content">
            <h3>${reminder.text.replace(/<b>|<\/b>/gi,'')}</h3>
            <hr>
            ${reminder.time ? `<p><strong>Hora:</strong> ${formatTimeWithPeriod(reminder.time)}</p>` : ''}
            ${reminder.date ? `<p><strong>Fecha:</strong> ${formatDateDetailed(reminder.date)}</p>` : ''}
            <p><strong>Radio:</strong> ${reminder.radiusMeters || DEFAULT_LOCATION_RADIUS}m</p>
            <div class="map-item-modal-buttons">
                <button id="modal-modify-btn" style="background-color: #10B981;">Modificar</button>
                <button id="modal-close-btn" style="background-color: #6c757d;">Cerrar</button>
            </div>
        </div>
    `;

    document.body.appendChild(overlay);

    const closeHandler = () => {
        if (overlay.parentNode) overlay.remove();
    };

    overlay.querySelector('#modal-close-btn').addEventListener('click', closeHandler);
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) closeHandler();
    });

    overlay.querySelector('#modal-modify-btn').addEventListener('click', () => {
        const mapContextBeforeModal = sessionStorage.getItem('mapContext');
        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
        if (mapContextBeforeModal) {
            sessionStorage.setItem('mapContext', mapContextBeforeModal);
        }
        showReminderModal(reminder, { onTopOfMap: true });
        closeHandler();
    });
}   
// ===================================================================
// NOMBRE: handleAutoZoom (MODIFICADA - USA ESTADO DE MODO)
// RESUMEN: Ajusta el zoom, pero solo si el modo 'auto' está activo.
function handleAutoZoom() {
    const currentAutoZoomMode = localStorage.getItem(AUTO_ZOOM_MODE_KEY) || 'off';
    if (currentAutoZoomMode !== 'auto' || isManualZoomActive || !(isNavigating || isFreeDriveActive) || !navigationMapInstance) return;

    if (isZoomedForManeuver) return;

    const speed = window.currentSpeedKmh || 0;
    let targetZoom;

    if (speed < 30) targetZoom = 19;
    else if (speed < 50) targetZoom = 18.5;
    else if (speed < 80) targetZoom = 18;
    else if (speed < 100) targetZoom = 17.5;
    else if (speed < 110) targetZoom = 17.1;
    else if (speed < 120) targetZoom = 16.6;
    else if (speed < 200) targetZoom = 16.3;
    else return; 

    if (Math.abs(navigationMapInstance.getZoom() - targetZoom) > 0.1) {
        navigationMapInstance.easeTo({ zoom: targetZoom, duration: 3000 });
    }
}
    
// ===================================================================
// NOMBRE: handleDragStartReorder
// RESUMEN: Inicia el arrastre de una etapa en la lista de reordenamiento.
function handleDragStartReorder(e) {
    draggedStageLi = e.target.closest('li');
    if (draggedStageLi) {
        setTimeout(() => {
            if(draggedStageLi) draggedStageLi.classList.add('dragging');
        }, 0);
    }
}
    
// ===================================================================
// NOMBRE: vehicleIconElement (const)
// RESUMEN: Define el elemento DOM del vehículo principal con un overlay para maniobras.
    const vehicleIconElement = document.createElement('div');
    vehicleIconElement.className = 'vehicle-icon-mapbox-container';
    vehicleIconElement.innerHTML = `<div class="vehicle-icon-wrapper"><img src="PNG/AVANCE.PNG" alt="Coche"><div class="vehicle-maneuver-overlay"></div></div>`;
        
// ===================================================================
// NOMBRE: vehicleIconMiniMap (const) - (ADAPTADO PARA LEAFLET)
// RESUMEN: Define el icono Leaflet para el vehículo en el minimapa.
    const vehicleIconMiniMap = L.divIcon({
        html: `<div class="vehicle-icon-minimap"><img src="PNG/AVANCE.PNG" alt="Coche Mini"><div class="vehicle-maneuver-overlay-minimap"></div></div>`,
        className: 'vehicle-icon-minimap-leaflet-container',
        iconSize: [48, 48],
        iconAnchor: [24, 24]
    });   

// ===================================================================
// NOMBRE: setupZoomButtons (NUEVA FUNCIÓN)
// RESUMEN: Inicializa la lógica y los eventos para los botones de zoom.
function setupZoomButtons() {
    const container = document.getElementById('zoom-button-container');
    const zoomInBtn = document.getElementById('zoom-in-button');
    const zoomOutBtn = document.getElementById('zoom-out-button');
    const levelDisplay = document.getElementById('zoom-level-display');
    if (!container || !zoomInBtn || !zoomOutBtn || !levelDisplay || !navigationMapInstance) return;

    const map = navigationMapInstance;

    const updateZoomDisplay = () => {
        levelDisplay.textContent = map.getZoom().toFixed(1);
    };

    map.on('zoom', updateZoomDisplay);
    updateZoomDisplay();

    const handleZoomClick = (zoomFunction) => {
        isManualZoomActive = true;
        if (manualZoomTimeout) {
            clearTimeout(manualZoomTimeout);
            manualZoomTimeout = null;
        }
        
        zoomFunction();

        manualZoomTimeout = setTimeout(() => {
            isManualZoomActive = false;
        }, 30000); 
    };

    zoomInBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        handleZoomClick(() => map.zoomIn());
    });

    zoomOutBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        handleZoomClick(() => map.zoomOut());
    });
}
// ===================================================================
// NOMBRE: startGpsWatching (VERSIÓN CORREGIDA Y DEFINITIVA 2)
// RESUMEN: Se añade la comprobación `!isRouteCompleted` para evitar
//          que la navegación se reinicie automáticamente si la ruta ya ha finalizado.
function startGpsWatching() {
    if (gpsRetryTimeoutId) {
        clearTimeout(gpsRetryTimeoutId);
        gpsRetryTimeoutId = null;
    }
    if (locationWatchId !== null) {
        return;
    }
    if (!('geolocation' in navigator) || !('watchPosition' in navigator.geolocation)) {
        showToast("Geolocalización no soportada por este navegador.", "error", 5000);
        return;
    }
    if (gpsRetryAttempt >= MAX_GPS_RETRIES) {
        showToast("Error persistente: No se pudo conectar al GPS. Revisa la configuración del dispositivo.", "error", 0, false, "gps-persistent-error");
        return;
    }
    gpsRetryAttempt++;
    
    if (gpsRetryAttempt > 3) {
        showToast(`Intentando conectar al GPS (Intento ${gpsRetryAttempt}/${MAX_GPS_RETRIES})...`, "info", GPS_RETRY_DELAY_MS, false, "gps-attempt-toast");
    }
    locationWatchId = navigator.geolocation.watchPosition(
        (position) => {
            if (isSimulatingGpsLocation) return;
            const attemptToast = document.getElementById("gps-attempt-toast");
            if (attemptToast) attemptToast.remove();
            activeToasts = activeToasts.filter(t => t.id !== "gps-attempt-toast");
            gpsRetryAttempt = 0;
            const persistentErrorToast = document.getElementById("gps-persistent-error");
            if (persistentErrorToast) persistentErrorToast.remove();
            const coordsForUpdate = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                heading: position.coords.heading,
                speed: position.coords.speed,
                altitude: position.coords.altitude
            };
            navigationCurrentLocation = coordsForUpdate;

            const hasPlottedRoute = navigationCurrentRouteData && navigationWaypoints.length >= 2;
            
            const lastWaypoint = hasPlottedRoute ? navigationWaypoints[navigationWaypoints.length - 1] : null;
            const isRouteCompleted = lastWaypoint && lastWaypoint.visited === true;

            if (!isNavigating && hasPlottedRoute && !isRouteCompleted) {
                const startPoint = navigationWaypoints[0];
                const distanceFromStart = calculateDistance(startPoint.lat, startPoint.lng, coordsForUpdate.latitude, coordsForUpdate.longitude);

                const START_TRIGGER_DISTANCE = 50;  
                const RELEVANCE_DISTANCE = 200; 

                if (distanceFromStart > START_TRIGGER_DISTANCE && distanceFromStart < RELEVANCE_DISTANCE) {
                    toggleNavigationState(); 
                    return;  }
            }
            
            const noRouteLoaded = !hasPlottedRoute;
            if (!isNavigating && !isFreeDriveActive && noRouteLoaded) {
                
                if (lastPositionForStats) {
                    const distanceMoved = calculateDistance(
                        lastPositionForStats.latitude, lastPositionForStats.longitude,
                        coordsForUpdate.latitude, coordsForUpdate.longitude
                    );
                    if (distanceMoved > 20) { 
                        startFreeDrive(coordsForUpdate); 
                        return; 
                    }
                }
                
                lastPositionForStats = { ...coordsForUpdate };
            }
          
            const isTripActive = isNavigating || isFreeDriveActive;
            if (isTripActive && lastPositionForStats) {
                const distanceMovedSinceLastPoint = calculateDistance(lastPositionForStats.latitude, lastPositionForStats.longitude, coordsForUpdate.latitude, coordsForUpdate.longitude);
                
                if (navigationStartTimeForStats === null && distanceMovedSinceLastPoint > 1) {
                    navigationStartTimeForStats = new Date();
                }

                if (navigationStartTimeForStats !== null) {
                    totalDistanceTravelledForStats += distanceMovedSinceLastPoint;
                    
                    const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000;
                    if (timeElapsedS > 0) {
                        window.averageSpeedKmh = (totalDistanceTravelledForStats / timeElapsedS) * 3.6;
                    }
                }
                lastPositionForStats = { ...coordsForUpdate };
            }

            updateInitialUserPosition(coordsForUpdate, navigationMapInstance);

            if (isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0] && coordsForUpdate) {
                const routeForDistCalc = navigationCurrentRouteData.routes[0];
                let carDistTurf = 0;
                if (navigationMapInstance.getSource('route') && navigationMapInstance.getSource('route')._data && typeof turf !== 'undefined') {
                    try {
                        const carPointTurf = turf.point([coordsForUpdate.longitude, coordsForUpdate.latitude]);
                        const routeGeoJSON = navigationMapInstance.getSource('route')._data;
                        const routeLineStringTurf = turf.lineString(routeGeoJSON.geometry.coordinates);
                        const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                        const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                        carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                    } catch (e) { }
                }
                const totalRouteLength = routeForDistCalc.distance;
                if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                    if (carDistTurf > lastCarDistanceAlongRouteForNavLogic - 100) {
                         lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                    }
                } else if (carDistTurf > totalRouteLength + 500) {
                    lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
                }

                checkAndMarkWaypointsAsVisited(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic, coordsForUpdate);
                renderWaypointMarkers();
                
                updateTurnByTurnDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                updateNavigationProgressDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
            } else if (isFreeDriveActive) {
                updateNavigationProgressDisplay(null, 0);
            }
        },
        (error) => {
            showToast(`Error GPS: ${error.message}`, "warning");
            if (locationWatchId !== null) {
                navigator.geolocation.clearWatch(locationWatchId);
                locationWatchId = null;
            }
            gpsRetryTimeoutId = setTimeout(startGpsWatching, GPS_RETRY_DELAY_MS);
        },
        { enableHighAccuracy: true, timeout: 15000, maximumAge: 2000, distanceFilter: 3 }
    );
}

// ===================================================================
// NOMBRE: processSimulatedGpsPosition (VERSIÓN FINAL CON LÓGICA DE ESTADÍSTICAS)
// RESUMEN: Procesa la posición GPS simulada y actualiza el estado de la navegación, incluyendo el inicio y la actualización de las estadísticas de viaje.
function processSimulatedGpsPosition(forceExactPosition = false) {
    if (!isSimulatingGpsLocation || !simulatedGpsLocation) return;
    navigationCurrentLocation = { ...simulatedGpsLocation };

    const isTripActive = isNavigating || isFreeDriveActive;
    if (isTripActive && lastPositionForStats) {
        const distanceMovedSinceLastPoint = calculateDistance(lastPositionForStats.latitude, lastPositionForStats.longitude, navigationCurrentLocation.latitude, navigationCurrentLocation.longitude);
        
        if (navigationStartTimeForStats === null && distanceMovedSinceLastPoint > 1) {
            navigationStartTimeForStats = new Date();
            showToast("Viaje simulado iniciado. Registrando estadísticas.", "success");
        }

        if (navigationStartTimeForStats !== null) {
            
            const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000;
            if (timeElapsedS > 0) {
                window.averageSpeedKmh = (totalDistanceTravelledForStats / timeElapsedS) * 3.6;
            }
        }
        lastPositionForStats = { ...navigationCurrentLocation };
    }

    updateInitialUserPosition(navigationCurrentLocation, navigationMapInstance);

    if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
        const route = navigationCurrentRouteData.routes[0];
        let carDistTurf = 0;
        const routeSource = navigationMapInstance.getSource('route');

        if (routeSource && routeSource._data && typeof turf !== 'undefined') {
            try {
                const carPointTurf = turf.point([simulatedGpsLocation.longitude, simulatedGpsLocation.latitude]);
                const routeGeoJSON = routeSource._data;
                const routeLineStringTurf = turf.lineString(routeGeoJSON.geometry.coordinates);
                let nearestPointOnLineTurf;
                if (forceExactPosition) {
                     nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                } else {
                    nearestPointOnLineTurf = carPointTurf;
                }
                const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
            } catch (turfError) {
                console.error("Error al calcular la distancia simulada en la ruta:", turfError);
            }
         }
        
        checkAndMarkWaypointsAsVisited(route, carDistTurf, simulatedGpsLocation);
        renderWaypointMarkers();

        lastCarDistanceAlongRouteForNavLogic = carDistTurf;
        updateTurnByTurnDisplay(route, carDistTurf);
        updateNavigationProgressDisplay(route, carDistTurf);
    }
    
    if (!automatedSimulationIntervalId) { 
        showToast(`Posición GPS simulada: ${simulatedGpsLocation.latitude.toFixed(4)}, ${simulatedGpsLocation.longitude.toFixed(4)}`, "info");
    }
}

    
// NOMBRE: redrawAllHTMLMarkers (VERSIÓN FINAL Y CORRECTA)
// RESUMEN: Limpia y redibuja los marcadores de Etapas y Recordatorios/Radares.
// ===================================================================
function redrawAllHTMLMarkers() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
        return;
    }

    navigationWaypoints.forEach(wp => {
        if (wp && wp.marker) {
            wp.marker.remove();
            wp.marker = null;
        }
    });

    reminderMapObjects.forEach(obj => {
        if (obj.marker) obj.marker.remove();
    });
    reminderMapObjects = [];

    renderWaypointMarkers();
    plotRemindersOnNavigationMap();
}
 
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// NOMBRE: updateAllIconSizes (VERSIÓN FINAL CON LÓGICA DE RECREACIÓN)
// RESUMEN: Controlador central que decide CUÁNDO se deben redibujar los iconos.
function updateAllIconSizes() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
        return;
    }

    const currentZoomLevel = navigationMapInstance.getZoom();

    const ZOOM_LEJANO = 10;
    const ZOOM_MEDIO = 14;

    const getZoomRange = (zoom) => {
        if (zoom <= ZOOM_LEJANO) return 'lejano';
        if (zoom <= ZOOM_MEDIO) return 'medio';
        return 'cercano';
    };

    const currentRange = getZoomRange(currentZoomLevel);
    const previousRange = getZoomRange(mapPreviousZoomLevelForPDRs); // Reutilizamos la variable

    if (currentRange !== previousRange) {
        redrawAllHTMLMarkers();
    }

    const PDR_ZOOM_THRESHOLD = 14;
    const crossedThresholdUp = mapPreviousZoomLevelForPDRs <= PDR_ZOOM_THRESHOLD && currentZoomLevel > PDR_ZOOM_THRESHOLD;
    const crossedThresholdDown = mapPreviousZoomLevelForPDRs > PDR_ZOOM_THRESHOLD && currentZoomLevel <= PDR_ZOOM_THRESHOLD;

    if (crossedThresholdUp || crossedThresholdDown) {
        displayChargingPointsOnMap();
    }
    
    mapPreviousZoomLevelForPDRs = currentZoomLevel;
}

// ===================================================================
// NOMBRE: redrawReminderMapObjects (CORREGIDA Y RESTAURADA)
// RESUMEN: Limpia y redibuja todos los recordatorios/radares en el mapa.
function redrawReminderMapObjects() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
        return;
    }

    const remindersToRedraw = reminderMapObjects.map(obj => {
        const rems = JSON.parse(localStorage.getItem('reminders') || '[]');
        let reminderData = rems.find(r => r.id === obj.reminderId);
        if (reminderData) {
            return { ...reminderData, isFromTarea: obj.isFromTarea };
        }
        return null;
    }).filter(Boolean);

    reminderMapObjects.forEach(obj => {
        if (obj.marker) obj.marker.remove();
        if (obj.circleId) {
            if (navigationMapInstance.getLayer(obj.circleId)) navigationMapInstance.removeLayer(obj.circleId);
            if (navigationMapInstance.getSource(obj.circleId)) navigationMapInstance.removeSource(obj.circleId);
        }
    });
    reminderMapObjects = [];

    remindersToRedraw.forEach(reminder => {
        const newMapObject = plotSingleReminderOnMap(reminder, navigationMapInstance);
        if (newMapObject) {
            reminderMapObjects.push(newMapObject);
        }
    });
}

// ===================================================================
// NOMBRE: hidePostArrivalActionModal (NUEVA FUNCIÓN)
// RESUMEN: Oculta y elimina el modal de acciones post-llegada.
function hidePostArrivalActionModal() {
    const modal = document.getElementById('post-arrival-action-modal');
    if (modal) {
        modal.remove();
    }
}

// ===================================================================
// NOMBRE: showPostArrivalActionModal (NUEVA FUNCIÓN)
// RESUMEN: Muestra un modal persistente con opciones después de llegar a un destino.
function showPostArrivalActionModal() {
    hidePostArrivalActionModal(); // Limpia cualquier instancia anterior

    const modal = document.createElement('div');
    modal.id = 'post-arrival-action-modal';
    
    // <<< MODIFICACIÓN: Se añade el tercer botón "Salir" al innerHTML >>>
    modal.innerHTML = `
        <p class="post-arrival-title">Viaje finalizado</p>
        <div class="post-arrival-buttons">
            <button id="return-trip-button">Cargar Viaje de Vuelta</button>
            <button id="clear-completed-route-button">Borrar Ruta Actual</button>
            <button id="post-arrival-exit-button" style="background-color: #6c757d;">Salir</button>
        </div>
    `;

    document.body.appendChild(modal);

    document.getElementById('return-trip-button').addEventListener('click', () => {
        createAndLoadReturnTrip();
        hidePostArrivalActionModal();
    });

    document.getElementById('clear-completed-route-button').addEventListener('click', () => {
        handleLoadOrDeleteRouteClick(null);
        hidePostArrivalActionModal();
    });

    // <<< NUEVO: Se añade el event listener para el botón "Salir" >>>
    document.getElementById('post-arrival-exit-button').addEventListener('click', () => {
        hidePostArrivalActionModal();
    });
}
    
// ===================================================================
// NOMBRE: createAndLoadReturnTrip (VERSIÓN FINAL Y ROBUSTA)
// RESUMEN: Se corrige el bug de numeración y estado persistente.
async function createAndLoadReturnTrip() {
    if (!navigationWaypoints || navigationWaypoints.length < 2) {
        showToast("No hay una ruta completa para invertir.", "warning");
        return;
    }

    showToast("Preparando ruta de vuelta...", "info", 2000);

    try {
        const originalWaypointsForReturn = navigationWaypoints
            .filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart)
            .map(wp => ({ lat: wp.lat, lng: wp.lng, address: wp.address }));

        handleLoadOrDeleteRouteClick(null);

        await new Promise(resolve => setTimeout(resolve, 50));
        
        const currentPos = await getCurrentLocationAsync();
        
        const originalStart = originalWaypointsForReturn.shift(); // Este era 'S', ahora será el nuevo 'F'.
        if (originalWaypointsForReturn.length > 0) {
            originalWaypointsForReturn.pop(); // Eliminamos el 'F' original.
        }
        const intermediateReversed = originalWaypointsForReturn.reverse();

        let returnWaypointsData = [
            { lat: currentPos.latitude, lng: currentPos.longitude, address: 'Posición Actual (GPS)' },
            ...intermediateReversed,
            originalStart 
        ];

        const returnRouteObject = {
            name: `VUELTA: ${originalStart.address || 'Ruta Original'}`,
            waypoints: returnWaypointsData
        };

        loadRouteFromObject(returnRouteObject, true);
        addRouteToRecents(returnRouteObject);

    } catch (error) {
        showToast(`Error al crear ruta de vuelta: ${error.message}`, "error");
    }
}

// ===================================================================
// NOMBRE: showarrivalstatsmodal (VERSIÓN CORREGIDA Y MEJORADA)
// RESUMEN: Al cerrar, en lugar de borrar la ruta, ahora invoca el nuevo
//          modal de acciones post-llegada (Vuelta / Borrar Ruta).
function showArrivalStatsModal(freeDriveStatsData = null) {
    closeOtherModals('arrival-stats-modal');
    document.body.classList.add('modal-open');

    let modal = document.getElementById('arrival-stats-modal');
    if (modal) {
        clearModalAutoCloseTimer(modal, modal.querySelector('#arrival-stats-accept-button'), 'arrival-stats-modal');
        modal.remove();
    }

    modal = document.createElement('div');
    modal.id = 'arrival-stats-modal';
    
    const isFreeDrive = !!freeDriveStatsData;
    
    const destinationName = isFreeDrive ? "Viaje Libre" : (navigationWaypoints[navigationWaypoints.length - 1]?.address || "Destino");
    const startTime = isFreeDrive ? freeDriveStatsData.startTime : (navigationStartTimeForStats ? new Date(navigationStartTimeForStats) : new Date());
    const arrivalTime = new Date();
    const durationMs = arrivalTime - startTime;
    const durationHours = Math.floor(durationMs / (1000 * 60 * 60));
    const durationMinutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
    
    let kmRealizados = isFreeDrive 
        ? (freeDriveStatsData.totalDistance / 1000).toFixed(1)
        : (totalDistanceTravelledForStats / 1000).toFixed(1);
    if (isSimulatingGpsLocation && automatedSimulationIntervalId) {
        kmRealizados = (simulatedDistanceAlongRoute / 1000).toFixed(1);
    }

    const kmEstimadosTexto = (!isFreeDrive && tripInitialDistanceMeters !== null) 
        ? `<br><small style="font-size: 0.7em; color: #b0b0b0;">(Estimados: ${(tripInitialDistanceMeters / 1000).toFixed(1)} km)</small>`
        : '';
    
    const initialDurationTotalMinutes = tripInitialDurationSec ? Math.round(tripInitialDurationSec / 60) : 0;
    const initialDurationHours = Math.floor(initialDurationTotalMinutes / 60);
    const initialDurationMinutes = initialDurationTotalMinutes % 60;
    const tiempoEstimadoTexto = (!isFreeDrive && tripInitialDurationSec !== null)
        ? `<br><small style="font-size: 0.7em; color: #b0b0b0;">(Estimado: ${String(initialDurationHours).padStart(2,'0')}:${String(initialDurationMinutes).padStart(2,'0')})</small>`
        : '';

    const velocidadMedia = window.averageSpeedKmh.toFixed(1);
    const velocidadMediaEstimadaTexto = (!isFreeDrive && graphExpectedAvgSpeed)
        ? `<br><small style="font-size: 0.7em; color: #b0b0b0;">(Estimada: ${graphExpectedAvgSpeed.toFixed(1)} km/h)</small>`
        : '';
    
    const horaLlegadaEstimadaTexto = (!isFreeDrive && tripInitialOverallEtaTime)
        ? `<br><small style="font-size: 0.7em; color: #b0b0b0;">(Estimada: ${tripInitialOverallEtaTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'})})</small>`
        : '';

    const velocidadMaxima = maxSpeedDuringTrip.toFixed(1);
    const altitudMaxima = maxAltitudeDuringTrip !== -Infinity ? `${maxAltitudeDuringTrip.toFixed(0)} m` : 'N/D';
    const altitudMinima = minAltitudeDuringTrip !== Infinity ? `${minAltitudeDuringTrip.toFixed(0)} m` : 'N/D';
    
    let altitudMediaHtml = 'N/D';
    if (graphDataPoints && graphDataPoints.altitude && graphDataPoints.altitude.length > 0) {
        const sum = graphDataPoints.altitude.reduce((a, b) => a + b, 0);
        const avg = sum / graphDataPoints.altitude.length;
        altitudMediaHtml = `${avg.toFixed(0)} m`;
    }

    let deviationHtml = '';
    let initialEtaDetailsHtml = '';
    if (!isFreeDrive) {
        if (tripInitialOverallEtaTime) {
            const finalDeviationMs = arrivalTime.getTime() - tripInitialOverallEtaTime.getTime();
            deviationHtml = formatDeviation(finalDeviationMs);
            if (Math.abs(finalDeviationMs) < 5000) {
                initialEtaDetailsHtml = `Previsión inicial coincidió con la real.`;
            } else {
                const initialEtaTime = tripInitialOverallEtaTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                const initialDurationFormatted = `${String(initialDurationHours).padStart(2,'0')}:${String(initialDurationMinutes).padStart(2,'0')}`;
                const initialAvgSpeed = graphExpectedAvgSpeed ? graphExpectedAvgSpeed.toFixed(1) : '0.0';
                initialEtaDetailsHtml = `<strong>Previsión inicial:</strong> Llegada: ${initialEtaTime} | Tiempo: ${initialDurationFormatted} | Vel. media: ${initialAvgSpeed} Km/h`;
            }
        }
    }
    
    const deviationSectionHtml = isFreeDrive ? '' : `
        <h3 class="stats-section-header">Desviación ETA</h3>
        <div class="stats-grid">
            <div class="stat-card" style="grid-column: 1 / -1;">
                <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=_gn_lN6WnWZh&format=png&color=FFFFFF" alt="Desviación ETA"/></div>
                <span class="stat-label">Desviación sobre ETA (mm:ss)</span>
                <span class="stat-value">${deviationHtml}</span>
            </div>
        </div>
        ${initialEtaDetailsHtml ? `<div class="initial-eta-details">${initialEtaDetailsHtml}</div>` : ''}
    `;

    modal.innerHTML = `
        <div class="arrival-stats-header">
            <h2>${isFreeDrive ? 'RESUMEN DEL VIAJE' : '¡HAS LLEGADO!'}</h2>
            <p class="destination-name">${destinationName}</p>
        </div>
        <div class="arrival-stats-body">
            <div class="arrival-stats-layout-grid">
                <div class="main-stats-container">
                    <h3 class="stats-section-header">Tiempos y Duración</h3>
                    <div class="stats-grid" style="grid-template-columns: repeat(3, 1fr);">
                         <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=25235&format=png&color=FFFFFF" alt="Salida"/></div>
                            <span class="stat-label">Hora Salida</span>
                            <span class="stat-value">${startTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/time.png" alt="Duración"/></div>
                            <span class="stat-label">Duración Viaje</span>
                            <span class="stat-value">${String(durationHours).padStart(2,'0')}:${String(durationMinutes).padStart(2,'0')} ${tiempoEstimadoTexto}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/finish-flag.png" alt="Llegada"/></div>
                            <span class="stat-label">Hora Llegada</span>
                            <span class="stat-value">${arrivalTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})} ${horaLlegadaEstimadaTexto}</span>
                        </div>
                    </div>

                    <h3 class="stats-section-header">Distancia y Velocidad</h3>
                    <div class="stats-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=fodDbvH8xepW&format=png&color=ffffff" alt="Distancia"/></div>
                            <span class="stat-label">Km Realizados</span>
                            <span class="stat-value">${kmRealizados} km ${kmEstimadosTexto}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/speedometer.png" alt="Velocidad Media"/></div>
                            <span class="stat-label">Velocidad Media</span>
                            <span class="stat-value">${velocidadMedia} km/h ${velocidadMediaEstimadaTexto}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=c7DeWFZX07r8&format=png&color=ffffff" alt="Velocidad Máxima"/></div>
                            <span class="stat-label">Velocidad Máxima</span>
                            <span class="stat-value">${velocidadMaxima} km/h <button id="show-max-speed-location-button">¿Dónde?</button></span>
                        </div>
                    </div>
                </div>

                <div class="side-stats-container">
                    ${deviationSectionHtml}
                    <h3 class="stats-section-header">Métricas de Altitud</h3>
                    <div class="stats-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/mountain.png" alt="Altitud Máxima"/></div>
                            <span class="stat-label">Altitud Máxima</span>
                            <span class="stat-value">${altitudMaxima}</span>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/ios/50/FFFFFF/mountain.png" alt="Altitud Mínima" style="transform: scaleY(-1);"/></div>
                            <span class="stat-label">Altitud Mínima</span>
                            <span class="stat-value">${altitudMinima}</span>
                        </div>
                         <div class="stat-card">
                            <div class="stat-icon"><img src="https://img.icons8.com/?size=50&id=113129&format=png&color=ffffff" alt="Altitud Media"/></div>
                            <span class="stat-label">Altitud Media</span>
                            <span class="stat-value">${altitudMediaHtml}</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="arrival-stats-footer">
            <button id="arrival-stats-accept-button">Aceptar <span class="button-countdown-timer"></span></button>
        </div>
    `;

    document.body.appendChild(modal);
    
    const coordsAreValid = maxSpeedCoordinates && typeof maxSpeedCoordinates.lat === 'number' && !isNaN(maxSpeedCoordinates.lat) && typeof maxSpeedCoordinates.lng === 'number' && !isNaN(maxSpeedCoordinates.lng);
    if (coordsAreValid && navigationMapInstance) {
        const maxSpeedFeature = {
            type: 'Feature',
            geometry: {
                type: 'Point',
                coordinates: [maxSpeedCoordinates.lng, maxSpeedCoordinates.lat]
            },
            properties: {
                type: 'maxSpeed',
                speedText: maxSpeedDuringTrip.toFixed(0)
            }
        };
        speedMarkerFeatures.push(maxSpeedFeature);
        if (navigationMapInstance.getSource('speed-markers-source')) {
            navigationMapInstance.getSource('speed-markers-source').setData({
                type: 'FeatureCollection',
                features: speedMarkerFeatures
            });
        }
        modal.querySelector('#show-max-speed-location-button').addEventListener('click', () => {
            closeHandler();
            navigationMapInstance.flyTo({ center: [maxSpeedCoordinates.lng, maxSpeedCoordinates.lat], zoom: 17 });
        });
    }

    const acceptButton = modal.querySelector('#arrival-stats-accept-button');
    const closeHandler = () => {
        document.body.classList.remove('modal-open');
        clearModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal');
        if (modal.parentNode) modal.remove();
        isGraphingActive = false;
        if (graphIntervalTimer) { clearInterval(graphIntervalTimer); graphIntervalTimer = null; }
        
        if (isFreeDrive) {
             isFreeDriveActive = false;
             isFreeDrivePaused = false;
             freeDriveStats = null;
             tripStartLocationForStats = null;
        } else {
            isNavigating = false;
            navigationFollowUser = false;
            showPostArrivalActionModal(); 
          }

        mapHeaderButtonsVisible = true;
        toggleMapHeaderRowsVisibility(true);
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        showMapInfoOverlay(isFreeDrive ? "Viaje libre finalizado" : "HA LLEGADO A: " + destinationName);
    };

    acceptButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal', 150000);
}

// ===================================================================
// NOMBRE: drawRouteOnMap (REESCRITA - IMPLEMENTA EL SWAP SEGURO)
// RESUMEN: Encapsula la lógica completa de pintado: destruye la ruta antigua
//          y crea la nueva, todo dentro de una promesa segura.
// ===================================================================
async function drawRouteOnMap(route) {
    return new Promise((resolve, reject) => {
        if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
            return reject(new Error("El mapa no está listo para dibujar."));
        }

        const geojsonData = (route && route.geometry && route.geometry.coordinates.length >= 2) 
            ? { type: 'Feature', properties: {}, geometry: route.geometry }
            : { type: 'Feature', properties: {}, geometry: { type: 'LineString', coordinates: [] } };

        const cleanupAndReject = (message) => {
            clearTimeout(timeoutId);
            navigationMapInstance.off('sourcedata', onSourceData);
            reject(new Error(message));
        };
        
        const timeoutId = setTimeout(() => {
            cleanupAndReject("Timeout esperando la confirmación de renderizado del mapa.");
        }, 7000);

        const onSourceData = (e) => {
            if (e.sourceId === 'route' && e.isSourceLoaded) {
                clearTimeout(timeoutId);
                navigationMapInstance.off('sourcedata', onSourceData);
                resolve();
            }
        };
        
        navigationMapInstance.on('sourcedata', onSourceData);

        try {
            if (navigationMapInstance.getLayer('route')) {
                navigationMapInstance.removeLayer('route');
            }
            if (navigationMapInstance.getSource('route')) {
                navigationMapInstance.removeSource('route');
            }

            navigationMapInstance.addSource('route', { type: 'geojson', data: geojsonData });
            navigationMapInstance.addLayer({
                id: 'route',
                type: 'line',
                source: 'route',
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                paint: getRouteStyleProperties()
            });
           } catch (error) {
            cleanupAndReject(`Error al añadir capa/fuente: ${error.message}`);
        }
    });
}

    
// ===================================================================
// NOMBRE: handleAddRadarHereClick
// RESUMEN: Inicia el proceso para añadir un radar, mostrando el modal de selección de velocidad.
function handleAddRadarHereClick(button) {
    showRadarSpeedModal((selectedSpeed) => {
        if (selectedSpeed === null) {
            return;
        }

        button.disabled = true;
        const radarImg = button.querySelector('img');
        if (radarImg) radarImg.src = "PNG/RADAR.PNG";

        getCurrentLocation(
            (coords) => {
                const now = new Date();
                let radarText;
                if (selectedSpeed === 'TRAMO') {
                    radarText = `<b>RADAR: DE TRAMO (Añadido por el usuario)</b>`;
                } else {
                    radarText = `<b>RADAR: DE ${selectedSpeed} KM/H (Añadido por el usuario)</b>`;
                }

                const newRadarReminder = {
                    id: Date.now(),
                    text: radarText,
                    type: 'simple',
                    time: `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`,
                    date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                    createdAt: now.toISOString(),
                    managedByUser: false,
                    isLocationEnabled: true,
                    locationCoordinates: { latitude: coords.latitude, longitude: coords.longitude },
                    radiusMeters: 350,
                    excludeFromList: true
                };

                let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                reminders.push(newRadarReminder);
                localStorage.setItem('reminders', JSON.stringify(reminders));
                
                showToast(`Radar de ${selectedSpeed === 'TRAMO' ? 'Tramo' : selectedSpeed + ' km/h'} creado en tu ubicación.`, "success");
                
                updateReminderCount();
                updateButtonStyles();
                
                if (navigationMapInstance) {
                    const newMapObject = plotSingleReminderOnMap(newRadarReminder, navigationMapInstance);
                    if (newMapObject) {
                        reminderMapObjects.push(newMapObject);
                    }
                    navigationMapInstance.flyTo({ center: [coords.longitude, coords.latitude], zoom: 15 });
                }
                
                button.disabled = false;
                if (radarImg) radarImg.src = "PNG/RADARAQUI.PNG";
            },
            (errorMsg) => {
                showToast(`Error al obtener ubicación para RADAR: ${errorMsg}`, "error");
                button.disabled = false;
                if (radarImg) radarImg.src = "PNG/RADARAQUI.PNG";
            }
        );
    });
}
// ===================================================================
// NOMBRE: proceedWithRecalculation (MODIFICADA - ACTIVA EL TOAST)
// RESUMEN: Gestiona la lógica de recálculo de ruta según la acción del usuario.
async function proceedWithRecalculation(action) {
    if (!isNavigating || !navigationCurrentLocation) {
        showToast("No se puede recalcular: no se está navegando o la ubicación es desconocida.", "error");
        return;
    }
    if (action === 'skip_one') {
        // --- CORRECCIÓN APLICADA AQUÍ: Se añade '&& wp.type !== 'F'' para no omitir nunca el destino final ---
        const nextUnvisitedStageIndex = navigationWaypoints.findIndex(wp => wp && !wp.isInternal && !wp.isRecalculatedStart && !wp.visited && wp.type !== 'S' && wp.type !== 'S_Recalc' && wp.type !== 'F');
        if (nextUnvisitedStageIndex !== -1) {
            navigationWaypoints[nextUnvisitedStageIndex].visited = true;
            showToast(`Omitiendo etapa: ${navigationWaypoints[nextUnvisitedStageIndex].address || 'Siguiente' }`, "info");
        } else {
            showToast("No hay próximas etapas intermedias para omitir. Recalculando a destino.", "info");
        }
    } else if (action === 'skip_multiple') {
        const stagesToSkip = [];
        const currentHeading = navigationCurrentLocation.heading;
        navigationWaypoints.forEach(wp => {
            // Esta condición ya era correcta, pero la dejamos para asegurar que el destino final NUNCA se omita.
            if (wp.visited || wp.type === 'S' || wp.type === 'S_Recalc' || wp.type === 'F') return;
            const bearingToWp = turf.bearing(
                turf.point([navigationCurrentLocation.longitude, navigationCurrentLocation.latitude]),
                turf.point([wp.lng, wp.lat])
            );
            let angleDiff = Math.abs(currentHeading - (bearingToWp < 0 ? bearingToWp + 360 : bearingToWp));
            if (angleDiff > 180) angleDiff = 360 - angleDiff;
            if (angleDiff > 110) {
                stagesToSkip.push(wp.id);
            }
        });
        if (stagesToSkip.length > 0) {
            navigationWaypoints.forEach(wp => {
                if (stagesToSkip.includes(wp.id)) wp.visited = true;
            });
            showToast(`Saltando ${stagesToSkip.length} etapas que han quedado atrás.`, "info");
        }
    }
    await recalculateAndDrawRoute(true);
}
// ===================================================================
// NOMBRE: checkAndMarkWaypointsAsVisited (VERSIÓN CON LÓGICA DE ACUMULACIÓN CORREGIDA)
// RESUMEN: Corrige el error lógico "off-by-one" que marcaba la primera etapa
//          como visitada. La distancia de cada tramo ahora se usa para evaluar la
//          llegada a la etapa correcta.
// ===================================================================
function checkAndMarkWaypointsAsVisited(route, carDistanceAlongRoute, currentCoords) {
    if (!route || !route.legs || !currentCoords) return;

    let cumulativeDistance = 0; // Distancia acumulada ANTES del tramo actual.
    navigationWaypoints.forEach((wp, index) => {
        if (wp) {
            const isStartPoint = wp.type === 'S' || wp.isRecalculatedStart;
            const isIntermediate = wp.type === 'intermediate';
            const isFinal = wp.type === 'F';

            if (isStartPoint) {
                wp.visited = true;
            } else if (isIntermediate && (index - 1) < route.legs.length) {
                const leg = route.legs[index - 1];
                if (leg) {
                    // <<< CORRECCIÓN CLAVE >>>
                    // Se calcula la distancia hasta el final de ESTA etapa antes de hacer nada más.
                    const distanceToEndOfThisLeg = cumulativeDistance + (leg.distance || 0);

                    const tripHasPhysicallyStarted = isNavigating && navigationStartTimeForStats;
                    const hasClearedStartBuffer = carDistanceAlongRoute > 20;

                    // La comprobación ahora usa la distancia correcta para esta etapa.
                    if (tripHasPhysicallyStarted && hasClearedStartBuffer && carDistanceAlongRoute >= distanceToEndOfThisLeg - WAYPOINT_VISITED_THRESHOLD_METERS) {
                        wp.visited = true;
                    }
                    
                    // Solo DESPUÉS de la comprobación, se actualiza la distancia acumulada para la SIGUIENTE etapa.
                    cumulativeDistance = distanceToEndOfThisLeg;
                }
            } else if (isFinal) {
                const finalDestinationCoords = route.legs[route.legs.length - 1].steps.slice(-1)[0].maneuver.location;
                const physicalDistanceToFinal = calculateDistance(currentCoords.latitude, currentCoords.longitude, finalDestinationCoords[1], finalDestinationCoords[0]);
                
                if (physicalDistanceToFinal <= WAYPOINT_VISITED_THRESHOLD_METERS) {
                    wp.visited = true;
                }
            }
        }
    });
}
    

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// NOMBRE: findChargingPointsOnRoute (CORREGIDA - ROBUSTA CONTRA ERUDA)
// RESUMEN: Busca PDRs de OCM y gestiona el estado de la búsqueda.
async function findChargingPointsOnRoute(powerFilters, searchConfig) {
    const pdrButton = document.getElementById('pdrs-ruta-button');
    if (pdrButton) pdrButton.classList.remove('pdr-search-highlight');

    clearChargingPoints();
    lastPdrSearchResults = [];
    
    showToast("Buscando puntos de recarga (OCM)...", "info", 0, false, "pdrs-search");

    const PDR_SEARCH_IN_VIEW_KEY = 'boardinggate_pdrSearchInView';
    const hasRoute = searchConfig.type === 'route';
    const searchInCurrentViewChecked = localStorage.getItem(PDR_SEARCH_IN_VIEW_KEY) === 'true';
    
    let apiUrl;

    if (searchInCurrentViewChecked) {
        const bounds = navigationMapInstance.getBounds();
        apiUrl = `https://api.openchargemap.io/v3/poi/?output=json&key=${OCM_API_KEY}&boundingbox=(${bounds.getSouthWest().lat},${bounds.getSouthWest().lng}),(${bounds.getNorthEast().lat},${bounds.getNorthEast().lng})&maxresults=1500&compact=false&verbose=true`;
        showToast("Buscando en la vista actual del mapa...", "info", 2000);
    } else if (hasRoute) {
        const routeSource = navigationMapInstance.getSource('route');
        if (!routeSource || !routeSource._data || !routeSource._data.geometry || !routeSource._data.geometry.coordinates || routeSource._data.geometry.coordinates.length < 2) {
            showToast("No hay ruta válida para buscar PDRs sobre ella.", "error");
            const existingToast = document.getElementById("pdrs-search");
            if (existingToast) existingToast.remove();
            return;
        }
        const routeBounds = new mapboxgl.LngLatBounds();
        routeSource._data.geometry.coordinates.forEach(coord => routeBounds.extend(coord));
        apiUrl = `https://api.openchargemap.io/v3/poi/?output=json&key=${OCM_API_KEY}&boundingbox=(${routeBounds.getSouthWest().lat},${routeBounds.getSouthWest().lng}),(${routeBounds.getNorthEast().lat},${routeBounds.getNorthEast().lng})&maxresults=1500&compact=false&verbose=true`;
    } else if (searchConfig.type === 'radius') {
        apiUrl = `https://api.openchargemap.io/v3/poi/?output=json&key=${OCM_API_KEY}&latitude=${searchConfig.center.lat}&longitude=${searchConfig.center.lng}&distance=${searchConfig.radiusKm}&distanceunit=km&maxresults=1000&compact=false&verbose=true`;
    } else {
        showToast("Tipo de búsqueda no válido.", "error");
        pdrSearchState = 'initial';
        return;
    }
    
    try {
        const response = await fetch(apiUrl);
        if (!response.ok) throw new Error(`Error de red de OCM: ${response.statusText}`);
        const data = await response.json();
        if (!data || !Array.isArray(data)) throw new Error("Respuesta de OCM no válida.");

        window.lastOcmApiResponse = data;

        const operatorFilterText = (document.getElementById('operator-filter-input')?.value || localStorage.getItem('boardinggate_operator_filter') || '').toLowerCase().trim();
        const operatorFilterWords = operatorFilterText ? operatorFilterText.split(/\s+/).filter(w => w) : [];
        
        const routeLineForDistanceCheck = (searchConfig.type === 'route' && navigationMapInstance.getSource('route') && navigationMapInstance.getSource('route')._data) ? turf.lineString(navigationMapInstance.getSource('route')._data.geometry.coordinates) : null;
        
        let filteredPoints = [];

        data.forEach(point => {
            const formattedPoint = formatOCMPoint(point);
            if (!formattedPoint) return;
            const power = parseFloat(formattedPoint.power);
            if (isNaN(power) || power < powerFilters.min || power > powerFilters.max) return;

            if (operatorFilterWords.length > 0) {
                const pointOperator = (formattedPoint.operator || '').toLowerCase();
                const pointAddress = (formattedPoint.address || '').toLowerCase();
                const operatorMatch = operatorFilterWords.some(word => 
                    pointOperator.includes(word) || pointAddress.includes(word)
                );
                if (!operatorMatch) return;
            }
            
            if (!searchInCurrentViewChecked && hasRoute && routeLineForDistanceCheck) {
                const pointTurf = turf.point([formattedPoint.lon, formattedPoint.lat]);
                const distanceKm = turf.pointToLineDistance(pointTurf, routeLineForDistanceCheck, { units: 'kilometers' });
                if (distanceKm <= searchConfig.distanceFilters.max) {
                    filteredPoints.push(formattedPoint);
                }
            } else { 
                filteredPoints.push(formattedPoint);
            }
        });
        
        lastPdrSearchResults = [...filteredPoints];
        currentChargingPointsOnRoute = [...filteredPoints];

        const cheapestBySegment = {
            '#5e5e5e': { price: Infinity, point: null },
            '#007863': { price: Infinity, point: null },
            'rgb(30, 144, 255)': { price: Infinity, point: null },
            '#de2e03': { price: Infinity, point: null }
        };

        const parsePrice = (priceString) => {
            if (priceString && typeof priceString === 'string') {
                const priceMatch = priceString.match(/(\d[\d,.]*)/);
                if (priceMatch && priceMatch[1]) {
                    const priceNum = parseFloat(priceMatch[1].replace(',', '.'));
                    if (!isNaN(priceNum) && priceNum > 0 && priceNum < 10) {
                        return priceNum;
                    }
                }
            }
            return Infinity;
        };

        currentChargingPointsOnRoute.forEach(point => {
            point.isCheapest = false;
            const power = parseFloat(point.power);
            const segmentColor = getChargingPointColorByPower(power);
            const price = parsePrice(point.price);
            
            if (cheapestBySegment[segmentColor] && price < cheapestBySegment[segmentColor].price) {
                cheapestBySegment[segmentColor].price = price;
                cheapestBySegment[segmentColor].point = point;
            }
        });

        for (const color in cheapestBySegment) {
            const cheapest = cheapestBySegment[color];
            if (cheapest.point) {
                cheapest.point.isCheapest = true;
            }
        }

        const existingToast = document.getElementById("pdrs-search");
        if (existingToast) existingToast.remove();
        showToast(`${currentChargingPointsOnRoute.length} PDRs encontrados.`, "success");
        displayChargingPointsOnMap();

        pdrSearchState = 'results_shown';

    } catch (error) {
        const existingToast = document.getElementById("pdrs-search");
        if (existingToast) existingToast.remove();
        showToast(`Error al buscar PDRs: ${error.message}`, "error");
        pdrSearchState = 'initial';
    }
}


// NOMBRE: updateUserIdDisplay
// RESUMEN: Muestra el ID de usuario en la pantalla si existe.
// ===================================================================
function updateUserIdDisplay() {
    const userIdDisplay = document.getElementById('user-id-display');
    const userId = localStorage.getItem('userData_userId');
    if (userIdDisplay) {
        if (userId) {
            userIdDisplay.textContent = userId.trim();
            userIdDisplay.style.display = 'block';
        } else {
            userIdDisplay.textContent = '';
            userIdDisplay.style.display = 'none';
        }
    }
}

// ===================================================================
// NOMBRE: handleGpsSimulationToggle (MODIFICADA - PARA MAPBOX)
// RESUMEN: Activa/desactiva el modo de simulación GPS. Si hay una ruta cargada al activar, muestra el modal de selección de velocidad y tipo de simulación.
function handleGpsSimulationToggle() {
    const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
    const mapDiv = document.getElementById('reminders-location-map-div');
    if (isSimulatingGpsLocation) { 
        if (isSimulatingFreeDrive) {
            stopFreeDrive();
            isSimulatingFreeDrive = false; 
        }
        
        stopAutomatedRouteSimulationInternal(); 
        isSimulatingGpsLocation = false;
        reactivateRealGpsAfterSimulation();
        if (mapDiv) mapDiv.classList.remove('simulating-gps-click-mode');
        if (simulateGpsButton) {
            simulateGpsButton.classList.remove('active-simulate-gps-mode'); 
            simulateGpsButton.title = "Activar Simulación GPS (recorrido automático o clic manual)";
        }
        if (maxSpeedMarkerObjects && maxSpeedMarkerObjects.length > 0) {
            maxSpeedMarkerObjects.forEach(marker => marker.remove());
            maxSpeedMarkerObjects = [];
        }
        if (speedMilestoneMarkerObjects && speedMilestoneMarkerObjects.length > 0) {
            speedMilestoneMarkerObjects.forEach(marker => marker.remove());
            speedMilestoneMarkerObjects = [];
        }
        showToast("Modo simulación GPS desactivado. Volviendo a GPS real.", "info");
    } else { 
        if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0] && navigationWaypoints.filter(wp => !wp.isInternal && !wp.isRecalculatedStart).length >= 2) {
            showSimulationSpeedModal(simulationSpeedKmph, (newSpeed) => {
                startAutomatedRouteSimulation(newSpeed); 
                if (mapDiv) mapDiv.classList.remove('simulating-gps-click-mode'); 
            });
        } else {
            isSimulatingGpsLocation = true;
            if (simulateGpsButton) simulateGpsButton.classList.add('active-simulate-gps-mode'); 
            if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode'); 
            showToast("Modo simulación GPS por clic ACTIVADO. Carga una ruta para recorrido automático o toca el mapa.", "info", 6000);
        }
    }
    setNavigationMapClickHandler();
}

// ===================================================================
// NOMBRE: deleteFilteredRadars (MODIFICADA)
// RESUMEN: Borra radares y limpia la caché para forzar su reconstrucción.
async function deleteFilteredRadars() {
    window.radarsCache = null;
    window.radarsSpatialIndex = null;
    localStorage.removeItem('radarsCacheData');
    localStorage.removeItem('radarsCacheIndex');
    localStorage.removeItem('radarsCacheVersion');
    
    const latFilterValue = document.getElementById('radar-filter-lat').value.trim();
    const lonFilterValue = document.getElementById('radar-filter-lon').value.trim();
    const keywordsFilterRaw = document.getElementById('radar-filter-keywords').value.trim().toUpperCase();
    const keywordsFilter = keywordsFilterRaw ? keywordsFilterRaw.split(/\s+/).filter(k => k) : [];
    const statusMessage = document.getElementById('radar-import-status');
    const progressContainer = document.getElementById('radar-import-progress-container');
    const noFiltersProvided = !latFilterValue && !lonFilterValue && keywordsFilter.length === 0;
    let confirmationMessage = "";
    if (noFiltersProvided) {
        confirmationMessage = "¿Estás seguro de que quieres borrar TODOS los recordatorios tipo RADAR/POI (ya que no has especificado ningún filtro)? Esta acción no se puede deshacer.";
    } else {
        confirmationMessage = "¿Estás seguro de que quieres borrar los recordatorios tipo RADAR/POI que coincidan con los filtros actuales? Esta acción no se puede deshacer.";
    }
    if (!confirm(confirmationMessage)) {
        showToast("Borrado cancelado", "info");
        return;
    }
    progressContainer.style.display = 'block';
    const progressBar = document.getElementById('radar-import-progress-bar');
    if(progressBar) progressBar.style.display = 'none';
    statusMessage.textContent = 'Borrando recordatorios...';
    statusMessage.style.color = '';
    try {
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        let originalLength = reminders.length;
        reminders = reminders.filter(r => {
            const isRadarType = r.isLocationEnabled && (r.text.toUpperCase().includes("RADAR") || r.excludeFromList);
            if (!isRadarType) return true;
            if (noFiltersProvided) {
                return false;
            }
            let matchesKeywords = true;
            if (keywordsFilter.length > 0) {
                matchesKeywords = keywordsFilter.some(kw => r.text.toUpperCase().includes(kw));
            }
            let matchesLat = true;
            if (latFilterValue) {
                if (r.locationCoordinates) {
                    matchesLat = parseCoordinateFilter(latFilterValue, r.locationCoordinates.latitude);
                } else {
                    matchesLat = false;
                }
            }
            let matchesLon = true;
            if (lonFilterValue) {
                if (r.locationCoordinates) {
                    matchesLon = parseCoordinateFilter(lonFilterValue, r.locationCoordinates.longitude);
                } else {
                    matchesLon = false;
                }
            }
            return !(matchesKeywords && matchesLat && matchesLon);
        });
        localStorage.setItem('reminders', JSON.stringify(reminders));
        const numDeleted = originalLength - reminders.length;
        statusMessage.textContent = `Borrado completo. ${numDeleted} recordatorios eliminados.`;
        statusMessage.style.color = '#28a745';
        showToast(`${numDeleted} recordatorios eliminados`, 'success');
        updateReminderCount();
        updateButtonStyles();
        checkReminders();
    } catch (error) {
        statusMessage.textContent = `Error: ${error.message}`;
        statusMessage.style.color = 'red';
        showToast('Error durante el borrado', 'error');
    } finally {
        setTimeout(() => {
            progressContainer.style.display = 'none';
            if(progressBar) progressBar.style.display = 'block';
            statusMessage.style.color = '';
        }, 3000);
    }
}

// ===================================================================
// NOMBRE: handleMapClickToAddReminder (MODIFICADA - PARA MAPBOX)
// RESUMEN: Maneja el clic para añadir un recordatorio en el mapa.
function handleMapClickToAddReminder(e) {
    if (!isAddReminderAtLocationModeActive || !navigationMapInstance) return;
    const latlng = e.lngLat;
    toggleAddReminderAtLocationMode(); 
    const mapContextBeforeModal = sessionStorage.getItem('mapContext');
    sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
    if (mapContextBeforeModal) {
      sessionStorage.setItem('mapContext', mapContextBeforeModal);
    }
    showReminderModal({
        isLocationEnabled: true,
        locationCoordinates: { latitude: latlng.lat, longitude: latlng.lng },
        radiusMeters: DEFAULT_LOCATION_RADIUS,
        text: 'Recordatorio en mapa: ',
        excludeFromList: false
    }, { onTopOfMap: true });
}

// ===================================================================
// NOMBRE: loadSavedSettings (MODIFICADA - CARGA EL PITCH)
// RESUMEN: Carga la configuración, incluyendo el valor de pitch guardado.
function loadSavedSettings() {
    const savedDarkMode = localStorage.getItem('darkMode');
    isDarkMode = savedDarkMode ? JSON.parse(savedDarkMode) : false;
    if (isDarkMode) document.body.classList.add('dark-mode');
    
    mapOffsetX = parseInt(localStorage.getItem(MAP_VIEW_OFFSET_X_KEY)) || 0;
    mapOffsetY = parseInt(localStorage.getItem(MAP_VIEW_OFFSET_Y_KEY)) || -30;
    const savedMinimapPref = localStorage.getItem(MAP_VIEW_SHOW_MINIMAP_KEY);
    showMinimapPreference = savedMinimapPref === null ? true : JSON.parse(savedMinimapPref);
    // --- LÍNEA MODIFICADA: Carga el pitch guardado ---
    mapPitchValue = parseInt(localStorage.getItem(MAP_VIEW_PITCH_KEY)) || 56;

    const savedZoomState = localStorage.getItem('zoomState');
    const zoomButtonElem = document.getElementById('zoom-button');
    if (zoomButtonElem) {
        zoomButtonElem.dataset.zoomState = savedZoomState || 'off';
        applyZoom(zoomButtonElem.dataset.zoomState);
    }
    const savedPasswordActive = localStorage.getItem('password_active');
    isPasswordActive = savedPasswordActive ? JSON.parse(savedPasswordActive) : false;
    storedPin = localStorage.getItem('password_pin');
    lastUpdatesCheckDate = localStorage.getItem('lastUpdatesCheckDate');
    const savedNoticesActive = localStorage.getItem('noticesActive');
    const savedFooterVisible = localStorage.getItem('footerVisible');
    isActive = savedNoticesActive ? JSON.parse(savedNoticesActive) : true;
    isFooterVisible = savedFooterVisible ? JSON.parse(savedFooterVisible) : true;
    const noticeContainer = document.querySelector('.notices-container');
    if (noticeContainer) noticeContainer.style.display = isActive ? 'flex' : 'none';
    const footerElement = document.querySelector('footer');
    if (footerElement) footerElement.classList.toggle('footer-hidden', !isFooterVisible);
    const onOffBtn = document.getElementById('on-off-toggle');
    if (onOffBtn) {
        const savedOnOffState = localStorage.getItem('onOffState');
        onOffBtn.dataset.state = savedOnOffState ? savedOnOffState : 'on';
    }
    const toggleStatesFromCache = JSON.parse(localStorage.getItem('toggleStates') || '{}');
    document.querySelectorAll('.range-toggle').forEach(toggle => {
        const start = parseInt(toggle.dataset.rangeStart);
        const savedState = toggleStatesFromCache[start] || 'visible';
        toggle.dataset.state = savedState;
    });
    const mainSearchInputGrid = document.getElementById('grid-filter-input');
    if (mainSearchInputGrid) {
        const savedMainFilter = localStorage.getItem('gridFilterValue');
        if (savedMainFilter !== null) {
            mainSearchInputGrid.value = savedMainFilter;
        } else {
            mainSearchInputGrid.value = '';
        }
    }
    
    const mapFilterInput = document.getElementById('filter-input'); 
    if (mapFilterInput) {
        mapFilterInput.value = localStorage.getItem(MAP_FILTER_INPUT_KEY) || 'España';
    }
    
    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresRutaCheckbox) {
        const savedCheckState = localStorage.getItem(RADARES_RUTA_CHECKED_KEY);
        radaresRutaCheckbox.checked = savedCheckState === 'true';
    }
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasRutaCheckbox) {
        const savedTareasCheckState = localStorage.getItem(TAREAS_RUTA_CHECKED_KEY);
        tareasRutaCheckbox.checked = savedTareasCheckState === 'true';
    }
    currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviación ETA';
    const userIdInput = document.getElementById('user-id');
    const modelInput = document.getElementById('tesla-model');
    const yearInput = document.getElementById('tesla-year');
    const provinceInput = document.getElementById('tesla-province');
    const dmsCheckbox = document.getElementById('allow-dms');
    const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
    if (userIdInput) userIdInput.value = localStorage.getItem('userData_userId') || '';
    if (modelInput) modelInput.value = localStorage.getItem('userData_teslaModel') || '';
    if (yearInput) yearInput.value = localStorage.getItem('userData_teslaYear') || '';
    if (provinceInput) provinceInput.value = localStorage.getItem('userData_teslaProvince') || '';
   
   const savedAllowDMs = localStorage.getItem('userData_allowDMs');
   if (dmsCheckbox) {
    dmsCheckbox.checked = savedAllowDMs === null ? true : JSON.parse(savedAllowDMs); 
   } 
    
    if (autoBackupCheckbox) {
        const savedAutoBackup = localStorage.getItem('boardinggate_autoBackupOnLoad');
        autoBackupCheckbox.checked = savedAutoBackup === null ? true : JSON.parse(savedAutoBackup);
    }
    const savedLockState = localStorage.getItem(PROGRESS_BAR_LOCKED_KEY);
    isProgressBarLocked = savedLockState === null ? true : JSON.parse(savedLockState);
    actualizarContadorRadares(0);
    actualizarContadorTareas(0);
    updateUserIdDisplay();
    updateReminderCount();
}
    
// ===================================================================
// NOMBRE: showReorderStagesModal (VERSIÓN FINAL CON CORRECCIÓN DE ID)
// RESUMEN: Se corrige el bug crítico que truncaba los IDs de las etapas al leerlos
function showReorderStagesModal() {
    if (isNavigating) {
        showToast("No se puede reordenar etapas mientras se navega.", "warning");
        return;
    }
    const actualWaypointsForReorder = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    if (actualWaypointsForReorder.length < 2) {
        showToast("Se necesitan al menos 2 puntos para reordenar", "warning");
        return;
    }

    const modal = document.getElementById('reorder-stages-modal');
    const listElement = modal.querySelector('#sortable-stages-list');

    
    listElement.innerHTML = '';
    
    actualWaypointsForReorder.forEach(async (wp) => {
        const li = document.createElement('li');
        li.dataset.id = wp.id;

        const dragHandle = document.createElement('span');
        dragHandle.className = 'drag-handle';
        dragHandle.innerHTML = '<img src="PNG/MOVER.PNG" alt="Mover etapa">';
        dragHandle.title = 'Arrastrar para reordenar';
        dragHandle.draggable = true;

        const badge = document.createElement('span');
        badge.className = 'stage-label-badge';
        badge.textContent = wp.label;

        const nameSpan = document.createElement('span');
        nameSpan.className = 'stage-name-text';
        nameSpan.textContent = wp.address || `Cargando... (${wp.lat.toFixed(3)}, ${wp.lng.toFixed(3)})`;
        if (!wp.address) {
             wp.address = await getAddressForWaypoint(wp.lat, wp.lng);
             nameSpan.textContent = wp.address;
        }

        const deleteButton = document.createElement('span');
        deleteButton.className = 'delete-stage-button';
        deleteButton.innerHTML = '×';
        deleteButton.title = 'Eliminar esta etapa';

        deleteButton.addEventListener('click', (e) => {
            e.stopPropagation();
            const listItem = e.target.closest('li');
            if (listItem) {
                listItem.remove();
            }
        });

        li.appendChild(dragHandle);
        li.appendChild(badge);
        li.appendChild(nameSpan);
        li.appendChild(deleteButton);
        listElement.appendChild(li);
    });

    modal.classList.remove('hidden');
    
    const confirmButton = modal.querySelector('#confirm-reorder-stages');
    const cancelButton = modal.querySelector('#cancel-reorder-stages');
    
    const newConfirmButton = confirmButton.cloneNode(true);
    confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
    const newCancelButton = cancelButton.cloneNode(true);
    cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);
    
    const closeReorderModal = () => {
        clearModalAutoCloseTimer(modal, newConfirmButton, 'reorder-stages-modal');
        modal.classList.add('hidden');
        listElement.removeEventListener('dragstart', handleDragStartReorder);
        listElement.removeEventListener('dragend', handleDragEndReorder);
        listElement.removeEventListener('dragover', handleDragOverReorder);
        listElement.removeEventListener('touchstart', handleStageTouchStart);
        listElement.removeEventListener('touchmove', handleStageTouchMove);
        listElement.removeEventListener('touchend', handleStageTouchEnd);
        listElement.removeEventListener('touchcancel', handleStageTouchEnd);
        document.body.style.overflow = '';
    };

    newConfirmButton.addEventListener('click', async () => {
        const orderedLiElements = Array.from(listElement.children);
        
        const finalWaypointIds = orderedLiElements.map(li => parseFloat(li.dataset.id));
        clearAllWaypointMarkersFromMap();

        if (finalWaypointIds.length < 2) {
            navigationWaypoints = [];
            handleLoadOrDeleteRouteClick(null);
            closeReorderModal();
            return;
        }

        try {
            const waypointMap = new Map(navigationWaypoints.map(wp => [wp.id, wp]));
            
            const userWaypointsInNewOrder = [];
            finalWaypointIds.forEach(id => {
                if (waypointMap.has(id)) {
                    userWaypointsInNewOrder.push(waypointMap.get(id));
                }
            });
            
            const recalcStartPoint = navigationWaypoints.find(wp => wp && wp.isRecalculatedStart);
            navigationWaypoints = recalcStartPoint ? [recalcStartPoint, ...userWaypointsInNewOrder] : [...userWaypointsInNewOrder];
            
            const safeFinalWaypoints = navigationWaypoints.map(wp => ({ id: wp.id, address: wp.address, type: wp.type, label: wp.label, isInternal: wp.isInternal }));
            
            await updateWaypointTypesAndLabels();
            renderWaypointMarkers();
            
            await recalculateAndDrawRoute();

        } catch (error) {
            console.error("[DEBUG] Error capturado en el bloque `try` del modal al intentar recalcular:", error);
        } finally {
            closeReorderModal();
            updateStartNavigationButtonState();
            updateNavigationButtonColor();
        }
    });
    
    newCancelButton.addEventListener('click', () => {
        showToast("Reordenación cancelada.", "info");
        closeReorderModal();
        if (navigationWaypoints.length >= 2) {
            renderWaypointMarkers();
            recalculateAndDrawRoute().catch(() => {});
        } else {
            handleLoadOrDeleteRouteClick(null);
        }
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
    });

    addModalAutoCloseTimer(modal, newConfirmButton, 'reorder-stages-modal', 60000);
    
    listElement.addEventListener('dragstart', handleDragStartReorder);
    listElement.addEventListener('dragend', handleDragEndReorder);
    listElement.addEventListener('dragover', handleDragOverReorder);
    listElement.addEventListener('touchstart', handleStageTouchStart, { passive: false });
    listElement.addEventListener('touchmove', handleStageTouchMove, { passive: false });
    listElement.addEventListener('touchend', handleStageTouchEnd);
    listElement.addEventListener('touchcancel', handleStageTouchEnd);
}
    
// ===================================================================
// NOMBRE: updateProgressBarLockIcon (NUEVA FUNCIÓN)
// RESUMEN: Actualiza el icono del candado en la barra de progreso según su estado.
function updateProgressBarLockIcon() {
    const lockButton = document.getElementById('toggle-progress-bar-lock');
    if (!lockButton) return;
    const img = lockButton.querySelector('img');
    if (img) {
        if (isProgressBarLocked) {
            img.src = "PNG/IMG_4281.png";
            lockButton.title = "Panel de progreso BLOQUEADO. Púlsame para activar auto-ocultación.";
        } else {
            img.src = "PNG/IMG_4280.png";
            lockButton.title = "Panel de progreso DESBLOQUEADO. Se ocultará automáticamente. Púlsame para bloquearlo.";
        }
    }
}

// ===================================================================
// NOMBRE: Lógica de Pre-carga de GPS
// RESUMEN: Obtiene la ubicación del GPS al cargar la página para acelerar la apertura del mapa.
// ===================================================================

let preloadedGpsPosition = null;

function preloadGpsLocation() {
    if ('geolocation' in navigator) {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                console.log("GPS position pre-loaded successfully for faster map opening.");
                preloadedGpsPosition = {
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy,
                    altitude: position.coords.altitude,
                    heading: position.coords.heading,
                    speed: position.coords.speed
                };
            },
            (error) => {
                // No mostramos un toast aquí para no molestar al usuario si falla en segundo plano.
                console.warn("Could not pre-load GPS position:", error.message);
            },
            { 
                enableHighAccuracy: true, 
                timeout: 15000,      // Damos hasta 15 segundos
                maximumAge: 60000    // Aceptamos una posición de hasta 1 minuto de antigüedad
            }
        );
    }
}    

// ===================================================================
// NOMBRE: openNavigationMap (VERSIÓN CON ANIMACIÓN Y LOCALIZACIÓN RÁPIDA)
// RESUMEN: Mantiene la animación del globo, pero usa la posición GPS precargada
//          para volar a la ubicación del usuario inmediatamente después, sin esperas.
// ===================================================================
async function openNavigationMap() {
    const { primaryId: userId } = parseUserId(localStorage.getItem('userData_userId'));
    if (userId && userId.toLowerCase() !== 'boardinggate') {
        const toastId = "map-access-check";
        try {
            const adminDocRef = window.doc(window.db, "user_data", "boardinggate");
            const userDocRef = window.doc(window.db, "user_data", userId);
            
            const [adminSnap, userSnap] = await Promise.all([window.getDoc(adminDocRef), window.getDoc(userDocRef)]);
            
            let maxSessions = Infinity;
            if (adminSnap.exists() && typeof adminSnap.data().max_monthly_sessions === 'number') {
                maxSessions = adminSnap.data().max_monthly_sessions;
            }
            
            let userMonthlyCount = 0;
            if (userSnap.exists()) {
                const userData = userSnap.data();
                const now = new Date();
                const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
                if (userData.map_sessions_last_month === currentMonthStr) {
                    userMonthlyCount = userData.map_sessions_month || 0;
                }
            }

            const existingToast = document.getElementById(toastId);
            if(existingToast) existingToast.remove();
            
            if (userMonthlyCount >= maxSessions) {
                showToast("HA SUPERADO EL NÚMERO MÁXIMO DE SESIONES MENSUALES DE MAPA, consulte con el administrador", "error", 10000);
                return; 
            }
        } catch (error) {
            const existingToast = document.getElementById(toastId);
            if(existingToast) existingToast.remove();
            showToast("No se pudo verificar el límite de sesiones. Acceso permitido.", "warning");
        }
    }

                           
    isGeolocated = false;
    const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'none';
    const footer = document.querySelector('footer'); if (footer) footer.style.display = 'none';
    const noticesContainer = document.querySelector('.notices-icon-container'); if (noticesContainer) noticesContainer.style.display = 'none';
    const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'none');
    document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button, #accident-alert-button').forEach(el => el.style.display = 'none');
    const gridFilter = document.getElementById('grid-filter-container'); if (gridFilter) gridFilter.style.display = 'none';

    isNavigationMapActive = true;
    sessionStorage.setItem('mapContext', 'navigation');
    closeOtherModals('reminders-location-map-modal');
    
    const mapModal = document.getElementById('reminders-location-map-modal');
    if (!mapModal) { console.error("Error crítico: El modal del mapa no se encuentra en el HTML."); isNavigationMapActive = false; return; }
    
    mapModal.classList.remove('map-modal-hidden');
    const mapActualContainer = document.getElementById('mapbox-map-actual-container');
    
    if (navigationMapInstance) {
        handleLoadOrDeleteRouteClick(null);
        setNavigationMapClickHandler();
        setTimeout(() => { if (navigationMapInstance) navigationMapInstance.resize(); }, 100);
        
    } else {
        try {
            const savedLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "HÍBRIDO";
            const finalLayerName = MAP_LEGACY_NAME_MAP[savedLayerName] || savedLayerName;
            const initialStyle = MAP_STYLES[finalLayerName] || MAP_STYLES["HÍBRIDO"];
            showToast("INICIALIZANDO MAPA...", "info", 0, false, "map-init-toast");
  
            const startCoordsTexas = { lat: 30.3715, lng: -97.1903 };
            navigationMapInstance = new mapboxgl.Map({
                container: mapActualContainer,
                style: initialStyle, 
                center: [startCoordsTexas.lng, startCoordsTexas.lat],
                zoom: 2.8,
                pitch: 0,
                bearing: 0,
                attributionControl: false, 
                accessToken: mapboxgl.accessToken
            });
            
            setMapImmersiveMode(true);
            
            incrementMapSessionCount();
            mapSessionStartTime = Date.now();
            
            const customControls = new CustomMapControlsGroup();
            navigationMapInstance.addControl(customControls, 'bottom-right');
            
            compassAndModeControl = new CompassAndStatsControl();
            navigationMapInstance.addControl(compassAndModeControl, 'bottom-left');
            
            // ... (el resto de tu código de inicialización de controles y listeners)
            if (!navigationMapInstance._interactionListenersAttached) {
                const mapCanvas = navigationMapInstance.getCanvasContainer();
                let touchStartPos = null;
                let hasMovedEnoughToDrag = false;
                const DRAG_THRESHOLD = 10;
                const onTouchStart = (e) => {
                    if (e.touches && e.touches.length > 1) return;
                    const touch = e.touches ? e.touches[0] : e;
                    touchStartPos = { x: touch.clientX, y: touch.clientY };
                    hasMovedEnoughToDrag = false;
                };
                const onTouchMove = (e) => {
                    if (hasMovedEnoughToDrag || !touchStartPos) return;
                    if (e.touches && e.touches.length > 1) return;
                    const touch = e.touches ? e.touches[0] : e;
                    const deltaX = Math.abs(touch.clientX - touchStartPos.x);
                    const deltaY = Math.abs(touch.clientY - touchStartPos.y);
                    if (deltaX > DRAG_THRESHOLD || deltaY > DRAG_THRESHOLD) {
                        hasMovedEnoughToDrag = true;
                        handleManualMapInteraction(); 
                    }
                };
                const onTouchEnd = () => {
                    touchStartPos = null;
                    hasMovedEnoughToDrag = false;
                };
                mapCanvas.addEventListener('touchstart', onTouchStart, { passive: true });
                mapCanvas.addEventListener('touchmove', onTouchMove, { passive: true });
                mapCanvas.addEventListener('touchend', onTouchEnd, { passive: true });
                navigationMapInstance.on('pitchend', (e) => {
                    if (e.originalEvent) { 
                        const newPitch = navigationMapInstance.getPitch();
                        if (Math.abs(newPitch - mapPitchValue) > 0.1) {
                            mapPitchValue = newPitch;
                            saveSettings();
                        }
                    }
                });
                navigationMapInstance._interactionListenersAttached = true; 
            }
            // ...
            
            navigationMapInstance.on('error', (e) => {
                if (e.error && e.error.message.includes("Token")) {
                    showToast("Error de Token de Mapbox. Revisa los permisos (scopes) en tu cuenta.", "error", 10000);
                }
            });
            
            navigationMapInstance.on('load', async function() {
                try {
                    const initToast = document.getElementById("map-init-toast");
                    if (initToast) initToast.remove();

                    await loadAndAddMapImages(navigationMapInstance);
                    reAddCustomMapLayersAndSources(navigationMapInstance);
                    
                    processTrafficAlerts();
                    
                    navigationMapInstance.on('pitch', updateLineWidthsOnPitchChange);
                    
                    mapPreviousZoomLevelForPDRs = navigationMapInstance.getZoom();
                    navigationMapInstance.on('zoomend', updateAllIconSizes);
                    navigationMapInstance.on('zoomend', updateTrafficAlertIconSizes);
                    toggleMapHeaderRowsVisibility(mapHeaderButtonsVisible);

                    navigationMapInstance.on('click', async (e) => {
                        // ... (tu código de 'click' existente)
                    });
                    
                    enablePoiInteractivity(navigationMapInstance);
                    setNavigationMapClickHandler();
                    
                    // --- INICIO DE LA LÓGICA DE ANIMACIÓN Y LOCALIZACIÓN ---
                    
                    // 1. Animación del Globo (siempre se ejecuta)
                    const globeSpinPromise = new Promise(resolve => {
                        const startCoords = { lat: 30.3715, lng: -97.1903 };
                        const endCoords = { lat: 40.3748, lng: -3.7354 };
                        const duration = 2500;
                        const directLngDiff = endCoords.lng - startCoords.lng;
                        const totalLngChange = -(360 - directLngDiff);
                        const totalLatChange = endCoords.lat - startCoords.lat;
                        const startTimestamp = performance.now();

                        function animateSpin(timestamp) {
                            const elapsedTime = timestamp - startTimestamp;
                            let progress = Math.min(elapsedTime / duration, 1);
                            progress = 1 - Math.pow(1 - progress, 3);
                            const currentLng = startCoords.lng + (totalLngChange * progress);
                            const currentLat = startCoords.lat + (totalLatChange * progress);
                            navigationMapInstance.setCenter([currentLng, currentLat]);
                            if (progress < 1) {
                                requestAnimationFrame(animateSpin);
                            } else {
                                navigationMapInstance.setCenter([endCoords.lng, endCoords.lat]);
                                resolve();
                            }
                        }
                        requestAnimationFrame(animateSpin);
                    });

                    // 2. Función para obtener GPS con reintentos
                    async function getGpsWithRetries() {
                        // Si ya tenemos la posición, la devolvemos inmediatamente.
                        if (preloadedGpsPosition) {
                            return preloadedGpsPosition;
                        }
                        
                        // Si no, la buscamos activamente.
                        const toastId = "gps-locate-toast";
                        showToast("LOCALIZANDO VEHÍCULO...", "info", 0, false, toastId);
                        
                        while (true) {
                            try {
                                const coords = await getCurrentLocationAsync();
                                const loadingToast = document.getElementById(toastId);
                                if (loadingToast) loadingToast.remove();
                                return coords;
                            } catch (error) {
                                showToast(`No se pudo obtener la ubicación. Reintentando en 3 segundos...`, "warning", 0, false, toastId);
                                await new Promise(resolve => setTimeout(resolve, 3000));
                            }
                        }
                    }

                    // 3. Ejecutamos la animación Y la búsqueda de GPS en paralelo.
                    const [_, currentPos] = await Promise.all([
                        globeSpinPromise,
                        getGpsWithRetries()
                    ]);
                    
                    // 4. Cuando ambas terminan, volamos a la posición del coche.
                    setMapImmersiveMode(false);
                    navigationFollowUser = true;
                    shouldCenterOnUser = true;
                    updateLocateMeButtonsUI();
                    toggleMapControls(true);
                    navigationCurrentLocation = currentPos;
                    updateInitialUserPosition(currentPos, navigationMapInstance);
                    
                    if (navigationMapInstance) {
                        navigationMapInstance.flyTo({
                            center: [currentPos.longitude, currentPos.latitude],
                            zoom: 17,
                            bearing: 0,
                            pitch: 50,
                            duration: 2300
                        });
                    }
                    startGpsWatching();
                    
                } catch (loadError) {
                    showToast(`Error crítico al cargar los recursos del mapa: ${loadError.message}`, "error", 10000);
                }
            });
        } catch (initError) {
             if (mapActualContainer) mapActualContainer.innerHTML = `<div style="color:red; text-align:center; padding:20px; background: rgba(0,0,0,0.7); height:100%; display:flex; align-items:center; justify-content:center; flex-direction:column;"><h2>Error al cargar el mapa</h2><p>${initError.message}</p><p style="margin-top:10px; font-size:0.9rem;">Por favor, revisa tu token de Mapbox y sus permisos (scopes).</p></div>`;
             isNavigationMapActive = false;
        }
    }
    
    assignMapButtonListeners();
    const lockButton = document.getElementById('toggle-progress-bar-lock');
    if (lockButton && !lockButton.dataset.listenerAttached) {
        lockButton.addEventListener('click', handleProgressBarLockToggle);
        lockButton.dataset.listenerAttached = 'true';
    }
    updateProgressBarLockIcon();
    
    const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresCheckbox) radaresCheckbox.checked = localStorage.getItem(RADARES_RUTA_CHECKED_KEY) === 'true';
    const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasCheckbox) tareasCheckbox.checked = localStorage.getItem(TAREAS_RUTA_CHECKED_KEY) === 'true';
    const mapboxCheckbox = document.getElementById('mapbox-primary-checkbox');
    if (mapboxCheckbox) mapboxCheckbox.checked = localStorage.getItem('boardinggate_useMapboxAsPrimary') === 'true';
    currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviación ETA';
    mapViewMode = localStorage.getItem(MAP_VIEW_MODE_KEY) || 'static';
    isAutoZoomActive = localStorage.getItem(AUTO_ZOOM_ACTIVE_KEY) === 'true';
    const autoBtn = document.getElementById('zoom-auto-button');
    if (autoBtn) autoBtn.classList.toggle('active', isAutoZoomActive);
    toggleMapHeaderRowsVisibility(mapHeaderButtonsVisible);
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    toggleMapLocationSearchVisibility(!isNavigating);
}    

// ===================================================================
// NOMBRE: loadRouteFromObject (VERSIÓN FINAL Y ROBUSTA CONTRA MOVIMIENTO)
// RESUMEN: "Salva" la ubicación GPS actual ANTES de limpiar, garantizando un recálculo fiable.
async function loadRouteFromObject(routeObject, autoStartNavigation = false) {
    if (!routeObject || !routeObject.waypoints) {
        showToast("Error: El objeto de la ruta es inválido.", "error");
        return;
    }

    if (isFreeDriveActive) {
        isFreeDrivePaused = true;
        isFreeDriveActive = false;
        showToast("Modo Conducción Libre en pausa.", "info");
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        clearNavigationGraph();
    }

    const startLocation = navigationCurrentLocation ? { ...navigationCurrentLocation } : null;

    resetNavigationState();

    currentRouteNameForSaving = routeObject.name;
    
    // --- INICIO DE LA CORRECCIÓN CLAVE ---
    // En lugar de copiar todos los waypoints, preparamos la lista para usar solo los destinos.
    const waypointsFromLoadedRoute = routeObject.waypoints;
    // --- FIN DE LA CORRECCIÓN CLAVE ---

    if (isNavigationMapActive && startLocation) {
      
        const startPoint = {
            id: Date.now() - 1,
            lat: startLocation.latitude,
            lng: startLocation.longitude,
            type: 'S', marker: null,
            label: 'S',
            address: 'Posición Actual (GPS)',
            visited: true,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false };
        
        navigationWaypoints = [startPoint];
        
        // --- INICIO DE LA MODIFICACIÓN CLAVE ---
        // Usamos .slice(1) para OMITIR el primer punto (el de partida original) de la ruta guardada.
        waypointsFromLoadedRoute.slice(1).forEach(wpData => {
            if (wpData) {
                navigationWaypoints.push({
                    id: wpData.id || Date.now() + Math.random(),
                    lat: wpData.lat, lng: wpData.lng, type: '', label: '', marker: null,
                    address: wpData.address || '', visited: false, isCriticalForRecalc: true,
                    isInternal: false, isRecalculatedStart: false
                });
            }
        });
        // --- FIN DE LA MODIFICACIÓN CLAVE ---

    } else {
        const isSingleDestinationRoute = routeObject.waypoints.length === 1;
        
        if (isSingleDestinationRoute && startLocation) {
             const startPoint = {
                id: Date.now() - 1, lat: startLocation.latitude, lng: startLocation.longitude,
                type: 'S', marker: null, label: 'S', address: 'Posición Actual (GPS)', visited: true,
                isCriticalForRecalc: true, isInternal: false, isRecalculatedStart: false
            };
            navigationWaypoints.push(startPoint);
        }
        
        // --- INICIO DE LA MODIFICACIÓN CLAVE (PARA EL CASO 'ELSE') ---
        const waypointsToAdd = isSingleDestinationRoute ? waypointsFromLoadedRoute : waypointsFromLoadedRoute.slice(1);
        waypointsToAdd.forEach(wpData => {
            if (wpData) {
                navigationWaypoints.push({
                    id: wpData.id || Date.now() + Math.random(),
                    lat: wpData.lat,
                    lng: wpData.lng,
                    type: '', label: '', marker: null,
                    address: wpData.address || '', visited: false, isCriticalForRecalc: true,
                    isInternal: false, isRecalculatedStart: false
                });
            }
        });
        // --- FIN DE LA MODIFICACIÓN CLAVE ---
    }

    await updateWaypointTypesAndLabels();
    renderWaypointMarkers();

    if (navigationWaypoints.filter(wp => wp && !wp.isInternal).length >= 2) {
        recalculateAndDrawRoute(false).then(() => {
            if (autoStartNavigation) {
                if (navigationMapInstance && navigationMapInstance.getSource('route') && navigationMapInstance.getSource('route')._data) {
                    const routeGeoJSON = navigationMapInstance.getSource('route')._data;
                    if (routeGeoJSON.geometry && routeGeoJSON.geometry.coordinates.length > 1) {
                        const coordinates = routeGeoJSON.geometry.coordinates;
                        const bounds = new mapboxgl.LngLatBounds();
                        coordinates.forEach(coord => bounds.extend(coord));
                        if (!bounds.isEmpty()) {
                            mapPreviousZoomLevel = navigationMapInstance.getZoom();
                            navigationMapInstance.fitBounds(bounds, { padding: 80, animate: true, duration: 1500 });
                        }
                    }
                }
                const firstDestination = navigationWaypoints.find(wp => wp && !wp.isInternal && wp.type !== 'S' && !wp.visited);
                if (firstDestination) {
                    fetchAndDisplayAlternativeRoutes(firstDestination.id);
                }
                showAutoStartNavigationModal();
            }
        });
    }
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}
    
// ===================================================================
// NOMBRE: fetchAndRenderChatUsers (CON ESTADÍSTICAS COMPLETAS PARA ADMIN)
// RESUMEN: Muestra la lista de usuarios y, para el admin, estadísticas
async function fetchAndRenderChatUsers() {
    const usersListContainer = document.getElementById('chat-users-list');
    const messageInput = document.getElementById('chat-message-input');
    const filterInput = document.getElementById('chat-user-filter-input');
    
    if (!usersListContainer || !window.db || !messageInput || !filterInput) return;

    if (!filterInput.listenerAdded) {
        filterInput.addEventListener('input', fetchAndRenderChatUsers);
        filterInput.listenerAdded = true;
    }

    const isAdmin = (localStorage.getItem('userData_userId') || '').toLowerCase() === 'boardinggate';

    if (isAdmin) {
        // Obtenemos ambas estadísticas globales en paralelo para mayor eficiencia
        const [sessionStats, poiStats] = await Promise.all([
            getGlobalMapSessionStats(),
            getGlobalPoiStats()
        ]);

        let statsHeader = document.getElementById('chat-admin-stats-header');
        if (!statsHeader) {
            statsHeader = document.createElement('div');
            statsHeader.id = 'chat-admin-stats-header';
            statsHeader.className = 'chat-admin-stats-header';
            const filterContainer = document.getElementById('chat-users-filter-container');
            if (filterContainer) {
                filterContainer.insertAdjacentElement('afterend', statsHeader);
            }
        }
        // Mostramos ambas líneas de estadísticas
        statsHeader.innerHTML = `Sesiones-> Mes: ${sessionStats.totalMonth} | Total: ${sessionStats.totalHistoric}<br>POI Clics (Mes): ${poiStats.totalMonth}`;
        
        let maxSessionsControl = document.getElementById('chat-max-sessions-control');
        if (!maxSessionsControl) {
            maxSessionsControl = document.createElement('div');
            maxSessionsControl.id = 'chat-max-sessions-control';
            maxSessionsControl.style.cssText = 'padding: 8px; background-color: #3a3a3c; border-bottom: 1px solid #444; display: flex; align-items: center; justify-content: center; gap: 10px;';
            maxSessionsControl.innerHTML = `
                <label for="chat-max-sessions-input" style="font-weight: bold; color: #ffd700;">MÁXIMO SESIONES:</label>
                <input type="number" id="chat-max-sessions-input" style="width: 80px; text-align: center; background-color: #2c2c2e; border: 1px solid #555; color: #f0f0f0; border-radius: 4px;">
            `;
            statsHeader.insertAdjacentElement('afterend', maxSessionsControl);

            const maxSessionsInput = document.getElementById('chat-max-sessions-input');
            
            const localMaxSessions = localStorage.getItem(MAX_SESSIONS_KEY);
            if(localMaxSessions) {
                maxSessionsInput.value = localMaxSessions;
            } else {
                const adminDocRef = window.doc(window.db, "user_data", "boardinggate");
                window.getDoc(adminDocRef).then(docSnap => {
                    if (docSnap.exists() && docSnap.data().max_monthly_sessions) {
                        const maxSessions = docSnap.data().max_monthly_sessions;
                        maxSessionsInput.value = maxSessions;
                        localStorage.setItem(MAX_SESSIONS_KEY, maxSessions);
                    }
                });
            }

            maxSessionsInput.addEventListener('change', async () => {
                const newValue = parseInt(maxSessionsInput.value, 10);
                if (!isNaN(newValue) && newValue >= 0) {
                    localStorage.setItem(MAX_SESSIONS_KEY, newValue);
                    const adminDocRef = window.doc(window.db, "user_data", "boardinggate");
                    try {
                        await window.setDoc(adminDocRef, { max_monthly_sessions: newValue }, { merge: true });
                        showToast(`Límite máximo de sesiones mensuales actualizado a ${newValue}.`, 'success');
                    } catch (error) {
                        showToast(`Error al guardar el límite en la nube.`, 'error');
                    }
                }
            });
        }
    } else {
        const statsHeader = document.getElementById('chat-admin-stats-header');
        if (statsHeader) statsHeader.remove();
        const maxSessionsControl = document.getElementById('chat-max-sessions-control');
        if (maxSessionsControl) maxSessionsControl.remove();
    }
    
    try {
        const usersRef = window.collection(window.db, "user_data");
        const q = window.query(usersRef, window.where("rss", "==", true));
        const querySnapshot = await window.getDocs(q);
        
        const filterText = filterInput.value.toLowerCase();
        let usersData = [];

        querySnapshot.forEach(doc => {
            const userData = doc.data();
            const userId = userData.usuario || doc.id;
            usersData.push({ id: userId, ...userData });
        });

        usersData.sort((a, b) => a.id.localeCompare(b.id));

        usersListContainer.innerHTML = ''; 
        let userCount = 0;
        
        const now = new Date();
        const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        usersData.forEach(userData => {
            const userId = userData.id;

            const isBoardingGateAccount = userId.toLowerCase().includes('boardinggate');
            const isMainAdminAccount = userId.toLowerCase() === 'boardinggate';
            if (isBoardingGateAccount && !isMainAdminAccount) {
                return; 
            }

            const userString = `${userId} ${userData.modelo || ''} ${userData.anio || ''} ${userData.provincia || ''}`.toLowerCase();
            if (filterText && !userString.includes(filterText)) {
                return;
            }
            
            const userElement = document.createElement('div');
            userElement.className = 'chat-user-item';
            userElement.style.cursor = 'pointer';
            userElement.title = `Enviar mensaje privado a ${userId}`;

            userElement.addEventListener('click', () => {
                const currentText = messageInput.value;
                if (currentText.startsWith('@')) {
                    const existingMentionEndIndex = currentText.indexOf(' ');
                    if (existingMentionEndIndex !== -1) {
                        messageInput.value = `@${userId} ` + currentText.substring(existingMentionEndIndex + 1);
                    } else {
                        messageInput.value = `@${userId} `;
                    }
                } else {
                    messageInput.value = `@${userId} ` + currentText;
                }
                messageInput.focus();
                messageInput.dispatchEvent(new Event('input'));
            });

            const userName = document.createElement('span');
            userName.className = 'chat-user-name';
            userName.textContent = userId;
            
            const userDetails = document.createElement('span');
            userDetails.className = 'chat-user-details';
            const detailsParts = [];
            if (userData.modelo) detailsParts.push(userData.modelo);
            if (userData.anio) detailsParts.push(userData.anio);
            if (userData.provincia) detailsParts.push(userData.provincia);
            userDetails.textContent = `(${detailsParts.join(', ')})`;

            if (isAdmin) {
                const userMonthSessions = (userData.map_sessions_last_month === currentMonthStr) ? (userData.map_sessions_month || 0) : 0;
                const userTotalSessions = userData.map_sessions_total || 0;
                const userPoiClicks = (userData.poi_clicks_last_month === currentMonthStr) ? (userData.poi_clicks_month || 0) : 0;
                
                const statsSpan = document.createElement('span');
                statsSpan.className = 'chat-user-session-stats';
                statsSpan.textContent = `(Sesiones Mes: ${userMonthSessions} | POI: ${userPoiClicks} | Sesiones Total: ${userTotalSessions})`;
                userDetails.appendChild(statsSpan);
            }
            
            userElement.appendChild(userName);
            userElement.appendChild(userDetails);
            usersListContainer.appendChild(userElement);
            userCount++;
        });

        if (userCount === 0) {
            usersListContainer.innerHTML = '<p class="chat-no-users">No hay usuarios que coincidan con el filtro.</p>';
        }

    } catch (error) {
        console.error("Error al renderizar usuarios del chat:", error);
        usersListContainer.innerHTML = '<p class="chat-no-users">Error al cargar usuarios.</p>';
    }
}

// ===================================================================
// NOMBRE: handleProgressiveManeuverZoom (VERSIÓN FINAL CON CORRECCIÓN DE ÁMBITO)
// RESUMEN: Incluye mejoras y corrección del bug de estado. Ahora recibe
//          carDistanceAlongRouteForNavLogic como argumento para funcionar correctamente.
// ===================================================================

// --- INICIO: Funciones de Ayuda para la lógica de zoom ---
const easeInOutQuad = t => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

function findNextValidStep(route, currentLeg, currentStep) {
    let legIndex = currentLeg;
    let stepIndex = currentStep + 1;
    const waypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal);

    while (legIndex < route.legs.length) {
        const leg = route.legs[legIndex];
        if (stepIndex >= leg.steps.length) {
            legIndex++;
            stepIndex = 0;
            continue;
        }
        const candidateStep = leg.steps[stepIndex];
        const isArrival = candidateStep.maneuver.type === 'arrive';
        const arrivalWaypoint = isArrival ? waypoints[legIndex + 1] : null;
        if (isArrival && arrivalWaypoint && arrivalWaypoint.isInternal) {
            stepIndex++;
            continue; 
        }
        return { step: candidateStep, legIndex: legIndex, stepIndex: stepIndex };
    }
    return null;
}
// --- FIN: Funciones de Ayuda ---

// <<< CAMBIO CLAVE AQUÍ: Se añade el nuevo argumento 'carDistanceAlongRouteForNavLogic' >>>
function handleProgressiveManeuverZoom(currentStep, distanceToManeuver, carDistanceAlongRouteForNavLogic) {
    if (isManualZoomActive) return null;

    if (!isNavigating || !navigationMapInstance || !currentStep) {
        if (isZoomedForManeuver) isZoomedForManeuver = false;
        return null;
    }
    
    const route = navigationCurrentRouteData?.routes?.[0];
    if (!route) return null;

    const maxZoomForMap = navigationMapInstance.getMaxZoom() || 19;
    const currentMapLayerName = (localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "satélite + calles").toLowerCase();
    const isSatelliteWithLabels = currentMapLayerName.includes("satélite + calles");
    const MANEUVER_PEAK_ZOOM_LEVEL = isSatelliteWithLabels ? Math.min(17.5, maxZoomForMap) : Math.min(18.5, maxZoomForMap);
    const HOLD_ZOOM_THRESHOLD = 250;
    
    const currentStepIdentifier = `${currentLegIndexNav}_${currentStepIndexNav}`;
    if (lastProcessedStepIdentifier !== null && lastProcessedStepIdentifier !== currentStepIdentifier) {
        if (progressiveZoomState === 'zooming-in' || progressiveZoomState === 'holding') {
            progressiveZoomState = 'zooming-out';
        }
    }
    lastProcessedStepIdentifier = currentStepIdentifier;

    const distanceIntoCurrentStep = currentStep.distance - distanceToManeuver;
    let targetZoom = null;

    switch (progressiveZoomState) {
        case 'zooming-out':
            isZoomedForManeuver = true;
            const nextStepAfterCurrent = findNextValidStep(route, currentLegIndexNav, currentStepIndexNav);
            
            // <<< CAMBIO CLAVE AQUÍ: Se usa el nuevo argumento >>>
            const distanceToNextStep = nextStepAfterCurrent ? calculateDistanceToEndOfStep(route, nextStepAfterCurrent.legIndex, nextStepAfterCurrent.stepIndex) - carDistanceAlongRouteForNavLogic : Infinity;
            
            if (nextStepAfterCurrent && distanceToNextStep < HOLD_ZOOM_THRESHOLD) {
                targetZoom = MANEUVER_PEAK_ZOOM_LEVEL;
            } else {
                if (distanceIntoCurrentStep > PROGRESSIVE_ZOOM_EXIT_END_DISTANCE || mapPreviousZoomLevelForProgressive === null) {
                    targetZoom = mapPreviousZoomLevelForProgressive;
                    progressiveZoomState = 'none';
                    mapPreviousZoomLevelForProgressive = null;
                    isZoomedForManeuver = false;
                } else if (distanceIntoCurrentStep >= PROGRESSIVE_ZOOM_EXIT_START_DISTANCE) {
                    const progress = (distanceIntoCurrentStep - PROGRESSIVE_ZOOM_EXIT_START_DISTANCE) / (PROGRESSIVE_ZOOM_EXIT_END_DISTANCE - PROGRESSIVE_ZOOM_EXIT_START_DISTANCE);
                    targetZoom = MANEUVER_PEAK_ZOOM_LEVEL - (MANEUVER_PEAK_ZOOM_LEVEL - mapPreviousZoomLevelForProgressive) * Math.min(1, progress);
                } else {
                    targetZoom = MANEUVER_PEAK_ZOOM_LEVEL;
                }
            }
            break;

        default:
            if (distanceToManeuver <= PROGRESSIVE_ZOOM_START_DISTANCE && distanceToManeuver > PROGRESSIVE_ZOOM_PEAK_DISTANCE) {
                if (progressiveZoomState !== 'zooming-in' && progressiveZoomState !== 'holding') {
                    mapPreviousZoomLevelForProgressive = navigationMapInstance.getZoom();
                }
                progressiveZoomState = 'zooming-in';
                let progress = (PROGRESSIVE_ZOOM_START_DISTANCE - distanceToManeuver) / (PROGRESSIVE_ZOOM_START_DISTANCE - PROGRESSIVE_ZOOM_PEAK_DISTANCE);
                progress = easeInOutQuad(progress);
                targetZoom = mapPreviousZoomLevelForProgressive + (MANEUVER_PEAK_ZOOM_LEVEL - mapPreviousZoomLevelForProgressive) * progress;
                isZoomedForManeuver = true;
            } else if (distanceToManeuver <= PROGRESSIVE_ZOOM_PEAK_DISTANCE) {
                if (progressiveZoomState !== 'holding' && mapPreviousZoomLevelForProgressive === null) {
                    mapPreviousZoomLevelForProgressive = navigationMapInstance.getZoom();
                }
                progressiveZoomState = 'holding';
                targetZoom = MANEUVER_PEAK_ZOOM_LEVEL;
                isZoomedForManeuver = true;
            } else {
                if (progressiveZoomState !== 'none' && mapPreviousZoomLevelForProgressive !== null) {
                    targetZoom = mapPreviousZoomLevelForProgressive;
                }
                progressiveZoomState = 'none';
                mapPreviousZoomLevelForProgressive = null;
                isZoomedForManeuver = false;
            }
            break;
    }
    return targetZoom;
}    
// ===================================================================
// NOMBRE: clearModalAutoCloseTimer
// RESUMEN: Limpia un temporizador de autocierre de un modal.
function clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId) {
    const timerIdToClear = modalId || (modalElement ? modalElement.dataset.modalTimerId : null);
    if (timerIdToClear && globalModalTimers[timerIdToClear]) {
        clearInterval(globalModalTimers[timerIdToClear].intervalId);
        const timerData = globalModalTimers[timerIdToClear];
        if (timerData.modalElement && timerData.resetHandler) {
            timerData.modalElement.removeEventListener('click', timerData.resetHandler);
            timerData.modalElement.removeEventListener('touchstart', timerData.resetHandler);
            timerData.modalElement.removeEventListener('input', timerData.resetHandler);
            timerData.modalElement.removeEventListener('scroll', timerData.resetHandler);
        }
        if (timerData.countdownSpan && timerData.countdownSpan.parentNode) {
            timerData.countdownSpan.remove();
        }
        delete globalModalTimers[timerIdToClear];
    }
    if(closeButtonElement){
        const orphanSpans = closeButtonElement.querySelectorAll('.button-countdown-timer');
        orphanSpans.forEach(s => s.remove());
    }
     if(modalElement && modalElement.dataset.modalTimerId) {
        delete modalElement.dataset.modalTimerId;
    }
}
    
// ===================================================================
// NOMBRE: eliminarTareasDeBarraProgreso (MODIFICADA - PARA MAPBOX)
// RESUMEN: Limpia tareas de la barra de progreso Y del mapa.
function eliminarTareasDeBarraProgreso() {
    eliminarTareasDeMapa(); 
    tareasEnRutaActual = [];
    actualizarContadorTareas(0);
    if (navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) {
        completedSegmentsGeoJSON.features = [];
        if (navigationMapInstance && navigationMapInstance.getSource('completed-segments')) {
            navigationMapInstance.getSource('completed-segments').setData(completedSegmentsGeoJSON);
        }
        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
}

// ===================================================================
// NOMBRE: toggleMapHeaderRowsVisibility (CORREGIDA v2 - ANTI TYPEERROR)
// RESUMEN: Muestra/oculta la cabecera y llama a map.resize() de forma segura.
function toggleMapHeaderRowsVisibility(show) {
    const header = document.getElementById('reminders-location-map-header');
    if (!header) return;

    const togglePanel = document.getElementById('toggle-map-header-buttons-panel');

    const removeCountdownOverlay = () => {
        if (togglePanel) {
            const existingOverlay = togglePanel.querySelector('#map-header-countdown-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
        }
    };

    if (mapHeaderAutohideTimer) {
        clearInterval(mapHeaderAutohideTimer);
        mapHeaderAutohideTimer = null;
    }
    removeCountdownOverlay();

    if (isNavigating && show) {
        mapHeaderButtonsVisible = true;
        header.querySelectorAll('.button-row').forEach(row => {
            row.classList.remove('hidden-map-header');
        });

        if (togglePanel) {
            const countdownOverlay = document.createElement('span');
            countdownOverlay.id = 'map-header-countdown-overlay';
            countdownOverlay.style.cssText = `
                position: absolute;
                top: 50%; left: 50%;
                transform: translate(-50%, -50%);
                font-size: 48px; font-weight: bold;
                color: rgba(189, 150, 24, 0.7);
                z-index: 10; pointer-events: none;
                text-shadow: 2px 2px 3px rgba(0,0,0,0.6);
            `;
            togglePanel.appendChild(countdownOverlay);

            let countdown = 20;
            countdownOverlay.textContent = countdown;

            mapHeaderAutohideTimer = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownOverlay.textContent = countdown;
                } else {
                    clearInterval(mapHeaderAutohideTimer);
                    mapHeaderAutohideTimer = null;
                    removeCountdownOverlay();
                    if (mapHeaderButtonsVisible) {
                       toggleMapHeaderRowsVisibility(false);
                    }
                }
            }, 1000);
        }
    } else {
        mapHeaderButtonsVisible = show;
        header.querySelectorAll('.button-row').forEach(row => {
            row.classList.toggle('hidden-map-header', !show);
        });
    }
    
    if (navigationMapInstance) {
        setTimeout(() => {
            const mapContainer = document.getElementById('mapbox-map-actual-container');
            if (navigationMapInstance && mapContainer && mapContainer.offsetHeight > 0) {
                try {
                    navigationMapInstance.resize();
                } catch(e) {
                    console.error("Error al redimensionar el mapa (dentro del timeout):", e);
                }
            }
        }, 350);
    }
}    


    
// ===================================================================
// NOMBRE: eliminarRadaresDeRuta (MODIFICADA - PARA MAPBOX)
// RESUMEN: Elimina del mapa los radares que se habían añadido dinámicamente a la ruta.
function eliminarRadaresDeRuta() {
    reminderMapObjects = reminderMapObjects.filter(obj => {
        if (obj.isFromRuta) {
            if (obj.marker) obj.marker.remove();
            if (obj.circleId && navigationMapInstance.getLayer(obj.circleId)) {
                navigationMapInstance.removeLayer(obj.circleId);
            }
            if (obj.circleId && navigationMapInstance.getSource(obj.circleId)) {
                navigationMapInstance.removeSource(obj.circleId);
            }
            return false;
        }
        return true;
    });
    radaresEnRutaActual = [];
    actualizarContadorRadares(0);
    if (navigationCurrentRouteData?.routes?.[0]) { 
        completedSegmentsGeoJSON.features = [];
        if (navigationMapInstance && navigationMapInstance.getSource('completed-segments')) {
            navigationMapInstance.getSource('completed-segments').setData(completedSegmentsGeoJSON);
        }
        updateNavigationProgressDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
    }
}
// ===================================================================
// NOMBRE: handleZoomToggleButtonClick (VERSIÓN DE DEPURACIÓN CON CONSOLE.LOG)
// ===================================================================
function handleZoomToggleButtonClick(button) {
    if (!navigationMapInstance || !button) return;


    const currentState = button.dataset.zoomState || 'waypoints';
    
    if (currentState === 'car') { 
        
        const currentZoom = navigationMapInstance.getZoom();
        zoomToggleMemory = currentZoom;
        triggerManualMapInteraction();
        
        const newState = 'waypoints';
        button.dataset.zoomState = newState;
        const img = button.querySelector('img');
        if (img) img.src = 'PNG/ZOOM+.PNG';
        button.title = "Acercar a la ubicación del coche";
        const otherButtonId = button.id === 'zoom-toggle-button' ? 'nav-map-zoomtoggle-button' : 'zoom-toggle-button';
        const otherButton = document.getElementById(otherButtonId);
        if (otherButton) {
            otherButton.dataset.zoomState = newState;
            const otherImg = otherButton.querySelector('img');
            if (otherImg) otherImg.src = 'PNG/ZOOM+.PNG';
            otherButton.title = "Acercar a la ubicación del coche";
        }
        
        const routeSource = navigationMapInstance.getSource('route');
        if (routeSource && routeSource._data && routeSource._data.geometry && routeSource._data.geometry.coordinates.length > 1) {
            const coordinates = routeSource._data.geometry.coordinates;
            const bounds = new mapboxgl.LngLatBounds();
            coordinates.forEach(coord => bounds.extend(coord));
            if (!bounds.isEmpty()) {
                navigationMapInstance.fitBounds(bounds, { padding: 80, animate: true, duration: 1500 });
            }
        } else {
            navigationMapInstance.flyTo({ zoom: 10, duration: 1500 });
        }

    } else { 
        triggerManualMapInteraction();
        
        if (navigationCurrentLocation) {
            const newState = 'car';
            button.dataset.zoomState = newState;
            const img = button.querySelector('img');
            if (img) img.src = 'PNG/ZOOM-.PNG';
            button.title = "Alejar para ver la ruta completa";
            const otherButtonId = button.id === 'zoom-toggle-button' ? 'nav-map-zoomtoggle-button' : 'zoom-toggle-button';
            const otherButton = document.getElementById(otherButtonId);
            if (otherButton) {
                otherButton.dataset.zoomState = newState;
                const otherImg = otherButton.querySelector('img');
                if (otherImg) otherImg.src = 'PNG/ZOOM-.PNG';
                otherButton.title = "Alejar para ver la ruta completa";
            }
                        
            navigationMapInstance.flyTo({ 
                center: [navigationCurrentLocation.longitude, navigationCurrentLocation.latitude], 
                zoom: zoomToggleMemory || 19, 
                duration: 1500 
            });
            
            zoomToggleMemory = null; 
        
        } else {
            showToast("Ubicación actual no disponible para hacer zoom.", "warning");
        }
        }
}    
// ===================================================================
// NOMBRE: showPDRsFilterModal (MODIFICADA - PARA MAPBOX)
// RESUMEN: Muestra un modal de filtro que se adapta si hay o no una ruta cargada.
function showPDRsFilterModal() {
    const mapContainer = document.getElementById('reminders-location-map-modal');
    if (!mapContainer || !navigationMapInstance) {
        showToast("El mapa de navegación debe estar abierto para usar los filtros.", "error");
        return;
    }

    const hasRoute = navigationMapInstance.getSource('route') && 
                     navigationMapInstance.getSource('route')._data &&
                     navigationMapInstance.getSource('route')._data.geometry &&
                     navigationMapInstance.getSource('route')._data.geometry.coordinates &&
                     navigationMapInstance.getSource('route')._data.geometry.coordinates.length > 1;

    const PDR_MIN_POWER_KEY = 'boardinggate_pdrFilterMinPower';
    const PDR_MAX_POWER_KEY = 'boardinggate_pdrFilterMaxPower';
    const PDR_DISTANCE_KEY = 'boardinggate_pdrFilterDistance';
    const PDR_RADIUS_KEY = 'boardinggate_pdrFilterRadius';

    const savedMinPower = parseInt(localStorage.getItem(PDR_MIN_POWER_KEY)) || 30;
    const savedMaxPower = parseInt(localStorage.getItem(PDR_MAX_POWER_KEY)) || 600;
    const savedDistance = parseInt(localStorage.getItem(PDR_DISTANCE_KEY)) || 20;
    const savedRadius = parseInt(localStorage.getItem(PDR_RADIUS_KEY)) || 15;
    let distanceControlHtml;
    if (hasRoute) {
        distanceControlHtml = `
            <div id="distance-slider-container" class="filter-group">
                <label id="distance-range-label">Distancia Máxima a la Ruta: ${savedDistance} km</label> 
                <div class="slider-container single-slider-container">
                    <div class="slider-track"></div>
                    <div class="slider-range" id="distance-slider-range"></div>
                    <div class="slider-thumb" id="distance-thumb"></div>
                </div>
            </div>`;
    } else {
        distanceControlHtml = `
            <div id="radius-slider-container" class="filter-group">
                <label id="radius-range-label">Radio de Búsqueda: ${savedRadius} km</label> 
                <div class="slider-container single-slider-container">
                    <div class="slider-track"></div>
                    <div class="slider-range" id="radius-slider-range"></div>
                    <div class="slider-thumb" id="radius-thumb"></div>
                </div>
            </div>`;
    }

    const existingModal = document.getElementById('pdrs-filter-modal-overlay');
    if (existingModal) existingModal.remove();

    const savedOperatorFilter = localStorage.getItem('boardinggate_operator_filter') || '';
    const modalOverlay = document.createElement('div');
    modalOverlay.id = 'pdrs-filter-modal-overlay';
    modalOverlay.className = 'filter-modal-overlay';
    
    modalOverlay.innerHTML = `
        <div class="filter-modal-content" style="background-color: #E6D6A8; color: #333;">
            <h2 style="color: #111;">FILTRO PUNTOS DE CARGA</h2>
            <div class="filter-group">
                <label for="operator-filter-input" style="font-weight:bold;">Filtrar operadores:</label>
                <div style="position: relative; width: 90%; margin: 5px auto 0 auto;">
                    <input type="text" id="operator-filter-input" value="${savedOperatorFilter}" placeholder="Ej: Zunder Iberdrola" style="width: 100%; padding: 8px 30px 8px 8px; font-size: 1rem; border-radius: 4px; border: 1px solid #aaa; background-color: #f0f0e0;">
                    <button id="clear-operator-filter" title="Limpiar filtro de operadores" style="position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 1.5rem; color: #888; cursor: pointer; padding: 0 5px; display: none;">×</button>
                </div>
            </div>
            <div class="filter-group">
                <label id="power-range-label" style="font-weight:bold;">Potencia: ${savedMinPower} kW - ${savedMaxPower} kW</label> 
                <div class="slider-container">
                    <div class="slider-track"></div>
                    <div class="slider-range" id="power-slider-range"></div>
                    <div class="slider-thumb left" id="power-thumb-min"></div>
                    <div class="slider-thumb right" id="power-thumb-max"></div>
                </div>
            </div>
            
            <div class="ocm-color-legend">
                <div class="ocm-color-legend-item">
                    <div class="ocm-color-legend-icon" style="border-color: black;"></div>
                    <span>≤50kW</span>
                </div>
                <div class="ocm-color-legend-item">
                    <div class="ocm-color-legend-icon" style="border-color: green;"></div>
                    <span>≤100kW</span>
                </div>
                <div class="ocm-color-legend-item">
                    <div class="ocm-color-legend-icon" style="border-color: rgb(30, 144, 255);"></div>
                    <span>≤250kW</span>
                </div>
                <div class="ocm-color-legend-item">
                    <div class="ocm-color-legend-icon" style="border-color: #de2e03;"></div>
                    <span>>250kW</span>
                </div>
            </div>

            ${distanceControlHtml}
            
            <div class="filter-group" style="text-align: left; margin-top: 20px;">
                <label id="search-in-view-label" style="display: flex; align-items: center; cursor: pointer; font-size: 1.1rem; user-select: none; transition: opacity 0.3s;">
                    <input type="checkbox" id="search-in-view-checkbox" style="width: 1.2rem; height: 1.2rem; margin-right: 10px; flex-shrink: 0;">
                    Buscar en la zona del mapa que estés viendo ahora
                </label>
            </div>

            <button id="accept-filters-btn" style="background-color: #2563EB;">Aceptar</button>

            <div class="ocm-modal-info-footer">
                <p><strong>(*) Cómo buscar:</strong> Si hay una ruta cargada, la búsqueda por defecto es sobre el trazado. Si no hay ruta, en un radio desde el centro. Para buscar siempre en la vista actual, marque la casilla superior.</p>
                <p><strong>(*) Secuencia del botón:</strong> <strong>1ª Pulsación:</strong> Abre filtros. | <strong>2ª Pulsación:</strong> Muestra solo los más económicos. | <strong>3ª Pulsación:</strong> Limpia el mapa de PDRs.</p>
                <p style="margin-top:10px; font-style:italic;">Datos proporcionados por <a href="https://openchargemap.org" target="_blank" style="color:#0056b3; text-decoration:underline;">Open Charge Map</a>.</p>
            </div>
        </div>
    `;

    mapContainer.appendChild(modalOverlay);
    
    const PDR_SEARCH_IN_VIEW_KEY = 'boardinggate_pdrSearchInView';
    const searchInViewCheckbox = document.getElementById('search-in-view-checkbox');
    const distanceSliderContainer = document.getElementById('distance-slider-container') || document.getElementById('radius-slider-container');
    
    const updateControlsState = () => {
        if (searchInViewCheckbox.checked) {
            distanceSliderContainer.style.opacity = '0.5';
            distanceSliderContainer.style.pointerEvents = 'none';
        } else {
            distanceSliderContainer.style.opacity = '1';
            distanceSliderContainer.style.pointerEvents = 'auto';
        }
    };
    
    const savedSearchInView = localStorage.getItem(PDR_SEARCH_IN_VIEW_KEY) === 'true';
    searchInViewCheckbox.checked = savedSearchInView;
    searchInViewCheckbox.addEventListener('change', () => {
        localStorage.setItem(PDR_SEARCH_IN_VIEW_KEY, searchInViewCheckbox.checked);
        updateControlsState();
    });
    
    updateControlsState();

    const operatorInput = document.getElementById('operator-filter-input');
    const clearOperatorButton = document.getElementById('clear-operator-filter');
    
    const toggleClearButtonVisibility = () => {
        clearOperatorButton.style.display = operatorInput.value.trim() ? 'block' : 'none';
    };

    operatorInput.addEventListener('input', toggleClearButtonVisibility);
    clearOperatorButton.addEventListener('click', () => {
        operatorInput.value = '';
        toggleClearButtonVisibility();
        operatorInput.focus();
    });
    toggleClearButtonVisibility();

    const setupSlider = (idPrefix, minVal, maxVal, defaultMin, defaultMax, unit, isRange = true) => {
        const thumbMax = document.getElementById(`${idPrefix}-thumb` + (isRange ? '-max' : ''));
        if (!thumbMax) return () => ({ min: 0, max: 0 });
        const container = thumbMax.parentElement;
        const range = document.getElementById(`${idPrefix}-slider-range`);
        const label = document.getElementById(`${idPrefix}-range-label`);
        const thumbMin = isRange ? document.getElementById(`${idPrefix}-thumb-min`) : null;
        let currentMin = defaultMin; 
        let currentMax = defaultMax;

        const updateVisuals = () => {
            const minPercent = isRange ? ((currentMin - minVal) / (maxVal - minVal)) * 100 : 0;
            const maxPercent = ((currentMax - minVal) / (maxVal - minVal)) * 100;
            
            if (isRange && thumbMin) thumbMin.style.left = `${minPercent}%`;
            thumbMax.style.left = `${maxPercent}%`;
            range.style.left = `${minPercent}%`;
            range.style.width = `${maxPercent - minPercent}%`;
            
            if(isRange){
                label.textContent = `Potencia: ${Math.round(currentMin)} ${unit} - ${Math.round(currentMax)} ${unit}`;
            } else {
                label.textContent = `${hasRoute ? 'Distancia Máxima a la Ruta' : 'Radio de Búsqueda'}: ${Math.round(currentMax)} ${unit}`;
            }
        };

        const onDrag = (e, thumb) => {
            const rect = container.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let percent = ((clientX - rect.left) / rect.width) * 100;
            percent = Math.max(0, Math.min(100, percent));
            
            let value = minVal + (percent / 100) * (maxVal - minVal);
            
            if (isRange && thumb === thumbMin) {
                currentMin = Math.min(value, currentMax);
            } else {
                currentMax = isRange ? Math.max(value, currentMin) : value;
            }
            updateVisuals();
        };

        const thumbsToSetup = isRange ? [thumbMin, thumbMax] : [thumbMax];
        thumbsToSetup.forEach(thumb => {
            const startDrag = (e) => {
                const moveHandler = (moveEvent) => onDrag(moveEvent, thumb);
                const endDrag = () => {
                    document.removeEventListener('mousemove', moveHandler);
                    document.removeEventListener('mouseup', endDrag);
                    document.removeEventListener('touchmove', moveHandler);
                    document.removeEventListener('touchend', endDrag);
                };
                document.addEventListener('mousemove', moveHandler);
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchmove', moveHandler);
                document.addEventListener('touchend', endDrag);
            };
            thumb.addEventListener('mousedown', startDrag);
            thumb.addEventListener('touchstart', startDrag);
        });
        
        updateVisuals();
        return () => ({ min: isRange ? currentMin : minVal, max: currentMax });
    };

    const getPowerValues = setupSlider('power', 7, 2000, savedMinPower, savedMaxPower, 'kW', true);
    const getDistanceValues = hasRoute ? setupSlider('distance', 0, 50, 0, savedDistance, 'km', false) : () => ({});
    const getRadiusValues = !hasRoute ? setupSlider('radius', 1, 100, 1, savedRadius, 'km', false) : () => ({});

    const acceptButton = document.getElementById('accept-filters-btn');
    acceptButton.addEventListener('click', () => {
        const operatorFilterValue = document.getElementById('operator-filter-input').value;
        localStorage.setItem('boardinggate_operator_filter', operatorFilterValue);

        const powerFilters = getPowerValues();
        localStorage.setItem(PDR_MIN_POWER_KEY, Math.round(powerFilters.min));
        localStorage.setItem(PDR_MAX_POWER_KEY, Math.round(powerFilters.max));

        let searchConfig;
        if (hasRoute) {
            const distanceFilters = getDistanceValues();
            localStorage.setItem(PDR_DISTANCE_KEY, Math.round(distanceFilters.max));
            searchConfig = { type: 'route', distanceFilters };
        } else {
            const radiusFilters = getRadiusValues();
            localStorage.setItem(PDR_RADIUS_KEY, Math.round(radiusFilters.max));
            searchConfig = { type: 'radius', radiusKm: radiusFilters.max, center: navigationMapInstance.getCenter() };
        }
        
        if (navigationFollowUser) {
            const locateMeButton = document.getElementById('locate-me-on-reminders-map');
            if (locateMeButton) {
                handleLocateMeClick(locateMeButton);
                showToast('Seguimiento pausado por 1 minuto para explorar el mapa.', 'info', 4000);
                if (window.followMeReactivationTimer) {
                    clearTimeout(window.followMeReactivationTimer);
                }
                window.followMeReactivationTimer = setTimeout(() => {
                    if (!navigationFollowUser) {
                        handleLocateMeClick(locateMeButton);
                        showToast('Seguimiento automático reactivado.', 'info');
                    }
                    window.followMeReactivationTimer = null;
                }, 60000);
            }
        }

        modalOverlay.remove();
        findChargingPointsOnRoute(powerFilters, searchConfig);
    });

    addModalAutoCloseTimer(modalOverlay, acceptButton, 'pdrs-filter-modal', 20000);
}

// ===================================================================
// NOMBRE: handleTouchCancel
// RESUMEN: Maneja la cancelación de un arrastre táctil.
function handleTouchCancel(e) {    if (!isEditMode) return;     handleTouchEndCleanup(); 
}
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// NOMBRE: openLocationsPreviewMap (VERSIÓN FINAL CON FILTRO CORREGIDO)
// RESUMEN: Abre un mapa modal satélite y dibuja TODOS los marcadores de forma eficiente, corrigiendo el error de sintaxis en el filtro de la capa de texto.
function openLocationsPreviewMap() {
    closeOtherModals('locations-preview-modal');
    document.body.classList.add('modal-open');

    let modal = document.getElementById('locations-preview-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'locations-preview-modal';
        modal.innerHTML = `
            <h2 id="locations-preview-title">Ubicaciones con Recordatorios</h2>
            <div id="locations-preview-map-container" style="height: calc(100% - 100px); width: 100%;"></div>
            <div class="modal-top-buttons" style="justify-content: center; margin-top: 1rem;">
                <button id="close-locations-preview">Salir</button>
            </div>
        `;
        document.body.appendChild(modal);
    }
    
    modal.classList.remove('hidden');
    const mapContainerEl = modal.querySelector('#locations-preview-map-container');
    const closeButton = modal.querySelector('#close-locations-preview');
    const titleElement = modal.querySelector('#locations-preview-title');
    
    const closeHandler = () => {
        if (locationsPreviewMap) {
            try { locationsPreviewMap.remove(); } catch (e) {}
            locationsPreviewMap = null;
        }
        locationsPreviewMapObjects = [];
        clearModalAutoCloseTimer(modal, closeButton, 'locations-preview-modal');
        modal.classList.add('hidden');
        document.body.classList.remove('modal-open');
    };

    const newCloseButton = closeButton.cloneNode(true);
    closeButton.parentNode.replaceChild(newCloseButton, closeButton);
    newCloseButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(modal, newCloseButton, 'locations-preview-modal', 120000);

    if (locationsPreviewMap) {
        try { locationsPreviewMap.remove(); } catch (e) {}
    }
    
    locationsPreviewMap = new mapboxgl.Map({
        container: mapContainerEl,
        style: 'mapbox://styles/mapbox/satellite-streets-v12', 
        center: [-3.703790, 40.416775],
        zoom: 6,
        attributionControl: true 
    });

    const plotAllLocations = async () => {
        await loadAndAddMapImages(locationsPreviewMap);

        const allReminders = JSON.parse(localStorage.getItem('reminders') || '[]').map(r => ({ ...r }));
        const showExcluded = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
        let locationsToPlot = allReminders.filter(r => {
            const hasLocation = r.isLocationEnabled && r.locationCoordinates?.latitude && r.locationCoordinates?.longitude;
            if (!hasLocation) return false;
            return showExcluded ? true : !r.excludeFromList;
        });

        if (titleElement) {
            titleElement.textContent = `Ubicaciones con Recordatorios ${showExcluded ? '(incl. Radares)' : '(sin Radares)'}`;
        }

        const geojsonFeatures = locationsToPlot.map(reminder => {
            const isRadar = reminder.text.toUpperCase().includes("RADAR") || reminder.excludeFromList;
            const speed = isRadar ? extractSpeedFromRadarText(reminder.text) : null;
            
            const properties = {
                reminderId: reminder.id,
                isRadar: isRadar,
                isFromTarea: reminder.isFromTarea || false,
            };
            if (speed !== null) {
                properties.speed = String(speed);
            }

            return {
                type: 'Feature',
                geometry: {
                    type: 'Point',
                    coordinates: [reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]
                },
                properties: properties
            };
        });

        const geojsonData = {
            type: 'FeatureCollection',
            features: geojsonFeatures
        };

        const sourceId = 'locations-preview-source';
        if (locationsPreviewMap.getSource(sourceId)) {
            locationsPreviewMap.getSource(sourceId).setData(geojsonData);
        } else {
            locationsPreviewMap.addSource(sourceId, { type: 'geojson', data: geojsonData });
        }

        const layers = [
            { id: 'preview-circles', type: 'circle', filter: ['==', 'isRadar', true], paint: {'circle-color': 'red', 'circle-radius': 15, 'circle-stroke-width': 2, 'circle-stroke-color': 'white'} },
            { id: 'preview-speed-text', type: 'symbol', filter: ['all', ['==', 'isRadar', true], ['has', 'speed']], layout: {'text-field': '{speed}', 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 12, 'text-allow-overlap': true}, paint: {'text-color': 'yellow'} },
            { id: 'preview-radar-text', type: 'symbol', filter: ['all', ['==', 'isRadar', true], ['!has', 'speed']], layout: { 'text-field': 'Rdar', 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 10, 'text-allow-overlap': true}, paint: { 'text-color': 'yellow'} },
            { id: 'preview-reminder-icons', type: 'symbol', filter: ['==', 'isRadar', false], layout: {'icon-image': 'reminder-icon', 'icon-size': 0.7, 'icon-allow-overlap': true, 'icon-anchor': 'bottom'} }
        ];

        layers.forEach(layer => {
            if (!locationsPreviewMap.getLayer(layer.id)) {
                locationsPreviewMap.addLayer({ ...layer, source: sourceId });
            }
        });
        
        setTimeout(() => {
            if (!locationsPreviewMap) return; 
            if (geojsonFeatures.length > 0) {
                const bounds = new mapboxgl.LngLatBounds();
                geojsonFeatures.forEach(feature => {
                    bounds.extend(feature.geometry.coordinates);
                });
                if (!bounds.isEmpty()) {
                    try {
                        locationsPreviewMap.fitBounds(bounds, { padding: 50, duration: 0 });
                    } catch(e) {
                        console.error("Error al ejecutar fitBounds en el modal de vista previa:", e);
                    }
                }
            } else {
                showToast(`No hay recordatorios con ubicación para mostrar según el filtro actual.`, "info");
            }
        }, 100);

        const interactiveLayers = ['preview-circles', 'preview-reminder-icons'];
        locationsPreviewMap.on('click', interactiveLayers, (e) => {
            if (e.features && e.features.length > 0) {
                const reminderId = e.features[0].properties.reminderId;
                showReminderActionModal(reminderId);
            }
        });

        locationsPreviewMap.on('mouseenter', interactiveLayers, () => { locationsPreviewMap.getCanvas().style.cursor = 'pointer'; });
        locationsPreviewMap.on('mouseleave', interactiveLayers, () => { locationsPreviewMap.getCanvas().style.cursor = ''; });
    };

    if (locationsPreviewMap.isStyleLoaded()) {
        plotAllLocations();
    } else {
        locationsPreviewMap.on('load', plotAllLocations);
    }
}    
// ===================================================================
// NOMBRE: showSavedLocationsModal (VERSIÓN FINAL CON REUTILIZACIÓN DE MAPA)
// RESUMEN: Muestra el modal de ubicaciones guardadas. El mapa selector se crea una
//          sola vez y se reutiliza, moviéndolo desde y hacia un "garaje" oculto
function showSavedLocationsModal(callbackOnClose, callbackOnSelectLocation, options = {}) {

    const existingModal = document.querySelector('.saved-locations-modal');
    if (existingModal) {
        if (locationPickerMap) { 
            // Si el modal se cierra de forma inesperada, devolvemos el mapa al garaje
            const mapGarage = document.getElementById('map-garage');
            const mapContainer = locationPickerMap.getContainer();
            if (mapGarage && mapContainer) mapGarage.appendChild(mapContainer);
        }
        clearModalAutoCloseTimer(existingModal, existingModal.querySelector('#close-saved-locations-modal'), 'saved-locations-modal');
        existingModal.remove();
    }

    tempSavedLocations = getSavedLocations().map(loc => loc ? {...loc} : null);
    const modal = document.createElement('div');
    modal.className = 'saved-locations-modal';
    
    modal.innerHTML = `
        <h2>Gestionar Ubicaciones Guardadas (Máx. ${MAX_SAVED_LOCATIONS})</h2>
        <div class="modal-top-buttons">
            <button id="save-all-user-locations">Guardar Cambios</button>
            <button id="close-saved-locations-modal">Cerrar</button>
        </div>
        <div id="saved-locations-list"> 
            <!-- Los slots de ubicación se insertarán aquí por JavaScript -->
            <div id="location-picker-map-container">
                <button id="picker-ok-map-button" title="Confirmar esta posición">OK</button>
                <button id="picker-locate-me-button" title="Ir a mi posición actual">Mi Ubic.</button>
            </div>
        </div>
    `;
  
    const parent = options.parentContainer || document.body;
    parent.appendChild(modal);
    
    const listElement = modal.querySelector('#saved-locations-list');
    const mapPickerContainer = modal.querySelector('#location-picker-map-container');
    const okMapBtn = modal.querySelector('#picker-ok-map-button');
    const locateMeMapBtn = modal.querySelector('#picker-locate-me-button');
    const saveAllButton = modal.querySelector('#save-all-user-locations');
    const closeButton = modal.querySelector('#close-saved-locations-modal');

    function loadAndDisplaySlots() {
        listElement.querySelectorAll('.location-slot').forEach(el => el.remove());
        
        for (let i = 0; i < MAX_SAVED_LOCATIONS; i++) {
            const location = tempSavedLocations[i];
            const slotDiv = document.createElement('div');
            slotDiv.className = 'location-slot';
            slotDiv.innerHTML = ` <span style="width: 25px; text-align: right; font-weight: bold;">${i + 1}.</span> <input type="text" placeholder="Nombre Ubicación" value="${location?.name || ''}" data-index="${i}"> <button class="map-button" data-index="${i}" title="Fijar en Mapa">📍 Mapa</button> <button class="select-location-button" data-index="${i}" title="Seleccionar esta ubicación para el recordatorio actual">Seleccionar</button> <span class="coords-display">${location?.lat && location?.lng ? `${parseFloat(location.lat).toFixed(4)}, ${parseFloat(location.lng).toFixed(4)}` : 'No fijada'}</span> `;
            
            listElement.insertBefore(slotDiv, mapPickerContainer);
            
            slotDiv.querySelector('input[type="text"]').addEventListener('input', (e) => {
                if (!tempSavedLocations[i]) tempSavedLocations[i] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
                tempSavedLocations[i].name = e.target.value;
            });
            
            slotDiv.querySelector('.map-button').addEventListener('click', () => {
                currentEditingLocationSlotIndex = i;
                mapPickerContainer.classList.add('expanded');
                initializeLocationPickerMap('location-picker-map-container', i); // Llama a la nueva función optimizada

                setTimeout(() => {
                    if (listElement) {
                        listElement.scrollTo({ top: listElement.scrollHeight, behavior: 'smooth' });
                    }
                }, 100);
            });
            
            const selectButton = slotDiv.querySelector('.select-location-button');
            selectButton.addEventListener('click', () => {
                const selectedIndex = parseInt(selectButton.dataset.index);
                const selectedLocData = tempSavedLocations[selectedIndex];
                if (selectedLocData && selectedLocData.lat && selectedLocData.lng) {
                    if (callbackOnSelectLocation && typeof callbackOnSelectLocation === 'function') {
                        callbackOnSelectLocation({ name: selectedLocData.name, lat: selectedLocData.lat, lng: selectedLocData.lng, radius: selectedLocData.radius || DEFAULT_LOCATION_RADIUS });
                    }
                    
                    // --- CORRECCIÓN: Al seleccionar, también devolvemos el mapa al garaje ---
                    if (locationPickerMap) {
                        const mapGarage = document.getElementById('map-garage');
                        const mapContainer = locationPickerMap.getContainer();
                        if (mapGarage && mapContainer) mapGarage.appendChild(mapContainer);
                        locationPickerMap.activeSlotIndex = null;
                    }

                    clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
                    modal.remove();
                } else { showToast("Ubicación no fijada. Fíjala en el mapa primero", "warning"); }
            });
        }
    }
    
    loadAndDisplaySlots();

    okMapBtn.addEventListener('click', () => {
        if (locationPickerMarker && currentEditingLocationSlotIndex !== -1) {
            const pos = locationPickerMarker.getLngLat();
            if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
            tempSavedLocations[currentEditingLocationSlotIndex].lat = pos.lat;
            tempSavedLocations[currentEditingLocationSlotIndex].lng = pos.lng;
            const slotInput = listElement.querySelector(`.location-slot input[data-index="${currentEditingLocationSlotIndex}"]`); 
            if (slotInput) {
                const coordsDisplay = slotInput.closest('.location-slot').querySelector('.coords-display');
                if (coordsDisplay) { coordsDisplay.textContent = `${pos.lat.toFixed(4)}, ${pos.lng.toFixed(4)}`; }
            }
        }
        mapPickerContainer.classList.remove('expanded');
        
        // --- CORRECCIÓN: No se destruye el mapa, solo se mueve al garaje ---
        if (locationPickerMap) {
            const mapGarage = document.getElementById('map-garage');
            const mapContainer = locationPickerMap.getContainer();
            if(mapGarage && mapContainer) mapGarage.appendChild(mapContainer);
            locationPickerMap.activeSlotIndex = null;
        }
        
        currentEditingLocationSlotIndex = -1;
    });

    locateMeMapBtn.addEventListener('click', () => {
        if (locationPickerMap) {
            locateMeMapBtn.disabled = true; locateMeMapBtn.textContent = 'Buscando...';
            getCurrentLocation(
                (coords) => {
                    locationPickerMap.flyTo({center: [coords.longitude, coords.latitude], zoom: 16});
                    if (locationPickerMarker) locationPickerMarker.setLngLat([coords.longitude, coords.latitude]);
                    if (currentEditingLocationSlotIndex !== -1) {
                        if (!tempSavedLocations[currentEditingLocationSlotIndex]) tempSavedLocations[currentEditingLocationSlotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
                        tempSavedLocations[currentEditingLocationSlotIndex].lat = coords.latitude;
                        tempSavedLocations[currentEditingLocationSlotIndex].lng = coords.longitude;
                    }
                    locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.';
                },
                (errorMsg) => { showToast(`Error localización: ${errorMsg}`, 'error'); locateMeMapBtn.disabled = false; locateMeMapBtn.textContent = 'Mi Ubic.'; }
            );
        }
    });

    saveAllButton.addEventListener('click', () => {
        const locationsToSave = tempSavedLocations.map(loc => {
            if (loc && (!loc.name || loc.name.trim() === '') && (loc.lat === null || loc.lng === null)) { return null; }
            if (loc && (loc.lat !== null && loc.lng !== null) && typeof loc.radius !== 'number') { loc.radius = DEFAULT_LOCATION_RADIUS; }
            return loc;
        }).filter(Boolean); 

        saveLocationsToCache(locationsToSave);
        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        savedRoutes = savedRoutes.filter(r => !r.name.startsWith("UBICACIÓN: "));

        locationsToSave.forEach(loc => {
            if (loc && loc.name && loc.lat && loc.lng) {
                const routeName = `UBICACIÓN: ${loc.name.toUpperCase()}`;
                const routeWaypoint = { id: Date.now() + Math.random(), lat: loc.lat, lng: loc.lng, type: 'F', label: 'F', address: loc.name, visited: false, isCriticalForRecalc: true };
                const existingRouteIndex = savedRoutes.findIndex(r => r.name === routeName);
                const routeToSave = { name: routeName, waypoints: [routeWaypoint], createdAt: new Date().toISOString() };
                if (existingRouteIndex !== -1) { savedRoutes[existingRouteIndex] = routeToSave; } else { savedRoutes.push(routeToSave); }
            }
        });
        if (savedRoutes.length > MAX_SAVED_ROUTES) {
             savedRoutes.sort((a,b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
             savedRoutes = savedRoutes.slice(0, MAX_SAVED_ROUTES);
        }
        localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes)); 
        showToast("Ubicaciones guardadas y sincronizadas.", "success"); 
        if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose();
        
        if (locationPickerMap) {
            const mapGarage = document.getElementById('map-garage');
            const mapContainer = locationPickerMap.getContainer();
            if (mapGarage && mapContainer) mapGarage.appendChild(mapContainer);
            locationPickerMap.activeSlotIndex = null;
        }

        clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
        modal.remove();
    });

    const closeHandler = () => {
        clearModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
        
        if (locationPickerMap) {
            const mapGarage = document.getElementById('map-garage');
            const mapContainer = locationPickerMap.getContainer();
            if (mapGarage && mapContainer) mapGarage.appendChild(mapContainer);
            locationPickerMap.activeSlotIndex = null;
        }

        if (callbackOnClose && typeof callbackOnClose === 'function') callbackOnClose();
        modal.remove();
    };

    closeButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(modal, closeButton, 'saved-locations-modal');
}    
// ===================================================================
// NOMBRE: showRadarSpeedModal
// RESUMEN: Muestra un modal para seleccionar la velocidad de un radar a añadir.
function showRadarSpeedModal(callbackOnSelect) {
    closeOtherModals('radar-speed-selection-modal');
    
    const modal = document.createElement('div');
    modal.id = 'radar-speed-selection-modal';
    modal.className = 'reminder-modal';
    
    const speeds = [30, 50, 60, 70, 80, 90, 100, 120, 'TRAMO'];
    
    let buttonsHtml = '';
    speeds.forEach(speed => {
        const isDefault = speed === 50;
        buttonsHtml += `<button class="action-button secondary speed-option ${isDefault ? 'default-selection' : ''}" data-speed="${speed}">${speed}</button>`;
    });

    modal.innerHTML = `
        <style>
            #radar-speed-selection-modal .reminder-modal-body {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                gap: 1.5rem;
            }
            #radar-speed-selection-modal .speed-options-grid {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 1rem;
                width: 100%;
                max-width: 400px;
            }
            #radar-speed-selection-modal .speed-option.selected {
                background-color: #007aff;
                border: 2px solid white;
                transform: scale(1.05);
            }
            #radar-speed-selection-modal .speed-option.default-selection {
                background-color: #F59E0B;
            }
        </style>
        <div class="reminder-modal-header">
            <h2 class="reminder-modal-title">Velocidad del Radar</h2>
        </div>
        <div class="reminder-modal-body">
            <p style="font-size: 1.1rem; text-align: center;">Selecciona la velocidad o se guardará la opción por defecto en <span id="radar-modal-countdown">4</span>s.</p>
            <div class="speed-options-grid">
                ${buttonsHtml}
            </div>
        </div>
        <div class="reminder-modal-footer" style="justify-content: center;">
             <button id="cancel-radar-add" class="action-button danger">Cancelar</button>
        </div>
    `;

    document.body.appendChild(modal);

    let countdown = 4;
    const countdownElement = modal.querySelector('#radar-modal-countdown');
    
    const closeHandler = () => {
        if (countdownInterval) clearInterval(countdownInterval);
        if (modal.parentNode) modal.remove();
    };

    let countdownInterval = setInterval(() => {
        countdown--;
        if (countdownElement) countdownElement.textContent = countdown;
        if (countdown <= 0) {
            clearInterval(countdownInterval);
            const defaultSpeed = modal.querySelector('.speed-option.default-selection')?.dataset.speed || '50';
            callbackOnSelect(defaultSpeed);
            closeHandler();
        }
    }, 1000);

    modal.querySelectorAll('.speed-option').forEach(button => {
        button.addEventListener('click', () => {
            const selectedSpeed = button.dataset.speed;
            callbackOnSelect(selectedSpeed);
            closeHandler();
        });
    });

    modal.querySelector('#cancel-radar-add').addEventListener('click', () => {
        showToast("Creación de radar cancelada.", "info");
        callbackOnSelect(null);
        closeHandler();
    });
}

    
// ===================================================================
// NOMBRE: checkForExcessiveRadars
// RESUMEN: Comprueba si el usuario tiene demasiados radares importados y ofrece limpiarlos y hacer backup.
function checkForExcessiveRadars() {
    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    const manualRadarReminders = reminders.filter(r => r && (r.text.toUpperCase().includes('RADAR') || r.excludeFromList === true) && !r.isDynamicRadar);

    if (manualRadarReminders.length > 200) {
        const modalId = 'excessive-radars-modal';
        const existingModal = document.getElementById(modalId);
        if (existingModal) return;

        const modal = document.createElement('div');
        modal.id = modalId;
        modal.className = 'choice-modal';
        modal.innerHTML = `
            <h2>Optimización de Radares</h2>
            <p style="margin-bottom: 1rem;">Hemos detectado que tienes <strong>${manualRadarReminders.length} radares</strong> importados manualmente. Un nuevo sistema carga automáticamente los radares cercanos (80 km) para mejorar el rendimiento.</p>
            <p style="margin-bottom: 1.5rem; font-weight: bold;">¿Deseas eliminar los radares importados y activar el nuevo sistema dinámico?</p>
            <div class="modal-top-buttons">
                <button id="confirm-radar-cleanup" class="choice-edit" style="background-color: #28a745; color: white;">Sí, limpiar y optimizar</button>
                <button id="cancel-radar-cleanup" class="choice-cancel">No, mantener mis radares</button>
            </div>
        `;
        document.body.appendChild(modal);

        const confirmBtn = document.getElementById('confirm-radar-cleanup');
        const cancelBtn = document.getElementById('cancel-radar-cleanup');
        
        const closeHandler = () => {
            clearModalAutoCloseTimer(modal, confirmBtn, modalId);
            if (modal.parentNode) modal.remove();
        };
        
        confirmBtn.addEventListener('click', async () => {
            showToast("Limpiando radares manuales antiguos...", "info", 0, false, "radar-cleanup-toast");
            const remindersToKeep = reminders.filter(r => !((r.text.toUpperCase().includes('RADAR') || r.excludeFromList === true) && !r.isDynamicRadar));
            localStorage.setItem('reminders', JSON.stringify(remindersToKeep));
            
            showToast("Guardando copia de seguridad en la nube...", "info", 0, false, "radar-cleanup-toast");
            await validateAndSaveUserToFirebase(); 
            
            const existingToast = document.getElementById("radar-cleanup-toast");
            if (existingToast) existingToast.remove();
            
            closeHandler();
            updateReminderCount();
            updateButtonStyles();
        });

        cancelBtn.addEventListener('click', () => {
             showToast("Optimización cancelada. Puedes limpiar los radares manualmente desde Configuración > Radares > Borrar.", "info", 8000);
             closeHandler();
        });
        
        addModalAutoCloseTimer(modal, confirmBtn, modalId, 60000);
    }
}    
    
// ===================================================================
// NOMBRE: toggleMapControls
// RESUMEN: Activa o desactiva los controles de planificación de ruta en el mapa (botones, buscador) y actualiza el estado de geolocalización.
function toggleMapControls(enabled) {
    isGeolocated = enabled;
    
    const controls = [
        document.getElementById('map-location-search-input'),
        document.getElementById('map-location-search-button'),
        document.getElementById('clear-map-search-input-button'),
        document.getElementById('load-saved-route-button'),
        document.getElementById('reorder-route-stages-button'),
        document.getElementById('pdrs-ruta-button'),
        document.getElementById('add-reminder-at-location-button')
    ];

    controls.forEach(control => {
        if (control) {
            control.disabled = !enabled;
            control.style.opacity = enabled ? '1' : '0.5';
            control.style.cursor = enabled ? 'pointer' : 'not-allowed';
        }
    });
    
    setNavigationMapClickHandler();
}
    
// ===================================================================
// NOMBRE: getGridCellId
// RESUMEN: Calcula el ID de una celda de la cuadrícula espacial para un punto geográfico.
function getGridCellId(lat, lon) {
    const GRID_SIZE = 0.1;
    const latIndex = Math.floor(lat / GRID_SIZE);
    const lonIndex = Math.floor(lon / GRID_SIZE);
    return `cell_${latIndex}_${lonIndex}`;
}

// ===================================================================
// NOMBRE: initializeRadarCache (VERSIÓN CON CACHÉ PERSISTENTE Y CARGA ESTÁNDAR)
// RESUMEN: Carga solo los radares de KLMFILES.TXT desde localStorage o los reconstruye si es necesario.
async function initializeRadarCache() {
    if (window.radarsCache) return; 
    if (isRadarCacheInitializing) {
        return new Promise(resolve => {
            const interval = setInterval(() => {
                if (!isRadarCacheInitializing) {
                    clearInterval(interval);
                    resolve();
                }
            }, 100);
        });
    }

    isRadarCacheInitializing = true;
    
    try {
        let remoteManifestDate = null;
        try {
            const response = await fetch(KML_FILES_LIST_STANDARD, { method: 'HEAD', cache: 'no-cache' });
            if (response.ok) {
                remoteManifestDate = response.headers.get('Last-Modified');
            }
        } catch (e) {
            console.warn("No se pudo obtener la fecha del manifiesto de radares, se forzará la recarga si no hay caché.");
        }

        const localCacheDate = localStorage.getItem('radarsCacheVersion');
        const cachedRadarsJSON = localStorage.getItem('radarsCacheData');
        const cachedIndexJSON = localStorage.getItem('radarsCacheIndex');

        if (remoteManifestDate && localCacheDate === remoteManifestDate && cachedRadarsJSON && cachedIndexJSON) {
            try {
                window.radarsCache = JSON.parse(cachedRadarsJSON);
                window.radarsSpatialIndex = JSON.parse(cachedIndexJSON);
                return; 
            } catch (e) {
                console.error("Error al parsear la caché de radares local. Se reconstruirá.", e);
            }
        }

    
        let filesToProcess = await fetchKMLFilesList(KML_FILES_LIST_STANDARD);

        const processingPromises = filesToProcess.map(kmlFileName => 
            fetchAndParseKML(KML_BASE_PATH + kmlFileName)
                .catch(error => {
                    console.warn(`No se pudo procesar el archivo ${kmlFileName}:`, error);
                    return [];
                })
        );
        
        const results = await Promise.all(processingPromises);
        
        const allRadars = [];
        const spatialIndex = {};

        results.flat().forEach(placemark => {
            const coords = placemark.coordinates;
            if (coords) {
                const [lonStr, latStr] = coords.split(',');
                const lon = parseFloat(lonStr);
                const lat = parseFloat(latStr);
                if (!isNaN(lat) && !isNaN(lon)) {
                    const radarData = { name: placemark.name, lat: lat, lon: lon };
                    allRadars.push(radarData);
                    
                    const cellId = getGridCellId(lat, lon);
                    if (!spatialIndex[cellId]) spatialIndex[cellId] = [];
                    spatialIndex[cellId].push(radarData);
                }
            }
        });
        
        window.radarsCache = allRadars;
        window.radarsSpatialIndex = spatialIndex;

        try {
            localStorage.setItem('radarsCacheData', JSON.stringify(allRadars));
            localStorage.setItem('radarsCacheIndex', JSON.stringify(spatialIndex));
            if (remoteManifestDate) {
                localStorage.setItem('radarsCacheVersion', remoteManifestDate);
            }
        } catch (e) {
            console.error("No se pudo guardar la caché de radares en localStorage:", e);
            showToast("No se pudo guardar la caché de radares. Puede que la optimización se repita.", "warning");
        }
        
        const existingToast = document.getElementById("radar-cache-init");
        if (existingToast) existingToast.remove();
       
    } catch (error) {
        showToast("Error crítico al inicializar la caché de radares.", "error");
        window.radarsCache = [];
        window.radarsSpatialIndex = {};
    } finally {
        isRadarCacheInitializing = false;
    }
}

    
// ===================================================================
// NOMBRE: deletePollMessage (NUEVA FUNCIÓN)
// RESUMEN: Permite al administrador borrar una encuesta permanentemente.
async function deletePollMessage(pollId) {
    if (!pollId) return;

    if (confirm('¿Estás seguro de que deseas eliminar esta encuesta/votación permanentemente?')) {
        try {
            const pollRef = window.doc(window.db, 'chatPolls', pollId);
            await window.deleteDoc(pollRef);
            showToast("Encuesta eliminada.", "success");
        } catch (error) {
            showToast("Error al eliminar la encuesta.", "error");
        }
    }
}

// ===================================================================
// NOMBRE: handlePollVote (MODIFICADA V2)
// RESUMEN: Gestiona el voto, actualiza la UI y actualiza el timestamp de la encuesta.
async function handlePollVote(pollId, optionIndex) {
    const currentUserId = localStorage.getItem('userData_userId');
    if (!currentUserId) {
        showToast("Debes configurar un ID de usuario para poder votar.", "warning");
        return;
    }

    const pollRef = window.doc(window.db, 'chatPolls', pollId);

    try {
        const pollSnap = await window.getDoc(pollRef);
        if (!pollSnap.exists()) {
            showToast("Error: La encuesta ya no existe.", "error");
            return;
        }

        const pollData = pollSnap.data();
        const updatedVotes = pollData.votes || {};

        if (updatedVotes[currentUserId] === optionIndex) {
            delete updatedVotes[currentUserId];
        } else {
            updatedVotes[currentUserId] = optionIndex;
        }

        await window.setDoc(pollRef, { 
            votes: updatedVotes,
            timestamp: window.serverTimestamp() 
        }, { merge: true });
        
        const pollElement = document.getElementById(`poll-${pollId}`);
        if (!pollElement) return;

        const totalVotes = Object.keys(updatedVotes).length;

        pollData.options.forEach((option, index) => {
            const optionElement = pollElement.querySelector(`[data-option-index="${index}"]`);
            if (!optionElement) return;

            const voteCount = Object.values(updatedVotes).filter(v => v === index).length;
            const percentage = totalVotes > 0 ? (voteCount / totalVotes) * 100 : 0;
            
            optionElement.querySelector('.poll-vote-count').textContent = voteCount;
            optionElement.querySelector('.poll-progress-fill').style.width = `${percentage}%`;
            
            const button = optionElement.querySelector('.poll-option-button');
            if (updatedVotes[currentUserId] === index) {
                button.classList.add('voted');
            } else {
                button.classList.remove('voted');
            }
            
            const voters = Object.entries(updatedVotes)
                .filter(([_, voteIndex]) => voteIndex === index)
                .map(([userId, _]) => userId);

            const votersList = optionElement.querySelector('.poll-voter-list');
            if (votersList) {
                if (voters.length > 0) {
                    votersList.innerHTML = voters.map(user => `<li class="poll-voter-name">${user}</li>`).join('');
                } else {
                    votersList.innerHTML = '';
                }
            }
        });

    } catch (error) {
        showToast("Error al registrar el voto.", "error");
    }
}

    
// ===================================================================
// NOMBRE: startEditPollQuestion (MODIFICADA)
// RESUMEN: Permite al admin editar la pregunta y actualiza el timestamp de la encuesta.
async function startEditPollQuestion(pollId, currentQuestion) {
    const newQuestion = prompt("Edita la pregunta de la encuesta:", currentQuestion);

    if (newQuestion && newQuestion.trim() !== '' && newQuestion !== currentQuestion) {
        try {
            const pollRef = window.doc(window.db, 'chatPolls', pollId);
            await window.setDoc(pollRef, { 
                question: newQuestion.trim(),
                timestamp: window.serverTimestamp() 
            }, { merge: true });
            showToast("Pregunta de la encuesta actualizada.", "success");
        } catch (error) {
            showToast("Error al actualizar la pregunta.", "error");
        }
    }
}


// ===================================================================
// NOMBRE: incrementMapSessionCount (NUEVA FUNCIÓN)
// RESUMEN: Incrementa el contador de sesiones de mapa del usuario en Firebase.
async function incrementMapSessionCount() {
    const { primaryId: userId } = parseUserId(localStorage.getItem('userData_userId'));
    if (!userId || !window.db) {
        return;
    }

    try {
        const userDocRef = window.doc(window.db, "user_data", userId);
        const docSnap = await window.getDoc(userDocRef);
        
        const now = new Date();
        const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        let newTotal = 1;
        let newMonthCount = 1;
        
        if (docSnap.exists()) {
            const data = docSnap.data();
            newTotal = (data.map_sessions_total || 0) + 1;
            
            if (data.map_sessions_last_month === currentMonthStr) {
                newMonthCount = (data.map_sessions_month || 0) + 1;
            } else {
                newMonthCount = 1;
            }
        }
        
        const dataToUpdate = {
            map_sessions_total: newTotal,
            map_sessions_month: newMonthCount,
            map_sessions_last_month: currentMonthStr
        };

        await window.setDoc(userDocRef, dataToUpdate, { merge: true });

    } catch (error) {
        console.error("Error al incrementar el contador de sesiones de mapa:", error);
    }
}

// ===================================================================
// NOMBRE: getGlobalMapSessionStats (NUEVA FUNCIÓN)
// RESUMEN: Calcula las estadísticas globales de sesiones de mapa de todos los usuarios.
async function getGlobalMapSessionStats() {
    if (!window.db) return { totalMonth: 0, totalHistoric: 0 };
    
    let totalMonth = 0;
    let totalHistoric = 0;
    
    try {
        const usersCollectionRef = window.collection(window.db, "user_data");
        const querySnapshot = await window.getDocs(usersCollectionRef);
        
        const now = new Date();
        const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        querySnapshot.forEach(doc => {
            const data = doc.data();
            totalHistoric += (data.map_sessions_total || 0);
            
            if (data.map_sessions_last_month === currentMonthStr) {
                totalMonth += (data.map_sessions_month || 0);
            }
        });

    } catch (error) {
        console.error("Error al obtener estadísticas globales de sesiones de mapa:", error);
    }
    
    return { totalMonth, totalHistoric };
}

// ===================================================================
// NOMBRE: updateTrafficAlertIconSizes (NUEVA FUNCIÓN)
// RESUMEN: Redimensiona todos los iconos de alerta de tráfico en el mapa según el nivel de zoom actual.
function updateTrafficAlertIconSizes() {
    if (!navigationMapInstance || !trafficAlertsMarkers || trafficAlertsMarkers.length === 0) {
        return;
    }

    const currentZoom = navigationMapInstance.getZoom();
    const ZOOM_THRESHOLD = 14.5;
    const isSmall = currentZoom < ZOOM_THRESHOLD;
    const finalSize = isSmall ? '25px' : '60px';

    trafficAlertsMarkers.forEach(marker => {
        const markerElement = marker.getElement();
        if (markerElement) {
            markerElement.style.width = finalSize;
            markerElement.style.height = finalSize;
        }
    });
}

// ===================================================================
// NOMBRE: displayAlertsOnMap (MODIFICADA - AÑADE LISTENER DE CLIC)
// RESUMEN: Dibuja las alertas y añade un listener de clic a cada marcador para que sean interactivos.
function displayAlertsOnMap() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) {
        return;
    }
    
    if (trafficAlertsMarkers && trafficAlertsMarkers.length > 0) {
        trafficAlertsMarkers.forEach(marker => marker.remove());
    }
    trafficAlertsMarkers = [];

    const currentZoom = navigationMapInstance.getZoom();
    const ZOOM_THRESHOLD = 14.5;
    const isSmall = currentZoom < ZOOM_THRESHOLD;
    const finalSize = isSmall ? '25px' : '60px';

    const alertIconsMap = {
        1: 'AACCIDENTE.png', 2: 'AAVERIADO.png', 3: 'AGUARDIA.png',
        4: 'AATASCO.png', 5: 'APELIGRO.png', 6: 'ARESVALAR.png',
        7: 'AOBRAS.png', 8: 'ACERRADA.png'
    };
    
    const alertDetailsMap = {
        1: 'Accidente de tráfico', 2: 'Coche averiado', 3: 'Control de tráfico / Radar',
        4: 'Atasco', 5: 'Peligro indeterminado', 6: 'Carretera en mal estado',
        7: 'Obras', 8: 'Vía / Carretera cerrada'
    };

    trafficAlertsCache.forEach(alert => {
        if (alert.code === 9) return;

        const iconFilename = alertIconsMap[alert.code];
        if (!iconFilename) return;

        const markerElement = document.createElement('div');
        markerElement.className = 'traffic-alert-marker';
        markerElement.style.width = finalSize;
        markerElement.style.height = finalSize;

        const iconImage = document.createElement('img');
        iconImage.src = `PNG/${iconFilename}`;
        iconImage.alt = `Alerta ${alert.code}`;
        markerElement.appendChild(iconImage);

        markerElement.addEventListener('click', (e) => {
            e.stopPropagation();
            const alertText = alertDetailsMap[alert.code] || 'Alerta de tráfico';
            showToast(alertText, 'warning', 4000);
        });
        
        const newMarker = new mapboxgl.Marker({
            element: markerElement,
            anchor: 'center'
        })
        .setLngLat([alert.coordinates.lon, alert.coordinates.lat])
        .addTo(navigationMapInstance);

        trafficAlertsMarkers.push(newMarker);
    });
}

// ===================================================================
// NOMBRE: reAddCustomMapLayersAndSources (VERSIÓN CORREGIDA SIN CAPA DE ALERTAS)
// RESUMEN: Ya no crea la fuente ni la capa para 'traffic-alerts-source', ya que se gestionan como marcadores HTML.
// ===================================================================
async function reAddCustomMapLayersAndSources(mapInstance) {
    if (!mapInstance) return;

    await loadAndAddMapImages(mapInstance);

    const routeGeojsonData = (navigationCurrentRouteData?.routes?.[0]?.geometry)
        ? { type: 'Feature', properties: {}, geometry: navigationCurrentRouteData.routes[0].geometry }
        : { type: 'FeatureCollection', features: [] };


    const pdrFeatures = lastPdrSearchResults.map((point, index) => ({
        type: 'Feature',
        geometry: {
            type: 'Point',
            coordinates: [point.lon, point.lat]
        },
        properties: {
            ocmId: point.ocmId,
            index: index,
            bgColor: getChargingPointColorByPower(parseFloat(point.power)),
            isCheapest: point.isCheapest || false,
            power: point.power,
            operator: point.operator.substring(0, 14),
            price: point.price,
            availability: point.availabilityText
        }
    }));
    const pdrsGeojsonData = {
        type: 'FeatureCollection',
        features: pdrFeatures
    };
    
    // --- CORRECCIÓN: Eliminadas las referencias a la capa de alertas de tráfico ---
    const sourcesAndLayersToRemove = [
        'speed-markers-text', 'speed-markers-circle-bg',
        'pdr-cards-layer-availability', 'pdr-cards-layer-price', 'pdr-cards-layer-operator', 'pdr-cards-layer-power', 'pdr-cards-layer-bg-halo', 'pdr-cards-layer-bg',
        'pdr-simple-text-layer', 'pdr-simple-circle-layer', 'completed-segments-layer', 'route',
        'speed-markers-source', 'pdrs-geojson-source', 'completed-segments', 'route'
    ];
    sourcesAndLayersToRemove.forEach(id => {
        try { if (mapInstance.getLayer(id)) mapInstance.removeLayer(id); if (mapInstance.getSource(id)) mapInstance.removeSource(id); } catch (e) {}
    });

    mapInstance.addSource('route', { type: 'geojson', data: routeGeojsonData });
    mapInstance.addSource('completed-segments', { type: 'geojson', data: completedSegmentsGeoJSON }); mapInstance.addSource('speed-markers-source', { type: 'geojson', data: { type: 'FeatureCollection', features: speedMarkerFeatures } });
    mapInstance.addSource('pdrs-geojson-source', { type: 'geojson', data: pdrsGeojsonData });
    // Ya no se añade la fuente 'traffic-alerts-source'

    mapInstance.addLayer({ id: 'route', type: 'line', source: 'route', layout: { 'line-join': 'round', 'line-cap': 'round' }, paint: getRouteStyleProperties() });
    mapInstance.addLayer({ id: 'completed-segments-layer', type: 'line', source: 'completed-segments', layout: { 'line-join': 'round', 'line-cap': 'round' }, paint: { 'line-color': 'green', 'line-width': (navigationMapInstance && navigationMapInstance.getPitch() > 20) ? 10 : 6, 'line-opacity': 0.8 } });
    
    mapInstance.addLayer({ id: 'speed-markers-circle-bg', type: 'circle', source: 'speed-markers-source', paint: { 'circle-radius': 15, 'circle-color': ['case', ['==', ['get', 'type'], 'maxSpeed'], '#4B0082', '#36454F'], 'circle-stroke-width': 2, 'circle-stroke-color': 'white' } });
    mapInstance.addLayer({ id: 'speed-markers-text', type: 'symbol', source: 'speed-markers-source', layout: { 'text-field': ['get', 'speedText'], 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 11, 'text-allow-overlap': true }, paint: { 'text-color': 'white' } });

    mapInstance.addLayer({ id: 'pdr-simple-circle-layer', type: 'circle', source: 'pdrs-geojson-source', filter: ['<=', ['zoom'], 14], paint: { 'circle-radius': 18, 'circle-color': ['get', 'bgColor'], 'circle-opacity': 1, 'circle-stroke-width': ['case', ['==', ['get', 'isCheapest'], true], 3.5, 2], 'circle-stroke-color': ['case', ['==', ['get', 'isCheapest'], true], '#FFD700', 'white'] } });
    mapInstance.addLayer({ id: 'pdr-simple-text-layer', type: 'symbol', source: 'pdrs-geojson-source', filter: ['<=', ['zoom'], 14], layout: { 'text-field': ['concat', ['get', 'power'], 'kW'], 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 9, 'text-allow-overlap': true }, paint: { 'text-color': 'white', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
    mapInstance.addLayer({ id: 'pdr-cards-layer-bg-halo', type: 'circle', source: 'pdrs-geojson-source', filter: ['all', ['>', ['zoom'], 14], ['==', ['get', 'isCheapest'], true]], paint: { 'circle-radius': 48, 'circle-color': '#FFD700', 'circle-opacity': 0.8, 'circle-blur': 1 } });
    mapInstance.addLayer({ id: 'pdr-cards-layer-bg', type: 'circle', source: 'pdrs-geojson-source', filter: ['>', ['zoom'], 14], paint: { 'circle-radius': 45, 'circle-color': ['get', 'bgColor'], 'circle-opacity': 1, 'circle-stroke-width': 3, 'circle-stroke-color': 'white' } });
    mapInstance.addLayer({ id: 'pdr-cards-layer-power', type: 'symbol', source: 'pdrs-geojson-source', filter: ['>', ['zoom'], 14], layout: { 'text-field': ['concat', ['get', 'power'], ' kW'], 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 14, 'text-offset': [0, -1.5], 'text-allow-overlap': true }, paint: { 'text-color': '#ffd700', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
    mapInstance.addLayer({ id: 'pdr-cards-layer-operator', type: 'symbol', source: 'pdrs-geojson-source', filter: ['>', ['zoom'], 14], layout: { 'text-field': ['get', 'operator'], 'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'], 'text-size': 11, 'text-offset': [0, -0.3], 'text-allow-overlap': true, 'text-max-width': 10 }, paint: { 'text-color': 'white', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
    mapInstance.addLayer({ id: 'pdr-cards-layer-price', type: 'symbol', source: 'pdrs-geojson-source', filter: ['>', ['zoom'], 14], layout: { 'text-field': ['get', 'price'], 'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'], 'text-size': 13, 'text-offset': [0, 1.0], 'text-allow-overlap': true }, paint: { 'text-color': '#90ee90', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
    mapInstance.addLayer({ id: 'pdr-cards-layer-availability', type: 'symbol', source: 'pdrs-geojson-source', filter: ['>', ['zoom'], 14], layout: { 'text-field': ['get', 'availability'], 'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'], 'text-size': 10, 'text-offset': [0, 2.8], 'text-allow-overlap': true }, paint: { 'text-color': '#e0e0e0', 'text-opacity': 1, 'text-halo-color': '#000', 'text-halo-width': 1 } });
  
}

// ===================================================================
// NOMBRE: updateLineWidthsOnPitchChange (NUEVA FUNCIÓN SIMPLE)
// RESUMEN: Ajusta el grosor de las líneas de ruta según la inclinación.
function updateLineWidthsOnPitchChange() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) return;

    const isPitched = navigationMapInstance.getPitch() > 20;
    const mainWidth = isPitched ? 16 : 12;
    const altWidth = isPitched ? 12 : 8;
    const completedWidth = isPitched ? 10 : 6;

    try {
        if (navigationMapInstance.getLayer('route')) {
            navigationMapInstance.setPaintProperty('route', 'line-width', mainWidth);
        }
        if (navigationMapInstance.getLayer('completed-segments-layer')) {
            navigationMapInstance.setPaintProperty('completed-segments-layer', 'line-width', completedWidth);
        }
        alternativeRouteLayers.forEach(alt => {
            if (navigationMapInstance.getLayer(alt.layerId)) {
                navigationMapInstance.setPaintProperty(alt.layerId, 'line-width', altWidth);
            }
        });
    } catch (e) { /* Ignorar errores si la capa no existe */ }
}
                                                                                                                                                                                                                                                                                                     
// ===================================================================
// NOMBRE: openChatModal (MODIFICADA)
// RESUMEN: Abre el modal del chat y lo convierte en una función asíncrona.
async function openChatModal() {
    const modalOverlay = document.getElementById('chat-modal-overlay');
    if (!modalOverlay) return;
    
    document.body.classList.add('chat-open');
    modalOverlay.classList.remove('hidden');

    const sendButton = document.getElementById('chat-send-button');
    const messageInput = document.getElementById('chat-message-input');
    const charCounter = document.getElementById('chat-char-counter');
    const permissionWarning = document.getElementById('chat-permission-warning');
    const messagesContainer = document.getElementById('chat-messages-container');
    
    const originalPlaceholder = "Escribe un mensaje... (antecede @usuario para mensaje privado, o pulsa en el lateral. Para referirse simplemente nómbralo). Vida de los mensajes 96 horas. En el coche usa los comandos de voz. Elon cree en la humanidad, the White Monkey y yo también, ser educad@s.";
    const pollPlaceholder = "Para encuestas/votaciones, usa el formato: #COMUNIDAD#Pregunta#Opción1 $ Opción2...#";
    messageInput.placeholder = `${originalPlaceholder} ${pollPlaceholder}`;

    const currentUserId = localStorage.getItem('userData_userId');
    const currentUserDmsAllowed = JSON.parse(localStorage.getItem('userData_allowDMs') || 'false');
    
    if (currentUserId === 'BoardingGate' && !sessionStorage.getItem('chatCleanupSessionDone')) {
        sessionStorage.setItem('chatCleanupSessionDone', 'true');
        showToast("Hola Admin. Realizando limpieza de mensajes antiguos...", "info");
        cleanUpOldChatMessages();
    }

    if (!currentUserId) {
        permissionWarning.textContent = "Debes configurar un ID de Usuario para poder chatear.";
        permissionWarning.classList.remove('hidden');
        sendButton.disabled = true;
        messageInput.disabled = true;
    } else if (!currentUserDmsAllowed) {
        permissionWarning.innerHTML = `Si quiere recibir mensajes o poder enviar mensajes tanto públicos como dirigidos a un usuario concreto debe activar en <strong>Configuración > Usuario > Permitir MDs (vía admin)</strong>`;
        permissionWarning.classList.remove('hidden');
        sendButton.disabled = true;
        messageInput.disabled = true;
    } else {
        permissionWarning.classList.add('hidden');
        sendButton.disabled = false;
        messageInput.disabled = false;
    }
    
    charCounter.textContent = messageInput.maxLength;
    
    if (!messageInput.listenerAdded) {
        messageInput.addEventListener('input', () => {
            const remaining = messageInput.maxLength - messageInput.value.length;
            charCounter.textContent = remaining;
        });
        messageInput.listenerAdded = true;
    }

    const newExitButton = document.getElementById('chat-exit-button').cloneNode(true);
    document.getElementById('chat-exit-button').parentNode.replaceChild(newExitButton, document.getElementById('chat-exit-button'));
    newExitButton.addEventListener('click', closeChatModal);

    const newSendButton = sendButton.cloneNode(true);
    sendButton.parentNode.replaceChild(newSendButton, sendButton);
    newSendButton.addEventListener('click', sendMessage);

    if (!messagesContainer.listenerAdded) {
        messagesContainer.addEventListener('click', (event) => {
            const target = event.target.closest('[data-action]');
            if (!target) return;

            event.stopPropagation();
            const action = target.dataset.action;
            const id = target.dataset.id;
            
            switch (action) {
                case 'vote-poll':
                    const optionIndex = parseInt(target.dataset.optionIndex, 10);
                    handlePollVote(id, optionIndex);
                    break;
                case 'edit-message':
                    const content = target.dataset.content;
                    startEditMessage(id, content);
                    break;
                case 'delete-message':
                    deleteChatMessage(id);
                    break;
                case 'edit-poll':
                    const question = target.dataset.question;
                    startEditPollQuestion(id, question);
                    break;
                case 'delete-poll':
                    deletePollMessage(id);
                    break;
            }
        });
        messagesContainer.listenerAdded = true;
    }

    await fetchAndRenderChatUsers();
    fetchAndRenderChatMessages();
    updateTotalMessageCount();

    if (chatUpdateInterval) clearInterval(chatUpdateInterval);
    chatUpdateInterval = setInterval(() => {
        if (!modalOverlay.classList.contains('hidden')) {
            updateTotalMessageCount();
        }
    }, 15000);
}
    
// ===================================================================
// NOMBRE: fetchAndRenderChatMessages (CORREGIDA V5 - ROBUSTA CON DOM)
// RESUMEN: Construye los elementos del chat de forma segura con el DOM API.
async function fetchAndRenderChatMessages() {
    const messagesContainer = document.getElementById('chat-messages-container');
    if (!messagesContainer || !window.db) return;

    const currentUserId = (localStorage.getItem('userData_userId') || '').trim();
    if (!currentUserId) {
        messagesContainer.innerHTML = '<p class="chat-system-message">Configura tu ID de usuario para ver el chat.</p>';
        return;
    }
    
    const currentUserIdLower = currentUserId.toLowerCase();

    try {
        const oneHundredTwentyHoursAgo = new Date(Date.now() - 120 * 60 * 60 * 1000);
        const messagesQuery = window.query(window.collection(window.db, 'chatMessages'), window.where('timestamp', '>', oneHundredTwentyHoursAgo), window.orderBy('timestamp', 'desc'));
        const pollsQuery = window.query(window.collection(window.db, 'chatPolls'), window.orderBy('timestamp', 'desc'));
        
        const [messagesSnapshot, pollsSnapshot] = await Promise.all([
            window.getDocs(messagesQuery),
            window.getDocs(pollsQuery)
        ]);

        let combinedItems = [];
        messagesSnapshot.forEach(doc => combinedItems.push({ id: doc.id, ...doc.data(), isPoll: false }));
        pollsSnapshot.forEach(doc => combinedItems.push({ id: doc.id, ...doc.data(), isPoll: true }));

        combinedItems.sort((a, b) => (b.timestamp?.toMillis() || 0) - (a.timestamp?.toMillis() || 0));

        messagesContainer.innerHTML = '';
        
        if (combinedItems.length === 0) {
            messagesContainer.innerHTML = '<p class="chat-system-message">No hay mensajes recientes. ¡Sé el primero en escribir!</p>';
            return;
        }

        combinedItems.forEach(item => {
            if (item.isPoll) {
                messagesContainer.appendChild(renderPollBubble(item, currentUserId));
            } else {
                const isPublic = item.recipientId.toLowerCase() === 'public';
                const isForMe = item.recipientId.toLowerCase() === currentUserIdLower;
                const iSentIt = item.senderId.toLowerCase() === currentUserIdLower;

                if (isPublic || isForMe || iSentIt) {
                    const bubble = document.createElement('div');
                    bubble.className = 'chat-message-bubble';
                    
                    let bubbleClass = '';
                    if (iSentIt && isPublic) { bubble.style.backgroundColor = '#DF6565'; bubbleClass = 'public-msg'; }
                    else if (isForMe && !iSentIt) { bubbleClass = 'private-msg'; }
                    else if (isPublic) { bubbleClass = 'public-msg'; }
                    else if (iSentIt && !isPublic) { bubbleClass = 'private-msg-sent'; }
                    bubble.classList.add(iSentIt ? 'sent' : 'received', bubbleClass);

                    const senderSpan = document.createElement('span');
                    senderSpan.className = 'chat-message-sender';
                    senderSpan.textContent = item.senderId + (item.recipientId.toLowerCase() !== 'public' ? ` a ${item.recipientId}` : '');
                    
                    const contentSpan = document.createElement('span');
                    contentSpan.className = 'chat-message-content';
                    contentSpan.textContent = item.content;
                    
                    const timeSpan = document.createElement('span');
                    timeSpan.className = 'chat-message-time';
                    const timeText = document.createElement('span');
                    timeText.textContent = item.timestamp?.toDate ? `${item.timestamp.toDate().toLocaleDateString([], {day:'2-digit', month:'2-digit'})} - ${item.timestamp.toDate().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}` : '';
                    timeSpan.appendChild(timeText);

                    if (iSentIt || currentUserId === 'BoardingGate') {
                        const actionsContainer = document.createElement('div');
                        actionsContainer.className = 'chat-message-actions';
                        
                        const editIcon = document.createElement('img');
                        editIcon.src = 'https://boardinggate.github.io/Tesla/PNG/editmsg.png';
                        editIcon.className = 'chat-action-icon';
                        editIcon.title = 'Editar mensaje';
                        editIcon.dataset.action = 'edit-message';
                        editIcon.dataset.id = item.id;
                        editIcon.dataset.content = item.content;

                        const deleteIcon = document.createElement('img');
                        deleteIcon.src = 'https://boardinggate.github.io/Tesla/PNG/erasemsg.png';
                        deleteIcon.className = 'chat-action-icon';
                        deleteIcon.title = 'Eliminar mensaje';
                        deleteIcon.dataset.action = 'delete-message';
                        deleteIcon.dataset.id = item.id;

                        actionsContainer.appendChild(editIcon);
                        actionsContainer.appendChild(deleteIcon);
                        timeSpan.appendChild(actionsContainer);
                    }
                    
                    bubble.appendChild(senderSpan);
                    bubble.appendChild(contentSpan);
                    bubble.appendChild(timeSpan);
                    messagesContainer.appendChild(bubble);
                }
            }
        });
        
        messagesContainer.scrollTop = 0;

    } catch (error) {
        messagesContainer.innerHTML = `<p class="chat-system-message">Error al cargar el chat: ${error.message}</p>`;
    }
}
// ===================================================================
// NOMBRE: renderPollBubble (CORREGIDA V5 - ROBUSTA CON DOM)
// RESUMEN: Construye un elemento DOM para la encuesta, evitando errores de sintaxis.
function renderPollBubble(poll, currentUserId) {
    const totalVotes = Object.keys(poll.votes || {}).length;
    
    const pollBubble = document.createElement('div');
    pollBubble.id = `poll-${poll.id}`;
    pollBubble.className = 'chat-message-bubble chat-poll-bubble';

    const senderTime = poll.timestamp?.toDate 
        ? `${poll.timestamp.toDate().toLocaleDateString([], {day: '2-digit', month: '2-digit'})} - ${poll.timestamp.toDate().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`
        : 'enviando...';

    const senderInfo = document.createElement('div');
    senderInfo.className = 'poll-sender-info';
    senderInfo.innerHTML = `<span class="chat-message-sender">${poll.senderId}</span><span class="poll-time">${senderTime}</span>`;
    
    const questionEl = document.createElement('p');
    questionEl.className = 'poll-question';
    questionEl.textContent = poll.question;

    const optionsList = document.createElement('ul');
    optionsList.className = 'poll-options-list';

    poll.options.forEach((option, index) => {
        const voteCount = Object.values(poll.votes || {}).filter(voteIndex => voteIndex === index).length;
        const percentage = totalVotes > 0 ? (voteCount / totalVotes) * 100 : 0;
        const hasVotedThis = (poll.votes || {})[currentUserId] === index;

        const voters = Object.entries(poll.votes || {}).filter(([_, vIndex]) => vIndex === index).map(([userId, _]) => userId);
        
        const listItem = document.createElement('li');
        listItem.className = 'poll-option-item';
        listItem.dataset.optionIndex = index;

        const button = document.createElement('button');
        button.className = `poll-option-button ${hasVotedThis ? 'voted' : ''}`;
        button.dataset.action = 'vote-poll';
        button.dataset.id = poll.id;
        button.dataset.optionIndex = index;
        button.innerHTML = `<div class="poll-option-text">${option}</div><div class="poll-vote-count">${voteCount}</div>`;

        const progressBar = document.createElement('div');
        progressBar.className = 'poll-progress-bar';
        progressBar.innerHTML = `<div class="poll-progress-fill" style="width: ${percentage}%;"></div>`;
        
        const votersContainer = document.createElement('div');
        votersContainer.className = 'poll-voters-container';
        const votersUl = document.createElement('ul');
        votersUl.className = 'poll-voter-list';
        votersUl.innerHTML = voters.map(user => `<li class="poll-voter-name">${user}</li>`).join('');
        votersContainer.appendChild(votersUl);

        listItem.appendChild(button);
        listItem.appendChild(progressBar);
        listItem.appendChild(votersContainer);
        optionsList.appendChild(listItem);
    });

    pollBubble.appendChild(senderInfo);
    pollBubble.appendChild(questionEl);
    pollBubble.appendChild(optionsList);

    if (currentUserId === 'BoardingGate') {
        const moderationIcons = document.createElement('div');
        moderationIcons.className = 'poll-moderation-icons';
        
        const editIcon = document.createElement('img');
        editIcon.src = "https://boardinggate.github.io/Tesla/PNG/editmsg.png";
        editIcon.className = 'chat-action-icon';
        editIcon.title = "Editar pregunta";
        editIcon.dataset.action = "edit-poll";
        editIcon.dataset.id = poll.id;
        editIcon.dataset.question = poll.question;
        
        const deleteIcon = document.createElement('img');
        deleteIcon.src = "https://boardinggate.github.io/Tesla/PNG/erasemsg.png";
        deleteIcon.className = 'chat-action-icon';
        deleteIcon.title = "Eliminar encuesta";
        deleteIcon.dataset.action = "delete-poll";
        deleteIcon.dataset.id = poll.id;
        
        moderationIcons.appendChild(editIcon);
        moderationIcons.appendChild(deleteIcon);
        pollBubble.appendChild(moderationIcons);
    }
    
    return pollBubble;
}
    
// ===================================================================
// NOMBRE: adaptMapboxRouteToOSRMFormat (NUEVA FUNCIÓN)
// RESUMEN: Convierte la respuesta de la API de Mapbox al formato de OSRM.
function adaptMapboxRouteToOSRMFormat(mapboxRoute) {
    const adaptedLegs = mapboxRoute.legs.map(leg => {
        const adaptedSteps = leg.steps.map(step => {
            return {
                distance: step.distance,
                duration: step.duration,
                geometry: step.geometry,
                maneuver: {
                    bearing_after: step.maneuver.bearing_after,
                    bearing_before: step.maneuver.bearing_before,
                    location: step.maneuver.location,
                    modifier: step.maneuver.modifier,
                    type: step.maneuver.type,
                },
                name: step.name,
            };
        });
        return {
            distance: leg.distance,
            duration: leg.duration,
            steps: adaptedSteps,
            summary: leg.summary,
        };
    });
    return {
        distance: mapboxRoute.distance,
        duration: mapboxRoute.duration,
        geometry: mapboxRoute.geometry,
        legs: adaptedLegs,
    };
}
    

// ===================================================================
// NOMBRE: startEditMessage (NUEVA FUNCIÓN)
// RESUMEN: Prepara la UI para editar un mensaje existente.
function startEditMessage(messageId, content) {
    const messageInput = document.getElementById('chat-message-input');
    const sendButton = document.getElementById('chat-send-button');

    if (messageInput && sendButton) {
        messageInput.value = content;
        messageInput.dataset.editingMessageId = messageId;
        sendButton.textContent = 'Actualizar';
        messageInput.focus();
        }
}

// ===================================================================
// NOMBRE: deleteChatMessage (NUEVA FUNCIÓN)
// RESUMEN: Elimina un mensaje del chat y de Firebase previa confirmación.
async function deleteChatMessage(messageId) {
    if (!messageId) return;

    if (confirm('¿Estás seguro de que deseas eliminar este mensaje permanentemente?')) {
        try {
            const messageRef = window.doc(window.db, 'chatMessages', messageId);
            await window.deleteDoc(messageRef);
            showToast("Mensaje eliminado.", "success");
            fetchAndRenderChatMessages();
        } catch (error) {
            showToast("Error al eliminar el mensaje.", "error");
        }
    }
}
   
// ===================================================================
// NOMBRE: closeChatModal (MODIFICADA)
// RESUMEN: Cierra el modal y restaura el scroll del body.
function closeChatModal() {
    const modalOverlay = document.getElementById('chat-modal-overlay');
    if (modalOverlay) {
        modalOverlay.classList.add('hidden');
    }
    document.body.classList.remove('chat-open'); 
    if (chatUpdateInterval) {
        clearInterval(chatUpdateInterval);
        chatUpdateInterval = null;
    }
}

// ===================================================================
// NOMBRE: updateTotalMessageCount (MODIFICADA)
// RESUMEN: Actualiza el contador de mensajes en el nuevo globo principal.
async function updateTotalMessageCount() {
    const globeButton = document.getElementById('chat-icon-button');
    const globeCounter = document.getElementById('chat-message-globe');
    if (!globeButton || !globeCounter || !window.db) return;

    try {
        const ninetySixHoursAgo = new Date(Date.now() - 96 * 60 * 60 * 1000);
        const messagesRef = window.collection(window.db, 'chatMessages');
        const q = window.query(messagesRef, window.where('timestamp', '>', ninetySixHoursAgo));
        
        const querySnapshot = await window.getDocs(q);
        const count = querySnapshot.size;

        if (count > 0) {
            globeCounter.textContent = count;
            globeButton.classList.remove('hidden');
        } else {
            globeCounter.textContent = '0';
             
        }
    } catch (error) {
        globeCounter.textContent = 'X';
        globeButton.classList.remove('hidden');
    }
}    

// ===================================================================
// NOMBRE: sendMessage (MODIFICADA V2)
// RESUMEN: Envía mensajes/encuestas y fuerza la actualización inmediata del chat.
async function sendMessage() {
    const messageInput = document.getElementById('chat-message-input');
    const sendButton = document.getElementById('chat-send-button');
    const content = messageInput.value.trim();
    const editingId = messageInput.dataset.editingMessageId;

    if (!content) {
        showToast("El mensaje no puede estar vacío.", "warning");
        return;
    }
    
    const currentUserId = localStorage.getItem('userData_userId');
    if (!currentUserId) {
        showToast("Error: No se ha podido identificar al usuario.", "error");
        return;
    }
    
    sendButton.disabled = true;

    try {
        if (content.toUpperCase().startsWith('#COMUNIDAD#')) {
            const parts = content.split('#');
            if (parts.length < 4 || !parts[2] || !parts[3]) {
                throw new Error("Formato de encuesta incorrecto. Use #COMUNIDAD#Pregunta#Opción1 $ Opción2 ...");
            }
            
            const question = parts[2].trim();
            const options = parts[3].split('$').map(opt => opt.trim()).filter(Boolean);

            if (options.length < 2 || options.length > 6) {
                throw new Error("Las encuestas deben tener entre 2 y 6 opciones.");
            }
            if (!question) {
                throw new Error("La pregunta de la encuesta no puede estar vacía.");
            }

            const newPoll = {
                senderId: currentUserId,
                question: question,
                options: options,
                timestamp: window.serverTimestamp(),
                votes: {}
            };

            await window.addDoc(window.collection(window.db, 'chatPolls'), newPoll);
            messageInput.value = '';

        } else if (editingId) {
            const messageRef = window.doc(window.db, 'chatMessages', editingId);
            await window.setDoc(messageRef, { content: content }, { merge: true });
            
            messageInput.value = '';
            delete messageInput.dataset.editingMessageId;
            sendButton.textContent = 'Enviar';
            showToast("Mensaje actualizado correctamente.", "success");

        } else {
            if (content.length > 500) {
                showToast("El mensaje excede los 500 caracteres.", "warning");
                sendButton.disabled = false;
                return;
            }
            
            let recipientId = 'public';
            let messageContent = content;
            const mentionMatch = content.match(/^@(\w+)\s/);
            
            if (mentionMatch) {
                const mentionedUser = mentionMatch[1];
                const usersRef = window.collection(window.db, "user_data");
                const q = window.query(usersRef, window.where("rss", "==", true));
                const querySnapshot = await window.getDocs(q);
                let foundRecipientId = null;

                querySnapshot.forEach(doc => {
                    const userData = doc.data();
                    const actualUserId = userData.usuario || doc.id;
                    if (actualUserId.toLowerCase() === mentionedUser.toLowerCase()) {
                        foundRecipientId = actualUserId;
                    }
                });

                if (foundRecipientId) {
                    recipientId = foundRecipientId;
                    messageContent = content.substring(mentionMatch[0].length).trim();
                } else {
                    showToast(`Usuario "@${mentionedUser}" no encontrado o no tiene MDs activados.`, "warning");
                    sendButton.disabled = false;
                    return;
                }
            }

            const newMessage = {
                senderId: currentUserId,
                recipientId: recipientId,
                content: messageContent,
                timestamp: window.serverTimestamp()
            };
            
            await window.addDoc(window.collection(window.db, 'chatMessages'), newMessage);
            messageInput.value = '';
        }
        
        messageInput.dispatchEvent(new Event('input')); 
        fetchAndRenderChatMessages();

    } catch (error) {
        showToast(error.message || (editingId ? "Error al actualizar." : "Error al enviar."), "error");
    } finally {
        sendButton.disabled = false;
    }
}

// ===================================================================
// NOMBRE: handleDragEnd
// RESUMEN: Maneja la finalización de una operación de arrastre.
function handleDragEnd(e) {     if (!isEditMode) return;  handleDragEndCleanup(); 
}
    
// ===================================================================
// NOMBRE: cleanUpOldChatMessages (MODIFICADA)
// RESUMEN: Borra los mensajes (no encuestas) con más de 120 horas (ejecutado por el admin).
async function cleanUpOldChatMessages() {
    if (!window.db) return;
    const oneHundredTwentyHoursAgo = new Date(Date.now() - 120 * 60 * 60 * 1000);
    const messagesRef = window.collection(window.db, 'chatMessages');
    const q = window.query(messagesRef, window.where('timestamp', '<=', oneHundredTwentyHoursAgo));

    try {
        const querySnapshot = await window.getDocs(q);
        if (querySnapshot.empty) {
            showToast("No hay mensajes antiguos que limpiar.", "info", 2000);
            return;
        }

        const batchPromises = [];
        const batchSize = 499;
        let currentBatch = window.writeBatch(window.db);
        let batchCount = 0;

        querySnapshot.forEach((doc, index) => {
            currentBatch.delete(doc.ref);
            batchCount++;
            if (batchCount === batchSize) {
                batchPromises.push(currentBatch.commit());
                currentBatch = window.writeBatch(window.db);
                batchCount = 0;
            }
        });
        
        if (batchCount > 0) {
            batchPromises.push(currentBatch.commit());
        }

        await Promise.all(batchPromises);
        showToast(`Limpieza completada: ${querySnapshot.size} mensajes eliminados.`, 'success');
        updateTotalMessageCount();

    } catch (error) {
        showToast('Error durante la limpieza de mensajes antiguos.', 'error');
    }
}    
    
// ===================================================================
// NOMBRE: createRouteLabelMarker (NUEVA FUNCIÓN - SIN L.divIcon)
// RESUMEN: Crea un icono de etiqueta personalizado para las rutas alternativas.
function createRouteLabelMarker(text, color) {
    const iconHtml = `<div class="route-label-marker" style="background-color: ${color};">${text}</div>`;
    const div = document.createElement('div');
    div.innerHTML = iconHtml;
    return div.firstChild; 
}

// ===================================================================
// NOMBRE: showAutoStartNavigationModal (MODIFICADA - VERSIÓN CON VERIFICACIÓN DE RUTA)
// RESUMEN: Muestra el modal de inicio. Si la ruta se borra mientras se muestra, el modal se cierra solo.
function showAutoStartNavigationModal() {
    hideAutoStartNavigationModal();

    const progressBar = document.getElementById('navigation-bottom-progress-bar');
    if (progressBar) {
        progressBar.classList.add('progress-bar-partially-hidden');
    }

    const modal = document.createElement('div');
    modal.id = 'auto-start-nav-modal';
    
    let countdown = 20;
    
    modal.innerHTML = `
        <div style="display: flex; gap: 10px; align-items: stretch;">
            <button id="start-route-now-button" style="flex-grow: 1;">INICIAR RUTA (${countdown})</button>
            <button id="cancel-start-nav" style="flex-shrink: 0; padding: 10px 15px; font-size: 1rem; background-color: #6c757d; color: white; border: 1px solid #FFF; border-radius: 5px; cursor: pointer;">Cancelar</button>
        </div>
        <p class="info-text">(*) Si prefiere otra ruta seleccione una de las alternativas mostradas.</p>
    `;

    document.body.appendChild(modal);

    const startButton = document.getElementById('start-route-now-button');
    const cancelButton = document.getElementById('cancel-start-nav');

    const startNavAndClose = () => {
        if (!isNavigating) {
            toggleNavigationState();
        }
    };
    
    startButton.addEventListener('click', startNavAndClose);
    
    cancelButton.addEventListener('click', () => {
        hideAutoStartNavigationModal();
    });

    autoStartNavModalTimer = setInterval(() => {
        const isRouteStillValid = navigationCurrentRouteData && navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2;
        
        if (!isRouteStillValid) {
            hideAutoStartNavigationModal();
            return;
        }
        
        countdown--;
        const btn = document.getElementById('start-route-now-button');
        if (countdown > 0) {
            if (btn) btn.textContent = `INICIAR RUTA (${countdown})`;
        } else {
            if (btn) startNavAndClose(); 
        }
    }, 1000);
}
    
// ===================================================================
// NOMBRE: selectAlternativeRoute (CORRECCIÓN FINAL)
// RESUMEN: Limpia las alternativas INMEDIATAMENTE, luego recalcula la ruta seleccionada.
async function selectAlternativeRoute(waypointId, routeType) {
    clearAlternativeRoutesDisplay();

    if (!alternativeRoutesCache.has(waypointId)) {
        showToast("Error de caché: No se encontraron datos para la ruta seleccionada.", "error");
        return;
    }

    const routesData = alternativeRoutesCache.get(waypointId);
    const selectedRouteData = routesData[routeType];

    if (!selectedRouteData || !selectedRouteData.geometry || !selectedRouteData.geometry.coordinates) {
        showToast("Error: La ruta alternativa seleccionada no tiene geometría válida.", "error");
        return;
    }

    selectedStageRoutes.set(waypointId, routeType);

    const endWaypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    if (endWaypointIndex < 1) return;

    let startWaypointIndex = -1;
    for (let i = endWaypointIndex - 1; i >= 0; i--) {
        if (navigationWaypoints[i] && !navigationWaypoints[i].isInternal) {
            startWaypointIndex = i;
            break;
        }
    }
    if (startWaypointIndex === -1) return;

    navigationWaypoints = navigationWaypoints.filter(wp => !(wp.isInternal && wp.parentWaypointId === waypointId));
    
    const geometryPoints = selectedRouteData.geometry.coordinates;
    const totalPoints = geometryPoints.length;
    const maxInternalPoints = 10;
    const step = totalPoints > maxInternalPoints + 2 ? Math.floor((totalPoints - 2) / maxInternalPoints) : 1;
    
    const internalWaypoints = [];
    for (let i = step; i < totalPoints - 1; i += step) {
         const coord = geometryPoints[i];
         internalWaypoints.push({
            id: Date.now() + Math.random() + i,
            lat: coord[1],
            lng: coord[0],
            type: 'internal',
            label: '',
            address: 'Punto de paso interno',
            isInternal: true,
            parentWaypointId: waypointId,
            visited: false,
            isCriticalForRecalc: true
        });
    }

    const newEndIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    navigationWaypoints.splice(newEndIndex, 0, ...internalWaypoints);
    
    await recalculateAndDrawRoute(true);
    
    const routeTypeTranslations = {
        'fastest': 'RÁPIDA',
        'shortest': 'CORTA',
        'alternative': 'ALTERNATIVA'
    };
    const translatedType = routeTypeTranslations[routeType] || routeType.toUpperCase();
    showToast(`Ruta para esta etapa cambiada a: ${translatedType}.`, "success");
}
    
// ===================================================================
// NOMBRE: drawAlternativeRoutes (MODIFICADA - PARA MAPBOX)
// RESUMEN: Dibuja en el mapa las polilíneas y etiquetas de las rutas alternativas.
function drawAlternativeRoutes(waypointId, routesData) {
    clearAlternativeRoutesDisplay(); 
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) return;

    const routeConfigs = [
        { type: 'fastest', data: routesData.fastest, color: '#0066FF', label: 'RAP' }, 
        { type: 'shortest', data: routesData.shortest, color: '#BA6BFF', label: 'COR' }, 
        { type: 'alternative', data: routesData.alternative, color: '#FF5900', label: 'ALT' } 
    ];

    routeConfigs.forEach((config, index) => {
        if (config.data && config.data.geometry) {
            const sourceId = `alt-route-${waypointId}-${config.type}`;
            const layerId = `alt-layer-${waypointId}-${config.type}`;
            const labelMarkerId = `alt-label-${waypointId}-${config.type}`;

            navigationMapInstance.addSource(sourceId, {
                type: 'geojson',
                data: config.data.geometry
            });
            navigationMapInstance.addLayer({
                id: layerId,
                type: 'line',
                source: sourceId,
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                paint: {
                    'line-color': config.color,
                    'line-width': (navigationMapInstance && navigationMapInstance.getPitch() > 20) ? 12 : 8,
                    'line-opacity': 0.8
                }
            });

            const midPoint = turf.along(config.data.geometry, turf.length(config.data.geometry) / 2).geometry.coordinates;
            const labelElement = createRouteLabelMarker(config.label, config.color);
            const labelMarker = new mapboxgl.Marker({ element: labelElement })
                .setLngLat(midPoint)
                .addTo(navigationMapInstance);
            
            labelMarker.getElement().addEventListener('click', (e) => {
                e.stopPropagation(); 
                selectAlternativeRoute(waypointId, config.type);
            });

            alternativeRouteLayers.push({ sourceId, layerId, labelMarker });
        }
    });
}


// ===================================================================
// NOMBRE: clearAlternativeRoutesDisplay (VERSIÓN FINAL CON REINTENTOS)
// RESUMEN: Inicia el proceso de limpieza de rutas alternativas, delegando
//          la lógica a una función auxiliar con reintentos para máxima robustez.
// ===================================================================
function clearAlternativeRoutesDisplay() {
    if (!navigationMapInstance) {
        alternativeRouteLayers = [];
        return;
    }

    // Copiamos los elementos a borrar y reseteamos el array principal inmediatamente.
    // Esto evita que nuevas rutas se añadan mientras limpiamos las antiguas.
    const itemsToClear = [...alternativeRouteLayers];
    alternativeRouteLayers = [];

    // Inicia el primer intento de limpieza.
    attemptClear(itemsToClear, 1);
}

// ===================================================================
// NOMBRE: attemptClear (NUEVA FUNCIÓN AUXILIAR)
// RESUMEN: Intenta limpiar los elementos de la ruta. Si alguno falla,
//          reintenta la operación para los elementos fallidos tras una breve espera.
// ===================================================================
function attemptClear(itemsToClear, attemptNumber) {
    const MAX_ATTEMPTS = 5;
    const RETRY_DELAY_MS = 100; // 100 milisegundos

    if (attemptNumber > MAX_ATTEMPTS || itemsToClear.length === 0) {
        if (itemsToClear.length > 0) {
            console.error(`Fallo definitivo al limpiar ${itemsToClear.length} elementos de ruta alternativa tras ${MAX_ATTEMPTS} intentos.`);
        }
        return; // Detenemos la recursión
    }

    const failedItems = [];

    // 1. Borrado robusto de iconos (se hace una sola vez, es muy fiable)
    if (attemptNumber === 1) {
        document.querySelectorAll('.route-label-marker').forEach(el => el.remove());
    }

    // 2. Intento de borrado de trazados (capas y fuentes)
    itemsToClear.forEach(item => {
        let success = true;
        try {
            if (navigationMapInstance.getLayer(item.layerId)) {
                navigationMapInstance.removeLayer(item.layerId);
            }
            if (navigationMapInstance.getSource(item.sourceId)) {
                navigationMapInstance.removeSource(item.sourceId);
            }
            // El marcador ya fue borrado en el primer intento, aquí solo limpiamos referencias
            if (item.labelMarker && typeof item.labelMarker.remove === 'function') {
                item.labelMarker.remove();
            }
        } catch (e) {
            success = false;
            failedItems.push(item); // Si falla, lo añadimos a la lista de reintento
        }
    });

    // 3. Si algún elemento falló, programamos un reintento
    if (failedItems.length > 0) {
        setTimeout(() => {
            attemptClear(failedItems, attemptNumber + 1);
        }, RETRY_DELAY_MS);
    }
}


    
// ===================================================================
// NOMBRE: fetchAndDisplayAlternativeRoutes (NUEVA FUNCIÓN)
// RESUMEN: Obtiene y muestra las rutas alternativas para una etapa específica.
async function fetchAndDisplayAlternativeRoutes(waypointId) {
    if (alternativeRoutesCache.has(waypointId)) {
        drawAlternativeRoutes(waypointId, alternativeRoutesCache.get(waypointId));
        return;
    }

    const endWaypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    if (endWaypointIndex < 1) return;

    let startWaypoint = null;
    for (let i = endWaypointIndex - 1; i >= 0; i--) {
        if (navigationWaypoints[i] && !navigationWaypoints[i].isInternal) {
            startWaypoint = navigationWaypoints[i];
            break;
        }
    }
    
    if (!startWaypoint) return;
    const endWaypoint = navigationWaypoints[endWaypointIndex];

    const url = `${OSRM_SERVICE_URL}/driving/${startWaypoint.lng},${startWaypoint.lat};${endWaypoint.lng},${endWaypoint.lat}?alternatives=true&overview=full&geometries=geojson&steps=false`;

    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Respuesta de red no fue OK');
        const data = await response.json();

        if (!data.routes || data.routes.length < 1) {
             showToast("NO HAY RUTAS ALTERNATIVAS", "info");
            return;
        }

        const fastestRoute = data.routes[0];
        const shortestRoute = [...data.routes].sort((a, b) => a.distance - b.distance)[0];
        const alternativeRoute = data.routes.find(r => r !== fastestRoute && r !== shortestRoute) || null;
        
        if (fastestRoute === shortestRoute && !alternativeRoute) {
            showToast("NO HAY RUTAS ALTERNATIVAS", "info");
            return;
        }

        const routesData = {
            fastest: fastestRoute,
            shortest: fastestRoute === shortestRoute ? null : shortestRoute,
            alternative: alternativeRoute
        };

        alternativeRoutesCache.set(waypointId, routesData);
        drawAlternativeRoutes(waypointId, routesData);

    } catch (error) {
        showToast("Error al obtener rutas alternativas", "error");
    }
}
   
// ===================================================================
// NOMBRE: cancelAutoStartNav (NUEVA FUNCIÓN)
// RESUMEN: Cancela la navegación automática iniciada al cargar una ruta.
function cancelAutoStartNav(toastId) {
    if (autoStartNavTimer) {
        clearInterval(autoStartNavTimer);
        autoStartNavTimer = null;
    }
    const toastElement = document.getElementById(toastId);
    if (toastElement) {
        toastElement.remove();
        activeToasts = activeToasts.filter(t => t.id !== toastId);
    }
    }
window.cancelAutoStartNav = cancelAutoStartNav;

 
// ===================================================================
// NOMBRE: showChargingPointModal (MODIFICADA - PARA MAPBOX POPUP)
// RESUMEN: Crea y muestra un modal detallado para un punto de recarga OCM.
function showChargingPointModal(point, index) {
    const existingModal = document.querySelector('.ocm-modal-overlay');
    if (existingModal) existingModal.remove();

    const overlay = document.createElement('div');
    overlay.className = 'ocm-modal-overlay';

    const photoUrl = (point.MediaItems && point.MediaItems.length > 0 && point.MediaItems[0].ItemURL) 
        ? point.MediaItems[0].ItemURL 
        : 'https://boardinggate.github.io/Tesla/PNG/PDREJEMPLO.PNG';
    
    const addressInfo = point.AddressInfo || {};
    const stationName = addressInfo.Title || 'Punto de Recarga';
    
    let addressParts = [];
    if (addressInfo.AddressLine1) addressParts.push(addressInfo.AddressLine1);
    
    const locationName = addressInfo.Town || addressInfo.StateOrProvince;
    if (addressInfo.Postcode && locationName) {
        addressParts.push(`${addressInfo.Postcode} - ${locationName}`);
    } else if (addressInfo.Postcode) {
        addressParts.push(addressInfo.Postcode);
    } else if (locationName) {
        addressParts.push(locationName);
    }
    const addressHtml = addressParts.join('<br>');

    const operatorInfo = point.OperatorInfo || {};

    let detailsHtml = '<h4>Detalles de Ubicación</h4>';
    detailsHtml += `<p><strong>Dirección Completa:</strong> ${addressInfo.Title}</p>`;
    detailsHtml += `<p><strong>Lat/Lon:</strong> ${addressInfo.Latitude.toFixed(5)}, ${addressInfo.Longitude.toFixed(5)}</p>`;
    
    const lat = addressInfo.Latitude;
    const lon = addressInfo.Longitude;
    const zoom = 17;

    const googleUrl = `https://www.google.com/maps/search/electric+vehicle+charging+stations/@${lat},${lon},${zoom}z`;
    const electroverseUrl = `https://electroverse.com/map?search=${lat}%2C${lon}`;
    const electromapsUrl = `https://map.electromaps.com/es/p/${lat},${lon}`;
    const reveUrl = "https://www.mapareve.es/mapa-puntos-recarga";

    detailsHtml += `
        <div class="ocm-external-links-container">
            <div class="ocm-external-links-left-group">
                <span class="ocm-external-links-label">Abrir en...</span>
                <p class="ocm-external-links-note">
                    <span style="font-size: 0.6rem;">(*) Para volver retroceda en el browser</span>
                </p>
            </div>
            <div class="ocm-external-links-buttons">
                <a href="${googleUrl}" target="_blank" rel="noopener noreferrer" class="ocm-external-link-btn" title="Abrir en Google Maps" onclick="event.stopPropagation();">
                    <img src="https://www.google.com/s2/favicons?domain=maps.google.com&sz=64" alt="Google Maps">
                </a>
                <a href="${reveUrl}" target="_blank" rel="noopener noreferrer" class="ocm-external-link-btn" title="Abrir en REVE (no admite localización)" onclick="event.stopPropagation();">
                    <img src="https://www.google.com/s2/favicons?domain=mapareve.es&sz=64" alt="REVE">
                </a>
                <a href="${electroverseUrl}" target="_blank" rel="noopener noreferrer" class="ocm-external-link-btn" title="Abrir en Electroverse" onclick="event.stopPropagation();">
                    <img src="https://www.google.com/s2/favicons?domain=electroverse.com&sz=64" alt="Electroverse">
                </a>
                <a href="${electromapsUrl}" target="_blank" rel="noopener noreferrer" class="ocm-external-link-btn" title="Abrir en Electromaps" onclick="event.stopPropagation();">
                    <img src="https://www.google.com/s2/favicons?domain=electromaps.com&sz=64" alt="Electromaps">
                </a>
                <button class="ocm-external-link-btn" title="Enviar a la app de Tesla" onclick="handleSendToTeslaClick(${lat}, ${lon}, '${stationName.replace(/'/g, "\\'")}'); event.stopPropagation();">
                    <img src="https://boardinggate.github.io/Tesla/PNG/th.jpeg" alt="Enviar a Tesla">
                </button>
            </div>
        </div>
    `;

    detailsHtml += '<h4>Equipamiento / Tarifa</h4>';
    if (point.Connections && point.Connections.length > 0) {
        point.Connections.forEach(conn => {
            const connType = conn.ConnectionType ? conn.ConnectionType.Title.replace(' (Socket)', '').replace(' (Connector)', '') : 'Desconocido';
            const power = conn.PowerKW ? `${conn.PowerKW.toFixed(0)} kW` : '';
            const status = conn.StatusType ? `(${translateOcmTerm(conn.StatusType.Title)})` : '';
            detailsHtml += `
                <div class="ocm-connection-item">
                    <span class="ocm-connection-type">• ${connType}</span>
                    <span class="ocm-connection-power-status">${power} ${status}</span>
                </div>`;
        });
    } else {
        detailsHtml += '<p>No hay información de conectores.</p>';
    }
    if (point.UsageCost) detailsHtml += `<p class="ocm-price-info"><strong>${point.UsageCost}</strong></p>`;

    detailsHtml += '<h4>Restricciones de Uso</h4>';
    detailsHtml += `<p><strong>Estado:</strong> ${translateOcmTerm(point.StatusType?.Title)}</p>`;
    detailsHtml += `<p><strong>Uso:</strong> ${translateOcmTerm(point.UsageType?.Title)}</p>`;

    detailsHtml += '<h4>Operador/Red</h4>';
    detailsHtml += `<p><strong>Nombre:</strong> ${operatorInfo.Title || 'No especificado'}</p>`;
    if (operatorInfo.WebsiteURL) detailsHtml += `<p><strong>Web:</strong> <a href="${operatorInfo.WebsiteURL}" target="_blank" rel="noopener noreferrer">${operatorInfo.WebsiteURL}</a></p>`;
    if (operatorInfo.PhonePrimaryContact) detailsHtml += `<p><strong>Teléfono:</strong> <a href="tel:${operatorInfo.PhonePrimaryContact}">${operatorInfo.PhonePrimaryContact}</a></p>`;

    let photosHtml = '<div class="ocm-photo-grid">';
    if (point.MediaItems && point.MediaItems.length > 0) {
        point.MediaItems.forEach(item => {
            if (item.ItemURL) {
                 photosHtml += `<img src="${item.ItemURL}" alt="${item.Comment || 'Foto del punto de recarga'}" data-full-url="${item.ItemURL}">`;
            }
        });
    } else {
        photosHtml += '<p>No hay fotografías disponibles para este punto.</p>';
    }
    photosHtml += '</div>';

    let commentsHtml = '<ul class="ocm-comment-list">';
    if (point.UserComments && point.UserComments.length > 0) {
        point.UserComments.forEach(comment => {
            commentsHtml += `
                <li class="ocm-comment">
                    <div class="ocm-comment-header">
                        <span class="user">${comment.UserName || 'Anónimo'}</span>
                        <span class="date">${comment.DateCreated ? formatDateToDDMMMYY(comment.DateCreated.split('T')[0]) : ''}</span>
                    </div>
                    <p class="comment-text">${comment.Comment}</p>
                </li>`;
        });
    } else {
        commentsHtml += '<p>No hay comentarios para este punto.</p>';
    }
    commentsHtml += '</ul>';

    overlay.innerHTML = `
        <div class="ocm-modal-content">
            <div class="ocm-modal-header" style="background-image: url('${photoUrl}')">
                <div class="ocm-modal-station-name-wrapper">
                    <span class="ocm-modal-station-name">${stationName}</span>
                </div>
                <div class="ocm-modal-address">${addressHtml}</div>
            </div>
            <div class="ocm-modal-tabs">
                <div class="ocm-modal-tab active" data-panel="details">DETALLES</div>
                <div class="ocm-modal-tab" data-panel="photos">FOTOS (${point.MediaItems?.length || 0})</div>
                <div class="ocm-modal-tab" data-panel="comments">COMENTARIOS (${point.UserComments?.length || 0})</div>
            </div>
            <div class="ocm-modal-body">
                <div id="ocm-panel-details" class="ocm-modal-panel active">${detailsHtml}</div>
                <div id="ocm-panel-photos" class="ocm-modal-panel">${photosHtml}</div>
                <div id="ocm-panel-comments" class="ocm-modal-panel">${commentsHtml}</div>
            </div>
            <div class="ocm-modal-footer">
                <button id="ocm-add-route-btn" data-index="${index}">Añadir a la Ruta</button>
                <button id="ocm-close-btn">Salir</button>
            </div>
        </div>
    `;

    const mapModalContainer = document.getElementById('reminders-location-map-modal');
    if (mapModalContainer) {
        mapModalContainer.appendChild(overlay);
    } else {
        document.body.appendChild(overlay);
    }

    const closeBtn = overlay.querySelector('#ocm-close-btn');
    let modalTimer = null;

    const closeHandler = () => {
        if (modalTimer) clearInterval(modalTimer);
        if (overlay.parentNode) {
            overlay.remove();
        }
    };
    closeBtn.addEventListener('click', closeHandler);
    
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            closeHandler();
        }
    });
    
    overlay.querySelector('#ocm-add-route-btn').addEventListener('click', (e) => {
        const pointIndex = parseInt(e.target.dataset.index);
        addChargingPointToRoute(pointIndex);
        closeHandler();
    });

    overlay.querySelectorAll('.ocm-modal-tab').forEach(tab => {
        tab.addEventListener('click', () => {
            overlay.querySelectorAll('.ocm-modal-tab').forEach(t => t.classList.remove('active'));
            overlay.querySelectorAll('.ocm-modal-panel').forEach(p => p.classList.remove('active'));
            tab.classList.add('active');
            overlay.querySelector(`#ocm-panel-${tab.dataset.panel}`).classList.add('active');
        });
    });

    overlay.querySelectorAll('.ocm-photo-grid img').forEach(img => {
        img.addEventListener('click', () => {
            showPhotoModal(img.dataset.fullUrl);
        });
    });

    let countdown = 70;
    const countdownSpan = document.createElement('span');
    countdownSpan.className = 'button-countdown-timer';
    countdownSpan.textContent = ` (${countdown})`;
    closeBtn.appendChild(countdownSpan);

    modalTimer = setInterval(() => {
        countdown--;
        countdownSpan.textContent = ` (${countdown})`;
        if (countdown <= 0) {
            closeHandler();
        }
    }, 1000);
}

// ===================================================================
// NOMBRE: showShareStageModal (NUEVA FUNCIÓN)
// RESUMEN: Muestra un modal para que el usuario seleccione qué etapa de una ruta compartir.
function showShareStageModal(routeObject) {
    if (!routeObject || !routeObject.waypoints || routeObject.waypoints.length === 0) {
        showToast("No hay etapas para compartir en esta ruta.", "error");
        return;
    }

    const existingOverlay = document.getElementById('share-stage-modal-overlay');
    if (existingOverlay) existingOverlay.remove();

    const overlay = document.createElement('div');
    overlay.id = 'share-stage-modal-overlay';
    overlay.className = 'route-modal-overlay';

    const modalContent = document.createElement('div');
    modalContent.id = 'share-stage-modal';
    modalContent.className = 'route-modal-container';

    modalContent.innerHTML = `
        <div class="route-modal-header" style="background-image: url('https://boardinggate.github.io/Tesla/PNG/modalrutas.png');">
            <div class="route-modal-title-card">
                <span class="route-modal-title">Compartir Etapa de Ruta</span>
            </div>
        </div>
        <div class="route-modal-body">
            <p style="margin-bottom: 15px; font-weight: 500; color: #333;">Selecciona una etapa para compartir sus coordenadas:</p>
            <div class="route-scroll-container">
                <ul id="share-stage-list" class="route-list"></ul>
            </div>
        </div>
        <div class="route-modal-footer">
            <button id="cancel-share-stage" class="btn-modal-action-secondary">Cancelar</button>
        </div>
    `;

    overlay.appendChild(modalContent);
    document.body.appendChild(overlay);

    const listElement = modalContent.querySelector('#share-stage-list');
    const cancelButton = modalContent.querySelector('#cancel-share-stage');

    const closeShareModal = () => {
        clearModalAutoCloseTimer(overlay, cancelButton, 'share-stage-modal');
        if (overlay.parentNode) overlay.remove();
    };

    routeObject.waypoints.forEach((waypoint, index) => {
        const li = document.createElement('li');
        li.className = 'route-list-item';
        li.style.cursor = 'pointer';

        const stageLabel = waypoint.type === 'S' ? 'Salida' : (waypoint.type === 'F' ? 'Destino' : `Etapa ${waypoint.label}`);
        const addressText = waypoint.address || `(${waypoint.lat.toFixed(4)}, ${waypoint.lng.toFixed(4)})`;

        li.innerHTML = `<span class="route-name" style="color: #105a52;"><strong>${stageLabel}:</strong> ${addressText}</span>`;
        
        li.addEventListener('click', () => {
            handleSendToTeslaClick(waypoint.lat, waypoint.lng, addressText);
            closeShareModal();
        });
        
        listElement.appendChild(li);
    });

    cancelButton.addEventListener('click', closeShareModal);
    addModalAutoCloseTimer(overlay, cancelButton, 'share-stage-modal', 25000);
}

// ===================================================================
// NOMBRE: getChargingPointColorByPower
// RESUMEN: Devuelve un color hexadecimal basado en el rango de potencia del PDR.
function getChargingPointColorByPower(power) {
    if (isNaN(power)) {
        return '#5e5e5e'; }
    if (power >= 0 && power <= 50) {
        return '#0f130c'; 
    } else if (power > 50 && power <= 100) {
        return '#007863'; 
    } else if (power > 100 && power <= 250) {
        return 'rgb(30, 144, 255)'; 
    } else if (power > 250 && power <= 2000) {
        return '#de2e03'; 
    }
    return '#5e5e5e'; 
}  

// ===================================================================
// NOMBRE: showPhotoModal
// RESUMEN: Muestra una imagen en un modal superpuesto.
function showPhotoModal(imageUrl) {
    const existingModal = document.querySelector('.ocm-photo-modal-overlay');
    if (existingModal) existingModal.remove();

    const overlay = document.createElement('div');
    overlay.className = 'ocm-photo-modal-overlay';
    
    overlay.innerHTML = `
        <div class="ocm-photo-modal-content">
            <img src="${imageUrl}" alt="Vista ampliada del punto de recarga">
            <div class="ocm-photo-modal-close-btn" title="Cerrar imagen">×</div>
        </div>
    `;

    document.body.appendChild(overlay);

    const close = () => {
        if (overlay.parentNode) {
            overlay.remove();
        }
    };
    overlay.querySelector('.ocm-photo-modal-close-btn').addEventListener('click', close);
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            close();
        }
    });
}
// ===================================================================
// NOMBRE: startFreeDrive (MODIFICADA - LIMPIEZA INICIAL)
// RESUMEN: Inicia el modo de conducción libre, limpiando marcadores de velocidad anteriores.
function startFreeDrive(initialCoords) {
    if (isFreeDriveActive || isNavigating) return;

    clearSpeedMarkers();
    isFreeDriveActive = true;
    isFreeDrivePaused = false;
    freeDriveStats = {
        startTime: new Date(),
        totalDistance: 0,
        lastPosition: { ...initialCoords },
    };

    navigationStartTimeForStats = new Date();
    totalDistanceTravelledForStats = 0;
    maxSpeedDuringTrip = 0;
    maxSpeedCoordinates = null;
    maxAltitudeDuringTrip = -Infinity;
    minAltitudeDuringTrip = Infinity;
    window.averageSpeedKmh = 0;
    lastPositionForStats = { ...initialCoords };
    
    showToast("Grabación de viaje en modo libre iniciada.", "success");

    navigationFollowUser = true;
    shouldCenterOnUser = true;
    const locateMeButton = document.getElementById('locate-me-on-reminders-map');
    const locateMeImg = locateMeButton ? locateMeButton.querySelector('img') : null;
    if (locateMeButton && locateMeImg) {
        locateMeImg.src = "PNG/DEJARSEGUIR.PNG";
        locateMeButton.title = "Dejar de centrar el mapa en mi posición";
    }
    toggleMapHeaderRowsVisibility(false);
    showMapInfoOverlay("Modo FREE DRIVE sin destino conocido");

    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    currentGraphMode = localStorage.getItem(GRAPH_STATE_KEY) || 'Desviación ETA'; 
    initializeNavigationGraph();
}
    
// ===================================================================
// NOMBRE: stopFreeDrive
// RESUMEN: Detiene el modo de conducción libre y muestra el modal de estadísticas.
function stopFreeDrive() {
    if (!isFreeDriveActive) return;

    const statsToSend = { ...freeDriveStats };
    showArrivalStatsModal(statsToSend);

    isFreeDriveActive = false;
    isFreeDrivePaused = false;
    freeDriveStats = null;
    tripStartLocationForStats = null;

    updateStartNavigationButtonState();
    updateNavigationButtonColor();
    clearNavigationGraph();
    showMapInfoOverlay("Modo FREE DRIVE fin de viaje");
}

// ===================================================================
// NOMBRE: updateNavigationProgressDisplay (VERSIÓN CON VISIBILIDAD CORREGIDA)
// RESUMEN: Muestra y actualiza la interfaz de progreso de la ruta.
function updateNavigationProgressDisplay(route, carDistanceAlongTheRoute = 0) {
    const progressBarContainer = document.getElementById('navigation-bottom-progress-bar');
    if (!progressBarContainer) return;

    const topInfoBar = document.getElementById('navigation-top-info-bar');
    const overallProgressContainer = document.getElementById('route-overall-progress-container');
    const etaInfoContainer = document.getElementById('navigation-eta-info');
    const distanceBar = document.getElementById('distance-progress-bar-to-turn-container');
    const hrSeparator = progressBarContainer.querySelector('hr');
    let freeDriveCard = document.getElementById('free-drive-stats-card');
    
    if (isFreeDriveActive) {
        progressBarContainer.style.display = 'flex'; // Mostrar la barra
        progressBarContainer.style.minWidth = 'auto';
        progressBarContainer.style.width = 'auto';
        if (topInfoBar) topInfoBar.style.display = 'none';
        if (overallProgressContainer) overallProgressContainer.style.display = 'none';
        if (etaInfoContainer) etaInfoContainer.style.display = 'none';
        if (distanceBar) distanceBar.style.display = 'none';
        if (hrSeparator) hrSeparator.style.display = 'none';
    } else if (route && typeof route.distance === 'number') {
        progressBarContainer.style.display = 'flex'; // Mostrar la barra
        progressBarContainer.style.minWidth = '480px';
        progressBarContainer.style.width = 'auto';
        if (topInfoBar) topInfoBar.style.display = 'flex';
        if (overallProgressContainer) overallProgressContainer.style.display = 'block';
        if (etaInfoContainer) etaInfoContainer.style.display = 'flex';
        if (distanceBar) distanceBar.style.display = 'block';
        if (hrSeparator) hrSeparator.style.display = 'block';
    } else {
        progressBarContainer.style.display = 'none'; // Ocultar si no hay ruta ni free drive
        return;
    }
  
    if (isFreeDriveActive) {
        if (!freeDriveCard) {
            freeDriveCard = document.createElement('div');
            freeDriveCard.id = 'free-drive-stats-card';
            progressBarContainer.appendChild(freeDriveCard);
        }
        freeDriveCard.style.display = 'block';

        const kmRealizadosTexto = `${(totalDistanceTravelledForStats / 1000).toFixed(1)} km`;
        const startTime = freeDriveStats ? freeDriveStats.startTime : new Date();
        const startTimeFormatted = `${startTime.getHours().toString().padStart(2, '0')}:${startTime.getMinutes().toString().padStart(2, '0')}`;
        const durationMs = Date.now() - startTime.getTime();
        const totalTravelSeconds = Math.floor(durationMs / 1000); 
        const travelHours = Math.floor(totalTravelSeconds / 3600);
        const travelMinutes = Math.floor((totalTravelSeconds % 3600) / 60);
        const travelSeconds = totalTravelSeconds % 60;
        const travelTimeFormatted = `${String(travelHours).padStart(2, '0')}:${String(travelMinutes).padStart(2, '0')}:${String(travelSeconds).padStart(2, '0')}`;
       
        freeDriveCard.innerHTML = `
            <div class="free-drive-card-content">
                <div class="fd-title">Modo Free Drive</div>
                <div class="fd-stats-grid">
                    <div class="fd-label">Distancia</div>
                    <div class="fd-label">Inicio</div>
                    <div class="fd-label">Duración</div>
                    <div class="fd-data">${kmRealizadosTexto}</div>
                    <div class="fd-data">${startTimeFormatted}</div>
                    <div class="fd-data">${travelTimeFormatted}</div>
                </div>
            </div>
        `;
        return;
    }

    if (freeDriveCard) {
        freeDriveCard.style.display = 'none';
    }
    
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    if (!route || typeof route.distance !== 'number' || typeof route.duration !== 'number' || actualWaypoints.length < 2) {
        return;
    }
    const overallProgressFill = document.getElementById('route-overall-progress');
    const routeProgressTextEl = document.getElementById('route-progress-text');
    const routeProgressIconEl = document.getElementById('route-progress-icon');
    const nextStageDistEl = document.getElementById('next-stage-distance');
    const nextStageTimeEl = document.getElementById('next-stage-time');
    const nextStageEtaEl = document.getElementById('next-stage-eta');
    const nextStageDeviationEl = document.getElementById('next-stage-eta-deviation');
    const finalDestDistEl = document.getElementById('final-destination-distance');
    const finalDestTimeEl = document.getElementById('final-destination-time');
    const finalDestEtaEl = document.getElementById('final-destination-eta');
    const finalDestDeviationEl = document.getElementById('final-destination-eta-deviation');
    const nextStageInfoDiv = document.getElementById('next-stage-info');
    const finalDestInfoDiv = document.getElementById('final-destination-info');
    const nextStageLabelEl = document.getElementById('next-stage-label');
    const totalJourneyDistanceForBar = (accumulatedDistanceBeforeCurrentSegment || 0) + route.distance;
    const currentJourneyDistanceForBar = (accumulatedDistanceBeforeCurrentSegment || 0) + carDistanceAlongTheRoute;
    const progressPercent = totalJourneyDistanceForBar > 0 ? (currentJourneyDistanceForBar / totalJourneyDistanceForBar) * 100 : 0;
    overallProgressFill.style.width = `${Math.min(100, progressPercent)}%`;
    if (routeProgressIconEl) {
        if (progressPercent > 0 && progressPercent < 100) {
            routeProgressIconEl.style.display = 'block';
        } else {
            routeProgressIconEl.style.display = 'none';
        }
    }
    if (routeProgressTextEl) {
        let kmRecorridosTexto = "-- km";
        let timeInfoString = ""; 
        if (navigationCurrentRouteData) { 
            if (isNavigating && navigationStartTimeForStats) {
                kmRecorridosTexto = `${(totalDistanceTravelledForStats / 1000).toFixed(1)} km`;
                const startTimeFormatted = `${navigationStartTimeForStats.getHours().toString().padStart(2, '0')}:${navigationStartTimeForStats.getMinutes().toString().padStart(2, '0')}`;
                const nowForTravelTime = new Date();
                const durationMs = nowForTravelTime - navigationStartTimeForStats;
                const totalTravelMinutes = Math.floor(durationMs / (1000 * 60));
                const travelHours = Math.floor(totalTravelMinutes / 60);
                const travelMinutes = totalTravelMinutes % 60;
                const travelTimeFormatted = `${String(travelHours).padStart(2, '0')}:${String(travelMinutes).padStart(2, '0')}`;
                timeInfoString = ` (${startTimeFormatted} • ${travelTimeFormatted})`;
            } else { 
                kmRecorridosTexto = "0.0 km";
                timeInfoString = ` (Stop)`;
            }
        } else { 
            kmRecorridosTexto = "-- km";
            timeInfoString = " (--:-- • --:--)";
        }
        routeProgressTextEl.innerHTML = `${kmRecorridosTexto}${timeInfoString}`;
    }
    const remainingDistanceTotal = Math.max(0, route.distance - carDistanceAlongTheRoute);
    const remainingDurationTotal = route.distance > 0 ? route.duration * (remainingDistanceTotal / route.distance) : 0;
    finalDestDistEl.textContent = `${(remainingDistanceTotal / 1000).toFixed(1)} km`;
    const finalDestTotalMinutes = Math.round(remainingDurationTotal / 60);
    const finalDestHours = Math.floor(finalDestTotalMinutes / 60);
    const finalDestMinutes = finalDestTotalMinutes % 60;
    finalDestTimeEl.textContent = `${String(finalDestHours).padStart(2, '0')}:${String(finalDestMinutes).padStart(2, '0')}`;
    const currentFinalEta = new Date(Date.now() + remainingDurationTotal * 1000);
    finalDestEtaEl.textContent = currentFinalEta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    if (tripInitialOverallEtaTime && isNavigating && navigationStartTimeForStats) {
        const finalDeviationMs = currentFinalEta.getTime() - tripInitialOverallEtaTime.getTime();
        finalDestDeviationEl.innerHTML = formatDeviation(finalDeviationMs);
    } else {
        finalDestDeviationEl.innerHTML = "";
    }
    const hasUnvisitedIntermediateStages = actualWaypoints.some(wp => !wp.visited && wp.type === 'intermediate');
    if (hasUnvisitedIntermediateStages) {
        etaInfoContainer.classList.remove('single-destination');
        finalDestInfoDiv.classList.remove('single-destination-layout');
        nextStageInfoDiv.style.display = 'block';
        const totalRealStages = actualWaypoints.length - 1;
        const currentRealStageIndex = actualWaypoints.findIndex(wp => !wp.visited && wp.type !== 'S') -1;
        const nextStageWaypointObject = actualWaypoints.find(wp => !wp.visited && wp.type !== 'S');
        if (nextStageLabelEl && nextStageWaypointObject) {
            let stageDescription = nextStageWaypointObject.address || `Etapa ${nextStageWaypointObject.label}`;
            if (stageDescription.length > 20) {
                stageDescription = stageDescription.substring(0, 20) + '...';
            }
            nextStageLabelEl.textContent = `Etapa ${currentRealStageIndex + 1} de ${totalRealStages}: ${stageDescription}`;
        }
        let cumulativeDistanceToStartOfCurrentLegOSRM = 0;
        if (route.legs) {
            for (let i = 0; i < currentLegIndexNav; i++) {
                if (route.legs[i] && typeof route.legs[i].distance === 'number') {
                    cumulativeDistanceToStartOfCurrentLegOSRM += route.legs[i].distance;
                }
            }
        }
        const legForDisplay = route.legs[currentLegIndexNav];
        if (legForDisplay) {
            const distanceIntoCurrentLegDisplay = Math.max(0, carDistanceAlongTheRoute - cumulativeDistanceToStartOfCurrentLegOSRM);
            const remainingDistanceThisLegDisplay = Math.max(0, (legForDisplay.distance || 0) - distanceIntoCurrentLegDisplay);
            const remainingDurationThisLegDisplay = (legForDisplay.distance > 0 && typeof legForDisplay.duration === 'number') ? legForDisplay.duration * (remainingDistanceThisLegDisplay / legForDisplay.distance) : 0;
            nextStageDistEl.textContent = `${(remainingDistanceThisLegDisplay / 1000).toFixed(1)} km`;
            const nextStageTotalMinutes = Math.round(remainingDurationThisLegDisplay / 60);
            const nextStageHours = Math.floor(nextStageTotalMinutes / 60);
            const nextStageMinutes = nextStageTotalMinutes % 60;
            nextStageTimeEl.textContent = `${String(nextStageHours).padStart(2, '0')}:${String(nextStageMinutes).padStart(2, '0')}`;
            const currentNextStageEta = new Date(Date.now() + remainingDurationThisLegDisplay * 1000);
            nextStageEtaEl.textContent = currentNextStageEta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            if (currentStageInitialExpectedEtaTime && isNavigating && navigationStartTimeForStats) {
               const deviationStageMs = currentNextStageEta.getTime() - currentStageInitialExpectedEtaTime.getTime();
               nextStageDeviationEl.innerHTML = formatDeviation(accumulatedDeviationMs + deviationStageMs);
            } else {
               nextStageDeviationEl.innerHTML = "";
            }
        }
    } else {
        etaInfoContainer.classList.add('single-destination');
        finalDestInfoDiv.classList.add('single-destination-layout');
        nextStageInfoDiv.style.display = 'none';
        if(nextStageDeviationEl) nextStageDeviationEl.innerHTML = "";
    }
    overallProgressContainer.querySelectorAll('.waypoint-dot-on-progress-bar, .radar-marker-on-progress-bar, .task-marker-on-progress-bar').forEach(dot => dot.remove());
    
    if (actualWaypoints.length > 2 && totalJourneyDistanceForBar > 0 && typeof turf !== 'undefined' && navigationMapInstance.getSource('route') && navigationMapInstance.getSource('route')._data) {
        const routeGeoJSON = navigationMapInstance.getSource('route')._data;
        const routeLineString = turf.lineString(routeGeoJSON.geometry.coordinates);
        const startOfRoute = turf.point(routeLineString.geometry.coordinates[0]);
        for (let i = 1; i < actualWaypoints.length - 1; i++) {
            const waypoint = actualWaypoints[i];
            const waypointPoint = turf.point([waypoint.lng, waypoint.lat]);
            const nearestPointOnLine = turf.nearestPointOnLine(routeLineString, waypointPoint, { units: 'meters' });
            const lineSliceToWaypoint = turf.lineSlice(startOfRoute, nearestPointOnLine, routeLineString);
            const distanceToWaypoint = turf.length(lineSliceToWaypoint, { units: 'meters' });
            const totalDistanceWithAccumulated = (accumulatedDistanceBeforeCurrentSegment || 0) + distanceToWaypoint;
            const percent = (totalDistanceWithAccumulated / totalJourneyDistanceForBar) * 100;
            if (percent < 100 && percent > 0) { 
                const dot = document.createElement('div');
                dot.className = 'waypoint-dot-on-progress-bar';
                dot.style.left = `calc(${percent}% - 7px)`;
                dot.title = `Etapa ${waypoint.label}`;
                overallProgressContainer.appendChild(dot);
            }
        }
    }

    const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
    if (radaresRutaCheckbox && radaresRutaCheckbox.checked && radaresEnRutaActual.length > 0 && totalJourneyDistanceForBar > 0) {
        radaresEnRutaActual.forEach(radar => {
            if (radar.distanceOnRoute !== undefined) {
                const totalDistanceToRadar = (accumulatedDistanceBeforeCurrentSegment || 0) + radar.distanceOnRoute;
                if(totalDistanceToRadar <= totalJourneyDistanceForBar) {
                    const percent = (totalDistanceToRadar / totalJourneyDistanceForBar) * 100;
                     if (percent >= 0 && percent <= 100) {
                        const radarMarker = document.createElement('div');
                        radarMarker.className = 'radar-marker-on-progress-bar';
                        radarMarker.style.left = `${percent}%`;
                        radarMarker.title = radar.text.replace(/<b>|<\/b>/gi, '');
                        overallProgressContainer.appendChild(radarMarker);
                    }
                }
            }
        });
    }
    const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
    if (tareasRutaCheckbox && tareasRutaCheckbox.checked && tareasEnRutaActual.length > 0 && totalJourneyDistanceForBar > 0) {
        tareasEnRutaActual.forEach(tarea => {
            if (tarea.distanceOnRoute !== undefined) {
                const totalDistanceToTask = (accumulatedDistanceBeforeCurrentSegment || 0) + tarea.distanceOnRoute;
                if(totalDistanceToTask <= totalJourneyDistanceForBar) {
                    const percent = (totalDistanceToTask / totalJourneyDistanceForBar) * 100;
                    if (percent >= 0 && percent <= 100) {
                        const taskMarker = document.createElement('div');
                        taskMarker.className = 'task-marker-on-progress-bar';
                        taskMarker.style.left = `${percent}%`;
                        taskMarker.title = tarea.text.replace(/<b>|<\/b>/gi, '');
                        overallProgressContainer.appendChild(taskMarker);
                    }
                }
            }
        });
    }
 
    if (isNavigating) {
        const destinationWp = navigationWaypoints[navigationWaypoints.length - 1];
        if (destinationWp && destinationWp.address) {
            const mapOverlay = document.getElementById('map-info-overlay');
            if (mapOverlay && !mapOverlay.textContent.startsWith("HA LLEGADO AL ")) {
                 showDestinationName();
            }
        }
    }
}
    
// ===================================================================
// NOMBRE: getAddressForWaypoint (MODIFICADA)
// RESUMEN: Obtiene la dirección o solo la calle de un punto de ruta.
async function getAddressForWaypoint(lat, lng, streetOnly = false) {
    if (typeof lat !== 'number' || typeof lng !== 'number' || isNaN(lat) || isNaN(lng)) {
        return "Ubicación Desconocida";
    }
    try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=1&accept-language=es`);
        if (response.ok) {
            const data = await response.json();
            if (streetOnly) {
                return data.address?.road || "Calle desconocida";
            }
            return data.display_name || `(${lat.toFixed(3)}, ${lng.toFixed(3)})`;
        } else {
            return streetOnly ? "Calle desconocida" : `Etapa (${lat.toFixed(3)}, ${lng.toFixed(3)})`;
        }
    } catch (err) {
        return streetOnly ? "Calle desconocida" : `Etapa (${lat.toFixed(3)}, ${lng.toFixed(3)})`;
    }
}


    
// ===================================================================
// NOMBRE: openAlertModal
// RESUMEN: Abre el modal para que el usuario seleccione una incidencia de tráfico.
function openAlertModal() {
   
    processTrafficAlerts();
    
    const alertModalOverlay = document.getElementById('alert-modal-overlay');
    const alertModalContent = document.getElementById('alert-modal-content');
    if (!alertModalOverlay || !alertModalContent) return;

    const alertOptions = [
        { code: 1, text: 'ACCIDENTE TRÁFICO', icon: 'PNG/AACCIDENTE.png' },
        { code: 2, text: 'COCHE AVERIADO', icon: 'PNG/AAVERIADO.png' },
        { code: 3, text: 'CONTROL TRÁFICO / RADAR', icon: 'PNG/AGUARDIA.png' },
        { code: 4, text: 'ATASCO', icon: 'PNG/AATASCO.png' },
        { code: 5, text: 'PELIGRO INDETERMINADO', icon: 'PNG/APELIGRO.png' },
        { code: 6, text: 'CARRETERA MAL ESTADO', icon: 'PNG/ARESVALAR.png' },
        { code: 7, text: 'OBRAS', icon: 'PNG/AOBRAS.png' },
        { code: 8, text: 'VÍA / CARRETERA CERRADA', icon: 'PNG/ACERRADA.png' }, 
        { code: 9, text: 'YA NO HAY NADA', icon: 'PNG/AANULAR.png' }           
    ];
    alertModalContent.innerHTML = '<div id="alert-columns-container"></div>';
    const columnsContainer = document.getElementById('alert-columns-container');

    const column1 = document.createElement('div');
    column1.className = 'alert-column';
    const column2 = document.createElement('div');
    column2.className = 'alert-column';

    alertOptions.forEach((option, index) => {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'alert-option';
        optionDiv.onclick = () => sendTrafficAlert(option.code, option.text);
        optionDiv.innerHTML = `<img src="${option.icon}" alt="${option.text}"><span>${option.text}</span>`;

        if (index < 5) {
            column1.appendChild(optionDiv);
        } else {
            column2.appendChild(optionDiv);
        }
    });

    const cancelButton = document.createElement('div');
    cancelButton.id = 'alert-cancel-button';
    cancelButton.innerHTML = '<span>CANCELAR <span id="alert-timer">(10)</span></span>';
    cancelButton.onclick = closeAlertModal;
    column2.appendChild(cancelButton); 

    columnsContainer.appendChild(column1);
    columnsContainer.appendChild(column2);

    alertModalOverlay.classList.remove('hidden');

    let countdown = 10;
    const timerSpan = document.getElementById('alert-timer');
    if (alertModalTimer) clearInterval(alertModalTimer);
    alertModalTimer = setInterval(() => {
        countdown--;
        if (timerSpan) timerSpan.textContent = `(${countdown})`;
        if (countdown <= 0) {
            closeAlertModal();
        }
    }, 1000);
}

// ===================================================================
// NOMBRE: formatOCMPoint
// RESUMEN: Convierte un punto de recarga del formato OCM a un formato interno estandarizado.
function formatOCMPoint(point) {
    if (!point || !point.AddressInfo) {
        return null;
    }

    let maxPower = 0;
    if (point.Connections && Array.isArray(point.Connections)) {
        point.Connections.forEach(conn => {
            if (conn.PowerKW && conn.PowerKW > maxPower) {
                maxPower = conn.PowerKW;
            }
        });
    }

    const totalPoints = point.NumberOfPoints || (point.Connections ? point.Connections.length : 0);
    const availabilityText = `${totalPoints} Poste${totalPoints !== 1 ? 's' : ''}`;

    let priceText = 'N/D';
    if (point.UsageCost) {
        const priceMatch = point.UsageCost.match(/(\d[\d,.]*)/);
        if (priceMatch && priceMatch[1]) {
            let priceNum = parseFloat(priceMatch[1].replace(',', '.'));
            if (!isNaN(priceNum) && priceNum > 0 && priceNum < 10) { 
                 priceText = `${priceNum.toFixed(2)} €/kWh`;
            }
        }
    }

    return {
        ocmId: point.ID,
        lat: point.AddressInfo.Latitude,
        lon: point.AddressInfo.Longitude,
        address: point.AddressInfo.Title || 'Dirección no disponible',
        availabilityText: availabilityText,
        price: priceText,
        fullPriceInfo: point.UsageCost || 'N/D',
        power: maxPower > 0 ? maxPower.toFixed(0) : 'N/A',
        operator: point.OperatorInfo ? point.OperatorInfo.Title : 'Desconocido',
        usageType: point.UsageType ? point.UsageType.Title : 'No especificado',
        accessInfo: point.AddressInfo.AccessComments || 'No especificado',
        connections: point.Connections || []
    };
}



    
// ===================================================================
// NOMBRE: closeAlertModal
// RESUMEN: Cierra el modal de selección de incidencias y limpia su temporizador.
function closeAlertModal() {
    const alertModalOverlay = document.getElementById('alert-modal-overlay');
    if (alertModalOverlay) {
        alertModalOverlay.classList.add('hidden');
    }
    if (alertModalTimer) {
        clearInterval(alertModalTimer);
        alertModalTimer = null;
    }
}
// ===================================================================
// NOMBRE: sendTrafficAlert (VERSIÓN FINAL Y CORRECTA)
// RESUMEN: Envía la alerta, la añade a la caché local y redibuja el mapa al instante.
function sendTrafficAlert(alertCode, alertName) {
    const userId = localStorage.getItem('userData_userId');
    if (!userId) {
        showToast("Debes configurar un ID de Usuario para enviar alertas.", "warning");
        closeAlertModal();
        return;
    }
    closeAlertModal();
    const sendData = async (coords) => {
        if (!window.db || !window.doc || !window.setDoc || !window.collection) {
            showToast("Error: Firebase no está inicializado.", "error");
            return;
        }
        const alertData = {
            user: userId,
            code: alertCode,
            latitude: coords.latitude,
            longitude: coords.longitude,
            timestamp: new Date().toISOString()
        };

        try {
            const alertsCollectionRef = window.collection(window.db, "users", "ALERTAS", "events");
            const docId = `${Date.now()}_${userId.replace(/[^a-zA-Z0-9]/g, '_')}`;
            const newAlertRef = window.doc(alertsCollectionRef, docId);
            
            await window.setDoc(newAlertRef, alertData);

            const newAlertForCache = {
                id: docId,
                code: alertData.code,
                coordinates: { lat: alertData.latitude, lon: alertData.longitude }
            };
            
            const existingIndex = trafficAlertsCache.findIndex(a => a.id === newAlertForCache.id);
            if (existingIndex > -1) {
                trafficAlertsCache[existingIndex] = newAlertForCache; // Evita duplicados
            } else {
                trafficAlertsCache.push(newAlertForCache);
            }

            displayAlertsOnMap();
            showToast(`Alerta "${alertName}" enviada y mostrada en el mapa.`, "success");

        } catch (error) {
            showToast(`Error al enviar alerta a Firebase: ${error.message}`, "error");
        }
    };

    if (isSimulatingGpsLocation && simulatedGpsLocation) {
        sendData(simulatedGpsLocation);
    } else {
        getCurrentLocation(
            (realCoords) => { sendData(realCoords); },
            (errorMsg) => { showToast(`No se pudo obtener la ubicación: ${errorMsg}`, "error"); }
        );
    }
}
    
// ===================================================================
// NOMBRE: processTrafficAlerts
// RESUMEN: Lógica principal que lee, limpia y actualiza las alertas desde Firebase.
async function processTrafficAlerts() {
    if (!window.db || !window.getDocs || !window.deleteDoc || !window.collection) {
        return;
    }
    
    lastAlertCheckTimestamp = Date.now();
    
    try {
        const alertsCollectionRef = window.collection(window.db, "users", "ALERTAS", "events");
        const querySnapshot = await window.getDocs(alertsCollectionRef);
        
        let allAlerts = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        const now = new Date();
        const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
        
        const removals = allAlerts.filter(alert => alert.code === 9);
        let activeAlerts = allAlerts.filter(alert => alert.code !== 9);

        for (const removal of removals) {
            const removalCoords = { lat: removal.latitude, lon: removal.longitude };
            const alertsToDelete = new Set();
            
            activeAlerts.forEach(alert => {
                if(alert.latitude && alert.longitude){
                    const alertCoords = { lat: alert.latitude, lon: alert.longitude };
                    if (calculateDistance(removalCoords.lat, removalCoords.lon, alertCoords.lat, alertCoords.lon) <= 800) {
                        alertsToDelete.add(alert.id);
                    }
                }
            });

            for (const idToDelete of alertsToDelete) {
                const docRef = window.doc(window.db, "users", "ALERTAS", "events", idToDelete);
                await window.deleteDoc(docRef);
            }
            
            const removalDocRef = window.doc(window.db, "users", "ALERTAS", "events", removal.id);
            await window.deleteDoc(removalDocRef);
        }

        activeAlerts = activeAlerts.filter(alert => {
            if (!alert.timestamp || new Date(alert.timestamp) < twentyFourHoursAgo) {
                const docRef = window.doc(window.db, "users", "ALERTAS", "events", alert.id);
                window.deleteDoc(docRef);
                return false;
            }
            return true;
        });
        
        trafficAlertsCache = activeAlerts.filter(alert => alert.latitude && alert.longitude).map(alert => ({
            id: alert.id,
            code: alert.code,
            coordinates: { lat: alert.latitude, lon: alert.longitude }
        }));
        
        displayAlertsOnMap(); 
        checkAlertsProximity();
      
    } catch (error) {
        console.error("Error procesando alertas de tráfico: ", error);
    }
}


// ===================================================================
// NOMBRE: eliminarTareasDeMapa (NUEVA FUNCIÓN)
// RESUMEN: Elimina del mapa los marcadores de tareas/radares personales.
function eliminarTareasDeMapa() {
    reminderMapObjects = reminderMapObjects.filter(obj => {
        if (obj.isFromTarea) {
            if (obj.marker) obj.marker.remove();
            if (obj.circleId && navigationMapInstance.getLayer(obj.circleId)) {
                navigationMapInstance.removeLayer(obj.circleId);
            }
            if (obj.circleId && navigationMapInstance.getSource(obj.circleId)) {
                navigationMapInstance.removeSource(obj.circleId);
            }
            return false;
        }
        return true;
    });
}
// ===================================================================
// NOMBRE: createRadarAlertIcon (CORRECCIÓN FINAL - ANTI-ERROR)
// RESUMEN: Crea un icono de alerta escalable asegurando que devuelve un elemento DOM.
function createRadarAlertIcon(currentZoomLevel = null, isFromTarea = false) {
    const container = document.createElement('div'); 
    const SCALE_THRESHOLD_ZOOM = 16;
    const MIN_SCALE = 0.35;
    const MIN_ZOOM_FOR_SCALING = 10;
    let scale = 1.0;

    if (currentZoomLevel !== null && currentZoomLevel < SCALE_THRESHOLD_ZOOM) {
        if (currentZoomLevel <= MIN_ZOOM_FOR_SCALING) {
            scale = MIN_SCALE;
        } else {
            const progress = (currentZoomLevel - MIN_ZOOM_FOR_SCALING) / (SCALE_THRESHOLD_ZOOM - MIN_ZOOM_FOR_SCALING);
            scale = MIN_SCALE + (1 - MIN_SCALE) * progress;
        }
    }

    const baseSize = 55;
    const finalSize = Math.round(baseSize * scale);
    const finalBorderSize = Math.max(1, Math.round(3 * scale));
    
    const borderColor = isFromTarea ? '#00FF00' : 'white';

    container.className = 'radar-alert-circle';
    container.style.cssText = `width:${finalSize}px; height:${finalSize}px; border-width:${finalBorderSize}px; border-color:${borderColor};`;
    container.innerHTML = `<img src="PNG/RADAR.PNG" alt="Radar">`;
    
    return container; 
}
    
    
// ===================================================================
// NOMBRE: checkAlertsProximity
// RESUMEN: Comprueba la proximidad del vehículo a las alertas y muestra un aviso si es necesario.
function checkAlertsProximity() {
    if (!navigationCurrentLocation || trafficAlertsCache.length === 0) {
        return;
    }

    const carLat = navigationCurrentLocation.latitude;
    const carLon = navigationCurrentLocation.longitude;
    trafficAlertsCache.forEach(alert => {
        const distance = calculateDistance(carLat, carLon, alert.coordinates.lat, alert.coordinates.lon);
        if (distance <= 500 && !currentlyDisplayedProximityAlerts.has(alert.id)) {
            showProximityAlert(alert);
            currentlyDisplayedProximityAlerts.add(alert.id);
        }
    });
}
// ===================================================================
// NOMBRE: hideProximityAlert
// RESUMEN: Oculta el modal de aviso de proximidad.
function hideProximityAlert(alertId) {
    const proximityModal = document.getElementById('proximity-alert-modal');
    if (proximityModal) proximityModal.classList.add('hidden');
    document.getElementById('flashing-border-overlay').classList.add('hidden');
    
    if (proximityAlertTimer) {
        clearInterval(proximityAlertTimer);
        proximityAlertTimer = null;
    }
}
// ===================================================================
// NOMBRE: forceProcessTrafficAlerts
// RESUMEN: Lanza el proceso de actualización de alertas inmediatamente.
function forceProcessTrafficAlerts() {
    console.log("-> Forzando actualización inmediata de alertas de tráfico...");
    lastAlertCheckTimestamp = Date.now();
    processTrafficAlerts();
}    
// ===================================================================
// NOMBRE: showProximityAlert
// RESUMEN: Muestra el modal de aviso de proximidad a una alerta de tráfico.
function showProximityAlert(alert) {
    const proximityModal = document.getElementById('proximity-alert-modal');
    if (!proximityModal) return;

    const alertDetails = [
        null, 
        { text: 'ACCIDENTE TRÁFICO', icon: 'PNG/AACCIDENTE.png' },
        { text: 'COCHE AVERIADO', icon: 'PNG/AAVERIADO.png' },
        { text: 'CONTROL TRÁFICO / RADAR', icon: 'PNG/AGUARDIA.png' },
        { text: 'ATASCO', icon: 'PNG/AATASCO.png' },
        { text: 'PELIGRO INDETERMINADO', icon: 'PNG/APELIGRO.png' },
        { text: 'CARRETERA MAL ESTADO', icon: 'PNG/ARESVALAR.png' },
        { text: 'OBRAS', icon: 'PNG/AOBRAS.png' },
        null, 
        { text: 'VÍA / CARRETERA CERRADA', icon: 'PNG/ACERRADA.png' } 
    ][alert.code];

    if (!alertDetails) return;

    proximityModal.innerHTML = `
        <img src="${alertDetails.icon}" alt="${alertDetails.text}">
        <div class="content">
            <span class="alert-text">${alertDetails.text}</span>
            <button id="proximity-ok-button">ENTERADO <span id="proximity-timer">(10)</span></button>
        </div>
    `;

    document.getElementById('flashing-border-overlay').classList.remove('hidden');
    proximityModal.classList.remove('hidden');

    const okButton = document.getElementById('proximity-ok-button');
    const timerSpan = document.getElementById('proximity-timer');
    let countdown = 15;
    
    if (proximityAlertTimer) clearInterval(proximityAlertTimer);
    proximityAlertTimer = setInterval(() => {
        countdown--;
        if (timerSpan) timerSpan.textContent = `(${countdown})`;
        if (countdown <= 0) {
            hideProximityAlert(alert.id);
        }
    }, 1000);
    
    okButton.onclick = () => hideProximityAlert(alert.id);
}
// ===================================================================
// NOMBRE: loadRouteByName (VERSIÓN CORREGIDA)
// RESUMEN: Busca una ruta guardada por su nombre y llama a la función de carga genérica.
function loadRouteByName(routeName, autoStartNavigation = false) {
    const savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
    const recentRoutes = JSON.parse(localStorage.getItem('boardinggate_recent_routes') || "[]");
    let routeToLoad = savedRoutes.find(r => r.name.toUpperCase() === routeName.toUpperCase());
    if (!routeToLoad) {
        routeToLoad = recentRoutes.find(r => r.name.toUpperCase() === routeName.toUpperCase());
    }
    if (routeToLoad) {
        loadRouteFromObject(routeToLoad, autoStartNavigation);
    } else {
        showToast(`No se pudo cargar la ruta "${routeName}". No encontrada`, "error");
        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox) {
           localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresRutaCheckbox.checked));
        }
        const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasRutaCheckbox) {
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasRutaCheckbox.checked));
        }
    }
}
    
   
// ===================================================================
// NOMBRE: generateBackup
// RESUMEN: Genera un código de backup con todos los datos locales y lo copia al portapapeles.
function generateBackup() {
    const backupData = {};
    managedKeys.forEach(key => {
        const value = localStorage.getItem(key);
        if (value !== null) {
            backupData[key] = value;
        }
    });
    const backupString = JSON.stringify(backupData);
    const backupDisplay = document.getElementById('config-backup-display');
    backupDisplay.value = btoa(unescape(encodeURIComponent(backupString)));
    backupDisplay.style.display = 'block';
    backupDisplay.select();
    try {
        document.execCommand('copy');
        showToast('Backup copiado al portapapeles', 'success');
         document.getElementById('config-backup-status').textContent = '¡Copiado! Guarda este código en un lugar seguro.';
         document.getElementById('config-backup-status').style.color = '#28a745';
    } catch (err) {
        showToast('Error al copiar. Por favor, copia manualmente', 'warning');
        document.getElementById('config-backup-status').textContent = 'Copia este código manualmente y guárdalo.';
        document.getElementById('config-backup-status').style.color = '#ffc107';
    }
}

// ===================================================================
// NOMBRE: getManeuverIconFilename
// RESUMEN: Devuelve el nombre del fichero de imagen para una maniobra.
function getManeuverIconFilename(maneuver) {
    if (!maneuver) return 'PNG/continue.png';
    const type = maneuver.type || '';
    const modifier = maneuver.modifier || '';

    if (type.includes('roundabout') && maneuver.exit && maneuver.exit >= 1 && maneuver.exit <= 5 && getManeuverInstructionText(maneuver).toLowerCase().includes("salida")) {
        return `PNG/S${maneuver.exit}.PNG`;
    }
    if (type === 'depart') return 'PNG/depart.png';
    if (type === 'arrive') return 'PNG/arrive.png';
    if (type.includes('roundabout') || type.includes('rotary')) return 'PNG/roundabout.png';
    
    if (modifier.includes('uturn')) return 'PNG/uturn.png';
    if (modifier.includes('sharp right')) return 'PNG/sharp-right.png';
    if (modifier.includes('sharp left')) return 'PNG/sharp-left.png';
    if (modifier.includes('slight right') || modifier.includes('bear right')) return 'PNG/bear-right.png';
    if (modifier.includes('slight left') || modifier.includes('bear left')) return 'PNG/bear-left.png';
    if (modifier.includes('right')) return 'PNG/turn-right.png';
    if (modifier.includes('left')) return 'PNG/turn-left.png';
    if (modifier.includes('ramp')) return 'PNG/ramp.png';
    return 'PNG/continue.png'; 
}
    
// ===================================================================
// NOMBRE: getSuggestedRouteName
// RESUMEN: Sugiere un nombre de ruta por defecto basado en la ubicación final.
async function getSuggestedRouteName(lat, lng, isMultiStage = false, totalWaypoints = 0) {
    let baseName = `RUTA: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
    try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=1&accept-language=es`);
        if (response.ok) {
            const data = await response.json();
            if (data.address) {
                const road = data.address.road;
                const city = data.address.city || data.address.town || data.address.village || data.address.hamlet;
                if (road && city) baseName = `${road}, ${city}`;
                else if (city) baseName = city;
                else if (road) baseName = road;
            }
        }
    } catch (e) {
    }
    if (isMultiStage) {
        const numStages = Math.max(0, totalWaypoints - 1);
        return `${numStages} ETAPAS: ${baseName}`;
    } else {
        return `  ${baseName}`;
    }
}
    
// ===================================================================
// NOMBRE: initializeConfigModalListeners
// RESUMEN: Asigna los listeners a todos los elementos interactivos del modal de configuración.
function initializeConfigModalListeners() {
    document.getElementById('config-save-user-firebase')?.addEventListener('click', validateAndSaveUserToFirebase);
    document.getElementById('config-save-user-firebase-from-backup-tab')?.addEventListener('click', validateAndSaveUserToFirebase);
    document.getElementById('config-restore-backup-firebase')?.addEventListener('click', restoreBackupFromFirebase);
    document.getElementById('config-save-pin')?.addEventListener('click', savePinSettings);
    document.getElementById('config-remove-pin')?.addEventListener('click', removePinSettings);
    document.getElementById('config-generate-backup')?.addEventListener('click', generateBackup);
    document.getElementById('config-restore-backup')?.addEventListener('click', restoreBackup);
    document.getElementById('config-restore-grid-button')?.addEventListener('click', restoreOriginalGrid);
    document.getElementById('config-clear-cache')?.addEventListener('click', clearAllLocalData);

    const importBtn = document.getElementById('import-radars-button');
    if (importBtn && !importBtn.dataset.listenerAttached) {
        importBtn.addEventListener('click', importRadars);
        importBtn.dataset.listenerAttached = "true";
    }

    const deleteBtn = document.getElementById('delete-filtered-radars-button');
    if (deleteBtn && !deleteBtn.dataset.listenerAttached) {
        deleteBtn.addEventListener('click', deleteFilteredRadars);
        deleteBtn.dataset.listenerAttached = "true";
    }

    const acceptTermsButton = document.getElementById('accept-terms-button');
    if (acceptTermsButton && !acceptTermsButton.dataset.listenerAttached) {
        acceptTermsButton.addEventListener('click', () => {
            localStorage.setItem('termsAccepted_v1', 'true');
            showToast('Normas aceptadas. Gracias.', 'success');
            const modal = document.getElementById('config-modal');
            if (modal) {
                modal.querySelectorAll('.config-tab-button').forEach(btn => {
                    btn.disabled = false;
                    btn.style.cursor = 'pointer';
                    btn.style.opacity = '1';
                });
                modal.querySelector('.config-tab-button[data-tab-target="#tab-content-normas"]').classList.remove('active');
                modal.querySelector('#tab-content-normas').classList.remove('active');
                modal.querySelector('.config-tab-button[data-tab-target="#tab-content-usuario"]').classList.add('active');
                modal.querySelector('#tab-content-usuario').classList.add('active');
            }
        });
        acceptTermsButton.dataset.listenerAttached = "true";
    }
    
    const directToNavCheckbox = document.getElementById('config-direct-to-nav');
    if (directToNavCheckbox && !directToNavCheckbox.dataset.listenerAttached) {
        directToNavCheckbox.addEventListener('change', () => {
            localStorage.setItem(DIRECT_TO_NAVIGATION_KEY, JSON.stringify(directToNavCheckbox.checked));
            showToast('Preferencia de inicio directo al mapa guardada.', 'success', 2000);
        });
        directToNavCheckbox.dataset.listenerAttached = "true";
    }
    const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
    if (autoBackupCheckbox && !autoBackupCheckbox.dataset.listenerAttached) {
        autoBackupCheckbox.addEventListener('change', () => {
            localStorage.setItem('boardinggate_autoBackupOnLoad', JSON.stringify(autoBackupCheckbox.checked));
            showToast(`Copia de seguridad automática al inicio: ${autoBackupCheckbox.checked ? 'Activada' : 'Desactivada'}`, 'info', 3000);
        });
        autoBackupCheckbox.dataset.listenerAttached = "true";
    }
}
    
    // ===================================================================
    // NOMBRE: parseUserId
    // RESUMEN: Analiza el ID de usuario para detectar si es un usuario móvil y extrae el ID principal.
    function parseUserId(rawUserId) {
        if (!rawUserId) {
            return { primaryId: null, isMobile: false, originalId: null };
        }
        const mobileRegex = /^(.*?)@(MÓVIL|MOVIL)$/i;
        const match = rawUserId.trim().match(mobileRegex);
        if (match && match[1]) {
            return {
                primaryId: match[1].trim(),
                isMobile: true,
                originalId: rawUserId.trim()
            };
        } else {
            return {
                primaryId: rawUserId.trim(),
                isMobile: false,
                originalId: rawUserId.trim()
            };
        }
    }
       
    // ===================================================================
    // NOMBRE: markCacheAsDirty
    // RESUMEN: Actualiza un timestamp para marcar que la caché local ha sido modificada.
    function markCacheAsDirty() {
        localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
    }

    // ===================================================================
    // NOMBRE: promptForBackupPassword
    // RESUMEN: Muestra un modal para que el usuario introduzca un PIN de seguridad para backups.
    function promptForBackupPassword(message, onConfirm, onCancel, isSettingPassword = false) {
        const existingModal = document.getElementById('backup-password-modal-overlay');
        if (existingModal) existingModal.remove();
        const modalOverlay = document.createElement('div');
        modalOverlay.id = 'backup-password-modal-overlay';
        modalOverlay.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85); display: flex; justify-content: center;
            align-items: center; z-index: 9999;
        `;
        const modalContent = document.createElement('div');
        modalContent.id = 'backup-password-modal-content';
        modalContent.style.cssText = `
            background-color: #DAC8A0; padding: 2rem; border-radius: 0.75rem;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4); text-align: center; border: 1px solid #A0522D;
            margin-top: -50px;
            max-width: 350px; width: 90%;
        `;
        modalContent.innerHTML = `
            <h2 style="font-size: 1.5rem; font-weight: bold; color: #333; margin-bottom: 1rem;">${message}</h2>
            <input type="password" id="backup-password-input" maxlength="6" pattern="\\d{6}" inputmode="numeric" style="
                width: 150px; padding: 0.8rem; font-size: 1.8rem; text-align: center;
                border: 2px solid #A0522D; border-radius: 0.25rem; margin-bottom: 1.5rem;
                letter-spacing: 0.5em; background-color: #f0f0e0;
            " required>
            ${isSettingPassword ? `
                <label for="backup-password-confirm" style="display: block; font-size: 1.1rem; color: #444; margin-bottom: 0.8rem;">Confirmar PIN:</label>
                <input type="password" id="backup-password-confirm" maxlength="6" pattern="\\d{6}" inputmode="numeric" style="
                    width: 150px; padding: 0.8rem; font-size: 1.8rem; text-align: center;
                    border: 2px solid #A0522D; border-radius: 0.25rem; margin-bottom: 1.5rem;
                    letter-spacing: 0.5em; background-color: #f0f0e0;
                " required>
            ` : ''}
            <p id="backup-password-error" style="color: #dc3545; font-weight: bold; margin-top: -0.5rem; margin-bottom: 1rem; min-height: 1.2em;"></p>
            <div style="display:flex; justify-content: space-around; gap:1rem;">
                <button id="backup-password-submit" style="padding: 0.8rem 1.5rem; font-size: 1.2rem; background-color: #28a745; color: white; border: none; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; flex: 1;">Aceptar</button>
                <button id="backup-password-cancel" style="padding: 0.8rem 1.5rem; font-size: 1.2rem; background-color: #6c757d; color: white; border: none; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; flex: 1;">Cancelar</button>
            </div>
        `;
        document.body.appendChild(modalOverlay);
        modalOverlay.appendChild(modalContent);
        const pinInput = document.getElementById('backup-password-input');
        const pinConfirmInput = document.getElementById('backup-password-confirm');
        const errorEl = document.getElementById('backup-password-error');
        const submitBtn = document.getElementById('backup-password-submit');
        const cancelBtn = document.getElementById('backup-password-cancel');
        pinInput.focus();
        const validateAndSubmit = () => {
            errorEl.textContent = '';
            const pin = pinInput.value;
            if (!/^\d{6}$/.test(pin)) {
                errorEl.textContent = 'El PIN debe ser de 6 dígitos numéricos.';
                if (navigator.vibrate) navigator.vibrate(100);
                return;
            }
            if (isSettingPassword) {
                const confirmPin = pinConfirmInput.value;
                if (pin !== confirmPin) {
                    errorEl.textContent = 'Los PINs no coinciden.';
                    if (navigator.vibrate) navigator.vibrate(100);
                    return;
                }
            }
            modalOverlay.remove();
            onConfirm(pin);
        };
        submitBtn.addEventListener('click', validateAndSubmit);
        cancelBtn.addEventListener('click', () => {
            modalOverlay.remove();
            onCancel();
        });
        pinInput.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                if (isSettingPassword && pinConfirmInput) {
                    pinConfirmInput.focus();
                } else {
                    validateAndSubmit();
                }
            }
        });
        if (isSettingPassword && pinConfirmInput) {
            pinConfirmInput.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') {
                    validateAndSubmit();
                }
            });
        }
        addModalAutoCloseTimer(modalOverlay, submitBtn, 'backup-password-modal', isSettingPassword ? 90000 : 30000);
    }
     
// ===================================================================
// NOMBRE: callFirebase (VERSIÓN CORREGIDA - CON MERGE:TRUE)
// RESUMEN: Encapsula las llamadas a Firestore, ahora usando { merge: true } para evitar borrar campos.
async function callFirebase(action, data) {
    if (!window.db || !window.doc || !window.setDoc || !window.getDoc || !window.collection) {
        console.error("Firebase Firestore SDK functions no están expuestas globalmente.");
        return { status: "error", message: "Error interno: Funciones de Firebase no están disponibles." };
    }
    const userId = data.userId;
    if (!userId) {
        return { status: "error", message: "ID de Usuario es obligatorio para las operaciones de Firebase." };
    }
    try {
        const userDocRef = window.doc(window.db, "user_data", userId);
        if (action === 'saveUser') {
            const documentData = {
                usuario: data.usuario,
                modelo: data.modelo || '',
                anio: data.anio || '',
                provincia: data.provincia || '',
                rss: data.rss || false,
                contenidoCacheCompleto: JSON.stringify(data.datosCache),
                fechaBackup: new Date().toISOString(),
                backupPassword: data.backupPassword || null
            };
            
            await window.setDoc(userDocRef, documentData, { merge: true });

            return { status: "success", message: "Datos guardados en Firebase." };
        } else if (action === 'getUserData') {
            const docSnap = await window.getDoc(userDocRef);
            if (docSnap.exists()) {
                const firebaseData = docSnap.data();
                try {
                    firebaseData.contenidoCacheCompleto = JSON.parse(firebaseData.contenidoCacheCompleto);
                } catch (e) {
                    console.error("Error al parsear contenidoCacheCompleto de Firebase:", e);
                }
                return { status: "success", message: "Datos recuperados de Firebase.", data: firebaseData };
            } else {
                return { status: "not_found", message: "No se encontró ningún backup para ese ID de Usuario." };
            }
        } else if (action === 'checkUserExists') {
             const docSnap = await window.getDoc(userDocRef);
             return { status: "success", exists: docSnap.exists() };
        } else {
            return { status: "error", message: "Acción de Firebase no reconocida." };
        }
    } catch (error) {
        console.error("Error en la operación de Firebase:", error);
        return { status: "error", message: `Error de Firebase: ${error.message}` };
    }
}   
    
    
// ===================================================================
// NOMBRE: validateAndSaveUserToFirebase (VERSIÓN CORREGIDA - ANTI RACE CONDITION)
// RESUMEN: Valida, pide PIN y guarda. Ahora, antes de guardar, relee los contadores de sesión para evitar conflictos.
async function validateAndSaveUserToFirebase() {
    const statusEl = document.getElementById('config-user-status');
    const userIdInput = document.getElementById('user-id');
    const { primaryId, isMobile, originalId } = parseUserId(userIdInput.value);

    if (primaryId && primaryId.toUpperCase() === 'ALERTAS') {
        statusEl.textContent = 'El nombre de usuario "ALERTAS" está reservado para el sistema. Por favor, elige otro.';
        statusEl.style.color = '#EF4444';
        showToast('Nombre de usuario no permitido', 'error');
        return;
    }

    if (!primaryId) {
        statusEl.textContent = 'El ID de Usuario es obligatorio.';
        statusEl.style.color = '#EF4444';
        return;
    }
    statusEl.textContent = 'Validando y preparando guardado...';
    statusEl.style.color = '#17a2b8';
    const toastId = "firebase-save-toast";
    showToast('Validando en la nube...', 'info', 0, false, toastId);

    const currentLocalUserId = localStorage.getItem('userData_userId');
    const hasChangedUser = originalId.toLowerCase() !== (currentLocalUserId || '').toLowerCase();

    if (hasChangedUser) {
        const checkResult = await callFirebase('checkUserExists', { userId: primaryId });
        if (checkResult.status === 'success' && checkResult.exists) {
            const userWantsToRestore = confirm(`Se ha encontrado una copia de seguridad para el usuario "${primaryId}".\n\n¿Deseas recuperar esa copia de seguridad?\n\n¡ATENCIÓN! Si dices que sí, se sobreescribirán todos tus datos locales actuales.`);
            if (userWantsToRestore) {
                document.getElementById('restore-user-id').value = originalId;
                await restoreBackupFromFirebase();
                const existingToast = document.getElementById(toastId);
                if (existingToast) existingToast.remove();
                return; 
            } else {
                showToast("Restauración cancelada. Se guardarán los datos actuales con el nuevo nombre de usuario.", "info");
            }
        }
    }

    const localBackupPassword = localStorage.getItem('userData_backupPassword');
    const completeSaveProcess = async (finalBackupPin) => {
        localStorage.setItem('userData_userId', originalId);
        localStorage.setItem('userData_teslaModel', document.getElementById('tesla-model').value.trim());
        localStorage.setItem('userData_teslaYear', document.getElementById('tesla-year').value.trim());
        localStorage.setItem('userData_teslaProvince', document.getElementById('tesla-province').value.trim());
        localStorage.setItem('userData_allowDMs', JSON.stringify(document.getElementById('allow-dms').checked));
        localStorage.setItem('boardinggate_autoBackupOnLoad', JSON.stringify(document.getElementById('config-auto-backup-on-load').checked));
        localStorage.setItem('userData_backupPassword', finalBackupPin);
        updateUserIdDisplay();
        
        const sessionDataResult = await callFirebase('getUserData', { userId: primaryId });
        const currentSessionData = {
            map_sessions_total: 0,
            map_sessions_month: 0,
            map_sessions_last_month: "0000-00"
        };
        if (sessionDataResult.status === 'success' && sessionDataResult.data) {
            currentSessionData.map_sessions_total = sessionDataResult.data.map_sessions_total || 0;
            currentSessionData.map_sessions_month = sessionDataResult.data.map_sessions_month || 0;
            currentSessionData.map_sessions_last_month = sessionDataResult.data.map_sessions_last_month || "0000-00";
        }
        const cacheData = {};
        managedKeys.forEach(key => {
            const value = localStorage.getItem(key);
            if (value !== null) cacheData[key] = value;
        });
        
        const saveData = {
            userId: primaryId,
            usuario: primaryId,
            modelo: localStorage.getItem('userData_teslaModel') || '',
            anio: localStorage.getItem('userData_teslaYear') || '',
            provincia: localStorage.getItem('userData_teslaProvince') || '',
            rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
            datosCache: cacheData,
            backupPassword: finalBackupPin,
            fechaBackup: new Date().toISOString(),
            // Usamos los contadores recién leídos para evitar el conflicto
            map_sessions_total: currentSessionData.map_sessions_total,
            map_sessions_month: currentSessionData.map_sessions_month,
            map_sessions_last_month: currentSessionData.map_sessions_last_month
        };
        
        const saveResult = await callFirebase('saveUser', saveData);
        
        const existingToast = document.getElementById(toastId);
        if (existingToast) existingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== toastId);
        
        if (saveResult.status === 'success') {
            const successMsg = isMobile ?
                `Datos sincronizados con el usuario "${primaryId}".` :
                "Datos guardados en la nube y localmente.";
            statusEl.textContent = successMsg;
            statusEl.style.color = '#28a745';
            showToast(successMsg, 'success');
            localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
        } else {
            statusEl.textContent = `Error al guardar: ${saveResult.message}. (Datos guardados localmente).`;
            statusEl.style.color = '#EF4444';
            showToast(`Error al guardar: ${saveResult.message}`, 'error');
        }
    };
    if (!hasChangedUser && localBackupPassword) {
        await completeSaveProcess(localBackupPassword);
    } else {
        const checkResult = await callFirebase('checkUserExists', { userId: primaryId });
        if (checkResult.status === 'error') {
            statusEl.textContent = `Error al verificar usuario en la nube: ${checkResult.message}.`;
            statusEl.style.color = '#EF4444';
            return;
        }
        if (checkResult.exists) {
            promptForBackupPassword(
                `Introduce el PIN para "${primaryId}":`,
                async (enteredPin) => {
                    const retrieveResult = await callFirebase('getUserData', { userId: primaryId });
                    if (retrieveResult.status === 'success' && retrieveResult.data && retrieveResult.data.backupPassword === enteredPin) {
                        await completeSaveProcess(enteredPin);
                    } else {
                        statusEl.textContent = 'PIN incorrecto. Guardado cancelado.';
                        statusEl.style.color = '#EF4444';
                        showToast('PIN incorrecto. Acceso denegado.', 'error');
                    }
                },
                () => { statusEl.textContent = 'Guardado cancelado.'; statusEl.style.color = '#6c757d'; }
            );
        } else {
            if (isMobile) {
                statusEl.textContent = `El usuario primario "${primaryId}" no existe. No se puede sincronizar.`;
                statusEl.style.color = '#EF4444';
                return;
            }
            promptForBackupPassword(
                'Nuevo usuario. Establece un PIN de 6 dígitos:',
                (pin) => completeSaveProcess(pin),
                () => { statusEl.textContent = 'Guardado cancelado.'; statusEl.style.color = '#6c757d'; },
                true
            );
        }
    }
}    
// ===================================================================
// NOMBRE: restoreBackupFromFirebase
// RESUMEN: Recupera y aplica un backup de datos desde Firebase, pidiendo PIN para confirmar.
async function restoreBackupFromFirebase(isAutoLoad = false) {
    const statusEl = document.getElementById('config-restore-status');
    const { primaryId, isMobile, originalId } = parseUserId(document.getElementById('restore-user-id').value || localStorage.getItem('userData_userId'));
    if (!primaryId) {
        if (!isAutoLoad) statusEl.textContent = 'Introduce un ID de Usuario para recuperar.';
        if (!isAutoLoad) statusEl.style.color = '#EF4444';
        return;
    }
    if (!isAutoLoad) {
        statusEl.textContent = `Buscando backup para "${primaryId}"...`;
        statusEl.style.color = '#17a2b8';
        showToast(`Recuperando backup de "${primaryId}"...`, 'info', 0, false, "firebase-restore-toast");
    }
    const result = await callFirebase('getUserData', { userId: primaryId });
    if (!isAutoLoad) {
        const existingToast = document.getElementById("firebase-restore-toast");
        if (existingToast) existingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== "firebase-restore-toast");
    }
    if (result.status === 'success' && result.data) {
        const firebaseData = result.data;
        const backupCacheData = firebaseData.contenidoCacheCompleto;
        if (!backupCacheData) {
            if (!isAutoLoad) {
                statusEl.textContent = `El backup para "${primaryId}" no contiene datos de caché.`;
                statusEl.style.color = '#EF4444';
                showToast('Backup incompleto.', 'error');
            }
            return;
        }
        const applyChanges = () => {
            const currentUserIdentity = localStorage.getItem('userData_userId') || originalId;
            for (const key in backupCacheData) {
                if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                    localStorage.setItem(key, backupCacheData[key]);
                }
            }
            localStorage.setItem('userData_userId', currentUserIdentity);
            const newTimestamp = Date.now().toString();
            localStorage.setItem('lastCacheUpdateTimestamp', newTimestamp);
            if (isMobile) {
                lastMobileSyncTimestamp = parseInt(newTimestamp);
            }
            showToast('Restauración completada. Recargando...', 'success', 3000);
            setTimeout(() => location.reload(), 2500);
        };
        if (isAutoLoad) {
            applyChanges();
        } else {
            promptForBackupPassword(
                `Introduce el PIN para "${primaryId}":`,
                (enteredPin) => {
                    if (enteredPin === firebaseData.backupPassword) {
                        if (confirm(`Backup para "${primaryId}" desbloqueado.\n\n¿Estás seguro de que quieres restaurar estos datos?\n\n¡ATENCIÓN! Se sobreescribirán TODOS tus datos locales actuales (grid, recordatorios, etc.). Esta acción NO se puede deshacer.`)) {
                            applyChanges();
                        } else {
                            statusEl.textContent = 'Restauración cancelada.';
                            statusEl.style.color = '#6c757d';
                            showToast("Restauración cancelada por el usuario.", "info");
                        }
                    } else {
                        statusEl.textContent = 'PIN incorrecto. Restauración cancelada.';
                        statusEl.style.color = '#EF4444';
                        showToast('PIN incorrecto.', 'error');
                    }
                },
                () => {
                    statusEl.textContent = 'Restauración cancelada.';
                    statusEl.style.color = '#6c757d';
                }
            );
        }
    } else if (result.status === 'not_found' && !isAutoLoad) {
        statusEl.textContent = `No se encontró backup para "${primaryId}".`;
        statusEl.style.color = '#EF4444';
        showToast('Backup no encontrado.', 'error not-found');
    } else if (!isAutoLoad) {
        statusEl.textContent = `Error al recuperar: ${result.message}`;
        statusEl.style.color = '#EF4444';
        showToast(`Error de recuperación: ${result.message}`, 'error');
    }
}
    
    // ===================================================================
    // NOMBRE: getRandomSpeedMultiplierForManeuver
    // RESUMEN: Devuelve un multiplicador aleatorio de velocidad para simular variaciones en las maniobras.
    function getRandomSpeedMultiplierForManeuver(maneuver) {
        const type = maneuver.type || '';
        const modifier = maneuver.modifier || '';
        let min, max;
        if (type === 'roundabout' || type === 'rotary' || modifier.includes('sharp') || modifier.includes('uturn')) {
            min = -0.40;
            max = 0.20;
        } else if (type === 'turn' || type === 'fork' || type === 'merge' || type === 'end of road') {
            min = -0.30;
            max = 0.10;
        } else {
            min = -0.25;
            max = 0.35;
        }
        return Math.random() * (max - min) + min;
    }

// ===================================================================
// NOMBRE: hideIntersectionPreviewMap
// RESUMEN: Oculta el minimapa de previsualización de la intersección.
function hideIntersectionPreviewMap() {
    const card = document.getElementById('intersection-preview-map-window');
    if (card) {
        card.classList.add('hidden');
        const rotator = card.querySelector('#intersection-rotator');
        if (rotator) {
            rotator.style.transform = 'rotate(0deg)';
        }
        miniMapOffsetActive.x = 0;
        targetMapCenterOffset.x -= miniMapOffsetActive.x;
    }
    if (intersectionPreviewTimer) {
        clearTimeout(intersectionPreviewTimer);
        intersectionPreviewTimer = null;
    }
}
// ===================================================================
// NOMBRE: addRouteToRecents (MODIFICADA - LÍMITE DE 3)
// RESUMEN: Añade una ruta o destino al historial, evitando duplicados por nombre
function addRouteToRecents(routeObject) {
    if (!routeObject || !routeObject.waypoints || routeObject.waypoints.length < 1) {
        return;
    }
    const RECENT_ROUTES_KEY = 'boardinggate_recent_routes';
    const MAX_RECENT_ROUTES = 3; 
    let recentRoutes = [];
    try {
        recentRoutes = JSON.parse(localStorage.getItem(RECENT_ROUTES_KEY)) || [];
    } catch (e) {
        recentRoutes = [];
    }

    const finalAddress = routeObject.waypoints[routeObject.waypoints.length - 1]?.address || 'destino desconocido';
    const simplifiedRoute = {
        name: routeObject.name || `Ruta a ${finalAddress}`,
        waypoints: routeObject.waypoints.map(wp => ({
            lat: wp.lat,
            lng: wp.lng,
            address: wp.address
        })),
        timestamp: new Date().toISOString()
    };

    const uniqueRecentRoutes = recentRoutes.filter(item => item.name !== simplifiedRoute.name);
    
    uniqueRecentRoutes.unshift(simplifiedRoute);
    const finalRecentRoutes = uniqueRecentRoutes.slice(0, MAX_RECENT_ROUTES);
    localStorage.setItem(RECENT_ROUTES_KEY, JSON.stringify(finalRecentRoutes));
}    

// ===================================================================
// NOMBRE: addModalAutoCloseTimer
// RESUMEN: Añade un temporizador de autocierre a un modal.
function addModalAutoCloseTimer(modalElement, closeButtonElement, modalId, duration = 90000) {
    if (!modalElement || !closeButtonElement || !modalId) {
        return;
    }
    modalElement.dataset.modalTimerId = modalId;
    clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId);
    let countdown = duration / 1000;
    const originalButtonText = closeButtonElement.textContent.split(' (')[0];
    const countdownSpanId = `modal-countdown-${modalId}`;
    let countdownSpan = closeButtonElement.querySelector(`.button-countdown-timer`);
    if (!countdownSpan) {
        countdownSpan = document.createElement('span');
        countdownSpan.className = 'button-countdown-timer';
        countdownSpan.style.marginLeft = '5px';
        countdownSpan.style.fontWeight = 'normal';
        closeButtonElement.appendChild(countdownSpan);
    }
    countdownSpan.textContent = ` (${countdown})`;
    const intervalId = setInterval(() => {
        countdown--;
        if (countdownSpan && document.body.contains(countdownSpan)) {
          countdownSpan.textContent = ` (${countdown})`;
        }
        if (countdown <= 0) {
            if (globalModalTimers[modalId]) {
                clearInterval(globalModalTimers[modalId].intervalId);
                delete globalModalTimers[modalId];
            }
            if (closeButtonElement && document.body.contains(closeButtonElement)) {
                closeButtonElement.click();
            } else if (modalElement && modalElement.parentNode) {
                 if (!STATIC_MODAL_IDS.includes(modalElement.id)) {
                    modalElement.parentNode.removeChild(modalElement);
                 } else {
                    modalElement.classList.add('hidden');
                 }
            }
        }
    }, 1000);
    const resetTimerHandler = () => {
        if (!globalModalTimers[modalId] || !globalModalTimers[modalId].intervalId) return;
        clearInterval(globalModalTimers[modalId].intervalId);
        countdown = duration / 1000;
        if (countdownSpan && document.body.contains(countdownSpan)) {
           countdownSpan.textContent = ` (${countdown})`;
        }
        const newIntervalId = setInterval(() => {
            countdown--;
            if (countdownSpan && document.body.contains(countdownSpan)) {
                countdownSpan.textContent = ` (${countdown})`;
            }
            if (countdown <= 0) {
                if (globalModalTimers[modalId]) {
                    clearInterval(globalModalTimers[modalId].intervalId);
                    delete globalModalTimers[modalId];
                }
                if (closeButtonElement && document.body.contains(closeButtonElement)) {
                    closeButtonElement.click();
                } else if (modalElement && modalElement.parentNode) {
                    if (!STATIC_MODAL_IDS.includes(modalElement.id)) {
                       modalElement.parentNode.removeChild(modalElement);
                    } else {
                       modalElement.classList.add('hidden');
                    }
                }
            }
        }, 1000);
        globalModalTimers[modalId].intervalId = newIntervalId;
    };
    modalElement.addEventListener('click', resetTimerHandler);
    modalElement.addEventListener('touchstart', resetTimerHandler, { passive: true });
    modalElement.addEventListener('input', resetTimerHandler);
    modalElement.addEventListener('scroll', resetTimerHandler, { passive: true });
    globalModalTimers[modalId] = {
        intervalId: intervalId,
        resetHandler: resetTimerHandler,
        modalElement: modalElement,
        closeButtonElement: closeButtonElement,
        countdownSpan: countdownSpan
    };
}

    
// ===================================================================
// NOMBRE: restoreBackup
// RESUMEN: Restaura los datos locales desde un código de backup manual.
function restoreBackup() {
    const restoreInput = document.getElementById('config-restore-input');
    const backupStringBase64 = restoreInput.value.trim();
    const statusEl = document.getElementById('config-restore-status');
    statusEl.textContent = '';
    if (!backupStringBase64) {
        statusEl.textContent = 'Pega el código de backup primero.';
        statusEl.style.color = '#EF4444';
        return;
    }
    try {
        const backupString = decodeURIComponent(escape(atob(backupStringBase64)));
        const backupData = JSON.parse(backupString);
        let restoredCount = 0;
        let incompatibleCount = 0;
        if (confirm('Esto sobreescribirá tus datos actuales con los del backup. ¿Estás seguro?')) {
            Object.keys(backupData).forEach(key => {
                if (managedKeys.includes(key)) {
                    localStorage.setItem(key, backupData[key]);
                    restoredCount++;
                } else {
                    incompatibleCount++;
                }
            });
            loadCustomData();
            loadSavedSettings();
            updateUserIdDisplay();
            checkReminders();
            statusEl.textContent = `Restauración completada. ${restoredCount} claves restauradas. ${incompatibleCount} claves ignoradas (incompatibles). La página se recargará.`;
            statusEl.style.color = '#28a745';
            showToast('Restauración completada. Recargando...', 'success');
            setTimeout(() => location.reload(), 2500);
        } else {
             statusEl.textContent = 'Restauración cancelada.';
             statusEl.style.color = '#6c757d';
        }
    } catch (e) {
        statusEl.textContent = 'Error: Código de backup inválido o corrupto.';
        statusEl.style.color = '#EF4444';
        showToast('Error en el código de backup', 'error');
    }
}  
    
    // ===================================================================
    // NOMBRE: clearNavigationGraph
    // RESUMEN: Limpia y oculta la gráfica de navegación.
    function clearNavigationGraph() {
        if (graphIntervalTimer) {
            clearInterval(graphIntervalTimer);
            graphIntervalTimer = null;
        }
        if (navigationChart) {
            navigationChart.destroy();
            navigationChart = null;
        }
        const graphCard = document.getElementById('navigation-graph-card');
        if (graphCard) {
            graphCard.classList.add('hidden');
        }
        graphDataPoints = { speed: [], altitude: [] };
        graphLabels = [];
    }
    

// ===================================================================
// NOMBRE: updateTurnByTurnDisplay (VERSIÓN CON TARJETA MÍNIMA Y ETA INTEGRADO)
// RESUMEN: Actualiza la barra de giro y gestiona la visibilidad
function updateTurnByTurnDisplay(route, carDistanceAlongTheRoute = 0) {
    const topInfoBar = document.getElementById('navigation-top-info-bar');
    const intersectionPreviewWindow = document.getElementById('intersection-preview-map-window');
    const helperLeft = document.getElementById('direction-card-izquierda');
    const helperRight = document.getElementById('direction-card-derecha');
    const progressBar = document.getElementById('navigation-bottom-progress-bar');
    const miniNavCard = document.getElementById('mini-nav-info-card'); 

    if (helperLeft) helperLeft.style.display = 'none';
    if (helperRight) helperRight.style.display = 'none';
    
    if (!route || !topInfoBar || !route.legs || route.legs.length === 0) {
        if (topInfoBar) topInfoBar.style.display = 'none';
        if (miniNavCard) miniNavCard.style.display = 'none'; 
        if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
        return;
    }
    if (!isNavigating && (!navigationCurrentRouteData || navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2)) {
         if (topInfoBar) topInfoBar.style.display = 'none';
         if (miniNavCard) miniNavCard.style.display = 'none'; 
         if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
         return;
    }

    topInfoBar.style.display = 'flex';
    const turnIconContainer = document.getElementById('turn-icon-container-styled');
    const turnIconDisplayEl = document.getElementById('turn-icon-display');
    const maneuverTextEl = document.getElementById('maneuver-text-display');
    const distanceFormattedEl = document.getElementById('distance-to-turn-formatted');
    const streetEl = document.getElementById('street-name-display');
    const progressBarEl = document.getElementById('distance-progress-bar-to-turn');
    
    if (turnIconDisplayEl) {
        turnIconDisplayEl.style.width = '100%';
        turnIconDisplayEl.style.height = '100%';
        turnIconDisplayEl.style.display = 'flex';
        turnIconDisplayEl.style.alignItems = 'center';
        turnIconDisplayEl.style.justifyContent = 'center';
    }

    const carDistance = Math.min(Math.max(0, carDistanceAlongTheRoute), route.distance);
    let distanceCoveredInRoute = 0;
    let currentLegIndex = -1, currentStepIndex = -1;
    let distanceToEndOfCurrentStepForProgress = 0;
    let previousStepForPath = null;
    
    for (let i = 0; i < route.legs.length; i++) {
        const leg = route.legs[i];
        for (let j = 0; j < leg.steps.length; j++) {
            const step = leg.steps[j];
            if (carDistance < distanceCoveredInRoute + step.distance) {
                currentLegIndex = i; currentStepIndex = j;
                distanceToEndOfCurrentStepForProgress = distanceCoveredInRoute + step.distance;
                if (j > 0) { previousStepForPath = leg.steps[j - 1]; } 
                else if (i > 0) { previousStepForPath = route.legs[i-1].steps[route.legs[i-1].steps.length - 1]; }
                break;
            }
            distanceCoveredInRoute += step.distance;
        }
        if (currentLegIndex === -1 && i === route.legs.length -1) {
             currentLegIndex = route.legs.length - 1;
             currentStepIndex = route.legs[currentLegIndex].steps.length - 1;
        } else if (currentLegIndex !== -1) {
            break;
        }
    }
    if (currentLegIndex === -1) {
        currentLegIndex = route.legs.length - 1;
        currentStepIndex = route.legs[currentLegIndex].steps.length - 1;
    }

    currentLegIndexNav = currentLegIndex;
    currentStepIndexNav = currentStepIndex;

    const waypointsForRequest = navigationWaypoints.filter(wp => wp);
    
    let finalStepToShow;
    let tempLegIdx = currentLegIndex;
    let tempStepIdx = currentStepIndex + 1;

    while (true) {
        if (tempLegIdx >= route.legs.length) {
            finalStepToShow = route.legs[route.legs.length - 1].steps[route.legs[route.legs.length - 1].steps.length - 1];
            break;
        }

        let leg = route.legs[tempLegIdx];
        if (tempStepIdx >= leg.steps.length) {
            tempLegIdx++;
            tempStepIdx = 0;
            continue;
        }
        
        const candidateStep = leg.steps[tempStepIdx];
        const isArrival = candidateStep.maneuver.type === 'arrive';
        const isDeparture = candidateStep.maneuver.type === 'depart';
        
        const arrivalWaypoint = isArrival ? waypointsForRequest[tempLegIdx + 1] : null; 
        const departureWaypoint = isDeparture ? waypointsForRequest[tempLegIdx] : null;

        if (isArrival && arrivalWaypoint?.isInternal) {
            tempStepIdx++;
            continue;
        } else if (isDeparture && departureWaypoint?.isInternal) {
            tempStepIdx++;
            continue;
        } else {
            finalStepToShow = candidateStep;
            break;
        }
    }
    let nextStepToDisplay = finalStepToShow;

    const currentStepForProgress = route.legs[currentLegIndex].steps[currentStepIndex];
    const distanceToNextManeuver = Math.max(0, distanceToEndOfCurrentStepForProgress - carDistance);
    const distanceIntoCurrentStep = currentStepForProgress.distance - distanceToNextManeuver;
    navigationTargetZoom = compassAndModeControl ? compassAndModeControl.mapViewMode : 'static';

    const now = Date.now();
    const infoOverlay = document.getElementById('map-info-overlay');

    if (!isProgressBarLocked && !isMapImmersiveModeActive && now > progressBarForceShowUntil) {
        const shouldHide = distanceToNextManeuver > 1000 && distanceIntoCurrentStep > 100;
        progressBar.classList.toggle('progress-bar-auto-hidden', shouldHide);
        if (infoOverlay) {
            infoOverlay.style.display = shouldHide ? 'none' : 'block';
        }
        if (miniNavCard) {
            if (shouldHide) {
                const distanceText = distanceToNextManeuver < 1000 ? `${Math.round(distanceToNextManeuver / 5) * 5} m` : `${(distanceToNextManeuver / 1000).toFixed(1)} km`;
                let etaHtml = '';

                const remainingDistanceTotal = Math.max(0, route.distance - carDistanceAlongTheRoute);
                const remainingDurationTotal = route.distance > 0 ? route.duration * (remainingDistanceTotal / route.distance) : 0;
                const currentFinalEta = new Date(Date.now() + remainingDurationTotal * 1000);

                if (isNavigating && tripInitialOverallEtaTime) {
                    const etaText = currentFinalEta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    const finalDeviationMs = currentFinalEta.getTime() - tripInitialOverallEtaTime.getTime();
                    
                    let deviationHtml = '';
                    if (typeof finalDeviationMs === 'number' && !isNaN(finalDeviationMs) && Math.abs(finalDeviationMs) >= 1000) {
                        const totalSeconds = Math.round(Math.abs(finalDeviationMs) / 1000);
                        const minutes = Math.floor(totalSeconds / 60);
                        const seconds = totalSeconds % 60;
                        const sign = finalDeviationMs > 0 ? '+' : '-';
                        
                        const shadowColor = finalDeviationMs > 0 ? 'red' : 'green';
                        
                        const style = `color: white; text-shadow: 0 0 5px ${shadowColor}, 0 0 7px ${shadowColor};`;
                    
                        const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                        deviationHtml = `<span style="${style}">[${sign}${formattedTime}]</span>`;
                    }
                    etaHtml = `<div style="font-size: 0.68em; margin-top: 2px; text-align: center; ">
                       <span>${etaText}</span>
                       <span style="margin-left: 8px;">${deviationHtml}</span>  </div>`;
                   }

                miniNavCard.innerHTML = `
                    <div>${distanceText}</div>
                    ${etaHtml}
                `;
                miniNavCard.style.display = 'block';
                // --- FIN DE LA MODIFICACIÓN ---
            } else {
                miniNavCard.style.display = 'none';
            }
        }
    } else {
        progressBar.classList.remove('progress-bar-auto-hidden');
        if (infoOverlay) {
            infoOverlay.style.display = 'block';
        }
        if (miniNavCard) {
            miniNavCard.style.display = 'none';
        }
    }
    
    if (nextStepToDisplay && nextStepToDisplay.maneuver) {
        const isArrivalManeuver = nextStepToDisplay.maneuver.type === 'arrive';
        const isVeryCloseToArrival = distanceToNextManeuver < 50;
        
        let stepForDisplayText;
        if (isArrivalManeuver && !isVeryCloseToArrival) {
            stepForDisplayText = currentStepForProgress;
        } else {
            stepForDisplayText = nextStepToDisplay;
        }
        
        const maneuver = stepForDisplayText.maneuver;
        const type = maneuver.type || '';
        let maneuverText = "";
        let streetNameText = stepForDisplayText.name || '';
        
        if (maneuver.type === 'arrive') {
            const isFinalLeg = currentLegIndex === route.legs.length - 1;

            if (isFinalLeg) {
                maneuverText = "Ha llegado a su destino";
                streetNameText = '';
            } else {
                const totalStages = navigationWaypoints.filter(wp => !wp.isInternal && !wp.isRecalculatedStart).length - 1;
                const stageNumber = currentLegIndex + 1;
                maneuverText = `Ha llegado a la etapa ${stageNumber} de ${totalStages}`;
                streetNameText = '';
            }
        } else {
            maneuverText = getManeuverInstructionText(maneuver);
            if (type === 'depart' || type.includes('roundabout') || type === 'end of road') {
                streetNameText = '';
            }
        }
        
        if (turnIconDisplayEl) {
            const iconFilename = getManeuverIconFilename(maneuver);
            if (iconFilename !== lastDisplayedManeuverIcon) {
                const iconUrl = `https://boardinggate.github.io/Tesla/${iconFilename}`;
                turnIconDisplayEl.innerHTML = `<img src="${iconUrl}" alt="${maneuverText}" style="width: 95%; height: 95%; object-fit: contain; ">`;
                lastDisplayedManeuverIcon = iconFilename;
            }
        }
        
        maneuverTextEl.textContent = maneuverText ? `${maneuverText} ` : '';
        streetEl.textContent = streetNameText;
        
        distanceToNextManeuverOSRM = distanceToNextManeuver;
        distanceFormattedEl.textContent = distanceToNextManeuver < 1000 ? `${Math.round(distanceToNextManeuver / 5) * 5} m` : `${(distanceToNextManeuver / 1000).toFixed(1)} km`;
        const progressPercent = (currentStepForProgress.distance > 0) ? ((currentStepForProgress.distance - distanceToNextManeuver) / currentStepForProgress.distance) * 100 : (distanceToNextManeuver === 0 ? 100 : 0);
        if(progressBarEl) progressBarEl.style.width = `${Math.min(100, Math.max(0, progressPercent))}%`;

        if (isNavigating && previousStepForPath && navigationMapInstance.getSource('completed-segments') && navigationCurrentLocation) {
             if (previousStepForPath.geometry && previousStepForPath.geometry.coordinates) {
                const segmentGeoJSON = turf.lineString(previousStepForPath.geometry.coordinates);
                if (segmentGeoJSON.geometry.coordinates.length >= 2) {
                    const isNewSegment = !lastProcessedStepManeuverLocation || 
                                         lastProcessedStepManeuverLocation[0] !== previousStepForPath.maneuver.location[0] ||
                                         lastProcessedStepManeuverLocation[1] !== previousStepForPath.maneuver.location[1];
                    if (isNewSegment) {
                        completedSegmentsGeoJSON.features.push(segmentGeoJSON);
                        navigationMapInstance.getSource('completed-segments').setData(completedSegmentsGeoJSON);
                        lastProcessedStepManeuverLocation = previousStepForPath.maneuver.location;
                    }
                }
            }
        }
        
        const isRelevantIntersectionManeuver = type !== 'continue' && type !== 'new name' && type !== 'depart' && type !== 'straight';
        if (isNavigating && distanceToNextManeuver < 800 && distanceToNextManeuver >= 100 && isRelevantIntersectionManeuver && (!intersectionPreviewWindow || intersectionPreviewWindow.classList.contains('hidden') || intersectionPreviewWindow.dataset.source !== 'click') && (currentLegIndex + '_' + currentStepIndex) !== lastAutoShownManeuverId) {
            showIntersectionPreviewMap(nextStepToDisplay, route, false, 10000);
            lastAutoShownManeuverId = currentLegIndex + '_' + currentStepIndex;
        } else if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click' && (distanceToNextManeuver >= 800 || distanceToNextManeuver < 100 || !isRelevantIntersectionManeuver)) {
            hideIntersectionPreviewMap();
        }
        
        const heading = navigationCurrentLocation?.heading;
        const isSouthOriented = heading > 135 && heading <= 225;
        const isEastOriented = heading > 45 && heading <= 135;
        const isWestOriented = heading > 225 && heading <= 315;
        const isNearIntersection = distanceToNextManeuver < 180;

        if (turnIconContainer) {
            turnIconContainer.classList.remove('maneuver-highlight', 'maneuver-highlight-south');
            turnIconContainer.style.backgroundColor = 'white';
            if (isNearIntersection && isNavigating) {
                if (isSouthOriented) {
                    turnIconContainer.classList.add('maneuver-highlight-south');
                    turnIconContainer.style.backgroundColor = 'yellow';
                } else if (isEastOriented || isWestOriented) {
                    turnIconContainer.classList.add('maneuver-highlight');
                    turnIconContainer.style.backgroundColor = 'yellow';
                } else {
                    turnIconContainer.classList.add('maneuver-highlight');
                }
            }
        }

    } else {
        if (turnIconDisplayEl) {
            const iconFilename = 'PNG/arrive.png';
            if (iconFilename !== lastDisplayedManeuverIcon) {
                turnIconDisplayEl.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/arrive.png" style="width:95%; height:95%; object-fit:contain;">`;
                lastDisplayedManeuverIcon = iconFilename;
            }
        }
        maneuverTextEl.textContent = '';
        streetEl.textContent = 'Has llegado a tu destino';
        distanceFormattedEl.textContent = '0 m';
        if(progressBarEl) progressBarEl.style.width = '100%';
        distanceToNextManeuverOSRM = Infinity;
        if (miniNavCard) miniNavCard.style.display = 'none';
        if (intersectionPreviewWindow && !intersectionPreviewWindow.classList.contains('hidden') && intersectionPreviewWindow.dataset.source !== 'click') hideIntersectionPreviewMap();
        if (turnIconContainer) {
            turnIconContainer.classList.remove('maneuver-highlight', 'maneuver-highlight-south');
            turnIconContainer.style.backgroundColor = 'white';
        }
    }
}
    

// ===================================================================
// NOMBRE: hideNavigationUI
// RESUMEN: Oculta los elementos de la interfaz de usuario de navegación.
function hideNavigationUI() {
    const topInfoBar = document.getElementById('navigation-top-info-bar');
    const bottomProgressBar = document.getElementById('navigation-bottom-progress-bar');
    const startNavButton = document.getElementById('start-navigation-button');
    const saveRouteButton = document.getElementById('save-route-button');
    const reorderBtn = document.getElementById('reorder-route-stages-button');
    const simulateBtn = document.getElementById('simulate-route-button');
    const toggleSimulateGpsBtn = document.getElementById('toggle-simulate-gps-button');
    const graphCard = document.getElementById('navigation-graph-card');
    const miniNavCard = document.getElementById('mini-nav-info-card');
    if (topInfoBar) topInfoBar.style.display = 'none';
    if (bottomProgressBar) bottomProgressBar.style.display = 'none';
    if (miniNavCard) miniNavCard.style.display = 'none';
    if (saveRouteButton) saveRouteButton.classList.add('hidden');
    if (reorderBtn) reorderBtn.style.display = 'none';
    if (simulateBtn) simulateBtn.style.display = 'none';
    if (graphCard) graphCard.classList.add('hidden');
    hideIntersectionPreviewMap();
}
    
    // ===================================================================
    // NOMBRE: showNavigationUIElementsForPlanning
    // RESUMEN: Muestra los elementos de la UI para la planificación de rutas.
    function showNavigationUIElementsForPlanning() {
        const topInfoBar = document.getElementById('navigation-top-info-bar');
        const bottomProgressBar = document.getElementById('navigation-bottom-progress-bar');
        if (!navigationCurrentRouteData || !navigationCurrentRouteData.routes || navigationCurrentRouteData.routes.length === 0 || navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
            if (topInfoBar) topInfoBar.style.display = 'none';
            if (bottomProgressBar) bottomProgressBar.style.display = 'none';
            hideMapInfoOverlay();
            hideIntersectionPreviewMap();
        } else {
            if (topInfoBar) topInfoBar.style.display = 'flex';
            if (bottomProgressBar) bottomProgressBar.style.display = 'flex';
            let carDistAlongRoutePlan = 0;
            const currentCarPosForShowUI = navigationCurrentLocation;
            if (currentCarPosForShowUI && navigationMapInstance && navigationCurrentRouteData.routes[0] && typeof turf !== 'undefined') {
                try {
                    const carPointTurf = turf.point([currentCarPosForShowUI.longitude, currentCarPosForShowUI.latitude]);
                    const routeLineStringTurf = turf.lineString(navigationCurrentRouteData.routes[0].geometry.coordinates);
                    const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                    const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                    carDistAlongRoutePlan = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                } catch(e){  }
             }
            updateTurnByTurnDisplay(navigationCurrentRouteData.routes[0], carDistAlongRoutePlan);
            showDestinationName();
        }
    }
     
    // ===================================================================
    // NOMBRE: getManeuverInstructionText
    // RESUMEN: Convierte una maniobra de OSRM en un texto legible.
    function getManeuverInstructionText(maneuver) {
        if (!maneuver) return '';
        const type = maneuver.type || '';
        const modifier = maneuver.modifier || '';
        let exit = maneuver.exit;
        let key = `${type}-${modifier}`;
        let text = maneuverTexts[key];
        if (!text) {
            key = `${type}-`;
            text = maneuverTexts[key];
        }
        if (!text && type === 'turn' && !modifier) {
            text = maneuverTexts['turn-'] || type.replace(/-/g, ' ');
        } else if (!text) {
            text = type.replace(/-/g, ' ');
        }
        const roundaboutExitTypes = ['roundabout turn', 'exit roundabout', 'rotary', 'roundabout'];
        if (roundaboutExitTypes.includes(type) && typeof exit === 'number' && exit > 0) {
             const ordinals = ["", "primera", "segunda", "tercera", "cuarta", "quinta"];
             const ordinalText = (exit >= 1 && exit <= 5) ? ordinals[exit] : `${exit}ª`;
             text = `Sal en la rotonda en la ${ordinalText} salida`;
        }
        let baseText = text.charAt(0).toUpperCase() + text.slice(1);
        return baseText;
    }  
    
// ===================================================================
// NOMBRE: formatDeviation
// RESUMEN: Formatea la desviación de tiempo ETA con signo y color.
function formatDeviation(milliseconds) {
    if (typeof milliseconds !== 'number' || isNaN(milliseconds)) {
        return '';
    }
    if (Math.abs(milliseconds) < 1000) {
        return `<span class="eta-deviation">[00:00]</span>`;
    }
    const totalSeconds = Math.round(Math.abs(milliseconds) / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const sign = milliseconds > 0 ? '+' : '-';
    const colorClass = milliseconds > 0 ? 'positive' : 'negative';
    const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    return `<span class="eta-deviation ${colorClass}">[${sign}${formattedTime}]</span>`;
}    
    
    // ===================================================================
    // NOMBRE: parseCoordinateFilter
    // RESUMEN: Parsea y aplica un filtro de coordenadas (valor único o rango).
   function parseCoordinateFilter(filterValue, coordinate) {
        if (!filterValue) return true;
        const parts = filterValue.trim().split(/\s+/).map(s => parseFloat(s.replace(',','.'))).filter(n => !isNaN(n));
        if (parts.length === 1) {
            return Math.abs(coordinate - parts[0]) < COORD_EPSILON;
        } else if (parts.length === 2) {
            const minVal = Math.min(parts[0], parts[1]);
            const maxVal = Math.max(parts[0], parts[1]);
            return coordinate >= minVal && coordinate <= maxVal;
        } else if (parts.length === 0 && filterValue.trim() !== "") {
            return false;
        }
        return true;
    }
    
// ===================================================================
// NOMBRE: closeOtherModals (VERSIÓN CORREGIDA Y DEFINITIVA)
// RESUMEN: Se ha eliminado 'address-suggestions-modal' de la lista
//          de modales a cerrar para evitar que se oculte por error.
function closeOtherModals(modalToKeepOpenId = null) {
    const STATIC_MODAL_IDS = ['config-modal', 'versions-modal-overlay', 'pin-modal-overlay', 'reorder-stages-modal', 'simulation-modal', 'locations-preview-modal', 'deviation-modal', 'arrival-stats-modal', 'simulation-speed-modal'];

    STATIC_MODAL_IDS.forEach(id => {
        if (id === modalToKeepOpenId) return;
        const modal = document.getElementById(id);
        if (modal && !modal.classList.contains('hidden')) {
            if (id === 'reorder-stages-modal') {
                const listElement = modal.querySelector('#sortable-stages-list');
                if (listElement) {
                    listElement.removeEventListener('dragstart', handleDragStartReorder);
                    listElement.removeEventListener('dragend', handleDragEndReorder);
                    listElement.removeEventListener('dragover', handleDragOverReorder);
                    listElement.removeEventListener('touchstart', handleStageTouchStart);
                    listElement.removeEventListener('touchmove', handleStageTouchMove);
                    listElement.removeEventListener('touchend', handleStageTouchEnd);
                    listElement.removeEventListener('touchcancel', handleStageTouchEnd);
                }
                if (draggedStageLi) {
                    draggedStageLi.classList.remove('dragging');
                    draggedStageLi = null;
                }
                clearTimeout(stageScrollTimeout);
                document.body.style.overflow = '';
            }
             if (id === 'deviation-modal') {
                if (deviationModalTimerId) clearInterval(deviationModalTimerId);
                deviationModalTimerId = null;
                isDeviationModalActive = false;
            }
             if (id === 'arrival-stats-modal') {
                const acceptButton = modal.querySelector('#arrival-stats-accept-button');
                if (acceptButton) clearModalAutoCloseTimer(modal, acceptButton, 'arrival-stats-modal');
             }
             if (id === 'simulation-speed-modal') {
                const confirmBtn = modal.querySelector('#confirm-navigation-simulation');
                if(confirmBtn) clearModalAutoCloseTimer(modal, confirmBtn, 'simulation-speed-modal');
             }
            modal.classList.add('hidden');
            const closeBtn = modal.querySelector('button[id^="close-"], button[id*="-close"], #cancel-postpone, #close-saved-routes-modal, #cancel-reorder-stages, #config-close-modal, #close-versions-modal, #pin-submit-button, #close-simulation-modal, #close-locations-preview, #deviation-accept, #arrival-stats-accept-button, #cancel-simulation-speed');
            if (closeBtn) clearModalAutoCloseTimer(modal, closeBtn, id.replace(/-/g, '_') || `modal_timer_${Date.now()}`);
             if (id === 'simulation-modal') {
                 if (simulationModalTimer) {
                     clearTimeout(simulationModalTimer);
                     simulationModalTimer = null;
                 }
                 hideIntersectionPreviewMap();
             }
        }
    });
    document.querySelectorAll(
        '.choice-modal, .edit-modal, .edit-info-modal, .help-modal, .reminder-modal, .reminder-table-modal, #postpone-options-modal, .saved-locations-modal, #reminders-map-help-modal-instance'
    ).forEach(m => {
        if (m.id === modalToKeepOpenId) return;
        if (m.parentNode) {
             const closeBtn = m.querySelector('button[id^="close-"], button[id*="-close"], #cancel-postpone');
             if(closeBtn) clearModalAutoCloseTimer(m, closeBtn, m.id.replace(/-/g, '_') || `modal_timer_${Date.now()}`);
             m.remove();
        }
    });
     if (modalToKeepOpenId !== 'unified-reminder-window') {
        hideUnifiedReminderWindow();
     }
}    
// ===================================================================
// NOMBRE: showConfigModal (MODIFICADA - MUESTRA ESTADO DE SESIÓN)
// RESUMEN: Muestra el modal de configuración principal, incluyendo la hora de inicio de la sesión de mapa activa.
function showConfigModal() {
    closeOtherModals('config-modal');
    const modal = document.getElementById('config-modal');
    if (!modal) return;

    const sessionStatusEl = document.getElementById('map-session-status');
    if (sessionStatusEl) {
        if (mapSessionStartTime) {
            const sessionDate = new Date(mapSessionStartTime);
            const formattedTime = sessionDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            sessionStatusEl.textContent = `(Sesión de mapa abierta: ${formattedTime})`;
        } else {
            sessionStatusEl.textContent = '(No hay sesión de mapa activa)';
        }
    }
  
    const termsAccepted = localStorage.getItem('termsAccepted_v1') === 'true';
    const tabButtons = modal.querySelectorAll('.config-tab-button');
    const tabContents = modal.querySelectorAll('.config-tab-content');

    if (!termsAccepted) {
        tabButtons.forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.tabTarget !== '#tab-content-normas') {
                btn.disabled = true; 
                btn.style.cursor = 'not-allowed';
                btn.style.opacity = '0.5';
            }
        });
        tabContents.forEach(content => content.classList.remove('active'));
        
        modal.querySelector('.config-tab-button[data-tab-target="#tab-content-normas"]').classList.add('active');
        modal.querySelector('#tab-content-normas').classList.add('active');
    } else {
        tabButtons.forEach(btn => {
            btn.disabled = false;
            btn.style.cursor = 'pointer';
            btn.style.opacity = '1';
            btn.classList.toggle('active', btn.dataset.tabTarget === '#tab-content-usuario');
        });
        tabContents.forEach(content => {
            content.classList.toggle('active', content.id === 'tab-content-usuario');
        });
    }

    modal.querySelectorAll('.status-message').forEach(msg => msg.textContent = '');
    modal.querySelectorAll('input[type="text"], input[type="number"], textarea').forEach(input => {
        if (!['user-id', 'config-pin-set', 'config-pin-confirm'].includes(input.id)) {
            input.value = '';
        }
    });
    modal.querySelector('#config-pin-set').value = '';
    modal.querySelector('#config-pin-confirm').value = '';
    modal.querySelector('#config-backup-display').value = '';
    modal.querySelector('#config-restore-input').value = '';
    if(modal.querySelector('#config-backup-display')) modal.querySelector('#config-backup-display').style.display = 'none';
    const userIdInput = modal.querySelector('#user-id');
    const storedUserId = localStorage.getItem('userData_userId');
    if (userIdInput) userIdInput.value = storedUserId || '';
    
    const teslaModelInput = modal.querySelector('#tesla-model');
    if (teslaModelInput) teslaModelInput.value = localStorage.getItem('userData_teslaModel') || '';
    const teslaYearInput = modal.querySelector('#tesla-year');
    if (teslaYearInput) teslaYearInput.value = localStorage.getItem('userData_teslaYear') || '';
    const teslaProvinceInput = modal.querySelector('#tesla-province');
    if (teslaProvinceInput) teslaProvinceInput.value = localStorage.getItem('userData_teslaProvince') || '';
    const allowDmsCheckbox = modal.querySelector('#allow-dms');
    if (allowDmsCheckbox) allowDmsCheckbox.checked = JSON.parse(localStorage.getItem('userData_allowDMs')) || false;
    
    const directToNavCheckbox = document.getElementById('config-direct-to-nav');
    if (directToNavCheckbox) directToNavCheckbox.checked = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;

    const autoBackupCheckbox = document.getElementById('config-auto-backup-on-load');
    if (autoBackupCheckbox) {
        const savedAutoBackup = localStorage.getItem('boardinggate_autoBackupOnLoad');
        autoBackupCheckbox.checked = savedAutoBackup === null ? true : JSON.parse(savedAutoBackup);
    }

    modal.classList.remove('hidden');
    const closeButtonConfig = modal.querySelector('#config-close-modal');
    addModalAutoCloseTimer(modal, closeButtonConfig, 'config-modal', 120000);
}
    
    // ===================================================================
    // NOMBRE: loadNotices
    // RESUMEN: Carga los avisos desde un archivo de texto externo.
    async function loadNotices() { try { const r = await fetch('https://boardinggate.github.io/Tesla/avisos.txt', { cache: 'no-cache' }); if (!r.ok) throw new Error('Fetch failed'); const txt = await r.text(); notices = txt.split('\n').map(l => l.trim()).filter(l => l.length > 0); if (notices.length === 0) notices = ['No hay avisos.']; } catch (e) { notices = ['Error carga avisos.']; } updateNotice(); } 
    
    // ===================================================================
    // NOMBRE: updateNotice
    // RESUMEN: Actualiza el texto del aviso visible en la pantalla.
    function updateNotice() { const noticeElement = document.getElementById('current-notice'); if (!noticeElement || notices.length === 0) { return; } if (!isActive) { noticeElement.textContent = ''; noticeElement.style.animation = 'none'; return; } noticeElement.textContent = notices[currentNoticeIndex]; noticeElement.style.animation = 'none'; void noticeElement.offsetWidth; noticeElement.style.animation = 'fadeInOut 14s infinite'; currentNoticeIndex = (currentNoticeIndex + 1) % notices.length; }
    
    // ===================================================================
    // NOMBRE: toggleNotices
    // RESUMEN: Activa o desactiva la visualización de los avisos y el pie de página.
    function toggleNotices() { isActive = !isActive; const nC = document.querySelector('.notices-container'); if (nC) nC.style.display = isActive ? 'flex' : 'none'; const fC = document.querySelector('footer'); if (fC) fC.classList.toggle('footer-hidden', !isActive); isFooterVisible = isActive; const nE = document.getElementById('current-notice'); if (nE) { if (!isActive) { nE.textContent = ''; nE.style.animation = 'none'; } else { currentNoticeIndex = 0; updateNotice(); } } saveSettings(); }

    // ===================================================================
    // NOMBRE: startNoticeRotation
    // RESUMEN: Inicia la rotación periódica de los avisos.
    function startNoticeRotation() { if (notices.length === 0) return; if (isActive) updateNotice(); setInterval(updateNotice, 14000); }
    
    // ===================================================================
    // NOMBRE: adjustButtonPositions
    // RESUMEN: Ajusta dinámicamente la posición de los botones laterales fijos.
    function adjustButtonPositions() { const scrollToggle = document.getElementById('scroll-toggle'); if (!scrollToggle) { return; }
    const scrollToggleHeight = scrollToggle.offsetHeight; const buttonHeight = 74; const buttonSpacing = 10; const startTop = scrollToggleHeight + 20; const fixedButtons = [ document.getElementById('on-off-toggle'), ...document.querySelectorAll('.range-toggle'), document.getElementById('weather-button'), document.getElementById('reminder-button'), document.getElementById('zoom-button'), document.getElementById('dark-mode-toggle') ].filter(button => button !== null).sort((a, b) => { const startA = parseInt(a.dataset.rangeStart) || Infinity; const startB = parseInt(b.dataset.rangeStart) || Infinity; if (a.id === 'on-off-toggle') return -1; if (b.id === 'on-off-toggle') return 1; if (isFinite(startA) && isFinite(startB)) return startA - startB; if (isFinite(startA)) return -1; if (isFinite(startB)) return 1; const order = ['weather-button', 'reminder-button', 'zoom-button', 'dark-mode-toggle']; return order.indexOf(a.id) - order.indexOf(b.id); }); if (fixedButtons.length < 6) { return; } let currentTop = startTop; fixedButtons.forEach((button) => { button.style.position = 'fixed'; button.style.top = `${currentTop}px`; button.style.left = '10px'; currentTop += buttonHeight + buttonSpacing; }); }
    
    
 
// ===================================================================
// NOMBRE: translatePoiCategory (VERSIÓN CON TRADUCCIÓN MANUAL)
// RESUMEN: Traduce y formatea las categorías de POI recibidas en inglés desde la API de Mapbox.
function translatePoiCategory(categories) {
    if (!Array.isArray(categories) || categories.length === 0) {
        return 'General';
    }

    const MAPBOX_CATEGORY_TRANSLATIONS = {
        'restaurant': 'Restaurante',
        'cafe': 'Cafetería',
        'bar': 'Bar',
        'fast_food': 'Comida Rápida',
        'food_court': 'Zona de Restaurantes',
        'gas_station': 'Gasolinera',
        'parking': 'Parking',
        'hotel': 'Hotel',
        'motel': 'Motel',
        'lodging': 'Alojamiento',
        'supermarket': 'Supermercado',
        'grocery': 'Tienda de Alimentación',
        'convenience': 'Tienda de Conveniencia',
        'shopping': 'Tiendas',
        'mall': 'Centro Comercial',
        'clothing_store': 'Tienda de Ropa',
        'hardware_store': 'Ferretería',
        'home_goods_store': 'Tienda de Hogar',
        'pharmacy': 'Farmacia',
        'hospital': 'Hospital',
        'clinic': 'Clínica',
        'doctor': 'Médico',
        'dentist': 'Dentista',
        'atm': 'Cajero Automático',
        'bank': 'Banco',
        'tourist_attraction': 'Atracción Turística',
        'landmark': 'Lugar de Interés',
        'museum': 'Museo',
        'park': 'Parque',
        'zoo': 'Zoo',
        'airport': 'Aeropuerto',
        'bus_station': 'Estación de Autobuses',
        'train_station': 'Estación de Tren',
        'subway_station': 'Estación de Metro',
        'car_rental': 'Alquiler de Coches',
        'car_repair': 'Taller Mecánico',
        'car_wash': 'Lavado de Coches',
        'library': 'Biblioteca',
        'school': 'Colegio',
        'university': 'Universidad',
        'post_office': 'Oficina de Correos',
        'police': 'Policía',
        'fire_station': 'Bomberos',
        'cinema': 'Cine',
        'night_club': 'Discoteca',
        'stadium': 'Estadio',
        'gym': 'Gimnasio',
        'golf_course': 'Campo de Golf',
        'beach': 'Playa',
        'campground': 'Camping',
        'marina': 'Puerto Deportivo'
    };

    const translatedCategories = categories.map(englishCategory => {
        const translated = MAPBOX_CATEGORY_TRANSLATIONS[englishCategory];
        if (translated) {
            return translated;
        } else {
            const cleaned = englishCategory.replace(/_/g, ' ');
            return cleaned.charAt(0).toUpperCase() + cleaned.slice(1);
        }
    });

    return translatedCategories.join(', ');
}

// ===================================================================
// NOMBRE: findExistingWaypointAtCoords
// RESUMEN: Busca si ya existe una etapa de ruta en las coordenadas dadas.
function findExistingWaypointAtCoords(lat, lon, toleranceMeters = 10) {
    for (const waypoint of navigationWaypoints) {
        if (waypoint && !waypoint.isInternal) {
            const distance = calculateDistance(lat, lon, waypoint.lat, waypoint.lng);
            if (distance <= toleranceMeters) {
                return waypoint;
            }
        }
    }
    return null;
}
// ===================================================================
// NOMBRE: enablePoiInteractivity (VERSIÓN SIMPLIFICADA)
// RESUMEN: Únicamente cambia el cursor a "puntero" al pasar sobre los POIs.
function enablePoiInteractivity(mapInstance) {
    if (!mapInstance) return;

    const interactiveLayers = [
        'poi-label', 'transit-label', 'airport-label', 'settlement-label', 
        'natural-label', 'water-point-label'
    ];

    mapInstance.on('mouseenter', interactiveLayers, () => {
        mapInstance.getCanvas().style.cursor = 'pointer';
    });
    mapInstance.on('mouseleave', interactiveLayers, () => {
        mapInstance.getCanvas().style.cursor = '';
    });
}
// ===================================================================
// NOMBRE: loadAndAddMapImages (VERSIÓN ROBUSTA)
// RESUMEN: Carga imágenes y continúa aunque alguna falle.
async function loadAndAddMapImages(mapInstance) {
    const imagesToLoad = [
        { name: 'reminder-icon', url: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png' },
        { name: 'radar-generic-icon', url: 'PNG/RADARAQUI.PNG' },
        { name: 'pdr-icon-simple', url: 'PNG/pdrs.png' }
    ];

    const imageLoadPromises = imagesToLoad.map(img => 
        new Promise((resolve) => { // No usamos reject para no detener Promise.all
            if (mapInstance.hasImage(img.name)) {
                resolve();
                return;
            }
            mapInstance.loadImage(img.url, (error, image) => {
                if (error) {
                    console.error(`Error al cargar imagen ${img.name}:`, error);
                    resolve(); // Resuelve igualmente para no bloquear
                    return;
                }
                if (!mapInstance.hasImage(img.name)) {
                    mapInstance.addImage(img.name, image, { sdf: false });
                }
                resolve();
            });
        })
    );
    await Promise.all(imageLoadPromises);
}

// ===================================================================
// NOMBRE: showSaveRoutePromptForSingleWaypoint (VERSIÓN CORREGIDA Y DEFINITIVA)
// RESUMEN: Muestra el modal de guardado, usando directamente el nombre descriptivo
//          del POI que se le pasa, en lugar de recalcularlo.
// ===================================================================
async function showSaveRoutePromptForSingleWaypoint(waypointObject) {
    // ¡CORRECCIÓN CLAVE! Usa directamente el nombre del POI pasado en 'waypointObject.address'.
    const defaultName = `UBICACIÓN: ${waypointObject.address}`.toUpperCase();
    
    const onSaveCallback = (confirmedName) => {
        const routeToSave = {
            name: confirmedName,
            waypoints: [{ ...waypointObject, type: 'F', label: 'F' }],
            createdAt: new Date().toISOString()
        };

        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        const existingRouteIndex = savedRoutes.findIndex(r => r.name.toUpperCase() === confirmedName);

        if (existingRouteIndex !== -1) {
            if (confirm(`Ya existe una ubicación guardada como "${confirmedName}". ¿Deseas sobreescribirla?`)) {
                savedRoutes[existingRouteIndex] = routeToSave;
            } else {
                showToast("Guardado cancelado", "info");
                return;
            }
        } else {
            savedRoutes.push(routeToSave);
        }

        if (savedRoutes.length > MAX_SAVED_ROUTES) {
            savedRoutes.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
            savedRoutes = savedRoutes.slice(0, MAX_SAVED_ROUTES);
        }
        localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes));
        markCacheAsDirty();
        showToast(`Ubicación "${confirmedName}" guardada en favoritos.`, "success");
    };

    showSaveRoutePromptModal(defaultName, onSaveCallback);
} 
// ===================================================================
// NOMBRE: getGlobalPoiStats
// RESUMEN: Calcula las estadísticas globales de clics en POIs de todos los usuarios.
async function getGlobalPoiStats() {
    if (!window.db) return { totalMonth: 0 };
    
    let totalMonth = 0;
    
    try {
        const usersCollectionRef = window.collection(window.db, "user_data");
        const querySnapshot = await window.getDocs(usersCollectionRef);
        
        const now = new Date();
        const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        querySnapshot.forEach(doc => {
            const data = doc.data();
            if (data.poi_clicks_last_month === currentMonthStr) {
                totalMonth += (data.poi_clicks_month || 0);
            }
        });

    } catch (error) {
        console.error("Error al obtener estadísticas globales de POIs:", error);
    }
    
    return { totalMonth };
}

// ===================================================================
// NOMBRE: showPoiInfoModal (VERSIÓN CON GOOGLE PLACES Y FALLBACK IMG CORREGIDO)
// RESUMEN: Muestra un modal enriquecido con datos de Google Places.
async function showPoiInfoModal(feature) {
    const existingModal = document.querySelector('.poi-modal-overlay');
    if (existingModal) existingModal.remove();

    const overlay = document.createElement('div');
    overlay.className = 'poi-modal-overlay';
    
    overlay.innerHTML = `
        <div class="poi-modal-content">
            <div class="poi-modal-body" style="text-align: center; padding: 3rem;">
                <p>Obteniendo información del lugar...</p>
            </div>
        </div>
    `;
    document.body.appendChild(overlay);

    try {
        const canProceed = await checkAndIncrementPoiCount();
        if (!canProceed) {
            if (overlay.parentNode) overlay.remove();
            return;
        }

        const mapboxProperties = feature.properties || {};
        const coordinates = feature.geometry.coordinates.slice();
        const mapboxName = mapboxProperties.name || 'Punto de Interés';
        
        const placeId = await findGooglePlaceId(mapboxName, coordinates[1], coordinates[0]);
        
        let name, address, phone, website, imageUrl, saveName, photosHtml = '', commentsHtml = '', detailsHtml = '';
        const lat = coordinates[1];
        const lng = coordinates[0];

        if (placeId) {
            const googleDetails = await getGooglePlaceDetails(placeId);
            
            if (googleDetails) {
                name = googleDetails.displayName || mapboxName;
                address = googleDetails.formattedAddress || `(${lat.toFixed(4)}, ${lng.toFixed(4)})`;
                phone = googleDetails.nationalPhoneNumber;
                website = googleDetails.websiteURI;
                imageUrl = (googleDetails.photos && googleDetails.photos.length > 0) 
                    ? googleDetails.photos[0].getURI({ maxWidth: 600, maxHeight: 400 }) 
                    : 'PNG/modalrutas.png'; // <-- CAMBIO APLICADO AQUÍ
                saveName = name;

                detailsHtml += '<h4>Valoración</h4>';
                if(googleDetails.rating) {
                    detailsHtml += `<p>${'★'.repeat(Math.round(googleDetails.rating))}${'☆'.repeat(5 - Math.round(googleDetails.rating))} (${googleDetails.rating} de ${googleDetails.userRatingCount} opiniones)</p>`;
                } else {
                    detailsHtml += '<p>No hay valoraciones disponibles.</p>';
                }
                
                if (googleDetails.regularOpeningHours) {
                    detailsHtml += '<h4>Horario</h4>';
                    googleDetails.regularOpeningHours.weekdayDescriptions.forEach(day => {
                        detailsHtml += `<p>${day}</p>`;
                    });
                }
                
                detailsHtml += '<h4>Contacto</h4>';
                if(phone) detailsHtml += `<p><strong>Teléfono:</strong> <a href="tel:${phone}">${phone}</a></p>`;
                if(website) detailsHtml += `<p><strong>Web:</strong> <a href="${website}" target="_blank">${website}</a></p>`;
                if(googleDetails.googleMapsURI) detailsHtml += `<p><strong>En Google Maps:</strong> <a href="${googleDetails.googleMapsURI}" target="_blank">Abrir</a></p>`;

                if (googleDetails.photos && googleDetails.photos.length > 0) {
                    photosHtml = '<div class="ocm-photo-grid">' + googleDetails.photos.slice(0, 6).map(photo => 
                        `<img src="${photo.getURI({ maxWidth: 200, maxHeight: 200 })}" alt="Foto de ${name}" data-full-url="${photo.getURI()}">`
                    ).join('') + '</div>';
                } else { photosHtml = '<p>No hay fotos disponibles.</p>'; }

                if (googleDetails.reviews && googleDetails.reviews.length > 0) {
                    commentsHtml = '<ul class="ocm-comment-list">' + googleDetails.reviews.map(review => {
                        const authorName = review.authorAttribution ? review.authorAttribution.displayName : 'Anónimo';
                        const reviewDate = review.publishTime ? new Date(review.publishTime).toLocaleDateString('es-ES', { day: '2-digit', month: 'short', year: 'numeric'}) : '';
                        const reviewText = review.text ? review.text.originalText : 'Sin comentario.';
                        return `
                        <li class="ocm-comment">
                            <div class="ocm-comment-header">
                                <span class="user">${authorName} (${review.rating} ★)</span>
                                <span class="date">${reviewDate}</span>
                            </div>
                            <p class="comment-text">${reviewText}</p>
                        </li>
                    `}).join('') + '</ul>';
                } else { commentsHtml = '<p>No hay opiniones disponibles.</p>'; }

            } else {
                throw new Error("Google Place Details falló después de encontrar un ID.");
            }
        } else {
            name = mapboxName;
            address = `(${lat.toFixed(4)}, ${lng.toFixed(4)})`;
            category = translatePoiCategory(mapboxProperties.categories || []);
            imageUrl = 'PNG/modalrutas.png'; // <-- CAMBIO APLICADO AQUÍ
            saveName = name;
            detailsHtml = `<h4>Categoría</h4><p>${category}</p><p>No se encontraron detalles adicionales en Google.</p>`;
            photosHtml = '<p>No disponible.</p>';
            commentsHtml = '<p>No disponible.</p>';
        }
        
        const existingWaypoint = findExistingWaypointAtCoords(lat, lng);
        let buttonsHtml = `
            <button id="poi-add-btn" class="btn-modal-action-primary">Añadir a Ruta</button>
            <button id="poi-save-btn" class="btn-modal-favorite">Guardar POI</button>
            <button id="poi-share-btn" class="btn-modal-action-primary">Compartir</button>
        `;
        if (existingWaypoint) {
            buttonsHtml += `<button id="poi-delete-btn" class="btn-modal-danger" data-waypoint-id="${existingWaypoint.id}">Eliminar Etapa</button>`;
        } else {
             buttonsHtml += `<button id="poi-close-btn" class="btn-modal-action-secondary">Cerrar <span class="button-countdown-timer"></span></button>`;
        }
        
        overlay.querySelector('.poi-modal-content').innerHTML = `
            <div class="poi-modal-header" style="background-image: url('${imageUrl}');">
                <h3 class="poi-modal-title">${name}</h3>
                <p class="poi-modal-address">${address}</p>
            </div>
            <div class="ocm-modal-tabs">
                <div class="ocm-modal-tab active" data-panel="details">DETALLES</div>
                <div class="ocm-modal-tab" data-panel="photos">FOTOS</div>
                <div class="ocm-modal-tab" data-panel="comments">OPINIONES</div>
            </div>
            <div class="poi-modal-body">
                <div id="poi-panel-details" class="ocm-modal-panel active">${detailsHtml}</div>
                <div id="poi-panel-photos" class="ocm-modal-panel">${photosHtml}</div>
                <div id="poi-panel-comments" class="ocm-modal-panel">${commentsHtml}</div>
            </div>
            <div class="poi-modal-footer">${buttonsHtml}</div>
        `;
        
        const closeHandler = () => {
            clearModalAutoCloseTimer(overlay, overlay.querySelector('#poi-close-btn, #poi-delete-btn'), 'poi-modal');
            if (overlay.parentNode) overlay.remove();
        };

        const closeBtn = overlay.querySelector('#poi-close-btn');
        if (closeBtn) closeBtn.addEventListener('click', closeHandler);
        
        overlay.querySelector('#poi-add-btn').addEventListener('click', async () => {
            const snapped = await snapCoordsToRoad(lat, lng);
            addWaypoint({ lat: snapped.lat, lng: snapped.lng }, address);
            closeHandler();
        });

        overlay.querySelector('#poi-save-btn').addEventListener('click', () => {
             const waypointForSave = { lat: lat, lng: lng, address: saveName, id: Date.now() };
             showSaveRoutePromptForSingleWaypoint(waypointForSave);
             closeHandler();
        });

        overlay.querySelector('#poi-share-btn').addEventListener('click', () => {
            handleSendToTeslaClick(lat, lng, name);
            closeHandler();
        });
        
        overlay.querySelectorAll('.ocm-modal-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                overlay.querySelectorAll('.ocm-modal-tab, .ocm-modal-panel').forEach(el => el.classList.remove('active'));
                tab.classList.add('active');
                overlay.querySelector(`#poi-panel-${tab.dataset.panel}`).classList.add('active');
            });
        });

        overlay.querySelectorAll('.ocm-photo-grid img').forEach(img => {
            img.addEventListener('click', () => showPhotoModal(img.dataset.fullUrl));
        });

        const deleteBtn = overlay.querySelector('#poi-delete-btn');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', () => {
                handleDeleteWaypointClick(parseInt(deleteBtn.dataset.waypointId));
                closeHandler();
            });
        }
        addModalAutoCloseTimer(overlay, overlay.querySelector('#poi-close-btn, #poi-delete-btn'), 'poi-modal', 45000);

    } catch (error) {
        console.error("Error al mostrar el modal del POI:", error);
        showToast("Error al mostrar información del POI.", 'error');
        if (overlay.parentNode) overlay.remove();
    }
}    
    
// ===================================================================
// NOMBRE: updateRouteAndCarIconStyle (MODIFICADA)
// RESUMEN: Ajusta el estilo de la línea de ruta cuando ya existe, tras un cambio de capa de mapa.
function updateRouteAndCarIconStyle() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) return;

    if (navigationMapInstance.getLayer('route')) {
        const styleProps = getRouteStyleProperties();
        Object.keys(styleProps).forEach(prop => {
            navigationMapInstance.setPaintProperty('route', prop, styleProps[prop]);
        });
    }
}
    
    // ===================================================================
    // NOMBRE: loadCustomData
    // RESUMEN: Carga los datos de personalización del grid desde localStorage.
    function loadCustomData() { const savedData = localStorage.getItem('customGridData'); currentBookmarks = []; currentToggleRanges = []; customData = { bookmarks: {}, toggles: {} }; if (savedData) { try { customData = JSON.parse(savedData) || { bookmarks: {}, toggles: {} }; } catch (e) { customData = { bookmarks: {}, toggles: {} }; } } if (!customData.bookmarks) customData.bookmarks = {}; if (!customData.toggles) customData.toggles = {}; currentBookmarks = Array.from({ length: TOTAL_CELLS }).map((_, index) => { if (customData.bookmarks.hasOwnProperty(index)) { return customData.bookmarks[index] ? { ...customData.bookmarks[index] } : null; } else { const original = index < originalBookmarks.length ? originalBookmarks[index] : null; return original ? { ...original } : null; } }); currentToggleRanges = originalToggleRanges.map(originalRange => { const customToggle = customData.toggles[originalRange.start]; const rangeCopy = { ...originalRange }; if (customToggle) { if (typeof customToggle.label === 'string') rangeCopy.label = customToggle.label; if (Array.isArray(customToggle.assignedIndexes)) rangeCopy.assignedIndexes = [...customToggle.assignedIndexes]; } if (!rangeCopy.assignedIndexes) rangeCopy.assignedIndexes = Array.from({ length: rangeCopy.end - originalRange.start + 1 }, (_, i) => originalRange.start + i); return rangeCopy; }); }
     
    // ===================================================================
    // NOMBRE: loadReminders
    // RESUMEN: Carga los recordatorios y actualiza el contador.
    function loadReminders() { updateReminderCount(); }

// ===================================================================
// NOMBRE: actualizarContadorRadares
// RESUMEN: Actualiza el contador numérico de radares en la UI del mapa.
function actualizarContadorRadares(count) {
    const contadorElement = document.getElementById('radares-ruta-count');
    if (contadorElement) {
        contadorElement.textContent = count;
        const checkbox = document.getElementById('radares-ruta-checkbox');
        contadorElement.classList.toggle('hidden', count === 0 && (!checkbox || !checkbox.checked));
    }
}
// ===================================================================
// NOMBRE: actualizarContadorTareas
// RESUMEN: Actualiza el contador numérico de tareas en la UI del mapa.
function actualizarContadorTareas(count) {
    const contadorElement = document.getElementById('tareas-ruta-count');
    if (contadorElement) {
        contadorElement.textContent = count;
        const checkbox = document.getElementById('tareas-ruta-checkbox');
        contadorElement.classList.toggle('hidden', count === 0 && (!checkbox || !checkbox.checked));
    }
}    
// ===================================================================
// NOMBRE: applyZoom (VERSIÓN CON PROPORCIONALIDAD CORREGIDA)
// RESUMEN: Aplica el zoom. En modo 'on', usa un tamaño fijo de 190px por columna, que es proporcionalmente
function applyZoom(state) {
    const originalWidth = 984;
    const zoomedCols = 4;
    const originalCols = 6;
    const gap = 15;
    const zoomButton = document.getElementById('zoom-button');

    if (state === 'on') {
        const zoomedColumnWidth = 224; // Nuevo tamaño calculado para ser proporcionalmente más grande.
        grid.style.gridTemplateColumns = `repeat(${zoomedCols}, ${zoomedColumnWidth}px)`;
        grid.style.gap = `${gap}px`;
        grid.style.maxWidth = `${(zoomedCols * zoomedColumnWidth) + ((zoomedCols - 1) * gap)}px`; 
        
        document.querySelectorAll('.bookmark-item img').forEach(i => { i.style.width = '48px'; i.style.maxWidth = '52px'; });
        document.querySelectorAll('.bookmark-name').forEach(n => { n.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)'; });
        document.querySelectorAll('.small-bookmark img').forEach(i => { i.style.width = '48px'; i.style.maxWidth = '52px'; });
        document.querySelectorAll('.small-bookmark .bookmark-name').forEach(n => { n.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)'; });
        if (zoomButton) zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/zoon+.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`;
    } else {
        grid.style.gridTemplateColumns = `repeat(${originalCols}, minmax(120px, 1fr))`;
        grid.style.gap = `${gap}px`;
        grid.style.maxWidth = `${originalWidth}px`; 
        document.querySelectorAll('.bookmark-item img').forEach(i => { i.style.width = '36px'; i.style.maxWidth = '40px'; });
        document.querySelectorAll('.bookmark-name').forEach(n => { n.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)'; });
        document.querySelectorAll('.small-bookmark img').forEach(i => { i.style.width = '24px'; i.style.maxWidth = '28px'; });
        document.querySelectorAll('.small-bookmark .bookmark-name').forEach(n => { n.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)'; });
        if (zoomButton) zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`;
    }
}    
    
    // ===================================================================
    // NOMBRE: getSectionForIndex
    // RESUMEN: Devuelve la configuración de la sección a la que pertenece un índice del grid.
    function getSectionForIndex(index) { return currentToggleRanges.find(range => range.assignedIndexes.includes(index)); } 
    
    // ===================================================================
    // NOMBRE: getColorForSection
    // RESUMEN: Obtiene el color de fondo para una sección, considerando el modo oscuro.
    function getColorForSection(sectionStart, state = 'visible') { if (state === 'hidden') { return sectionColors.off; } if (isDarkMode) { return darkModeGenericButtonColor; } else { return sectionColors[sectionStart] || sectionColors.unassigned; } }
     
    // ===================================================================
    // NOMBRE: updateButtonStyles
    // RESUMEN: Actualiza los estilos visuales de todos los botones de la UI.
    function updateButtonStyles() {
        const darkModeToggleElem = document.getElementById('dark-mode-toggle');
        const onOffToggleElem = document.getElementById('on-off-toggle');
        const rangeToggleButtonsElems = document.querySelectorAll('.toggle-sign.range-toggle');
        const reminderButtonElem = document.getElementById('reminder-button');
        if (onOffToggleElem) {
            onOffToggleElem.src = `https://boardinggate.github.io/Tesla/${onOffToggleElem.dataset.state === 'on' ? 'PNG/IMG_4192.jpg' : 'PNG/IMG_4191.jpg'}`;
            onOffToggleElem.alt = `Toggle ${onOffToggleElem.dataset.state === 'on' ? 'On' : 'Off'}`;
            onOffToggleElem.style.backgroundColor = sectionColors.off;
            if (isDarkMode) {
                onOffToggleElem.style.filter = 'brightness(85%)';
                 if (onOffToggleElem.dataset.state === 'on') {
                    onOffToggleElem.style.backgroundColor = darkModeGenericButtonColor;
                 }
            } else {
                onOffToggleElem.style.filter = '';
            }
        }
        if (darkModeToggleElem) {
            darkModeToggleElem.src = `https://boardinggate.github.io/Tesla/PNG/${isDarkMode ? 'oscuro2.png' : 'claro2.png'}`;
            darkModeToggleElem.alt = `Toggle ${isDarkMode ? 'Oscuro' : 'Claro'}`;
            darkModeToggleElem.style.backgroundColor = sectionColors.off;
            if (isDarkMode) darkModeToggleElem.style.filter = 'brightness(85%)'; else darkModeToggleElem.style.filter = '';
        }
        let reminders = [];
        try {
            reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        } catch(e) {
            reminders = [];
        }
        const showExcludedInTable = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false;
        let remindersForButtonStyleCount = reminders;
        if (!showExcludedInTable) {
            remindersForButtonStyleCount = reminders.filter(r => !r.excludeFromList);
        }
        const totalPendingCount = remindersForButtonStyleCount.length;
        if (reminderButtonElem) {
            reminderButtonElem.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/IMG_4197.jpg" alt="Recordatorio" style="max-width: 70%; max-height: 70%; object-fit: contain;">${totalPendingCount > 0 ? `<span class="reminder-count">${totalPendingCount}</span>` : ''}`;
            reminderButtonElem.style.backgroundColor = sectionColors.off;
            if (isDarkMode) reminderButtonElem.style.filter = 'brightness(85%)'; else reminderButtonElem.style.filter = '';
        }
        rangeToggleButtonsElems.forEach(toggle => {
            const start = parseInt(toggle.dataset.rangeStart);
            const state = toggle.dataset.state || 'visible';
            const rangeConfig = currentToggleRanges.find(r => r.start === start);
            if (rangeConfig) {
                toggle.innerHTML = `<span class="sign">${state === 'visible' ? '-' : '+'}</span>${rangeConfig.label}`;
            }
            toggle.style.backgroundColor = getColorForSection(start, state);
            if (isDarkMode && state === 'visible') {
                toggle.style.filter = 'brightness(85%)';
            } else {
                toggle.style.filter = '';
            }
        });
        updatePasswordToggleIcon();
        const zoomButtonElem = document.getElementById('zoom-button');
        if (zoomButtonElem && zoomButtonElem.dataset.zoomState) {
            applyZoom(zoomButtonElem.dataset.zoomState);
        }
        if (cellElements && cellElements.length > 0) {
            cellElements.forEach((cell, index) => {
                const bookmarkItem = cell.querySelector('.bookmark-item');
                const emptySlot = cell.classList.contains('empty-slot');
                const section = getSectionForIndex(index);
                const color = sectionColors[section ? section.start : null] || sectionColors.unassigned;
                if (bookmarkItem) {
                    bookmarkItem.style.backgroundColor = color;
                } else if (emptySlot) {
                    cell.style.backgroundColor = color;
                }
            });
        }
    }
// ===================================================================
// NOMBRE: showWaypointActionModal (MODIFICADA - NUEVO DISEÑO Y BOTÓN)
// RESUMEN: Muestra un modal con el nuevo diseño oscuro para las acciones de una etapa de ruta, incluyendo el nuevo botón "Añadir a Favoritos".
function showWaypointActionModal(waypointId) {
    const wp = navigationWaypoints.find(w => w && w.id === waypointId);
    if (!wp) return;

    const existingOverlay = document.getElementById('route-modal-action-overlay');
    if(existingOverlay) existingOverlay.remove();
    
    const overlay = document.createElement('div');
    overlay.id = 'route-modal-action-overlay';
    overlay.className = 'route-modal-overlay';
    
    let distanceToWaypoint = 0, timeToWaypoint = 0, etaToWaypoint = "--:--";
    const currentActualWaypointsForModal = navigationWaypoints.filter(w => w && !w.isInternal && !w.isRecalculatedStart);
    const actualWaypointIndexInRoute = currentActualWaypointsForModal.findIndex(awp => awp.id === wp.id);
    if (navigationCurrentRouteData?.routes?.[0]) {
        const route = navigationCurrentRouteData.routes[0];
        if (actualWaypointIndexInRoute > 0) {
            for (let i = 0; i < actualWaypointIndexInRoute && i < route.legs.length; i++) {
                distanceToWaypoint += (route.legs[i].distance || 0);
                timeToWaypoint += (route.legs[i].duration || 0);
            }
        }
        if (timeToWaypoint > 0) etaToWaypoint = new Date(Date.now() + timeToWaypoint * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }
    const distanciaTexto = `${(distanceToWaypoint / 1000).toFixed(1)} km`;
    const waypointTotalMinutes = Math.round(timeToWaypoint / 60);
    const tiempoTexto = `${String(Math.floor(waypointTotalMinutes / 60)).padStart(2, '0')}:${String(waypointTotalMinutes % 60).padStart(2, '0')}`;
    
    const alternativesButtonHtml = (wp.type !== 'S' && wp.type !== 'S_Recalc') ? `<button id="modal-alternatives-btn" class="btn-modal-action-primary">Otras Rutas</button>` : '';
    const deleteButtonHtml = (wp.type !== 'S_Recalc') ? `<button id="modal-delete-btn" class="btn-modal-danger">Borrar Punto</button>` : '';
    const favoriteButtonHtml = `<button id="modal-favorite-btn" class="btn-modal-favorite">Añadir a Favoritos</button>`;
    
    overlay.innerHTML = `
        <div id="waypoint-action-modal" class="route-modal-container">
            <div class="route-modal-header">
                <div class="route-modal-title-card">
                    <span class="route-modal-title">Etapa ${wp.label}</span>
                </div>
            </div>
            <div class="route-modal-body">
                <p style="font-size: 1.1rem; color: #f0f0f0; margin-bottom: 15px;"><strong>Destino:</strong> ${wp.address}</p>
                <p><strong>Distancia:</strong> ${distanciaTexto}</p>
                <p><strong>Tiempo:</strong> ${tiempoTexto}</p>
                <p><strong>Llegada (ETA):</strong> ${etaToWaypoint}</p>
            </div>
            <div class="route-modal-footer" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <button id="modal-share-btn" class="btn-modal-action-primary">Compartir</button>
                ${alternativesButtonHtml}
                ${favoriteButtonHtml}
                ${deleteButtonHtml}
                <button id="modal-close-btn" class="btn-modal-action-secondary" style="grid-column: 1 / -1;">Cerrar <span class="button-countdown-timer"></span></button>
            </div>
        </div>
    `;

    document.body.appendChild(overlay);

    const closeHandler = () => {
        clearModalAutoCloseTimer(overlay, overlay.querySelector('#modal-close-btn'), 'waypoint-action-modal');
        if (overlay.parentNode) overlay.remove();
    };

    overlay.querySelector('#modal-close-btn').addEventListener('click', closeHandler);
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) closeHandler();
    });

    overlay.querySelector('#modal-share-btn').addEventListener('click', () => {
        handleSendToTeslaClick(wp.lat, wp.lng, wp.address);
        closeHandler();
    });

    overlay.querySelector('#modal-favorite-btn').addEventListener('click', () => {
        saveSingleWaypointAsFavorite(wp.id);
        closeHandler();
    });

    const alternativesBtn = overlay.querySelector('#modal-alternatives-btn');
    if (alternativesBtn) {
        alternativesBtn.addEventListener('click', () => {
            fetchAndDisplayAlternativeRoutes(wp.id);
            closeHandler();
        });
    }

    const deleteBtn = overlay.querySelector('#modal-delete-btn');
    if (deleteBtn) {
        deleteBtn.addEventListener('click', () => {
            handleDeleteWaypointClick(wp.id);
            closeHandler();
        });
    }

    addModalAutoCloseTimer(overlay, overlay.querySelector('#modal-close-btn'), 'waypoint-action-modal', 20000);
}

// ===================================================================
// NOMBRE: saveSingleWaypointAsFavorite (NUEVA FUNCIÓN)
// RESUMEN: Inicia el proceso de guardado para un único punto de ruta como favorito.
function saveSingleWaypointAsFavorite(waypointId) {
    const waypointToSave = navigationWaypoints.find(wp => wp && wp.id === waypointId);
    if (!waypointToSave) {
        showToast("Error: No se pudo encontrar la etapa para guardar.", "error");
        return;
    }
    showSaveRoutePromptForSingleWaypoint(waypointToSave);
}

// ===================================================================
// NOMBRE: saveCurrentRoute (MODIFICADA - REFACTORIZADA CON NUEVO MODAL)
// RESUMEN: Inicia el proceso para guardar la ruta completa, llamando al modal reutilizable de guardado.
async function saveCurrentRoute() {
    const actualWaypointsToSave = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    
    if (actualWaypointsToSave.length < 2) {
        showToast("No hay ruta activa para guardar (se necesitan al menos 2 puntos)", "warning");
        return;
    }

    const isMultiStage = actualWaypointsToSave.length > 2;
    const lastWp = actualWaypointsToSave[actualWaypointsToSave.length - 1];
    const defaultRouteName = await getSuggestedRouteName(lastWp.lat, lastWp.lng, isMultiStage, actualWaypointsToSave.length);
    
    const onSaveCallback = (confirmedName) => {
        let waypointsToSave = actualWaypointsToSave.map(wp => ({
            id: wp.id, lat: wp.lat, lng: wp.lng, label: wp.label, type: wp.type, address: wp.address || '', visited: false, isCriticalForRecalc: true, isInternal: false, isRecalculatedStart: false
        }));

        const routeToSave = {
            name: confirmedName,
            waypoints: waypointsToSave,
            createdAt: new Date().toISOString()
        };

        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        const existingRouteIndex = savedRoutes.findIndex(r => r.name.toUpperCase() === confirmedName);
        if (existingRouteIndex !== -1) {
            if (!confirm(`Ya existe una ruta llamada "${confirmedName}". ¿Sobreescribir?`)) {
                showToast("Guardado cancelado", "info");
                return;
            }
            savedRoutes[existingRouteIndex] = routeToSave;
        } else {
            savedRoutes.push(routeToSave);
        }
        if (savedRoutes.length > MAX_SAVED_ROUTES) {
            savedRoutes.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
            savedRoutes = savedRoutes.slice(0, MAX_SAVED_ROUTES);
        }
        localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes));
        markCacheAsDirty();
        addRouteToRecents(routeToSave);
        showToast(`Ruta "${confirmedName}" guardada.`, "success");
    };

    showSaveRoutePromptModal(defaultRouteName, onSaveCallback);
}

// ===================================================================
// NOMBRE: showSaveRoutePromptModal (NUEVA FUNCIÓN REUTILIZABLE)
// RESUMEN: Muestra un modal de guardado genérico con el nuevo diseño oscuro.
function showSaveRoutePromptModal(defaultName, onSaveCallback) {
    const existingOverlay = document.getElementById('route-modal-save-overlay');
    if (existingOverlay) existingOverlay.remove();

    const overlay = document.createElement('div');
    overlay.id = 'route-modal-save-overlay';
    overlay.className = 'route-modal-overlay';
    
    const modalContent = document.createElement('div');
    modalContent.id = 'save-route-prompt-modal';
    modalContent.className = 'route-modal-container';
    modalContent.innerHTML = `
        <div class="route-modal-header">
            <div class="route-modal-title-card">
                 <span class="route-modal-title">Guardar Favorito</span>
            </div>
        </div>
        <div class="route-modal-body">
            <label for="route-name-input" class="route-label">Nombre:</label>
            <div class="input-with-clear-button" style="position: relative;">
                <input type="text" id="route-name-input" value="${defaultName.toUpperCase()}" class="route-filter-input" style="padding-right: 40px;">
                <button class="clear-input-btn" title="Limpiar nombre" style="position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: transparent; border: none; font-size: 1.8rem; color: #aaa; cursor: pointer; display: none;">×</button>
            </div>
            <p style="font-size: 0.8rem; color: #8e8e93; margin-top: 10px;">
                (*) Las rutas se guardan y recuperan con el trayecto MÁS RÁPIDO.
            </p>
        </div>
        <div class="route-modal-footer">
            <button id="confirm-save-route" class="btn-modal-save">Guardar <span class="button-countdown-timer"></span></button>
            <button id="cancel-save-route" class="btn-modal-cancel">Cancelar</button>
        </div>
    `;
    
    overlay.appendChild(modalContent);
    document.body.appendChild(overlay);

    const nameInput = modalContent.querySelector('#route-name-input');
    const confirmButton = modalContent.querySelector('#confirm-save-route');
    const cancelButton = modalContent.querySelector('#cancel-save-route');
    const clearBtn = modalContent.querySelector('.clear-input-btn');
    
    const toggleClearButton = () => { clearBtn.style.display = nameInput.value.trim().length > 0 ? 'block' : 'none'; };
    nameInput.addEventListener('input', toggleClearButton);
    clearBtn.addEventListener('click', () => { nameInput.value = ''; toggleClearButton(); nameInput.focus(); });
    toggleClearButton();

    nameInput.focus();
    const textLength = nameInput.value.length;
    nameInput.setSelectionRange(textLength, textLength);

    const closePrompt = () => {
        clearModalAutoCloseTimer(overlay, confirmButton, 'save-route-prompt-modal');
        if (overlay.parentNode) overlay.remove();
    };

    const saveAction = () => {
        let routeName = nameInput.value.trim().toUpperCase();
        if (!routeName) {
            showToast("El nombre no puede estar vacío", "warning");
            addModalAutoCloseTimer(overlay, confirmButton, 'save-route-prompt-modal', 15000);
            return;
        }
        onSaveCallback(routeName);
        closePrompt();
    };

    confirmButton.addEventListener('click', saveAction);
    cancelButton.addEventListener('click', closePrompt);
    addModalAutoCloseTimer(overlay, confirmButton, 'save-route-prompt-modal', 20000);
}
    
    // ===================================================================
    // NOMBRE: formatVersionDate
    // RESUMEN: Formatea una fecha a un formato de versión específico (YY.MM.DDHH).
    function formatVersionDate(date) { const y = date.getUTCFullYear().toString().slice(-2); const m = String(date.getUTCMonth() + 1).padStart(2, '0'); const d = String(date.getUTCDate()).padStart(2, '0'); const h = String(date.getUTCHours()).padStart(2, '0'); return `${y}.${m}.${d}${h}`; }
    
    // ===================================================================
    // NOMBRE: getLastModifiedDate
    // RESUMEN: Obtiene la fecha de la última modificación desde un archivo remoto, con caché local.
    async function getLastModifiedDate() {
        const k = 'teslaHtmlLastModified';
        const tk = 'teslaHtmlLastModifiedTimestamp';
        const dur = 86400000;
        const cd = localStorage.getItem(k);
        const ct = localStorage.getItem(tk);
        const now = Date.now();
        if (cd && ct && (now - parseInt(ct)) < dur) {
            return new Date(cd);
        }
        try {
            const r = await fetch('https://boardinggate.github.io/Tesla/version.txt', { cache: 'no-cache' });
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const txt = await r.text();
            const lmd = new Date(txt.trim());
            if (isNaN(lmd.getTime())) throw new Error('Invalid date format');
            localStorage.setItem(k, lmd.toISOString());
            localStorage.setItem(tk, now.toString());
            return lmd;
        } catch (e) {
            if (cd) return new Date(cd);
            return new Date('2024-01-01T00:00:00Z');
        }
    }
    
    
    // ===================================================================
    // NOMBRE: updateVersion
    // RESUMEN: Actualiza el texto de la versión en la UI.
    async function updateVersion() { try { const lmd = await getLastModifiedDate(); const v = formatVersionDate(lmd); const el = document.getElementById('version'); if (el) el.textContent = `versión: ${v}`; } catch (e) { const el = document.getElementById('version'); if (el) el.textContent = 'versión: error'; } }
    
    // ===================================================================
    // NOMBRE: getFaviconUrl
    // RESUMEN: Obtiene la URL del favicon para un marcador, usando un servicio externo como fallback.
    const getFaviconUrl = (bookmarkData) => { try { const urlToParse = bookmarkData?.url || ''; const customFavicon = bookmarkData?.favicon; if (customFavicon && (customFavicon.startsWith('data:image') || customFavicon.startsWith('http') || customFavicon.startsWith('./'))) return customFavicon; if (urlToParse) { const domain = new URL(urlToParse).hostname; return `https://www.google.com/s2/favicons?domain=${domain}&sz=64`; } } catch (e) { } return 'https://via.placeholder.com/64'; };
    
    // ===================================================================
    // NOMBRE: renderGrid
    // RESUMEN: Dibuja o redibuja el grid completo de marcadores.
    function renderGrid() { grid.innerHTML = ''; cellElements = []; Array.from({ length: TOTAL_CELLS }).forEach((_, index) => { const cellContainer = document.createElement('div'); cellContainer.classList.add('grid-cell'); cellContainer.dataset.index = index; const bookmarkData = currentBookmarks[index]; const section = getSectionForIndex(index); const bgColor = sectionColors[section ? section.start : null] || sectionColors.unassigned; if (bookmarkData) { const link = document.createElement('a'); link.className = 'bookmark-item'; link.title = bookmarkData.name; link.style.backgroundColor = bgColor; link.href = bookmarkData.url || "#"; link.dataset.index = index;
        if (isKeywordAssignmentMode || (bookmarkData.name && bookmarkData.name === "Inicio Tesla") || !bookmarkData.url || bookmarkData.url === '#') { } else { link.target = "_blank"; link.rel = "noopener noreferrer"; }
        const img = document.createElement('img'); img.src = getFaviconUrl(bookmarkData); img.alt = `Favicon ${bookmarkData.name}`; img.loading = "lazy"; img.onerror = function() { this.src = 'https://via.placeholder.com/64'; this.onerror = null; }; if (bookmarkData.name === "Mis Updates") img.classList.add('favicon-red'); else if (bookmarkData.name === "Olas Updates") img.classList.add('favicon-blue'); const nameSpan = document.createElement('span'); nameSpan.className = 'bookmark-name'; nameSpan.textContent = bookmarkData.name; link.appendChild(img); link.appendChild(nameSpan); cellContainer.appendChild(link); } else { cellContainer.classList.add('empty-slot'); const addIcon = document.createElement('span'); addIcon.textContent = '+'; cellContainer.appendChild(addIcon); cellContainer.style.backgroundColor = bgColor; }
        cellContainer.addEventListener('click', handleGridCellClick);
        if (isEditMode) {
             cellContainer.draggable = true;
             cellContainer.addEventListener('dragstart', handleDragStart); cellContainer.addEventListener('dragover', handleDragOver);
             cellContainer.addEventListener('dragleave', handleDragLeave);
             cellContainer.addEventListener('drop', handleDrop);
             cellContainer.addEventListener('dragend', handleDragEnd);
             cellContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
             cellContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
             cellContainer.addEventListener('touchend', handleTouchEnd);
             cellContainer.addEventListener('touchcancel', handleTouchCancel);
             cellContainer.classList.add('editable');
        } else {
             cellContainer.draggable = false;
             cellContainer.removeEventListener('dragstart', handleDragStart);
             cellContainer.removeEventListener('dragover', handleDragOver);
             cellContainer.removeEventListener('dragleave', handleDragLeave);
             cellContainer.removeEventListener('drop', handleDrop);
             cellContainer.removeEventListener('dragend', handleDragEnd);
             cellContainer.removeEventListener('touchstart', handleTouchStart);
             cellContainer.removeEventListener('touchmove', handleTouchMove);
             cellContainer.removeEventListener('touchend', handleTouchEnd);
             cellContainer.removeEventListener('touchcancel', handleTouchCancel);
             cellContainer.classList.remove('editable');
        }
        grid.appendChild(cellContainer); cellElements.push(cellContainer); }); }
    
    
    // ===================================================================
    // NOMBRE: renderToggleButtons
    // RESUMEN: Dibuja los botones laterales para ocultar/mostrar secciones del grid.
    function renderToggleButtons() {
        document.querySelectorAll('.range-toggle').forEach(btn => btn.remove());
        toggleButtonElements = {};
        const toggleStatesFromCache = JSON.parse(localStorage.getItem('toggleStates') || '{}');
        currentToggleRanges.forEach((range) => {
            const toggle = document.createElement('span');
            toggle.className = 'toggle-sign range-toggle';
            toggle.dataset.rangeStart = range.start;
            toggle.dataset.rangeEnd = range.end;
            toggle.style.position = 'fixed';
            toggle.style.top = '100px';
            toggle.style.left = '10px';
            const initialState = toggleStatesFromCache[range.start] || 'visible';
            toggle.dataset.state = initialState;
            toggle.addEventListener('click', handleToggleClick);
            document.body.appendChild(toggle);
            toggleButtonElements[range.start] = toggle;
        });
    }
  // ===================================================================
// NOMBRE: createOtherButtons
// RESUMEN: Crea y añade a la UI los botones de acción fijos.
function createOtherButtons() {
    if (!document.getElementById('on-off-toggle')) {
        onOffToggle = document.createElement('img');
        onOffToggle.className = 'toggle-image';
        onOffToggle.id = 'on-off-toggle';
        const savedOnOffState = localStorage.getItem('onOffState');
        onOffToggle.dataset.state = savedOnOffState ? savedOnOffState : 'on';
        document.body.appendChild(onOffToggle);
        onOffToggle.addEventListener('mousedown', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) pressStartTime = Date.now(); });
        onOffToggle.addEventListener('mouseup', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) handleOnOffAction(); });
        onOffToggle.addEventListener('mouseleave', () => { pressStartTime = null; });
        onOffToggle.addEventListener('touchstart', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); pressStartTime = Date.now(); } });
        onOffToggle.addEventListener('touchend', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); handleOnOffAction(); } });
    }
    if (!document.getElementById('weather-button')) { weatherButton = document.createElement('span'); weatherButton.className = 'toggle-sign'; weatherButton.id = 'weather-button'; weatherButton.innerHTML = `<img src="https://www.google.com/s2/favicons?domain=accuweather.com&sz=64" alt="Tiempo" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; document.body.appendChild(weatherButton); weatherButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; window.open('https://www.ventusky.com/?p=40.2;-4.7;5&l=rain-3h', '_blank'); }); }
    if (!document.getElementById('reminder-button')) { reminderButton = document.createElement('span'); reminderButton.className = 'toggle-sign'; reminderButton.id = 'reminder-button'; document.body.appendChild(reminderButton); reminderButton.addEventListener('mousedown', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) reminderPressStartTime = Date.now(); }); reminderButton.addEventListener('mouseup', () => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) handleReminderLongPress(); }); reminderButton.addEventListener('mouseleave', () => { reminderPressStartTime = null; }); reminderButton.addEventListener('touchstart', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); reminderPressStartTime = Date.now(); } }); reminderButton.addEventListener('touchend', (e) => { if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) { e.preventDefault(); handleReminderLongPress(); } }); }
    if (!document.getElementById('zoom-button')) { zoomButton = document.createElement('span'); zoomButton.className = 'toggle-sign'; zoomButton.id = 'zoom-button'; zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`; zoomButton.dataset.zoomState = localStorage.getItem('zoomState') || 'off'; document.body.appendChild(zoomButton); zoomButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const cS = zoomButton.dataset.zoomState; const nS = cS === 'off' ? 'on' : 'off'; applyZoom(nS); zoomButton.dataset.zoomState = nS; updateButtonStyles(); saveSettings(); adjustButtonPositions(); }); }
    if (!document.getElementById('dark-mode-toggle')) { darkModeToggle = document.createElement('img'); darkModeToggle.className = 'toggle-image'; darkModeToggle.id = 'dark-mode-toggle'; document.body.appendChild(darkModeToggle); darkModeToggle.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; isDarkMode = !isDarkMode; document.body.classList.toggle('dark-mode', isDarkMode); updateButtonStyles(); saveSettings(); }); }
    if (!document.getElementById('config-button')) {
        const configButton = document.createElement('span');
        configButton.id = 'config-button';
        configButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/config.jpg" alt="Configuración">`;
        document.body.appendChild(configButton);
        configButton.addEventListener('click', () => {
            if (!isEditMode && !isAssignmentMode && !isKeywordAssignmentMode) {
                const mapIsCurrentlyOpen = isNavigationMapActive;
                const currentMapContext = sessionStorage.getItem('mapContext');
                if (mapIsCurrentlyOpen && currentMapContext) {
                    sessionStorage.setItem('boardinggate_map_should_reopen_after_config', 'true');
                    sessionStorage.setItem('mapContextToReopenAfterConfig', currentMapContext);
                    closeNavigationMap(true);
                }
                showConfigModal();
            }
        });
    }
    if (!document.getElementById('personal-button')) {
        const personalButton = document.createElement('span');
        personalButton.id = 'personal-button';
        personalButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="Personal">`;
        document.body.appendChild(personalButton);
        personalButton.addEventListener('click', handlePersonalizationClick);
    }
    if (!document.getElementById('radar-button')) {
        radarButton = document.createElement('span');
        radarButton.id = 'radar-button';
        radarButton.innerHTML = `<img src="PNG/AVANCE.PNG" alt="Radar/Ubicaciones/Navegación">`;
        document.body.appendChild(radarButton);
        radarButton.addEventListener('click', () => {
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;

            const userId = localStorage.getItem('userData_userId');
            const allowDMs = JSON.parse(localStorage.getItem('userData_allowDMs') || 'false');

            if (userId && userId.trim() !== '' && allowDMs) {
                openNavigationMap();
            } else {
                const message = "PARA ACCEDER A MAPAS, ES IMPRESCINDIBLE QUE CREE EN CONFIGURACIÓN UN NOMBRE DE USUARIO ÚNICO (y debe estar activado Permitir MDs también)...";
                const duration = 10000; 

                showToast(message, 'error', duration);

                setTimeout(() => {
                    showConfigModal();
                }, duration);
            }
             });
    }
    if (!document.getElementById('home-button')) {
        const homeButton = document.createElement('span');
        homeButton.id = 'home-button';
        homeButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/home.webp" alt="Inicio">`;
        document.body.appendChild(homeButton);
        homeButton.addEventListener('click', (e) => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) { e.preventDefault(); return; } window.history.back(); });
    }
    if (!document.getElementById('reload-button')) {
        const reloadButton = document.createElement('span');
        reloadButton.id = 'reload-button';
        reloadButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/reload.webp" alt="Recargar">`;
        document.body.appendChild(reloadButton);
        reloadButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; location.reload(); });
    }
    if (!document.getElementById('keyword-assignment-button')) {
         const keywordButton = document.createElement('span');
         keywordButton.id = 'keyword-assignment-button';
         keywordButton.title = "Asignar/Quitar palabra clave filtro";
         keywordButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/IMG_4314.PNG" alt="Asignar Keyword">`;
         document.body.appendChild(keywordButton);
         keywordButton.addEventListener('click', () => { toggleKeywordAssignmentMode(!isKeywordAssignmentMode); });
    }
    if (!document.getElementById('password-toggle-button')) {
        const passwordButton = document.createElement('span');
        passwordButton.id = 'password-toggle-button';
        passwordButton.innerHTML = `<img src="" alt="Clave">`;
        document.body.appendChild(passwordButton);
        passwordButton.addEventListener('click', handlePasswordToggleClick);
    }
    if (!document.getElementById('versions-button')) {
         versionsButton = document.createElement('span');
         versionsButton.id = 'versions-button';
         versionsButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/IMG_4309.PNG" alt="Versiones">`;
         document.body.appendChild(versionsButton);
         versionsButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; showVersionsModal(); });
    }
    if (!document.getElementById('info-button')) {
         infoButton = document.createElement('span');
         infoButton.id = 'info-button';
         infoButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/PNG/IMG_4326.PNG" alt="Info">`;
         document.body.appendChild(infoButton);
         infoButton.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; window.open('https://boardinggate.github.io/Tesla/manual.html', '_blank'); });
    }
}  
    
    // ===================================================================
    // NOMBRE: handleGridCellClick
    // RESUMEN: Gestiona los clics en las celdas del grid, según el modo activo.
    function handleGridCellClick(event) {
        const cellContainer = event.currentTarget; const index = parseInt(cellContainer.dataset.index);
        if (isEditMode) { const link = cellContainer.querySelector('a.bookmark-item'); if (link) event.preventDefault(); showEditModal(index, false); }
        else if (isAssignmentMode) { event.preventDefault(); handleGridCellClickForAssignment(index); }
        else if (isKeywordAssignmentMode) { event.preventDefault(); handleKeywordAssignmentClick(index); }
        else { const link = cellContainer.querySelector('a.bookmark-item'); const bookmarkData = currentBookmarks[index];
            if (!link || !link.href || link.href === '#') {
                event.preventDefault();
                if (bookmarkData && bookmarkData.url && bookmarkData.url.startsWith("map-action:")) {
                    const action = bookmarkData.url.split(":")[1];
                    if (action === "openRemindersMapWithNoRadars") {
                        openLocationsPreviewMap();
                    } else if (action === "openRemindersMap") {
                        openNavigationMap();
                    }
                }
            } else {
                if (!link.target && bookmarkData && bookmarkData.name !== "Inicio Tesla") {
                    link.target = "_blank"; link.rel = "noopener noreferrer";
                }
            }
        }
    }
    
    // ===================================================================
    // NOMBRE: handleToggleClick
    // RESUMEN: Gestiona los clics en los botones laterales de sección, según el modo activo.
    function handleToggleClick(event) { const toggle = event.currentTarget; if (isEditMode) { event.preventDefault(); const start = parseInt(toggle.dataset.rangeStart); showEditModal(start, true); } else if (isAssignmentMode) { event.preventDefault(); handleToggleClickForAssignment(toggle); } else if (isKeywordAssignmentMode) { event.preventDefault(); } else { updateToggleState(toggle); } }
    
    
    // ===================================================================
    // NOMBRE: updateToggleState
    // RESUMEN: Cambia el estado (visible/oculto) de un botón de sección.
    function updateToggleState(toggle) { if (!toggle || isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const start = parseInt(toggle.dataset.rangeStart); if (isNaN(start)) return; const rangeConfig = currentToggleRanges.find(r => r.start === start); if (!rangeConfig) return; const currentState = toggle.dataset.state; const newState = currentState === 'visible' ? 'hidden' : 'visible'; toggle.dataset.state = newState; const savedStates = JSON.parse(localStorage.getItem('toggleStates') || '{}'); savedStates[start] = newState; localStorage.setItem('toggleStates', JSON.stringify(savedStates)); updateButtonStyles(); filterGridItems(); } 
    
    
    // ===================================================================
    // NOMBRE: updateAllToggles
    // RESUMEN: Cambia el estado de todos los toggles a la vez (on/off general).
    function updateAllToggles(newState) { const onOffToggleElem = document.getElementById('on-off-toggle'); if (!onOffToggleElem) return; onOffToggleElem.dataset.state = newState; localStorage.setItem('onOffState', newState); updateButtonStyles(); filterGridItems(); saveSettings(); }
    const scrollToggle = document.getElementById('scroll-toggle'); if (scrollToggle) scrollToggle.addEventListener('click', () => { if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return; const sP = window.scrollY; const mS = document.body.scrollHeight - window.innerHeight; window.scrollTo({ top: sP < 100 ? mS : 0, behavior: 'smooth' }); });
    
    // ===================================================================
    // NOMBRE: handleOnOffAction
    // RESUMEN: Maneja la acción del botón de on/off general.
    function handleOnOffAction() { if (pressStartTime !== null) { const t = document.getElementById('on-off-toggle'); if (t) { const nS = t.dataset.state === 'on' ? 'off' : 'on'; updateAllToggles(nS); } } pressStartTime = null; } 
    
    // ===================================================================
    // NOMBRE: handleReminderLongPress
    // RESUMEN: Maneja el clic corto/largo en el botón de recordatorios.
    function handleReminderLongPress() { if (reminderPressStartTime === null) return; const dur = Date.now() - reminderPressStartTime; if (dur >= 2000) showAllReminders(); else showReminderModal(); reminderPressStartTime = null; }
    
    // ===================================================================
    // NOMBRE: handlePersonalizationClick
    // RESUMEN: Gestiona el clic en el botón de personalización, mostrando el menú de opciones.
    function handlePersonalizationClick() {
        const personalButton = document.getElementById('personal-button'); const wasEditing = isEditMode; const wasAssigning = isAssignmentMode; const wasKeywordAssigning = isKeywordAssignmentMode;
        if (wasKeywordAssigning) { toggleKeywordAssignmentMode(false); }
        if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
        if (wasEditing) { toggleEditMode(false); } else if (wasAssigning) { toggleAssignmentMode(false); } else if (!wasKeywordAssigning) { showPersonalizationChoice(); }
    }
    
    // ===================================================================
    // NOMBRE: showPersonalizationChoice
    // RESUMEN: Muestra el modal para elegir el tipo de personalización.
    function showPersonalizationChoice() {
        const existingModal = document.querySelector('.choice-modal'); if (existingModal) existingModal.remove();
        const modal = document.createElement('div'); modal.className = 'choice-modal'; modal.setAttribute('aria-label', 'Elegir tipo de personalización');
        modal.innerHTML = `
            <h2>¿Qué quieres personalizar?</h2>
            <div class="modal-top-buttons">
                <button class="choice-cancel">Cancelar</button>
            </div>
            <p class="mb-6">Elige una opción:</p>
            <div class="personalization-options">
                <button class="choice-edit">URLs / Etiquetas / Reordenar</button>
                <button class="choice-assign">Asignar Botones Ocultación</button>
                <button class="choice-help">Ver Ayuda</button>
            </div>
        `;
        modal.querySelector('.choice-edit').addEventListener('click', () => { modal.remove(); toggleEditMode(true); });
        modal.querySelector('.choice-assign').addEventListener('click', () => { modal.remove(); toggleAssignmentMode(true); });
        modal.querySelector('.choice-help').addEventListener('click', () => { modal.remove(); showEditInfoModal(); });
        modal.querySelector('.choice-cancel').addEventListener('click', () => { modal.remove(); });
        document.body.appendChild(modal);
        addModalAutoCloseTimer(modal, modal.querySelector('.choice-cancel'), 'choice-modal', 30000);
    }
    
    
    // ===================================================================
    // NOMBRE: toggleEditMode
    // RESUMEN: Activa o desactiva el modo de edición (URLs, etiquetas, arrastrar).
    function toggleEditMode(activate) {
        const personalButton = document.getElementById('personal-button'); isEditMode = activate; personalButton.classList.toggle('editing', isEditMode); document.body.classList.toggle('editing-active', isEditMode);
        if (isEditMode) {
            if (isAssignmentMode) toggleAssignmentMode(false); if (isKeywordAssignmentMode) toggleKeywordAssignmentMode(false);
            if (firstPersonalizationSession) { showEditInfoModal(); firstPersonalizationSession = false; sessionStorage.setItem('personalizationHelpShown', 'true'); }
            showToast("Modo Edición (URLs/Etiquetas/Arrastrar) Activado", "info", 4000);
        } else {
            showToast("Modo Edición Desactivado", "info", 2000);
            cellElements.forEach(cell => cell.classList.remove('dragging', 'drag-over')); draggedItem = null; draggedItemIndex = null; currentTouchTarget = null; dragOverIndex = null;
            if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
        } renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles(); adjustButtonPositions();
        document.querySelectorAll('.range-toggle').forEach(el => { el.classList.toggle('editable', isEditMode); }); filterGridItems();
    }
     
    // ===================================================================
    // NOMBRE: toggleAssignmentMode
    // RESUMEN: Activa o desactiva el modo de asignación de botones a secciones.
    function toggleAssignmentMode(activate) {
        const personalButton = document.getElementById('personal-button'); isAssignmentMode = activate; personalButton.classList.toggle('assigning', isAssignmentMode); document.body.classList.toggle('assignment-active', isAssignmentMode);
        if (isAssignmentMode) {
            if (isEditMode) toggleEditMode(false); if (isKeywordAssignmentMode) toggleKeywordAssignmentMode(false);
            if (firstPersonalizationSession) { showEditInfoModal(); firstPersonalizationSession = false; sessionStorage.setItem('personalizationHelpShown', 'true'); }
            showToast("Modo Asignación Botones Activado", "info", 4000);
            const firstToggle = document.querySelector('.range-toggle');
            if (firstToggle) { handleToggleClickForAssignment(firstToggle); } else { currentlyAssigningToggleStart = null; updateGridAssignmentVisuals(); }
        } else {
            showToast("Modo Asignación Botones Desactivado", "info", 2000); saveCustomData();
            document.querySelectorAll('.range-toggle.assigning-selected').forEach(t => t.classList.remove('assigning-selected'));
            document.querySelectorAll('.grid-cell.assigned-to-current').forEach(c => { c.classList.remove('assigned-to-current'); c.style.opacity = ''; c.style.outline=''; c.style.boxShadow=''; c.style.backgroundColor = ''; });
            document.querySelectorAll('.range-toggle').forEach(t => t.style.opacity = '');
            currentlyAssigningToggleStart = null;
        } renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles(); adjustButtonPositions(); filterGridItems(); 
    }
    
    
    // ===================================================================
    // NOMBRE: toggleKeywordAssignmentMode
    // RESUMEN: Activa o desactiva el modo de asignación de palabras clave a los nombres de los marcadores.
    function toggleKeywordAssignmentMode(activate) {
         const keywordButton = document.getElementById('keyword-assignment-button'); const filterInput = document.getElementById('grid-filter-input'); isKeywordAssignmentMode = activate;
         if (keywordButton) { keywordButton.classList.toggle('active', isKeywordAssignmentMode); }
        document.body.classList.toggle('keyword-assignment-active', isKeywordAssignmentMode);
         if (isKeywordAssignmentMode) {
              if (isEditMode) toggleEditMode(false); if (isAssignmentMode) toggleAssignmentMode(false);
              const toastMessage = "Modo activo: Escribe palabra(s) en el campo filtro grid (separadas por espacio si son varias). Pulsa ICONO FILTRO para añadir/quitar esa(s) palabra(s) al nombre del botón(es) que vaya seleccionando. Pulsa el icono para salir de este modo.";
              showToast(toastMessage, "info", 15000); filterGridItems(); applyInitialKeywordHighlights();
         } else {
              showToast("Modo Asignación de Palabras Clave Desactivado", "info", 2000); cellElements.forEach(cell => cell.classList.remove('keyword-assigned-highlight')); filterGridItems();
         }
    }
    
    // ===================================================================
    // NOMBRE: applyInitialKeywordHighlights
    // RESUMEN: Resalta los marcadores que ya contienen la palabra clave del filtro al activar el modo.
    function applyInitialKeywordHighlights() { const filterInput = document.getElementById('grid-filter-input'); const keyword = filterInput.value.trim().replace(/\s+/g, '').toUpperCase(); if (!keyword) return; const keywordTag = `[${keyword}]`; cellElements.forEach((cell, index) => { const bookmark = currentBookmarks[index]; if (bookmark && bookmark.name && bookmark.name.includes(keywordTag)) { cell.classList.add('keyword-assigned-highlight'); } else { cell.classList.remove('keyword-assigned-highlight'); } }); }
    
    // ===================================================================
    // NOMBRE: handleKeywordAssignmentClick
    // RESUMEN: Añade o quita la palabra clave del filtro al nombre de un marcador.
    function handleKeywordAssignmentClick(index) {
        const filterInput = document.getElementById('grid-filter-input'); const keyword = filterInput.value.trim().replace(/\s+/g, '').toUpperCase();
        if (!keyword) { showToast("Escribe una palabra en el campo filtro primero.", "warning"); return; }
        const bookmark = currentBookmarks[index]; const cellElement = cellElements[index];
        if (!bookmark || !cellElement) { showToast(`No hay un marcador en la posición ${index + 1}.`, "warning"); return; }
        const keywordTag = `[${keyword}]`; const currentName = bookmark.name || ""; const nameSpan = cellElement.querySelector('.bookmark-name');
        let newName = currentName; let actionTaken = '';
        if (currentName.includes(keywordTag)) { newName = currentName.replace(keywordTag, '').replace(/\s{2,}/g, ' ').trim(); cellElement.classList.remove('keyword-assigned-highlight'); actionTaken = 'removed'; }
        else { newName = currentName.trim(); const lastBracketIndex = newName.lastIndexOf(']'); const endsWithBracket = lastBracketIndex !== -1 && lastBracketIndex === newName.length - 1;
            if (endsWithBracket) { newName += '  ' + keywordTag; } else { newName += '          ' + keywordTag; } cellElement.classList.add('keyword-assigned-highlight'); actionTaken = 'added'; }
        bookmark.name = newName; currentBookmarks[index] = { ...bookmark }; if (!customData.bookmarks) customData.bookmarks = {}; customData.bookmarks[index] = { ...bookmark }; saveCustomData();
        if (nameSpan) { nameSpan.textContent = newName; }
        if (actionTaken === 'added') { showToast(`"${keyword}" añadido. Nombre: ${newName}`, "success", 2500); } else if (actionTaken === 'removed') { showToast(`"${keyword}" quitado. Nombre: ${newName}`, "info", 2500); }
    }
    
    // ===================================================================
    // NOMBRE: handleToggleClickForAssignment
    // RESUMEN: Selecciona un botón de sección para empezar a asignarle marcadores.
    function handleToggleClickForAssignment(toggleElement) { const start = parseInt(toggleElement.dataset.rangeStart); if (isNaN(start)) return; currentlyAssigningToggleStart = start; document.querySelectorAll('.range-toggle').forEach(t => { t.classList.toggle('assigning-selected', t === toggleElement); t.style.opacity = t === toggleElement ? '' : '0.7'; }); updateGridAssignmentVisuals(); showToast(`Asignando botones para: ${toggleElement.textContent.substring(1)}`, "info", 2500); } 
    
    
    // ===================================================================
    // NOMBRE: handleGridCellClickForAssignment
    // RESUMEN: Asigna o desasigna un marcador a la sección actualmente seleccionada.
    function handleGridCellClickForAssignment(cellIndex) {
        if (currentlyAssigningToggleStart === null) { showToast("Selecciona primero un botón lateral (PdR,s, iAs, etc.)", "warning"); return; }
        const startKey = currentlyAssigningToggleStart.toString(); if (!customData.toggles[startKey]) { const currentRange = currentToggleRanges.find(r => r.start == startKey); customData.toggles[startKey] = { label: currentRange ? currentRange.label : `Rango ${startKey}`, assignedIndexes: currentRange ? [...currentRange.assignedIndexes] : [] }; }
        else if (!customData.toggles[startKey].assignedIndexes) { const currentRange = currentToggleRanges.find(r => r.start == startKey); customData.toggles[startKey].assignedIndexes = currentRange ? [...currentRange.assignedIndexes] : []; }
        const assigned = customData.toggles[startKey].assignedIndexes; const indexInArray = assigned.indexOf(cellIndex);
        if (indexInArray > -1) { assigned.splice(indexInArray, 1); } else { assigned.push(cellIndex); assigned.sort((a, b) => a - b); }
        const currentRangeIndex = currentToggleRanges.findIndex(r => r.start == startKey); if (currentRangeIndex > -1) { currentToggleRanges[currentRangeIndex].assignedIndexes = [...assigned]; }
        updateGridAssignmentVisuals(); saveCustomData(); showToast('Asignación guardada', 'success', 500);
    }
    
    // ===================================================================
    // NOMBRE: updateGridAssignmentVisuals
    // RESUMEN: Actualiza la apariencia visual del grid durante el modo de asignación.
    function updateGridAssignmentVisuals() { if (!isAssignmentMode || currentlyAssigningToggleStart === null) { cellElements.forEach(cell => { cell.classList.remove('assigned-to-current'); cell.style.opacity = ''; cell.style.outline = ''; cell.style.boxShadow = ''; }); return; } const startKey = currentlyAssigningToggleStart.toString(); let assignedIndexesForCurrentToggle = []; if (customData.toggles[startKey] && customData.toggles[startKey].assignedIndexes) { assignedIndexesForCurrentToggle = customData.toggles[startKey].assignedIndexes; } else { const currentRange = currentToggleRanges.find(r => r.start == startKey); if (currentRange?.assignedIndexes) { assignedIndexesForCurrentToggle = currentRange.assignedIndexes; } } cellElements.forEach((cell, index) => { const isAssigned = assignedIndexesForCurrentToggle.includes(index); cell.classList.toggle('assigned-to-current', isAssigned); if (isAssigned) { cell.style.opacity = ''; cell.style.outline = '3px solid cyan'; cell.style.boxShadow = document.body.classList.contains('dark-mode') ? 'inset 0 0 10px rgba(0, 200, 200, 0.7)' : 'inset 0 0 8px rgba(0, 255, 255, 0.6)'; } else { cell.style.opacity = document.body.classList.contains('dark-mode') ? '0.5' : '0.6'; cell.style.outline = `1px dashed ${document.body.classList.contains('dark-mode') ? '#555' : '#aaa'}`; cell.style.boxShadow = ''; } }); } 
    
    
    // ===================================================================
    // NOMBRE: showEditInfoModal
    // RESUMEN: Muestra el modal con la ayuda sobre los modos de personalización.
    function showEditInfoModal() {
        const existingModal = document.querySelector('.edit-info-modal'); if (existingModal) existingModal.remove();
        const modal = document.createElement('div'); modal.className = 'edit-info-modal'; modal.setAttribute('aria-label', 'Ayuda Personalización');
        modal.innerHTML = `
            <h2 class="text-xl font-bold mb-4">Ayuda de Personalización</h2>
            <div class="modal-top-buttons" style="justify-content: flex-end;">
                <button type="button" id="close-edit-info" class="px-6 py-2" style="flex: 0 1 auto; min-width: 120px;">Entendido</button>
            </div>
            <p class="mb-3">Al pulsar el botón <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (personalizar) o el icono <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4314.PNG" alt="Key" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (llave) puedes elegir entre varios modos:</p>
            <div class="mb-4 p-3 bg-yellow-100 border border-yellow-300 rounded">
                 <h3 class="font-semibold text-lg mb-2">1. Editar URLs / Etiquetas / Reordenar (Botón Personalizar Amarillo)</h3>
                 <ul class="list-disc pl-5 space-y-1 text-sm">
                    <li><strong>Activar:</strong> Elige "URLs / Etiquetas / Reordenar" en el menú inicial. El botón <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> se pondrá amarillo.</li>
                    <li><strong>Editar Marcador/Botón Lateral:</strong> Haz clic en un marcador del grid o en un botón lateral (PdR,s, iAs, etc.). Se abrirá una ventana para editar su nombre, URL (si es marcador) o etiqueta (si es botón lateral). <strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                    <li><strong>Arrastrar y Soltar:</strong> Mantén pulsado un marcador del grid y arrástralo a otra posición (incluso vacía) para reordenarlos.</li>
                    <li><strong>Guardar Cambios:</strong> Los cambios en nombre/URL/etiqueta se guardan al pulsar "Guardar" en la ventana de edición. El reordenamiento se guarda automáticamente al soltar.</li>
                    <li><strong>Vaciar Casilla:</strong> En la ventana de edición de un marcador, pulsa "Vaciar" para eliminarlo.</li>
                    <li><strong>Resetear:</strong> En la ventana de edición, pulsa "Resetear" para volver a los valores originales (si los tenía).</li>
                 </ul>
            </div>
            <div class="mb-4 p-3 bg-cyan-100 border border-cyan-300 rounded">
                <h3 class="font-semibold text-lg mb-2">2. Asignar Botones Ocultación (Botón Personalizar Cian)</h3>
                <ul class="list-disc pl-5 space-y-1 text-sm">
                    <li><strong>Activar:</strong> Elige "Asignar Botones Ocultación" en el menú inicial. El botón <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> se pondrá cian.</li>
                    <li><strong>Seleccionar Botón Lateral:</strong> Haz clic en el botón lateral (PdR,s, iAs, etc.) cuyos marcadores quieres definir. Se resaltará.</li>
                    <li><strong>Asignar/Desasignar Marcadores:</strong> Haz clic en cualquier marcador de la rejilla. Si estaba asignado, se desasignará (atenuado). Si no lo estaba, se asignará (resaltado). <strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                    <li><strong>Cambiar Botón Lateral:</strong> Haz clic en otro botón lateral para asignar sus marcadores.</li>
                    <li><strong>Guardar:</strong> Los cambios se guardan automáticamente al salir de este modo (pulsando el botón <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:16px; height:16px; display:inline; vertical-align:middle;"> cian).</li>
                    <li><strong>Visibilidad por defecto:</strong> Marcadores no asignados a <i>ningún</i> botón lateral siempre serán visibles (salvo que el botón general <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4191.jpg" alt="OFF" style="width:20px; height:11px; display:inline; vertical-align:middle;"> esté desactivado).</li>
                </ul>
            </div>
            <div class="mb-4 p-3 bg-green-100 border border-green-300 rounded">
            <h3 class="font-semibold text-lg mb-2">3. Asignar Palabra Clave Filtro (Icono Llave Verde)</h3>
            <ul class="list-disc pl-5 space-y-1 text-sm">
                <li><strong>Activar:</strong> Pulsa el icono de la llave <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4314.PNG" alt="Key" style="width:16px; height:16px; display:inline; vertical-align:middle;"> junto al campo de filtro. El icono se pondrá verde. Si vuelves a pulsar, se desactivará.</li>
                <li><strong>Escribe la Palabra:</strong> Escribe la palabra que quieres añadir al nombre de los botones en el campo de filtro. Se eliminarán los espacios automáticamente.</li>
                <li><strong>Asignar:</strong> Haz clic en el botón del grid al que quieres añadir la palabra clave. La palabra (en corchetes) se añadirá a su nombre (si no existe ya).</li>
                <li><strong><span style="color:red;">Hacer clic NO abre la URL en este modo.</span></strong></li>
                <li><strong>Guardar:</strong> Los cambios se guardan automáticamente cada vez que asignas una palabra clave a un botón.</li>
                <li><strong>Mostrar Todo:</strong> Al activar este modo, se limpiará el filtro y se mostrarán todos los botones para facilitar la asignación.</li>
            </ul>
            </div>
            <p class="mb-4"><strong>Salir de Personalización:</strong> Pulsa el botón activo <img src="https://boardinggate.github.io/Tesla/PNG/personal.png" alt="P" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (amarillo o cian) o el icono de la llave <img src="https://boardinggate.github.io/Tesla/PNG/IMG_4314.PNG" alt="Key" style="width:20px; height:20px; display:inline; vertical-align:middle;"> (verde) para desactivar el modo actual y volver al uso normal.</p>
        `;
        document.body.appendChild(modal);
        const closeEditInfoButton = modal.querySelector('#close-edit-info');
        const closeHandler = () => { clearModalAutoCloseTimer(modal, closeEditInfoButton, 'edit-info-modal'); if (modal.parentNode) modal.parentNode.removeChild(modal); };
        closeEditInfoButton.addEventListener('click', closeHandler); addModalAutoCloseTimer(modal, closeEditInfoButton, 'edit-info-modal');
    }
    
    // ===================================================================
    // NOMBRE: showEditModal
    // RESUMEN: Muestra el modal para editar los detalles de un marcador o de un botón de sección.
    function showEditModal(targetIndexOrStart, isToggle = false) { if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); } const existingModal = document.querySelector('.edit-modal'); if (existingModal) existingModal.remove(); const modal = document.createElement('div'); modal.className = 'edit-modal'; if (isToggle) { editingTargetElement = toggleButtonElements[targetIndexOrStart]; } else { editingTargetElement = cellElements[targetIndexOrStart]; } if (editingTargetElement) { editingTargetElement.classList.add('editing-target'); } else { } let currentItemData = {}; let originalItemData = {}; let title = ''; let isNewBookmark = false; const targetIndex = isToggle ? -1 : targetIndexOrStart; if (isToggle) { const targetStart = targetIndexOrStart; const currentRange = currentToggleRanges.find(r => r.start === targetStart); const originalRange = originalToggleRanges.find(r => r.start === targetStart); const currentLabel = customData.toggles[targetStart]?.label ?? currentRange?.label ?? ''; currentItemData = { label: currentLabel }; originalItemData = { label: originalRange?.label || '' }; title = `Editar Etiqueta Sección`;
        modal.innerHTML = `
            <h2>${title}</h2>
            <div class="modal-top-buttons" style="margin-bottom: 1.2rem;">
                <button class="save">Guardar</button>
                <button class="reset">Resetear</button>
                <button class="cancel">Cancelar</button>
            </div>
            <div><label for="edit-label">Etiqueta (máx 7):</label><input type="text" id="edit-label" value="${currentItemData.label}" maxlength="7"></div>
        `;
    } else { const currentBookmark = currentBookmarks[targetIndex]; const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null; currentItemData = currentBookmark ? { ...currentBookmark } : { name: '', url: '', favicon: '' }; originalItemData = originalBookmark ? { ...originalBookmark } : { name: '', url: '', favicon: '' }; isNewBookmark = !currentBookmark; title = currentBookmark ? `Editar Marcador: ${currentItemData?.name || `Índice ${targetIndex}`}` : `Añadir Marcador (Posición ${targetIndex + 1})`;
        modal.innerHTML = `
            <h2>${title}</h2>
            <div class="modal-top-buttons" style="margin-bottom: 1.2rem;">
                <button class="save">Guardar</button>
                <button class="reset">Resetear</button>
                <button class="empty">Vaciar</button>
                <button class="cancel">Cancelar</button>
            </div>
            <div><label for="edit-name">Nombre:</label><input type="text" id="edit-name" value="${currentItemData.name || ''}"></div>
            <div><label for="edit-url">URL:</label><div class="input-with-button"><input type="url" id="edit-url" value="${currentItemData.url || ''}" placeholder="https://ejemplo.com"><button class="search-button" id="search-url-button" title="Buscar URL en Google (basado en URL/Nombre)">🔍</button></div></div>
            <div><label for="edit-favicon">URL Favicon (Opcional):</label><div class="input-with-button"><input type="text" id="edit-favicon" value="${currentItemData.favicon || ''}" placeholder="Dejar vacío para auto"><button class="search-button" id="search-favicon-button" title="Buscar Favicon en Google Images (basado en Favicon/Nombre)">🖼️</button></div></div>
        `;
    } document.body.appendChild(modal); const cleanupEditModal = () => { if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; } if (modal.parentNode) modal.parentNode.removeChild(modal); }; modal.querySelector('.save').addEventListener('click', () => { let dataChanged = false; if (isToggle) { const targetStart = targetIndexOrStart; const newLabel = modal.querySelector('#edit-label').value.trim(); if (!newLabel) { showToast("La etiqueta no puede estar vacía.", "warning"); return; } if (newLabel.length > 7) { showToast("La etiqueta no puede exceder 7 caracteres.", "warning"); return; } const originalLabel = originalToggleRanges.find(r => r.start === targetStart)?.label || ''; if (newLabel !== originalLabel) { if (!customData.toggles[targetStart]) customData.toggles[targetStart] = {}; customData.toggles[targetStart].label = newLabel; dataChanged = true; } else { if (customData.toggles[targetStart] && customData.toggles[targetStart].hasOwnProperty('label')) { delete customData.toggles[targetStart].label; if (Object.keys(customData.toggles[targetStart]).length === 0) delete customData.toggles[targetStart]; dataChanged = true; } } const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetStart); if (rangeIdx > -1) currentToggleRanges[rangeIdx].label = newLabel; } else { const nameInput = modal.querySelector('#edit-name'); const urlInput = modal.querySelector('#edit-url'); const faviconInput = modal.querySelector('#edit-favicon');
                const newName = nameInput.value.trim();
                const newUrl = urlInput.value.trim();
                const newFavicon = faviconInput.value.trim() || null;
                const isEmpty = !newName && !newUrl && !newFavicon;
                const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                if (isEmpty) {
                    if (originalBookmark !== null && originalBookmark !== undefined) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = null;
                        dataChanged = true;
                    } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = null;
                } else {
                    if (!newName || !newUrl) {
                        showToast("Nombre y URL son obligatorios.", "warning");
                        return;
                    }
                    try { new URL(newUrl); } catch (_) {
                        showToast("URL inválida.", "warning");
                        return;
                    }
                    const bookmarkUpdate = { name: newName, url: newUrl, favicon: newFavicon };
                    const originalData = originalBookmark ? { name: originalBookmark.name, url: originalBookmark.url, favicon: originalBookmark.favicon || null } : null;
                    const bookmarksAreEqual = (b1, b2) => { if (b1 === null && b2 === null) return true; if (b1 === null || b2 === null) return false; return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null); };
                    if (!bookmarksAreEqual(bookmarkUpdate, originalData)) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = bookmarkUpdate;
                        dataChanged = true;
                   } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = bookmarkUpdate;
                }
            }
            if (dataChanged) {
                saveCustomData();
                showToast("Cambios guardados", "success");
            } else {
          }
            updateGridItemUI(targetIndexOrStart, isToggle);
            cleanupEditModal();
        });
        modal.querySelector('.reset').addEventListener('click', () => {
            let dataChanged = false;
            if (isToggle) {
                const targetStart = targetIndexOrStart;
                const originalRange = originalToggleRanges.find(r => r.start === targetStart);
                const originalLabel = originalRange?.label || '';
                modal.querySelector('#edit-label').value = originalLabel;
                if (customData.toggles && customData.toggles[targetStart] && customData.toggles[targetStart].hasOwnProperty('label')) {
                    delete customData.toggles[targetStart].label;
                    if (Object.keys(customData.toggles[targetStart]).length === 0) delete customData.toggles[targetStart];
                    dataChanged = true;
                }
                const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetStart);
                if (rangeIdx > -1) currentToggleRanges[rangeIdx].label = originalLabel;
            } else {
                const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                modal.querySelector('#edit-name').value = originalBookmark?.name || '';
                modal.querySelector('#edit-url').value = originalBookmark?.url || '';
                modal.querySelector('#edit-favicon').value = originalBookmark?.favicon || '';
                if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                    delete customData.bookmarks[targetIndex];
                    dataChanged = true;
                }
                currentBookmarks[targetIndex] = originalBookmark ? { ...originalBookmark } : null;
            }
            if (dataChanged) {
                saveCustomData();
                showToast("Valores reseteados al original y guardados", "info");
            } else {
                showToast("Ya estaba con los valores originales", "info");
            }
            updateGridItemUI(targetIndexOrStart, isToggle);
            cleanupEditModal();
        });
        modal.querySelector('.cancel').addEventListener('click', cleanupEditModal);
        if (!isToggle) {
            const emptyBtn = modal.querySelector('.empty');
            if (emptyBtn) {
                emptyBtn.addEventListener('click', () => {
                    modal.querySelector('#edit-name').value = '';
                    modal.querySelector('#edit-url').value = '';
                    modal.querySelector('#edit-favicon').value = '';
                    const originalBookmark = targetIndex < originalBookmarks.length ? originalBookmarks[targetIndex] : null;
                    let dataChanged = false;
                    if (originalBookmark !== null && originalBookmark !== undefined) {
                        if (!customData.bookmarks) customData.bookmarks = {};
                        customData.bookmarks[targetIndex] = null;
                        dataChanged = true;
                    } else {
                        if (customData.bookmarks && customData.bookmarks.hasOwnProperty(targetIndex)) {
                            delete customData.bookmarks[targetIndex];
                            dataChanged = true;
                        }
                    }
                    currentBookmarks[targetIndex] = null;
                    if(dataChanged) {
                        saveCustomData();
                        showToast("Marcador vaciado y guardado.", "success");
                    } else {
                        oast("Marcador ya estaba vacío.", "info");
                    }
                    updateGridItemUI(targetIndex, false);
                    cleanupEditModal();
                });
            }
            const searchUrlBtn = modal.querySelector('#search-url-button');
            const searchFaviconBtn = modal.querySelector('#search-favicon-button');
            const nameInput = modal.querySelector('#edit-name');
            const urlInputSearch = modal.querySelector('#edit-url');
            const faviconInputSearch = modal.querySelector('#edit-favicon');
            if (searchUrlBtn) {
                searchUrlBtn.addEventListener('click', () => {
                    const urlValue = urlInputSearch.value.trim();
                    const nameValue = nameInput.value.trim();
                    const query = urlValue || nameValue;
                    if (query) { window.open(`https://www.google.com/search?q=${encodeURIComponent(query)}`, '_blank'); }
                    else { showToast("Escribe un Nombre o URL para buscar.", "warning"); }
                });
            }
            if (searchFaviconBtn) {
                searchFaviconBtn.addEventListener('click', () => {
                    const faviconValue = faviconInputSearch.value.trim();
                    const nameValue = nameInput.value.trim();
                    const query = faviconValue || nameValue;
                    if (query) { window.open(`https://www.google.com/search?tbm=isch&q=${encodeURIComponent(`"${query}" favicon logo icon`)}`, '_blank'); }
                    else { showToast("Escribe un Nombre o URL de Favicon para buscar.", "warning"); }
                });
            }
        }
    }
       
    
    // ===================================================================
    // NOMBRE: updateGridItemUI
    // RESUMEN: Redibuja el grid y los botones para reflejar los cambios realizados en la edición.
    function updateGridItemUI(indexOrStart, isToggle = false) {
        renderGrid(); renderToggleButtons(); loadSavedSettings(); updateButtonStyles();adjustButtonPositions();
        if (isAssignmentMode) {
            updateGridAssignmentVisuals();
            if (currentlyAssigningToggleStart !== null && toggleButtonElements[currentlyAssigningToggleStart]) {
                toggleButtonElements[currentlyAssigningToggleStart].classList.add('assigning-selected');
                toggleButtonElements[currentlyAssigningToggleStart].style.opacity = '';
            }
        } else if (isKeywordAssignmentMode) { applyInitialKeywordHighlights(); }
    }  
    
    
    // ===================================================================
    // NOMBRE: performInsertAndSave
    // RESUMEN: Realiza la lógica de mover un marcador en el grid y guarda los cambios.
    function performInsertAndSave(sourceIndex, targetIndex) { if (sourceIndex === targetIndex || sourceIndex === null || targetIndex === null) { return false; } const draggedData = currentBookmarks.splice(sourceIndex, 1)[0]; currentBookmarks.splice(targetIndex, 0, draggedData); if (!customData.bookmarks) customData.bookmarks = {}; if (!customData.toggles) customData.toggles = {}; const minIdx = Math.min(sourceIndex, targetIndex); const maxIdx = Math.max(sourceIndex, targetIndex); currentToggleRanges.forEach(range => { if (range.assignedIndexes) {
        range.assignedIndexes = range.assignedIndexes.map(idx => { if (idx === sourceIndex) return targetIndex; else if (idx > sourceIndex && idx <= targetIndex) return idx - 1; else if (idx < sourceIndex && idx >= targetIndex) return idx + 1; else return idx; }).sort((a, b) => a - b); const startKey = range.start.toString(); if (customData.toggles[startKey] && customData.toggles[startKey].hasOwnProperty('assignedIndexes')) { customData.toggles[startKey].assignedIndexes = [...range.assignedIndexes]; } } }); for (let i = minIdx; i <= maxIdx; i++) { const currentItem = currentBookmarks[i]; const originalItem = i < originalBookmarks.length ? originalBookmarks[i] : null; const bookmarksAreEqual = (b1, b2) => { if (b1 === null && b2 === null) return true; if (b1 === null || b2 === null) return false; return b1.name === b2.name && b1.url === b2.url && (b1.favicon || null) === (b2.favicon || null); }; if (!bookmarksAreEqual(currentItem, originalItem)) { customData.bookmarks[i] = currentItem ? { ...currentItem } : null; } else if (customData.bookmarks.hasOwnProperty(i)) { delete customData.bookmarks[i]; } } saveCustomData(); renderGrid(); loadSavedSettings(); updateButtonStyles(); showToast(`Movido de ${sourceIndex + 1} a ${targetIndex + 1}`, "success", 1500); return true; }
    
    // ===================================================================
    // NOMBRE: handleDragStart
    // RESUMEN: Maneja el inicio del arrastre de un elemento del grid.
    function handleDragStart(e) { if (!isEditMode) return; draggedItem = e.currentTarget; draggedItemIndex = parseInt(draggedItem.dataset.index); e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', draggedItemIndex); setTimeout(() => { if (draggedItem) draggedItem.classList.add('dragging'); }, 0); }
    
    
    // ===================================================================
    // NOMBRE: handleDragOver
    // RESUMEN: Maneja el evento cuando un elemento arrastrado pasa sobre otro.
    function handleDragOver(e) { if (!isEditMode || !draggedItem) return; e.preventDefault(); e.dataTransfer.dropEffect = 'move'; const targetCell = e.target.closest('.grid-cell'); const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetCell && targetIndex !== dragOverIndex) { if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } if (targetIndex !== draggedItemIndex) { targetCell.classList.add('drag-over'); dragOverIndex = targetIndex; } else { dragOverIndex = null; } } else if (!targetCell && dragOverIndex !== null) { if (cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } dragOverIndex = null; } }
    
    // ===================================================================
    // NOMBRE: handleDragLeave
    // RESUMEN: Maneja el evento cuando un elemento arrastrado sale de una celda destino.
    function handleDragLeave(e) { if (!isEditMode || !draggedItem) return; const targetCell = e.target.closest('.grid-cell'); if (targetCell && !targetCell.contains(e.relatedTarget)) { if (parseInt(targetCell.dataset.index) === dragOverIndex) { targetCell.classList.remove('drag-over'); dragOverIndex = null; } } }
    
    // ===================================================================
    // NOMBRE: handleDrop
    // RESUMEN: Maneja el evento de soltar un elemento arrastrado.
    function handleDrop(e) { if (!isEditMode || !draggedItem) return; e.preventDefault(); const targetCell = e.target.closest('.grid-cell'); const sourceIndex = draggedItemIndex; const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetIndex !== null && sourceIndex !== targetIndex) { performInsertAndSave(sourceIndex, targetIndex); } else { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } } handleDragEndCleanup(); }
    
    // ===================================================================
    // NOMBRE: handleDragEndCleanup
    // RESUMEN: Limpia las variables y estilos de la operación de arrastre.
    function handleDragEndCleanup() { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } draggedItem = null; draggedItemIndex = null; dragOverIndex = null; }
    
    // ===================================================================
    // NOMBRE: handleTouchStart
    // RESUMEN: Maneja el inicio de un toque para el arrastre en dispositivos táctiles.
    function handleTouchStart(e) { if (!isEditMode || e.touches.length !== 1) return; draggedItem = e.currentTarget; draggedItemIndex = parseInt(draggedItem.dataset.index); const touch = e.touches[0]; touchStartX = touch.clientX; touchStartY = touch.clientY; draggedItem.classList.add('dragging'); currentTouchTarget = draggedItem; }
    
    // ===================================================================
    // NOMBRE: handleTouchMove
    // RESUMEN: Maneja el movimiento del dedo durante el arrastre táctil.
    function handleTouchMove(e) { if (!isEditMode || !draggedItem || e.touches.length !== 1) return; e.preventDefault(); const touch = e.touches[0]; const elementOver = document.elementFromPoint(touch.clientX, touch.clientY); const targetCell = elementOver?.closest('.grid-cell'); const targetIndex = targetCell ? parseInt(targetCell.dataset.index) : null; if (targetCell && targetIndex !== dragOverIndex) { if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } if (targetIndex !== draggedItemIndex) { targetCell.classList.add('drag-over'); dragOverIndex = targetIndex; currentTouchTarget = targetCell; } else { dragOverIndex = null; currentTouchTarget = draggedItem; } } else if (!targetCell && dragOverIndex !== null) { if (cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } dragOverIndex = null; currentTouchTarget = null; } }   
      
    // ===================================================================
    // NOMBRE: handleTouchEnd
    // RESUMEN: Maneja la finalización de un arrastre táctil.
    function handleTouchEnd(e) { if (!isEditMode || !draggedItem) return; if (dragOverIndex !== null && dragOverIndex !== draggedItemIndex) { performInsertAndSave(draggedItemIndex, dragOverIndex); e.preventDefault(); } else { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } } handleTouchEndCleanup(); }   
    
    // ===================================================================
    // NOMBRE: handleTouchEndCleanup
    // RESUMEN: Limpia las variables y estilos de la operación de arrastre táctil.
    function handleTouchEndCleanup() { if (draggedItem) draggedItem.classList.remove('dragging'); if (dragOverIndex !== null && cellElements[dragOverIndex]) { cellElements[dragOverIndex].classList.remove('drag-over'); } draggedItem = null; draggedItemIndex = null; dragOverIndex = null; currentTouchTarget = null; touchStartX = 0; touchStartY = 0; }
    
    // ===================================================================
    // NOMBRE: normalizeText
    // RESUMEN: Normaliza un texto (minúsculas, sin acentos) para facilitar comparaciones.
    function normalizeText(text) { if (!text) return ''; return text.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, ''); }
    
    // ===================================================================
    // NOMBRE: filterGridItems
    // RESUMEN: Filtra los elementos del grid según el texto del filtro y los toggles de sección.
    function filterGridItems() {
        const filterInput = document.getElementById('grid-filter-input');
        const clearButton = document.getElementById('clear-filter-button');
        if (!filterInput || !clearButton || !cellElements || cellElements.length === 0) { return; }
        if (isKeywordAssignmentMode) {
            cellElements.forEach(cellContainer => { cellContainer.classList.remove('hidden'); });
            clearButton.style.display = filterInput.value.trim() ? 'inline-block' : 'none';
            return;
        }
        const rawFilterText = filterInput.value.trim();
        clearButton.style.display = rawFilterText ? 'inline-block' : 'none';
        const filterWords = rawFilterText.split(/\s+/).filter(word => word.length > 0).map(word => normalizeText(word));
        const onOffToggleElem = document.getElementById('on-off-toggle');
        const masterState = onOffToggleElem ? (onOffToggleElem.dataset.state || 'on') : 'on';
        cellElements.forEach((cellContainer, index) => {
            const isMasterOff = masterState === 'off';
            if (isMasterOff) {
                cellContainer.classList.add('hidden');
                return;
            }
            const bookmark = currentBookmarks[index];
            const bookmarkName = bookmark ? normalizeText(bookmark.name) : '';
            const isEmptySlot = !bookmark;
            let matchesFilter = true;
            if (filterWords.length > 0) {
                if (isEmptySlot) {
                    matchesFilter = false;
                } else {
                    matchesFilter = filterWords.every(word => bookmarkName.includes(word));
                }
            }
            const shouldBeHiddenByFilter = filterWords.length > 0 && !matchesFilter;
            let shouldBeHiddenByToggles = false;
            const containingRange = getSectionForIndex(index);
            if (containingRange) {
                const toggleButton = toggleButtonElements[containingRange.start] || document.querySelector(`.range-toggle[data-range-start="${containingRange.start}"]`);
                if (toggleButton) {
                    const toggleState = toggleButton.dataset.state || 'visible';
                    shouldBeHiddenByToggles = toggleState === 'hidden';
                }
            } else {
                shouldBeHiddenByToggles = false;
            }
            const shouldBeHidden = shouldBeHiddenByToggles || shouldBeHiddenByFilter;
            cellContainer.classList.toggle('hidden', shouldBeHidden);
        });
    }
    
    // ===================================================================
    // NOMBRE: promptForPin
    // RESUMEN: Muestra el modal para introducir el PIN de acceso.
    function promptForPin() { const pinModal = document.getElementById('pin-modal-overlay'); const pinInput = document.getElementById('pin-input'); const pinSubmit = document.getElementById('pin-submit-button'); const pinError = document.getElementById('pin-error-message'); pinModal.classList.remove('hidden');
        pinInput.value = ''; pinError.textContent = ''; pinInput.focus(); const newPinSubmit = pinSubmit.cloneNode(true); pinSubmit.parentNode.replaceChild(newPinSubmit, pinSubmit); newPinSubmit.addEventListener('click', checkPin); pinInput.addEventListener('keyup', (event) => { if (event.key === 'Enter') { checkPin(); } }); }
    
    
    // ===================================================================
    // NOMBRE: checkPin
    // RESUMEN: Verifica el PIN introducido por el usuario.
    function checkPin() { const pinModal = document.getElementById('pin-modal-overlay'); const pinInput = document.getElementById('pin-input'); const pinError = document.getElementById('pin-error-message'); const enteredPin = pinInput.value; if (enteredPin === storedPin) { pinModal.classList.add('hidden'); initializeApp(); } else { pinError.textContent = 'Clave incorrecta.'; pinInput.value = ''; pinInput.focus(); if (navigator.vibrate) navigator.vibrate(100); } }
    
    // ===================================================================
    // NOMBRE: handlePasswordToggleClick
    // RESUMEN: Activa o desactiva la solicitud de PIN al inicio.
    function handlePasswordToggleClick() { if (!storedPin) { showToast('Primero establece una clave en Configuración -> Usuario.', 'warning'); return; } isPasswordActive = !isPasswordActive; updatePasswordToggleIcon(); saveSettings(); showToast(`Solicitar clave al inicio: ${isPasswordActive ? 'Activado' : 'Desactivado'}`, 'info'); }
    
    
    // ===================================================================
    // NOMBRE: updatePasswordToggleIcon
    // RESUMEN: Actualiza el icono del candado según si el PIN está activo o no.
    function updatePasswordToggleIcon() { const passwordButton = document.getElementById('password-toggle-button'); if (passwordButton) { const img = passwordButton.querySelector('img'); if(img) { const iconPath = isPasswordActive ? 'PNG/IMG_4281.png' : 'PNG/IMG_4280.png'; img.src = `https://boardinggate.github.io/Tesla/${iconPath}`;
        img.alt = isPasswordActive ? 'Clave Activada' : 'Clave Desactivada'; passwordButton.title = `Clave al inicio: ${isPasswordActive ? 'Activada' : 'Desactivada'}`; } } }
    
    // ===================================================================
    // NOMBRE: savePinSettings
    // RESUMEN: Guarda las nuevas configuraciones de PIN y preferencias de inicio.
    function savePinSettings() {
        const pinSetInput = document.getElementById('config-pin-set');
        const pinConfirmInput = document.getElementById('config-pin-confirm');
        const pinStatus = document.getElementById('config-pin-status');
        const directToNavCheckbox = document.getElementById('config-direct-to-nav');
        const newPin = pinSetInput.value;
        const confirmPin = pinConfirmInput.value;
        pinStatus.textContent = '';
        let keySaved = false;
        let prefSaved = false;
        if (newPin || confirmPin) {
            if (!/^\d{4}$/.test(newPin)) {
                pinStatus.textContent = 'La clave debe tener exactamente 4 cifras.';
                pinStatus.style.color = '#EF4444';
                return;
            }
            if (newPin !== confirmPin) {
                pinStatus.textContent = 'Las claves no coinciden.';
                pinStatus.style.color = '#EF4444';
                return;
            }
            try {
                localStorage.setItem('password_pin', newPin);
                storedPin = newPin;
                if (!localStorage.getItem('password_active') || isPasswordActive) {
                    isPasswordActive = true;
                    localStorage.setItem('password_active', 'true');
                }
                pinStatus.textContent = 'Clave guardada. ';
                pinStatus.style.color = '#28a745';
                pinSetInput.value = '';
                pinConfirmInput.value = '';
                updatePasswordToggleIcon();
                keySaved = true;
            } catch (e) {
                pinStatus.textContent ='Error al guardar la clave.';
                pinStatus.style.color = '#EF4444';
                showToast('Error al guardar la clave.', 'error');
            }
        }
        const directToNavChecked = directToNavCheckbox.checked;
        localStorage.setItem(DIRECT_TO_NAVIGATION_KEY, JSON.stringify(directToNavChecked));
        prefSaved = true;
        if (keySaved && prefSaved) {
            showToast('Clave y preferencia de inicio guardadas.', 'success');
            pinStatus.textContent += (pinStatus.textContent ? "Y " : "") + "Preferencia de inicio guardada.";
             pinStatus.style.color = '#28a745';
        } else if (keySaved) {
            showToast('Clave guardada. Preferencia de inicio también actualizada.', 'success');
             pinStatus.textContent += (pinStatus.textContent ? " " : "") + "Preferencia de inicio guardada.";
             pinStatus.style.color = '#28a745';
        } else if (prefSaved) {
            showToast('Preferencia de inicio guardada.', 'success');
            pinStatus.textContent = "Preferencia de inicio guardada.";
            pinStatus.style.color = '#28a745';
        } else if (!newPin && !confirmPin) {
             pinStatus.textContent = "No se realizaron cambios en la clave. Preferencia de inicio no cambió.";
             pinStatus.style.color = '#17a2b8';
        }
        saveSettings();
    }
    
    // ===================================================================
    // NOMBRE: removePinSettings
    // RESUMEN: Elimina la configuración de PIN de acceso.
    function removePinSettings() { const pinStatus = document.getElementById('config-pin-status'); if (confirm('¿Estás seguro de que deseas eliminar la clave de acceso? Ya no se solicitará al inicio.')) { try { localStorage.removeItem('password_pin'); localStorage.setItem('password_active', 'false'); storedPin = null; isPasswordActive = false; pinStatus.textContent = 'Clave eliminada.'; pinStatus.style.color = '#17a2b8'; document.getElementById('config-pin-set').value = ''; document.getElementById('config-pin-confirm').value = ''; updatePasswordToggleIcon(); saveSettings(); showToast('Clave eliminada.', 'info'); } catch (e) { pinStatus.textContent = 'Error al eliminar la clave.'; pinStatus.style.color = '#EF4444'; showToast('Error al eliminar la clave.', 'error'); } } }
    
    // ===================================================================
    // NOMBRE: getRemoteUpdatesDate
    // RESUMEN: Obtiene la fecha de la última actualización de un archivo remoto.
    async function getRemoteUpdatesDate() { try { const response = await fetch('https://boardinggate.github.io/Tesla/updates.txt', { cache: 'no-cache' }); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const text = await response.text(); const firstLine = text.split('\n')[0].trim(); const dateMatch = firstLine.match(/^\d{4}-\d{2}-\d{2}/); if (dateMatch) { const [year, month, day] = dateMatch[0].split('-').map(Number); const remoteDate = new Date(Date.UTC(year, month - 1, day)); if (!isNaN(remoteDate.getTime())) { return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`; } } return null; } catch (e) { return null; } }
    
    
    // ===================================================================
    // NOMBRE: isRemoteDateNewer
    // RESUMEN: Compara si una fecha remota es más reciente que una fecha en caché.
    function isRemoteDateNewer(remoteDateStr, cachedDateStr) { if (!remoteDateStr) return false; if (!cachedDateStr) return true; try { return remoteDateStr > cachedDateStr; } catch (e) { return false; } }
    
    // ===================================================================
    // NOMBRE: checkVersionsIconOpacity
    // RESUMEN: Ajusta la opacidad del icono de versiones si hay actualizaciones nuevas.
    async function checkVersionsIconOpacity() { const versionsIcon = document.getElementById('versions-button'); const versionsImg = versionsIcon ? versionsIcon.querySelector('img') : null; if (!versionsImg) return;
        let showAsNew = false; const remoteDateStr = await getRemoteUpdatesDate();
        if (remoteDateStr) { showAsNew = isRemoteDateNewer(remoteDateStr, lastUpdatesCheckDate); } versionsImg.style.opacity = showAsNew ? '1.0' : '0.1';
    }
    
    
    // ===================================================================
    // NOMBRE: showVersionsModal
    // RESUMEN: Muestra el modal con el historial de versiones.
    async function showVersionsModal() {
        const versionsModalOverlay = document.getElementById('versions-modal-overlay');
        const versionsContent = document.getElementById('versions-content');
        const closeButton = document.getElementById('close-versions-modal');
        if (!versionsModalOverlay || !versionsContent || !closeButton) return;
        const newCloseButton = closeButton.cloneNode(true);
        closeButton.parentNode.replaceChild(newCloseButton, closeButton);
        const closeHandler = () => {
            versionsModalOverlay.classList.add('hidden');
            clearModalAutoCloseTimer(versionsModalOverlay, newCloseButton, 'versions-modal');
        };
        newCloseButton.addEventListener('click', closeHandler);
        versionsContent.textContent = 'Cargando histórico...';
        versionsModalOverlay.classList.remove('hidden');
        addModalAutoCloseTimer(versionsModalOverlay, newCloseButton, 'versions-modal');
        try {
            const response = await fetch('https://boardinggate.github.io/Tesla/updates.txt', { cache: 'no-cache' });
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const text = await response.text();
            versionsContent.textContent = text;
            const firstLine = text.split('\n')[0].trim();
            const dateMatch = firstLine.match(/^\d{4}-\d{2}-\d{2}/);
            let dateToStore = null;
            if (dateMatch) {
                const [year, month, day] = dateMatch[0].split('-').map(Number);
                const checkDate = new Date(Date.UTC(year, month - 1, day));
                if (!isNaN(checkDate.getTime())) {
                    dateToStore = dateMatch[0];
                }
            }
            if (dateToStore) {
                lastUpdatesCheckDate = dateToStore;
            } else {
                const today = new Date();
                lastUpdatesCheckDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
            }
            saveSettings();
            await checkVersionsIconOpacity();
        } catch (e) {
            versionsContent.textContent = `Error al cargar el histórico:\n${e.message}`;
        }
    }
    
    // ===================================================================
    // NOMBRE: getCurrentLocation
    // RESUMEN: Obtiene la ubicación actual del dispositivo a través de la API de Geolocalización.
    function getCurrentLocation(callback, errorCallback) {
        if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    callback({
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy,
                        altitude: position.coords.altitude,
                        heading: position.coords.heading,
                        speed: position.coords.speed
                    });
                },
                (error) => {
                    let message = "No se pudo obtener la ubicación.";
                    switch (error.code) {
                        case error.PERMISSION_DENIED:
                            message = "Permiso de ubicación denegado.";
                            break;
                        case error.POSITION_UNAVAILABLE:
                            message = "Información de ubicación no disponible.";
                            break;
                        case error.TIMEOUT:
                            message = "Timeout obteniendo ubicación.";
                            break;
                    }
                    if (errorCallback) errorCallback(message);
                    else showToast(message, "error");
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        } else {
            const message = "Geolocalización no soportada por este navegador.";
            if (errorCallback) errorCallback(message);
            else showToast(message, "error");
        }
    }
    
    // ===================================================================
    // NOMBRE: calculateDistance
    // RESUMEN: Calcula la distancia en metros entre dos coordenadas geográficas.
    function calculateDistance(lat1, lon1, lat2, lon2) {
        if (typeof lat1 !== 'number' || typeof lon1 !== 'number' || typeof lat2 !== 'number' || typeof lon2 !== 'number' || isNaN(lat1) || isNaN(lon1) || isNaN(lat2) || isNaN(lon2)) {
             return Infinity;
        }
        const R = 6371e3; const φ1 = lat1 * Math.PI / 180; const φ2 = lat2 * Math.PI / 180; const Δφ = (lat2 - lat1) * Math.PI / 180; const Δλ = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return R * c;
    }
    
    
    
    // ===================================================================
    // NOMBRE: restoreCacheForMobile
    // RESUMEN: Descarga silenciosamente la caché de Firebase al iniciar en móvil.
    async function restoreCacheForMobile() {
        const { primaryId } = parseUserId(localStorage.getItem('userData_userId'));
        if (!primaryId) return;
        const result = await callFirebase('getUserData', { userId: primaryId });
        if (result.status === 'success' && result.data) {
            const backupCacheData = result.data.contenidoCacheCompleto;
            if (backupCacheData) {
                showToast('Sincronizando datos desde la nube...', 'info', 2000);
                const currentUserIdentity = localStorage.getItem('userData_userId');
                for (const key in backupCacheData) {
                    if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                        localStorage.setItem(key, backupCacheData[key]);
                    }
                }
                if (currentUserIdentity) {
                    localStorage.setItem('userData_userId', currentUserIdentity);
                }
                loadCustomData();
                loadSavedSettings();
                updateUserIdDisplay();
                checkReminders();
            }
        }
    }
    
// ===================================================================
// NOMBRE: hideUnifiedReminderWindow
// RESUMEN: Oculta la ventana unificada de recordatorios y limpia sus elementos.
function hideUnifiedReminderWindow() {
    if (realtimeSpeedUpdateInterval) {
        clearInterval(realtimeSpeedUpdateInterval);
        realtimeSpeedUpdateInterval = null;
    }
    const windowElement = document.getElementById('unified-reminder-window');
    if (windowElement && windowElement.classList.contains('visible')) {
        windowElement.classList.remove('visible');
        isUnifiedWindowVisibleByLogic = false;
        const swiperContainer = document.getElementById('reminder-swiper-container');
        Object.values(previewMaps).forEach(map => {
            if (map && typeof map.remove === 'function') {
                map.remove();
            }
        });
        previewMaps = {};
        if (swiperContainer) {
            swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay);
            setTimeout(() => {
                if (swiperContainer && !windowElement.classList.contains('visible')) {
                    swiperContainer.innerHTML = '';
                }
            }, 600);
        }
        const hideAllButton = document.getElementById('hide-all-reminders-button');
        if (hideAllButton) { const newHideAllButton = hideAllButton.cloneNode(true); hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton); }
        const mapShouldReopen = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
        const mapContextToReopen = sessionStorage.getItem('mapContext');
        sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes');
        if (mapShouldReopen &&
            !document.querySelector('.reminder-modal') &&
            !document.querySelector('.reminder-table-modal') &&
            !document.getElementById('reminders-location-map-modal')
           ) {
             if (mapContextToReopen === 'navigation') openNavigationMap();
              sessionStorage.removeItem('mapContext');
        }
    }
}
    
// ===================================================================
// NOMBRE: postponeAllVisibleReminders
// RESUMEN: Pospone todos los recordatorios actualmente visibles en la ventana unificada.
function postponeAllVisibleReminders() {
    const swiperContainer = document.getElementById('reminder-swiper-container'); if (!swiperContainer) return;
    const visibleSlides = swiperContainer.querySelectorAll('.reminder-slide'); if (visibleSlides.length === 0) return;
    let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    let updated = false;
    const idsToUpdate = [];
    visibleSlides.forEach(slide => {
        const reminderId = parseInt(slide.dataset.id);
        if (isNaN(reminderId)) return;
        idsToUpdate.push(reminderId);
        const index = reminders.findIndex(r => r.id === reminderId);
        if (index !== -1) {
            const { newDateISO, newTime } = calculatePostponedDateTime(1);
            reminders[index].date = newDateISO;
            reminders[index].time = newTime;
            reminders[index].managedByUser = false;
            updated = true;
        }
    });
    if (updated) {
        localStorage.setItem('reminders', JSON.stringify(reminders));
        
        // >>> ¡CORRECCIÓN CLAVE AÑADIDA AQUÍ! <<<
        // Marcamos la caché como sucia para que checkReminders la reconstruya.
        markRemindersCacheAsDirty();

        showToast(`${idsToUpdate.length} recordatorio(s) pospuesto(s) 1 minuto`, 'info');
        idsToUpdate.forEach(id => updateUnifiedWindowUI(id)); // Esto es para la UI, no afecta la lógica.
        updateReminderCount();
        updateButtonStyles();
    }
    if (idsToUpdate.length > 0 && document.getElementById('unified-reminder-window')?.classList.contains('visible')) {
       hideUnifiedReminderWindow();
    }
}

    
    // ===================================================================
    // NOMBRE: updateReminderIndexDisplay
    // RESUMEN: Actualiza el contador de índice del slide actual en la ventana unificada.
    function updateReminderIndexDisplay() {
        const swiperContainer = document.getElementById('reminder-swiper-container');
        const currentIndexSpan = document.getElementById('current-reminder-index');
        if (!swiperContainer || !currentIndexSpan) return;
        const totalSlides = swiperContainer.querySelectorAll('.reminder-slide').length;
        if (totalSlides === 0) {
            currentIndexSpan.textContent = '0';
            return;
        }
        const containerWidth = swiperContainer.offsetWidth;
        if (containerWidth <= 0) {
           return;
        }
        const currentScroll = swiperContainer.scrollLeft;
        const currentIndex = Math.round(currentScroll / containerWidth);
        currentNotificationSlideIndex = currentIndex;
        const displayIndex = Math.max(1, Math.min(currentIndex + 1, totalSlides));
        currentIndexSpan.textContent = displayIndex;
         const currentSlideElement = swiperContainer.querySelectorAll('.reminder-slide')[currentIndex];
         if (currentSlideElement && !isNavigationMapActive) {
            const mapId = currentSlideElement.querySelector('.reminder-map-preview')?.id;
            if (mapId) {
                 const reminderId = parseInt(mapId.replace('map-preview-', ''));
                 if (previewMaps[reminderId]) {
                     setTimeout(() => { if(previewMaps[reminderId]) previewMaps[reminderId].resize(); }, 50);
                 }
            }
         }
    }
    
    // ===================================================================
    // NOMBRE: updateUnifiedWindowUI
    // RESUMEN: Actualiza la UI de la ventana unificada después de que un recordatorio es gestionado.
    function updateUnifiedWindowUI(processedReminderId) {
        const windowElement = document.getElementById('unified-reminder-window');
        const swiperContainer = document.getElementById('reminder-swiper-container');
        const slideToRemove = swiperContainer ? swiperContainer.querySelector(`.reminder-slide[data-id="${processedReminderId}"]`) : null;
        if (previewMaps[processedReminderId]) {
           if (typeof previewMaps[processedReminderId].remove === 'function') {
               previewMaps[processedReminderId].remove();
           }
           delete previewMaps[processedReminderId];
        }
        if (slideToRemove && slideToRemove.parentNode === swiperContainer) {
            swiperContainer.removeChild(slideToRemove);
        }
        const remainingSlides = swiperContainer ? swiperContainer.querySelectorAll('.reminder-slide') : [];
        const remainingCount = remainingSlides.length;
        if (remainingCount === 0) {
            hideUnifiedReminderWindow();
        }
        else {
            const countHeader = windowElement.querySelector('.reminder-count-header');
            const countSpan = document.getElementById('total-reminder-count');
            const countTextContainer = document.getElementById('reminder-count-text-container');
            const swipeHint = document.getElementById('reminder-swipe-hint');
            countSpan.textContent = remainingCount;
            updateReminderIndexDisplay();
            if (remainingCount > 1) {
                countTextContainer.style.display = 'inline';
                swipeHint.style.display = 'block';
                document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = 'calc(85vh - 60px)');
            } else {
                countTextContainer.style.display = 'none';
                swipeHint.style.display = 'none';
                document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = '85vh');
            }
            const maxScrollIndex = remainingCount - 1;
            if (currentNotificationSlideIndex > maxScrollIndex) {
                 currentNotificationSlideIndex = maxScrollIndex;
                 swiperContainer.scrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
                 updateReminderIndexDisplay();
            }
        }
        updateReminderCount();
        updateButtonStyles();
    }
    
    
    // ===================================================================
    // NOMBRE: updateReminderCount
    // RESUMEN: Actualiza los contadores de recordatorios en la UI.
    function updateReminderCount() {
         let reminders = []; try { reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); } catch (e) { reminders = []; }
         const showExcludedInTable = JSON.parse(localStorage.getItem(SHOW_EXCLUDED_REMINDERS_KEY)) || false; let remindersForCount = reminders;
         if (!showExcludedInTable) { remindersForCount = reminders.filter(r => !r.excludeFromList); }
         const totalCount = remindersForCount.length; const nonCyclicReminders = remindersForCount.filter(r => r.type !== 'weekly' && r.type !== 'interval'); const nonCyclicCount = nonCyclicReminders.length;
         const countElGlobe = document.getElementById('reminder-count-globe'); if (countElGlobe) { countElGlobe.textContent = nonCyclicCount > 0 ? nonCyclicCount : ''; countElGlobe.style.display = nonCyclicCount > 0 ? 'flex' : 'none'; }
         const reminderButtonElem = document.getElementById('reminder-button'); if (reminderButtonElem) { let countSpanSide = reminderButtonElem.querySelector('.reminder-count'); if (totalCount > 0) { if (!countSpanSide) { countSpanSide = document.createElement('span'); countSpanSide.className = 'reminder-count'; reminderButtonElem.appendChild(countSpanSide); } countSpanSide.textContent = totalCount; } else { if (countSpanSide) { countSpanSide.remove(); } } }
    }
        
 
// ===================================================================
// NOMBRE: formatTimeWithPeriod
// RESUMEN: Formatea una hora (HH:MM) para añadir un período del día (Mañana, Tarde, etc.).
function formatTimeWithPeriod(timeString) {
     if (!timeString || !timeString.match(/^\d{2}:\d{2}$/)) return '-';
     try {
         const [hourStr, minuteStr] = timeString.split(':');
         const hour = parseInt(hourStr);
         const minute = parseInt(minuteStr);
         if (isNaN(hour) || isNaN(minute) || hour < 0 || hour > 23 || minute < 0 || minute > 59) {
             return timeString;
         }
         let period = '';
         if (hour >= 22 || hour < 5) { period = 'de la Noche'; }
         else if (hour >= 5 && hour < 12) { period = 'de la Mañana'; }
         else if (hour >= 12 && hour < 14) { period = 'del Mediodía'; }
         else { period = 'de la Tarde'; }
         return `${hourStr}:${minuteStr} (${period})`;
     } catch (e) {
         return timeString;
     }
}

// ===================================================================
// NOMBRE: formatDateDetailed
// RESUMEN: Formatea una fecha (YYYY-MM-DD) a un formato más legible (DD-Mes-YYYY).
function formatDateDetailed(dateString) {
    if (!dateString || !dateString.match(/^\d{4}-\d{2}-\d{2}$/)) return '-';
    try {
        const [year, month, day] = dateString.split('-').map(Number);
        const date = new Date(Date.UTC(year, month - 1, day));
        if (isNaN(date.getTime())) return dateString;
        const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
        const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
        const monthName = monthNames[date.getUTCMonth()];
        const fullYear = date.getUTCFullYear();
        return `${dayOfMonth}-${monthName}-${fullYear}`;
    } catch (e) {
        return dateString;
    }
}

// ===================================================================
// NOMBRE: extractSpeedFromRadarText (VERSIÓN ESTRICTA)
// RESUMEN: Extrae un límite de velocidad válido (entre 20-130) del texto de un recordatorio.
function extractSpeedFromRadarText(text) {
    if (!text) return null;
    const cleanText = text.replace(/<[^>]*>/g, '').toUpperCase();
    const validSpeeds = [20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130];

    const kmMatch = cleanText.match(/\b(\d{2,3})\s*KM/);
    if (kmMatch && kmMatch[1]) {
        const speed = parseInt(kmMatch[1], 10);
        if (validSpeeds.includes(speed)) return speed;
    }
    
    const codeMatch = cleanText.match(/\b[FCN](\d{2,3})\b/);
    if (codeMatch && codeMatch[1]) {
        const speed = parseInt(codeMatch[1], 10);
        if (validSpeeds.includes(speed)) return speed;
    }
    
    const looseNumbers = cleanText.match(/\b(\d{2,3})\b/g);
    if (looseNumbers) {
        for (const numStr of looseNumbers) {
            const speed = parseInt(numStr, 10);
            if (validSpeeds.includes(speed)) {
                return speed; 
            }
        }
    }

    return null; 
} 
      
// ===================================================================
// NOMBRE: displayUnifiedReminderWindow
// RESUMEN: Muestra y rellena la ventana unificada de recordatorios con los que están vencidos.
function displayUnifiedReminderWindow(overdueReminders) {
    const windowElement = document.getElementById('unified-reminder-window');
    const swiperContainer = document.getElementById('reminder-swiper-container');
    const countHeader = windowElement.querySelector('.reminder-count-header');
    const countSpan = document.getElementById('total-reminder-count');
    const currentIndexSpan = document.getElementById('current-reminder-index');
    const countTextContainer = document.getElementById('reminder-count-text-container');
    const swipeHint = document.getElementById('reminder-swipe-hint');
    const hideAllButton = document.getElementById('hide-all-reminders-button');
     Object.values(previewMaps).forEach(map => {
       if (map && typeof map.remove === 'function') {
           map.remove();
       }
     });
     previewMaps = {};
    if (realtimeSpeedUpdateInterval) {
        clearInterval(realtimeSpeedUpdateInterval);
        realtimeSpeedUpdateInterval = null;
    }
    if (!windowElement || !swiperContainer || !countHeader || !countSpan || !currentIndexSpan || !countTextContainer || !swipeHint || !hideAllButton) {
        return;
    }
    swiperContainer.innerHTML = '';
    overdueReminders.sort((a, b) => { try { const dateA = new Date(`${a.date}T${a.time}:00Z`); const dateB = new Date(`${b.date}T${b.time}:00Z`); return dateA - dateB; } catch (e) { return 0; } });
    if (!isUnifiedWindowVisibleByLogic) {
        currentNotificationSlideIndex = 0;
    }
    overdueReminders.forEach((reminder, index) => {
        const slide = document.createElement('div');
        slide.className = 'reminder-slide';
        slide.dataset.id = reminder.id;
        slide.setAttribute('role', 'group');
        slide.setAttribute('aria-label', `Recordatorio: ${reminder.text.replace(/<[^>]*>/g, '')}`);
        
        let slideContentHtml = '';
        const isRadarAlert = reminder.text.toUpperCase().includes("RADAR");

        if (isRadarAlert) {
            const radarSpeed = extractSpeedFromRadarText(reminder.text);
            const validSpeeds = [20, 30, 50, 60, 70, 80, 90, 100, 110, 120];
            const isStandardSpeed = radarSpeed !== null && validSpeeds.includes(radarSpeed);

            let speedLimitHtml = '';
            let currentSpeedHtml = '';

            if (isStandardSpeed) {
                speedLimitHtml = `<p class="reminder-text" style="color: red; font-weight: bold; text-transform: uppercase; font-size: 1.8rem; margin-bottom: 0.2rem; text-align: center;">${radarSpeed} Km/h</p>`;
            } else {
                speedLimitHtml = `<p class="reminder-text" style="color: red; font-weight: bold; text-transform: uppercase; font-size: 1.4rem; margin-bottom: 0.2rem; text-align: center;">RADAR DE TRAMO o INDETERMINADO</p>`;
            }

            const carSpeed = Math.round(window.currentSpeedKmh || 0);
            const speedExceeded = isStandardSpeed && carSpeed > radarSpeed;
            
            currentSpeedHtml = `<p id="current-speed-display-${reminder.id}" style="text-align:center; font-size: 1.7rem; font-weight: bold; color: ${speedExceeded ? 'red' : '#333'};">[Velocidad actual: ${carSpeed} Km/h]</p>`;

            slideContentHtml = `
                <div class="reminder-slide-content">
                    <img src="https://boardinggate.github.io/Tesla/PNG/AGUARDIA.png" alt="Icono Radar" class="radar-icon">
                    <div class="reminder-content-scrollable">
                        ${speedLimitHtml}
                        ${currentSpeedHtml}
                        <p class="reminder-text" style="text-align: center; margin-top: 0.5rem; ${isStandardSpeed ? 'font-size: 1rem; color: #444;' : ''}">${reminder.text}</p>
                    </div>
                    <div class="button-group">
                        <button class="route-radar-seen" style="background-color: #2563EB; color: white; font-weight: bold; height: 70px; font-size: 1.2rem;">VISTO (Posponer 5 min)</button>
                        <button class="modify">Modificar</button>
                    </div>
                </div>
            `;
        } else {
            let detailsHtml = '';
            if (reminder.time) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Hora: ${formatTimeWithPeriod(reminder.time)}</p>`;
            if (reminder.date) detailsHtml += `<p class="reminder-details" style="font-size: 1.15rem;">Fecha: ${formatDateDetailed(reminder.date)}</p>`;
            if (reminder.type === 'weekly' && reminder.repeatDays?.length > 0) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Repite: ${reminder.repeatDays.map(d => ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'][d]).join(', ')}</p>`;
            if (reminder.type === 'interval' && reminder.intervalDays) detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Cada: ${reminder.intervalDays} días</p>`;
            if (reminder.isLocationEnabled && reminder.locationCoordinates) {
                detailsHtml += `<p class="reminder-details" style="font-size: 1.0rem;">Ubicación: Activada (Radio ${reminder.radiusMeters || DEFAULT_LOCATION_RADIUS}m)</p>`;
            }
            const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval';
            const showAdjustButton = isCyclic && reminder.time !== '00:01';
            const adjustButtonHtml = showAdjustButton ? `<button class="adjust-time-0001">Ajustar Hora 00:01 y Visto</button>` : '';
            const cyclicCancelButtonHtml = isCyclic ? `<button class="cancel-cyclic">Anular Ciclo</button>` : '';
            
            const buttonsHtml = `
                <div class="button-group">
                    <button class="cancel">Visto / Próximo</button>
                    <button class="postpone">Posponer</button>
                    <button class="modify">Modificar</button>
                    ${adjustButtonHtml}
                    ${cyclicCancelButtonHtml}
                </div>`;

            const mapPreviewHtml = (reminder.isLocationEnabled && reminder.locationCoordinates && !isNavigationMapActive) ? `
                <div class="reminder-map-preview-container">
                    <div id="map-preview-${reminder.id}" class="reminder-map-preview"></div>
                </div>
            ` : '';

            slideContentHtml = `
                <div class="reminder-slide-content">
                    <div class="reminder-content-scrollable">
                        <p class="reminder-text">${reminder.text}</p>
                        ${detailsHtml}
                    </div>
                    ${buttonsHtml} 
                </div>
                ${mapPreviewHtml}
            `;
        }
        
        slide.innerHTML = slideContentHtml;

        addSlideButtonListeners(slide, reminder);
        swiperContainer.appendChild(slide);

        if (reminder.isLocationEnabled && reminder.locationCoordinates && !isNavigationMapActive && !isRadarAlert) {
             const mapPreviewElement = slide.querySelector(`#map-preview-${reminder.id}`);
             if (mapPreviewElement) {
                setTimeout(() => {
                    try {
                        if (!document.getElementById(mapPreviewElement.id)) return;
                        if (previewMaps[reminder.id] && typeof previewMaps[reminder.id].remove === 'function') {
                           previewMaps[reminder.id].remove();
                        }
                        const isRadarType = reminder.text.toUpperCase().includes("RADAR") || reminder.excludeFromList;
                        const circleColor = isRadarType ? 'rgba(255, 165, 0, 0.2)' : 'blue';
                        
                        const map = new mapboxgl.Map({
                            container: mapPreviewElement,
                            style: 'mapbox://styles/mapbox/streets-v12',
                            center: [reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude],
                            zoom: 14,
                            interactive: false,
                            attributionControl: false
                        });
                        
                        map.on('load', () => {
                            new mapboxgl.Marker().setLngLat([reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]).addTo(map);

                            const circlePolygon = turf.circle(
                                [reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude], 
                                reminder.radiusMeters || DEFAULT_LOCATION_RADIUS, 
                                { steps: 64, units: 'meters' }
                            );
                            
                            const circleSourceId = `map-preview-circle-${reminder.id}`;
                            map.addSource(circleSourceId, {
                                'type': 'geojson',
                                'data': circlePolygon
                            });
                            map.addLayer({
                                'id': circleSourceId,
                                'type': 'fill',
                                'source': circleSourceId,
                                'paint': {
                                    'fill-color': circleColor,
                                    'fill-opacity': isRadarType ? 0.2 : 0.05
                                }
                            });
                        });

                        map.resize();
                        previewMaps[reminder.id] = map;
                    } catch (mapError) {
                         if (mapPreviewElement) mapPreviewElement.innerHTML = `<p style="font-size:0.8rem; color: red; text-align: center; padding: 5px;">Error al cargar mapa</p>`;
                    }
                }, 100);
             }
        }
    });
    const count = overdueReminders.length;
    countSpan.textContent = count;
    if (count > 0) {
         if (currentNotificationSlideIndex >= count) {
             currentNotificationSlideIndex = 0;
         }
         swiperContainer.scrollLeft = currentNotificationSlideIndex * swiperContainer.offsetWidth;
         updateReminderIndexDisplay();
         countHeader.classList.remove('hidden');
         if (count > 1) {
            countTextContainer.style.display = 'inline';
            swipeHint.style.display = 'block';
            document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = 'calc(85vh - 60px)');
         } else {
            countTextContainer.style.display = 'none';
            swipeHint.style.display = 'none';
            document.querySelectorAll('.reminder-slide').forEach(s => s.style.maxHeight = '85vh');
         }
          hideAllButton.classList.remove('hidden');
          const newHideAllButton = hideAllButton.cloneNode(true);
          hideAllButton.parentNode.replaceChild(newHideAllButton, hideAllButton);
          newHideAllButton.addEventListener('click', postponeAllVisibleReminders);
          
          realtimeSpeedUpdateInterval = setInterval(() => {
              if (!windowElement.classList.contains('visible')) {
                  clearInterval(realtimeSpeedUpdateInterval);
                  realtimeSpeedUpdateInterval = null;
                  return;
              }
              const carSpeed = Math.round(window.currentSpeedKmh || 0);
              overdueReminders.forEach(reminder => {
                  if(reminder.text.toUpperCase().includes("RADAR")) {
                      const speedDisplayElement = document.getElementById(`current-speed-display-${reminder.id}`);
                      if (speedDisplayElement) {
                          const radarSpeed = extractSpeedFromRadarText(reminder.text);
                          const speedExceeded = radarSpeed !== null && carSpeed > radarSpeed;
                          speedDisplayElement.textContent = `[Velocidad actual: ${carSpeed} Km/h]`;
                          speedDisplayElement.style.color = speedExceeded ? 'red' : '#333';
                      }
                  }
              });
          }, 500);

    } else {
        countHeader.classList.add('hidden');
        hideAllButton.classList.add('hidden');
        currentNotificationSlideIndex = 0;
    }
    windowElement.classList.add('visible');
    isUnifiedWindowVisibleByLogic = true;
    swiperContainer.removeEventListener('scroll', updateReminderIndexDisplay);
    swiperContainer.addEventListener('scroll', updateReminderIndexDisplay);
}
    
    // ===================================================================
    // NOMBRE: getSavedLocations
    // RESUMEN: Obtiene las ubicaciones guardadas desde localStorage.
    function getSavedLocations() { try { const locations = localStorage.getItem(SAVED_LOCATIONS_KEY); return locations ? JSON.parse(locations) : Array(MAX_SAVED_LOCATIONS).fill(null); } catch (e) { return Array(MAX_SAVED_LOCATIONS).fill(null); } }
    
    // ===================================================================
    // NOMBRE: saveLocationsToCache
    // RESUMEN: Guarda el array de ubicaciones en localStorage.
    function saveLocationsToCache(locationsArray) { try { localStorage.setItem(SAVED_LOCATIONS_KEY, JSON.stringify(locationsArray));} catch (e) { showToast("Error al guardar ubicaciones.", "error"); } }
    
    
// ===================================================================
// NOMBRE: plotIntervalData (CORREGIDA)
// RESUMEN: Añade un nuevo punto de datos a la gráfica a intervalos regulares. La condición de ejecución se ha modificado para permitir que se ejecute tanto en modo Navegación como en modo Free Drive.
function plotIntervalData() {
    if (!isGraphingActive || !(isNavigating || isFreeDriveActive) || !navigationChart || !navigationStartTimeForStats || !navigationCurrentLocation) {
        return;
    }

    let currentAverageSpeed = 0;
    const timeElapsedS = (Date.now() - navigationStartTimeForStats.getTime()) / 1000;

    if (timeElapsedS > 0 && totalDistanceTravelledForStats > 0) {
        const avgSpeedMs = totalDistanceTravelledForStats / timeElapsedS;
        currentAverageSpeed = avgSpeedMs * 3.6;
    }
    
    if (currentAverageSpeed > 1) { 
        minAverageSpeedInTrip = Math.min(minAverageSpeedInTrip, currentAverageSpeed);
        maxAverageSpeedInTrip = Math.max(maxAverageSpeedInTrip, currentAverageSpeed);
        
        const timeLabel = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        graphLabels.push(timeLabel);
        graphDataPoints.speed.push(currentAverageSpeed);
    }
    
    const currentAltitude = navigationCurrentLocation.altitude || 0;
    
    if (graphDataPoints.altitude.length < graphDataPoints.speed.length) {
        graphDataPoints.altitude.push(currentAltitude);
    }
    
    updateChartData();

    const isCurrentlyStopped = (window.currentSpeedKmh || 0) < 1;
    if (isCurrentlyStopped) {
        if (isCarStoppedForGraph) return; 
        isCarStoppedForGraph = true;
    } else {
        isCarStoppedForGraph = false;
    }
}    

// ===================================================================
// NOMBRE: updateChartData (MODIFICADA - GESTIONA MODO LIBRE)
// RESUMEN: Actualiza los datos y la configuración de la gráfica de navegación, adaptando el título y contenido para el modo "Free Drive".
function updateChartData() {
    if (!navigationChart) return;
    const graphCard = document.getElementById('navigation-graph-card');
    const isEnlarged = graphCard ? graphCard.classList.contains('enlarged') : false;
    const valueStyle = "font-size: 1.2em; opacity: 1.0; line-height: 1.4; font-weight: bold; text-align: right; padding-right: 22px;";
    const etaColor = "#D29BFD";
    const avgColor = "yellow";
    const maxColor = "#FFA420";
    const minAvgLineColor = '#FFA500';
    const maxAvgLineColor = '#28a745';

    const mainDataset = navigationChart.data.datasets[0];
    const altitudeFillDataset = navigationChart.data.datasets[1];
    const referenceDataset = navigationChart.data.datasets[2];
    const minAvgSpeedDataset = navigationChart.data.datasets[3];
    const maxAvgSpeedDataset = navigationChart.data.datasets[4];
    const accumulatedAvgSpeedDataset = navigationChart.data.datasets[5];

    if (currentGraphMode === 'Desviación ETA') {
        navigationChart.options.scales.yPrimary.ticks.callback = function(value) { return Math.round(value) + ' km/h'; };
        
        mainDataset.borderColor = 'rgba(129, 216, 208, 0.6)'; 
        mainDataset.backgroundColor = 'rgba(37, 99, 235, 0.25)';
        mainDataset.fill = 'origin';
        mainDataset.pointRadius = 0;

        altitudeFillDataset.hidden = true; 
        altitudeFillDataset.data = []; 
        
        const currentAvgSpeed = window.averageSpeedKmh || 0;
        
        const valuesToShow = [graphExpectedAvgSpeed];
        if (currentAvgSpeed > 1) valuesToShow.push(currentAvgSpeed);
        if (maxAverageSpeedInTrip > -Infinity) valuesToShow.push(maxAverageSpeedInTrip);
        if (minAverageSpeedInTrip < Infinity) valuesToShow.push(minAverageSpeedInTrip);
        
        const maxVisibleValue = Math.max(...valuesToShow);
        const minVisibleValue = Math.min(...valuesToShow);

        const newYMax = maxVisibleValue + 3;
        const newYMin = Math.max(0, minVisibleValue - 3);
        
        navigationChart.options.scales.yPrimary.min = newYMin;
        navigationChart.options.scales.yPrimary.max = newYMax;

        const yAxisRange = newYMax - newYMin;
        const targetTickCount = isEnlarged ? 20 : 10;
        let stepSize = yAxisRange > 0 ? yAxisRange / targetTickCount : 1;
        const niceIntervals = [0.1, 0.2, 0.5, 1, 2, 5];
        let bestFitStep = niceIntervals[niceIntervals.length - 1];
        for (const interval of niceIntervals) {
            if (stepSize <= interval) {
                bestFitStep = interval;
                break;
            }
        }
        navigationChart.options.scales.yPrimary.ticks.stepSize = bestFitStep;

        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            const avgVal = (window.averageSpeedKmh || 0).toFixed(1);
            const maxVal = (maxSpeedDuringTrip || 0).toFixed(1);
            
            if (isFreeDriveActive) {
                graphTitleElement.innerHTML = `
                    <span style="font-size: 0.9em;">VELOCIDAD</span> 
                    <small style="${valueStyle}">
                        <span style="color:${avgColor};">Med: ${avgVal}</span> 
                        <span style="color:${maxColor};">   |  Máx: ${maxVal} Km/h</span>
                    </small>`;
                referenceDataset.hidden = true;
            } else {
                const etaVal = (graphExpectedAvgSpeed || 0).toFixed(1);
                graphTitleElement.innerHTML = `
                    <span style="font-size: 0.9em;">ETA</span> 
                    <small style="${valueStyle}">
                        <span style="color:${etaColor};">ETA: ${etaVal}</span> 
                        <span style="color:${avgColor};">   |  Med: ${avgVal}</span> 
                        <span style="color:${maxColor};">   |  Máx: ${maxVal} Km/h</span>
                    </small>`;
                referenceDataset.hidden = false;
            }
        }
        
        mainDataset.data = graphDataPoints.speed;
        mainDataset.label = 'Velocidad Media Real';
        
        referenceDataset.data = graphLabels.map(() => graphExpectedAvgSpeed);
        referenceDataset.label = 'Media ETA Inicial';
        
        minAvgSpeedDataset.data = graphLabels.map(() => minAverageSpeedInTrip === Infinity ? null : minAverageSpeedInTrip);
        minAvgSpeedDataset.label = 'Media Mínima';
        minAvgSpeedDataset.borderColor = minAvgLineColor;
        
        maxAvgSpeedDataset.data = graphLabels.map(() => maxAverageSpeedInTrip === -Infinity ? null : maxAverageSpeedInTrip);
        maxAvgSpeedDataset.label = 'Media Máxima';
        maxAvgSpeedDataset.borderColor = maxAvgLineColor;

        accumulatedAvgSpeedDataset.data = graphLabels.map(() => window.averageSpeedKmh);
        accumulatedAvgSpeedDataset.hidden = false;

    } else if (currentGraphMode === 'Altitud') {
        accumulatedAvgSpeedDataset.hidden = true;
        accumulatedAvgSpeedDataset.data = [];

        navigationChart.options.scales.yPrimary.ticks.callback = function(value) { return Math.round(value) + ' m'; };
        navigationChart.options.scales.yPrimary.max = undefined;
        navigationChart.options.scales.yPrimary.min = undefined;
        
        mainDataset.borderColor = 'rgba(129, 216, 208, 1)'; 
        mainDataset.backgroundColor = 'transparent';
        mainDataset.fill = 'origin' ;
        mainDataset.pointRadius = 0;

        altitudeFillDataset.data = graphDataPoints.altitude;
        altitudeFillDataset.hidden = false;
        
        const altitudeValues = graphDataPoints.altitude.length > 0 ? graphDataPoints.altitude : [0];
        const minAlt = Math.min(...altitudeValues);
        const maxAlt = Math.max(...altitudeValues);
        const altRange = maxAlt - minAlt;
        const targetTickCountAlt = isEnlarged ? 10 : 5;

        if (altRange > 0) {
            const rawStepAlt = altRange / targetTickCountAlt;
            const niceIntervalsAlt = [2, 5, 10, 20, 50, 100];
            let stepSizeAlt = niceIntervalsAlt[niceIntervalsAlt.length - 1];
            for (const interval of niceIntervalsAlt) { if(rawStepAlt <= interval) { stepSizeAlt = interval; break; } }
            navigationChart.options.scales.yPrimary.ticks.stepSize = stepSizeAlt;
        } else {
             navigationChart.options.scales.yPrimary.ticks.stepSize = undefined;
        }
        
        const altitudePoints = graphDataPoints.altitude;
        const avgAltitudeValue = altitudePoints.length > 0 ? altitudePoints.reduce((a, b) => a + b, 0) / altitudePoints.length : 0;
        const graphTitleElement = document.getElementById('navigation-graph-title');
        if (graphTitleElement) {
            const maxAltVal = (maxAltitudeDuringTrip !== -Infinity ? maxAltitudeDuringTrip : 0).toFixed(0);
            const avgAltVal = avgAltitudeValue.toFixed(0);
            const minAltVal = (minAltitudeDuringTrip !== Infinity ? minAltitudeDuringTrip : 0).toFixed(0);
            graphTitleElement.innerHTML = `
                <span style="font-size: 0.7em;">DESNIVEL RUTA</span>
                <small style="${valueStyle}">
                    <span style="color:${maxColor};">Máx: ${maxAltVal}</span> 
                    <span style="color:${etaColor};">   |  Med: ${avgAltVal}</span> 
                    <span style="color:${avgColor};">   |  Mín: ${minAltVal}m</span>
                </small>`;
        }
        
        mainDataset.data = graphDataPoints.altitude;
        mainDataset.label = 'Altitud';
        
        referenceDataset.data = graphLabels.map(() => avgAltitudeValue);
        referenceDataset.label = 'Media';
        
        minAvgSpeedDataset.data = graphLabels.map(() => minAltitudeDuringTrip !== Infinity ? minAltitudeDuringTrip : null);
        minAvgSpeedDataset.label = 'Mínima';
        minAvgSpeedDataset.borderColor = '#FFA500';
        
        maxAvgSpeedDataset.data = graphLabels.map(() => maxAltitudeDuringTrip !== -Infinity ? maxAltitudeDuringTrip : null);
        maxAvgSpeedDataset.label = 'Máxima';
        maxAvgSpeedDataset.borderColor = '#28a745';
    }
    navigationChart.data.labels = graphLabels; 
    navigationChart.update('none');
}    
    
// ===================================================================
// NOMBRE: initializeNavigationGraph
// RESUMEN: Inicializa el gráfico de Chart.js para la navegación.
function initializeNavigationGraph() {
    const graphCard = document.getElementById('navigation-graph-card');
    const graphContainer = document.getElementById('navigation-graph-container');
    const graphTitleElement = document.getElementById('navigation-graph-title');
    if (!graphCard || !graphContainer || !graphTitleElement || (!isNavigating && !isFreeDriveActive) || currentGraphMode === 'Gráfica off') {
        if (graphCard) graphCard.classList.add('hidden');
        if (navigationChart) { navigationChart.destroy(); navigationChart = null; }
        return;
    }
    graphCard.classList.remove('hidden');
    const compassElement = document.querySelector('.map-control-orientation-altitude');
    graphCard.style.height = compassElement ? (compassElement.offsetHeight + 'px') : '157px';
    isCarStoppedForGraph = false;
    graphDataPoints = { speed: [], altitude: [] };
    graphLabels = [];
    minAverageSpeedInTrip = Infinity;
    maxAverageSpeedInTrip = -Infinity;
    graphPlotState = { 
        lastPlotTime: Date.now(), 
        lastPlotCoords: navigationCurrentLocation ? { ...navigationCurrentLocation } : null 
    };
    if (navigationChart) {
        navigationChart.destroy();
        navigationChart = null;
    }
    isGraphingActive = true;
    const ctx = document.getElementById('navigation-chart')?.getContext('2d');
    if (!ctx || !ctx.canvas) {
        showToast("Error crítico: Canvas para gráfica no encontrado.", "error");
        if (graphCard) graphCard.classList.add('hidden');
        return;
    }
    
    const initialRouteDurationSec = navigationCurrentRouteData?.routes?.[0]?.duration || 0;
    const initialRouteDistance = navigationCurrentRouteData?.routes?.[0]?.distance || 0;
    
    const graphWidth = ctx.canvas.clientWidth || 300;
    const pixelsPerPoint = 3;
    const maxPoints = Math.floor(graphWidth / pixelsPerPoint);
    
    if (isNavigating && initialRouteDurationSec > 0 && maxPoints > 0) {
        const idealIntervalMs = (initialRouteDurationSec / maxPoints) * 1000;
        graphIntervalDuration = Math.max(5000, idealIntervalMs); 
    } else if (isFreeDriveActive) {
        graphIntervalDuration = 10000;
    } else {
        graphIntervalDuration = 30000;
    }

    graphExpectedAvgSpeed = (initialRouteDurationSec > 0 && initialRouteDistance > 0) ? (initialRouteDistance / initialRouteDurationSec) * 3.6 : 0;
    
    navigationChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'Velocidad Media Real', data: [],
                    borderColor: 'rgba(75, 192, 192, 0.5)',
                    backgroundColor: 'rgba(75, 192, 192, 0.25)',
                    tension: 0.1, yAxisID: 'yPrimary', 
                    pointRadius: 0, 
                    order: 3, 
                    fill: 'origin'
                },
                {
                    label: 'Área Desnivel', data: [],
                    borderColor: 'rgba(255, 165, 0, 0.5)', 
                    backgroundColor: 'rgba(255, 165, 0, 0.3)', 
                    fill: 'origin',
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: true, order: 4
                },
                {
                    label: 'Media ETA Inicial', data: [], 
                    borderColor: '#dfcae1', 
                    borderWidth: 3,          
                    fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 2
                },
                {
                    label: 'Media Mínima', data: [], borderColor: '#FFA500',
                    borderWidth: 1.5, borderDash: [5, 5], fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 1
                },
                {
                    label: 'Media Máxima', data: [], borderColor: '#28a745',
                    borderWidth: 1.5, borderDash: [5, 5], fill: false,
                    pointRadius: 0, yAxisID: 'yPrimary', hidden: false, order: 0
                },
                {
                    label: 'Media Acumulada Real', data: [], 
                    borderColor: '#F9e4b7', 
                    borderWidth: 3,        
                    fill: false,
                    pointRadius: 0, 
                    yAxisID: 'yPrimary', 
                    hidden: false, 
                    order: 2
                }
            ]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            layout: {
                padding: { top: 5, bottom: 2, left: 0, right: 2 }
            },
            scales: {
                x: {
                    type: 'category',
                    ticks: {
                        display: false 
                    },
                    grid: {
                        drawOnChartArea: false
                    }
                },
                yPrimary: {
                    type: 'linear', position: 'left',
                    min: Math.max(0, graphExpectedAvgSpeed - 3),
                    max: graphExpectedAvgSpeed + 3,
                    ticks: { color: 'white', font: { size: 11 }, callback: (v) => Math.round(Number(v)).toString(), stepSize: 0.2 },
                    grid: { color: 'rgba(255,255,255,0.1)' }, title: { display: false }
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: { 
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) { label += ': '; }
                            if (context.parsed.y !== null) {
                                label += context.parsed.y.toFixed(1);
                                if (currentGraphMode === 'Desviación ETA') label += ' km/h';
                                else if (currentGraphMode === 'Altitud') label += ' m';
                            }
                            return label;
                        }
                    }
                 }
            },
            animation: { duration: 250 }
        }
    });
    startGraphIntervalTimer();
    updateNavigationGraphVisibilityAndMode();
}


// ===================================================================
// NOMBRE: updateInitialUserPosition (VERSIÓN CON INICIALIZACIÓN DE ANIMACIÓN CORREGIDA)
// RESUMEN: Se asegura de que la animación del marcador tenga un punto de partida.
// ===================================================================
function updateInitialUserPosition(coords, mapInstanceToUse) {
    if (!mapInstanceToUse || !coords || typeof coords.latitude !== 'number' || typeof coords.longitude !== 'number') {
        return;
    }
    lastGpsUpdateTime = Date.now();

    const lngLat = new mapboxgl.LngLat(coords.longitude, coords.latitude);
    initialUserLocationMarkerLat = coords.latitude;
    initialUserLocationMarkerLng = coords.longitude;

    let effectiveHeading = null;
    if (coords.heading !== null && typeof coords.heading === 'number' && coords.heading >= 0) {
        effectiveHeading = coords.heading;
    } else if (window.lastPositionForSpeedCalc && typeof turf !== 'undefined') {
        const lastPoint = turf.point([window.lastPositionForSpeedCalc.longitude, window.lastPositionForSpeedCalc.latitude]);
        const currentPoint = turf.point([coords.longitude, coords.latitude]);
        if (turf.distance(lastPoint, currentPoint, { units: 'meters' }) > 1) {
            const bearing = turf.bearing(lastPoint, currentPoint);
            effectiveHeading = (bearing < 0) ? bearing + 360 : bearing;
        }
    }

    const currentHeading = (effectiveHeading !== null) ? effectiveHeading : (currentMapBearing || 0);

    if (!initialUserLocationMarker) {
        const vehicleIconElement = document.createElement('div');
        vehicleIconElement.style.width = '48px';
        vehicleIconElement.style.height = '48px';
        vehicleIconElement.innerHTML = `<img src="PNG/AVANCE.PNG" alt="Coche" style="width:100%; height:100%; object-fit:contain;">`;

        initialUserLocationMarker = new mapboxgl.Marker({ element: vehicleIconElement, rotationAlignment: 'map', anchor: 'center' })
            .setLngLat(lngLat)
            .addTo(mapInstanceToUse);
    }

    if (!markerAnimationState.currentLngLat) {
        markerAnimationState.currentLngLat = lngLat;
    }
   
    markerAnimationState.targetLngLat = lngLat;
    markerAnimationState.targetIconRotation = currentHeading - 90;
    if (!markerAnimationState.animationFrameId) {
        markerAnimationState.animationFrameId = requestAnimationFrame(animateMarkerAndMap);
    }

    if (compassAndModeControl) {
        compassAndModeControl.updateOrientation(currentHeading);
        compassAndModeControl.updateAltitude(coords.altitude);
        if (window.lastPositionForSpeedCalc && typeof coords.speed === 'number' && coords.speed !== null) {
            const distM = calculateDistance(window.lastPositionForSpeedCalc.latitude, window.lastPositionForSpeedCalc.longitude, coords.latitude, coords.longitude);
            const timeS = (Date.now() - window.lastPositionForSpeedCalc.time) / 1000;
            if (timeS > 0 && distM >= 0) {
                let speedMs = coords.speed;
                if (typeof speedMs !== 'number' || speedMs === null || speedMs < 0) { speedMs = distM / timeS; }
                window.currentSpeedKmh = speedMs * 3.6;
            } else { window.currentSpeedKmh = 0; }
        } else {
            if (typeof coords.speed === 'number' && coords.speed !== null && coords.speed >= 0) { window.currentSpeedKmh = coords.speed * 3.6; } else { window.currentSpeedKmh = 0; }
        }
        window.lastPositionForSpeedCalc = { latitude: coords.latitude, longitude: coords.longitude, time: Date.now() };
        const isTripActive = isNavigating || isFreeDriveActive;
        if (isTripActive) {
            if (window.currentSpeedKmh > maxSpeedDuringTrip) {
                maxSpeedDuringTrip = window.currentSpeedKmh;
                if (coords) { maxSpeedCoordinates = { lat: coords.latitude, lng: coords.longitude }; }
            }
            if (coords.altitude !== null && !isNaN(coords.altitude)) {
                maxAltitudeDuringTrip = Math.max(maxAltitudeDuringTrip, coords.altitude);
                minAltitudeDuringTrip = Math.min(minAltitudeDuringTrip, coords.altitude);
            }
            SPEED_MILESTONES.forEach(milestone => {
                if (window.currentSpeedKmh > milestone && milestone > lastSpeedMilestone) {
                    lastSpeedMilestone = milestone;
                    const newMilestoneFeature = {
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [coords.longitude, coords.latitude]
                        },
                        properties: {
                            type: 'milestone',
                            speedText: String(milestone)
                        }
                    };
                    speedMarkerFeatures.push(newMilestoneFeature);
                    if (navigationMapInstance.getSource('speed-markers-source')) {
                        navigationMapInstance.getSource('speed-markers-source').setData({
                            type: 'FeatureCollection',
                            features: speedMarkerFeatures
                        });
                    }
                }
            });
        }
        compassAndModeControl.updateCurrentSpeed(window.currentSpeedKmh);
        compassAndModeControl.updateAverageSpeed(window.averageSpeedKmh);
        compassAndModeControl.updateMaxSpeed(maxSpeedDuringTrip);
    }

    const shouldFollow = (shouldCenterOnUser || navigationFollowUser);

    if (!shouldFollow) {
        return;
    }

    if (!isRecalculatingRoute && navigationMapInstance) {
        const animationDuration = 1000;
        //const targetZoom = handleProgressiveManeuverZoom(navigationCurrentRouteData?.routes?.[0]?.legs?.[currentLegIndexNav]?.steps?.[currentStepIndexNav], distanceToNextManeuverOSRM);
        const targetZoom = handleProgressiveManeuverZoom(navigationCurrentRouteData?.routes?.[0]?.legs?.[currentLegIndexNav]?.steps?.[currentStepIndexNav], distanceToNextManeuverOSRM, lastCarDistanceAlongRouteForNavLogic);
        const viewOptions = {
            center: lngLat,
            duration: animationDuration,
            essential: true
        };

        const mapHeight = navigationMapInstance.getCanvas().clientHeight;
        const mapWidth = navigationMapInstance.getCanvas().clientWidth;
        const verticalPadding = mapHeight * Math.abs(mapOffsetY / 100);
        const horizontalPadding = mapWidth * Math.abs(mapOffsetX / 100);

        viewOptions.padding = {
            top: mapOffsetY > 0 ? verticalPadding : 0,
            bottom: mapOffsetY < 0 ? verticalPadding : 0,
            left: mapOffsetX > 0 ? horizontalPadding : 0,
            right: mapOffsetX < 0 ? horizontalPadding : 0
        };

        if (targetZoom !== null && !isManualZoomActive) {
            viewOptions.zoom = targetZoom;
        }

        if (mapViewMode === 'heading' || mapViewMode === 'perspective') {
            viewOptions.bearing = currentHeading;
        }

        if (mapViewMode === 'perspective') {
            viewOptions.pitch = mapPitchValue;
        } else {
            viewOptions.pitch = 0;
        }

        navigationMapInstance.easeTo(viewOptions);
    }

    handleAutoZoom();
}


// ===================================================================
// NOMBRE: startAutomatedRouteSimulation (VERSIÓN FINAL CON REINICIO CORRECTO)
// RESUMEN: Inicia o reanuda la simulación. Gestiona correctamente el
//          reinicio del progreso al reanudar tras un desvío.
// ===================================================================
function startAutomatedRouteSimulation(speedKmph, continueFromCurrentState = false) {
    if (!isSimulatingGpsLocation) {
        isSimulatingGpsLocation = true;
        if (locationWatchId !== null && navigator.geolocation) {
            navigator.geolocation.clearWatch(locationWatchId);
            locationWatchId = null;
        }
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) {
            simulateGpsButton.classList.add('active-simulate-gps-mode');
            simulateGpsButton.title = "Desactivar Simulación GPS (Volver a GPS Real)";
        }
    }
    
    if (automatedSimulationIntervalId) {
        clearInterval(automatedSimulationIntervalId);
        automatedSimulationIntervalId = null;
    }
    
    simulationSpeedKmph = speedKmph;
    currentSimulationSpeedKmph = speedKmph;
    
    const route = navigationCurrentRouteData?.routes?.[0];
    if (!route) {
        showToast("No hay ruta válida para iniciar la simulación.", "error");
        stopAutomatedRouteSimulation();
        return;
    }
    
    // --- INICIO DE LA LÓGICA DE REINICIO CORREGIDA ---
    if (continueFromCurrentState) {
        // Al REANUDAR, calculamos la distancia inicial en la NUEVA ruta.
        const carPointTurf = turf.point([simulatedGpsLocation.longitude, simulatedGpsLocation.latitude]);
        const routeLineStringTurf = turf.lineString(route.geometry.coordinates);
        const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
        const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
        
        // ¡LA CORRECCIÓN CLAVE! Asignamos este nuevo valor inicial al progreso.
        simulatedDistanceAlongRoute = turf.length(lineSliceToNearestTurf, { units: 'meters' });
        
        // Mantenemos las estadísticas totales del viaje
        
    } else {
        // Al INICIAR DE CERO, reseteamos todo.
        wasSimulatingBeforeRecalc = false;
        simulatedDistanceAlongRoute = 0;
        navigationStartTimeForStats = null;
        totalDistanceTravelledForStats = 0;
        maxSpeedDuringTrip = 0;
        clearSpeedMarkers();

        const startWaypoint = navigationWaypoints.find(wp => wp.type === 'S' || wp.isRecalculatedStart) || navigationWaypoints[0];
        lastPositionForStats = { latitude: startWaypoint.lat, longitude: startWaypoint.lng };
        
        let initialHeading = 0;
        if (route.geometry.coordinates.length >= 2) {
            initialHeading = turf.bearing(turf.point(route.geometry.coordinates[0]), turf.point(route.geometry.coordinates[1]));
            if (initialHeading < 0) initialHeading += 360;
        }
        simulatedGpsLocation = { latitude: startWaypoint.lat, longitude: startWaypoint.lng, accuracy: 5, heading: initialHeading, altitude: (navigationCurrentLocation?.altitude) ?? 0, speed: 0 };
        maxSpeedCoordinates = { lat: startWaypoint.lat, lng: startWaypoint.lng };
        processSimulatedGpsPosition(true);
        showToast(`Simulación automática de ruta iniciada a ${speedKmph.toFixed(0)} km/h.`, "info");
    }
    // --- FIN DE LA LÓGICA DE REINICIO CORREGIDA ---
    
    lastCarDistanceAlongRouteForNavLogic = simulatedDistanceAlongRoute;
    setNavigationMapClickHandler(); 

    let simulationStepIndex = 0;
    let simulationLegIndex = 0;
    
    let tempDistance = 0;
    for (let i = 0; i < route.legs.length; i++) {
        let legFound = false;
        for (let j = 0; j < route.legs[i].steps.length; j++) {
            tempDistance += route.legs[i].steps[j].distance;
            if (simulatedDistanceAlongRoute < tempDistance) {
                simulationLegIndex = i;
                simulationStepIndex = j;
                legFound = true;
                break;
            }
        }
        if (legFound) break;
    }
    let distanceToEndOfCurrentStep = calculateDistanceToEndOfStep(route, simulationLegIndex, simulationStepIndex);

    automatedSimulationIntervalId = setInterval(() => {
        const currentRouteForInterval = navigationCurrentRouteData?.routes?.[0];
        if (!currentRouteForInterval) {
            stopAutomatedRouteSimulationInternal();
            return;
        }

        const totalRouteDistance = currentRouteForInterval.distance;
        const speedMps = (currentSimulationSpeedKmph * 1000) / 3600;
        const distanceIncrement = speedMps * (SIMULATION_TICK_INTERVAL_MS / 1000);
        simulatedDistanceAlongRoute += distanceIncrement;

        if (navigationStartTimeForStats) {
            totalDistanceTravelledForStats += distanceIncrement;
        }
        
        if (simulatedDistanceAlongRoute > distanceToEndOfCurrentStep) {
            simulationStepIndex++;
            if (currentRouteForInterval.legs[simulationLegIndex] && simulationStepIndex >= currentRouteForInterval.legs[simulationLegIndex].steps.length) {
                simulationStepIndex = 0;
                simulationLegIndex++;
            }
            if (simulationLegIndex < currentRouteForInterval.legs.length && currentRouteForInterval.legs[simulationLegIndex]) {
                const currentStep = currentRouteForInterval.legs[simulationLegIndex].steps[simulationStepIndex];
                if (currentStep) { 
                    const multiplier = getRandomSpeedMultiplierForManeuver(currentStep.maneuver);
                    currentSimulationSpeedKmph = Math.max(20, Math.min(5000, simulationSpeedKmph * (1 + multiplier)));
                    distanceToEndOfCurrentStep = calculateDistanceToEndOfStep(currentRouteForInterval, simulationLegIndex, simulationStepIndex);
                }
            }
        }
      
        if (simulatedDistanceAlongRoute >= totalRouteDistance) {
            stopAutomatedRouteSimulationInternal();
            const endPointCoords = currentRouteForInterval.geometry.coordinates[currentRouteForInterval.geometry.coordinates.length - 1];
            simulatedGpsLocation = {
                ...simulatedGpsLocation,
                latitude: endPointCoords[1],
                longitude: endPointCoords[0],
                speed: 0
            };
            processSimulatedGpsPosition(true);
            showToast("Simulación de ruta completada. Modo simulación por clic activo.", "success");
            const mapDiv = document.getElementById('reminders-location-map-div');
            if (mapDiv) mapDiv.classList.add('simulating-gps-click-mode'); 
            if (isNavigating || (!isNavigating && navigationWaypoints.length > 0)) {
                 showArrivalStatsModal();
            }
            setNavigationMapClickHandler();
            return;
        }
        const turfLine = turf.lineString(currentRouteForInterval.geometry.coordinates);
        const pointOnLine = turf.along(turfLine, simulatedDistanceAlongRoute / 1000, { units: 'kilometers' });
        if (pointOnLine?.geometry?.coordinates) {
            const [lng, lat] = pointOnLine.geometry.coordinates;
            let headingSim = 0;
            const lookAheadDistance = Math.min(distanceIncrement * 2, totalRouteDistance - simulatedDistanceAlongRoute);
            if (simulatedDistanceAlongRoute + lookAheadDistance <= totalRouteDistance && lookAheadDistance > 0) {
                const nextPointOnLine = turf.along(turfLine, (simulatedDistanceAlongRoute + lookAheadDistance) / 1000, { units: 'kilometers' });
                if (nextPointOnLine?.geometry?.coordinates) {
                    headingSim = turf.bearing(pointOnLine, nextPointOnLine);
                    if (headingSim < 0) headingSim += 360;
                }
            } else {
                headingSim = simulatedGpsLocation?.heading || 0;
            }
            simulatedGpsLocation = {
                latitude: lat,
                longitude: lng,
                accuracy: 5,
                heading: headingSim,
                altitude: (navigationCurrentLocation?.altitude) ?? 0,
                speed: speedMps
            };
            processSimulatedGpsPosition(false);
        }
    }, SIMULATION_TICK_INTERVAL_MS);
}
// ===================================================================
// NOMBRE: showIntersectionPreviewMap (VERSIÓN CON POSICIÓN CORREGIDA)
// RESUMEN: Muestra el minimapa de maniobras alineado en la esquina superior
//          izquierda de la barra de progreso, superponiéndose a ella.
function showIntersectionPreviewMap(step, route, isSimulationContextOrClick = false, timerDurationMs = null) {
    if (!showMinimapPreference) {
        hideIntersectionPreviewMap();
        return;
    }
  
    const previewWindow = document.getElementById('intersection-preview-map-window');
    const progressBarEl = document.getElementById('navigation-bottom-progress-bar');
    if (!previewWindow || !step || !step.geometry || !route || !navigationMapInstance) {
        hideIntersectionPreviewMap();
        return;
    }
    const DISTANCE_BEFORE_MANEUVER_METERS = 110;
    const DISTANCE_AFTER_MANEUVER_METERS = 90;
    const CAR_POSITION_BEFORE_MANEUVER_METERS = 25;
    if (!previewWindow.querySelector('#intersection-rotator')) {
        previewWindow.innerHTML = `
            <div id="intersection-rotator" style="width: 100%; height: 100%; transition: transform 0.3s ease-out;">
                <div id="intersection-preview-map-container"></div>
            </div>
        `;
    }
    const rotatorDiv = previewWindow.querySelector('#intersection-rotator');
    const mapContainerEl = previewWindow.querySelector('#intersection-preview-map-container');
    const isProgressBarVisible = progressBarEl && progressBarEl.offsetParent !== null;

    if (isProgressBarVisible) {
        const progressBarRect = progressBarEl.getBoundingClientRect();
        previewWindow.style.width = `${progressBarRect.width}px`;

        // --- INICIO DE LA CORRECCIÓN DEFINITIVA ---
        // Alinear la parte SUPERIOR del mini-mapa con la parte SUPERIOR de la barra de progreso.
        previewWindow.style.top = `${progressBarRect.top}px`;
        previewWindow.style.left = `${progressBarRect.left}px`;
        
        // Resetear otras propiedades de posicionamiento para evitar conflictos.
        previewWindow.style.bottom = 'auto';
        previewWindow.style.transform = 'none';
        // --- FIN DE LA CORRECCIÓN DEFINITIVA ---

    } else if (isSimulationContextOrClick) {
        previewWindow.style.width = '90%';
        previewWindow.style.maxWidth = '500px';
        previewWindow.style.left = '50%';
        previewWindow.style.top = '50%';
        previewWindow.style.transform = 'translate(-50%, -50%)';
    } else {
        hideIntersectionPreviewMap();
        return;
    }

    previewWindow.classList.remove('hidden');
    previewWindow.dataset.source = isSimulationContextOrClick ? 'click' : 'auto';
    if (intersectionPreviewTimer) clearTimeout(intersectionPreviewTimer);

    try {
        if (intersectionPreviewMap) {
            try {
                intersectionPreviewMap.remove();
            } catch(e) {}
            intersectionPreviewMap = null;
        }

        intersectionPreviewMap = L.map(mapContainerEl, {
            zoomControl: false, dragging: false, touchZoom: false, scrollWheelZoom: false,
            doubleClickZoom: false, boxZoom: false, keyboard: false, attributionControl: false
        });

        if (rotatorDiv) {
            rotatorDiv.style.transition = 'none';
            rotatorDiv.style.transform = 'rotate(0deg)';
        }

        const currentMapLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "HÍBRIDO";
        const layerNameLower = currentMapLayerName.toLowerCase();
        let tileLayerInstance;

        if (layerNameLower.includes("satélite puro") || layerNameLower.includes("satélite")) {
            tileLayerInstance = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' });
        } else if (layerNameLower.includes("híbrido") || layerNameLower.includes("satélite + calles")) {
            const labelsPaneName = 'intersection_labels_pane_unique';
            tileLayerInstance = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' });
            if (!intersectionPreviewMap.getPane(labelsPaneName)) {
                intersectionPreviewMap.createPane(labelsPaneName);
                intersectionPreviewMap.getPane(labelsPaneName).style.zIndex = 650;
                intersectionPreviewMap.getPane(labelsPaneName).style.pointerEvents = 'none';
            }
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', { attribution: '© OSM © CARTO', pane: labelsPaneName }).addTo(intersectionPreviewMap);
        } else { 
            tileLayerInstance = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap' });
        }
        
        tileLayerInstance.addTo(intersectionPreviewMap);

        const maneuverPoint = L.latLng(step.maneuver.location[1], step.maneuver.location[0]);
        const fullRouteLineString = turf.lineString(route.geometry.coordinates);
        const maneuverPointOnRoute = turf.nearestPointOnLine(fullRouteLineString, step.maneuver.location, { units: 'kilometers' });
        const maneuverDistanceKm = maneuverPointOnRoute.properties.location;
        const startSliceDistanceKm = Math.max(0, maneuverDistanceKm - (DISTANCE_BEFORE_MANEUVER_METERS / 1000));
        const endSliceDistanceKm = Math.min(turf.length(fullRouteLineString), maneuverDistanceKm + (DISTANCE_AFTER_MANEUVER_METERS / 1000));
        const startSlicePoint = turf.along(fullRouteLineString, startSliceDistanceKm);
        const endSlicePoint = turf.along(fullRouteLineString, endSliceDistanceKm);
        const routeSlice = turf.lineSlice(startSlicePoint, endSlicePoint, fullRouteLineString);
        const routeSegmentCoords = routeSlice.geometry.coordinates.map(c => [c[1], c[0]]);

        if (!routeSegmentCoords || routeSegmentCoords.length < 2) {
            throw new Error("El segmento de ruta para la vista previa de la intersección es inválido.");
        }

        intersectionPreviewRouteLayer = L.polyline(routeSegmentCoords, { color: 'orange', weight: 10, opacity: 1 }).addTo(intersectionPreviewMap);
        intersectionPreviewManeuverMarker = L.circleMarker(maneuverPoint, { radius: 5, color: 'white', weight: 1, fillColor: 'blue', fillOpacity: 1, zIndexOffset: 1000 }).addTo(intersectionPreviewMap);
        
        const lineStringToPlaceCar = turf.lineString(routeSegmentCoords.map(c => [c[1], c[0]]));
        const distanceForCarOnSegment = Math.max(0, DISTANCE_BEFORE_MANEUVER_METERS - CAR_POSITION_BEFORE_MANEUVER_METERS);
        const carPositionPointTurf = turf.along(lineStringToPlaceCar, distanceForCarOnSegment, { units: 'meters' });
        const carPositionLatLng = L.latLng(carPositionPointTurf.geometry.coordinates[1], carPositionPointTurf.geometry.coordinates[0]);
        intersectionPreviewCarMarker = L.marker(carPositionLatLng, { icon: vehicleIconMiniMap, zIndexOffset: 1001 }).addTo(intersectionPreviewMap);
        
        const maneuver = step.maneuver;
        const iconFilename = getManeuverIconFilename(maneuver);
        const iconUrl = `https://boardinggate.github.io/Tesla/${iconFilename}`;
        if (intersectionPreviewCarMarker && intersectionPreviewCarMarker.getElement()) {
            const overlayMini = intersectionPreviewCarMarker.getElement().querySelector('.vehicle-maneuver-overlay-minimap');
            if (overlayMini) {
                overlayMini.style.backgroundImage = `url('${iconUrl}')`;
                overlayMini.style.display = 'block';
            }
        }
        
        const bounds = L.latLngBounds(routeSegmentCoords).pad(0.5);

        setTimeout(() => {
            if (intersectionPreviewMap && document.body.contains(mapContainerEl)) {
                intersectionPreviewMap.invalidateSize();
                
                const mapMaxZoom = intersectionPreviewMap.getMaxZoom() || 22;
                const zoomThatFitsBounds = intersectionPreviewMap.getBoundsZoom(bounds);
                const targetZoom = Math.min(mapMaxZoom, zoomThatFitsBounds + 2);
                
                intersectionPreviewMap.setView(bounds.getCenter(), targetZoom, { animate: false });
                
                requestAnimationFrame(() => {
                    let segmentBearing = 0;
                    const lookAheadPointTurf = turf.along(lineStringToPlaceCar, distanceForCarOnSegment + 5, { units: 'meters' });
                    if (lookAheadPointTurf) {
                        segmentBearing = turf.bearing(carPositionPointTurf, lookAheadPointTurf);
                        if (segmentBearing < 0) segmentBearing += 360;
                    } else {
                        segmentBearing = (navigationCurrentLocation && typeof navigationCurrentLocation.heading === 'number') ? navigationCurrentLocation.heading : currentMapBearing;
                    }

                    let mapRotation = 0;
                    if (segmentBearing > 45 && segmentBearing <= 135) {
                        mapRotation = -90;
                    } else if (segmentBearing > 135 && segmentBearing <= 225) {
                        mapRotation = 180;
                    } else if (segmentBearing > 225 && segmentBearing <= 315) {
                        mapRotation = 90;
                    }

                    if (rotatorDiv) {
                        rotatorDiv.style.transition = 'transform 0.3s ease-out';
                        rotatorDiv.style.transform = `rotate(${mapRotation}deg)`;
                    }
                    const finalIconRotation = segmentBearing - 90;
                    if (intersectionPreviewCarMarker && intersectionPreviewCarMarker.getElement()) {
                        const carWrapperMini = intersectionPreviewCarMarker.getElement().querySelector('.vehicle-icon-minimap');
                        if (carWrapperMini) {
                            carWrapperMini.style.transform = `rotate(${finalIconRotation}deg)`;
                        }
                    }
                });
            }
        }, 50);

        if (timerDurationMs && timerDurationMs > 0) {
            intersectionPreviewTimer = setTimeout(hideIntersectionPreviewMap, timerDurationMs);
        }
    } catch (error) {
        console.error("Error al mostrar el mapa de intersección:", error);
        hideIntersectionPreviewMap();
    }
}    
    
// ===================================================================
// NOMBRE: saveSettings (MODIFICADA - GUARDA NUEVOS AJUSTES)
// RESUMEN: Guarda la configuración, incluyendo los nuevos ajustes de offset y minimapa.
function saveSettings() {
    localStorage.setItem('darkMode', JSON.stringify(isDarkMode));
    const tS = {};
    document.querySelectorAll('.range-toggle').forEach(t => {
        const start = t.dataset.rangeStart;
        if (start) tS[start] = t.dataset.state;
    });
    localStorage.setItem('toggleStates', JSON.stringify(tS));
    const zoomButton = document.getElementById('zoom-button');
    if (zoomButton) localStorage.setItem('zoomState', zoomButton.dataset.zoomState);
    const onOffBtn = document.getElementById('on-off-toggle');
    if (onOffBtn) localStorage.setItem('onOffState', onOffBtn.dataset.state);
    localStorage.setItem('noticesActive', JSON.stringify(isActive));
    localStorage.setItem('footerVisible', JSON.stringify(isFooterVisible));
    localStorage.setItem('password_active', JSON.stringify(isPasswordActive));
    localStorage.setItem('lastUpdatesCheckDate', lastUpdatesCheckDate);
    localStorage.setItem(GRAPH_STATE_KEY, currentGraphMode);
    localStorage.setItem(MAP_VIEW_OFFSET_X_KEY, mapOffsetX);
    localStorage.setItem(MAP_VIEW_OFFSET_Y_KEY, mapOffsetY);
    localStorage.setItem(MAP_VIEW_SHOW_MINIMAP_KEY, showMinimapPreference);
    // --- LÍNEA AÑADIDA: Guarda el pitch ---
    localStorage.setItem(MAP_VIEW_PITCH_KEY, mapPitchValue);
    const radaresCheckboxElement = document.getElementById('radares-ruta-checkbox');
    if (radaresCheckboxElement) {
        localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckboxElement.checked));
    }
    const tareasCheckboxElement = document.getElementById('tareas-ruta-checkbox');
    if (tareasCheckboxElement) { 
        localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckboxElement.checked));
    }
    const mainSearchInputGrid = document.getElementById('main-search-input'); 
    if (mainSearchInputGrid) {
        localStorage.setItem('gridFilterValue', mainSearchInputGrid.value);
    }
    const mapFilterInput = document.getElementById('filter-input'); 
    if (mapFilterInput) {
        localStorage.setItem(MAP_FILTER_INPUT_KEY, mapFilterInput.value);
    }
    if (mapLayersControl && mapLayersControl._map && mapLayersControl._map._layers) {
        const layersArray = Object.values(mapLayersControl._map._layers);
        const baseLayerMapObject = layersArray.find(l => l._map && l.options && !l.options.pane && l.options.attribution);
        if (baseLayerMapObject) {
            const activeLayerEntry = mapLayersControl._layers.find(l => l.layer === baseLayerMapObject);
            if (activeLayerEntry && activeLayerEntry.name) {
                localStorage.setItem(ACTIVE_MAP_LAYER_KEY, activeLayerEntry.name);
            }
        }
    }
}
// ===================================================================
// NOMBRE: handleLoadOrDeleteRouteClick (MODIFICADA - USA RESET CENTRAL)
// RESUMEN: Llama a la función de reseteo completa antes de realizar otras acciones.
function handleLoadOrDeleteRouteClick(button) {
    clearAlternativeRoutesDisplay(); 
    resetNavigationState();

    if (isSimulatingGpsLocation) {
        stopAutomatedRouteSimulation();
    }
    
    if (isFreeDrivePaused) {
        handleFreeDriveCancellation();
    }

    clearAllWaypointMarkersFromMap();
    if (navigationMapInstance && navigationMapInstance.getSource('route')) {
        navigationMapInstance.getSource('route').setData({ type: 'FeatureCollection', features: [] });
    }
    if (navigationMapInstance && navigationMapInstance.getSource('completed-segments')) {
        navigationMapInstance.getSource('completed-segments').setData({ type: 'FeatureCollection', features: [] });
    }
    
    if (button) {
       }
    
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}
// ===================================================================
// NOMBRE: showLoadRouteModal (MODIFICADA - NUEVO DISEÑO CON RECIENTES)
// RESUMEN: Muestra el modal de carga con una sección superior para rutas/destinos recientes,
function showLoadRouteModal() {
    resetNavigationState();

    const existingOverlay = document.getElementById('route-modal-load-overlay');
    if (existingOverlay) existingOverlay.remove();

    const overlay = document.createElement('div');
    overlay.id = 'route-modal-load-overlay';
    overlay.className = 'route-modal-overlay';

    const modalContent = document.createElement('div');
    modalContent.id = 'saved-routes-modal';
    modalContent.className = 'route-modal-container';

    modalContent.innerHTML = `
        <div class="route-modal-header">
             <div class="route-modal-title-card">
                 <span class="route-modal-title">Cargar Destinos o Rutas</span>
             </div>
        </div>
        <div class="route-modal-body">
            <div class="route-modal-controls">
                <input type="text" id="filter-saved-routes" class="route-filter-input" placeholder="FILTRAR DESTINOS Y RUTAS...">
                <button id="clear-filter-button" class="clear-input-btn" title="Limpiar filtro" style="display: none;">×</button>
            </div>
            
            <!-- NUEVO: Sección de Recientes/Favoritos fuera de las pestañas -->
            <h3 class="routes-section-title">Recientes</h3>
            <div id="recents-container" class="route-scroll-container" style="max-height: 180px; flex-grow: 0; margin-bottom: 15px;">
                <ul id="recent-items-list" class="route-list"></ul>
            </div>
            
            <div class="route-modal-tabs">
                <button class="route-modal-tab active" data-tab="destinos">DESTINOS GUARDADOS</button>
                <button class="route-modal-tab" data-tab="rutas">RUTAS GUARDADAS</button>
            </div>

            <div id="routes-container" class="route-scroll-container">
                <div class="route-modal-panel active" id="panel-destinos">
                    <ul id="saved-destinations-list" class="route-list"></ul>
                </div>
                <div class="route-modal-panel" id="panel-rutas">
                    <ul id="saved-routes-list" class="route-list"></ul>
                </div>
            </div>
        </div>
        <div class="route-modal-footer">
            <button id="close-saved-routes-modal" class="btn-modal-action-secondary" style="flex: 1;">Cerrar <span class="button-countdown-timer"></span></button>
        </div>
    `;
    
    overlay.appendChild(modalContent);
    document.body.appendChild(overlay);

    const closeButton = modalContent.querySelector('#close-saved-routes-modal');
    const filterInput = modalContent.querySelector('#filter-saved-routes');
    const clearFilterBtn = modalContent.querySelector('#clear-filter-button');
    const tabs = modalContent.querySelectorAll('.route-modal-tab');
    const panels = modalContent.querySelectorAll('.route-modal-panel');

    const closeHandler = () => {
        clearModalAutoCloseTimer(overlay, closeButton, 'saved-routes-modal');
        if (overlay.parentNode) overlay.remove();
    };
    closeButton.addEventListener('click', closeHandler);
    addModalAutoCloseTimer(overlay, closeButton, 'saved-routes-modal', 45000);

    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            tabs.forEach(t => t.classList.remove('active'));
            panels.forEach(p => p.classList.remove('active'));
            tab.classList.add('active');
            document.getElementById(`panel-${tab.dataset.tab}`).classList.add('active');
        });
    });
    
    const renderRouteListItem = (route, listElement, isRecent) => {
        const li = document.createElement('li');
        li.className = 'route-list-item';
        const showReturnButton = route.waypoints.length > 1;
        const buttonType = isRecent ? 'Quitar' : 'Borrar';

        li.innerHTML = `
            <span class="route-name">${route.name}</span>
            <div class="route-actions">
                ${showReturnButton ? '<button class="btn-return" title="Cargar ruta en sentido inverso">Vuelta</button>' : ''}
                <button class="btn-share" style="background-color: #007aff;" title="Compartir coordenadas">Compartir</button> 
                <button class="btn-delete" title="${isRecent ? 'Quitar del historial' : 'Borrar permanentemente'}">${buttonType}</button>
            </div>
        `;
        
        li.querySelector('.route-name').addEventListener('click', () => {
            loadRouteByName(route.name, true);
            addRouteToRecents(route);
            closeHandler();
        });

        li.querySelector('.btn-share').addEventListener('click', (e) => {
             e.stopPropagation();
             if (route.waypoints.length === 1) {
                 const dest = route.waypoints[0];
                 handleSendToTeslaClick(dest.lat, dest.lng, dest.address);
             } else {
                 closeHandler();
                 showShareStageModal(route);
             }
        });

        if (showReturnButton) {
            li.querySelector('.btn-return').addEventListener('click', (e) => {
                e.stopPropagation();
                getCurrentLocation(
                    async (currentPos) => {
                        const originalWaypoints = [...route.waypoints];
                        const originalStart = originalWaypoints.shift();
                        if (originalWaypoints.length > 0) { originalWaypoints.pop(); }
                        const intermediateReversed = originalWaypoints.reverse();
                        let returnWaypoints = [{ lat: currentPos.latitude, lng: currentPos.longitude, address: 'Posición Actual (GPS)'}, ...intermediateReversed, originalStart];
                        const returnRouteObject = { name: `VUELTA: ${route.name}`, waypoints: returnWaypoints };
                        loadRouteFromObject(returnRouteObject, true);
                        addRouteToRecents(returnRouteObject);
                        closeHandler();
                    },
                    (errorMsg) => { showToast(`Error al obtener ubicación: ${errorMsg}`, "error"); }
                );
            });
        }
        
        li.querySelector('.btn-delete').addEventListener('click', (e) => {
            e.stopPropagation();
            if (isRecent) {
                let recentRoutes = JSON.parse(localStorage.getItem('boardinggate_recent_routes') || "[]");
                recentRoutes = recentRoutes.filter(r => r.name !== route.name);
                localStorage.setItem('boardinggate_recent_routes', JSON.stringify(recentRoutes));
            } else {
                let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
                savedRoutes = savedRoutes.filter(r => r.name !== route.name);
                localStorage.setItem(SAVED_ROUTES_KEY, JSON.stringify(savedRoutes));
                markCacheAsDirty();
                showToast(`"${route.name}" borrado`, "info");
            }
            displayRoutes(); 
        });
        listElement.appendChild(li);
    };
    
    const displayRoutes = () => {
        const filterText = filterInput.value.toUpperCase().trim();
        clearFilterBtn.style.display = filterText ? 'block' : 'none';

        let recentRoutes = JSON.parse(localStorage.getItem('boardinggate_recent_routes') || "[]");
        let savedRoutes = JSON.parse(localStorage.getItem(SAVED_ROUTES_KEY) || "[]");
        savedRoutes.sort((a, b) => new Date(b.createdAt || 0).getTime() - new Date(a.createdAt || 0).getTime());

        const recentItemsList = document.getElementById('recent-items-list');
        const recentsTitle = recentItemsList.parentElement.previousElementSibling;
        recentItemsList.innerHTML = '';
        const filteredRecents = recentRoutes.filter(r => r.name.toUpperCase().includes(filterText));
        if (filteredRecents.length > 0) {
            recentsTitle.style.display = 'block';
            filteredRecents.forEach(route => renderRouteListItem(route, recentItemsList, true));
        } else {
            recentsTitle.style.display = 'none';
        }
        
        const recentRouteNames = recentRoutes.map(r => r.name);

        const savedDestinationsList = document.getElementById('saved-destinations-list');
        savedDestinationsList.innerHTML = '';
        const savedDestinations = savedRoutes.filter(r => 
            r.waypoints.length === 1 && 
            !recentRouteNames.includes(r.name) && 
            r.name.toUpperCase().includes(filterText)
        );
        if (savedDestinations.length > 0) {
            savedDestinations.forEach(route => renderRouteListItem(route, savedDestinationsList, false));
        } else {
            savedDestinationsList.innerHTML = `<li class="route-list-empty">No hay destinos guardados que coincidan.</li>`;
        }

        const savedRoutesList = document.getElementById('saved-routes-list');
        savedRoutesList.innerHTML = '';
        const savedMultiStage = savedRoutes.filter(r => 
            r.waypoints.length > 1 && 
            !recentRouteNames.includes(r.name) && 
            r.name.toUpperCase().includes(filterText)
        );
        if (savedMultiStage.length > 0) {
            savedMultiStage.forEach(route => renderRouteListItem(route, savedRoutesList, false));
        } else {
            savedRoutesList.innerHTML = `<li class="route-list-empty">No hay rutas guardadas que coincidan.</li>`;
        }
    };

    filterInput.addEventListener('input', displayRoutes);
    clearFilterBtn.addEventListener('click', () => { filterInput.value = ''; displayRoutes(); });
    displayRoutes();
}

// ===================================================================
// NOMBRE: closeNavigationMap (MODIFICADA - USA RESET CENTRAL)
// RESUMEN: Llama a la función de reseteo al cerrar el mapa para asegurar limpieza.
function closeNavigationMap(force = false) {
    hideAddressSuggestionsModal();
    resetNavigationState(); // Llamada a la nueva función de reseteo
    
    if (manualZoomTimeout) { clearTimeout(manualZoomTimeout); manualZoomTimeout = null; }
    isManualZoomActive = false;
    isAutoZoomActive = false;
    if (markerAnimationState.animationFrameId) { cancelAnimationFrame(markerAnimationState.animationFrameId); markerAnimationState.animationFrameId = null; }
    isGeolocated = false;

    const wasInDirectToMapModeSession = sessionStorage.getItem('isInDirectToMapMode') === 'true';
    const userPrefersDirectToNav = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
    if (wasInDirectToMapModeSession && userPrefersDirectToNav && !force) {
        sessionStorage.removeItem('isInDirectToMapMode');
        sessionStorage.setItem(TEMP_PREVENT_DIRECT_NAV_KEY, 'true');
        location.reload();
        return;
    }
    directToNavOnLoad = false;
    sessionStorage.removeItem('isInDirectToMapMode');
    isNavigationMapActive = false;
    sessionStorage.removeItem('mapContext');
    if (locationWatchId !== null && navigator.geolocation) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
    if (gpsRetryTimeoutId) { clearTimeout(gpsRetryTimeoutId); gpsRetryTimeoutId = null; }
    gpsRetryAttempt = 0;
    
    const mapModalElement = document.getElementById('reminders-location-map-modal');
    if (mapModalElement) {
        mapModalElement.classList.add('map-modal-hidden');
    }
    
    const simModal = document.getElementById('simulation-modal');
    if (simModal && !simModal.classList.contains('hidden')) {
        if (simulationModalTimer) clearTimeout(simulationModalTimer);
        const simCloseBtn = simModal.querySelector('#close-simulation-modal');
        if (simCloseBtn) clearModalAutoCloseTimer(simModal, simCloseBtn, 'simulation-modal');
        simModal.classList.add('hidden');
        hideIntersectionPreviewMap();
    }

    sessionStorage.removeItem('boardinggate_map_should_reopen_after_form');
    hideUnifiedReminderWindow();
    
    if (!directToNavOnLoad) {
        const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'block';
        const footer = document.querySelector('footer'); if (footer) footer.style.display = 'block';
        const noticesContainer = document.querySelector('.notices-icon-container'); if (noticesContainer) noticesContainer.style.display = 'flex';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'flex');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'block');
        const gridFilter = document.getElementById('grid-filter-container'); if (gridFilter) gridFilter.style.display = 'flex';
        renderGrid();
        renderToggleButtons();
        updateButtonStyles();
        filterGridItems();
        setTimeout(adjustButtonPositions, 100);
    }
}
// ===================================================================
// NOMBRE: updateStartNavigationButtonState (CORRECCIÓN FINAL: SIMULADOR SIEMPRE VISIBLE)
// RESUMEN: Actualiza la visibilidad de los botones de navegación. Iniciar y Simular GPS ahora siempre están visibles.
function updateStartNavigationButtonState() {
    const startNavButton = document.getElementById('start-navigation-button');
    const saveRouteButton = document.getElementById('save-route-button');
    const reorderBtn = document.getElementById('reorder-route-stages-button');
    const startNavImg = startNavButton ? startNavButton.querySelector('img') : null;
    const simulateBtn = document.getElementById('simulate-route-button');
    const deleteRouteBtn = document.getElementById('delete-current-route-button');
    const loadRouteBtn = document.getElementById('load-saved-route-button'); 
    const toggleSimulateGpsBtn = document.getElementById('toggle-simulate-gps-button');
    const graphCard = document.getElementById('navigation-graph-card');

    if (!startNavButton || !saveRouteButton || !reorderBtn || !simulateBtn || !loadRouteBtn || !deleteRouteBtn || !toggleSimulateGpsBtn || !graphCard) return;
    
    const hasEnoughWaypointsForRoute = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length >= 2;
    const hasRouteData = navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0];
    const canDisplayRoute = hasEnoughWaypointsForRoute && hasRouteData;

    // <<< CORRECCIÓN DEFINITIVA: Los botones de Iniciar Navegación y Simular GPS siempre están visibles >>>
    startNavButton.classList.remove('hidden');
    if (toggleSimulateGpsBtn) toggleSimulateGpsBtn.style.display = 'inline-flex';

    // Se actualiza el icono de Iniciar/Terminar según el estado
    if (isNavigating || isFreeDriveActive) {
        if(startNavImg) startNavImg.src = "PNG/TERMINARNAVEGACION.PNG";
    } else {
        if(startNavImg) startNavImg.src = "PNG/INICIARNAVEGACION.PNG";
    }
    saveRouteButton.classList.toggle('hidden', !(!isNavigating && canDisplayRoute));
    if (reorderBtn) reorderBtn.style.display = (!isNavigating && canDisplayRoute) ? 'inline-flex' : 'none';
    const canSimulate = (canDisplayRoute || (isNavigating && hasRouteData));
    if(simulateBtn) simulateBtn.style.display = canSimulate ? 'inline-flex' : 'none';
    
    if (deleteRouteBtn) {
        deleteRouteBtn.classList.remove('hidden');
    }
    if (loadRouteBtn) {
        loadRouteBtn.classList.remove('hidden');
    }
    const hasGraphData = graphDataPoints && (graphDataPoints.speed.length > 0 || graphDataPoints.altitude.length > 0);
    graphCard.classList.toggle('hidden', !hasGraphData || currentGraphMode === 'Gráfica off');
    
    if (!hasEnoughWaypointsForRoute && !isNavigating && !isFreeDriveActive) {
         if (navigationMapInstance && navigationMapInstance.getLayer('route')) {
             navigationMapInstance.removeLayer('route');
             navigationMapInstance.removeSource('route');
         }
         navigationRouteLayer = null;
         completedSegmentsGeoJSON.features = [];
         if (navigationMapInstance && navigationMapInstance.getSource('completed-segments')) {
             navigationMapInstance.getSource('completed-segments').setData(completedSegmentsGeoJSON);
         }
         navigationCurrentRouteData = null;
         hideNavigationUI();
         hideMapInfoOverlay();
    }
    updateNavigationGraphVisibilityAndMode();
}
    
// ===================================================================
// NOMBRE: updateNavigationGraphVisibilityAndMode
// RESUMEN: Actualiza la visibilidad y modo de la gráfica de navegación.
function updateNavigationGraphVisibilityAndMode() {
    const graphCard = document.getElementById('navigation-graph-card');
    const graphContainer = document.getElementById('navigation-graph-container');
    const graphTitleElement = document.getElementById('navigation-graph-title');
    const compassControl = document.querySelector('.map-control-orientation-altitude');
    if (!graphCard || !graphContainer || !graphTitleElement) {
        return;
    }
    if (compassAndModeControl) {
        compassAndModeControl._updateGraphTitle();
    }
    const isEnlarged = graphCard.classList.contains('enlarged');
    if ((navigationCurrentRouteData || isFreeDriveActive) && currentGraphMode !== 'Gráfica off') {
        graphCard.classList.remove('hidden');
        if (!isEnlarged) {
            const compassHeight = compassControl ? compassControl.offsetHeight : 0;
            graphCard.style.height = compassHeight > 0 ? `${compassHeight}px` : '157px';
        }
        if (navigationChart) {
            updateChartData(); 
        } else if (isNavigating || isFreeDriveActive) {
            initializeNavigationGraph();
        }
    } else {
        graphCard.classList.add('hidden');
    }
}    
    
// ===================================================================
// NOMBRE: handlePickerMapClick (NUEVA FUNCIÓN - PARA MAPBOX)
// RESUMEN: Maneja el clic en el mapa selector de ubicaciones para fijar coordenadas.
function handlePickerMapClick(e, slotIndex) {
    const lngLat = e.lngLat;
    if (locationPickerMarker) {
        locationPickerMarker.setLngLat(lngLat);
    }
    if (!tempSavedLocations[slotIndex]) tempSavedLocations[slotIndex] = { name: '', lat: null, lng: null, radius: DEFAULT_LOCATION_RADIUS };
    tempSavedLocations[slotIndex].lat = lngLat.lat;
    tempSavedLocations[slotIndex].lng = lngLat.lng;
}
    
    // ===================================================================
    // NOMBRE: updateNavigationButtonColor
    // RESUMEN: Actualiza el color del botón de inicio de navegación según el estado.
    function updateNavigationButtonColor() {
        const startNavButton = document.getElementById('start-navigation-button');
        if (startNavButton) {
            if (isNavigating) {
                startNavButton.style.setProperty('background-color', '#000000', 'important');
            } else {
                startNavButton.style.backgroundColor = 'white';
                startNavButton.style.boxShadow = '2px 3px 5px rgba(0,0,0,0.60)';
            }
        }
    }
    
// ===================================================================
// NOMBRE: showToast (MODIFICADA - AÑADIDO BOTÓN INTERACTIVO)
function showToast(message, type = 'info', duration = 3000, isErrorNotFound = false, toastId = null) {
    const uniqueToastId = toastId || 'toast-notification-element' + (type === 'debug' ? '-debug' : '') + `-${Date.now()}`;
    
    let currentTopOffset = 180;
    const toastSpacing = 10;
    
    if (type !== 'instructional') {
        activeToasts.forEach(activeToast => {
            const toastElement = document.getElementById(activeToast.id);
            if (toastElement) {
                 currentTopOffset += toastElement.offsetHeight + toastSpacing;
            }
        });
    }

    const existingToast = document.getElementById(uniqueToastId);
    if (existingToast && !toastId) {
        existingToast.remove();
        activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
    } else if (existingToast && toastId) {
         existingToast.remove();
         activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
         currentTopOffset = 180;
         activeToasts.forEach(activeToast => {
            const toastElement = document.getElementById(activeToast.id);
            if (toastElement) {
                currentTopOffset += toastElement.offsetHeight + toastSpacing;
            }
         });
    }
    const toast = document.createElement('div');
    toast.id = uniqueToastId;
    toast.className = `toast-notification toast-${type}`;
    if (isErrorNotFound && type === 'error') {
        toast.classList.add('not-found');
    }
    const messageSpan = document.createElement('span');
    messageSpan.innerHTML = message.replace(/\n/g, '<br>');
    toast.appendChild(messageSpan);
    if (type === 'debug') {
        toast.style.top = 'auto';
        toast.style.bottom = '20px';
        toast.style.right = '20px';
        toast.style.left = 'auto';
        toast.style.transform = 'none';
        toast.style.maxWidth = 'calc(100% - 40px)';
        const closeButtonToast = document.createElement('button');
        closeButtonToast.textContent = 'Cerrar Info Debug';
        closeButtonToast.style.cssText = "display: block; margin-top: 10px; padding: 5px 10px; background-color: rgba(255,255,255,0.2); color: white; border: 1px solid white; border-radius: 3px; cursor: pointer;";
        closeButtonToast.onclick = () => {
            if (toast.parentNode) toast.parentNode.removeChild(toast);
             activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
        };
        toast.appendChild(closeButtonToast);
    }

    if (type === 'instructional') {
        const buttonContainer = document.createElement('div');
        buttonContainer.style.marginTop = '10px';
        const enteradoButton = document.createElement('button');
        enteradoButton.textContent = 'ENTERADO';
        enteradoButton.style.cssText = `
            background-color: rgba(0,0,0,0.3); color: white; border: 1px solid white; 
            padding: 5px 10px; border-radius: 5px; font-weight: bold; cursor: pointer;
        `;
        
        const closeToast = () => {
            if (toast.classList.contains('show')) {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => {
                    if (toast.parentNode) toast.parentNode.removeChild(toast);
                    activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
                }, { once: true });
            } else {
                if (toast.parentNode) toast.parentNode.removeChild(toast);
                activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
            }
        };

        enteradoButton.addEventListener('click', closeToast);
        buttonContainer.appendChild(enteradoButton);
        toast.appendChild(buttonContainer);
        
        toast.style.top = '25px';
        toast.style.right = '15px';
        
    } else {
        toast.style.top = `${currentTopOffset}px`;
    }

    document.body.appendChild(toast);
    activeToasts.push({ id: uniqueToastId, element: toast });
    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            toast.classList.add('show');
        });
    });
    if (duration > 0 && type !== 'debug') {
        setTimeout(() => {
            const toastElement = document.getElementById(uniqueToastId);
            if (toastElement && toastElement.classList.contains('show')) {
                toastElement.classList.remove('show');
                toastElement.addEventListener('transitionend', () => {
                     if (toastElement.parentNode) { toastElement.parentNode.removeChild(toastElement); }
                     activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
                }, { once: true });
            } else if (toastElement) {
                 if (toastElement.parentNode) { toastElement.parentNode.removeChild(toastElement); }
                 activeToasts = activeToasts.filter(t => t.id !== uniqueToastId);
            }
        }, duration);
    }
}    
// ===================================================================
// NOMBRE: toggleEnlargedGraph
// RESUMEN: Amplía o reduce la gráfica de navegación.
function toggleEnlargedGraph() {
    const graphCard = document.getElementById('navigation-graph-card');
    const enlargeButton = document.getElementById('enlarge-graph-button');
    const compassControlContainer = document.querySelector('.map-control-orientation-altitude');
    const mapModal = document.getElementById('reminders-location-map-modal');
    if (!graphCard || !enlargeButton || !compassControlContainer || !mapModal) return;
    const isCurrentlyEnlarged = graphCard.classList.contains('enlarged');
    if (!isCurrentlyEnlarged) {
        graphCard.classList.add('enlarged');
        const compassRect = compassControlContainer.getBoundingClientRect();
        const fixedWidth = 995; 
        const fixedHeight = 600; 
        const newLeft = compassRect.left;
        const distanceFromBottom = window.innerHeight - compassRect.bottom;
        const newBottom = distanceFromBottom;
        graphCard.style.left = `${newLeft}px`;
        graphCard.style.bottom = `${newBottom}px`;
        graphCard.style.width = `${fixedWidth}px`;
        graphCard.style.height = `${fixedHeight}px`;
        enlargeButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        `;
        enlargeButton.title = 'Reducir gráfica';
    } else {
        graphCard.classList.remove('enlarged');
        graphCard.style.left = '';
        graphCard.style.bottom = '';
        graphCard.style.width = '';
        graphCard.style.height = '';
        graphCard.style.top = '';
        graphCard.style.right = '';
        graphCard.style.transform = '';
        enlargeButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="11" y1="8" x2="11" y2="14"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        `;
        enlargeButton.title = 'Ampliar gráfica';
    }
    if (navigationChart) {
        updateChartData(); 
        setTimeout(() => {
            navigationChart.resize();
        }, 200);
    }
    updateNavigationGraphVisibilityAndMode();    
}

// ===================================================================
// NOMBRE: setMapImmersiveMode (NUEVA FUNCIÓN)
// RESUMEN: Activa o desactiva el modo inmersivo del mapa de forma explícita.
function setMapImmersiveMode(activate) {
    if (isMapImmersiveModeActive === activate) return;

    isMapImmersiveModeActive = activate;
    const mapModal = document.getElementById('reminders-location-map-modal');
    if (mapModal) {
        mapModal.classList.toggle('immersive-mode-active', isMapImmersiveModeActive);
        
        if (!isMapImmersiveModeActive) {
            progressBarForceShowUntil = Date.now() + 20000;
            const progressBar = document.getElementById('navigation-bottom-progress-bar');
            if (progressBar) {
                progressBar.classList.remove('progress-bar-auto-hidden');
            }
        }
        
        if (navigationMapInstance) {
            setTimeout(() => {
                try {
                    navigationMapInstance.resize();
                } catch(e) { console.error("Error al redimensionar mapa en setMapImmersiveMode:", e); }
            }, 350);
        }
    }
}
// ===================================================================
// NOMBRE: hideAutoStartNavigationModal (MODIFICADA)
// RESUMEN: Oculta el modal de inicio y restaura la posición de la barra de progreso.
function hideAutoStartNavigationModal() {
    if (autoStartNavModalTimer) {
        clearInterval(autoStartNavModalTimer);
        autoStartNavModalTimer = null;
    }
    const modal = document.getElementById('auto-start-nav-modal');
    if (modal) {
        modal.remove();
    }
    
    const progressBar = document.getElementById('navigation-bottom-progress-bar');
    if (progressBar) {
        progressBar.classList.remove('progress-bar-partially-hidden');
    }
}    

// ===================================================================
// NOMBRE: toggleMapImmersiveMode (CORREGIDA - USA RESIZE)
// RESUMEN: Activa o desactiva el modo inmersivo del mapa para ocultar los controles.
function toggleMapImmersiveMode() {
    isMapImmersiveModeActive = !isMapImmersiveModeActive;
    const mapModal = document.getElementById('reminders-location-map-modal');
    if (mapModal) {
        mapModal.classList.toggle('immersive-mode-active', isMapImmersiveModeActive);
        
        if (!isMapImmersiveModeActive) {
            progressBarForceShowUntil = Date.now() + 20000;
            const progressBar = document.getElementById('navigation-bottom-progress-bar');
            if (progressBar) {
                progressBar.classList.remove('progress-bar-auto-hidden');
            }
        }
        
        if (navigationMapInstance) {
            setTimeout(() => {
                try {
                    navigationMapInstance.resize();
                } catch(e) { console.error("Error al redimensionar mapa en toggleMapImmersiveMode:", e); }
            }, 350);
        }
    }
    showToast(isMapImmersiveModeActive ? 'Modo Inmersivo Activado' : 'Modo Inmersivo Desactivado', 'info');
}
        
// ===================================================================
// NOMBRE: reactivateRealGpsAfterSimulation (MODIFICADA - PARA MAPBOX)
// RESUMEN: Reactiva el seguimiento del GPS real después de una simulación.
function reactivateRealGpsAfterSimulation() {
    if (locationWatchId === null && 'geolocation' in navigator && 'watchPosition' in navigator.geolocation) {
        locationWatchId = navigator.geolocation.watchPosition(
            (position) => {
                if (isSimulatingGpsLocation) return;
                const coordsForUpdate = {
                     latitude: position.coords.latitude, longitude: position.coords.longitude,
                     accuracy: position.coords.accuracy, heading: position.coords.heading,
                     altitude: position.coords.altitude, speed: position.coords.speed
                };
                navigationCurrentLocation = coordsForUpdate;
                updateInitialUserPosition(coordsForUpdate, navigationMapInstance);
                 if(isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
                    const routeForDistCalc = navigationCurrentRouteData.routes[0];
                    let carDistTurf = 0;
                    if (routeForDistCalc.geometry && typeof turf !== 'undefined') {
                        try {
                            const carPointTurf = turf.point([coordsForUpdate.longitude, coordsForUpdate.latitude]);
                            const routeLineStringTurf = turf.lineString(routeForDistCalc.geometry.coordinates);
                            const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                            const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                            carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                        } catch(e){
                        }
                    }
                    const totalRouteLength = routeForDistCalc.distance;
                     if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                        if (carDistTurf < lastCarDistanceAlongRouteForNavLogic - 100 && lastCarDistanceAlongRouteForNavLogic > 100) {
                        } else {
                            lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                        }
                    } else if (carDistTurf > totalRouteLength + 500) {
                        lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
                    }
                    updateTurnByTurnDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                    updateNavigationProgressDisplay(routeForDistCalc, lastCarDistanceAlongRouteForNavLogic);
                }
            },
            (error) => {
                showToast(`Error al reactivar GPS: ${error.message}`, "warning");
            },
            { enableHighAccuracy: true, timeout: 15000, maximumAge: 3000, distanceFilter: 3 }
        );
        getCurrentLocation(coords => {
            if (!isSimulatingGpsLocation) {
                navigationCurrentLocation = coords;
                updateInitialUserPosition(coords, navigationMapInstance);
                if (isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
                    const routeForDistCalc = navigationCurrentRouteData.routes[0];
                    let carDistTurf = 0;
                     if (routeForDistCalc.geometry && typeof turf !== 'undefined') {
                        try {
                            const carPointTurf = turf.point([coords.longitude, coords.latitude]);
                            const routeLineStringTurf = turf.lineString(routeForDistCalc.geometry.coordinates);
                            const nearestPointOnLineTurf = turf.nearestPointOnLine(routeLineStringTurf, carPointTurf, { units: 'meters' });
                            const lineSliceToNearestTurf = turf.lineSlice(turf.point(routeLineStringTurf.geometry.coordinates[0]), nearestPointOnLineTurf, routeLineStringTurf);
                            carDistTurf = turf.length(lineSliceToNearestTurf, { units: 'meters' });
                        } catch(e){
                        }
                     }
                    const totalRouteLength = routeForDistCalc.distance;
                     if (carDistTurf >= 0 && carDistTurf <= totalRouteLength + 500) {
                        if (carDistTurf < lastCarDistanceAlongRouteForNavLogic - 100 && lastCarDistanceAlongRouteForNavLogic > 100) {
                        }
                        lastCarDistanceAlongRouteForNavLogic = carDistTurf;
                    } else if (carDistTurf > totalRouteLength + 500) {
                        lastCarDistanceAlongRouteForNavLogic = totalRouteLength;
                    }
                    updateTurnByTurnDisplay(routeForDistCalc, carDistTurf);
                    updateNavigationProgressDisplay(routeForDistCalc, carDistTurf);
                }
            }
        });
    }
}
// ===================================================================
// NOMBRE: animateMarkerAndMap (VERSIÓN CORREGIDA - YA NO CONTROLA EL MAPA)
// RESUMEN: Bucle de animación que mueve y rota suavemente el ICONO del coche.
// ===================================================================
function animateMarkerAndMap(timestamp) {
    if (!markerAnimationState.lastTimestamp) {
        markerAnimationState.lastTimestamp = timestamp;
        markerAnimationState.animationFrameId = requestAnimationFrame(animateMarkerAndMap);
        return;
    }

    const deltaTime = timestamp - markerAnimationState.lastTimestamp;
    markerAnimationState.lastTimestamp = timestamp;

    const LERP_RATE = 0.005; 
    const ROTATION_LERP_RATE = 0.006;
    const lerpFactor = 1.0 - Math.exp(-deltaTime * LERP_RATE);
    const rotationLerpFactor = 1.0 - Math.exp(-deltaTime * ROTATION_LERP_RATE);

    if (markerAnimationState.currentLngLat && markerAnimationState.targetLngLat) {
        markerAnimationState.currentLngLat.lng += (markerAnimationState.targetLngLat.lng - markerAnimationState.currentLngLat.lng) * lerpFactor;
        markerAnimationState.currentLngLat.lat += (markerAnimationState.targetLngLat.lat - markerAnimationState.currentLngLat.lat) * lerpFactor;
        if (initialUserLocationMarker) {
            initialUserLocationMarker.setLngLat(markerAnimationState.currentLngLat);
        }
    }

    // Rotar el icono del marcador
    let deltaIconRotation = markerAnimationState.targetIconRotation - markerAnimationState.currentIconRotation;
    if (deltaIconRotation > 180) deltaIconRotation -= 360;
    if (deltaIconRotation < -180) deltaIconRotation += 360;
    markerAnimationState.currentIconRotation += deltaIconRotation * rotationLerpFactor;
    if (initialUserLocationMarker) {
        initialUserLocationMarker.setRotation(markerAnimationState.currentIconRotation);
    }
    
    markerAnimationState.animationFrameId = requestAnimationFrame(animateMarkerAndMap);
}    
    
// ===================================================================
// NOMBRE: getRouteStyleProperties (VERSIÓN CORREGIDA)
// RESUMEN: Devuelve el estilo correcto para la ruta (amarillo para satélite/híbrido, azul para calles).
function getRouteStyleProperties() {
    let activeLayerName = localStorage.getItem(ACTIVE_MAP_LAYER_KEY) || "HÍBRIDO";
    const isStreetsView = activeLayerName === 'CALLES';
    
    return {
        'line-color': isStreetsView ? 'blue' : 'yellow',        
        'line-width': (navigationMapInstance && navigationMapInstance.getPitch() > 20) ? 16 : 12,
        'line-opacity': isStreetsView ? 0.6 : 0.8
    };
}
    
// ===================================================================
// NOMBRE: parseReminderText
// RESUMEN: Parsea el texto de un recordatorio para extraer fecha, hora, repetición, etc.
function parseReminderText(text, elementsToUpdate = null) {
    const result = { text: `<b>${text.trim().toUpperCase()}</b>`, time: null, date: null, repeatDays: [], intervalDays: null, type: null, isLocationEnabled: false, locationCoordinates: null, radiusMeters: 350, excludeFromList: false };
    let norm = text.toUpperCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    const numW = { 'UNA': 1, 'UNO': 1, 'DOS': 2, 'TRES': 3, 'CUATRO': 4, 'CINCO': 5, 'SEIS': 6, 'SIETE': 7, 'OCHO': 8, 'NUEVE': 9, 'DIEZ': 10, 'ONCE': 11, 'DOCE': 12, 'TRECE': 13, 'CATORCE': 14, 'QUINCE': 15, 'DIECISEIS': 16, 'DIECISIETE': 17, 'DIECIOCHO': 18, 'DIECINUEVE': 19, 'VEINTE': 20, 'VEINTIUNO': 21, 'VEINTIDOS': 22, 'VEINTITRES': 23, 'VEINTICUATRO': 24, 'VEINTICINCO': 25, 'VEINTISEIS': 26, 'VEINTISIETE': 27, 'VEINTIOCHO': 28, 'VEINTINUEVE': 29, 'TREINTA': 30, 'TREINTAYUNO': 31 }; const tRgx = /\b(\d{1,2}):(\d{2})\b/; const ttRgx = /.*\bA\s*LAS?\s*(\d+|\w+)\s*(?:Y\s*(CUARTO|MEDIA|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA)|MENOS\s*(CUARTO|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA))?\s*(DE\s*LA\s*(MANANA|TARDE|NOCHE))?/i; const tM = norm.match(tRgx); if (tM) { let h = parseInt(tM[1]); let m = parseInt(tM[2]); if (h >= 0 && h <= 23 && m >= 0 && m <= 59) result.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`; } else { const ttM = norm.match(ttRgx); if (ttM) { let h = numW[ttM[1].toUpperCase()] || parseInt(ttM[1]); if (!isNaN(h)) { const minTxt = ttM[2]?.toUpperCase() || ''; const minus = ttM[3]?.toUpperCase() || ''; const period = ttM[5]?.toUpperCase() || null; let m = 0; if (minTxt) m = minTxt === 'CUARTO' ? 15 : minTxt === 'MEDIA' ? 30 : numW[minTxt] || parseInt(minTxt) || 0; else if (minus) { m = minus === 'CUARTO' ? 15 : numW[minus] || parseInt(minus) || 0; h = (h - 1 + 24) % 24; m = (60 - m + 60) % 60; } if (period) { if (period === 'TARDE' && h >= 1 && h <= 11) h += 12; if (period === 'NOCHE' && h >= 1 && h <= 11) h += 12; if (period === 'MANANA' && h === 12) h = 0; if (period === 'TARDE' && h === 12) h = 12; if (period === 'NOCHE' && h === 12) h = 0; } else if (h >= 1 && h <= 5) h += 12; if (h >= 0 && h <= 23 && m >= 0 && m <= 59) result.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`; } } } const daysMap = { 'LUNES': 1, 'MARTES': 2, 'MIERCOLES': 3, 'MIÉRCOLES': 3, 'JUEVES': 4, 'VIERNES': 5, 'SABADO': 6, 'SÁBADO': 6, 'DOMINGO': 0 }; const wRgx = /(TODOS\s+LOS|LOS|CADA)?\s*(LUNES|MARTES|MIERCOLES|MIÉRCOLES|JUEVES|VIERNES|SABADO|SÁBADO|DOMINGO)/g; let wM; while ((wM = wRgx.exec(norm)) !== null) { const day = daysMap[wM[2]]; if (day !== undefined && !result.repeatDays.includes(day)) result.repeatDays.push(day); }
    const now = new Date(); const manDRgx = /(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{2}|\d{4})\b/; const manDM = norm.match(manDRgx);
    if (manDM && !result.date) { let d = parseInt(manDM[1]); let m = parseInt(manDM[2]); let y = parseInt(manDM[3]); if (y >= 0 && y <= 99) y += 2000; if (d >= 1 && d <= 31 && m >= 1 && m <= 12 && y >= 2000 && y <= 2099) { const tD = new Date(Date.UTC(y, m - 1, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() + 1 === m && tD.getUTCFullYear() === y) { result.date = `${y}-${m.toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } } }
    const todayRgx = /\bHOY\b/; const tomRgx = /\bMANANA\b/; const dayAftRgx = /\bPASADO\s*MANANA\b/;
    if (!result.date) { if (norm.match(todayRgx)) { result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (norm.match(dayAftRgx)) { const tD = new Date(now); tD.setDate(now.getDate() + 2); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } else if (norm.match(tomRgx)) { const tD = new Date(now); tD.setDate(now.getDate() + 1); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } }
    const dndRgx = /(?:EL\s*(PROXIMO)?\s*)?(LUNES|MARTES|MIERCOLES|MIÉRCOLES|JUEVES|VIERNES|SABADO|SÁBADO|DOMINGO)/i; const dndM = norm.match(dndRgx);
    if (dndM && !result.date) { const tDN = dndM[2].toUpperCase(); const tD = daysMap[tDN]; if (tD !== undefined) { const curD = now.getDay(); let dU = (tD - curD + 7) % 7; if (dU === 0) dU = 7; if (dndM[1]?.toUpperCase() === 'PROXIMO') dU += 7; const target = new Date(now); target.setDate(now.getDate() + dU); result.date = `${target.getFullYear()}-${(target.getMonth() + 1).toString().padStart(2, '0')}-${target.getDate().toString().padStart(2, '0')}`; } }
    const didRgx = /DENTRO\s*DE\s*(\d+)\s*DIAS?/; const didM = norm.match(didRgx);
    if (didM && !result.date) { const d = parseInt(didM[1]); if (!isNaN(d) && d > 0) { const tD = new Date(now); tD.setDate(now.getDate() + d); result.date = `${tD.getFullYear()}-${(tD.getMonth() + 1).toString().padStart(2, '0')}-${tD.getDate().toString().padStart(2, '0')}`; } }
    const dsdRgx = /\bEL\s*DIA\s*(\d{1,2})\b/; const dsdM = norm.match(dsdRgx);
    if (dsdM && !result.date) { const d = parseInt(dsdM[1]); if (!isNaN(d) && d >= 1 && d <= 31) { let tM = now.getMonth(); let tY = now.getFullYear(); if (d < now.getDate()) { tM++; if (tM > 11) { tM = 0; tY++; } } const tD = new Date(Date.UTC(tY, tM, d)); if (!isNaN(tD.getTime()) && tD.getUTCDate() === d && tD.getUTCMonth() === tM) { result.date = `${tY}-${(tM + 1).toString().padStart(2, '0')}-${d.toString().padStart(2, '0')}`; } } }
    const intRgx = /CADA\s*(\d+)\s*DIAS?/; const intM = norm.match(intRgx);
    if (intM) { result.intervalDays = parseInt(intM[1]); if (!result.date) { result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } }
    const timRgx = /(ALARMA|AVISO|AVISAR|AVISARME|AVÍSAME|TEMPORIZADOR|TIMER|RECORDAR|RECORDARME|RECUÉRDAME)\b.*?\b(\d+|\w+)\s*(MINUTOS?|HORAS?|MINS?|HRS?)/i; const timM = norm.match(timRgx);
    if (timM) { const valStr = timM[2]; const unit = timM[3]?.toUpperCase(); let val = numW[valStr.toUpperCase()] || parseInt(valStr); if (!isNaN(val) && val > 0 && unit) { let tmc = 0; if (unit.startsWith('HORA') || unit.startsWith('HR')) { tmc = val * 60; } else if (unit.startsWith('MINUTO') || unit.startsWith('MIN')) { tmc = val; }
            if (tmc > 0) { const endT = new Date(Date.now() + tmc * 60000); result.date = `${endT.getFullYear()}-${(endT.getMonth() + 1).toString().padStart(2, '0')}-${endT.getDate().toString().padStart(2, '0')}`; result.time = `${endT.getHours().toString().padStart(2, '0')}:${endT.getMinutes().toString().padStart(2, '0')}`; result.repeatDays = []; result.intervalDays = null; result.type = 'simple'; } } }
    
    const locationPhrases = ["EN EL LUGAR", "EN EL SITIO", "EN LA UBICACION", "EN LA LOCALIZACION"];
    if (locationPhrases.some(phrase => norm.includes(phrase)) || norm.includes("RADAR")) {
        result.isLocationEnabled = true;
    }
    
    const radiusRgx = /(?:RADIO|MARGEN)\s*DE\s*(\d+)\s*METROS?/i; const radiusMatch = norm.match(radiusRgx);
    if (radiusMatch && radiusMatch[1]) { const parsedRadius = parseInt(radiusMatch[1]); if (!isNaN(parsedRadius) && parsedRadius > 0) { result.radiusMeters = parsedRadius; result.isLocationEnabled = true; } }
    const excludePhrases = ["NO LISTAR", "NO MOSTRAR EN LISTA", "EXCLUIR LISTA", "OCULTAR LISTA", "RADAR"]; if (excludePhrases.some(phrase => norm.includes(phrase))) { result.excludeFromList = true; }
    if (norm.toUpperCase().startsWith("<b>RADAR") && result.radiusMeters === 350 && !radiusMatch) {
        result.radiusMeters = 350;
    } else if (result.radiusMeters === 350 && !norm.toUpperCase().startsWith("<b>RADAR") && !radiusMatch && !excludePhrases.some(phrase => norm.includes(phrase))) {
        result.radiusMeters = 350;
    }
    if (result.type === null) {
        if (result.intervalDays !== null && result.date) { result.type = 'interval'; } else if (result.repeatDays.length > 0 && result.time) { result.type = 'weekly'; } else if (result.date && result.time) { result.type = 'daily'; } else if (result.time) { result.type = 'daily'; if (!result.date) result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`; } else if (result.date) { result.type = 'daily'; } else { result.type = 'simple'; } }
    if (!result.time && (result.type === 'daily' || result.type === 'weekly' || result.type === 'interval' )) { result.time = '00:01'; }
    if (elementsToUpdate) {
         if (elementsToUpdate.locationCheckbox) { const shouldBeChecked = result.isLocationEnabled; if (elementsToUpdate.locationCheckbox.checked !== shouldBeChecked && !elementsToUpdate.mapExpandedManually) { elementsToUpdate.locationCheckbox.checked = shouldBeChecked; } }
         if (elementsToUpdate.radiusInput) { elementsToUpdate.radiusInput.value = result.radiusMeters; }
         if (!elementsToUpdate.manualTimeInput && elementsToUpdate.timeInput && result.time) { elementsToUpdate.timeInput.value = result.time; }
         if (elementsToUpdate.dateInput && result.date) { const dateParts = result.date.split('-');
         if(dateParts.length === 3) { elementsToUpdate.dateInput.value = `${dateParts[2]}/${dateParts[1]}/${dateParts[0]}`; } else { elementsToUpdate.dateInput.value = ''; } } else if (elementsToUpdate.dateInput) { elementsToUpdate.dateInput.value = ''; }
         if (elementsToUpdate.intervalInput) { elementsToUpdate.intervalInput.value = result.intervalDays || ''; }
         if (elementsToUpdate.repeatCheckboxes && result.repeatDays && result.repeatDays.length > 0) { elementsToUpdate.repeatCheckboxes.forEach(input => { input.checked = result.repeatDays.includes(parseInt(input.value)); }); } else if (elementsToUpdate.repeatCheckboxes) { elementsToUpdate.repeatCheckboxes.forEach(input => { input.checked = false; }); }
         if (elementsToUpdate.excludeFromListCheckbox) { elementsToUpdate.excludeFromListCheckbox.checked = result.excludeFromList; }
    } return result;
}

// ===================================================================
// NOMBRE: displayAddressSuggestionsModal (VERSIÓN FINAL Y CORRECTA)
// RESUMEN: La corrección clave es que ahora elimina la clase '.hidden'
function displayAddressSuggestionsModal(suggestions) {
    const searchInput = document.getElementById('map-location-search-input');
    if (!searchInput) return;

    const modalId = 'address-suggestions-modal';
    let modal = document.getElementById(modalId);
    
    if (!modal) {
        modal = document.createElement('div');
        modal.id = modalId;
        modal.className = 'address-suggestions-modal';
        modal.style.zIndex = '11005 !important'; 
        modal.innerHTML = `
            <h2 id="address-suggestions-title"></h2>
            <ul id="address-suggestions-list"></ul>
            <div class="modal-top-buttons" style="justify-content: flex-end; margin-top: 1rem;">
                <button id="close-address-suggestions-modal" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
            </div>
        `;
        document.body.appendChild(modal); 
        const closeButton = modal.querySelector('#close-address-suggestions-modal');
        closeButton.addEventListener('click', hideAddressSuggestionsModal);
    }
    
    const titleElement = modal.querySelector('#address-suggestions-title');
    const listElement = modal.querySelector('#address-suggestions-list');
    const closeButton = modal.querySelector('#close-address-suggestions-modal');
    
    clearModalAutoCloseTimer(modal, closeButton, 'address-suggestions-modal');

    if (suggestions.length === 0) {
        titleElement.textContent = "No se encontraron coincidencias";
        listElement.innerHTML = '<li style="cursor: default; background-color: #a09888; color: #444;">Prueba con términos más generales.</li>';
        modal.classList.remove('hidden'); 

        addModalAutoCloseTimer(modal, closeButton, 'address-suggestions-modal', 5000); 
        return;
    }
    
    titleElement.textContent = `${suggestions.length} coincidencia${suggestions.length !== 1 ? 's' : ''} encontrada${suggestions.length !== 1 ? 's' : ''}`;
    listElement.innerHTML = '';
    suggestions.forEach(suggestion => {
        const li = document.createElement('li');
        li.textContent = suggestion.display_name;
        li.dataset.lat = suggestion.lat;
        li.dataset.lon = suggestion.lon;
        
        li.addEventListener('click', async () => {
            const lat = parseFloat(li.dataset.lat);
            const lon = parseFloat(li.dataset.lon);
            const displayName = li.textContent;
            
            if (isNaN(lat) || isNaN(lon)) {
                showToast("Error: Coordenadas de sugerencia no válidas.", "error");
                return;
            }

            hideAddressSuggestionsModal();
            showToast("Ajustando a la carretera más cercana...", "info", 3000);
            
            const snappedLatLng = await snapCoordsToRoad(lat, lon);
            await addWaypoint(snappedLatLng, displayName);

            if (navigationMapInstance) navigationMapInstance.flyTo({ center: [lon, lat], zoom: 15 });
            if (searchInput) {
                searchInput.value = '';
                searchInput.dispatchEvent(new Event('input'));
            }
            showToast("Ubicación añadida a la ruta", "success");
        });
      
        listElement.appendChild(li);
    });
    
    const searchInputRect = searchInput.getBoundingClientRect();
    modal.style.top = `${searchInputRect.bottom + 5}px`;
    const viewportHeight = window.innerHeight;
    const modalTop = searchInputRect.bottom + 5;
    const availableHeight = viewportHeight - modalTop - 20;
    modal.style.maxHeight = `${availableHeight}px`;
    const titleHeight = titleElement.offsetHeight;
    const buttonsHeight = modal.querySelector('.modal-top-buttons').offsetHeight;
    const listMaxHeight = availableHeight - titleHeight - buttonsHeight - 30;
    listElement.style.maxHeight = `${Math.max(100, listMaxHeight)}px`;
    
    modal.classList.remove('hidden');
    
    addModalAutoCloseTimer(modal, closeButton, 'address-suggestions-modal', 30000);
}

// ===================================================================
// NOMBRE: stopAutomatedRouteSimulationInternal (NUEVA FUNCIÓN - CORRECCIÓN)
// RESUMEN: Detiene el intervalo de la simulación automática y limpia su ID. Es la función auxiliar que faltaba.
function stopAutomatedRouteSimulationInternal() {
    if (automatedSimulationIntervalId) {
        clearInterval(automatedSimulationIntervalId);
        automatedSimulationIntervalId = null;
    }
}
                  
// ===================================================================
// NOMBRE: fetchRouteData (MODIFICADA - DEVUELVE EL SERVICIO USADO)
// RESUMEN: Pide siempre UNA SOLA ruta por defecto y ahora devuelve el
async function fetchRouteData(coordsString, startHeading = null) {
    const MAPBOX_PRIMARY_KEY = 'boardinggate_useMapboxAsPrimary';
    const useMapboxAsPrimary = localStorage.getItem(MAPBOX_PRIMARY_KEY) === 'true'; // Corregido: Era `!== 'true'`
  
    const osrmService = {
        name: 'OSRM',
        buildUrl: (coords) => {
            return `${OSRM_SERVICE_URL}/driving/${coords}?overview=full&geometries=geojson&steps=true&alternatives=false&annotations=true`;
        },
        processResponse: async (response) => {
            if (!response.ok) {
                let errorData = { message: `OSRM HTTP error ${response.status}` };
                try { errorData = await response.json(); } catch (e) {}
                throw new Error(errorData.code || errorData.message || response.statusText);
            }
            const data = await response.json();
            if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) {
                throw new Error(data.message || "No se encontraron rutas en OSRM.");
            }
            return { routeData: data, serviceUsed: 'OSRM' }; // Devuelve el servicio usado
        }
    };

    const mapboxService = {
        name: 'Mapbox',
        buildUrl: (coords) => {
            return `https://api.mapbox.com/directions/v5/mapbox/driving/${coords}?alternatives=false&geometries=geojson&overview=full&steps=true&access_token=${MAPBOX_ACCESS_TOKEN}`;
        },
        processResponse: async (response) => {
            if (!response.ok) {
                let errorData = { message: `Mapbox HTTP error ${response.status}` };
                try { errorData = await response.json(); } catch (e) {}
                throw new Error(errorData.message || response.statusText);
            }
            const data = await response.json();
            if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) {
                throw new Error(data.message || "No se encontraron rutas en Mapbox.");
            }
            const adaptedRoute = adaptMapboxRouteToOSRMFormat(data.routes[0]);
            const adaptedWaypoints = data.waypoints.map(wp => ({
                distance: wp.distance,
                hint: wp.hint,
                location: wp.location,
                name: wp.name,
            }));
            const finalData = {
                code: 'Ok',
                routes: [adaptedRoute],
                waypoints: adaptedWaypoints
            };
            return { routeData: finalData, serviceUsed: 'Mapbox' }; // Devuelve el servicio usado
        }
    };

    const buildUrlWithCorrectBearings = (service, coords) => {
        let baseUrl = service.buildUrl(coords).split('?')[0];
        let params = new URLSearchParams(service.buildUrl(coords).split('?')[1] || '');

        if (startHeading !== null && !isNaN(startHeading)) {
            const waypointCount = (coords.match(/;/g) || []).length + 1;
            let bearingsString = `${Math.round(startHeading)},45`;
            if (waypointCount > 1) {
                bearingsString += ';'.repeat(waypointCount - 1);
            }
            params.set('bearings', bearingsString);
        } else {
            params.delete('bearings'); 
        }
        
        return `${baseUrl}?${params.toString()}`;
    };

    const primaryService = useMapboxAsPrimary ? mapboxService : osrmService;
    const fallbackService = useMapboxAsPrimary ? osrmService : mapboxService;

    try {
        const primaryUrl = buildUrlWithCorrectBearings(primaryService, coordsString);
        const primaryResponse = await fetch(primaryUrl);
        return await primaryService.processResponse(primaryResponse);
    } catch (primaryError) {
        showToast(`Servicio principal (${primaryService.name}) falló. Intentando con respaldo (${fallbackService.name})...`, "warning", 4000);
        
        try {
            const fallbackUrl = buildUrlWithCorrectBearings(fallbackService, coordsString);
            const fallbackResponse = await fetch(fallbackUrl);
            const fallbackData = await fallbackService.processResponse(fallbackResponse);
            fallbackData.serviceUsed += ' (Respaldo)';
            return fallbackData;
        } catch (fallbackError) {
            return { error: fallbackError, failedServices: `${primaryService.name} (Fallo), ${fallbackService.name} (Fallo)` };
        }
    }
}  



    
// ===================================================================
// NOMBRE: handleSimulateGpsPositionClick (MODIFICADA - PARA MAPBOX)
// RESUMEN: Maneja el clic en el mapa durante la simulación GPS manual.
function handleSimulateGpsPositionClick(e, forceExactPosition = false) {
    if (!isSimulatingGpsLocation || !navigationMapInstance) return;

    navigationFollowUser = true;
    shouldCenterOnUser = true;
    clearLocateMeReactivationTimer(); updateLocateMeButtonsUI(); 

    
    if (automatedSimulationIntervalId) {
        wasSimulatingBeforeRecalc = true;
        stopAutomatedRouteSimulationInternal();
        showToast("Simulación automática pausada. Forzando desvío...", "info");
    }
    let lngLatToUse = [e.lngLat.lng, e.lngLat.lat]; 
    
    if (!forceExactPosition && navigationMapInstance.getSource('route') && typeof turf !== 'undefined' && navigationMapInstance.getSource('route')._data) {
        const routeGeoJSON = navigationMapInstance.getSource('route')._data;
        if (routeGeoJSON && routeGeoJSON.type === 'Feature' && routeGeoJSON.geometry && routeGeoJSON.geometry.coordinates) {
            const routeLineString = turf.lineString(routeGeoJSON.geometry.coordinates);
            const clickPoint = turf.point(lngLatToUse);
            const nearestPointOnRoute = turf.nearestPointOnLine(routeLineString, clickPoint, { units: 'meters' });
            
            if (nearestPointOnRoute && nearestPointOnRoute.properties.dist !== undefined && nearestPointOnRoute.properties.dist < 50) { 
                lngLatToUse = nearestPointOnRoute.geometry.coordinates;
            }
        }
    }

    simulatedGpsLocation = {
        latitude: lngLatToUse[1],
        longitude: lngLatToUse[0],
        accuracy: 10,
        heading: navigationCurrentLocation ? navigationCurrentLocation.heading : 0,
        altitude: navigationCurrentLocation ? navigationCurrentLocation.altitude : 0,
        speed: 0
    };
    processSimulatedGpsPosition(true); 
    setNavigationMapClickHandler(); 
}        

// ===================================================================
// NOMBRE: setNavigationMapClickHandler (VERSIÓN SIMPLIFICADA)
// RESUMEN: Únicamente gestiona el estado visual del mapa (clases y cursor) según el modo actual.
// ===================================================================
function setNavigationMapClickHandler() {
    const mapDiv = document.getElementById('reminders-location-map-div');
    if (!navigationMapInstance || !mapDiv) return;

    // Limpia todos los estados visuales
    mapDiv.classList.remove('add-reminder-mode', 'simulating-gps-click-mode', 'navigating');
    const canvas = navigationMapInstance.getCanvas();
    if(canvas) canvas.style.cursor = ''; // Restaura cursor por defecto

    // Aplica el estado visual correcto según el modo
    if (isAddReminderAtLocationModeActive) {
        mapDiv.classList.add('add-reminder-mode');
        // El cursor se gestiona con CSS a través de la clase .add-reminder-mode
    } else if (isSimulatingGpsLocation) {
        mapDiv.classList.add('simulating-gps-click-mode');
        // El cursor se gestiona con CSS a través de la clase .simulating-gps-click-mode
    } else if (isNavigating) {
        mapDiv.classList.add('navigating');
        if(canvas) canvas.style.cursor = 'default';
    } else {
        // Modo de planificación por defecto
        if(canvas) canvas.style.cursor = 'crosshair';
    }
} 
// ===================================================================
// NOMBRE: showSimulationSpeedModal (MODIFICADA - AÑADIDO TEXTO DE AYUDA PARA DESVÍOS)
// RESUMEN: Muestra un modal para que el usuario introduzca la velocidad de simulación y elija el modo, incluyendo ahora una nota sobre cómo simular desvíos.
function showSimulationSpeedModal(defaultSpeed, callback) {
    closeOtherModals('simulation-speed-modal');
    let modal = document.getElementById('simulation-speed-modal');
    if (modal) modal.remove();
    modal = document.createElement('div');
    modal.id = 'simulation-speed-modal';
    modal.innerHTML = `
        <h2>Velocidad y Modo de Simulación</h2>
        <div class="filter-group" style="margin-bottom: 20px;">
            <label id="speed-range-label">Velocidad: ${defaultSpeed} km/h</label>
            <div class="slider-container single-slider-container" style="height: 25px;">
                <div class="slider-track"></div>
                <div class="slider-range" id="speed-slider-range"></div>
                <div class="slider-thumb" id="speed-thumb" style="left: 0%;"></div>
            </div>
        </div>
        <div class="modal-top-buttons" style="flex-direction: column; gap: 10px;">
            <button id="confirm-navigation-simulation" style="background-color: #28a745; color: white;">Simular Navegación Normal <span class="button-countdown-timer"></span></button>
            <button id="confirm-freedrive-simulation" style="background-color: #34D399; color: #111827; font-weight: bold;">Recorrer en Modo Free Drive</button>
            <button id="cancel-simulation-speed" style="background-color: #6c757d; color: white;">Cancelar</button>
        </div>
        <!-- AÑADIDO: Párrafo de ayuda para simular desvíos -->
        <p style="font-size: 0.85rem; color: #444; margin-top: 1.5rem; text-align: left; font-style: italic; border-top: 1px solid #ccc; padding-top: 10px;">
            (*) Para simular DESVIOS, carga una ruta, luego pulsa simulación y cuando quieras pincha en el mapa para probar un desvio desde ese punto</p>
    `;
    document.body.appendChild(modal);

    const speedSliderContainer = modal.querySelector('#speed-thumb').parentElement;
    const speedThumb = modal.querySelector('#speed-thumb');
    const speedRange = modal.querySelector('#speed-slider-range');
    const speedLabel = modal.querySelector('#speed-range-label');
    const minSpeed = 1;
    const maxSpeed = 5000;
    let currentSpeed = defaultSpeed || 90;

    const updateSpeedVisuals = () => {
        const minLog = Math.log(minSpeed);
        const maxLog = Math.log(maxSpeed);
        const percent = (Math.log(currentSpeed) - minLog) / (maxLog - minLog);
        
        speedThumb.style.left = `${percent * 100}%`;
        speedRange.style.width = `${percent * 100}%`;
        speedLabel.textContent = `Velocidad: ${Math.round(currentSpeed)} km/h`;
    };

    const onSpeedDrag = (e) => {
        const rect = speedSliderContainer.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        let percent = (clientX - rect.left) / rect.width;
        percent = Math.max(0, Math.min(1, percent));
        
        const minLog = Math.log(minSpeed);
        const maxLog = Math.log(maxSpeed);
        currentSpeed = Math.exp(minLog + percent * (maxLog - minLog));
        
        updateSpeedVisuals();
    };

    const startSpeedDrag = (e) => {
        const moveHandler = (moveEvent) => onSpeedDrag(moveEvent);
        const endDrag = () => {
            document.removeEventListener('mousemove', moveHandler);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchmove', moveHandler);
            document.removeEventListener('touchend', endDrag);
        };
        document.addEventListener('mousemove', moveHandler);
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchmove', moveHandler);
        document.addEventListener('touchend', endDrag);
    };
    
    speedThumb.addEventListener('mousedown', startSpeedDrag);
    speedThumb.addEventListener('touchstart', startSpeedDrag);
    updateSpeedVisuals();
    
    const confirmNavBtn = modal.querySelector('#confirm-navigation-simulation');
    const confirmFreeDriveBtn = modal.querySelector('#confirm-freedrive-simulation');
    const cancelBtn = modal.querySelector('#cancel-simulation-speed');
    
    const closeHandler = () => {
        clearModalAutoCloseTimer(modal, confirmNavBtn, 'simulation-speed-modal');
        if (modal.parentNode) modal.remove();
    };

    confirmNavBtn.addEventListener('click', () => {
        isSimulatingFreeDrive = false; 
        callback(Math.round(currentSpeed));
        closeHandler();
    });

    confirmFreeDriveBtn.addEventListener('click', () => {
        isSimulatingFreeDrive = true; 
        callback(Math.round(currentSpeed));
        closeHandler();
    });

    cancelBtn.addEventListener('click', () => {
        showToast("Inicio de simulación cancelado", "info");
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) simulateGpsButton.classList.remove('active-simulate-gps-mode');
        isSimulatingGpsLocation = false;
        reactivateRealGpsAfterSimulation();
        setNavigationMapClickHandler();
        closeHandler();
    });

    addModalAutoCloseTimer(modal, confirmNavBtn, 'simulation-speed-modal', 30000);
}    

// ===================================================================
// NOMBRE: showHelpModal
// RESUMEN: Muestra el modal de ayuda con ejemplos de uso para crear recordatorios.
function showHelpModal(options = {}) {
    const modal = document.createElement('div');
    modal.className = 'help-modal reminder-modal'; 
    modal.setAttribute('aria-label', 'Ayuda recordatorios');
    
    modal.innerHTML = `
        <div class="reminder-modal-header">
            <h2 class="reminder-modal-title">Ayuda de Recordatorios</h2>
        </div>
        <div class="reminder-modal-body">
            <p class="mb-4">Ejemplos de comandos de voz o texto:</p>
            <ul class="list-disc pl-6 mb-4 space-y-2">
                <li><strong>Texto:</strong> "Recordar cita", "Llamar mamá"</li>
                <li><strong>Hora:</strong> "A LAS DIEZ Y CUARTO" → 10:15, "A LAS CINCO Y MEDIA TARDE" → 17:30</li>
                <li><strong>Fecha:</strong> "HOY", "MAÑANA", "DENTRO DE 15 DÍAS", "EL DÍA 22", "PRÓXIMO LUNES", "25/05/2025"</li>
                <li><strong>Repetición:</strong> "CADA LUNES", "TODOS LOS VIERNES Y SÁBADOS"</li>
                <li><strong>Intervalo:</strong> "CADA 7 DÍAS"</li>
                <li><strong>Alarma:</strong> "ALARMA EN 30 MINUTOS", "RECORDAR EN 2 HORAS".</li>
                <li><strong>Excluir/Radar:</strong> Añadir "NO LISTAR", "EXCLUIR LISTA" o "RADAR" para ocultarlo de la lista general y que aparezca con chincheta morada en el mapa.</li>
            </ul>
            <p class="mb-4">Nota: Combina hora, fecha, días, etc. Las palabras Alarma, Aviso, Recordar, Timer... crean alarmas de tiempo exacto.</p>
            
            <h3 class="font-bold text-lg mt-6 mb-2 text-[#007aff]">Recordatorios por Ubicación</h3>
            <ul class="list-disc pl-6 mb-4 space-y-2">
                <li><strong>Activar:</strong> Marca la casilla "RECORDATORIO POR UBICACIÓN" o usa frases como "EN EL LUGAR", "EN EL SITIO".</li>
                <li><strong>Fijar Punto:</strong> Pulsa "VER/EDITAR POSICIÓN EN MAPA" para ampliarlo y haz clic donde quieras fijar el punto. Usa "ESTÁS AQUÍ" para centrar en tu posición.</li>
                <li><strong>Radio:</strong> Ajusta el radio con el slider o con frases como "RADIO DE 200 METROS".</li>
                <li><strong>Guardar/Usar Ubicaciones:</strong> Usa el botón "Ubicaciones" para guardar y seleccionar tus lugares frecuentes.</li>
                <li><strong>Navegación:</strong> Para planificar rutas, usa el icono <img src="RADAR.PNG" alt="Radar Icon" style="width:1em; height:1em; vertical-align:middle; display:inline;"> en la barra superior. Consulta su ayuda específica <img src="./PNG/IMG_4326.PNG" alt="Ayuda" style="height:1.2em; display:inline; vertical-align:middle;">.</li>
            </ul>
        </div>
        <div class="reminder-modal-footer">
            <button type="button" id="close-help" class="action-button primary" style="grid-column: 1 / -1;">Entendido</button>
        </div>
    `;
    const parent = options.parentContainer || document.body;
    parent.appendChild(modal);
    const closeHelpButton = modal.querySelector('#close-help');
    const closeHandler = () => { clearModalAutoCloseTimer(modal, closeHelpButton, 'help-modal'); if (modal.parentNode) modal.parentNode.removeChild(modal); };
    closeHelpButton.addEventListener('click', closeHandler); 
    addModalAutoCloseTimer(modal, closeHelpButton, 'help-modal');
}

    // ===================================================================
    // NOMBRE: stopAutomatedRouteSimulation
    // RESUMEN: Detiene completamente el modo de simulación y vuelve al GPS real.
    function stopAutomatedRouteSimulation() {
        stopAutomatedRouteSimulationInternal();
        isSimulatingGpsLocation = false;
        const mapDiv = document.getElementById('reminders-location-map-div');
        if (mapDiv) {
            mapDiv.classList.remove('simulating-gps-click-mode');
        }
        const simulateGpsButton = document.getElementById('toggle-simulate-gps-button');
        if (simulateGpsButton) {
            simulateGpsButton.classList.remove('active-simulate-gps-mode');
            simulateGpsButton.title = "Activar Simulación GPS (recorrido automático o clic manual)";
        }
        startGpsWatching();
        setNavigationMapClickHandler();
    }
    
    
    // ===================================================================
    // NOMBRE: toggleAddReminderAtLocationMode
    // RESUMEN: Activa/desactiva el modo para añadir un recordatorio haciendo clic en el mapa.
    function toggleAddReminderAtLocationMode() {
        isAddReminderAtLocationModeActive = !isAddReminderAtLocationModeActive;
        const mapDiv = document.getElementById('reminders-location-map-div');
        const button = document.getElementById('add-reminder-at-location-button');
        if (button) {
            if (isAddReminderAtLocationModeActive) {
                button.classList.add('active-reminder-mode');
                if (mapDiv) mapDiv.classList.add('add-reminder-mode');
                showToast("Modo 'Añadir Recordatorio en Mapa' ACTIVADO. Pulsa en el mapa para crear un recordatorio.", "info", 5000);
            } else {
                button.classList.remove('active-reminder-mode');
                if (mapDiv) mapDiv.classList.remove('add-reminder-mode');
                showToast("Modo 'Añadir Recordatorio en Mapa' DESACTIVADO.", "info");
            }
        }
        setNavigationMapClickHandler();
    }
    

// ===================================================================
// NOMBRE: handlePdrSearchButtonClick
// RESUMEN: Gestiona el ciclo de búsqueda de PDRs (Buscar > Filtrar > Limpiar).
function handlePdrSearchButtonClick() {
    const pdrButton = document.getElementById('pdrs-ruta-button');

    switch (pdrSearchState) {
        case 'initial': 
            if (pdrButton) pdrButton.classList.remove('pdr-search-highlight');
            showPDRsFilterModal();
            break;
            
        case 'results_shown': 
            if (lastPdrSearchResults.length > 0) {
                if (pdrButton) pdrButton.classList.add('pdr-search-highlight');
                filterForCheapestPDRs();
                pdrSearchState = 'cheapest_shown';
            } else {
                showToast("No hay PDRs en el mapa para filtrar. Realice una nueva búsqueda.", "info");
                pdrSearchState = 'initial'; 
                showPDRsFilterModal();
            }
            break;

        case 'cheapest_shown': 
            if (pdrButton) pdrButton.classList.remove('pdr-search-highlight');
            clearChargingPoints();
            showToast("Puntos de recarga eliminados del mapa.", "info");
            pdrSearchState = 'initial'; 
            break;
    }
}

// ===================================================================
// NOMBRE: filterForCheapestPDRs (VERSIÓN CON FILTRADO CORRECTO)
// RESUMEN: Filtra para mostrar solo los PDRs más baratos y actualiza la lista principal de resultados.
function filterForCheapestPDRs() {
    if (lastPdrSearchResults.length === 0) {
        showToast("No hay resultados previos para filtrar. Realiza una nueva búsqueda.", "info");
        pdrSearchState = 'initial';
        return;
    }
    showToast("Mostrando solo los PDRs más económicos por rango de potencia...", "info");

    const cheapestBySegment = {
        '#0f130c': { price: Infinity, point: null }, 
        '#007863': { price: Infinity, point: null }, 
        'rgb(30, 144, 255)': { price: Infinity, point: null }, 
        '#de2e03': { price: Infinity, point: null },
        '#5e5e5e': { price: Infinity, point: null } // Añadir color para potencia desconocida
    };

    const parsePrice = (priceString) => {
        if (priceString && typeof priceString === 'string') {
            const priceMatch = priceString.match(/(\d[\d,.]*)/);
            if (priceMatch && priceMatch[1]) {
                const priceNum = parseFloat(priceMatch[1].replace(',', '.'));
                if (!isNaN(priceNum) && priceNum >= 0 && priceNum < 10) { // Permitir precio 0
                    return priceNum;
                }
            }
        }
        return Infinity;
    };

    lastPdrSearchResults.forEach(point => {
        const power = parseFloat(point.power);
        const segmentColor = getChargingPointColorByPower(power);
        const price = parsePrice(point.price);
        
        if (cheapestBySegment[segmentColor] && price < cheapestBySegment[segmentColor].price) {
            cheapestBySegment[segmentColor].price = price;
            cheapestBySegment[segmentColor].point = point;
        }
    });
    
    const cheapestPoints = Object.values(cheapestBySegment)
        .map(item => item.point)
        .filter(p => p !== null);
     cheapestPoints.forEach(p => { p.isCheapest = true; });
    lastPdrSearchResults = cheapestPoints;
    displayChargingPointsOnMap();
}

// ===================================================================
// NOMBRE: addChargingPointToRoute (VERSIÓN CORREGIDA)
// RESUMEN: Añade un PDR como etapa. Si no hay ruta, crea una nueva. Si se navega, preserva estadísticas.
async function addChargingPointToRoute(pointIndex) {
    const point = currentChargingPointsOnRoute[pointIndex];
    if (!point) return;

    const noRouteLoaded = navigationWaypoints.length === 0;

    if (noRouteLoaded) {
        if (!navigationCurrentLocation) {
            showToast("No se puede añadir el punto de carga sin una ubicación GPS inicial.", "error");
            return;
        }

        const startPoint = {
            id: Date.now() - 1,
            lat: navigationCurrentLocation.latitude,
            lng: navigationCurrentLocation.longitude,
            type: 'S',
            marker: null,
            label: 'S',
            address: 'Posición Actual (GPS)',
            visited: true,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false
        };

        const newWaypoint = {
            id: Date.now(),
            lat: point.lat,
            lng: point.lon,
            type: '',
            marker: null,
            label: '',
            address: point.address || 'Punto de Recarga',
            visited: false,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false
        };

        navigationWaypoints.push(startPoint, newWaypoint);
        showToast("Ruta creada desde tu posición hasta el punto de recarga.", "success");

    } else {
        let lastVisitedIndex = -1;
        navigationWaypoints.forEach((wp, index) => {
            if (wp.visited) {
                lastVisitedIndex = index;
            }
        });
        const insertIndex = lastVisitedIndex + 1;
        
        const newWaypoint = {
            id: Date.now(),
            lat: point.lat,
            lng: point.lon,
            type: '', 
            marker: null,
            label: '',
            address: point.address || 'Punto de Recarga',
            visited: false,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false
        };

        navigationWaypoints.splice(insertIndex, 0, newWaypoint);
        showToast(`'${newWaypoint.address}' añadido como etapa. Recalculando...`, "success");
    }
    
    updateWaypointTypesAndLabels();
    renderWaypointMarkers();

    try {
        await recalculateAndDrawRoute(true);
        
        clearChargingPoints();

        const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
            toggleRadaresRuta(true);
        }
    } catch (e) {
        showToast("Error recalculando la ruta tras añadir el punto de recarga.", "error");
    }

    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}

    // ===================================================================
    // NOMBRE: calculateDistanceToEndOfStep
    // RESUMEN: Calcula la distancia acumulada hasta el final de un paso específico de la ruta.
    function calculateDistanceToEndOfStep(route, targetLegIndex, targetStepIndex) {
        let totalDistance = 0;
        if (!route || !route.legs) return 0;
        for (let legIdx = 0; legIdx <= targetLegIndex; legIdx++) {
            const leg = route.legs[legIdx];
            if (!leg || !leg.steps) continue;
            const limitStepIndex = (legIdx === targetLegIndex) ? targetStepIndex : leg.steps.length - 1;
            for (let stepIdx = 0; stepIdx <= limitStepIndex; stepIdx++) {
                const step = leg.steps[stepIdx];
                if (step && typeof step.distance === 'number') {
                    totalDistance += step.distance;
                }
            }
        }
        return totalDistance;
    }

// ===================================================================
// NOMBRE: plotRemindersOnNavigationMap (NUEVA VERSIÓN GEOJSON)
// RESUMEN: Carga todos los recordatorios a una única fuente GeoJSON para un renderizado eficiente.
function plotRemindersOnNavigationMap() {
    if (!navigationMapInstance || !navigationMapInstance.isStyleLoaded()) return;

    // --- LIMPIEZA TOTAL PREVIA ---
    // 1. Eliminar todos los marcadores HTML de recordatorios existentes.
    // Esto es crucial y garantiza que los iconos borrados desaparezcan.
    reminderMapObjects.forEach(obj => {
        if (obj.marker) {
            try {
                obj.marker.remove();
            } catch (e) { /* Ignorar si ya fue removido */ }
        }
    });
    reminderMapObjects = []; // Reseteamos el array de control

    // 2. Eliminar capas y fuentes GeoJSON de recordatorios anteriores.
    // Esto previene la acumulación de datos fantasma en el mapa.
    const layersAndSourcesToRemove = ['reminders-icons-layer', 'reminders-geojson-source'];
    layersAndSourcesToRemove.forEach(id => {
        try {
            if (navigationMapInstance.getLayer(id)) navigationMapInstance.removeLayer(id);
            if (navigationMapInstance.getSource(id)) navigationMapInstance.removeSource(id);
        } catch (e) {
            // Silenciar errores si la capa/fuente no existe, es normal en la primera ejecución.
        }
    });

    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    const remindersWithLocation = reminders.filter(r => r.isLocationEnabled && r.locationCoordinates?.latitude && r.locationCoordinates?.longitude && !r.isFromRuta);

    // Separamos los radares de los recordatorios normales
    const radarReminders = remindersWithLocation.filter(r => r.text.toUpperCase().includes("RADAR") || r.excludeFromList);
    const normalReminders = remindersWithLocation.filter(r => !(r.text.toUpperCase().includes("RADAR") || r.excludeFromList));

    // --- DIBUJADO DE RECORDATORIOS NORMALES (CON ICONOS GEOJSON) ---
    const normalReminderFeatures = normalReminders.map(reminder => ({
        type: 'Feature',
        geometry: {
            type: 'Point',
            coordinates: [reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude]
        },
        properties: {
            reminderId: reminder.id
        }
    }));

    navigationMapInstance.addSource('reminders-geojson-source', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: normalReminderFeatures }
    });

    navigationMapInstance.addLayer({
        id: 'reminders-icons-layer',
        type: 'symbol',
        source: 'reminders-geojson-source',
        layout: {
            'icon-image': 'reminder-icon',
            'icon-size': ['interpolate', ['linear'], ['zoom'], 10, 0.4, 14, 0.6, 17, 0.8],
            'icon-allow-overlap': true,
            'icon-anchor': 'bottom'
        }
    });

    // Hacemos los iconos de recordatorios normales "clicables"
    navigationMapInstance.on('click', 'reminders-icons-layer', (e) => {
        if (e.features && e.features.length > 0) {
            const reminderId = e.features[0].properties.reminderId;
            showReminderActionModal(reminderId);
        }
    });
    navigationMapInstance.on('mouseenter', 'reminders-icons-layer', () => { navigationMapInstance.getCanvas().style.cursor = 'pointer'; });
    navigationMapInstance.on('mouseleave', 'reminders-icons-layer', () => { navigationMapInstance.getCanvas().style.cursor = ''; });

    // --- DIBUJADO DE RADARES (CON MARCADORES HTML) ---
    // Usamos marcadores HTML para los radares porque sus iconos son más complejos (con texto).
    radarReminders.forEach(reminder => {
        const speedLimit = extractSpeedFromRadarText(reminder.text);
        const isFromPersonalTask = reminder.isFromTarea === true;
        const markerElement = createRadarSpeedIcon(speedLimit, navigationMapInstance.getZoom(), isFromPersonalTask);
        
        const marker = new mapboxgl.Marker({ element: markerElement, anchor: 'center' })
            .setLngLat([reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude])
            .addTo(navigationMapInstance);
        
        marker.getElement().addEventListener('click', (e) => {
            e.stopPropagation();
            showReminderActionModal(reminder.id);
        });

        // Guardamos la referencia para poder limpiarla después
        reminderMapObjects.push({
            reminderId: reminder.id,
            marker: marker
        });
    });
}
    
// ===================================================================
// NOMBRE: updateLocateMeButtonsUI (NUEVA FUNCIÓN)
// RESUMEN: Sincroniza la apariencia (icono y título) de ambos botones de localización.
function updateLocateMeButtonsUI() {
    const topButton = document.getElementById('locate-me-on-reminders-map');
    const bottomButton = document.getElementById('zoom-locate-me-button');
    const buttons = [topButton, bottomButton].filter(Boolean);

    buttons.forEach(button => {
        const img = button.querySelector('img');
        if (!img) return;

        if (navigationFollowUser) {
            img.src = "PNG/DEJARSEGUIR.PNG";
            button.title = "Dejar de centrar el mapa en mi posición";
            const countdownOverlay = bottomButton?.querySelector('.countdown-overlay');
            if (countdownOverlay) {
                countdownOverlay.remove();
            }
        } else {
            img.src = "PNG/ESTASAQUI.PNG";
            button.title = "Mostrar mi posición actual y activar seguimiento";
        }
    });
}

// ===================================================================
// NOMBRE: clearLocateMeReactivationTimer (NUEVA FUNCIÓN)
// RESUMEN: Limpia los temporizadores de reactivación y el contador visual.
function clearLocateMeReactivationTimer() {
    if (window.followMeReactivationTimer) {
        clearTimeout(window.followMeReactivationTimer);
        window.followMeReactivationTimer = null;
    }
    if (manualZoomTimeout) {
        clearTimeout(manualZoomTimeout);
        manualZoomTimeout = null;
    }
    if (locateMeCountdownInterval) {
        clearInterval(locateMeCountdownInterval);
        locateMeCountdownInterval = null;
    }
    const bottomButton = document.getElementById('zoom-locate-me-button');
    const countdownOverlay = bottomButton?.querySelector('.countdown-overlay');
    if (countdownOverlay) {
        countdownOverlay.remove();
    }
}

// ===================================================================
// NOMBRE: startLocateMeReactivationTimer (NUEVA FUNCIÓN)
// RESUMEN: Inicia el temporizador de 30s y el contador visual para reactivar el seguimiento.
function startLocateMeReactivationTimer() {
    clearLocateMeReactivationTimer();

    window.followMeReactivationTimer = setTimeout(() => {
        const mapModal = document.getElementById('reminders-location-map-modal');
        if (!navigationFollowUser && mapModal && !mapModal.classList.contains('map-modal-hidden')) {
            handleLocateMeClick();
            showToast("Seguimiento automático reactivado.", "info");
        }
        clearLocateMeReactivationTimer();
    }, 30000);
    
    manualZoomTimeout = window.followMeReactivationTimer;

    let countdown = 30;
    const bottomButton = document.getElementById('zoom-locate-me-button');
    if (!bottomButton) return;

    let countdownOverlay = bottomButton.querySelector('.countdown-overlay');
    if (!countdownOverlay) {
        countdownOverlay = document.createElement('div');
        countdownOverlay.className = 'countdown-overlay';
        bottomButton.appendChild(countdownOverlay);
    }
    countdownOverlay.textContent = countdown;

    locateMeCountdownInterval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
            countdownOverlay.textContent = countdown;
        } else {
            clearLocateMeReactivationTimer();
        }
    }, 1000);
}
// ===================================================================
// NOMBRE: triggerManualMapInteraction (VERSIÓN FINAL CON LÓGICA DE MODOS)
// RESUMEN: Desactiva temporalmente el seguimiento. Si el modo es 'RUTA', lo cambia a 'OFF'.
//          Si el modo es 'AUTO', solo lo anula temporalmente sin cambiar el estado.
function triggerManualMapInteraction() {
    isManualZoomActive = true;
    navigationFollowUser = false;
    shouldCenterOnUser = false;

    clearLocateMeReactivationTimer();

    const currentAutoZoomMode = localStorage.getItem(AUTO_ZOOM_MODE_KEY) || 'off';
    const autoBtn = document.getElementById('zoom-auto-button');

    if (currentAutoZoomMode === 'route') {
        localStorage.setItem(AUTO_ZOOM_MODE_KEY, 'off');
        showToast("Modo 'Ruta' desactivado por interacción manual.", "info");

        if (autoBtn) {
            autoBtn.textContent = 'AUTO';
            autoBtn.classList.remove('active', 'route-mode');
            autoBtn.title = 'Zoom automático (Desactivado)';
        }
    }
  
    startLocateMeReactivationTimer();
    updateLocateMeButtonsUI();
}

// ===================================================================
// NOMBRE: handleManualMapInteraction (VERSIÓN CON DETECCIÓN DE INTENCIÓN)
// RESUMEN: Desactiva el seguimiento SOLO cuando detecta un gesto de arrastre o
function handleManualMapInteraction() {
    if (!navigationFollowUser) {
        startLocateMeReactivationTimer();
        return;
    }

    isManualZoomActive = true;
    navigationFollowUser = false;
    shouldCenterOnUser = false;
    mapPreviousZoomLevel = navigationMapInstance.getZoom();
    
    updateLocateMeButtonsUI();
    startLocateMeReactivationTimer();
}
    
 // ===================================================================
// NOMBRE: assignMapButtonListeners (VERSIÓN FINAL CON REASIGNACIÓN SEGURA)
// RESUMEN: Asigna listeners a los botones del modal. Clona y reemplaza elementos clave como el input de búsqueda para eliminar listeners antiguos y añadir los nuevos, garantizando la interactividad al reabrir el mapa.
function assignMapButtonListeners() {
    const header = document.getElementById('reminders-location-map-header');
    const togglePanelButton = document.getElementById('toggle-map-header-buttons-panel');
    const mapLocationSearchInput = document.getElementById('map-location-search-input');
    const mapFilterInput = document.getElementById('filter-input');
    
    if (!header || !togglePanelButton || !mapLocationSearchInput || !mapFilterInput) return;

    const reassignElement = (element) => {
        const newElement = element.cloneNode(true);
        element.parentNode.replaceChild(newElement, element);
        return newElement;
    };
    
    const newTogglePanelButton = reassignElement(togglePanelButton);
    let swipeStartX = 0, swipeStartY = 0, isSwiping = false, pressTimer = null;
    const handleGestureStart = (e) => { isSwiping = false; swipeStartX = e.touches ? e.touches[0].clientX : e.clientX; swipeStartY = e.touches ? e.touches[0].clientY : e.clientY; clearTimeout(pressTimer); pressTimer = setTimeout(() => { openAlertModal(); swipeStartX = 0; swipeStartY = 0; }, 800); if(e.type === 'touchstart') e.preventDefault(); };
    const handleGestureMove = (e) => { if (swipeStartX === 0) return; const moveX = e.touches ? e.touches[0].clientX : e.clientX; const moveY = e.touches ? e.touches[0].clientY : e.clientY; if (Math.abs(moveX - swipeStartX) > 10 || Math.abs(moveY - swipeStartY) > 10) { isSwiping = true; clearTimeout(pressTimer); } };
    const handleGestureEnd = (e) => { clearTimeout(pressTimer); if (swipeStartX === 0) return; const endX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX; const endY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY; const deltaX = endX - swipeStartX; const deltaY = endY - swipeStartY; const swipeThreshold = 50; if (!isSwiping) { toggleMapHeaderRowsVisibility(!mapHeaderButtonsVisible); } else { if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > swipeThreshold) { if (deltaY < 0) { toggleNavigationState(); } else { loadRouteByName("TRABAJO", true); } } else if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > swipeThreshold) { if (deltaX < 0) { toggleMapImmersiveMode(); } else { loadRouteByName("CASA", true); } } } swipeStartX = 0; swipeStartY = 0; isSwiping = false; };
    newTogglePanelButton.addEventListener('mousedown', handleGestureStart);
    newTogglePanelButton.addEventListener('mousemove', handleGestureMove);
    newTogglePanelButton.addEventListener('mouseup', handleGestureEnd);
    newTogglePanelButton.addEventListener('mouseleave', handleGestureEnd);
    newTogglePanelButton.addEventListener('touchstart', handleGestureStart, { passive: false });
    newTogglePanelButton.addEventListener('touchmove', handleGestureMove, { passive: false });
    newTogglePanelButton.addEventListener('touchend', handleGestureEnd);
    
    if (!header._delegateAttached) {
        header.addEventListener('click', (event) => {
            const button = event.target.closest('button');
            if (!button || button.disabled) return;
            event.stopPropagation();
            
            switch (button.id) {
                 case 'close-reminders-location-map': closeNavigationMap(false); break;
                 case 'locate-me-on-reminders-map': handleLocateMeClick(true); break;
                 case 'nav-map-zoomtoggle-button': handleZoomToggleButtonClick(button); break;
                 case 'start-navigation-button': toggleNavigationState(); break;
                 case 'save-route-button': saveCurrentRoute(); break;
                 case 'delete-current-route-button': handleLoadOrDeleteRouteClick(button); break;
                 case 'load-saved-route-button': showLoadRouteModal(); break;
                 case 'add-radar-here': handleAddRadarHereClick(button); break;
                 case 'accident-alert-button-map': openAlertModal(); break;
                 case 'pdrs-ruta-button': handlePdrSearchButtonClick(); break;
                 case 'add-reminder-at-location-button': toggleAddReminderAtLocationMode(); break;
                 case 'toggle-simulate-gps-button': handleGpsSimulationToggle(); break;
                 case 'simulate-route-button': showSimulationModal(); break;
                 case 'reorder-route-stages-button': showReorderStagesModal(); break;
                 case 'navigation-map-help-button': showNavigationMapHelpModal(); break;
                 case 'map-location-search-button':
                    const currentSearchInput = document.getElementById('map-location-search-input');
                    const currentFilterInput = document.getElementById('filter-input');
                    const mainTerm = currentSearchInput?.value.trim() || '';
                    if (!mainTerm) { showToast("El campo de búsqueda principal no puede estar vacío.", "warning"); return; }
                    const filterTerm = currentFilterInput?.value.trim() || '';
                    let combinedSearchTerm = mainTerm;
                    if (filterTerm) { combinedSearchTerm += ' ' + filterTerm; }
                    searchAndAddWaypoint(combinedSearchTerm);
                    break;
                 case 'clear-map-search-input-button':
                    const currentSearchInputToClear = document.getElementById('map-location-search-input');
                    if (currentSearchInputToClear) { currentSearchInputToClear.value = ''; }
                    currentSearchInputToClear?.dispatchEvent(new Event('input'));
                    currentSearchInputToClear?.focus();
                    hideAddressSuggestionsModal();
                    break;
            }
        });
        header._delegateAttached = true;
    }

    const newMapLocationSearchInput = reassignElement(mapLocationSearchInput);
    const newMapFilterInput = reassignElement(mapFilterInput);

    let searchDebounceTimer;
    const handleSearchInput = () => {
        const hasMainText = newMapLocationSearchInput.value.trim() !== '';
        const searchBtn = document.getElementById('map-location-search-button');
        const clearBtn = document.getElementById('clear-map-search-input-button');
        if(searchBtn) searchBtn.style.display = hasMainText ? 'inline-flex' : 'none';
        if(clearBtn) clearBtn.style.display = hasMainText ? 'inline-flex' : 'none';
        
        clearTimeout(searchDebounceTimer);
        const mainTerm = newMapLocationSearchInput.value.trim();
        if (mainTerm) {
            const filterTerm = newMapFilterInput.value.trim();
            let combinedSearchTerm = mainTerm;
            if (filterTerm) { combinedSearchTerm += ' ' + filterTerm; }
            searchDebounceTimer = setTimeout(() => fetchAddressSuggestions(combinedSearchTerm), 300);
        } else {
            hideAddressSuggestionsModal();
        }
        localStorage.setItem(MAP_FILTER_INPUT_KEY, newMapFilterInput.value);
    };

    newMapLocationSearchInput.addEventListener('input', handleSearchInput);
    newMapFilterInput.addEventListener('input', handleSearchInput);

    newMapLocationSearchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            const mainTerm = newMapLocationSearchInput.value.trim();
            if (!mainTerm) { showToast("El campo de búsqueda principal no puede estar vacío.", "warning"); return; }
            const filterTerm = newMapFilterInput.value.trim() || '';
            let combinedSearchTerm = mainTerm;
            if (filterTerm) { combinedSearchTerm += ' ' + filterTerm; }
            hideAddressSuggestionsModal();
            searchAndAddWaypoint(combinedSearchTerm);
        }
    });

    const radaresCheckbox = reassignElement(document.getElementById('radares-ruta-checkbox'));
    radaresCheckbox.addEventListener('change', (e) => toggleRadaresRuta(e.target.checked));
    
    const tareasCheckbox = reassignElement(document.getElementById('tareas-ruta-checkbox'));
    tareasCheckbox.addEventListener('change', (e) => toggleTareasRuta(e.target.checked));
    
    const mapboxCheckbox = reassignElement(document.getElementById('mapbox-primary-checkbox'));
    mapboxCheckbox.addEventListener('change', (e) => {
        localStorage.setItem('boardinggate_useMapboxAsPrimary', e.target.checked);
        markCacheAsDirty();
        const serviceName = e.target.checked ? 'Mapbox' : 'OSRM';
        showToast(`Servicio primario cambiado a ${serviceName}. Recalculando ruta...`, 'success');
        if (navigationWaypoints.length >= 2) { recalculateAndDrawRoute(true); }
    });
    
    newMapLocationSearchInput.value = '';
    newMapFilterInput.value = localStorage.getItem(MAP_FILTER_INPUT_KEY) || 'España';
}
// ===================================================================
// NOMBRE: getCurrentLocationAsync (NUEVA FUNCIÓN ASÍNCRONA)
// RESUMEN: Envuelve getCurrentLocation en una Promise para poder usar async/await.
function getCurrentLocationAsync() {
    return new Promise((resolve, reject) => {
        getCurrentLocation(
            (coords) => resolve(coords),
            (errorMsg) => reject(new Error(errorMsg))
        );
    });
}

    
// ===================================================================
// NOMBRE: displayChargingPointsOnMap (VERSIÓN GEOJSON CON DISPONIBILIDAD)
// RESUMEN: Carga los PDRs a una fuente GeoJSON para un renderizado nativo y eficiente.
function displayChargingPointsOnMap() {
    if (!navigationMapInstance || !navigationMapInstance.getSource('pdrs-geojson-source')) return;
    
    const geojsonFeatures = lastPdrSearchResults.map((point, index) => {
        const operatorText = point.operator.length > 15 ? point.operator.substring(0, 14) + '...' : point.operator;
        
        return {
            type: 'Feature',
            geometry: {
                type: 'Point',
                coordinates: [point.lon, point.lat]
            },
            properties: {
                ocmId: point.ocmId,
                index: index,
                bgColor: getChargingPointColorByPower(parseFloat(point.power)),
                isCheapest: point.isCheapest || false,
                power: point.power,
                operator: operatorText,
                price: point.price,
                availability: point.availabilityText
            }
        };
    });

    const geojsonData = {
        type: 'FeatureCollection',
        features: geojsonFeatures
    };
    
    navigationMapInstance.getSource('pdrs-geojson-source').setData(geojsonData);
    chargingPointsLayer = 'pdrs-geojson-source';
}

// ===================================================================
// NOMBRE: plotSingleReminderOnMap (VERSIÓN FINAL CON MODAL PERSONALIZADO)
// RESUMEN: Dibuja un recordatorio y, al hacer clic, abre un modal de acciones personalizado.
function plotSingleReminderOnMap(reminder, mapInstance) {
    if (!mapInstance || !reminder.isLocationEnabled || !reminder.locationCoordinates) return null;

    let mapObject = null;

    const plot = () => {
        const lngLat = [reminder.locationCoordinates.longitude, reminder.locationCoordinates.latitude];
        const isRadarType = reminder.text.toUpperCase().includes("RADAR") || reminder.excludeFromList;
        const currentZoomLevel = mapInstance.getZoom();

        let markerElement;
        let anchorPoint;

        if (isRadarType) {
            const speedLimit = extractSpeedFromRadarText(reminder.text);
            const isFromPersonalTask = reminder.isFromTarea === true;
            markerElement = createRadarSpeedIcon(speedLimit, currentZoomLevel, isFromPersonalTask);
            anchorPoint = 'center';
        } else {
            markerElement = document.createElement('img');
            markerElement.src = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png';
            markerElement.style.width = '25px';
            markerElement.style.height = '41px';
            markerElement.style.cursor = 'pointer';
            anchorPoint = 'bottom';
        }

        const marker = new mapboxgl.Marker({element: markerElement, anchor: anchorPoint})
            .setLngLat(lngLat)
            .addTo(mapInstance);

        // --- INICIO DE LA CORRECCIÓN ---
        // Se ha eliminado toda la lógica que creaba la fuente y la capa del círculo (circleId).
        // Ahora solo se crea el marcador.
        // --- FIN DE LA CORRECCIÓN ---
        
        marker.getElement().addEventListener('click', (e) => {
            e.stopPropagation();
            showReminderActionModal(reminder.id);
        });

        mapObject = {
            reminderId: reminder.id,
            marker: marker,
            circleId: null, // Se establece explícitamente a null
            isFromRuta: reminder.isFromRuta || false,
            isFromTarea: reminder.isFromTarea || false,
            circleRadius: reminder.radiusMeters || DEFAULT_LOCATION_RADIUS
        };
    };
    if (mapInstance.isStyleLoaded()) {
        plot();
    } else {
        mapInstance.once('style.load', plot);
    }
    return mapObject;
}    

// ===================================================================
// NOMBRE: renderWaypointMarkers (VERSIÓN FINAL CON CORRECCIÓN DE OFFSET DE ARRASTRE)
// RESUMEN: Corrige el desplazamiento visual durante el arrastre al tener en cuenta la
function renderWaypointMarkers() {
    if (!navigationMapInstance) return;

    navigationWaypoints.forEach(wp => {
        if (wp && wp.marker) {
            try { wp.marker.remove(); } catch (e) {}
            wp.marker = null;
        }
    });

    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    
    actualWaypoints.forEach(wp => {
        if (!wp || typeof wp.lat !== 'number' || typeof wp.lng !== 'number') return;
        
        const waypointIconElement = createWaypointMarkerIcon(wp.label, wp.type, wp.visited, wp.id);
        
        waypointIconElement.dataset.waypointId = wp.id;
        
        wp.marker = new mapboxgl.Marker({
            element: waypointIconElement,
            draggable: false, 
            anchor: 'center'
        }).setLngLat([wp.lng, wp.lat]).addTo(navigationMapInstance);
        
        const markerElement = wp.marker.getElement();

        let isDragging = false;
        let hasMovedEnough = false;
        let startPos = { x: 0, y: 0 };

        const onPointerDown = (e) => {
            if (isNavigating) return;
            e.stopPropagation();
            
            isDragging = false;
            hasMovedEnough = false;
            const point = e.touches ? e.touches[0] : e;
            startPos = { x: point.clientX, y: point.clientY };

            document.addEventListener('mousemove', onPointerMove);
            document.addEventListener('mouseup', onPointerUp);
            document.addEventListener('touchmove', onPointerMove, { passive: false });
            document.addEventListener('touchend', onPointerUp);
        };

        const onPointerMove = (e) => {
            if (e.type === 'touchmove') e.preventDefault();
            
            const point = e.touches ? e.touches[0] : e;
            const deltaX = Math.abs(point.clientX - startPos.x);
            const deltaY = Math.abs(point.clientY - startPos.y);

            if (!hasMovedEnough && (deltaX > 5 || deltaY > 5)) {
                hasMovedEnough = true;
                navigationMapInstance.getCanvas().style.cursor = 'grabbing';
                markerElement.style.cursor = 'grabbing';
            }

            if (hasMovedEnough) {
                isDragging = true;
                const mapContainer = document.getElementById('mapbox-map-actual-container');
                const mapRect = mapContainer.getBoundingClientRect();
                const relativeX = point.clientX - mapRect.left;
                const relativeY = point.clientY - mapRect.top;

                const coords = navigationMapInstance.unproject([relativeX, relativeY]);
                wp.marker.setLngLat(coords);
            }
        };

        const onPointerUp = async (e) => {
            document.removeEventListener('mousemove', onPointerMove);
            document.removeEventListener('mouseup', onPointerUp);
            document.removeEventListener('touchmove', onPointerMove);
            document.removeEventListener('touchend', onPointerUp);
            
            navigationMapInstance.getCanvas().style.cursor = '';
            markerElement.style.cursor = 'pointer';

            if (isDragging) {
                const point = e.changedTouches ? e.changedTouches[0] : e;
                const mapContainer = document.getElementById('mapbox-map-actual-container');
                const mapRect = mapContainer.getBoundingClientRect();
                const relativeX = point.clientX - mapRect.left;
                const relativeY = point.clientY - mapRect.top;
                const finalCoords = navigationMapInstance.unproject([relativeX, relativeY]);
                // *** FIN DE LA CORRECCIÓN DE OFFSET ***
                
                const waypointIndex = navigationWaypoints.findIndex(w => w.id === wp.id);
                if (waypointIndex !== -1) {
                    navigationWaypoints[waypointIndex].lat = finalCoords.lat;
                    navigationWaypoints[waypointIndex].lng = finalCoords.lng;
                    navigationWaypoints[waypointIndex].address = await getAddressForWaypoint(finalCoords.lat, finalCoords.lng);
                    
                    await recalculateAndDrawRoute();
                    renderWaypointMarkers();
                }
            } else {
                showWaypointActionModal(wp.id);
            }
            
            isDragging = false;
            hasMovedEnough = false;
        };

        markerElement.addEventListener('mousedown', onPointerDown);
        markerElement.addEventListener('touchstart', onPointerDown, { passive: false });
    });
}
// ===================================================================
// NOMBRE: handleProgressBarLockToggle (CORREGIDA)
// RESUMEN: Cambia el estado del candado, lo guarda y actualiza la UI,
//          marcando la caché como modificada para que persista en la nube.
// ===================================================================
function handleProgressBarLockToggle() {
    isProgressBarLocked = !isProgressBarLocked;
    saveSettings(); // <-- ESTA LÍNEA ES LA CORRECCIÓN. Llama a la función que guarda y marca los datos para sincronizar.
    updateProgressBarLockIcon();
    showToast(`Panel de progreso ${isProgressBarLocked ? 'BLOQUEADO' : 'DESBLOQUEADO'}`, 'info');
    
    const progressBar = document.getElementById('navigation-bottom-progress-bar');
    if (isProgressBarLocked) {
        progressBar.classList.remove('progress-bar-auto-hidden');
    } else {
        if (navigationCurrentRouteData && navigationCurrentRouteData.routes[0]) {
            updateTurnByTurnDisplay(navigationCurrentRouteData.routes[0], lastCarDistanceAlongRouteForNavLogic);
        }
    }
}
// ===================================================================
// NOMBRE: showNavigationMapHelpModal (VERSIÓN FINAL Y MEJORADA)
// RESUMEN: Muestra un modal de ayuda completo y detallado para el mapa de navegación.
function showNavigationMapHelpModal() {
    const existingHelpModal = document.getElementById('reminders-map-help-modal-instance');
    if (existingHelpModal) {
        clearModalAutoCloseTimer(existingHelpModal, existingHelpModal.querySelector('#close-reminders-map-help-instance'), 'reminders-map-help-modal-instance');
        existingHelpModal.remove();
    }

    const helpModal = document.createElement('div');
    helpModal.id = 'reminders-map-help-modal-instance';
    helpModal.className = 'help-modal';
    helpModal.setAttribute('aria-label', 'Ayuda Mapa de Navegación/Radares');
    
    helpModal.innerHTML = `
        <style>
            #reminders-map-help-modal-instance h3 { color: #87CEEB; margin-top: 1.2rem; margin-bottom: 0.5rem; border-bottom: 1px solid #444; padding-bottom: 4px;}
            #reminders-map-help-modal-instance ul { list-style-position: inside; padding-left: 0.5rem; }
            #reminders-map-help-modal-instance li { margin-bottom: 0.5rem; }
            #reminders-map-help-modal-instance .icon-in-text { height: 1.4em; display: inline; vertical-align: middle; margin: 0 4px; padding: 2px; border-radius: 4px; background: rgba(255,255,255,0.1);}
            #reminders-map-help-modal-instance .icon-in-text.circle { border-radius: 50%; }
            /* Estilos para los sliders (CORREGIDOS) */
            .visual-settings-container { background-color: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin-top: 10px;}
            .slider-control { display: flex; align-items: center; gap: 15px; margin-bottom: 10px; }
            .slider-control label { flex-basis: 120px; text-align: right; font-weight: bold; color: #a0a0a0; } /* Color de etiqueta mejorado */
            .slider-control input[type="range"] { flex-grow: 1; accent-color: #87CEEB; }
            .slider-control .value-display { flex-basis: 50px; font-weight: bold; color: #f0f0f0; } /* Color de valor mejorado */
            .reset-visuals-btn { background-color: #ox2bc7; color: black; padding: 4px 4px; border:none; border-radius: 5px; cursor: pointer; margin-top: 5px; }
        </style>

        <h2 class="text-xl font-bold mb-4">Ayuda del Mapa de Navegación</h2>
        <div class="modal-top-buttons" style="justify-content: flex-end;">
            <button type="button" id="close-reminders-map-help-instance" style="flex: 0 1 auto; min-width: 120px;">Entendido</button>
        </div>
        <div style="max-height: 70vh; overflow-y: auto; padding-right: 15px;">
            
            <h3><img src="https://boardinggate.github.io/Tesla/PNG/personal.png" class="icon-in-text"> Ajustes Visuales del Mapa</h3>
            <div class="visual-settings-container">
                <div class="slider-control">
                    <label for="map-saturation-slider">Saturación:</label>
                    <input type="range" id="map-saturation-slider" min="0.5" max="2" step="0.05">
                    <span id="map-saturation-value" class="value-display">120%</span>
                </div>
                <div class="slider-control">
                    <label for="map-contrast-slider">Contraste:</label>
                    <input type="range" id="map-contrast-slider" min="0.5" max="2" step="0.05">
                    <span id="map-contrast-value" class="value-display">110%</span>
                </div>
                <button id="map-visuals-reset-btn" class="reset-visuals-btn">Restaurar por defecto</button>
            </div>

            <h3><img src="https://boardinggate.github.io/Tesla/PNG/config.jpg" class="icon-in-text"> Controles Principales</h3>
            <ul class="list-disc space-y-2">
                <li><strong>Botón Flotante <img src="PNG/Coche_Sat.PNG" class="icon-in-text circle">:</strong> Es tu navaja suiza. Realiza diferentes acciones según el gesto:
                    <ul style="padding-left: 20px; margin-top: 5px;">
                        <li><strong>Clic Corto:</strong> Muestra u oculta la barra de botones superior.</li>
                        <li><strong>Pulsación Larga (1 seg):</strong> Abre el menú para reportar <strong>Alertas de Tráfico</strong>.</li>
                        <li><strong>Deslizar ARRIBA:</strong> Inicia <img src="PNG/INICIARNAVEGACION.PNG" class="icon-in-text"> o detiene <img src="PNG/TERMINARNAVEGACION.PNG" class="icon-in-text"> la navegación.</li>
                        <li><strong>Deslizar a la IZQUIERDA:</strong> Activa/desactiva el modo inmersivo (pantalla completa).</li>
                        <li><strong>Deslizar a la DERECHA / ABAJO:</strong> Carga y navega automáticamente a tus rutas guardadas "CASA" o "TRABAJO".</li>
                    </ul>
                </li>
                <li><strong>Salir del Mapa <img src="PNG/SALIR.PNG" class="icon-in-text">:</strong> Cierra la vista de navegación y vuelve al lanzador principal.</li>
                <li><strong>Localización <img src="PNG/ESTASAQUI.PNG" class="icon-in-text">:</strong> Centra el mapa en tu posición actual. Si lo pulsas de nuevo (<img src="PNG/DEJARSEGUIR.PNG" class="icon-in-text">), desactivas el seguimiento automático.</li>
                <li><strong>Zoom <img src="PNG/ZOOM+.PNG" class="icon-in-text"> / <img src="PNG/ZOOM-.PNG" class="icon-in-text">:</strong> Alterna entre una vista general de toda la ruta y un zoom cercano a tu vehículo.</li>
            </ul>

            <h3><img src="./PNG/ANADIRPUNTO.PNG" class="icon-in-text"> Planificación de Ruta</h3>
            <ul class="list-disc space-y-2">
                <li><strong>Añadir Puntos:</strong> Simplemente <strong>pulsa en cualquier lugar del mapa</strong> para añadir una etapa. También puedes usar el <strong>buscador de texto</strong> para encontrar direcciones o lugares y añadirlos con el botón <img src="./PNG/ANADIRPUNTO.PNG" class="icon-in-text">.</li>
                <li><strong>Eliminar Puntos:</strong> Pulsa la <strong>'X' roja</strong> sobre cualquier marcador de etapa.</li>
                <li><strong>Reordenar Etapas <img src="./PNG/MOVER.PNG" class="icon-in-text">:</strong> Abre un menú para arrastrar y cambiar el orden de las etapas de tu ruta.</li>
                <li><strong>Guardar y Cargar Rutas <img src="PNG/GUARDARRUTA.PNG" class="icon-in-text"> <img src="PNG/CARGARRUTA.PNG" class="icon-in-text">:</strong> Guarda la ruta actual para usarla en el futuro o carga una ya existente.</li>
            </ul>

            <h3><img src="https://boardinggate.github.io/Tesla/th.jpeg" class="icon-in-text circle"> Durante la Navegación</h3>
            <ul class="list-disc space-y-2">
                <li><strong>Rutas Alternativas:</strong>
                    <ul>
                        <li><strong>Pulsación Larga</strong> sobre un marcador de etapa (1, 2, F...) para ver al instante las rutas alternativas (Rápida, Corta, Alternativa) para ese tramo.</li>
                        <li>También puedes hacer un <strong>clic corto</strong> en el marcador, y en la tarjeta que se abre, pulsar el botón <strong>"OTRAS RUTAS"</strong>.</li>
                    </ul>
                </li>
                <li><strong>Puntos de Recarga (PDRs) <img src="PNG/pdrs.png" class="icon-in-text">:</strong>
                    <ul>
                        <li><strong>1ª Pulsación:</strong> Abre un modal para filtrar PDRs por potencia, distancia a la ruta y operadores.</li>
                        <li><strong>2ª Pulsación:</strong> Muestra en el mapa solo el PDR más económico de cada rango de potencia (resaltado con un halo amarillo).</li>
                        <li><strong>3ª Pulsación:</strong> Limpia todos los PDRs del mapa.</li>
                    </ul>
                </li>
                 <li><strong>Radares y Tareas en Ruta:</strong> Activa los checkboxes <img src="https://i.imgur.com/r33g3oY.png" class="icon-in-text"> para ver en el mapa y en la barra de progreso los radares o tus tareas personales que se encuentren en el trazado actual.</li>
                 <li><strong>Simulación <img src="./PNG/GPS.PNG" class="icon-in-text">:</strong> Activa este modo para que el coche recorra la ruta automáticamente o para fijar tu posición GPS manualmente haciendo clic en el mapa.</li>
            </ul>
        </div>
    `;

    const mapModal = document.getElementById('reminders-location-map-modal');
    if (mapModal) {
        mapModal.style.zIndex = 6400;
    }

    document.body.appendChild(helpModal); 
    
    const saturationSlider = helpModal.querySelector('#map-saturation-slider');
    const contrastSlider = helpModal.querySelector('#map-contrast-slider');
    const saturationValue = helpModal.querySelector('#map-saturation-value');
    const contrastValue = helpModal.querySelector('#map-contrast-value');
    const resetButton = helpModal.querySelector('#map-visuals-reset-btn');

    const updateLabels = () => {
        saturationValue.textContent = `${Math.round(saturationSlider.value * 100)}%`;
        contrastValue.textContent = `${Math.round(contrastSlider.value * 100)}%`;
    };

    saturationSlider.value = getComputedStyle(document.documentElement).getPropertyValue('--map-saturation').trim() || '1.2';
    contrastSlider.value = getComputedStyle(document.documentElement).getPropertyValue('--map-contrast').trim() || '1.1';
    updateLabels();
    saturationSlider.addEventListener('input', () => {
        const val = saturationSlider.value;
        document.documentElement.style.setProperty('--map-saturation', val);
        localStorage.setItem('boardinggate_map_saturation', val);
        updateLabels();
    });

    contrastSlider.addEventListener('input', () => {
        const val = contrastSlider.value;
        document.documentElement.style.setProperty('--map-contrast', val);
        localStorage.setItem('boardinggate_map_contrast', val);
        updateLabels();
    });

    resetButton.addEventListener('click', () => {
        saturationSlider.value = '1.2';
        contrastSlider.value = '1.1';
        saturationSlider.dispatchEvent(new Event('input'));
        contrastSlider.dispatchEvent(new Event('input'));
        showToast('Ajustes visuales restaurados a los valores por defecto.', 'info');
    });

    const closeButtonHelp = helpModal.querySelector('#close-reminders-map-help-instance');
    
    const closeHandlerHelp = () => { 
        clearModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance'); 
        if (helpModal.parentNode) {
            helpModal.parentNode.removeChild(helpModal); 
        }
        if (mapModal) {
            mapModal.style.zIndex = '';
        }
    };
    
    closeButtonHelp.addEventListener('click', closeHandlerHelp); 
    addModalAutoCloseTimer(helpModal, closeButtonHelp, 'reminders-map-help-modal-instance', 90000);
}
    
    // ===================================================================
    // NOMBRE: formatPhotonFeatureName
    // RESUMEN: Formatea el nombre de una ubicación obtenida del servicio Photon.
    function formatPhotonFeatureName(feature) {
        if (!feature || !feature.properties) return "Ubicación desconocida";
        const props = feature.properties;
        let nameParts = [];
        if (props.name) nameParts.push(props.name);
        if (props.street) { let streetPart = props.street; if (props.housenumber) streetPart += ` ${props.housenumber}`; nameParts.push(streetPart); }
        if (props.postcode) nameParts.push(props.postcode);
        if (props.city && (!props.name || props.name.toLowerCase() !== props.city.toLowerCase())) nameParts.push(props.city);
        else if (props.county && (!props.name || props.name.toLowerCase() !== props.county.toLowerCase())) nameParts.push(props.county);
        else if (props.state && (!props.name || props.name.toLowerCase() !== props.state.toLowerCase())) nameParts.push(props.state);
        if (props.country && nameParts.length > 0 && props.country.toLowerCase() !== nameParts[nameParts.length - 1].toLowerCase()) nameParts.push(props.country);
        else if (props.country && nameParts.length === 0) nameParts = [props.country];
        let formattedName = nameParts.filter((value, index, self) => self.map(v => v.toLowerCase()).indexOf(value.toLowerCase()) === index).join(', ');
        if (!formattedName && feature.geometry && feature.geometry.coordinates) { formattedName = `(${feature.geometry.coordinates[1].toFixed(4)}, ${feature.geometry.coordinates[0].toFixed(4)})`; }
        return formattedName || "Ubicación desconocida";
    }

// ===================================================================
// NOMBRE: addWaypoint (MODIFICADA - GESTIONA MODO LIBRE)
// RESUMEN: Añade un punto de ruta y pausa el modo "Free Drive" si está activo.
async function addWaypoint(latlng, displayName = null) {
    if (isNavigating) return;
    
    if (navigationFollowUser) {
        navigationFollowUser = false;
        const locateMeButton = document.getElementById('locate-me-on-reminders-map');
        const locateMeImg = locateMeButton ? locateMeButton.querySelector('img') : null;
        if (locateMeButton && locateMeImg) {
            locateMeImg.src = "PNG/ESTASAQUI.PNG";
            locateMeButton.title = "Mostrar mi posición actual y activar seguimiento";
        }
        showToast("Seguimiento pausado para añadir puntos.", "info");
    }

    if (isFreeDriveActive) {
        isFreeDrivePaused = true;
        isFreeDriveActive = false;
        showToast("Modo Conducción Libre en pausa.", "info");
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        clearNavigationGraph();
    }
    
    let address = displayName;
    if (!address) {
        address = await getAddressForWaypoint(latlng.lat, latlng.lng);
    }

    const newWaypoint = {
        id: Date.now(),
        lat: latlng.lat,
        lng: latlng.lng,
        type: '',
        marker: null,
        label: '',
        address: address,
        visited: false,
        isCriticalForRecalc: true,
        isInternal: false,
        isRecalculatedStart: false
    };

    if (navigationWaypoints.length === 0 && navigationCurrentLocation) {
        const startPoint = {
            id: Date.now() - 1,
            lat: navigationCurrentLocation.latitude,
            lng: navigationCurrentLocation.longitude,
            type: 'S',
            marker: null,
            label: 'S',
            address: 'Posición Actual (GPS)',
            visited: true,
            isCriticalForRecalc: true,
            isInternal: false,
            isRecalculatedStart: false
        };
        navigationWaypoints.push(startPoint);
    }

    navigationWaypoints.push(newWaypoint);
    await updateWaypointTypesAndLabels();
    renderWaypointMarkers();

    if (navigationWaypoints.filter(wp => wp && !wp.isInternal).length >= 2) {
        if (navigationWaypoints.filter(wp => wp && !wp.isInternal).length === 2) {
            showToast("Para ELIMINAR ETAPA, COMPARTIR o buscar RUTAS ALTERNATIVAS, haga una pulsación LARGA sobre el icono de la etapa, o ARRÁSTRELA para RESITUARLA", "instructional", 4000);
        }
        recalculateAndDrawRoute();
    }
    
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}

// ===================================================================
// NOMBRE: fetchAddressSuggestions (VERSIÓN CORREGIDA CON MANEJO DE "NO RESULTADOS")
// RESUMEN: En lugar de ocultar el modal cuando no hay resultados, lo mantiene
//          abierto y le pasa un array vacío para que muestre un mensaje.
async function fetchAddressSuggestions(query) {
    if (!query || query.length < 3) {
        hideAddressSuggestionsModal();
        return;
    }
    try {
        let queryToSearch = query.replace(/,/g, '');
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(queryToSearch)}&limit=60&accept-language=es&addressdetails=1`;
        
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Error de red: ${response.status}`);
        
        const data = await response.json();

        if (data && data.length > 0) {
            const results = data.reduce((acc, item) => {
                if (item && typeof item.lat === 'string' && item.lat.trim() !== '' && typeof item.lon === 'string' && item.lon.trim() !== '') {
                    acc.push({
                        display_name: item.display_name || "Ubicación desconocida",
                        lat: parseFloat(item.lat),
                        lon: parseFloat(item.lon)
                    });
                }
                return acc;
            }, []);
            if (results.length === 0) {
                 displayAddressSuggestionsModal([]);
            } else {
                 displayAddressSuggestionsModal(results.slice(0, 60));
            }

        } else {
            displayAddressSuggestionsModal([]);
        }
    } catch (error) {
        showToast(`Error buscando sugerencias: ${error.message}`, "error");
        hideAddressSuggestionsModal();
    }
}   
// ===================================================================
// NOMBRE: snapCoordsToRoad (NUEVA FUNCIÓN)
// RESUMEN: Toma coordenadas y devuelve las coordenadas del punto más cercano en la red de carreteras.
async function snapCoordsToRoad(lat, lon) {
    try {
        const nearestUrl = `${OSRM_SERVICE_URL}/nearest/v1/driving/${lon},${lat}?number=1`;
        const nearestResponse = await fetch(nearestUrl);
        if (!nearestResponse.ok) {
            console.warn(`OSRM /nearest falló, se usarán coordenadas originales.`);
            return { lat: lat, lng: lon };
        }
        const nearestData = await nearestResponse.json();
        if (nearestData.code === "Ok" && nearestData.waypoints && nearestData.waypoints.length > 0) {
            const snappedCoords = nearestData.waypoints[0].location;
            return { lat: snappedCoords[1], lng: snappedCoords[0] };
        } else {
            console.warn("OSRM /nearest no encontró un punto válido, se usarán coordenadas originales.");
            return { lat: lat, lng: lon };
        }
    } catch (error) {
        console.error("Error en snapCoordsToRoad:", error);
        return { lat: lat, lng: lon }; 
    }
}

// ===================================================================
// NOMBRE: searchAndAddWaypoint (MODIFICADA - SIN L.latLng)
// RESUMEN: Busca una dirección, la transforma en coordenadas, las ajusta a la carretera y la añade como waypoint.
async function searchAndAddWaypoint(addressQuery = null) {
    const searchInput = document.getElementById('map-location-search-input');
    const address = addressQuery || searchInput.value.trim();
    if (!address) {
        showToast("Por favor, introduce una dirección para buscar", "warning");
        return;
    }

    const searchButton = document.getElementById('map-location-search-button');
    if (searchButton) {
        searchButton.disabled = true;
        searchButton.innerHTML = `<img src="PNG/BUSCANDO.PNG" alt="Buscando...">`;
    }

    try {
        showToast("Buscando dirección...", "info", 3000);
        const searchUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address.replace(/,/g, ''))}&limit=1&accept-language=es&addressdetails=1`;
        
        const searchResponse = await fetch(searchUrl);
        if (!searchResponse.ok) throw new Error(`Error de red en Nominatim: ${searchResponse.status}`);
        
        const searchData = await searchResponse.json();
        if (!searchData || searchData.length === 0) throw new Error("Dirección no encontrada");
        
        const result = searchData[0];
        const initialLat = parseFloat(result.lat);
        const initialLon = parseFloat(result.lon);
        const displayName = result.display_name || `Ubicación (${initialLat.toFixed(3)}, ${initialLon.toFixed(3)})`;
        if (isNaN(initialLat) || isNaN(initialLon)) throw new Error("Coordenadas no válidas de Nominatim");

        showToast("Ajustando a la carretera más cercana...", "info", 3000);
        const snappedLatLng = await snapCoordsToRoad(initialLat, initialLon);
        
        await addWaypoint(snappedLatLng, displayName);
        
        if (navigationMapInstance) navigationMapInstance.flyTo({ center: [initialLon, initialLat], zoom: 15 });
        if (searchInput) {
            searchInput.value = '';
            searchInput.dispatchEvent(new Event('input'));
        }
        showToast("Ubicación añadida a la ruta", "success");

    } catch (error) {
        showToast(`Error al buscar dirección: ${error.message}`, "error", 4000, true);
    } finally {
        if (searchButton) {
            searchButton.disabled = false;
            searchButton.innerHTML = `<img src="PNG/ANADIRPUNTO.PNG" alt="Añadir Punto Ruta">`;
            if (searchInput && searchInput.value.trim() === '') {
                searchButton.style.display = 'none';
                const clearMapSearchBtn = document.getElementById('clear-map-search-input-button');
                if (clearMapSearchBtn) clearMapSearchBtn.style.display = 'none';
            }
        }
    }
}    
    
    // ===================================================================
    // NOMBRE: hideAddressSuggestionsModal
    // RESUMEN: Oculta el modal de sugerencias de direcciones.
    function hideAddressSuggestionsModal() {
        const modal = document.getElementById('address-suggestions-modal');
        if (modal && !modal.classList.contains('hidden')) {
            clearModalAutoCloseTimer(modal, modal.querySelector('#close-address-suggestions-modal'), 'address-suggestions-modal');
            modal.classList.add('hidden');
        }
    } 
    // ===================================================================
    // NOMBRE: toggleMapLocationSearchVisibility
    // RESUMEN: Muestra u oculta la fila de búsqueda del mapa.
    function toggleMapLocationSearchVisibility(show) {
        const searchRow = document.getElementById('search-row-map-header');
        const reorderButton = document.getElementById('reorder-route-stages-button');
        if (show) {
            if (searchRow) searchRow.style.display = 'flex';
            if (reorderButton && navigationWaypoints.length >= 2) reorderButton.style.display = 'inline-flex';
            else if (reorderButton) reorderButton.style.display = 'none';
        } else {
            if (searchRow) searchRow.style.display = 'none';
            if (reorderButton) reorderButton.style.display = 'none';
        }
    } 
// ===================================================================
// NOMBRE: updateWaypointTypesAndLabels (VERSIÓN CORREGIDA Y DEFINITIVA 2)
// RESUMEN: Actualiza los tipos y etiquetas, esperando a que todas las operaciones asíncronas finalicen.
async function updateWaypointTypesAndLabels() {
    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    if (actualWaypoints.length === 0) return;

    await Promise.all(actualWaypoints.map(async (wp, index) => {
        if (!wp) return;

        if (actualWaypoints.length === 1) {
            wp.type = 'S';
            wp.label = 'S';
        } else if (index === 0) {
            wp.type = 'S';
            wp.label = 'S';
        } else if (index === actualWaypoints.length - 1) {
            wp.type = 'F';
            wp.label = 'F';
        } else {
            wp.type = 'intermediate';
            wp.label = String(index);
        }

        if (!wp.address) {
            if (typeof wp.lat === 'number' && typeof wp.lng === 'number') {
                wp.address = await getAddressForWaypoint(wp.lat, wp.lng);
            } else {
                wp.address = "Coordenadas no disponibles para dirección";
            }
        }
    }));

    navigationWaypoints.forEach(wp => {
        if(wp && (wp.isInternal || wp.isRecalculatedStart)) {
            wp.label = '';
        }
    });
} 

// ===================================================================
// NOMBRE: getRouteForSingleLeg (MODIFICADA - SIN L.latLng)
// RESUMEN: Obtiene la distancia y duración de un solo tramo de ruta.
async function getRouteForSingleLeg(lon1, lat1, lon2, lat2) {
    const url = `${OSRM_SERVICE_URL}/driving/${lon1},${lat1};${lon2},${lat2}?overview=false&alternatives=false&steps=false&annotations=false`;
    try {
        const response = await fetch(url);
        if (!response.ok) {
            return { distance: 0, duration: 0 };
        }
        const data = await response.json();
        if (data.routes && data.routes.length > 0 && data.routes[0]) {
            return {
                distance: data.routes[0].distance || 0,
                duration: data.routes[0].duration || 0
            };
        }
        return { distance: 0, duration: 0 };
    } catch (error) {
        return { distance: 0, duration: 0 };
    }
}    

// ===================================================================
// NOMBRE: clearAllWaypointMarkersFromMap (MODIFICADA - PARA MAPBOX)
// RESUMEN: Elimina todos los marcadores de puntos de ruta del mapa.
function clearAllWaypointMarkersFromMap() {
    navigationWaypoints.forEach(wp => {
        if (wp && wp.marker) {
            wp.marker.remove();
            wp.marker = null;
        }
    });
}

// ===================================================================
// NOMBRE: handleSendToTeslaClick
// RESUMEN: Abre el diálogo nativo para compartir un destino a la app de Tesla.
async function handleSendToTeslaClick(lat, lng, name) {
    if (!navigator.share) {
        showToast("Tu navegador no soporta la función de compartir.", "warning");
        return;
    }

    try {
        const shareData = {
            title: `Destino: ${name}`,
            text: `Enviar "${name}" a la app de Tesla para iniciar la navegación.`,
            url: `https://maps.google.com/?q=${lat},${lng}`
        };

        await navigator.share(shareData);
        showToast("Selecciona la app de Tesla para enviar el destino.", "info");

    } catch (err) {
        if (err.name !== 'AbortError') {
            showToast(`Error al compartir: ${err.message}`, "error");
        }
    }
}
// ===================================================================
// NOMBRE: clearAllRouteVisualsFromMap (NUEVA FUNCIÓN MAESTRA)
// RESUMEN: Realiza una limpieza completa y garantizada de TODOS los
//          elementos visuales de la ruta (marcadores, etiquetas, líneas)
//          inspeccionando el estado real del mapa, no los arrays.
// ===================================================================
function clearAllRouteVisualsFromMap() {
    if (!navigationMapInstance) return;

    // 1. Eliminar marcadores HTML (Etapas y Etiquetas de Alternativas)
    // Este método es robusto porque busca los elementos directamente en el DOM del mapa.
    document.querySelectorAll('.navigation-waypoint-marker').forEach(el => el.remove());
    document.querySelectorAll('.route-label-marker').forEach(el => el.remove());

    // 2. Eliminar capas y fuentes de Mapbox
    if (navigationMapInstance.isStyleLoaded()) {
        const style = navigationMapInstance.getStyle();

        // Eliminar capas (ruta principal y alternativas)
        if (style && style.layers) {
            style.layers.forEach(layer => {
                if (layer.id === 'route' || layer.id.startsWith('alt-layer-')) {
                    try {
                        if (navigationMapInstance.getLayer(layer.id)) {
                            navigationMapInstance.removeLayer(layer.id);
                        }
                    } catch (e) {
                        console.warn(`Error al eliminar capa ${layer.id}: ${e.message}`);
                    }
                }
            });
        }

        // Eliminar fuentes de datos (ruta principal y alternativas)
        if (style && style.sources) {
            Object.keys(style.sources).forEach(sourceId => {
                if (sourceId === 'route' || sourceId.startsWith('alt-route-')) {
                    try {
                        if (navigationMapInstance.getSource(sourceId)) {
                            navigationMapInstance.removeSource(sourceId);
                        }
                    } catch (e) {
                        console.warn(`Error al eliminar fuente ${sourceId}: ${e.message}`);
                    }
                }
            });
        }
    }
    
    // 3. Reseteo final de variables de estado de capas
    navigationRouteLayer = null;
    alternativeRouteLayers = [];
}


// ===================================================================
// NOMBRE: resetNavigationState (MODIFICADA - USA LA NUEVA LIMPIEZA MAESTRA)
// RESUMEN: Reinicia a su estado original TODAS las variables relacionadas
//          con la navegación, llamando primero a la limpieza visual garantizada.
// ===================================================================
function resetNavigationState() {
    // --- PASO 1: LIMPIEZA VISUAL COMPLETA Y GARANTIZADA ---
    clearAllRouteVisualsFromMap();

    // --- PASO 2: LIMPIEZA DEL ESTADO DE LA APLICACIÓN ---
    const autoStartModal = document.getElementById('auto-start-nav-modal');
    if (autoStartModal) {
        hideAutoStartNavigationModal();
        showToast("Inicio automático cancelado: La ruta ha sido modificada/borrada.", "info");
    }

    // Estado de la ruta y navegación
    navigationWaypoints = [];
    navigationCurrentRouteData = null;
    isNavigating = false;
    currentRouteNameForSaving = null;
    
    // Progreso y Turn-by-Turn
    lastCarDistanceAlongRouteForNavLogic = 0;
    lastValidCarDistanceForDisplay = 0;
    currentLegIndexNav = 0;
    currentStepIndexNav = 0;
    completedSegmentsGeoJSON.features = [];
    lastDisplayedManeuverIcon = null;
    lastProcessedStepIdentifier = null;
    lastProcessedStepForLock = null;

    // Estadísticas del viaje
    tripInitialOverallEtaTime = null;
    currentStageInitialExpectedEtaTime = null;
    accumulatedDeviationMs = 0;
    accumulatedDistanceBeforeCurrentSegment = 0;
    navigationStartTimeForStats = null;
    totalDistanceTravelledForStats = 0;
    lastPositionForStats = null;
    maxSpeedDuringTrip = 0;
    maxSpeedCoordinates = null;
    maxAltitudeDuringTrip = -Infinity;
    minAltitudeDuringTrip = Infinity;
    window.averageSpeedKmh = 0;

    // POIs en ruta y caché
    radaresEnRutaActual = [];
    tareasEnRutaActual = [];
    alternativeRoutesCache.clear();
    selectedStageRoutes.clear();

    // Estado de la UI
    isArrivalSequenceStarted = false;
    hideNavigationUI();
    hideMapInfoOverlay();
    clearNavigationGraph();
    clearSpeedMarkers();
    
    // Limpia los contadores visuales
    actualizarContadorRadares(0);
    actualizarContadorTareas(0);
}

// ===================================================================
// NOMBRE: handleDeleteWaypointClick (MODIFICADA - CIERRA MODAL DE INICIO)
// RESUMEN: Elimina una etapa Y SUS PUNTOS INTERNOS ASOCIADOS.
async function handleDeleteWaypointClick(waypointId) {
    if (isNavigating) {
        showToast("No se pueden borrar puntos mientras se navega.", "warning");
        return;
    }
    clearAlternativeRoutesDisplay();
    alternativeRoutesCache.clear();

    const waypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    if (waypointIndex === -1) return;
    
    navigationWaypoints = navigationWaypoints.filter(wp => !(wp.isInternal && wp.parentWaypointId === waypointId));
    
    const finalWaypointIndex = navigationWaypoints.findIndex(wp => wp && wp.id === waypointId);
    if (finalWaypointIndex !== -1) {
        const waypointToDelete = navigationWaypoints[finalWaypointIndex];
        if (waypointToDelete.marker && navigationMapInstance) {
            waypointToDelete.marker.remove();
            waypointToDelete.marker = null;
        }
        navigationWaypoints.splice(finalWaypointIndex, 1);
    }
 
    if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) { 
        const autoStartModal = document.getElementById('auto-start-nav-modal');
        if (autoStartModal) {
            hideAutoStartNavigationModal();
            showToast("Inicio automático cancelado: La ruta ya no es válida.", "info");
        }
        
        clearAllWaypointMarkersFromMap(); 
        navigationWaypoints = [];
        if (navigationMapInstance && navigationMapInstance.getLayer('route')) {
            navigationMapInstance.removeLayer('route');
            navigationMapInstance.removeSource('route');
            navigationRouteLayer = null;
        }
        completedSegmentsGeoJSON.features = [];
        if (navigationMapInstance && navigationMapInstance.getSource('completed-segments')) {
            navigationMapInstance.getSource('completed-segments').setData(completedSegmentsGeoJSON);
        }

        navigationCurrentRouteData = null;
        hideNavigationUI();
        hideMapInfoOverlay();
        eliminarRadaresDeRuta();
        actualizarContadorRadares(0);
        eliminarTareasDeBarraProgreso();
        actualizarContadorTareas(0);
        const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
        if (radaresCheckbox) {
             localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckbox.checked)); 
        }
        const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
        if (tareasCheckbox) {
            localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckbox.checked));
        }
    } else {
        await updateWaypointTypesAndLabels();
        renderWaypointMarkers();
        if (navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart).length < 2) {
            if (navigationMapInstance && navigationMapInstance.getLayer('route')) { navigationMapInstance.removeLayer('route'); navigationMapInstance.removeSource('route'); }
            navigationRouteLayer = null;
            completedSegmentsGeoJSON.features = [];
            if (navigationMapInstance && navigationMapInstance.getSource('completed-segments')) {
                navigationMapInstance.getSource('completed-segments').setData(completedSegmentsGeoJSON);
            }
            navigationCurrentRouteData = null;
            hideMapInfoOverlay();
            eliminarRadaresDeRuta();
            actualizarContadorRadares(0);
            eliminarTareasDeBarraProgreso();
            actualizarContadorTareas(0);
            const radaresCheckbox = document.getElementById('radares-ruta-checkbox');
            if (radaresCheckbox) {
                localStorage.setItem(RADARES_RUTA_CHECKED_KEY, String(radaresCheckbox.checked));
            }
            const tareasCheckbox = document.getElementById('tareas-ruta-checkbox');
            if (tareasCheckbox) {
                localStorage.setItem(TAREAS_RUTA_CHECKED_KEY, String(tareasCheckbox.checked));
            }
        } else {
            recalculateAndDrawRoute().then(() => {
                const radaresRutaCheckbox = document.getElementById('radares-ruta-checkbox');
                if (radaresRutaCheckbox && radaresRutaCheckbox.checked) {
                    toggleRadaresRuta(true);
                }
                const tareasRutaCheckbox = document.getElementById('tareas-ruta-checkbox');
                if (tareasRutaCheckbox && tareasRutaCheckbox.checked) {
                    toggleTareasRuta(true);
                }
            });
        }
        showToast("Etapa eliminada.", "info");
    }
    updateStartNavigationButtonState();
    updateNavigationButtonColor();
}    

// =============================
// NOMBRE: translateOcmTerm
// RESUMEN: Traduce términos comunes de OCM del inglés al castellano.
function translateOcmTerm(term) {
    if (!term) return 'No especificado';
     const translations = {
        'Parking': 'Parking de pago',
        'Operational': 'Operativo',
        'Non-Operational': 'No operativo',
        'Not Operational': 'No operativo',   
        'Partly-Operational': 'Parcialmente operativo',
        'Planned For Future Date': 'Planificado',
        'Decommissioned': 'Fuera de servicio',
        'Public - Membership Required': 'Público - Requiere Membresía',
        'Public - Pay At Location': 'Público - Pago en el sitio',
        'Public': 'Público',
        'Privately Owned - For Staff, Visitors or Customers': 'Privado - Para personal o clientes',
        'Private - For Staff, Visitors or Customers': 'Privado - Para personal o clientes',
        'Private - Restricted Access': 'Privado - Acceso restringido'
    };
    return translations[term] || term;
}   

// ===================================================================
// NOMBRE: clearChargingPoints (CORREGIDA - PARA MAPBOX GEOJSON)
// RESUMEN: Elimina del mapa los puntos de recarga vaciando la fuente de datos.
function clearChargingPoints() {
    currentChargingPointsOnRoute = [];
    lastPdrSearchResults = [];
    
    if (navigationMapInstance && navigationMapInstance.getSource('pdrs-geojson-source')) {
        navigationMapInstance.getSource('pdrs-geojson-source').setData({
            type: 'FeatureCollection',
            features: []
        });
    }

    const pdrButton = document.getElementById('pdrs-ruta-button');
    if (pdrButton) pdrButton.classList.remove('pdr-search-highlight');
    pdrSearchState = 'initial'; 
}    
    
// ===================================================================
// NOMBRE: handleFreeDriveCancellation
// RESUMEN: Gestiona la reanudación del modo libre cuando se cancela una planificación de ruta.
function handleFreeDriveCancellation() {
    if (isFreeDrivePaused) {
        isFreeDriveActive = true;
        isFreeDrivePaused = false;
        
        if (freeDriveStats && !freeDriveStats.startTime) {
            freeDriveStats.startTime = new Date();
        }

        showToast("Planificación de ruta cancelada. Reanudando registro de Conducción Libre.", "info");
        
        updateStartNavigationButtonState();
        updateNavigationButtonColor();
        initializeNavigationGraph();
    }
}    

// ===================================================================
// NOMBRE: restoreOriginalGrid
// RESUMEN: Restaura el grid de marcadores a su estado original de fábrica.
function restoreOriginalGrid() {
    if (confirm('¿Restaurar el grid de botones a su estado original? Perderás tu personalización del grid (URLs, nombres, orden).')) {
        localStorage.removeItem('customGridData');
        localStorage.removeItem('gridFilterValue');
        loadCustomData();
        renderGrid();
        renderToggleButtons();
        loadSavedSettings();
        updateButtonStyles();
        filterGridItems();
        document.getElementById('config-restore-grid-status').textContent = 'Grid restaurado al original. Recargando...';
        document.getElementById('config-restore-grid-status').style.color = '#28a745';
        showToast('Grid restaurado. Recargando...', 'success');
        setTimeout(() => location.reload(), 1500);
    }
}

// ===================================================================
// NOMBRE: clearAllLocalData
// RESUMEN: Borra todos los datos guardados en el almacenamiento local del navegador.
function clearAllLocalData() {
    if (confirm('¡ATENCIÓN! Esto borrará TODOS los datos locales (marcadores personalizados, recordatorios, configuración de usuario, PIN, etc.). Esta acción NO SE PUEDE DESHACER. ¿Estás seguro?')) {
        if (confirm('DE VERDAD, ¿ESTÁS COMPLETAMENTE SEGURO? SE BORRARÁ TODO.')) {
            managedKeys.forEach(key => localStorage.removeItem(key));
            localStorage.removeItem('personalizationHelpShown');
            localStorage.removeItem('gridFilterValue');
            showToast('Todos los datos locales borrados. Recargando...', 'success');
            setTimeout(() => location.reload(), 1500);
        } else {
            showToast('Borrado cancelado', 'info');
        }
    } else {
        showToast('Borrado cancelado', 'info');
    }
}

// ===================================================================
// NOMBRE: fetchKMLFilesList
// RESUMEN: Obtiene la lista de archivos KML a procesar desde una URL.
async function fetchKMLFilesList(listUrl) {
    try {
        const response = await fetch(listUrl, { cache: 'no-cache' });
        if (!response.ok) throw new Error(`Error HTTP ${response.status} obteniendo lista KML: ${listUrl}`);
        const text = await response.text();
        return text.split('\n').map(f => f.trim()).filter(f => f.length > 0 && f.toLowerCase().endsWith('.kml'));
    } catch (error) {
        showToast(`Error cargando lista ${listUrl.split('/').pop()}`, 'error');
        return [];
    }
}

// ===================================================================
// NOMBRE: fetchAndParseKML
// RESUMEN: Descarga y decodifica un archivo KML.
async function fetchAndParseKML(kmlFileUrl) {
    try {
        const response = await fetch(kmlFileUrl, { cache: 'no-cache' });
        if (!response.ok) throw new Error(`Error HTTP ${response.status} obteniendo KML: ${kmlFileUrl}`);
        const buffer = await response.arrayBuffer();
        const decoder = new TextDecoder('iso-8859-1');
        const kmlText = decoder.decode(buffer);
        return parseKML(kmlText);
    } catch (error) {
        throw error;
    }
}

// ===================================================================
// NOMBRE: parseKML
// RESUMEN: Parsea el texto de un archivo KML para extraer los Placemarks.
function parseKML(kmlText) {
    const placemarks = [];
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(kmlText, "application/xml");
    const parserErrorNode = xmlDoc.querySelector("parsererror");
    if (parserErrorNode) {
        let errorMessage = "Error de parseo XML desconocido.";
        if (parserErrorNode.textContent) {
            const match = parserErrorNode.textContent.match(/error on line \d+ at column \d+: ([^\n]+)/);
            if (match && match[1]) {
                errorMessage = match[1];
            } else {
                errorMessage = parserErrorNode.textContent.split('\n')[0] || parserErrorNode.textContent;
            }
        } else if (parserErrorNode.innerText) {
             errorMessage = parserErrorNode.innerText.split('\n')[0] || parserErrorNode.innerText;
        }
        throw new Error("KML parsing error: " + errorMessage);
    }
    const KML_NS_GOOGLE = "http://earth.google.com/kml/2.0";
    const KML_NS_OGC = "http://www.opengis.net/kml/2.2";
    let placemarkNodes = xmlDoc.getElementsByTagNameNS(KML_NS_GOOGLE, 'Placemark');
    if (placemarkNodes.length === 0) {
        placemarkNodes = xmlDoc.getElementsByTagNameNS(KML_NS_OGC, 'Placemark');
    }
     if (placemarkNodes.length === 0) {
        placemarkNodes = xmlDoc.getElementsByTagName('Placemark');
    }
    for (let i = 0; i < placemarkNodes.length; i++) {
        const node = placemarkNodes[i];
        let nameNode, coordinatesNode;
        nameNode = node.getElementsByTagNameNS(KML_NS_GOOGLE, 'name')[0] || node.getElementsByTagNameNS(KML_NS_OGC, 'name')[0] || node.getElementsByTagName('name')[0];
        coordinatesNode = node.getElementsByTagNameNS(KML_NS_GOOGLE, 'coordinates')[0] || node.getElementsByTagNameNS(KML_NS_OGC, 'coordinates')[0] || node.getElementsByTagName('coordinates')[0];
        if (nameNode && coordinatesNode) {
            const name = nameNode.textContent.trim();
            const coordinatesRaw = coordinatesNode.textContent.trim();
            const coordPartsMatch = coordinatesRaw.match(/^(-?\d+\.?\d*)[,\s]+(-?\d+\.?\d*)/);
            if (name && coordPartsMatch && coordPartsMatch.length >= 3) {
                const lonStr = coordPartsMatch[1];
                const latStr = coordPartsMatch[2];
                const coordinates = `${lonStr},${latStr}`;
                const lon = parseFloat(lonStr);
                const lat = parseFloat(latStr);
                if (!isNaN(lon) && !isNaN(lat)) {
                    if (name.startsWith("Radares BBS www.laradiobbs.net") && lon === 0 && lat === 0) {
                        continue;
                    }
                    placemarks.push({ name, coordinates });
                }
            }
        }
    }
    return placemarks;
}


// ===================================================================
// NOMBRE: importRadars (MODIFICADA)
// RESUMEN: Importa radares y limpia la caché para forzar su reconstrucción.
async function importRadars() {
    window.radarsCache = null;
    window.radarsSpatialIndex = null;
    localStorage.removeItem('radarsCacheData');
    localStorage.removeItem('radarsCacheIndex');
    localStorage.removeItem('radarsCacheVersion');

    const latFilterValue = document.getElementById('radar-filter-lat').value.trim();
    const lonFilterValue = document.getElementById('radar-filter-lon').value.trim();
    const keywordsFilterRaw = document.getElementById('radar-filter-keywords').value.trim().toUpperCase();
    const keywordsFilter = keywordsFilterRaw ? keywordsFilterRaw.split(/\s+/).filter(k => k) : [];
    const importExtra = document.getElementById('import-extra-radars-checkbox').checked;
    const statusMessage = document.getElementById('radar-import-status');
    const progressContainer = document.getElementById('radar-import-progress-container');
    
    progressContainer.style.display = 'block';
    const progressBar = document.getElementById('radar-import-progress-bar');
    if(progressBar) progressBar.style.display = 'none';

    statusMessage.textContent = 'Iniciando importación...';
    statusMessage.style.color = '';
    try {
        let filesToProcess = await fetchKMLFilesList(KML_FILES_LIST_STANDARD);
        if (importExtra) {
            const extraFiles = await fetchKMLFilesList(KML_FILES_LIST_EXTRA);
            filesToProcess = filesToProcess.concat(extraFiles.filter(f => !filesToProcess.includes(f)));
        }
        if (filesToProcess.length === 0) {
            statusMessage.textContent = 'No se encontraron listas de archivos KML para procesar.';
            showToast('No hay archivos KML en las listas.', 'warning');
            setTimeout(() => { progressContainer.style.display = 'none'; }, 3000);
            return;
        }
        
        statusMessage.textContent = `Procesando ${filesToProcess.length} archivos KML...`;
        
        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        let newRadarsCount = 0;

        const processingPromises = filesToProcess.map(kmlFileName =>
            fetchAndParseKML(KML_BASE_PATH + kmlFileName).catch(e => {
                console.warn(`Error procesando ${kmlFileName}, se omitirá.`, e);
                return [];
            })
        );
        
        const results = await Promise.all(processingPromises);
        
        results.flat().forEach(placemark => {
            const name = placemark.name.toUpperCase();
            const coords = placemark.coordinates;
            const matchesKeywords = keywordsFilter.length === 0 || keywordsFilter.some(kw => name.includes(kw));
            if (coords && matchesKeywords) {
                const [lonStr, latStr] = coords.split(',');
                const lon = parseFloat(lonStr);
                const lat = parseFloat(latStr);
                if (isNaN(lat) || isNaN(lon)) return;
                
                const matchesLat = parseCoordinateFilter(latFilterValue, lat);
                const matchesLon = parseCoordinateFilter(lonFilterValue, lon);

                if (matchesLat && matchesLon) {
                    const existingRadar = reminders.find(r =>
                        r.isLocationEnabled && r.locationCoordinates &&
                        Math.abs(r.locationCoordinates.latitude - lat) < COORD_EPSILON &&
                        Math.abs(r.locationCoordinates.longitude - lon) < COORD_EPSILON &&
                        (r.text.toUpperCase().includes("RADAR") || r.excludeFromList)
                    );
                    if (!existingRadar) {
                        const now = new Date();
                        const newRadar = {
                            id: Date.now() + Math.random() + newRadarsCount,
                            text: `<b>RADAR: ${placemark.name}</b>`,
                            type: 'simple', time: '00:01',
                            date: `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`,
                            createdAt: now.toISOString(), managedByUser: false,
                            isLocationEnabled: true, locationCoordinates: { latitude: lat, longitude: lon },
                            radiusMeters: 400, excludeFromList: true
                        };
                        reminders.push(newRadar);
                        newRadarsCount++;
                    }
                }
            }
        });
        
        localStorage.setItem('reminders', JSON.stringify(reminders));
        statusMessage.textContent = `Importación completa. ${newRadarsCount} nuevos radares/POIs añadidos.`;
        statusMessage.style.color = '#28a745';
        showToast(`${newRadarsCount} nuevos radares/POIs añadidos.`, 'success');
        updateReminderCount();
        updateButtonStyles();
        checkReminders();
    } catch (error) {
        statusMessage.textContent = `Error general: ${error.message}`;
        statusMessage.style.color = 'red';
        showToast('Error durante la importación.', 'error');
    } finally {
         setTimeout(() => {
            progressContainer.style.display = 'none';
            if(progressBar) progressBar.style.display = 'block';
            statusMessage.style.color = '';
        }, 5000);
    }
}

    
// ===================================================================
// NOMBRE: showSimulationModal (RESTAURADA)
// RESUMEN: Muestra un modal con la lista de maniobras de la ruta actual. No inicia ninguna simulación.
async function showSimulationModal() {
    const canSimulate = (navigationWaypoints.filter(wp => !wp.isInternal && !wp.isRecalculatedStart).length >= 2 && navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]) ||
                    (isNavigating && navigationCurrentRouteData && navigationCurrentRouteData.routes && navigationCurrentRouteData.routes[0]);
    if (!canSimulate) {
        showToast("Se necesitan al menos 2 puntos y una ruta calculada para mostrar las maniobras.", "warning");
        return;
    }
    const route = navigationCurrentRouteData.routes[0];
    if (!route || !route.legs || route.legs.length === 0) {
        showToast("Datos de ruta incompletos para mostrar maniobras.", "error");
        return;
    }
    closeOtherModals('simulation-modal');
    
    let modal = document.getElementById('simulation-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'simulation-modal';
        document.body.appendChild(modal);
    }
    modal.innerHTML = `
        <h2 style="font-size: 1.3rem; font-weight: bold; text-align: center; margin-bottom: 1rem; color: #333;">Maniobras de la Ruta</h2>
        <div class="modal-top-buttons" style="justify-content: flex-start; margin-bottom: 1rem;">
            <button id="close-simulation-modal" style="flex: 0 0 auto; width: auto; min-width: unset;">Salir <span class="button-countdown-timer"></span></button>
        </div>
        <div id="simulation-content-area"><p>Cargando maniobras...</p></div>
    `;
    modal.classList.remove('hidden');

    const closeButton = modal.querySelector('#close-simulation-modal');
    const closeSimulationModalHandler = () => {
        if (simulationModalTimer) clearTimeout(simulationModalTimer);
        clearModalAutoCloseTimer(modal, closeButton, 'simulation-modal');
        modal.classList.add('hidden');
        hideIntersectionPreviewMap();
    };
    closeButton.addEventListener('click', closeSimulationModalHandler);
    addModalAutoCloseTimer(modal, closeButton, 'simulation-modal', 50000);

    const carDist = lastCarDistanceAlongRouteForNavLogic;
    let simulationList = document.createElement('ul');
    let stepsShown = 0;
    let actualStageCounter = 1;
    
    const waypointsForRequest = navigationWaypoints.filter(wp => wp);
    
    for (let legIdx = 0; legIdx < route.legs.length; legIdx++) {
        const leg = route.legs[legIdx];
        if (!leg || !leg.steps) continue;
        
        const legDestinationWaypoint = waypointsForRequest[legIdx + 1];
        if (legDestinationWaypoint && !legDestinationWaypoint.isInternal) {
             const stageAddress = legDestinationWaypoint.address || `Etapa ${legDestinationWaypoint.label}`;
             const stageDistance = leg.distance ? (leg.distance / 1000).toFixed(1) + " km" : "Dist. desc.";
             const headerLi = document.createElement('li');
             headerLi.style.cssText = "background-color: #e0e0e0; font-weight: bold; padding: 5px; margin-top:5px;";
             headerLi.textContent = `ETAPA ${actualStageCounter}: ${stageAddress} (Total ${stageDistance})`;
             simulationList.appendChild(headerLi);
             actualStageCounter++;
        }
        
        for (let stepIdx = 0; stepIdx < leg.steps.length; stepIdx++) {
            const step = leg.steps[stepIdx];
            if (!step || !step.maneuver) continue;

            const isArrivalAtInternal = step.maneuver.type === 'arrive' && waypointsForRequest[legIdx + 1]?.isInternal;
            const isDepartureFromInternal = step.maneuver.type === 'depart' && stepIdx === 0 && legIdx > 0 && waypointsForRequest[legIdx]?.isInternal;
            if (isArrivalAtInternal || isDepartureFromInternal) continue;
            
            const distanceToEndOfThisStep = calculateDistanceToEndOfStep(route, legIdx, stepIdx);
            if (distanceToEndOfThisStep < carDist) continue;
            const distanceToThisStepManeuver = Math.max(0, distanceToEndOfThisStep - carDist);
            
            const maneuver = step.maneuver;
            const type = maneuver.type || '';
            
            const maneuverText = getManeuverInstructionText(maneuver);
            let streetNameText = step.name || '';
            if (type === 'arrive' || type === 'depart' || type === 'end of road' || type === 'roundabout' || type === 'rotary') {
                streetNameText = '';
            } else if (streetNameText.toLowerCase() === 'continúa' && maneuverText.toLowerCase() !== 'continúa') {
                streetNameText = '';
            }
            
            let distanceFormatted = (distanceToThisStepManeuver >= 1000) ? `${(distanceToThisStepManeuver / 1000).toFixed(1)} km` : `${Math.round(distanceToThisStepManeuver)} m`;
            
            const li = document.createElement('li');
            li.dataset.legIndex = legIdx;
            li.dataset.stepIndex = stepIdx;
            li.style.cursor = 'pointer';
            
            const iconContainer = document.createElement('span');
            iconContainer.className = 'turn-icon-sim';
            
            const textContainer = document.createElement('span');
            textContainer.innerHTML = `${maneuverText}${streetNameText ? ` <strong>${streetNameText}</strong>` : ''} (${distanceFormatted})`;
            
            li.appendChild(iconContainer);
            li.appendChild(textContainer);
            simulationList.appendChild(li);

            const iconFilename = getManeuverIconFilename(maneuver);
            const iconUrl = `https://boardinggate.github.io/Tesla/${iconFilename}`;
            iconContainer.innerHTML = `<img src="${iconUrl}" alt="Maniobra" style="width:24px; height:24px; object-fit:contain;">`;
            
            stepsShown++;
        }
    }
    
    const contentArea = modal.querySelector('#simulation-content-area');
    if (stepsShown > 0) {
        contentArea.innerHTML = '';
        contentArea.appendChild(simulationList);
        contentArea.removeEventListener('click', handleSimulationItemClick);
        contentArea.addEventListener('click', handleSimulationItemClick);
    } else {
        contentArea.innerHTML = "<p>No hay más interacciones futuras en la ruta o estás muy cerca del final.</p>";
    }
}

// ===================================================================
// NOMBRE: handleSimulationItemClick (VERSIÓN CORREGIDA)
// RESUMEN: Maneja el clic en un elemento de la lista de maniobras para mostrar el detalle del mapa.
function handleSimulationItemClick(event) {
    const listItem = event.target.closest('li[data-leg-index][data-step-index]');
    if (!listItem) {
        return;
    }
    if (!navigationCurrentRouteData || !navigationCurrentRouteData.routes || navigationCurrentRouteData.routes.length === 0) {
        return;
    }
    const legIndex = parseInt(listItem.dataset.legIndex);
    const stepIndex = parseInt(listItem.dataset.stepIndex);
    const route = navigationCurrentRouteData.routes[0];
    if (route.legs && legIndex < route.legs.length && route.legs[legIndex].steps && stepIndex < route.legs[legIndex].steps.length) {
        const step = route.legs[legIndex].steps[stepIndex];
        showIntersectionPreviewMap(step, route, true, 5000);
    } else {
        hideIntersectionPreviewMap();
    }
}


// ===================================================================
// NOMBRE: hideMapInfoOverlay
// RESUMEN: Oculta el mensaje de información del mapa.
function hideMapInfoOverlay() {
    const overlay = document.getElementById('map-info-overlay');
    if (overlay) {
        overlay.textContent = '';
        overlay.style.display = 'none';
    }
}
  

// ===================================================================
// NOMBRE: showMapInfoOverlay (VERSIÓN CORREGIDA Y MEJORADA)
// RESUMEN: Muestra un mensaje y solo añade una clase de error si es necesario, sin tocar el fondo por defecto.
function showMapInfoOverlay(message, isError = false) {
    const overlay = document.getElementById('map-info-overlay');
    if (overlay) {
        let finalMessage = message;
        if (message.startsWith(" ")) {
            const destName = message.substring(" ".length).trim().replace(/<br>/gi, ' ');
            finalMessage = " " + (destName.length > 55 ? destName.substring(0, 52) + "..." : destName);
        } else if (message.startsWith("ETAPA ")) {
            const stageInfo = message.substring("ETAPA ".length).trim().replace(/<br>/gi, ' ');
            finalMessage = "ETAPA " + (stageInfo.length > 55 ? stageInfo.substring(0, 52) + "..." : stageInfo);
        } else if (message.startsWith("HA LLEGADO AL ")) {
            const destinationName = message.substring("HA LLEGADO AL : ".length).trim().replace(/<br>/gi, ' ');
            finalMessage = "HA LLEGADO A: " + (destinationName.length > 55 ? destinationName.substring(0, 52) + "..." : destinationName);
        }
        
        overlay.innerHTML = `<span>${finalMessage}</span>`;
        
        if (!isNavigating) {
            overlay.style.display = 'block';
        }
        
        overlay.classList.toggle('error-overlay', isError);
    }
}    

// ===================================================================
// NOMBRE: showDestinationName
// RESUMEN: Muestra el nombre del destino o de la siguiente etapa en el overlay del mapa.
function showDestinationName() {
    if (!navigationWaypoints || navigationWaypoints.length === 0) {
        hideMapInfoOverlay();
        return;
    }
    let message = "";
    let nextUnvisitedStageWp = null;
    if (isNavigating) {
        const totalEtapas = navigationCurrentRouteData?.routes?.[0]?.legs?.length || 0;
        const etapaActualUsuario = currentLegIndexNav + 1;
        for(let i = currentLegIndexNav; i < navigationWaypoints.length; i++) {
            const waypointToCheck = navigationWaypoints[i];
            if (waypointToCheck && !waypointToCheck.isInternal && !waypointToCheck.visited && waypointToCheck.type !== 'S' && waypointToCheck.type !== 'S_Recalc') {
                nextUnvisitedStageWp = waypointToCheck;
                break;
            }
        }
         if (!nextUnvisitedStageWp && navigationWaypoints.length > 0) {
            const lastWaypoint = navigationWaypoints[navigationWaypoints.length -1];
            if (lastWaypoint.type === 'F' && !lastWaypoint.visited) {
                 nextUnvisitedStageWp = lastWaypoint;
            }
        }
        if (nextUnvisitedStageWp) {
            if (nextUnvisitedStageWp.type === 'F') {
                message = ` ${nextUnvisitedStageWp.address || ' Final'}`;
            } else if (nextUnvisitedStageWp.type === 'intermediate' && totalEtapas > 1) {
                message = `ETAPA ${etapaActualUsuario} de ${totalEtapas}: ${nextUnvisitedStageWp.address || `Etapa ${nextUnvisitedStageWp.label}`}`;
            } else {
                 message = ` ${nextUnvisitedStageWp.address || 'Siguiente Punto'}`;
            }
        } else {
            const finalDestination = navigationWaypoints[navigationWaypoints.length - 1];
            if (finalDestination && !finalDestination.isInternal) {
                 message = ` ${finalDestination.address || ' Final'}`;
            } else {
                 message = "RUTA NO DEFINIDA";
            }
        }
    } else {
        const finalDestination = navigationWaypoints[navigationWaypoints.length - 1];
        if (finalDestination && !finalDestination.isInternal) {
             message = ` ${finalDestination.address || ' Final'}`;
        } else {
             message = "RUTA NO DEFINIDA";
        }
    }
    showMapInfoOverlay(message);
}

    

// ===================================================================
// NOMBRE: clearModalAutoCloseTimer
// RESUMEN: Limpia un temporizador de autocierre de un modal.
function clearModalAutoCloseTimer(modalElement, closeButtonElement, modalId) {
    const timerIdToClear = modalId || (modalElement ? modalElement.dataset.modalTimerId : null);
    if (timerIdToClear && globalModalTimers[timerIdToClear]) {
        clearInterval(globalModalTimers[timerIdToClear].intervalId);
        const timerData = globalModalTimers[timerIdToClear];
        if (timerData.modalElement && timerData.resetHandler) {
            timerData.modalElement.removeEventListener('click', timerData.resetHandler);
            timerData.modalElement.removeEventListener('touchstart', timerData.resetHandler);
            timerData.modalElement.removeEventListener('input', timerData.resetHandler);
            timerData.modalElement.removeEventListener('scroll', timerData.resetHandler);
        }
        if (timerData.countdownSpan && timerData.countdownSpan.parentNode) {
            timerData.countdownSpan.remove();
        }
        delete globalModalTimers[timerIdToClear];
    }
    if(closeButtonElement){
        const orphanSpans = closeButtonElement.querySelectorAll('.button-countdown-timer');
        orphanSpans.forEach(s => s.remove());
    }
     if(modalElement && modalElement.dataset.modalTimerId) {
        delete modalElement.dataset.modalTimerId;
    }
}

// ===================================================================
// NOMBRE: formatDateToDDMMMYY
// RESUMEN: Formatea una fecha (YYYY-MM-DD) a un formato legible (DD Mes Abreviado YY).
function formatDateToDDMMMYY(dateString) {
     if (!dateString) return '-';
     try {
         const [year, month, day] = dateString.split('-').map(Number);
         const date = new Date(Date.UTC(year, month - 1, day));
         if (isNaN(date.getTime())) return '-';
         const dayOfMonth = String(date.getUTCDate()).padStart(2, '0');
         const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
         const monthName = monthNames[date.getUTCMonth()];
         const yearShort = String(date.getUTCFullYear()).slice(-2);
         return `${dayOfMonth} ${monthName} ${yearShort}`;
     } catch (e) {
         return '-';
     }
}

// ===================================================================
// NOMBRE: calculateNextOccurrence
// RESUMEN: Calcula la próxima fecha de vencimiento de un recordatorio cíclico.
function calculateNextOccurrence(reminder, referenceDate) {
      if (!reminder || !reminder.type || !reminder.time || !reminder.date) { return null; } try {
          let [year, month, day] = reminder.date.split('-').map(Number); let [hour, minute] = reminder.time.split(':').map(Number);
          let baseDate = new Date(Date.UTC(year, month - 1, day, hour, minute)); if (isNaN(baseDate.getTime())) { return null; }
          const refDateUTC = new Date(referenceDate.getTime()); if (baseDate > refDateUTC) return baseDate;
          if (reminder.type === 'simple') { return null; }
          if (reminder.type === 'daily' || reminder.type === 'hourly') { let next = new Date(baseDate); while (next <= refDateUTC) { next.setUTCDate(next.getUTCDate() + 1); } return next; }
          if (reminder.type === 'weekly' && reminder.repeatDays && reminder.repeatDays.length > 0) {
              let next = new Date(refDateUTC); next.setUTCHours(hour, minute, 0, 0);
              if (next <= refDateUTC || !reminder.repeatDays.includes(next.getUTCDay())) { next.setUTCDate(next.getUTCDate() + 1); }
              for (let i = 0; i < 7; i++) { if (reminder.repeatDays.includes(next.getUTCDay())) { return next; } next.setUTCDate(next.getUTCDate() + 1); } return null;
          }
          if (reminder.type === 'interval' && reminder.intervalDays && reminder.intervalDays > 0) { let next = new Date(baseDate); while (next <= refDateUTC) { next.setUTCDate(next.getUTCDate() + reminder.intervalDays); } return next; }
          return null; } catch (e) { return null; }
 }

// ===================================================================
// NOMBRE: calculatePostponedDateTime
// RESUMEN: Calcula la fecha y hora para posponer un recordatorio.
function calculatePostponedDateTime(mins) {
      const now = new Date(); const postponedDate = new Date(now.getTime() + mins * 60000);
      const newDateISO = `${postponedDate.getFullYear()}-${(postponedDate.getMonth() + 1).toString().padStart(2, '0')}-${postponedDate.getDate().toString().padStart(2, '0')}`;
      const newTime = `${postponedDate.getHours().toString().padStart(2, '0')}:${postponedDate.getMinutes().toString().padStart(2, '0')}`; return { newDateISO, newTime };
     }
       
// ===================================================================
// NOMBRE: showPostponeOptionsModal(reminder
// RESUMEN: Muestra un modal con opciones para posponer un recordatorio.
function showPostponeOptionsModal(reminder, source = 'unified') {
         const existingModal = document.getElementById('postpone-options-modal'); if (existingModal) { if (existingModal.autoPostponeInterval) clearInterval(existingModal.autoPostponeInterval); if (existingModal.parentNode) existingModal.parentNode.removeChild(existingModal); }
         const modal = document.createElement('div'); modal.id = 'postpone-options-modal'; modal.className = 'postpone-options';
         modal.style.cssText = `position:fixed; top:10px; left:50%; transform:translateX(-50%); width:90%; max-width:480px; max-height:calc(100vh - 20px); overflow-y:auto; background-color:#F5E1A9; padding:1.5rem; border-radius:1rem; box-shadow:0 10px 25px rgba(0,0,0,0.2); z-index:7500; `;
         modal.setAttribute('aria-label', 'Posponer recordatorio');
         let countdown = 10; const isCyclic = reminder.type === 'weekly' || reminder.type === 'interval'; const defaultMinutes = 15;
         let buttonHtml = ` <button data-minutes="15" class="postpone-option">15 Minutos</button> <button data-minutes="60" class="postpone-option">1 Hora</button> <button data-minutes="180" class="postpone-option">3 Horas</button> `;
         if (!isCyclic) { buttonHtml += ` <button data-minutes="1440" class="postpone-option">1 Día</button> <button data-minutes="4320" class="postpone-option">3 Días</button> `; }
         modal.innerHTML = `
            <style>
                .postpone-options .reminder-text { color:#333; font-size:1.2rem; margin-bottom:.5rem; word-wrap:break-word; }
                .postpone-options .reminder-details { color:#555; font-size:1rem; margin-bottom:1.5rem; }
                .postpone-options .button-group { display:flex; flex-direction:column; gap:1rem; align-items:stretch; }
                .postpone-options button.postpone-option { font-size:1.3rem; font-weight:bold; padding:.8rem 1rem; background-color:#F59E0B; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                .postpone-options button.postpone-option:hover { background-color:#D97706; }
                #postpone-countdown { text-align:center; margin-top:1.8rem; font-size:1.1rem; font-weight:500; color:#444; }
                #postpone-timer-value { font-weight:bold; font-size:1.2rem; }
                #cancel-postpone { margin-top:1.2rem; width:100%; padding:.7rem 1rem; font-size:1.1rem; background-color:#EF4444; color:white; border:none; border-radius:.375rem; cursor:pointer; text-align:center; transition:background-color .2s ease; }
                #cancel-postpone:hover { background-color:#DC2626; }
            </style>
            <div class="modal-top-buttons" style="justify-content: flex-end; margin-bottom: 1rem;">
                 <button id="cancel-postpone" style="flex: 0 1 auto; min-width: 120px;">Cancelar</button>
            </div>
            <p class="reminder-text">Posponer: ${reminder.text.replace(/<[^>]*>/g, '')}</p>
            <p class="reminder-details">Selecciona tiempo:</p>
            <div class="button-group">
                ${buttonHtml}
            </div>
            <p id="postpone-countdown">Automático en <span id="postpone-timer-value">${countdown}</span>s (${defaultMinutes} min)</p>
         `;
         document.body.appendChild(modal);
         const countdownDisplay = modal.querySelector('#postpone-timer-value');
         const handlePostpone = (minutes) => {
             if (modal.autoPostponeInterval) clearInterval(modal.autoPostponeInterval); modal.autoPostponeInterval = null;
             updateUnifiedWindowUI(reminder.id);
             let reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); const index = reminders.findIndex(r => r.id === reminder.id);
             if (index === -1) { showToast("Error: Recordatorio no encontrado", "error"); checkReminders(); if (modal.parentNode) document.body.removeChild(modal); return; }
             const { newDateISO, newTime } = calculatePostponedDateTime(minutes); reminders[index].date = newDateISO; reminders[index].time = newTime; reminders[index].managedByUser = false;
             if (!isCyclic) { reminders[index].type = 'daily'; reminders[index].repeatDays = []; reminders[index].intervalDays = null; }
             localStorage.setItem('reminders', JSON.stringify(reminders)); updateReminderCount(); updateButtonStyles(); 
             const durationText = minutes >= 1440 ? `${minutes / 1440} día(s)` : (minutes >= 60 ? `${minutes / 60} hora(s)` : `${minutes} minutos`);
             showToast(`Pospuesto ${durationText}`, 'info');
             if (modal.parentNode) document.body.removeChild(modal);
             if (source === 'table') { setTimeout(showAllReminders, 100); }
             else { const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                 const mapContextToReopen = sessionStorage.getItem('mapContext');
                 if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) { sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); if (!document.getElementById('reminders-location-map-modal')) { if (mapContextToReopen === 'navigation') openNavigationMap(); sessionStorage.removeItem('mapContext');} } } };
         modal.autoPostponeInterval = setInterval(() => { countdown--; if (countdownDisplay) countdownDisplay.textContent = countdown; if (countdown <= 0) { handlePostpone(defaultMinutes); } }, 1000);
         modal.querySelectorAll('.postpone-option').forEach(button => { button.addEventListener('click', () => { const minutes = parseInt(button.dataset.minutes); if (!isNaN(minutes)) { handlePostpone(minutes); } }); });
         modal.querySelector('#cancel-postpone').addEventListener('click', () => {
             clearInterval(modal.autoPostponeInterval); modal.autoPostponeInterval = null; markReminderAsManaged(reminder.id, false); if (modal.parentNode) document.body.removeChild(modal);
             if (source === 'table') { setTimeout(showAllReminders, 100); }
             else { const mapShouldReopenAfterUnified = sessionStorage.getItem('boardinggate_map_should_reopen_when_unified_closes') === 'true';
                  const mapContextToReopen = sessionStorage.getItem('mapContext');
                 if (mapShouldReopenAfterUnified && !document.getElementById('unified-reminder-window')?.classList.contains('visible')) { sessionStorage.removeItem('boardinggate_map_should_reopen_when_unified_closes'); if (!document.getElementById('reminders-location-map-modal')) { if (mapContextToReopen === 'navigation') openNavigationMap(); sessionStorage.removeItem('mapContext');} } } showToast('Posposición cancelada', 'info'); });
     }
    
  
// ===================================================================
// NOMBRE: handleDragEndReorder
// RESUMEN: Maneja la finalización de una operación de arrastre en la lista de etapas.
function handleDragEndReorder(e) {
    if (draggedStageLi) {
        draggedStageLi.classList.remove('dragging');
    }
    draggedStageLi = null;
}

// ===================================================================
// NOMBRE: handleDragOverReorder
// RESUMEN: Maneja el evento de pasar por encima al arrastrar en la lista de etapas.
function handleDragOverReorder(e) {
    e.preventDefault();
    if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
    const listElement = document.getElementById('sortable-stages-list');
    if (!listElement || !draggedStageLi) return;
    const afterElement = getDragAfterElement(listElement, e.clientY);
    const currentLi = e.target.closest('li');
    if (draggedStageLi && currentLi && draggedStageLi !== currentLi) {
        if (afterElement == null) {
            listElement.appendChild(draggedStageLi);
        } else {
            listElement.insertBefore(draggedStageLi, afterElement);
        }
    } else if (draggedStageLi && !currentLi && afterElement == null) {
         listElement.appendChild(draggedStageLi);
    } else if (draggedStageLi && !currentLi && afterElement) {
         listElement.insertBefore(draggedStageLi, afterElement);
    }
}

// ===================================================================
// NOMBRE: handleStageTouchStart
// RESUMEN: Maneja el inicio de un toque en una etapa para reordenar.
function handleStageTouchStart(e) {
    if (e.touches.length === 1 && e.target.closest('.drag-handle')) {
        draggedStageLi = e.target.closest('li');
        if (!draggedStageLi) return;
        const touch = e.touches[0];
        stageTouchStartX = touch.clientX;
        stageTouchStartY = touch.clientY;
        clearTimeout(stageScrollTimeout);
        stageScrollTimeout = setTimeout(() => {
            if (draggedStageLi) {
                draggedStageLi.classList.add('dragging');
                document.body.style.overflow = 'hidden';
            }
        }, 150);
    }
}

// ===================================================================
// NOMBRE: createWaypointMarkerIcon (MODIFICADA CON TAMAÑO DE FUENTE DINÁMICO Y COLOR DE VISITADO)
// RESUMEN: Crea el elemento DOM para un marcador de etapa, con tamaño de fuente escalable y color gris para visitados.
function createWaypointMarkerIcon(label, type, visited, id, currentZoomLevel = null) {
    const el = document.createElement('div');
    el.className = 'navigation-waypoint-marker';
    
    let color;
    if (visited) {
        color = 'rgba(85, 85, 85, 0.8)'; 
    } else if (type === 'S' || type === 'S_Recalc') {
        color = 'rgba(0, 128, 0, 0.80)'; 
    } else if (type === 'F') {
        color = 'rgba(0, 0, 255, 0.80)'; 
    } else {
        color = 'rgba(230, 140, 0, 0.80)'; 
    }
    
    const ZOOM_PEQUENO = 12;
    const ZOOM_GRANDE = 17;
    const FONT_MINIMO = 15; 
    const FONT_MAXIMO = 19; 
    
    let finalFontSize = FONT_MAXIMO;
    if (currentZoomLevel !== null) {
        if (currentZoomLevel <= ZOOM_PEQUENO) {
            finalFontSize = FONT_MINIMO;
        } else if (currentZoomLevel >= ZOOM_GRANDE) {
            finalFontSize = FONT_MAXIMO;
        } else {
            const progress = (currentZoomLevel - ZOOM_PEQUENO) / (ZOOM_GRANDE - ZOOM_PEQUENO);
            finalFontSize = FONT_MINIMO + (FONT_MAXIMO - FONT_MINIMO) * progress;
        }
    }
    
    el.style.backgroundColor = color;
    el.style.width = '45px';
    el.style.height = '45px';
    el.style.border = `2px solid ${visited ? '#555' : 'white'}`;
    el.style.opacity = visited ? '0.7' : '1';
    el.textContent = label;
    el.style.fontSize = `${Math.round(finalFontSize)}px`;
    el.style.cursor = 'pointer';
    
    return el;
}
    
// ===================================================================
// NOMBRE: handleStageTouchMove
// RESUMEN: Maneja el movimiento de un toque en una etapa para reordenar.
function handleStageTouchMove(e) {
    if (!draggedStageLi || e.touches.length !== 1) return;
    e.preventDefault();
    clearTimeout(stageScrollTimeout);
    if (!draggedStageLi.classList.contains('dragging')) {
        draggedStageLi.classList.add('dragging');
         document.body.style.overflow = 'hidden';
    }
    const touch = e.touches[0];
    const listElement = document.getElementById('sortable-stages-list');
    if (!listElement) return;
    const afterElement = getDragAfterElement(listElement, touch.clientY);
     if (afterElement == null) {
        listElement.appendChild(draggedStageLi);
    } else {
        listElement.insertBefore(draggedStageLi, afterElement);
    }
}
  
// ===================================================================
// NOMBRE: handleStageTouchEnd
// RESUMEN: Maneja el final de un toque en una etapa para reordenar.
function handleStageTouchEnd(e) {
    clearTimeout(stageScrollTimeout);
    if (draggedStageLi) {
        draggedStageLi.classList.remove('dragging');
        draggedStageLi = null;
    }
    document.body.style.overflow = '';
}

// ===================================================================
// NOMBRE: getDragAfterElement
// RESUMEN: Encuentra el elemento después del cual se debe soltar el elemento arrastrado.
function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('li:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

// ===================================================================
// NOMBRE: startGraphIntervalTimer (CORREGIDA)
function startGraphIntervalTimer() {
    if (graphIntervalTimer) clearInterval(graphIntervalTimer);
    if ((isNavigating || isFreeDriveActive) && currentGraphMode !== 'Gráfica off' && graphIntervalDuration > 0) { 
        graphIntervalTimer = setInterval(plotIntervalData, graphIntervalDuration);
    }
}

// ===================================================================
// NOMBRE: initializeApp (VERSIÓN FINAL CON LLAMADA A FUNCIÓN CORREGIDA)
// RESUMEN: Llama a la nueva función `uploadDirtyCacheOnLoad_Car` y establece el timestamp inicial para la sincronización móvil.
async function initializeApp() {
    loadCustomData();
    loadSavedSettings();
    applyMapVisualSettings();
    isMobileSession = parseUserId(localStorage.getItem('userData_userId')).isMobile; // <-- AÑADE ESTA LÍNEA AQUÍ
    
    if (isMobileSession) {
        document.body.classList.add('mobile-view');
        await restoreCacheForMobile();
    } else {
        await uploadDirtyCacheOnLoad_Car();
    }

    // Establecemos el timestamp de la última sincronización al cargar la página.
    lastMobileSyncTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');
    
    checkForExcessiveRadars();
    
    const termsAccepted = localStorage.getItem('termsAccepted_v1') === 'true';
    const shouldDirectToNav = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
    const tempPreventDirectNav = sessionStorage.getItem(TEMP_PREVENT_DIRECT_NAV_KEY);
    
    if (shouldDirectToNav && !tempPreventDirectNav && termsAccepted) {
        sessionStorage.setItem('isInDirectToMapMode', 'true');
        directToNavOnLoad = true;
        const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'none';
        const footerContent = document.querySelector('footer'); if (footerContent) footerContent.style.display = 'none';
        const noticesIconContainer = document.querySelector('.notices-icon-container'); if (noticesIconContainer) noticesIconContainer.style.display = 'none';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'none');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'none');
        document.getElementById('grid-filter-container').style.display = 'none';
        createOtherButtons();
        renderToggleButtons();
        openNavigationMap();
    } else {
        sessionStorage.removeItem('isInDirectToMapMode');
        directToNavOnLoad = false;
        const mainContent = document.querySelector('main'); if (mainContent) mainContent.style.display = 'block';
        const footerContent = document.querySelector('footer'); if (footerContent) footerContent.style.display = 'block';
        const noticesIconContainer = document.querySelector('.notices-icon-container'); if (noticesIconContainer) noticesIconContainer.style.display = 'flex';
        const sideControls = document.querySelectorAll('.toggle-image, .toggle-sign, .scroll-toggle-button'); sideControls.forEach(el => el.style.display = 'flex');
        document.querySelectorAll('#config-button, #personal-button, #radar-button, #home-button, #reload-button, #keyword-assignment-button, #password-toggle-button, #versions-button, #info-button').forEach(el => el.style.display = 'block');
        document.getElementById('grid-filter-container').style.display = 'flex';
        renderGrid();
        createOtherButtons();
        renderToggleButtons();
        updateButtonStyles();
        filterGridItems();
    }

    initializeConfigModalListeners();
    try { await updateVersion(); } catch (e) { }
    try { await loadNotices(); startNoticeRotation(); } catch (e) { }
    if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
    
    checkReminders(); 

    currentCheckIntervalDuration = 3000;
    reminderCheckIntervalId = setInterval(checkReminders, currentCheckIntervalDuration);
    
    if (!termsAccepted) {
        showConfigModal();
    }

    const noticeToggleIcon = document.getElementById('notice-toggle-icon');
    if (noticeToggleIcon) noticeToggleIcon.addEventListener('click', toggleNotices);
    const countEl = document.getElementById('reminder-count-globe');
    if (countEl) {
         const openTable = (e) => {
             if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
             e.preventDefault(); e.stopPropagation();
             showAllReminders();
         };
         countEl.addEventListener('click', openTable);
         countEl.style.cursor = 'pointer';
    }
    const filterInput = document.getElementById('grid-filter-input');
    const clearButton = document.getElementById('clear-filter-button');
    if (filterInput) {
        const savedFilter = localStorage.getItem('gridFilterValue');
        if (savedFilter !== null) filterInput.value = savedFilter;
        filterInput.addEventListener('input', () => {
             localStorage.setItem('gridFilterValue', filterInput.value);
             filterGridItems();
             if(isKeywordAssignmentMode) applyInitialKeywordHighlights();
        });
    }
    if (clearButton) {
        clearButton.addEventListener('click', () => {
             if (filterInput) filterInput.value = '';
             localStorage.removeItem('gridFilterValue');
             filterGridItems();
             if(isKeywordAssignmentMode) applyInitialKeywordHighlights();
        });
    }
    adjustButtonPositions();
    window.addEventListener('resize', adjustButtonPositions);
    
    const openChatArea = document.getElementById('open-chat-area');
    if (openChatArea) {
        openChatArea.addEventListener('click', openChatModal);
    }
    updateTotalMessageCount(); 
    
    const userCountGlobe = document.getElementById('user-count-globe');
    if (userCountGlobe) {
        userCountGlobe.addEventListener('click', () => {
            showToast('Usuarios activos', 'info');
        });
        if (window.db && window.getDocs && window.collection) {
            const usersCollectionRef = window.collection(window.db, "user_data");
            window.getDocs(usersCollectionRef).then(snapshot => {
                userCountGlobe.textContent = snapshot.size;
            }).catch(error => {
                userCountGlobe.textContent = 'X';
            });
        }
    }

    await checkVersionsIconOpacity();

    document.body.addEventListener('click', function(event) {
        const target = event.target;
        const targetId = target.id || (target.closest('[id]') ? target.closest('[id]').id : null);
        if (targetId === 'config-close-modal') {
            const termsAcceptedForClose = localStorage.getItem('termsAccepted_v1') === 'true';
            if (!termsAcceptedForClose) {
                showToast('Debes aceptar las normas de uso para continuar.', 'warning');
                return;
            }
            const modal = document.getElementById('config-modal');
            if (modal && !modal.classList.contains('hidden')) {
                clearModalAutoCloseTimer(modal, target, 'config-modal');
                modal.classList.add('hidden');
                 const mapWasOpenBeforeConfig = sessionStorage.getItem('boardinggate_map_should_reopen_after_config') === 'true';
                 const mapContextToReopen = sessionStorage.getItem('mapContextToReopenAfterConfig');
                 sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');
                 sessionStorage.removeItem('mapContextToReopenAfterConfig');
                 if (mapWasOpenBeforeConfig && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !document.getElementById('reminders-location-map-modal')) {
                    if (mapContextToReopen === 'navigation') {
                        setTimeout(() => openNavigationMap(), 50);
                    }
                }
            }
        }
        if (target.matches('.config-tab-button')) {
            const modal = document.getElementById('config-modal');
            if(modal && modal.classList.contains('hidden') === false) {
                const tabTarget = target.dataset.tabTarget;
                modal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                modal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (modal.querySelector(tabTarget)) {
                    modal.querySelector(tabTarget).classList.add('active');
                }
            }
        }
        if (targetId === 'close-reminders-top' || targetId === 'close-reminders-bottom') {
            const modalTable = document.querySelector('.reminder-table-modal');
            if (modalTable) {
                if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                modalTable.remove();
                const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                const mapContext = sessionStorage.getItem('mapContext');
                sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                sessionStorage.removeItem('mapContext');
                if (fromReminderModal) {
                    fromReminderModal = false;
                    if (mapShouldReopen) {
                        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                        sessionStorage.setItem('mapContext', mapContext);
                    }
                    showReminderModal();
                } else if (mapShouldReopen) {
                     if (mapContext === 'navigation') openNavigationMap();
                }
            }
        }
        if (targetId === 'view-all-locations-map') {
            const modalTable = document.querySelector('.reminder-table-modal');
             if (modalTable && modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
             if (modalTable) modalTable.remove();
            setTimeout(() => {
                openLocationsPreviewMap();
            }, 50);
        }
         if (targetId === 'close-locations-preview') {
            const previewModal = document.getElementById('locations-preview-modal');
            if (previewModal) {
                if (locationsPreviewMap) {
                    try { locationsPreviewMap.remove(); } catch (e) {}
                    locationsPreviewMap = null;
                }
                if (mapLayersControlLocationsPreview) {
                    try {mapLayersControlLocationsPreview.remove();} catch(e){}
                    mapLayersControlLocationsPreview = null;
                }
                clearModalAutoCloseTimer(previewModal, target, 'locations-preview-modal');
                previewModal.classList.add('hidden');
            }
        }
        if (targetId === 'close-address-suggestions-modal') {
            hideAddressSuggestionsModal();
        }
    });
    const configModal = document.getElementById('config-modal');
    if (configModal) {
        configModal.addEventListener('click', function(event) {
            const target = event.target;
            if (target.matches('.config-tab-button')) {
                const tabTarget = target.dataset.tabTarget;
                configModal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                configModal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (configModal.querySelector(tabTarget)) {
                    configModal.querySelector(tabTarget).classList.add('active');
                }
            }
        });
    }
    const bookmarkGrid = document.getElementById('bookmark-grid');
    if (bookmarkGrid) {
        bookmarkGrid.addEventListener('click', function(event) {
            const link = event.target.closest('a.bookmark-item');
            if (link && link.href && link.href.startsWith("map-action:")) {
                event.preventDefault();
                const action = link.href.split(":")[1];
                if (action === "openRemindersMapWithNoRadars") {
                    closeOtherModals();
                    setTimeout(() => {
                        const existingPreviewModal = document.getElementById('locations-preview-modal');
                        if (existingPreviewModal && !existingPreviewModal.classList.contains('hidden')) {
                            showToast("El mapa de ubicaciones (sin radar) ya está abierto", "info");
                        } else {
                           openLocationsPreviewMap();
                        }
                    }, 50);
                } else if (action === "openRemindersMap") {
                    closeOtherModals();
                    setTimeout(() => {
                        const mapModalElement = document.getElementById('reminders-location-map-modal');
                        if (mapModalElement && !mapModalElement.classList.contains('hidden')) {
                            showToast("El mapa de navegación/ubicaciones ya está abierto", "info");
                            if (navigationMapInstance) {
                                requestAnimationFrame(() => {
                                    requestAnimationFrame(() => {
                                        if (navigationMapInstance) {
                                            try {
                                                 navigationMapInstance.resize();
                                             } catch (e) {  }
                                        }
                                    });
                                });
                            }
                        } else {
                           openNavigationMap();
                        }
                    }, 50);
                }
            }
        });
    }
    
    const accidentAlertButton = document.getElementById('accident-alert-button');
    if (accidentAlertButton) {
        accidentAlertButton.addEventListener('click', () => {
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
            openAlertModal();
        });
    }
}
// ===================================================================
// NOMBRE: showDeviationModal (VERSIÓN FINAL CON LÓGICA DUAL Y TEMPORIZADOR)
// RESUMEN: Muestra un modal diferente si la ruta es simple o multietapa.
//          Para rutas multietapa, incluye un temporizador de 10s que
//          selecciona "Ir a Destino Final" como acción por defecto.
// ===================================================================
function showDeviationModal() {
    if (isDeviationModalActive) return;
    console.log("[MODAL DESVÍO] Mostrando modal de opciones de desvío...");
    closeOtherModals('deviation-modal');
    isDeviationModalActive = true;
    let modal = document.getElementById('deviation-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'deviation-modal';
        document.body.appendChild(modal);
    }

    const actualWaypoints = navigationWaypoints.filter(wp => wp && !wp.isInternal && !wp.isRecalculatedStart);
    const unvisitedSelectableStages = actualWaypoints.filter(wp => !wp.visited && wp.type !== 'S' && wp.type !== 'S_Recalc' && wp.type !== 'F');
    const iconHtml = `<img src="PNG/APELIGRO.png" alt="Icono de Peligro" style="width: 115px; height: 70px; margin: 0 auto 10px auto; display: block;">`;

    // Lógica dual: Comprobar si hay etapas intermedias sin visitar
    if (unvisitedSelectableStages.length === 0) {
        // ESCENARIO 1: RUTA SIMPLE (o solo queda el destino final)
        console.log("[MODAL DESVÍO] Ruta simple detectada. Mostrando modal informativo y comenzando recálculo automático.");
        modal.innerHTML = `
            <style>
                #deviation-modal h2 { font-size: 1.5rem; margin-bottom: 10px; color: #333; }
                #deviation-modal p { font-size: 1.1rem; line-height: 1.4; margin-bottom: 15px; font-weight: bold; }
                #deviation-status-spinner { border: 4px solid rgba(0, 0, 0, 0.1); border-left-color: #28a745; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 0 auto; }
                @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
            </style>
            <h2>Desvío Detectado</h2>
            ${iconHtml}
            <p id="deviation-modal-message">Recalculando nueva ruta...</p>
            <div id="deviation-status-spinner"></div>
        `;
        modal.classList.remove('hidden');
        recalculateAndDrawRoute(true); // Inicia el bucle de recálculo automático

    } else {
        // ESCENARIO 2: RUTA MULTIETAPA con opciones para el usuario y temporizador
        console.log("[MODAL DESVÍO] Ruta multietapa detectada. Mostrando modal interactivo con temporizador.");
        const finalDestination = actualWaypoints[actualWaypoints.length - 1];
        const stageButtonsHtml = unvisitedSelectableStages.map(wp => {
            const addressSummary = wp.address ? (wp.address.split(',')[0].trim()) : `Etapa ${wp.label}`;
            return `<button class="deviation-stage-button" data-waypoint-id="${wp.id}">ETAPA ${wp.label}: ${addressSummary}</button>`;
        }).join('');

        modal.innerHTML = `
            <style>
                 #deviation-modal h2 { font-size: 1.5rem; margin-bottom: 10px; color: #333; flex-shrink: 0; }
                 #deviation-modal p { font-size: 1rem; line-height: 1.4; margin-bottom: 15px; flex-shrink: 0; font-weight: bold; }
                 #deviation-modal .deviation-options-container { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; }
                 #deviation-modal .stage-list-scroll-container { overflow-y: auto; display: flex; flex-direction: column; gap: 10px; padding: 10px; margin: 5px 0; border-top: 2px solid #C0B080; border-bottom: 2px solid #C0B080; background-color: rgba(0,0,0,0.05); border-radius: 6px; }
                 #deviation-modal #scroll-hint-text { font-size: 0.85rem; font-style: italic; color: #555; margin-top: 5px; margin-bottom: -5px; display: none; }
                 #deviation-modal button { padding: 12px 15px; border: none; border-radius: 5px; font-size: 1.1rem; font-weight: bold; cursor: pointer; transition: background-color 0.2s ease; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-shrink: 0; }
                 #deviation-modal #deviation-go-to-final { background-color: #28a745; color: white; margin-bottom: 5px; }
                 #deviation-modal .deviation-stage-button { background-color: #007bff; color: white; }
                 #deviation-modal #deviation-cancel { background-color: #6c757d; color: white; margin-top: 5px; }
            </style>
            <h2>Desvío Detectado</h2>
            ${iconHtml}
            <p>Elige tu próximo destino o se seleccionará el destino final automáticamente.</p>
            <div class="deviation-options-container">
                <button id="deviation-go-to-final">Ir a Destino Final (${finalDestination.address.split(',')[0].trim()}) <span class="button-countdown-timer"></span></button>
                <p id="scroll-hint-text"></p>
                <div class="stage-list-scroll-container">
                    ${stageButtonsHtml}
                </div>
                <button id="deviation-cancel">Cancelar (Seguir Desviado)</button>
            </div>
        `;
        modal.classList.remove('hidden');

        const goToFinalButton = document.getElementById('deviation-go-to-final');

        const clearDefaultActionTimer = () => {
            clearModalAutoCloseTimer(modal, goToFinalButton, 'deviation-modal-default-action');
        };

        goToFinalButton.addEventListener('click', (e) => {
            e.stopPropagation();
            clearDefaultActionTimer();
            handleFinalDestinationSelection();
        });

        document.querySelectorAll('.deviation-stage-button').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                clearDefaultActionTimer();
                const waypointId = parseInt(e.currentTarget.dataset.waypointId);
                handleStageSelectionFromDeviationModal(waypointId);
            });
        });

        document.getElementById('deviation-cancel').addEventListener('click', (e) => {
            e.stopPropagation();
            clearDefaultActionTimer();
            closeModalAndProceed();
        });
        
        // Iniciar el temporizador de 10 segundos como acción por defecto
        addModalAutoCloseTimer(modal, goToFinalButton, 'deviation-modal-default-action', 10000);

        const scrollContainer = modal.querySelector('.stage-list-scroll-container');
        const scrollHint = modal.querySelector('#scroll-hint-text');
        requestAnimationFrame(() => {
            if (scrollContainer.scrollHeight > scrollContainer.clientHeight) {
                scrollHint.textContent = `(Deslice para ver las ${unvisitedSelectableStages.length} etapas restantes)`;
                scrollHint.style.display = 'block';
            }
        });
    }
}

// ===================================================================
// NOMBRE: handleFinalDestinationSelection (NUEVA FUNCIÓN)
// RESUMEN: Maneja la lógica cuando el usuario elige ir al destino final.
// ===================================================================
async function handleFinalDestinationSelection() {
    const finalDestination = navigationWaypoints.find(wp => wp.type === 'F');
    const startPoint = navigationWaypoints.find(wp => wp.isRecalculatedStart || wp.type === 'S');

    if (!finalDestination || !startPoint) {
        showToast("Error: No se pudo determinar el inicio o el fin de la ruta.", "error");
        closeModalAndProceed();
        return;
    }

    navigationWaypoints = [startPoint, finalDestination];
    closeModalAndProceed();
    
    try {
        await recalculateAndDrawRoute(true, true);
        renderWaypointMarkers();
        deviationCheckGracePeriodUntil = Date.now() + 5000;
    } catch (error) {
        showToast("Error al recalcular la ruta hacia el destino final.", "error");
    }
}

// ===================================================================
// NOMBRE: handleStageSelectionFromDeviationModal (NUEVA FUNCIÓN)
// RESUMEN: Maneja la lógica cuando el usuario elige una etapa intermedia.
// ===================================================================
async function handleStageSelectionFromDeviationModal(selectedWaypointId) {
    const selectedIndex = navigationWaypoints.findIndex(wp => wp.id === selectedWaypointId);
    const startPoint = navigationWaypoints.find(wp => wp.isRecalculatedStart || wp.type === 'S');

    if (selectedIndex === -1 || !startPoint) {
        showToast("Error: No se encontró la etapa o el punto de inicio.", "error");
        closeModalAndProceed();
        return;
    }

    const newWaypoints = [startPoint];
    for (let i = selectedIndex; i < navigationWaypoints.length; i++) {
        const wp = navigationWaypoints[i];
        if (wp && !wp.isInternal && !wp.isRecalculatedStart) {
            newWaypoints.push(wp);
        }
    }
    
    navigationWaypoints = newWaypoints;
    closeModalAndProceed();
    
    try {
        await recalculateAndDrawRoute(true, true);
        renderWaypointMarkers();
        deviationCheckGracePeriodUntil = Date.now() + 5000;
    } catch (error) {
        showToast("Error al recalcular la ruta hacia la etapa seleccionada.", "error");
    }
}
    

// ===================================================================
// NOMBRE: OFFFrecalculateAndDrawRoute (VERSIÓN DEFINITIVA CON GESTIÓN DE ESTADO ATÓMICA)
// RESUMEN: Lógica de recálculo final que garantiza que todas las variables
async function OFFrecalculateAndDrawRoute(preserveAccumulatedStats = false, isUserAction = false) {
    const RETRY_CADENCE_MS = 3000;
    const MAX_RETRIES = 5; // Límite para evitar bucles infinitos
    let attempt = 1;

    // Bucle de reintento para máxima robustez ante fallos de red o del servidor
    while (attempt <= MAX_RETRIES) {
        // Solo continuamos el bucle si el modal de desvío sigue activo, o si es el primer intento
        if (!isDeviationModalActive && attempt > 1) break;
        
        console.log(`[RECALC] Intento #${attempt} de ${MAX_RETRIES}...`);
        isRecalculatingRoute = true;
        const wasNavigatingBeforeRecalc = isNavigating;

        try {
            const completedDistance = preserveAccumulatedStats ? totalDistanceTravelledForStats : 0;

            let waypointsForAPI = [];
            let currentHeading = null;
            
            // --- INICIO DE LA MODIFICACIÓN CLAVE: DIFERENCIAR PLANIFICACIÓN Y NAVEGACIÓN ---
            
            // Si NO estamos navegando (es decir, estamos en modo planificación),
            // la ruta SIEMPRE debe calcularse desde el primer waypoint de la lista,
            // ignorando la posición GPS actual. Esto corrige el bug al añadir múltiples etapas.
            if (!isNavigating) {
                console.log("[RECALC] Modo Planificación: Calculando ruta desde la lista de waypoints definida.");
                waypointsForAPI = [...navigationWaypoints];
                currentHeading = null; // No usamos el rumbo del coche para la planificación
            } else { 
                // La lógica original para cuando SÍ estamos navegando (recalculando por desvío)
                console.log("[RECALC] Modo Navegación Activa: Recalculando desde la posición GPS actual.");
                if (navigationCurrentLocation) {
                    currentHeading = navigationCurrentLocation.heading;
                    waypointsForAPI.push({ lat: navigationCurrentLocation.latitude, lng: navigationCurrentLocation.longitude, isRecalculatedStart: true });
                    waypointsForAPI.push(...navigationWaypoints.filter(wp => !wp.visited));
                } else {
                    // Fallback si perdemos el GPS durante la navegación: usamos la lista tal cual
                    waypointsForAPI = [...navigationWaypoints];
                }
            }
            // --- FIN DE LA MODIFICACIÓN CLAVE ---

            const validWaypoints = waypointsForAPI.filter(wp => wp && typeof wp.lat === 'number' && typeof wp.lng === 'number');
            if (validWaypoints.length < 2) { 
                isRecalculatingRoute = false; 
                return; // No hay suficientes puntos para una ruta
            };

            const coordsString = validWaypoints.map(wp => `${wp.lng},${wp.lat}`).join(';');
            
            const result = await fetchRouteData(coordsString, currentHeading);
            if (result.error) throw result.error;

            const newRouteData = result.routeData;
            const newRemainingRoute = newRouteData.routes[0];

            // --- INICIO DE LA SOLUCIÓN: Guardia de Calidad Contextual v2 ---
            // Comprueba si la ruta devuelta tiene una distancia sospechosamente corta.
            if (newRemainingRoute && newRemainingRoute.distance < 10) { // Umbral de 10m por flexibilidad
                
                // ANTES de rechazarla, verificamos si es una llegada legítima.
                const startPointOfRecalc = validWaypoints[0]; // Nuestra posición GPS actual
                const endPointOfRecalc = validWaypoints[validWaypoints.length - 1]; // El destino de este cálculo
                
                // Calculamos la distancia física (en línea recta) al destino.
                const physicalDistanceToDestination = calculateDistance(
                    startPointOfRecalc.lat, 
                    startPointOfRecalc.lng, 
                    endPointOfRecalc.lat, 
                    endPointOfRecalc.lng
                );

                // SOLO si la ruta es "cero" PERO estamos lejos del destino, es un error.
                if (physicalDistanceToDestination > WAYPOINT_VISITED_THRESHOLD_METERS) { // 70 metros
                    console.warn(`[GUARDIA DE CALIDAD] Ruta de distancia cero (${newRemainingRoute.distance.toFixed(1)}m) recibida, pero la distancia física al destino es de ${physicalDistanceToDestination.toFixed(1)}m. Forzando reintento.`);
                    throw new Error("Ruta inválida (distancia cero) recibida del servidor.");
                }
                // Si no se cumple la condición, significa que la distancia es cero porque
                // realmente hemos llegado, por lo que permitimos que la ruta continúe.
            }
            // --- FIN DE LA SOLUCIÓN ---

            await drawRouteOnMap(newRemainingRoute);
            
            navigationCurrentRouteData = newRouteData;
            
            if (preserveAccumulatedStats) {
                accumulatedDistanceBeforeCurrentSegment = completedDistance;
            }

            tripInitialOverallEtaTime = new Date(Date.now() + newRemainingRoute.duration * 1000);
            if (newRemainingRoute.legs && newRemainingRoute.legs.length > 0) {
                currentStageInitialExpectedEtaTime = new Date(Date.now() + newRemainingRoute.legs[0].duration * 1000);
            } else {
                currentStageInitialExpectedEtaTime = null;
            }

            renderWaypointMarkers();
            updateNavigationProgressDisplay(newRemainingRoute, 0);
            updateTurnByTurnDisplay(newRemainingRoute, 0);
            showDestinationName();
            toggleRadaresRuta(document.getElementById('radares-ruta-checkbox').checked);
            toggleTareasRuta(document.getElementById('tareas-ruta-checkbox').checked);
            updateStartNavigationButtonState();
            updateNavigationButtonColor();

            showToast("¡Ruta recalculada con éxito!", "success");
            closeModalAndProceed();
            return; // Salimos de la función con éxito
            
        } catch (error) {
            console.error(`[RECALC] Fallo en intento #${attempt}:`, error);
            if (attempt === MAX_RETRIES) {
                showToast("Fallo al recalcular la ruta tras varios intentos. Comprueba tu conexión.", "error");
                closeModalAndProceed(); // Cerrar el modal para no bloquear al usuario
            } else {
                showToast(`Error al recalcular (${attempt}/${MAX_RETRIES}). Reintentando...`, "warning");
                await new Promise(resolve => setTimeout(resolve, RETRY_CADENCE_MS));
            }
        } finally {
            isRecalculatingRoute = false; // Se resetea en cada intento
            isNavigating = wasNavigatingBeforeRecalc;
            attempt++;
        }
    }
    console.log("[RECALC] Bucle de recálculo finalizado sin éxito.");
}    




// ===================================================================
// NOMBRE: recalculateAndDrawRoute (VERSIÓN DEFINITIVA CON GESTIÓN DE ESTADO ATÓMICA)
// RESUMEN: Lógica de recálculo final que garantiza que todas las variables
async function recalculateAndDrawRoute(preserveAccumulatedStats = false, isUserAction = false) {
    const RETRY_CADENCE_MS = 3000;
    const MAX_RETRIES = 5; // Límite para evitar bucles infinitos
    let attempt = 1;

    // Bucle de reintento para máxima robustez ante fallos de red o del servidor
    while (attempt <= MAX_RETRIES) {
        // Solo continuamos el bucle si el modal de desvío sigue activo, o si es el primer intento
        if (!isDeviationModalActive && attempt > 1) break;
        
        console.log(`[RECALC] Intento #${attempt} de ${MAX_RETRIES}...`);
        isRecalculatingRoute = true;
        const wasNavigatingBeforeRecalc = isNavigating;

        try {
            // <<< INICIO DE LA CORRECCIÓN CLAVE: USO DIRECTO DE LA VARIABLE DE ESTADO >>>
            // En lugar de recalcular, usamos directamente la distancia total que ya hemos registrado.
            // Esta es la "fuente de verdad" del progreso del viaje.
            const completedDistance = preserveAccumulatedStats ? totalDistanceTravelledForStats : 0;
            // <<< FIN DE LA CORRECCIÓN CLAVE >>>

            let waypointsForAPI = [];
            let currentHeading = null;
            
            // --- Lógica de planificación vs. navegación (sin cambios) ---
            if (!isNavigating) {
                console.log("[RECALC] Modo Planificación: Calculando ruta desde la lista de waypoints definida.");
                waypointsForAPI = [...navigationWaypoints];
                currentHeading = null;
            } else { 
                console.log("[RECALC] Modo Navegación Activa: Recalculando desde la posición GPS actual.");
                if (navigationCurrentLocation) {
                    currentHeading = navigationCurrentLocation.heading;
                    waypointsForAPI.push({ lat: navigationCurrentLocation.latitude, lng: navigationCurrentLocation.longitude, isRecalculatedStart: true });
                    waypointsForAPI.push(...navigationWaypoints.filter(wp => !wp.visited));
                } else {
                    waypointsForAPI = [...navigationWaypoints];
                }
            }
            // --- Fin de la lógica ---

            const validWaypoints = waypointsForAPI.filter(wp => wp && typeof wp.lat === 'number' && typeof wp.lng === 'number');
            if (validWaypoints.length < 2) { 
                isRecalculatingRoute = false; 
                return;
            };

            const coordsString = validWaypoints.map(wp => `${wp.lng},${wp.lat}`).join(';');
            
            const result = await fetchRouteData(coordsString, currentHeading);
            if (result.error) throw result.error;

            const newRouteData = result.routeData;
            const newRemainingRoute = newRouteData.routes[0];

            // --- Guardia de Calidad (sin cambios) ---
            if (newRemainingRoute && newRemainingRoute.distance < 10) { 
                const startPointOfRecalc = validWaypoints[0];
                const endPointOfRecalc = validWaypoints[validWaypoints.length - 1];
                const physicalDistanceToDestination = calculateDistance(
                    startPointOfRecalc.lat, 
                    startPointOfRecalc.lng, 
                    endPointOfRecalc.lat, 
                    endPointOfRecalc.lng
                );
                if (physicalDistanceToDestination > WAYPOINT_VISITED_THRESHOLD_METERS) {
                    console.warn(`[GUARDIA DE CALIDAD] Ruta de distancia cero (${newRemainingRoute.distance.toFixed(1)}m) recibida, pero la distancia física al destino es de ${physicalDistanceToDestination.toFixed(1)}m. Forzando reintento.`);
                    throw new Error("Ruta inválida (distancia cero) recibida del servidor.");
                }
            }
            // --- Fin de la Guardia de Calidad ---

            await drawRouteOnMap(newRemainingRoute);
            
            navigationCurrentRouteData = newRouteData;
            
            // <<< INICIO DE LA CORRECCIÓN CLAVE: REINICIO ATÓMICO DEL ESTADO >>>
            // Después de obtener la nueva ruta (sin importar el proveedor),
            // forzamos un reinicio limpio de las variables que dependen de la
            // estructura interna de la ruta.
            
            if (preserveAccumulatedStats) {
                // Preservamos el progreso real del viaje.
                accumulatedDistanceBeforeCurrentSegment = completedDistance;
            } else {
                // Si no se preservan (inicio de nueva ruta), se resetean.
                accumulatedDistanceBeforeCurrentSegment = 0;
            }

            // Reseteamos los "punteros" que leen la estructura de la ruta.
            // Ahora leerán desde el principio del "nuevo libro".
            currentLegIndexNav = 0;
            currentStepIndexNav = 0;
            lastProcessedStepIdentifier = null;
            lastProcessedStepForLock = null;
            lastDisplayedManeuverIcon = null;

            // La "promesa" del ETA de la siguiente etapa se recalcula basándose
            // en los datos frescos de la nueva ruta. El ETA final no se toca aquí.
            if (newRemainingRoute.legs && newRemainingRoute.legs.length > 0) {
                currentStageInitialExpectedEtaTime = new Date(Date.now() + newRemainingRoute.legs[0].duration * 1000);
            } else {
                currentStageInitialExpectedEtaTime = null;
            }
            // <<< FIN DE LA CORRECCIÓN CLAVE >>>
            
            renderWaypointMarkers();
            updateNavigationProgressDisplay(newRemainingRoute, 0); // Se llama con progreso 0 en el *nuevo* tramo
            updateTurnByTurnDisplay(newRemainingRoute, 0); // Igual aquí
            showDestinationName();
            toggleRadaresRuta(document.getElementById('radares-ruta-checkbox').checked);
            toggleTareasRuta(document.getElementById('tareas-ruta-checkbox').checked);
            updateStartNavigationButtonState();
            updateNavigationButtonColor();

            showToast("¡Ruta recalculada con éxito!", "success");
            closeModalAndProceed();
            return; // Salimos de la función con éxito
            
        } catch (error) {
            console.error(`[RECALC] Fallo en intento #${attempt}:`, error);
            if (attempt === MAX_RETRIES) {
                showToast("Fallo al recalcular la ruta tras varios intentos. Comprueba tu conexión.", "error");
                closeModalAndProceed();
            } else {
                showToast(`Error al recalcular (${attempt}/${MAX_RETRIES}). Reintentando...`, "warning");
                await new Promise(resolve => setTimeout(resolve, RETRY_CADENCE_MS));
            }
        } finally {
            isRecalculatingRoute = false;
            isNavigating = wasNavigatingBeforeRecalc;
            attempt++;
        }
    }
    console.log("[RECALC] Bucle de recálculo finalizado sin éxito.");
}




    
// ===================================================================
// NOMBRE: closeModalAndProceed (MODIFICADA)
// RESUMEN: Cierra el modal de desvío y llama a la reanudación de simulación.
// ===================================================================
function closeModalAndProceed() {
    isDeviationModalActive = false;
    deviationStartTime = 0;
    const modal = document.getElementById('deviation-modal');
    if (modal) {
        modal.classList.add('hidden');
    }

    if (wasSimulatingBeforeRecalc) {
        wasSimulatingBeforeRecalc = false; // Se resetea la bandera
//      simulatedDistanceAlongRoute = 0; 
        showToast("Desvío recalculado. Reanudando simulación...", "info");
        setTimeout(() => {
            // ¡CAMBIO CLAVE! Pasamos 'true' para indicar que es una reanudación.
            startAutomatedRouteSimulation(currentSimulationSpeedKmph, true); 
        }, 100);
    }
}

// ===================================================================
// NOMBRE: handleLocateMeClick (VERSIÓN CORREGIDA SIN INTERFERENCIAS)
// RESUMEN: Gestiona el clic en "Estás Aquí" sin tocar ninguna variable de memoria de zoom.
// ===================================================================
function handleLocateMeClick(isExplicitAction = false) {
    if (!navigationMapInstance) return;

    clearLocateMeReactivationTimer();
    isManualZoomActive = false;
    
    navigationFollowUser = !navigationFollowUser;
    shouldCenterOnUser = navigationFollowUser;

    if (navigationFollowUser) {
    
        if (navigationCurrentLocation) {
            const viewOptions = {
                center: [navigationCurrentLocation.longitude, navigationCurrentLocation.latitude],
                zoom: 17, // Este botón siempre usará un zoom fijo de 17.
                essential: true
            };

            const mode = mapViewMode || 'static';
            if(mode === 'heading' || mode === 'perspective') {
                viewOptions.bearing = navigationCurrentLocation.heading || 0;
            }
            if(mode === 'perspective') {
                viewOptions.pitch = mapPitchValue;
            } else {
                viewOptions.pitch = 0;
            }
            navigationMapInstance.flyTo(viewOptions);

        } else {
            getCurrentLocation(coords => {
                if (navigationMapInstance) {
                     navigationMapInstance.flyTo({ center: [coords.longitude, coords.latitude], zoom: 17 });
                }
                updateInitialUserPosition(coords, navigationMapInstance);
            }, () => showToast("No se pudo obtener tu ubicación.", "warning"));
        }
    } else {
        
        mapPreviousZoomLevel = navigationMapInstance.getZoom();
        
        if (!isExplicitAction) {
            startLocateMeReactivationTimer();
        }
    }
    
    updateLocateMeButtonsUI();
    updateStartNavigationButtonState();
}    

    
// ===================================================================
// NOMBRE: preflightSync (NUEVA FUNCIÓN)
// RESUMEN: Se ejecuta ANTES de que se cargue la app. Comprueba si hay datos más nuevos en la nube
async function preflightSync() {
    const autoSyncEnabled = JSON.parse(localStorage.getItem('boardinggate_autoBackupOnLoad') || 'false');
    const { primaryId, isMobile } = parseUserId(localStorage.getItem('userData_userId'));
    const backupPassword = localStorage.getItem('userData_backupPassword');

    if (!autoSyncEnabled || !primaryId || isMobile || !backupPassword) {
        return;
    }

    try {
        const result = await callFirebase('getUserData', { userId: primaryId });

        if (result.status === 'success' && result.data) {
            const cloudTimestamp = new Date(result.data.fechaBackup || 0).getTime();
            const localTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');

            if (cloudTimestamp > localTimestamp + 10000) { // 10s de margen
                const backupCacheData = result.data.contenidoCacheCompleto;
                if (backupCacheData) {
                    showToast('Sincronizando datos desde la nube...', 'info', 3000);

                    const currentUserIdentity = localStorage.getItem('userData_userId') || primaryId;
                    for (const key in backupCacheData) {
                        if (backupCacheData.hasOwnProperty(key) && managedKeys.includes(key)) {
                            localStorage.setItem(key, backupCacheData[key]);
                        }
                    }
                    if (currentUserIdentity) {
                        localStorage.setItem('userData_userId', currentUserIdentity);
                    }
                    localStorage.setItem('lastCacheUpdateTimestamp', Date.now().toString());
                } else {
                 }
            } else {
                 }
        } else {
             }
    } catch (error) {
        }
   }

// ===================================================================
// NOMBRE: uploadDirtyCacheOnLoad_Car (MODIFICADA)
// RESUMEN: Función específica para el COCHE. Al cargar, si los datos locales son más nuevos, los sube a la nube.
async function uploadDirtyCacheOnLoad_Car() {
    const autoSyncEnabled = JSON.parse(localStorage.getItem('boardinggate_autoBackupOnLoad') || 'false');
    const { primaryId, isMobile } = parseUserId(localStorage.getItem('userData_userId'));
    const backupPassword = localStorage.getItem('userData_backupPassword');

    if (!autoSyncEnabled || !primaryId || isMobile || !backupPassword) {
        return;
    }

    console.log(`Sync on Load: Checking if local data for ${primaryId} needs to be uploaded.`);
    const result = await callFirebase('getUserData', { userId: primaryId });

    if (result.status === 'success' && result.data) {
        const cloudTimestamp = new Date(result.data.fechaBackup || 0).getTime();
        const localTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0');

        if (localTimestamp > cloudTimestamp + 10000) { // Si local es más nuevo, subimos
            showToast(`Subiendo cambios locales de ${primaryId} a la nube...`, 'info', 4000);
            await autoSaveFromMobile(primaryId, backupPassword); // Reutilizamos la función de guardado
        }
    } else if (result.status === 'not_found') { // Si no hay nada en la nube, subimos lo local
        showToast(`Creando primer backup en la nube para ${primaryId}...`, 'info', 4000);
        await autoSaveFromMobile(primaryId, backupPassword);
    }
}

// ===================================================================
// NOMBRE: autoSaveFromMobile
// RESUMEN: Realiza un guardado automático en Firebase, llamado por checkReminders para usuarios móviles.
async function autoSaveFromMobile(primaryId, backupPassword) {
    const cacheData = {};
    managedKeys.forEach(key => {
        const value = localStorage.getItem(key);
        if (value !== null) cacheData[key] = value;
    });
    const saveData = {
        userId: primaryId,
        usuario: primaryId,
        modelo: localStorage.getItem('userData_teslaModel') || '',
        anio: localStorage.getItem('userData_teslaYear') || '',
        provincia: localStorage.getItem('userData_teslaProvince') || '',
        rss: JSON.parse(localStorage.getItem('userData_allowDMs') || 'false'),
        datosCache: cacheData,
        backupPassword: backupPassword,
        fechaBackup: new Date().toISOString()
    };
    const saveResult = await callFirebase('saveUser', saveData);
    const toast = document.getElementById('mobile-autosave');
    if(toast) toast.remove();
    if (saveResult.status === 'success') {
        showToast('Cambios sincronizados con la nube.', 'success');
        // Actualizamos el timestamp de la última sincronización para que no vuelva a guardar inmediatamente
        lastMobileSyncTimestamp = parseInt(localStorage.getItem('lastCacheUpdateTimestamp') || '0'); 
    } else {
        showToast(`Error al sincronizar: ${saveResult.message}`, 'error');
    }
}

// ===================================================================
// NOMBRE: DOMContentLoaded (MODIFICADO)
// RESUMEN: Punto de entrada principal. Ahora espera a la sincronización pre-vuelo ANTES de inicializar la app.
document.addEventListener('DOMContentLoaded', async () => {
     // 1. precargar ubicacion coche y Realiza la comprobación y posible descarga de datos antes de hacer nada más.
    preloadGpsLocation(); 
    await preflightSync();
     
     // 2. Una vez que el localStorage está actualizado, procede con la lógica de renderizado normal.
     storedPin = localStorage.getItem('password_pin');
     const savedPasswordActive = localStorage.getItem('password_active');
     isPasswordActive = savedPasswordActive ? JSON.parse(savedPasswordActive) : false;
     const initialDirectToNavPref = JSON.parse(localStorage.getItem(DIRECT_TO_NAVIGATION_KEY)) || false;
     const tempPreventDirectNav = sessionStorage.getItem(TEMP_PREVENT_DIRECT_NAV_KEY);

     if (isPasswordActive && storedPin && !(initialDirectToNavPref && !tempPreventDirectNav)) {
         promptForPin();
     } else {
         await initializeApp();
     }

    assignMapButtonListeners();
    document.body.addEventListener('click', function(event) {
        const target = event.target;
        const targetId = target.id || (target.closest('[id]') ? target.closest('[id]').id : null);

        if (targetId === 'config-close-modal') {
            const termsAcceptedForClose = localStorage.getItem('termsAccepted_v1') === 'true';
            if (!termsAcceptedForClose) {
                showToast('Debes aceptar las normas de uso para continuar.', 'warning');
                return;
            }
            const modal = document.getElementById('config-modal');
            if (modal && !modal.classList.contains('hidden')) {
                clearModalAutoCloseTimer(modal, target, 'config-modal');
                modal.classList.add('hidden');
                 const mapWasOpenBeforeConfig = sessionStorage.getItem('boardinggate_map_should_reopen_after_config') === 'true';
                 const mapContextToReopen = sessionStorage.getItem('mapContextToReopenAfterConfig');
                 sessionStorage.removeItem('boardinggate_map_should_reopen_after_config');
                 sessionStorage.removeItem('mapContextToReopenAfterConfig');
                 if (mapWasOpenBeforeConfig && !document.getElementById('unified-reminder-window')?.classList.contains('visible') && !document.getElementById('reminders-location-map-modal')) {
                    if (mapContextToReopen === 'navigation') {
                        setTimeout(() => openNavigationMap(), 50);
                    }
                }
            }
        }
        if (target.matches('.config-tab-button')) {
            const modal = document.getElementById('config-modal');
            if(modal && modal.classList.contains('hidden') === false) {
                const tabTarget = target.dataset.tabTarget;
                modal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                modal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (modal.querySelector(tabTarget)) {
                    modal.querySelector(tabTarget).classList.add('active');
                }
            }
        }
        if (targetId === 'close-reminders-top' || targetId === 'close-reminders-bottom') {
            const modalTable = document.querySelector('.reminder-table-modal');
            if (modalTable) {
                if (modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
                modalTable.remove();
                const mapShouldReopen = sessionStorage.getItem('boardinggate_map_was_open_before_table') === 'true';
                const mapContext = sessionStorage.getItem('mapContext');
                sessionStorage.removeItem('boardinggate_map_was_open_before_table');
                sessionStorage.removeItem('mapContext');
                if (fromReminderModal) {
                    fromReminderModal = false;
                    if (mapShouldReopen) {
                        sessionStorage.setItem('boardinggate_map_should_reopen_after_form', 'true');
                        sessionStorage.setItem('mapContext', mapContext);
                    }
                    showReminderModal();
                } else if (mapShouldReopen) {
                     if (mapContext === 'navigation') openNavigationMap();
                }
            }
        }
        if (targetId === 'view-all-locations-map') {
            const modalTable = document.querySelector('.reminder-table-modal');
             if (modalTable && modalTable.autoCloseInterval) clearInterval(modalTable.autoCloseInterval);
             if (modalTable) modalTable.remove();
            setTimeout(() => {
                openLocationsPreviewMap();
            }, 50);
        }
         if (targetId === 'close-locations-preview') {
            const previewModal = document.getElementById('locations-preview-modal');
            if (previewModal) {
                if (locationsPreviewMap) {
                    try { locationsPreviewMap.remove(); } catch (e) {}
                    locationsPreviewMap = null;
                }
                if (mapLayersControlLocationsPreview) {
                    try {mapLayersControlLocationsPreview.remove();} catch(e){}
                    mapLayersControlLocationsPreview = null;
                }
                clearModalAutoCloseTimer(previewModal, target, 'locations-preview-modal');
                previewModal.classList.add('hidden');
            }
        }
        if (targetId === 'close-address-suggestions-modal') {
            hideAddressSuggestionsModal();
        }
    });
   const configModal = document.getElementById('config-modal');
    if (configModal) {
        configModal.addEventListener('click', function(event) {
            const target = event.target;
            if (target.matches('.config-tab-button')) {
                const tabTarget = target.dataset.tabTarget;
                configModal.querySelectorAll('.config-tab-button').forEach(btn => btn.classList.remove('active'));
                configModal.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                if (configModal.querySelector(tabTarget)) {
                    configModal.querySelector(tabTarget).classList.add('active');
                }
            }
        });
    }
    const bookmarkGrid = document.getElementById('bookmark-grid');
    if (bookmarkGrid) {
        bookmarkGrid.addEventListener('click', function(event) {
            const link = event.target.closest('a.bookmark-item');
            if (link && link.href && link.href.startsWith("map-action:")) {
                event.preventDefault();
                const action = link.href.split(":")[1];
                if (action === "openRemindersMapWithNoRadars") {
                    closeOtherModals();
                    setTimeout(() => {
                        const existingPreviewModal = document.getElementById('locations-preview-modal');
                        if (existingPreviewModal && !existingPreviewModal.classList.contains('hidden')) {
                            showToast("El mapa de ubicaciones (sin radar) ya está abierto", "info");
                        } else {
                           openLocationsPreviewMap();
                        }
                    }, 50);
                } else if (action === "openRemindersMap") {
                    closeOtherModals();
                    setTimeout(() => {
                        const mapModalElement = document.getElementById('reminders-location-map-modal');
                        if (mapModalElement && !mapModalElement.classList.contains('hidden')) {
                            showToast("El mapa de navegación/ubicaciones ya está abierto", "info");
                            if (navigationMapInstance) {
                                requestAnimationFrame(() => {
                                    requestAnimationFrame(() => {
                                        if (navigationMapInstance) {
                                            try {
                                                 navigationMapInstance.resize();
                                             } catch (e) {  }
                                        }
                                    });
                                });
                            }
                        } else {
                           openNavigationMap();
                        }
                    }, 50);
                }
            }
        });
    }
    
    const accidentAlertButton = document.getElementById('accident-alert-button');
    if (accidentAlertButton) {
        accidentAlertButton.addEventListener('click', () => {
            if (isEditMode || isAssignmentMode || isKeywordAssignmentMode) return;
            openAlertModal();
        });
    }

     window.addEventListener('beforeunload', () => {
         if (reminderCheckIntervalId) { clearInterval(reminderCheckIntervalId); }
         if (locationWatchId !== null && navigator.geolocation) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
         if (editingTargetElement) { editingTargetElement.classList.remove('editing-target'); editingTargetElement = null; }
         const openReminderModal = document.querySelector('.reminder-modal');
         if (openReminderModal && typeof openReminderModal.cleanUpModalTimers === 'function') { openReminderModal.cleanUpModalTimers(true); }
         Object.keys(globalModalTimers).forEach(modalId => {
            const timerData = globalModalTimers[modalId];
            if (timerData) {
                clearModalAutoCloseTimer(timerData.modalElement, timerData.closeButtonElement, modalId);
            }
         });
         globalModalTimers = {};
         const openTableModal = document.querySelector('.reminder-table-modal');
         if(openTableModal && openTableModal.autoCloseInterval) { clearInterval(openTableModal.autoCloseInterval); }
         const openPostponeModal = document.getElementById('postpone-options-modal');
         if(openPostponeModal && openPostponeModal.autoPostponeInterval) { clearInterval(openPostponeModal.autoPostponeInterval); }
         const openSavedLocationsModal = document.querySelector('.saved-locations-modal');
         if (openSavedLocationsModal && locationPickerMap) { try { locationPickerMap.remove(); } catch(e){} locationPickerMap = null; locationPickerMarker = null; }
         const simModalUnload = document.getElementById('simulation-modal');
         if (simModalUnload && simulationModalTimer) clearTimeout(simulationModalTimer);
         if (autoStartNavTimer) clearTimeout(autoStartNavTimer);
         if (isNavigationMapActive || navigationMapInstance) {
            closeNavigationMap(true);
         }
         if (locationsPreviewMap) {
             try { locationsPreviewMap.remove(); } catch(e){}
             locationsPreviewMap = null;
         }
         if (isAssignmentMode || isEditMode || isKeywordAssignmentMode) { saveCustomData(); }
         const filterInput = document.getElementById('grid-filter-input');
         if (filterInput && filterInput.value.trim()) {
              localStorage.setItem('gridFilterValue', filterInput.value);
         } else {
              localStorage.removeItem('gridFilterValue');
         }
          saveSettings();
          if (reminderModalMap) try {reminderModalMap.remove();} catch(e){}
          Object.values(previewMaps).forEach(map => {try {map?.remove();} catch(e){}});
          if (intersectionPreviewMap) try {intersectionPreviewMap.remove();} catch(e){}
          if (navigationChart) navigationChart.destroy();
          if (graphIntervalTimer) clearInterval(graphIntervalTimer);
     });
});

</script> 
<div id="map-garage" style="display: none;"></div>            
</body>
</html>
