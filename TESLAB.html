// Añade estas variables globales al inicio del script
let customToggleConfigs = {}; // Objeto para guardar las configuraciones personalizadas
let isConfigMode = false;     // Flag para saber si estamos en modo configuración
let currentConfiguringToggle = null; // Qué toggle estamos configurando
let currentConfigIndices = []; // Índices seleccionados temporalmente

// Modifica la definición de toggleRanges para incluir un id único
const toggleRanges = [
    { id: "toggle-pdr", start: 18, end: 29, defaultLabel: "PdR,s" },
    { id: "toggle-ias", start: 30, end: 41, defaultLabel: "iAs" },
    { id: "toggle-util", start: 42, end: 59, defaultLabel: "Útil" },
    { id: "toggle-varios", start: 60, end: 95, defaultLabel: "Varios" }
];

// *** EN LA FUNCIÓN loadSavedSettings ***
// Añade esto DENTRO de la función loadSavedSettings, antes de crear los botones toggle
loadCustomToggleConfigs();
// Asegúrate de que los botones toggle se crean DESPUÉS de cargar las configs


// *** REEMPLAZA el listener de configButton ***
configButton.addEventListener('click', () => {
    if (isMinimalMode || isConfigMode) return;
    showConfigMenu();
});

// *** AÑADE estas NUEVAS FUNCIONES ***

function loadCustomToggleConfigs() {
    const savedConfigs = localStorage.getItem('customToggleConfigs');
    if (savedConfigs) {
        try {
            customToggleConfigs = JSON.parse(savedConfigs);
            // Validar un poco la estructura si es necesario
            if (typeof customToggleConfigs !== 'object' || customToggleConfigs === null) {
                 customToggleConfigs = {};
            }
        } catch (e) {
            console.error("Error parsing customToggleConfigs from localStorage", e);
            customToggleConfigs = {};
        }
    } else {
        customToggleConfigs = {};
    }
    console.log("Loaded custom configs:", customToggleConfigs);
}

function saveCustomToggleConfigs() {
    localStorage.setItem('customToggleConfigs', JSON.stringify(customToggleConfigs));
    console.log("Saved custom configs:", customToggleConfigs);
}

function showConfigMenu() {
    isConfigMode = true;
    document.body.classList.add('config-mode');

    const overlay = document.createElement('div');
    overlay.className = 'config-overlay';
    overlay.id = 'config-overlay';

    const modal = document.createElement('div');
    modal.className = 'config-modal';

    modal.innerHTML = `
        <h2>Configuración</h2>
        <p>Seleccione una opción:</p>
        <button id="config-customize-toggles">Personalizar Filtros</button>
        <button id="config-clear-cache">Borrar Caché y Recargar</button>
        <button id="config-reset-toggles">Restaurar Filtros Predeterminados</button>
        <hr style="margin: 1rem 0;">
        <button id="config-cancel" class="cancel-button">Cancelar</button>
    `;

    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    document.getElementById('config-customize-toggles').onclick = showToggleSelectionMenu;
    document.getElementById('config-clear-cache').onclick = () => {
        localStorage.clear();
        location.reload();
    };
    document.getElementById('config-reset-toggles').onclick = () => {
        if (confirm('¿Está seguro de que desea restaurar todos los filtros a sus valores predeterminados?')) {
            customToggleConfigs = {};
            saveCustomToggleConfigs();
            alert('Filtros restaurados. Recargando...');
            location.reload();
        }
    };
    document.getElementById('config-cancel').onclick = exitConfigurationMode;
}

function showToggleSelectionMenu() {
    const modal = document.querySelector('.config-modal');
    if (!modal) return;

    let toggleButtonsHTML = toggleRanges.map(range => {
        const currentConfig = customToggleConfigs[range.id] || {};
        const currentLabel = currentConfig.label || range.defaultLabel;
        return `<button class="config-toggle-button" data-toggle-id="${range.id}">${currentLabel}</button>`;
    }).join('');

    modal.innerHTML = `
        <h2>Personalizar Filtros</h2>
        <p>Seleccione el filtro que desea modificar:</p>
        <div>${toggleButtonsHTML}</div>
        <hr style="margin: 1rem 0;">
        <button id="config-back" class="cancel-button">Volver</button>
    `;

    modal.querySelectorAll('.config-toggle-button').forEach(button => {
        button.onclick = () => startToggleConfiguration(button.dataset.toggleId);
    });
    document.getElementById('config-back').onclick = showConfigMenu; // Vuelve al menú anterior
}

function startToggleConfiguration(toggleId) {
    currentConfiguringToggle = toggleId;
    const rangeInfo = toggleRanges.find(r => r.id === toggleId);
    const currentConfig = customToggleConfigs[toggleId] || {};
    const currentLabel = currentConfig.label || rangeInfo.defaultLabel;
    const currentIndices = currentConfig.itemIndices || getDefaultIndices(rangeInfo);

    currentConfigIndices = [...currentIndices]; // Copia para edición

    const modal = document.querySelector('.config-modal');
    if (!modal) return;

    // 1. Pedir nueva etiqueta
    const newLabel = prompt(`Ingrese la nueva etiqueta para "${currentLabel}" (máx 6 letras):`, currentLabel);

    if (newLabel === null) return; // El usuario canceló el prompt

    const validatedLabel = newLabel.trim().substring(0, 6);
    if (!validatedLabel) {
        alert("La etiqueta no puede estar vacía.");
        return;
    }

    // 2. Preparar interfaz de selección de items
    modal.innerHTML = `
        <h2>Configurando: ${validatedLabel}</h2>
        <p>Pulse sobre los iconos del grid para añadirlos o quitarlos de este grupo.</p>
        <p>Los elementos seleccionados se marcarán con un borde azul.</p>
        <div style="margin-top: 1rem;">
             <button id="config-save-group">Guardar Grupo "${validatedLabel}"</button>
             <button id="config-cancel-group" class="cancel-button">Cancelar Cambios</button>
        </div>
    `;

    document.body.classList.add('selecting-items-mode');
    grid.scrollIntoView({ behavior: 'smooth', block: 'start' }); // Muestra el grid

    // Resaltar los items actualmente seleccionados y añadir listeners
    cellElements.forEach((cell, index) => {
        cell.classList.remove('config-selected'); // Limpia selecciones previas
        // Solo permite seleccionar celdas que no estén vacías
        const isEmpty = cell.classList.contains('bg-gray-50') || cell.children.length === 0;
        if (!isEmpty) {
            if (currentConfigIndices.includes(index)) {
                cell.classList.add('config-selected');
            }
            // Añadir listener (si no existe ya uno para este modo)
            cell.removeEventListener('click', handleGridItemClickInConfig); // Previene duplicados
            cell.addEventListener('click', handleGridItemClickInConfig);
            cell.dataset.gridIndex = index; // Guardamos el índice para fácil acceso
        } else {
            cell.style.opacity = '0.2'; // Hace las celdas vacías casi invisibles
            cell.style.cursor = 'not-allowed';
        }
    });

    document.getElementById('config-save-group').onclick = () => saveToggleConfiguration(toggleId, validatedLabel);
    document.getElementById('config-cancel-group').onclick = () => {
        // Simplemente vuelve a la pantalla de selección de toggles sin guardar
        exitItemSelectionMode();
        showToggleSelectionMenu();
    };
}

function handleGridItemClickInConfig(event) {
    // Asegurarse de que no se navegue si hay un link dentro
    event.preventDefault();
    event.stopPropagation();

    const cell = event.currentTarget;
    const index = parseInt(cell.dataset.gridIndex);

    if (isNaN(index)) return;

    cell.classList.toggle('config-selected');

    // Actualizar el array temporal de índices
    const isSelected = cell.classList.contains('config-selected');
    if (isSelected && !currentConfigIndices.includes(index)) {
        currentConfigIndices.push(index);
    } else if (!isSelected && currentConfigIndices.includes(index)) {
        currentConfigIndices = currentConfigIndices.filter(i => i !== index);
    }
    console.log("Indices seleccionados:", currentConfigIndices);
}

function saveToggleConfiguration(toggleId, newLabel) {
    // Guardar la configuración
    customToggleConfigs[toggleId] = {
        label: newLabel,
        itemIndices: [...currentConfigIndices].sort((a, b) => a - b) // Guarda copia ordenada
    };
    saveCustomToggleConfigs();

    // Limpiar y volver
    exitItemSelectionMode();
    applyToggleConfiguration(toggleId); // Aplica inmediatamente la nueva config al botón
    showToggleSelectionMenu(); // Vuelve a la pantalla de selección
    alert(`Filtro "${newLabel}" guardado.`);
}

function exitItemSelectionMode() {
     document.body.classList.remove('selecting-items-mode');
     // Quitar listeners y estilos de selección de los items del grid
     cellElements.forEach(cell => {
         cell.removeEventListener('click', handleGridItemClickInConfig);
         cell.classList.remove('config-selected');
         cell.style.opacity = ''; // Restaura opacidad
         cell.style.cursor = ''; // Restaura cursor
         delete cell.dataset.gridIndex;
     });
     currentConfiguringToggle = null;
     currentConfigIndices = [];
}

function exitConfigurationMode() {
    if (document.body.classList.contains('selecting-items-mode')) {
        exitItemSelectionMode();
    }
    const overlay = document.getElementById('config-overlay');
    if (overlay) {
        document.body.removeChild(overlay);
    }
    document.body.classList.remove('config-mode');
    isConfigMode = false;
}

function getDefaultIndices(rangeInfo) {
    const indices = [];
    if (rangeInfo && typeof rangeInfo.start !== 'undefined' && typeof rangeInfo.end !== 'undefined') {
        for (let i = rangeInfo.start; i <= rangeInfo.end; i++) {
            // Opcional: verificar si la celda existe y no está vacía
             if (cellElements[i] && !cellElements[i].classList.contains('bg-gray-50')) {
                 indices.push(i);
             }
        }
    }
    return indices;
}

// Nueva función para aplicar la configuración a un botón específico
function applyToggleConfiguration(toggleId) {
    const toggleButton = document.querySelector(`.range-toggle[data-toggle-id='${toggleId}']`);
    if (!toggleButton) {
        console.warn("Could not find toggle button for id:", toggleId);
        return;
    }

    const rangeInfo = toggleRanges.find(r => r.id === toggleId);
    const config = customToggleConfigs[toggleId];

    let label, itemIndices;

    if (config && config.label && config.itemIndices) {
        // Usar configuración personalizada
        label = config.label;
        itemIndices = config.itemIndices;
        console.log(`Applying custom config for ${toggleId}: Label=${label}, Indices=${itemIndices.join(',')}`);
    } else {
        // Usar configuración predeterminada
        label = rangeInfo.defaultLabel;
        itemIndices = getDefaultIndices(rangeInfo);
         console.log(`Applying default config for ${toggleId}: Label=${label}, Indices=${itemIndices.join(',')}`);
    }

    // Almacenar los índices que controla este botón (como string separado por comas)
    toggleButton.dataset.itemIndices = itemIndices.join(',');
    toggleButton.dataset.label = label; // Guardar la etiqueta base

    // Actualizar el texto visible del botón (dependiendo del estado actual)
    const currentState = toggleButton.dataset.state || 'visible'; // Asume visible si no está definido
    const sign = currentState === 'visible' ? '-' : '+';
    toggleButton.innerHTML = `<span class="sign">${sign}</span>${label}`;

    // Asegurarse de que la visibilidad de los items sea la correcta según el estado actual
    const hideItems = currentState === 'hidden';
     itemIndices.forEach(index => {
         if (cellElements[index]) {
             cellElements[index].classList.toggle('hidden', hideItems);
         }
     });
}

// *** MODIFICA la función que crea los botones toggle ***
// Debes encontrar dónde se crean los botones (parece que es dinámico después de `toggleRanges`)
// Y asegurarte de que se les asigna el `data-toggle-id` y se llama a `applyToggleConfiguration`

// EJEMPLO de cómo modificar la creación (ajusta a tu código existente):
/*
        // Dentro del bucle o map donde creas los toggleButtons
        const range = toggleRanges[index]; // O cómo obtengas la info del rango
        const toggle = document.createElement('span');
        toggle.className = 'toggle-sign range-toggle';
        toggle.dataset.toggleId = range.id; // *** AÑADIR ESTO ***
        // toggle.dataset.rangeStart = range.start; // Ya no es estrictamente necesario si usamos itemIndices
        // toggle.dataset.rangeEnd = range.end; // Ya no es estrictamente necesario si usamos itemIndices
        toggle.dataset.state = 'visible'; // Estado inicial

        // *** LLAMAR A ESTO para establecer label e índices iniciales ***
        applyToggleConfiguration(range.id);

        toggle.style.left = `10px`;
        document.body.appendChild(toggle);

        // Listener (modificado para llamar a updateToggleState con el botón mismo)
         toggle.addEventListener('click', () => {
            if (isMinimalMode || isConfigMode) return;
            updateToggleState(toggle); // Pasar el elemento del botón
        });

        return toggle;
        // Fin del ejemplo de modificación
*/

// *** MODIFICA la función updateToggleState ***
// function updateToggleState(toggle) { // Ahora recibe el elemento del botón
function updateToggleState(toggle) {
    // const start = parseInt(toggle.dataset.rangeStart); // Ya no se usa
    // const end = parseInt(toggle.dataset.rangeEnd); // Ya no se usa
    const currentState = toggle.dataset.state;
    const itemIndicesString = toggle.dataset.itemIndices || ''; // Obtiene los índices del data attribute
    const itemIndices = itemIndicesString.split(',').filter(s => s !== '').map(Number); // Convierte a array de números
    const label = toggle.dataset.label; // Obtiene la etiqueta base

    const newState = currentState === 'visible' ? 'hidden' : 'visible';
    const hideItems = newState === 'hidden';
    const sign = newState === 'visible' ? '-' : '+';

     console.log(`Toggling ${label} to ${newState}. Indices: ${itemIndices.join(',')}`);

    itemIndices.forEach(index => {
        if (cellElements[index]) {
             // console.log(`Item ${index}: Toggling hidden to ${hideItems}`);
            cellElements[index].classList.toggle('hidden', hideItems);
        } else {
            console.warn(`Item at index ${index} not found for toggle ${label}`);
        }
    });

    toggle.dataset.state = newState;
    toggle.innerHTML = `<span class="sign">${sign}</span>${label}`;

    updateButtonStyles(); // Asume que esto actualiza colores basados en data-state
    saveSettings(); // Guarda el estado visible/oculto del toggle
}

// *** MODIFICA saveSettings y loadSavedSettings ***
// Asegúrate de que `saveSettings` guarda el `data-state` de los toggles
// y que `loadSavedSettings` restaura ese `data-state` y luego llama
// a `applyToggleConfiguration` para cada toggle para establecer la
// etiqueta correcta y asegurar la visibilidad inicial de los items.

// Ejemplo DENTRO de saveSettings:
/*
    const toggleStates = {};
    document.querySelectorAll('.range-toggle').forEach(toggle => {
        // Guardar por ID para asegurar consistencia
        toggleStates[toggle.dataset.toggleId] = toggle.dataset.state;
    });
    localStorage.setItem('toggleStates', JSON.stringify(toggleStates));
*/

// Ejemplo DENTRO de loadSavedSettings (después de crear los botones y cargar customConfigs):
/*
    const savedToggleStates = localStorage.getItem('toggleStates');
    if (savedToggleStates) {
        const toggleStates = JSON.parse(savedToggleStates);
        document.querySelectorAll('.range-toggle').forEach(toggle => {
            const toggleId = toggle.dataset.toggleId;
            if (toggleStates[toggleId]) {
                toggle.dataset.state = toggleStates[toggleId];
            }
             // Aplicar la configuración (label, indices) y la visibilidad inicial
            applyToggleConfiguration(toggleId);
        });
    } else {
         // Si no hay estados guardados, aplicar config inicial a todos
         document.querySelectorAll('.range-toggle').forEach(toggle => {
             applyToggleConfiguration(toggle.dataset.toggleId);
         });
    }
    // ... resto de loadSavedSettings ...
    updateButtonStyles(); // Actualizar colores al final
*/

// *** Asegúrate de que la creación inicial de botones y la carga de ajustes
//    llamen a applyToggleConfiguration para cada botón después de crearlo
//    y después de cargar los estados guardados. ***

// En la creación dinámica de los botones toggle (reemplaza el código existente si es necesario)
const toggleButtonsContainer = document.body; // O donde sea que los añadas
const createdToggleButtons = []; // Para mantener referencia si es necesario

// Limpia botones toggle existentes si esta función se llama múltiples veces (ej. al recargar config)
document.querySelectorAll('.range-toggle').forEach(btn => btn.remove());

toggleRanges.forEach((range) => {
    const toggle = document.createElement('span');
    toggle.className = 'toggle-sign range-toggle';
    toggle.dataset.toggleId = range.id; // Asigna el ID único
    toggle.dataset.state = 'visible';   // Estado inicial por defecto

    // Aplica la configuración inicial (cargará custom o default)
    applyToggleConfiguration(range.id);

    toggle.style.left = `10px`; // Posición (ajustar con adjustButtonPositions)
    toggleButtonsContainer.appendChild(toggle);

    // Añade el listener
    toggle.addEventListener('click', () => {
        if (isMinimalMode || isConfigMode) return;
        updateToggleState(toggle); // Pasa el elemento del botón
    });

    createdToggleButtons.push(toggle); // Guarda referencia si es necesario
});

// Es crucial llamar a adjustButtonPositions DESPUÉS de añadir todos los botones al DOM
// y después de llamar a loadSavedSettings para que las posiciones y estilos sean correctos.
// Asegúrate que en tu `DOMContentLoaded` o al final de `loadSavedSettings` haces algo como:
// adjustButtonPositions();
// updateButtonStyles();