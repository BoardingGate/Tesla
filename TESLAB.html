
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BoardingGate Lanzador</title>
    <link rel="icon" href="https://boardinggate.github.io/Tesla/IMG_4157.jpeg" type="image/jpeg">
    <script src="https://cdn.tailwindcss.com"></script>
<style>
    :root {
        --hue: 200; /* Default cool tone */
        --saturation: 50%;
        --lightness: 80%;
    }
    .bookmark-item {
        transition: transform 0.4s ease, box-shadow 0.4s ease;
        box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1);
        position: relative;
    }
    .bookmark-item:hover {
        transform: scale(1.1) translateY(-2px);
        box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.6), -6px -6px 12px rgba(255, 255, 255, 0.15);
    }
    .bookmark-item img {
        image-rendering: crisp-edges;
    }
    .bookmark-name {
        font-weight: bold;
        color: #333;
        text-align: center;
        margin-top: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
    }
    #bookmark-grid {
        display: grid;
        grid-template-columns: repeat(6, minmax(120px, 1fr));
        gap: 15px;
        background-color: transparent;
        border-radius: 0.75rem;
        position: relative;
        width: 100%;
        max-width: 984px;
        margin: 0 auto 0 85px; 
        transition: all 0.3s ease;
    }
    #bookmark-grid > div {
        height: auto;
        aspect-ratio: 16 / 9;
        transition: all 0.3s ease;
    }
    .bookmark-item {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        border-radius: 0.5rem;
        transition: all 0.3s ease;
        background-color: hsla(var(--hue), var(--saturation), var(--lightness), 0.64);
    }
    .bookmark-item img {
        width: 36px;
        height: auto;
        max-width: 40px;
        border-radius: 0.25rem;
    }
    .bookmark-name {
        font-size: clamp(0.85rem, 1.5vw, 1.15rem);
    }
    .small-bookmark img {
        width: 24px;
        max-width: 28px;
    }
    .small-bookmark .bookmark-name {
        font-size: clamp(0.85rem, 1.5vw, 1.15rem);
    }
    @media (max-width: 768px) {
        #bookmark-grid {
            grid-template-columns: repeat(3, minmax(100px, 1fr));
            gap: 10px;
        }
    }
    @media (max-width: 480px) {
        #bookmark-grid {
            grid-template-columns: repeat(2, minmax(80px, 1fr));
            gap: 8px;
        }
    }
    .header-container {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        background-color: #ABAB99;
        padding: 0.5rem;
        /* Removed margin-left here as per original code */
    }
    body.dark-mode .header-container {
        background-color: #92927E;
    }
    .header-logo {
        width: 100px;
        height: 70px;
        transition: filter 0.2s ease;
    }
    body.dark-mode .header-logo {
        filter: brightness(85%);
    }
    .title-container {
        background-color: #ABAB99;
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        display: inline-block;
    }
    body.dark-mode .title-container {
        background-color: #92927E;
    }
    .header-container h1 {
        color: #5C5C47;
    }
    .version-text {
        font-size: 0.75rem;
        color: #5C5C47;
        font-weight: normal;
    }
    body {
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        background-color: #ABAB99;
        margin: 0;
        overflow-x: hidden;
    }
    body.dark-mode {
        background-color: #92927E;
    }
    header {
        margin-bottom: 0.5rem;
    }
    
    main {
        position: relative;
        margin: 10px auto 0.5rem 60px; /* Original margin */
        background-color: transparent;
        border-radius: 0.75rem;
        padding: 16px;
        min-height: 400px;
        max-width: 984px;
        width: 100%;
        transition: margin-top 0.5s ease-in-out;
        position: relative;
    }
    footer {
        margin: 0.5rem auto;
        text-align: center;
        max-width: 984px;
        width: 100%;
        display: block;
        background-color: #ABAB99;
        margin-left: 145px; /* Original margin */
    }
    body.dark-mode footer {
        background-color: #92927E;
    }
    .footer-content {
        color: #5C5C47;
        padding: 0.5rem;
        margin: 0 auto;
        max-width: 100%;
        position: relative;
    }
    .footer-subtext {
        font-size: 0.75rem;
        color: #5C5C47;
        margin-top: 0.25rem;
        text-align: center;
    }
    .footer-link-green {
        color: #5C5C47;
        text-decoration: none;
        transition: color 0.2s ease;
    }
    .footer-link-green:hover {
        color: #5C5C47;
    }
    .footer-line {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
    }

    /* Estilos Botones Izquierda (Fixed positioning) */
    .toggle-image,
    .toggle-sign {
        width: 135px;
        height: 74px;
        margin-bottom: 2px;
        box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.4);
        border: 1px solid #7c7c68;
        left: 10px; 
        z-index: 1000;
        transition: background-color 0.2s ease, filter 0.2s ease, top 0.3s ease; 
        border-radius: 35px; 
        align-items: center; 
        justify-content: center;
        cursor: pointer;
        display: flex; 
        position: fixed; /* Kept fixed positioning */
        /* Top positions will be set by JS */
    }

    .scroll-toggle-button {
        position: fixed;
        width: 110px !important; 
        height: clamp(75px, 20vw, 130px) !important;
        background-color: #ABAB99;
        border-radius: 60px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
        padding: clamp(10px, 2vw, 20px);
        cursor: pointer;
        box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.4) !important;
        border: 1px solid #808080 !important;
        z-index: 1001;
        transition: background-color 0.2s ease;
        left: 10px;
        top: 10px;
    }

    .scroll-toggle-button:hover {
        background-color: #668B8B;
    }
    .scroll-toggle-button svg {
        width: clamp(24px, 4vw, 32px);
        height: clamp(24px, 4vw, 32px);
        stroke: #E6E6DC;
    }

    /* Config, Home, Reload buttons - Positioning as in original HTML */
    /* They are inside the header and positioned absolutely there */
     .header-container {
         position: relative; /* Make header-container a positioning context for absolute children */
     }

    #config-button,
    #home-button,
    #reload-button {
        width: auto !important; 
        height: auto !important; 
        background-color: transparent !important;
        border: none !important;
        box-shadow: none !important;
        padding: 5px !important;
        position: absolute !important; /* Positioned absolutely within header */
        top:   27px !important;     
        z-index: 900 !important; 
    }

    /* Adjusted positioning within the header */
    #config-button { left: 250px !important; }  
    #home-button { left: 315px !important; }   
    #reload-button { left: 380px !important; } 

    #config-button img,
    #home-button img,
    #reload-button img {
        max-width: 37px !important; 
        max-height: 37px !important;
        width: 37px;
        height: 37px;
        object-fit: contain;
        display: block; 
        filter: none !important; 
    }


.top-text-container {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: clamp(0.6rem, 1.5vw, 0.75rem);
    color: #5C5C47;
    background-color: #ABAB98;
    margin-top: 0.25rem;
    margin-left: 70px; /* Original margin */
    gap: 0.5rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    animation: fadeOut 4s forwards;
    position: relative;  
    height: 2rem; 
    transition: opacity 0.5s ease-in-out;
    box-sizing: border-box; 
    z-index: 1900;

}

    body.dark-mode .top-text-container {
        background-color: #6B7280;
    }
    .top-text-container span {
        color: #5C5C47;
        font-size: clamp(0.9rem, 2vw, 1.2rem);
    }

@keyframes fadeOut {
    0% { opacity: 1; height: 2rem; } 
    75% { opacity: 1; height: 2rem; } 
    100% { opacity: 0; height: 2rem; pointer-events: none; }
}

    .arrow-button {
        width: clamp(36px, 6vw, 48px);
        height: clamp(36px, 6vw, 48px);
        background-color: #668B8B;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        transition: background-color 0.2s ease;
    }
    .arrow-button:hover {
        background-color: #5C5C47;
    }
    .arrow-button svg {
        stroke: #E6E6DC;
    }
    .counter-container {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        margin-top: 1rem;
        text-align: center;
        opacity: 0.2;
        margin-left: 145px; /* Original margin */
    }
    .favicon-red {
        filter: hue-rotate(0deg) saturate(200%) brightness(80%);
    }
    .favicon-blue {
        filter: hue-rotate(200deg) saturate(150%) brightness(90%);
    }
    .notices-icon-container {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        max-width: 984px;
        margin: 0 auto;
        margin-left: 165px; /* Original margin */
        position: relative;
    }
    .notices-container {
        flex-grow: 1;
        padding: 0.5rem;
        border: none;
        border-radius: 0.5rem;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0;
        margin-left: 2px;
        height: 3rem;
    }
    .notice-wrapper {
        padding: 0.5rem;
        height: 1.5rem;
        flex-grow: 1;
        overflow: hidden;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .notice {
        color: #E6E6DC;
        font-size: 1.3rem;
        font-weight: bold;
        white-space: nowrap;
        text-align: center;
        opacity: 0;
        animation: fadeInOut 14s infinite;
    }
    @keyframes fadeInOut {
        0% { opacity: 1; }
        10% { opacity: 1; }
        90% { opacity: 1; }
        100% { opacity: 0; }
    }
    .notice-off-icon {
        width: auto;
        height: clamp(2rem, 5vw, 3rem);
        margin-right: 10px;
        align-self: center;
        cursor: pointer;
        transition: filter 0.3s ease;
    }
    body.dark-mode .notice-off-icon {
        filter: brightness(85%);
    }
    .toggle-sign {
        background-color: #ABAB99;
        font-weight: bold;
        font-size: 1.25rem;
        color: #000000;
        text-align: center;
        /* Kept fixed positioning for this group */
        position: fixed; /* Set here for all .toggle-sign */
        left: 10px; /* Set here for all .toggle-sign */
        /* Top set by JS */
    }
    .toggle-sign .sign {
        font-size: 1.5rem;
        margin-right: 2px;
    }
    .toggle-sign:hover {
        background-color: #D9A066;
    }
    /* Removed hover effects for config, home, reload as they are now standard buttons */
     #config-button:hover,
     #home-button:hover,
     #reload-button:hover {
         background-color: transparent !important;
         transform: scale(1.1);
         transition: transform 0.1s ease;
     }


    .toggle-sign img,
    .toggle-image img { 
        max-width: 70%; 
        max-height: 70%; 
        object-fit: contain;
    }

    body.dark-mode .toggle-sign#config-button {
        filter: brightness(85%);
         background-color: transparent !important; 
    }
    body.dark-mode .toggle-sign#config-button img {
        filter: brightness(65%);
    }
    .toggle-image {
        /* Kept fixed positioning for this group */
        position: fixed; /* Set here for all .toggle-image */
        left: 10px; /* Set here for all .toggle-image */
         /* Top set by JS */
    }
    .toggle-image:hover {
        filter: brightness(80%);
    }
    body.dark-mode .toggle-image#on-off-toggle {
        filter: brightness(85%);
    }
    #reminder-button {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        /* Already has position: fixed; left: 10px; from .toggle-sign */
        background-color: #ABAB99;
    }
    #reminder-button img {
        object-fit: contain;
    }
  #reminder-button .reminder-count {
    position: absolute;
    top: 6px; 
    left: 8px; 
    background-color: #EF4444; 
    color: #FFFFFF; 
    border-radius: 55%; 
    padding: 4px 10px; 
    font-size: 1.1rem; 
    font-weight: bold;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1500; 
    min-width: 1.9rem; 
    max-width: 2.5rem; 
    text-align: center;
}
    .hidden {
        display: none !important; 
    }
    .footer-hidden {
        display: none;
    }
    body.dark-mode .bookmark-item {
        filter: brightness(60%);
    }
    body.dark-mode .bg-gray-50.border.border-dashed.border-gray-200.rounded-lg {
        filter: brightness(60%);
    }
    body.dark-mode .scroll-toggle-button {
        background-color: #ABAB99;
    }
    body.dark-mode .scroll-toggle-button:hover {
        background-color: #ABAB99;
    }
    body.dark-mode .toggle-sign.range-toggle { /* Target only range toggles */
        background-color: #ABAB99; /* Apply background to range toggles */
    }
    body.dark-mode .toggle-sign.range-toggle:hover { 
        background-color: #ABAB99; /* Hover color for range toggles */
    }
    body.dark-mode .toggle-sign.range-toggle[data-state="hidden"] {
        background-color: #ABAB99;
    }
    .toggle-sign.range-toggle[data-state="hidden"] {
    color: #7F7F7F;
   }

    /* Removed dark mode styles for config/home/reload buttons as they are now in header */
    body.dark-mode #weather-button {
        background-color: #ABAB99;
    }
    body.dark-mode #zoom-button:not(.zoomed) {
        background-color: #ABAB99;
    }
    body.dark-mode #zoom-button.zoomed {
        background-color: #ABAB99;
    }
    body.dark-mode #reminder-button {
        background-color: #ABAB99;
    }

    .minimal-mode {
        background-color: #ABAB99;
    }
    body.dark-mode.minimal-mode {
        background-color: #92927E;
    }
    .minimal-mode main,
    .minimal-mode .notices-container,
    .minimal-mode .footer-content,
    .minimal-mode .top-text-container,
    .minimal-mode .scroll-toggle-button,
    .minimal-mode .toggle-sign,  
    .minimal-mode .toggle-image,
    /* .minimal-mode #reminder-notifications, /* Kept notifications visible in minimal mode */
    .minimal-mode .counter-wrapper,
    .minimal-mode .notice-off-icon,
    .minimal-mode #dark-mode-toggle,
    /* .minimal-mode .header-container, */ /* Kept header visible in minimal mode */
    /* .minimal-mode .header-logo, */ /* Kept logo visible in minimal mode */
    .minimal-mode .reminder-count-globe { /* Hide globe in minimal mode */
        display: none !important;
    }
    .minimal-mode #on-off-toggle {
        filter: none;
        opacity: 0.3;
    }
    .minimal-mode-message {
        color: #000000;
        font-size: 1rem;
        font-weight: bold;
        position: fixed;
        top: 70px;
        left: 10px;
        z-index: 1000;
    }

    .reminder-modal {
    position: fixed;
    top: 2%;
    left: 3%;
    transform: translateY(-1%);
    background-color: #D2B48C;
    padding: 1rem; 
    border-radius: 0.5rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    z-index: 2000;
    max-width: 1050px; 
    width: 98%;
    max-height: 700px; 
    overflow-y: auto;
    font-weight: bold;
    font-size: 1.3rem; 

}
    .help-modal {
        position: fixed;
        top: 10%;
        left: 35px;
        transform: translateY(-10%);
        background-color: #DAC8A0; 
        padding: 2rem;
        border-radius: 0.5rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 2000;
        max-width: 1020px;
        width: 98%;
        max-height: 80vh;
        overflow-y: auto;
        font-size: 1.10rem;
    }

    .reminder-modal h2, .help-modal h2 {
        font-size: 1.5rem;
        font-weight: bold;
        margin-bottom: 0.5rem;
        color: #111827;
    }
    .reminder-modal label, .help-modal label {
        display: block;
        margin-bottom: 0.25rem;
        font-weight: 500;
        color: #374151;
        font-size: 1.1rem;
    }
    /* Aumentar tamaño de letra para el textarea del recordatorio */
    .reminder-modal textarea#reminder-text {
        width: 100%;
        padding: 0.5rem;
        margin-bottom: 0.5rem;
        border: 1px solid #D1D5DB;
        border-radius: 0.25rem;
        font-size: 1.4rem; 
        font-weight: bold;
        text-transform: uppercase;
    }
    .reminder-modal input[type="text"],
    .reminder-modal input[type="number"] {
        width: 100%;
        padding: 0.5rem;
        margin-bottom: 0.5rem;
        border: 1px solid #D1D5DB;
        border-radius: 0.25rem;
        font-size: 2rem; 
        text-align: center; 
    }


    .reminder-modal .form-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 0.5rem;
    }
    .reminder-modal .full-width {
        grid-column: span 4;
    }
    .reminder-modal .days-group {
        display: flex;
        gap: 2rem;
        flex-wrap: wrap;
    }

    .reminder-modal .button-group {
        display: flex;
        justify-content: space-between;
        gap: 0.35rem;
        flex-wrap: nowrap;
    }

.reminder-modal .days-group label {
    font-size: 1.3rem; 
}

    .reminder-modal button, .help-modal button {
        padding: 0.5rem 1rem;
        border-radius: 0.25rem;
        cursor: pointer;
        font-size: 1.3rem;
        flex: 1;
        text-align: center;
    }
    .reminder-modal button[type="submit"] {
        background-color: #2563EB;
        height:70px;
        font-weight: bold;
        font-size: 1.5rem;
        color: #FFFFFF;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.6rem; 
    }
     .reminder-modal button[type="submit"] span#countdown-save {
         font-size: 1.6rem; 
         font-weight: bold;
         justify-content: right;
         color: #e6e6dc; 
     }

    .reminder-modal button[type="button"] {
        background-color: #D1D5DB;
        color: #111827;
    }
    .help-modal button#close-help {
        background-color: #2563EB;
        color: #FFFFFF;
        font-size: 1.5rem;
        padding: 1rem 2rem;
        height:70px;
    }
    .reminder-notification {
        position: fixed;
        /* Keep original notification positioning from the previous version */
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #FFFF99;
        padding: 1.5rem;
        border-radius: 2.5rem;
        border: 2px solid #ABAB99;
        box-shadow: 0 6px 6px rgba(1, 0, 0, 0.3);
        z-index: 3000;
        max-width: 470px;
        width: 95%;
        text-align: center;
        /* Ensure notifications can stack if needed, using the container */
    }
    .reminder-notification .reminder-text {
        margin: 0.5rem 0;
        font-size: 1.8rem;
        font-weight: bold;
        color: #0000FF;
         word-wrap: break-word; /* Prevent text overflow */
    }
    .reminder-notification .reminder-details {
        margin: 0.5rem 0;
        font-size: 1.0rem;
        font-weight: bold;
        color: #0000FF;
         word-wrap: break-word; /* Prevent text overflow */
    }
    .reminder-notification .button-group {
        display: flex;
        justify-content: center;
        gap: 0.5rem;
        margin-top: 1rem;
    }
    .reminder-notification button {
        padding: 0.5rem 1rem;
        border-radius: 0.25rem;
        cursor: pointer;
        font-size: 0.9rem;
        flex: 1; /* Allow buttons to grow/shrink */
        min-width: 0; /* Needed for flex-item shrinking */
    }
     .reminder-notification button.cancel {
        background-color: #EF4444;
        color: #FFFFFF;
        font-weight: bold;
        width: 150px;
        height:70px;
        font-size: 1.2rem;
    }
    .reminder-notification button.modify {
        background-color: #10B981;
        font-weight: bold;
        width: 150px;
        height:60px;
        font-size: 1.2rem;
        color: #FFFFFF;
    }
    .reminder-notification button.postpone {
        background-color: #F59E0B;
        width: 150px;
        font-weight: bold;
        height:60px;
        font-size: 1.2rem;
        color: #FFFFFF;
    }

     /* Styles for Postpone Options Modal (Kept from previous version) */
     #postpone-options-modal {
         position: fixed;
         top: 50%;
         left: 50%;
         transform: translate(-50%, -50%);
         background-color: #F5E1A9; /* Light yellow/beige */
         padding: 1.5rem;
         border-radius: 1.5rem;
         border: 2px solid #D97706; /* Darker orange border */
         box-shadow: 0 6px 6px rgba(0, 0, 0, 0.3);
         z-index: 4000; /* Higher than notification */
         max-width: 480px;
         width: 90%;
         max-height: 85vh;
         overflow-y: auto;
         text-align: center;
         font-weight: bold;
         color: #000000; /* Default text color */
     }

     #postpone-options-modal p {
         margin: 0.5rem 0;
         word-wrap: break-word;
     }

     #postpone-options-modal .reminder-text {
         font-size: 1.2rem; /* Slightly smaller than main notification */
         color: #333; /* Darker text */
         margin-bottom: 0.5rem;
     }

     #postpone-options-modal .reminder-details {
         font-size: 1rem;
         color: #555;
         margin-bottom: 1.5rem;
     }

     #postpone-options-modal .button-group {
         display: flex;
         flex-direction: column; /* Stack buttons vertically */
         gap: 1rem; /* Space between buttons */
         align-items: stretch; /* Make buttons fill width */
     }

     #postpone-options-modal button {
         padding: 0.8rem 1rem; /* Adjust padding */
         font-size: 1.3rem; /* Font size */
         font-weight: bold;
         border: none;
         border-radius: 0.375rem;
         cursor: pointer;
         text-align: center;
         transition: background-color 0.2s ease; /* Smooth transition */
     }

     #postpone-options-modal button.postpone-option {
         background-color: #F59E0B; /* Orange */
         color: white;
     }
     #postpone-options-modal button.postpone-option:hover {
         background-color: #D97706; /* Darker orange */
     }

     #postpone-options-modal button#cancel-postpone {
         margin-top: 1.2rem;
         width: 100%; /* Full width */
         background-color: #EF4444; /* Red */
         color: white;
         padding: 0.7rem 1rem;
         font-size: 1.1rem;
     }
     #postpone-options-modal button#cancel-postpone:hover {
          background-color: #DC2626; /* Darker red */
     }

     #postpone-options-modal #postpone-countdown {
         text-align: center;
         margin-top: 1.8rem;
         font-size: 1.1rem;
         font-weight: 500;
         color: #333; /* Dark text */
     }
     #postpone-options-modal #postpone-timer-value {
         font-weight: bold;
         font-size: 1.2rem;
         color: #0000FF; /* Blue text */
     }


    .reminder-table-modal {
        position: fixed;
        top: 30px;
        left: 35px;
        transform: translateY(10%);
        background-color: #E6D6A8;
        padding: 1.5rem;
        border-radius: 1.5rem;
        box-shadow: 0 4px 6px rgba(1, 1, 0, 0.1);
        z-index: 2000;
        max-width: 99%;
        width: 1090px;
        max-height: 80vh;
        overflow-y: auto;
    }
    .reminder-table-modal table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 1rem;
    }
     .reminder-table-modal tbody tr { 
         cursor: pointer;
     }
     .reminder-table-modal tbody tr:hover { 
         background-color: rgba(0, 0, 0, 0.05);
     }

    .reminder-table-modal th,
    .reminder-table-modal td {
        padding: 0.5rem;
        border: 1px solid #1E3A8A; 
        font-size: 1.1rem;
        text-align: center;
        vertical-align: middle; 
    }
    .reminder-table-modal td.text-column {
        text-align: left;
         word-wrap: break-word; /* Allow text wrapping */
         max-width: 250px; /* Example: Set a max width if needed */
    }
    .reminder-table-modal th {
        background-color: #E5E7EB;
        font-weight: bold;
    }
    .reminder-table-modal td.date-column {
        white-space: nowrap;
    }
     .reminder-table-modal td:first-child { 
         display: flex;
         justify-content: space-around; 
         align-items: center;
         gap: 0.5rem; 
         padding: 0.3rem 0.5rem; 
         /* border: none; */ /* Keep border left/right */
         min-width: 220px; /* Ensure enough space for buttons */
     }
     .reminder-table-modal td:first-child button {
         padding: 0.5rem 0.8rem; 
         font-size: 0.85rem; 
         flex: 1 1 auto; /* Allow buttons to grow/shrink */
         margin: 0; 
     }

    .reminder-table-modal button.modify {
        background-color: #10B981;
        font-size: 1rem;
        height:70px;
        color: #000000;
    }
    .reminder-table-modal button.delete {
        background-color: #EF4444;
        font-size: 1.2rem;
        height:65px;
        color: #FFFFFF;
    }
    .reminder-table-modal button.postpone {
        background-color: #F59E0B;
        font-size: 1.2rem;
        height:65px;
        color: #FFFFFF;
    }
    .reminder-table-modal .button-group {
        display: flex;
        margin-top: 1rem;
    }
    .reminder-table-modal #close-reminders,
    .reminder-table-modal #close-reminders-top {
        padding-left: 3rem;
        padding-right: 3rem;
         background-color: #2563EB; 
         color: white;
         padding: 0.75rem 3rem; 
         border-radius: 0.5rem;
         font-size: 1.25rem;
         font-weight: bold;
         border: 2px solid #1E3A8A;
         cursor: pointer;
         transition: background-color 0.2s ease;
         display: inline-flex; 
         align-items: center; 
    }
     .reminder-table-modal #close-reminders:hover,
     .reminder-table-modal #close-reminders-top:hover {
         background-color: #1D4ED8; 
     }
     .reminder-table-modal .top-button-container {
         display: flex;
         justify-content: flex-end; 
         margin-bottom: 1rem; 
     }

    .button-countdown {
        margin-left: 8px; 
        font-weight: bold; 
        font-size: 1.1em; 
        opacity: 0.85; 
    }


    .reminder-count-globe {
        position: fixed;
        top: 10px;
        left: 10px;
        background-color: #EF4444;
        color: white;
        border-radius: 65%;
        padding: 10px 15px;
        font-size: 1.3rem;
        font-weight: bold;
        z-index: 1500;
    }
    .minimal-mode .reminder-count-globe,
    .minimal-mode .reminder-notification {
        display: none !important;
    }

.reminder-count-globe,
#reminder-notifications,
.notices-icon-container,
footer {
    transition: margin-top 0.5s ease-in-out; 
}


.speech-button {
    background-color: #668B8B; 
    color: white;
    border: none;
    border-radius: 0.25rem;
    padding: 0.5rem;
    cursor: pointer;
    margin-left: 0.5rem;
    font-size: 1rem;
    vertical-align: top; 
}

.speech-button:hover {
    background-color: #668B8B; 
}

.speech-status {
    font-size: 0.85rem;
    color: #ABAB99; 
    margin-top: 0.25rem;
    min-height: 1.2em; 
}


#auto-save-timer {
    color: #1E40AF; 
}

.statcounter-container {
    display: flex;      
    justify-content: center;  
    align-items: center;    
    gap: 10px;             
    margin-top: 0.25rem;       
}
/* --- Estilos para Notificaciones Flotantes (Toasts - Kept for UX) --- */
.toast-notification {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    padding: 12px 25px;
    border-radius: 25px;
    color: white;
    font-size: 1rem;
    font-weight: 500;
    z-index: 9999;
    opacity: 0;
    transition: opacity 0.4s ease-in-out, bottom 0.4s ease-in-out;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    text-align: center;
    min-width: 250px;
    max-width: 80%;
}

.toast-notification.show {
    opacity: 1;
    bottom: 40px;
}

.toast-success { background-color: #28a745; }
.toast-error { background-color: #dc3545; }
.toast-warning { background-color: #ffc107; color: #333; }
.toast-info { background-color: #17a2b8; }

/* --- End Styles Toasts --- */

</style>
</head>
<body class="min-h-screen bg-[#ABAB99] flex flex-col items-center p-6">

    <div class="top-text-container">
        <div class="arrow-button" id="back-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
        </div>
        <span>[ Web anterior o posterior arrastre ]</span>
        <div class="arrow-button" id="forward-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14M12 5l7 7-7 7"/></svg>
        </div>
    </div>
    <div class="reminder-count-globe" id="reminder-count-globe"></div>
    <!-- Container for multiple reminder notifications -->
    <div id="reminder-notifications" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 3000;">
        <!-- Notifications will be added here -->
    </div>

<main>

    <div id="bookmark-grid">
        <!-- Bookmarks will be generated here by JS -->
    </div>
</main>

<div class="notices-icon-container">
    <img src="https://boardinggate.github.io/Tesla/IMG_4194.jpg" alt="Toggle Avisos" class="notice-off-icon" id="notice-toggle-icon">
    <div class="notices-container">
        <div class="notice-wrapper">
            <span class="notice" id="current-notice"></span>
        </div>
    </div>
</div>

<footer>
    <div class="footer-content">
        <div class="header-container">
            <img src="https://boardinggate.github.io/Tesla/LOGOTESLA.jpg" class="header-logo">
            <div class="title-container">
                <h1 class="text-2xl font-bold inline">
                    <span class="text-2xl">BoardingGate</span>
                    <span class="text-base">Lanzador</span>
                    <span id="version" class="version-text"></span>
                </h1>
            </div>
             <!-- Config, Home, Reload buttons as they were in the original HTML -->
             <span class="toggle-sign" id="config-button" title="Configuración"><img src="https://boardinggate.github.io/Tesla/config.jpg" alt="Configuración"></span>
             <span class="toggle-sign" id="home-button" title="Web anterior"><img src="./home.webp" alt="Inicio"></span>
             <span class="toggle-sign" id="reload-button" title="Recargar Página"><img src="./reload.webp" alt="Recargar"></span>

        </div>
        <div class="footer-line">
            <a href="https://x.com/boardinggate?s=21" class="footer-link-green" target="_blank" rel="noopener noreferrer">@BoardingGate</a>
            <span class="text-green-200" style="font-size: 1.5rem;">🤝</span>
            <a href="https://x.com/boardinggate/status/1857325553742721116?s=46" class="footer-link-green" target="_blank" rel="noopener noreferrer">Ahorremos un dinero con mis REFERIDOS</a>
        </div>

        <div class="statcounter-container">
          <div style="display: inline-flex; align-items: center; gap: 10px;">
            <script type="text/javascript">
              var sc_project=13126275;
              var sc_invisible=0;
              var sc_security="0fc568cc";
              var scJsHost = "https://";
              document.write("<sc"+"ript type='text/javascript' src='" +
              scJsHost+
              "statcounter.com/counter/counter.js'></"+"script>");
            </script>
            <noscript><div class="statcounter"><a title="Web Analytics"
            href="https://statcounter.com/" target="_blank"><img
            class="statcounter"
            src="https://c.statcounter.com/13126275/0/0fc568cc/0/"
            alt="Web Analytics"
            referrerPolicy="no-referrer-when-downgrade"></a></div></noscript>
            <a href="https://statcounter.com/p13126275/?guest=1" class="footer-subtext">Legionarios de Elon</a>
          </div>
        </div> 
        
        <p class="footer-subtext">La inteligencia tiene ciertas limitaciones. La locura, casi ninguna 🫶 🤟</p>
    </div>
</footer>


<div id="scroll-toggle" class="scroll-toggle-button" title="Ir al inicio o fin">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M19 12l-7 7-7-7"/></svg>
</div>

<script>
    const bookmarks = [
        { name: "YouTube", url: "https://www.youtube.com" },
        { name: "Google", url: "https://www.google.com" },
        { name: "GDrive", url: "https://drive.google.com", favicon: "./IMG_4172.png" },
        { name: "GMail", url: "https://mail.google.com/mail/mu/mp/603/#tl/Recibidos", favicon: "./IMG_4171.png"},
        { name: "Google Fotos", url: "https://photos.google.com" },
        { name: "iCloud", url: "https://www.icloud.com/", favicon: "https://www.google.com/s2/favicons?domain=icloud.com&sz=64" },
        { name: "ABRP", url: "https://abetterrouteplanner.com" },
        { name: "ElectroMaps", url: "https://map.electromaps.com/es/", favicon: "https://www.google.com/s2/favicons?domain=electromaps.com&sz=64" },
        { name: "REVE PdR España", url: "https://www.mapareve.es/mapa-puntos-recarga", favicon: "https://www.google.com/s2/favicons?domain=mapareve.es&sz=64" },
        { name: "PdR,s", url: "https://www.google.com/maps/search/puntos+recarga+veh%C3%ADculos+el%C3%A9ctricos", favicon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 18h8v2h-8v-2z'/><path d='M12 14h8v2h-8v-2z'/><path d='M12 10h8v2h-8v-2z'/><path d='M12 6h8v2h-8V6z'/><path d='M4 18h4v-2H4v2zM4 14h4v-2H4v2zM4 10h4v-2H4v2zM4 6h4V4H4v2z'/></svg>" },
        { name: "Google Maps", url: "https://maps.google.com" },
        { name: "WhatsApp", url: "https://web.whatsapp.com/" },
        { name: "TESSIE", url: "https://dash.tessie.com/signin", favicon: "https://www.google.com/s2/favicons?domain=tessie.com&sz=64" },
        { name: "Mis Updates", url: "https://dash.tessie.com/software", favicon: "https://cdn-icons-png.flaticon.com/512/148/148767.png" },
        { name: "Olas Updates", url: "https://es.stats.tessie.com/", favicon: "https://cdn-icons-png.flaticon.com/512/5815/5815902.png" },
        { name: "NotaTeslaApp", url: "https://www.notateslaapp.com/software-updates/" },
        { name: "ENHAUTO", url: "https://www.enhauto.com" },
        { name: "MAREAS", url: "https://www.meteogalicia.gal/web/predicion/mareas-e-luas" }, // Index 17
        // Index 18 starts PdRs block
        { name: "ELECTROVERSE", url: "https://electroverse.com/es/map", favicon: "https://www.google.com/s2/favicons?domain=electroverse.com&sz=64" },
        { name: "ACCIONA", url: "https://www.google.com/maps/search/recarga+Acciona", favicon: "https://www.google.com/s2/favicons?domain=acciona.com&sz=64" },
        { name: "IBERDROLA", url: "https://www.google.com/maps/search/recarga+IBERDROLA", favicon: "https://www.google.com/s2/favicons?domain=iberdrola.com&sz=64" },
        { name: "WAYLET Repsol", url: "https://www.google.com/maps/search/recarga+REPSOL+Waylet", favicon: "https://www.google.com/s2/favicons?domain=repsol.com&sz=64" },
        { name: "ENDESA xWay", url: "https://www.google.com/maps/search/recarga+ENDESA+XWAY", favicon: "https://www.google.com/s2/favicons?domain=endesa.com&sz=64" },
        { name: "ZUNDER", url: "https://www.google.com/maps/search/recarga+ZUNDER", favicon: "https://www.google.com/s2/favicons?domain=zunder.com&sz=64" },
        { name: "IONITY", url: "https://www.google.com/maps/search/recarga+IONITY", favicon: "https://www.google.com/s2/favicons?domain=ionity.eu&sz=64" },
        { name: "WENEA", url: "https://www.google.com/maps/search/recarga+WENEA", favicon: "https://www.google.com/s2/favicons?domain=wenea.com&sz=64" },
        { name: "T.ENERGIES", url: "https://www.google.com/maps/search/recarga+TOTAL+ENERGIES", favicon: "https://www.google.com/s2/favicons?domain=totalenergies.com&sz=64" },
        { name: "GALP", url: "https://www.google.com/maps/search/recarga+GALP", favicon: "https://www.google.com/s2/favicons?domain=galp.com&sz=64" },
        { name: "MIIO", url: "https://miio.com", favicon: "https://www.google.com/s2/favicons?domain=miio.com&sz=64" },
        { name: "EVDC", url: "https://evdc.network", favicon: "https://www.google.com/s2/favicons?domain=evdc.network&sz=64" }, // Index 29
        // Index 30 starts iAs block
        { name: "GROK", url: "https://grok.com/?referrer=website" },
        { name: "CHATGPT", url: "https://chat.openai.com" },
        { name: "CLAUDE", url: "https://claude.ai/new" },
        { name: "GEMINI", url: "https://gemini.google.com" },
        { name: "NOTEBOOKLM", url: "https://notebooklm.google.com" },
        { name: "Batería", url: "https://docs.google.com/spreadsheets/d/1bLZmgVGTBqg2bS2E45JpORjs9eK2nb05AWXYLLDY-RI/edit?gid=1398548891#gid=1398548891", favicon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='10'/><polyline points='12 6 12 12 16 14'/></svg>" },
        { name: "TeslaParaTodos", url: "https://teslaparatodos.com/cine/" },
        { name: "BetterTheater", url: "https://abettertheater.com", favicon: "https://www.google.com/s2/favicons?domain=abettertheater.com&sz=64" },
        { name: "Filmin", url: "https://www.filmin.es/catalogo/peliculas" },
        { name: "Octopus", url: "https://octopus.energy/dashboard" },
        { name: "App MCE", url: "https://www.oscarabilleira.com/app-mi-coche-electrico/#ayuda" },
        { name: "Patrón Luz", url: "https://docs.google.com/spreadsheets/d/1R7UUZ9i4BAYWAGAX6PQT1WGd12GEZ4Ja/edit?usp=sharing&ouid=108345701896498198132&rtpof=true&sd=true" }, // Index 41
        // Index 42 starts Util block
        { name: "TradingView", url: "https://es.tradingview.com/chart/t5g9UFG0/" },
        { name: "Telegram", url: "https://web.telegram.org/a/" },
        { name: "Twitter", url: "https://x.com" },
        { name: "Maesal Detailer", url: "https://www.maesaldetailer.es/" },
        { name: "Superchargers", url: "https://www.tesla.com/es_es/findus?bounds=45.41107111786193%2C19.27853056943938%2C29.703668286784747%2C-16.64676239931062" },
        { name: "TESLA web", url: "https://www.tesla.com/es_es" },
        { name: "Manual M3", url: "https://www.tesla.com/ownersmanual/model3/es_es/" },
        { name: "de Servicio", url: "https://service.tesla.com/docs/Model3/ServiceManual/2024/es-es/" },
        { name: "de Despiece", url: "https://epc.tesla.com/es-MX/catalogs/e0e07c3d-272f-4d06-b8b6-9e92f857e5f3" },
        { name: "de Usted Mismo", url: "https://www.tesla.com/es_es/support/do-it-yourself-guides" },
        { name: "de Filtro Cabina", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-DB0A1E3C-926E-498C-A2FD-A27B8421A471.html" },
        { name: "de Móvil remoto", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-53651B16-A2E3-4118-933E-B5F41C74D433.html" },
        { name: "Waze (consultas)", url: "https://www.waze.com/es/live-map/", favicon: "https://www.google.com/s2/favicons?domain=waze.com&sz=64" },
        { name: "AMAZON", url: "https://www.amazon.es" },
        { name: "BIP&DRIVE", url: "https://areaprivada.bipdrive.com/login" },
        { name: "ITV Cita", url: "https://www.sycitv.com/es/cita-previa-particulares/", favicon: "https://boardinggate.github.io/Tesla/itv.png" },
        { name: "Deportes", url: "https://www.sofascore.com/es/tenis" }, // Index 59
         null, // Index 60 starts Varios block
        { name: "Jaime Odena", url: "https://www.youtube.com/@JOdena", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "Eduardo Arcos", url: "https://www.youtube.com/@earcos", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "AutoIngenium", url: "https://www.youtube.com/@AutoIngenium", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "Gallego en Munich", url: "https://www.youtube.com/@ungallegoenmunich", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "Electromiaumiau", url: "https://www.youtube.com/@electromiaumiau", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "Manuel Martos", url: "https://www.youtube.com/@Manuel_Martos", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "Todos Electricos", url: "https://www.youtube.com/@TodosElectricos", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "Juan Vidal Haces", url: "https://www.youtube.com/@JuanVidalHaces", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "Ruedana", url: "https://www.youtube.com/@ruedana", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "STR-600", url: "https://www.youtube.com/@STR-600", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "Juanjo T. Aventuras", url: "https://www.youtube.com/@juanjoteslaventuras", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "Carlos Cuezva", url: "https://www.youtube.com/@CarlosCuezva", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "Javi Manzanoo", url: "https://www.youtube.com/@javimanzanoo", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "Crifedi", url: "https://www.youtube.com/@Crifedi", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "Tescno Tesla", url: "https://www.youtube.com/@TecnoTesla", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "Full Electric Mex", url: "https://www.youtube.com/@FullElectricMexico", favicon: "https://www.youtube.com/favicon.ico" },
        null,
        null,
        { name: "La iA Jon", url: "https://www.youtube.com/@la_inteligencia_artificial", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "JF Ccalero", url: "https://www.youtube.com/@jfcalero", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "Visual Politik", url: "https://www.youtube.com/@VisualPolitik", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "Fabian Barrio", url: "https://www.youtube.com/@fabiancbarrio", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "Loquetudigas", url: "https://www.youtube.com/@Loquetudigas", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "David Antunes", url: "https://www.youtube.com/@davidantunesmusic", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "TheWildProject", url: "https://www.youtube.com/@TheWildProject", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "Estas Tonne", url: "https://www.youtube.com/@Estastonne", favicon: "https://www.youtube.com/favicon.ico" },
        { name: "BBC6 Music", url: "https://www.youtube.com/@BBC6Music", favicon: "https://www.youtube.com/favicon.ico" },
        null, null // Ends at index 95
    ];
    const TOTAL_CELLS = 96;
    const COLS = 6;
    const grid = document.getElementById('bookmark-grid');
    let isDarkMode = false;
    let isMinimalMode = false;
    let pressStartTime = null;
    let reminderPressStartTime = null;
    let isActive = true; // Controls notices and footer
    let isFooterVisible = true;
    let notices = [];
    let currentNoticeIndex = 0;
    let fromReminderModal = false; // Flag to return to reminder modal after viewing table


    async function loadNotices() {
        try {
            const response = await fetch('https://boardinggate.github.io/Tesla/avisos.txt', {
                cache: 'no-cache' // Ensure no caching of the avisos.txt file itself
            });
            if (!response.ok) {
                throw new Error('No se pudo cargar avisos.txt');
            }
            const text = await response.text();
            notices = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            if (notices.length === 0) {
                notices = ['No hay avisos disponibles.'];
            }
        } catch (error) {
            console.error('Error al cargar avisos.txt:', error);
            notices = ['Error al cargar los avisos.'];
        }
        updateNotice();
    }

    function checkDarkModeTime() {
        const now = new Date();
        const hours = now.getHours();
        const minutes = now.getMinutes();
        return (hours >= 21 || hours < 7 || (hours === 7 && minutes <= 30));
    }


    function saveSettings() {
        localStorage.setItem('darkMode', JSON.stringify(isDarkMode));
        localStorage.setItem('minimalMode', JSON.stringify(isMinimalMode));
        const toggleStates = {};
        document.querySelectorAll('.range-toggle').forEach(toggle => {
            toggleStates[toggle.dataset.rangeStart] = toggle.dataset.state;
        });
        localStorage.setItem('toggleStates', JSON.stringify(toggleStates));
        const zoomButton = document.getElementById('zoom-button');
        if (zoomButton) localStorage.setItem('zoomState', zoomButton.dataset.zoomState);
        const onOffToggle = document.getElementById('on-off-toggle');
         if (onOffToggle) localStorage.setItem('onOffState', onOffToggle.dataset.state);
        localStorage.setItem('noticesActive', JSON.stringify(isActive)); // Save notice toggle state
        localStorage.setItem('footerVisible', JSON.stringify(isFooterVisible));
        console.log('Settings saved:', { darkMode: isDarkMode, minimalMode: isMinimalMode, noticesActive: isActive, footerVisible: isFooterVisible });
    }

    function loadSavedSettings() {
        const savedDarkMode = localStorage.getItem('darkMode');
        isDarkMode = savedDarkMode ? JSON.parse(savedDarkMode) : checkDarkModeTime();
        if (isDarkMode) {
            document.body.classList.add('dark-mode');
        } else {
             document.body.classList.remove('dark-mode');
        }

        const savedMinimalMode = localStorage.getItem('minimalMode');
        isMinimalMode = savedMinimalMode ? JSON.parse(savedMinimalMode) : false;


        const zoomButton = document.getElementById('zoom-button');
        const savedZoomState = localStorage.getItem('zoomState');
        if (zoomButton && savedZoomState) {
            zoomButton.dataset.zoomState = savedZoomState;
            applyZoom(savedZoomState);
        } else if (zoomButton) {
             zoomButton.dataset.zoomState = 'off'; // Default if not saved
             applyZoom('off');
        }


        const onOffToggle = document.getElementById('on-off-toggle');
        const savedOnOffState = localStorage.getItem('onOffState');
         if (onOffToggle) {
             onOffToggle.dataset.state = savedOnOffState ? savedOnOffState : 'on';
         } else {
              // Should not happen if created dynamically, but as fallback
              console.warn("onOffToggle element not found during loadSavedSettings.");
         }

        const savedToggleStates = localStorage.getItem('toggleStates');
        const masterState = onOffToggle ? onOffToggle.dataset.state : 'on'; // Default master state


        document.querySelectorAll('.range-toggle').forEach(toggle => {
            const start = toggle.dataset.rangeStart;
            const end = toggle.dataset.rangeEnd;
            let individualState = 'visible'; // Default

            if (savedToggleStates) {
                const toggleStates = JSON.parse(savedToggleStates);
                if (toggleStates[start]) {
                    individualState = toggleStates[start];
                }
            }

            toggle.dataset.state = individualState;
            const label = toggleRanges.find(r => r.start == start).label;
            toggle.innerHTML = `<span class="sign">${individualState === 'visible' ? '-' : '+'}</span>${label}`;

            // Hide based on master state AND individual state
            const shouldHide = masterState === 'off' || individualState === 'hidden';
            for (let i = parseInt(start); i <= parseInt(end); i++) {
                if (cellElements[i]) {
                    cellElements[i].classList.toggle('hidden', shouldHide);
                }
            }
        });

        const noticesContainer = document.querySelector('.notices-container');
        const footerContent = document.querySelector('.footer-content');
         const noticeToggleIcon = document.getElementById('notice-toggle-icon');

        const savedNoticesActive = localStorage.getItem('noticesActive');
        isActive = savedNoticesActive ? JSON.parse(savedNoticesActive) : true; // Default to active

        if (noticesContainer) noticesContainer.style.display = isActive ? 'flex' : 'none';
        // Footer visibility is linked to isActive and minimal mode
        // The actual footer visibility is set in toggleFooterVisibility

        const savedFooterVisible = localStorage.getItem('footerVisible');
        isFooterVisible = savedFooterVisible ? JSON.parse(savedFooterVisible) : true; // Default to visible

        if (isMinimalMode) {
            toggleMinimalMode(true);
        } else {
             toggleMinimalMode(false); // Ensure minimal mode is off if not loaded
             toggleFooterVisibility();
        }

        updateButtonStyles();
        // loadReminders(); // Renamed to handle initial simple reminders specifically
        handleInitialRemindersLoad(); // Handle simple reminders on load
        adjustButtonPositions(); // Adjust positions after elements are created and states loaded
    }


function handleInitialRemindersLoad() {
    console.log('Handling initial reminders load');
    updateReminderCount();
    // Show simple reminders (type 'simple') that are still in storage on load.
    // These should have no time, date, repeat, interval, or timerEnd.
    // They remain in storage until acted upon by the user via the notification.
    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    const simpleReminders = reminders.filter(r => r.type === 'simple' && r.text && r.text.trim() !== '<b></b>');

    if (simpleReminders.length > 0) {
        console.log(`Showing ${simpleReminders.length} simple reminders on initial load.`);
    }

    // Show notifications for these simple reminders. They are not removed here.
    simpleReminders.forEach(showReminderNotification);

    // Other reminder types (daily, weekly, interval, timer) will be handled
    // by the checkReminders interval after the page loads.

    updateReminderCount(); // Update count just in case
    updateButtonStyles(); // Update button style just in case
}


    function toggleMinimalMode(enable) {
        if (enable) {
            if (!document.body.classList.contains('minimal-mode')) {
                document.body.classList.add('minimal-mode');
                const message = document.createElement('div');
                message.id = 'minimal-mode-message';
                message.className = 'minimal-mode-message';
                message.textContent = 'Modo minimalista activo (recargar para salir)';
                document.body.appendChild(message);
            }
        } else {
            if (document.body.classList.contains('minimal-mode')) {
                document.body.classList.remove('minimal-mode');
                const message = document.getElementById('minimal-mode-message');
                if (message) message.remove();
                // Re-apply normal visibility settings when exiting minimal mode
                 adjustButtonPositions();
                 updateButtonStyles();
                 toggleFooterVisibility();
                 updateReminderCount(); // Ensure globe/count is visible if needed
            }
        }
        isMinimalMode = enable; // Update state variable
         saveSettings(); // Save the state
    }

    function applyZoom(state) {
        const originalWidth = 984;
        const adjustedWidth = 935; // This value seems to be the target for the 4-column layout
        const originalCols = 6;
        const zoomedCols = 4;
        const gap = 15;
        const originalCellWidth = (originalWidth - (originalCols - 1) * gap) / originalCols;
        const zoomedCellWidth = (adjustedWidth - (zoomedCols - 1) * gap) / zoomedCols;
        const zoomButton = document.getElementById('zoom-button');

        if (!grid || !zoomButton) return; // Ensure elements exist

        if (state === 'on') {
            grid.style.gridTemplateColumns = `repeat(${zoomedCols}, minmax(120px, 1fr))`; // Keep minmax for responsiveness
            grid.style.gap = `${gap}px`;
            grid.style.maxWidth = `${adjustedWidth}px`;
            // Adjust child styles based on zoom state
            document.querySelectorAll('#bookmark-grid > div').forEach(cell => {
                 // Let grid handle width/height for responsiveness, just adjust child content scale if needed
                 // cell.style.width = `${zoomedCellWidth}px`; // Removed to let grid handle sizing
                 // cell.style.height = `${zoomedCellWidth * 9 / 16}px`; // Removed
            });
            document.querySelectorAll('.bookmark-item img').forEach(img => {
                img.style.width = '48px';
                img.style.maxWidth = '56px';
            });
            document.querySelectorAll('.bookmark-name').forEach(name => {
                name.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)';
            });
            document.querySelectorAll('.small-bookmark img').forEach(img => {
                img.style.width = '48px';
                maxWidt = '56px';
            });
            document.querySelectorAll('.small-bookmark .bookmark-name').forEach(name => {
                name.style.fontSize = 'clamp(1.05rem, 1.8vw, 1.35rem)';
            });
            zoomButton.innerHTML = `<img src="./zoon+.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`;
            zoomButton.dataset.zoomState = 'on'; // Set state data attribute

        } else { // state === 'off'
            grid.style.gridTemplateColumns = `repeat(${originalCols}, minmax(120px, 1fr))`;
            grid.style.gap = `${gap}px`;
            grid.style.maxWidth = `${originalWidth}px`;
             // Revert child styles
            document.querySelectorAll('#bookmark-grid > div').forEach(cell => {
                // cell.style.width = 'auto'; // Removed
                // cell.style.height = 'auto'; // Removed
            });
            document.querySelectorAll('.bookmark-item img').forEach(img => {
                img.style.width = '36px';
                img.style.maxWidth = '40px';
            });
            document.querySelectorAll('.bookmark-name').forEach(name => {
                name.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)';
            });
            document.querySelectorAll('.small-bookmark img').forEach(img => {
                img.style.width = '24px';
                img.style.maxWidth = '28px';
            });
            document.querySelectorAll('.small-bookmark .bookmark-name').forEach(name => {
                name.style.fontSize = 'clamp(0.85rem, 1.5vw, 1.15rem)';
            });
            zoomButton.innerHTML = `<img src="./zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`;
            zoomButton.dataset.zoomState = 'off'; // Set state data attribute
        }
        // Ensure button styles are updated after zoom state changes
        updateButtonStyles();
    }


    function updateButtonStyles() {
        // Select elements by their IDs - these should exist if created dynamically or in HTML
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        const onOffToggle = document.getElementById('on-off-toggle');
        const toggleButtons = document.querySelectorAll('.toggle-sign.range-toggle'); // Fixed buttons
        const weatherButton = document.getElementById('weather-button'); // Fixed
        const zoomButton = document.getElementById('zoom-button'); // Fixed
        const reminderButton = document.getElementById('reminder-button'); // Fixed
        // Config, Home, Reload are in HTML, inside header - not fixed left

        if(onOffToggle) {
             onOffToggle.src = `https://boardinggate.github.io/Tesla/${
                 onOffToggle.dataset.state === 'on' ? 'IMG_4192.jpg' : 'IMG_4191.jpg'
             }`;
             onOffToggle.alt = `Toggle ${onOffToggle.dataset.state === 'on' ? 'On' : 'Off'}`;
        }

        if(darkModeToggle) {
            darkModeToggle.src = `https://boardinggate.github.io/Tesla/${
                isDarkMode ? 'oscuro2.png' : 'claro2.png'
            }`;
            darkModeToggle.alt = `Toggle ${isDarkMode ? 'Oscuro' : 'Claro'}`;
        }

        // Update reminder count bubble (handled by updateReminderCount function)
        // Update button styles based on dark mode / minimal mode - CSS handles most of this now

        // Specific background color overrides for fixed buttons in dark mode if needed (CSS handles this)
        // if (isDarkMode && !isMinimalMode) {
        //     toggleButtons.forEach(toggle => {
        //         toggle.style.backgroundColor = '#ABAB99';
        //     });
        //      if (weatherButton) weatherButton.style.backgroundColor = '#ABAB99';
        //      if (zoomButton) zoomButton.style.backgroundColor = '#ABAB99';
        //      if (reminderButton) reminderButton.style.backgroundColor = '#ABAB99';
        // } else if (!isMinimalMode) {
        //      // Apply non-dark mode styles if needed (CSS handles this)
        //      toggleButtons.forEach(toggle => {
        //         toggle.style.backgroundColor = '#ABAB99';
        //      });
        //      if (weatherButton) weatherButton.style.backgroundColor = '#ABAB99';
        //      if (zoomButton) zoomButton.style.backgroundColor = '#ABAB99';
        //      if (reminderButton) reminderButton.style.backgroundColor = '#ABAB99';
        // }

        // Update zoom button image based on its state (handled by applyZoom function)
        // if (zoomButton) {
        //      zoomButton.innerHTML = `<img src="./zoon${zoomButton.dataset.zoomState === 'on' ? '+' : '-'}.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`;
        // }
    }

    function formatVersionDate(date) {
        const year = date.getUTCFullYear().toString().slice(-2);
        const month = String(date.getUTCMonth() + 1).padStart(2, '0');
        const day = String(date.getUTCDate()).padStart(2, '0');
        const hours = String(date.getUTCHours()).padStart(2, '0');
        return `${year}.${month}.${day}${hours}`;
    }

    async function getLastModifiedDate() {
        const cacheKey = 'teslaHtmlLastModified';
        const cacheTimestampKey = 'teslaHtmlLastModifiedTimestamp';
        const cacheDuration = 24 * 60 * 60 * 1000;
        const cachedDate = localStorage.getItem(cacheKey);
        const cachedTimestamp = localStorage.getItem(cacheTimestampKey);
        const now = new Date().getTime();
        if (cachedDate && cachedTimestamp && now - cachedTimestamp < cacheDuration) {
            return new Date(cachedDate);
        }
        try {
            // Fetch version.txt with no cache to get the latest date
            const response = await fetch('https://boardinggate.github.io/Tesla/version.txt', {
                cache: 'no-cache'
            });

            if (!response.ok) {
                // If fetch fails, fall back to cached date if available
                console.warn(`Error fetching version.txt: ${response.status} ${response.statusText}. Using cached date if available.`);
                if (cachedDate) {
                     return new Date(cachedDate);
                }
                 // If no cached date either, use a default
                throw new Error('Could not fetch version.txt and no cached date available.');
            }

            const text = await response.text();
            const lastModifiedDate = new Date(text.trim());
            if (isNaN(lastModifiedDate.getTime())) {
                 // If date from file is invalid, use cached if available, else default
                 console.warn('Invalid date format in version.txt. Using cached date if available.');
                 if (cachedDate) {
                     return new Date(cachedDate);
                 }
                 throw new Error('Invalid date format in version.txt and no cached date.');
            }

            // Cache the valid date and timestamp
            localStorage.setItem(cacheKey, lastModifiedDate.toISOString());
            localStorage.setItem(cacheTimestampKey, now.toString());
            return lastModifiedDate;

        } catch (error) {
            console.error('Failed to determine version date:', error);
            // Use a default date if everything else fails
            return new Date('2024-01-01T00:00:00Z');
        }
    }


    async function updateVersion() {
        const lastModifiedDate = await getLastModifiedDate();
        const version = formatVersionDate(lastModifiedDate);
        const versionElement = document.getElementById('version');
        if (versionElement) {
            versionElement.textContent = `versión: ${version}`;
        } else {
             console.error("Element with id 'version' not found.");
        }
    }

    const getFaviconUrl = (bookmark) => {
        try {
            if (bookmark.favicon) return bookmark.favicon;
             // Use a default icon if URL is missing or invalid
            if (!bookmark.url) return 'https://via.placeholder.com/64'; // Placeholder if no URL
            const url = new URL(bookmark.url); // Check if URL is valid
            const domain = url.hostname;
            return `https://www.google.com/s2/favicons?domain=${domain}&sz=64`;
        } catch (e) {
             console.error("Error generating favicon URL:", e, bookmark);
            return 'https://via.placeholder.com/64'; // Fallback on error
        }
    };

     // --- Color Generation Logic (Kept) ---
    function generateBrightColor() {
        const hue = Math.floor(Math.random() * 360);
        const saturation = 40 + Math.floor(Math.random() * 30);
        const lightness = 80 + Math.floor(Math.random() * 15);
        return `hsla(${hue}, ${saturation}%, ${lightness}%, 0.64)`;
    }

    function areColorsSimilar(color1, color2) {
        if (!color1 || !color2) return false;
         // Robust parsing of HSL(A)
        const parseHsl = (colorString) => {
             const match = colorString.match(/hsla?\((\d+),\s*(\d+)%?,\s*(\d+)%?,?\s*([\d\.]+)?\)/);
             if (!match) return null;
             return {
                 h: parseInt(match[1]),
                 s: parseInt(match[2]),
                 l: parseInt(match[3]),
                 a: match[4] ? parseFloat(match[4]) : 1
             };
        };

        const hsl1 = parseHsl(color1);
        const hsl2 = parseHsl(color2);

        if (!hsl1 || !hsl2) return false;

        const hueDiff = Math.abs(hsl1.h - hsl2.h);
        const minHueDiff = Math.min(hueDiff, 360 - hueDiff);

        // Define similarity threshold (e.g., less than 60 degrees difference in hue)
        return minHueDiff < 60;
    }

    const colors = Array(TOTAL_CELLS).fill(null);
    for (let i = 0; i < TOTAL_CELLS; i++) {
        if (bookmarks[i] !== null) {
            let color;
            let attempts = 0;
            do {
                color = generateBrightColor();
                attempts++;
                if (attempts > 100) { // Increase attempts slightly for more grid positions
                     console.warn(`Could not find a dissimilar color after ${attempts} attempts for cell ${i}.`);
                     break; // Prevent infinite loops
                }
            } while (
                // Check adjacent cells (above, below, left, right)
                (i >= COLS && areColorsSimilar(color, colors[i - COLS])) || // Above
                (i < TOTAL_CELLS - COLS && areColorsSimilar(color, colors[i + COLS])) || // Below
                (i % COLS !== 0 && i > 0 && colors[i - 1] !== null && areColorsSimilar(color, colors[i - 1])) || // Left
                (i % COLS !== COLS - 1 && i < TOTAL_CELLS - 1 && colors[i + 1] !== null && areColorsSimilar(color, colors[i + 1])) // Right
            );
            colors[i] = color;
        }
    }
    // --- End Color Generation Logic ---


    const toggleRanges = [
        { start: 18, end: 29, name: "ELECTROVERSE", label: "PdR,s" },
        { start: 30, end: 41, name: "GROK", label: "iAs" },
        { start: 42, end: 59, name: "TradingView", label: "Útil" },
        { start: 60, end: 95, name: "JOdena", label: "Varios" }
    ];
    const cellElements = [];
    Array.from({ length: TOTAL_CELLS }).forEach((_, index) => {
        const cell = document.createElement('div');
        if (index < bookmarks.length && bookmarks[index] !== null) {
            const bookmark = bookmarks[index];
            const link = document.createElement('a');
            link.className = 'bookmark-item'; // Apply bookmark-item to all
            link.title = bookmark.name;
            link.style.backgroundColor = colors[index];
            link.href = bookmark.url || "#";
            if (bookmark.url && bookmark.url !== "#") { // Only open in new tab if URL exists
                link.target = "_blank";
                link.rel = "noopener noreferrer";
            } else {
                 // If no URL, make it non-clickable or show message? Make it just decorative.
                 link.style.cursor = 'default';
                 link.addEventListener('click', (e) => { e.preventDefault(); console.log(`Bookmark "${bookmark.name}" has no URL.`); });
            }

            if (bookmark.name !== "" || bookmark.favicon) { // Render content if name or favicon exists
                const img = document.createElement('img');
                img.src = getFaviconUrl(bookmark);
                img.alt = `Favicon de ${bookmark.name}`;
                img.loading = "lazy";
                img.onerror = () => (img.src = 'https://via.placeholder.com/64');
                if (bookmark.name === "Mis Updates") img.classList.add('favicon-red');
                else if (bookmark.name === "Olas Updates") img.classList.add('favicon-blue');

                const name = document.createElement('span');
                name.className = 'bookmark-name';
                name.textContent = bookmark.name || 'Sin Nombre'; // Default text if name is empty

                link.appendChild(img);
                link.appendChild(name);
            }

            cell.appendChild(link);
        } else {
            cell.className = 'bg-gray-50 border border-dashed border-gray-200 rounded-lg';
        }
        grid.appendChild(cell);
        cellElements.push(cell);
    });

    const scrollToggle = document.getElementById('scroll-toggle');

    // Create fixed buttons dynamically and append to body
    const onOffToggle = document.createElement('img');
    onOffToggle.className = 'toggle-image'; 
    onOffToggle.id = 'on-off-toggle';
    onOffToggle.dataset.state = 'on'; // Default state
    document.body.appendChild(onOffToggle);

    const toggleButtons = toggleRanges.map((range, index) => {
        const toggle = document.createElement('span');
        toggle.className = 'toggle-sign range-toggle'; 
        toggle.dataset.rangeStart = range.start;
        toggle.dataset.rangeEnd = range.end;
        toggle.dataset.state = 'visible'; // Default state
        document.body.appendChild(toggle);
        return toggle;
    });

    const weatherButton = document.createElement('span');
    weatherButton.className = 'toggle-sign'; 
    weatherButton.id = 'weather-button';
    weatherButton.innerHTML = `<img src="https://www.google.com/s2/favicons?domain=accuweather.com&sz=64" alt="Tiempo" style="max-width: 60%; max-height: 60%; object-fit: contain;">`;
    document.body.appendChild(weatherButton);

    const reminderButton = document.createElement('span');
    reminderButton.className = 'toggle-sign';
    reminderButton.id = 'reminder-button';
    document.body.appendChild(reminderButton);

    const zoomButton = document.createElement('span');
    zoomButton.className = 'toggle-sign';
    zoomButton.id = 'zoom-button';
    zoomButton.dataset.zoomState = 'off'; // Default state
    document.body.appendChild(zoomButton);

    const darkModeToggle = document.createElement('img');
    darkModeToggle.className = 'toggle-image'; 
    darkModeToggle.id = 'dark-mode-toggle';
    document.body.appendChild(darkModeToggle);

    // Get references to Config, Home, Reload buttons from the HTML (inside the header)
    const reloadButton = document.getElementById('reload-button');
    const homeButton = document.getElementById('home-button');
    const configButton = document.getElementById('config-button');


    // --- Event Listeners for Side Buttons (Fixed) ---
     if(darkModeToggle) {
        darkModeToggle.addEventListener('click', () => {
            if (isMinimalMode) return;
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark-mode', isDarkMode);
            updateButtonStyles();
            saveSettings();
        });
     }

    // --- Event Listeners for Header Buttons (Absolute) ---
     if(configButton) {
        configButton.addEventListener('click', () => {
            if (isMinimalMode) return;
            // Show a simple placeholder or toast for the Config button
             showToast('Configuración (Próximamente)', 'info');
            // If you wanted to re-enable the complex modal later,
            // you would uncomment showConfigModal() and keep that function's code.
            // showConfigModal(); // <-- Call the function if complex modal is desired
        });
     }

     if(homeButton) {
        homeButton.addEventListener('click', (e) => {
            if (isMinimalMode) return;
            e.preventDefault();
            window.history.back();
        });
     }

     if(reloadButton) {
        reloadButton.addEventListener('click', () => {
            if (isMinimalMode) return;
            location.reload();
        });
     }


    function clamp(min, val, max) {
        return Math.min(Math.max(val, min), max);
    }

    function updateToggleState(toggle) {
        const start = parseInt(toggle.dataset.rangeStart);
        const end = parseInt(toggle.dataset.rangeEnd);
        const currentState = toggle.dataset.state;
        const newState = currentState === 'visible' ? 'hidden' : 'visible';
        const label = toggleRanges.find(r => r.start === start).label;
        toggle.dataset.state = newState; // Update state first
        toggle.innerHTML = `<span class="sign">${newState === 'visible' ? '-' : '+'}</span>${label}`;
        const onOffToggle = document.getElementById('on-off-toggle'); // Get reference
        const masterState = onOffToggle ? onOffToggle.dataset.state : 'on'; // Default if element not found


        for (let i = start; i <= end; i++) {
            if (cellElements[i]) {
                // Hide if master is off OR if the individual toggle is hidden
                const shouldHide = masterState === 'off' || newState === 'hidden';
                cellElements[i].classList.toggle('hidden', shouldHide);
            }
        }
        updateButtonStyles(); 
        saveSettings(); 
    }

    function updateAllToggles(newState) {
        const onOffToggle = document.getElementById('on-off-toggle');
        if (!onOffToggle) return; // Check if element exists

        onOffToggle.dataset.state = newState;
        for (let i = 0; i <= 17; i++) {
            if (cellElements[i]) {
                cellElements[i].classList.toggle('hidden', newState === 'off');
            }
        }

        document.querySelectorAll('.range-toggle').forEach(toggle => { // Select range toggles
            const start = parseInt(toggle.dataset.rangeStart);
            const end = parseInt(toggle.dataset.rangeEnd);
            const individualState = toggle.dataset.state; // Keep individual state

            for (let i = start; i <= end; i++) {
                if (cellElements[i]) {
                    // Hide if master is off OR if the individual toggle is hidden
                    const shouldHide = newState === 'off' || individualState === 'hidden';
                    cellElements[i].classList.toggle('hidden', shouldHide);
                }
            }
             const label = toggleRanges.find(r => r.start == start).label;
             toggle.innerHTML = `<span class="sign">${individualState === 'visible' ? '-' : '+'}</span>${label}`;
        });
        updateButtonStyles(); 
        saveSettings(); 
    }


    if(scrollToggle) {
        scrollToggle.addEventListener('click', () => {
            if (isMinimalMode) return;
            const scrollPosition = window.scrollY;
            const maxScroll = document.body.scrollHeight - window.innerHeight;
            if (scrollPosition < 100) {
                window.scrollTo({ top: maxScroll, behavior: 'smooth' });
            } else {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        });
    }
 
    function handleOnOffAction() {
        if (pressStartTime !== null) { 
             const onOffToggle = document.getElementById('on-off-toggle'); // Get reference
             if (onOffToggle) {
                const currentState = onOffToggle.dataset.state;
                const newState = currentState === 'on' ? 'off' : 'on';
                updateAllToggles(newState);
             }
        }
        pressStartTime = null; 
    }

    if(onOffToggle) {
        onOffToggle.addEventListener('mousedown', (e) => { e.preventDefault(); pressStartTime = Date.now(); });
        onOffToggle.addEventListener('mouseup', handleOnOffAction);
        onOffToggle.addEventListener('touchstart', (e) => { e.preventDefault(); pressStartTime = Date.now(); });
        onOffToggle.addEventListener('touchend', (e) => { e.preventDefault(); handleOnOffAction(); });
    }

    function handleReminderLongPress() {
        const pressDuration = Date.now() - reminderPressStartTime;
        if (pressDuration >= 500) { // Reduced long press threshold slightly for mobile
             showAllReminders(); // Show table on long press
        } else if (!isMinimalMode) {
            showReminderModal(); // Show add/edit modal on short press
        }
        reminderPressStartTime = null;
    }

    if(reminderButton) {
        reminderButton.addEventListener('mousedown', (e) => { e.preventDefault(); reminderPressStartTime = Date.now(); });
        reminderButton.addEventListener('mouseup', handleReminderLongPress);
        reminderButton.addEventListener('touchstart', (e) => { e.preventDefault(); reminderPressStartTime = Date.now(); });
        reminderButton.addEventListener('touchend', (e) => { e.preventDefault(); handleReminderLongPress(); });
    }

    document.querySelectorAll('.range-toggle').forEach(toggle => {
        toggle.addEventListener('click', () => {
            if (isMinimalMode) return;
            updateToggleState(toggle); 
        });
    });


    if(weatherButton) {
        weatherButton.addEventListener('click', () => {
            if (isMinimalMode) return;
            window.open('https://www.ventusky.com/?p=40.2;-4.7;5&l=rain-3h', '_blank');
        });
    }

    if(zoomButton) {
        zoomButton.addEventListener('click', () => {
            if (isMinimalMode) return;
            const currentState = zoomButton.dataset.zoomState;
            applyZoom(currentState === 'off' ? 'on' : 'off');
            // The state is already updated in applyZoom
            // zoomButton.dataset.zoomState = currentState === 'off' ? 'on' : 'off'; // Redundant
            updateButtonStyles(); // Ensure styles like zoomed class are applied
            saveSettings();
            adjustButtonPositions();
        });
    }
    
    function adjustButtonPositions() {
        // Calculate the height of the scroll toggle button dynamically
        const scrollToggleElement = document.getElementById('scroll-toggle');
        const scrollToggleHeight = scrollToggleElement ? scrollToggleElement.offsetHeight : 130; // Use a default if not found

        const buttonHeight = 79; // Approximate height of other fixed toggle buttons
        const buttonSpacing = 4; // Space between buttons
        const startTop = scrollToggleHeight + 13; // Starting position below scroll toggle

        // List of buttons that are positioned fixed on the left
        const fixedButtons = [
            onOffToggle,
            ...toggleButtons, // This is an array of elements
            weatherButton,
            reminderButton,
            zoomButton,
            darkModeToggle
        ].filter(btn => btn); // Filter out any null references if elements aren't found

        fixedButtons.forEach((button, index) => {
            const topPosition = startTop + index * (buttonHeight + buttonSpacing);
            button.style.top = `${topPosition}px`;
            button.style.left = '10px'; // Keep left position consistent
        });

        // The Config, Home, Reload buttons are positioned absolutely within the header
        // Their positioning is handled by CSS rules like `#config-button { left: 250px !important; }`
        // so they don't need to be included in this fixed positioning loop.
    }


    function updateNotice() {
        const noticeElement = document.getElementById('current-notice');
        if (!noticeElement || notices.length === 0) {
             if (!noticeElement) console.error("Element with ID 'current-notice' not found.");
             return;
        }
        noticeElement.textContent = notices[currentNoticeIndex];
        // Restart animation by clearing and re-applying
        noticeElement.style.animation = 'none';
        void noticeElement.offsetWidth; // Trigger reflow
        noticeElement.style.animation = 'fadeInOut 14s infinite';
        currentNoticeIndex = (currentNoticeIndex + 1) % notices.length;
    }

  function toggleNotices() {
    isActive = !isActive;
    console.log('Toggling notices, isActive:', isActive);
    const noticesContainer = document.querySelector('.notices-container');
    const footerContent = document.querySelector('.footer-content');

    if(noticesContainer) noticesContainer.style.display = isActive ? 'flex' : 'none';

    // Footer visibility depends on both isActive and isFooterVisible state if you added a separate footer toggle
    // Based on the original code, footer visibility seems linked to the notice toggle.
    if(footerContent) footerContent.style.display = isActive ? 'block' : 'none';

    saveSettings(); // Save the new state
}

    function toggleFooterVisibility() {
         // In the original code, footer visibility seems tied to noticesActive.
         // If you added a separate footer toggle, this function would use isFooterVisible.
         // Reverting to original behavior where footer is tied to notices.
        const footer = document.querySelector('footer');
        if(footer) {
            // Hide footer if notices are inactive or if minimal mode is on
            if (!isActive || isMinimalMode) {
                footer.classList.add('footer-hidden');
            } else {
                footer.classList.remove('footer-hidden');
            }
        }
        // Note: isFooterVisible state variable is still saved/loaded, but not used by this function
        // if footer visibility is solely controlled by noticesActive + minimalMode.
        // If you intended a separate footer toggle, this function needs revision.
        // Assuming it follows the original code's visible behavior tied to notices.
    }

    const noticeToggleIcon = document.getElementById('notice-toggle-icon');
    if(noticeToggleIcon) {
        noticeToggleIcon.addEventListener('click', () => {
            if (isMinimalMode) return;
            toggleNotices(); // Toggle notices (which also affects footer)
            toggleFooterVisibility(); // Ensure footer visibility is updated
        });
    }

    const backButton = document.getElementById('back-button');
    const forwardButton = document.getElementById('forward-button');

    if(backButton) {
        backButton.addEventListener('click', () => {
            window.history.back();
        });
    }

    if(forwardButton) {
        forwardButton.addEventListener('click', () => {
            window.history.forward();
        });
    }


    let touchStartX = 0;
    let touchEndX = 0;

    document.addEventListener('touchstart', (e) => {
        // Only track touches that start near the edges (e.g., left 150px or right 150px)
        const edgeThreshold = 150; // Pixels from edge
        if (e.changedTouches && e.changedTouches[0]) {
             if (e.changedTouches[0].clientX < edgeThreshold || e.changedTouches[0].clientX > window.innerWidth - edgeThreshold) {
                touchStartX = e.changedTouches[0].screenX;
             } else {
                touchStartX = 0; // Ignore touches in the middle
             }
        } else {
             touchStartX = 0; // Handle cases without touch events (unlikely but safe)
        }
    }, { passive: true }); // Use passive listener for performance

    document.addEventListener('touchend', (e) => {
        if (touchStartX === 0) return; // Ignore if touch didn't start near edge
         if (e.changedTouches && e.changedTouches[0]) {
             touchEndX = e.changedTouches[0].screenX;
             handleSwipe();
         }
        touchStartX = 0; // Reset after handling
    }, { passive: true }); // Use passive listener for performance

    function handleSwipe() {
        const swipeDistance = touchEndX - touchStartX;
        const minSwipeDistance = 100; // Minimum distance for a swipe in pixels
        // Use both pixel threshold and percentage of screen width threshold
        const swipeThresholdPercent = 0.1; // 10% of screen width

        if (Math.abs(swipeDistance) > Math.max(minSwipeDistance, window.innerWidth * swipeThresholdPercent)) {
             if (swipeDistance > 0) { // Swipe right
                window.history.back();
             } else { // Swipe left
                window.history.forward();
             }
        }
    }


    function formatDateToDDMMMYY(dateStr) {
        if (!dateStr || dateStr === '-') return '-';
        const parts = dateStr.split('-');
        // Expect YYYY-MM-DD
        if (parts.length !== 3) {
             // Try parsing other formats if necessary, or just return the original string
             console.warn(`Fecha en formato inesperado para formatear: ${dateStr}`);
             return dateStr; // Return original if not standard YYYY-MM-DD
        }
        const [year, month, day] = parts;
        // Basic validation to ensure month and day are numbers
        if (isNaN(parseInt(month)) || isNaN(parseInt(day)) || isNaN(parseInt(year))) {
             console.warn(`Partes de fecha inválidas: ${dateStr}`);
             return dateStr;
        }

        const months = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
        const monthIndex = parseInt(month) - 1;
        if (monthIndex < 0 || monthIndex > 11) {
             console.warn(`Índice de mes inválido: ${month}. Fecha: ${dateStr}`);
             return dateStr;
        }
         // Ensure day is padded if needed
        const formattedDay = String(parseInt(day)).padStart(2, '0');
        return `${formattedDay}/${months[monthIndex]}/${year.slice(-2)}`; // Use slice(-2) for YY
    }

    // --- Reminder Parsing Logic (Kept and Refined) ---
     function parseReminderText(text) {
         const originalText = text; // Keep original for the text field
         // Normalize and remove accents, convert to uppercase for easier regex matching
         let normalizedText = text.toUpperCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');

         const result = {
             text: originalText, // Store original text input
             type: 'simple', // Default type (no specific criteria met)
             time: null,
             date: null,
             repeatDays: [], // Store as numbers (0=Dom, 1=Lun...)
             intervalDays: null,
             timerMinutes: null
         };

         const numberWords = {
             'UNA': 1, 'UNO': 1, 'DOS': 2, 'TRES': 3, 'CUATRO': 4, 'CINCO': 5,
             'SEIS': 6, 'SIETE': 7, 'OCHO': 8, 'NUEVE': 9, 'DIEZ': 10,
             'ONCE': 11, 'DOCE': 12, 'TRECE': 13, 'CATORCE': 14, 'QUINCE': 15,
             'DIECISEIS': 16, 'DIECISIETE': 17, 'DIECIOCHO': 18, 'DIECINUEVE': 19,
             'VEINTE': 20, 'VEINTIUNO': 21, 'VEINTIDOS': 22, 'VEINTITRES': 23,
             'VEINTICUATRO': 24, 'VEINTICINCO': 25, 'VEINTISEIS': 26, 'VEINTISIETE': 27,
             'VEINTIOCHO': 28, 'VEINTINUEVE': 29, 'TREINTA': 30, 'TREINTAYUNO': 31
         };

         // --- Timer parsing ---
         // Match phrases like "ALARMA EN 30 MINUTOS", "RECORDAR EN 2 HORAS", "AVISO 5 MIN"
         const timerRegex = /(ALARMA|AVISO|AVISAR|AVISARME|TEMPORIZADOR|TIMER|RECORDAR|RECORDARME)\b.*?\b(?:EN\s*)?(\d+|\w+)\s*(MINUTOS?|HORAS?|MINS?|HRS?)/g;
         let timerMatchFound = false;
         // Use matchAll to find all potential matches, but we'll process them sequentially
         const timerMatches = Array.from(normalizedText.matchAll(timerRegex));

         if (timerMatches.length > 0) {
             // Process matches to find a valid number and unit
             for (const match of timerMatches) {
                  const valueText = match[2]; // The number word or digit
                  const unit = match[3]; // MINUTOS/HORAS etc.
                  let value = numberWords[valueText] || parseInt(valueText); // Convert word or parse digit

                 if (value !== undefined && !isNaN(value)) { // Check if a valid number was found
                     result.timerMinutes = (unit.startsWith('HORA') || unit.startsWith('HR')) ? value * 60 : value; // Convert hours to minutes
                     result.type = 'timer'; // Explicitly set type to timer
                     timerMatchFound = true;
                     // For timers based on relative time (e.g., "in 30 minutes"),
                     // we calculate the end time and populate date/time fields for display in modal.
                     const endTime = new Date(Date.now() + result.timerMinutes * 60 * 1000);
                     result.time = `${endTime.getHours().toString().padStart(2, '0')}:${endTime.getMinutes().toString().padStart(2, '0')}`;
                     result.date = `${endTime.getFullYear()}-${(endTime.getMonth() + 1).toString().padStart(2, '0')}-${endTime.getDate().toString().padStart(2, '0')}`;
                     break; // Stop after finding the first valid timer phrase
                 }
             }
         }


         // --- Time parsing (only if NOT a timer or explicitly setting time) ---
         // Prioritize direct HH:MM format
          const timeRegex = /\b(\d{1,2}):(\d{2})\b/;
          const timeMatches = normalizedText.match(timeRegex);
          if (timeMatches) {
              let hours = parseInt(timeMatches[1]);
              let minutes = parseInt(timeMatches[2]);
              if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) {
                  result.time = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                   if (result.type === 'simple') result.type = 'hourly'; // If no other type set yet, it's at least hourly
              }
          } else {
              // Parse time from text like "A LAS TRES Y MEDIA"
               const timeTextRegex = /\bA\s*LAS?\s*(\w+|\d{1,2})\s*(?:Y\s*(CUARTO|MEDIA|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA))?(?:\s*MENOS\s*(CUARTO|DIEZ|VEINTE|TREINTA|CUARENTA|CINCUENTA))?\s*(DE\s*LA\s*(MAÑANA|TARDE|NOCHE))?/i;
               const timeTextMatches = normalizedText.match(timeTextRegex);
               if (timeTextMatches) {
                  let hours = numberWords[timeTextMatches[1]] || parseInt(timeTextMatches[1]) || 0;
                  const minuteText = timeTextMatches[2] || ''; // Part after 'Y'
                  const minusPart = timeTextMatches[3] || ''; // Part after 'MENOS'
                  const period = timeTextMatches[5] || null; // MAÑANA, TARDE, NOCHE

                  let minutes = 0;
                  if (minuteText) {
                      minutes = minuteText === 'CUARTO' ? 15 :
                                minuteText === 'MEDIA' ? 30 :
                                minuteText === 'DIEZ' ? 10 :
                                minuteText === 'VEINTE' ? 20 :
                                minuteText === 'TREINTA' ? 30 :
                                minuteText === 'CUARENTA' ? 40 :
                                minuteText === 'CINCUENTA' ? 50 :
                                0;
                  } else if (minusPart) {
                      minutes = minusPart === 'CUARTO' ? 15 :
                                minusPart === 'DIEZ' ? 10 :
                                minusPart === 'VEINTE' ? 20 :
                                minusPart === 'TREINTA' ? 30 :
                                minusPart === 'CUARENTA' ? 40 :
                                minusPart === 'CINCUENTA' ? 50 :
                                0;
                       // Adjust hours and minutes for "menos"
                       hours = (hours - 1 + 24) % 24; // Subtract 1 hour, handle midnight (1 AM minus 1 hour is 0 AM)
                       minutes = 60 - minutes;
                  }

                   // Adjust hours based on period (MAÑANA, TARDE, NOCHE) if period is specified
                   if (period) {
                       if (period === 'TARDE' && hours < 12) hours += 12; // 1-11 TARDE -> 13-23
                       if (period === 'NOCHE') {
                           if (hours >= 1 && hours <= 5) hours += 12; // 1-5 NOCHE -> 13-17 (PM)
                           else if (hours >= 6 && hours <= 11) hours += 12; // 6-11 NOCHE -> 18-23 (PM)
                           else if (hours === 12) hours = 0; // 12 NOCHE -> 0 (AM)
                       }
                       if (period === 'MAÑANA' && hours === 12) hours = 0; // 12 MAÑANA -> 0 (AM)
                   } else {
                        // If no period, make an educated guess (common for voice)
                        // Assume hours 1-5 are PM (e.g., "a las tres" means 3 PM / 15:00)
                        if (hours >= 1 && hours <= 5) {
                           hours += 12;
                        }
                        // Assume hours 6-12 are AM (e.g., "a las ocho" means 8 AM / 08:00)
                   }


                  if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) {
                      result.time = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                       if (result.type === 'simple') result.type = 'hourly'; // If no other type set yet, it's at least hourly
                  }
               }
          }


         // --- Repetition parsing (Weekly) ---
         const weeklyRegex = /(TODOS\s+LOS|LOS|CADA)?\s*(LUNES|MARTES|MIERCOLES|JUEVES|VIERNES|SABADO|DOMINGO)/g;
         // Find all occurrences of day names
         const weeklyMatches = Array.from(normalizedText.matchAll(weeklyRegex));

         for (const match of weeklyMatches) {
             const dayName = match[2]; // e.g., "LUNES"
             if (daysMap[dayName] !== undefined && !result.repeatDays.includes(daysMap[dayName])) {
                 result.repeatDays.push(daysMap[dayName]); // Add numeric day (0-6)
             }
         }

         if (result.repeatDays.length > 0) {
             result.type = 'weekly'; // Set type if repeating days are found
              // If no date is explicitly set for a weekly reminder, set it to today.
              // The reminder checking logic will figure out the *first* upcoming day to notify.
              if (!result.date) {
                  const now = new Date();
                  result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
              }
         }


         // --- Interval parsing ---
         // Match "CADA 7 DIAS"
         const intervalRegex = /CADA\s*(\d+)\s*DIAS?/;
         const intervalMatch = normalizedText.match(intervalRegex);
         if (intervalMatch) {
             result.intervalDays = parseInt(intervalMatch[1]);
             if (result.intervalDays > 0) { // Ensure interval is positive
                 result.type = 'interval'; // Set type if interval is found
                  // If no date is set for an interval reminder, default the start date to today.
                  if (!result.date) {
                      const now = new Date();
                      result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
                  }
             } else {
                 result.intervalDays = null; // Ignore interval if 0 or negative
             }
         }

         // --- Date parsing (prioritized if not already set by Timer) ---
         // Specific date keywords: HOY, MAÑANA, PASADO MAÑANA
         // These override date derived from a timer if they appear in text, unless it's purely a timer phrase.
         // Let's apply these only if result.date wasn't already set by a calculated timer end time.
          if (result.type !== 'timer' || !result.date) { // Only parse date if not set by timer or if it's *not* just a timer phrase
               if (normalizedText.includes('PASADO MANANA')) {
                  const now = new Date();
                  const targetDate = new Date(now);
                  targetDate.setDate(now.getDate() + 2);
                  result.date = `${targetDate.getFullYear()}-${(targetDate.getMonth() + 1).toString().padStart(2, '0')}-${targetDate.getDate().toString().padStart(2, '0')}`;
                   if (result.type === 'simple') result.type = 'daily'; // Mark as daily if no other type set
              } else if (normalizedText.includes('MANANA')) {
                  const now = new Date();
                  const targetDate = new Date(now);
                  targetDate.setDate(now.getDate() + 1);
                  result.date = `${targetDate.getFullYear()}-${(targetDate.getMonth() + 1).toString().padStart(2, '0')}-${targetDate.getDate().toString().padStart(2, '0')}`;
                   if (result.type === 'simple') result.type = 'daily';
              } else if (normalizedText.includes('HOY')) {
                  const now = new Date();
                  result.date = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
                   if (result.type === 'simple') result.type = 'daily';
              }

              // Specific date: "EL DIA 22" (Assumes current/next month) - Apply only if date not yet set
               const dateSpecificDayRegex = /(?:EL\s*DIA\s*)(\d{1,2})\b/;
               const dateSpecificDayMatch = normalizedText.match(dateSpecificDayRegex);
               if (!result.date && dateSpecificDayMatch) {
                   const day = parseInt(dateSpecificDayMatch[1]);
                   const now = new Date();
                   let month = now.getMonth(); // 0-indexed
                   let year = now.getFullYear();
                   const currentDayOfMonth = now.getDate();

                   if (day >= 1 && day <= 31) {
                       // If the specified day is before the current day of the month, assume next month
                       if (day <= currentDayOfMonth) {
                            month++;
                           if (month > 11) { // December -> January next year
                               month = 0;
                               year++;
                           }
                       }
                       // Validate if the day exists in the target month/year
                       const testDate = new Date(year, month, day);
                       if (testDate.getDate() === day && testDate.getMonth() === month && testDate.getFullYear() === year) {
                            result.date = `${year}-${(month + 1).toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
                             if (result.type === 'simple') result.type = 'daily';
                       }
                   }
               }

               // Relative date: "DENTRO DE 15 DIAS" - Apply only if date not yet set
               const dateInDaysRegex = /(?:DENTRO\s*DE\s*)(\d+)\s*DIAS?/;
               const dateInDaysMatch = normalizedText.match(dateInDaysRegex);
               if (!result.date && dateInDaysMatch) {
                   const days = parseInt(dateInDaysMatch[1]);
                   const targetDate = new Date();
                   targetDate.setDate(targetDate.getDate() + days);
                   result.date = `${targetDate.getFullYear()}-${(targetDate.getMonth() + 1).toString().padStart(2, '0')}-${targetDate.getDate().toString().padStart(2, '0')}`;
                    if (result.type === 'simple') result.type = 'daily';
               }

              // Specific date: DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY (or YY) - Apply only if date not yet set
              const manualDateRegex = /(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{2,4})/;
              const manualDateMatch = normalizedText.match(manualDateRegex);
              if (!result.date && manualDateMatch) {
                  let day = parseInt(manualDateMatch[1]);
                  let month = parseInt(manualDateMatch[2]);
                  let year = parseInt(manualDateMatch[3]);
                  if (year < 100) year += 2000; // Convert AA to AAAA (e.g., 25 → 2025)
                  // Basic validation and check if the date is actually valid
                  if (day >= 1 && day <= 31 && month >= 1 && month <= 12 && year >= 2000) {
                       const testDate = new Date(year, month - 1, day);
                       if (testDate.getDate() === day && testDate.getMonth() + 1 === month && testDate.getFullYear() === year) {
                          result.date = `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
                           if (result.type === 'simple') result.type = 'daily';
                       }
                  }
              }
          }


         // Ensure time is set to a default if date/repeat/interval exist but time doesn't
         // and it's not a timer (as timers get time from calculation)
         if (!result.time && (result.date || result.repeatDays.length > 0 || result.intervalDays !== null) && result.type !== 'timer') {
             result.time = '00:01'; // Default to 00:01 if date/repeat/interval exists but no explicit time
              if (result.type === 'simple') result.type = 'daily'; // If it now has a date/repeat/interval, it's not simple
         }

         // If it's still 'simple' and has a time but no date/repeat/interval, mark as hourly
         if (result.type === 'simple' && result.time && !result.date && result.repeatDays.length === 0 && result.intervalDays === null) {
             result.type = 'hourly';
         }

         // If it has date but no time/repeat/interval, mark as daily
         if (result.type === 'simple' && result.date && !result.time && result.repeatDays.length === 0 && result.intervalDays === null) {
              result.type = 'daily';
         }


         // Final check on type based on parsed values
         if (result.timerMinutes !== null) {
              result.type = 'timer';
         } else if (result.intervalDays !== null) {
              result.type = 'interval';
         } else if (result.repeatDays.length > 0) {
              result.type = 'weekly';
         } else if (result.date) {
              result.type = 'daily';
         } else if (result.time) {
              result.type = 'hourly';
         } else {
              result.type = 'simple';
         }


         console.log("Parsed Result:", result);
         return result;
     }

    // Mostrar ventana de ayuda
    function showHelpModal() {
        // Close any other modals first
        closeAllModals();

        const helpModal = document.createElement('div');
        helpModal.className = 'help-modal';
        helpModal.setAttribute('aria-label', 'Ayuda para recordatorios');
        helpModal.innerHTML = `
            <h2 class="text-2xl font-bold text-gray-900">Ayuda para Recordatorios</h2>
            <p class="text-gray-700 mb-4">Usa comandos de voz o escribe en el campo de texto para configurar recordatorios. Ejemplos:</p>
            <ul class="list-disc pl-6 text-gray-700 mb-4">
                <li><strong>Texto:</strong> "Recordar mi cita", "Llamar a mamá"</li>
                <li><strong>Hora:</strong> "A LAS DIEZ Y CUARTO DE LA MAÑANA" → 10:15, "A LAS CINCO Y MEDIA DE LA TARDE" → 17:30, "A LAS OCHO MENOS CUARTO" → 07:45, "A LAS TRES" → 15:00 (horas 1-5 se asumen de la tarde si no se especifica)</li>
                <li><strong>Fecha:</strong> "HOY", "MAÑANA", "PASADO MAÑANA", "DENTRO DE 15 DÍAS", "EL DÍA 22", "EL PRÓXIMO LUNES", "25/05/2025", "25-05-25", "25.05.2025"</li>
                <li><strong>Repetición:</strong> "CADA LUNES", "TODOS LOS VIERNES Y SÁBADOS"</li>
                <li><strong>Intervalo:</strong> "CADA 7 DÍAS" (usa "CADA" seguido del número de días)</li>
                <li><strong>Temporizador:</strong> "ALARMA EN 30 MINUTOS", "RECORDAR EN 2 HORAS", "AVISO EN 45 MINUTOS" (usa "ALARMA", "AVISO", "RECORDAR", "TEMPORIZADOR", etc.)</li>
            </ul>
            <p class="text-gray-700 mb-4">Formatos de fecha aceptados: DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY, DD/MM/YY, DD-MM-YY, DD.MM.YY</p>
            <p class="text-gray-700 mb-4">Nota: Puedes combinar hora, fecha, días, intervalo y temporizador en un solo texto, y todos se aplicarán.</p>
             <p class="text-gray-700 mb-4">Nota: El reconocimiento de voz requiere que uses el botón del micrófono junto al campo de texto.</p>
            <div class="button-group flex justify-end">
                <button type="button" id="close-help">Cerrar</button>
            </div>
        `;
        document.body.appendChild(helpModal);
        helpModal.querySelector('#close-help').addEventListener('click', () => {
            if (helpModal.parentNode) document.body.removeChild(helpModal);
        });
    }

function showReminderModal(reminder = null) {
    // Close any other modals first
    closeAllModals();

    // Use existing reminder data or default empty structure for new reminder
    const reminderData = reminder ? reminder : { id: null, text: '', type: 'simple', time: null, date: '', repeatDays: [], intervalDays: null, timerMinutes: null, createdAt: null, timerEnd: null };
    
    // Format date for input field (YYYY-MM-DD to DD/MM/YYYY) if it exists and is in the expected format
    let formattedDate = '';
    if (reminderData.date && reminderData.date.match(/^\d{4}-\d{2}-\d{2}$/)) {
        const [year, month, day] = reminderData.date.split('-');
        formattedDate = `${day}/${month}/${year}`;
    } else if (reminderData.date) {
         // If date exists but isn't in YYYY-MM-DD, use it directly (might be from old parsing)
         formattedDate = reminderData.date;
    }


    const modal = document.createElement('div');
    modal.className = 'reminder-modal';
    modal.setAttribute('aria-label', 'Formulario de recordatorio');
    modal.innerHTML = `
        <h2 class="text-2xl font-bold text-gray-900">RECORDATORIOS</h2>
        <form id="reminder-form">
            <div class="form-grid">
                <div class="full-width">
                     <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <button type="button" id="clear-fields" class="speech-button" title="Limpiar campos" style="background-color: #D1D5DB; color: #111827; flex-shrink: 0;">Limpiar</button>
                        <textarea id="reminder-text" rows="4" required style="flex-grow: 1;">${reminderData.text.replace(/<b>|<\/b>/g, '')}</textarea>
                        <button type="button" id="start-speech" class="speech-button" title="Iniciar reconocimiento de voz" style="flex-shrink: 0;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mic"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                        </button>
                    </div>
                    <p id="speech-status" class="speech-status"></p>
                    <p id="parse-status" class="text-sm mt-1"></p>
                </div>
                <div>
                    <label for="reminder-time">Hora (HH:MM):</label>
                    <input type="text" id="reminder-time" placeholder="HH:MM" pattern="^([01]\\d|2[0-3]):([0-5]\\d)$" value="${reminderData.time || ''}">
                </div>
                <div>
                    <label for="reminder-date">Fecha (DD/MM/AAAA):</label>
                    <input type="text" id="reminder-date" placeholder="DD/MM/AAAA" pattern="^\\d{2}/\\d{2}/\\d{4}$" value="${formattedDate}">
                </div>
                <div>
                    <label for="reminder-interval">Intervalo (días):</label>
                    <input type="number" id="reminder-interval" min="1" value="${reminderData.intervalDays || ''}">
                </div>
                <div>
                    <label for="reminder-timer">Temporizador (minutos):</label>
                    <input type="number" id="reminder-timer" min="1" value="${reminderData.timerMinutes || ''}">
                </div>
                <div class="full-width">
                    <label>Días de repetición:</label>
                    <div class="days-group">
                        ${['Lun ', 'Mar ', 'Mié ', 'Jue ', 'Vie ', 'Sáb ', 'Dom '].map((day, i) => `
                            <label style="flex: 0 0 auto;">
                                <input type="checkbox" name="repeat" value="${(i + 1) % 7}" ${reminderData.repeatDays && reminderData.repeatDays.includes((i + 1) % 7) ? 'checked' : ''}> ${day}
                            </label>
                        `).join('')}
                    </div>
                </div>
                <div class="full-width button-group">
                    <button type="submit" id="save-reminder">Aceptar <span id="countdown-save">25</span></button>
                    <button type="button" id="cancel-reminder">Cancelar</button>
                   <button type="button" id="view-reminders">Ver Recordatorios</button>
                   <button type="button" id="help-reminder">Ayuda</button>
                </div>
            </div>
            <p id="auto-save-timer" class="text-sm text-gray-600 mt-2">Se guardará automáticamente si no hay actividad.</p>
        </form>
    `;
    document.body.appendChild(modal);

    const parseStatus = modal.querySelector('#parse-status');
    const speechStatus = modal.querySelector('#speech-status');
    const autoSaveTimerLabel = modal.querySelector('#auto-save-timer');
    let countdownSaveElement = modal.querySelector('#countdown-save');
    const textInput = modal.querySelector('#reminder-text');
    const timeInput = modal.querySelector('#reminder-time');
    const dateInput = modal.querySelector('#reminder-date');
    const speechButton = modal.querySelector('#start-speech');
    const saveButton = modal.querySelector('#save-reminder');
    const clearButton = modal.querySelector('#clear-fields');

    let manualTimeInput = false; // Flag to prevent time parsing from overwriting manual input
    let manualDateInput = false; // Flag to prevent date parsing from overwriting manual input
    // Timers and timeouts are now stored on the modal element itself
    modal.autoSaveInterval = null;
    modal.parseTimeout = null;
    modal.focusTimeout = null;

    let countdownSave = 25; // Initial countdown value

    // Initialize countdown display
    if (countdownSaveElement) {
        countdownSaveElement.textContent = countdownSave;
    }

    // --- Timer and Focus Check Logic (Attached to modal element) ---
     function cleanUpModalTimers(modalElement) {
         if (modalElement.autoSaveInterval) clearInterval(modalElement.autoSaveInterval);
         modalElement.autoSaveInterval = null;
         if (modalElement.parseTimeout) clearTimeout(modalElement.parseTimeout);
         modalElement.parseTimeout = null;
         if (modalElement.focusTimeout) clearTimeout(modalElement.focusTimeout);
         modalElement.focusTimeout = null;
     }

     function startCountdown(modalElement) {
        cleanUpModalTimers(modalElement); // Ensure no other timers are running

        modalElement.autoSaveInterval = setInterval(() => {
            countdownSave--;
            if (countdownSaveElement) {
                 countdownSaveElement.textContent = countdownSave;
            }

            if (countdownSave <= 0) {
                cleanUpModalTimers(modalElement);
                const form = modalElement.querySelector('#reminder-form');
                if (form) {
                     console.log('Auto-saving form...');
                     const submitEvent = new Event('submit', { bubbles: true, cancelable: true });
                     form.dispatchEvent(submitEvent);
                } else {
                     console.error('Form not found for auto-save.');
                }
            }
        }, 1000);
    }

     function startFocusCheck(modalElement) {
         // Clear existing focus check timeout if any for this modal
         if (modalElement.focusTimeout) clearTimeout(modalElement.focusTimeout);

         modalElement.focusTimeout = setTimeout(() => {
             // Check if the modal is still in the DOM and if focus is *not* inside it
             if (document.body.contains(modalElement) && !modalElement.contains(document.activeElement)) {
                 console.log("Inactivity detected outside modal, refocusing text area.");
                 // Attempt to focus the text input
                 const textInput = modalElement.querySelector('#reminder-text');
                 if(textInput) textInput.focus();
             }
             // Restart the focus check regardless of whether focus was moved
             startFocusCheck(modalElement);
         }, 5000); // Check every 5 seconds
     }


     function resetAndStartCountdown(modalElement) {
         cleanUpModalTimers(modalElement); // Clean up existing timers
         countdownSave = 25; // Reset countdown value
         if (countdownSaveElement) { // Update display
              countdownSaveElement.textContent = countdownSave;
         }
         startCountdown(modalElement); // Start the countdown timer
         startFocusCheck(modalElement); // Start the focus check timer
     }
    // --- End Timer and Focus Check Logic ---


     // --- Speech Recognition Logic (Kept) ---
     if ('webkitSpeechRecognition' in window) {
         const recognition = new webkitSpeechRecognition();
         recognition.continuous = false; // Important: false so 'onend' fires on pauses
         recognition.interimResults = false;
         recognition.lang = 'es-ES'; // Spanish

         if (speechButton) {
             speechButton.addEventListener('click', () => {
                 // Clear any timers/timeouts before starting speech recognition
                 cleanUpModalTimers(modal);
                 recognition.start();
             });
         }

         recognition.onstart = () => {
             if(speechStatus) {
                  speechStatus.textContent = 'Escuchando...';
                  speechStatus.style.color = '#10B981'; // Green
             }
         };

         recognition.onresult = (event) => {
             const transcript = event.results[0][0].transcript;
             // Append the new transcript to the text area
             textInput.value += transcript;
             if(speechStatus) speechStatus.textContent = ''; // Clear status on result

             // Manually trigger input event to start parsing logic
             const inputEvent = new Event('input', { bubbles: true });
             textInput.dispatchEvent(inputEvent);
         };

         recognition.onerror = (event) => {
             console.error('Speech recognition error:', event.error);
             if(speechStatus) {
                  speechStatus.textContent = `Error: ${event.error}`;
                  speechStatus.style.color = '#EF4444'; // Red
             }
             // Reset timers/timeouts even if there's an error
             resetAndStartCountdown(modal);
         };

         recognition.onend = () => {
             console.log('Speech recognition ended.');
             // If no error message is displayed by onerror, clear status after a delay
             if(speechStatus && !speechStatus.textContent.startsWith('Error')) {
                 setTimeout(() => speechStatus.textContent = '', 2000);
             }
              // Ensure timers/timeouts are running again
             resetAndStartCountdown(modal);
         };

     } else {
         // Hide speech button and show message if not supported
         if(speechStatus) {
              speechStatus.textContent = 'Reconocimiento de voz no soportado en este navegador.';
              speechStatus.style.color = '#EF4444';
         }
         if (speechButton) speechButton.style.display = 'none';
     }
    // --- End Speech Recognition Logic ---


    // Event listeners to reset countdown and focus timer on interaction
    modal.querySelectorAll('input, textarea, button:not(#start-speech)').forEach(element => {
        element.addEventListener('input', () => {
            resetAndStartCountdown(modal);
        });
        element.addEventListener('focus', () => {
             // Stop focus check while an element *inside* the modal has focus
             if (modal.focusTimeout) clearTimeout(modal.focusTimeout);
             modal.focusTimeout = null;
        });
        element.addEventListener('blur', () => {
             // If focus leaves an element *inside* the modal, restart the check
             startFocusCheck(modal);
        });
         element.addEventListener('click', () => { // Also reset on button clicks etc.
            resetAndStartCountdown(modal);
         });
    });


    textInput.addEventListener('input', (e) => {
        const text = e.target.value || '';
        if (text.trim() === '') {
            // Clear all fields if text is empty
            clearFields();
             if(parseStatus) {
                  parseStatus.textContent = ''; // No parsing needed for empty text
                  parseStatus.classList.remove('text-green-600', 'text-red-600');
             }
            resetAndStartCountdown(modal); // Reset timer
            return;
        }

        if(parseStatus) {
             parseStatus.textContent = 'Esperando 4 segundos para parsear...';
             parseStatus.classList.remove('text-green-600', 'text-red-600');
        }


        // Clear previous parse timeout specific to this modal
        if (modal.parseTimeout) clearTimeout(modal.parseTimeout);

        modal.parseTimeout = setTimeout(() => {
            try {
                const parsed = parseReminderText(text);
                 console.log('Parsed result:', parsed); // Debug parsed result

                // Update fields only if they were NOT manually edited since the last parse/load
                 // Use the flags set by manual input listeners
                 if (!manualTimeInput && parsed.time) {
                     timeInput.value = parsed.time;
                 }
                 if (!manualDateInput && parsed.date) {
                     // Convert YYYY-MM-DD ISO format from parse back to DD/MM/YYYY for display
                     const [year, month, day] = parsed.date.split('-');
                     dateInput.value = `${day}/${month}/${year}`;
                 }

                 // Always update repeat days, interval, and timer as they are derived from the text
                 modal.querySelectorAll('input[name="repeat"]').forEach(input => {
                     // Ensure parsed.repeatDays is an array before checking includes
                     input.checked = (Array.isArray(parsed.repeatDays) ? parsed.repeatDays : []).includes(parseInt(input.value));
                 });
                 modal.querySelector('#reminder-interval').value = parsed.intervalDays || '';
                 modal.querySelector('#reminder-timer').value = parsed.timerMinutes || '';

                if(parseStatus) {
                     parseStatus.textContent = 'Datos parseados correctamente';
                     parseStatus.classList.add('text-green-600');
                     parseStatus.classList.remove('text-red-600');
                }


                // Reset manual input flags after parsing has potentially overwritten fields
                manualTimeInput = false;
                manualDateInput = false;

            } catch (error) {
                console.error('Error durante el parseo:', error);
                 if(parseStatus) {
                     parseStatus.textContent = `Error al parsear: ${error.message}`;
                     parseStatus.classList.add('text-red-600');
                     parseStatus.classList.remove('text-green-600');
                 }
            }
             resetAndStartCountdown(modal); // Reset countdown after parsing finishes
        }, 4000); // 4-second delay
    });


    const form = modal.querySelector('#reminder-form');
    form.addEventListener('submit', (e) => {
        e.preventDefault();
        console.log('Evento submit disparado');
        cleanUpModalTimers(modal); // Clean up timers before saving

        const textInput = modal.querySelector('#reminder-text');
        const timeInput = modal.querySelector('#reminder-time');
        const dateInput = modal.querySelector('#reminder-date');
        const intervalInput = modal.querySelector('#reminder-interval');
        const timerInput = modal.querySelector('#reminder-timer');

        const text = textInput.value.trim();
        if (!text) {
            console.log('Error: Texto vacío');
             if(parseStatus) {
                  parseStatus.textContent = 'El texto del recordatorio no puede estar vacío.';
                  parseStatus.classList.add('text-red-600');
                  parseStatus.classList.remove('text-green-600');
             }
             resetAndStartCountdown(modal); // Restart countdown
            return;
        }

        let time = timeInput.value.trim();
        let date = dateInput.value.trim(); // Use trimmed value
        const repeatDays = Array.from(modal.querySelectorAll('input[name="repeat"]:checked')).map(input => parseInt(input.value));
        const intervalDays = parseInt(intervalInput.value) || null;
        const timerMinutes = parseInt(timerInput.value) || null;

        let dateISO = null;
        if (date) { // Only validate/parse if date is entered
             if (date.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                 const [day, month, year] = date.split('/').map(Number);
                 // Basic validation
                 if (day >= 1 && day <= 31 && month >= 1 && month <= 12 && year >= 2000) {
                      // Check if date is valid for the month (e.g., no Feb 30)
                      const testDate = new Date(year, month - 1, day);
                      if (testDate.getDate() === day && testDate.getMonth() + 1 === month && testDate.getFullYear() === year) {
                           dateISO = `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
                      } else {
                          // Invalid date like Feb 30
                           if(parseStatus) {
                                parseStatus.textContent = 'Fecha inválida (DD/MM/AAAA)';
                                parseStatus.classList.add('text-red-600');
                                parseStatus.classList.remove('text-green-600');
                           }
                           resetAndStartCountdown(modal);
                           return;
                      }
                 } else {
                      // Basic range validation failed
                      if(parseStatus) {
                           parseStatus.textContent = 'Fecha inválida (DD/MM/AAAA)';
                           parseStatus.classList.add('text-red-600');
                           parseStatus.classList.remove('text-green-600');
                      }
                      resetAndStartCountdown(modal);
                      return;
                 }
             } else {
                  // Format validation failed
                  if(parseStatus) {
                       parseStatus.textContent = 'Formato de fecha requerido DD/MM/AAAA';
                       parseStatus.classList.add('text-red-600');
                       parseStatus.classList.remove('text-green-600');
                  }
                   resetAndStartCountdown(modal);
                  return;
             }
        }

        // Validate time format and range if time is entered
        if (time) {
             if (!time.match(/^\d{2}:\d{2}$/)) {
                 if(parseStatus) {
                      parseStatus.textContent = 'Formato de hora inválido (HH:MM)';
                      parseStatus.classList.add('text-red-600');
                      parseStatus.classList.remove('text-green-600');
                 }
                  resetAndStartCountdown(modal);
                 return;
             } else {
                  const [hours, minutes] = time.split(':').map(Number);
                 if (hours > 23 || minutes > 59) {
                     if(parseStatus) {
                          parseStatus.textContent = 'Hora inválida (00:00-23:59)';
                          parseStatus.classList.add('text-red-600');
                          parseStatus.classList.remove('text-green-600');
                     }
                      resetAndStartCountdown(modal);
                     return;
                 }
             }
        }


        // Determine the reminder type based on input fields (priority order)
        let type = 'simple'; // Default to simple if no other criteria met
        if (timerMinutes !== null) type = 'timer';
        else if (intervalDays !== null) type = 'interval';
        else if (repeatDays.length > 0) type = 'weekly';
        else if (dateISO) type = 'daily';
        else if (time) type = 'hourly';


        // Validation: A reminder needs *something* to trigger it unless it's explicitly 'simple'
        // If it's not 'simple' but lacks triggering criteria, it's invalid.
        // If it IS 'simple', it only needs text.
        if (type !== 'simple' && !time && !dateISO && repeatDays.length === 0 && intervalDays === null && timerMinutes === null) {
             if(parseStatus) {
                  parseStatus.textContent = 'Debe especificar hora, fecha, repetición, intervalo o temporizador si no es simple.';
                  parseStatus.classList.add('text-red-600');
                  parseStatus.classList.remove('text-green-600');
             }
              resetAndStartCountdown(modal);
             return;
        }

        // Default time to 00:01 for date/repeat/interval types if no time is explicitly given
        // This ensures checkReminders can handle them at the start of the day
        const finalTimeAdjusted = (!time && (dateISO || repeatDays.length > 0 || intervalDays !== null) && type !== 'timer') ? '00:01' : time;


        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');

        const now = new Date();
        const newReminder = {
            id: reminderData.id ? reminderData.id : Date.now(), // Use existing ID or create new one
            text: `<b>${text.toUpperCase()}</b>`, // Store text in uppercase and bold HTML
            type: type, // Use the determined type
            time: finalTimeAdjusted, // Use adjusted time
            date: dateISO, // Use ISO date format (YYYY-MM-DD)
            repeatDays: repeatDays, // Store as array of numbers
            intervalDays: intervalDays, // Store as number or null
            timerMinutes: timerMinutes, // Store as number or null
            createdAt: reminderData.createdAt ? reminderData.createdAt : now.toISOString(), // Keep original creation date or set new ISO string
            // Calculate timerEnd date *only* if the type is timer and minutes are specified
            timerEnd: (type === 'timer' && timerMinutes !== null) ? new Date(now.getTime() + timerMinutes * 60 * 1000).toISOString() : null
        };

        console.log('Saving reminder:', newReminder);

        if (reminderData.id) {
            // Update existing reminder
            const index = reminders.findIndex(r => r.id === reminderData.id);
            if (index !== -1) {
                reminders[index] = newReminder;
                showToast('Recordatorio actualizado.', 'success');
            } else {
                 // This should not happen if called from edit mode, but handle as fallback
                 reminders.push(newReminder); // Add as new if not found
                 showToast('Recordatorio guardado (como nuevo).', 'success');
            }
        } else {
            // Add new reminder
            reminders.push(newReminder);
            showToast('Recordatorio creado.', 'success');
        }

        localStorage.setItem('reminders', JSON.stringify(reminders));
        cleanUpModalTimers(modal); // Ensure timers are stopped before closing
        if (modal.parentNode) document.body.removeChild(modal); // Close the modal

        updateReminderCount(); // Update the globe count
        updateButtonStyles(); // Ensure button styles (like count) are updated
        // checkReminders(); // Optionally trigger an immediate check after saving,
                          // but the periodic check will handle it soon anyway.
    });

    // Use clearFields function for the clear button and potentially on empty text input
    function clearFields() {
         const modal = document.querySelector('.reminder-modal'); // Get modal reference
         if (!modal) return;
         modal.querySelector('#reminder-text').value = '';
         modal.querySelector('#reminder-time').value = '';
         modal.querySelector('#reminder-date').value = '';
         modal.querySelectorAll('input[name="repeat"]').forEach(input => input.checked = false);
         modal.querySelector('#reminder-interval').value = '';
         modal.querySelector('#reminder-timer').value = '';

         const parseStatus = modal.querySelector('#parse-status');
         const speechStatus = modal.querySelector('#speech-status');
         if(parseStatus) parseStatus.textContent = '';
         if(speechStatus) speechStatus.textContent = '';
         manualTimeInput = false;
         manualDateInput = false;
         // Reset timer
         resetAndStartCountdown(modal);
         // Optionally refocus text input
         const textInput = modal.querySelector('#reminder-text');
         if(textInput) textInput.focus();
    }

    if(clearButton) {
         clearButton.addEventListener('click', clearFields);
    }


    if(modal.querySelector('#cancel-reminder')) {
        modal.querySelector('#cancel-reminder').addEventListener('click', () => {
            cleanUpModalTimers(modal); // Clean up timers before closing
            if (modal.parentNode) document.body.removeChild(modal);
             showToast('Creación/Edición cancelada.', 'info');
        });
    }

    if(modal.querySelector('#help-reminder')) {
        modal.querySelector('#help-reminder').addEventListener('click', () => {
             showHelpModal(); // Open help modal
        });
    }

    if(modal.querySelector('#view-reminders')) {
        modal.querySelector('#view-reminders').addEventListener('click', () => {
            cleanUpModalTimers(modal); // Clean up timers
            if (modal.parentNode) document.body.removeChild(modal);
            fromReminderModal = true; // Set flag to indicate we came from the reminder modal
            showAllReminders(); // Open the table
        });
    }

    // Initial focus and timer start
    if(textInput) textInput.focus();
    resetAndStartCountdown(modal);

}

    // Helper to get a notification element by reminder ID
    function getNotificationElement(reminderId) {
        const notificationsContainer = document.getElementById('reminder-notifications');
        if (!notificationsContainer) return null;
         // Use querySelector to find a child notification with the matching data-id
        return notificationsContainer.querySelector(`.reminder-notification[data-id="${reminderId}"]`);
    }

    function showReminderNotification(reminder) {
        // Prevent showing notification if minimal mode is active
        if (isMinimalMode) return;

        // Check if a notification for this reminder ID is already displayed
        if (getNotificationElement(reminder.id)) {
            console.log(`Notification for reminder ID ${reminder.id} already displayed.`);
            return; // Don't show again if already visible
        }

        console.log("Showing notification for reminder:", reminder);

        const notification = document.createElement('div');
        notification.className = 'reminder-notification';
        notification.setAttribute('aria-label', 'Notificación de recordatorio');
        // Add data attribute for ID to uniquely identify this notification
        notification.dataset.id = reminder.id;

        // Format details string based on reminder type and available data
        const formattedDate = reminder.date ? `${reminder.date.split('-')[2]}/${reminder.date.split('-')[1]}/${reminder.date.split('-')[0].slice(-2)}` : ''; // DD/MM/YY

        let details = '';
        if (reminder.type === 'timer' && reminder.timerEnd) {
             const endDate = new Date(reminder.timerEnd);
             if (!isNaN(endDate)) {
                details += `<p class="reminder-details">Fin Temporizador: ${endDate.getHours().toString().padStart(2, '0')}:${endDate.getMinutes().toString().padStart(2, '0')} ${endDate.getDate().toString().padStart(2, '0')}/${(endDate.getMonth() + 1).toString().padStart(2, '0')}/${endDate.getFullYear().toString().slice(-2)}</p>`;
             } else {
                 details += `<p class="reminder-details">Fin Temporizador: Fecha inválida</p>`;
             }
        } else {
            if (reminder.time) details += `<p class="reminder-details">Hora: ${reminder.time}</p>`;
            if (reminder.date) details += `<p class="reminder-details">Fecha: ${formattedDate}</p>`;
             // Ensure repeatDays is an array before checking length
            if (reminder.repeatDays && Array.isArray(reminder.repeatDays) && reminder.repeatDays.length > 0) details += `<p class="reminder-details">Repite: ${reminder.repeatDays.map(d => ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'][d]).join(', ')}</p>`;
            if (reminder.intervalDays) details += `<p class="reminder-details">Cada ${reminder.intervalDays} días</p>`;
        }

        notification.innerHTML = `
            <p class="reminder-text">${reminder.text.replace(/<b>|<\/b>/g, '')}</p> <!-- Remove bold HTML for display in notification -->
            ${details}
            <div class="button-group">
                <button class="cancel" data-id="${reminder.id}">Borrar</button>
                <button class="modify" data-id="${reminder.id}">Modificar</button>
                <button class="postpone" data-id="${reminder.id}">Posponer</button>
            </div>
        `;

        const notificationsContainer = document.getElementById('reminder-notifications');
        if (notificationsContainer) {
             // Set pointer-events: auto on the notification itself so its buttons are clickable
             notification.style.pointerEvents = 'auto';
             // Set pointer-events: none on the container so clicks fall through where there are no notifications
             notificationsContainer.style.pointerEvents = 'none'; // Should be set on the container CSS

             // Append the new notification to the container
             notificationsContainer.appendChild(notification);
             // You might want to center it or position it differently if multiple notifications appear
             // For now, they will stack according to standard flow within the container.
             // A simple centering style might be applied to .reminder-notification.
        } else {
             console.error("#reminder-notifications container not found.");
             return;
        }


        // Add event listeners to buttons
        notification.querySelector('.cancel').addEventListener('click', () => {
            let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
            // Filter out the reminder by its ID
            reminders = reminders.filter(r => r.id !== reminder.id);
            localStorage.setItem('reminders', JSON.stringify(reminders));
            updateReminderCount();
            updateButtonStyles();
            if (notification.parentNode) notification.parentNode.removeChild(notification); // Remove this specific notification from DOM
            showToast('Recordatorio borrado.', 'success');
        });

        notification.querySelector('.modify').addEventListener('click', () => {
            if (notification.parentNode) notification.parentNode.removeChild(notification); // Remove this notification from DOM
            showReminderModal(reminder); // Open modal for editing, passing the reminder data
        });

        notification.querySelector('.postpone').addEventListener('click', () => {
             // Remove the notification *now* before showing the options modal
             if (notification.parentNode) notification.parentNode.removeChild(notification);
             // Show the options modal, indicating the source was a notification
             showPostponeOptionsModal(reminder, 'notification');
        });

        // Notifications remain until explicitly dismissed by user action. No auto-hide timer needed.
    }

    // Function to hide all modals (Kept and refined)
     function closeAllModals() {
         // Select all potential modal elements
         document.querySelectorAll('.help-modal, .reminder-modal, .reminder-table-modal, #postpone-options-modal').forEach(modal => {
             // Clean up any specific timers associated with the modal element before removing
             if (modal.autoSaveInterval) clearInterval(modal.autoSaveInterval);
             if (modal.autoPostponeInterval) clearInterval(modal.autoPostponeInterval);
             if (modal.parseTimeout) clearTimeout(modal.parseTimeout);
             if (modal.focusTimeout) clearTimeout(modal.focusTimeout);

             // Remove the modal from the DOM
             if (modal.parentNode) {
                 modal.parentNode.removeChild(modal);
             }
         });
         // Reset the flag indicating if we came from the reminder modal
         fromReminderModal = false; // Reset flag when *any* modal is closed by this function
         console.log("All modals closed.");
     }


    // Mostrar tabla de recordatorios (Kept and refined)
    function showAllReminders() {
    // Close any other modals first
    closeAllModals();

    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    // Sort reminders: timers first, then by date, then by time, then by creation date
    reminders.sort((a, b) => {
        const typeOrder = { 'timer': 0, 'simple': 1, 'hourly': 2, 'weekly': 3, 'interval': 4, 'daily': 5 };
        const typeDiff = (typeOrder[a.type] ?? 99) - (typeOrder[b.type] ?? 99);
        if (typeDiff !== 0) return typeDiff;

        // For timers, sort by timerEnd date
        if (a.type === 'timer' && b.type === 'timer' && a.timerEnd && b.timerEnd) {
             const endA = new Date(a.timerEnd).getTime();
             const endB = new Date(b.timerEnd).getTime();
             // Handle cases where timerEnd might be invalid or missing for sorting
             if (isNaN(endA) && isNaN(endB)) return 0;
             if (isNaN(endA)) return 1; // Invalid A goes after valid B
             if (isNaN(endB)) return -1; // Valid A goes before invalid B
             return endA - endB;
        }

        // For other types, sort by Date then Time
        const dateA = a.date || '9999-12-31'; // Put items without date at the end
        const dateB = b.date || '9999-12-31';
        const dateCompare = dateA.localeCompare(dateB);
        if (dateCompare !== 0) return dateCompare;

        const timeA = a.time || '00:00'; // Treat no time as start of day for sorting
        const timeB = b.time || '00:00';
        const timeCompare = timeA.localeCompare(timeB);
        if (timeCompare !== 0) return timeCompare;


        // Fallback sort by creation date if all else is equal (older first)
        const creationA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
        const creationB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
        // Handle cases where createdAt might be missing
        if (isNaN(creationA) && isNaN(creationB)) return 0;
        if (isNaN(creationA)) return 1;
        if (isNaN(creationB)) return -1;
        return creationA - creationB;
    });


    const modal = document.createElement('div');
    modal.className = 'reminder-table-modal';
    modal.setAttribute('aria-label', 'Tabla de recordatorios');

    modal.innerHTML = `
        <h2>Recordatorios</h2>
         <div class="top-button-container">
             <button type="button" id="close-reminders-top">SALIR <span class="button-countdown"></span></button>
         </div>
        <table>
            <thead>
                <tr>
                    <th>Acciones</th>
                    <th>Texto</th>
                    <th>Tipo</th> <!-- Added Type column -->
                    <th>Hora</th>
                    <th>Fecha</th>
                    <th>Días</th>
                    <th>Cada x días</th>
                    <th>Fin Alarma</th>
                     <th>Creado</th>
                </tr>
            </thead>
            <tbody>
                ${reminders.length === 0 ? '<tr><td colspan="9">No hay recordatorios.</td></tr>' : reminders.map(r => { // Updated colspan to 9
                    // Display date in DD/MM/YY format
                    let dateDisplay = formatDateToDDMMMYY(r.date);

                    let timeDisplay = r.time || '-';
                    let timerEndDisplay = '-';
                     let typeDisplay = r.type || 'simple'; // Display reminder type

                    // Display timer end for timer types
                    if (r.type === 'timer' && r.timerEnd) {
                        const endDate = new Date(r.timerEnd);
                        if (!isNaN(endDate)) {
                            timerEndDisplay = `${endDate.getHours().toString().padStart(2, '0')}:${endDate.getMinutes().toString().padStart(2, '0')} ${endDate.getDate().toString().padStart(2, '0')}/${(endDate.getMonth() + 1).toString().padStart(2, '0')}/${endDate.getFullYear().toString().slice(-2)}`;
                        } else {
                            timerEndDisplay = 'Fecha inválida';
                        }
                    }

                    // Display created date in DD/MM/YY format
                     const createdAtDisplay = r.createdAt ? formatDateToDDMMMYY(r.createdAt.split('T')[0]) : '-';


                    return `
                        <tr data-id="${r.id}">
                            <td>
                                <button class="delete" data-id="${r.id}">Borrar</button>
                                <button class="postpone" data-id="${r.id}">Posponer</button>
                            </td>
                            <td class="text-column">${r.text.replace(/<b>|<\/b>/g, '')}</td> <!-- Display text without bold HTML -->
                             <td>${typeDisplay}</td>
                            <td>${timeDisplay}</td>
                            <td class="date-column">${dateDisplay}</td>
                             <td>${r.repeatDays && Array.isArray(r.repeatDays) && r.repeatDays.length > 0 ? r.repeatDays.map(d => ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'][d]).join(', ') : '-'}</td> <!-- Ensure repeatDays is array -->
                            <td>${r.intervalDays || '-'}</td>
                            <td>${timerEndDisplay}</td>
                             <td class="date-column">${createdAtDisplay}</td>
                        </tr>
                    `;
                    }).join('')}
            </tbody>
        </table>
        <div class="button-group flex justify-start">
               <button type="button" id="close-reminders">SALIR <span class="button-countdown"></span></button>
        </div>

    `;

    document.body.appendChild(modal);

    let countdown = 60; // Countdown for auto-closing
    const countdownSpans = modal.querySelectorAll('.button-countdown');
    countdownSpans.forEach(span => span.textContent = `(${countdown})`);

    const closeModalAndCleanup = () => {
         clearInterval(modal.autoCloseInterval); // Clear interval specific to this modal
         modal.autoCloseInterval = null; // Clear reference

         if (modal.parentNode) document.body.removeChild(modal); // Remove from DOM

         if (fromReminderModal) { // Check flag: did we come from the reminder form modal?
             fromReminderModal = false; // Reset flag
             showReminderModal(); // Return to the creation/editing modal
         }
     };

    // Store interval ID on the modal element itself
    modal.autoCloseInterval = setInterval(() => {
        countdown--;
        countdownSpans.forEach(span => span.textContent = `(${countdown})`);

        if (countdown <= 0) {
            closeModalAndCleanup(); // Auto-close the modal
        }
    }, 1000);

    const resetTimer = () => {
        clearInterval(modal.autoCloseInterval); // Clear existing timer
        countdown = 60; // Reset countdown value
        countdownSpans.forEach(span => span.textContent = `(${countdown})`); // Update display
        // Start a new timer and store its ID
        modal.autoCloseInterval = setInterval(() => {
            countdown--;
            countdownSpans.forEach(span => span.textContent = `(${countdown})`);
            if (countdown <= 0) {
                closeModalAndCleanup();
            }
        }, 1000);
    };

    // Reset timer on any interaction within the modal
    modal.addEventListener('click', resetTimer);
    modal.addEventListener('touchstart', resetTimer);
    modal.addEventListener('input', resetTimer);


    // --- Event Listeners for action buttons in the table ---

    modal.querySelectorAll('.delete').forEach(button => {
        button.addEventListener('click', (event) => {
            event.stopPropagation(); // Prevent the row click handler from firing
            const id = parseInt(button.dataset.id);
            let currentReminders = JSON.parse(localStorage.getItem('reminders') || '[]');
            // Filter out the reminder by its ID
            currentReminders = currentReminders.filter(r => r.id !== id);
            localStorage.setItem('reminders', JSON.stringify(currentReminders));
            updateReminderCount();
            updateButtonStyles();
            // Remove the corresponding notification if it's currently displayed
            const notificationElement = getNotificationElement(id);
            if (notificationElement && notificationElement.parentNode) {
                 notificationElement.parentNode.removeChild(notificationElement);
            }
            // Reload the table after deletion by closing and re-opening
             closeModalAndCleanup(); // Close the current table modal gracefully
             setTimeout(() => showAllReminders(), 100); // Open the table again after a small delay
             showToast('Recordatorio borrado.', 'success');
        });
    });

    modal.querySelectorAll('.postpone').forEach(button => {
        button.addEventListener('click', (event) => {
             event.stopPropagation(); // Prevent row click
            const id = parseInt(button.dataset.id);
            // Find the specific reminder object from the current list in memory
            const reminder = reminders.find(r => r.id === id);
            if (reminder) {
                 // Close the table modal before showing postpone options
                 closeModalAndCleanup();
                 // Show the options modal, indicating the source was the table
                 showPostponeOptionsModal(reminder, 'table');
            } else {
                console.error("No se encontró el recordatorio para posponer desde la tabla.");
                // Provide feedback to the user
                 showToast('Error: Recordatorio no encontrado.', 'error');
            }
        });
    });

    // Close buttons
    if(modal.querySelector('#close-reminders')) modal.querySelector('#close-reminders').addEventListener('click', closeModalAndCleanup);
    if(modal.querySelector('#close-reminders-top')) modal.querySelector('#close-reminders-top').addEventListener('click', closeModalAndCleanup);

     // --- Event Listener for click on the row (for editing) ---
     const tableBody = modal.querySelector('tbody');
     if (tableBody) {
         tableBody.addEventListener('click', (event) => {
             // If the click was on a button within the first cell, do nothing here
             if (event.target.closest('td:first-child button')) {
                 return;
             }
             // If the click was on the first cell itself but not a button inside, handle as edit
             if (event.target.closest('td:first-child')) {
                 const row = event.target.closest('tr');
                 if (row && row.dataset.id) {
                     const id = parseInt(row.dataset.id);
                     const reminder = reminders.find(r => r.id === id);
                     if (reminder) {
                          closeModalAndCleanup(); // Close the table
                          showReminderModal(reminder); // Open the modal for editing
                     }
                 }
                 return; // Stop propagation if clicked in the first cell
             }

             // Handle click on any other cell in the row for editing
             const row = event.target.closest('tr');
             if (row && row.dataset.id) {
                 const id = parseInt(row.dataset.id);
                 const reminder = reminders.find(r => r.id === id);
                 if (reminder) {
                     closeModalAndCleanup(); // Close the table
                     showReminderModal(reminder); // Open the modal for editing
                 }
             }
         });
     }
}

    function updateReminderCount() {
        const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        const count = reminders.length;
        const globeCount = document.getElementById('reminder-count-globe');
        // Update the count displayed in the globe element
        if (globeCount) {
            globeCount.textContent = count > 0 ? count : '';
            // Hide the globe entirely if count is 0 or if in minimal mode
            globeCount.style.display = count > 0 && !isMinimalMode ? 'block' : 'none';
        }
         // Also update the count on the reminder button itself (if using a different style)
         const reminderButton = document.getElementById('reminder-button');
         if (reminderButton) {
              const currentCountSpan = reminderButton.querySelector('.reminder-count');
              if (count > 0) {
                   if (!currentCountSpan) {
                        const countSpan = document.createElement('span');
                        countSpan.className = 'reminder-count';
                        countSpan.textContent = count;
                        reminderButton.appendChild(countSpan);
                   } else {
                        currentCountSpan.textContent = count;
                   }
              } else {
                   // Remove the count span if count is 0
                   if (currentCountSpan && currentCountSpan.parentNode) {
                        currentCountSpan.parentNode.removeChild(currentCountSpan);
                   }
              }
         }
    }

// --- Reminder Checking Logic (Kept and Refined) ---
function checkReminders() {
    // Don't check or notify if minimal mode is active
    if (isMinimalMode) return;

    const reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
    const now = new Date();
    // Use a small buffer (e.g., 15 seconds) to capture events that are due *right now* or very soon.
    // This helps ensure notifications aren't missed due to slight delays in the interval timer.
    const notificationBufferMs = 15000; // 15 seconds buffer
    const nowBuffered = new Date(now.getTime() + notificationBufferMs);

    // Get current date and time components based on the buffered time
    const currentYear = nowBuffered.getFullYear();
    const currentMonth = nowBuffered.getMonth(); // 0-indexed
    const currentDay = nowBuffered.getDate();
    const currentDateFormatted = `${currentYear}-${(currentMonth + 1).toString().padStart(2, '0')}-${currentDay.toString().padStart(2, '0')}`;
    const currentDayOfWeek = nowBuffered.getDay(); // 0=Domingo, 6=Sábado
    const currentMinutesPastMidnight = nowBuffered.getHours() * 60 + nowBuffered.getMinutes();


    const remindersToKeep = []; // Reminders that should remain in storage
    let needsUpdate = false; // Flag to indicate if localStorage needs to be saved

    reminders.forEach(reminder => {
        let shouldNotify = false;
        let shouldKeep = true; // By default, keep the reminder

        try { // Wrap processing in try-catch for robustness

            // --- Timer reminders (should only trigger once) ---
            if (reminder.type === 'timer' && reminder.timerEnd) {
                 const timerEndDate = new Date(reminder.timerEnd);
                 if (!isNaN(timerEndDate) && timerEndDate <= nowBuffered) {
                     shouldNotify = true;
                     shouldKeep = false; // Timers are one-time events, remove after triggering
                 } else {
                     // If timerEnd is in the future, keep it
                     shouldKeep = true;
                 }
            }
            // --- Daily reminders (specific date and time, should trigger once on that date) ---
            else if (reminder.type === 'daily' && reminder.date && reminder.time) {
                 // Check if the reminder date is today (based on buffered time)
                 if (reminder.date === currentDateFormatted) {
                     const [h, m] = reminder.time.split(':').map(Number);
                     const reminderTimeMinutes = h * 60 + m; // Reminder time in minutes past midnight

                      // Check if the current time (buffered) is past or exactly the reminder time
                      if (currentMinutesPastMidnight >= reminderTimeMinutes || nowBuffered >= new Date(`${reminder.date}T${reminder.time}:00`)) {
                         shouldNotify = true;
                         shouldKeep = false; // Daily reminders trigger once and are removed
                      } else {
                          // If date is today but time is in the future, keep it
                           shouldKeep = true;
                      }
                 } else if (new Date(reminder.date) < new Date(currentDateFormatted)) {
                      // If the reminder date is in the past, it should have already triggered.
                      // This state indicates it was likely missed or an error occurred. Remove it.
                       shouldKeep = false;
                       needsUpdate = true; // Mark for saving
                 } else {
                      // If the reminder date is in the future, keep it
                       shouldKeep = true;
                 }
            }
             // --- Weekly reminders (repeating on specific days at a specific time) ---
             else if (reminder.type === 'weekly' && reminder.repeatDays && Array.isArray(reminder.repeatDays) && reminder.repeatDays.length > 0 && reminder.time) {
                 // Check if today is one of the repeating days
                 if (reminder.repeatDays.includes(currentDayOfWeek)) {
                     const [h, m] = reminder.time.split(':').map(Number);
                     const reminderTimeMinutes = h * 60 + m;

                      // Check if the current time (buffered) is past or exactly the reminder time
                      if (currentMinutesPastMidnight >= reminderTimeMinutes || nowBuffered >= new Date(currentYear, currentMonth, currentDay, h, m, 0, 0)) {
                         // Prevent repeated notifications within a short buffer window for repeating reminders
                         const lastNotifiedKey = `reminder_last_notified_${reminder.id}`;
                         const lastNotifiedTimestamp = parseInt(sessionStorage.getItem(lastNotifiedKey) || '0');
                         const notificationCooldownMs = 90000; // 90 seconds cooldown

                         if ((Date.now() - lastNotifiedTimestamp) > notificationCooldownMs) {
                             shouldNotify = true;
                             sessionStorage.setItem(lastNotifiedKey, Date.now().toString()); // Mark as notified now
                         }
                         // Weekly reminders are kept (not removed automatically)
                         shouldKeep = true;
                      } else {
                          // If today is a repeat day but the time is in the future, keep it
                           shouldKeep = true;
                      }
                 } else {
                      // If today is not a repeat day, keep it for the next due day
                      shouldKeep = true;
                 }
             }
            // --- Interval reminders (repeating every X days starting from a date) ---
            else if (reminder.type === 'interval' && reminder.date && reminder.intervalDays > 0) {
                const [h, m] = (reminder.time || '00:01').split(':').map(Number); // Use 00:01 if no time specified
                const lastTriggerDate = new Date(reminder.date + 'T' + (reminder.time || '00:00') + ':00'); // Include time for start point


                // Calculate how many full intervals have passed since the last trigger date *and time*
                const msSinceLastTrigger = nowBuffered.getTime() - lastTriggerDate.getTime();
                const msPerInterval = reminder.intervalDays * 24 * 60 * 60 * 1000;

                // Check if the current time (buffered) is past the last trigger date + interval
                if (msSinceLastTrigger >= 0 && msPerInterval > 0 && (msSinceLastTrigger % msPerInterval) < notificationBufferMs) { // Check if *approximately* due within buffer

                     // Refined check: Calculate the exact time of the *next* expected trigger based on the start date
                     let nextExpectedTrigger = new Date(lastTriggerDate);
                     // Move to the start of the day of the last trigger date to calculate full days passed
                     nextExpectedTrigger.setHours(0, 0, 0, 0);

                     const daysSinceStart = Math.floor((nowBuffered.getTime() - nextExpectedTrigger.getTime()) / (24 * 60 * 60 * 1000));

                      if (daysSinceStart >= 0 && (daysSinceStart % reminder.intervalDays === 0)) {
                          // It's the correct day. Now check if the time today has passed.
                          const reminderTimeToday = new Date(currentYear, currentMonth, currentDay, h, m, 0, 0);

                           if (!isNaN(reminderTimeToday) && nowBuffered >= reminderTimeToday) {
                              // Prevent repeated notifications within a short buffer window
                              const lastNotifiedKey = `reminder_last_notified_${reminder.id}`;
                              const lastNotifiedTimestamp = parseInt(sessionStorage.getItem(lastNotifiedKey) || '0');
                              const notificationCooldownMs = 90000; // 90 seconds cooldown

                              if ((Date.now() - lastNotifiedTimestamp) > notificationCooldownMs) {
                                  shouldNotify = true;
                                  sessionStorage.setItem(lastNotifiedKey, Date.now().toString()); // Mark as notified now

                                   // Update the reminder's stored date to the *current* trigger date for the next calculation base
                                   const todayISO = `${currentYear}-${(currentMonth + 1).toString().padStart(2, '0')}-${currentDay.toString().padStart(2, '0')}`;
                                   if (reminder.date !== todayISO) { // Only update if it's not already today
                                      reminder.date = todayISO;
                                      needsUpdate = true; // Mark for saving
                                   }
                              }
                              // Interval reminders are kept
                              shouldKeep = true;
                           } else {
                               // It's the correct day, but the time is in the future, keep it
                                shouldKeep = true;
                           }
                      } else {
                           // It's not a trigger day based on the interval, keep it for the next time
                           shouldKeep = true;
                      }
                } else {
                     // Not due based on the interval/buffer, keep it
                      shouldKeep = true;
                }
            }
             // --- Hourly reminders (specific time every day/hour) ---
             else if (reminder.type === 'hourly' && reminder.time) {
                  const [h, m] = reminder.time.split(':').map(Number);
                  const reminderTimeMinutes = h * 60 + m; // Minutes past midnight

                  // Check if the current time (buffered) is past or exactly the reminder time
                   if (currentMinutesPastMidnight >= reminderTimeMinutes || nowBuffered >= new Date(currentYear, currentMonth, currentDay, h, m, 0, 0)) {
                      // Prevent repeated notifications within a short buffer window
                      const lastNotifiedKey = `reminder_last_notified_${reminder.id}`;
                      const lastNotifiedTimestamp = parseInt(sessionStorage.getItem(lastNotifiedKey) || '0');
                      const notificationCooldownMs = 90000; // 90 seconds cooldown

                      if ((Date.now() - lastNotifiedTimestamp) > notificationCooldownMs) {
                          shouldNotify = true;
                          sessionStorage.setItem(lastNotifiedKey, Date.now().toString()); // Mark as notified now
                      }
                  }
                  // Hourly reminders are kept
                  shouldKeep = true;
             }
            // --- Simple reminders (no time, date, repeat, interval, timer) ---
            else if (reminder.type === 'simple') {
                // Simple reminders are only notified on initial page load by handleInitialRemindersLoad().
                // They are *not* triggered by this periodic interval check.
                // They persist until manually deleted or postponed by the user via their notification.
                shouldKeep = true; // Always keep simple reminders unless user acts
            }
             else {
                  // Catch-all for potentially malformed reminders or unknown types
                  // Log a warning and remove them to prevent issues
                  console.warn("Encountered reminder with unknown or insufficient type/data, removing:", reminder);
                  shouldKeep = false; // Remove malformed ones
                  needsUpdate = true; // Mark for update to remove the bad reminder
             }


        } catch (error) {
            console.error(`Error processing reminder ID ${reminder.id}:`, error, reminder);
            // If an error occurs during processing, treat it as a malformed reminder and remove it
            shouldKeep = false;
            needsUpdate = true; // Mark for update
            showToast(`Error processing reminder ID ${reminder.id}. Removed.`, 'error', 5000);
        }

        // If the reminder should be kept, add it to the list for saving
        if (shouldKeep) {
            remindersToKeep.push(reminder);
        } else {
            // If it was not kept, mark that a save is needed if the original list size will change
             if (reminders.length !== remindersToKeep.length + (reminders.length - remindersToKeep.filter(r => r.id !== reminder.id).length)) {
                  needsUpdate = true;
             }
        }

        // If the reminder should trigger a notification, call showReminderNotification
        // showReminderNotification itself checks if the notification is already displayed based on data-id
        if (shouldNotify) {
             console.log(`Triggering notification for reminder ID ${reminder.id} (${reminder.type}).`);
             showReminderNotification(reminder);
        }
    });


    // Save the list of reminders that were kept *only if* changes were made
    // (either a reminder was removed or an interval date was updated)
    if (needsUpdate || reminders.length !== remindersToKeep.length) {
        console.log("Saving updated reminders list. Needs update:", needsUpdate, "Original count:", reminders.length, "Kept count:", remindersToKeep.length);
        localStorage.setItem('reminders', JSON.stringify(remindersToKeep));
        updateReminderCount(); // Update count if the list size changed
        updateButtonStyles(); // Update button style if count changed
    }
}

// --- Postpone Logic (Kept and Refined) ---
function calculatePostponedDateTime(reminder, postponeMinutes) {
    const now = new Date();
    const postponedDate = new Date(now.getTime() + postponeMinutes * 60000);

    const newDateISO = `${postponedDate.getFullYear()}-${(postponedDate.getMonth() + 1).toString().padStart(2, '0')}-${postponedDate.getDate().toString().padStart(2, '0')}`;
    const newTime = `${postponedDate.getHours().toString().padStart(2, '0')}:${postponedDate.getMinutes().toString().padStart(2, '0')}`;

    // When postponing ANY reminder type from a notification or the table,
    // it should become a temporary 'timer' that goes off after the postpone duration.
    // Store this as a 'timer' type with the calculated timerEnd time.
    const updatedReminder = { ...reminder }; // Create a copy to avoid modifying the original object in the list directly

    updatedReminder.type = 'timer'; // Change type to timer
    updatedReminder.date = newDateISO; // Set the calculated date
    updatedReminder.time = newTime; // Set the calculated time
    updatedReminder.timerEnd = postponedDate.toISOString(); // Set the new timer end time

    // Clear any previous repeating/interval/daily properties as they are replaced by the timer
    updatedReminder.repeatDays = [];
    updatedReminder.intervalDays = null;
    // Optionally keep timerMinutes to show how long it was postponed for, or clear it
    updatedReminder.timerMinutes = postponeMinutes; // Store the postpone duration

    return updatedReminder; // Return the updated reminder object
}    

function showPostponeOptionsModal(reminder, source = 'notification') {
    // Close any other modals first
    closeAllModals(); // This handles cleaning up other timers/intervals too

    // Check if reminder object is valid
    if (!reminder || reminder.id === undefined) {
         console.error("Invalid reminder object passed to showPostponeOptionsModal.");
         showToast("Error: No se pudo posponer el recordatorio.", 'error');
         // If source was table, try to re-open it
         if (source === 'table') setTimeout(() => showAllReminders(), 100);
         return;
    }


    const modal = document.createElement('div');
    modal.id = 'postpone-options-modal';
    modal.className = 'reminder-notification'; // Use base class for some styles

    // Apply custom styles to override and center
    modal.style.position = 'fixed';
    modal.style.top = '50%';
    modal.style.left = '50%';
    modal.style.transform = 'translate(-50%, -50%)';
    modal.style.width = '90%';
    modal.style.maxWidth = '480px';
    modal.style.maxHeight = '85vh';
    modal.style.overflowY = 'auto';
    modal.style.backgroundColor = '#F5E1A9';
    modal.style.padding = '1.5rem';
    modal.style.borderRadius = '1rem';
    modal.style.border = '2px solid #D97706';
    modal.style.boxShadow = '0 6px 6px rgba(0, 0, 0, 0.3)';
    modal.style.zIndex = '4000';
    modal.setAttribute('aria-label', 'Opciones para posponer recordatorio');

    let countdown = 10; // Countdown for auto-postpone (15 min)

    modal.innerHTML = `
        <p class="reminder-text" style="margin-bottom: 0.5rem; font-size: 1.2rem; word-wrap: break-word;">Posponer: ${reminder.text.replace(/<b>|<\/b>/g, '')}</p>
        <p class="reminder-details" style="font-size: 1rem; margin-bottom: 1.5rem;">Selecciona tiempo:</p>
        <div class="button-group" style="flex-direction: column; gap: 1rem; align-items: stretch;">
            <button data-minutes="15" class="postpone-option" style="font-size: 1.3rem; font-weight: bold; padding: 0.8rem 1rem; background-color: #F59E0B; color: white; border: none; border-radius: 0.375rem; cursor: pointer; text-align: center;">15 Minutos</button>
            <button data-minutes="60" class="postpone-option" style="font-size: 1.3rem; font-weight: bold; padding: 0.8rem 1rem; background-color: #F59E0B; color: white; border: none; border-radius: 0.375rem; cursor: pointer; text-align: center;">1 Hora</button>
            <button data-minutes="180" class="postpone-option" style="font-size: 1.3rem; font-weight: bold; padding: 0.8rem 1rem; background-color: #F59E0B; color: white; border: none; border-radius: 0.375rem; cursor: pointer; text-align: center;">3 Horas</button>
            <button data-minutes="1440" class="postpone-option" style="font-size: 1.3rem; font-weight: bold; padding: 0.8rem 1rem; background-color: #F59E0B; color: white; border: none; border-radius: 0.375rem; cursor: pointer; text-align: center;">1 Día</button>
            <button data-minutes="4320" class="postpone-option" style="font-size: 1.3rem; font-weight: bold; padding: 0.8rem 1rem; background-color: #F59E0B; color: white; border: none; border-radius: 0.375rem; cursor: pointer; text-align: center;">3 Días</button>
        </div>
        <p id="postpone-countdown" style="text-align: center; margin-top: 1.8rem; font-size: 1.1rem; font-weight: 500;">Automático en <span id="postpone-timer-value" style="font-weight: bold; font-size: 1.2rem;">${countdown}</span> (15 min)</p>
        <button id="cancel-postpone" class="cancel" style="margin-top: 1.2rem; width: 100%; padding: 0.7rem 1rem; font-size: 1.1rem; background-color: #EF4444; color: white; border: none; border-radius: 0.375rem; cursor: pointer; text-align: center;">Cancelar</button>
    `;

    document.body.appendChild(modal);

    const countdownDisplay = modal.querySelector('#postpone-timer-value');

    const handlePostpone = (minutes) => {
        // Clean up the modal timer before processing
        clearInterval(modal.autoPostponeInterval);
        modal.autoPostponeInterval = null;

        let reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
        const index = reminders.findIndex(r => r.id === reminder.id);

        if (index !== -1) {
             // Calculate the new reminder details (returns the updated reminder object)
            const postponedReminder = calculatePostponedDateTime(reminders[index], minutes);

            // Update the reminder in the array with the new timer details
            reminders[index] = postponedReminder;

            // Save updated reminders to localStorage
            localStorage.setItem('reminders', JSON.stringify(reminders));

            // Update UI elements
            updateReminderCount();
            updateButtonStyles();

             // Remove the original notification if it was the source
             if (source === 'notification') {
                 const notificationElement = getNotificationElement(reminder.id);
                 if (notificationElement && notificationElement.parentNode) {
                      notificationElement.parentNode.removeChild(notificationElement);
                 }
             }
             // If the source was the table, refresh the table after closing this modal
             else if (source === 'table') {
                 // Re-open the table modal after this modal closes
                 setTimeout(() => showAllReminders(), 100); // Small delay
             }

             showToast(`Recordatorio pospuesto ${minutes} minutos.`, 'success');

        } else {
            console.error("No se encontró el recordatorio original en storage para posponer.");
            showToast('Error al posponer recordatorio.', 'error');
             // If source was table and reminder not found, try re-opening table
             if (source === 'table') setTimeout(() => showAllReminders(), 100);
        }

        // Close the postpone options modal
        if (modal.parentNode) document.body.removeChild(modal);
    };

    // Start the auto-postpone timer
    modal.autoPostponeInterval = setInterval(() => {
        countdown--;
        if (countdownDisplay) {
            countdownDisplay.textContent = countdown;
        }

        if (countdown <= 0) {
            clearInterval(modal.autoPostponeInterval);
            handlePostpone(15); // Auto-postpone by 15 minutes after countdown
        }
    }, 1000);


    // Add event listeners to the postpone option buttons
    modal.querySelectorAll('.postpone-option').forEach(button => {
        button.addEventListener('click', () => {
            const minutes = parseInt(button.dataset.minutes);
            handlePostpone(minutes); // Process the selected option
        });
         // Optional: Add hover effects (using inline styles as in provided code)
        button.onmouseover = () => button.style.backgroundColor = '#D97706'; // Darker orange
        button.onmouseout = () => button.style.backgroundColor = '#F59E0B'; // Orange
    });

    // Add event listener to the cancel button
    const cancelButton = modal.querySelector('#cancel-postpone');
    if(cancelButton) {
        cancelButton.addEventListener('click', () => {
            clearInterval(modal.autoPostponeInterval); // Stop the timer
            if (modal.parentNode) document.body.removeChild(modal); // Close the modal
             if (source === 'table') { // If cancelled from table, re-show table
                 setTimeout(() => showAllReminders(), 100);
             }
             showToast('Posponer cancelado.', 'info');
        });
         // Optional: Add hover effects
        cancelButton.onmouseover = () => cancelButton.style.backgroundColor = '#DC2626'; // Darker red
        cancelButton.onmouseout = () => cancelButton.style.backgroundColor = '#EF4444'; // Red
    }
     // Prevent clicks inside modal from propagating outside (if needed)
     modal.addEventListener('click', (event) => event.stopPropagation());
}


// --- Simple Config Modal Placeholder (Removed Complex GAS/Tabs) ---
function showConfigModal() {
    // Close any other modal open
    closeAllModals();

    const modal = document.createElement('div');
    // Reusing a basic modal class or creating a minimal one
    modal.className = 'help-modal'; // Use help-modal styles as a base for simplicity
    modal.id = 'config-modal'; // Give it a unique ID
     // Adjust styling to be centered like the previous config modal
    modal.style.position = 'fixed';
    modal.style.top = '50%';
    modal.style.left = '50%';
    modal.style.transform = 'translate(-50%, -50%)';
    modal.style.backgroundColor = '#ECEFE8'; // Background from original config
    modal.style.padding = '1.5rem';
    modal.style.borderRadius = '0.75rem';
    modal.style.boxShadow = '0 8px 16px rgba(0, 0, 0, 0.25)';
    modal.style.zIndex = '5000'; // High z-index
    modal.style.maxWidth = '600px'; // Smaller max width
    modal.style.width = '95%';
    modal.style.maxHeight = '80vh';
    modal.style.overflowY = 'auto';
    modal.setAttribute('aria-label', 'Configuración');


    modal.innerHTML = `
        <h2 class="text-2xl font-bold text-gray-900" style="text-align: center; margin-bottom: 1.5rem;">Configuración</h2>
        <p style="text-align: center; margin-bottom: 1rem;">La sección de configuración con opciones de usuario, backup y restore está actualmente en desarrollo y no está disponible en esta versión.</p>
        <p style="text-align: center; font-weight: bold;">¡Vuelve pronto para más actualizaciones!</p>
        <div class="button-group flex justify-center" style="margin-top: 2rem;">
            <button type="button" id="config-close-modal" style="background-color: #6B7280; color: white; padding: 0.8rem 2.5rem; font-size: 1.15rem; border: none; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s ease;">Cerrar</button>
        </div>
    `;

    document.body.appendChild(modal);

    // Add event listener for the close button
    const closeModalBtn = modal.querySelector('#config-close-modal');
    if(closeModalBtn) {
        closeModalBtn.addEventListener('click', () => {
            if (modal.parentNode) document.body.removeChild(modal);
        });
         closeModalBtn.onmouseover = () => closeModalBtn.style.backgroundColor = '#4B5563'; // Hover effect
         closeModalBtn.onmouseout = () => closeModalBtn.style.backgroundColor = '#6B7280'; // Normal color
    }

     // Prevent clicks inside modal from propagating outside
     modal.addEventListener('click', (event) => event.stopPropagation());

    showToast('Configuración (Próximamente)', 'info');
}

/**
 * Muestra una notificación flotante (toast) al usuario. (Kept for UX)
 * @param {string} message El mensaje a mostrar.
 * @param {'success'|'error'|'warning'|'info'} type El tipo de notificación (para el color).
 * @param {number} duration Duración en milisegundos (por defecto 3000ms).
 */
function showToast(message, type = 'info', duration = 3000) {
    // Use a consistent ID to find and replace existing toasts
    const toastId = 'app-toast-notification';
    const existingToast = document.getElementById(toastId);
    if (existingToast) {
        existingToast.remove(); // Remove existing toast
    }

    const toast = document.createElement('div');
    toast.id = toastId; // Assign the unique ID
    toast.className = `toast-notification toast-${type}`; // Apply base and type classes
    toast.textContent = message;

    // Ensure toast is added to the body
    document.body.appendChild(toast);

    // Use requestAnimationFrame for smoother transition start (optional but good practice)
    requestAnimationFrame(() => {
         // Forcing reflow is sometimes needed before adding the 'show' class
         void toast.offsetWidth;
         // Show the toast
         toast.classList.add('show');
    });


    // Ocultar y eliminar después de la duración especificada
    setTimeout(() => {
        toast.classList.remove('show');
        // Wait for the hide transition to finish before removing from DOM
        toast.addEventListener('transitionend', () => {
            if (toast.parentNode) {
                toast.parentNode.removeChild(toast);
            }
        }, { once: true }); // Ensure the listener runs only once
    }, duration);
}


// --- Initial Load Logic ---
document.addEventListener('DOMContentLoaded', async () => {
    // 1. Update version display based on file modification date
    await updateVersion();

    // 2. Load saved settings (dark mode, minimal mode, toggle states, zoom, notices active)
    // This also calls handleInitialRemindersLoad internally via setTimeout
    loadSavedSettings();

    // 3. Load notices from avisos.txt and start rotation
    await loadNotices(); // Wait for notices to load
    startNoticeRotation();

    // 4. Adjust button positions (fixed left buttons)
    adjustButtonPositions();
    window.addEventListener('resize', adjustButtonPositions); // Adjust on resize

    // 5. Start the periodic check for non-simple reminders that are due
    // Simple reminders were handled by handleInitialRemindersLoad which is called by loadSavedSettings.
    // checkReminders(); // An immediate check might trigger things due *right now*
    setInterval(checkReminders, 15000); // Check every 15 seconds for due reminders

    // 6. Make the reminder globe interactive (short press shows modal, long press shows table)
    // The logic for short/long press is already attached to the reminderButton element.
    // We just need to ensure clicks/touches on the globe element bubble up or are forwarded.
    const countElement = document.getElementById('reminder-count-globe');
    const reminderButtonElement = document.getElementById('reminder-button');
    if (countElement && reminderButtonElement) {
        // Forward mouse/touch events from the globe to the reminder button
        const forwardEvent = (e) => {
            // Create a new event of the same type
            const newEvent = new e.constructor(e.type, {
                bubbles: true,
                cancelable: e.cancelable,
                clientX: e.clientX,
                clientY: e.clientY,
                // Copy touch details if available
                touches: e.touches,
                targetTouches: e.targetTouches,
                changedTouches: e.changedTouches,
                 // Make sure coordinates within target are preserved if needed
                 // This is tricky, simpler to just forward the event type and let the button's logic handle the rest
            });
            // Dispatch the new event on the reminder button element
             reminderButtonElement.dispatchEvent(newEvent);

             // Prevent default behavior on the globe (like text selection or drag)
             if (e.cancelable) e.preventDefault();
             e.stopPropagation(); // Stop the event from propagating further up from the globe
        };

        // Add listeners to the globe element, forwarding them to the reminder button
        countElement.addEventListener('mousedown', forwardEvent);
        countElement.addEventListener('mouseup', forwardEvent);
        countElement.addEventListener('touchstart', forwardEvent, { passive: false }); // Use passive: false for preventDefault
        countElement.addEventListener('touchend', forwardEvent, { passive: false }); // Use passive: false for preventDefault
   } else {
       console.warn("Reminder count globe or button element not found.");
   }
});

// No window.addEventListener('resize', adjustButtonPositions) here, moved inside DOMContentLoaded
</script>
</body>
</html>