<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BoardingGate Lanzador</title>
    <link rel="icon" href="https://boardinggate.github.io/Tesla/th.jpeg" type="image/jpeg">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- NEW: SortableJS for Drag & Drop -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
<style>
    /* --- START OF CSS (Modificaciones aplicadas) --- */
    .bookmark-item { transition: transform 0.2s ease, box-shadow 0.2s ease; box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1); position: relative; cursor: pointer; background-color: hsla(var(--hue, 0), var(--saturation, 0%), var(--lightness, 90%), 0.64); }
    .bookmark-item:hover:not(.editing-active *) { transform: scale(1.05) translateY(-1px); box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.6), -6px -6px 12px rgba(255, 255, 255, 0.15); }
    .bookmark-item img { image-rendering: crisp-edges; }
    .bookmark-name { font-weight: bold; color: #333; text-align: center; margin-top: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; }
    #bookmark-grid { display: grid; grid-template-columns: repeat(6, minmax(120px, 1fr)); gap: 15px; background-color: transparent; border-radius: 0.75rem; position: relative; width: 100%; max-width: 984px; margin: 0 auto 0 85px; transition: all 0.3s ease; }
    #bookmark-grid > div { height: auto; aspect-ratio: 16 / 9; transition: all 0.3s ease; } /* Grid cell container */
    .bookmark-item { width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; border-radius: 0.5rem; transition: all 0.3s ease; }
    .bookmark-item img { width: 36px; height: auto; max-width: 40px; border-radius: 0.25rem; }
    .bookmark-name { font-size: clamp(0.85rem, 1.5vw, 1.15rem); }
    .small-bookmark img { width: 24px; max-width: 28px; } .small-bookmark .bookmark-name { font-size: clamp(0.85rem, 1.5vw, 1.15rem); }
    @media (max-width: 768px) { #bookmark-grid { grid-template-columns: repeat(3, minmax(100px, 1fr)); gap: 10px; } }
    @media (max-width: 480px) { #bookmark-grid { grid-template-columns: repeat(2, minmax(80px, 1fr)); gap: 8px; } }
    .header-container { display: flex; align-items: center; justify-content: center; gap: 0.5rem; background-color: #ABAB99; padding: 0.5rem; } body.dark-mode .header-container { background-color: #92927E; } .header-logo { width: 100px; height: 70px; transition: filter 0.2s ease; } body.dark-mode .header-logo { filter: brightness(85%); } .title-container { background-color: #ABAB99; padding: 0.5rem 1rem; border-radius: 0.5rem; display: inline-block; } body.dark-mode .title-container { background-color: #92927E; } .header-container h1 { color: #5C5C47; } .version-text { font-size: 0.75rem; color: #5C5C47; font-weight: normal; }
    body { display: flex; flex-direction: column; min-height: 100vh; background-color: #ABAB99; margin: 0; overflow-x: hidden; } body.dark-mode { background-color: #92927E; } header { margin-bottom: 0.5rem; }

    main { position: relative; margin: 0 auto 0.5rem 60px; margin-top: 50px; background-color: transparent; border-radius: 0.75rem; padding: 16px; min-height: 400px; max-width: 984px; width: 100%; transition: margin-top 0.5s ease-in-out; position: relative; }
    footer { margin: 0.5rem auto; text-align: center; max-width: 984px; width: 100%; display: block; background-color: #ABAB99; margin-left: 145px; } body.dark-mode footer { background-color: #92927E; } .footer-content { color: #5C5C47; padding: 0.5rem; margin: 0 auto; max-width: 100%; position: relative; } .footer-subtext { font-size: 0.75rem; color: #5C5C47; margin-top: 0.25rem; text-align: center; } .footer-link-green { color: #5C5C47; text-decoration: none; transition: color 0.2s ease; } .footer-link-green:hover { color: #5C5C47; } .footer-line { display: flex; justify-content: center; align-items: center; gap: 0.5rem; flex-wrap: wrap; }
    .toggle-image, .toggle-sign { width: 135px; height: 74px; margin-bottom: 2px; box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.4); border: 1px solid #7c7c68; left: 10px; z-index: 1000; transition: background-color 0.2s ease, filter 0.2s ease, top 0.3s ease, border 0.2s ease; border-radius: 35px; align-items: center; justify-content: center; cursor: pointer; display: flex; position: fixed; top: 90px; }
    .scroll-toggle-button { position: fixed; width: 110px !important; height: clamp(75px, 20vw, 130px) !important; background-color: #ABAB99; border-radius: 60px; display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: clamp(10px, 2vw, 20px); cursor: pointer; box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.4) !important; border: 1px solid #808080 !important; z-index: 1001; transition: background-color 0.2s ease; left: 10px; top: 10px; } .scroll-toggle-button:hover { background-color: #668B8B; } .scroll-toggle-button svg { width: clamp(24px, 4vw, 32px); height: clamp(24px, 4vw, 32px); stroke: #E6E6DC; }
    #config-button, #personal-button, #home-button, #reload-button { width: auto !important; height: auto !important; background-color: transparent !important; border: none !important; box-shadow: none !important; padding: 5px !important; position: absolute !important; top: 30px !important; z-index: 900 !important; cursor: pointer; border-radius: 50%; transition: transform 0.1s ease, background-color 0.2s ease; }
    #config-button { left: 185px !important; } #personal-button { left: 250px !important; } #home-button { left: 315px !important; } #reload-button { left: 380px !important; }
    #config-button img { max-width: 41px !important; max-height: 41px !important; width: 41px; height: 41px; object-fit: contain; display: block; filter: none !important; } #personal-button img, #home-button img, #reload-button img { max-width: 37px !important; max-height: 37px !important; width: 37px; height: 37px; object-fit: contain; display: block; filter: none !important; }
    #config-button:hover, #personal-button:hover, #home-button:hover, #reload-button:hover { transform: scale(1.1); background-color: rgba(255, 255, 255, 0.2); }
    #personal-button.editing, #personal-button.assigning { border: 3px solid yellow !important; box-shadow: 0 0 10px yellow !important; }
    /* NUEVO: Sombra a√±adida al User ID */
    #user-id-display { position: absolute; top: -25px; right: 0px; font-weight: bold; font-size: 1.1rem; color: #5C5C47; padding: 4px 4px; background-color: rgba(171, 171, 153, 0.7); border-radius: 1px; z-index: 800; white-space: nowrap; text-align: right; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4); }
    body.dark-mode #user-id-display { color: #E6E6DC; background-color: rgba(146, 146, 126, 0.7); opacity: 0.7; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6); }

    .arrow-button { width: clamp(36px, 6vw, 48px); height: clamp(36px, 6vw, 48px); background-color: #668B8B; border-radius: 50%; display: flex; align-items: right; justify-content: center; cursor: pointer; box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3); transition: background-color 0.2s ease; } .arrow-button:hover { background-color: #5C5C47; } .arrow-button svg { stroke: #E6E6DC; }
    .counter-container { display: flex; justify-content: center; align-items: center; flex-direction: column; margin-top: 1rem; text-align: center; opacity: 0.2; margin-left: 145px; }
    .favicon-red { filter: hue-rotate(0deg) saturate(200%) brightness(80%); } .favicon-blue { filter: hue-rotate(200deg) saturate(150%) brightness(90%); }
    .notices-icon-container { display: flex; align-items: center; justify-content: center; width: 100%; max-width: 984px; margin: 0 auto; margin-left: 165px; position: relative; } .notices-container { flex-grow: 1; padding: 0.5rem; border: none; border-radius: 0.5rem; overflow: hidden; display: flex; align-items: center; justify-content: center; gap: 0; margin-left: 2px; height: 3rem; } .notice-wrapper { padding: 0.5rem; height: 1.5rem; flex-grow: 1; overflow: hidden; position: relative; display: flex; align-items: center; justify-content: center; } .notice { color: #E6E6DC; font-size: 1.3rem; font-weight: bold; white-space: nowrap; text-align: center; opacity: 0; animation: fadeInOut 14s infinite; } @keyframes fadeInOut { 0% { opacity: 1; } 10% { opacity: 1; } 90% { opacity: 1; } 100% { opacity: 0; } } .notice-off-icon { width: auto; height: clamp(2rem, 5vw, 3rem); margin-right: 10px; align-self: center; cursor: pointer; transition: filter 0.3s ease; } body.dark-mode .notice-off-icon { filter: brightness(85%); }
    .toggle-sign { background-color: #ABAB99; font-weight: bold; font-size: 1.25rem; color: #000000; text-align: center; } .toggle-sign .sign { font-size: 1.5rem; margin-right: 2px; } .toggle-sign:hover:not(#config-button):not(#personal-button):not(#home-button):not(#reload-button) { background-color: #D9A066; } .toggle-sign img, .toggle-image img { max-width: 70%; max-height: 70%; object-fit: contain; } body.dark-mode .toggle-sign#config-button { filter: brightness(85%); background-color: transparent !important; }
    .toggle-image {} .toggle-image:hover { filter: brightness(80%); } body.dark-mode .toggle-image#on-off-toggle { filter: brightness(85%); }
    #reminder-button { display: flex; flex-direction: column; justify-content: center; align-items: center; position: fixed; background-color: #ABAB99; } #reminder-button img { object-fit: contain; } #reminder-button .reminder-count { position: absolute; top: 6px; left: 8px; background-color: #EF4444; color: #FFFFFF; border-radius: 55%; padding: 4px 10px; font-size: 1.1rem; font-weight: bold; line-height: 1; display: flex; align-items: center; justify-content: center; z-index: 1500; min-width: 1.9rem; max-width: 2.5rem; text-align: center; }
    .hidden { display: none !important; } .footer-hidden { display: none !important; } body.dark-mode .bookmark-item { filter: brightness(60%); } body.dark-mode .bg-gray-50.border.border-dashed.border-gray-200.rounded-lg { filter: brightness(60%); } body.dark-mode .scroll-toggle-button { background-color: #ABAB99; } body.dark-mode .scroll-toggle-button:hover { background-color: #ABAB99; } body.dark-mode .toggle-sign:not(#config-button):not(#personal-button):not(#home-button):not(#reload-button) { background-color: #ABAB99; } body.dark-mode .toggle-sign:not(#config-button):not(#personal-button):not(#home-button):not(#reload-button):hover { background-color: #ABAB99; } body.dark-mode .toggle-sign.range-toggle[data-state="visible"] { background-color: #ABAB99; } body.dark-mode .toggle-sign.range-toggle[data-state="hidden"] { background-color: #ABAB99; } .toggle-sign.range-toggle[data-state="hidden"] { color: #7F7F7F; } body.dark-mode #reload-button {} body.dark-mode #home-button {} body.dark-mode #personal-button {} body.dark-mode #weather-button { background-color: #ABAB99; } body.dark-mode #zoom-button:not(.zoomed) { background-color: #ABAB99; } body.dark-mode #zoom-button.zoomed { background-color: #ABAB99; } body.dark-mode #reminder-button { background-color: #ABAB99; }
    .reminder-modal { position: fixed; top: 2%; left: 3%; transform: translateY(0); background-color: #D2B48C; padding: 1rem; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); z-index: 2000; max-width: 1050px; width: 98%; max-height: 96vh; overflow-y: auto; font-weight: bold; font-size: 1.3rem; }
    .help-modal, .edit-info-modal, .personalization-choice-modal { position: fixed; top: 10%; left: 35px; transform: translateY(-10%); background-color: #DAC8A0; padding: 2rem; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); z-index: 2000; max-width: 1020px; width: 98%; max-height: 80vh; overflow-y: auto; font-size: 1.10rem; }
    .reminder-modal h2, .help-modal h2, .edit-info-modal h2, .personalization-choice-modal h2 { font-size: 1.5rem; font-weight: bold; margin-bottom: 0.5rem; color: #111827; }
    .reminder-modal label, .help-modal label, .edit-info-modal label, .personalization-choice-modal label { display: block; margin-bottom: 0.25rem; font-weight: 500; color: #374151; font-size: 1.1rem; }
    .reminder-modal textarea#reminder-text { width: 100%; padding: 0.5rem; margin-bottom: 0.5rem; border: 1px solid #D1D5DB; border-radius: 0.25rem; font-size: 1.4rem; font-weight: bold; text-transform: uppercase; }
    .reminder-modal input[type="text"], .reminder-modal input[type="number"] { width: 100%; padding: 0.5rem; margin-bottom: 0.5rem; border: 1px solid #D1D5DB; border-radius: 0.25rem; font-size: 2rem; text-align: center; }
    .reminder-modal .form-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; }
    .reminder-modal .full-width { grid-column: span 3; } .reminder-modal .days-group { display: flex; gap: 2rem; flex-wrap: wrap; }
    .reminder-modal .button-group { display: flex; justify-content: space-between; gap: 0.5rem; flex-wrap: nowrap; margin-top: 1rem; }
    .reminder-modal .days-group label { font-size: 1.3rem; }
    .reminder-modal button, .help-modal button, .edit-info-modal button, .personalization-choice-modal button { padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-size: 1.3rem; flex: 1; text-align: center; min-width: 100px; }
    .reminder-modal button[type="submit"] { background-color: #2563EB; height:70px; font-weight: bold; font-size: 1.5rem; color: #FFFFFF; display: flex; align-items: center; justify-content: center; gap: 0.6rem; }
    .reminder-modal button[type="submit"] span#countdown-save { font-size: 1.6rem; font-weight: bold; justify-content: right; color: #e6e6dc; }
    .reminder-modal button[type="button"] { background-color: #D1D5DB; color: #111827; }
    .help-modal button#close-help, .edit-info-modal button#close-edit-info, .personalization-choice-modal button { background-color: #2563EB; color: #FFFFFF; font-size: 1.5rem; padding: 1rem 2rem; height:70px; }
    .personalization-choice-modal .choice-buttons { display: flex; justify-content: space-around; gap: 1rem; margin-top: 1.5rem; }
    .reminder-notification { position: fixed; top: 45%; left: 55%; transform: translate(-85%, -85%); background-color: #FFFF99; padding: 1.5rem; border-radius: 2.5rem; border: 2px solid #ABAB99; box-shadow: 0 6px 6px rgba(1, 0, 0, 0.3); z-index: 3000; max-width: 470px; width: 95%; text-align: center; }
    .reminder-notification .reminder-text { margin: 0.5rem 0; font-size: 1.8rem; font-weight: bold; color: #0000FF; } .reminder-notification .reminder-details { margin: 0.5rem 0; font-size: 1.0rem; font-weight: bold; color: #0000FF; }
    .reminder-notification .button-group { display: flex; flex-direction: column; justify-content: center; gap: 0.5rem; margin-top: 1rem; }
    .reminder-notification button { padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.9rem; width: 100%; }
    .reminder-notification button.cancel { background-color: #EF4444; color: #FFFFFF; font-weight: bold; height:70px; font-size: 1.2rem; order: 3; }
    .reminder-notification button.modify { background-color: #10B981; font-weight: bold; height:60px; font-size: 1.2rem; color: #FFFFFF; order: 1; }
    .reminder-notification button.postpone { background-color: #F59E0B; font-weight: bold; height:60px; font-size: 1.2rem; color: #FFFFFF; order: 2; }
    .reminder-notification button.cancel-cyclic { background-color: #8B0000; color: #FFFFFF; font-weight: bold; height: 60px; font-size: 1.2rem; order: 4; margin-top: 0.5rem; }

    .reminder-table-modal { position: fixed; top: 30px; left: 35px; transform: translateY(0); background-color: #E6D6A8; padding: 1.5rem; border-radius: 1.5rem; box-shadow: 0 4px 6px rgba(1, 1, 0, 0.1); z-index: 2000; max-width: 99%; width: 1090px; max-height: 90vh; overflow-y: auto; }
    .reminder-table-modal table { width: 100%; border-collapse: collapse; margin-bottom: 1rem; } .reminder-table-modal tbody tr { cursor: pointer; } .reminder-table-modal tbody tr:hover { background-color: rgba(0, 0, 0, 0.05); } .reminder-table-modal th, .reminder-table-modal td { padding: 0.5rem; border: 1px solid #1E3A8A; font-size: 1.1rem; text-align: center; vertical-align: middle; } .reminder-table-modal td.text-column { text-align: left; } .reminder-table-modal th { background-color: #E5E7EB; font-weight: bold; } .reminder-table-modal td.date-column { white-space: nowrap; } .reminder-table-modal td:first-child { display: flex; justify-content: space-around; align-items: center; gap: 0.5rem; padding: 0.3rem 0.5rem; border: none; } .reminder-table-modal td:first-child button { padding: 0.5rem 0.8rem; font-size: 0.85rem; flex: 0 1 auto; margin: 0; } .reminder-table-modal button.modify { background-color: #10B981; font-size: 1rem; height:70px; color: #000000; } .reminder-table-modal button.delete { background-color: #EF4444; font-size: 1.2rem; height:65px; color: #FFFFFF; } .reminder-table-modal button.postpone { background-color: #F59E0B; font-size: 1.2rem; height:65px; color: #FFFFFF; } .reminder-table-modal .button-group { display: flex; margin-top: 1rem; } .reminder-table-modal #close-reminders, .reminder-table-modal #close-reminders-top { padding-left: 3rem; padding-right: 3rem; background-color: #2563EB; color: white; padding: 0.75rem 3rem; border-radius: 0.5rem; font-size: 1.25rem; font-weight: bold; border: 2px solid #1E3A8A; cursor: pointer; transition: background-color 0.2s ease; display: inline-flex; align-items: center; } .reminder-table-modal #close-reminders:hover, .reminder-table-modal #close-reminders-top:hover { background-color: #1D4ED8; } .reminder-table-modal .top-button-container { display: flex; justify-content: flex-end; margin-bottom: 1rem; }
    .button-countdown { margin-left: 8px; font-weight: bold; font-size: 1.1em; opacity: 0.85; }
    .reminder-count-globe { position: fixed; top: 10px; left: 10px; background-color: #EF4444; color: white; border-radius: 65%; padding: 10px 15px; font-size: 1.3rem; font-weight: bold; z-index: 1500; }
    .reminder-count-globe, #reminder-notifications, .notices-icon-container, footer { transition: margin-top 0.5s ease-in-out; }
    .speech-button { background-color: #668B8B; color: white; border: none; border-radius: 0.25rem; padding: 0.5rem; cursor: pointer; margin-left: 0.5rem; font-size: 1rem; vertical-align: top; } .speech-button:hover { background-color: #668B8B; } .speech-status { font-size: 0.85rem; color: #ABAB99; margin-top: 0.25rem; min-height: 1.2em; } #auto-save-timer { color: #1E40AF; }
    .statcounter-container { display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 0.25rem; }
    .toast-notification { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 25px; border-radius: 25px; color: white; font-size: 1rem; font-weight: 500; z-index: 9999; opacity: 0; transition: opacity 0.4s ease-in-out, bottom 0.4s ease-in-out; box-shadow: 0 4px 10px rgba(0,0,0,0.2); text-align: center; min-width: 250px; max-width: 80%; } .toast-notification.show { opacity: 1; bottom: 40px; } .toast-success { background-color: #28a745; } .toast-error { background-color: #dc3545; } .toast-warning { background-color: #ffc107; color: #333; } .toast-info { background-color: #17a2b8; }

    /* --- Edit Mode Styles --- */
    .editable:hover { outline: 2px dashed yellow; outline-offset: 2px; }
    .editing-active .bookmark-item:hover,
    .editing-active .range-toggle:hover,
    .editing-active .empty-slot:hover {
        transform: none;
        box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.1);
        outline: 3px solid yellow;
        cursor: crosshair;
    }
    .empty-slot { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; border: 1px dashed #ccc; border-radius: 0.5rem; background-color: rgba(200, 200, 200, 0.1); color: #aaa; transition: background-color 0.2s ease; cursor: default; }
    .editing-active .empty-slot { cursor: crosshair; }
    .empty-slot span { font-size: 2rem; pointer-events: none; }
    body.dark-mode .empty-slot { border-color: #666; color: #777; background-color: rgba(100, 100, 100, 0.2); }

    /* Drag & Drop Styles */
    .sortable-ghost { opacity: 0.4; background-color: #add8e6 !important; }
    .sortable-chosen { box-shadow: 0 0 10px rgba(0, 0, 255, 0.5); }
    .editing-active #bookmark-grid > div { cursor: grab; } /* Cursor grab en modo edici√≥n D&D */
    .editing-active #bookmark-grid > div.sortable-ghost { cursor: grabbing; }

    /* --- Toggle Assignment Mode Styles --- */
    body.assigning-toggles-active .range-toggle { cursor: pointer; outline-offset: 3px; }
    body.assigning-toggles-active .range-toggle:hover { outline: 2px dashed cyan; }
    body.assigning-toggles-active .range-toggle.toggle-selected-for-assignment { outline: 3px solid cyan !important; box-shadow: 0 0 10px cyan; }
    body.assigning-toggles-active #bookmark-grid > div { cursor: cell; } /* Cursor para indicar seleccion */
    body.assigning-toggles-active #bookmark-grid > div .bookmark-item,
    body.assigning-toggles-active #bookmark-grid > div.empty-slot {
         transition: outline 0.1s linear;
         outline: 2px solid transparent;
         outline-offset: -2px;
    }
    body.assigning-toggles-active #bookmark-grid > div.item-assigned-to-selected-toggle .bookmark-item,
    body.assigning-toggles-active #bookmark-grid > div.item-assigned-to-selected-toggle.empty-slot {
         outline: 3px solid #00FFFF; /* Cyan outline */
    }
    #assignment-info-panel {
        position: fixed; bottom: 10px; left: 160px; background: rgba(0, 0, 0, 0.7); color: white;
        padding: 8px 15px; border-radius: 5px; z-index: 1005; font-size: 0.9rem;
        display: none; /* Hidden by default */
    }
    body.assigning-toggles-active #assignment-info-panel { display: block; }


    .edit-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #EADDCA; padding: 2rem; border-radius: 0.75rem; box-shadow: 0 5px 15px rgba(0,0,0,0.3); z-index: 6000; width: 90%; max-width: 500px; border: 1px solid #A0522D; }
    .edit-modal h2 { font-size: 1.4rem; margin-bottom: 1rem; color: #333; font-weight: bold; text-align: center; }
    .edit-modal label { display: block; margin-bottom: 0.3rem; font-weight: 500; color: #444; font-size: 1rem; }
    .edit-modal input[type="text"], .edit-modal input[type="url"] { width: 100%; padding: 0.6rem; margin-bottom: 0.8rem; border: 1px solid #BDB7AB; border-radius: 0.25rem; font-size: 1rem; }
    .edit-modal .input-with-button { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.8rem; }
    .edit-modal .input-with-button input { flex-grow: 1; margin-bottom: 0; }
    .edit-modal .search-button { padding: 0.4rem 0.6rem; font-size: 0.8rem; background-color: #668B8B; color: white; border: none; border-radius: 0.25rem; cursor: pointer; line-height: 1; height: fit-content; }
    .edit-modal .search-button:hover { background-color: #5C5C47; }
    .edit-modal .button-group { display: flex; justify-content: space-between; gap: 1rem; margin-top: 1.5rem; flex-wrap: wrap; }
    .edit-modal button { padding: 0.7rem 1rem; font-size: 1rem; border-radius: 0.25rem; cursor: pointer; border: none; flex: 1 1 auto; min-width: 90px; }
    .edit-modal button.save { background-color: #28a745; color: white; } .edit-modal button.save:hover { background-color: #218838; }
    .edit-modal button.cancel { background-color: #6c757d; color: white; } .edit-modal button.cancel:hover { background-color: #5a6268; }
    .edit-modal button.reset { background-color: #ffc107; color: #333; } .edit-modal button.reset:hover { background-color: #e0a800; }
    .edit-modal button.empty { background-color: #fd7e14; color: white; } .edit-modal button.empty:hover { background-color: #e66b04; }
    /* --- END OF CSS --- */
</style>
</head>
<body class="min-h-screen bg-[#ABAB99] flex flex-col items-center p-6">

    <div class="reminder-count-globe" id="reminder-count-globe"></div>
    <div id="reminder-notifications"></div>
<main>
    <div id="user-id-display"></div>
    <div id="bookmark-grid">
        <!-- Grid items will be generated by JavaScript -->
    </div>
</main>

<!-- NEW: Info panel for assignment mode -->
<div id="assignment-info-panel">Selecciona un ocultador (izq.), luego clica en los botones del grid para asignar/desasignar. Pulsa <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:16px;height:16px;display:inline;vertical-align:middle;"> para guardar y salir.</div>

<div class="notices-icon-container">
    <img src="https://boardinggate.github.io/Tesla/IMG_4194.jpg" alt="Toggle Avisos" class="notice-off-icon" id="notice-toggle-icon">
    <div class="notices-container">
        <div class="notice-wrapper">
            <span class="notice" id="current-notice"></span>
        </div>
    </div>
</div>

<footer>
    <!-- Footer content remains the same -->
    <div class="footer-content">
        <div class="header-container">
            <img src="https://boardinggate.github.io/Tesla/LOGOTESLA.jpg" class="header-logo">
            <div class="title-container">
                <h1 class="text-2xl font-bold inline">
                    <span class="text-2xl">BoardingGate</span>
                    <span class="text-base">Lanzador</span>
                    <span id="version" class="version-text"></span>
                </h1>
            </div>
        </div>
        <div class="footer-line">
            <a href="https://x.com/boardinggate?s=21" class="footer-link-green" target="_blank" rel="noopener noreferrer">@BoardingGate</a>
            <span class="text-green-200" style="font-size: 1.5rem;">ü§ù</span>
            <a href="https://x.com/boardinggate/status/1857325553742721116?s=46" class="footer-link-green" target="_blank" rel="noopener noreferrer">Ahorremos un dinero con mis REFERIDOS</a>
        </div>

        <div class="statcounter-container">
          <div style="display: inline-flex; align-items: center; gap: 10px;">
            <script type="text/javascript"> /* Statcounter code */ </script>
            <noscript><div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img class="statcounter" src="https://c.statcounter.com/13126275/0/0fc568cc/0/" alt="Web Analytics" referrerPolicy="no-referrer-when-downgrade"></a></div></noscript>
            <a href="https://statcounter.com/p13126275/?guest=1" class="footer-subtext">Legionarios de Elon</a>
          </div>
        </div>
        <p class="footer-subtext">La inteligencia tiene ciertas limitations. La locura, casi ninguna ü´∂ ü§ü</p>
    </div>
</footer>


<div id="scroll-toggle" class="scroll-toggle-button" title="Ir al inicio o fin">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M19 12l-7 7-7-7"/></svg>
</div>

<script>
    // --- Original Data ---
    const originalBookmarks = [ { name: "YouTube", url: "https://www.youtube.com" }, { name: "Google", url: "https://www.google.com" }, { name: "GDrive", url: "https://drive.google.com", favicon: "./IMG_4172.png" }, { name: "GMail", url: "https://mail.google.com/mail/mu/mp/603/#tl/Recibidos", favicon: "./IMG_4171.png"}, { name: "Google Fotos", url: "https://photos.google.com" }, { name: "iCloud", url: "https://www.icloud.com/", favicon: "https://www.google.com/s2/favicons?domain=icloud.com&sz=64" }, { name: "ABRP", url: "https://abetterrouteplanner.com" }, { name: "ElectroMaps", url: "https://map.electromaps.com/es/", favicon: "https://www.google.com/s2/favicons?domain=electromaps.com&sz=64" }, { name: "REVE PdR Espa√±a", url: "https://www.mapareve.es/mapa-puntos-recarga", favicon: "https://www.google.com/s2/favicons?domain=mapareve.es&sz=64" }, { name: "PdR,s", url: "https://www.google.com/maps/search/puntos+recarga+veh%C3%ADculos+el%C3%A9ctricos", favicon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 18h8v2h-8v-2z'/><path d='M12 14h8v2h-8v-2z'/><path d='M12 10h8v2h-8v-2z'/><path d='M12 6h8v2h-8V6z'/><path d='M4 18h4v-2H4v2zM4 14h4v-2H4v2zM4 10h4v-2H4v2zM4 6h4V4H4v2z'/></svg>" }, { name: "Google Maps", url: "https://maps.google.com" }, { name: "WhatsApp", url: "https://web.whatsapp.com/" }, { name: "TESSIE", url: "https://dash.tessie.com/signin", favicon: "https://www.google.com/s2/favicons?domain=tessie.com&sz=64" }, { name: "Mis Updates", url: "https://dash.tessie.com/software", favicon: "https://cdn-icons-png.flaticon.com/512/148/148767.png" }, { name: "Olas Updates", url: "https://es.stats.tessie.com/", favicon: "https://cdn-icons-png.flaticon.com/512/5815/5815902.png" }, { name: "NotaTeslaApp", url: "https://www.notateslaapp.com/software-updates/" }, { name: "ENHAUTO", url: "https://www.enhauto.com" }, { name: "MAREAS", url: "https://www.meteogalicia.gal/web/predicion/mareas-e-luas" }, /* 18 */ { name: "ELECTROVERSE", url: "https://electroverse.com/es/map", favicon: "https://www.google.com/s2/favicons?domain=electroverse.com&sz=64" }, { name: "ACCIONA", url: "https://www.google.com/maps/search/recarga+Acciona", favicon: "https://www.google.com/s2/favicons?domain=acciona.com&sz=64" }, { name: "IBERDROLA", url: "https://www.google.com/maps/search/recarga+IBERDROLA", favicon: "https://www.google.com/s2/favicons?domain=iberdrola.com&sz=64" }, { name: "WAYLET Repsol", url: "https://www.google.com/maps/search/recarga+REPSOL+Waylet", favicon: "https://www.google.com/s2/favicons?domain=repsol.com&sz=64" }, { name: "ENDESA xWay", url: "https://www.google.com/maps/search/recarga+ENDESA+XWAY", favicon: "https://www.google.com/s2/favicons?domain=endesa.com&sz=64" }, { name: "ZUNDER", url: "https://www.google.com/maps/search/recarga+ZUNDER", favicon: "https://www.google.com/s2/favicons?domain=zunder.com&sz=64" }, { name: "IONITY", url: "https://www.google.com/maps/search/recarga+IONITY", favicon: "https://www.google.com/s2/favicons?domain=ionity.eu&sz=64" }, { name: "WENEA", url: "https://www.google.com/maps/search/recarga+WENEA", favicon: "https://www.google.com/s2/favicons?domain=wenea.com&sz=64" }, { name: "T.ENERGIES", url: "https://www.google.com/maps/search/recarga+TOTAL+ENERGIES", favicon: "https://www.google.com/s2/favicons?domain=totalenergies.com&sz=64" }, { name: "GALP", url: "https://www.google.com/maps/search/recarga+GALP", favicon: "https://www.google.com/s2/favicons?domain=galp.com&sz=64" }, { name: "MIIO", url: "https://miio.com", favicon: "https://www.google.com/s2/favicons?domain=miio.com&sz=64" }, { name: "EVDC", url: "https://evdc.network", favicon: "https://www.google.com/s2/favicons?domain=evdc.network&sz=64" } /* 29 */, /* 30 */ { name: "GROK", url: "https://grok.com/?referrer=website" }, { name: "CHATGPT", url: "https://chat.openai.com" }, { name: "CLAUDE", url: "https://claude.ai/new" }, { name: "GEMINI", url: "https://gemini.google.com" }, { name: "NOTEBOOKLM", url: "https://notebooklm.google.com" }, null, null, null, null, null, null, null /* 41 */, /* 42 */ { name: "Bater√≠a", url: "https://docs.google.com/spreadsheets/d/1bLZmgVGTBqg2bS2E45JpORjs9eK2nb05AWXYLLDY-RI/edit?gid=1398548891#gid=1398548891", favicon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='10'/><polyline points='12 6 12 12 16 14'/></svg>" }, { name: "TeslaParaTodos", url: "https://teslaparatodos.com/cine/" }, { name: "BetterTheater", url: "https://abettertheater.com", favicon: "https://www.google.com/s2/favicons?domain=abettertheater.com&sz=64" }, { name: "Filmin", url: "https://www.filmin.es/catalogo/peliculas" }, { name: "Octopus", url: "https://octopusenergy.es/login" }, { name: "App MCE", url: "https://www.oscarabilleira.com/app-mi-coche-electrico/#ayuda" }, { name: "Patr√≥n Luz", url: "https://docs.google.com/spreadsheets/d/1R7UUZ9i4BAYWAGAX6PQT1WGd12GEZ4Ja/edit?usp=sharing&ouid=108345701896498198132&rtpof=true&sd=true" }, { name: "TradingView", url: "https://es.tradingview.com/chart/t5g9UFG0/" }, { name: "Telegram", url: "https://web.telegram.org/a/" }, { name: "Twitter", url: "https://x.com" }, { name: "Maesal Detailer", url: "https://www.maesaldetailer.es/" }, { name: "Superchargers", url: "https://www.tesla.com/es_es/findus?bounds=45.41107111786193%2C19.27853056943938%2C29.703668286784747%2C-16.64676239931062" }, { name: "TESLA web", url: "https://www.tesla.com/es_es" }, { name: "Waze (consultas)", url: "https://www.waze.com/es/live-map/", favicon: "https://www.google.com/s2/favicons?domain=waze.com&sz=64" }, { name: "AMAZON", url: "https://www.amazon.es" }, { name: "BIP&DRIVE", url: "https://areaprivada.bipdrive.com/login" }, { name: "ITV Cita", url: "https://www.sycitv.com/es/cita-previa-particulares/", favicon: "https://boardinggate.github.io/Tesla/itv.png" }, { name: "Deportes", url: "https://www.sofascore.com/es/tenis" } /* 59 */, /* 60 */ { name: "Manual M3", url: "https://www.tesla.com/ownersmanual/model3/es_es/" }, { name: "de Servicio", url: "https://service.tesla.com/docs/Model3/ServiceManual/2024/es-es/" }, { name: "de Despiece", url: "https://epc.tesla.com/es-MX/catalogs/e0e07c3d-272f-4d06-b8b6-9e92f857e5f3" }, { name: "de Usted Mismo", url: "https://www.tesla.com/es_es/support/do-it-yourself-guides" }, { name: "de Filtro Cabina", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-DB0A1E3C-926E-498C-A2FD-A27B8421A471.html" }, { name: "de M√≥vil remoto", url: "https://service.tesla.com/docs/Public/diy/model3/es_es/GUID-53651B16-A2E3-4118-933E-B5F41C74D433.html" }, { name: "Jaime Odena", url: "https://www.youtube.com/@JOdena", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Eduardo Arcos", url: "https://www.youtube.com/@earcos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "AutoIngenium", url: "https://www.youtube.com/@AutoIngenium", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Gallego en Munich", url: "https://www.youtube.com/@ungallegoenmunich", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Electromiaumiau", url: "https://www.youtube.com/@electromiaumiau", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Manuel Martos", url: "https://www.youtube.com/@Manuel_Martos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Todos Electricos", url: "https://www.youtube.com/@TodosElectricos", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Juan Vidal Haces", url: "https://www.youtube.com/@JuanVidalHaces", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Ruedana", url: "https://www.youtube.com/@ruedana", favicon: "https://www.youtube.com/favicon.ico" }, { name: "STR-600", url: "https://www.youtube.com/@STR-600", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Juanjo T. Aventuras", url: "https://www.youtube.com/@juanjoteslaventuras", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Carlos Cuezva", url: "https://www.youtube.com/@CarlosCuezva", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Javi Manzanoo", url: "https://www.youtube.com/@javimanzanoo", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Crifedi", url: "https://www.youtube.com/@Crifedi", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Tescno Tesla", url: "https://www.youtube.com/@TecnoTesla", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Full Electric Mex", url: "https://www.youtube.com/@FullElectricMexico", favicon: "https://www.youtube.com/favicon.ico" }, null, null, { name: "La iA Jon", url: "https://www.youtube.com/@la_inteligencia_artificial", favicon: "https://www.youtube.com/favicon.ico" }, { name: "JF Ccalero", url: "https://www.youtube.com/@jfcalero", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Visual Politik", url: "https://www.youtube.com/@VisualPolitik", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Fabian Barrio", url: "https://www.youtube.com/@fabiancbarrio", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Loquetudigas", url: "https://www.youtube.com/@Loquetudigas", favicon: "https://www.youtube.com/favicon.ico" }, { name: "David Antunes", url: "https://www.youtube.com/@davidantunesmusic", favicon: "https://www.youtube.com/favicon.ico" }, { name: "TheWildProject", url: "https://www.youtube.com/@TheWildProject", favicon: "https://www.youtube.com/favicon.ico" }, { name: "Estas Tonne", url: "https://www.youtube.com/@Estastonne", favicon: "https://www.youtube.com/favicon.ico" }, { name: "BBC6 Music", url: "https://www.youtube.com/@BBC6Music", favicon: "https://www.youtube.com/favicon.ico" }, null, null /* 95 */ ];
    const originalToggleRanges = [ { start: 18, end: 29, label: "PdR,s" }, { start: 30, end: 41, label: "iAs" }, { start: 42, end: 59, label: "√ötil" }, { start: 60, end: 95, label: "Varios" } ];

    // --- Global Variables ---
    const TOTAL_CELLS = 96; const COLS = 6; const grid = document.getElementById('bookmark-grid');
    let isDarkMode = false; let pressStartTime = null; let reminderPressStartTime = null; let isActive = true; let isFooterVisible = true; let notices = []; let currentNoticeIndex = 0; let fromReminderModal = false;
    let isEditMode = false; // For URL/Label editing + Drag&Drop
    let isAssigningToggles = false; // NEW: For Toggle Assignment mode
    let selectedToggleForAssignment = null; // NEW: Tracks which toggle is being configured
    let tempToggleAssignments = {}; // NEW: Temporary storage during assignment

    let customData = { bookmarks: {}, toggles: {}, toggleAssignments: {} }; // Added toggleAssignments
    let cellElements = []; // Holds the DOM elements for each grid cell (the outer div)
    let currentBookmarks = []; // Initialized in loadCustomData
    let currentToggleRanges = []; // Initialized in loadCustomData
    let sortableInstance = null; // For Drag & Drop

    let onOffToggle, weatherButton, reminderButton, zoomButton, darkModeToggle;

    // --- Core Functions ---

    // --- Load/Save Functions (Modifications for Toggle Assignments & Drag/Drop) ---
    function saveCustomData() {
        try {
            // Ensure toggleAssignments exists in customData before saving
            if (!customData.toggleAssignments) {
                customData.toggleAssignments = {};
            }
            // Clean up empty assignment arrays before saving
            Object.keys(customData.toggleAssignments).forEach(key => {
                if (!customData.toggleAssignments[key] || customData.toggleAssignments[key].length === 0) {
                    delete customData.toggleAssignments[key];
                } else {
                    // Ensure array contains only numbers
                    customData.toggleAssignments[key] = customData.toggleAssignments[key]
                        .map(Number)
                        .filter(n => !isNaN(n) && n >= 0 && n < TOTAL_CELLS);
                }
            });
             if (Object.keys(customData.toggleAssignments).length === 0) {
                 delete customData.toggleAssignments; // Remove the key if it's empty
             }


            localStorage.setItem('customGridData', JSON.stringify(customData));
            console.log("Custom grid data saved (including bookmarks, toggles, assignments).");
        } catch (e) {
            console.error("Error saving custom grid data:", e);
            showToast("Error al guardar personalizaci√≥n", "error");
        }
    }

    function loadCustomData() {
        const savedData = localStorage.getItem('customGridData');
        if (savedData) {
            try {
                customData = JSON.parse(savedData);
                // Ensure essential keys exist
                if (!customData.bookmarks) customData.bookmarks = {};
                if (!customData.toggles) customData.toggles = {};
                if (!customData.toggleAssignments) customData.toggleAssignments = {}; // Ensure toggleAssignments exists

                // --- Load Bookmarks (handles potential order changes from D&D) ---
                currentBookmarks = Array.from({ length: TOTAL_CELLS }).map((_, index) => {
                    // Check if customData has an entry for this index *after* potential D&D
                    const customBookmark = customData.bookmarks?.[index];
                    if (customBookmark !== undefined) {
                        // Use custom data (could be null if explicitly emptied, or an object)
                        return customBookmark;
                    } else {
                        // Fallback to original if no specific custom data for this *final* position
                        // This handles cases where original data might be "shifted" due to D&D
                        // but not explicitly overridden
                        const originalBookmark = originalBookmarks[index];
                        // Need to check if this *original* bookmark might have been moved *elsewhere*
                        let foundOriginalElsewhere = false;
                        for (const key in customData.bookmarks) {
                             const item = customData.bookmarks[key];
                             // Compare by URL and Name as a heuristic for identity if original is not null
                             if (originalBookmark && item && item.url === originalBookmark.url && item.name === originalBookmark.name) {
                                 foundOriginalElsewhere = true;
                                 break;
                             }
                        }
                         // If the original bookmark for this index wasn't found moved elsewhere by custom data,
                         // and there's no specific custom data for this index, use the original.
                         if (!foundOriginalElsewhere) {
                             return originalBookmark !== undefined ? JSON.parse(JSON.stringify(originalBookmark)) : null;
                         } else {
                             // The original item for this index was moved, so this slot should be empty
                             // unless explicitly set otherwise by customData.bookmarks[index] (already handled above)
                             return null;
                         }
                    }
                });

                // Ensure length is correct
                if (currentBookmarks.length !== TOTAL_CELLS) {
                     console.warn(`Bookmark array length mismatch after load (${currentBookmarks.length}), adjusting to ${TOTAL_CELLS}`);
                     currentBookmarks.length = TOTAL_CELLS;
                     // Fill potentially missing slots, respecting customData
                     for(let i = 0; i < TOTAL_CELLS; i++) {
                         if (currentBookmarks[i] === undefined) {
                            currentBookmarks[i] = customData.bookmarks?.[i] !== undefined ? customData.bookmarks[i] : null;
                         }
                     }
                }

                // --- Load Toggles ---
                currentToggleRanges = originalToggleRanges.map(range => {
                    const customLabel = customData.toggles?.[range.start]?.label;
                    return {
                        ...range, // Copy original start, end
                        label: customLabel !== undefined ? customLabel : range.label // Use custom label or original
                    };
                });

                 // --- Load Toggle Assignments (already in customData.toggleAssignments) ---
                 // Validate assignments (ensure indices are numbers and within bounds)
                 Object.keys(customData.toggleAssignments).forEach(key => {
                     if (!Array.isArray(customData.toggleAssignments[key])) {
                         console.warn(`Invalid toggle assignment found for key ${key}, removing.`);
                         delete customData.toggleAssignments[key];
                     } else {
                         customData.toggleAssignments[key] = customData.toggleAssignments[key]
                             .map(Number)
                             .filter(n => !isNaN(n) && n >= 0 && n < TOTAL_CELLS);
                     }
                 });


                console.log("Custom grid data loaded.");
            } catch (e) {
                console.error("Error parsing custom grid data:", e);
                showToast("Error al cargar personalizaci√≥n. Reseteando a valores por defecto.", "error", 5000);
                customData = { bookmarks: {}, toggles: {}, toggleAssignments: {} }; // Reset on error
                // Initialize currentBookmarks and currentToggleRanges from originals
                currentBookmarks = Array.from({ length: TOTAL_CELLS }, (_, index) =>
                    originalBookmarks[index] !== undefined ? JSON.parse(JSON.stringify(originalBookmarks[index])) : null
                );
                 if (currentBookmarks.length < TOTAL_CELLS) currentBookmarks.length = TOTAL_CELLS;
                 currentBookmarks.fill(null, originalBookmarks.length); // Fill extra slots

                currentToggleRanges = JSON.parse(JSON.stringify(originalToggleRanges));
            }
        } else {
            // No saved data, use originals and initialize customData
            customData = { bookmarks: {}, toggles: {}, toggleAssignments: {} }; // Initialize empty
             currentBookmarks = Array.from({ length: TOTAL_CELLS }, (_, index) =>
                 originalBookmarks[index] !== undefined ? JSON.parse(JSON.stringify(originalBookmarks[index])) : null
             );
              if (currentBookmarks.length < TOTAL_CELLS) currentBookmarks.length = TOTAL_CELLS;
              currentBookmarks.fill(null, originalBookmarks.length);

            currentToggleRanges = JSON.parse(JSON.stringify(originalToggleRanges));
            console.log("No custom data found, using originals.");
        }
    }

    function loadSavedSettings() {
        // Load Dark Mode, Zoom State etc. (existing logic is fine)
        const savedDarkMode = localStorage.getItem('darkMode');
        isDarkMode = savedDarkMode ? JSON.parse(savedDarkMode) : checkDarkModeTime();
        if (isDarkMode) document.body.classList.add('dark-mode');

        const savedZoomState = localStorage.getItem('zoomState');
        const zoomButton = document.getElementById('zoom-button');
        if (savedZoomState && zoomButton) { zoomButton.dataset.zoomState = savedZoomState; applyZoom(savedZoomState); }
        else if (zoomButton) { zoomButton.dataset.zoomState = 'off'; applyZoom('off'); }

        const savedOnOffState = localStorage.getItem('onOffState');
        const savedNoticesActive = localStorage.getItem('noticesActive');
        const savedFooterVisible = localStorage.getItem('footerVisible');
        const onOffToggle = document.getElementById('on-off-toggle');

        // --- Load Master On/Off State ---
        const masterState = (savedOnOffState && onOffToggle) ? savedOnOffState : (onOffToggle ? 'on' : 'on');
        if (onOffToggle) onOffToggle.dataset.state = masterState;

        // Hide initial 0-17 range based on master state
        for (let i = 0; i <= 17; i++) {
            if (cellElements[i]) cellElements[i].classList.toggle('hidden', masterState === 'off');
        }

        // --- Load Individual Toggle States and Apply Visibility ---
        const savedToggleStates = localStorage.getItem('toggleStates');
        let parsedToggleStates = {};
        try {
            if (savedToggleStates) parsedToggleStates = JSON.parse(savedToggleStates);
        } catch (e) {
            console.error("Error parsing saved toggle states:", e);
        }

        document.querySelectorAll('.range-toggle').forEach(toggle => {
            const start = parseInt(toggle.dataset.rangeStart);
            const rangeConfig = currentToggleRanges.find(r => r.start === start);
            if (!rangeConfig) return;

            const state = parsedToggleStates[start] || 'visible'; // Default to visible
            toggle.dataset.state = state;
            toggle.innerHTML = `<span class="sign">${state === 'visible' ? '-' : '+'}</span>${rangeConfig.label}`;

            // Determine items controlled by this toggle (custom or default)
            const controlledIndices = getAssignedIndicesForToggle(start);

            // Apply visibility based on master state and individual toggle state
            const shouldHide = (masterState === 'off') || (state === 'hidden');
            controlledIndices.forEach(index => {
                if (cellElements[index]) {
                    cellElements[index].classList.toggle('hidden', shouldHide);
                }
            });
        });

        // Load Notices/Footer visibility (existing logic fine)
        isActive = savedNoticesActive ? JSON.parse(savedNoticesActive) : true;
        const nC = document.querySelector('.notices-container');
        if (nC) nC.style.display = isActive ? 'flex' : 'none';
        const fC = document.querySelector('footer');
        if (fC) fC.classList.toggle('footer-hidden', !isActive);

        isFooterVisible = savedFooterVisible ? JSON.parse(savedFooterVisible) : true;
        const footer = document.querySelector('footer');
        if (footer) footer.classList.toggle('footer-hidden', !isFooterVisible);

        updateButtonStyles();
        loadReminders();
        adjustButtonPositions();
        updateUserIdDisplay();
        console.log("UI settings loaded.");
    }

    // --- Rendering Functions ---
     function renderGrid() {
        grid.innerHTML = ''; // Clear previous grid
        cellElements = []; // Reset cell elements array

        // Destroy previous Sortable instance if it exists
        if (sortableInstance) {
            sortableInstance.destroy();
            sortableInstance = null;
        }

        for (let index = 0; index < TOTAL_CELLS; index++) {
            const cellWrapper = document.createElement('div'); // Outer div for grid layout + D&D target
            cellWrapper.dataset.index = index; // Set index on the wrapper

            const bookmarkData = currentBookmarks[index];

            if (bookmarkData) {
                const link = document.createElement('a');
                link.className = 'bookmark-item';
                link.title = bookmarkData.name || '';
                link.href = bookmarkData.url || "#";
                 link.dataset.index = index; // Keep index on link for consistency? Maybe not needed if using wrapper.

                // Apply color
                let color = generateBrightColor(); // Generate color logic needs refinement if needed
                const colorValues = color.match(/hsla\((\d+),\s*(\d+)%,\s*(\d+)%/);
                 if(colorValues) {
                     link.style.setProperty('--hue', colorValues[1]);
                     link.style.setProperty('--saturation', colorValues[2] + '%');
                     link.style.setProperty('--lightness', colorValues[3] + '%');
                 } else {
                     link.style.backgroundColor = 'hsla(0, 0%, 90%, 0.64)';
                 }


                if (bookmarkData.url && bookmarkData.name !== "Inicio Tesla") { // Only add target blank if it has a URL
                    link.target = "_blank";
                    link.rel = "noopener noreferrer";
                }

                const img = document.createElement('img');
                img.src = getFaviconUrl(bookmarkData);
                img.alt = `Favicon ${bookmarkData.name || ''}`;
                img.loading = "lazy";
                img.onerror = function() { this.src = 'https://via.placeholder.com/64'; this.onerror = null; };
                if (bookmarkData.name === "Mis Updates") img.classList.add('favicon-red');
                else if (bookmarkData.name === "Olas Updates") img.classList.add('favicon-blue');

                const nameSpan = document.createElement('span');
                nameSpan.className = 'bookmark-name';
                nameSpan.textContent = bookmarkData.name || 'Unnamed';

                link.appendChild(img);
                link.appendChild(nameSpan);
                cellWrapper.appendChild(link);
                 cellWrapper.addEventListener('click', handleItemClick); // Use wrapper for click

            } else {
                // Empty slot
                cellWrapper.className = 'empty-slot';
                const addIcon = document.createElement('span');
                addIcon.textContent = '+';
                cellWrapper.appendChild(addIcon);
                cellWrapper.addEventListener('click', handleItemClick); // Use wrapper for click
            }

            grid.appendChild(cellWrapper);
            cellElements.push(cellWrapper); // Store the wrapper
        }

        // Initialize SortableJS if in edit mode
        if (isEditMode) {
            initializeSortable();
        }
         applyStylesBasedOnState(); // Apply hidden styles etc. after rendering
    }


    function renderToggleButtons() {
        // Remove existing toggle buttons first
        document.querySelectorAll('.range-toggle').forEach(btn => btn.remove());

        // Create new toggle buttons based on currentToggleRanges
        currentToggleRanges.forEach((range) => {
            const toggle = document.createElement('span');
            toggle.className = 'toggle-sign range-toggle';
            toggle.dataset.rangeStart = range.start;
            // Store the original end, might be useful, but not used for hiding anymore
            toggle.dataset.rangeEnd = range.end;
            toggle.dataset.state = 'visible'; // Default state
            toggle.style.position = 'fixed'; // Position will be adjusted later
            toggle.style.left = '10px';
            toggle.innerHTML = `<span class="sign">-</span>${range.label}`; // Initial display

            toggle.addEventListener('click', handleToggleClick);

            document.body.appendChild(toggle);
        });

        // Re-adjust all button positions after adding/removing toggles
        adjustButtonPositions();
        // Apply visibility based on saved states AFTER buttons are rendered
        // loadSavedSettings(); // Careful: this might re-render grid/toggles causing loop. Call applyStylesBasedOnState instead.
        applyStylesBasedOnState();
    }

     function applyStylesBasedOnState() {
         // Applies .hidden class based on master state and individual toggle states
         const onOffToggle = document.getElementById('on-off-toggle');
         const masterState = onOffToggle?.dataset.state || 'on';

         // Hide initial 0-17 range based on master state
         for (let i = 0; i <= 17; i++) {
             if (cellElements[i]) cellElements[i].classList.toggle('hidden', masterState === 'off');
         }

         // Apply visibility for each toggle's controlled items
         document.querySelectorAll('.range-toggle').forEach(toggle => {
             const start = parseInt(toggle.dataset.rangeStart);
             const state = toggle.dataset.state || 'visible';
             const controlledIndices = getAssignedIndicesForToggle(start);
             const shouldHide = (masterState === 'off') || (state === 'hidden');

             controlledIndices.forEach(index => {
                 if (cellElements[index]) {
                     cellElements[index].classList.toggle('hidden', shouldHide);
                 }
             });
         });
          updateButtonStyles(); // Update visual styles of buttons (colors, icons)
     }

    function createOtherButtons() {
        // Create On/Off, Weather, Reminder, Zoom, DarkMode, Config, Personal, Home, Reload buttons
        // (Existing logic seems fine, just ensure IDs are correct)
        if (!document.getElementById('on-off-toggle')) {
            onOffToggle = document.createElement('img');
            onOffToggle.className = 'toggle-image'; onOffToggle.id = 'on-off-toggle';
            onOffToggle.dataset.state = 'on'; document.body.appendChild(onOffToggle);
            onOffToggle.addEventListener('mousedown', () => { pressStartTime = Date.now(); });
            onOffToggle.addEventListener('mouseup', handleOnOffAction);
            onOffToggle.addEventListener('mouseleave', () => { pressStartTime = null; });
            onOffToggle.addEventListener('touchstart', (e) => { e.preventDefault(); pressStartTime = Date.now(); });
            onOffToggle.addEventListener('touchend', (e) => { e.preventDefault(); handleOnOffAction(); });
        }
        if (!document.getElementById('weather-button')) {
            weatherButton = document.createElement('span');
            weatherButton.className = 'toggle-sign'; weatherButton.id = 'weather-button';
            weatherButton.innerHTML = `<img src="https://www.google.com/s2/favicons?domain=accuweather.com&sz=64" alt="Tiempo" style="max-width: 60%; max-height: 60%; object-fit: contain;">`;
            document.body.appendChild(weatherButton);
            weatherButton.addEventListener('click', () => { if (isEditMode || isAssigningToggles) return; window.open('https://www.ventusky.com/?p=40.2;-4.7;5&l=rain-3h', '_blank'); });
        }
         if (!document.getElementById('reminder-button')) {
             reminderButton = document.createElement('span');
             reminderButton.className = 'toggle-sign'; reminderButton.id = 'reminder-button';
             document.body.appendChild(reminderButton);
             reminderButton.addEventListener('mousedown', () => { reminderPressStartTime = Date.now(); });
             reminderButton.addEventListener('mouseup', handleReminderLongPress);
             reminderButton.addEventListener('mouseleave', () => { reminderPressStartTime = null; });
             reminderButton.addEventListener('touchstart', (e) => { e.preventDefault(); reminderPressStartTime = Date.now(); });
             reminderButton.addEventListener('touchend', (e) => { e.preventDefault(); handleReminderLongPress(); });
         }
         if (!document.getElementById('zoom-button')) {
             zoomButton = document.createElement('span');
             zoomButton.className = 'toggle-sign'; zoomButton.id = 'zoom-button';
             zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/zoon-.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`;
             zoomButton.dataset.zoomState = 'off'; document.body.appendChild(zoomButton);
             zoomButton.addEventListener('click', () => { if (isEditMode || isAssigningToggles) return; const cS = zoomButton.dataset.zoomState; const nS = cS === 'off' ? 'on' : 'off'; applyZoom(nS); zoomButton.dataset.zoomState = nS; updateButtonStyles(); saveSettings(); adjustButtonPositions(); });
         }
        if (!document.getElementById('dark-mode-toggle')) {
            darkModeToggle = document.createElement('img');
            darkModeToggle.className = 'toggle-image'; darkModeToggle.id = 'dark-mode-toggle';
            document.body.appendChild(darkModeToggle);
            darkModeToggle.addEventListener('click', () => { isDarkMode = !isDarkMode; document.body.classList.toggle('dark-mode', isDarkMode); updateButtonStyles(); saveSettings(); });
        }
        if (!document.getElementById('config-button')) {
             const configButton = document.createElement('span'); configButton.className = 'toggle-sign'; configButton.id = 'config-button';
             configButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/config.jpg" alt="Configuraci√≥n">`; document.body.appendChild(configButton);
             configButton.addEventListener('click', () => { if (isEditMode || isAssigningToggles) return; showConfigModal(); });
        }
        if (!document.getElementById('personal-button')) {
             const personalButton = document.createElement('span'); personalButton.className = 'toggle-sign'; personalButton.id = 'personal-button';
             personalButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/personal.png" alt="Personal">`; document.body.appendChild(personalButton);
             personalButton.addEventListener('click', handlePersonalizationClick); // Use new handler
        }
         if (!document.getElementById('home-button')) {
             const homeButton = document.createElement('span'); homeButton.className = 'toggle-sign'; homeButton.id = 'home-button';
             homeButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/home.webp" alt="Inicio">`; document.body.appendChild(homeButton);
             homeButton.addEventListener('click', (e) => { if (isEditMode || isAssigningToggles) { e.preventDefault(); return; } window.history.back(); });
         }
        if (!document.getElementById('reload-button')) {
             const reloadButton = document.createElement('span'); reloadButton.className = 'toggle-sign'; reloadButton.id = 'reload-button';
             reloadButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/reload.webp" alt="Recargar">`; document.body.appendChild(reloadButton);
             reloadButton.addEventListener('click', () => { if (isEditMode || isAssigningToggles) return; location.reload(); });
        }
    }

    // --- Toggle Logic (Using Assignments) ---
    function getAssignedIndicesForToggle(toggleStart) {
        // Check custom assignments first
        const customAssignments = customData?.toggleAssignments?.[toggleStart];
        if (customAssignments && Array.isArray(customAssignments) && customAssignments.length > 0) {
            return customAssignments;
        }

        // Fallback to original range if no custom assignment
        const originalRange = originalToggleRanges.find(r => r.start === toggleStart);
        if (originalRange) {
            const indices = [];
            for (let i = originalRange.start; i <= originalRange.end; i++) {
                indices.push(i);
            }
            return indices;
        }

        // Fallback if something is wrong
        console.warn(`No assignment or original range found for toggle start ${toggleStart}. Returning empty.`);
        return [];
    }

     function updateToggleState(toggle) {
        if (!toggle || isEditMode || isAssigningToggles) return; // Don't toggle state if in any edit mode

        const start = parseInt(toggle.dataset.rangeStart);
        if (isNaN(start)) return;

        const currentState = toggle.dataset.state;
        const newState = currentState === 'visible' ? 'hidden' : 'visible';
        const rangeConfig = currentToggleRanges.find(r => r.start === start);
        const label = rangeConfig?.label || `Rango ${start}`;

        toggle.dataset.state = newState;
        toggle.innerHTML = `<span class="sign">${newState === 'visible' ? '-' : '+'}</span>${label}`;

        const controlledIndices = getAssignedIndicesForToggle(start);
        const masterState = document.getElementById('on-off-toggle')?.dataset.state || 'on';

        // Hide/show only if master state is 'on'
        if (masterState === 'on') {
            controlledIndices.forEach(index => {
                if (cellElements[index]) {
                    cellElements[index].classList.toggle('hidden', newState === 'hidden');
                }
            });
        }

        // Save the state change
        const savedStates = JSON.parse(localStorage.getItem('toggleStates') || '{}');
        savedStates[start] = newState;
        localStorage.setItem('toggleStates', JSON.stringify(savedStates));

        updateButtonStyles(); // Update color etc.
    }

    function updateAllToggles(newState) { // Triggered by On/Off button
        const onOffToggle = document.getElementById('on-off-toggle');
        if (!onOffToggle) return;
        onOffToggle.dataset.state = newState;

        // Hide/Show items 0-17 based on new master state
        for (let i = 0; i <= 17; i++) {
            if (cellElements[i]) cellElements[i].classList.toggle('hidden', newState === 'off');
        }

        // Update visibility for all toggle-controlled items
        document.querySelectorAll('.range-toggle').forEach(toggle => {
            const start = parseInt(toggle.dataset.rangeStart);
            if (isNaN(start)) return;

            const individualState = toggle.dataset.state || 'visible'; // Keep individual state
            const controlledIndices = getAssignedIndicesForToggle(start);
            const shouldHide = (newState === 'off') || (individualState === 'hidden');

            controlledIndices.forEach(index => {
                if (cellElements[index]) {
                    cellElements[index].classList.toggle('hidden', shouldHide);
                }
            });
        });

        updateButtonStyles(); // Update icons/colors
        saveSettings(); // Save master state and other UI settings
    }

    // --- Event Handlers ---
    function handleToggleClick(event) {
        const toggle = event.currentTarget;
        if (isAssigningToggles) {
            // --- Logic for Toggle Assignment Mode ---
            event.preventDefault();
            const start = parseInt(toggle.dataset.rangeStart);
             if (isNaN(start)) return;

             // Deselect previous toggle visually
             if (selectedToggleForAssignment !== null) {
                 const prevToggle = document.querySelector(`.range-toggle[data-range-start="${selectedToggleForAssignment}"]`);
                 if (prevToggle) prevToggle.classList.remove('toggle-selected-for-assignment');
             }

             // Clear previous item highlights
             clearAssignmentHighlights();

             // Select new toggle
             selectedToggleForAssignment = start;
             toggle.classList.add('toggle-selected-for-assignment');

             // Highlight items currently assigned to this toggle
             highlightAssignedItems(start);

             // Update info panel
             const infoPanel = document.getElementById('assignment-info-panel');
             if (infoPanel) {
                 const rangeConfig = currentToggleRanges.find(r => r.start === start);
                 infoPanel.innerHTML = `Asignando a: <strong>${rangeConfig?.label || `Ocultador ${start}`}</strong>. Clica en grid para a√±adir/quitar. Pulsa <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:16px;height:16px;display:inline;vertical-align:middle;"> para guardar.`;
             }

        } else if (isEditMode) {
            // --- Logic for URL/Label Edit Mode ---
            event.preventDefault(); // Prevent normal toggle action
            const start = parseInt(toggle.dataset.rangeStart);
             if (!isNaN(start)) {
                 showEditModal(start, true); // Open modal for editing toggle label
             }
        } else {
            // --- Normal Mode ---
            updateToggleState(toggle); // Perform the standard hide/show action
        }
    }

    function handleItemClick(event) {
        const targetWrapper = event.currentTarget; // The outer div cellWrapper
        const index = parseInt(targetWrapper.dataset.index);
         if (isNaN(index)) return;

         if (isAssigningToggles) {
            // --- Logic for Toggle Assignment Mode ---
            event.preventDefault(); // Prevent link navigation
            if (selectedToggleForAssignment === null) {
                showToast("Primero selecciona un bot√≥n ocultador de la izquierda.", "warning");
                return;
            }

            // Initialize assignments for the selected toggle if not present
            if (!tempToggleAssignments[selectedToggleForAssignment]) {
                 // Start with current assignments (custom or default)
                 tempToggleAssignments[selectedToggleForAssignment] = [...getAssignedIndicesForToggle(selectedToggleForAssignment)];
            }

            const assignmentList = tempToggleAssignments[selectedToggleForAssignment];
            const itemIndexInList = assignmentList.indexOf(index);

            if (itemIndexInList > -1) {
                // Item is currently assigned, remove it
                assignmentList.splice(itemIndexInList, 1);
                targetWrapper.classList.remove('item-assigned-to-selected-toggle');
                 showToast(`Bot√≥n ${index + 1} desasignado.`, 'info', 1500);
            } else {
                // Item is not assigned, add it
                assignmentList.push(index);
                targetWrapper.classList.add('item-assigned-to-selected-toggle');
                showToast(`Bot√≥n ${index + 1} asignado.`, 'success', 1500);
            }
             // Keep tempToggleAssignments updated, save happens on exit

        } else if (isEditMode) {
            // --- Logic for URL/Label Edit Mode (or adding new) ---
             const linkElement = targetWrapper.querySelector('.bookmark-item'); // Check if it has a bookmark inside
             if (linkElement) {
                event.preventDefault(); // Prevent navigation if clicking existing bookmark link
             }
             showEditModal(index, false); // Open modal for editing bookmark/empty slot

        } else {
            // --- Normal Mode ---
            // Allow default behavior (navigation for links)
             const linkElement = targetWrapper.querySelector('.bookmark-item');
             if (linkElement && linkElement.href && linkElement.href !== '#') {
                 // Click is likely on a valid link, let the browser handle it.
                 // If target="_blank" is set, it will open in a new tab.
             } else {
                 // Clicked on empty slot or link without href in normal mode - do nothing
                 event.preventDefault();
             }
        }
    }

    // --- Personalization Mode Switching ---
    function handlePersonalizationClick() {
        const personalButton = document.getElementById('personal-button');

        if (isEditMode) {
            // Currently in URL/Label/D&D Edit mode, exit it
            exitEditMode();
        } else if (isAssigningToggles) {
            // Currently in Toggle Assignment mode, save and exit
            exitToggleAssignmentMode(true); // true = save changes
        } else {
            // Not in any personalization mode, show choice modal
            showPersonalizationChoiceModal();
        }
    }

    function showPersonalizationChoiceModal() {
        const existingModal = document.querySelector('.personalization-choice-modal');
        if (existingModal) existingModal.remove();

        const modal = document.createElement('div');
        modal.className = 'personalization-choice-modal';
        modal.innerHTML = `
            <h2>Personalizar</h2>
            <p>¬øQu√© deseas hacer?</p>
            <div class="choice-buttons">
                <button id="choice-edit-urls">Editar URLs / Etiquetas / Orden</button>
                <button id="choice-assign-toggles">Asignar Ocultadores</button>
            </div>
            <div style="text-align:center; margin-top: 1.5rem;">
                 <button id="choice-cancel" style="background-color:#6c757d; font-size: 1.1rem; padding: 0.6rem 1.2rem; height: auto;">Cancelar</button>
            </div>
        `;
        document.body.appendChild(modal);

        modal.querySelector('#choice-edit-urls').addEventListener('click', () => {
            modal.remove();
            enterEditMode();
        });
        modal.querySelector('#choice-assign-toggles').addEventListener('click', () => {
            modal.remove();
            enterToggleAssignmentMode();
        });
        modal.querySelector('#choice-cancel').addEventListener('click', () => {
            modal.remove();
        });
    }

    function enterEditMode() {
        if (isAssigningToggles) exitToggleAssignmentMode(false); // Exit assignment mode if active

        isEditMode = true;
        const personalButton = document.getElementById('personal-button');
        if(personalButton) personalButton.classList.add('editing');
        document.body.classList.add('editing-active');
        grid.querySelectorAll('.bookmark-item, .empty-slot').forEach(el => el.classList.add('editable'));
        document.querySelectorAll('.range-toggle').forEach(el => el.classList.add('editable'));

        initializeSortable(); // Enable Drag & Drop

        if (!sessionStorage.getItem('editModeExplained')) {
            showEditInfoModal(); // Show combined help
            sessionStorage.setItem('editModeExplained', 'true');
        }
        showToast("Modo Edici√≥n (URLs/Etiquetas/Orden) Activado", "info", 4000);
    }

    function exitEditMode() {
        isEditMode = false;
        const personalButton = document.getElementById('personal-button');
        if(personalButton) personalButton.classList.remove('editing');
        document.body.classList.remove('editing-active');
        grid.querySelectorAll('.bookmark-item, .empty-slot').forEach(el => el.classList.remove('editable'));
        document.querySelectorAll('.range-toggle').forEach(el => el.classList.remove('editable'));

        if (sortableInstance) { // Disable Drag & Drop
            sortableInstance.destroy();
            sortableInstance = null;
        }
        // Remove grab cursor potentially set by Sortable
        grid.querySelectorAll('#bookmark-grid > div').forEach(el => el.style.cursor = '');

        showToast("Modo Edici√≥n (URLs/Etiquetas/Orden) Desactivado", "info", 2000);
         // Re-apply normal click behavior? Might not be necessary if handled correctly in handleItemClick
         // Re-render might be safest, but less efficient. Let's rely on the handleItemClick logic first.
         applyStylesBasedOnState(); // Ensure hidden state is correct
    }

    function enterToggleAssignmentMode() {
        if (isEditMode) exitEditMode(); // Exit URL edit mode if active

        isAssigningToggles = true;
        selectedToggleForAssignment = null; // Nothing selected initially
        tempToggleAssignments = JSON.parse(JSON.stringify(customData.toggleAssignments || {})); // Work on a copy

        const personalButton = document.getElementById('personal-button');
        if(personalButton) personalButton.classList.add('assigning'); // Use 'assigning' class
        document.body.classList.add('assigning-toggles-active');

        // Ensure D&D is off
        if (sortableInstance) {
            sortableInstance.destroy();
            sortableInstance = null;
        }
        grid.querySelectorAll('#bookmark-grid > div').forEach(el => el.style.cursor = 'cell'); // Set assignment cursor


        if (!sessionStorage.getItem('editModeExplained')) {
             showEditInfoModal(); // Show combined help
             sessionStorage.setItem('editModeExplained', 'true');
        }

        showToast("Modo Asignaci√≥n Ocultadores Activado", "info", 4000);
        const infoPanel = document.getElementById('assignment-info-panel');
        if (infoPanel) infoPanel.innerHTML = `Selecciona un ocultador (izq.), luego clica en los botones del grid para asignar/desasignar. Pulsa <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:16px;height:16px;display:inline;vertical-align:middle;"> para guardar y salir.`;
    }

    function exitToggleAssignmentMode(saveChanges = false) {
        if (saveChanges) {
            // Save the temporary assignments to the main customData object
            customData.toggleAssignments = JSON.parse(JSON.stringify(tempToggleAssignments));
            saveCustomData();
            showToast("Asignaciones de ocultadores guardadas", "success");
        } else {
            showToast("Asignaci√≥n de ocultadores cancelada", "info");
        }

        isAssigningToggles = false;
        selectedToggleForAssignment = null;
        tempToggleAssignments = {};

        const personalButton = document.getElementById('personal-button');
        if(personalButton) personalButton.classList.remove('assigning');
        document.body.classList.remove('assigning-toggles-active');

        // Clear visual cues
        clearAssignmentHighlights();
         const selectedToggle = document.querySelector('.toggle-selected-for-assignment');
         if(selectedToggle) selectedToggle.classList.remove('toggle-selected-for-assignment');
         grid.querySelectorAll('#bookmark-grid > div').forEach(el => el.style.cursor = ''); // Reset cursor


        applyStylesBasedOnState(); // Re-apply correct visibility based on saved/restored state
    }

    // --- Toggle Assignment Helpers ---
    function clearAssignmentHighlights() {
        grid.querySelectorAll('.item-assigned-to-selected-toggle').forEach(el => {
            el.classList.remove('item-assigned-to-selected-toggle');
        });
    }

    function highlightAssignedItems(toggleStart) {
        clearAssignmentHighlights();
        // Use temp assignments if available, otherwise current/default
        const indicesToHighlight = tempToggleAssignments[toggleStart] ?? getAssignedIndicesForToggle(toggleStart);
        indicesToHighlight.forEach(index => {
            if (cellElements[index]) {
                cellElements[index].classList.add('item-assigned-to-selected-toggle');
            }
        });
    }

    // --- Drag & Drop Implementation ---
    function initializeSortable() {
        if (!isEditMode || sortableInstance) {
             // Only init if in edit mode and not already initialized
             // Or destroy if not in edit mode
             if (!isEditMode && sortableInstance) {
                 sortableInstance.destroy();
                 sortableInstance = null;
                 grid.querySelectorAll('#bookmark-grid > div').forEach(el => el.style.cursor = ''); // Reset cursor
             }
             return;
        }

        sortableInstance = new Sortable(grid, {
            animation: 150,
            ghostClass: 'sortable-ghost', // Class for the drop placeholder
            chosenClass: 'sortable-chosen', // Class for the item being dragged
            // draggable: '.bookmark-item, .empty-slot', // Specify items that can be dragged (use wrapper div)
             filter: '.fixed', // Define elements that should not be draggable (if any)
            preventOnFilter: true, // Prevent dragging of filtered elements

            onStart: function (evt) {
                 // console.log('Drag start:', evt.oldIndex);
                 grid.querySelectorAll('#bookmark-grid > div').forEach(el => el.style.cursor = 'grabbing');
            },

            onEnd: function (evt) {
                grid.querySelectorAll('#bookmark-grid > div').forEach(el => el.style.cursor = 'grab'); // Reset cursor
                const oldIndex = evt.oldIndex;
                const newIndex = evt.newIndex;

                 if (oldIndex === newIndex) {
                     // console.log('Drag end: No change');
                     return; // No change in position
                 }

                 console.log(`Drag end: Item moved from ${oldIndex} to ${newIndex}`);

                 // --- Update the Data Arrays ---
                 // 1. Update currentBookmarks (visual order)
                 const itemToMove = currentBookmarks.splice(oldIndex, 1)[0];
                 currentBookmarks.splice(newIndex, 0, itemToMove);

                 // 2. Update customData.bookmarks to reflect the new state for persistence
                 // Create a new bookmarks object based on the final order in currentBookmarks
                 const newCustomBookmarks = {};
                 currentBookmarks.forEach((bookmark, index) => {
                    // Only store non-null bookmarks or explicitly store null if it differs from original
                    const originalAtIndex = originalBookmarks[index];
                     if (bookmark !== null) {
                         // If the item is different from the original at this index OR the original was null, store it.
                         if (bookmark !== originalAtIndex || originalAtIndex === null || (originalAtIndex && (bookmark.name !== originalAtIndex.name || bookmark.url !== originalAtIndex.url))) {
                              newCustomBookmarks[index] = JSON.parse(JSON.stringify(bookmark));
                         }
                    } else {
                        // If the slot is now empty (null) but was originally filled, store null.
                         if (originalAtIndex !== null && originalAtIndex !== undefined) {
                             newCustomBookmarks[index] = null;
                         }
                    }
                 });
                 customData.bookmarks = newCustomBookmarks;

                 // 3. Save the updated customData
                 saveCustomData();

                 // 4. Re-render the grid to update data-index attributes and potentially styles
                 //    We need to re-render because the `data-index` on the DOM elements
                 //    no longer matches the array index after Sortable moves them visually.
                 renderGrid(); // This also re-initializes Sortable if still in edit mode
                 showToast(`√çtem movido de posici√≥n ${oldIndex + 1} a ${newIndex + 1}`, 'info', 2000);
            }
        });
         grid.querySelectorAll('#bookmark-grid > div').forEach(el => el.style.cursor = 'grab');
         console.log("Sortable initialized.");
    }


    // --- Modal Functions ---
    function showEditInfoModal() {
        const modal = document.createElement('div');
        modal.className = 'edit-info-modal';
        modal.setAttribute('aria-label', 'Ayuda Personalizaci√≥n');
        // --- UPDATED HELP TEXT ---
        modal.innerHTML = `
            <h2>Ayuda Personalizaci√≥n</h2>
            <p>Tras pulsar <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:20px;height:20px;display:inline;vertical-align:middle;">, elige qu√© personalizar:</p>
            <ul class="list-disc pl-6 mb-4">
                <li>
                    <strong>Editar URLs / Etiquetas / Orden:</strong>
                    <ul class="list-circle pl-6">
                        <li>Clic en un <strong>marcador</strong> o <strong>espacio vac√≠o (+)</strong> para editar/a√±adir URL y nombre.</li>
                        <li>Clic en una <strong>etiqueta de secci√≥n</strong> lateral (PdR,s, etc.) para cambiar su nombre (m√°x 7 caract.).</li>
                        <li>En el editor: Guarda, Cancela, Resetea al original o <strong>Vac√≠a</strong> el espacio.</li>
                        <li><strong>Arrastra y suelta</strong> los botones del grid para reordenarlos.</li>
                    </ul>
                </li>
                <li>
                    <strong>Asignar Ocultadores:</strong>
                     <ul class="list-circle pl-6">
                        <li>Clic en un <strong>bot√≥n ocultador lateral</strong> (PdR,s, etc.) para seleccionarlo (se marcar√° en cian).</li>
                        <li>Luego, clica en los <strong>botones del grid</strong> (marcadores o vac√≠os) para asignarlos o desasignarlos a ese ocultador (se marcar√°n en cian).</li>
                        <li>Puedes seleccionar otro ocultador lateral para configurar sus asignaciones.</li>
                    </ul>
                </li>
            </ul>
            <p>Pulsa <img src="https://boardinggate.github.io/Tesla/personal.png" alt="P" style="width:20px;height:20px;display:inline;vertical-align:middle;"> de nuevo para <strong>guardar y salir</strong> del modo actual.</p>
            <div class="flex justify-end">
                <button type="button" id="close-edit-info">Entendido</button>
            </div>`;
        // --- END OF UPDATED HELP TEXT ---
        document.body.appendChild(modal);
        modal.querySelector('#close-edit-info').addEventListener('click', () => {
            if (modal.parentNode) modal.parentNode.removeChild(modal);
        });
    }

     function showEditModal(targetIndex, isToggle = false) {
         // --- MODIFIED: Check current personalization mode ---
         if (isAssigningToggles) {
             console.warn("Attempted to open edit modal while in assignment mode. Ignoring.");
             return;
         }
         if (!isEditMode) {
              console.warn("Attempted to open edit modal outside of edit mode. Ignoring.");
             return;
         }
         // --- END MODIFICATION ---


         const existingModal = document.querySelector('.edit-modal');
         if (existingModal) existingModal.remove();

         const modal = document.createElement('div');
         modal.className = 'edit-modal';

         let currentItemData = {};
         let originalItemData = {};
         let title = '';

         if (isToggle) {
             // Editar Etiqueta de Secci√≥n (Toggle)
             const currentRange = currentToggleRanges.find(r => r.start === targetIndex);
             const originalRange = originalToggleRanges.find(r => r.start === targetIndex);
             currentItemData = { label: currentRange?.label || '' };
             originalItemData = { label: originalRange?.label || '' };
             title = `Editar Etiqueta Secci√≥n`;
             modal.innerHTML = `
                 <h2>${title}</h2>
                 <div>
                     <label for="edit-label">Etiqueta (m√°x 7):</label>
                     <input type="text" id="edit-label" value="${currentItemData.label}" maxlength="7">
                 </div>
                 <div class="button-group">
                     <button class="save">Guardar</button>
                     <button class="reset">Resetear</button>
                     <button class="cancel">Cancelar</button>
                 </div>`;
         } else {
             // Editar Marcador (o a√±adir uno nuevo)
             const currentBookmark = currentBookmarks[targetIndex]; // Can be null
             const originalBookmark = originalBookmarks[targetIndex]; // Can be null or undefined

             currentItemData = currentBookmark ? { ...currentBookmark } : {};
             originalItemData = originalBookmark ? { ...originalBookmark } : {}; // Use original definition

             title = currentBookmark
                 ? `Editar Marcador: ${currentItemData?.name || `√çndice ${targetIndex + 1}`}`
                 : `A√±adir Marcador (Posici√≥n ${targetIndex + 1})`;

             modal.innerHTML = `
                 <h2>${title}</h2>
                 <div>
                     <label for="edit-name">Nombre:</label>
                     <input type="text" id="edit-name" value="${currentItemData.name || ''}">
                 </div>
                 <div>
                     <label for="edit-url">URL:</label>
                     <div class="input-with-button">
                         <input type="url" id="edit-url" value="${currentItemData.url || ''}" placeholder="https://ejemplo.com">
                         <button class="search-button" id="search-url-button" title="Buscar URL en Google (basado en URL/Nombre)">üîç</button>
                     </div>
                 </div>
                 <div>
                     <label for="edit-favicon">URL Favicon (Opcional):</label>
                     <div class="input-with-button">
                         <input type="text" id="edit-favicon" value="${currentItemData.favicon || ''}" placeholder="Dejar vac√≠o para auto">
                         <button class="search-button" id="search-favicon-button" title="Buscar Favicon en Google Images (basado en Favicon/Nombre)">üñºÔ∏è</button>
                     </div>
                 </div>
                 <div class="button-group">
                     <button class="save">Guardar</button>
                     <button class="reset">Resetear</button>
                     <button class="empty">Vaciar</button>
                     <button class="cancel">Cancelar</button>
                 </div>`;
         }

         document.body.appendChild(modal);

         // --- Event Listeners del Modal ---
         modal.querySelector('.save').addEventListener('click', () => {
             if (isToggle) {
                 const newLabel = modal.querySelector('#edit-label').value.trim();
                 if (!newLabel) { showToast("La etiqueta no puede estar vac√≠a.", "warning"); return; }
                 if (newLabel.length > 7) { showToast("La etiqueta no puede exceder 7 caracteres.", "warning"); return; }

                 if (!customData.toggles) customData.toggles = {};
                 if (!customData.toggles[targetIndex]) customData.toggles[targetIndex] = {};
                 customData.toggles[targetIndex].label = newLabel;

                 const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetIndex);
                 if (rangeIdx > -1) currentToggleRanges[rangeIdx].label = newLabel;

             } else {
                 const nameInput = modal.querySelector('#edit-name');
                 const urlInput = modal.querySelector('#edit-url');
                 const faviconInput = modal.querySelector('#edit-favicon');
                 const newName = nameInput.value.trim();
                 const newUrl = urlInput.value.trim();
                 const newFavicon = faviconInput.value.trim();

                 if (!newName && !newUrl && !newFavicon) {
                     // Explicitly emptying the slot
                     if (!customData.bookmarks) customData.bookmarks = {};
                     customData.bookmarks[targetIndex] = null;
                     currentBookmarks[targetIndex] = null;
                     saveCustomData();
                     updateGridItemUI(targetIndex, false); // Update specific item
                     if (modal.parentNode) modal.parentNode.removeChild(modal);
                     showToast("Espacio vaciado y guardado", "success");
                     return;
                 }

                 if (!newName || !newUrl) {
                     showToast("Nombre y URL son obligatorios para guardar un marcador.", "warning");
                     return;
                 }
                 try { if (newUrl) new URL(newUrl); } catch (_) { showToast("La URL introducida no es v√°lida.", "warning"); return; }

                 const bookmarkUpdate = { name: newName, url: newUrl, favicon: newFavicon || undefined }; // Store undefined if empty

                 if (!customData.bookmarks) customData.bookmarks = {};
                 customData.bookmarks[targetIndex] = bookmarkUpdate;
                 currentBookmarks[targetIndex] = { ...bookmarkUpdate }; // Update live array with a copy
             }

             saveCustomData();
             updateGridItemUI(targetIndex, isToggle); // Update specific item
             if (modal.parentNode) modal.parentNode.removeChild(modal);
             showToast("Cambios guardados", "success");
         });

         modal.querySelector('.reset').addEventListener('click', () => {
             if (isToggle) {
                 const originalRange = originalToggleRanges.find(r => r.start === targetIndex);
                 const originalLabel = originalRange?.label || '';
                 modal.querySelector('#edit-label').value = originalLabel;

                 // Remove customization for this toggle label
                 if (customData.toggles?.[targetIndex]) {
                     delete customData.toggles[targetIndex];
                     if (Object.keys(customData.toggles).length === 0) delete customData.toggles;
                 }
                 // Update live data
                 const rangeIdx = currentToggleRanges.findIndex(r => r.start === targetIndex);
                 if (rangeIdx > -1 && originalRange) {
                      currentToggleRanges[rangeIdx].label = originalLabel;
                 }

             } else {
                 const originalBookmark = originalBookmarks[targetIndex]; // Could be undefined/null
                 modal.querySelector('#edit-name').value = originalBookmark?.name || '';
                 modal.querySelector('#edit-url').value = originalBookmark?.url || '';
                 modal.querySelector('#edit-favicon').value = originalBookmark?.favicon || '';

                 // Remove customization for this bookmark index
                 if (customData.bookmarks?.[targetIndex] !== undefined) {
                      delete customData.bookmarks[targetIndex];
                      if (Object.keys(customData.bookmarks).length === 0) delete customData.bookmarks;
                 }
                  // Update live data to original (could be null)
                  currentBookmarks[targetIndex] = originalBookmark ? JSON.parse(JSON.stringify(originalBookmark)) : null;
             }

             saveCustomData(); // Save the removal of custom data
             updateGridItemUI(targetIndex, isToggle); // Update UI
             showToast("Valores reseteados al original. Pulsa Guardar si quieres mantener el reset.", "info");
             // Do not close modal on reset, let user save/cancel
         });

         modal.querySelector('.cancel').addEventListener('click', () => {
             if (modal.parentNode) modal.parentNode.removeChild(modal);
         });

         if (!isToggle) {
             // Listener for "Vaciar" button
             const emptyBtn = modal.querySelector('.empty');
             if (emptyBtn) {
                 emptyBtn.addEventListener('click', () => {
                     modal.querySelector('#edit-name').value = '';
                     modal.querySelector('#edit-url').value = '';
                     modal.querySelector('#edit-favicon').value = '';
                     showToast("Campos vaciados. Pulsa Guardar para confirmar.", "info");
                 });
             }
             // Listeners for search buttons
             const searchUrlBtn = modal.querySelector('#search-url-button');
             const searchFaviconBtn = modal.querySelector('#search-favicon-button');
             const nameInput = modal.querySelector('#edit-name');
             const urlInput = modal.querySelector('#edit-url');
             const faviconInput = modal.querySelector('#edit-favicon');

             if (searchUrlBtn) { searchUrlBtn.addEventListener('click', () => { const q = urlInput.value.trim() || nameInput.value.trim(); if(q) window.open(`https://www.google.com/search?q=${encodeURIComponent(q)}`, '_blank'); else showToast("Escribe Nombre o URL.", "warning"); }); }
             if (searchFaviconBtn) { searchFaviconBtn.addEventListener('click', () => { const q = faviconInput.value.trim() || nameInput.value.trim(); if(q) window.open(`https://www.google.com/search?tbm=isch&q=${encodeURIComponent(`"${q}" favicon logo icon`)}`, '_blank'); else showToast("Escribe Nombre o Favicon.", "warning"); }); }
         }
     }

     function updateGridItemUI(indexOrStart, isToggle = false) {
        // This function now re-renders the whole grid and toggles for simplicity
        // after edits or resets, ensuring data-indexes and assignments are correct.
        console.log(`Updating UI potentially affecting ${isToggle ? 'toggle' : 'bookmark'} at index/start ${indexOrStart}`);
        renderGrid(); // Re-renders the grid based on currentBookmarks
        renderToggleButtons(); // Re-renders toggles based on currentToggleRanges
         // loadSavedSettings(); // Reloads visibility states etc. - Might be overkill, applyStyles might be enough
         applyStylesBasedOnState(); // Apply correct hidden classes and button styles
         adjustButtonPositions(); // Ensure buttons are positioned correctly
     }


    // --- Other Helper Functions (generateBrightColor, getFaviconUrl, etc. remain mostly the same) ---
    const getFaviconUrl = (bookmarkData) => { /* ... existing logic ... */ return 'https://via.placeholder.com/64'; };
    function generateBrightColor() { /* ... existing logic ... */ return `hsla(${Math.floor(Math.random() * 360)}, ${40 + Math.floor(Math.random() * 30)}%, ${80 + Math.floor(Math.random() * 15)}%, 0.64)`;}
    function areColorsSimilar(c1, c2) { /* ... existing logic ... */ return false; }
    function applyZoom(state) { /* ... existing logic ... */ }
    function updateButtonStyles() { /* ... existing logic (might need minor adjustments for assigning class) ... */
         const darkModeToggle = document.getElementById('dark-mode-toggle');
         const onOffToggle = document.getElementById('on-off-toggle');
         const toggleButtons = document.querySelectorAll('.toggle-sign.range-toggle');
         const weatherButton = document.getElementById('weather-button');
         const zoomButton = document.getElementById('zoom-button');
         const reminderButton = document.getElementById('reminder-button');

         if (onOffToggle) { onOffToggle.src = `https://boardinggate.github.io/Tesla/${onOffToggle.dataset.state === 'on' ? 'IMG_4192.jpg' : 'IMG_4191.jpg'}`; onOffToggle.alt = `Toggle ${onOffToggle.dataset.state === 'on' ? 'On' : 'Off'}`; }
         if (darkModeToggle) { darkModeToggle.src = `https://boardinggate.github.io/Tesla/${isDarkMode ? 'oscuro2.png' : 'claro2.png'}`; darkModeToggle.alt = `Toggle ${isDarkMode ? 'Oscuro' : 'Claro'}`; }

         const reminders = JSON.parse(localStorage.getItem('reminders') || '[]'); const pendingCount = reminders.length;
         if (reminderButton) { reminderButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/IMG_4197.jpg" alt="Recordatorio" style="max-width: 70%; max-height: 70%; object-fit: contain;">${pendingCount > 0 ? `<span class="reminder-count">${pendingCount}</span>` : ''}`; }

         const baseBg = '#ABAB99'; // Assuming light mode base or dark mode override base
          const darkBg = '#92927E'; // Specific dark mode background if needed, or adjust brightness

         const currentBg = isDarkMode ? darkBg : baseBg;

         toggleButtons.forEach(t => { t.style.backgroundColor = currentBg; t.style.color = isDarkMode ? '#E6E6DC' : '#000000'; t.classList.toggle('dark-mode', isDarkMode); });
         if (weatherButton) weatherButton.style.backgroundColor = currentBg;
         if (zoomButton) { zoomButton.style.backgroundColor = currentBg; zoomButton.classList.toggle('zoomed', zoomButton.dataset.zoomState === 'on'); }
         if (reminderButton) reminderButton.style.backgroundColor = currentBg;

         // Ensure zoom button icon updates correctly
         if(zoomButton) { zoomButton.innerHTML = `<img src="https://boardinggate.github.io/Tesla/${zoomButton.dataset.zoomState === 'on' ? 'zoon+' : 'zoon-'}.png" alt="Zoom" style="max-width: 60%; max-height: 60%; object-fit: contain;">`;}

    }
    function formatVersionDate(date) { /* ... */ }
    async function getLastModifiedDate() { /* ... */ }
    async function updateVersion() { /* ... */ }
    function checkDarkModeTime() { /* ... */ }
    function saveSettings() { /* ... (Ensure toggleStates are saved correctly) ... */
         localStorage.setItem('darkMode', JSON.stringify(isDarkMode));
         const tS = {};
         document.querySelectorAll('.range-toggle').forEach(t => { tS[t.dataset.rangeStart] = t.dataset.state; });
         localStorage.setItem('toggleStates', JSON.stringify(tS));
         const zoomBtn = document.getElementById('zoom-button'); if (zoomBtn) localStorage.setItem('zoomState', zoomBtn.dataset.zoomState);
         const onOffBtn = document.getElementById('on-off-toggle'); if (onOffBtn) localStorage.setItem('onOffState', onOffBtn.dataset.state);
         localStorage.setItem('noticesActive', JSON.stringify(isActive));
         localStorage.setItem('footerVisible', JSON.stringify(isFooterVisible));
         console.log('UI Settings saved.');
    }
    function loadReminders() { /* ... */ }
    function updateUserIdDisplay() { /* ... */ }
    function adjustButtonPositions() { /* ... */ }
    async function loadNotices() { /* ... */ }
    function updateNotice() { /* ... */ }
    function toggleNotices() { /* ... */ }
    function toggleFooterVisibility() { /* ... */ }
    function startNoticeRotation() { /* ... */ }
    const scrollToggle = document.getElementById('scroll-toggle'); if (scrollToggle) scrollToggle.addEventListener('click', () => { window.scrollTo({ top: window.scrollY < 100 ? document.body.scrollHeight : 0, behavior: 'smooth' }); });
    function handleOnOffAction() { if (pressStartTime !== null) { const t = document.getElementById('on-off-toggle'); if(t) updateAllToggles(t.dataset.state === 'on' ? 'off' : 'on'); } pressStartTime = null; }
    function handleReminderLongPress() { if (reminderPressStartTime === null) return; const dur = Date.now() - reminderPressStartTime; if (dur >= 2000) showAllReminders(); else showReminderModal(); reminderPressStartTime = null; }
     function showToast(message, type = 'info', duration = 3000) { /* ... existing logic ... */ }
     function showConfigModal() { /* ... existing logic ... */ }

    // --- Reminder Functions (largely unchanged, ensure they don't conflict with new modes) ---
    function parseReminderText(text) { /* ... */ }
    function showHelpModal() { /* ... */ }
    function showReminderModal(reminder = null) { if(isEditMode || isAssigningToggles) return; /* ... rest of logic ... */ }
    function showReminderNotification(reminder) { /* ... */ }
    function showAllReminders() { if(isEditMode || isAssigningToggles) return; /* ... */ }
    function updateReminderCount() { /* ... */ }
    function calculateNextOccurrence(reminder, referenceDate) { /* ... */ }
    function checkReminders() { /* ... */ }
    function showPostponeOptionsModal(reminder, source = 'notification') { /* ... */ }
    function calculatePostponedDateTime(mins) { /* ... */ }
     function formatDateToDDMMMYY(dateString) { /* ... */ }


    // --- Initial Setup ---
    document.addEventListener('DOMContentLoaded', async () => {
        console.log("DOM loaded");

        loadCustomData();      // Load custom data first (bookmarks, toggle labels, assignments)
        renderGrid();          // Render grid based on loaded/original data
        createOtherButtons();  // Create side buttons, config, personal etc.
        renderToggleButtons(); // Render toggle buttons based on loaded/original labels

        try { await updateVersion(); } catch (e) { console.error("Version update fail", e); }

        // Load UI states AFTER grid and toggles exist
        loadSavedSettings();   // Applies dark mode, zoom, AND toggle visibility states

        try { await loadNotices(); startNoticeRotation(); } catch (e) { console.error("Notices fail", e); }

        checkReminders(); // Initial reminder check
        const remInterval = setInterval(checkReminders, 60000); // Periodic check

        // Show initial help/tip if not seen before (now includes personalization choice)
        // Check moved inside enterEditMode / enterToggleAssignmentMode to show only when relevant mode entered first time
        // showToast("Consejo: Arrastra pantalla izq/der para historial nav.", 'info', 10000);

        const noticeToggleIcon = document.getElementById('notice-toggle-icon');
        if (noticeToggleIcon) { noticeToggleIcon.addEventListener('click', toggleNotices); }
        else { console.error("Notice toggle icon not found!"); }

        const countEl = document.getElementById('reminder-count-globe');
        if (countEl) { const openTable = (e) => { e.preventDefault(); e.stopPropagation(); showAllReminders(); }; countEl.addEventListener('click', openTable); countEl.style.cursor = 'pointer'; }

        // Final adjustments
        adjustButtonPositions();
        window.addEventListener('resize', adjustButtonPositions);

        window.addEventListener('beforeunload', () => {
             clearInterval(remInterval);
             // Cleanup modals (existing logic)
        });

        // Initial application of hidden classes based on loaded states
        // applyStylesBasedOnState(); // Called within loadSavedSettings now

        console.log("Setup complete.");
    });

</script>
</body>
</html>
